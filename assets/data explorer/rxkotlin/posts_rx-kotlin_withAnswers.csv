Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"26968674","1","26969028","","2014-11-17 08:46:02","","36","11043","<p>I am going to start using reactive programming in my Android project. I am using Kotlin as primary language and now I would like to apply Rx. My first choice was RxAndroid but then I noticed that there is RxKotlin.</p>

<p>As far as I know both are forked from RxJava so RxAndroid probably provides some API for android common tasks. On the other hand RxKotlin support lambas out of the box and allow me avoiding mixing kotlin with java.</p>

<p>Which one is preferred library in that case?   </p>
","1456931","","1456931","","2014-11-17 08:56:37","2016-04-01 03:23:55","Use RxAndroid or RxKotlin when programming in Kotlin for Android?","<android><rx-android><rx-kotlin>","1","1","8","2014-11-18 13:08:24","","CC BY-SA 3.0"
"26969028","2","","26968674","2014-11-17 09:06:09","","45","","<p>You could use both of them. 
<strong><a href=""https://github.com/ReactiveX/RxKotlin"">RxKotlin</a></strong> contains an <a href=""http://kotlinlang.org/docs/reference/extensions.html"">extension functions</a> that provides to you idiomatic way(with writing less code) of using <a href=""https://github.com/ReactiveX/RxJava""><strong>rxJava</strong></a> in Kotlin.
<strong>rxAndroid</strong>(is now split in few libraries) provides specific platform bindings such as: </p>

<ul>
<li><em><a href=""https://github.com/ReactiveX/RxAndroid"">rxAndroid</a></em> that could help you to manage an execution with native android <a href=""http://developer.android.com/intl/ru/reference/android/os/Handler.html"">Handlers</a> </li>
<li><em><a href=""https://github.com/trello/RxLifecycle"">rxLifecycle</a></em> that provides Activity lifecycle bindings </li>
<li><em><a href=""https://github.com/JakeWharton/RxBinding"">rxBinding and rxBinding-kotlin</a></em> that helps to manage UI with all power of rxJava</li>
</ul>

<p>There are few more useful <a href=""https://github.com/zsoltk/RxAndroidLibs"">libraries for rxJava and Android</a> you could be interested.</p>

<p><strong>Edited 01.04.16</strong></p>
","631814","","631814","","2016-04-01 03:23:55","2016-04-01 03:23:55","","","","2","","","","CC BY-SA 3.0"
"29882922","1","29939049","","2015-04-26 20:08:43","","1","580","<p>The error in the title appears in Android Studio as a warning bar above all my code: <img src=""https://i.stack.imgur.com/JVvo5.png"" alt=""Error""></p>

<p>Android Studio version: <code>1.1.0</code><br>
Kotlin plugin version for Android Studio: <code>0.11.91.AndroidStudio.4</code><br>
<code>build.gradle</code> file that seems to be using all the most recent versions of the Kotlin libraries:</p>

<pre><code>apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'

android {
    compileSdkVersion 22
    buildToolsVersion ""22.0.1""

    defaultConfig {
        applicationId ""ca.amandeep.simpletransit""
        minSdkVersion 16
        targetSdkVersion 22
        versionCode 1
        versionName ""1.0""
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    sourceSets {
        main.java.srcDirs += 'src/main/kotlin'
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:22.0.0'
    compile ""org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version""
    compile 'com.squareup.retrofit:retrofit:1.9.0'
    compile('com.squareup.retrofit:converter-simplexml:1.9.0') {
        exclude module: 'stax'
        exclude module: 'stax-api'
        exclude module: 'xpp3'
    }
    compile 'com.squareup.okhttp:okhttp:2.3.0'
    compile 'com.squareup.okhttp:okhttp-urlconnection:2.3.0'
    compile 'com.google.guava:guava:18.0'
    compile 'com.facebook.stetho:stetho:1.0.1'
    compile 'com.facebook.stetho:stetho-okhttp:1.0.1'
    compile 'com.jakewharton.timber:timber:2.7.1'
    compile 'io.reactivex:rxkotlin:0.21.0'
    compile 'io.reactivex:rxandroid:0.24.0'
    compile 'com.github.techfreak:wizardpager:1.0.0'
}
buildscript {
    ext.kotlin_version = '0.11.91.1'
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath ""org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version""
        classpath ""org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version""
        classpath 'com.jakewharton.hugo:hugo-plugin:1.2.1'
    }
}
repositories {
    mavenCentral()
}

apply plugin: 'com.jakewharton.hugo'
</code></pre>
","137081","","","","","2016-01-04 18:39:25","Kotlin library 'rxkotlin-0.21.0.jar' has an unsupported format. Please update the library or the plugin","<android><android-studio><kotlin><rx-android><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"29939049","2","","29882922","2015-04-29 09:05:01","","1","","<p>I think they wrongly packaged this version. There is an issue about that on github :</p>

<p><a href=""https://github.com/ReactiveX/RxKotlin/issues/18"" rel=""nofollow"">https://github.com/ReactiveX/RxKotlin/issues/18</a></p>

<p>Maybe you should ping it.</p>
","231417","","","","","2015-04-29 09:05:01","","","","0","","","","CC BY-SA 3.0"
"34583595","1","34587372","","2016-01-04 01:25:32","","5","872","<p>I was having some issues using RxJava and Kotlin earlier. I made some interesting discoveries which I'm still puzzled about. </p>

<p>There is the simple <code>Func1</code> interface in RxJava</p>

<pre><code>public interface Func1&lt;T, R&gt; extends Function {
    R call(T t);
}
</code></pre>

<p>I was trying to add an extension method to an <code>Observable</code>, also an RxJava class. This would collect the emissions into a Google Guava <code>ImmutableListMulitmap</code> using a <code>Func1</code> to map the key off each item. </p>

<pre><code>fun &lt;K,T&gt; Observable&lt;T&gt;.toImmutableListMultimap(keyMapper: Func1&lt;T, K&gt;): Observable&lt;ImmutableListMultimap&lt;K,T&gt;&gt; {
    return this.collect({ ImmutableListMultimap.builder&lt;K,T&gt;()},{ b, t -&gt; b.put(keyMapper.call(t), t)}).map { it.build() }
}
</code></pre>

<p>When I tried to invoke this extension method I could not get it to compile, and it was not understanding the lambda expression at all. </p>

<pre><code>ScheduledItem.all.flatMap { it.rebuildSoftTransactions }
.toImmutableListMultimap { it.id /*compile error */ } .cache()
</code></pre>

<p>However, the strangest thing happened when I modified the extension method to use the <a href=""https://kotlinlang.org/docs/reference/lambdas.html#function-types"">function type</a>.</p>

<pre><code>fun &lt;K,T&gt; Observable&lt;T&gt;.toImmutableListMultimap(keyMapper: (T) -&gt; K): Observable&lt;ImmutableListMultimap&lt;K,T&gt;&gt; {
    return this.collect({ ImmutableListMultimap.builder&lt;K,T&gt;()},{ b, t -&gt; b.put(keyMapper(t), t)}).map { it.build() }
}
</code></pre>

<p>And then everything compiled fine. But this is what puzzled me: How come it did not infer the lambda onto the interface? When I use the standard <code>map()</code> method on the <code>Observable</code> it infers the lambda just fine using the curly bracket <code>{ }</code> syntax. But why does it not work for my extension method above?</p>
","1373258","","","","","2016-01-04 08:44:23","Behavior with Kotlin Higher-Order Functions and Single-method interfaces?","<lambda><rx-java><kotlin><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"34587372","2","","34583595","2016-01-04 08:44:23","","7","","<p>The SAM conversion (converting a lambda into a function type) currently works only for methods written in Java. Kotlin has proper function types, so there is no need for SAM conversion - you can declare the parameter as a function type directly (which works, as you have observed).</p>

<p><code>Observable.map()</code> is written in Java, so the SAM conversion is applied. Your extension function is written in Kotlin, so it's not.</p>
","147024","","","","","2016-01-04 08:44:23","","","","0","","","","CC BY-SA 3.0"
"34966999","1","34971416","","2016-01-23 18:14:59","","13","4712","<p>I'm confused by Kotlin lambda syntax. </p>

<p>At first, I have</p>

<pre><code>.subscribe(
          { println(it) }
          , { println(it.message) }
          , { println(""completed"") }
      )
</code></pre>

<p><strong>which works fine</strong>.</p>

<p>Then I moved the onNext to another class called GroupRecyclerViewAdapter which implements <code>Action1&lt;ArrayList&lt;Group&gt;&gt;</code>. </p>

<pre><code>.subscribe(
          view.adapter as GroupRecyclerViewAdapter
          , { println(it.message) }
          , { println(""completed"") }
      )
</code></pre>

<p>However, I got the error:</p>

<p><a href=""https://i.stack.imgur.com/0GAwv.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/0GAwv.png"" alt=""error""></a></p>

<pre><code>Error:(42, 17) Type mismatch: inferred type is () -&gt; ??? but rx.functions.Action1&lt;kotlin.Throwable!&gt;! was expected
Error:(42, 27) Unresolved reference: it
Error:(43, 17) Type mismatch: inferred type is () -&gt; kotlin.Unit but rx.functions.Action0! was expected
</code></pre>

<p>I can fix the error by changing to:</p>

<pre><code>.subscribe(
          view.adapter as GroupRecyclerViewAdapter
          , Action1&lt;kotlin.Throwable&gt; { println(it.message) }
          , Action0 { println(""completed"") }
      )
</code></pre>

<p><strong>Is there a way to write the lambda without specifying a type?</strong> (<code>Action1&lt;kotlin.Throwable&gt;</code>, <code>Action0</code>) </p>

<p><a href=""https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/Observable.java"" rel=""noreferrer"">Note: subscribe is RxJava method</a></p>

<p><strong>Edit 1</strong></p>

<pre><code>class GroupRecyclerViewAdapter(private val groups: MutableList&lt;Group&gt;,
                           private val listener: OnListFragmentInteractionListener?) :
RecyclerView.Adapter&lt;GroupRecyclerViewAdapter.ViewHolder&gt;(), Action1&lt;ArrayList&lt;Group&gt;&gt; {
</code></pre>
","1104902","","1104902","","2016-01-24 22:34:48","2016-01-25 14:19:58","Kotlin lambda syntax confusion","<kotlin><rx-kotlin>","2","3","2","","","CC BY-SA 3.0"
"34971416","2","","34966999","2016-01-24 02:06:04","","11","","<p><code>view.adapter as GroupRecyclerViewAdapter</code> part should be lambda func, not Action, since onError and onComplete also lambdas</p>

<p>so, to fix this try:</p>

<pre><code>.subscribe(
          { (view.adapter as GroupRecyclerViewAdapter).call(it) }
          , { println(it.message) }
          , { println(""completed"") }
      )
</code></pre>

<p>with your names (replace <code>Unit</code> with your type)</p>

<pre><code>class GroupRecyclerViewAdapter : Action1&lt;Unit&gt; {
    override fun call(t: Unit?) {
        print (""onNext"")
    }
}
</code></pre>

<p>with lambdas</p>

<pre><code>val ga = GroupRecyclerViewAdapter()
...subscribe(
    { result -&gt; ga.call(result) },
    { error -&gt; print (""error $error"") },
    { print (""completed"") })
</code></pre>

<p>with actions</p>

<pre><code>...subscribe(
    ga,
    Action1{ error -&gt; print (""error $error"") },
    Action0{ print (""completed"") })
</code></pre>

<p>pick one</p>
","4594990","","3679676","","2016-01-25 10:32:34","2016-01-25 10:32:34","","","","22","","","","CC BY-SA 3.0"
"35524980","1","35527773","","2016-02-20 15:04:15","","3","993","<p>This is working code but I have a few questions as well as a request for advice on improving it. I am new to RxJava and I have not fully wrapped my head around how to chain these type of observables together. </p>

<p>I have two model objects, <code>ListItem</code> and <code>UserInfo</code>. <code>ListItem</code>s exists in a local database and the <code>UserInfo</code> is fetched from the server by using an ID provided from the <code>ListItem</code>. </p>

<p>The <code>UserInfo</code> web service accepts an array of IDs for which it will return a list of <code>UserInfo</code> objects. </p>

<p>The flow of this code is as follows:</p>

<ol>
<li>Load <code>ListItem</code>s from database</li>
<li>Using the <code>ListItem</code>s fetched from the database, check an in memory cache to see if I've already fetched the <code>UserInfo</code> for a particular <code>ListItem</code></li>
<li>For any items whose <code>UserInfo</code> is not cached, fetch them from the network</li>
<li>Place the fetched <code>UserInfo</code> objects into the cache</li>
<li>Re-run step 2 ( the method is <code>loadCachedUserInfo</code>)</li>
<li>Return results to subscriber</li>
</ol>

<p>NOTE: The <code>UserInfo</code> objects should only be fetched for a <code>ListItem</code> if the list has been deemed a <code>isUserList</code>.</p>

<p>Here is the code:</p>

<pre><code>fun itemsInList(list : ATList, parentValue : String? = null, searchString : String? = null, limit : Int = defaultFetchLimit, sortOrder: SortDescriptor? = null) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    return Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
        val listItems = listItemsInList(list, parentValue = parentValue, searchString = searchString, limit = limit, sortOrder = sortOrder)
        subscriber.onNext(listItems)
        subscriber.onCompleted()
    }.flatMap { listItems -&gt;
        if ( list.isUserList ) {
            return@flatMap loadCachedUserInfo(listItems, userIDIndex = list.userIDIndex!!)
        }
        return@flatMap Observable.just(listItems)
    }.flatMap { listItems -&gt;
        if ( list.isUserList ) {
            return@flatMap fetchUserInfoForListItems(listItems, list.userIDIndex!!, force = false)
        }
        return@flatMap Observable.just(listItems)
    }
}

fun loadCachedUserInfo(listItems : List&lt;ATListItem&gt;, userIDIndex : Int) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    return Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
        for ( listItem in listItems ) {
            listItem.coreUserInfo = coreUserMap[listItem.valueForAttributeIndex(userIDIndex)?.toLowerCase()]
        }
        subscriber.onNext(listItems)
        subscriber.onCompleted()
    }
}

fun fetchUserInfoForListItems(listItems : List&lt;ATListItem&gt;, userIDIndex: Int, force: Boolean) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    val itemsToFetch = if ( force ) listItems else listItems.filter { it.coreUserInfo == null }
    val ids = itemsToFetch.map { it.valueForAttributeIndex(userIDIndex) ?: """" }.filter { !it.isEmpty() }
    val records = hashMapOf(""records"" to ids)
    if ( itemsToFetch.count() == 0 ) {
        return Observable.just(listItems)
    }
    return RuntimeDataController.dataService.fetchCoreUserInfo(recordsMap = records)
            .map { json -&gt;
                val recordsArray = json.arrayValue(""records"")
                for ( i in 0..recordsArray.length() - 1) {
                    val coreUserInfo = CoreUserInfo(recordsArray.getJSONObject(i))
                    coreUserMap[coreUserInfo.username.toLowerCase()] = coreUserInfo
                    coreUserMap[coreUserInfo.userID] = coreUserInfo
                    coreUserInfo.externalUserID?.let { coreUserMap[it] = coreUserInfo }
                }
                return@map listItems
            }.flatMap { loadCachedUserInfo(listItems, userIDIndex = userIDIndex) }
}
</code></pre>

<p>The user would initiate the sequence of events by calling:</p>

<p><code>ListController.itemsInList(list)</code></p>

<p>My questions about this code are:</p>

<ol>
<li>Currently <code>loadCachedUserInfo</code> takes in an array of <code>ListItem</code> and returns that same array as an observable after the cached items have been associated with it. This feels wrong to me. I think instead this call should only return the items that have a cached <code>UserInfo</code> associated with it. However, I need to continue passing the full array of <code>ListItem</code> to the next method</li>
</ol>

<p>2.) Do I need to do additional work to support unsubscribing?</p>

<p>3.) This is similar question 1. My <code>fetchUserInfoForListItems</code> takes an array of list items and returns an observable with that same array of list items after they have been fetched and re-run through the cache method. This also feels incorrect to me. I would rather this method return an <code>Observable&lt;List&lt;UserInfo&gt;&gt;</code> for the objects that were fetched. I am not understanding how in <code>itemsInList</code> to then associate the <code>ListItem</code>s with the newly fetched <code>UserInfo</code> and return an Observable of those <code>ListItem</code>s.</p>

<p><strong>Edit</strong>: After writing this post it gave helped me realize a few things. I can flatMap wrap my calls in an Observable.create that can contain the smarts I wanted to take out of my <code>fetchUserInfoForListItems</code>, letting me address question #3. Here is the updated code:</p>

<pre><code> fun itemsInList(list : ATList, parentValue : String? = null, searchString : String? = null, limit : Int = defaultFetchLimit, sortOrder: SortDescriptor? = null) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    return Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
        val listItems = listItemsInList(list, parentValue = parentValue, searchString = searchString, limit = limit, sortOrder = sortOrder)
        subscriber.onNext(listItems)
        subscriber.onCompleted()
    }.flatMap { listItems -&gt;
        if ( list.isUserList ) {
            return@flatMap loadCachedUserInfo(listItems, userIDIndex = list.userIDIndex!!)
        }
        return@flatMap Observable.just(listItems)
    }.flatMap { listItems -&gt;
        if ( list.isUserList ) {
            return@flatMap Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
                fetchUserInfoForListItems(listItems, list.userIDIndex!!, force = false).map { userInfoList -&gt;
                    for (coreUserInfo in userInfoList) {
                        coreUserMap[coreUserInfo.username.toLowerCase()] = coreUserInfo
                        coreUserMap[coreUserInfo.userID] = coreUserInfo
                        coreUserInfo.externalUserID?.let { coreUserMap[it] = coreUserInfo }
                    }
                }.flatMap {
                    loadCachedUserInfo(listItems, userIDIndex = list.userIDIndex!!)
                }.subscribe {
                    subscriber.onNext(listItems)
                    subscriber.onCompleted()
                }
            }
        }
        return@flatMap Observable.just(listItems)
    }
}

fun loadCachedUserInfo(listItems : List&lt;ATListItem&gt;, userIDIndex : Int) : Observable&lt;List&lt;ATListItem&gt;&gt; {
    return Observable.create&lt;List&lt;ATListItem&gt;&gt; { subscriber -&gt;
        listItems.forEach { listItem -&gt; listItem.coreUserInfo = coreUserMap[listItem.valueForAttributeIndex(userIDIndex)?.toLowerCase()] }
        subscriber.onNext(listItems)
        subscriber.onCompleted()
    }
}

fun fetchUserInfoForListItems(listItems : List&lt;ATListItem&gt;, userIDIndex: Int, force: Boolean) : Observable&lt;List&lt;CoreUserInfo&gt;&gt; {
    val itemsToFetch = if ( force ) listItems else listItems.filter { it.coreUserInfo == null }
    val ids = itemsToFetch.map { it.valueForAttributeIndex(userIDIndex) ?: """" }.filter { !it.isEmpty() }
    val records = hashMapOf(""records"" to ids)
    if ( itemsToFetch.count() == 0 ) { return Observable.just(ArrayList&lt;CoreUserInfo&gt;()) }
    return RuntimeDataController.dataService.fetchCoreUserInfo(recordsMap = records)
            .map { json -&gt;
                val userInfo = ArrayList&lt;CoreUserInfo&gt;()
                json.arrayValue(""records"").eachObject { userInfo.add(CoreUserInfo(it)) }
                return@map userInfo
            }
}
</code></pre>
","4586842","","4586842","","2016-02-20 17:25:44","2016-02-20 19:16:44","Using RxJava to join local data with remote ( or cached ) data","<android><rx-java><kotlin><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"35527773","2","","35524980","2016-02-20 19:10:24","","3","","<blockquote>
  <ol>
  <li>Currently loadCachedUserInfo takes in an array of ListItem and returns that same array as an observable after the cached items have been associated with it. This feels wrong to me. I think instead this call should only return the items that have a cached UserInfo associated with it. However, I need to continue passing the full array of ListItem to the next method</li>
  </ol>
</blockquote>

<p>I am not sure I understand you correctly but if you only need side-effect (caching), you can just use <code>doOnNext</code>. For example,</p>

<pre><code>.doOnNext { listItems -&gt;
    if ( list.isUserList ) {
        cache(listItems, userIDIndex = list.userIDIndex!!)
    }
}

fun cache(listItems : List&lt;ATListItem&gt;, userIDIndex : Int) {
    // caching
}
</code></pre>

<blockquote>
  <ol start=""2"">
  <li>Do I need to do additional work to support unsubscribing?</li>
  </ol>
</blockquote>

<p>No, AFAIK.</p>

<p><strong>Note:</strong></p>

<p><strong>More info about <code>doOnNext</code> can be found at <a href=""https://stackoverflow.com/questions/28402689/what-is-the-purpose-of-doonnext-in-rxjava"">What is the purpose of doOnNext(...) in RxJava</a> and <a href=""http://www.grokkingandroid.com/rxjavas-side-effect-methods/"" rel=""nofollow noreferrer"">here</a></strong></p>

<p>Normally you don't need <code>return@...</code> if the last statement in lambda is an expression. 
e.g.:</p>

<pre><code>.flatMap { listItems -&gt;
    if ( list.isUserList ) {
        return@flatMap loadCachedUserInfo(listItems, userIDIndex = list.userIDIndex!!)
    }
    return@flatMap Observable.just(listItems)
}    
</code></pre>

<p>can be written like:</p>

<pre><code>.flatMap { listItems -&gt;
    if ( list.isUserList )
        loadCachedUserInfo(listItems, userIDIndex = list.userIDIndex!!)
    else
        Observable.just(listItems)
} 
</code></pre>

<p><strong>I didn't test the code.</strong></p>
","1104902","","-1","","2017-05-23 12:07:55","2016-02-20 19:16:44","","","","1","","","","CC BY-SA 3.0"
"35612056","1","","","2016-02-24 20:10:27","","1","537","<p>I'm currently using the Android-ReactiveLocation Library (<a href=""https://github.com/mcharmas/Android-ReactiveLocation"" rel=""nofollow"">Github</a>). The <code>LastKnownLocationObservable</code> (<a href=""https://github.com/mcharmas/Android-ReactiveLocation/blob/master/android-reactive-location/src/main/java/pl/charmas/android/reactivelocation/observables/location/LastKnownLocationObservable.java"" rel=""nofollow"">Code</a>) is working as intended. I'm using a <code>flatMap</code> to fetch nearby stations from a db and (because of realm) I'm creating a model from the data. So I have a list of items and I'm creating the new Observable in <code>flatMap</code> with <code>Observable.from(data)</code>.</p>

<p>Then I want to sort the locations, filter them and group them.</p>

<pre><code>.toSortedList()
.flatMap { Observable.from(it) }
.filter { it.distance &lt;= (maxDistance.toDouble() * 1000) }
.groupBy { //Group the stations in categories
    if (it.distance &lt;= maxDistance &amp;&amp; it.favorite) {
        ""nearbyFavorite""
    } else if (it.favorite) {
        ""outOfReachFavorite""
    } else {
        ""nearby""
    }
}
</code></pre>

<p>However the onComplete is never called when I subscribe to the Observable. The Observable just stalls at <code>toSortedList()</code>.</p>

<p>The Subscribe:</p>

<pre><code>.subscribe(object: Subscriber&lt;GroupedObservable&lt;String, NearbyLocationItem&gt;&gt;() {
    override fun onNext(p0: GroupedObservable&lt;String, NearbyLocationItem&gt;?) {
        val locationItems = ArrayList&lt;NearbyLocationItem&gt;()
        p0.subscribe { loc -&gt;
            locationItems.add(loc)
        }
        locations.put(p0.key, locationItems)
    }


    override fun onCompleted() {
        Log.d(javaClass.simpleName, ""Never called"")
    }

    override fun onError(p0: Throwable?) {

    }
}
</code></pre>
","1501857","","","","","2016-02-24 20:10:27","OnComplete never called with toSortedList() and groupBy()","<android><rx-java><kotlin><rx-android><rx-kotlin>","0","9","","","","CC BY-SA 3.0"
"35818449","1","35820705","","2016-03-05 19:00:58","","4","3697","<p>I created a function which returns an <code>Observable&lt;String&gt;</code> with file names, but I don't get any event in my subscription where I call this method. Also there is no call of onError, or onComplete <br>
See my code:</p>

<pre><code>fun getAllFiles(): Observable&lt;String&gt; {

    val allFiles = File(""/Users/stephan/Projects/Playground/kotlinfiles/"")
            .listFiles { file -&gt; !file.isDirectory() }
    return observable { subscriber -&gt;
        allFiles.toObservable()
                .map { f -&gt; ""${f.name}"" }
                .doOnNext { println(""Found file $it"") }
                .subscribe { subscriber}
    }
}

fun test() {
    getAllFiles()
            .doOnNext { println(""File name$it"") }
            .subscribe(
                    {n -&gt; println(""File: $n"")},
                    {e -&gt; println(""Damn: $e"")},
                    {println(""Completed"")})
}
</code></pre>

<p>Though everything is being called in the <code>getAllFiles()</code> function, so what am I missing?</p>
","1031556","","","","","2016-03-06 00:07:43","rx kotlin subscription not working, not receiving items","<kotlin><rx-kotlin>","1","0","1","","","CC BY-SA 3.0"
"35820705","2","","35818449","2016-03-05 22:27:32","","9","","<p><code>observable</code> is for creating an Observable from scratch but you already have <code>Observable&lt;String&gt;</code> from <code>toObservable()</code> so you don't need it. The code below works for me:</p>

<pre><code>fun getAllFiles(): Observable&lt;String&gt; {
  val allFiles = File(""/Users/stephan/Projects/Playground/kotlinfiles/"")
    .listFiles { file -&gt; !file.isDirectory }
  return allFiles.toObservable()
    .map { f -&gt; ""${f.name}"" }
}

fun test() {
  getAllFiles()
    .doOnNext { println(""File name $it"") }
    .subscribe(
        { n -&gt; println(""File: $n"") },
        { e -&gt; println(""Damn: $e"") },
        { println(""Completed"") })
}
</code></pre>

<p>You can also fix this by changing from:</p>

<pre><code>.subscribe{subscriber}
</code></pre>

<p>to</p>

<pre><code>.subscribe(subscriber)
</code></pre>

<p>but this nested Observable version is confusing to me.</p>
","1104902","","1104902","","2016-03-06 00:07:43","2016-03-06 00:07:43","","","","2","","","","CC BY-SA 3.0"
"35995630","1","35998109","","2016-03-14 18:48:09","","2","609","<p>I've been playing with Kotlin/RxJava and tried to create an extension method for adding a <code>Subscription</code> to a <code>CompositeSubscription</code>, that would work like:</p>

<pre><code>search.subscribe {
       //do stuff
}.addToComposite(compositeSubscription)
</code></pre>

<p>This is my attempt so far:</p>

<pre><code>fun Subscription.addToComposite(composite: CompositeSubscription) = { composite.add(this) }
</code></pre>

<p>It compiles and runs without errors but doesn't seem to actually add the <code>Subscription</code> to the <code>CompositeSubscription</code>. Am I doing something wrong?</p>
","1607552","","1363438","","2018-01-01 17:34:28","2018-01-01 17:34:28","Can I create a Kotlin extension method for adding an rxJava Subscription to a CompositeSubscription?","<rx-java><kotlin><kotlin-extension><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"35998109","2","","35995630","2016-03-14 21:08:24","","6","","<p>Your function is defined incorrectly. Compare:</p>

<pre><code>fun f() { println(""hello"") }
</code></pre>

<p>This function executes the single statement <code>println(""hello"")</code> and is a simple <a href=""https://kotlinlang.org/docs/reference/functions.html#unit-returning-functions"" rel=""nofollow noreferrer""><code>Unit</code>-returning function</a> (same to <code>void</code> in Java). </p>

<pre><code>fun g() = { println(""hello"") }
</code></pre>

<p>This function is a <a href=""https://kotlinlang.org/docs/reference/functions.html#single-expression-functions"" rel=""nofollow noreferrer"">single-expression function</a>, it just returns value of expression <br><code>{ println(""hello"") }</code>, that is a <a href=""https://kotlinlang.org/docs/reference/lambdas.html#lambda-expressions-and-anonymous-functions"" rel=""nofollow noreferrer"">lambda expression</a>. <code>g</code>'s return type is <code>() -&gt; Unit</code>, <em>and it doesn't execute the lambda body!</em></p>

<p>This is also <a href=""https://stackoverflow.com/questions/36037442/kotlin-function-declaration-equals-sign-before-curly-braces/"">explained here</a>.
<hr>
To fix your code, you can just remove <code>=</code> from your function declaration:</p>

<pre><code>fun Subscription.addToComposite(composite: CompositeSubscription) { composite.add(this) }
</code></pre>
","2196460","","-1","","2017-05-23 11:46:08","2016-03-16 13:45:11","","","","0","","","","CC BY-SA 3.0"
"36809467","1","","","2016-04-23 10:16:23","","6","1931","<p>I'm using rxAndroid and rxKotlin in my Android app to handle network requests asynchronously. Now I would like to retry a failed network request only after click on Snackbar button.</p>

<p>My code now:</p>

<pre><code>val citiesService = ApiFactory.citiesService

citiesService.cities()
    .subscribeOn(Schedulers.newThread()) // fetch List&lt;String&gt;
    .flatMap { Observable.from(it) }     // convert to sequence of String
    .flatMap { city -&gt;
        citiesService.coordinates(city)  // fetch DoubleArray
            .map { City(city, it) }      // convert to City(String, DoubleArray)
        }
    .toList()
    .observeOn(AndroidSchedulers.mainThread())
    .doOnNext {
        listView.setOnItemClickListener { adapterView, view, position, id -&gt;
            onItemClick(it[position])
        }
    }
    .map { it.map { it.getName(activity) } }
    .subscribe(
        { listAdapter = setupAdapter(it) },
        { showErrorSnackbar() }  // handle error
    )

fun showErrorSnackbar() {
        Snackbar.make(listView, getString(R.string.not_available_msg), Snackbar.LENGTH_INDEFINITE)
                .setAction(getString(R.string.snack_retry_btn), {
                    // retry observable
                })
                .show()
    }
</code></pre>

<p>Cities interface for retrofit:</p>

<pre><code>interface CitiesService {

    @GET(""api/v1/cities"")
    fun cities(): Observable&lt;List&lt;String&gt;&gt;

    @GET(""api/v1/cities/{city}/coordinates"")
    fun coordinates(@Path(""city"") city: String): Observable&lt;DoubleArray&gt;
}
</code></pre>

<p>Api factory:</p>

<pre><code>object ApiFactory {

    val citiesService: CitiesService
        get() = retrofit.create(CitiesService::class.java)

    private val retrofit: Retrofit
        get() = Retrofit
            .Builder()
            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
            .addConverterFactory(GsonConverterFactory.create())
            .baseUrl(BASE_URL)
            .build()
}
</code></pre>

<p>How can I restart the observable in such way?</p>
","4589262","","4589262","","2016-04-23 10:59:33","2017-03-28 21:47:05","RxAndroid - retry observable on click","<android><rx-java><retrofit2><rx-android><rx-kotlin>","1","3","2","","","CC BY-SA 3.0"
"37421742","1","37423378","","2016-05-24 18:57:18","","4","2860","<p>I know this breaks a lot of Rx rules, but I really like <a href=""https://github.com/davidmoten/rxjava-jdbc"" rel=""nofollow"">RxJava-JDBC</a> and so do my teammates. Relational databases are very core to what we do and so is Rx.</p>

<p>However there are some occasions where we do not want to emit as an <code>Observable&lt;ResultSet&gt;</code> but would rather just have a pull-based Java 8 <code>Stream&lt;ResultSet&gt;</code> or Kotlin <code>Sequence&lt;ResultSet&gt;</code>. But we are very accustomed to the RxJava-JDBC library which only returns an <code>Observable&lt;ResultSet&gt;</code>. </p>

<p>Therefore, I am wondering if there is a way I can turn an <code>Observable&lt;ResultSet&gt;</code> into a <code>Sequence&lt;ResultSet&gt;</code> using an extension function, and not do any intermediary collection or <code>toBlocking()</code> calls. Below is all I have so far but my head is spinning now trying to connect push and pull based systems, and I cannot buffer either as the <code>ResultSet</code> is stateful with each <code>onNext()</code> call. Is this an impossible task?</p>

<pre><code>import rx.Observable
import rx.Subscriber
import java.sql.ResultSet

fun Observable&lt;ResultSet&gt;.asSequence() = object: Iterator&lt;ResultSet&gt;, Subscriber&lt;ResultSet&gt;() {

    private var isComplete = false

    override fun onCompleted() {
        isComplete = true
    }

    override fun onError(e: Throwable?) {
        throw UnsupportedOperationException()
    }

    override fun onNext(rs: ResultSet?) {
        throw UnsupportedOperationException()
    }


    override fun hasNext(): Boolean {
        throw UnsupportedOperationException()
    }

    override fun next(): ResultSet {
        throw UnsupportedOperationException()
    }

}.asSequence()
</code></pre>
","1373258","","1373258","","2016-05-24 19:25:19","2016-05-25 05:10:26","RxJava- Turn Observable into Iterator, Stream, or Sequence","<stream><sequence><rx-java><kotlin><rx-kotlin>","2","3","2","","","CC BY-SA 3.0"
"37423378","2","","37421742","2016-05-24 20:35:18","","4","","<p>I'm not sure that's the easiest way to achieve what you want but you can try this code. It converts an <code>Observable</code> to an <code>Iterator</code> by creating a blocking queue and publishing all events from the <code>Observable</code> to this queue. The <code>Iterable</code> pulls events from the queue and blocks if there're none. Then it modify its own state depending on received current event.</p>

<pre><code>class ObservableIterator&lt;T&gt;(
    observable: Observable&lt;T&gt;,
    scheduler: Scheduler
) : Iterator&lt;T&gt;, Closeable {

  private val queue = LinkedBlockingQueue&lt;Notification&lt;T&gt;&gt;()
  private var cached: Notification&lt;T&gt;? = null
  private var completed: Boolean = false

  private val subscription =
      observable
          .materialize()
          .subscribeOn(scheduler)
          .subscribe({ queue.put(it) })

  override fun hasNext(): Boolean {
    cacheNext()
    return !completed
  }

  override fun next(): T {
    cacheNext()
    val notification = cached ?: throw NoSuchElementException()
    check(notification.isOnNext)
    cached = null
    return notification.value
  }

  private fun cacheNext() {
    if (completed) {
      return
    }

    if (cached == null) {
      queue.take().let { notification -&gt;
        if (notification.isOnError) {
          completed = true
          throw RuntimeException(notification.throwable)
        } else if (notification.isOnCompleted) {
          completed = true
        } else {
          cached = notification
        }
      }
    }
  }

  override fun close() {
    subscription.unsubscribe()
    completed = true
    cached = null
  }
}
</code></pre>
","170842","","170842","","2016-05-25 05:10:26","2016-05-25 05:10:26","","","","12","","","","CC BY-SA 3.0"
"38666086","1","38670838","","2016-07-29 19:19:01","","3","895","<p>I'm trying to port an RxJava library and leverage extension functions in Kotlin.</p>

<pre><code>fun &lt;T,R: MutableCollection&lt;T&gt;&gt; Observable&lt;T&gt;.collectWhile(factory: (() -&gt; R), condition: (R,T) -&gt; Boolean) =
        compose(Transformers.collectWhile(factory,condition))
</code></pre>

<p>The <code>Transformers.collectWhile()</code> is written in Java and has this signature: </p>

<pre><code>public static &lt;T, R extends Collection&lt;T&gt;&gt; Transformer&lt;T, R&gt; collectWhile(final Func0&lt;R&gt; factory,
            final Action2&lt;? super R, ? super T&gt; collect)
</code></pre>

<p>However, I am getting an issue with mapping the <code>collect</code> argument and I'm not good at generics. How do I express <code>super</code> with a functional type?</p>

<p><strong>UPDATE</strong></p>

<p>Stupid mistake on my part. I should not have been posting on SO late at night. </p>

<p>I was actually targeting this</p>

<pre><code>public static &lt;T, R extends Iterable&lt;?&gt;&gt; Transformer&lt;T, R&gt; collectWhile(final Func0&lt;R&gt; factory,
        final Action2&lt;? super R, ? super T&gt; collect, final Func2&lt;? super R, ? super T, Boolean&gt; condition)
</code></pre>

<p>And this is what I should have done. </p>

<pre><code>fun &lt;T,R: MutableCollection&lt;T&gt;&gt; Observable&lt;T&gt;.collectWhile(factory: (() -&gt; R), action: (R,T) -&gt; Unit, condition: (R,T) -&gt; Boolean) =
    compose(Transformers.collectWhile(factory,action,condition))
</code></pre>
","1373258","","1373258","","2016-07-30 18:02:52","2016-07-30 18:02:52","Expressing ""super"" generics in Kotlin functional types?","<java><generics><rx-java><kotlin><rx-kotlin>","1","1","1","","","CC BY-SA 3.0"
"38670838","2","","38666086","2016-07-30 05:58:19","","7","","<p>Java wildcard type <code>? super T</code> corresponds to <code>in T</code> <a href=""https://kotlinlang.org/docs/reference/generics.html#use-site-variance-type-projections"" rel=""noreferrer"">use-site type projection</a> in Kotlin, so the corresponding type of <code>collect</code> parameter would be <code>Action2&lt;in R, in T&gt;</code>.</p>

<p>That type is roughly equivalent (or more specifically is eligible for <a href=""https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions"" rel=""noreferrer"">SAM-conversion</a>) to <code>(R, T) -&gt; Unit</code> functional type in Kotlin, because <code>(R, T) -&gt; Unit</code> is a synonym for type <code>Function2&lt;R, T, Unit&gt;</code> and the latter is equivalent to <code>Function2&lt;in R, in T, out Unit&gt;</code> due to the <a href=""https://kotlinlang.org/docs/reference/generics.html#declaration-site-variance"" rel=""noreferrer"">declaration-site variance</a> of the Function2 type parameters.</p>

<p>You cannot pass a function of type <code>(R, T) -&gt; Boolean</code> as an argument to <code>collect</code>, where <code>(R, T) -&gt; Unit</code> is expected.</p>

<p>Either change the type of <code>collect</code> parameter, or the type of <code>condition</code> parameter`.</p>
","869184","","869184","","2016-07-30 06:10:53","2016-07-30 06:10:53","","","","1","","","","CC BY-SA 3.0"
"39057409","1","39069635","","2016-08-20 18:25:27","","0","539","<p>Here's a fun RxJava problem. </p>

<p>I want to use RxJava backpressure operators to quickly lookup a typed input while each character is being typed, much like Google does on its search page. I went through the <a href=""https://github.com/ReactiveX/RxJava/wiki/Backpressure"" rel=""nofollow"">Backpressure</a> documentation and I came up with this (I am using RxJavaFX/RxKotlinFX to leverage JavaFX). </p>

<pre><code>val myControl: Node = ...
val burstyMulticast = myControl.events(KeyEvent.KEY_TYPED).publish().refCount()
val burstyDebounced = burstyMulticast.debounce(200, TimeUnit.MILLISECONDS)
val burstyBuffered = burstyMulticast.buffer(burstyDebounced)

burstyBuffered
        .flatMap { it.toObservable().map { it.character }.reduce("""") { x,y -&gt; x + y } }
        .subscribe { println(it) }
</code></pre>

<p>This works great. If I type ""Hello"" against the control it will emit the <code>String</code> ""Hello"" after 200 ms of no typing. But if I want this to truly be more responsive, I should actually have some sort of rolling accumulation for each keystroke input.  Then my console output should really look like this:</p>

<pre><code>H
He
Hel
Hell
Hello
</code></pre>

<p>Those should be all my emissions when I type the word ""Hello"", and the 200ms defines how much time should elapse before the accumulation resets. How do I do this?</p>
","1373258","","1373258","","2016-08-22 03:42:44","2016-08-22 03:42:44","RxJava - Backpressuring keyboard inputs?","<javafx><rx-java><kotlin><backpressure><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"39069635","2","","39057409","2016-08-21 23:13:49","","0","","<p>Got it! I figured out that I actually don't want <code>buffer()</code>, but rather a <code>switchMap()</code> and a <code>scan()</code> inside of it. I use a multicast to drive both the timer reset emission pushed into <code>switchMap()</code>, and the <code>scan()</code> which will infinitely concatenate typed characters until the <code>switchMap()</code> kills it for resetting.</p>

<pre><code>val burstyMulticast = events(KeyEvent.KEY_TYPED).publish().refCount().map { it.character }

burstyMulticast.throttleLast(1000, TimeUnit.MILLISECONDS).startWith("""")
        .switchMap {
            burstyMulticast.scan { x,y -&gt; x + y }
        }.subscribe { println(it) }
</code></pre>
","1373258","","","","","2016-08-21 23:13:49","","","","0","","","","CC BY-SA 3.0"
"40335952","1","","","2016-10-31 02:48:00","","8","6497","<p>I have got <code>Observable&lt;Rates&gt;</code> and Rate is just a simple object: </p>

<pre><code>Rate(val value:String){}
Rates(val rates: List&lt;Rate&gt;)
</code></pre>

<p>and i wanna change that <code>Observable&lt;Rates&gt;</code> into <code>Observable&lt;HashMap&lt;String,Long&gt;</code>. </p>

<p>so for example for rates <code>Rates(arrayOf(Rate(""1""),Rate(""2""), Rate(""3""),Rate(""3""), Rate(""2""),Rate(""2"")))</code> i expect result: </p>

<pre><code>(1 -&gt; 1)
(2 -&gt; 3)
(3 -&gt; 2)
(4 -&gt; 0)
(5 -&gt; 0)
</code></pre>

<p>I start creating something like that : </p>

<pre><code>service.getRates()
        .flatMap {it-&gt; Observable.from(it.rates) }
        .filter { !it.value.isNullOrEmpty() }
        .groupBy {it -&gt; it.value}
        .collect({ HashMap&lt;String,Long&gt;()}, { b, t -&gt; b.put(t.key, t.count???)}
</code></pre>

<p>but I am stuck here and i do not know count all values? and i do not know how to add empty values (0) if there is no 5 of 4. Is there any way to do this using rx? </p>
","1568605","","1137789","","2016-10-31 12:39:27","2016-10-31 12:39:27","How to do a groupBy and collect using RxJava and Kotlin?","<rx-java><reactive-programming><kotlin><rx-kotlin>","3","0","1","","","CC BY-SA 3.0"
"40630716","1","40661241","","2016-11-16 11:14:02","","3","1503","<p>We're trying to observe either a 15s interval, or whenever we're firing <code>onNext</code> on our subject <code>refreshEventsSubject</code>, but without success.</p>

<p>The subject is initiated like so</p>

<p><code>private val refreshEventsSubject = PublishSubject&lt;Long&gt;()</code></p>

<p>And then we try to observe it like this</p>

<p><code>Observable.merge(Observable.interval(0, 15, TimeUnit.SECONDS), refreshEventsSubject)
    .subscribe { ... }</code></p>

<p>We get the events from the interval every 15s, but the subject is not firing after running</p>

<p><code>refreshEventsSubject.onNext(0)</code></p>

<p>Any ideas appreciated.</p>

<p>(Everything is written in Kotlin)</p>
","1639409","","1639409","","2016-11-16 11:35:15","2016-11-17 17:21:24","RxJava(Kotlin), Observable.amb and PublishSubject is not firing","<android><rx-java><kotlin><rx-kotlin>","2","2","","","","CC BY-SA 3.0"
"40661241","2","","40630716","2016-11-17 17:21:24","","1","","<p>Make sure <code>refreshEventsSubject.onNext(0)</code> is not called from your main thread as it may cause deadlocks!</p>

<p>Also use <a href=""http://reactivex.io/documentation/operators/amb.html"" rel=""nofollow noreferrer"">http://reactivex.io/documentation/operators/amb.html</a> rather than merge as merge will emmit two events oppon calling onNext on your subject.</p>
","565319","","","","","2016-11-17 17:21:24","","","","0","","","","CC BY-SA 3.0"
"40818410","1","40819077","","2016-11-26 12:39:42","","10","18170","<p>I have some problem. I'm a beginer in RxJava/RxKotlin/RxAndroid, and dont understand some features. For Example:</p>

<pre><code>import rus.pifpaf.client.data.catalog.models.Category
import rus.pifpaf.client.data.main.MainRepository
import rus.pifpaf.client.data.main.models.FrontDataModel
import rus.pifpaf.client.data.product.models.Product
import rx.Observable
import rx.Single
import rx.lang.kotlin.observable
import java.util.*


class MainInteractor {

    private var repository: MainRepository = MainRepository()

    fun getFrontData() {

        val cats = getCategories()
        val day = getDayProduct()
        val top = getTopProducts()

        return Observable.zip(cats, day, top, MainInteractor::convert)
    }

    private fun getTopProducts(): Observable&lt;List&lt;Product&gt;&gt; {
        return repository.getTop()
                .toObservable()
                .onErrorReturn{throwable -&gt; ArrayList() }

    }

    private fun getDayProduct(): Observable&lt;Product&gt; {
        return repository.getSingleProduct()
                .toObservable()
                .onErrorReturn{throwable -&gt; Product()}

    }

    private fun getCategories(): Observable&lt;List&lt;Category&gt;&gt; {
        return repository.getCategories()
                .toObservable()
                .onErrorReturn{throwable -&gt; ArrayList() }
    }

    private fun convert(cats: List&lt;Category&gt;, product: Product, top: List&lt;Product&gt;): FrontDataModel {

    }
}
</code></pre>

<p>Then I'm use <strong>MainInteractor::convert</strong> Android studio tell me next</p>

<p><a href=""https://i.stack.imgur.com/Caoua.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Caoua.jpg"" alt=""enter image description here""></a></p>

<p>I tried a lot of variant and tried to understand what does it want, but no success. Help me please... Best Regards.</p>
","3775934","","3775934","","2019-10-08 10:54:03","2021-01-27 21:18:18","How to zip few observables in Kotlin language with RxAndroid","<android><rx-java><kotlin><rx-android><rx-kotlin>","3","0","1","","","CC BY-SA 4.0"
"40819077","2","","40818410","2016-11-26 13:55:48","","21","","<p>Just replace function reference with lambda:</p>

<pre><code>return Observable.zip(cats, day, top, { c, d, t -&gt; convert(c, d, t) })
</code></pre>

<p>And don't forget to declare function's return type explicitly:</p>

<pre><code>fun getFrontData(): Observable&lt;FrontDataModel&gt; {
    ...
</code></pre>
","7045114","","","","","2016-11-26 13:55:48","","","","0","","","","CC BY-SA 3.0"
"41223466","1","41608056","","2016-12-19 13:17:20","","2","1398","<p>RuntimeExceptions are supposed to indicate programming error and I want my application to crash when something inside my observables throws RuntimeException. </p>

<p>What is the best way to do this? Right now I'm considering this solution (it's Kotlin, but I hope it's understandable)</p>

<pre><code>fun &lt;T&gt; Observable&lt;T&gt;.subscribeCrashOnRuntimeException(onNext: (T) -&gt; Unit, onError: (Throwable) -&gt; Unit) {
  this.subscribe({
    onNext(it)
  }, { e -&gt;
    if (e is RuntimeException) {
      throw e
    } else {
      onError(e)
    }
  })
}

fun usageExample() {
  val observable = Observable.just(1)
  observable.subscribeCrashOnRuntimeExceptions(
    { next -&gt; Log.d(""TAG"", ""next: $next"") },
    { e -&gt; Log.d(""TAG"", ""error: $e"") }
  )
}
</code></pre>

<p>But I have doubts about it. For example it is hard to occasionally ""catch"" specific RuntimeExceptions with this solution. Perhaps there is a well known way to deal with situation that I just don't know how to google?</p>
","544406","","697313","","2017-01-12 11:27:52","2017-01-12 11:51:51","RuntimeException handling best practices","<android><rx-java><rx-kotlin>","1","3","1","","","CC BY-SA 3.0"
"41608056","2","","41223466","2017-01-12 08:12:16","","1","","<p>I don't think there should be much difference in handling runtime (aka unchecked) or regular (aka checked) exceptions. Both are widely used these days and could be either recoverable or not depending on particular situation.</p>

<p><strong>The reactive ways of handling errors are:</strong></p>

<ol>
<li>via <code>onErrorResumeNext</code> or <code>onErrorReturn</code> operators; these allow to inspect the error and possibly recover from it</li>
<li>via <code>retry*</code> family of operators; these allow to inspect the error and possibly recover from it by means of re-subscribing (for example retry network call)</li>
<li>via <code>onError</code> callback of your subscribers; by the way in case you do not supply such a callback the error will be re-thrown in regular Java fashion, so your program <em>will</em> crash</li>
</ol>

<p>Related topic: <a href=""https://stackoverflow.com/q/38052919/697313"">How to handle different kinds of errors in Retrofit Rx onError without ugly instanceof</a></p>

<p><strong>Also note the drawbacks of throwing exceptions in regular Java way:</strong></p>

<ul>
<li>the call stack during message processing is different from the call stack when you define message processing rules; this means it could be quite hard to catch such exceptions, as well as to interpret the stack trace</li>
<li>exceptions caught by schedulers might not lead to program termination; i.e. your program might end up hanging in broken state</li>
</ul>

<p><strong>Sample code</strong></p>

<pre><code>Observable.fromCallable(() -&gt; {
    ...
    if (ok) return ""Success!"";
    else throw new RuntimeException(""Failure at source"");
})
.map(s -&gt; {
    ... processing is bypassed in case of an error
})
.map(s -&gt; {
    ...
    if (...) return s.upperCase();
    else throw new RuntimeException(""Failure during processing"");
})
.onErrorReturn(e -&gt; {
    if (e.getMessage().contains(""processing""))
        return ""Recovered"";
    throw Exceptions.propagate(e); // let it continue as an error
})
.subscribe(s -&gt; println(""got result: "" + s),
           e -&gt; println(""got error: "" + e);
</code></pre>

<p>All exceptions get caught by RxJava and passed along the defined route.</p>

<p><code>onError*</code> operators act like intermediate <code>catch</code> blocks.</p>

<p>Subscriber's <code>onError</code> callback acts like top-level <code>catch</code> block.</p>

<p><strong>More links on the subject:</strong></p>

<ul>
<li><a href=""http://blog.danlew.net/2015/12/08/error-handling-in-rxjava/"" rel=""nofollow noreferrer"">Error handling in RxJava</a></li>
<li><a href=""https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators"" rel=""nofollow noreferrer"">Error Handling Operators</a></li>
</ul>
","697313","","-1","","2017-05-23 12:13:58","2017-01-12 11:51:51","","","","4","","","","CC BY-SA 3.0"
"41987704","1","41990290","","2017-02-01 19:08:56","","1","308","<p>I thought this is how it works, seems like I'm missing something..</p>

<pre><code>@Test
fun singleCompletes()
{
    val testSubscriber = TestSubscriber&lt;Boolean&gt;()

    Single.just(true)
            .subscribeOn(Schedulers.immediate())
            .subscribe { testSubscriber }

    testSubscriber.assertNoErrors()
    testSubscriber.assertValue(true)
}
</code></pre>

<blockquote>
  <p>java.lang.AssertionError: Number of items does not match. Provided: 1  Actual: 0.</p>
</blockquote>
","2192545","","","","","2017-02-01 21:40:45","RxKotlin - Single.just() does not emit when subscribing TestSubscriber","<kotlin><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"41990290","2","","41987704","2017-02-01 21:40:45","","3","","<p>I think your invocation of <code>subscribe</code> is incorrect.</p>

<p>It seems you meant </p>

<pre><code>Single.just(true)
    .subscribeOn(Schedulers.immediate())
    .subscribe(testSubscriber)
</code></pre>

<p>Which would invoke the <code>subscribe(Subscriber&lt;? super T&gt; subscriber)</code>.</p>

<p>Your code is invoking <code>subscribe(final Action1&lt;? super T&gt; onSuccess)</code>, which would explain what you see.</p>
","697630","","","","","2017-02-01 21:40:45","","","","0","","","","CC BY-SA 3.0"
"42066066","1","42126960","","2017-02-06 10:55:51","","85","27865","<p>Why would I want to use Kotlin's coroutines?</p>
<p>It seems that the RxKotlin library is much more versatile.
Kotlin's coroutines look significantly less powerful and more cumbersome to use in comparison.</p>
<p>I base my opinion on coroutines on <a href=""https://www.youtube.com/watch?v=4W3ruTWUhpw"" rel=""noreferrer"">this design talk by Andrey Breslav (JetBrains)</a></p>
<p>Slideshow from the talk is <a href=""https://www.slideshare.net/abreslav/jvmls-2016-coroutines-in-kotlin"" rel=""noreferrer"">accessible here.</a></p>
<hr />
<p>EDIT (thanks to @hotkey):</p>
<p>Better source on the current state of coroutines <a href=""https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md"" rel=""noreferrer"">here.</a></p>
","3160531","","13363205","","2020-07-26 21:55:18","2021-10-03 09:54:47","How Kotlin coroutines are better than RxKotlin?","<kotlin><rx-kotlin>","5","0","45","","","CC BY-SA 4.0"
"42126960","2","","42066066","2017-02-09 02:00:06","","107","","<p><strong>Disclaimer:</strong> Parts of this answer are irrelevant since Coroutines now have the flow API, very similar to Rx one. If you want an up-to-date answer, jump to the last edit.</p>
<p>There is two parts in Rx; the Observable pattern, and a solid set of operators to manipulate, transform and combine them. The Observable pattern, by itself, doesn't do a lot. Same with Coroutines; it's just another paradigm to deal with asynchronism. You can compare the pro/cons of callbacks, Observable and coroutines to solve a given problem, but you can't compare a paradigm with a fully featured library. It's like comparing a language with a framework.</p>
<p>How Kotlin coroutines are better than RxKotlin ? Didn't used coroutines yet, but it's look similar to async/wait in C#. You just write sequential code, everything is as easy as writing synchronous code ... except it execute asynchronously. It's easier to grasp.</p>
<p>Why would I want to use kotlin coroutines ? I will answer for myself. Most of the time I will stick to Rx, because I favor event-driven architecture. But should arise the situation where I am writing sequential code, and I need to call an asynchronous method in the middle, I will happily leverage coroutines to keep it that way and avoiding wrapping everything in Observable.</p>
<p><strong>Edit</strong>: Now that I am using coroutines it's time for an update.</p>
<p>RxKotlin is just syntactic sugar to use RxJava in Kotlin, so I will speak about RxJava and not RxKotlin in the following. Coroutines are a lower lever and more general concept than RxJava, they serve others use-cases. That said, there is one use-case where you could compare RxJava and coroutines (<code>channel</code>), it's passing around data asynchronously. Coroutines have a clear advantage over RxJava here:</p>
<h2>Coroutines are better to deal with resources</h2>
<ul>
<li>In RxJava you can assign computations to schedulers but <code>subscribeOn()</code> and <code>ObserveOn()</code>are confusing. Every coroutine is given a thread context and return to parent context. For a channel, both side (producer, consumer) execute on his own context. Coroutines are more intuitive on thread or thread pool affectation.</li>
<li>Coroutines give more control on when those computation occur. You can for example pass hand (<code>yield</code>), prioritize (<code>select</code>), parallelize (multiple <code>producer</code>/<code>actor</code> on <code>channel</code>) or lock resource (<code>Mutex</code>) for a given computation. It may not matter on server (where RxJava came first) but on resources limited environment this level of control may be required.</li>
<li>Due to it's reactive nature, backpressure doesn't fit well in RxJava. In the other end <code>send()</code> to channel is a suspensive function that suspend when channel capacity is reached. It's out-of-the-box backpressure given by nature. You could also <code>offer()</code> to channel, in which case the call never suspend but return <code>false</code> in case the channel is full, effectively reproducing <code>onBackpressureDrop()</code> from RxJava. Or you could just write your own custom backpressure logic, which won't be difficult with coroutines, especially compared to do the same with RxJava.</li>
</ul>
<p>There is another use-case, where coroutines shine and this will answer your second question &quot;Why would I want to use Kotlin coroutines?&quot;. Coroutines are the perfect replacement for background threads or <code>AsyncTask</code> (Android). It's as easy as <code>launch { someBlockingFunction() }</code>. Of course you could achieve this with RxJava too, using <code>Schedulers</code> and <code>Completable</code> perhaps. You won't (or little) use the Observer pattern and the operators which are the signature of RxJava, a hint that this work is out of scope for RxJava. RxJava complexity (a useless tax here) will make your code more verbose and less clean than Coroutine's version.</p>
<p>Readability matters. On this regard, RxJava and coroutines approach differ a lot. Coroutines are simpler than RxJava. If you are not at ease with <code>map()</code>, <code>flatmap()</code> and functional reactive programming in general, coroutines manipulations are easier, involving basics instructions: <code>for</code>, <code>if</code>, <code>try/catch</code> ... But I personally find coroutine's code harder to understand for non-trivial tasks. Especially it involves more nesting and indentation whereas operator chaining in RxJava keep everything in line. Functional-style programming make processing more explicit. On top of that RxJava can solve complex transformations with a few standard operators from their rich (OK, way too rich) operator set. RxJava shine when you have complex data flows requiring a lot of combinations and transformations.</p>
<p>I hope those considerations will help you choose the right tool given your needs.</p>
<p><strong>Edit:</strong> Coroutine now have flow, an API very, very similar to Rx. One could compare pro/cons of each, but the truth is the differences are minor.</p>
<p>Coroutines as it's core is a concurrency design pattern, with add-on libraries, one of those being a stream API similar to Rx. Obviously, Coroutines having a far broader scope than Rx, there is a lot of things that Coroutines can that Rx can't, and I can't list them all. But usually if I use Coroutines in one of my project it boil down to one reason:</p>
<h2>Coroutines are better at removing callback from your code</h2>
<p>I avoid using callback wich harm readability too much. Coroutines make asynchronous code simple and easy to write. By leveraging the suspend keyword, your code look like synchronous one.</p>
<p>I have seen Rx used in project mostly for the same purpose of replacing callback, but if you don't plan to modify your architecture to commit to the reactive pattern, Rx will be a burden. Consider this interface:</p>
<pre><code>interface Foo {
   fun bar(callback: Callback)
}
</code></pre>
<p>The Coroutine equivalent is more explicit, with a return type and the keyword suspend indicating it's an asynchronous operation.</p>
<pre><code>interface Foo {
   suspend fun bar: Result
}
</code></pre>
<p>But there is a problem with the Rx equivalent:</p>
<pre><code>interface Foo {
   fun bar: Single&lt;Result&gt;
}
</code></pre>
<p>When you call bar() in the callback or Coroutine version, you trigger the computation; with the Rx version, you get a representation of a computation that you can trigger at will. You need to call bar() then subscribing to the Single. Usually not a big deal, but it's a little confusing for beginner and can lead to subtle problem.</p>
<p>One exemple of such problems, suppose the callback bar function is implemented as such:</p>
<pre><code>fun bar(callback: Callback) {
   setCallback(callback)
   refreshData()
}
</code></pre>
<p>If you don't port it properly, you will end with a Single that can be triggered only once because refreshData() is called in bar() function and not at subscription time. A beginner mistake, granted, but the thing is Rx is way more than a callback replacement and a lot of developers struggle to grasp Rx.</p>
<p>If your objective is to transform an asynchronous task from callback to a nicer paradigm, Coroutines are a perfect fit whereas Rx add some complexity.</p>
","3988291","","3988291","","2021-01-10 10:39:13","2021-01-10 10:39:13","","","","8","","","","CC BY-SA 4.0"
"42727899","1","","","2017-03-10 21:20:29","","-1","1481","<p>So I have an observable with a debounce of 300ms.<br>
It does an API-call after a key-up event.</p>

<p>There's an API-lock in place to prevent future calls until it is completed, but I would also like to check if the observable is running (that's making the API call) and stop it.</p>

<p>How would this be accomplished?</p>
","2368378","","2368378","","2017-03-10 21:40:53","2017-03-10 21:40:53","How do I check if an observable is running and stop it?","<android><thread-safety><rx-java><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"42772319","1","42774592","","2017-03-13 19:55:38","","0","87","<p>I'm trying to write an Android app with Kotlin. Now, I want to show a counter in the ActionBar. I added an item called show_timer for that. Each second, it should count up by one:</p>

<pre><code>override fun onWindowFocusChanged(hasFocus: Boolean) {
    val item = findViewById(R.id.show_timer) as ActionMenuItemView
    PublishSubject.interval(1, java.util.concurrent.TimeUnit.SECONDS, Schedulers.newThread())
            .subscribeBy(onNext = {item.text = it.toString()})

    super.onWindowFocusChanged(hasFocus)
}
</code></pre>

<p>But somehow this doesn't work. It updates the default text to 0, but after that it does nothing. Does someone know why this doesn't work?</p>

<p>Thank you in advance,</p>

<p>Niklas</p>
","7544860","","","","","2017-03-13 22:30:09","Can't Change Text of ActionMenuItemView with RxKotlin","<android><system.reactive><kotlin><rx-kotlin>","1","2","","","","CC BY-SA 3.0"
"42774592","2","","42772319","2017-03-13 22:30:09","","0","","<p>In order for the text to update, it needs to be updated on the main thread (not the <code>Schedulers.newThread()</code> one)</p>

<p>Adding:</p>

<pre><code>.observeOn(AndroidSchedulers.mainThread())
</code></pre>

<p>Should fix things, and get the label to update</p>
","6509","","","","","2017-03-13 22:30:09","","","","1","","","","CC BY-SA 3.0"
"42927824","1","","","2017-03-21 12:56:54","","0","208","<p>is it possible to send the same object to subscribers in Rx repeatedly? 
For exmaple this code(on Kotlin): </p>

<pre><code> val exmp = listOf(""А"")
        var observable = exmp.toObservable()
            observable.subscribeBy(
                    onNext = {
                        it + ""1""
                        println(it)
                    },
                    onError = { it.printStackTrace() },
                    onComplete = { println(""Done!"") }
            )
</code></pre>

<p>I try to send string value ""A"" repeatedly to method onNext() and get ""A111111"". 
Method replay() of Rx library as I understand starting sending date again for new subsribers. In circle <code>for</code> date from observable not changing, just  method is called several times</p>
","7745622","","","","","2017-03-21 14:45:36","Repeat sending object to subsriber on Rx","<rx-java><reactive-programming><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"43285064","1","43320828","","2017-04-07 18:40:43","","20","8839","<p>I'm trying to test the following RxKotlin/RxJava 2 code:</p>

<pre class=""lang-java prettyprint-override""><code>validate(data)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .flatMap { ... }
</code></pre>

<p>I'm attempting to override the schedulers as follows:</p>

<pre class=""lang-java prettyprint-override""><code>// Runs before each test suite
RxJavaPlugins.setInitIoSchedulerHandler { Schedulers.trampoline() }
RxAndroidPlugins.setInitMainThreadSchedulerHandler { Schedulers.trampoline() }
</code></pre>

<p>However, I get the following error when running the test:</p>

<pre class=""lang-java prettyprint-override""><code>java.lang.ExceptionInInitializerError
...
Caused by: java.lang.NullPointerException: Scheduler Callable result can't be null
    at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39)
    at io.reactivex.plugins.RxJavaPlugins.applyRequireNonNull(RxJavaPlugins.java:1317)
    at io.reactivex.plugins.RxJavaPlugins.initIoScheduler(RxJavaPlugins.java:306)
    at io.reactivex.schedulers.Schedulers.&lt;clinit&gt;(Schedulers.java:84)
</code></pre>

<p>Has anyone experienced this problem? </p>

<hr>

<p>The test worked fine when using RxKotlin/RxJava 1 and the following scheduler overrides:</p>

<pre class=""lang-java prettyprint-override""><code>RxAndroidPlugins.getInstance().registerSchedulersHook(object : RxAndroidSchedulersHook() {
    override fun getMainThreadScheduler() = Schedulers.immediate()
})

RxJavaPlugins.getInstance().registerSchedulersHook(object : RxJavaSchedulersHook() {
    override fun getIOScheduler() = Schedulers.immediate()
})
</code></pre>
","1261256","","1000551","","2019-11-06 10:06:31","2019-11-26 17:20:37","RxJava 2 overriding IO scheduler in unit test","<kotlin><rx-java><rx-kotlin>","4","4","7","","","CC BY-SA 4.0"
"43320828","2","","43285064","2017-04-10 10:30:48","","24","","<p>I suggest you take a different approach and add a layer of abstraction to your schedulers. This guy has a nice <a href=""https://medium.com/@peter.tackage/an-alternative-to-rxandroidplugins-and-rxjavaplugins-scheduler-injection-9831bbc3dfaf"" rel=""nofollow noreferrer"">article</a> about it. </p>

<p>It would look something like this in Kotlin</p>

<pre><code>interface SchedulerProvider {
    fun ui(): Scheduler
    fun computation(): Scheduler
    fun trampoline(): Scheduler
    fun newThread(): Scheduler
    fun io(): Scheduler 
}
</code></pre>

<p>And then you override that with your own implementation of SchedulerProvider:</p>

<pre><code>class AppSchedulerProvider : SchedulerProvider {
    override fun ui(): Scheduler {
        return AndroidSchedulers.mainThread()
    }

    override fun computation(): Scheduler {
        return Schedulers.computation()
    }

    override fun trampoline(): Scheduler {
        return Schedulers.trampoline()
    }

    override fun newThread(): Scheduler {
        return Schedulers.newThread()
    }

    override fun io(): Scheduler {
        return Schedulers.io()
    }
}
</code></pre>

<p>And one for testing classes:</p>

<pre><code>class TestSchedulerProvider : SchedulerProvider {
    override fun ui(): Scheduler {
        return Schedulers.trampoline()
    }

    override fun computation(): Scheduler {
        return Schedulers.trampoline()
    }

    override fun trampoline(): Scheduler {
        return Schedulers.trampoline()
    }

    override fun newThread(): Scheduler {
        return Schedulers.trampoline()
    }

    override fun io(): Scheduler {
        return Schedulers.trampoline()
    }
}
</code></pre>

<p>Your code would look like this where you call RxJava:</p>

<pre><code>mCompositeDisposable.add(mDataManager.getQuote()
        .subscribeOn(mSchedulerProvider.io())
        .observeOn(mSchedulerProvider.ui())
        .subscribe(Consumer&lt;Quote&gt; {
...
</code></pre>

<p>And you'll just override your implementation of <code>SchedulerProvider</code> based on where you test it. Here's a sample project for reference, I am linking the test file that would use the testable-version of <code>SchedulerProvider</code>: <a href=""https://github.com/Obaied/DingerQuotes/blob/master/app/src/test/java/com/obaied/dingerquotes/QuotePresenterTest.kt#L31"" rel=""nofollow noreferrer"">https://github.com/Obaied/DingerQuotes/blob/master/app/src/test/java/com/obaied/dingerquotes/QuotePresenterTest.kt#L31</a></p>
","3870025","","4699509","","2019-11-26 17:20:37","2019-11-26 17:20:37","","","","3","","","","CC BY-SA 4.0"
"43564621","1","","","2017-04-22 21:06:33","","7","4766","<p>I'm trying to observe observable on main thread by using:</p>

<pre><code>    // Kotlin Code
    Observable
      .observeOn(AndroidSchedulers.mainThread())
</code></pre>

<p>but I'm getting following error:</p>

<pre><code>    Type Mismatch:
      Required: rx.Scheduler!
      Found: io.reactivex.Scheduler!
</code></pre>

<p>The Observable I'm subscribing to is from a Library that is written in Java and therefore uses RxJava.</p>

<p>Am i being stupid and missing something? I'm puzzeled :$</p>

<p>Thanks in advance :)</p>
","6411538","","","","","2021-02-19 01:10:08","Cant 'observeOn' main thread with RxKotlin","<android><kotlin><rx-java2><rx-kotlin><kotlin-interop>","4","2","2","","","CC BY-SA 3.0"
"43681939","1","","","2017-04-28 13:54:04","","4","1746","<p>In a JavaFX Gradle-based application that I develop using RxJava and Kotlin in IntelliJ IDEA 2017.1.2 (Build #IC-171.4249.39), I'm getting an exception:</p>

<blockquote>
  <p>Exception in thread ""JavaFX Application Thread"" java.lang.NoClassDefFoundError: org/reactivestreams/Publisher</p>
</blockquote>

<p>everytime a code like this</p>

<pre><code>return Completable.complete()
</code></pre>

<p>is executed. Following a suggestion of a similar question <a href=""https://stackoverflow.com/questions/43231477/why-i-am-getting-noclassdeffounderror-org-reactivestreams-publisher"">Why I am getting NoClassDefFoundError: org/reactivestreams/Publisher</a>, I've tried to add include the reactive-streams to the <code>dependencies</code> block of my <code>build.gradle</code> script</p>

<pre><code>dependencies {
    compile 'org.jetbrains.kotlin:kotlin-stdlib:1.1.2'
    compile 'org.reactivestreams:reactive-streams:1.0.0'
    compile 'io.reactivex.rxjava2:rxkotlin:2.0.0'
}
</code></pre>

<p>but the problem persists. The dependency tree looks like this one:</p>

<pre><code>compile - Dependencies for source set 'main' (deprecated, use 'implementation ' instead).
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

compileClasspath - Compile classpath for source set 'main'.
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

\--- org.jetbrains.kotlin:kotlin-annotation-processing:1.1.2
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
          \--- org.jetbrains:annotations:13.0

kaptTest
\--- org.jetbrains.kotlin:kotlin-annotation-processing:1.1.2
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
          \--- org.jetbrains:annotations:13.0

runtime - Runtime dependencies for source set 'main' (deprecated, use 'runtimeOnly ' instead).
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

runtimeClasspath - Runtime classpath of source set 'main'.
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

testCompile - Dependencies for source set 'test' (deprecated, use 'testImplementation ' instead).
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

testCompileClasspath - Compile classpath for source set 'test'.
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

testRuntime - Runtime dependencies for source set 'test' (deprecated, use 'testRuntimeOnly ' instead).
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)

testRuntimeClasspath - Runtime classpath of source set 'test'.
+--- org.jetbrains.kotlin:kotlin-stdlib:1.1.2
|    \--- org.jetbrains:annotations:13.0
+--- org.reactivestreams:reactive-streams:1.0.0
\--- io.reactivex.rxjava2:rxkotlin:2.0.0
     +--- io.reactivex.rxjava2:rxjava:2.0.7
     |    \--- org.reactivestreams:reactive-streams:1.0.0
     \--- org.jetbrains.kotlin:kotlin-stdlib:1.1.0 -&gt; 1.1.2 (*)
</code></pre>

<p>As you can see, <strong>org.reactivestreams:reactive-streams</strong> is present in each environment. </p>

<p>Now, I've managed to resolve the problem by adding manually dependency on a <a href=""https://jar-download.com/?detail_search=g%3A%22io.reactivex.rxjava2%22&amp;g=io.reactivex.rxjava2"" rel=""nofollow noreferrer"">reactive-streams-1.0.0.jar</a>, but I don't like this solution at all. </p>

<p>Could somebody advice a better solution? Thanks!</p>
","2114895","","-1","","2017-05-23 10:31:25","2017-05-08 14:58:51","Exception caused by: java.lang.ClassNotFoundException: org.reactivestreams.Publisher","<intellij-idea><gradle><kotlin><rx-java2><rx-kotlin>","0","1","1","","","CC BY-SA 3.0"
"43771854","1","43774178","","2017-05-04 00:00:00","","3","874","<p>I am trying to get a better understanding of how to do unit tests with Rx-Kotlin, but I have not been able to successfully set the subject to ""completed"". As a result, I am always waiting for the timeout of 5 seconds (the onComplete should be immediate) and then fail on assertComplete.</p>

<p>My understanding of <a href=""http://reactivex.io/RxJava/javadoc/rx/observers/TestSubscriber.html#awaitTerminalEvent()"" rel=""nofollow noreferrer"">awaitTerminalEvent</a> is that it should only block until the onComplete is called. I have also looked into <a href=""http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html"" rel=""nofollow noreferrer"">TestScheduler,</a> but I do not believe that it should be required here. </p>

<p>Any help or documentation that can lead me in the right direction would be much appreciated.</p>

<pre><code>@Test
fun testObservable() {
    val subject = BehaviorSubject.create&lt;Int&gt;()
    subject.onNext(0)

    TestSubscriber&lt;Int&gt;().apply {
        subject.subscribe({
            System.out.println(it)
            subject.onNext(1)
            subject.onComplete()
        })

        this.awaitTerminalEvent(5, TimeUnit.SECONDS)
        this.assertComplete()
        this.assertValue(1)
    }
}
</code></pre>
","2461717","","3903847","","2017-05-04 04:57:25","2017-05-04 04:57:25","Rx-Kotlin awaitTerminalEvent never getting onComplete","<unit-testing><testing><kotlin><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"43774178","2","","43771854","2017-05-04 04:56:56","","5","","<p>You're using the wrong tool in the wrong way...  </p>

<ul>
<li><code>TestSubscriber</code> is for testing <code>Flowable</code>, you should use here <code>TestObserver</code>.</li>
<li>you should subscribe with the <code>TestObserver</code> (or <code>TestSubscriber</code> in <code>Flowable</code>), in order for it to monitor emissions and be able to wait for terminal event and assert values. In your code the <code>TestSubscriber</code> is not attached to any stream, so it will never get any event.  </li>
</ul>

<p>trying to mimic your code, it could be something like this:</p>

<pre><code> @Test
fun testObservable() {
    val subject = BehaviorSubject.create&lt;Int&gt;()
    subject.onNext(0)

    TestObserver&lt;Int&gt;().apply {
        subject.doOnNext {
            System.out.println(it)
            subject.onNext(1)
            subject.onComplete()
        }
                .subscribe(this)

        this.awaitTerminalEvent(5, TimeUnit.SECONDS)
        this.assertComplete()
        this.assertValue(1)
    }
}  
</code></pre>

<p>as you can see, I'm using <code>TestObserver</code> the subscribe is done with the <code>TestObserver</code> object, and the subject <code>onNext()</code>, <code>onComplete()</code> moved to the <code>doOnNext()</code>. the test will fail as you have two emitted values, while the test assert only for single '1' value.  </p>

<p>Generally speaking, it's kind of wrong, that you using subject to emit again in the <code>onNext()</code> and then call <code>onComplete()</code>, you can subscribe before and then emit outside. something like this:</p>

<pre><code>TestObserver&lt;Int&gt;().apply {
        subject.subscribe(this)
        subject.onNext(1)
        subject.onComplete()
        ....
}
</code></pre>
","3903847","","","","","2017-05-04 04:56:56","","","","1","","","","CC BY-SA 3.0"
"43807056","1","43807850","","2017-05-05 14:04:38","","10","6184","<p>In an app that connects to bluetooth devices, I am using the following function using RxKotlin:</p>

<pre><code>private fun startBluetoothPair(device: BluetoothDevice) {
    Observable.just(device)
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .map {
            var uuid: UUID = BLUETOOTH_UUID
            var socket = it.createRfcommSocketToServiceRecord(uuid)
            socket.connect()
            return socket
        }
        .subscribe {
            // Do something with the BluetoothSocket
        }
}
</code></pre>

<p>This function should simply connect with the bluetoothdevice on the background and then do something with the socket (in the mainthread again). However, the <code>map</code> can't handle the <code>return socket</code> part, telling me there is a <code>Type mismatch</code>, it found a <code>BluetoothSocket</code> where it required a <code>Unit</code>.</p>

<p>What is going wrong here? I thought a map should be able to infer the return type.</p>
","1506976","","","","","2021-02-03 06:40:33","Rx Kotlin: map function can't infer return type","<android><reactivex><rx-kotlin>","2","3","2","","","CC BY-SA 3.0"
"43807850","2","","43807056","2017-05-05 14:43:53","","33","","<p>In your map function replace the statement</p>

<pre><code>return socket
</code></pre>

<p>with</p>

<pre><code>return@map socket
</code></pre>

<p>Because <strong>return</strong> statement is normally used to return values for top-level functions. For lambda expressions and inline (nested) functions, use returns at labels i.e. <strong>return@{method_name}</strong>. You can also leave last line just to <strong><code>socket</code></strong> in the case, and the compiler will handle it for you assuming the last line as return value for the inline function. But for better readability, I will definitely prefer  qualified return syntax. You can read more details in kotlin documentation <a href=""https://kotlinlang.org/docs/reference/returns.html#return-at-labels"" rel=""noreferrer"">here</a> and <a href=""http://kotlinlang.org/docs/reference/lambdas.html#lambda-expression-syntax"" rel=""noreferrer"">here</a></p>
","1771663","","","","","2017-05-05 14:43:53","","","","2","","","","CC BY-SA 3.0"
"43821571","1","43822648","","2017-05-06 14:22:47","","3","1365","<p>I have a Observables which emits some numbers and I simply want to take last N elements. </p>

<p>I have following code (I'm using RxKotlin which is simply a wrapper on RxJava):</p>

<pre><code>val list = listOf(1,2,3,4,5,6,7,8,9,10)
Observable.fromIterable(list)
          .buffer(3, 1)
          .lastOrError()
          .subscribe{value -&gt; println(value)}
</code></pre>

<p>Unfortunately the result is <code>[10]</code>, as I looked closer what the buffer operator returns, I saw this:</p>

<pre><code>[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]
[8, 9, 10]
[9, 10]
[10] 
</code></pre>

<p>is there a way to get last ""full"" buffer -> <code>[8, 9, 10]</code> ?</p>
","2794332","","2794332","","2017-05-06 14:28:01","2017-05-06 16:13:01","Get N last objects emitted by observable in RxJava2","<java><kotlin><reactive-programming><rx-java2><rx-kotlin>","1","0","1","","","CC BY-SA 3.0"
"43822648","2","","43821571","2017-05-06 16:13:01","","4","","<p>In RxJava, many operators have the name that matches the common language expression of the same operation: take + last N -> <code>takeLast(int n)</code>:</p>

<pre><code>Observable.range(1, 10)
   .takeLast(3)
   .toList() // &lt;--  in case you want it as a list
   .subscribe(System.out::println);
</code></pre>
","61158","","","","","2017-05-06 16:13:01","","","","0","","","","CC BY-SA 3.0"
"43945068","1","","","2017-05-12 19:22:03","","1","1311","<p>(Working in RxKotlin and RxJava, but using metacode for simplicity)</p>

<p>Many <code>Reactive Extensions</code> guides begin by creating an <code>Observable</code> from already available data.  From <a href=""https://gist.github.com/staltz/868e7e9bc2a7b8c1f754"" rel=""nofollow noreferrer"">The introduction to Reactive Programming you've been missing</a>, it's created from a single string</p>

<pre><code>var soureStream= Rx.Observable.just('https://api.github.com/users');
</code></pre>

<p>Similarly, from the frontpage of <a href=""https://github.com/ReactiveX/RxKotlin"" rel=""nofollow noreferrer"">RxKotlin</a>, from a populated list</p>

<pre><code>val list = listOf(1,2,3,4,5)
list.toObservable()     
</code></pre>

<p>Now consider a simple filter that yields an <code>outStream</code>,  </p>

<pre><code>var outStream = sourceStream.filter({x &gt; 3})
</code></pre>

<p>In both guides the source events are declared <em>apriori</em>.  Which means the timeline of events has some form</p>

<pre><code>source: ----1,2,3,4,5-------
out:    --------------4,5---
</code></pre>

<p>How can I modify <code>sourceStream</code> to become more of a pipeline?  In other words, no input data is available during <code>sourceStream</code> creation?  When a source event becomes available, it is immediately processed by out:</p>

<pre><code>source: ---1--2--3-4---5-------
out:    ------------4---5-------
</code></pre>

<p>I expected to find an <code>Observable.add()</code> for dynamic updates</p>

<pre><code>var sourceStream = Observable.empty()
var outStream = sourceStream.filter({x&gt;3})

//print each element as its added 
sourceStream .subscribe({println(it)})
outStream.subscribe({println(it)})

for i in range(5):
    sourceStream.add(i)
</code></pre>

<p>Is this possible?</p>
","4076764","","4076764","","2017-05-12 19:30:10","2017-05-14 01:48:58","How to dynamically update an RX Observable?","<java><rx-java><reactive-programming><rx-kotlin>","1","9","","","","CC BY-SA 3.0"
"43945102","1","43945802","","2017-05-12 19:25:06","","2","2598","<p>I'm kind of new to Kotlin and I'm trying to Inject a value (in this example it is just an Int but in the real code it is a Provider class)
What am I doing wrong here? and why is x is an unresolved reference?</p>

<pre><code>class Test
@Inject constructor(private val x: Int) {

companion object {
    var y: Int = 0

        @BeforeClass @JvmStatic
        fun beforeClass() {
            y = x * 2
        }
    }
}
</code></pre>
","2811244","","1502352","","2017-05-12 20:19:48","2017-05-12 20:19:48","Inject constructor and companion object","<java><junit><kotlin><guice><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"43945802","2","","43945102","2017-05-12 20:13:55","","4","","<p>A companion object is a static object associated with a <strong>class</strong>, not with an instance of a class.</p>

<pre><code>class Foo(val bar: Baz) {
    companion object {}
}
</code></pre>

<p>is similar to the following code in Java:</p>

<pre><code>class Foo {
    static class Companion { }
    static final Foo.Companion Companion = new Foo.Companion();

    final Baz bar;
    Foo(Baz bar) { this.bar = bar; }
}
</code></pre>

<p>This is why <code>x</code> is not in the variable scope of the companion object, just like you cannot access the <code>bar</code> field from the static class <code>Companion</code>. Your property <code>y</code> is actually a field in the <code>Test.Companion</code> class. </p>

<p>I'm not sure what you're trying to do with the <code>BeforeClass</code> thing, since I'm not familiar with it. Hope my answer helps anyway.</p>
","1502352","","","","","2017-05-12 20:13:55","","","","0","","","","CC BY-SA 3.0"
"44211577","1","44211963","","2017-05-26 23:57:14","","1","96","<p>In Kotlin the final statement of a function can be interpreted as its return value.</p>

<p>Can a situation like the following example be simplified to be less verbose?</p>

<pre><code>{ text: String -&gt;
  val validated = validateText(text)
  if (validated) {
    actOnValidation()
  }
  validated
}
</code></pre>

<p>A concrete case where I would like to do this is below in an example using RxJava - even if there's a better Rx approach I'm also interested in a pure Kotlin solution if it exists.</p>

<pre><code>fun inputChainObservable(targetField: TextView, chainedField: TextView): Observable&lt;Boolean&gt; {
  return targetField.textChanges()
      .observeOn(AndroidSchedulers.mainThread())
      .map { cs: CharSequence? -&gt;
        val hasInput = validateText(cs.toString())
        if (hasInput) {
          chainedField.requestFocus()
        }
        hasInput
      }
}
</code></pre>
","2087534","","","","","2017-05-27 01:12:32","For a Kotlin function used as an expression, is there concise way to operate on and return a value?","<android><rx-java><kotlin><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"44211963","2","","44211577","2017-05-27 01:12:32","","5","","<p>You can use <code>also()</code> to operate on and return the receiver:</p>

<pre><code>{ text: String -&gt;
    validateText(text).also { valid -&gt;
        if (valid) actOnValidation()
    }
}
</code></pre>

<p>You can also write it like this, but I prefer the first form because I think it's clearer:</p>

<pre><code>{ text: String -&gt;
    validateText(text).also {
        if (it) actOnValidation()
    }
}
</code></pre>
","1631664","","","","","2017-05-27 01:12:32","","","","0","","","","CC BY-SA 3.0"
"44245780","1","44246048","","2017-05-29 15:15:43","","1","579","<p>I'm converting some Java code to Kotlin and I'm having some trouble with <code>flattenAsObservable()</code></p>

<p>Here's what the code looked like in Java:</p>

<pre><code>discogsInteractor.search(query)
    .map(RootSearchResponse::getSearchResults)
    .flattenAsObservable(searchResults -&gt; searchResults)
    .take(12)
</code></pre>

<p>Here's what I have so far in Kotlin:</p>

<pre><code>discogsInteractor.search(query)
    .map { RootSearchResponse::searchResults }
    .flattenAsObservable&lt;SearchResult&gt; { searchResults -&gt; searchResults }
    .take(12)
</code></pre>

<p>It underlines the second <code>searchResults</code> and gives me the following error:</p>

<pre><code>Required: (Mutable)Iterable&lt;SearchResult!&gt;!
Found: KProperty1&lt;RootSearchResponse, List&lt;SearchResult&gt;&gt;!
</code></pre>

<p>I can replace </p>

<pre><code>.map { RootSearchResponse::searchResults }
</code></pre>

<p>with </p>

<pre><code>.map { searchResponse -&gt; searchResponse.searchResults }
</code></pre>

<p>and it will work. How do I correctly method reference? Or what's the reason that I can't in this instance?</p>

<p><strong>RootSearchResponse:</strong></p>

<pre><code>data class RootSearchResponse(val pagination: Pagination,
                              @SerializedName(""results"") val searchResults: List&lt;SearchResult&gt;)
</code></pre>
","4624156","","","","","2017-05-29 15:31:18","RxKotlin flattenAsObservable(): type mismatch with method reference","<kotlin><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"44246048","2","","44245780","2017-05-29 15:31:18","","2","","<p><code>RootSearchResponse::searchResults</code> is a method reference. Instead of passing this to the <code>map</code> function, by using <code>{}</code>, you're passing in a lambda that always returns this method reference. </p>

<p>Basically, you're mapping every incoming element to that method reference with your <code>map</code> operation, instead of applying that method to every element like you'd want to. So the incoming parameters of your <code>flattenAsObservable</code> method are always that same reference to the <code>searchResults</code> method, which is a <code>KProperty1</code>.</p>

<p>To apply the method that you're referencing to every element, you can pass the method reference in regular parentheses, like so:</p>

<pre><code>.map(RootSearchResponse::searchResults)
</code></pre>

<hr>

<p>For an additional simple example of what's happening with the lambda:</p>

<pre><code>listOf(1, 2, 3, 4, 5).map { 2 }
</code></pre>

<p>This operation would map every element to <code>2</code>, and you'd end up with a list that only contains <code>2</code> five times. It's basically just shorthand for the following, just without an explicit parameter name:</p>

<pre><code>listOf(1, 2, 3, 4, 5).map { x -&gt; 2 }
</code></pre>
","4465208","","","","","2017-05-29 15:31:18","","","","0","","","","CC BY-SA 3.0"
"44274144","1","","","2017-05-31 01:10:15","","1","99","<p>This is in Kotlin, but I think anyone who writes Java will be able to understand.</p>

<p>I'm trying to make a stopwatch with Rx and I'm having a little trouble with doing the actual stopping and starting. The big problem is that I don't know how to keep the current time, while modifying it as different actions (starting and stopping) come in. Here's what I've got right now.</p>

<pre><code>fullTime.switchMap { startTime -&gt;
    controlCommands.switchMap { command -&gt;
        when (command) {
            ControlState.PLAY -&gt; Observable.interval(1L, TimeUnit.SECONDS).map {
                ControlState.PLAY
            }
            ControlState.PAUSE -&gt; Observable.just(ControlState.PAUSE)
            else -&gt; Observable.just(ControlState.STOP)
        }
    }
}
</code></pre>

<p>Where <code>fullTime</code> and <code>controlCommands</code> are <code>Observable</code>s that emit events about the current starting time to count down from and say what to do next, respectively. I want to chain off of <code>controlCommands</code> and be able to keep state starting at <code>startTime</code> that will count down when a <code>PLAY</code> event appears, pause when <code>PAUSE</code> appears, and reset at <code>startTime</code> when <code>STOP</code> appears.</p>

<p><code>scan</code> almost works, but I don't know how to stop after the timer hits 0 and <code>PLAY</code> is still being sent every second, since it would be sending duplicate info. Also it doesn't allow a separation between the state and the observed value. So the value I accumulate with <code>scan</code> has to be the same type as the value inside the <code>Observable</code> (if that makes sense).</p>

<p>Any ideas what I should do?</p>
","1828448","","","","","2017-05-31 05:43:43","Repeating actions on state with RxJava","<java><rx-java><kotlin><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"44525885","1","44525981","","2017-06-13 15:34:49","","7","931","<p>I've been working through the examples in the book <a href=""https://www.amazon.co.uk/Reactive-Programming-RxJava-Asynchronous-Applications/dp/1491931655/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1497368108&amp;sr=1-1&amp;keywords=reactive%20programming%20with%20rxjava"" rel=""noreferrer"">Reactive Programming with RxJava</a>, which is targeted at version 1 not 2. An introduction to infinite streams has the following example (and notes there are better ways to deal with the concurrency):</p>

<pre><code>Observable&lt;BigInteger&gt; naturalNumbers = Observable.create(subscriber -&gt; {
    Runnabler = () -&gt; {
        BigInteger i = ZERO;
        while (!subscriber.isUnsubscribed()) {
            subscriber.onNext(i);
            i = i.add(ONE);
        }
    };
    new Thread(r).start();
});

...

Subscription subscription = naturalNumbers.subscribe(x -&gt; log(x));
/* after some time... */
subscription.unsubscribe();
</code></pre>

<p>However, in RxJava 2, the lambda expression passed to the <code>create()</code> method is of type <code>ObservableEmitter</code> and this doesn't have an <code>isUnsubscribed()</code> method. I've had a look in <a href=""https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-2.0"" rel=""noreferrer"">What's Different in 2.0</a> and also performed a search of the repository but can't find any such method.</p>

<p>How would this same functionality be achieved in 2.0?</p>

<p><strong>Edited to include solution as given below (n.b. using kotlin):</strong></p>

<pre><code>val naturalNumbers = Observable.create&lt;BigInteger&gt; { emitter -&gt;
    Thread({
        var int: BigInteger = BigInteger.ZERO
        while (!emitter.isDisposed) {
            emitter.onNext(int)
            int = int.add(BigInteger.ONE)
        }
    }).start()
}

val first = naturalNumbers.subscribe { log(""First: $it"") }
val second = naturalNumbers.subscribe { log(""Second: $it"") }

Thread.sleep(5)
first.dispose()
Thread.sleep(5)
second.dispose()
</code></pre>
","8086746","","8086746","","2017-06-13 17:11:05","2017-06-13 17:11:05","RxJava 2 equivalent to isUnsubscribed","<rx-java><rx-java2><rx-kotlin>","1","0","1","","","CC BY-SA 3.0"
"44525981","2","","44525885","2017-06-13 15:39:27","","6","","<p>After you subscribe to Observable, <code>Disposable</code> is returned. You can save it to your local variable and check <code>disposable.isDisposed()</code> to see if it still subscribing or not.</p>
","4643073","","","","","2017-06-13 15:39:27","","","","0","","","","CC BY-SA 3.0"
"44578211","1","44587447","","2017-06-15 22:54:48","","3","1601","<p>The following code is my attempt to convert an RxJava example into Kotlin. It's supposed to collect a bunch of <code>Int</code>'s into a <code>MutableList</code>, but I get a host of errors.</p>

<pre><code>val all: Single&lt;MutableList&lt;Int&gt;&gt; = Observable
        .range(10, 20)
        .collectInto(::MutableList, MutableList::add)
</code></pre>

<p>The errors:</p>

<pre><code>    Error:(113, 36) Kotlin: Type inference failed: Not enough information to infer parameter T in inline fun &lt;T&gt; MutableList(size: Int, init: (index: Int) -&gt; T): MutableList&lt;T&gt;
Please specify it explicitly.

Error:(113, 49) Kotlin: One type argument expected for interface MutableList&lt;E&gt; : List&lt;E&gt;, MutableCollection&lt;E&gt; defined in kotlin.collections

    Error:(113, 67) Kotlin: None of the following functions can be called with the arguments supplied: 
public abstract fun add(element: Int): Boolean defined in kotlin.collections.MutableList
public abstract fun add(index: Int, element: Int): Unit defined in kotlin.collections.MutableList
</code></pre>

<p>If I change <code>ImmutableList::add</code> to <code>ImmutableList&lt;Int&gt;::add</code>, I get rid of the type argument expected error, which is replaced with:</p>

<pre><code>Error:(113, 22) Kotlin: Type inference failed: fun &lt;U : Any!&gt; collectInto(initialValue: U!, collector: ((U!, Int!) -&gt; Unit)!): Single&lt;U!&gt;!
        cannot be applied to
        (&lt;unknown&gt;,&lt;unknown&gt;)
</code></pre>

<p>This is a straight copy of the following in Java:</p>

<pre><code>Observable&lt;List&lt;Integer&gt;&gt; all = Observable
    .range(10, 20)
    .collect(ArrayList::new, List::add);
</code></pre>

<p>I understand that the first error is telling me it's either inferring the incorrect type and I need to be more explicit (where?), but I thought that <code>::MutableList</code> would be the equivalent of <code>() -&gt; MutableList&lt;Int&gt;</code>. The third error is telling me that it can't call any of the <code>add()</code> methods with the arguments, but again, I thought that <code>MutableList::add</code> is equivalent to <code>{ list, value -&gt; list.add(value) }</code>. The fourth error tells me it can't figure out the types being applied to the <code>collector</code>.</p>

<p>If I use a lambda expression instead, there are no errors:</p>

<pre><code>val all: Single&lt;MutableList&lt;Int&gt;&gt; = Observable
        .range(10, 20)
        .collectInto(mutableListOf(), { list, value -&gt; list.add(value) })

all.subscribe { x -&gt; println(x) }
</code></pre>

<p>I'd appreciate some comments on what I'm doing wrong with the method references, as there's clearly something I've misunderstood (looking through the <a href=""https://kotlinlang.org/docs/reference/reflection.html#bound-function-and-property-references-since-11"" rel=""nofollow noreferrer"">Kotlin Language Reference</a>, I'm wondering if it's even a language feature at this time?). Much appreciated.</p>
","8086746","","8086746","","2017-06-16 06:34:29","2017-06-16 10:51:46","RxKotlin collectInto() MutableList using method references","<kotlin><method-reference><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"44587447","2","","44578211","2017-06-16 10:51:46","","3","","<p>In your first example, you try to apply the method signature of <code>collect</code> to the one from <code>collectInto</code>.</p>

<p>This can never work, since <code>collect</code> expects a <code>Func0&lt;R&gt;</code> and a  <code>Action2&lt;R, ? super T&gt;</code> and <code>collectInto</code> expects a <em>real object</em> and a <code>BiConsumer&lt;U, T&gt;</code>.<br>
A constructor <em>reference</em> can't work for <code>collectInto</code> - you need a real object (e.g. your <code>mutableListOf()</code> call)</p>

<p>The second problem is that Kotlin is expecting a <code>BiConsumer</code> object and not a function. I'm not quite sure why. Apparently Kotlin can't handle multiple generics for lambdas and function reference from SAM-Interfaces.</p>

<p>You therefore need to pass an instance of <code>BiConsumer</code> and not just a function.<br>
That's also why I asked in the comment whether you're sure about the error message:</p>

<pre><code>range(10, 20).collectInto(mutableListOf(), { l, i -&gt;  l.add(i) }) 
</code></pre>

<p>will give me an error, while</p>

<pre><code>range(10, 20).collectInto(mutableListOf(), BiConsumer { l, i -&gt;  l.add(i) })
</code></pre>

<p>won't. </p>
","1096567","","","","","2017-06-16 10:51:46","","","","4","","","","CC BY-SA 3.0"
"44617459","1","44637593","","2017-06-18 17:03:12","","1","491","<p>I'm trying to wrap my head around how to implement something in RxJava (2.0). It's for Android and I'm using Kotlin, although the choice of platform and language shouldn't matter here.</p>

<p>The idea is that I'd base some sort of MVP architecture on RxJava. In this implementation I'm thinking about an <code>Activity</code> (could be a <code>Fragment</code> or a custom <code>View</code> as well) exposes a stream of values (<code>Boolean</code>s for simplicity) which indicate lifecycle events, or whether the view is attached or detached.</p>

<p>The underlying idea is basically this:</p>

<pre><code>private val lifecycleEvents = PublishSubject.create&lt;Boolean&gt;()
val screenStates: Observable&lt;Boolean&gt; = lifecycleEvents.hide()

override fun onResume() {
    super.onResume()
    lifecycleEvents.onNext(true) // I'm attached!
}

override fun onPause() {
    lifecycleEvents.onNext(false) // I'm detached!
    super.onPause()
}

override fun onDestroy() {
    lifecycleEvents.onComplete() // I'm gone        
    super.onDestroy()
}
</code></pre>

<p>And then from the other end, the Presenter exposes an <code>Observable</code> that is a stream of objects representing screen states - to be rendered by the View. </p>

<p>(This follows the concept explained in this series <a href=""http://hannesdorfmann.com/android/mosby3-mvi-1"" rel=""nofollow noreferrer"">http://hannesdorfmann.com/android/mosby3-mvi-1</a> - which boils down to the fact that the Presenter feeds the View with standalone objects encapsulating screen states in their entirety rather than multiple different methods on the View). </p>

<p>And then I'd like to bind these two observable streams so that:</p>

<ul>
<li><p>Whenever the View gets detached, input from the Presenter is disregarded (and it's not buffered, so as not to run into any backpressure problems)</p></li>
<li><p>However, once the View gets reattached, it picks up the <em>latest</em> state the Presenter emmitted. In other words, only one state instance is to be buffered at most.</p></li>
</ul>

<p>It would work as follows (assuming the states are of <code>String</code> type for simplicity):</p>

<pre><code>val merged: Observable&lt;String&gt; = ???

val attached = true
val disattached = false        

screenStates.onNext(attached)
fromPresenter.onNext(""state A"")
fromPresenter.onNext(""state B"")

screenStates.onNext(disattached)
fromPresenter.onNext(""state C"") // this won't survive at the end
fromPresenter.onNext(""state D"") // this will ""override"" the previous one.
// as that's the last state from BEFORE the screen is reattached

screenStates.onNext(attached)
// ""state D"" should be replayed at this point, ""state C"" is skipped and lost

fromPresenter.onNext(""state E"")

// what ""merged"" is supposed to have received at this point:
// ""state A"", ""state B"", ""state D"", ""state E""
</code></pre>

<p>I'm not sure what the best, idiomatic solution is. </p>

<p>I tried to implement it as an <code>ObservableTransformer</code>, but I couldn't quite get it right. I believe the transformer should be stateless, whereas my solution gravitated towards explicitly keeping track of what was emmitted and buffering the last element ""manually"" etc., which feels messy and too imperative, so I suppose it's wrong. </p>

<p>I found <a href=""https://github.com/akarnokd/RxJava2Extensions/blob/master/src/main/java/hu/akarnokd/rxjava2/operators/FlowableValve.java"" rel=""nofollow noreferrer"">https://github.com/akarnokd/RxJava2Extensions/blob/master/src/main/java/hu/akarnokd/rxjava2/operators/FlowableValve.java</a>, but the implementation looks very complex and I can't believe it couldn't be done in a simpler manner (I don't need all the flexibility, I only want something that works for the described usecase).</p>

<p>Any insights would be appreciated, including whether there's something else I should take into consideration still, within the context of Android. Also note that I don't use RxKotlin bindings (I may, I just didn't suppose they should be required here).</p>

<p><strong>EDIT:</strong></p>

<p>Below is my current implementation. As I said, I'm not too happy about it because it's explicitly stateful, and I believe this should be achieved declaratively, leveraging some constructs of RxJava.</p>

<p>I needed to merge two streams of different types, and because <code>combineLatest</code> nor <code>zip</code> didn't quite do it, I resorted to a trick, creating a common wrapper for both distinct type of events. It introduces certain overhead again.</p>

<pre><code>sealed class Event
class StateEvent(val state: String): Event()
class LifecycleEvent(val attached: Boolean): Event()

class ValveTransformer(val valve: Observable&lt;Boolean&gt;) : ObservableTransformer&lt;String, String&gt; {
    var lastStateEvent: Event? = null
    var lastLifecycleEvent = LifecycleEvent(false)

    private fun buffer(event: StateEvent) {
        lastStateEvent = event
    }

    private fun buffer(event: LifecycleEvent) {
        lastLifecycleEvent = event
    }

    private fun popLastState(): String {
        val bufferedState = (lastStateEvent as StateEvent).state
        lastStateEvent = null
        return bufferedState
    }

    override fun apply(upstream: Observable&lt;String&gt;): ObservableSource&lt;String&gt; = Observable
            .merge(
                    upstream.map(::StateEvent).doOnNext { buffer(it) }, 
                    valve.distinctUntilChanged().map(::LifecycleEvent).doOnNext { buffer (it) })
            .switchMap { when {
                it is LifecycleEvent &amp;&amp; it.attached &amp;&amp; lastStateEvent != null -&gt;
                    // the screen is attached now, pump the pending state out of the buffer
                    just(popLastState())
                it is StateEvent &amp;&amp; lastLifecycleEvent.attached -&gt; just(it.state)
                else -&gt; empty&lt;String&gt;()
            } }
}
</code></pre>
","168719","","168719","","2017-06-18 20:35:30","2017-07-01 18:25:29","Implementation of a ""valve"" for Observable streams, including buffering the last element emmitted before the valve reopened","<android><rx-java><observable><reactive-programming><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"44627173","1","","","2017-06-19 09:44:48","","2","1277","<p>Is there a better / more idiomatic way to use a <code>Maybe</code> type from JavaRx 2 than <code>flatMap</code> and <code>try/catch</code>? The following example takes a <code>Maybe&lt;User&gt;</code> and tries to book them a random ticket for a flight. If the user doesn't exist, return an empty <code>Observable</code>.</p>

<pre><code>fun bookRandomTicketFor(userId: UUID): Observable&lt;Ticket&gt; {
    val agencies = travelAgents() // Observable&lt;TravelAgency&gt;
    val user = findById(userId) // Maybe&lt;User&gt;
    val location = locate() // Observable&lt;GeoLocation&gt;

    return Observable
            .just(user.toObservable())
            .flatMap { usr -&gt;
                try {
                    usr.zipWith(location, { aUser, location -&gt;
                        agencies
                                .flatMap { agency -&gt;
                                    agency
                                            .search(aUser, location) // Observable&lt;Flight&gt;.
                                            .toList() // Convert to List&lt;Flight&gt;.
                                            .toObservable() // And to Observable&lt;List&lt;Flight&gt;&gt;.
                                            .flatMap { flights -&gt; // So it can be shuffled,
                                                Observable.just( // giving a random order.
                                                        shuffle(flights as MutableList&lt;Flight&gt;)[0]
                                                )
                                            }
                                }.firstElement() // Now take the first randomly shuffled Flight.
                    }).flatMap { flight -&gt;
                        book(user.toObservable(), flight.toObservable())
                    }
                } catch (ex: Exception) {
                    Observable.empty&lt;Ticket&gt;()
                }
            }
            .doOnSubscribe { Logger.log(""Random ticket: start for $userId"") }
            .doOnComplete { Logger.log(""Random ticket: exit for $userId"") }
}
</code></pre>

<p>It seems a bit of a fudge to have to convert the <code>Maybe&lt;User&gt;</code> to an <code>Observable</code> and start with an <code>Observable&lt;Observable&lt;User&gt;&gt;</code> that I can then <code>flatMap</code> and <code>try/catch</code>. Just wondering if there is a neater approach to doing this?</p>
","8086746","","3385212","","2017-06-27 14:01:37","2017-06-27 14:01:37","RxJava2 Maybe return empty Observable if no element","<kotlin><rx-java2><rx-kotlin>","0","1","","","","CC BY-SA 3.0"
"44637593","2","","44617459","2017-06-19 18:33:29","","2","","<p>To combine @TpoM6oH's answer with the original proposal:</p>

<pre><code>val bufferedEvent: Observable&lt;Event&gt; = BehaviorSubject.create()
bufferedEventResult = valve.switchMap( 
     viewEvent -&gt; if (viewEvent) 
                       bufferedEvent 
                  else Observable.never() )
</code></pre>

<p>The <code>switchMap()</code> operator takes care of subscribing and unsubscribing.</p>

<p>You can then split the resulting observable into the requisite states and events, using <code>publish()</code>. I'm not sure what the need for <code>ObservableTransformer</code> is.</p>
","1241193","","1241193","","2017-07-01 18:25:29","2017-07-01 18:25:29","","","","5","","","","CC BY-SA 3.0"
"44640465","1","44640799","","2017-06-19 21:44:56","","3","739","<p>I'm trying to get an example working that uses two different timeout values. An initial larger value for the first emission and then shorter values for all subsequent emissions. The example is converted to Kotlin from Java for RxJava v1x, although I am attempting this is v2x (not sure if that makes any difference). </p>

<p>The problem is that the timeout for the first event doesn't throw a <code>TimeoutException</code>. With the value set below 500ms, I'm expecting a stack trace to be printed, but I get output as if no timeout has occurred (subsequent emissions with timeout set to 40ms results in stack trace as expected). What is wrong with the following example that prevents the initial timeout from succeeding?</p>

<pre><code>fun nextSolarEclipse(after: LocalDate): Observable&lt;LocalDate&gt; {
    return Observable
            .just(
                    LocalDate.of(2016, Month.MARCH, 9),
                    LocalDate.of(2016, Month.SEPTEMBER, 1),
                    LocalDate.of(2017, Month.FEBRUARY, 26),
                    LocalDate.of(2017, Month.AUGUST, 21),
                    LocalDate.of(2018, Month.FEBRUARY, 15),
                    LocalDate.of(2018, Month.JULY, 13),
                    LocalDate.of(2018, Month.AUGUST, 11),
                    LocalDate.of(2019, Month.JANUARY, 6),
                    LocalDate.of(2019, Month.JULY, 2),
                    LocalDate.of(2019, Month.DECEMBER, 26)
            )
            .skipWhile { date -&gt;
                !date.isAfter(after)
            }
            .zipWith(
                    Observable.interval(500, 50, TimeUnit.MILLISECONDS),
                    { date, _ -&gt; date }
            )
}

fun main(args: Array&lt;String&gt;) {
    nextSolarEclipse(LocalDate.now())
            .timeout&lt;Long, Long&gt;(
                    { Observable.timer(400, TimeUnit.MILLISECONDS) },
                    { Observable.timer(40, TimeUnit.MILLISECONDS) }
            )
            .subscribe(
                    { println(it) },
                    { it.printStackTrace() },
                    { println(""Completed"") }
            )

    TimeUnit.MILLISECONDS.sleep(2000)
}
</code></pre>

<p><strong>Edit: 20-Jun-17</strong></p>

<p>With Kotlin 1.1.2-5, using IntelliJ, with the suggested alteration applied, I still get the error. Attempting to run the code anyway results, as I would expect, with:</p>

<p><code>Error:(34, 21) Kotlin: Interface Function does not have constructors</code></p>

<p><a href=""https://i.stack.imgur.com/dM3D1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dM3D1.png"" alt=""Interface Function does not have constructors""></a></p>
","8086746","","8086746","","2017-06-20 13:47:03","2017-06-20 13:47:03","RxKotlin (RxJava2) timeout() doesn't throw TimeoutException","<rx-java><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"44640799","2","","44640465","2017-06-19 22:15:57","","4","","<p>This is yet another case of Kotlin implying you need a function instead of a <code>Observable</code> instance. Try this:</p>

<pre><code>.timeout&lt;Long, Long&gt;(
     Observable.timer(400, TimeUnit.MILLISECONDS),
     Function { Observable.timer(40, TimeUnit.MILLISECONDS) }
)
</code></pre>
","61158","","","","","2017-06-19 22:15:57","","","","6","","","","CC BY-SA 3.0"
"44709940","1","44722241","","2017-06-22 21:54:10","","1","87","<p>Can someone help me find the proper solution for this problem I face? </p>

<ol>
<li>I have a backend service that give me <code>Observables</code> of the data I need, which are <code>Events</code>.</li>
<li>Form the Event I can get an <code>EventGroup</code>, which contains Ids of all events in the same group.</li>
<li>Next I can get all the <code>Event</code>s that are part of this group.</li>
</ol>

<p>However, I get a <code>Observable&lt;List&lt;Observable&lt;Event&gt;&gt;&gt;</code>, where I'd like to get a <code>Observable&lt;List&lt;Event&gt;&gt;</code>. How can I achive this, without actually subscribing to the nested <code>Observables</code>?</p>

<pre><code>val events : Observable&lt;List&lt;Observable&lt;Event&gt;&gt;&gt; = 
   eventProvider.observable
      .flatMap { myBackend.getEventGroup(it.eventGroupId) }
      .map { 
         it.eventIds.map { myBackend.getEvent(it) } 
      }
</code></pre>

<p><strong>TL:DR</strong></p>

<p>How do I get <code>Observable&lt;List&lt;X&gt;&gt;</code> from a <code>Observable&lt;List&lt;Observable&lt;X&gt;&gt;&gt;</code>?</p>
","3108709","","","","","2017-06-23 13:07:37","RxJava1: How to convert Observable<List<Observable<X>>> to Observable<List<X>>","<rx-java><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"44722241","2","","44709940","2017-06-23 13:07:37","","0","","<p>I figured it out, inspired by the answer of @akarnokd. @akarnokd answer expects all sources to be finite, but mine are all infinite. However I can live with partially infinite as well.</p>

<p>I need my resulting <code>Observable</code> to be infinite, because I want to receive a new list of <code>Events</code> whenever the <code>eventProvider.observable</code> emits something. However, I'm ok with the events I get back via <code>myBackend.getEvent(it)</code> to behave as a finite source.</p>

<pre><code>val events : Observable&lt;List&lt;Event&gt;&gt; = 
   eventProvider.observable
      .flatMap { myBackend.getEventGroup(it.eventGroupId) }
      .map { it.eventIds.map { myBackend.getEvent(it) } }
      .map { it.toObservable().flatMap { it.first() }.toList() }
      .flatMap { it }
</code></pre>
","3108709","","","","","2017-06-23 13:07:37","","","","0","","","","CC BY-SA 3.0"
"44883593","1","","","2017-07-03 10:43:06","","8","23337","<p>Am using kotlin for developing the application.Now i want to get JSON data from server. </p>

<p>In java am implemented Asyntask as well as  Rxjava for read JSON from Url . Am also search in google but i cant get proper details for my requirement.</p>

<p>How can i  read JSON from Url  using kotlin?</p>
","3710865","","","","","2021-01-08 00:10:27","How to read JSON from Url using kotlin Android?","<android><kotlin><rx-kotlin>","7","0","2","","","CC BY-SA 3.0"
"44997284","1","44997285","","2017-07-09 14:11:35","","0","656","<p>Docs in the RxKotlin repository on GitHub doesn't specify a way to explicitly depend on the latest RxJava versionn.</p>

<p>If we see the <code>build.gradle</code> file of the library, it as of now uses <code>compile 'io.reactivex.rxjava2:rxjava:2.1.0'</code></p>

<p>But what if we want to keep up with the latest RxJava releases and not the one present in the library.</p>
","4173071","","","","","2017-07-10 05:23:06","How to specify the version of RxJava when using RxKotlin?","<android><rx-java><kotlin><rx-java2><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"44997285","2","","44997284","2017-07-09 14:11:35","","1","","<p>You can override the version of RxJava in your projects <code>build.gradle</code>.</p>

<p>The specified version of RxJava will be chosen (and override RxKotlin's) if you just explicitly specify it like this in Gradle/Maven:</p>

<pre><code>dependencies {
    compile 'io.reactivex.rxjava2:rxjava:2.1.1'
    compile 'io.reactivex.rxjava2:rxkotlin:2.1.0'
}
</code></pre>

<p>This is also stated in the RxAndroid readme file.
I had a little chat with one of the contributors of the RxKotlin and he said that just like RxAndroid, they also internally use the same policy.</p>
","4173071","","","","","2017-07-09 14:11:35","","","","0","","","","CC BY-SA 3.0"
"45118207","1","45126490","","2017-07-15 12:28:01","","-2","229","<p>I using rxjava 2 in kotlin but it is not compiling how should i resolve it ?</p>

<pre><code>var emailField = name.textChanges().skipInitialValue().toFlowable(BackpressureStrategy.LATEST)
var passField = password.textChanges().skipInitialValue().toFlowable(BackpressureStrategy.LATEST)

Flowable.combineLatest(emailField,passField, BiFunction { t1, t2 -&gt;  t1.isNotEmpty() &amp;&amp; t2.isNotEmpty()    })
</code></pre>

<p><a href=""https://i.stack.imgur.com/HRSUu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/HRSUu.png"" alt=""enter image description here""></a></p>
","3700517","","","","","2017-07-16 08:19:06","Rxjava with kotlin","<android><kotlin><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"45126490","2","","45118207","2017-07-16 08:19:06","","2","","<p>i was missing generic params for combineLatest</p>

<pre><code> BiFunction&lt;T1, T2, R&gt; { t1, t2 -&gt; combineFunction(t1,t2) }
</code></pre>
","3700517","","","","","2017-07-16 08:19:06","","","","0","","","","CC BY-SA 3.0"
"45195799","1","45200122","","2017-07-19 16:09:42","","1","1190","<p>I am writing following code snippet to fetch list of saved food from firebase database and then using that list, I am again fetching individual food details from firebase database.</p>

<p>Following code working fine, except i am unable to figure out how to let second flatMap know that emission of first flatMap has finished(All food list has been processed). So I am unable to call <code>onCompleted()</code> method hence unable to detect when whole process finishes.</p>

<p>Have a look at comments in following snippet:</p>

<pre><code>Observable.create&lt;List&lt;PersonalizedFood&gt;&gt; {

            FirebaseDTDatabase.getSavedDietFoodQuery(user.uid).addListenerForSingleValueEvent(object : ValueEventListener {
                override fun onCancelled(p0: DatabaseError?) {

                }

                override fun onDataChange(p0: DataSnapshot?) {
                    val list = ArrayList&lt;PersonalizedFood&gt;()
                    p0?.let {
                        for (dateObject in p0.children) {
                            for (foodItem in dateObject.children) {
                                val food = foodItem.getValue(FBPersonalizedFood::class.java) as FBPersonalizedFood
                                list.add(PersonalizedFood(food))
                            }
                        }
                    }
                    it.onNext(list)
                    it.onCompleted()
                }
            })
        }.subscribeOn(Schedulers.io()).flatMap {
            Observable.from(it) // returning a Observable that emits items of list (""it"" is the list here) 
        }.observeOn(Schedulers.io()).flatMap {
        // How does this flatMap know that emission of all item has been finished so that onCompleted() method could be called.
            personalizedFood -&gt;

            Observable.create&lt;Boolean&gt;{
                FirebaseDTDatabase.getFoodListReference(personalizedFood.foodId).addListenerForSingleValueEvent(object :ValueEventListener{
                    override fun onCancelled(p0: DatabaseError?) {
                        it.onError(p0?.toException())
                    }

                    override fun onDataChange(p0: DataSnapshot?) {
                        if(p0 != null) {
                            val food = p0.getValue(FBFood::class.java)!!
                            val repo = LocalFoodRepository()
                            doAsync {
                                repo.insertFood(this@LoginActivity, Food(food.foodId, food.foodName, food.foodDesc))
                                repo.insertServingDetails(this@LoginActivity, food.servingList.map { it.component2() })
                                repo.saveFood(this@LoginActivity, personalizedFood)
                                it.onNext(true)
                            }

                        }else {
                            it.onNext(false)
                        }
                    }

                })
            }
        }.observeOn(Schedulers.io()).doOnCompleted{
            dismissProgressDialog()
            finish()
        }.doOnError{
            it.printStackTrace()
            dismissProgressDialog()
            finish()
        }.subscribe()
</code></pre>

<p>Thanks.</p>
","5039950","","","","","2017-07-19 20:08:50","RxAndroid, How to detect if observable has finished emission","<android><kotlin><rx-java><rx-android><rx-kotlin>","1","3","","","","CC BY-SA 3.0"
"45200122","2","","45195799","2017-07-19 20:08:50","","2","","<p>The <code>Observable</code> from the <code>flatMap</code> knows ""when to all of the items have been finished"" when all of the observables emitted by it have called <code>onCompleted()</code>. The second <code>flatMap</code> in your code never calls <code>onCompleted()</code> because none of the observables it creates call <code>onCompleted()</code>.</p>

<p>You should call <code>onCompleted()</code> in your <code>onDataChange()</code> method. Since each of the observables created in the <code>flatMap</code> only emit one item, it can be called directly after the <code>onNext()</code> method:</p>

<pre><code>override fun onDataChange(p0: DataSnapshot?) {
    if(p0 != null) {
        val food = p0.getValue(FBFood::class.java)!!
        val repo = LocalFoodRepository()
        doAsync {
            repo.insertFood(this@LoginActivity, Food(food.foodId, food.foodName, food.foodDesc))
            repo.insertServingDetails(this@LoginActivity, food.servingList.map { it.component2() })
            repo.saveFood(this@LoginActivity, personalizedFood)
            it.onNext(true)
            it.onCompleted()
        }
    } else {
        it.onNext(false)
        it.onCompleted()
    }
}
</code></pre>
","5115932","","","","","2017-07-19 20:08:50","","","","6","","","","CC BY-SA 3.0"
"45234134","1","","","2017-07-21 09:32:04","","-2","1165","<p>How can I make it in kotlin using for loop?</p>

<pre><code>for (double i = 0; i &lt; 10.0; i += 0.25) {
    System.out.println(""value is:"" + i);
}
</code></pre>
","7602736","","4467208","","2017-07-21 09:32:48","2020-12-05 21:01:18","How do i make a loop like mentioned below in kotlin programming language?","<android><android-studio><kotlin><rx-kotlin><kotlin-interop>","4","4","","","","CC BY-SA 3.0"
"45294524","1","45371201","","2017-07-25 05:23:01","","20","23184","<p>I initialize my variable like this:-</p>

<pre><code> val user: BehaviorSubject&lt;User?&gt; user = BehaviorSubject.create()
</code></pre>

<p>But I can't do this. IDE throws an error:-</p>

<pre><code>user.onNext(null)
</code></pre>

<p>And doing this, IDE says u will never be null:-</p>

<pre><code>user.filter( u -&gt; u!=null)
</code></pre>
","4908259","","4908259","","2017-07-25 05:36:33","2021-05-19 17:50:57","How to pass null to an Observable with nullable type in RxJava 2 and Kotlin","<android><kotlin><rx-java><rx-java2><rx-kotlin>","7","7","1","","","CC BY-SA 3.0"
"45371201","2","","45294524","2017-07-28 10:33:32","","3","","<p>Thank you very much for all your answers but I ultimately went with this solution:-</p>

<pre><code>class UserEnvelope(val user:User?) {}
</code></pre>

<p>And using this in the observables.</p>

<p>This best suited my requirements.</p>

<p>I am new to Kotlin so I don't know how to use Optionals. But from what I understand, I would have to typecast it to User type everytime I need to observe the values right?</p>
","4908259","","1000551","","2019-03-07 11:34:46","2019-03-07 11:34:46","","","","1","","","","CC BY-SA 4.0"
"45380773","1","45382149","","2017-07-28 19:09:18","","1","235","<p>I've got a buffered stream, waiting for a predetermined amount of silence time, before publishing a list of elements that have been buffered:</p>

<pre><code>INTEGERS
     .share()
     .buffer(INTEGERS.debounce(DEBOUNCE_TIME,TimeUnit.MILLISECONDS,scheduler))
     .map { durations -&gt;
       ... 
     }
</code></pre>

<p>I'd like to make <code>DEBOUNCE_TIME</code> dynamically adjust depending on the average of the buffered items, but I'm having a hard time figuring out how to achieve this. </p>
","3692626","","3692626","","2017-07-28 19:14:59","2017-07-28 20:46:54","How to dynamically scale debounce of burst emission stream?","<java><kotlin><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"45382149","2","","45380773","2017-07-28 20:46:54","","1","","<p>You could defer the debounce, take one item of it and trigger repeat once the new debounce value has been determined:</p>

<pre><code>int DEBOUNCE_TIME = 100;
AtomicInteger debounceTime = new AtomicInteger(DEBOUNCE_TIME);
PublishSubject&lt;Integer&gt; mayRepeat = PublishSubject.create();

AtomicInteger counter = new AtomicInteger();

Observable&lt;Integer&gt; INTEGERS =
        Observable.fromArray(10, 20, 200, 250, 300, 550, 600, 650, 700, 1200)
        .flatMap(v -&gt; Observable.timer(v, TimeUnit.MILLISECONDS)
                .map(w -&gt; counter.incrementAndGet()));

INTEGERS.publish(o -&gt;
        o.buffer(
            Observable.defer(() -&gt;
                o.debounce(
                    debounceTime.get(), TimeUnit.MILLISECONDS)
            )
            .take(1)
            .repeatWhen(v -&gt; v.zipWith(mayRepeat, (a, b) -&gt; b))
        )
    )
    .map(list -&gt; {
        int nextDebounce = Math.min(100, list.size() * 100);
        debounceTime.set(nextDebounce);
        mayRepeat.onNext(1);
        return list;
    })
    .blockingSubscribe(System.out::println);
</code></pre>

<p>This prints:</p>

<pre><code>[1, 2]
[3, 4, 5]
[6, 7, 8, 9]
[10]
</code></pre>
","61158","","","","","2017-07-28 20:46:54","","","","1","","","","CC BY-SA 3.0"
"45404606","1","45405457","","2017-07-30 20:53:25","","0","930","<p>I have a custom Android TextView which shows the amount of time left in a game via a CountDownTimer</p>

<pre><code>class CountdownTextView(context: Context, attrs: AttributeSet) : TextView(context, attrs) {

    private lateinit var countDownTimer: CountDownTimer
    private lateinit var onFinishObservable: Observable&lt;Unit&gt;

    fun setTime(initTime: Int) {
        this.text = ""$initTime:00""
        countDownTimer = object : CountDownTimer((initTime *1000).toLong(), 1000) {
            override fun onTick(millisUntilFinished: Long) {
            val minutes = millisUntilFinished / 60000
            val seconds = (millisUntilFinished % 60000) / 1000
            if (seconds / 10 &gt; 0) {
                text = ""$minutes:${(millisUntilFinished % 60000) / 1000}""
            } else {
                text = ""$minutes:0${(millisUntilFinished % 60000) / 1000}""
            }
        }

        override fun onFinish() {

        }
    }


    fun startCountdown() {
        countDownTimer.start()
    }
}
</code></pre>

<p>How do I set up an observable that emits a value when the countDownTimer's onFinish() method is called? I need this so that on the main activity, I can subscribe to that observable and perform the necessary actions when the countdowntimer expires. </p>
","6407499","","","","","2017-07-30 22:49:16","How to notify Observable when CountdownTimer is finished","<android><kotlin><rx-java><rx-kotlin>","1","0","2","","","CC BY-SA 3.0"
"45405457","2","","45404606","2017-07-30 22:49:16","","0","","<p>You could provide a <a href=""https://github.com/ReactiveX/RxJava/wiki/Subject"" rel=""nofollow noreferrer"">Subject</a>.</p>

<pre><code>val onFinishObservable = CompletableSubject.create()

override fun onFinish() {
    onFinishObservable.onComplete()
}
</code></pre>

<p>Or you could use Rx for the timer instead of <code>CountDownTimer</code>.</p>

<pre><code>fun countDownTimer(
        time: Long, timeUnit: TimeUnit = TimeUnit.MILLISECONDS,
        tick: Long = 1, tickUnit: TimeUnit = TimeUnit.MILLISECONDS
): Observable&lt;Long&gt; {
    val timeNanos = timeUnit.toNanos(time).also { require(it &gt;= 0) }
    val tickNanos = tickUnit.toNanos(tick).also { require(it &gt; 0) }
    val ticks = timeNanos / tickNanos
    return Observable
        .intervalRange(
            1L, ticks, timeNanos % tickNanos, tickNanos, TimeUnit.NANOSECONDS)
        .map { ticks - it }
        .startWith(ticks)
}

fun start(time: Long, timeUnit: TimeUnit = TimeUnit.SECONDS): Completable {
    timerSubscription?.dispose()
    val timer = countDownTimer(time, timeUnit, tickUnit = TimeUnit.SECONDS)
    timerSubscription = timer.subscribe {
        text = String.format(""%d:%02d"", it / 60, it % 60)
    }
    return timer.ignoreElements()
}
</code></pre>

<p>Either way, the caller can subscribe to that <code>Completable</code>.</p>
","20713","","","","","2017-07-30 22:49:16","","","","3","","","","CC BY-SA 3.0"
"45441074","1","45502088","","2017-08-01 14:48:34","","1","1582","<p>In order to improve my skills in kotlin, Rx, Retrofit2 I've decided to do a demo project.
The demo project consist to display posts in a recycler view then display details of the post in a detail activity.<br>
I've encountered difficulties displaying data coming from different api call: the user name, the title, the body of the post and the number of comments of the post.</p>

<p>My problem is that I would like to do multiple request and then have all the data needed in order to display them in the detail activity. Which mean doing a call that give me the user name and then a call that give me the number of comments for the post. The title and the body of the post are coming from a request done in the main activity I just transmit it with the bundle to the detail activity.</p>

<p>Api calls:<br>
// return the comments for the post 1<br>
<a href=""http://jsonplaceholder.typicode.com/comments?postId=1"" rel=""nofollow noreferrer"">http://jsonplaceholder.typicode.com/comments?postId=1</a> </p>

<p>// return the information of the user 2<br>
<a href=""http://jsonplaceholder.typicode.com/users/2"" rel=""nofollow noreferrer"">http://jsonplaceholder.typicode.com/users/2</a>  </p>

<p>// call used to display posts in the main activity<br>
http:/jsonplaceholder.typicode.com/posts</p>

<p>I'm still new on Rx, I was thinking to use a flatMap but I don't know how to use it with Flowable in kotlin..   </p>

<pre><code>var post = viewModel.getPost()
var userStream: Flowable&lt;User&gt; = postService.getUser(post.userId)
var commentsByPostIdCall: Flowable&lt;List&lt;Comment&gt;&gt; = postService.getCommentsByPostId(post.id)

userStream.subscribeOn(Schedulers.io())
        .subscribe(object : Subscriber&lt;User&gt; {
            override fun onError(t: Throwable?) {
                Log.d(this.toString(), "" Read of users failed with the following message: "" + t?.message);
            }

            override fun onNext(user: User) {
                userTextView.text = user.name
                title.text = post.title
                body.text = post.body
            }

            override fun onComplete() {
            }

            override fun onSubscribe(s: Subscription?) {
                if (s != null) {
                    s.request(1)
                }
            }
        })
</code></pre>

<p>I have put the second call in a method <em>getNumberComments</em>:</p>

<pre><code>    private fun getNumberComments(commentsByPostIdCall: Flowable&lt;List&lt;Comment&gt;&gt;): Int {
    var listComments = listOf&lt;Comment&gt;()
    var listCommentSize = 0

     commentsByPostIdCall
             .subscribeOn(Schedulers.io())
             .subscribe(object : Subscriber&lt;List&lt;Comment&gt;&gt; {
                override fun onError(t: Throwable?) {
                    Log.d(this.toString(), "" Read of comments failed with the following message: "" + t?.message);
                }

                override fun onNext(comment: List&lt;Comment&gt;) {
                    listComments = comment
                }

                override fun onComplete() {
                    print(""onComplete!"")
                    listCommentSize = listComments.size
                }

                override fun onSubscribe(s: Subscription?) {
                    if (s != null) {
                        s.request(1)
                    }
                }
            })
    return listCommentSize

}
</code></pre>

<p>Other think that I've noticed is that sometimes the stream didn't go to onComplete, sometimes it remains blocked on onNext. Don't understand why?</p>

<p>Any help will be much appreciate! Thanks a lot :)</p>
","5065580","","5065580","","2017-08-04 15:07:27","2017-08-04 15:07:27","Multiple retrofit2 requests using Flowable in Kotlin","<android><kotlin><retrofit2><rx-kotlin>","2","4","","","","CC BY-SA 3.0"
"45489971","1","","","2017-08-03 16:34:05","","4","1629","<p>I am a beginner with rxjava/rxkotlin/rxandroid.</p>

<p>I need to deal with three diferent async-calls in a sequence.
The problem is that the first step returns a <code>Single&lt;LocationResult&gt;</code>, the second a <code>Completable</code>and the third again a <code>Completable</code>.</p>

<p>(Single -> Completable -> Completable)</p>

<p>The problem is now that the last <code>Completable</code> depends on the data of the first <code>Single</code></p>

<p>My current solution:</p>

<p>I think this is a bad solution, but I don't know how to do this right.</p>

<pre><code>val ft = FenceTransaction(applicationContext, apiClient)
        stream
            .flatMap { locationResult -&gt;
                ft.removeAll()
                return@flatMap ft.commit().toSingle({ return@toSingle locationResult })
            }
            .flatMapCompletable {
                ft.recycle()
                ft.setZone(it.location.longitude, it.location.latitude, ZONE_RADIUS)
                val dots = DotFilter().getFilteredDots()
                for (dot in dots) {
                    ft.addDot(dot)
                }
                return@flatMapCompletable ft.commit()
            }
            .subscribeBy(
                onComplete = {
                    ""transaction complete"".logi(this)
                },
                onError = {
                    ""transaction error"".logi(this)
                })
</code></pre>

<p>Is this approch the correct way to do it?</p>

<p>And how should I dispose the <code>Completeables</code>?
Generally when should I dispose <code>Observables</code>?</p>
","6255743","","6255743","","2017-08-03 16:48:11","2018-04-24 19:13:14","How to chain ""Single - Completeable - Completable"" in rxkotlin?","<android><rx-java2><reactivex><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"45502088","2","","45441074","2017-08-04 08:41:15","","4","","<p>this is how i would solve it:  </p>

<pre><code>Flowable.zip&lt;User, Comments, Pair&lt;User, Comments&gt;&gt;(
      postService.getUser(postId),
      postService.getCommentsByPostId(postId),
      BiFunction { user, comments -&gt; Pair(user, comments) })
      .subscribeOn(Schedulers.io())
      .observeOn(AndroidSchedulers.mainThread())
      .bindToLifecycle(this)
      .map { (first, second) -&gt; Triple(first, second, ExtraDatasFromSomewhere) }
      .subscribe({
        Log.d(""MainActivity"", ""OnNext"")
      }, {
        Log.d(""MainActivity"", ""OnError"")
      }, {
        Log.d(""MainActivity"", ""OnComplete"")
      })
</code></pre>

<p>Use the <code>zip</code> or <code>zipWith</code> functions to achieve your goal if the retrofit2 calls dont depent on each other.<br>
You can find out more here:<br>
RxZip() : <code>http://reactivex.io/documentation/operators/zip</code> . </p>

<p>You can easily map the data from the server with the mainActivity data together like this:</p>

<pre><code>.map { (first, second) -&gt; Triple(first, second, ExtraDatasFromSomewhere) }
</code></pre>

<p>Kotlin has a very beautiful syntax for lambda functions so i would encourage you to use them with the specific subscribe function:<br>
subscribe() : <code>http://reactivex.io/RxJava/javadoc/io/reactivex/Flowable.html#subscribe(io.reactivex.functions.Consumer,%20io.reactivex.functions.Consumer,%20io.reactivex.functions.Action)</code> </p>

<p><strong>Also very important to note</strong> that i did not use only the raw Rxjava2 lib. i used the libs below:
<a href=""https://github.com/ReactiveX/RxAndroid"" rel=""nofollow noreferrer""><strong>RxAndroid</strong></a><br>
for <code>observeOn(AndroidSchedulers.mainThread())</code> to get the mainThread. This is because you manipulated the UI without specifying the thread you subscribed on. With this you can achieve that your subscription will be handled on the mainThread.<br>
<a href=""https://github.com/trello/RxLifecycle"" rel=""nofollow noreferrer""><strong>RxLifecycle</strong></a><br>
for <code>.bindToLifecycle(this)</code> this will make sure you don't leave memory leak if the activity is closed but your retrofit2 call did not finished</p>
","4748738","","","","","2017-08-04 08:41:15","","","","1","","","","CC BY-SA 3.0"
"45517571","1","45520704","","2017-08-05 02:09:10","","1","3180","<p>I am trying to build a presenter that calculates some events within some time period, shows a loading only the first time of loading, and updates the ui when it is done. Because the events can be updated via multiple ways (such as user preferences) I need to be able to tell the presenter that the events were updated and that it has to refresh them again. Here is what I have right now:</p>

<pre><code>                      subject
                            .map&lt;List&lt;UpcomingRowViewModel&gt;&gt; {
                                provider.calculateEventsBetween(TimePeriod.aYearFrom(firstDay))
                            }
                            .doOnSubscribe {
                                view.showLoading()
                            }
                            .observeOn(resultScheduler)
                            .subscribeOn(workScheduler)
                            .subscribe { upcomingRowViewModels -&gt;
                                view.display(upcomingRowViewModels)
                            }
                      subject.onNext(TRIGGER)
</code></pre>

<p>The subject is a <code>PublishSubject</code> of Int. I do the <code>onNext()</code> right after the subscription because I want the data to be refreshed as soon as I subscribe to them. </p>

<p>The above code works wonders in my unit tests and also only when I am running it on a device <em>with the debugger attached</em>. If I just run it (without any debugger), it reaches the <code>view.showLoading()</code> part, but never the <code>provider.calculateEventsBetween(TimePeriod.aYearFrom(firstDay)</code> so the UI gets 'stuck' with the loading. </p>

<p>Any ideas?</p>
","1315110","","","","","2017-08-05 10:10:50","onNext() never gets called on a PublishSubject","<rx-java><rx-kotlin><publishsubject>","1","0","","","","CC BY-SA 3.0"
"45520704","2","","45517571","2017-08-05 10:10:50","","6","","<p>The likely reason you don't see the consumer called is <code>.subscribeOn(workScheduler)</code>. By applyint this to a <code>Subject</code>, which by itself has no practical use as there are no subscription side-effects when subscribing to a <code>Subject</code>, you delay the subscription to the <code>Subject</code> just enough that the <code>onNext</code> call won't find any observers at that moment.</p>

<p>What you probably want is something like this:</p>

<pre><code>subject
    .observeOn(resultScheduler)             // &lt;--------------- (1)
    .doOnNext {
        view.showLoading()
    }
    .observeOn(workScheduler)               // &lt;--------------- (2)
    .map&lt;List&lt;UpcomingRowViewModel&gt;&gt; {
        provider.calculateEventsBetween(
            TimePeriod.aYearFrom(firstDay))
    }
    .observeOn(resultScheduler)             // &lt;--------------- (3)
    .subscribe { upcomingRowViewModels -&gt;
        view.display(upcomingRowViewModels)
    }
subject.onNext(TRIGGER)
</code></pre>

<p>Instead of <code>doOnSubscribe</code>, which gets executed once, (1) makes sure when there is work to do, the subject's onNext emission will trigger the loading indicator on the main thread (assuming resultScheduler is <code>AndroidSchedulers.mainThread</code> in non-tests). Then you'd want to perform the mapping off the main thread and thus (2) moves the item onto the background thread. Once the mapping has happened, the resulting item is then moved onto the main thread again at (3) where your view can display it.</p>
","61158","","","","","2017-08-05 10:10:50","","","","2","","","","CC BY-SA 3.0"
"45737107","1","45931105","","2017-08-17 13:55:40","","1","4081","<p>I am using <code>retorift</code> to hit <code>getAricle</code> api and get list of articles related to the user. <code>getArticle</code> api will throw error if token passed is expired if so then I have to call <code>refreshToken</code> api to get new token then again I have to call the <code>getArticle</code> api </p>

<pre><code> ApiController.createRx().getArticle(token)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ response -&gt; toast(response.body().url) }, { e -&gt;
                println(e.printStackTrace())
                if(e is HttpException &amp;&amp; e.code() in  arrayOf(401,403)){                      
                   //Here I want to call refresh tolken api
                   toast(""Auth error"")
                }
                else
                   toast(R.string.something_went_wrong)
            })
</code></pre>

<p><strong>Edit</strong></p>

<p>Even though given answers showed some direction but those are not a direct answer to my question. This is how solved it but I feel this can be refactored into much better code</p>

<pre><code>ApiController.createRx().getArticle(Preference.getToken())
            .flatMap { value -&gt;
                if (value.code() in arrayOf(403, 401)) {
                    ApiController.refreshToken()
                    ApiController.createRx().getArticle(Preference.getToken())
                } else Observable.just(value)
            }
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ response -&gt; println(""Success"") }, { e -&gt;
                e.printStackTrace()
                toast(R.string.something_went_wrong)
            })



fun refreshToken() {
        val token:String?=ApiController.createRx().refreshToken(Preferences.getRefreshToken()).blockingFirst()?.body()?.token
        if (token != null) Preferences.setAuthToken(token)
    }
</code></pre>

<p><strong>EDIT</strong></p>

<p>I refactored my code to little more cleaner version</p>

<pre><code>Observable.defer { ApiController.createRx().getArticle(Preferences.getToken()) }
            .flatMap {
                if (it.code() in arrayOf(401, 403)) {
                    ApiController.refreshToken()
                    Observable.error(Throwable())
                } else Observable.just(it)
            }
            .retry(1)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({println(""Success"") }, {
              it.printStackTrace()
              toast(R.string.something_went_wrong)
            })



 fun refreshToken() {
        var token: String? = null
        try {
            token = createRx().refreshToken(Preferences.getRefreshToken()).blockingFirst().body()!!.token
        } catch (e: Exception) {
            throw e
        }
        println(""saving token"")
        if (token != null) Preferences.setAuthToken(token)
    }
</code></pre>

<p><strong>EDIT</strong></p>

<p>Please check my answer for the final refactored code</p>
","2085698","","2085698","","2017-08-29 05:17:22","2017-08-29 05:24:02","RxJava: Execute second observables only if first one throws an error and repeat from the first","<android><rx-java><retrofit2><rx-java2><rx-kotlin>","4","4","","","","CC BY-SA 3.0"
"45826626","1","45827707","","2017-08-22 20:42:18","","1","1498","<p>I have some methods</p>

<pre><code>Maybe&lt;Foo&gt; getLocalFoo()
Single&lt;List&lt;Foo&gt;&gt; getFooFromInternet()
</code></pre>

<p>And want to check local item and if it's empty then fetch that item from network for example.</p>

<pre><code>storage
            .getLocalFoo()
            .switchIfEmpty { network.getFooFromInternet().map { it[0] }.toMaybe() }
            .subscribe({}, {})
</code></pre>

<p>But seens that code doesn't execute <em>network.getBarcodeTemplates()</em> this function.  </p>
","2093032","","2093032","","2017-08-23 08:02:40","2017-08-23 08:02:40","SwitchIfEmpty not executing maybesource inside","<android><rx-java><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"45827707","2","","45826626","2017-08-22 22:05:16","","3","","<p>Try with <code>(</code> instead of <code>{</code> in the <code>switchIfEmpty</code> line: </p>

<pre><code>.switchIfEmpty ( network.getFooFromInternet().map { it[0] }.toMaybe() )
</code></pre>
","61158","","","","","2017-08-22 22:05:16","","","","1","","","","CC BY-SA 3.0"
"45834989","1","","","2017-08-23 08:52:07","","3","1063","<p>Let's take two methods written with Rx:</p>

<pre><code>Maybe&lt;Foo&gt; getFooFromLocal
Single&lt;Foo&gt; getFooFromNetwork
</code></pre>

<p>I want to write a chain when we check our local storage for <em>Foo</em>. If we don't have any <em>Foo</em> we should get it from the network then save it to the local storage and again get it from local storage and pass it to our subscriber. </p>

<pre><code>storage
            .getFooFromLocal()
            .switchIfEmpty(network.getFooFromNetwork().map { it[0] }
                    .flatMapCompletable { storage.saveFoo(it) }
                    .andThen(storage.getFooFromLocal()))
                    .subscriber(/**/)
</code></pre>

<p>The problem is that <code>andThen</code> part completes before completable passed into <code>flatMapCompletable</code>. I found out that I can get rid of this problem if I wrap into <code>Maybe.defer{}</code>. But according to the documentation of <code>andThen</code>
it </p>

<blockquote>
  <p>Returns a <code>Maybe</code> which will subscribe to this Completable.</p>
</blockquote>

<p>And maybe is already</p>

<blockquote>
  <p>Represents a <strong>deferred</strong> computation and emission of a maybe value or exception </p>
</blockquote>

<p>So the question is why my <code>andThen</code> part run before completable finished. And what is the best and elegant way to write such chains. </p>

<p>Calls log :</p>

<pre><code>06:05:58.803 getFooFromLocal
06:05:58.804 getFooFromLocal
06:05:58.804 getFooFromNetwork
06:05:59.963 saveFoo
</code></pre>
","2093032","","2093032","","2017-08-23 13:10:22","2017-08-23 13:29:19","AndThen executes before completable finished","<android><rx-java><rx-kotlin>","1","4","","","","CC BY-SA 3.0"
"45870757","1","45871210","","2017-08-24 20:57:23","","0","290","<p>The question is about RxJava2. </p>

<p>Noticed that zipping <code>Throwable</code> that comes from <code>retryWhen</code> with <code>range</code> emits all items from <code>Observable.range</code> before zipper function has been applied. Also, <code>range</code> emits sequence even if <code>zipWith</code> wasn't called. For example this source code </p>

<pre><code>Observable.create&lt;String&gt; {
        println(""subscribing"")
        it.onError(RuntimeException(""always fails""))
    }
    .retryWhen {
        it.zipWith(Observable.range(1, 3).doOnNext { println(""range $it"") },
                BiFunction { t: Throwable, i: Int -&gt; i })
                .flatMap {
                    System.out.println(""delay retry by $it + second(s)"")
                    Observable.timer(it.toLong(), TimeUnit.SECONDS)
                }
    }./*subscribe*/
</code></pre>

<p>gives the following result </p>

<pre><code> range 1
 range 2
 range 3
 subscribing
 delay retry by 1 + second(s)
 subscribing
 delay retry by 2 + second(s)
 subscribing
 delay retry by 3 + second(s)
 subscribing
 onComplete
</code></pre>

<p>Replacing <code>onError</code> in <code>observable</code> creation also don't eliminate emitting <code>range</code> items. So the question is why it's happening as <code>Range</code> is cold.</p>
","2093032","","61158","","2017-08-24 21:26:48","2017-08-24 21:32:36","Using range in zipWith also emits all items from range sequence before zipper function applied","<reactive-programming><rx-java2><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"45871210","2","","45870757","2017-08-24 21:32:36","","1","","<p><code>Observable</code>s in 2.x don't have backpressure thus a <code>range</code> operator will emit all its items as soon as it can. Your case, however, can use a normal counter incremented along the error notification of the retry handler:</p>

<pre><code>source.retryWhen(e -&gt; {
    int[] counter = { 0 };
    return e.takeWhile(v -&gt; ++counter[0] &lt; 4)
            .flatMap(v -&gt; Observable.timer(counter[0], TimeUnit.SECONDS));
})
</code></pre>
","61158","","","","","2017-08-24 21:32:36","","","","0","","","","CC BY-SA 3.0"
"45872463","1","45872598","","2017-08-24 23:43:47","","0","735","<p>I have a data flow like this:</p>

<pre><code>Observable
    .fromFuture(
        CompletableFuture.supplyAsync { // First remote call returns Future&lt;List&lt;Type&gt;&gt;
            listOf(1, 2, 3, 57005, 5)
        },
        Schedulers.computation()
    )
    .flatMap { it.toObservable() } // I turn that list into a stream of single values to process them one by one
    .map {
        CompletableFuture.supplyAsync { // This remote call may fail if it does not like the input. I want to skip that failures and continue the stream like the fail never occurred.
            if (it == 0xDEAD) {
                throw IOException(""Dead value!"")
            }

            it
        }
    }
    .flatMap {
        Observable.fromFuture(it) // Turn that Futures into a stream of Observables once again
    }
    .doOnNext {
        println(it) // Debug
    }
    .blockingSubscribe()
</code></pre>

<p>I've replaced business logic (that actually return <code>Future</code>s) with <code>CompletableFuture.supplyAsync</code>.
And, yes, this is Kotlin, but I guess you got the intent.</p>

<p>When I comment ""dead"" value (<code>57005</code>, <code>0xDEAD</code>) the output is:</p>

<pre><code>1
4
9
25
</code></pre>

<p>But if that ""dead"" value appears in the stream, it fails:</p>

<pre><code>1
4
9
Exception in thread ""main"" java.lang.RuntimeException: java.util.concurrent.ExecutionException: java.io.IOException: Dead value!
    at io.reactivex.internal.util.ExceptionHelper.wrapOrThrow(ExceptionHelper.java:45)
    at io.reactivex.internal.operators.observable.ObservableBlockingSubscribe.subscribe(ObservableBlockingSubscribe.java:86)
    at io.reactivex.Observable.blockingSubscribe(Observable.java:5035)
    at by.dev.madhead.rx.TestKt.main(test.kt:41)
Caused by: java.util.concurrent.ExecutionException: java.io.IOException: Dead value!
    at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:357)
    at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1895)
...
</code></pre>

<p>I'm a newbie in RX, so quickly googled for a solution: <code>onExceptionResumeNext</code>: <code>Observable.fromFuture(it)</code> --> <code>Observable.fromFuture(it).onExceptionResumeNext { Observable.empty&lt;Int&gt;() }</code>. But now my application hangs forever (after producing the output I expect).
Looks like the stream never ends.</p>

<p>Should I ""shutdown"" that <code>Observable</code> somehow or what?
Or, more generally, is it a good approach when working with RX?
Should I rethink it in another way?</p>
","750510","","750510","","2018-12-18 01:14:32","2018-12-18 01:14:32","How to skip exceptions silently in RxJava2?","<rx-java><reactive-programming><rx-java2><rx-kotlin><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"45872598","2","","45872463","2017-08-25 00:04:05","","3","","<p>Swallow exceptions like this:</p>

<pre><code> Observable.fromFuture(it).onErrorResumeNext(Observable.empty())
</code></pre>
","397786","","","","","2017-08-25 00:04:05","","","","3","","","","CC BY-SA 3.0"
"45931105","2","","45737107","2017-08-29 05:12:12","","0","","<p>I solved my problem after reading more about <code>RxJava</code> and this is how I implemented it.
First of all will <code>retrofit</code> throw 4xx error to <code>onError</code> or <code>onNext\onSuccess</code> depends on how we define it.
Ex:</p>

<p><code>@GET(""content"")
 fun getArticle(@Header(""Authorization"") token: String):Single&lt;Article&gt;</code></p>

<p>this will throw all the 4xx errors to <code>onError</code> and instead of <code>Single&lt;Article&gt;</code> if you define it as <code>Single&lt;Response&lt;Article&gt;&gt;</code> then all the response from server including 4xx will go to <code>onNext\onSuccess</code></p>

<pre><code>Single.defer { ApiController.createRx().getArticle(Preferences.getAuthToken())}
                .doOnError {
                    if (it is HttpException &amp;&amp; it.code() == 401)
                        ApiController.refreshToken()
                }
                .retry { attempts, error -&gt; attempts &lt; 3 &amp;&amp; error is HttpException &amp;&amp; error.code() == 401 }
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe({println(""Success"") }, {
                  it.printStackTrace()
                  toast(R.string.something_went_wrong)
                })
</code></pre>

<p>I am using <code>defer</code> as a wrapper around my actual <code>Observable</code> because I want to recreate the article fetch observable on retry after token refresh because I want <code>Preferences.getAuthToken()</code> to be called again as my refresh token code stores newly fetched token in preference.</p>

<p><code>retry</code> returns true if the <code>HttpException</code> is 401 and not attempted retry more than 2 times</p>
","2085698","","2085698","","2017-08-29 05:24:02","2017-08-29 05:24:02","","","","0","","","","CC BY-SA 3.0"
"45975091","1","","","2017-08-31 06:55:53","","1","409","<p>I have a problem which I was unable to solve so far
I'm new to RxKotlin so it might be easy. Please have a look at the code:</p>

<pre><code>    override fun infos(): Stream&lt;Info&gt; =
        client.infoAboutItem(identifier)
                .map {
                    val itemId = it.itemId ?: """"
                    val item = client.itemForId(itemId)
                    ClientInfo(client, it, source, item) as Info
                }
                .let { AccessStream(it) }
</code></pre>

<p>Where stream is our self-made collection. Map is a method that allows you to iterate over every item inside that collection.</p>

<p>The problem here is that </p>

<pre><code> client.itemForId(itemId)
</code></pre>

<p>is an http call that returns a Single which is not ideal.</p>

<p>I would want to create an asynchronous call inside map that would return Item instead of Single and then pass it to ClientInfo. The things that I've tried so far was was using subscribing inside the map and using blockingGet() method but this blocks the main thread even if I observe and subscribe on a different thread</p>

<p>So it involves making an asynchronous call for every thing in the collection.</p>

<p>Thanks for help</p>
","1840040","","","","","2017-08-31 19:59:08","Asynchronous call for every item inside a collection","<java><kotlin><rx-java><rx-kotlin>","2","5","","","","CC BY-SA 3.0"
"46224173","1","46224508","","2017-09-14 16:27:53","","1","326","<p>Here's a simplified version of what I'm trying to do (using Kotlin and RxJava)</p>

<pre><code>makeServerCall()
                .doOnNext {
                    doStuff(it)
                }
                //TODO: if it == 0, call asyncOperation() and wait for its callback to fire 
                //before running the rest of the stream. Otherwise immediately run the rest
                //of the stream
                .flatMap {
                    observable1(it)
                    observable2(it)
                    Observable.merge(
                            getSpotSearchObservable(observable1),
                            getSpotSearchObservable(observable2)
                }
                .subscribeBy(onNext = {
                allDone()
                    view?
                })
</code></pre>

<p>How do I squeeze in the call to <code>asyncOperation()</code> and make the rest of the stream wait for its callback to fire, but only when a certain condition is met? This seems like it's probably a trivial operation in Rx, but no obvious solution is coming to mind.</p>
","967131","","","","","2017-09-14 16:47:18","How can I conditionally add an asynchronous operation in the middle of an RxJava stream?","<android><kotlin><rx-java><rx-android><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"46224508","2","","46224173","2017-09-14 16:47:18","","3","","<p>FlatMap it!</p>

<pre><code>.flatMap {
    if (it == 0) {
        return@flatMap asyncOperation()
            .ignoreElements()
            .andThen(Observable.just(0))
    }
    return@flatMap Observable.just(it)
}
.flatMap {
    observable1(it)
    observable2(it)
    Observable.merge(
        getSpotSearchObservable(observable1),
        getSpotSearchObservable(observable2)
    )
}
</code></pre>
","61158","","","","","2017-09-14 16:47:18","","","","0","","","","CC BY-SA 3.0"
"46459795","1","46459906","","2017-09-28 01:58:34","","-2","513","<p>I'm trying to make a network request using RxKotlin, but keep getting a <code>NetworkOnMainThreadException</code> I'm subscribing on the main thread, so I'm not sure why it's not taking it off of the UI thread.</p>

<p>Here is where I subscribe to the Observable</p>

<pre><code>weatherInteractor.getWeather(lat, lng)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                        {response -&gt;
                            try {
                                val jsonData = response.body().string()
                                val currentWeather = getCurrentWeatherData(jsonData)
                                view!!.displayCurrentWeather(currentWeather)
                            } catch (e: JSONException) {
                                Log.d(""Present JSON Exception"", e.message)
                            } catch (e: IOException) {
                                Log.d(""Present IO Exception"", e.message)
                            }
                        },
                        {
                            error -&gt;
                            error.printStackTrace()
                        }
                )
    }
</code></pre>

<p>Here is where I create my Observable</p>

<pre><code>fun getWeather(lat: Double, lng: Double): Observable&lt;Response&gt; {
        val URL = """"
        val client = OkHttpClient()
        val request = Request.Builder()
                .url(URL)
                .build()

        return Observable.create { em -&gt;
            try {
                val response = client.newCall(request).execute()
                em.onNext(response)
                em.onComplete()
            } catch (err: IOException) {
                err.printStackTrace()
                em.onError(err)
            }
        }
    }
</code></pre>
","3079130","","3079130","","2017-09-28 15:56:38","2017-09-28 15:56:38","Getting NetworkOnMainThreadException with RxKotlin","<android><kotlin><rx-java><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"46459906","2","","46459795","2017-09-28 02:14:49","","1","","<p>It seems that you confuse <code>subscribeOn</code> and <code>observeOn</code> methods.</p>

<p><code>subscribeOn</code> specifies the scheduler observable will be created on and will operate on. (You specify it once, position doesn't matter).</p>

<p><code>observeOn</code> changes the scheduler <em>for every action you type after it</em>.
You can use it multiple times and each set of actions will be executed on specified scheduler.</p>

<p>Here is an example:</p>

<pre><code>Observable
            .just(""test"")
            .subscribeOn(Schedulers.io())
            .map(s -&gt; { //this and all Observable code is executed on Schedulers.io()

                return s;
            })
            .observeOn(Schedulers.computation())
            .map(s -&gt; { // executed on Schedulers.computation()

                return s;
            })
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(s -&gt; { // executed on Android main thread

            }, throwable -&gt; {

            });
</code></pre>
","6851796","","6851796","","2017-09-28 03:20:52","2017-09-28 03:20:52","","","","8","","","","CC BY-SA 3.0"
"46546041","1","46547211","","2017-10-03 13:42:01","","0","412","<p>I'm using Kotlin 1.1.4-3 with Spring-context 5.0.0.RELEASE. </p>

<p>On starting project I get this error:</p>

<pre><code>org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'coroutineAnnotationBeanPostProcessor' defined in class path resource [org/springframework/kotlin/experimental/coroutine/context/ProxyCoroutineConfiguration.class]: Unsatisfied dependency expressed through method 'coroutineAnnotationBeanPostProcessor' parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'globalCoroutineContextResolver' defined in class path resource [org/springframework/kotlin/experimental/coroutine/context/CoroutineContextResolverConfiguration.class]: Unexpected exception during bean creation; nested exception is java.lang.reflect.InvocationTargetException
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:723)
        at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:458)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1249)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1098)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:545)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:502)
        at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:312)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:310)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:205)
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'globalCoroutineContextResolver' defined in class path resource [org/springframework/kotlin/experimental/coroutine/context/CoroutineContextResolverConfiguration.class]: Unexpected exception during bean creation; nested exception is java.lang.reflect.InvocationTargetException
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:518)
        at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:312)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:310)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
        at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:251)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1133)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1060)
        at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:809)
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:715)
Caused by: java.lang.reflect.InvocationTargetException: null
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.processAnnotationArguments(ReflectKotlinClass.kt:173)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.processAnnotation(ReflectKotlinClass.kt:162)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.loadMethodAnnotations(ReflectKotlinClass.kt:97)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.visitMembers(ReflectKotlinClass.kt:87)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectKotlinClass.visitMembers(ReflectKotlinClass.kt:68)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.AbstractBinaryClassAnnotationAndConstantLoader.loadAnnotationsAndInitializers(AbstractBinaryClassAnnotationAndConstantLoader.kt:257)
Caused by: java.lang.TypeNotPresentException: Type rx.Scheduler not present
        at sun.reflect.annotation.TypeNotPresentExceptionProxy.generateException(TypeNotPresentExceptionProxy.java:46)
        at sun.reflect.annotation.AnnotationInvocationHandler.invoke(AnnotationInvocationHandler.java:84)
        at com.sun.proxy.$Proxy166.value(Unknown Source)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.processAnnotationArguments(ReflectKotlinClass.kt:173)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.processAnnotation(ReflectKotlinClass.kt:162)
        at kotlin.reflect.jvm.internal.impl.load.kotlin.reflect.ReflectClassStructure.loadMethodAnnotations(ReflectKotlinClass.kt:97)
Caused by: java.lang.ClassNotFoundException: rx.Scheduler
        at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:348)
        at sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:114)
        at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:125)
        at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49)
        at sun.reflect.annotation.AnnotationParser.parseSig(AnnotationParser.java:439)
        at sun.reflect.annotation.AnnotationParser.parseClassValue(AnnotationParser.java:420)
</code></pre>

<p>It seems spring is looking for <code>rx.Scheduler</code> class but it's not in the classpath. It's obvious that corresponding dependency of <code>rx.Scheduler</code> is not added. but I couldn't find anything relevant on the Internet.</p>

<p>I added RxJava2 (<code>io.reactivex.rxjava2</code>) to project but it didn't work.
 What can I do?</p>

<p>Final Answer - based on Rafal G. response:</p>

<p>This error is because of using <a href=""https://github.com/konrad-kaminski/spring-kotlin-coroutine"" rel=""nofollow noreferrer"">konrad-kaminski/spring-kotlin-coroutine</a> library.
However, I used these dependencies in my project:</p>

<pre><code>  ""org.springframework.kotlin"" % ""spring-kotlin-coroutine"" % ""0.2.2"" exclude(""org.jetbrains.kotlinx"", ""kotlinx-coroutines""),

  ""org.springframework"" % ""spring-context"" % ""5.0.0.RELEASE"",
  ""org.springframework.data"" % ""spring-data-jpa"" % ""2.0.0.RELEASE"",

  // https://mvnrepository.com/artifact/io.reactivex.rxjava2/rxjava
  ""io.reactivex.rxjava2"" % ""rxjava"" % ""2.1.4"",

  // https://mvnrepository.com/artifact/io.reactivex/rxjava
  ""io.reactivex"" % ""rxjava"" % ""1.3.2"",

  // https://mvnrepository.com/artifact/io.projectreactor/reactor-core
  ""io.projectreactor"" % ""reactor-core"" % ""3.1.0.RELEASE""
</code></pre>
","2250391","","2250391","","2017-10-04 10:19:04","2017-10-04 10:19:04","Spring 5 and Kotlin 1.1 Coroutines: Type rx.Scheduler not present","<java><spring><kotlin><rx-kotlin><kotlinx.coroutines>","1","2","","","","CC BY-SA 3.0"
"46547211","2","","46546041","2017-10-03 14:37:50","","2","","<p>You need to use RxJava 1 because it is where class rx.Schedulers is defined.</p>
","743716","","","","","2017-10-03 14:37:50","","","","0","","","","CC BY-SA 3.0"
"46828909","1","46855916","","2017-10-19 11:32:10","","1","249","<p>I've encountered a strange problem which I'm struggling to understand. I have written some code that creates an observable from callable. It compiles fine, but as soon as I specify a scheduler for it it changes the return type and doesn't compile.</p>

<p>Here is the code without the subscribeOn (which compiles):</p>

<pre><code>/**
 * Gets all the room bookings for the specified day
 */
override fun getRoomBookingsForDay(date: Date): Observable&lt;Collection&lt;Model.RoomBooking&gt;&gt; =
        Observable.fromCallable {
            Realm.getDefaultInstance().use { realm -&gt;
                // Get all the bookings that begin and end within the specified date
                val dbRoomBookings =
                        realm.where(DBRoomBooking::class.java)
                                .greaterThan(""timeFromUtc"", date)
                                .lessThan(""timeToUtc"", date)
                                .findAllSorted(""timeFromUtc"")

                if (dbRoomBookings.isEmpty()) {
                    emptyList()
                } else {
                    dbRoomBookings.asSequence().map { dbRoomBooking -&gt;
                        makeRoomBookingModel(dbRoomBooking)
                    }.filterNotNull().toList()
                }
            }
        }
</code></pre>

<p>And here is the code with subscribeOn (which doesn't compile):</p>

<pre><code>/**
 * Gets all the room bookings for the specified day
 */
override fun getRoomBookingsForDay(date: Date): Observable&lt;Collection&lt;Model.RoomBooking&gt;&gt; =
        Observable.fromCallable {
            Realm.getDefaultInstance().use { realm -&gt;
                // Get all the bookings that begin and end within the specified date
                val dbRoomBookings =
                        realm.where(DBRoomBooking::class.java)
                                .greaterThan(""timeFromUtc"", date)
                                .lessThan(""timeToUtc"", date)
                                .findAllSorted(""timeFromUtc"")

                if (dbRoomBookings.isEmpty()) {
                    emptyList()
                } else {
                    dbRoomBookings.asSequence().map { dbRoomBooking -&gt;
                        makeRoomBookingModel(dbRoomBooking)
                    }.filterNotNull().toList()
                }
            }
        }.subscribeOn(AndroidRealmSchedulers.realmThread())
</code></pre>

<p>The compile time error message is:</p>

<pre><code>Type mismatch.
Required: Observable&lt;Collection&lt;Model.RoomBooking&gt;&gt;
Found: Observable&lt;List&lt;Model.RoomBooking&gt;!&gt;!
</code></pre>

<p>Surely, specifying the scheduler shouldn't change the type that is being returned? Any ideas?</p>
","5963279","","","","","2017-10-20 19:17:18","Adding subscribeOn() is changing return type of observable","<android><kotlin><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"46855916","2","","46828909","2017-10-20 19:17:18","","1","","<p>I think you have to define the co-variance with the return-type:</p>

<pre><code>override fun getRoomBookingsForDay(date: Date): Observable&lt;out Collection&lt;Model.RoomBooking&gt;&gt;
</code></pre>

<p>Using the <code>out T</code> is the same as <code>? extends T</code> in Java.</p>

<p>Alternatively you can make sure to only use the <code>Collection</code>. In your first example the return-type of <code>Observable.fromCallable()</code> is inferred by the return-type of the <code>fun</code> while it is inferred by the return-type of the <code>Callable</code> in the second example. So just declare it directly:</p>

<pre><code>Observable.fromCallable&lt;Collections&lt;Model.RoomBooking&gt;&gt; { ... }
</code></pre>
","3385212","","","","","2017-10-20 19:17:18","","","","0","","","","CC BY-SA 3.0"
"47046329","1","47107834","","2017-11-01 00:09:01","","9","31264","<p>I have an object <em>QuickSort</em> that I am attempting to create 2 instances of. When I try to create 2 separate instances I can see that it is only using one instance because I have a count in the <em>QuickSort</em> class that is inaccurate. Kotlin does not use <strong>new</strong> in the syntax, so how would I go about this?</p>

<pre><code>object QuickSort {
      var count = 0;
      quickSortOne(...){
          ...
          count++
          ...
      }
      quickSortTwo(...){
          ...
          count++
          ...
      }
  } 
</code></pre>

<p>Here is how I am attempting to create my 2 instances.My goal is to have <em>quickSort1</em> and <em>quickSort2</em> be 2 separate instances.</p>

<pre><code>var quickSort1 = QuickSort
quickSort1.quickSortOne(...)

var quickSort2 = QuickSort
quickSort2.quickSortTwo(...)
</code></pre>

<p><strong>Attempted Solution</strong>: Converting <em>QuickSort</em> from an object to a class. This still results in the same instance being used as seen by the count of the second method including the first calls count.</p>

<pre><code>class QuickSort {
      var count = 0;
      quickSortOne(...){
          ...
          count++
          ...
      }
      quickSortTwo(...){
          ...
          count++
          ...
      }
  }
</code></pre>

<p>...</p>

<pre><code>var quickSortFirst = QuickSort()
printTest(quickSortFirst.quickSortFirst(arrayList, 0, arrayList.size - 1))

var quickSortLast = QuickSort()
printTest(quickSortLast.quickSortLast(arrayList, 0, arrayList.size - 1))
</code></pre>
","2253682","","2253682","","2017-11-01 03:49:29","2017-11-04 05:42:23","Create New Instance of Kotlin Object","<kotlin><kotlin-android-extensions><kotlin-extension><rx-kotlin>","4","5","1","","","CC BY-SA 3.0"
"47107834","2","","47046329","2017-11-04 05:42:23","","2","","<p>I figured out my issue. I was passing in the same ArrayList to both quickSortOne() and quickSortTwo(). Since the ArrayList was being modified by the first method, the second method was being affected as well.</p>
","2253682","","","","","2017-11-04 05:42:23","","","","0","","","","CC BY-SA 3.0"
"47173475","1","50465274","","2017-11-08 07:02:43","","0","1639","<p><strong>Kotlin Code:</strong></p>

<pre class=""lang-kotlin prettyprint-override""><code>fun &lt;T&gt; Observable&lt;T&gt;.circuitBreaker(): Observable&lt;T&gt; {
  val relay = PublishRelay.create&lt;T&gt;()
  this.subscribe(relay)
  return relay.toFlowable(BackpressureStrategy.LATEST).toObservable()
}
</code></pre>

<p>Above is a Kotlin code which I'm trying to convert into Swift. But, I'm facing an error saying <strong>Cannot convert value of type 'PublishRelay' to expected argument type '(Event&lt;_>) -> Void'</strong></p>

<p><strong>Swift Code:</strong></p>

<pre class=""lang-swift prettyprint-override""><code>extension Observable {
  func circuitBreaker&lt;T&gt;() -&gt; Observable&lt;T&gt; {
    let relay = PublishRelay&lt;T&gt;()
    self.subscribe(relay)
    return relay.asObservable()
  }
}
</code></pre>

<p>Any help would be appreciated.</p>
","1083859","","6584288","","2017-11-08 07:09:57","2018-05-22 10:20:39","How to subscribe to PublishRelay from generic observable?","<generics><rx-swift><rx-cocoa><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"47187808","1","","","2017-11-08 19:12:29","","2","1755","<p>When im using the following dependencies in my pom file:</p>

<pre><code>&lt;properties&gt;
    &lt;rxkotlinfx.version&gt;2.2.0&lt;/rxkotlinfx.version&gt;
    &lt;rxkotlin.version&gt;2.1.0&lt;/rxkotlin.version&gt;
    &lt;kotlin.version&gt;1.1.51&lt;/kotlin.version&gt;
    &lt;tornadofx.version&gt;1.7.12&lt;/tornadofx.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.github.thomasnield&lt;/groupId&gt;
        &lt;artifactId&gt;rxkotlinfx&lt;/artifactId&gt;
        &lt;version&gt;${rxkotlinfx.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.reactivex.rxjava2&lt;/groupId&gt;
        &lt;artifactId&gt;rxkotlin&lt;/artifactId&gt;
        &lt;version&gt;${rxkotlin.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;no.tornado&lt;/groupId&gt;
        &lt;artifactId&gt;tornadofx&lt;/artifactId&gt;
        &lt;version&gt;${tornadofx.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
        &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;
        &lt;version&gt;${kotlin.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
        &lt;artifactId&gt;kotlin-test&lt;/artifactId&gt;
        &lt;version&gt;${kotlin.version}&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p>And running the following code:</p>

<pre><code>fun main(args: Array&lt;String&gt;) {
    val source = listOf(""A"", ""B"", ""C"").toObservable()
            .filter { it == ""B"" }
            .subscribeBy(
                    onNext = { println(it) }
            )
}
</code></pre>

<p>Im getting the following error:</p>

<pre><code>Error:(37, 40) Kotlin: Cannot access class 'io.reactivex.Observable'. Check your module classpath for missing or conflicting dependencies
</code></pre>

<p>Why am I getting this error and what setup of dependencies do I need to be able to work with this stack?</p>
","3139545","","3139545","","2017-11-08 19:29:18","2017-11-09 18:07:28","Kotlin with RxKotlinFX stack gives Cannot access class error","<kotlin><rx-kotlin>","2","1","","","","CC BY-SA 3.0"
"47196773","1","","","2017-11-09 08:04:50","","0","482","<p>I'm using RxKotlin together with Retrofit 2</p>

<p>I'm trying figure out how to have dynamic list of observers on a single operation.</p>

<p>The first observer should trigger the operation, and all additional observers should wait until the operation complete/fails</p>

<p>Once the operation complete,I need to make data manipulation (Store in cache/Memory) and then notify all the observers.</p>

<p>Here's what I did:</p>

<pre><code>class UserManager
{
    val observers = ArrayList&lt;Observer&lt;ArrayList&lt;User&gt;&gt;&gt;()
    var isFetchingUsers = false

    fun getUsers(observer: Observer&lt;ArrayList&lt;User&gt;&gt;)
    {
        observers.add(observer)

        if (isFetchingUsers)
        {
            return
        }

        api.getUserList.observeOn(AndroidSchedulers.mainThread()).subscribe(object : Observer&lt;UserListResponse&gt;
        {
            override fun onNext(response: UserListResponse)
            {
                // Do some manipulations on the response and notify all

                observers.forEach {
                    it.onNext(response.getUsers())
                }
            }

            override fun onError(e: Throwable)
            {
                observers.forEach {
                    it.onError(Throwable())
                }
            }

            override fun onComplete()
            {
                isFetchingUsers = false
                observers.clear()
            }

            override fun onSubscribe(d: Disposable)
            {
            }
        })
    }
}
</code></pre>

<p>Here's Retrofit observable creation (this one is in Java..)</p>

<pre><code>   /**
     * Get users
     */
    public Observable&lt;UserListResponse&gt; getUserList()
    {
        return mService.getUserList().subscribeOn(Schedulers.io());
    }
</code></pre>

<p>I'm sure there's a better way for doing this</p>

<p>Thanks!</p>
","1039477","","1039477","","2017-11-09 08:10:38","2017-11-09 18:15:54","RxKotlin - Dynamic observers array","<android><kotlin><rx-java><rx-android><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"47294290","1","47294652","","2017-11-14 20:04:16","","0","322","<p>I have a stream of <code>ResponseMessage</code> which can be of different subtypes. I would like to split the stream into streams where I can handle each type in its own stream.</p>

<p>My first try resulted in this which I can not see working out.</p>

<pre><code>file.readLines()
        .toObservable()
        .map { mapper.readValue(it, ResponseMessage::class.java) }
        .groupBy { when(it) {
            is MarketChangeMessage -&gt; it::class
            else -&gt; it::class
        }}
        .map { it.????? } //How can possible this work?
</code></pre>

<p>My question is now:
What is the idiomatic way to divide a stream into streams on one specific sub type?</p>
","3139545","","2597143","","2018-10-24 13:19:55","2018-10-24 13:19:55","RxJava/RxKotlin split stream depending on subtype","<kotlin><rx-java><rx-kotlin><rx-kotlin2><rx-javafx>","1","0","","","","CC BY-SA 3.0"
"47294652","2","","47294290","2017-11-14 20:30:19","","3","","<p>You could use the <code>ofType</code> operator:</p>

<blockquote>
  <p>ofType( ) — emit only those items from the source Observable that are of a particular class.</p>
</blockquote>

<p>Example:</p>

<pre><code>val messages = file.readLines()
    .toObservable()
    .map { mapper.readValue(it, ResponseMessage::class.java) }
    .share() // &lt;-- or other multicasting operator

messages
    .ofType(MarketChangeMessage::class)
    .subscribe()

messages
    .ofType(Other::class)
    .subscribe()
</code></pre>
","2597143","","2597143","","2017-11-14 20:37:15","2017-11-14 20:37:15","","","","0","","","","CC BY-SA 3.0"
"47376858","1","","","2017-11-19 12:28:54","","1","422","<p>Im stuck getting the following example working as expected, I have tried using <code>zip</code> and <code>combineLatest</code> and as show below <code>withLatestFrom</code> however non of them gives the expected output.</p>
<pre><code>@Test
fun thereCanBeOnlyOne() {
    val s1 = BehaviorSubject.create&lt;Int&gt;()
    val s2 = BehaviorSubject.create&lt;Int&gt;()

    s2.withLatestFrom&lt;Int, Int, Int&gt;(s1)
            .subscribe { (a, b) -&gt;
                println(&quot;$a - $b&quot;)
            }

    s1.onNext(1)
    s1.onNext(2)
    s2.onNext(1)
    s2.onNext(2)
    s1.onNext(333)
    s2.onNext(444)
}
</code></pre>
<p>What I want is the following to print:</p>
<blockquote>
<p>2 - 1</p>
<p>2 - 2</p>
<p>333 - 444</p>
</blockquote>
","3139545","","-1","","2020-06-20 09:12:55","2017-11-19 12:42:14","Combine two subject only when one changes and get latest from other","<rx-java><rx-java2><reactivex><rx-kotlin><rx-kotlin2>","1","0","","","","CC BY-SA 3.0"
"47534447","1","","","2017-11-28 14:50:47","","16","10010","<p>Suppose you want to insert a Completable in your Observable chain, such as for each emitted element, there is a completable that runs and blocks until it completes, what option would you choose? (here the <code>Completable.complete()</code> is just to make an example)</p>

<ol>
<li><p><code>.flatMap { Completable.complete().andThen(Observable.just(it)) }</code></p></li>
<li><p><code>.doOnNext { Completable.complete().blockingAwait() }</code></p></li>
<li><p>something else?</p></li>
</ol>
","1855855","","","","","2018-04-26 05:27:53","Chain Completable into Observable flow","<rx-java><rx-java2><rx-kotlin><rx-kotlin2>","2","0","","","","CC BY-SA 3.0"
"47730952","1","47731024","","2017-12-09 17:02:25","","2","830","<pre><code>class TaskRepo(taskData: TaskData) {

companion object {
    private val repoByTask: LRUMap&lt;String, OrderFormRepo&gt; = LRUMap(2, 10);

     fun getInstance(taskData: TaskData): OrderFormRepo {
        if (notFoundObject(taskData.taskId)) {
            repoByTask[taskData.taskId] = OrderFormRepo(taskData);
        }
        return repoByTask[taskData.taskId];//PROBLEM HERE
    }

    private fun notFoundObject(taskId: String): Boolean {
        if (repoByTask.containsKey(taskId) &amp;&amp; repoByTask[taskId] != null) {
            return false
        }
        return true
    }
}
</code></pre>

<p>}</p>

<p>in getInstance method of companion object I am getting compile time <strong>error:</strong>
<strong>Required TaskRepo and found TaskRepo?</strong></p>
","1412900","","4465208","","2017-12-09 17:51:06","2017-12-09 17:51:06","Required <Object> and found <Object>?","<kotlin><kotlin-android-extensions><kotlin-extension><rx-kotlin><kotlin-interop>","1","0","","","","CC BY-SA 3.0"
"47731024","2","","47730952","2017-12-09 17:09:49","","4","","<p><code>LRUMap</code> implements the <a href=""https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html"" rel=""nofollow noreferrer""><code>Map</code></a> interface, the <a href=""https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/get.html"" rel=""nofollow noreferrer""><code>get</code></a> method of which in Kotlin returns a <code>V?</code>, as it returns <code>null</code> when no element is present for the given key. </p>

<p>As you've already done the checking beforehand in this case, you can be reasonably sure (assuming no other threads are modifying the map at the same time) that this value won't be null, and force a conversion to the non-nullable type with the <a href=""https://kotlinlang.org/docs/reference/null-safety.html#the--operator"" rel=""nofollow noreferrer""><code>!!</code> operator</a>:</p>

<pre><code>return repoByTask[taskData.taskId]!!
</code></pre>

<p>For other ways to handle a missing key when reading from a <code>Map</code>, see the <a href=""https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/get-or-default.html"" rel=""nofollow noreferrer""><code>getOrDefault</code></a> and <a href=""https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/get-or-else.html"" rel=""nofollow noreferrer""><code>getOrElse</code></a> methods.</p>
","4465208","","","","","2017-12-09 17:09:49","","","","2","","","","CC BY-SA 3.0"
"47735111","1","47900911","","2017-12-10 01:53:59","","-3","82","<p>could you please help me for this <a href=""https://stackoverflow.com/questions/47595813/rxkotlin-groupby-is-not-working"">rxkotlin groupby is not working</a>? working in rxjava but not kotlin. highly apreciate your help</p>
","1820178","","","","","2017-12-20 07:33:13","I can't get map from groupby in rxkotlin","<kotlin><rx-java><rx-kotlin>","1","2","","","","CC BY-SA 3.0"
"47770059","1","","","2017-12-12 10:14:32","","2","3324","<p>
this is my xml :</p>

<pre><code>&lt;data&gt;

    &lt;variable
        name=""notificationViewmodel""
        type=""com.kdcos.contsync.viewmodel.notification.NotificationViewModel""&gt;&lt;/variable&gt;

&lt;/data&gt;


&lt;RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android""
    android:layout_width=""match_parent""
    android:layout_height=""match_parent""
    android:background=""@color/colorpalegrey""&gt;

    &lt;RelativeLayout
        android:id=""@+id/header""
        android:layout_width=""match_parent""
        android:layout_height=""wrap_content""
        android:layout_alignParentTop=""true""
        android:layout_gravity=""center""
        android:background=""#689F38""
        android:gravity=""center""&gt;

        &lt;include
            android:id=""@+id/layout_toolbar""
            layout=""@layout/toolbar_white_bg"" /&gt;
    &lt;/RelativeLayout&gt;


    &lt;LinearLayout
        android:layout_width=""match_parent""
        android:layout_height=""wrap_content""
        android:layout_below=""@+id/header""
        android:layout_marginTop=""20dp""
        android:background=""@drawable/topbottomborder""
        android:orientation=""vertical""&gt;


        &lt;RelativeLayout
            android:layout_width=""fill_parent""
            android:layout_height=""wrap_content""
            android:layout_marginTop=""18dp""
            android:paddingBottom=""20dp""
            android:paddingLeft=""@dimen/margin_20dp""&gt;


            &lt;TextView
                android:layout_width=""match_parent""
                android:layout_height=""wrap_content""
                android:fontFamily=""sans-serif-medium""
                android:lineSpacingExtra=""30sp""
                android:text=""@={notificationViewmodel.getText()}""
                android:textColor=""@color/colorDusk""
                android:textSize=""16sp""
                android:textStyle=""normal"" /&gt;

            &lt;Switch
                android:layout_width=""wrap_content""
                android:layout_height=""wrap_content""
                android:layout_alignParentRight=""true""
                android:paddingRight=""10dp""
                android:onCheckedChanged=""@={notificationViewmodel.checked}""
                android:textColor=""@android:color/black"" /&gt;

        &lt;/RelativeLayout&gt;
    &lt;/LinearLayout&gt;


&lt;/RelativeLayout&gt;
</code></pre>

<p></p>

<p>this is my View Model</p>

<pre><code>class NotificationViewModel(val context: Context, val bus: Bus, val manager: CNotificationManager) : BaseObservable() {
    private var checked: Boolean = false
    fun getToolbarTitle(): String? {
        return manager.getToolbarTitle()
    }

    fun setToolbarTextColor(): Int {
        return ContextCompat.getColor(context, R.color.colorDusk)
    }

    fun isChecked(): Boolean {
        return checked
    }

    fun setChecked(checked: Boolean) {
        this.checked = checked
    }

    fun getText(): String {
        if (isChecked()) {
            return ""Notfication On""
        } else {
            return ""Notification Off""
        }
        notifyChange()
    }
}
</code></pre>

<p>I want to apply data binding in <code>switch</code> so that when I on <code>switch</code> then  <code>textView</code> should display Notification off and checked value should set to true when I off then it <code>textview</code> should display  notification off and checked Boolean variable should set false. please suggest me how I will implement using Data-binding .</p>
","7108422","","5400914","","2017-12-12 11:20:22","2021-02-26 12:18:27","how to implement Switch using Data binding in android","<android><data-binding><kotlin><rx-kotlin>","2","2","","","","CC BY-SA 3.0"
"47900911","2","","47735111","2017-12-20 07:33:13","","0","","<pre><code>doAsync { val groupedTransactions = accountTransactions.transactions ?.groupBy { it.effectiveDate } ....
</code></pre>

<p>Try this</p>
","3282461","","","","","2017-12-20 07:33:13","","","","0","","","","CC BY-SA 3.0"
"47993122","1","47993505","","2017-12-27 13:33:13","","0","59","<p>I am using firebase in android with some complex data. I need to save references and I'm getting problems with my zip operation, or the way I'm handling RX overall.</p>

<p>I want to create a new <code>A object</code> with information about a certain <code>B</code>, and update my <code>B object</code> to have information about the created <code>A</code>. When the firebase operations have both been successful I will return the <code>Single&lt;A&gt;</code></p>

<pre><code>val singleA = firebaseCall(A(""ABC"", bKey))

val singleB = singleA.flatMap{ a -&gt; firebaseCall(B(aKey)) }

return Single.zip(singleA, singleB, BiFunction { a, b -&gt; a })
</code></pre>

<p>When going through logcat I can see that <code>SingleA</code> get subscribed to twice, and pushes twice to firebase. I want to avoid this!</p>

<p>So, how can I use a zip function on A and B, when B is dependent on A; and not have A being performed twice?</p>
","1570640","","7505436","","2017-12-27 15:16:03","2017-12-27 15:16:03","How do I avoid .zip(stream1, stream2, BiFun) subscribing to stream1 twice, when stream2 is based on stream1?","<android><firebase-realtime-database><reactive-programming><rx-java2><rx-kotlin>","1","3","","","","CC BY-SA 3.0"
"47993505","2","","47993122","2017-12-27 14:01:21","","1","","<p>You don't really need <code>zip</code> for this as you can simple map <code>a</code> back:</p>

<pre><code>val singleA = firebaseCall(A(""ABC"", bKey))

return singleA.flatMap{ a -&gt; firebaseCall(B(aKey)).map { a } }
</code></pre>
","61158","","","","","2017-12-27 14:01:21","","","","2","","","","CC BY-SA 3.0"
"48055716","1","","","2018-01-02 04:49:16","","-6","734","<pre><code> override fun itemclick(position: Int) {
        binding.progressbar.visibility=View.VISIBLE
        binding?.barcode?.setImageBitmap(exchngeViewModel.getQrImageBitmap(qrCodeData[position], this!!.activity!!))
        showDetail(position)
        binding.progressbar.visibility=View.GONE
    }    

fun getQrImageBitmap(data: String, context: Context): Bitmap? {
        bitMap = AppUtils.TextToImageEncode(data, context, bus) 
        return this!!.bitMap
    }
</code></pre>

<p>This is my code i want to display Progress <code>dialog</code> on item click it should dismiss till that time when  <code>getQrImageBitmap</code> and showDetail function  completed but i its not working please suggest me how to achieve this how to show and hide detail on item click.Thanks!! </p>
","7251198","","5110595","","2018-01-02 05:35:42","2018-01-02 05:44:39","How to show Progress dialog and dismiss on Item click","<android><kotlin><rx-java><rx-kotlin>","1","6","","","","CC BY-SA 3.0"
"48126761","1","51862452","","2018-01-06 11:15:03","","6","1761","<p>I am using RxJava/Kotlin with Room and Retrofit. I am sure I'm not making something write as I just started learning RxJava. The scenario is that I make a call to check if there are favorite records in DB and get them in a List, fetch data from API and insert it in DB, update the DB with the previous favorites list and get all records as an, now updated, List. I get the result in my fragment but each time I get it it's as if I get 1 less favorite item until I get no favorite items.</p>

<p><code>Repository</code></p>

<pre><code>fun getKafaniFromApi(): Observable&lt;List&lt;Kafana&gt;&gt; {
    return apiService.getKafani().toObservable().doOnNext {
        insertKafaniInDb(it)
    }
}

fun getKafaniFromDb(): Observable&lt;List&lt;Kafana&gt;&gt; {
    return kafanaDao.getKafani().toObservable()
}

fun insertKafaniInDb(kafani: List&lt;Kafana&gt;) {
    Observable.fromCallable { kafanaDao.insertAll(kafani) }
            .subscribeOn(Schedulers.io())
            .subscribe {
                Timber.d(""Inserted ${kafani.size} kafani from API in DB..."")
            }
}

fun getFavoriteKafani(): Single&lt;List&lt;Kafana&gt;&gt; {
    return kafanaDao.getFavoriteKafani()
}

fun setKafanaFavorite(kafana: Kafana, isFavorite: Int) {
    return kafanaDao.setFavourite(kafana.name, isFavorite)
}

fun updateFavoriteKafana(kafana: Kafana) {
    return kafanaDao.updateFavoriteKafana(kafana)
}
</code></pre>

<p>And in my <code>viewmodel</code></p>

<pre><code>fun get(): Observable&lt;List&lt;Kafana&gt;&gt; {
    return kafanaRepository.getFavoriteKafani()
            .toObservable()
            .doOnNext { kafaniList = it }
            .flatMap { kafanaRepository.getKafaniFromApi() }
            .doOnNext { kafaniList?.forEach { kafanaRepository.updateFavoriteKafana(it) } }
            .flatMap { kafanaRepository.getKafaniFromDb() }
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
}
</code></pre>

<p>I will actually get the list in my fragment but, as I said, it will always be one less favorite until there are none.</p>
","6638520","","","","","2018-08-15 16:13:16","Chaining multiple calls RxJava, Room and Retrofit","<android><retrofit2><rx-java2><android-room><rx-kotlin>","1","0","1","","","CC BY-SA 3.0"
"48129498","1","52319803","","2018-01-06 16:43:21","","9","5141","<p>I have issue that I cannot solve. Im trying to .zip(List, ) multiple Singles into one using Kotlin and none of Functions i supply as second argument fits.</p>

<pre><code>    fun getUserFriendsLocationsInBuckets(token: String) {
    roomDatabase.userFriendsDao().getUserFriendsDtosForToken(token).subscribe(
            { userFriends: List&lt;UserFriendDTO&gt; -&gt;
                Single.zip(getLocationSingleForEveryUser(userFriends),
                        Function&lt;Array&lt;List&lt;Location&gt;&gt;, List&lt;Location&gt;&gt; { t: Array&lt;List&lt;Location&gt;&gt; -&gt; listOf&lt;Location&gt;() })
            },
            { error: Throwable -&gt; }
    )
}

private fun getLocationSingleForEveryUser(userFriends: List&lt;UserFriendDTO&gt;): List&lt;Single&lt;List&lt;Location&gt;&gt;&gt; =
        userFriends.map { serverRepository.locationEndpoint.getBucketedUserLocationsInLast24H(it.userFriendId) }
</code></pre>

<p><a href=""https://i.stack.imgur.com/1ByNM.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/1ByNM.png"" alt=""Android studio error""></a></p>
","5396120","","","","","2018-09-13 18:30:20","RxJava 2.0 and Kotlin Single.zip() with list of singles","<kotlin><rx-java><rx-kotlin>","1","2","1","","","CC BY-SA 3.0"
"48225258","1","48225383","","2018-01-12 11:22:37","","16","20568","<pre><code>val mutableList1: MutableList&lt;TeamInvitationData?&gt;?
val mutableList2: MutableList&lt;TeamInvitationData?&gt;?
</code></pre>

<p><strong>addAll</strong> method can be use to merge nullable mutable list but, here it throws me compile time error. </p>

<p>Example:</p>

<pre><code>val map1 = listOne?.map { TeamInvitationData(it) }
val map2 = listTwo?.map { TeamInvitationData(it) }
map1.addAll(map2)
</code></pre>

<blockquote>
  <p>Type interface failed ,Please try to specify type argument explicitly.</p>
</blockquote>

<p>Here Any way can I merge this two array , thanks in advance.</p>
","1339473","","1339473","","2018-01-12 12:50:44","2019-12-31 06:22:57","Kotlin merge two nullable mutable list","<android><kotlin><rx-kotlin>","3","4","3","","","CC BY-SA 3.0"
"48225383","2","","48225258","2018-01-12 11:29:16","","26","","<p>Here are couple of solutions.</p>

<ol>
<li><p>In case if you need to <strong>add all elements</strong> to <code>mutableList1</code>:</p>

<pre><code>val mutableList1: MutableList&lt;Any?&gt;? = ...
val mutableList2: MutableList&lt;Any?&gt;? = ...

mutableList1?.let { list1 -&gt; mutableList2?.let(list1::addAll) }
</code></pre></li>
<li><p>In case if you need <strong>new nullable list</strong> as result:</p>

<pre><code>val mutableList1: MutableList&lt;Any?&gt;? = ...
val mutableList2: MutableList&lt;Any?&gt;? = ...

val list3: List&lt;Any?&gt;? = mutableList1?.let { list1 -&gt;
    mutableList2?.let { list2 -&gt; list1 + list2 }
}
</code></pre></li>
<li><p>In case if you need <strong>new nullable mutable list</strong> as result: </p>

<pre><code>val mutableList1: MutableList&lt;Any?&gt;? = ...
val mutableList2: MutableList&lt;Any?&gt;? = ...

val list3: MutableList&lt;Any?&gt;? = mutableList1
        ?.let { list1 -&gt; mutableList2?.let { list2 -&gt; list1 + list2 } }
        ?.toMutableList()
</code></pre></li>
<li><p>In case if you need <strong>new non-null list</strong> as result:</p>

<pre><code>val mutableList1: MutableList&lt;Any?&gt;? = ...
val mutableList2: MutableList&lt;Any?&gt;? = ...

val list3: List&lt;Any?&gt; = mutableList1.orEmpty() + mutableList2.orEmpty()
</code></pre></li>
</ol>
","4727432","","4727432","","2018-01-12 11:35:23","2018-01-12 11:35:23","","","","4","","","","CC BY-SA 3.0"
"48261094","1","48374540","","2018-01-15 10:28:48","","2","611","<p>I'm writing a wrapper around FirebaseFirestore snapshot listener that emits the changes using RxKotlin Observable.</p>

<p>I wrote the following class which makes use of create() method to create the observable and emit the changes asynchronously when a new data snapshot is available. </p>

<p>The problem is that I'm leaking memory every time I create an instance of this class and I stop using it. What is the best way to rewrite this class without leaking memory?</p>

<p>Any resources about how to create Observables that can emit objects from listeners would be really helpful!</p>

<pre><code>class DocumentRepository&lt;T : ModelWithMetadata&gt;(
        path: List&lt;String&gt;,
        private val model: Class&lt;T&gt;) {

    private var documentReference: DocumentReference

    val observable: Observable&lt;T&gt;

    private var emitter: ObservableEmitter&lt;T&gt;? = null
    private lateinit var item: T


    init {
        documentReference = FirebaseFirestore.getInstance().collection(path[0]).document(path[1])
        for (i in 2..path.lastIndex step 2)
            documentReference = documentReference.collection(path[i]).document(path[i + 1])

        observable = Observable.create(this::listenChanges)
    }

    private fun listenChanges(emitter: ObservableEmitter&lt;T&gt;) {
        this.emitter = emitter
        documentReference.addSnapshotListener { documentSnapshot, _ -&gt;
            item = documentSnapshot.toObject(this.model)
            this.emitter?.onNext(item)
        }
    }

    fun get() {
        emitter?.onNext(item)
    }

    fun put(item: T) {
        item.updatedAt = TimeExtension.now()
        documentReference.set(item)
    }

    fun delete(item: T) {
        documentReference.delete()
    }
}
</code></pre>
","3723306","","","","","2018-01-22 04:08:50","Avoid memory leak when Observable.create() to emit listener objects","<google-cloud-firestore><rx-java2><rx-android><reactivex><rx-kotlin>","1","1","1","","","CC BY-SA 3.0"
"48347759","1","48357786","","2018-01-19 18:52:09","","0","654","<p>perform a task with an observable and emit value</p>

<pre><code>private val performTask = io.reactivex.Observable.create&lt;Boolean&gt;({ emitter -&gt;
// do somethinf
    emitter.onNext(true)
    emitter.onComplete()
})
</code></pre>

<p>// this is also another observable with retry. I want to retry 2 times, but only if perform task is successful. </p>

<pre><code>fun &lt;T&gt; io.reactivex.Observable&lt;T&gt;.retryAuth(): Observable&lt;T&gt; {
    return this.retry ({ count, error -&gt; 
        if (count == 2 &amp;&amp; error is ApolloException) {
            // do something with performTask and return the value

        } else false
    })
</code></pre>

<p>just need illustration on achieving this</p>
","3100757","","3100757","","2018-01-20 07:24:39","2018-01-20 15:23:23","execute and return value from observable on retry predicate","<java><android><rx-java><rx-kotlin>","1","2","","","","CC BY-SA 3.0"
"48357786","2","","48347759","2018-01-20 15:23:23","","1","","<p>You could use <code>retryWhen</code>:</p>

<pre><code>this.retryWhen({ errors -&gt;
   val counter = AtomicInteger()
   .flatMap({ error -&gt;
       if (counter.incrementAndGet() &lt;= 2 &amp;&amp; error is ApolloException) {
           return performTask
              .flatMap({ result -&gt;
                   if (result) {
                       return Observable.just(true)
                   }
                   return Observable.error(error)
              })
       }
       return Observable.error(error)
   })  
})
</code></pre>
","61158","","","","","2018-01-20 15:23:23","","","","2","","","","CC BY-SA 3.0"
"48374540","2","","48261094","2018-01-22 04:08:50","","1","","<p><code>documentReference.addSnapshotListener</code> returns a <a href=""https://firebase.google.com/docs/firestore/reference/android/ListenerRegistration"" rel=""nofollow noreferrer""><code>ListenerRegistration</code></a> which allows you to call <a href=""https://firebase.google.com/docs/firestore/reference/android/ListenerRegistration.html#remove()"" rel=""nofollow noreferrer""><code>ListenerRegistration#remove</code></a> to remove the listener. </p>

<p>And, <a href=""http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/ObservableEmitter.html#setCancellable-io.reactivex.functions.Cancellable-"" rel=""nofollow noreferrer""><code>Emitter#setCancellable</code></a> allows you to clean up resources, in this case detaching a listener, when the <code>Observable</code> is unsubscribed. </p>

<p>So your <code>listenChanges</code> would look like this:</p>

<pre><code>private fun listenChanges(emitter: ObservableEmitter&lt;T&gt;) {
  this.emitter = emitter
  val registration = documentReference.addSnapshotListener { documentSnapshot, _ -&gt;
    item = documentSnapshot.toObject(this.model)
    this.emitter?.onNext(item)
  }
  emitter.setCancellable { registration.remove() }
}
</code></pre>
","620138","","","","","2018-01-22 04:08:50","","","","2","","","","CC BY-SA 3.0"
"48398348","1","48411925","","2018-01-23 09:35:22","","1","1098","<p>I have my observables defined like this </p>

<pre><code>    val initLoading = Observable.fromCallable { println(""${System.currentTimeMillis()}"") }
            .subscribeOn(Schedulers.computation())
            .delay(WAIT_TIME, TimeUnit.SECONDS)
            .map { ""loading ${System.currentTimeMillis()}"" }
            .observeOn(AndroidSchedulers.mainThread())

    val click = RxView.clicks(button).map { ""click ${System.currentTimeMillis()}"" }
    initLoading.concatWith(click)
            .subscribeBy(
                    onNext = { println(""result $it"") },
                    onError = { throw it }
            )
</code></pre>

<p><code>initialLoading</code> starts running at Activity's <code>onCreate</code> method. <code>click</code> is executed on button click. I have two cases and first is working, second isn't.</p>

<p><strong>case 1</strong> </p>

<p>activity starts and button is clicked <strong>after</strong> <code>WAIT_TIME</code> seconds. Output: </p>

<pre><code>   01-23 13:08:07.170  I/System.out: 1516698487170
   01-23 13:08:17.174  I/System.out: result loading 1516698497172
   01-23 13:08:29.258  I/System.out: result click 1516698509258
</code></pre>

<p><strong>case 2</strong></p>

<p>activity starts and button is clicked <strong>before</strong> <code>WAIT_TIME</code> period is over. Output</p>

<pre><code>   01-23 13:09:07.392 I/System.out: 1516698547392
   01-23 13:09:17.398 I/System.out: result loading 1516698557395
</code></pre>

<p>so, the problem is that the click event is lost. I want the click event to wait for the loading, and then continue working. in short, case 2 output should be the same as case 1.</p>

<p>How can i chive this using rx operators. I tried <code>merge</code> but it just combines both and click event doesn't wait for loading. </p>

<p>I also tried <code>reply, cache, publish, share</code> but couldn't get the right combination of them to work as I want. </p>
","3904645","","","","","2018-01-23 22:32:22","RxJava: Combining hot and cold observable to wait for each other","<android><rx-java><rx-java2><rx-kotlin><rx-kotlin2>","2","0","1","","","CC BY-SA 3.0"
"48411925","2","","48398348","2018-01-23 22:32:22","","1","","<p>The <code>concatWith</code> operator is good for your use case but the second observable should start to store click events immediately after it is created so that the stored events can be emitted when the observable is subscribed to (which happens when <code>initLoading</code> completes). This can be achieved by modifying your <code>click</code> observable with <code>replay()</code> and <code>connect()</code>.</p>

<pre><code>val replayedClicks = click.replay();
replayedClicks.connect(); // The original click observable is subscribed to at this point
</code></pre>

<p>Now you can use <code>replayedClicks</code> in the <code>concatWith</code>, and its stored events will be replayed after <code>initLoading</code> finishes:</p>

<pre><code>initLoading.concatWith(replayedClicks)
        .subscribeBy(
                onNext = { println(""result $it"") },
                onError = { throw it }
        )
</code></pre>
","5132200","","","","","2018-01-23 22:32:22","","","","1","","","","CC BY-SA 3.0"
"48414894","1","","","2018-01-24 04:36:42","","2","2749","<p>I am new in Spring 5 and Reactive Programming. My problem is creating the export feature for the database by a rest API.
User hits GET request -> Server reads data and returns data as a zip file. Because zip file is large, so I need to stream these data.
My code as below:</p>

<pre><code>    @GetMapping(
    value = ""/export"",
    produces = [""application/octet-stream""],
    headers = [
              ""Content-Disposition: attachment; filename=\""result.zip\"""",
              ""Content-Type: application/zip""])
    fun streamData(): Flux&lt;Resource&gt; = service.export()
</code></pre>

<p>I use curl as below:</p>

<pre><code>curl http://localhost/export -H ""Accept: application/octet-stream""
</code></pre>

<p>But it always returns 406 Not Acceptable.
Anyone helps?</p>

<p>Thank you so much</p>
","5867133","","","","","2018-01-26 02:25:07","Response zip file with WebFlux","<stream><kotlin><reactive-programming><spring-webflux><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"48468325","1","48468793","","2018-01-26 19:33:12","","1","461","<p>I am writing a method in Kotlin:</p>

<pre><code>fun fetchDepositSession(): Completable =
        Observable.fromIterable(session.accounts)
                .map(DepositSession::DepositAccount)
                .toList()
                .doOnSuccess(depositSession::depositAccounts::set)
                .flatMapObservable(Observable::fromIterable)
                .map(DepositSession.DepositAccount::account::get)
                .toCompletable()
</code></pre>

<p>The line <code>.flatMapObservable(Observable::fromIterable)</code> is causing an error:</p>

<p><a href=""https://i.stack.imgur.com/WKMsm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/WKMsm.png"" alt=""enter image description here""></a></p>
","2836797","","","","","2018-01-26 20:07:28","Generic Function References in Rx and Kotlin -- type inference failed","<android><kotlin><rx-java><rx-java2><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"48468793","2","","48468325","2018-01-26 20:07:28","","2","","<p>RxJava and Kotlin inferring types don't work that well. There is a couple of issues like <a href=""https://youtrack.jetbrains.com/issue/KT-13609"" rel=""nofollow noreferrer"">KT-13609</a> and <a href=""https://youtrack.jetbrains.com/issue/KT-14984"" rel=""nofollow noreferrer"">KT-14984</a>.</p>

<p>See <a href=""https://stackoverflow.com/questions/42635968/kotlin-and-rxjava-why-is-my-single-zip-not-compiling"">this question</a> that is relative to the problem. There is also an <a href=""https://github.com/ReactiveX/RxKotlin/issues/103"" rel=""nofollow noreferrer"">issue in RxKotlin's Github</a> talking about it.</p>

<p>Anyway, you can always use:</p>

<pre><code>.flatMapObservable { Observable.fromIterable(it) }
</code></pre>
","1797950","","","","","2018-01-26 20:07:28","","","","0","","","","CC BY-SA 3.0"
"48528325","1","48528504","","2018-01-30 18:36:40","","1","325","<p>This never completes:</p>

<pre><code>Completable.complete()
        .andThen{ Completable.complete() }
        .test()
        .assertComplete()
</code></pre>

<p>This does complete:</p>

<pre><code>Completable.complete()
        .andThen(Completable.complete())
        .test()
        .assertComplete()
</code></pre>

<p>According to Jake Wharton:</p>

<p>""You want <code>andThen(Completable.complete())</code>. Note the use of parenthesis and
not curly braces. The latter creates a lambda that doesn't call its emitter.""</p>

<p>Reference: <a href=""https://github.com/ReactiveX/RxJava/issues/5551"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxJava/issues/5551</a></p>

<p>Can anyone explain this in more detail? I thought I understood lambda's but this has really thrown me. </p>
","5963279","","8073652","","2018-01-30 18:51:51","2018-01-30 18:51:51","RXKotlin Lambda Understanding","<lambda><kotlin><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"48528504","2","","48528325","2018-01-30 18:48:44","","3","","<p>With the curly braces, you're using <a href=""https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions"" rel=""nofollow noreferrer"">SAM conversion</a> and defining an anonymous <code>CompletableSource</code> instance by describing its single method inside the lambda. </p>

<p>This is the same as doing the following:</p>

<pre><code>Completable.complete()
        .andThen(object: CompletableSource {
            override fun subscribe(cs: CompletableObserver) {
                Completable.complete()
            }
        })
        .test()
        .assertComplete()
</code></pre>

<p>As you can see, inside this <code>CompletableSource</code> you're doing nothing but creating a <code>Completable</code> instance and throwing away its result. For the chain to continue, you'd have to call methods on the <code>CompleteableObserver</code> that you've received as a parameter (for example, you could call <code>onNext()</code> and <code>onComplete()</code> on it).</p>

<hr>

<p>Although it's almost the same syntax, here's the Java version, in case it helps you understand things:</p>

<pre><code>Completable.complete()
        .andThen(new CompletableSource() {
            @Override
            public void subscribe(CompletableObserver cs) {
                Completable.complete();
            }
        })
        .test()
        .assertComplete();
</code></pre>
","4465208","","","","","2018-01-30 18:48:44","","","","3","","","","CC BY-SA 3.0"
"48568178","1","","","2018-02-01 17:08:04","","1","548","<p>Currently I'm building a project in Kotlin using RxKotlin. My background with Rx is primarily grounded in RxJS. </p>

<p>A pattern I would regularly use for creating <code>hot observables</code> in Typescript would look something along the lines of this: </p>

<pre><code>  private dataStore: IFoo;
  private dataStoreSubject: BehaviorSubject&lt;IFoo&gt; = new BehaviorSubject(this.dataStore);
  public dataStoreObservable: Observable&lt;IFoo&gt; = Observable.from(this.dataStoreSubject);

  public getNetworkData(): Observable&lt;IFoo[]&gt; {
      return this.http.get()
         .map((response: IResponse) =&gt; {
             this.dataStore = &lt;IFoo[]&gt;response;
             this.dataStoreSubject.next(this.dataStore);
             return this.dataStore;
          });
   }
</code></pre>

<p>This would allow me to expose an <code>Observable</code>, without exposing the <code>Subject</code> and subsequently the <code>subject.next();</code> method.</p>

<p>My question is: What would be the most idiomatic way to establish similar logic in RxKotlin or RxJava?</p>
","6754267","","","","","2019-02-18 19:59:26","Idiomatically creating hot observables with BehaviorSubject in RxKotlin / RxJava","<java><rxjs><rx-java><rx-java2><rx-kotlin>","1","5","","","","CC BY-SA 3.0"
"48689211","1","48689307","","2018-02-08 15:35:11","","0","164","<p>I'm developing an android app using room and RxAndroid. The problem is that i'm using the next code to refresh the info in my recycler view.</p>

<pre><code>observable.subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe{adapter.data = it}
</code></pre>

<p>if i implement this in my activity it works like a charm. But i want to create an extension function to make the code cleaner when using flowables from the database. I create this funtion </p>

<pre><code>fun &lt;T&gt; Flowable&lt;T&gt;.uiSubscribe(x : (T) -&gt; Unit)  {
this.subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe{x}
</code></pre>

<p>but when i tried to use it, it does nothing. It doesn't trow an error or anything. Does somebody know a way to archive this? or does somebody know why it is not working?</p>
","5420543","","1843331","","2018-02-08 16:25:45","2018-02-08 16:25:45","How to create a extension function to make rx subscription to flowable cleaner?","<android><kotlin><rx-java2><rx-android><rx-kotlin>","1","1","","","","CC BY-SA 3.0"
"48689307","2","","48689211","2018-02-08 15:40:13","","2","","<p>You should use <code>subscribe { x(it) }</code> or <code>subscribe(x)</code>.</p>

<p>In your case <code>subscribe{x}</code> creates an <code>onNext</code> consumer which does nothing but state <code>x</code> in the expression.</p>
","3385212","","","","","2018-02-08 15:40:13","","","","0","","","","CC BY-SA 3.0"
"48753572","1","48753835","","2018-02-12 18:57:09","","6","5143","<pre><code>    Observable.just(1)
            .flatMap(object : Function&lt;Int, Observable&lt;Int&gt;&gt; {
                override fun apply(integer: Int): Observable&lt;Int&gt; {
                    return Observable.just(integer * 10)
                }
            })
            .flatMap(object : Function&lt;Int, Observable&lt;Int&gt;&gt; {
                override fun apply(integer: Int): Observable&lt;Int&gt; {
                    return Observable.just(integer * 20)
                }
            })
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(object : Observer&lt;Int&gt; {
                override fun onComplete() {
                }

                override fun onSubscribe(d: Disposable) {
                }

                override fun onNext(t: Int) {
                    Log.d(""result"", """" + t)
                }

                override fun onError(e: Throwable) {
                    e.printStackTrace()
                }
            })
</code></pre>
","2069407","","","","","2018-08-01 09:23:17","How can I convert this rxjava/rxkotlin flatMap into lambda expression?","<android><lambda><rx-java><flatmap><rx-kotlin>","2","0","1","","","CC BY-SA 3.0"
"48753835","2","","48753572","2018-02-12 19:13:31","","5","","<p>This should do.</p>

<pre><code>Observable.just(1)
        .flatMap { 
            return@flatMap Observable.just(it*10)
        }.flatMap { 
            return@flatMap Observable.just(it*20)
        }.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread())
        .subscribe({
            //OnNext
           Log.d(""result"", """" + it)
        },{
          it.printStackTrace()
            //on error
        },{
            //on complete
        })
</code></pre>
","7639117","","","","","2018-02-12 19:13:31","","","","0","","","","CC BY-SA 3.0"
"48845703","1","48851716","","2018-02-17 20:35:45","","0","1424","<p>I'm trying to sort the emissions of an <code>Observable</code> using either <code>sorted()</code> or <code>toSortedList()</code>.</p>

<p>Here's my code:</p>

<pre><code>bookshelfUseCase.addedBooks(uid, BookshelfRepositoryContract.READ_LIST)
            .flatMap { Observable.fromIterable(it) }
            .doOnNext { Log.d(""RLP1"", it.toString()) }
            .toSortedList { first, second -&gt; first.timestamp.compareTo(second.timestamp) }
            .toObservable()
            .doOnNext { Log.d(""RLP2"", it.toString()) }
            .subscribe { getView().showBooks(it) }
</code></pre>

<p>Here, I'm comparing the timestamp of each <code>Book</code> to get a sorted list for showing it to the user.</p>

<h2>What's the problem?</h2>

<p>The <code>Observable</code> or <code>Single</code> returned by <code>sorted()</code> or <code>toSortedList()</code> doesn't emit anything. Just blank. Zero emissions.</p>

<p>Here's the output of log printed by the <code>doOnNext()</code> before and after <code>toSortedList()</code> is called:</p>

<pre><code>02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=368593, title=The 4-Hour Workweek, year=2007, author=Author(id=210456, name=Timothy Ferriss), rating=3.85, coverImageUrl=https://s.gr-assets.com/assets/nophoto/book/111x148-bcc042a9c91a29c1d680899eff700a03.png, coverImageUrlSmall=https://s.gr-assets.com/assets/nophoto/book/50x75-a91bf249278a81aabab721ef782c4a74.png, checkInTime=0, timestamp=1518895501664)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=12605157, title=The $100 Startup: Reinvent the Way You Make a Living, Do What You Love, and Create a New Future, year=2012, author=Author(id=3367145, name=Chris Guillebeau), rating=3.85, coverImageUrl=https://images.gr-assets.com/books/1345666854m/12605157.jpg, coverImageUrlSmall=https://images.gr-assets.com/books/1345666854s/12605157.jpg, checkInTime=0, timestamp=0)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=13497818, title=The Casual Vacancy, year=2012, author=Author(id=1077326, name=J.K. Rowling), rating=3.28, coverImageUrl=https://images.gr-assets.com/books/1509893913m/13497818.jpg, coverImageUrlSmall=https://images.gr-assets.com/books/1509893913s/13497818.jpg, checkInTime=0, timestamp=0)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=29095176, title=Lyrebird, year=2016, author=Author(id=7116, name=Cecelia Ahern), rating=3.76, coverImageUrl=https://images.gr-assets.com/books/1465023152m/29095176.jpg, coverImageUrlSmall=https://images.gr-assets.com/books/1465023152s/29095176.jpg, checkInTime=0, timestamp=0)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=31823677, title=Tools of Titans: The Tactics, Routines, and Habits of Billionaires, Icons, and World-Class Performers, year=2016, author=Author(id=210456, name=Timothy Ferriss), rating=4.25, coverImageUrl=https://s.gr-assets.com/assets/nophoto/book/111x148-bcc042a9c91a29c1d680899eff700a03.png, coverImageUrlSmall=https://s.gr-assets.com/assets/nophoto/book/50x75-a91bf249278a81aabab721ef782c4a74.png, checkInTime=0, timestamp=0)
02-18 01:54:27.743 25032-25032/com.bookwritten D/RLP1: Book(id=36204090, title=Crushing It!: How Great Entrepreneurs Build Their Business and Influence—and How You Can, Too, year=0, author=Author(id=1371305, name=Gary Vaynerchuk), rating=4.58, coverImageUrl=https://images.gr-assets.com/books/1514065832m/36204090.jpg, coverImageUrlSmall=https://images.gr-assets.com/books/1514065832s/36204090.jpg, checkInTime=0, timestamp=0)
</code></pre>

<p>As you can see, no logs are being printed after the <code>toSortedList()</code> has been called in the chain.</p>

<p>What could I be missing here?</p>

<p>Any help is highly appreciated. Thanks in advance.</p>
","3922919","","","","","2018-02-18 12:32:40","Sorting emissions in Rx using sorted() or toSortedList() not working","<android><kotlin><rx-java2><rx-kotlin>","1","2","","","","CC BY-SA 3.0"
"48851716","2","","48845703","2018-02-18 12:32:40","","0","","<p>Looks like I made the mistake of applying <code>sorted()</code> on an infinite <code>Observable</code>, as pointed out by @akarnokd.</p>

<p>The <code>Observable</code> in question is infinite because it's connected to a <strong>Firebase Realtime DB</strong>.</p>

<p>Therefore, my sorting problem was easily solved by sorting the values on <code>subscribe{}</code> rather than applying the function within the chain. The code goes like this:</p>

<pre><code>bookshelfUseCase.addedBooks(uid, BookshelfRepositoryContract.MY_BOOKS)
            .subscribe { getView().showBooks(it.sortedWith(compareByDescending { it.timestamp })) }
</code></pre>

<p>Hope this saves someone's time.</p>
","3922919","","","","","2018-02-18 12:32:40","","","","0","","","","CC BY-SA 3.0"
"48922214","1","48922453","","2018-02-22 07:55:34","","3","1369","<p>I have code to listen to exactly three fields using <strong>Observables.combineLatest</strong> </p>

<pre><code>Observables.combineLatest(text_name.asObservable(),text_username.asObservable(), text_email.asObservable()).subscribe({ t -&gt;
            if (t.first.toString() != currentName || t.second.toString() != currentUsername) {
                startActionMode()
            } else {
                finishActionMode()
            }
        })
</code></pre>

<p>but when I add another parameter to the <strong>Observables.combineLatest</strong> it throughs error since only 3 inline-parameters can be passed..</p>

<p>Now I would wish to pass 4 parameters in the parameter list for <strong>Observables.combineLatest</strong>.. I know it should be done using an array or a list, passed in as parameter but It's hard for me to figure it out using <strong>Kotlin</strong>.</p>

<p>Help me out.. Thanks in Advance..</p>
","7813796","","6296561","","2018-02-22 10:03:47","2018-02-22 10:03:47","How to Listen to more than Three Fields in Observables.combineLatest","<android><kotlin><kotlin-android-extensions><rx-kotlin>","1","2","","","","CC BY-SA 3.0"
"48922453","2","","48922214","2018-02-22 08:12:25","","1","","<p>You need to add a combine function if you want to combine more than 3 observables. You can do something like this. </p>

<pre><code>    Observables.combineLatest(
            first.asObservable(),
            second.asObservable(),
            third.asObservable(),
            forth.asObservable()
    )
    // combine function
    { first, second, third, forth-&gt;
        // verify data and return a boolean
        return@subscribe first.toString() != currentName || second.toString() != currentUsername
    }
    .subscribe({ isValid-&gt;
                   if (isValid) {
                       startActionMode()
                   } else {
                       finishActionMode()
                   }
               })
</code></pre>

<p>In the combine function you can verify your data and return a boolean.
Then in subscribe you can take an action based on that boolean</p>
","2819510","","","","","2018-02-22 08:12:25","","","","1","","","","CC BY-SA 3.0"
"48967171","1","48971608","","2018-02-24 20:17:23","","0","722","<p>In my application I'm using RxJava2 and new class from Architecture Components ViewModel. In my case, I need to push SQL clause to ViewModel, which will do some magic and return Observable that will give me the data I need. Everything works fine, but I am not sure if I am using RX in the best way. </p>

<p>My data flow:
ViewModel has PublishSubject on which I am pushing SQL's. ViewModel has also Observable which is created by mapping subject. Also, I used distinctUntilChanged on Subject, to prevent from executing the same query again. 
 To cache data I used replay(1).autoconnect(1) on Observable, but that approach had a flaw. Sometimes my Subject pushed Sql when Observable wasn't yet connect, and my data never arrived to me. Should I use BehaviourSubject? Or maybe I shouldn't use replay(1).autoconnect(1) in the first place? Or maybe my whole flow is wrong? Example:</p>

<pre><code>val listSubject: Subject&lt;RawSql&gt; = PublishSubject.create()
val sqlListEmitter: Observable&lt;List&lt;T&gt;&gt; =
        listSubject
                .subscribeOn(Schedulers.computation())
                .map { // SOME MAGIC HERE }
                .replay(1).autoConnect(1, { compositeDisposable.add(it) })
</code></pre>
","7799729","","8551764","","2018-12-02 19:58:28","2018-12-02 19:58:28","Best way to cache data in Android with ViewModel and RxJava2","<android><kotlin><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"48971608","2","","48967171","2018-02-25 08:16:37","","0","","<p>In your case <code>autoConnect()</code> just waits for the first subscription to <code>connect()</code> to your stream. Since your subject and your stream build an inherent entity, you might not want to wait for it at all and instead connect it directly.</p>

<pre><code>val listSubject: Subject&lt;RawSql&gt; = PublishSubject.create()
val sqlListEmitter: Observable&lt;List&lt;T&gt;&gt; =
        listSubject
                .observeOn(Schedulers.computation())
                .map { // SOME MAGIC HERE }
                .replay(1)
                .let {
                    it.connect(compositeDisposable::add)
                    it.publish()
                }
</code></pre>

<p>Also you might need to change <code>subscribeOn()</code> to <code>observeOn()</code>. The subject emits on the same thread as the data is pushed to it and does not consider the thread it's subscribed on.</p>
","3385212","","","","","2018-02-25 08:16:37","","","","2","","","","CC BY-SA 3.0"
"49031599","1","49811981","","2018-02-28 14:14:42","","3","609","<p>I was first introduced to reactive programming with <strong>ReactiveCocoa</strong> several years ago. In there they had the notion on <code>RACCommand</code>s, which was carried over to <strong>RxSwift</strong> with the extension library <strong><a href=""https://github.com/RxSwiftCommunity/Action"" rel=""nofollow noreferrer"">Action</a></strong>.</p>
<p>As stated on their GitHub page:</p>
<blockquote>
<p>An action is a way to say &quot;hey, later I'll need you to subscribe to this thing.&quot;</p>
<p>Actions accept a <code>workFactory</code>: a closure that takes some input and produces an observable. When <code>execute()</code> is called, it passes its parameter to this closure and subscribes to the work.</p>
<ul>
<li>Can only be executed while &quot;enabled&quot; (true if unspecified).</li>
<li>Only execute one thing at a time.</li>
<li>Aggregates next/error events across individual executions.</li>
</ul>
</blockquote>
<p>In my experience it is an absolutely <em>indispensable</em> tool in the reactive programming toolbox when doing robust, reactive iOS development.</p>
<hr />
<p>Now we would like to carry this over to <strong>Android</strong> app as well. But after countless hours of research I have not been able to find a corresponding component for either <strong>RxJava</strong> or <strong>RxKotlin</strong>.</p>
<p>The implementation in Swift is relatively straight forward, so we <em>could</em> just port it, but I'd first like to hear if:</p>
<ol>
<li>This really does not exists, and if so</li>
<li>Is there an Android specific reason for this to not exist, i.e. a reason <strong>not</strong> to port it</li>
</ol>
","746968","","-1","","2020-06-20 09:12:55","2018-04-13 07:55:37","RxSwift like Actions for Android","<android><ios><rx-java><rx-swift><rx-kotlin>","1","3","","","","CC BY-SA 3.0"
"49188172","1","49189651","","2018-03-09 06:55:39","","4","1922","<p>Facing Problem on getting Response in ArrayList. </p>

<p>I have following Respose on String value </p>

<pre><code> var res_message: String = """"
 res_message = ""${result.vehicletypes} ""
</code></pre>

<p>Getting below Value on this String</p>

<pre><code>     [VehicleType(_id=1, vehicleType=Hatchback, __v=0), 
      VehicleType(_id=2, vehicleType=Maruti, __v=0), 
      VehicleType(_id=3, vehicleType=Honda, __v=0), 
      VehicleType(_id=4, vehicleType=Bike, __v=0)] 
</code></pre>

<p>Retrofit Result is </p>

<pre><code> vehicletypes = {ArrayList@6055}  size = 4
 0 = {Model$VehicleType@6058} ""VehicleType(_id=1, 
vehicleType=Hatchback, __v=0)""
 1 = {Model$VehicleType@6059} ""VehicleType(_id=2, 
 vehicleType=Maruti, __v=0)""
  2 = {Model$VehicleType@6060} ""VehicleType(_id=3, 
 vehicleType=Honda, __v=0)""
  3 = {Model$VehicleType@6061} ""VehicleType(_id=4, 
  vehicleType=Bike, __v=0)""
</code></pre>

<p>Below Code snippest sending request to API. </p>

<pre><code>            disposable = apiServices.getVehicle(token)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                    { result -&gt;


                        res_message = ""${result.vehicletypes} ""
                        Log.d(""Type=="", res_message)
                    },
                    { error -&gt;
                        res_message = ""${error.message}""
                        // validateToken()
                    }
            )
</code></pre>

<p><em>Model Class</em></p>

<pre><code>  data class Vehicles(val success: Boolean, val vehicletypes: List&lt;VehicleType&gt;, val message: String)
  data class VehicleType(val _id: String, val vehicleType: String, val __v: String)
</code></pre>

<p>I want to get this value on Arralist <strong>VehicleType</strong> List on below <strong>vehicleListArray</strong></p>

<pre><code>   private var vehicleListArray: ArrayList&lt;Model.VehicleType&gt;? = null
</code></pre>

<p>How we can achieve this. 
<strong>Thanks in advance.</strong> </p>
","3992260","","3992260","","2018-03-09 08:40:14","2018-03-09 13:04:40","How to get Json Response in Arraylist from List<Item> using RxJava and Kotlin","<android><kotlin><retrofit2><rx-kotlin>","2","1","","","","CC BY-SA 3.0"
"49189651","2","","49188172","2018-03-09 08:39:48","","0","","<p>I got solution I have to handle Respose as below code snippet. </p>

<pre><code>private fun getVehicleType() { 
    disposable?.add(apiServices.getVehicle(token)
            .observeOn(AndroidSchedulers.mainThread())
            .subscribeOn(Schedulers.io())
            .subscribe(this::handleResponse, this::handleError))
}

private fun handleResponse(vehicles: Model.Vehicles) {
    VehiclesArrayList = ArrayList(vehicles.vehicletypes)
    Log.d(""type=="",""n--""+VehiclesArrayList )
    mAdapter = DataAdapter(VehiclesArrayList !!, this)
    v_android_list.adapter = mAdapter
}

private fun handleError(error: Throwable) {
    Log.d(""type"", error.localizedMessage)
    Toast.makeText(context, ""Error ${error.localizedMessage}"", Toast.LENGTH_SHORT).show()
}
</code></pre>
","3992260","","6244429","","2018-03-09 13:04:40","2018-03-09 13:04:40","","","","0","","","","CC BY-SA 3.0"
"49541333","1","49543422","","2018-03-28 18:05:30","","0","753","<p>Let imagine situation on Kotlin, when we try get request but hasn't internet connection and we get error, then show AlertDialog, and we need retry request if user click on ""positive button"".</p>

<p>This method check for exist user by phone number:</p>

<pre><code>override fun checkPhone(phone: String, context: Context) {
    view?.let {
        it.showOrHideProgressBar(true)
        apiManager.checkPhone(phone)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeOn(Schedulers.io())
                .subscribe({ result -&gt;
                    view?.showOrHideProgressBar(false)
                    if (result.user_exists) {
                        view?.showLogin()
                    } else {
                        val code = result.confirmation_code
                        confirmPhone(phone, code, context)
                    }
                }, { error -&gt;
                    handleAnyError(error, context)
                }).addToCompositeDisposable(compositeDisposable)
    }
}
</code></pre>

<p>And here common method for handle errors:</p>

<pre><code>private fun handleAnyError(it: Throwable, context: Context) {
    view?.showOrHideProgressBar(false)
    when (it) {
        is SocketTimeoutException -&gt; showDialogWithException(context)
        is UnknownHostException -&gt; showDialogWithException(context)
        else -&gt; {
            if (it.message.equals(MESS_429)) {
                view?.showAnyError(context.getString(R.string.err_429))
            } else if (it.message.equals(MESS_422)) {
                view?.showAnyError(context.getString(R.string.err_422))
            }
        }
    }
}
</code></pre>

<p>Finally, method to show dialog suggesting retrying request when click positive button:</p>

<pre><code>fun showDialogWithException(context: Context) {
if (!(context as Activity).isFinishing) {
    DialogInternetUtils().showOkDialog(
            context,
            context.getString(R.string.no_internet_connection),
            DialogInterface.OnClickListener
            { dialogInterface, i -&gt;
                dialogInterface?.dismiss()
                if (i == Dialog.BUTTON_NEGATIVE) {
                    dialogInterface!!.dismiss()
                    return@OnClickListener
                } else if (i == Dialog.BUTTON_POSITIVE) {
                    // here handle click button positive, need retry request
                }
            })
}
</code></pre>

<p>}</p>

<p>Please, help me finish handle click on positive button to retry request.
I guess, need handle error in methods <code>.doOnError()</code> or <code>.onErrorResumeNext()</code> but I'm stuck here...</p>
","7369357","","","","","2018-03-28 20:15:59","Kotlin, how can retry request if get error when tap on button of dialog","<android><kotlin><kotlin-extension><rx-kotlin>","1","0","","","","CC BY-SA 3.0"
"49543422","2","","49541333","2018-03-28 20:15:59","","2","","<p>You could pass a function to be executed when the dialog button is clicked:</p>

<pre><code>fun showDialogWithException(context: Context, action: () -&gt; Unit) {
  if (!(context as Activity).isFinishing) {
    DialogInternetUtils().showOkDialog(
        context,
        context.getString(R.string.no_internet_connection),
        DialogInterface.OnClickListener
        { dialogInterface, i -&gt;
          dialogInterface?.dismiss()
          if (i == Dialog.BUTTON_NEGATIVE) {
            dialogInterface!!.dismiss()
            return@OnClickListener
          } else if (i == Dialog.BUTTON_POSITIVE) {
            action()
          }
        })
  }
}
</code></pre>



<pre><code>private fun handleAnyError(it: Throwable, context: Context, action: () -&gt; Unit) {
  view?.showOrHideProgressBar(false)
  when (it) {
    is SocketTimeoutException -&gt; showDialogWithException(context, action)
    is UnknownHostException -&gt; showDialogWithException(context, action)
    else -&gt; {
      if (it.message.equals(MESS_429)) {
        view?.showAnyError(context.getString(R.string.err_429))
      } else if (it.message.equals(MESS_422)) {
        view?.showAnyError(context.getString(R.string.err_422))
      }
    }
  }
}
</code></pre>



<pre><code>override fun checkPhone(phone: String, context: Context) {
  view?.let {
    it.showOrHideProgressBar(true)
    apiManager.checkPhone(phone)
        .observeOn(AndroidSchedulers.mainThread())
        .subscribeOn(Schedulers.io())
        .subscribe({ result -&gt;
          view?.showOrHideProgressBar(false)
          if (result.user_exists) {
            view?.showLogin()
          } else {
            val code = result.confirmation_code
            confirmPhone(phone, code, context)
          }
        }, { error -&gt;
          handleAnyError(error, context, { checkPhone(phone, context) })
        }).addToCompositeDisposable(compositeDisposable)
  }
}
</code></pre>
","4350835","","","","","2018-03-28 20:15:59","","","","1","","","","CC BY-SA 3.0"
"49644088","1","","","2018-04-04 06:19:27","","0","414","<p>This is my code template</p>

<pre><code>getLastMessageSingle()
.flatmap(
    message-&gt;
    if(message.image==null)
        Single.Just(message)
    else
        Single.zip(t1,t2,BiFunction&lt;String,String,String&gt;{
            s1,s2-&gt;
          //body sets data to message

          message
        })
)
//subscribe part
</code></pre>

<p>I found that Single.Just will execute but zip part is never executed. Am i doing any thing wrong or flat function does not support zip in it.</p>

<p>Any help will be appreciated thanks.</p>

<p>Solution:</p>

<p>It was my mistake second single t2 did not produce a response.</p>
","5311864","","5311864","","2018-04-04 06:56:18","2018-04-04 06:56:18","RxKotlin zip inside flatmap","<android><reactivex><rx-kotlin>","2","3","","","","CC BY-SA 3.0"
"49782036","1","49782471","","2018-04-11 18:22:43","","0","1445","<p>I have this problem. I'm trying to sync a local database into my android app with a remote app. I'm creating the logic to upload the new info created locally and the server responds with the remote id save it in the server. To archive this, I'm using a method that takes an array of objects an return an Observable which emit the response of the server for each element.
Like this.</p>

<pre><code>val dailyEntries = App.db.dailyEntryDao().getDailyEntriesCreated()
            dailyEntries.sync(context) //Return an observable
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe({                        
                        val response = DailyEntry(it)//Creates a daily entry using 
                                                      the response from the server
                        thread {                                
                          App.db.dailyEntryDao().update(response)
                        }
                    }, {
                        it.printStackTrace()
                    }, {
                        uploadEnclosures()
                    })
</code></pre>

<p>How you can see, in the onSuccess from the current observable calls another method. It uses the same logic and is showing ahead. </p>

<pre><code>private fun uploadEnclosures() {
        thread {
            val enclosures = App.db.enclosureDao().getEnclosuresCreated()
            enclosures.sync(context)
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe({
                        val response = Enclosure(it)
                        thread {                                
                            App.db.enclosureDao().update(response)
                        }
                    }, {
                        it.printStackTrace()
                    }, {
                        uploadSmokeTest()
                    })
        }
    }
</code></pre>

<p>It goes on with all the tables. Always we perform the update of the next table in the onSuccess of the current Observable. It is done like this because i need to make the sync in a specific order.</p>

<p>My question is, Is there a way to merge all these Observables in just one to perform a single Subscribe and controlling each onNext emotion?</p>

<p>Thanks for the answers </p>
","5420543","","","","","2018-04-11 19:16:21","How to Merge multiple Observables with diferents call backs into one single Stream?","<android><kotlin><rx-java><reactive-programming><rx-kotlin>","1","2","","","","CC BY-SA 3.0"
"49782471","2","","49782036","2018-04-11 18:49:32","","2","","<p>Well yes, but there would be a small bit of work required, you can use <code>concat</code> operator which takes care of the ordering for you and pass it a list of <code>observables</code> in order and then subscribe to it using a single observer which expects <code>Any</code> event to trickle down to it.</p>

<p>To be strict on type safety you can mark your observable source types with a common interface and use instance check to take actions specific to the event type.</p>

<p>Check more <a href=""http://reactivex.io/documentation/operators/concat.html"" rel=""nofollow noreferrer"">here</a></p>

<p>Code example -</p>

<pre><code>fun concatCalls(): Observable&lt;Any&gt; {
    return Observable.concat(src1, src2, ...)
}
</code></pre>

<p>The consumer would look like this then -</p>

<pre><code>concatCalls().subscribe(object: Subscriber&lt;Any&gt; {
    override fun onNext(o: Any) {
       when (o) {
           is Object1 -&gt; // do handling for stuff emitted by src1
           is Object2 -&gt; // do handling for stuff emitted by src2
           ....
           else // skip
    }
    ....
})
</code></pre>
","3622901","","3622901","","2018-04-11 19:16:21","2018-04-11 19:16:21","","","","3","","","","CC BY-SA 3.0"
"49811981","2","","49031599","2018-04-13 07:55:37","","0","","<p>We ended up porting the iOS version ourselves. </p>

<p>It's open source and can be found here: <strong><a href=""https://github.com/tonsser/kaction"" rel=""nofollow noreferrer"">https://github.com/tonsser/kaction</a></strong></p>
","746968","","","","","2018-04-13 07:55:37","","","","0","","","","CC BY-SA 3.0"
"49851127","1","","","2018-04-16 06:50:47","","1","283","<p>I was looking other questions but this one is using a different method.</p>

<p>I’m using MVVM in my Android app.</p>

<p>Actually this is the way that I’m getting data from my server: </p>

<ul>
<li>Inject dataManager into viewModel.</li>
<li>viewModel calls dataManager->fetchUsers</li>
<li>fetchUsers make request to server and return an Observable of Several which in this case should be Several but it’s generic.</li>
<li>viewModel subscribe to this request and expect a Several.</li>
<li>At this point everything works besides Several doesn’t have a list of User. This several have a list of LinkedTreeMap</li>
</ul>

<p><a href=""https://i.stack.imgur.com/UDn9X.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UDn9X.png"" alt=""enter image description here""></a> </p>

<p>I tried to change my dataManager to return a string then map the response in my viewModel but the thing with this is that I will have to do that in every request.</p>

<p>Also I tried to map the request in my dataManager but I got the same link tree map array. </p>

<p>The thing with TypeToken approach is that I have to map in my viewModel. </p>

<p><strong>UPDATED</strong></p>

<p>UsersViewModel</p>

<pre><code> private fun fetchUsers() {
        isLoading.set(false)
        compositeDisposable += dataManager.GET&lt;User&gt;(classJava = User::class)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe( { response -&gt;
                    isLoading.set(false)
                   // Here the response should be a several with a list of users.
                }, { err -&gt;
                    isLoading.set(false)
                })
    }
</code></pre>

<p>GET function:</p>

<pre><code> override fun &lt;T&gt; GET(classJava: KClass&lt;*&gt;): Single&lt;Several&lt;T&gt;&gt; {

    return Rx2AndroidNetworking.get(""EndPoint"")
            .addHeaders(""Authorization"",  apiHeader.protectedAPIHeader.accessToken!!)
            .setOkHttpClient(APIClient.getUnsafeClient())
            .build()
             // Also I tested with
             // .getObjectSingle(Several::class.java) // The thing is that I can't assign the type &lt;T&gt; with this approach.
            .stringSingle
            .map {

                val fromJSON = fromJson&lt;Several&lt;T&gt;&gt;(it)
                fromJSON

            }
}
</code></pre>

<p>fromJson function:</p>

<pre><code>inline fun &lt;reified T&gt; fromJson(json: String): T = Gson().fromJson(json, object: TypeToken&lt;T&gt;() {}.type)
</code></pre>

<p>Several.kt</p>

<pre><code>data class Several&lt;T&gt;(val items: MutableList&lt;T&gt;)
</code></pre>

<p>If I change my GET function to return a String then in UsersViewModel I add a .map like this</p>

<pre><code>private fun fetchUsers() {
        isLoading.set(false)
        compositeDisposable += dataManager.GET&lt;User&gt;(classJava = User::class)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .map(
                    val severalUsers = fromJson&lt;Several&lt;User&gt;&gt;(it)
                    severalUsers 

                )
                .subscribe( { response -&gt;
                    isLoading.set(false)
                   // usersLiveData.value = response
                }, { err -&gt;
                    Log.e(""tag"", ""Ocurred some error"")
                    isLoading.set(false)
                })
    }
</code></pre>

<p>Then I would have a list of Users as expected but What I dont want to do is map the response in UsersViewModel because I would have to do in every single request that expect a list of items.</p>

<p>Is there any way that I could get a several object without map in my viewmodel?</p>
","6606971","","6606971","","2018-04-16 13:40:01","2018-04-16 13:40:01","Kotlin Generic List Parsing","<android><kotlin><android-databinding><kotlin-extension><rx-kotlin>","0","3","","","","CC BY-SA 3.0"
"49929073","1","49931641","","2018-04-19 19:45:02","","0","307","<p>What I would like to do is create a function which runs another function every second. The second function returns <code>Observables&lt;A&gt;</code> and I want the first function to return <code>Observables&lt;A&gt;</code> as well instead of <code>Observable&lt;Observable&lt;A&gt;&gt;</code></p>

<p>for example:</p>

<pre><code>private A calcA(){
   ...
   return new A(...)
}

public Observable&lt;A&gt; getAs(){
   return Observable.create( subscriber -&gt; {
      Bool condition = ...
      do {
         subscriber.onNext(calcA())
      } while (condition)
      subscriber.onComplete()
   })
}

public Observable&lt;A&gt; pollAs(){
   return Observable.create(subscriber -&gt; {
      do {
         subscriber.onNext(getAs()) // Flatten here I guess
         Thread.sleep(1000)
      } while(true)
   })
</code></pre>

<p>So I would like to do something similar (I tried to write this in a Java-ish way, but I will use Kotlin)</p>
","2092686","","","","","2018-04-20 20:22:19","Flatten Observable of Observables","<rx-java><observable><reactivex><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"49931641","2","","49929073","2018-04-19 23:20:34","","2","","<p>You don't need to use the <code>flatMap()</code> operator to flatten the inner observable, since you only want to repeatedly subscribe to the same observable.</p>

<pre><code>public Observable&lt;A&gt; getAs() {
   return Observable.fromCallable( () -&gt; calcA() )
            .repeat()
            .takeWhile( v -&gt; !condition( v );
}
</code></pre>

<p><code>getAs()</code> will emit items until the condition has been reached. It will then complete.</p>

<pre><code>public Observable&lt;A&gt; pollAs(){
   return getAs()
            .repeatWhen( completed -&gt; completed.delay(1000, TimeUnit.MILLISECONDS) );
</code></pre>

<p><code>pollAs()</code> will continually resubscribe to the <code>getAs()</code> observable, pausing for a second between each subscription.</p>

<p>Edit: I have uploaded a 6-month-duration example to <a href=""https://pastebin.com/kSmi24GF"" rel=""nofollow noreferrer"">https://pastebin.com/kSmi24GF</a>
It shows that you have to keep advancing the time for data to come out.</p>
","1241193","","1241193","","2018-04-20 20:22:19","2018-04-20 20:22:19","","","","7","","","","CC BY-SA 3.0"
"50019891","1","50056968","","2018-04-25 10:26:22","","0","1066","<p>My outer <code>RecyclerView</code> crashes either with</p>

<pre><code>IllegalArgumentException: Scrapped or attached views may not be recycled. isScrap:false isAttached:true...
</code></pre>

<p>or</p>

<pre><code>IllegalStateException: The specified child already has a parent. You must call removeView() on the child's parent first.
</code></pre>

<p>Like the title suggests I have an <code>RecyclerView</code> in the list item layout of the first <code>RecyclerView</code>. This layout is used to display messages and the 
inner <code>RecyclerView</code> to display attachments that come with the message. The inner <code>RecyclerViews</code> visibility is set to either <code>GONE</code> or <code>VISIBLE</code> depending whether the message has any attachments or not. The simplified outer list item layout looks like this</p>

<pre><code>ConstraintLayout
    TextView
    TextView
    TextView
    RecyclerView
</code></pre>

<p>And the part of the adapter that handles the inner <code>RecyclerView</code> looks like this</p>

<pre><code>private fun bindFiles(message: Message?) = with(itemView) {
      if (message != null &amp;&amp; message.attachments.isNotEmpty())
      {
            sent_message_attachments.setAsVisible()
            sent_message_attachments.layoutManager = GridLayoutManager(this.context,Math.min(message.attachments.size,3))
            sent_message_attachments.adapter = AttachmentAdapter(message.attachments)
            sent_message_attachments.itemAnimator = null
            sent_message_attachments.setHasFixedSize(true)
      }
      else{
            sent_message_attachments.setAsGone()
            sent_message_attachments.adapter = null
            sent_message_attachments.layoutManager = null
      }
    }
</code></pre>

<p>The bug has something to do with the way I fetch the attachments in the inner adapter since once I disable the part that start the download process, everything is fine. There's no problem when loading images from the device, but once I start the download process, everything goes to hell. This is the part that handles images and kicks off the download process in the inner adapter. I have functions for videos and for other file types that are pretty much the same exact thing but use slightly different layout.</p>

<pre><code>private fun bindImage(item: HFile?) = with(itemView) {
      if (item != null)
      {
        if (item.isOnDevice &amp;&amp; !item.path.isNullOrEmpty())
        {
          if (item.isGif)
          {
            attachment_image.displayGif(File(item.path))
          }
          else
          {
            attachment_image.displayImage(File(item.path))
          }
        }
        else
        {
          //TODO: Add option to load images manually
          FileHandler(item.id).downloadFileAsObservable(false)
              .subscribeOn(Schedulers.io())
              .observeOn(AndroidSchedulers.mainThread())
              .subscribe(
                  { progress -&gt;
                    //TODO: Show download process
                  },
                  { error -&gt; 
                  error.printStackTrace()
                  //TODO: Enable manual retry 
                  },
                  { notifyItemChanged(adapterPosition)} //onComplete
              )
        }
      }
  }
</code></pre>

<p>I use the same structure as above in my <code>DiscussionListAdapter</code> to load discussion portraits (profile pictures etc.) and it does not have the same issue.</p>

<p>These are the extensions functions used to inflate the viewHolders and to display the images</p>

<pre><code>fun ViewGroup.inflate(layoutRes: Int): View
{
  return LayoutInflater.from(context).inflate(layoutRes, this, false)
}

fun ImageView.displayGif(file:File){
  GlideApp.with(context).asGif().load(file).transforms(CenterCrop(), RoundedCorners(30)).into(this)
}

fun ImageView.displayImage(file:File){
  GlideApp.with(context).load(file).transforms(CenterCrop(), RoundedCorners(30)).into(this)
}
</code></pre>

<p>I've been on this for the past couple of days and just can't get my head around it. Any help in any direction is greatly appreciated. I know my explanations can be a bit all over the place so just ask for clarification when needed :)</p>

<h2>UPDATE</h2>

<p>I have now been able to produce this with a <code>GridLayout</code> as well as with <code>RecyclerView</code>. It's safe to assume that the nested <code>RecyclerViews</code> were not the culprit here. I even tried to ditch the Rx-piece that handled loading the images and created an <code>IntentService</code> for the process, but the same crashes still occur.</p>

<p>With <code>GridLayout</code> I mean that instead of having another adapter to populate the nested <code>RecyclerView</code> I use only one adapter to populate the message and to inflate and populate views for the attachments as well and to attach those views to the nested <code>GridLayout</code>.</p>

<p>The crash happens when I start to download a file and then scroll the view, that is supposed to show the downloaded file, out of the screen. That view should get recycled but for some reason the download process (which in my test cases only takes around 100ms-400ms) causes the app to throw one of the two errors mentioned in the original question. It might be worth noting that I'm using <code>Realm</code> and the adapter takes in a <code>RealmResults&lt;Message&gt;</code> list as it's dataset. My presenter looks for changes in the list and then notifies the adapter when needed (changed due to the implementation of <code>IntentService</code>).</p>

<p>This is how I'm capable to reproduce this time and time again:</p>

<ol>
<li>Open a discussion that has messages with attachments</li>
<li>Start to scroll upwards for more messages</li>
<li>Pass a message with an attachment and scroll it off screen while it's still loading</li>
<li>Crash</li>
</ol>

<p>There is no crash if I stop and wait for the download to complete and everything works as intended. The image/video/file gets updated with a proper thumbnail and the app wont crash if I scroll that out of view.</p>

<h2>UPDATE 2</h2>

<p>I tried swapping the nested <code>ViewGroup</code> for a single <code>ImageView</code> just to see is the problem within the nestedness. Lo and behold! It still crashes. Now I'm really confused, since the <code>DiscussionListAdapter</code> I mentioned before has the same exact thing in it and that one works like a charm... My search continues. I hope someone, some day will benefit from my agony.</p>

<h2>UPDATE 3</h2>

<p>I started to log the parent of every <code>ViewHolder</code> in the <code>onBindViewHolder()</code> function. Like expected I got <code>nulls</code> after <code>nulls</code> after <code>nulls</code>, before the app crashed and spew this out.</p>

<pre><code>04-26 21:54:50.718 27075-27075/com.hailer.hailer.dev D/MsgAdapter: Parent of ViewHolder: android.view.ViewOverlay$OverlayViewGroup{82a9fbc V.E...... .......D 0,0-1440,2168}
</code></pre>

<p>There's a method to my madness after all! But this just poses more questions. Why is <code>ViewOverlay</code> used here? As a part of RecyclerView or as a part of the dark magicians plans to deprive me of my sanity?</p>

<p><strong>Sidenote</strong></p>

<p>I went digging into <code>RecyclerViews</code> code to check if I could find a reason for the <code>ViewOverlay</code>mystery. I found out that <code>RecyclerView</code> calls the adapters <code>onCreateViewHolder()</code> function only twice. Both times providing itself as the <code>parent</code> argument for the function. So no luck there... What the hell can cause the item view to have the <code>ViewOverlay</code> as it's parent? The parent is an immutable value, so the only way for the <code>ViewOverlay</code> to be set as the parent, is for something to construct a new <code>ViewHolder</code> and supply the <code>ViewOverlay</code> as the parent object.</p>

<h2>UPDATE 4</h2>

<p>Sometimes I amaze myself with my own stupidity. The <code>ViewOverlay</code> is used because the items are being animated. I didn't even consider this to be an option since I've set the <code>itemAnimator</code> for the <code>RecyclerView</code> as <code>null</code>, but for some odd reason that does not work. The items are still being animated and that is causing this whole charade. So what could be the cause of this? <em>(How I chose to ignore the moving items, I do not know, but the animations became very clear when I forced the app to download same picture over and over again and the whole list went haywire.)</em></p>

<p>My <code>DiscussionInstanceFragment</code> contains the RecyclerView in question and a nested ConstraintLayout that in turn contains an <code>EditText</code> for user input and a send button.</p>

<pre><code>    val v = inflater.inflate(R.layout.fragment_discussion_instance, container, false)
    val lm = LinearLayoutManager(context)
    lm.reverseLayout = true
    v.disc_instance_messages_list.layoutManager = lm
    v.disc_instance_messages_list.itemAnimator = null
    v.disc_instance_messages_list.adapter = mPresenter.messageAdapter
</code></pre>

<p>This is the piece that handles the initialization of the <code>RecyclerView</code>. I'm most definitely setting the <code>itemAnimator</code> as <code>null</code>, but the animations just wont stop! I've tried setting the <code>animateLayoutChanges</code> xml attribute on the root <code>ConstraintLayout</code> and on the <code>RecyclerView</code> but neither of them worked. It's worth mentioning that I also checked whether the <code>RecyclerView</code> had an <code>itemAnimator</code> in different states of the program, and every time I check the animator, it is null. So what is animating my <code>RecyclerView</code>?!</p>
","5778533","","5778533","","2018-04-26 22:50:31","2018-05-09 10:17:39","Setting RecyclerViews itemAnimator to null does not remove animations","<android><android-recyclerview><kotlin><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"50056968","2","","50019891","2018-04-27 06:58:14","","0","","<p>I finally figured out what was causing this. In my <code>DiscussionInstanceView</code> I have a small <code>view</code> that is animated into and out of view with <code>ConstraintLayout</code> keyframe animations. This view only shows the download progress of the chat history and is used only once, when the discussion is first opened. BUT since I had a call to hiding that view every time my dataset got updated, I was forcing the <code>ConstraintLayout</code> to fire of an animation sequence thus making everything animate during the dataset update. I just added a simple check whether I was downloading the history or not and this problem got fixed.</p>
","5778533","","5778533","","2018-05-09 10:17:39","2018-05-09 10:17:39","","","","0","","","","CC BY-SA 4.0"
"50293583","1","50294698","","2018-05-11 13:36:22","","5","3087","<p>I have a list <code>List&lt;FileModel&gt;</code> </p>

<p><code>FileModel</code> is just a class contains <code>id: Int</code></p>

<p><code>id</code> - is ID of photo file I need to fetch and cast to Bitmap</p>

<p>I have a request:</p>

<pre><code>fun getFile(fileId: Int): Single&lt;ResponseBody&gt;
</code></pre>

<p>This request returns <code>ResponseBody</code> which we can cast to Bitmap</p>

<p>And</p>

<pre><code>fun generatePhoto(responseBody: ResponseBody): Single&lt;Bitmap?&gt;
</code></pre>

<p>What I want is to create a function </p>

<pre><code>fun getPhotos(list: List&lt;FileModel&gt;): Single&lt;List&lt;Bitmap&gt;&gt; {
    // Execute getFile(...) for each item in the list
    // Cast getFile(...) result to Bitmap using generatePhoto(...)
    // Return a list of Bitmaps
}
</code></pre>

<p>I've tried something like this but it's completely wrong </p>

<pre><code>fun getPhotos(list: List&lt;FileModel&gt;): Single&lt;List&lt;Bitmap&gt;&gt; {
    return Observable.fromIterable(list)
        .flatMap { getFile(it.id) }
        // How to call generatePhoto(...) here?
}
</code></pre>
","4932519","","4932519","","2018-05-11 13:41:37","2018-05-11 14:52:25","RxJava2. Execute a request for every item in a list","<android><kotlin><rx-java2><rx-android><rx-kotlin>","3","2","","","","CC BY-SA 4.0"
"50294698","2","","50293583","2018-05-11 14:35:56","","6","","<p>You can do it like this: </p>

<pre><code>fun getPhotos(list: List&lt;FileModel&gt;): Single&lt;List&lt;Bitmap&gt;&gt; {
    // Get an Observable of the list
    return Observable.fromIterable(list)
        // Get a Single&lt;ResponseBody&gt; for every FileModel
        .flatMapSingle { getFile(it.id) }
        // Get a Single&lt;Bitmap&gt; for every ResponseBody
        .flatMapSingle { file -&gt; generatePhoto(file) }
        // Put everything back on a list
        .toList()
}
</code></pre>

<p>This way you can iterate over the list <code>flapMapping</code> for your needs and then putting it back together as a list in the end. The <code>toList()</code> operator is just a convenience that puts together the items emitted previously.</p>

<p>And to call this function just go:</p>

<pre><code>    getPhotos(list)
        .doOnSuccess { resultList -&gt;
          Log.d(""Rx"", ""doOnSuccess.resultList=[$resultList]"")
        }
        .subscribe()
</code></pre>

<p>By the way, if you have <code>RxKotlin</code> as a dependency you can get an <code>Observable</code> from a <code>List</code> with an extension function, like this:
<code>myList.toObservable()</code></p>
","2418721","","2418721","","2018-05-11 14:52:25","2018-05-11 14:52:25","","","","0","","","","CC BY-SA 4.0"
"50465274","2","","47173475","2018-05-22 10:20:39","","0","","<p>I did it using below:</p>

<pre><code>extension Observable {
  func circuitBreaker&lt;T&gt;() -&gt; Observable&lt;T&gt; {
    let relay = PublishSubject&lt;T&gt;()
    _ = self.subscribe { (event: Event&lt;Element&gt;) in
      if let event = event as? Event&lt;T&gt; { relay.on(event) }
    }
    return relay.asObservable()
  }
}
</code></pre>
","1083859","","","","","2018-05-22 10:20:39","","","","0","","","","CC BY-SA 4.0"
"50536642","1","50566723","","2018-05-25 20:46:03","","0","267","<p>I have a scenario where I have a function, scanForTargets, that returns an Observable of type FoundNumber. In FoundNumber I just need an ID field I can grab out of it. As each element comes back in the scanResults Observable, I want to check to see if the name field matches one of the names on a target list. If so, then I want to emit that. For example, if I am looking for numbers 1, and 2, and scanForTargets() emits back 1, 2, 3, and 4, then I want scanForValues to emit back only 1 and 2.</p>

<p>The caveat is that I only want to continue doing this until either:
 1) A time period elapses (in which case I throw and error)
 2) All items on the String list are found before the timeout.</p>

<p>What I have so far looks like this, but I cannot get it to work for me mostly due to the shortcut of stopping once/if all of the targets are found before the timeout. </p>

<pre><code>fun scanForValues(targetList: List&lt;String&gt;): Observable&lt;FoundNumber&gt; {
    val scanResult = scanForTargets()

    return scanResult.doOnNext {scanResult -&gt; Log.d(TAG, ""Found potential target: "" + scanResult.name) }
            .filter(TargetPredicate(targetList)) //See if it's one of those we want
            .timeout(5, TimeUnit.SECONDS) //Wait a max of 5 seconds to find all items
            .doOnError { Log.w(TAG, ""Failed to scan""}"") }
            .map{s-&gt;scanResult.name}  
}

class TargetPredicate(private val targetList: List&lt;String&gt;) : Predicate&lt;ScanResult&gt; { override fun test(scanResult: ScanResult): Boolean {
        if(scanResult == null) {
            return false
        }
        return scanResult.name in targetList 
    }
}
</code></pre>

<p>How can I also add the check to stop if I find all of the items in the list? I can't just add another predicate right?</p>

<p>Thanks.</p>

<p>Update: As requested, here is some data to show what I mean.</p>

<p>Let's say that the scanForTargets() and supporting code looks like this:</p>

<pre><code>var emittedList: List&lt;String?&gt; = listOf(null, ""0"", ""1"", ""2"", ""3"")


fun scanForTargets(): Observable&lt;FoundNumber&gt; = Observable
    .intervalRange(0, emittedList.size.toLong(), 0, 1, TimeUnit.SECONDS)
    .map { index -&gt; FoundNumber(emittedList[index.toInt()]) }

data class FoundNumber(val targetId: String?)
</code></pre>

<p>Now if scanForValues was called with a list of 1 and 2, then it should emit back an Observable of 1 and then 2.</p>
","443654","","443654","","2018-06-05 21:02:28","2018-06-06 08:54:17","Checking a list and timing out if all entries not found in RxJava/RxKotlin","<rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"50566723","2","","50536642","2018-05-28 12:40:14","","1","","<p>No, it is not as simple as adding another <code>filter</code>.</p>

<p>A possible solution is to use <code>scan</code> to remove items from a set containing your targets, and complete when the set becomes empty.</p>

<p>Example:</p>

<pre><code>val targets = listOf(""a"", ""b"", ""c"")

fun scanForTarget(): Observable&lt;String&gt; = Observable.just(""a"", ""b"")

fun scanForValues(targets: List&lt;String&gt;): Completable {
    val initial = targets.toMutableSet()
    return scanForTarget()
            .timeout(5, TimeUnit.SECONDS)
            .scan(initial) { acc, next -&gt; acc.remove(next); acc }
            .filter { it.isEmpty() }
            .singleOrError()
            .toCompletable()
}
</code></pre>

<p>Note: a <code>Completable</code> is a special type of publisher that can only signal <code>onComplete</code> or <code>onError</code>.</p>

<hr>

<p><strong>Update</strong>: response to question update.</p>

<p>The new example in your question won't work, because <code>null</code> values are not allowed in <code>RxJava2</code>.</p>

<p>Assuming you fix that, the following solution may help you.</p>

<pre><code>fun scanForValues(targets: List&lt;String&gt;): Observable&lt;String&gt; {
    val accumulator: Pair&lt;Set&lt;String&gt;, String?&gt; = targets.toSet() to null
    return scanForTarget()
            .timeout(5, TimeUnit.SECONDS)
            .scan(accumulator) { acc, next -&gt; 
                val (set, previous) = acc
                val item = if (next in set) next else null
                (set - next) to item     // return set and nullable item
            }
            .filter { it.second != null } // item not null
            .take(initial.size)           // limit to the number of items
            .map { it.second }            // unwrap the item from the pair
            .map { FoundNumber(it) }      // wrap in your class
}
</code></pre>

<p>Instead of using only the <code>Set&lt;String&gt;</code> as the accumulator, now we also add the item.</p>

<p>The item is nullable, this allows us to check if a given item was present or not.</p>

<p>Notice that no <code>null</code> values are passed through the observable flow. In this case <code>null</code> values are wrapped inside <code>Pair&lt;Set&lt;String&gt;, String?&gt;</code> which are never <code>null</code> themselves.</p>
","2597143","","2597143","","2018-06-06 08:54:17","2018-06-06 08:54:17","","","","5","","","","CC BY-SA 4.0"
"50625166","1","","","2018-05-31 13:10:41","","1","1935","<p><em>I have seen other questions here related to this error but still not able to fix. Plus I'm asking this question because unlike other questions here, I'm getting this error only when I convert the code to Kotlin from Java.</em></p>

<p>I'm using this same RxJava code in Java, it works fine. 
I converted to Kotlin and it gives this error - </p>

<blockquote>
  <p>Kotlin Compilation Error : None of the following functions can be
  called with the arguments supplied</p>
</blockquote>

<pre><code>var observable : Observable&lt;Bitmap&gt; = Observable.just(bitmap)

var observer:Observer&lt;Bitmap&gt; = Observer&lt;Bitmap&gt;() {
                fun onSubscribe(d: Disposable) {
                    disposable = d
                }
                fun onNext(orientedBitmap:Bitmap) {
                    // do something
                }
                fun onError(e:Throwable) {
                }
                fun onComplete() {

                }
            }

observable.subscribeOn(Schedulers.io())
          .observeOn(AndroidSchedulers.mainThread())

          // It shows the error here
          .subscribe(observer)
</code></pre>

<p>Can anyone explain what's wrong here?</p>
","1724453","","","","","2018-05-31 14:42:01","Error: None of the following functions can be called with the arguments supplied when converted to Kotlin from Java","<android><kotlin><rx-java><android-bitmap><rx-kotlin>","1","3","","","","CC BY-SA 4.0"
"50724513","1","50731185","","2018-06-06 15:46:08","","7","9948","<p>I am stuck at this problem, which should be fairly simple. I need subscriber to execute a code block when the <code>Maybe</code> has completed as an <code>Empty Maybe</code>. I found that </p>

<ol>
<li>we can pass default Maybe value or use switchIfEmpty but I feel both are hacky. </li>
<li>Also there is a subscribe function which takes onComplete function (along with handlers for other two events), but onComplete does not take any argument which can be used to find if maybe was completed empty.</li>
<li>Another way could be <code>Maybe.isEmpty.blockingGet()</code>, but it is dirty too.</li>
</ol>

<p>I have tried following (<em>Kotlin Syntax</em>):-</p>

<pre><code>fun &lt;T&gt; Maybe&lt;T&gt;.subscribeWithEmptyHandler(onSuccess: (T) -&gt; Unit, onError: (Throwable) -&gt; Unit, onEmpty: () -&gt; Unit) {
    this.isEmpty.subscribe({ if (it) onEmpty() }, { onError(it) })
    this.subscribe({ onSuccess(it) }, { onError(it) })
}
</code></pre>

<p>But as expected it is running subscription twice, tested here:-</p>

<pre><code>Maybe.create&lt;Int&gt; {
    println(""subscribing"")
    //Remove line below to create Empty Maybe
    it.onSuccess(5)
    it.onComplete()
}
    .subscribeWithEmptyHandler({println(""success"")},{println(""error"")},{println(""empty"")})
</code></pre>

<p>Could somebody please suggest neater way to solve this?</p>
","1699956","","1000551","","2019-01-18 11:23:45","2021-03-14 22:49:50","RxJava Maybe: Any neat way to handle Empty case?","<kotlin><rx-java><rx-kotlin>","3","0","","","","CC BY-SA 4.0"
"50731185","2","","50724513","2018-06-06 23:52:17","","8","","<p>Use <code>Maybe.doOnEvent</code> (java example):</p>

<pre><code>Maybe
 .empty()
 .doOnEvent((value, error)-&gt; {
    if (value==null &amp;&amp; error == null) {
      System.out.println(""empty!"");
    }})
 .subscribe();
</code></pre>
","471955","","","","","2018-06-06 23:52:17","","","","2","","","","CC BY-SA 4.0"
"50937317","1","50937413","","2018-06-19 21:40:58","","0","1339","<p>There seems to be a limit to the number of Observables to use as parameters in the zip method for Kotlin. If this is accurate, what is the best alternative?</p>

<p>For instance, when I use 9 parameters it works as expected. When I add a 10th parameter I receive the error <strong>Cannot infer a type for this parameter. Please specify it explicitly</strong></p>

<pre><code>Observable.zip(
            //TODO: parameterize exchange symbols based on pair
            methodOne() as Observable&lt;Any&gt;),
            methodTwo() as Observable&lt;Any&gt;),
            methodThree() as Observable&lt;Any&gt;),
            methodFour() as Observable&lt;Any&gt;),
            methodFive() as Observable&lt;Any&gt;),
            methodSix() as Observable&lt;Any&gt;),
            methodSeven() as Observable&lt;Any&gt;),
            methodEight() as Observable&lt;Any&gt;),
            methodNine() as Observable&lt;Any&gt;),
            { oneResult, twoResult, threeResult, fourResult, fiveResult, sixResult, sevenResult, eightResult, nineResult -&gt;
                    //logic here applying computation to results
            })
            .subscribe(
                    {},
                    {
                        println(String.format(""Error: %s"", it.message))
                    })
            .unsubscribe()
}
</code></pre>
","2253682","","2253682","","2018-06-19 21:46:00","2018-06-19 21:54:55","Is There A Limit to The Number of Observables in .zip Method?","<java><android><kotlin><rx-java><rx-kotlin>","3","0","","","","CC BY-SA 4.0"
"50937413","2","","50937317","2018-06-19 21:50:52","","3","","<p>RxJava only supports up to 9 distinct sources with <code>zip</code>. Beyond that, you have to use the <a href=""http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#zip-java.lang.Iterable-io.reactivex.functions.Function-"" rel=""nofollow noreferrer""><code>zip(Iterable&lt;ObservableSource&gt;, Func&lt;Object[],R&gt;)</code></a> method and cast each element of the <code>Object[]</code> back to its respective type.</p>

<blockquote>
  <p>Returns an <code>Observable</code> that emits the results of a specified <code>combiner</code> function applied to combinations of items emitted, in sequence, by an <code>Iterable</code> of other <code>ObservableSource</code>s.
  zip applies this function in strict sequence, so the first item emitted by the new <code>ObservableSource</code> will be the result of the function applied to the first item emitted by each of the source <code>ObservableSource</code>s; the second item emitted by the new <code>ObservableSource</code> will be the result of the function applied to the second item emitted by each of those <code>ObservableSource</code>s; and so forth.</p>
  
  <p>The resulting <code>ObservableSource&lt;R&gt;</code> returned from zip will invoke <code>onNext</code> as many times as the number of <code>onNext</code> invocations of the source <code>ObservableSource</code> that emits the fewest items.</p>
  
  <p>The operator subscribes to its sources in order they are specified and completes eagerly if one of the sources is shorter than the rest while disposing the other sources. Therefore, it is possible those other sources will never be able to run to completion (and thus not calling <code>doOnComplete()</code>). This can also happen if the sources are exactly the same length; if source A completes and B has been consumed and is about to complete, the operator detects A won't be sending further values and it will dispose B immediately. For example:</p>

<pre><code>zip(Arrays.asList(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&gt; a)
</code></pre>
  
  <p><code>action1</code> will be called but <code>action2</code> won't. 
  To work around this termination property, use <code>doOnDispose(Action)</code> as well or use <code>using()</code> to do cleanup in case of completion or a <code>dispose()</code> call.
  Note on method signature: since Java doesn't allow creating a generic array with new <code>T[]</code>, the implementation of this operator has to create an <code>Object[]</code> instead. Unfortunately, a <code>Function&lt;Integer[], R&gt;</code> passed to the method would trigger a <code>ClassCastException</code>.</p>
</blockquote>
","61158","","","","","2018-06-19 21:50:52","","","","0","","","","CC BY-SA 4.0"
"50939047","1","50939320","","2018-06-20 01:43:26","","0","919","<p>Sorry nooby kotlin question</p>

<pre><code>func someThingElse(): Observable&lt;String&gt; {
   return Observable.just(""aasd"")
} 

fun doSomething(): Observable&lt;Void&gt; {
    return someThisElse().fetch().map { () } 
}
</code></pre>

<p>How do i return an observable of void?
I tried <code>void</code>, <code>Void()</code>, <code>Void</code></p>
","242769","","242769","","2018-06-20 02:01:45","2018-06-20 21:24:17","RXKotlin how do you map to void?","<android><kotlin><rx-java><rx-kotlin>","2","0","","","","CC BY-SA 4.0"
"50939320","2","","50939047","2018-06-20 02:24:51","","2","","<p><code>Unit</code> in Kotlin corresponds to <code>void</code> in Java. Like <code>void</code>, <code>Unit</code> is the default return type of any function in Kotlin that does return anything.</p>

<p>Using <a href=""https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-2.0#completable"" rel=""nofollow noreferrer""><code>Completable</code></a>, <a href=""https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-2.0#single"" rel=""nofollow noreferrer""><code>Single</code></a> or <a href=""https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-2.0#maybe"" rel=""nofollow noreferrer""><code>Maybe</code></a> might make more sense though</p>
","2874139","","2874139","","2018-06-20 21:24:17","2018-06-20 21:24:17","","","","0","","","","CC BY-SA 4.0"
"50945144","1","50945458","","2018-06-20 09:46:04","","0","481","<p>Here is my Retrofit Interface and creation code:</p>

<pre><code>interface SSApi {
companion object {
    private fun create(): SSApi {
        val httpClient = OkHttpClient().newBuilder()
        val networkInterceptor = Interceptor { chain -&gt;
            val request = chain.request()?.newBuilder()?.addHeader(""api-key"", SSConstants.API_KEY)?.build()
            chain.proceed(request!!)
        }

        val loggingInterceptor = HttpLoggingInterceptor()
        loggingInterceptor.level = HttpLoggingInterceptor.Level.BODY

        httpClient.addNetworkInterceptor(networkInterceptor).addInterceptor(loggingInterceptor)

        val retrofit = Retrofit.Builder()
                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
                .addConverterFactory(GsonConverterFactory.create())
                .baseUrl(SSConstants.BASE_URL)
                .client(httpClient.build())
                .build()

        return retrofit.create(SSApi::class.java)
    }

    val api by lazy {
        SSApi.create()
    }

    var disposable: Disposable? = null
}

@GET
fun getWeatherInfo(@Url url: String): Observable&lt;OpenWeatherMapInfo&gt;
}
</code></pre>

<p>And here is how I use the <code>disposable</code>:</p>

<pre><code>    private fun getWeather() {
    disposable = api
            .getWeatherInfo(SSConstants.OPEN_WEATHER_MAP_API_ENDPOINT)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                    { results -&gt; Log.i(""Dale"", results.toString())},
                    { error -&gt; Log.i(""Dale"", error.message)}
            )
    }
</code></pre>

<p>When I execute the request, I can see that it my <code>OPEN_WEATHER_MAP_API_ENDPOINT</code> still appends to my <code>baseUrl</code>. </p>

<p>Here is my Constants class for reference:</p>

<pre><code>object SSConstants {
const val OPEN_WEATHER_MAP_API_ENDPOINT = ""api.openweathermap.org/data/2.5/weather?q=Catbalogan,PH&amp;units=metric""
const val BASE_URL = ""https://api.xxx.xxx/""
}
</code></pre>
","6243778","","6243778","","2018-06-20 09:53:29","2018-06-20 10:01:27","Retrofit Dynamic URL still appends to the Base URL","<android><kotlin><retrofit2><rx-android><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"50945458","2","","50945144","2018-06-20 10:00:03","","1","","<p>Your issue is that you didn't provide the full URL in the dynamic call, and that's why Retrofit is trying to make the call relative to the base url still. Just add <code>https://</code> to the dynamic URL:</p>

<pre><code>const val OPEN_WEATHER_MAP_API_ENDPOINT = ""https://api.openweathermap.org/data/2.5/weather?q=Catbalogan,PH&amp;units=metric""
</code></pre>

<p><a href=""https://futurestud.io/tutorials/retrofit-2-how-to-use-dynamic-urls-for-requests"" rel=""nofollow noreferrer"">Here</a> is an article discussing how the dynamic URL is resolved in different scenarios, for further reference.</p>
","4465208","","","","","2018-06-20 10:00:03","","","","0","","","","CC BY-SA 4.0"
"50949942","1","","","2018-06-20 13:53:49","","0","70","<p>I'm working on an Android App. I have a list of photos loaded in memory. I want to make use of Reactive library, so I declare a memory-base datasource where I save the list:</p>

<pre><code>    @Singleton
    class MemoryPhotosSource @Inject constructor() {
         var photos: MutableList&lt;Image&gt; = mutableListOf()
         ...

         // Here is my function to add items to list.
         fun addPhoto(image: Image) {
              photos.add(image)
         }

         // Here is my function to list the items.
         fun listPhotos(): List&lt;Image&gt; = photos

         // Here is my function to remove items from list.
         fun removePhoto(image: Image): Image {
               photos.remove(image)
               return image
         }
    }
</code></pre>

<p>Then, I have a ViewModel where I call these methods:</p>

<pre><code>class CreateDocumentFromPhotosViewModel @Inject constructor(): ViewModel() {
       @Inject
       lateinit var source: MemoryPhotosSource

       fun listImages(): Observable&lt;List&lt;Image&gt;&gt; = Observable.fromCallable {
           source.listPhotos()
       }.applySchedulers()

       fun addImage(image: Image) {
           source.addPhoto(image)
       }

       fun removeImage(image: Image): Image {
           source.removePhoto(image)
           return image
       }
}
</code></pre>

<p>Finally, I subscribe in my application:</p>

<pre><code>    dis add viewModel.listImages()
            .subscribe {
                adapter.data = it
            }

    dis add onDelete
            .map { viewModel.removeImage(it) }
            .map { showSnackbar(parentView, resources.getString(R.string.document_removed), resources.getString(R.string.undo), it)}
            .map { it.subscribe { viewModel.addImage(it) } }
            .subscribe()
</code></pre>

<p>Listing and adding images work nicely. However, when I press the delete button, which publish in the onDelete subject, the snackbar is shown, but no change is performed to the RecyclerView adapter. Debugging, I noticed that the <code>removePhoto</code> function is being called in <code>MemoryPhotosSource</code> class, and the list is being successfuly modified. However, it does not emit the changes, that's why the RecyclerView is not updated. I confirmed this behavior by leaving the application and entering again, which forced the repainting of the Recycler, and then, the removed element didn't show up, as it should be. So, I think the problem is the list doesn't emit the changes when an item is removed. </p>

<p>Does anybody know a way to solve this? Any help would be much appreciated.</p>

<p>Thanks!</p>
","9858922","","","","","2018-06-20 14:00:04","List not emitting on remove item (RxKotlin)","<android><kotlin><reactive-programming><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"50992991","1","51000130","","2018-06-22 17:31:32","","2","1646","<p>Can someone please explain me why <code>PublishSubject</code> is not working nicely with <code>firstOrError()</code>?</p>

<p>I'm expecting <code>firstOrError</code> to return a <code>NoSuchElementException</code> when the <code>PublishSubject</code> is created without any value.</p>

<p>I wrote some tests in order to better explain the problem:</p>

<pre><code>@Test
fun `test one`() {
    // THIS TEST FAILS
    val publishSubject = PublishSubject.create&lt;Boolean&gt;()

    val testSubscriber = publishSubject
        // .toFlowable(BackpressureStrategy.LATEST) // With or without this doesn't make any difference
        .firstOrError()
        .test()

    testSubscriber
        .assertNotComplete()
        .assertError(NoSuchElementException::class.java)
}

@Test
fun `test two`() {
    // THIS TEST PASSES
    val flowable = Flowable.empty&lt;Boolean&gt;()

    val testSubscriber = flowable
        .firstOrError()
        .test()

    testSubscriber
        .assertNotComplete()
        .assertError(NoSuchElementException::class.java)
}
</code></pre>
","3096313","","1115491","","2018-06-22 20:51:45","2018-06-23 21:42:48","PublishSubject does not work with firstOrError()","<android><rx-java><rx-java2><rx-kotlin>","1","4","","","","CC BY-SA 4.0"
"51000130","2","","50992991","2018-06-23 10:11:32","","3","","<p>Short version: <strong><code>Flowable</code> emits no element and completes whereas <code>PublishSubject</code> emits no element and doesn't complete</strong>.</p>

<p>Long version:</p>

<p>You assume that <code>PublishSubject.create&lt;Boolean&gt;()</code> is equivalent to <code>Flowable.empty&lt;Boolean&gt;()</code>. But they are not.</p>

<p>First, let's see what <a href=""http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#firstOrError--"" rel=""nofollow noreferrer""><code>firstOrError()</code></a> really does:</p>

<blockquote>
  <p>Returns a Single that emits only the very first item emitted by this Observable or signals a NoSuchElementException if this Observable is empty. </p>
</blockquote>

<p>So you it makes sense that <code>Flowable.empty&lt;Boolean&gt;()</code> works, because it's, well, empty. What does it mean <a href=""http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#empty--"" rel=""nofollow noreferrer"">""empty""</a>?</p>

<blockquote>
  <p>Returns a Flowable that emits no items to the Subscriber and immediately <strong>invokes its onComplete method.</strong></p>
</blockquote>

<p>I emphasized important fragment. <code>Flowable.empty()</code> calls <code>onComplete</code> whereas <code>PublishSubject.create()</code> just creates <code>Subject</code> which waits for calling <code>onNext()</code> on him or for subscribers. </p>

<p>So <code>Flowable.empty()</code> is empty, but <code>PublishSubject.create()</code> is not empty. <strong>It doesn't call <code>onComplete</code>.</strong> See <a href=""http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/subjects/PublishSubject.html"" rel=""nofollow noreferrer"">PublishSubject docs</a> for more info.</p>

<p>If you want to have empty <code>PublishSubject</code>, simply call <code>PublishSubject.empty&lt;Boolean&gt;()</code>.</p>
","2707179","","2707179","","2018-06-23 21:42:48","2018-06-23 21:42:48","","","","4","","","","CC BY-SA 4.0"
"51072877","1","","","2018-06-27 23:49:45","","0","26","<p>I tried the following:</p>

<pre><code>$ git clone https://github.com/ReactiveX/RxKotlin.git    
$ cd RxKotlin/    
$ gradle build
</code></pre>

<p>It fails with:</p>

<blockquote>
  <p>...FAILURE: Build failed with an exception.</p>
  
  <ul>
  <li><p>Where: Build file '/home/myuser/RxKotlin/build.gradle' line: 13</p></li>
  <li><p>What went wrong: A problem occurred evaluating root project 'rxkotlin'.</p>
  
  <blockquote>
    <p>org/gradle/api/internal/project/AbstractProject</p>
  </blockquote></li>
  </ul>
</blockquote>
","1988515","","","","","2018-06-28 00:14:16","RxKotlin repo gradle build compilation fails with gradle 4.7 (JDK 1.8)","<kotlin><rx-kotlin><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"51144111","1","51144570","","2018-07-02 21:44:56","","0","368","<p>I have an function in <code>@Dao</code>. Lets call that class <code>DaoClass</code></p>

<p><code>abstract fun getData() : Flowable&lt;List&lt;Data&gt;&gt;</code></p>

<p>Now, I want to check if list of data returned is empty or not. I dug through the DaoClass_Impl (generated at build time) and I found out that the Flowable won't be empty. So, </p>

<p><code>getData().isEmpty</code> will always return false.</p>

<p>So what I did was 
<code>getData().singleOrError().map{it.isEmpty()}</code> to return if the returned list is actually empty. </p>

<p>But I am having problem as the value is not getting emitted.</p>
","1042124","","","","","2018-07-02 22:48:44","Converting Flowable<List<T>> to Single<Boolean>","<android><kotlin><android-room><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"51144570","2","","51144111","2018-07-02 22:48:44","","2","","<p>You need to check what <code>singleOrError</code> actually does:</p>

<blockquote>
  <p>Returns a Single that emits the single item emitted by this Flowable, if this Flowable emits only a single item, otherwise if this Flowable completes without emitting any items a NoSuchElementException will be signaled and if this Flowable emits more than one item, an IllegalArgumentException will be signaled.</p>
</blockquote>

<p>What you're looking for is <code>firstOrError</code>, which returns just the first value emitted.</p>
","1452094","","","","","2018-07-02 22:48:44","","","","0","","","","CC BY-SA 4.0"
"51185759","1","51186490","","2018-07-05 07:39:56","","3","3698","<p>I have code that does blocking operation in while loop (downloads some data from a server). Client does not know how many items are going to be returned in each step. Loop breaks when N items are downloaded.</p>

<pre><code>val n = 10
val list = ArrayList&lt;T&gt;()

while (list.size &lt; n) {
    val lastItemId = list.last()?.id ?: 0
    val items = downloadItems(lastItemId)
    list.addAll(items)
}
</code></pre>

<p><code>downloadItems</code> performs blocking HTTP call and returns list. Now let's assume <code>downloadItems</code> changes and new return type is <code>Observable&lt;Item&gt;</code>. How could I change the code to use RxJava without performing something like <code>blockingGet</code>?</p>
","1740335","","1740335","","2018-07-05 16:54:07","2018-07-05 18:24:13","Converting loop with condition into RxJava stream","<android><rx-java><rx-java2><rx-kotlin><rx-kotlin2>","2","0","1","","","CC BY-SA 4.0"
"51186490","2","","51185759","2018-07-05 08:21:45","","8","","<p>You could use <code>repeatUntil</code> to achieve this:</p>

<pre><code>var totalItems = 0    
var id = 0
Observable.fromCallable {
            downloadItems(id)
        }
        .flatMap {
            list -&gt;
                totalItems += list.size
                id = list.last()?.id ?: 0
                Observable.just(list)
        }
        .repeatUntil({totalItems &gt; n})
        .subscribe({result -&gt; System.out.println(result) })
</code></pre>
","1055395","","1055395","","2018-07-05 18:24:13","2018-07-05 18:24:13","","","","0","","","","CC BY-SA 4.0"
"51368000","1","","","2018-07-16 18:25:22","","1","517","<p>I am using following Kotlin code to generate proxy (This will also generate Rx methods)</p>

<pre><code>@ProxyGen
@VertxGen
interface JobService {
    @Fluent
    fun getCertain(jobId: Int, handler: Handler&lt;AsyncResult&lt;Job?&gt;&gt;): JobService
}
</code></pre>

<p>When I see generated Rx Code it is as follows.</p>

<pre><code>public Single&lt;Job&gt; rxGetCertain(int jobId) { 
   return new io.vertx.reactivex.core.impl.AsyncResultSingle&lt;Job&gt;(handler -&gt; {
     getCertain(jobId, handler);
   });
}
</code></pre>

<p><strong>Issue:-</strong></p>

<p>Unfortunately i am not able to use this in Kotlin as kotlin won't allow null values for non-null fields and it is throwing following exception.</p>

<pre><code>java.lang.IllegalArgumentException: Parameter specified as non-null is null
</code></pre>

<p>How do i force Vertx CodeGen to generate return type as MayBe so that my code works without any issues in kotlin.</p>
","2631567","","","","","2019-02-01 08:00:01","How to Force Vertx Rx CodeGen To Generate MayBe As Return Type","<kotlin><rx-java2><vert.x><rx-kotlin><codegen>","1","4","","","","CC BY-SA 4.0"
"51422390","1","","","2018-07-19 12:11:03","","0","1372","<p>I tried it by the following program but it shows the error that kotlin variable is expected:  </p>

<p>[<img src=""https://i.stack.imgur.com/eQqNp.png"" alt=""enter image description here""></p>
","9921917","","1797950","","2018-07-19 12:28:13","2019-03-14 09:52:37","can we swap two numbers in kotlin using two variables and take input from user?","<kotlin><kotlin-android-extensions><kotlin-extension><rx-kotlin><kotlin-interop>","4","2","","","","CC BY-SA 4.0"
"51679808","1","","","2018-08-03 20:35:48","","2","234","<p>I use rxjava to read from the room database on the Schedulers.io thread. I've noticed that when my app is killed and reopened it always crashes with </p>

<blockquote>
  <p>Cannot access database on the main thread since it may potentially
  lock the UI for a long period of time.</p>
</blockquote>

<p>I use MVVM architecture with Dagger and instantiate view model with lazy</p>

<pre><code>private val viewModel by lazy { ViewModelProviders.of(this, viewModelFactory).get(StudentsListViewModel::class.java) }
</code></pre>

<p>All my requests to database look like this: </p>

<pre><code>compositeDisposable.add(viewModel.students
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .doOnNext {
                    &lt;I do things here&gt;
                }
                .doOnError { it.printStackTrace() }
                .subscribe()
        )
</code></pre>

<p>I kill disposable onDestroy with </p>

<pre><code>compositeDisposable.apply {
            clear()
            dispose()
        }
</code></pre>

<p>So, why is it crushing on recreate and what is it trying to do on the main thread?</p>

<p>My ModelView class:</p>

<pre><code>class StudentsListViewModel@Inject
constructor(private val studioRepository: StudioRepository): ViewModel() {

val students: Flowable&lt;List&lt;Student&gt;&gt; = studioRepository.students

fun getStudentById(studentId: Int): Maybe&lt;Student&gt; {
    return studioRepository.getStudentById(studentId)
}

fun insertStudent(student: Student): Unit = studioRepository.insertStudent(student)
fun insertStudentFlat(student: Student) = studioRepository.insertStudentFlat(student)

fun updateStudent(student: Student) {
    studioRepository.updateStudent(student)
}

fun deleteAllStudents() {
    studioRepository.deleteAllStudents()
}

fun getStudentsNames(): Flowable&lt;List&lt;String&gt;&gt; = studioRepository.studentNames

val studentsCount: Flowable&lt;Int&gt; = studioRepository.studentsCount

fun getTicketById(ticketId: Int): Maybe&lt;Ticket&gt; {
    return studioRepository.getTicketById(ticketId)
}

fun getTicketByIdFlat(ticketId: Int): Ticket {
    return studioRepository.getTicketByIdFlat(ticketId)
}

fun updateTicket(ticket: Ticket) = studioRepository.updateTicket(ticket)

val activeTicketsStudentIds: Flowable&lt;List&lt;Int&gt;&gt; = studioRepository.activeTicketsStudentIds

fun getClassesByIdFlat(values: List&lt;Int&gt;): List&lt;YClass&gt; = studioRepository.getYclassesByIdFlat(values)

private fun getStudent(studentId: Int): Maybe&lt;Student&gt; = studioRepository.getStudentById(studentId)

private fun getAllActiveTicketsForAStudent(studentId: Int): Maybe&lt;List&lt;Ticket&gt;&gt; = studioRepository.getAllActiveTicketsForAStudent(studentId)

fun archiveStudentByIdAndDeactivateHisTickets(id: Int) {
    getStudent(id)
            .subscribeOn(Schedulers.io())
            .observeOn(Schedulers.io())
            .doOnSuccess {
                it.isArchived = true
                studioRepository.updateStudent(it)
                getAllActiveTicketsForAStudent(id)
                        .subscribeOn(Schedulers.io())
                        .observeOn(Schedulers.io())
                        .doOnSuccess { list -&gt;
                            list.forEach {
                                it.actual = false
                                updateTicket(it)
                            }
                        }
                        ?.subscribe()
            }
            .doOnError {
                it.printStackTrace()
            }
            .subscribe()
}
</code></pre>

<p>}</p>

<pre><code>08-03 22:17:45.601 7776-7776/com.labfoodandfriends.nikitagudkovs.jlogOpenClasses E/AndroidRuntime: FATAL EXCEPTION: main
    Process: com.labfoodandfriends.nikitagudkovs.jlogOpenClasses, PID: 7776
    java.lang.RuntimeException: **Unable to start activity** ComponentInfo{com.labfoodandfriends.nikitagudkovs.jlogOpenClasses/com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity}: java.lang.RuntimeException: java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.
        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2778)
        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2856)
        at android.app.ActivityThread.-wrap11(Unknown Source:0)
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1589)
        at android.os.Handler.dispatchMessage(Handler.java:106)
        at android.os.Looper.loop(Looper.java:164)
        at android.app.ActivityThread.main(ActivityThread.java:6494)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)
     Caused by: java.lang.RuntimeException: java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.
        at com.labfoodandfriends.nikitagudkovs.jlog.factory.AppViewModelFactory.create(AppViewModelFactory.java:55)
        at android.arch.lifecycle.ViewModelProvider.get(ViewModelProvider.java:134)
        at android.arch.lifecycle.ViewModelProvider.get(ViewModelProvider.java:102)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity$viewModel$2.invoke(StudentsActivity.kt:83)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity$viewModel$2.invoke(StudentsActivity.kt:69)
        at kotlin.SynchronizedLazyImpl.getValue(LazyJVM.kt:74)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity.getViewModel(Unknown Source:7)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity.observeStudents(StudentsActivity.kt:136)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsActivity.onCreate(StudentsActivity.kt:103)
        at android.app.Activity.performCreate(Activity.java:7009)
        at android.app.Activity.performCreate(Activity.java:7000)
        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1214)
        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2731)
        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2856) 
        at android.app.ActivityThread.-wrap11(Unknown Source:0) 
        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1589) 
        at android.os.Handler.dispatchMessage(Handler.java:106) 
        at android.os.Looper.loop(Looper.java:164) 
        at android.app.ActivityThread.main(ActivityThread.java:6494) 
        at java.lang.reflect.Method.invoke(Native Method) 
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438) 
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807) 
     Caused by: java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.
        at android.arch.persistence.room.RoomDatabase.assertNotMainThread(RoomDatabase.java:204)
        at android.arch.persistence.room.RoomDatabase.query(RoomDatabase.java:232)
        at com.labfoodandfriends.nikitagudkovs.jlog.database.dao.StudentDAO_Impl.getStudents(StudentDAO_Impl.java:272)
        at com.labfoodandfriends.nikitagudkovs.jlog.repository.StudioRepositoryImpl.&lt;init&gt;(StudioRepositoryImpl.kt:50)
        at com.labfoodandfriends.nikitagudkovs.jlog.di.AppModule.provideStudioRepository(AppModule.kt:26)
        at com.labfoodandfriends.nikitagudkovs.jlog.di.AppModule_ProvideStudioRepositoryFactory.get(AppModule_ProvideStudioRepositoryFactory.java:24)
        at com.labfoodandfriends.nikitagudkovs.jlog.di.AppModule_ProvideStudioRepositoryFactory.get(AppModule_ProvideStudioRepositoryFactory.java:10)
        at dagger.internal.DoubleCheck.get(DoubleCheck.java:47)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsListViewModel_Factory.get(StudentsListViewModel_Factory.java:17)
        at com.labfoodandfriends.nikitagudkovs.jlog.activity.students.StudentsListViewModel_Factory.get(StudentsListViewModel_Factory.java:8)
        at com.labfoodandfriends.nikitagudkovs.jlog.factory.AppViewModelFactory.create(AppViewModelFactory.java:53)
</code></pre>
","7663625","","7663625","","2018-08-04 14:16:27","2018-08-04 14:16:27","rxJava and app lifecycle error","<android><rx-java><rx-android><android-room><rx-kotlin>","0","11","","","","CC BY-SA 4.0"
"51786847","1","51822996","","2018-08-10 12:44:07","","0","216","<p>I have an object that generates different strings in the random moments of time, and i need to sudscribe to this generator to take these strings and provide them to ui (maybe it will be multiple subscribers in different activities).
Suppose, i got the following code: </p>

<p>generator:</p>

<pre><code>class Generator {

    private var stringToGenerate = """"

    var subject: BehaviorSubject&lt;String&gt; = BehaviorSubject.create&lt;String&gt;()

    init {
        //seems like these instructions are skipped
        subject
                .subscribeOn(AndroidSchedulers.mainThread())
                .doOnNext { t -&gt; Log.i(""subject doOnNext"", Thread.currentThread().name + "" "" + Thread.currentThread().id) }
                .observeOn(AndroidSchedulers.mainThread())
                .map { _ -&gt; Log.i(""subject map"", Thread.currentThread().name + "" "" + Thread.currentThread().id) }

        //imitation of async creating of strings in separate thread
        timer(""timerThread"", false, 2000L, 2000L) {
            stringToGenerate = System.currentTimeMillis().toString()
            subject.onNext(stringToGenerate)
        }
    }
}
</code></pre>

<p>One of the activities that must consume generated strings:</p>

<pre><code>class TestActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(R.layout.activity_test)

        val wrongThreadObserver = object : Observer&lt;String&gt; {
            override fun onComplete() {
            }

            override fun onSubscribe(d: Disposable) {
            }

            override fun onNext(t: String) {
                Log.i(""wrongThreadObserver"", Thread.currentThread().name + "" "" + Thread.currentThread().id)
            }

            override fun onError(e: Throwable) {
            }
        }

        val generator = Generator()
        generator.subject.subscribe(wrongThreadObserver)

        //for correct work illustration
        val correctThreadObserver = object : Observer&lt;String&gt; {
            override fun onComplete() {
            }

            override fun onSubscribe(d: Disposable) {
            }

            override fun onNext(t: String) {
                Log.i(""correctThreadObserver"", Thread.currentThread().name + "" "" + Thread.currentThread().id)
            }

            override fun onError(e: Throwable) {
            }
        }

        val mainThreadSubject = BehaviorSubject.create&lt;String&gt;()
        mainThreadSubject
                .doOnNext { obj -&gt; Log.i(""correctThread doOnNext"", Thread.currentThread().name + "" "" + Thread.currentThread().id) }
                .subscribeOn(Schedulers.io())
                .observeOn(Schedulers.newThread())
                .subscribe(correctThreadObserver)
        mainThreadSubject.onNext(""test thread"")
        val handler = Handler()
        handler.postDelayed({ mainThreadSubject.onNext(""test thread 2"") }, 1000)
        handler.postDelayed({ mainThreadSubject.onNext(""test thread 3"") }, 2000)
    }
}
</code></pre>

<p>In this case <strong>correctThreadObserver</strong>, created just in activity, works fine, but <strong>wrongThreadObserver</strong> keeps work in timer thread, it seems like it ignoring instructions <strong>subscribeOn, ObserveOn, doOnNext</strong> in Generator, no matter where these instuctions called - in init, in timer thread, in activity by getting object to it from generator - <strong>wrongThreadObserver</strong> still work in timer thread. 
So log is:</p>

<blockquote>
  <p><em>I/correctThread doOnNext: main 2</em></p>
  
  <p><em>I/correctThreadObserver: RxNewThreadScheduler-1 941</em></p>
  
  <p><em>I/correctThread doOnNext: main 2</em></p>
  
  <p><em>I/correctThreadObserver: RxNewThreadScheduler-1 941</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
  
  <p><em>I/correctThread doOnNext: main 2</em></p>
  
  <p><em>I/correctThreadObserver: RxNewThreadScheduler-1 941</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
</blockquote>

<p>No <code>doOnNext</code> and no main thread for <code>wrongThreadObserver</code>
What i do wrong?</p>
","10208467","","9389285","","2018-08-10 12:58:15","2018-08-13 12:59:37","RxKotlin - Wrong subscribeOn, observeOn thread changing for Subject out of Activity?","<android><multithreading><kotlin-android-extensions><rx-kotlin><rx-kotlin2>","1","1","","","","CC BY-SA 4.0"
"51822996","2","","51786847","2018-08-13 12:59:37","","0","","<p>I find the following solution: 
We must subscribe to <code>Observable</code>, not to <code>Subject</code>, so we must use the result of method <code>observeOn()</code>, not object ""subject"" itself.
If multiple subscribtion is needed, we can cache the result of <code>observeOn</code> in separate variable:</p>

<pre><code>//in Generator
.......
var observableInSeparateVar = subject.observeOn(AndroidSchedulers.mainThread())
.......

//in TestActivity
.......
generator.observableInSeparateVar.subscribe(wrongThreadObserver)
.......
</code></pre>

<p>Also we can call <code>observeOn()</code> to subject and subscribe after that: </p>

<pre><code>//in TestActivity
.......
generator.subject
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(wrongThreadObserver)
</code></pre>
","10208467","","","","","2018-08-13 12:59:37","","","","0","","","","CC BY-SA 4.0"
"51862452","2","","48126761","2018-08-15 16:13:16","","1","","<p>First of all try not rely on Side effects, that make things unpredictable .. for example this function</p>

<pre><code>fun insertKafaniInDb(kafani: List&lt;Kafana&gt;) {
    Observable.fromCallable { kafanaDao.insertAll(kafani) }
            .subscribeOn(Schedulers.io())
            .subscribe {
                Timber.d(""Inserted ${kafani.size} kafani from API in DB..."")
            }
}
</code></pre>

<p>its return type is Unit, it's better to include it in the stream, this is done by converting to <code>Completable</code>  so it will be something like this</p>

<pre><code>  fun insertKafaniInDb(kafani: List&lt;Kafana&gt;) {
    return  Observable.fromAction { kafanaDao.insertAll(kafani) }
        .subscribeOn(Schedulers.io())
        .doOnComplete { Timber.d(""Inserted ${kafani.size} kafani from API in DB..."") }
  }
</code></pre>

<p>other functions that return Unit (void in java) should be converted the same way to completabel. so now I'll try to rewrite your logic without using side effects. and explaining each step.</p>

<pre><code>fun getUpdatedData(): Single&lt;MutableList&lt;String&gt;&gt;? {
    return kafanaRepository.getFavoriteKafani()
        .toObservable()
        .flatMap { Observable.fromIterable(it) } //to iterate on favorite items
        .flatMap { localItem -&gt;
          kafanaRepository.getKafaniFromApi()
              .flatMap { Observable.fromIterable(it) } //to iterate api items
              .filter { localItem == it } //search for the favorite item in Api response
              .flatMap {
                //we update this item then we pass it after update
                kafanaRepository.updateFavoriteKafana(it)
                    .andThen(Observable.just(it))
              }
              .defaultIfEmpty(localItem) //if it's not found, then no update needed we take this it.

        }.toList() // we collect the updated and non updated local items to list
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
  }
</code></pre>

<p>Hope this could help you.
Final words .. Rx is about ordering your thoughts and plug your logic in functional way .. try to avoid using <code>onNext()</code> to update global variables, use it just for logging and non Business logic.</p>
","4252667","","","","","2018-08-15 16:13:16","","","","0","","","","CC BY-SA 4.0"
"51981476","1","51988382","","2018-08-23 08:34:43","","0","2928","<p>My code-</p>

<pre><code>val accessTokenRequest: JsonObjectRequest = JsonObjectRequest(Request.Method.GET, url,
            Response.Listener { response -&gt;
            },
            Response.ErrorListener { error -&gt;
                Toast.makeText(activity,error.toString(), Toast.LENGTH_LONG).show()
            }
    )

    AppController.instance!!.addToRequestQueue(accessTokenRequest)
</code></pre>

<p>Header I wat to put -
""Search""&amp;
""Authorization""</p>
","8188198","","","","","2018-08-23 14:39:33","How to put header in url using volley in Kotlin?","<kotlin><android-volley><kotlin-android-extensions><kotlin-extension><rx-kotlin>","1","1","","","","CC BY-SA 4.0"
"51988382","2","","51981476","2018-08-23 14:39:33","","6","","<p>Try using the following code to add headers </p>

<pre><code>val accessTokenRequest: JsonObjectRequest = object : JsonObjectRequest(
    Request.Method.GET, """", JSONObject(),
    Response.Listener&lt;JSONObject?&gt; {
        TODO(""not implemented"") //To change body of created functions use File | Settings | File Templates.
    }, Response.ErrorListener {
    TODO(""not implemented"") //To change body of created functions use File | Settings | File Templates.
}) {
    @Throws(AuthFailureError::class)
    override fun getHeaders(): Map&lt;String, String&gt; {
        var params: MutableMap&lt;String, String&gt;? = super.getHeaders()
        if (params == null) params = HashMap()
        params[""Authorization""] = ""Your authorization""
        //..add other headers
        return params
    }
}
</code></pre>

<p><strong>Note: To generate kotlin code from java try using Ctrl + Shift + Alt + K or simply copy paste it on a kotlin file.</strong></p>
","5119753","","","","","2018-08-23 14:39:33","","","","2","","","","CC BY-SA 4.0"
"52033814","1","52039569","","2018-08-27 06:42:41","","3","10294","<p>I need to parse this information-</p>

<pre><code>[
{
    ""artist"": ""12"",
    ""image"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
},
{
    ""video_id"": ""12"",
    ""video_title"": ""23""
}]
</code></pre>

<p>As you can see the first field is different, how to parse below information differently and the first field differently in Kotlin.</p>

<p>I am parsing 1st part as-</p>

<pre><code>response -&gt;

                for (i in 0..(response.length() -1)){

                    /**
                        FIRST SONG
                     **/
                    val song = response.get(0).toString()

                    val listOfSongs = response.toString()

                    val parser = Parser()
                    val stringBuilder = StringBuilder(song)
                    val json: JsonObject = parser.parse(stringBuilder) as JsonObject
                    val firstArtist = json.string(""artist"")
                    val firstImage = json.string(""image"")
                    val intent = Intent(activity,ResultPage::class.java)
                    intent.putExtra(""firstArtist"",firstArtist)
                    intent.putExtra(""firstImage"",firstImage)

                    startActivity(intent)
                    /**
                        FIRST SONG
                    **/


                }
            }
</code></pre>

<p>and am also using KLAXON library here.</p>
","8188198","","","","","2019-10-30 07:22:49","How to parse below Json data in Kotlin?","<kotlin><android-volley><kotlin-android-extensions><kotlin-extension><rx-kotlin>","2","0","2","","","CC BY-SA 4.0"
"52039569","2","","52033814","2018-08-27 12:38:28","","10","","<p>For your json, this should work :</p>

<pre><code>fun parseResponse(response: String) {

    var artist = """"
    var image = """"
    val videoList = ArrayList&lt;Video&gt;()

    val jsonArray = JSONArray(response)

    (0..5).forEach { index -&gt;
        val jsonObject = jsonArray.getJSONObject(index)
        if (jsonObject.has(""artist"") &amp;&amp; jsonObject.has(""image"")) {
            artist = jsonObject.getString(""artist"")
            image = jsonObject.getString(""image"")
        }
        else if (jsonObject.has(""video_id"") &amp;&amp; jsonObject.has(""video_title"")) {
            val newVideo = Video(jsonObject.getString(""video_id""), jsonObject.getString(""video_title""))
            videoList.add(newVideo)
        }
    }
}

class Video(val id: String, val title: String)
</code></pre>

<p>But this way is very lengthy and unnecessary. I would suggest use an Object Mapping library like <a href=""https://github.com/google/gson"" rel=""noreferrer"" title=""GSON"">GSON</a> or <a href=""https://github.com/square/moshi"" rel=""noreferrer"" title=""MOSHI"">Moshi</a>.</p>

<p>For that, the video list in your json should ideally be something like:</p>

<pre><code>[
    {
        ""artist"": ""12"",
        ""image"": ""23"",
        ""videos"": [
            {
                ""video_id"": ""12"",
                ""video_title"": ""23""
            },
            {
                ""video_id"": ""12"",
                ""video_title"": ""23""
            },
            {
                ""video_id"": ""12"",
                ""video_title"": ""23""
            },
            {
                ""video_id"": ""12"",
                ""video_title"": ""23""
            },
            {
                ""video_id"": ""12"",
                ""video_title"": ""23""
            }
        ]
    }
]
</code></pre>

<p>Using this Json, you can easily create a class for this object, e.g.</p>

<pre><code>class Artist(val id: String, val name: String, val image: String, val videos: List&lt;Video&gt;)
class Video(@field:Json(name = ""video_id"") val id: String, @field:Json(name = ""video_title"") val title: String)
</code></pre>

<p>And parse them easily like this:</p>

<pre><code>    Moshi.Builder().build().adapter(Artist::class.java).fromJson(response)
</code></pre>

<p>and then access this information like: </p>

<pre><code>    val artist = Moshi.Builder().build().adapter(Artist::class.java).fromJson(response)

    intent.putExtra(""firstArtist"",artist?.name)
    intent.putExtra(""firstImage"",artist?.image)
</code></pre>
","8085421","","8085421","","2018-08-27 12:44:46","2018-08-27 12:44:46","","","","1","","","","CC BY-SA 4.0"
"52096003","1","52096151","","2018-08-30 11:32:16","","2","1059","<p>So i have been trying to convert my EditText input  that i get from my TextWatcher to an observable of stream but i cannot convert it.</p>

<p>I am trying the following</p>

<pre><code>etSearch.addTextChangedListener(object: TextWatcher{
        override fun afterTextChanged(p0: Editable?) {
            //I want to create an observable here to send events
               Observable.create(e-&gt;e.next(p0));
        }

        override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {

        }

        override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {

        }
    })
</code></pre>

<p>I am not able to figure out where i should create my events so that i am able to subscribe to it.</p>
","6048312","","","","","2018-08-30 11:39:42","Convert my EditText Input to an observable stream","<android><kotlin><rx-kotlin>","2","0","1","","","CC BY-SA 4.0"
"52096151","2","","52096003","2018-08-30 11:39:42","","4","","<p>You can simply create an extension in <code>kotlin</code> which returns a <code>Flowable</code> of <code>EditTextFlow</code></p>

<pre><code>fun EditText.addTextWatcher(): Flowable&lt;EditTextFlow&gt; {
    return Flowable.create&lt;EditTextFlow&gt;({ emitter -&gt;
        addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {
                emitter.onNext(EditTextFlow(p0.toString(), EditTextFlow.Type.BEFORE))
            }

            override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {
                emitter.onNext(EditTextFlow(p0.toString(), EditTextFlow.Type.ON))
            }

            override fun afterTextChanged(p0: Editable?) {
                emitter.onNext(EditTextFlow(p0.toString(), EditTextFlow.Type.AFTER))
            }
        })
    }, BackpressureStrategy.BUFFER)
}
</code></pre>

<p><strong>EditTextFlow</strong></p>

<pre><code>data class EditTextFlow(
        val query: String,
        val type: Type
) {
    enum class Type { BEFORE, AFTER, ON }
}
</code></pre>

<p>Then use it like this:</p>

<pre><code>etSearch.addTextWatcher()
                .filter { it.type == EditTextFlow.Type.AFTER }
                .map { it.query }
                .flatMap { /*Make any request or anything*/ }
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeBy(
                        onNext = {
                            // Update UI here
                        },
                        onError = {
                            // Log error
                        }
                )
</code></pre>
","6744566","","","","","2018-08-30 11:39:42","","","","0","","","","CC BY-SA 4.0"
"52098683","1","","","2018-08-30 13:47:56","","1","79","<p>I have Extension of EditText where I'm listenig to events from keyboard of EditText. I need to know when user press any button for showing (or not showing) error. So I make Observable for keys (rxbinding2) and I'm getting any press but when I press back button and cursor still in this EditText method onBackPressed doesn`t work.
How to filter onBack pressed?</p>

<pre><code>fun EditText.changeWithFormatting(formatter: (String) -&gt; String): Observable&lt;String&gt; {
    return Observable.merge(
            afterTextChangeEvents()
                    .map { editableText },
            keys()
                    .filter { it.action == KeyEvent.ACTION_UP }
                    .map { editableText }
    )
            .map { changeText(formatter(it.toString())) }
}
</code></pre>
","5555912","","","","","2018-08-30 14:11:56","OnBackPressed doesn't work when observe EditText KEys","<android><kotlin><rx-android><rx-kotlin><rx-binding>","1","0","","","","CC BY-SA 4.0"
"52140410","1","","","2018-09-02 19:33:45","","0","1619","<p>I need to show error view if status is error and <code>call.isEmpty()</code> returns <code>true</code>.</p>

<p>Is there a better way to achieve this result?</p>

<pre><code>val errorVisible = states.asFlowable()
    .map { it.status == Status.ERROR }
    .flatMap { isError -&gt;
        if (isError) call.isEmpty()
        else Flowable.just(false)
    }
</code></pre>

<p><code>call.isEmpty()</code> returns <code>Flowable&lt;Boolean&gt;</code> but can return something else like <code>Single&lt;Boolean&gt;</code>.</p>

<p><strong>EDIT:</strong> Another question, if <code>call.isEmpty()</code> returns <code>Flowable&lt;Boolean&gt;</code> how can I merge two streams (two <code>Flowable&lt;Boolean&gt;</code>s - <code>states.isError</code> and <code>call.isEmpty()</code>) and map it to one <code>Flowable&lt;Boolean&gt;</code> so it's one condition?</p>
","2897341","","2897341","","2018-09-02 20:51:00","2019-11-28 14:25:44","rx - Conditional flatMap / add condition to flowable boolean","<kotlin><rxjs><rx-java><rx-java2><rx-kotlin>","3","2","","","","CC BY-SA 4.0"
"52190121","1","","","2018-09-05 16:55:30","","0","2367","<p>I am new to the Rx world so please bear with me.</p>

<p>My code is in Kotlin but a Java code will help also.</p>

<p>I have 2 methods, one of them loads tasks from the database, if there are tasks, I want to send them to the server.</p>

<pre><code>fun getListFromDb(): Single&lt;List&lt;TaskEntity&gt;&gt; {
    return taskEntityDao.getAll()
}

 fun syncTasks(localTasks: TaskSyncRequest): Observable&lt;ApiResponse&lt;List&lt;TaskEntity&gt;&gt;&gt; {
    return taskServices.syncTasks(localTasks)
}
</code></pre>

<p>I know I can use flatmap to chain observables, but just couldn't get it working between Single and Observables.</p>
","10216356","","","","","2018-09-28 23:32:37","How to chain an Observable with a Single in RxJava?","<rx-java><rx-java2><flatmap><rx-kotlin><rx-kotlin2>","1","4","","","","CC BY-SA 4.0"
"52198889","1","52231733","","2018-09-06 07:40:10","","0","367","<p>I have trying to parse actual response body even if server returns 401 HTTP Exception.</p>

<pre><code>protected inline fun &lt;RESPONSE : ParentResponse&gt; executeNetworkCall(
        crossinline request: () -&gt; Single&lt;RESPONSE&gt;,
        crossinline successful: (t: RESPONSE) -&gt; Unit,
        crossinline error: (t: RESPONSE) -&gt; Unit) {

    request().subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(
                    { t: RESPONSE -&gt;
                        errorHandler!!.checkApiResponseError(t)?.let {
                            listener?.onErrorWithId(t.message!!)
                            error(t)
                            return@subscribe
                        }
                        successful(t)
                    }
                    ,
                    { t: Throwable -&gt;
                        listener?.onErrorWithId(t.message!!)
                    }
            )
}
</code></pre>

<p>This is what I have written. It parses response and error very well when both are separate in usual ways. But I want to parse success response when I get even 401 HTTP Exception.</p>

<p>Thanks in advance..</p>

<p>Response with 401 HTTP looks like below.</p>

<pre><code>401 Unauthorized - HTTP Exception 
{""Message"":""Authentication unsuccessful"",""otherData"":""//Some data""}
</code></pre>

<p>By the way I have to check HTTP error code..</p>

<pre><code>if (statusCode==401){
 print(""Authentication unsuccessful"")
}
</code></pre>
","3282461","","","","","2018-09-08 03:31:55","How to parse success body response on http exception 401?","<android><kotlin><rx-java2><rx-kotlin><android-mvvm>","1","2","","","","CC BY-SA 4.0"
"52219187","1","53335756","","2018-09-07 09:10:07","","4","8072","<p>Here is my Code that for Volley Request:- </p>

<pre><code>    val searchRequest = object : JsonArrayRequest(Request.Method.GET,url,
            Response.Listener { response -&gt;

                val result = response.toString()


            },
            Response.ErrorListener { error -&gt;
                Toast.makeText(activity, ""Error!"",Toast.LENGTH_LONG)
                        .show()
                Log.d(""ERROR"",error.toString())
            })
    {
        override fun getBody(): ByteArray {

           //   TODO add Body, Header section works  //////////

            return super.getBody()
        }

        override fun getBodyContentType(): String {
            return ""application/json""
        }


        override fun getHeaders() : Map&lt;String,String&gt; {
            val params: MutableMap&lt;String, String&gt; = HashMap()
            params[""Search-String""] = songName
            params[""Authorization""] = ""Bearer ${accessTx.text}""
            return params
        }
    }
    AppController.instance!!.addToRequestQueue(searchRequest)
</code></pre>

<p>I want to add this information in the body section</p>

<p>video_id =  ""BDJIAH"" , 
audio_quality = ""256"" </p>

<p>here is the sample to add above information in the below segment.</p>

<p>{
""video_id"":""ABCDE"",
 ""audio_quality"":""256""
}</p>

<p>Basically, I am facing problem in ByteArray section. That doesn't work for me.</p>
","8188198","","","","","2020-02-05 06:51:58","How to add Body in Url in Volley request in Kotlin?","<json><kotlin><android-volley><kotlin-android-extensions><rx-kotlin>","2","0","","","","CC BY-SA 4.0"
"52231733","2","","52198889","2018-09-08 03:31:55","","1","","<p>You can use Retrofit's <code>Response</code> class for that purpose, which is a wrapper over your response object, it has both your response's data and error bodies and also the success state, so instead of doing <code>Single&lt;RESPONSE&gt;</code> use <code>Single&lt;Response&lt;RESPONSE&gt;&gt;</code>.</p>

<p>Parsing the response object can be something like this:</p>

<pre><code>{ t: Response&lt;RESPONSE&gt; -&gt;
if (t.isSuccessful())
    // That's the usual success scenario
else
    // You have a response that has an error body.
}
,
{ t: Throwable -&gt;
    // You didn't reach the endpoint somehow, maybe a timeout or an invalid URL.
}
</code></pre>
","5036979","","","","","2018-09-08 03:31:55","","","","0","","","","CC BY-SA 4.0"
"52255995","1","","","2018-09-10 10:39:42","","0","67","<p>I'm looking to make a sample project with a clean architecture approach and i have some difficulties to transform a single to another.</p>

<p>I have my retrofit service (with a Single) :</p>

<pre><code>@GET(""nearbysearch/json"") fun getNearbyPlaces(@Query(""type"") type: String, @Query(""location"") location: String, @Query(""radius"") radius: Int): Single&lt;GooglePlacesNearbySearchResult&gt;
</code></pre>

<p>And i use it in my repository implementation :</p>

<pre><code>override fun getNearbyPlaces(type: String, location: String, radius: Int): Single&lt;List&lt;Place&gt;&gt; {
    return googlePlacesApi.getNearbyPlaces(type, location, radius)
        .subscribeOn(Schedulers.io())
        .observeOn(Schedulers.computation())
        .doOnSuccess { googlePlacesNearbySearchResult -&gt; nearbyPlaceListResultMapper.transform(googlePlacesNearbySearchResult) }
}
</code></pre>

<p>In this single, i want to transform my <code>Single&lt;GooglePlacesNearbyResultSearch&gt;</code> to a <code>Single&lt;List&lt;Place&gt;&gt;</code>, and i want to do this with my mapper <code>NearbyPlaceListResultMapper</code></p>

<p>The issue is i don't succeed in having a <code>Single&lt;List&lt;Place&gt;&gt;</code> at the end. I can transform it to an Observable or a Completable but not the Single one.</p>

<p>Can anyone help me to have it in a cleaner way ?</p>

<p>Thanks</p>
","10291684","","","","","2018-09-10 17:56:22","ReactiveX - Single<T> to Single<R>","<rx-java><retrofit2><reactivex><clean-architecture><rx-kotlin>","1","0","1","","","CC BY-SA 4.0"
"52319803","2","","48129498","2018-09-13 18:30:20","","6","","<p>The problem is that, because of type erasure, the type of the parameters to the <code>zipper</code> function are unknown. As you can see in the definition of <code>zip</code>:</p>

<pre><code>public static &lt;T, R&gt; Single&lt;R&gt; zip(final Iterable&lt;? extends SingleSource&lt;? extends T&gt;&gt; sources, Function&lt;? super Object[], ? extends R&gt; zipper)
</code></pre>

<p>You'll have to use <code>Any</code> as the input of your array, and cast to whatever you need each of them to be:</p>

<pre><code>roomDatabase.userFriendsDao().getUserFriendsDtosForToken(token).subscribe(
        { userFriends: List&lt;UserFriendDTO&gt; -&gt;
            Single.zip(
                    getLocationSingleForEveryUser(userFriends),
                    Function&lt;Array&lt;Any&gt;, List&lt;Location&gt;&gt; { t: Array&lt;Any&gt; -&gt; listOf&lt;Location&gt;() })
        },
        { error: Throwable -&gt; }
)
</code></pre>
","1963973","","","","","2018-09-13 18:30:20","","","","0","","","","CC BY-SA 4.0"
"52331198","1","","","2018-09-14 11:38:18","","0","72","<p>I have following code that works well.</p>

<pre><code>Observable.from(...)
    .map { // List&lt;Object&gt;
        if (My_Condition_is_true) {
            //...
        }
        val newList = getNewListIfConditionIsOkay(it)
        newList.map { item -&gt; toSomethingElse(item) }
    }
    .subscribeBy(myErrorFun) {
        //...
    }
</code></pre>

<p>I feel <code>map</code> operator does not looks cool but I have no idea how to fix it. This is what is in my mind.</p>

<pre><code>Observable.from(...)
        .doOnNext {// List&lt;Object&gt;
            if (My_Condition_is_true) {
                //...
                return getNewListIfConditionIsOkay(it)
            }
            return it
        .map { // List&lt;Object&gt;
            it.map { item -&gt; toSomethingElse(item) }
        }
        .subscribeBy(myErrorFun) {
            //...
        }
</code></pre>

<p>My Observable returns only a list. What is your recommendation? </p>
","513413","","472495","","2018-09-18 09:03:43","2018-09-18 09:03:43","How to pass modified list downstream in RxJava in Android?","<android><rx-java2><rx-kotlin>","2","2","","","","CC BY-SA 4.0"
"52387704","1","53049617","","2018-09-18 13:27:46","","0","234","<p>I'm trying to set up a DrawerLayout in the MvRx sample project but i am kind of stuck.</p>

<p>Totally new to both epoxy and MvRx in general and i have been playing around for a week now learning about the framework and testing components i need to convert our app to MvRx.</p>

<p><strong>What i am wondering is how you setup a DrawerLayout view using MvRx.</strong></p>

<p>Also the current examples are very comprehensive for noobs. Anyone has a minimalist starter available?</p>

<p>// JQ</p>
","2333802","","4438601","","2018-09-19 06:35:44","2018-10-29 16:12:15","MvRX DrawerLayout + generally more examples wanted","<android><kotlin><drawerlayout><rx-kotlin><epoxy>","1","0","1","","","CC BY-SA 4.0"
"52435122","1","","","2018-09-21 00:45:44","","0","462","<p><a href=""https://i.stack.imgur.com/FDdi6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FDdi6.png"" alt=""enter image description here""></a></p>

<p>So I have a database in Firebase Cloud Firestore that stores users and tasks. Each user has a number of fields such as name, username,etc. I want to know how to fetch each field that is associated with each user using Kotlin. </p>

<p>I'm trying to get all these accounts so I can display them in an activity called friends, that's why I want to collect all these accounts from the database. Here is a picture of my database to have a clear understanding of what I'm trying to do. </p>
","5730289","","10191554","","2018-09-21 05:03:19","2018-09-21 05:03:19","how to get data from Firebase Cloud Firestore in Kotlin","<android><android-studio><kotlin><google-cloud-firestore><rx-kotlin>","0","3","","","","CC BY-SA 4.0"
"52446947","1","52448032","","2018-09-21 15:31:52","","2","517","<p>I'm trying to use combineLatest with several RxTextViews and I thought that I was disposing my Disposables properly but it looks like I'm still getting a memory leak.</p>

<pre><code>val one = RxTextView.afterTextChangeEvents(one)
            val two = RxTextView.afterTextChangeEvents(two)
            val three = RxTextView.afterTextChangeEvents(three)
            val four = RxTextView.afterTextChangeEvents(four)
            val five = RxTextView.afterTextChangeEvents(five)

            val disposable = Observables.combineLatest(one, two, three, four, five) { oneEvent, twoEvent, threeEvent, fourEvent, fiveEvent -&gt;
                 //combining happening with these strings: oneEvent.view().text.toString  }
                    .skip(1) 
                    .debounce(1000, TimeUnit.MILLISECONDS)
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe {
                        //network call
                    }
            compositeDisposable.add(disposable)
        }
</code></pre>

<p>And then in my <code>onStop</code> I dispose of it.</p>

<pre><code>override fun onStop() {
    super.onStop()
    if (!compositeDisposable.isDisposed) {
        compositeDisposable.dispose()
    }
}
</code></pre>

<p>I read that if some Views are referenced in the onNext() method, then there’s a potential NullPointerException which is what I believe is happening. Here's my NPE I'm getting:</p>

<pre><code>fatal Exception: java.lang.NullPointerException: view == null
       at com.jakewharton.rxbinding2.internal.Preconditions.checkNotNull(Preconditions.java:27)
       at com.jakewharton.rxbinding2.widget.RxTextView.afterTextChangeEvents(RxTextView.java:159)
       at MyFragment$setUpTextListeners$1.execute(MyFragment.kt:170)
</code></pre>

<p>Here's the fragment I'm using:</p>

<pre><code>private lateinit var viewModel: MyViewModel
private lateinit var binding: FragmentMyThingsBinding

private val compositeDisposable = CompositeDisposable()

override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {

    binding = FragmentMyThingsBinding.inflate(inflater, container, false)
    viewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)
    binding.viewModel = viewModel

    //calls to kick off business logic

    return binding.root
}


override fun onStart() {
    super.onStart()

    setUpTextListeners()
}

override fun onStop() {
    super.onStop()
    if (!compositeDisposable.isDisposed) {
        compositeDisposable.dispose()
    }
}

private fun setUpTextListeners() {

    val one = RxTextView.afterTextChangeEvents(one)
    val two = RxTextView.afterTextChangeEvents(two)
    val three = RxTextView.afterTextChangeEvents(three)
    val four = RxTextView.afterTextChangeEvents(four)
    val five = RxTextView.afterTextChangeEvents(five)

    compositeDisposable.add(Observables.combineLatest(one, two, three, four, five) { oneEvent, twoEvent, threeEvent, fourEvent, fiveEvent -&gt;
            //combine here using oneEvent.view().text.toString  }
            .skip(1)
            .debounce(1000, TimeUnit.MILLISECONDS)
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe {
                //network call
            })

    }
}
</code></pre>
","2752082","","2752082","","2018-09-21 17:28:04","2018-09-23 12:59:32","Rxjava, combineLatest with RxTextView memory leak","<android><memory-leaks><rx-java><rx-kotlin><rx-binding>","1","0","","","","CC BY-SA 4.0"
"52448032","2","","52446947","2018-09-21 16:45:32","","1","","<p>One of your views, that you pass to <code>RxTextView.afterTextChangeEvents</code>, is null. There is <a href=""https://github.com/JakeWharton/RxBinding/blob/master/rxbinding/src/main/java/com/jakewharton/rxbinding2/widget/RxTextView.java#L159"" rel=""nofollow noreferrer"">assert in that function</a>, that checks incoming argument on <code>null</code>.</p>

<p>And that problem is not connected with memory leaks.</p>

<p>EDIT:
Changing the synthetic view property to use <code>binding.editText</code> fixed the issue. (Discussion in comments)</p>
","8490194","","2752082","","2018-09-23 12:59:32","2018-09-23 12:59:32","","","","8","","","","CC BY-SA 4.0"
"52544735","1","","","2018-09-27 20:33:27","","2","1026","<p>I have a data provider that has an <code>Observable&lt;Int&gt;</code> as part of the public API. My class under test maps this into a <code>Observable&lt;String&gt;</code>.</p>

<p>How do I create a mock so that it can send out different values on the data provider's observable?</p>

<p>I can do it using a <code>Fake</code> object, but that is a lot of work that I don't think is necessary with MockK.</p>

<p>Simplified code:</p>

<pre><code>interface DataProvider {
    val numberData:Observable&lt;Int&gt;
}

class FakeDataProvider():DataProvider {

    private  val _numberData = BehaviorSubject.createDefault(0)
    override val  numberData = _numberData.hide()

    // Note: the internals of this class cause the _numberData changes.
    // I can use this method to fake the changes for this fake object,
    // but the real class doesn't have this method.

    fun fakeNewNumber( newNumber:Int ) {
        _numberData.onNext( newNumber )
    }
}

interface ClassUnderTest {
    val stringData:Observable&lt;String&gt;

}
class MyClassUnderTest( dataProvider: DataProvider ):ClassUnderTest {

    override val stringData = dataProvider.numberData.map { ""string = "" + it.toString() }
}

class MockKTests {

    @Test fun testUsingFakeDataProvider() {

        val fakeDataProvider        = FakeDataProvider()
        val classUnderTest          = MyClassUnderTest( fakeDataProvider )

        val stringDataTestObserver  = TestObserver&lt;String&gt;()

        classUnderTest.stringData.subscribe( stringDataTestObserver )

        fakeDataProvider.fakeNewNumber( 1 )
        fakeDataProvider.fakeNewNumber( 2 )
        fakeDataProvider.fakeNewNumber( 3 )

        // Note we are expecting the initial value of 0 to also come through
        stringDataTestObserver.assertValuesOnly( ""string = 0"", ""string = 1"",""string = 2"",""string = 3"" )
    }

    // How do you write the mock to trigger the dataProvider observable?
    @Test fun testUsingMockDataProvider() {
        val mockDataProvider        = mockk&lt;DataProvider&gt;()

//        every { ... what goes here ... } just Runs

        val classUnderTest          = MyClassUnderTest( mockDataProvider )

        val stringDataTestObserver  = TestObserver&lt;String&gt;()

        classUnderTest.stringData.subscribe( stringDataTestObserver )


        // Note we are expecting the initial value of 0 to also come through
        stringDataTestObserver.assertValuesOnly( ""string = 0"", ""string = 1"",""string = 2"",""string = 3"" )
    }
}
</code></pre>
","5135551","","","","","2018-11-15 12:33:03","How to use MockK to mock an observable","<rx-kotlin><rx-kotlin2><mockk>","1","0","","","","CC BY-SA 4.0"
"52566383","1","52588056","","2018-09-29 07:58:20","","0","784","<p>I have a dummy network data source:</p>

<pre><code>    fun networkDataSource(): Single&lt;List&lt;Int&gt;&gt; {
        return Single.just((0 until 100).toList())
                .delay(150, TimeUnit.MILLISECONDS)
    }
</code></pre>

<p>Here is an endless observable. It's main use is that it's calculation should be 'protected', so that <strong>it calculates it's single value only once</strong>. <em>(Here the value is the 1.)</em></p>

<pre><code>    val endless = Observable
            .just(1)
            .observeOn(Schedulers.io())
            .delay(500, TimeUnit.MILLISECONDS)
            // Counts as heavy operation, do not calculate this here once again
            .doOnNext { println(""=&gt; E: Calculated once"") }
            .cache()
            //.doOnNext { println(""=&gt; E: From cache"") }
            .repeat()
</code></pre>

<p>The main stream just simply emits values:</p>

<pre><code>    val mainStream = Observable.range(0, 6)
            .doOnNext { println(""=&gt; M: Main stream $it"") }
</code></pre>

<p>The task:</p>

<p>Zip the 3 observables together, and optimize the network usage, so that it will not be called more than necessary. (Once the number of data - integers in this case - is met.</p>

<p>Approach:</p>

<pre><code>    mainStream
            .concatMap {index -&gt;
                Observables.zip(
                        Observable.just(index),
                        endless,
                        networkDataSource()
                                .toObservable()
                                .doOnNext { println(""#&gt; N: Network data fetch $index"") }
                )
            }
            .doOnNext { println(""=&gt; After concatmap: ${it.first}"") }
            .take(4)
            .doOnNext { println(""=&gt; After take: ${it.first}"") }
            .subscribe(
                    { println(""=&gt; Last onnext"") },
                    { it.printStackTrace() },
                    { synchronized(check) { check.notifyAll() } }
            )
</code></pre>

<p>Finishing the locked thread - only needed for testing:</p>

<pre><code>synchronized(check) {
    check.wait()
}
println(""Ending"")
</code></pre>

<p>Here is the output:</p>

<pre><code>=&gt; M: Main stream 0
=&gt; M: Main stream 1
=&gt; M: Main stream 2
=&gt; M: Main stream 3
=&gt; M: Main stream 4
=&gt; M: Main stream 5
#&gt; N: Network data fetch 0
=&gt; E: Calculated once
=&gt; After concatmap: 0
=&gt; After take: 0
=&gt; Last onnext
#&gt; N: Network data fetch 1
=&gt; After concatmap: 1
=&gt; After take: 1
=&gt; Last onnext
</code></pre>

<p>This the output and it is stuck after the second take. (Doesn't proceed in a minute). My question is, why does that happen? </p>

<p>As a sidenote, if I uncomment the line from the <code>endless</code> observable:</p>

<pre><code>.doOnNext { println(""=&gt; E: From cache"") }
</code></pre>

<p>It is going to flood the console with that line. Why is <code>endless</code> called so many times instead for each iteration?</p>

<p><code>flatMap()</code> is not a solution here, because it does not take <code>take(4)</code> into account and proceeds to finish all network calls.</p>

<p>So how could I make <code>concatMap()</code> work?</p>

<p>(I also added <em>RxJS</em> tag because this is a reactive problem and absolutely not about Kotlin. JS solutions are also welcome, if those functions exist in the RxJava library.)</p>

<p>Edit.:</p>

<p>I looked into the code and the 2 outputs are probably because of the <code>prefetch</code> parameter:</p>

<pre><code>@CheckReturnValue
@SchedulerSupport(SchedulerSupport.NONE)
public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper) {
    return concatMap(mapper, 2);
}
</code></pre>

<p>But I still don't understand how it works. I've only read that <code>concatMap()</code> is <code>flatmap()</code>, but it waits for the results of each.</p>
","4420543","","4420543","","2018-09-29 08:03:25","2018-10-01 09:25:10","RxJava: concatMap() with zip() gets stuck","<kotlin><rxjs><rx-java><rx-java2><rx-kotlin>","1","4","","","","CC BY-SA 4.0"
"52588056","2","","52566383","2018-10-01 09:25:10","","1","","<p>From the comments:</p>

<p>The whole setup will likely run on the same thread after the first item and the <code>repeat</code> in <code>endless</code> will never give up the thread, preventing any other operator from progressing. It makes no sense to me to repeat that <code>cache</code> because you'll only ever use one and only item of it.</p>
","61158","","","","","2018-10-01 09:25:10","","","","0","","","","CC BY-SA 4.0"
"52603665","1","","","2018-10-02 07:20:55","","1","1668","<p>Rx noobie here: any idea on how to achieve this?:</p>

<p>I have a list of items from the UI and would like to POST them to the server. I need the list of POSTed items back from the server (to use the server-issued IDs, timestamps etc).</p>

<p>Pardon my long examples but here's the code I'm struggle to make work:</p>

<pre><code>/**
 * create each item (POST) in the list and return the list
 * of newly created ones
 */
fun postItems(items: List&lt;Item&gt;): Maybe&lt;List&lt;Item&gt;&gt; {
    // loop through all items, making a network call for each and return the
    // list of POSTed items

    // attempt 1
    // Failed type inference. Expected type mismatch:
    // Expected: Maybe&lt;List&lt;Item&gt;&gt;
    // Found: List&lt;Maybe&lt;Item&gt;&gt;
    return items.map {
        postItem(it)
    }

    // attempt 2: 'extract' each item in resulting observable and
    // shove it back to original list
    return Maybe.just(items.map {
        postItem(it!!)
                // 'extract' item from observable
                .flatMap {
                    // error: Type mismatch.
                    // Required ((Item) -&gt; MaybeSource&lt;out (???...???)&gt;!)!
                    // Found (Item) -&gt; Item
                    it
                }
    })

    // attempt 3: convert a Maybe to Flowable to collect all items from post
    // and emit them as a single list
    // Type mismatch. Required:(((Mutable)List&lt;Item!&gt;) -&gt; SingleSource&lt;out (???...???)&gt;!)!
    // Found: ((Mutable)List&lt;Item!&gt;) -&gt; (Mutable)List&lt;Item!&gt;
    return items.forEach {
        postItem(it!!).toFlowable().toList().flatMap { it }
    }

    // attempt 4: modify attempt 3 with concatMap:
    // Type mismatch. Required:((List&lt;Item!&gt;) -&gt; MaybeSource&lt;out (???...???)&gt;!)!
    // Found: (List&lt;Item!&gt;) -&gt; List&lt;Maybe&lt;Item&gt;&gt;
    return Maybe.just(items)
            // wait for each observable to finish all the work 
            // until the next one is processed
            .concatMap({
                it.map { addItem(it!!) }
            }).toFlowable()
            .toList().toMaybe()

    // attempt 6: blocking call on each API request.
    // results in android.os.NetworkOnMainThreadException
    return Maybe.just(places.map {
        addPlace(it!!).blockingGet()
    })
}

fun postItem(item: Item): Maybe&lt;Item&gt; {
    return networkService.post(item) // async call to API, returns Maybe&lt;Item&gt;
}
</code></pre>

<p><strong>UPDATE</strong></p>

<p>I have tried the approach suggested by @AlexeySoshin below but still have some points of confusion:</p>

<p>I have tried the second, shorter approach but the retrofit call doesn't go thru for some reason :(, i.e the network service endpoints aren't hit). It's slightly modified because I couldn't get rx-kotlin wrapper to work, but I imagine it's roughly equivalent to this:</p>

<pre><code>fun addItems(items: List&lt;Item?&gt;): Flowable&lt;Maybe&lt;Item&gt;&gt; {
    return Flowable.fromIterable(items).map {
        // tried items.toFlowable().map but got 'Unresolved reference toFlowable
        // even after adding rx-kotlin to project via gradle
        return@map postItem(it)
    }
}
</code></pre>

<p>My network service works successfully for a single Item with this code:</p>

<pre><code>// works as expected
fun postOneItem(item: Item): Maybe&lt;Item&gt; {
    return postItem(item)
}

// also works
fun postOneItemFlowable(item: Item): Flowable&lt;Item&gt; {
    return postItem(item).toFlowable()
}


// this variant didn't work
fun postOneItemFlowable(item: Item): Flowable&lt;Maybe&lt;Item&gt;&gt; {
    return Flowable.just(postItem(item))
}
</code></pre>

<p>How to make <code>Flowable&lt;Maybe&lt;Item&gt;&gt;</code> calls go thru successfully? (or <code>Flowable&lt;List&lt;Item&gt;&gt;</code>, which would be closer to what I need eventually)</p>

<p>Finally, how to obtain the actual output list from a
    <code>Flowable&lt;Maybe&lt;Item&gt;&gt;</code>? It would help to see how the <code>.subscribe()</code>
    block might look like to 'extract' that final list. Here is how my current subscribe code looks like:</p>

<pre><code>...
private fun createItem(item: Item) {
    disposables.add(
            addItemUseCase.postOneItem(item)
                    .subscribeOn(Schedulers.io())
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe({
                        Timber.d(""one item posted: $it"")
                    }, { /* error handler *//})
}
...
</code></pre>
","1145905","","1145905","","2018-10-04 07:58:27","2018-10-04 07:58:27","RxJava: Create items in list and return new list","<java><android><kotlin><rx-java><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"52642493","1","","","2018-10-04 08:39:30","","1","60","<p>Probably an rx newbee question.</p>

<p>If I have two rx streams, which have some common parts, is there a possibility to extract and to reuse them?</p>

<p>Here is pseudo code example:</p>

<pre><code>someManager.getInfo(id) returns a Single&lt;SometInfo&gt;
</code></pre>

<p>This fun takes an id and should return just a single with status</p>

<pre><code>fun getStatus(id: String): Single&lt;Status&gt; =
    someManager.getInfo(id)
        .flattenAsObservable { it.items }
        .map { getSomeProp(it) } // from here
        .toList()
        .map { getStatus(it) }
        .doOnSuccess { getStatusRelay(id).accept(it) } // until here it's common
</code></pre>

<p>and this one doesn't take an id but already an object and should check if a status is ok</p>

<pre><code>fun isStatusOk(info: SomeInfo): Single&lt;Boolean&gt; =
    Observable.fromIterable(info.items)
        .map { getSomeProp(it) } // from here
        .toList()
        .map { getStatus(it) }
        .doOnSuccess { getStatusRelay(id).accept(it) } // until here it's common
        .map { it == Status.OK }
</code></pre>

<p>Thank you in advance</p>
","408780","","408780","","2018-10-04 08:53:42","2018-10-22 10:22:01","Reuse part of RxJava stream","<rx-java><rx-java2><rx-kotlin><rx-kotlin2>","2","3","","","","CC BY-SA 4.0"
"52756197","1","52758673","","2018-10-11 09:03:02","","3","640","<p>Here is a kotlin activity which should display a list of events (from sample.json)</p>

<pre><code>class TalksActivity : AppCompatActivity(), TalkAdapter.Listener {

private val TAG = TalksActivity::class.java.simpleName

private var mCompositeDisposable: CompositeDisposable? = null
private var mAdapter: TalkAdapter? = null
private var disposable: Disposable? = null
private val mapper = createMapper()

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_talks)
    pbWaiting.visibility = View.VISIBLE

    mCompositeDisposable = CompositeDisposable()

    initRecyclerView()
    loadTalks()
}


private fun initRecyclerView() {
    rv_talks_list.setHasFixedSize(true)
    val layoutManager: RecyclerView.LayoutManager = LinearLayoutManager(this)
    rv_talks_list.layoutManager = layoutManager
    rv_talks_list.adapter = TalkAdapter(ArrayList(Collections.emptyList()), this)
}

private fun loadTalks() {
    disposable = getTalks()
            .subscribeOn(AndroidSchedulers.mainThread())
            .observeOn(Schedulers.io())
            .subscribe ({ result -&gt; handleResponse(result) }, { error -&gt; handleError(error) })
}

private fun handleResponse(talkList: List&lt;Talk&gt;) {
    mAdapter = TalkAdapter(ArrayList(talkList), this)
    rv_talks_list.adapter = mAdapter
    pbWaiting.visibility = View.GONE
}

private fun handleError(error: Throwable) {
    pbWaiting.visibility = View.GONE
    throw error
}

private fun createMapper(): ObjectMapper {
    val mapper = jacksonObjectMapper()
    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
    return mapper
}

override fun onItemClick(talk: Talk) {
    startActivity(CountdownActivity.newIntent(this, talk))
}

private fun getTalks() : Observable&lt;List&lt;Talk&gt;&gt; {
    val text = resources.openRawResource(R.raw.sample).bufferedReader().use { it.readText() }
    val typeFactory = mapper.typeFactory
    val collectionType = typeFactory.constructCollectionType(ArrayList::class.java, Talk::class.java)
    return Observable.create&lt;List&lt;Talk&gt;&gt; {
        mapper.readValue(text, collectionType)
    }
}

}
</code></pre>

<p>The problem: When I call <code>loadTalks()</code>, handleResponse(result) or handleError(error) are never called and the screen stay white with only the progressbar running.</p>

<p>I have no error in the console.</p>

<p>Here is my very simple activity_talks.xml</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;
&lt;android.support.constraint.ConstraintLayout xmlns:android=""http://schemas.android.com/apk/res/android""
xmlns:app=""http://schemas.android.com/apk/res-auto""
xmlns:tools=""http://schemas.android.com/tools""
android:layout_width=""match_parent""
android:layout_height=""match_parent""
tools:context="".TalksActivity""&gt;

&lt;android.support.v7.widget.RecyclerView
    android:id=""@+id/rv_talks_list""
    android:layout_width=""match_parent""
    android:layout_height=""match_parent""
    app:layout_constraintBottom_toBottomOf=""parent""
    app:layout_constraintLeft_toLeftOf=""parent""
    app:layout_constraintRight_toRightOf=""parent""
    app:layout_constraintTop_toTopOf=""parent"" /&gt;

&lt;ProgressBar
    android:id=""@+id/pbWaiting""
    android:layout_width=""wrap_content""
    android:layout_height=""wrap_content""
    android:visibility=""gone""
    app:layout_constraintBottom_toBottomOf=""parent""
    app:layout_constraintEnd_toEndOf=""parent""
    app:layout_constraintHorizontal_bias=""0.5""
    app:layout_constraintStart_toStartOf=""parent""
    app:layout_constraintTop_toTopOf=""parent"" /&gt;

&lt;/android.support.constraint.ConstraintLayout&gt;
</code></pre>

<p>What's wrong?</p>

<p>This was working without rxKotlin and observable code.</p>

<p><strong>EDIT</strong></p>

<p>Here is my Adapter:</p>

<pre><code>class TalkAdapter(private val dataList: ArrayList&lt;Talk&gt;, private val listener: Listener) : RecyclerView.Adapter&lt;TalkAdapter.ViewHolder&gt;() {

interface Listener {

    fun onItemClick(talk: Talk)
}

private val colors: Array&lt;String&gt; = arrayOf(""#EF5350"", ""#EC407A"", ""#AB47BC"", ""#7E57C2"", ""#5C6BC0"", ""#42A5F5"")

override fun onBindViewHolder(holder: ViewHolder, position: Int) {
    holder.bind(dataList[position], listener, colors, position)
}

override fun getItemCount(): Int = dataList.count()

override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {

    val view = LayoutInflater.from(parent.context).inflate(R.layout.adapter_talk, parent, false)

    return ViewHolder(view)
}

class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {

    fun bind(talk: Talk, listener: Listener, colors: Array&lt;String&gt;, position: Int) {

        itemView.title.text = talk.title
        itemView.recap.text = talk.summary
        itemView.eventId.text = talk.eventId
        itemView.setBackgroundColor(Color.parseColor(colors[position % 6]))

        itemView.setOnClickListener { listener.onItemClick(talk) }
    }
}
}
</code></pre>

<p><strong>EDIT</strong></p>

<p><em>Found the solution thanks to Demigod answer.</em></p>

<p>When I create an Observable with <code>Observable.create</code> I have to trigger  <code>onNext()</code> and <code>onError()</code> manually. </p>

<p>To fix it, change </p>

<pre><code>private fun getTalks() : Observable&lt;List&lt;Talk&gt;&gt; {
    val text = resources.openRawResource(R.raw.sample).bufferedReader().use { it.readText() }
    val typeFactory = mapper.typeFactory
    val collectionType = typeFactory.constructCollectionType(ArrayList::class.java, Talk::class.java)
    return Observable.create&lt;List&lt;Talk&gt;&gt; {
        mapper.readValue(text, collectionType)
    }
}
</code></pre>

<p>with </p>

<pre><code>private fun getTalks(): Observable&lt;List&lt;Talk&gt;&gt; {
    val text = resources.openRawResource(R.raw.sample).bufferedReader().use { it.readText() }
    val typeFactory = mapper.typeFactory
    val collectionType = typeFactory.constructCollectionType(ArrayList::class.java, Talk::class.java)
    return Observable.fromCallable { mapper.readValue&lt;List&lt;Talk&gt;&gt;(text, collectionType) }
}
</code></pre>

<p>and for better perfs:</p>

<pre><code>private fun getTalks(): Observable&lt;List&lt;Talk&gt;&gt; {
    return Observable.fromCallable {
        val text = resources.openRawResource(R.raw.sample).bufferedReader().use { it.readText() }
        val typeFactory = mapper.typeFactory
        val collectionType = typeFactory.constructCollectionType(ArrayList::class.java, Talk::class.java)
        mapper.readValue&lt;List&lt;Talk&gt;&gt;(text, collectionType)
    }
}
</code></pre>
","2683000","","2683000","","2018-10-11 13:31:17","2018-10-11 13:31:17","Populate a RecyclerView with rxkotlin: The Recyclerview stay empty","<android><android-recyclerview><kotlin><rx-kotlin>","3","0","","","","CC BY-SA 4.0"
"52758673","2","","52756197","2018-10-11 11:14:03","","1","","<p>I think that the issue is in the way you're creating your <code>Observable</code>:</p>

<pre><code> return Observable.create&lt;List&lt;Talk&gt;&gt; {
      mapper.readValue(text, collectionType)
 }
</code></pre>

<p>When you're creating your observable with <code>Observable.create</code> you should manually emit new items like this:</p>

<pre><code>Observable.create&lt;Int&gt; { e: ObservableEmitter&lt;Int&gt; -&gt;
    e.onNext(1)
}
</code></pre>

<p>In your case you should probable use <code>Observable.fromCallable {  }</code> or <code>Single.fromCallable {  }</code> since it will be a single result anyway.</p>
","3569545","","","","","2018-10-11 11:14:03","","","","5","","","","CC BY-SA 4.0"
"52761570","1","","","2018-10-11 13:40:18","","0","117","<p>I've successfully compiled and able to run the app into the device, since I am getting this issue trying to use any JNIs function.</p>

<p>Here is the error which I am stuck at -</p>

<p><a href=""https://i.stack.imgur.com/8AhfN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8AhfN.png"" alt=""enter image description here""></a></p>
","1180661","","","","","2018-10-11 13:40:18","Cannot resolve corresponding JNI Function | Open CV | Android | Kotlin","<android><kotlin><android-ndk><java-native-interface><rx-kotlin>","0","4","","","","CC BY-SA 4.0"
"52973193","1","","","2018-10-24 15:49:22","","0","407","<p>I am trying to bridge some existing rx code and api that uses futures. When I 
manually dispose an observable I would expect onDispose() to be always called. It usually does but when I specify a custom scheduler it sometimes does not get called. My example:</p>

<pre><code>class Work {

private val disposables = CompositeDisposable()

fun getFuture(): ListenableFuture&lt;String&gt; {

    val future = ResolvableFuture.create&lt;String&gt;()

    disposables.add(

            Observable.fromCallable {
                try {
                    Thread.sleep(2000)
                } catch (ex: InterruptedException) {

                }
                ""1""
            }.firstOrError()
                .onErrorReturn { ""2"" }
                .doOnDispose {
                    println(""disposing 1 on ${Thread.currentThread().name}"")
                    //sometimes this dispose does not get called
                    future.set(""2"")
                }
                .subscribeOn(Schedulers.io())
                .doOnDispose {
                    println(""disposing 2 on ${Thread.currentThread().name}"")
                    //only this dispose gets called every time
                    //future.set(""2"")
                }
                .subscribe(Consumer {
                    future.set(""2"")
                })
    )

    return future
}

fun stop() {
    disposables.clear()
}

}

@Test
fun `doOnDispose does not get called`() {
    println(""------------"")

    for (i in 1..100) {

        val work = Work()

        val future = work.getFuture()

        println(""Cancelling"")

        work.stop()

        println(""Getting ${Thread.currentThread().name}"")
        val result = future.get(2, TimeUnit.SECONDS)

        assertEquals(""2"", result)

        println(""------------"")
    }
}
</code></pre>

<p>What happens is only the second onDispose gets called every time. The one before .subscribeOn() is sometimes not called at all.  </p>
","935553","","","","","2018-10-24 20:52:06","doOnDispose does not get called when subscribing on a background scheduler","<rx-java><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"53049617","2","","52387704","2018-10-29 16:12:15","","1","","<p>So the question you're really trying to ask is how to set up drawer layout with epoxy, since MvRx has nothing to do with layouts, but it's actually used for state management.</p>

<p>Epoxy makes it easy to setup dynamic views, and scrolling screens but for all of the stuff like toolbars, bottom navigation views, drawers etc. you need to set it up exactly the same as before. </p>

<p>What I usually do in my projects is set up a drawer layout in activity and frame layout for my fragments and all of my fragments have only one EpoxyRecyclerView in them and I just insert them into the frame layout of my activity upon a click from navigation drawer.</p>
","4745241","","","","","2018-10-29 16:12:15","","","","0","","","","CC BY-SA 4.0"
"53281983","1","53283004","","2018-11-13 13:22:43","","1","265","<p>i am using rx kotlin newly and didn't understand all of it yet. I am trying to loop over a list of queries, and execute them one by one. in this list i have a special string that once reached, i want to break the loop and perform another function</p>

<p>how can i do this in the below example?</p>

<pre><code>fun runQueries() {

     Observable.fromIterable(queriesTemp)

                    .subscribeOn(Schedulers.computation())
                    .doOnNext { query -&gt;
                        if (query.contains(""COMPLETION OF SDF QUERIES"")) {
                            if (loginStatus == StaticVariables.FT_CASE_NEW_LOGIN) {
                                tasksQueriesTemp = arrayOfNulls(queries.size - queries.indexOf(query))
                                System.arraycopy(queries, queries.indexOf(query), tasksQueriesTemp, 0, tasksQueriesTemp!!.size)
                            }
                          // break the loop here 
                            runOtherQueries()
                             break
                        }
                        if (!TextUtils.isEmpty(query)) {
                            mDatabase.execSQL(query, false, """")
                        }
                        action(tasksQueriesTemp!!.indexOf(query))
                    }
                    .doOnComplete { executeOtherUpdates(tasksQueriesTemp) }
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe()
}

fun runOtherQueries() {
}
</code></pre>
","1950784","","13302","","2019-12-17 21:28:23","2019-12-17 21:28:23","RXKotlin Break Inside doOnNext and Call Another Function","<android><rx-java><rx-kotlin>","1","2","1","","","CC BY-SA 4.0"
"53283004","2","","53281983","2018-11-13 14:16:08","","1","","<p>Factor out the part you want to break on from the <code>doOnNext</code> use <code>takeWhile</code>:</p>

<pre><code>val broken = AtomicBoolean();
Observable.fromIterable(queriesTemp)
    .subscribeOn(Schedulers.computation())
    .takeWhile { query -&gt;
        if (query.contains(""COMPLETION OF SDF QUERIES"")) {
            if (loginStatus == StaticVariables.FT_CASE_NEW_LOGIN) {
                tasksQueriesTemp = arrayOfNulls(queries.size -
                    queries.indexOf(query))
                System.arraycopy(queries, queries.indexOf(query), 
                    tasksQueriesTemp, 0, tasksQueriesTemp!!.size)
            }
            // break the loop here 
            runOtherQueries()
            broken.set(true)
            return@takeWhile false  // whatever the Kotlin syntax is for local returns
        }
        return@takeWhile true
    }
    .doOnNext { query -&gt;

        if (!TextUtils.isEmpty(query)) {
            mDatabase.execSQL(query, false, """")
        }
        action(tasksQueriesTemp!!.indexOf(query))
    }
    .doOnComplete { 
         // if you don't want to execute the other updates if the code
         // in takeWhile has ""broken out of the loop""
         if (!broken.get())
             executeOtherUpdates(tasksQueriesTemp) 
    }
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe()
</code></pre>
","61158","","13302","","2019-12-17 21:28:15","2019-12-17 21:28:15","","","","0","","","","CC BY-SA 4.0"
"53307056","1","53307691","","2018-11-14 18:59:17","","0","722","<p>What are the differences in the following cases: </p>

<pre><code>fun a(params: String) = Completable.fromAction {
        if (params.isEmpty()) {
            throw EmptyRequiredFieldException() 
        }
    }
</code></pre>

<p>VS</p>

<pre><code>fun b(params: String) = if(params.isEmpty()) 
       Completable.error(EmptyRequiredFieldException()) 
else 
       Completable.complete()
</code></pre>

<p>Specifically in the context of android, if it matters (even though I don't think it does)
Thanks!</p>
","10614184","","","","","2018-11-14 19:43:23","In RxJava/RxKotlin, what are the differences between returning a Completable.error(Exception()) and throwing?","<error-handling><kotlin><observable><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"53307691","2","","53307056","2018-11-14 19:43:23","","1","","<p>According to <a href=""http://reactivex.io/RxJava/javadoc/io/reactivex/Completable.html#fromAction-io.reactivex.functions.Action-"" rel=""nofollow noreferrer"">documentation</a>, </p>

<blockquote>
  <p>If the Action throws an exception, the respective Throwable is delivered to the downstream via CompletableObserver.onError(Throwable), except when the downstream has disposed this Completable source. In this latter case, the Throwable is delivered to the global error handler via RxJavaPlugins.onError(Throwable) as an UndeliverableException.</p>
</blockquote>

<p>So both of two ways you described are similar (except when the downstream has disposed). Note, that first approach (with manually throwing exception) allow to modify behavior of <code>Completable</code> at runtime. And second one - statically defined as you return particular type of <code>Completable</code> and can't modify it.</p>

<p>What to choose depends on your needs.</p>
","8490194","","","","","2018-11-14 19:43:23","","","","4","","","","CC BY-SA 4.0"
"53335756","2","","52219187","2018-11-16 10:18:10","","6","","<p>This function i created to send a call to server and this is how you will add body in your call.</p>

<pre><code>    fun sendcall() {
            //RequestQueue initialized
            mRequestQueue = Volley.newRequestQueue(this)

           //String Request initialized
            mStringRequest = object : StringRequest(Request.Method.POST, url, Response.Listener { response -&gt;
                Toast.makeText(applicationContext, ""Logged In Successfully"", Toast.LENGTH_SHORT).show()


            }, Response.ErrorListener { error -&gt;
                Log.i(""This is the error"", ""Error :"" + error.toString())
                Toast.makeText(applicationContext, ""Please make sure you enter correct password and username"", Toast.LENGTH_SHORT).show()
            }) {
                override fun getBodyContentType(): String {
                    return ""application/json""
                }

                @Throws(AuthFailureError::class)
                override fun getBody(): ByteArray {
                    val params2 = HashMap&lt;String, String&gt;()
                    params2.put(""Login"",""your credentials"" )
                    params2.put(""Password"", ""your credentials"")
                    return JSONObject(params2).toString().toByteArray()
                }

            }
            mRequestQueue!!.add(mStringRequest!!)
        }
</code></pre>
","7274287","","7274287","","2018-11-16 10:24:13","2018-11-16 10:24:13","","","","2","","","","CC BY-SA 4.0"
"53352838","1","53353032","","2018-11-17 15:52:14","","1","361","<p>I am using RxJava/Kotlin <code>Observable#take()</code> to get first 50 items from the list. But <code>#take()</code> operator is not behaving as it should as per Rx docs. </p>

<p>In Rx docs, <code>#take()</code> is defined as:</p>

<blockquote>
  <p>""Emit only the first n items emitted by an Observable""</p>
</blockquote>

<p><a href=""https://i.stack.imgur.com/q4oTZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/q4oTZ.png"" alt=""enter image description here""></a></p>

<p>I have a function like this:</p>

<p>As we can see the <code>pageSize</code> argument is <code>50</code> </p>

<p><a href=""https://i.stack.imgur.com/DbyoV.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DbyoV.png"" alt=""enter image description here""></a></p>

<p>And initial <code>size</code> of the <code>list</code> is <code>300</code> </p>

<p><a href=""https://i.stack.imgur.com/mK0Ai.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mK0Ai.png"" alt=""enter image description here""></a></p>

<p>After that <code>#take(50)</code> is applied to that <code>Observable</code> and at next breakpoint I still get the <strong>full size</strong> list <code>i.e. size = 300</code> </p>

<p><a href=""https://i.stack.imgur.com/hpBBD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hpBBD.png"" alt=""enter image description here""></a></p>

<p>But <code>just for the check</code>, if something is wrong with the debugger or observable, I tried to take only items whose displayName contains ""9"", but this time I get the expected result of <code>smaller list</code> with <code>9</code> in each of their <code>#displayName field</code>.</p>

<p><a href=""https://i.stack.imgur.com/zZOK5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zZOK5.png"" alt=""enter image description here""></a></p>

<p>I believe <code>RxJava/Kotlin's #take()</code> operator is not that crazy and it's just me.</p>
","2581314","","472495","","2019-01-14 20:41:53","2019-01-14 20:41:53","Observable#take(Long) not returning desired size of items in RxJava","<java><kotlin><rx-java><rx-android><rx-kotlin>","2","1","","","","CC BY-SA 4.0"
"53353032","2","","53352838","2018-11-17 16:13:06","","5","","<p><code>take</code> behaves correctly as it will give you only 50 <code>List&lt;FollowersEntry&gt;</code> ""marbles"". Based on your screenshots and wording, I guess you wanted 50 <code>FollowersEntry</code>. There is a fundamental logical difference between a container of objects and the objects themselves. RxJava sees only an object sequence of type <code>List&lt;&gt;</code> but it can't know about the nested objects you intended to work with.</p>

<p>Therefore, you either have to use <code>it.take(50)</code> inside <code>map</code> (or whatever the Kotlin collections function is) or unroll the sequence of lists into sequence of entries via <code>flatMapIterable</code>:</p>

<pre><code>getFollowers()
.flatMapIterable(entry -&gt; entry)
.take(50 /* entries this time, not lists */)
</code></pre>
","61158","","","","","2018-11-17 16:13:06","","","","1","","","","CC BY-SA 4.0"
"53360939","1","","","2018-11-18 12:35:35","","0","82","<p>I am working on a feature where I need to filter out the network response data based on local database data.</p>

<p>For example, my network layers return me a list of items and my database layer returns an observable list of ids. Now I want to only return those objects from network layer whose id matches anyone from the database layer response.</p>

<p>Below code fetches data from the network and saves the result to a database(cache).</p>

<pre><code>factory.getRemoteDataStore()
                .searchForVenues(query)
                .toObservable()
                .distinctUntilChanged()
                .flatMap { venues -&gt;
                    factory.getCacheDataStore()
                            .saveVenues(venues)
                            .andThen(Observable.just(venues))
                }
</code></pre>

<p>I also have a method that returns a list of venues that needs to be filtered</p>

<pre><code>factory.getCacheDataStore().getDislikedVenues()
</code></pre>

<p>Now, how do I extend the previous chain to use getDislikedVenues() Observable to filter them from the response of network response?</p>

<p>Sorry for such noob question, I really am struggling with this.</p>
","5421753","","","","","2018-11-18 14:29:27","Create a filtered observable from 2 observable of list of items in RxJava","<android><rx-java><observable><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"53509536","1","53514768","","2018-11-27 22:59:35","","0","80","<p>I am trying to convert examples from <a href=""https://www.androidhive.info/RxJava/android-getting-started-with-reactive-programming/#example5"" rel=""nofollow noreferrer"">this article</a> from Java to Kotlin.
I get error from picture at Exmaple 5:</p>

<p><a href=""https://i.stack.imgur.com/Vhp81.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Vhp81.png"" alt=""enter image description here""></a></p>

<p>And I noticed, that without map() function I don't get this error</p>

<p><a href=""https://i.stack.imgur.com/ZOVsj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZOVsj.png"" alt=""enter image description here""></a></p>

<p>So, what the point of this error and how to write it right?</p>
","8230672","","","","","2018-11-28 08:05:37","mapping custom data RxAndroid with Kotlin","<android><kotlin><rx-java><rx-android><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"53514768","2","","53509536","2018-11-28 08:05:37","","1","","<p>The return value of a lambda in Kotlin is always the last expression in the block. </p>

<p>So in this case the result of</p>

<pre><code>.map { it.note = it.note.toUpperCase() }
</code></pre>

<p>is not returning a meaningful value.</p>

<p>What you should do instead is this</p>

<pre><code>.map { 
    it.note = it.note.toUpperCase()
    it
}
</code></pre>

<p>Which returns a type of Note instead of Unit.</p>
","10715642","","","","","2018-11-28 08:05:37","","","","0","","","","CC BY-SA 4.0"
"53546662","1","","","2018-11-29 19:59:20","","1","65","<p>I'm using RxRoom with Kotlin. In my Dao class 
If I use this: </p>

<p><code>@Insert
    fun insertPaymentRef(paymentRef: PaymentRef): Single&lt;Long&gt;</code></p>

<p>Or this:</p>

<pre><code>@Insert
fun insertPaymentRef(paymentRef: PaymentRef): Completable
</code></pre>

<p>the generated <code>Dao</code> class throws this error </p>

<blockquote>
  <p>error: local variable paymentRef is accessed from within inner class; needs to be declared final</p>
</blockquote>

<p>A sneek peak in the generated class is this:</p>

<pre><code>public Single&lt;Long&gt; insertPaymentRef(PaymentRef paymentRef) {
return Single.fromCallable(new Callable&lt;Long&gt;() {
  @Override
  public Long call() throws Exception {
    __db.beginTransaction();
    try {
      long _result = __insertionAdapterOfPaymentRef.insertAndReturnId(paymentRef);
      __db.setTransactionSuccessful();
      return _result;
    } finally {
      __db.endTransaction();
    }
  }
});
</code></pre>

<p>}</p>

<p>The only time I don't get this error is if I only make my <code>insert</code> call like this:</p>

<pre><code>@Insert(onConflict = OnConflictStrategy.REPLACE)
fun insertPaymentRef(paymentRef: PaymentRef)
</code></pre>

<p>How do I make the <code>INSERT</code> call work in RxRoom: I've included RxRoom dependency and it works because if I try doing <code>GET</code> calls like this </p>

<pre><code>@Query(PaymentRefDbConstants.QUERY_PAYMENT_REF)
fun getPaymentRef(): Single&lt;PaymentRef&gt;
</code></pre>

<p>It works</p>
","7338759","","7338759","","2018-11-30 00:05:05","2018-11-30 00:05:05","RxRoom Kotlin: Generated Dao - error: local variable users is accessed from within inner class; needs to be declared final","<java><android><kotlin><android-room><rx-kotlin>","0","3","","","","CC BY-SA 4.0"
"53684317","1","53684470","","2018-12-08 16:04:24","","3","730","<p>I want to implement method to edit a note, save it to local database (cache) and then send it to the server as a POST request. I am learning RxJava and I wanted to create <code>Observable</code> from the note and then apply transformations on it, like to map it to an Entity model and saving. The issue that my method returns Completable and this chain returns <code>Observable&lt;Completable&gt;</code>. How to unwrap the <code>Completable</code> from this <code>Observable</code> which I used only to start RxJava stuff. Each <code>editNote()</code> methods returns a <code>Completable</code>.</p>

<pre><code> override fun editNote(note: Note): Completable {
    return Observable.just(note)
        .map { mapper.mapToEntity(it) }
        .map { noteEntity -&gt;
            factory.getCacheDataStore().editNote(noteEntity)
                .andThen { factory.getRemoteDataStore().editNote(noteEntity) }
        }
}
</code></pre>

<p>=======================================================</p>

<h1>UPDATE</h1>

<p>Finally, I managed to find ""a solution"" but I am not sure it is correct :-)</p>

<pre><code>override fun editNote(note: Note): Completable {
    return Observable.just(note)
        .map { mapper.mapToEntity(it) }
        .flatMapCompletable { noteEntity -&gt;
            factory.getCacheDataStore().editNote(noteEntity)
                .andThen { factory.getRemoteDataStore().editNote(noteEntity) }
        }
}
</code></pre>
","9188790","","9188790","","2018-12-08 16:19:01","2018-12-08 16:19:33","RxJava/Kotlin Observable method call chain - how to terminate?","<android><kotlin><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"53684470","2","","53684317","2018-12-08 16:19:33","","2","","<p>You're looking for <code>flatMapCompletable</code> instead of <code>map</code>, because <code>map</code> just intercepts the stream and maps the emissions to another type, while 'flatMap' (or it's siblings), from the docs:</p>

<blockquote>
  <p>Transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable.</p>
</blockquote>

<p>You can see it's marble diagram in <a href=""http://reactivex.io/documentation/operators/flatmap.html"" rel=""nofollow noreferrer"">Here</a></p>
","5036979","","","","","2018-12-08 16:19:33","","","","2","","","","CC BY-SA 4.0"
"53761781","1","53764341","","2018-12-13 12:23:23","","0","143","<p>I have a State(Enum) that contains (Good, Non-Critical, Critical) values</p>

<p>So requirement is :</p>

<ol>
<li>should trigger when state goes in non-critical state.</li>
<li>should trigger when state goes in critical state.</li>
<li>should trigger when state stays in critical state for 15 seconds.</li>
</ol>

<p>Input : </p>

<pre><code>publishSubject.onNext(""Good"")
publishSubject.onNext(""Critcal"") 
publishSubject.onNext(""Critcal"") 
publishSubject.onNext(""NonCritical"")  
publishSubject.onNext(""Critacal"") 
publishSubject.onNext(""Critical"") 
publishSubject.onNext(""Good"")
and so on...
</code></pre>

<p>See Code Structure for Reference:</p>

<pre><code>    var publishSubject = PublishSubject.create&lt;State&gt;()
    publishSubject.onNext(stateObject)


    publishSubject
            /* Business Logic Required Here ?? */
            .subscribeOn(Schedulers.computation())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe {
                AppLogger.printLog(""Trigger Success --&gt; "")
            }
</code></pre>

<p>Please help,
Thanks in Advance,</p>
","4051419","","4051419","","2018-12-13 13:02:06","2018-12-13 14:49:18","How can I achieve this requirement using Rx Java","<android><rx-java><rx-java2><rx-android><rx-kotlin>","2","5","","","","CC BY-SA 4.0"
"53764341","2","","53761781","2018-12-13 14:42:37","","2","","<p>You can use <code>distinctUntilChanged()</code> to suppress events that don't change the state. Filter out the normal events using <code>filter()</code>.</p>

<p>Use the <code>switchMap()</code> operator to create a new subscription when the state changes. When the state is ""critical"", use the <code>interval()</code> operator to wait out the 15 seconds. If the state changes in that 15 seconds, <code>switchMap()</code> will unsubscribe and re-subscribe to a new observable.</p>

<pre><code>publishSubject
  .distinctUntilChanged()
  .subscribeOn(Schedulers.computation())
  .observeOn(AndroidSchedulers.mainThread())
  .filter( state -&gt; state != State.Normal )
  .switchMap( state -&gt; {
                   if (state == State.Critical) {
                     return Observable.interval(0, 15, TimeUnit.SECONDS) // Note 1
                        .map(v -&gt; State.Critical); // Note 2
                   }
                   return Observable.just( State.Noncritical );
                 })
  .subscribe( ... );
</code></pre>

<ol>
<li><code>interval()</code> is given an initial value of <code>0</code>, causing it to emit a value immediately. After <code>15</code> seconds, the next value will be emitted, and so on.</li>
<li>The <code>map()</code> operator turns the <code>Long</code> emitted by <code>interval()</code> into </li>
</ol>
","1241193","","1241193","","2018-12-13 14:49:18","2018-12-13 14:49:18","","","","5","","","","CC BY-SA 4.0"
"53812184","1","54114882","","2018-12-17 09:22:51","","1","77","<p>I have the following call to retrieve some data from server and update the UI according to response.</p>

<pre><code>    poiAPIService.getPoiDetails(poiId!!)
            .observeOn(AndroidSchedulers.mainThread())
            .doOnSubscribe { showProgressBar(true) }
            .doFinally { showProgressBar(false) }
            .subscribeOn(Schedulers.io()).subscribe(
                    { poiDetails -&gt;
                        bindPoiDetails(poiDetails)
                    },
                    {
                        (getActivity() as MainOverviewActivity).fragmentControl.hidePoiDetailsFragment()
                    })

}
</code></pre>

<p>It complains about showProgressBar that the Views are only accessable on thread that created them.
If I change the call like this, everything seems to be fine again.</p>

<pre><code>showProgressBar(true)
poiAPIService.getPoiDetails(poiId!!)
        .observeOn(AndroidSchedulers.mainThread())
        .subscribeOn(Schedulers.io()).subscribe(
                { poiDetails -&gt;
                    showProgressBar(false)
                    bindPoiDetails(poiDetails)
                },
                {
                    showProgressBar(false)
                    (getActivity() as MainOverviewActivity).fragmentControl.hidePoiDetailsFragment()
                })

}
</code></pre>
","859742","","","","","2019-01-10 07:31:07","RxJava/RxKotlin complains about accessing views","<android><rx-java><reactive-programming><rx-kotlin>","2","0","","","","CC BY-SA 4.0"
"53910822","1","","","2018-12-24 08:10:51","","0","88","<p>I'v got this method from <a href=""https://developer.android.com/guide/topics/providers/document-provider#open-client"" rel=""nofollow noreferrer"">here</a> and it works well:</p>

<pre><code>@Throws(IOException::class)
fun readTextFromUri(ctx: Context, uri: Uri): String {
    val stringBuilder = StringBuilder()
    ctx.contentResolver.openInputStream(uri)?.use { inputStream -&gt;
        BufferedReader(InputStreamReader(inputStream)).use { reader -&gt;
            var line: String? = reader.readLine()
            while (line != null) {
                stringBuilder.append(""$line\n"")
                line = reader.readLine()
            }
        }
    }
    return stringBuilder.toString()
}
</code></pre>

<p>Then converted it to this method that returns each line using Observable:</p>

<pre><code>fun getUriAsStringObservable(ctx: Context, uri: Uri): Observable&lt;String&gt; {
    return Observable.create {
        try {
            ctx.contentResolver.openInputStream(uri)?.use { inputStream -&gt;
                BufferedReader(InputStreamReader(inputStream)).use { reader -&gt;
                    var line: String? = reader.readLine()
                    while (line != null) {
                        it.onNext(line)
                        line = reader.readLine()
                    }
                    it.onComplete()
                }
            }
        } catch (e: IOException) {
            it.onError(e)
        }
    }
}
</code></pre>

<p>But it didn't work as I expected, after subscribing to it nothing is printed:</p>

<pre><code>getUriAsStringObservable(this, uri)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .doOnNext {
        print(""Next: $it"")
    }
    .doOnError {
        print(""Error: $it"")
    }
    .doOnComplete {
        print(""completed"")
    }
    .subscribe()
</code></pre>

<p>What is my mistake?</p>
","3678849","","3678849","","2018-12-26 10:25:44","2018-12-27 05:52:11","Custom RxJava Observable emits nothing on subscribe","<observable><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"54040468","1","","","2019-01-04 14:04:07","","1","108","<p>I am trying to do some instrumented tests of a boilerplate code after migrating it to AndroidX. Note that before migration, all of them worked, but after, only unit tests work, the instrumented test crashes on Null Pointer exception, where it shouldnt.</p>

<p>Here is the errror: </p>

<pre><code>Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'io.reactivex.Flowable io.reactivex.Flowable.subscribeOn(io.reactivex.Scheduler)' on a null object reference
02:55:31 V/InstrumentationResultParser: at org.buffer.android.boilerplate.data.interactor.FlowableUseCase.execute(FlowableUseCase.kt:26)
02:55:31 V/InstrumentationResultParser: at org.buffer.android.boilerplate.ui.browse.BrowseBufferoosViewModel.fetchBufferoos(BrowseBufferoosViewModel.kt:25)
02:55:31 V/InstrumentationResultParser: at org.buffer.android.boilerplate.ui.browse.BrowseActivity.onCreate(BrowseActivity.kt:40)
</code></pre>

<p>as you see, it's in the declaration of my ""UseCase"" in this case, get bufferoos. For reference, here is the class that fails:</p>

<p><a href=""https://github.com/LukasAnda/bufferoo-androidx-migration/blob/master/data/src/main/java/org/buffer/android/boilerplate/data/browse/interactor/GetBufferoos.kt"" rel=""nofollow noreferrer"">GetBufferoos</a></p>

<p><a href=""https://github.com/LukasAnda/bufferoo-androidx-migration/blob/master/data/src/main/java/org/buffer/android/boilerplate/data/interactor/FlowableUseCase.kt"" rel=""nofollow noreferrer"">Flowable Use case</a></p>

<p>Here is the test that fails </p>

<p><a href=""https://github.com/LukasAnda/bufferoo-androidx-migration/blob/master/mobile-ui/src/androidTest/java/org/buffer/android/boilerplate/ui/browse/BrowseActivityTest.kt"" rel=""nofollow noreferrer"">ActivityTest</a></p>

<p>Here is modules.kt for koin</p>

<p><a href=""https://github.com/LukasAnda/bufferoo-androidx-migration/blob/master/mobile-ui/src/main/java/org/buffer/android/boilerplate/ui/di/modules.kt"" rel=""nofollow noreferrer"">Modules</a></p>
","4806502","","4806502","","2019-01-04 15:05:45","2019-01-04 15:05:45","Koin testing on Androidx with Activity","<android><kotlin><rx-java><rx-kotlin><koin>","0","7","","","","CC BY-SA 4.0"
"54060856","1","","","2019-01-06 11:01:10","","0","147","<p>I've wanted to try RxJava with kotlin to make coding easier, so I've produced this:</p>

<pre><code>fun postAnswers() {
    disposable = getToken.execute().subscribe({ token -&gt;
        questions.forEach { form -&gt;
            val answers = form.answers?.filter { it.isChecked }?.map { it.answer_id }
            disposable = postAnswer.execute(token?.token!!, SavedAnswer(form.form_id, answers)).subscribe({
                //Post live data about success
            }, {
                //Post live data failure
            })
        }
    }, {
        //Post live data failure
    })
}
</code></pre>

<p>But I have an impression it can be done better, but I do not know how. Basically what I am trying to achieve is getting a Token object from database, that returns Flowable Token? and then use it to call postAnswer in a for cycle, because I need to post each answer separately (That's how the API is designed). After that, postAnswer only returns Completable, but I need to let the Activity know (this is from ViewModel code) how many answers were posted</p>

<p>I've thought about using .flatMap or .concat functions, but I am not sure if it will be helpful in this case. Also, do I need to assign getToken.execute() to disposable?</p>

<p>Thank you for your answers</p>

<p>EDIT:</p>

<p>Here is my questions list:</p>

<pre><code>private var questions: List&lt;Form&gt; = emptyList()
</code></pre>

<p>It gets filled by viewModel functions</p>
","4806502","","4806502","","2019-01-06 12:53:22","2019-01-24 23:09:32","Simplify the statement using rxkotlin","<kotlin><retrofit><rx-java><android-room><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"54114882","2","","53812184","2019-01-09 16:50:55","","1","","<p>did you tried to do something like this...</p>

<pre><code>poiAPIService.getPoiDetails(poiId!!)
        .subscribeOn(AndroidSchedulers.mainThread())
        .observeOn(Schedulers.io())
        .doOnSubscribe { showProgressBar(true) }
        .doFinally { showProgressBar(false) }
        .subscribe(
                { poiDetails -&gt;
                    bindPoiDetails(poiDetails)
                },
                {
                    (getActivity() as MainOverviewActivity).fragmentControl.hidePoiDetailsFragment()
                })
</code></pre>

<p>pay attention to <code>observeOn</code> and <code>subscribeOn</code></p>

<p>Looks like you use <code>observeOn</code> and <code>subscribeOn</code> not correctly...
take a look to <a href=""https://stackoverflow.com/questions/53983854/how-rxjava-scheduler-threading-works-for-different-operator/53998063#53998063"">How RXJava Scheduler/Threading works for different operator?</a></p>
","4597766","","","","","2019-01-09 16:50:55","","","","0","","","","CC BY-SA 4.0"
"54379123","1","","","2019-01-26 14:04:51","","0","1103","<p>I've inherited this codebase which uses RxJava2 and kotlin with a rather peculiar Result pattern for API calls. i.e. all API calls return Singles with a Result object (which is a sealed class of Success and Error types as shown below) i.e.</p>

<pre><code>sealed class Result&lt;T, E&gt; {
    data class Success&lt;T, E&gt;(
            val data: T
    ): Result&lt;T, E&gt;()

    data class Error&lt;T, E&gt;(
            val error: E
    ): Result&lt;T, E&gt;()
}
</code></pre>

<p>Now I'm trying to chain together a bunch of API calls of these but need to terminate the chain on the first Result.Error in it and continue if not.</p>

<p>The only way I can think of is to zip all of the Singles and then have a zipper function that checks the type of each parameter and returns a <code>Result.Error()</code> with the first error it encounters. i.e. something like,</p>

<pre><code>Singles.zip(
    repo1.makeCall1(arg),
    repo1.makeCall2(arg2),
    repo2.makeCall1(arg3)
) { result1, result2, result3 -&gt;
    val data1 = when (result1) {
        is Result.Error -&gt; return@zip Result.Error(result1.error)
        is Result.Success -&gt; result1.data
    }
    val data2 = when (result2) {
        is Result.Error -&gt; return@zip Result.Error(result2.error)
        is Result.Success -&gt; result2.data
    }
    val data3 = when (result3) {
        is Result.Error -&gt; return@zip Result.Error(result3.error)
        is Result.Success -&gt; result3.data
    }

    return@zip Result.Success(MergedData(data1, data2, data3))
}
</code></pre>

<p>which works but looks really weird (and feels like a code smell with this huge ass zipper method). Also does not allow me to chain anything more after the last method (that checks if the Result is a Success / Error).</p>

<p>I feel it would be a lot more readable to be able to chain these calls and terminate on the first error but I don't know enough Rx to do this. Is there an operator or an approach that could help make this better?</p>
","2104070","","2413303","","2019-01-26 14:25:59","2019-01-29 20:27:52","How to break RxJava chain on error Result?","<android><rx-java><reactive-programming><rx-java2><rx-kotlin>","3","0","","","","CC BY-SA 4.0"
"54480893","1","54487008","","2019-02-01 13:50:57","","0","202","<p>I am writing some repository logic for android application, I have this logic for retrieving data from database and updating the database with data from api immediately after that.</p>

<pre><code>   fun fetchData(): Single&lt;Data&gt; {
    return Single.concatArrayEager(
            fetchFromDb(),
            fetchFromApi())
            .firstOrError()
}
</code></pre>

<p>By the way - database is Room and api is Retrofit. Now what happens is that room emits almost instantly, but for some reason api request is not fired - the second <code>Single</code> doesn't start. </p>

<p>I read the documentation on the eager operator and I am not sure if this is correct behavior. I even tried to delay the database fetch, by like 20 miliseconds - which resulted in that second single being actually fired</p>
","6855603","","","","","2019-02-01 20:52:51","Single concatArrayEager doesnt subscribe to all sources","<android><rx-java><rx-kotlin>","1","6","","","","CC BY-SA 4.0"
"54487008","2","","54480893","2019-02-01 20:52:51","","1","","<p>The <code>concatArrayEager</code> should subscribe to all <code>Observables</code>. But your API call might take some time to actually start. This might be more time than your DB call needs to return.</p>

<p>Now we see the effect of <code>firstOrError</code>. When the first value is received, the stream is terminated and all active or pending subscriptions of the concatenation are canceled. Also the API result won't ever be used.</p>
","3385212","","","","","2019-02-01 20:52:51","","","","1","","","","CC BY-SA 4.0"
"54782735","1","54782844","","2019-02-20 09:19:39","","2","144","<p>I'm using a custom repository to get observables for data in a room database, e.g:</p>

<pre><code>fun getUsers(): Observable&lt;List&lt;User&gt;&gt; = userDao.getAll()
        .toObservable()
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .doOnError { Logger.error(tag, ""error getting users: ${it.message}"") }
        .doOnNext { Logger.debug(tag, ""fetched ${it.size} users"") }
</code></pre>

<p>In my UI (Fragment) I start the subscription in <code>onResume</code>:</p>

<pre><code>override fun onResume() {
        super.onResume()
        userObserver = repository.getUsers()
            .subscribe {
                // handle user
            }
    }
</code></pre>

<p>And in the <code>onPause</code> I have:</p>

<pre><code>override fun onPause() {
        super.onPause()
        userObserver.dispose()
    }
</code></pre>

<p>Since each time <code>repository.getUsers()</code> is called, I'm creating a new Observable-object. Could this lead to memory leaks and should I rather try to reuse the observer instead of disposing and recreating it?</p>
","7855177","","7855177","","2019-02-20 09:57:42","2019-02-20 09:57:42","Reusing or recreating an observer?","<android><kotlin><android-room><rx-android><rx-kotlin>","1","0","0","","","CC BY-SA 4.0"
"54782844","2","","54782735","2019-02-20 09:25:05","","1","","<p>I would hold this inside a ViewModel.
When your fragment is recreated, it'll reuse the previous viewmodel. This will increase performance as it won't have to recreate your observer, and recall the database, it'll just use what was previously obtained.</p>

<p>See here: <a href=""https://developer.android.com/topic/libraries/architecture/viewmodel"" rel=""nofollow noreferrer"">Android ViewModel</a></p>
","8159708","","","","","2019-02-20 09:25:05","","","","0","","","","CC BY-SA 4.0"
"55174860","1","55176706","","2019-03-15 02:48:59","","7","10296","<p>I'm confusing about use case for doOnSuccess in rxJava.<br>
Let's see the code:  </p>

<p>Case 1:  </p>

<pre><code>networkApi.callSomething()
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())               
    .doOnSuccess(__ -&gt; showLog(SUCCESS))
    .doOnError(__ -&gt; showLog(ERROR))
    .subscribeBy(
             onSuccess = {//Do something}, 
             onError = {//Show log here}
          )
</code></pre>

<p>Case 2:</p>

<pre><code>networkApi.callSomething()
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())               
    .subscribeBy(
             onSuccess = {
               //Do something
               showLog(SUCCESS)
             }, 
             onError = {showLog(ERROR)}
          )
</code></pre>

<p>As normal, I think case 2 is fine.<br>
I also have referred some source code in github and I saw some people do like case 1.<br>
I try to ask myself what is the use case for <code>doOnSuccess</code> here ?  </p>

<p>Is there any use case that we need apply <strong><code>doOnSuccess()</code></strong> operator ?</p>
","951917","","","","","2019-03-15 06:21:37","What is the use case for doOnSuccess vs onSuccess in rxJava","<android><retrofit><rx-java><rx-kotlin>","2","1","","","","CC BY-SA 4.0"
"55176706","2","","55174860","2019-03-15 06:21:37","","9","","<p>Singles and Maybes have a success signal and the handler has the <code>onSuccess</code> method called. Often though, you'd want to side-effect the success signal at various points in the flow so there is the <code>doOnSuccess</code> operator.</p>

<pre class=""lang-java prettyprint-override""><code>getUserAsSingle()
.subscribeOn(Schedulers.io())
.observeOn(AndroidSchedulers.mainThread())
.doOnSuccess(user -&gt; ui.showUser(user))
.flatMap(user -&gt; 
     getUserFavoritesAsSingle(user)
     .subscribeOn(Schedulers.io())
)
.observeOn(AndroidSchedulers.mainThread())
.doOnSuccess(userFavs -&gt; ui.showUserFavorites(userFavs))
.flatMap(userFavs -&gt; 
     updateLoginCounter(userFavs.userId)
     .subscribeOn(Schedulers.io())
)
.observeOn(AndroidSchedulers.mainThread())
subscribe(newCounter -&gt; ui.showLoginCount(newCounter),
    error -&gt; ui.showError(error));
</code></pre>
","61158","","","","","2019-03-15 06:21:37","","","","0","","","","CC BY-SA 4.0"
"55244285","1","55244679","","2019-03-19 15:13:18","","0","359","<p>I'm using the <code>io.reactivex.rxkotlin</code> extension function: </p>

<pre><code>fun &lt;T : Any&gt; Observable&lt;T&gt;.subscribeBy(
        onError: (Throwable) -&gt; Unit = onErrorStub,
        onComplete: () -&gt; Unit = onCompleteStub,
        onNext: (T) -&gt; Unit = onNextStub
        ): Disposable
</code></pre>

<p>And when I use this extension there is a difference if I choose to send a parameter or if I use lambda.
For example</p>

<p><strong>first implementation:</strong></p>

<pre><code>myObservable.subscribeBy { str -&gt;
    // onNext
}
</code></pre>

<p><strong>Second implementation:</strong></p>

<pre><code>myObservable.subscribeBy({ throwable -&gt;
    // onError
})
</code></pre>

<ul>
<li>in the <strong>first implementation</strong> the function is the <code>onNext</code></li>
<li>and in the <strong>second implementation</strong> the function is the <code>onError</code></li>
</ul>

<p>And I'm not sure why.</p>
","4409815","","","","","2019-03-19 15:34:01","Kotlin pass function as a parameter vs lambda implementation","<kotlin><kotlin-extension><rx-kotlin>","2","0","","","","CC BY-SA 4.0"
"55244679","2","","55244285","2019-03-19 15:34:01","","7","","<p>From <a href=""https://kotlinlang.org/docs/reference/lambdas.html#passing-a-lambda-to-the-last-parameter"" rel=""noreferrer"">Higher-Order Functions and Lambdas</a>:</p>

<blockquote>
  <p>In Kotlin, there is a convention that if the last parameter of a function accepts a function, a lambda expression that is passed as the corresponding argument can be placed outside the parentheses:</p>
</blockquote>

<p>So in your case, you have a function that takes three optional parameters. In the first implementation:</p>

<pre><code>myObservable.subscribeBy { str -&gt; }
</code></pre>

<p>You're using this feature to omit parentheses for the <em>last</em> lambda paramter (which is <code>onNext</code>). However, when you use the second implementation:</p>

<pre><code>myObservable.subscribeBy({ throwable -&gt; })
</code></pre>

<p>Since it's within the parentheses, it must be the first parameter, unless you were to explicitly name it as the last parameter, e.g.:</p>

<pre><code>myObservable.subscribeBy(onNext = { str -&gt; })
</code></pre>
","321697","","","","","2019-03-19 15:34:01","","","","1","","","","CC BY-SA 4.0"
"55253503","1","55253850","","2019-03-20 04:14:30","","0","43","<p>i am trying the upload the image through rxkotlin, my problem is when i close my screen in my application, the uploading process gets terminated because am adding that subscription to my disposal, so when my screen closes or destroys i will be disposing. because of this dispose my job getting terminated, since anyway i need to dispose else it my leads to the memory leak                                                               </p>

<pre><code>fun uploadImage(imagePath : String){
   uploadToServer(imagePath)
        .subscribe()
        .addTo(disposal)   
}

override onCleared(){
   disposal.dispose()
}
</code></pre>

<p>So in this way i doing this, is there is any other way to continue this work, even after the screen destroys or cleared without memory leak ?</p>
","9344496","","","","","2019-03-20 05:01:53","RxKotlin - Process gets terminated when dispose is called","<android><rx-java><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"55253850","2","","55253503","2019-03-20 05:01:53","","0","","<p><code>ViewModel</code> are <strong>independent of activity/fragment lifecycles or just their configuration changes class</strong>, because of that <code>onCleared</code> is called only after the activity is finished. So don't dispose the Rx variables on <code>onCleared</code>. It is better to dispose them on <code>onDestroy</code></p>

<pre><code>override onDestory(){
super.onDestroy()
disposal.dispose()
}
</code></pre>
","5351055","","","","","2019-03-20 05:01:53","","","","2","","","","CC BY-SA 4.0"
"55411838","1","55412118","","2019-03-29 06:45:11","","0","329","<p>i have a list of some strings, where i need to iterate the list in batch.<br>
Example :</p>

<pre><code>val list = [""a"",""b"",""c"",""d"",""e"",""f""]
Observable.fromIteratable(list)
          .map{
          //here i need to get 4 items at a time
          //like in first iteration i need to get [""a"",""b"",""c"",""d""]
          //in second iteration i need to get [""e"",""f""]
        }
</code></pre>

<p>Is there is any option to do perform this ?</p>
","9344496","","","","","2019-03-29 07:19:26","Rxjava - Iterate the list with batch","<android><rx-java><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"55412118","2","","55411838","2019-03-29 07:06:35","","1","","<p>User <a href=""http://reactivex.io/documentation/operators/buffer.html"" rel=""nofollow noreferrer""><code>buffer</code></a></p>

<blockquote>
  <p>periodically gather items emitted by an Observable into bundles and emit these bundles rather than emitting the items one at a time</p>
</blockquote>

<pre><code> val list = arrayOf(""1"", ""2"", ""3"", ""4"", ""5"")
 Observable.fromIterable(list.asIterable())
     .buffer(4)
     .map { stringList: MutableList&lt;String&gt; -&gt;
       println(""insideMap -&gt; $stringList"")
       return@map ""wow $stringList""
     }
     .subscribe { value: String -&gt; println(""OnResult $value"")}
</code></pre>

<pre><code>//Output
insideMap -&gt; [1, 2, 3, 4]
OnResult wow [1, 2, 3, 4]
insideMap -&gt; [5]
OnResult wow [5]

</code></pre>

<blockquote>
  <p>The <strong>Buffer</strong> operator transforms an Observable that emits items into an Observable that emits buffered collections of those items. There are a number of variants in the various language-specific implementations of Buffer that differ in how they choose which items go in which buffers.</p>
</blockquote>

<p>Note that if the source Observable issues an <strong>onError</strong> notification, Buffer will pass on this notification immediately without first emitting the buffer it is in the process of assembling, even if that buffer contains items that were emitted by the source Observable before it issued the error notification.</p>
","8164116","","8164116","","2019-03-29 07:19:26","2019-03-29 07:19:26","","","","2","","","","CC BY-SA 4.0"
"55437513","1","","","2019-03-31 03:02:06","","0","84","<p>I am using the RXKotlin combineLatest and I have a multiple source. but I am calling this like</p>

<pre><code>Observables.combineLatest(source1, source2)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(
        {
            val first = it.first
            val second = it.second
        },
        {

        }
    )
</code></pre>

<p>and</p>

<pre><code>Observables.combineLatest(source3, source4)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(
        {
            val first = it.first
            val second = it.second
        },
        {

        }
    )
</code></pre>

<p>now I just want to ask on how to use the combineLatest to my sources only once.</p>

<p>like this.</p>

<pre><code>Observables.combineLatest(source1, source2, source3, source4)
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(
        {
            val first = it.first
            val second = it.second
            val third = it.third
            val fourth = it.fourth
            //...
        },
        {

        }
    )
</code></pre>

<p>I am always using this combineLatest but only with three parameters and I really don't know how or what should I do when I add more parameters to it.</p>

<p>Any help is appreciated, Thank you.</p>
","5693082","","5693082","","2019-03-31 04:52:19","2019-03-31 04:52:19","How to use combineLatest with multiple sources","<android><kotlin><rx-kotlin>","0","2","","2019-03-31 04:28:54","","CC BY-SA 4.0"
"55645167","1","55645276","","2019-04-12 05:43:20","","7","2364","<p>What is the difference between <code>rxjava2</code> dependency and <code>rxkotlin</code> dependency.
 If I'm using <code>rxkotlin</code> dependency, should i need to add <code>rxjava2</code> dependency along with that.</p>

<pre><code>implementation 'io.reactivex.rxjava2:rxkotlin:x.y.z'
// do i need to add the below dependencies also?
implementation 'io.reactivex.rxjava2:rxjava:2.2.4'
implementation 'io.reactivex.rxjava2:rxandroid:2.1.0'
</code></pre>
","5351055","","","","","2020-08-13 12:17:54","What is the difference between rxjava2 and rxkotlin?","<android><kotlin><rx-java2><rx-kotlin>","4","0","","","","CC BY-SA 4.0"
"55645276","2","","55645167","2019-04-12 05:53:23","","8","","<blockquote>
  <p>the thing is RX stands for Reactive Extensions , and Rx Java ,
  Rx Kotlin or Rx Swift all are the implementation of Reactive
  Extensions in that particular language.</p>
</blockquote>

<p><strong>What is RxJAVA?</strong>
RxJava is a Java VM implementation of Reactive Extensions. where we can create asynchronous data stream on any thread, transform it and these asynchronous data streams can be consumed by Observers on any thread.</p>

<p><strong>What is RxKotlin?</strong>
RxKotlin is a Kotlin implementation of Reactive Extensions.</p>

<p><strong>What is RxAndroid?</strong>
It is specific to Android Platform with some more added classes on top of RxJava.</p>

<p>for more details , visit my collection of rxjava simple examples  <a href=""https://github.com/myJarvis/Intro_to_RxJava"" rel=""noreferrer"">https://github.com/myJarvis/Intro_to_RxJava</a> .</p>

<p>and to more clarify , RxKotlin has some convenient extension functions  which comes with Kotlin. </p>

<p>You can either use {RxJava &amp; RxAndroid}  or {RxKotlin}</p>

<blockquote>
  <p>You can use RxJava with Kotlin out-of-the-box</p>
</blockquote>
","7193506","","7193506","","2019-04-12 08:49:39","2019-04-12 08:49:39","","","","10","","","","CC BY-SA 4.0"
"55727396","1","55737305","","2019-04-17 12:18:07","","0","192","<p>After struggling for a few days now, on what seems to be a simple task, I come to you guys:)</p>

<p>Idea is simple. I have two streams/observables, 'left' and 'right'.
I want items from 'right' to buffer/collect/aggregate to 'current' item in 'left'.<br>
Thus, each item in 'left' defines a new 'window', while all 'right' items will bind to that window, until a new 'left' item is emitted. So, to visualize:</p>

<p><strong>Task:</strong><br>
'left' &nbsp;&nbsp;&nbsp; : |- A - - - - - B - - C - - - -|<br>
'right' &nbsp; :       |- 1 - 2 - 3 -4 - 5 - 6 - - -|<br>
'result' : |- - - - - - - -x - - -y - - - -z| &nbsp;&nbsp;( <code>Pair&lt;Left, List&lt;Right&gt;&gt;</code>)<br>
<em>Where: <strong>A,1</strong> ; <strong>B,4</strong> (so x) ; <strong>C</strong> (so y) are emitted on the same time</em><br>
<em>So: &nbsp; &nbsp; &nbsp; x = Pair(A, [1,2,3]), &nbsp;&nbsp;y = Pair(B, [4, 5])</em><br>
<em>And: &nbsp; &nbsp;'right' &amp; 'result' complete/terminate when 'left' does</em><br>
<em>So: &nbsp; &nbsp; &nbsp;z = Pair(C, [6]) - emitted as a result of 'left' completing</em>  </p>

<p><strong>----</strong><br>
<strong>EDIT 2 - FINAL SOLUTION!</strong><br>
In order to aggregate 'right' items with the next 'left' and not the previous one, I changed the code to this much shorter/simpler one:  </p>

<pre><code>fun &lt;L, R&gt; Observable&lt;L&gt;.rightGroupJoin(right: Observable&lt;R&gt;): Observable&lt;Pair&lt;L, List&lt;R&gt;&gt;&gt; {
    return this.share().run {
        zipWith(right.buffer(this), BiFunction { left, rightList -&gt;
            Pair(left, rightList)
        })
    }
}  
</code></pre>

<p><strong>EDIT 1 - initial solution!</strong><br>
Taken from @Mark's (accepted) answer below, here's what I came up with.<br>
It is separated into smaller methods because I also do <code>multiRightGroupJoin()</code> to join in as many (right) streams as I want.  </p>

<pre><code>fun &lt;T, R&gt; Observable&lt;T&gt;.rightGroupJoin(right: Observable&lt;R&gt;): Observable&lt;Pair&lt;T, List&lt;R&gt;&gt;&gt; {
    return this.share().let { thisObservable -&gt;    //use 'share' to avoid multi-subscription complications, e.g. multi calls to **preceding** doOnComplete
        thisObservable.flatMapSingle { t -&gt;        //treat each 'left' as a Single
            bufferRightOnSingleLeft(thisObservable, t, right)
        }
    }
}
</code></pre>

<p>Where:  </p>

<pre><code>private fun &lt;T, R&gt; bufferRightOnSingleLeft(left: Observable&lt;*&gt;, leftSingleItem: T, right: Observable&lt;R&gt;)
    : Single&lt;Pair&lt;T, MutableList&lt;R&gt;&gt;&gt; {

    return right.buffer(left)                              //buffer 'right' until 'left' onNext() (for each 'left' Single) 
        .map { Pair(leftSingleItem, it) }
        .first(Pair(leftSingleItem, emptyList()))   //should be only 1 (list). THINK firstOrError
}  
</code></pre>

<p><strong>----</strong>  </p>

<p><strong>What I got so far</strong><br>
After much reading and the understanding that somehow there's no implementation for this out of the box, I've decided to use <code>groupJoin</code>, mostly using <a href=""https://leecampbell.com/2011/03/14/rx-part-9-join-window-buffer-and-group-join/"" rel=""nofollow noreferrer"">this link</a>, like so: <em>(many problems and places to improve here, don't use this code)</em>  </p>

<pre><code>private fun &lt;T, R&gt; Observable&lt;T&gt;.rightGroupJoin(right: Observable&lt;R&gt;): Observable&lt;Pair&lt;T, List&lt;R&gt;&gt;&gt; {

var thisCompleted = false //THINK is it possible to make the groupJoin complete on the left(this)'s onComplete automatically?
val thisObservable = this.doOnComplete { thisCompleted = true }
        .share() //avoid weird side-effects of multiple onSubscribe calls

//join/attach 'right/other' stream to windows (buffers), starting and ending on each 'this/left' onNext
return thisObservable.groupJoin(

    //bind 'right/other' stream to 'this/left'
    right.takeUntil { thisCompleted }//have an onComplete rule THINK add share() at the end?

    //define when windows start/end ('this/left' onNext opens new window and closes prev)
    , Function&lt;T, ObservableSource&lt;T&gt;&gt; { thisObservable }

    //define 'right/other' stream to have no windows/intervals/aggregations by itself
    // -&gt; immediately bind each emitted item to a 'current' window(T) above
    , Function&lt;R, ObservableSource&lt;R&gt;&gt; { Observable.empty() }

    //collect the whole 'right' stream in 'current' ('left') window
    , BiFunction&lt;T, Observable&lt;R&gt;, Single&lt;Pair&lt;T, List&lt;R&gt;&gt;&gt;&gt; { t, rObs -&gt;
        rObs.collect({ mutableListOf&lt;R&gt;() }) { acc, value -&gt;
            acc.add(value)
        }.map { Pair(t, it.toList()) }

    }).mergeAllSingles()
}  
</code></pre>

<p>I also used similar usage to create a <code>timedBuffer()</code> - same as <code>buffer(timeout)</code> but with a timestamp on each buffer(<code>List</code>) to know when it started. Basically by running the same code on an <code>Observable.interval(timeout)</code> (as the 'left')</p>

<p><strong>Problems / Questions (from the easiest to the hardest)</strong>  </p>

<ol>
<li>Is it the best way of doing something like that? Isn't it an overkill?</li>
<li>Is there a better way (must be) for completing the 'result' (and 'right') when 'left' is completed? Without this ugly boolean logic?</li>
<li><p>This usage seem to mess up the order of the rx. See code and print below:  </p>

<pre><code>leftObservable
.doOnComplete {
    log(""doOnComplete - before join"")
 }
.doOnComplete {
    log(""doOnComplete 2 - before join"")
 }
.rightGroupJoin(rightObservable)
.doOnComplete {
    log(""doOnComplete - after join"")
 }
</code></pre></li>
</ol>

<p>Prints (sometimes! Looks like a race condition) the following:<br>
<code>doOnComplete - before join</code><br>
<code>doOnComplete - after join</code><br>
<code>doOnComplete 2 - before join</code>  </p>

<ol start=""4"">
<li><p>On first run of the above code, <code>doOnComplete - after join</code> is not called, on the second time it's called <strong>twice</strong>. Third time is like the first, forth is like the second, etc...<br>
Both 3,4 are ran using this code. Probably has something to do with the subscribe {} usage? Note that I don't hold the disposable.
This stream finishes because I GC the 'left' observable</p>

<pre><code>leftObservable.subscribeOn().observeOn()
.doOnComplete{log...}
.rightGroupJoin()
.doOnComplete{log...}
.subscribe {}  
</code></pre></li>
</ol>

<p>Note1: adding <code>.takeUntil { thisCompleted }</code> after <code>mergeAllSingles()</code> seems to fix #4.   </p>

<p>Note2: After using this method to join multiple streams and applying 'Note1', it's apparent that the onComplete (before the groupJoin() call !!!) will be called as many times as there are 'right' Observables, probably meaning that the cause is the <code>right.takeUntil { thisCompleted }</code>, is it really important to close the 'right' stream?  </p>

<p>Note3: concerning Note1, it seems very much related to takeUntil vs. takeWhile. Using takeWhile lowers the doOnComplete calls, and it's somehow logical. Still trying to figure it out better.</p>

<ol start=""5"">
<li>Can you think of a multiGroupJoin, or in our case, multiRightGroupJoin, other than running zip on groupJoin * rightObservablesCount?</li>
</ol>

<p>Please ask anything you like. I know for a fact the my usage of the subscribe/disposable and the manual onComplete are not the way, I'm just not sure enough what is..</p>
","2774781","","2774781","","2019-04-24 17:39:03","2019-04-24 18:01:18","Rx (RxKotlin) - rightGroupJoin using groupJoin - merge / combine two observables of different types","<rxjs><rx-java><reactive-programming><rx-kotlin><rx-kotlin2>","2","0","1","","","CC BY-SA 4.0"
"55737305","2","","55727396","2019-04-17 23:32:56","","1","","<p>Something as simple as this should work :</p>

<pre><code>@JvmStatic
fun main(string: Array&lt;String&gt;) {
    val left = PublishSubject.create&lt;String&gt;()
    val right = PublishSubject.create&lt;Int&gt;()

    left.flatMapSingle { s -&gt;  right.buffer(left).map { Pair(s, it) }.firstOrError() }
            .subscribe{ println(""Group : Letter : ${it.first}, Elements : ${it.second}"") }


    left.onNext(""A"")
    right.onNext(1)
    right.onNext(2)
    right.onNext(3)
    left.onNext(""B"")
    right.onNext(4)
    right.onNext(5)
    left.onNext(""C"")
    right.onNext(6)
    left.onComplete()
}
</code></pre>

<p>Output :</p>

<pre><code>Group : Letter : A, Elements : [1, 2, 3]
Group : Letter : B, Elements : [4, 5]
Group : Letter : C, Elements : [6]
</code></pre>

<p>Your <code>Observable</code> of interest is the left, so subscribe to it. Then just buffer the right by the left observable's next emission or completion.  You're only ever interested in a single result of each upstream left emission, so just use <code>flatMapSingle</code>.  I chose <code>firstOrError()</code> but obviously could have a default item or other error handling or even a <code>flatMapMaybe</code> coupled with <code>firstElement()</code></p>

<p><strong>Edit</strong></p>

<p>OP has had further Q&amp;A and discovered that the original question and above solution to buffer right values with the previous left emission, until the next left emission (as above), is not the required behaviour.  New required behaviour is to buffer right values to the NEXT left emission as so:</p>

<pre><code>@JvmStatic
    fun main(string: Array&lt;String&gt;) {
        val left = PublishSubject.create&lt;String&gt;()
        val right = PublishSubject.create&lt;Int&gt;()


        left.zipWith (right.buffer(left), 
                BiFunction&lt;String, List&lt;Int&gt;, Pair&lt;String, List&lt;Int&gt;&gt;&gt; { t1, t2 -&gt; Pair(t1, t2)
        }).subscribe { println(""Group : Letter : ${it.first}, Elements : ${it.second}"") }

        left.onNext(""A"")
        right.onNext(1)
        right.onNext(2)
        right.onNext(3)
        left.onNext(""B"")
        right.onNext(4)
        right.onNext(5)
        left.onNext(""C"")
        right.onNext(6)
        left.onComplete()
    }
</code></pre>

<p>Which produces a different final result as left values are zipped with previous right values, until next left emission (inverse).</p>

<p>Output :</p>

<pre><code>Group : Letter : A, Elements : []
Group : Letter : B, Elements : [1, 2, 3]
Group : Letter : C, Elements : [4, 5]
</code></pre>
","4252352","","4252352","","2019-04-24 18:01:18","2019-04-24 18:01:18","","","","5","","","","CC BY-SA 4.0"
"55874840","1","","","2019-04-26 20:56:34","","4","2780","<p>Why do I get different results when unit testing my ViewModel?</p>

<p>I got two tests. When I launch each test individually that's ok but when I launch all tests in a row I got an error.
It's a ViewModel that change state each time I got a return from an 
API. I expect to get <code>android.arch.lifecycle.Observer.onChanged</code> called two times but it's just called once for the second test.
Unit test works fine when I replace <code>verify(view, times(2)).onChanged(arg.capture())</code> with <code>verify(view, atLeastOnce()).onChanged(arg.capture())</code> at the first test.</p>

<p>UserViewModel :</p>

<pre><code>class UserViewModel(
        private val leApi: LeApi
): ViewModel() {
    private val _states = MutableLiveData&lt;ViewModelState&gt;()
    val states: LiveData&lt;ViewModelState&gt;
        get() = _states

    fun getCurrentUser() {
        _states.value = LoadingState
        leApi.getCurrentUser()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(
                        { user -&gt; _states.value = UserConnected(user) },
                        { t -&gt; _states.value = FailedState(t) }
                )
        }
    }
}
</code></pre>

<p>UserViewModelTest :</p>

<pre><code>@RunWith(MockitoJUnitRunner::class)
class UserViewModelTest {

    lateinit var userViewModel: UserViewModel

    @Mock
    lateinit var view: Observer&lt;ViewModelState&gt;

    @Mock
    lateinit var leApi: LeApi

    @get:Rule
    val rule = InstantTaskExecutorRule()

    @Before
    fun setUp() {
        RxAndroidPlugins.setInitMainThreadSchedulerHandler { Schedulers.trampoline() }
        userViewModel = UserViewModel(leApi)
        userViewModel.states.observeForever(view)
    }

    @Test
    fun testGetCurrentUser() {
        val user = Mockito.mock(User::class.java)
        `when`(leApi.getCurrentUser()).thenReturn(Single.just(user))
        userViewModel.getCurrentUser()

        val arg = ArgumentCaptor.forClass(ViewModelState::class.java)
        verify(view, times(2)).onChanged(arg.capture())

        val values = arg.allValues

        assertEquals(2, values.size)
        assertEquals(LoadingState, values[0])
        assertEquals(UserConnected(user), values[1])
    }

    @Test
    fun testGetCurrentUserFailed() {
        val error = Throwable(""Got error"")
        `when`(leApi.getCurrentUser()).thenReturn(Single.error(error))
        userViewModel.getCurrentUser()

        val arg = ArgumentCaptor.forClass(ViewModelState::class.java)
        verify(view, times(2)).onChanged(arg.capture()) // Error occurred here. That's the 70th line from stack trace.

        val values = arg.allValues
        assertEquals(2, values.size)
        assertEquals(LoadingState, values[0])
        assertEquals(FailedState(error), values[1])
    }
}
</code></pre>

<p>Expected :
All tests passed.</p>

<p>Actual :</p>

<pre><code>org.mockito.exceptions.verification.TooLittleActualInvocations: 
view.onChanged(&lt;Capturing argument&gt;);
Wanted 2 times:
-&gt; at com.dev.titi.toto.mvvm.UserViewModelTest.testGetCurrentUserFailed(UserViewModelTest.kt:70)
But was 1 time:
-&gt; at android.arch.lifecycle.LiveData.considerNotify(LiveData.java:109)
</code></pre>
","11417436","","8134164","","2019-04-27 06:04:12","2019-08-25 09:26:08","Unit Test : Observer onChanged should be called twice instead of once","<android><unit-testing><mockito><android-viewmodel><rx-kotlin>","1","4","","","","CC BY-SA 4.0"
"55897609","1","55902557","","2019-04-29 05:46:08","","0","130","<p>I need to zip more than 3 observables with zip operator in rxkotlin, but when i try to zip more than 3 it shows me compile time error.<br>
<strong>Example</strong></p>

<pre><code> Observables.zip(Observable.just(someFun(0),Observable.just(someFun(1),Observable.just(someFun(2),Observable.just(someFun(3))
</code></pre>

<p>Is there we can zip more than 3 observable ?<br>
Any help</p>
","9344496","","","","","2019-04-29 11:38:03","Rxkotlin - How to zip more than three observables with zip operator","<rx-java><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"55902557","2","","55897609","2019-04-29 11:38:03","","1","","<p>Have you tried <code>zip</code>ping more than three <code>Observable</code>s? RxKotlin has a <code>zip</code> function up until six sources.<br>
So the answer is: yes, you can zip more than 3 observables.</p>
","1292745","","","","","2019-04-29 11:38:03","","","","1","","","","CC BY-SA 4.0"
"55914451","1","","","2019-04-30 05:27:21","","0","46","<p>I have a three layers in my application <strong>app</strong>, <strong>data</strong>, <strong>domain</strong>, i will be getting my result entity for my <strong>app</strong> from <strong>domain</strong> layer , the result entity class will be implementing with some interface <strong>L1</strong>, my need is when the result reaches app layer i need to replace the interface <strong>L1</strong> which is implemented in result entity  to interface <strong>L2</strong></p>

<p>Example<br>
<strong>Domain</strong></p>

<pre><code>interface L1
</code></pre>

<p>The above interface will not contain any methods or variables </p>

<pre><code>data class Result(val data : Any) : L1
</code></pre>

<p><strong>App</strong> </p>

<pre><code>interface L2
</code></pre>

<p>same as like interface L1</p>

<pre><code>data class Result(val data : Any) : L2
</code></pre>

<p>I am not sure whether i can achieve using rxkotlin, i had a rough idea about it like</p>

<pre><code>@Binds
abstract fun bindL1WithL2(l2 : L2) : L1
</code></pre>

<p>Is there is any solution for this ?<br>
Any help</p>
","9344496","","","","","2019-04-30 05:27:21","Android - Replacing One interface with other one using rx-kotlin","<android><kotlin><rx-java><rx-kotlin>","0","3","","","","CC BY-SA 4.0"
"55963637","1","","","2019-05-03 05:11:40","","-1","296","<p>I am using retrofit2 for making service call in my application, i need to show the progress percentage for the service call which is made using retrofit, the result of the call will be of some JSON object. we know that for downloading files we can use <code>@Streaming</code> and <code>ResponseBody</code> in retrofit for getting progress percent, but am unaware for the JSON response.</p>

<p>Example</p>

<pre><code>@POST(""/getdata"")
fun callSomeApi(@Query(""id"") id : String) : Observable&lt;Data&gt;
</code></pre>

<p>Is there is any option to get progress percent for JSON response using retrofit ?<br>
Any help</p>
","9344496","","","","","2019-05-03 11:06:58","Android - How to get progress for normal http call using retrofit","<android><kotlin><retrofit2><rx-kotlin>","1","1","1","","","CC BY-SA 4.0"
"56117279","1","","","2019-05-13 17:33:37","","1","39","<p>I'm using rxAndroid with an MVVM architecture. In my Activity, I need to bind my streams then fetch data from the server, which will eventually call the downstream.</p>

<p>My reasoning is the following:<br>
- I need to unsubscribe my streams in <code>onStop()</code> (<code>onDestroy</code> can cause memory leaks).<br>
-> therefore I need to subscribe to them in <code>onStart()</code> (otherwise coming back from background doesn't recreate the stream).<br>
-> therefore I need to fetch my data in or after <code>onStart()</code>, because the stream has to be bound before I can start calling the upstream.  </p>

<p>But in this case, every time I come back to the app after background, it's going to call the fetch method, which is not a behavior I want. Ideally I'd like to call the fetch method once, for example in <code>onCreate()</code>.</p>

<p>How can I nicely deal with this problem? I've tried finding solutions on SO and other websites but no luck.</p>
","10909037","","","","","2019-09-13 19:21:31","When to subscribe/bind streams in android lifecycle?","<android><kotlin><rx-android><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"56252342","1","56252954","","2019-05-22 08:23:21","","0","57","<p>I am trying to get access_token with RXjava.</p>

<p>I ran the program and called the function that requests the access_token, but the process finishes with code 0.</p>

<p>I think the main thread is dead while connecting the server</p>

<p>my solution was
<code>Thread.sleep(sometime)</code>
to give short time to get the response.</p>

<p>and I also tried </p>

<pre><code>val runnable = Runnable{ getToken() }
val thread = Thread(runnable)
thread.run()
thread.join()
</code></pre>

<p>but it didn't work..</p>

<p>here is my code below</p>

<pre><code>fun main(args : Array&lt;String&gt;) {
    getToken()

//    Thread.sleep(10000) // it works but don't want to do with this
}



fun getToken() {
    val id = ""test""
    val pw = ""test""
    println(id + "" "" + pw)

    val oAuthService = Retrofit.Builder()
        .baseUrl(URL)
        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
        .addConverterFactory(GsonConverterFactory.create())
        .client(httpClient)
        .build()
        .create(OAuthService::class.java)

    oAuthService.getAccessToken(
        CLIENT_ID,
        CLIENT_SECRET,
        id,
        pw
    ).subscribeOn(Schedulers.io())
        .flatMap {
            when(it.error){
                null -&gt; Single.just(TokenDto.Success(it.access_token?:"""", it.expires_int?:0, it.token_type?:"""", it.refresh_token?:""""))
                else -&gt; Single.just(TokenDto.Failure(""failed""))
            }
        }
        .retry { times, throwable -&gt;
            println(throwable)
            times &lt; 3 }
        .subscribeBy(
            onSuccess = {
                println(""onSuccess"")
                when(it){
                    is TokenDto.Success -&gt; {
                        println(""accessToken : ${it.access_token}"")
                    }
                    is TokenDto.Failure -&gt; {
                        println(""failed : ${it.msg}"")
                    }
                }
            },
            onError = {
                println(""onError"")
            }
        )
}


</code></pre>

<p>retrofit</p>

<pre><code>interface OAuthService {

    @FormUrlEncoded
    @POST(""oauth2/token"")
    fun getAccessToken(
        @Field(""client_id"") client_id:String,
        @Field(""client_secret"") client_secret:String,
        @Field(""username"") username:String,
        @Field(""password"") password:String
    ):Single&lt;TokenResponse&gt;
</code></pre>
","11532568","","8200936","","2019-05-22 10:11:38","2019-05-22 10:42:46","main function is dead while rxjava is working. any solution please","<kotlin><rx-java><retrofit2><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"56252954","2","","56252342","2019-05-22 08:56:34","","1","","<p>Your subscription to <code>getAccessToken</code> is asynchronous. That's mean that <code>subscribeBy</code> returns immediately and then your main thread is terminated because it has nothing to do. You can use <code>blockingSubscribeBy</code> if you have <code>Observable</code> or <code>blockingGet</code> in a case when you use <code>Single</code>. Both of the operators should block the subscription.</p>

<p>I also want to clarify that blocking is bad, you should avoid it. Specifically, in your situation, it's ok because you want to block the execution in the main function which is kind of ""end of the world"" of your program.</p>
","8200936","","8200936","","2019-05-22 10:42:46","2019-05-22 10:42:46","","","","3","","","","CC BY-SA 4.0"
"56362602","1","56363137","","2019-05-29 14:12:05","","3","147","<p>I have a simple setup to a problem but the solution seems to be more complicated.</p>

<p>Setup: I have a hot observable which originates from a scanner that will emit every number as a different element and an <code>R</code> when a code is complete.</p>

<p>Problem: From this I want a hot observable that emits every full code as 1 element.</p>

<p><a href=""https://i.stack.imgur.com/Rh5Xg.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Rh5Xg.png"" alt=""RxMarbles example""></a></p>

<p>I tried playing around with different <code>flatMap</code>, <code>takeUntil</code> and <code>groupBy</code>operators but haven't been able to come to a solution.</p>
","776141","","","","","2019-05-29 15:41:56","Take elements until a certain character and group them with RxJava","<java><kotlin><rx-java><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"56363137","2","","56362602","2019-05-29 14:38:58","","3","","<p>You can use the <em>buffer</em> operator.</p>

<pre><code>PublishSubject&lt;Token&lt;Integer&gt;&gt; s = PublishSubject.create();

Observable&lt;Token&lt;Integer&gt;&gt; markers = s.filter(x-&gt;x.isMarker());

s.buffer(markers).subscribe(
    v-&gt;{
        Optional&lt;Integer&gt; reduce = v.stream()
            .filter(t-&gt;!t.isMarker())
            .map(t-&gt;(ValueToken&lt;Integer&gt;)t)
            .map(ValueToken::get)
            .reduce((a,b)-&gt;a+b);
        reduce.ifPresent(System.out::println);
    }
);

s.onNext(value(12));
s.onNext(value(13));
s.onNext(marker()); // will emit 25

s.onNext(value(10));
s.onNext(value(7));
s.onNext(marker()); // will emit 17

s.onNext(value(10));
s.onNext(value(7)); // Not emitting yet
</code></pre>

<p>I made a class to wrap both values and markers in the flow.</p>

<pre><code>public abstract class Token&lt;T&gt; {
    private static final MarkerToken MARKER = new MarkerToken&lt;&gt;();

    public boolean isMarker() {
        return false;
    }

    public static &lt;T&gt; MarkerToken&lt;T&gt; marker() {
        return MARKER;
    }

    public static &lt;T&gt; ValueToken&lt;T&gt; value(T o) {
        return new ValueToken&lt;&gt;(o);
    }

    public static class ValueToken&lt;T&gt; extends Token&lt;T&gt; {
        T value;

        public ValueToken(T value) {
            this.value = value;
        }

        public T get() {
            return value;
        }
    }

    public static class MarkerToken&lt;T&gt; extends Token&lt;T&gt; {
        public boolean isMarker() {
            return true;
        }
    }

}
</code></pre>

<h2>update (using scan)</h2>

<p>The previous method would emit also on the closing of the stream, with this solution you can emit <strong>only</strong> complete buffers.</p>

<p>The message class function as an accumulator, it will accumulate tokens until closing marker is accumulated.</p>

<p>When this happens the <em>next</em> message will start from scratch.</p>

<p>The presence of the closing mark as last element <em>marks</em> the message as complete.</p>

<pre><code>public static class Message&lt;T&gt; {
    List&lt;Token&lt;T&gt;&gt; tokens = new ArrayList&lt;&gt;();

    public Message&lt;T&gt; append(Token&lt;T&gt; t) {

        Message&lt;T&gt; mx = new Message&lt;T&gt;();
        if(!isComplete()) {
            mx.tokens.addAll(tokens);
        }
        mx.tokens.add(t);
        return mx;
    }

    public boolean isComplete() {
        int n = tokens.size();
        return n&gt;0 &amp;&amp; tokens.get(n-1).isMarker();
    }

    public Optional&lt;List&lt;Token&lt;T&gt;&gt;&gt; fullMessage(){
        return isComplete() ? Optional.of(tokens):Optional.empty(); 
    }
}
</code></pre>

<p>Scanning the source you emit a message for each token emitted, then you filter out incomplete message and emit just the one marked as complete.</p>

<pre><code>    s.scan(new Message&lt;Integer&gt;(), (a, b) -&gt; a.append(b))
        .filter(Message::isComplete)
        .map(Message::fullMessage)
        .map(Optional::get).subscribe(v -&gt; {
            System.out.println(v);
        });

    s.onNext(value(12));
    s.onNext(value(13));
    s.onNext(marker());// [V(12), V(13), MARKER]

    s.onNext(value(10));
    s.onNext(value(7));
    s.onNext(marker()); // [V(10), V(7), MARKER]



    s.onNext(value(10));
    s.onNext(value(127));

    s.onComplete(); // Not emitting incomplete messages on the closing of the subject.
</code></pre>
","1271255","","1271255","","2019-05-29 15:41:56","2019-05-29 15:41:56","","","","0","","","","CC BY-SA 4.0"
"56547732","1","56556776","","2019-06-11 16:04:36","","0","178","<p>How can I collect emitted values from observable to array?</p>

<p><strong>Input:</strong></p>

<pre><code>Observable.just(1,2,3,4,5,6)
</code></pre>

<p><strong>Expected output:</strong></p>

<pre><code>[1,2,3,4,5,6]
</code></pre>
","2543013","","2543013","","2019-06-11 16:57:10","2019-06-12 07:29:11","RxJava collect emitted values to array","<rx-java><rx-java2><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"56556776","2","","56547732","2019-06-12 07:29:11","","1","","<p>There's a couple of options. Easiest is to use <code>toList()</code>:</p>

<pre><code>Observable.just(1,2,3,4,5,6)
    .toList()
</code></pre>

<p>If you need to do more than just collect them into a list you can use <code>collect()</code>:</p>

<pre><code>List&lt;Integer&gt; collected = new ArrayList&lt;&gt;();
Observable.just(1,2,3,4,5,6)
    .collect(collected, (alreadyCollected, value) -&gt; {
             // Do something with value and add it to collected at the end
        });
</code></pre>

<p><a href=""https://github.com/ReactiveX/RxJava/wiki/Mathematical-and-Aggregate-Operators#collect"" rel=""nofollow noreferrer"">Here</a> you'll find a better explanation about <code>collect</code></p>
","344487","","","","","2019-06-12 07:29:11","","","","0","","","","CC BY-SA 4.0"
"56569345","1","","","2019-06-12 19:42:30","","1","339","<p>How can I collect emitted items from observable to List when observable never completes?</p>

<p>Example I have something similar so Observable emits series of values, but never completes unless you unsubscribe, because of that <code>.toList()</code> not gonna work.</p>

<pre><code>Observable&lt;User&gt;
 .flatMap {}
 .toList()
</code></pre>

<p>How can I collect All users to List and emit it once after applying flatMap function to it?</p>
","2543013","","","","","2019-06-12 20:40:43","RxJava Collect emission to list","<android><rx-java><rx-java2><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"56660075","1","","","2019-06-19 04:29:48","","1","98","<p>I have a list of items say for example list of integers, if any of the integer is null, i need to consume the error and proceed with the next item</p>

<p>For example</p>

<pre><code>Observable.fromIterable(listOf(1, 2, 3, null, 5))
                .map {
                    doSomeProcess(it)
                }
                .onErrorReturnItem(-1)
                .subscribeBy(
                        onNext = {
                           print(it)
                        },
                        onError = {

                        },
                        onComplete = {

                        })
</code></pre>

<p>I am expecting the output like this</p>

<pre><code>1
2
3
-1
5
</code></pre>

<p>But my problem is after <code>-1</code> it is not getting proceeded with item <code>5</code>, it stops there, Can anyone help me out with this ?</p>
","9344496","","","","","2019-06-19 06:49:24","How to handle errors in rxjava chain in android?","<android><rx-java><rx-kotlin><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"56740292","1","","","2019-06-24 16:03:53","","0","286","<p>I've tried some examples with viewmodels and databinding using BehaviorSubjects and other Observables. Now I have real (data class) object in Kotlin, which holds most of the state. It is basically pojo, but independent from viewmodel and has no observables.
I don't understand how can I bind this automatically to ex. TextView in android without creating external observable variables in viewmodel and some boilercode. I'd think this is something very common in mvvm pattern. Or am I missing something totally?</p>
","4070660","","4070660","","2019-06-24 16:17:42","2019-06-25 15:20:03","Model properties binding in android viewmodel","<rx-java><rx-java2><rx-android><rx-kotlin><rx-kotlin2>","1","1","","","","CC BY-SA 4.0"
"56867353","1","56867985","","2019-07-03 09:49:17","","2","153","<p>I need to make a lot of API calls asynchronously and obviously make sure that they all pass so I can handle error/success in a single place.</p>

<p>Is there a way to easily extend Singles.zip() functionality in Kotlin to take more than base 9 parameters (in best case scenario, to make it take any given number of parameters) without doing massive amounts of copy-paste work when writing your own extensions for t10, t11, etc. ?</p>

<p>Well, writing dozens of extensions simply works, but is cumbersome, not very elegant and adds additional work.</p>
","10675759","","","","","2019-07-03 12:17:18","Extending Rx Singles zip infinitely","<java><android><kotlin><rx-java><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"56867985","2","","56867353","2019-07-03 10:24:13","","2","","<p>Single.zip method takes an Iterable of Singles</p>

<pre><code>val list = arrayListOf&lt;Single&lt;String&gt;&gt;()
list.add(Single.just(""hello""))
list.add(Single.just(""world""))

Single.zip(list) { args -&gt; Arrays.asList(args) }
        .subscribeOn(Schedulers.io())
        .observeOn(Schedulers.computation())
        .subscribe()
</code></pre>
","744015","","744015","","2019-07-03 12:17:18","2019-07-03 12:17:18","","","","0","","","","CC BY-SA 4.0"
"57049336","1","57051371","","2019-07-16 02:32:23","","2","196","<p>I have a <code>Category</code> data class and a <code>Plan</code> data class.
Each <code>Category</code> has a list of plan ids. There are Categories and Plans stored via Room.  I am trying to construct a local <code>List&lt;Any&gt;</code> where I add each category to a list, and then add each of it's plans.</p>

<p>So for each category, add the category to the list, then add each plan that belongs to that category.</p>

<p>The final result would look something like this...</p>

<pre><code>0 -&gt; a Category
1 -&gt; a Plan
2 -&gt; a Plan
3 -&gt; a Plan
4 -&gt; a Category
5 -&gt; a Plan
</code></pre>

<p>etc.</p>

<p>The following calls sucessfully return an <code>Observable&lt;List&lt;Category&gt;&gt;</code> and an <code>Observable&lt;Plan&gt;</code></p>

<pre><code>AppDatabase
   .getDatabase(context)
   .categoryDao()
   .getAll()

AppDatabase.getDatabase(context).planDao().getPlan(planId)
</code></pre>

<p>Here I am trying to build my list, but it actually never emits when I subscribe to it. No completion, or error. Everything else in the stream get's hit. Why can't I get my final result?</p>

<pre><code>    fun fetchCategoriesAndPlans() {
    val items = mutableListOf&lt;Any&gt;()
    AppDatabase
        .getDatabase(context)
        .categoryDao()
        .getAll()
        .concatMap { listOfCategories -&gt;
            listOfCategories.toObservable()
        }
        .doOnNext { category -&gt;
            items.add(category)
        }
        .concatMap { category -&gt;
            category.getPlanIds()!!.toObservable()
        }
        .flatMap { planId -&gt;
            AppDatabase.getDatabase(context).planDao().getPlan(planId)
        }.collectInto(items, BiConsumer{ list, i -&gt;
            Log.d(TAG, ""Collect into"")
            list.add(i)
        })
        .subscribeBy(
            onSuccess = {
                Log.d(TAG, ""Got the list"")
            },
            onError = {
                Log.e(TAG, ""Couldn't build list ${it.message}"", it)
            })
}
</code></pre>
","629259","","629259","","2019-07-16 02:54:01","2019-07-16 06:38:48","Building a list from two observable sources in RxKotlin/RxJava using collectInto","<android><rx-java2><android-room><collect><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"57051371","2","","57049336","2019-07-16 06:38:48","","1","","<p>I make a demo base on your case which help emit both <code>Category</code> and <code>Plan</code></p>

<pre><code>override fun onCreate(savedInstanceState: Bundle?) {
    ...

    getCategories()
        .flattenAsObservable { it }
        .flatMap { getPlanWithCategory(it) }
        .toList()
        .subscribe({
            for (item in it) {
                Log.i(""TAG"", "" "" + item.javaClass.canonicalName)
            }
        }, {

        })
}

fun getPlanWithCategory(category: Category): Observable&lt;Any&gt; {
    val getPlansObservable = Observable.fromArray(category.planIds).flatMapIterable {
        it
    }.flatMap {
        getPlan(it).toObservable()
    }
    return Observable.concat(Observable.just(category), getPlansObservable)
}


fun getPlan(planId: String): Single&lt;Plan&gt; {
    return Single.just(Plan())
}

fun getCategories(): Single&lt;List&lt;Category&gt;&gt; {
    val categories = arrayListOf&lt;Category&gt;()
    categories.add(Category(arrayListOf(""1"", ""2"", ""3"")))
    categories.add(Category(arrayListOf(""1"", ""2"")))
    return Single.just(categories)
}

class Category(val planIds: List&lt;String&gt;)

class Plan
</code></pre>

<p>Out put</p>

<pre><code> I/TAG:  Category
 I/TAG:  Plan
 I/TAG:  Plan
 I/TAG:  Category
 I/TAG:  Plan
 I/TAG:  Plan
</code></pre>

<p>Hope it help</p>
","5381331","","","","","2019-07-16 06:38:48","","","","2","","","","CC BY-SA 4.0"
"57063614","1","57928983","","2019-07-16 18:41:56","","1","385","<p>1) The code below fails to compile with an error: ""not enough information to infer type variable R""</p>

<pre><code>keywordChanges
  .withLatestFrom(searchParamsSubject)
  .subscribe { (keyword, searchParams) -&gt;
     ...
  }
</code></pre>

<p>2) The code below compiles and works, but I would prefer not to have an empty <code>subscribe()</code> and not to put side effects into the combiner function.</p>

<pre><code>keywordChanges
  .withLatestFrom(searchParamsSubject) { keyword, searchParams -&gt;
    searchParamsSubject.onNext(searchParams.copy(keyword = keyword))
  }
  .subscribe()
</code></pre>

<p>3) Below is the code from the RxKotlin library, that I am trying to call in 1)</p>

<pre><code>/**
 * Emits a `Pair`
 */
inline fun &lt;T, U, R&gt; Observable&lt;T&gt;.withLatestFrom(other: ObservableSource&lt;U&gt;): Observable&lt;Pair&lt;T,U&gt;&gt;
        = withLatestFrom(other, BiFunction{ t, u -&gt; Pair(t,u)  }
</code></pre>

<h3>How could I modify the code in 1) to make it work?</h3>
","133309","","","","","2019-09-13 18:55:30","RxKotlin ""withLatestFrom(...)"" compile error: not enough information to infer type variable R","<kotlin><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"57188728","1","","","2019-07-24 17:56:16","","1","282","<p>I am new to Android development, I'm trying to make form validation using RxKotlin and RxBinding.</p>

<p>I need a guidance how to make form validation with more than 9 fields?
Actually I can combine the result using <code>Observable.combinelatest</code>.</p>

<p>This is the code I've been trying:</p>

<pre><code>Observable.combineLatest(profileObserver, shopName, shopAddress, ownerName, idCard, ownerHp, ownerEmail, pin, confirmPin,
                Function9&lt;CharSequence, CharSequence, CharSequence, CharSequence, CharSequence, CharSequence, CharSequence, CharSequence, CharSequence,
                        Boolean&gt; {profile, name, address, owner, card, hpNumber, email, currentPin, confirmationPin -&gt;
                    return@Function9 isShopNameValid(name.toString()) &amp;&amp; isShopAddressValid(address.toString())
                            &amp;&amp; isOwnerNameValid(owner.toString())
                            &amp;&amp; isIdCardValid(card.toString())
                            &amp;&amp; isOwnerHpValid(hpNumber.toString())
                            &amp;&amp; isOwnerEmail(email.toString())
                            &amp;&amp; isPinValid(currentPin.toString())
                            &amp;&amp; isConfirmPinValid(confirmationPin.toString())
                }).subscribe {
                registrationProcess.isEnabled = it
            }
</code></pre>

<p>I still have 3 more fields to be validated.</p>
","5501860","","8412192","","2019-08-02 07:41:36","2019-09-13 15:01:37","RxKotlin combine latest more than 9 fields","<rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"57404599","1","57404794","","2019-08-08 02:58:31","","1","294","<p>Unfortunately, my REST Delete operation work only for one item. So what I was trying to do is,</p>

<pre><code>Observable.just(items).flatMapIterable { items -&gt; items }.flatMap {
                //call REST DELETE for every item
            }.flatMap {
                // call REST GET
            }
</code></pre>

<p>The problem is the GET call is being called for every item. How can I wait for finishing all the delete done and then perform the GET call? </p>

<p>Thanks in Advance.</p>
","1077539","","3633468","","2019-08-08 09:48:56","2019-08-08 09:48:56","Perform a task for all items in a list and then perform another task in RxJava","<java><android><kotlin><rx-java><rx-kotlin>","3","5","","","","CC BY-SA 4.0"
"57404794","2","","57404599","2019-08-08 03:28:27","","1","","<p>In your case, you can apply <code>toList()</code> like this</p>

<pre><code>fun doTask(items: List&lt;String&gt;):Observable&lt;Boolean&gt;{
        return Observable.fromIterable(items)
                .flatMap { processItem(it) }
                .toList()
                .toObservable()
                .flatMap { finalTask() }
    }
</code></pre>
","2164363","","2164363","","2019-08-08 04:38:34","2019-08-08 04:38:34","","","","2","","","","CC BY-SA 4.0"
"57469647","1","57480686","","2019-08-13 00:10:33","","0","165","<p>I'm trying for some time now to implement an extension function (just becuse it's easier to me) that is capable of delaying both normal item emissions and errors. The existing delay operators only delays normal item emissions, errors are delivered ASAP.</p>

<p>For context, I'm trying to immitate an Android LiveData's behavior (kinda). LiveDatas are a observable pattern implementation that is lifecycle aware. Their observers are only notified if they are in a state where they can process that emission. If they are not ready, the emission is cached in the livedata and delivered as soon as they become ready.</p>

<p>I created a BehaviourSubject that emits the state of my Activities and Fragments when it changes. With that I created a delay operator like this:</p>

<pre><code>fun &lt;T&gt; Flowable&lt;T&gt;.delayUntilActive(): Flowable&lt;T&gt; = delay { lifecycleSubject.toFlowable(BackpressureStrategy.LATEST).filter { it.isActive } }
</code></pre>

<p>and then use it like this</p>

<pre><code>myUseCase.getFlowable(Unit)
                .map { it.map { it.toDisplayModel() } }
                .delayUntilActive()
                .subscribe({
                    view.displaySomethings(
                }, { }).addTo(disposables)
</code></pre>

<p>So even if myUseCase emits when the view is not ready to display somethings, the emission won't reach onNext() until the view does become ready. The problem is that I also want the view to displayError() when onError is triggered, but that too is lifecycle sensitive. If the view isn't ready, the app will crash.</p>

<p>So I'm looking for a way to delay both emissions and errors (onComplete would be good too). Is this possible?
I tried some things with zip, onErrorReturn, delay inside delay, but nothing seemed right. I'd be equally unimpressed if this had a really easy solution I'm overlooking, or is impossible. Any ideas are welcome.</p>

<p>Bonus: any better way to do that for Single and Completable too? currently I'm just converting them to flowable. </p>

<p>Thanks in advance!</p>
","10614184","","10614184","","2019-10-05 03:34:53","2019-10-05 03:34:53","Is it possible to implement an operator like delay but that also delays errors?","<android><rx-java2><reactivex><rx-kotlin>","1","0","1","","","CC BY-SA 4.0"
"57480686","2","","57469647","2019-08-13 15:10:05","","2","","<p>You can handle the error via <code>onErrorResumeNext</code>, then taking the same error and delaying it via <code>delaySubscription</code> until your desired signal to emit said error happens:</p>

<pre><code>source
.onErrorResumeNext({ error -&gt; 
     Observable.error(error)
     .delaySubscription(lifecycleSubject.filter { it.Active } ) 
})
</code></pre>
","61158","","","","","2019-08-13 15:10:05","","","","0","","","","CC BY-SA 4.0"
"57618052","1","57672830","","2019-08-22 23:13:53","","0","170","<p>I have 2 observable sources where <code>fetchProductList()</code> returns <code>Observable&lt;Datasource&gt;</code> and other <code>canInvite.execute()</code> takes a value and returns a <code>Single&lt;Boolean&gt;</code>. I need to compose the stream to feed every emission from first source to the second in a way that I can return all the emission from <code>fetchProductList()</code> with the <code>true</code> value as a list. I tried to compose it this way but it looks a bit clunky, Any better/simpler ways to do it?</p>

<pre><code>fetchProductList()
                    .map { dataSource -&gt; dataSource.data }
                    .flatMap{ data -&gt;
                        Observable.from(data.roles.map { role -&gt;
                            canInvite.execute(role.key).map { canInvite -&gt;
                                role to canInvite
                            }
                        })
                    }

                    .compose { it -&gt; Single.merge(it) }
                    .filter { it -&gt; it.second == true}
                    .map { it -&gt; it.first }
                    .toList()
                    .subscribe {
</code></pre>
","2231099","","","","","2019-08-27 10:36:20","Composing two observable sources using one as a predicate in RxJava","<android><rx-java><reactive-programming><rx-android><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"57672830","2","","57618052","2019-08-27 10:36:20","","2","","<p>From my point of view, this is a bit more clear solution:</p>

<pre><code>fetchProductList()
    .map { dataSource -&gt; dataSource.data }
    .flatMap { data -&gt;
        Observable.fromIterable(data.roles)
            .flatMapMaybe { role -&gt;
                canInvite.execute(role.key)
                    .flatMapMaybe { result -&gt;
                        if (result) Maybe.just(role) else Maybe.empty()
                    }
            }
    }
    .toList()
    .subscribe { result -&gt; println(result) }
</code></pre>
","1554633","","","","","2019-08-27 10:36:20","","","","0","","","","CC BY-SA 4.0"
"57874011","1","","","2019-09-10 15:31:57","","0","122","<p>In my project, I use RxJava/RxKotlin bindings to communicate with REST API. The API sometimes returns a list of elements, that need to be altered/mapped, before I can use them.</p>

<p>Currently, mapping of these elements is done by nested <code>.map()</code> and <code>.apply()</code> functions, like this:</p>

<pre><code>fun getSampleObjects(): Single&lt;List&lt;SampleObject&gt;&gt; =
    sampleService.getSampleObjects()
        .map { list -&gt;
            list.map { sampleObject -&gt;
                sampleObject.apply {
                    sampleProperty = otherSampleService.getSampleProperty()
                }
            }
        }
</code></pre>

<p>where <code>sampleService.getSampleObjects()</code> returns and RxKotlin <code>Single&lt;List&lt;SampleObject&gt;&gt;</code></p>

<p>I'm looking for an easier-to-read and more efficient way to archive the same result, possibly without the need to alter data models.</p>
","5930112","","","","","2019-09-10 20:02:51","Mapping elements of collection from RX Single/Observable","<generics><kotlin><collections><rx-java><rx-kotlin>","1","0","1","","","CC BY-SA 4.0"
"57889004","1","","","2019-09-11 12:19:02","","3","73","<p>I am making 2 RX calls that are nested within each other and are co-dependent. There is an issue with the server (which cannot be solved right now for various reasons) which returns errors in the 2nd nested call. </p>

<p>Until this gets solved, I need to have it that if the 2nd call returns an error, the results of the first call are discarded as well. Right now, the entire iterative process stops the moment any of these error responses occur, and so my goal is to skip over them. </p>

<p>Here is what my call structure currently looks like: </p>

<pre><code> fun getAllDynamicUtterances(module: String) {

    var uttList: ArrayList&lt;DynamicUtterance&gt;? = ArrayList()
    rxSubs?.add(
        repository.getDynamicUtterances(module).map{res -&gt;
            res.uttSets.forEach {utt -&gt;
                    utt.module = res.module!!
                    utt.transferInputValues()
                    utt.generateDefaultFlatTree()
                    uttList?.add(utt)
                    insertDynamicUtterance(utt)
                    repository.updateDynamicUtteranceView(utt).blockingForEach {
                        utt.assignSelectionStrings(it)
                        repository.storeDynamicUttPieces(utt.inputUttPieces)
                        utt.uttLinearisations = it.linearisations
                        updateDynamicUtterance(utt)
                    }
            }
        }.subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread()).subscribe ({
                allDynamicUtterances?.postValue(uttList)
            },{
                Log.e(""errorHandle"",it.toString())
            })
    )
}
</code></pre>

<p>My thinking is to include an if statement that almost does a ""peek"" of the second call before proceeding, but I'm not sure how to go about it. This is what I came up with so far to give an idea of my thinking: </p>

<pre><code>fun getAllDynamicUtterances(module: String) {

    var uttList: ArrayList&lt;DynamicUtterance&gt;? = ArrayList()
    rxSubs?.add(
        repository.getDynamicUtterances(module).map{res -&gt;
            res.uttSets.forEach {utt -&gt;
                    utt.module = res.module!!
                    utt.transferInputValues()
                    utt.generateDefaultFlatTree()
                if (doesNotReturnError(utt)){ // &lt;- add this
                    uttList?.add(utt)
                    insertDynamicUtterance(utt)
                    repository.updateDynamicUtteranceView(utt).blockingForEach {
                        utt.assignSelectionStrings(it)
                        repository.storeDynamicUttPieces(utt.inputUttPieces)
                        utt.uttLinearisations = it.linearisations
                        updateDynamicUtterance(utt)
                    }
                }
            }
        }.subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread()).subscribe ({
                allDynamicUtterances?.postValue(uttList)
            },{
                Log.e(""errorHandle"",it.toString())
            })
    )
}
</code></pre>

<p>and then adding this function, or a function that performs what it is im trying to achieve in any case.</p>

<pre><code>private fun doesNotReturnError(utt: DynamicUtterance): Boolean{
   rxSubs?.add(
       repository.updateDynamicUtteranceView(utt).subscribeOn(Schedulers.io())
           .observeOn(AndroidSchedulers.mainThread())
           .subscribe({
             //cant put a return here :(
           }, {
               Timber.e(it)
           })
   )
    //returning over here will return nothing wont it? 
}
</code></pre>

<p>I welcome comments on how to improve my <em>getAllDynamicUtterances</em> function</p>
","860233","","13860","","2019-09-11 13:51:29","2019-09-13 15:43:34","How can I use the response result of an RXJava call as a condition for an if statement inside another RXJava function?","<android><kotlin><rx-java><okhttp><rx-kotlin>","1","1","","","","CC BY-SA 4.0"
"57928983","2","","57063614","2019-09-13 18:55:30","","1","","<p>You have to specifically tell the compiler what classes you are working with.</p>

<pre><code>        val o1 = Observable.just(1)
        val o2 = Observable.just(2)

        o1.withLatestFrom(o2, BiFunction { t1 : Int, t2 : Int -&gt;  t1 to t2})
            .subscribe { (one, two) -&gt; }
</code></pre>

<p>Alternatively, RxKotlin extension function library handles this for you. 
<a href=""https://github.com/ReactiveX/RxKotlin"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxKotlin</a></p>
","384306","","","","","2019-09-13 18:55:30","","","","0","","","","CC BY-SA 4.0"
"58108921","1","58333082","","2019-09-26 02:49:50","","1","38","<p>Basically my Android app have some meta data which need to report to backend server in different scenarios:</p>

<pre><code>data class SearchMetaData(
    val searchId: String?,
    val isRateLimit: Boolean
)
</code></pre>

<p>In order to make the code clean, I make the minimal case as follows. All the report logic are similar, each of the function <code>subscribe</code> the metadata provider and get the value that need to report.</p>

<pre><code>fun logEvent1() {
    fetchMetaData().observeOn(schedulers.mainThread()).subscribe({ metadata -&gt;
        ...//lots of other events data here
        val sessionMetadata = SessionMetadata()
        sessionMetadata.id = metadata.searchId
        sessionMetadata.limiit = metadata.isRateLimit
        event1.session = sessionMetadata
        ...
        report(event1)
    })
}

fun logEvent2() {
    fetchMetaData().observeOn(schedulers.mainThread()).subscribe({ metadata -&gt;
        ...//lots of other events data here
        val sessionMetadata = SessionMetadata()
        sessionMetadata.id = metadata.searchId
        sessionMetadata.limiit = metadata.isRateLimit
        event2.session = sessionMetadata
        ...
        report(event2)
    })
}

fun logEvent3() {
    fetchMetaData().observeOn(schedulers.mainThread()).subscribe({ metadata -&gt;
        ...//lots of other events data here
        val sessionMetadata = SessionMetadata()
        sessionMetadata.id = metadata.searchId
        sessionMetadata.limiit = metadata.isRateLimit
        event3.session = sessionMetadata
        ...
        report(event3)
    })
}
</code></pre>

<p>My concern is every time we change the schema of metadata, we need to update all the <code>logEventX</code> , I was wondering if maybe we could extract all the <code>subscribe</code> in different functions and get the metadata?</p>
","1319619","","13302","","2019-09-29 21:07:34","2019-10-11 01:28:00","RxJava: How to extract same observeOn from different functions?","<android><rx-java><reactive-programming><rx-kotlin>","1","4","","","","CC BY-SA 4.0"
"58333082","2","","58108921","2019-10-11 01:28:00","","1","","<p>Consider an extension function using compose and doOnSuccess</p>

<pre><code>Single&lt;MetaData&gt;.handleLogging() : Single&lt;MetaData&gt;{
  return compose{
     it.doOnSuccess{ metaData -&gt;
         val sessionMetadata = SessionMetadata()
         sessionMetadata.id = metadata.searchId
         sessionMetadata.limiit = metadata.isRateLimit
         report(sessionMetaData)
     }
  }
}

//usage
fetchMetaData().handleLogging().subscribe{
  //other uncommon logic here.
}
</code></pre>
","384306","","","","","2019-10-11 01:28:00","","","","0","","","","CC BY-SA 4.0"
"58492711","1","","","2019-10-21 19:07:28","","0","112","<p>A, B, C are objects</p>

<p>All function calls are made to a Rooms DB</p>

<p>This code snippet is inside a ViewModel</p>

<p>repo = Repository</p>

<p>So I'm making an android app (can't provide details) and for a particular screen I need to do the following.</p>

<p>My first call is repo.getInfo, which returns a Single Observable ListOfA: <code>Single&lt;List&lt;A&gt;&gt;</code> //perform some operations</p>

<p>for every element of ListOfA I need to call another function repo.getB(A) which returns a Single Observable ListOfB: <code>Single&lt;List&lt;B&gt;&gt;</code>  //perform some operations</p>

<p>for every element of ListOfB I need to call another function repo.getC(B) which returns a Single Observable ListOfC: <code>Single&lt;List&lt;C&gt;&gt;</code>  //perform some operations</p>

<p>after I have the required data I need to call another function that combines the data to display on the UI.</p>

<p>Now I can't get this to work. Here's what I've tried. But the flow stops at the line marked THIS LINE and jumps to subscribe block.
Individual calls to the functions work so the data is not the problem.
I'm pretty new at this and quite frankly out of my depth. Any help or hint is appreciated. Thanks</p>

<pre><code>localListOfA = emptyList&lt;A&gt;()
localListOfB = emptyList&lt;B&gt;()
localListOfC = emptyList&lt;C&gt;()
compositeDisposable.add(
    getInfo.map{listOfA -&gt;
        localListOfA.addAll(listofA)
        listOfA.map {elementA -&gt;   ////THIS LINE
            getB(elementA.id).map{listOfB -&gt;
                listOfB.filter {
                    //some logic to select a few objects
                }
            }.map { it // filtered list of B
                localListofB.addAll(it)
                localListOfB.last() //I only need the top element of this list
            }.map{elementB -&gt;
                getC(elementB.id).map{ listOfC -&gt;
                    localListOfC.addAll(listOfC)
                    //do some operations
                }
            }
        }
    }
    .subscribeOn(DEFAULT_CACHED_SCHEDULERS)
    .observeOn(AndroidSchedulers.mainThread())
    .doOnError(/*take log*/)
    .subscribe{
        prepareUi()
    }
)
</code></pre>
","12253227","","","","","2019-10-21 20:42:00","Fetching a Single<List> for all elements of another Single<List> in RxKotlin","<android><rx-java><reactive-programming><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"58788392","1","","","2019-11-10 11:55:26","","1","46","<p>How to get value <code>time</code> from this code </p>

<pre><code>val TAG = MainActivity::class.java.name
TrueTimeRx.build()

    .initializeRx(""time.google.com"")

    .subscribeOn(Schedulers.io())

    .subscribe({ time -&gt;
        Log.v(TAG, ""TrueTime was initialized and we have a time: $time"") },
        { throwable -&gt; throwable.printStackTrace() }

    )
</code></pre>

<p>and put it in this code</p>

<pre><code>helloWorld=findViewById(R.id.helloWorld)

val newTime=getString(R.string.hello, time)
helloWorld.text=newTime
</code></pre>

<p>how to take <code>time</code> from the first part of the code and to put it in the second</p>

<p>code above is in <code>onCreate()</code></p>

<p>and if it's important i have this </p>

<pre><code>internal lateinit var helloWorld: TextView
</code></pre>
","12343312","","9968399","","2019-11-10 12:32:54","2019-11-10 12:55:14","How to pass value","<android><kotlin><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"58795905","1","58796309","","2019-11-11 05:21:00","","1","337","<p>I've created rx function to call a network call from <code>view-model</code> in android, it parses network on main thread function. </p>

<p>I just change few line of code it worked. but i need to know the reason for this because its use same builder pattern to create a <code>rx-call</code>.
once I tried with changing <code>.doOnSubscribe()</code> ,<code>doOnComplete ()</code>           , <code>.applySchedulers()</code> after the flatmap call it worked? how is  this happened?</p>

<pre><code>fun loadjobs(var countryID:String){
subscription.add(
repository.getMainJobsFromLocal(countryID)
          .doOnSubscribe { postProgress(StatusModel(Status.IN_PROGRESS))}
          .doOnComplete { postProgress(StatusModel(Status.COMPLETED)) }
          .applySchedulers()
          .flatMap {
           if (it.isNullOrEmpty()) {
              repository.getMainJobsFromServer(countryID)
           } else {
              Flowable.just(Response.success(it))
           }
          }
          .subscribe({
            if (it.isResponseOk()) {
             postProgress(StatusModel(Status.SUCCESS))
             mainJobResponse.postValue(it.body())
           } else {
             postProgress(StatusModel(Status.FAILED))
             mainJobResponse.postValue(null)
           }
          }, {
           postProgress(StatusModel(Status.FAILED))
           mainJobResponse.postValue(null)
        }))
}


fun loadjobs(var countryID){
subscription.add(
repository.getMainJobsFromLocal(countryID)
          .flatMap {
           if (it.isNullOrEmpty()) {
             repository.getMainJobsFromServer(countryID).flatMap {
               Flowable.just(it)
             }
           } else {
             Flowable.just(Response.success(it))
           }
          }.doOnSubscribe { postProgress(StatusModel(Status.IN_PROGRESS)) }
            .doOnComplete { postProgress(StatusModel(Status.COMPLETED)) }
            .applySchedulers()
            .subscribe({
              if (it.isResponseOk()) {
                postProgress(StatusModel(Status.SUCCESS))
                mainJobResponse.postValue(it.body())
               } else {
               postProgress(StatusModel(Status.FAILED))
               mainJobResponse.postValue(null)
              }
           }, {
            postProgress(StatusModel(Status.FAILED))
            mainJobResponse.postValue(null)
    }))
}
</code></pre>
","8415366","","2185295","","2019-11-11 06:27:43","2019-11-11 06:27:43","Retrofit - android.os.NetworkOnMainThreadException with RxKotlin","<android><android-viewmodel><flatmap><rx-kotlin>","2","2","","","","CC BY-SA 4.0"
"58796309","2","","58795905","2019-11-11 06:08:58","","1","","<blockquote>
  <p>applySchedulers() after the flatmap call it worked? how is this happened?</p>
</blockquote>

<p><code>observeOn()</code> affects everything downstream. If you have a <code>flatMap()</code> after <code>observeOn()</code>, it gets executed on that scheduler.</p>

<p>Similarly <code>subscribeOn()</code> affects the upstream chain.</p>

<p>For these reasons, for most use cases you'd want to have the schedulers applied at the end of your rx chain and not in the middle.</p>
","101361","","","","","2019-11-11 06:08:58","","","","0","","","","CC BY-SA 4.0"
"59104815","1","59104982","","2019-11-29 12:27:22","","1","61","<p>I have this function which gets a parameter and first checks for its value. if it was null then gets its value from the result of fisrtFun() which returns a Single&lt; String>.</p>

<p>after that either that parameter was null or not, it returns the result of secondFun() which gets that parameter as input</p>

<pre><code>fun getUserEvents(id: String?): Single&lt;String&gt; {
    return if (userId == null) {
        firstFun().flatMap { id-&gt;
            secondFun(id)
        }
    } else {
        secondFun(id)
    }
}
</code></pre>

<p>But as you see I used if-else blocks and have written secondFun() multiple times</p>

<p>so I tried to make it cleaner </p>

<pre><code>fun getUserEvents(id: String?): Single&lt;String&gt; {
    val id = userId ?: fisrtFun().blockingGet()!!
    return secondFun(id)
}
</code></pre>

<p>I want to know if there is a better way to achieve this functionality without using blockingGet() to avoid blocking the thread </p>
","8838667","","","","","2019-11-29 12:38:33","How to make this block of code written with RxKotlin cleaner and avoid blocking thread?","<android><kotlin><reactive-programming><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"59104982","2","","59104815","2019-11-29 12:38:33","","2","","<p>Something like this should work:</p>

<pre><code>fun getUserEvents(id: String?): Single&lt;String&gt; {
    val idSingle = if (userId == null) firstFun() else Single.just(id)
    return idSingle.flatMap { id -&gt;
        secondFun(id)
    }
}
</code></pre>
","1644053","","","","","2019-11-29 12:38:33","","","","1","","","","CC BY-SA 4.0"
"59352476","1","","","2019-12-16 07:56:18","","0","63","<p>I have PublishSubject for observing status change and also I have method with multiple steps, which I execute in another thread. How I can force stop this thread when subject received changes?</p>
","7185703","","","","","2019-12-16 08:24:12","How to force stop thread","<android><multithreading><kotlin><rx-java><rx-kotlin>","1","1","","","","CC BY-SA 4.0"
"59523262","1","59525955","","2019-12-29 21:02:42","","1","265","<p>TL;DR Looking for recommendations on robust offline support using rx-kotlin. </p>

<p>I've followed a nice <a href=""https://medium.com/@eslam.hussein/dominate-remote-local-data-with-rx-retrofit-room-mvp-f2b13a0ac27b"" rel=""nofollow noreferrer"">guide on offline-support in Android apps</a>. 
It works like this: </p>

<ol>
<li>Load data from the Internet, go to step 3 if error</li>
<li>Store the data in the local database</li>
<li>Load the data from the local database</li>
<li>Display the data in the UI</li>
</ol>

<p>The code is:</p>

<pre><code> Observable.mergeDelayError(
                loadRemoteData()
                    .doOnNext { writeDataToLocalDatabase(it) }
                    .subscribeOn(Schedulers.io()), 
                loadDataFromLocalDatabase()
                    .subscribeOn(Schedulers.io())
            )
</code></pre>

<p>Unfortunately, this approach relies on the database code always working. If the database operations for some reason fail, everything fails, even when the data is loaded successfully from the remote server.</p>

<p>Is there a way I can achieve the following using rx-kotlin/rx-java?:</p>

<ol>
<li>Load data from the Internet, go to step 3 if error</li>
<li>Store the data in the local database</li>
<li>Load the data from the local database</li>
<li><strong>(if steps 2 or 3 failed) Use the data from step 1</strong></li>
<li>Display the data in the UI</li>
</ol>

<p>I'd like to avoid loading the data from the Internet twice. I'm using room + retrofit, if that matters.</p>

<p>EDIT:
Thanks to @MinseongPark, I ended up with the code below. 
The mergeDelayError reports an error only if both the remote and the local source fails, and if the <em>writeDataToLocalDatabase</em> method fails (throws an Exception), then that does not keep the remote data from being reported to the UI. The information about errors in <em>writeDataToLocalDatabase</em> is saved by reporting it  remotely. 
Now, the code is robust to one of the two sources failing, and to writing new entries to the database failing. </p>

<pre><code>        return Observable.mergeDelayError(
            loadRemoteData().doOnNext {
                try {
                    writeDataToLocalDatabase(it)
                } catch (error: Throwable) {
                    Timber.d(error)
                    Crashlytics.logException(error)
                }
            },
            loadDataFromLocalDatabase()
        )
            .subscribeOn(Schedulers.io())
</code></pre>
","788913","","788913","","2019-12-31 16:28:21","2019-12-31 16:28:21","How to implement robust offline support with rx-kotlin?","<android><rx-java><rx-kotlin>","1","3","","","","CC BY-SA 4.0"
"59525955","2","","59523262","2019-12-30 05:07:09","","0","","<p>Try this.</p>

<pre class=""lang-java prettyprint-override""><code>    Observable.mergeDelayError(
        loadRemoteData()
            .doOnNext { runCatching { writeDataToLocalDatabase(it) } }
            .subscribeOn(Schedulers.io()),
        loadDataFromLocalDatabase()
            .onErrorResumeNext(Observable.empty())
            .subscribeOn(Schedulers.io())

    )
</code></pre>
","8614522","","","","","2019-12-30 05:07:09","","","","3","","","","CC BY-SA 4.0"
"59536511","1","","","2019-12-30 20:28:20","","1","33","<p>I wanna fetch data from roomDB when variable changed. When folderName changed and when task changed.
I use <code>MediatorLiveData</code>, but it doesn't work.
How can I fix it?</p>

<p>This is a view model class.</p>

<pre><code> val folderName = ViewModelFolder.selectedFolder // MutableLiveData&lt;String&gt;
 val filteredTasks = MediatorLiveData&lt;LiveData&lt;List&lt;Task&gt;&gt;&gt;()
 init {
   filteredTasks.addSource(folderName) { name -&gt;
     filteredTasks.value = getTasksByFolderIsDone(name, false)
   }
}
</code></pre>

<p>Main activity</p>

<pre><code>taskViewModel.filteredTasks.observe(viewLifecycleOwner, Observer { tasks -&gt;
  tasks?.let { taskAdapter.setTasks(tasks as List&lt;Task&gt;) }
})
</code></pre>
","7359831","","","","","2019-12-30 20:28:20","Android: want to fetch data from roomDB when 2 variables changed","<android><kotlin><android-room><rx-kotlin>","0","2","","","","CC BY-SA 4.0"
"59708108","1","59708986","","2020-01-12 21:03:49","","2","1218","<p>I have a problem and I don't know how to resolve it with a better aproach. The problem is that I'm requesting to Spotify Web API and in some methods the artist image is returned and in others only basic artist info is obtained.</p>

<p>I have this two methods:</p>

<pre><code>fun getAlbum(albumId: String): Single&lt;SpotifyAlbumDTO&gt;

fun getArtist(artistId: String): Single&lt;SpotifyArtistDTO&gt;
</code></pre>

<p>When I get an album, the artist info doesn't contains the artist image url. So, I need to call the getAlbum() method and use the result to obtain the artistId and then call to getArtist() method. </p>

<p>I have the following method to do all this stuff:</p>

<pre><code>fun getAlbum(albumId: String): Single&lt;Album&gt;
</code></pre>

<p>On this method I need to call the previous two to return an Album object (my domain object). The only solution that worked for me it's the following:</p>

<pre><code>fun getAlbum(albumId: String): Single&lt;Album&gt; {
  return Single.create { emitter -&gt;
    _spotifyService.getAlbum(albumId).subscribe { spotifyAlbum -&gt;
      _spotifyService.getArtist(spotifyAlbum.artist.id).subscribe { spotifyArtist -&gt;
        val artistImage = spotifyArtist.imageUrl
        spotifyAlbum.artist.image = artistImage
        emitter.onNext(spotifyAlbum.toAlbum())
      }
    }
  }
}
</code></pre>

<p>I think that must exist another better way to do this than concating subscribe calls in other subscribes and creating deeper calls. I also try the following:</p>

<pre><code>_spotifyService.getAlbum(albumId).flatMap { spotifyAlbum -&gt;
  _spotifyService.getArtist(spotifyAlbum.artist.id)
}.flatMap { spotifyArtist -&gt;
  // Here I don't have the album and I can't to asign the image         
}
</code></pre>
","3828964","","","","","2020-01-13 10:33:15","RXJava/Kotlin - Chaining Single results in one","<rx-java><system.reactive><rx-kotlin>","2","0","1","","","CC BY-SA 4.0"
"59708986","2","","59708108","2020-01-12 23:26:04","","2","","<h3>PARALLEL SOLUTION</h3>

<p>To combine several source of data the best operator is <a href=""http://reactivex.io/documentation/operators/zip.html"" rel=""nofollow noreferrer"">zip</a>:</p>

<p><a href=""https://i.stack.imgur.com/8zWdH.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8zWdH.png"" alt=""Rx Zip operator""></a></p>

<pre><code>Single.zip(getAlbum(albumId), getArtist(artistId),
    BiFunction&lt;SpotifyAlbumDTO, SpotifyArtistDTO, SpotifyAlbumDTO&gt; { album, artist -&gt; 
        val artistImage = artist.imageUrl
        album.artist.image = artistImage
        album //return value of the merged observable 
    }
).subscribe { album: SpotifyAlbumDTO?, error: Throwable? -&gt;
    emitter.onNext(album.toAlbum())
}
</code></pre>

<p>It will run all the observables in parallel, and execute the merging function once every observable has finished.</p>

<p>If you have more observable to zip, you can use Function3, Function4,...</p>

<h3>SEQUENTIAL SOLUTION (EDIT)</h3>

<p>If parallel execution is not possible because you need the request to be executed sequentially then, you can you the <a href=""http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap-rx.functions.Func1-rx.functions.Func2-"" rel=""nofollow noreferrer"">resultSelector</a> of the flatmap function. It takes the item before the flatMap and the grouped collection after the flatmap. This way you will easily be able to create your model group, without any confusing usage of <code>Pair</code></p>

<p><a href=""https://i.stack.imgur.com/OJsc6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/OJsc6.png"" alt=""Flatmap with resultSelector""></a></p>

<p>The only catch is: <code>Single</code> does not support this kind of flatmap.
You can workaround the issue either changing your return type from <code>Single</code> to <code>Observable</code> or just convert your <code>Single</code> at runtime with the <code>toObservable</code> operator.</p>

<pre><code>getAlbum(albumId)
    .toObservable()
    .flatMap({album: SpotifyAlbumDTO -&gt; getArtist(album.artist.id).toObservable()},
             { album:SpotifyAlbumDTO, artist:SpotifyArtistDTO -&gt;
                 album.artist.image = artist.imageUrl
                 album
             })
    }?.subscribe { album: SpotifyAlbumDTO -&gt;
        print(album)
    }
</code></pre>
","795245","","795245","","2020-01-13 10:33:15","2020-01-13 10:33:15","","","","3","","","","CC BY-SA 4.0"
"59775506","1","","","2020-01-16 18:09:01","","2","559","<p>So I have the following test that keeps failing with the following error: </p>

<blockquote>
  <p>java.lang.AssertionError: No values (latch = 1, values = 0, errors = 0, completions = 0) </p>
</blockquote>

<pre><code>val ocrProcessor = mockk&lt;FirebaseFormProcessor&gt;()
        val date = listOf(DateTextExtraction())

        every { ocrProcessor.scan(any(), any(), any()) } answers {
            thirdArg&lt;OcrResultCallback&gt;().invoke(date)
        }

        viewModel = FormViewModel(ocrProcessor)

        viewModel.addImage(bitmap)

        viewModel.ocrAlert
            .test()
            .assertValue {
                it == date
            }
            .addTo(disposeBag)
</code></pre>

<p>What this tries to test is the following:</p>

<pre><code>override val ocrAlert: PublishSubject&lt;List&lt;TextExtractionInterface&gt;&gt; = PublishSubject.create()

override fun addImage(bitmap: Bitmap) {
    if (files.value.isEmpty())
        ocrProcessor.scan(bitmap, extract = textExtractionItems) { ocrResult -&gt;
            ocrAlert.onNext(ocrResult)
        }
}
</code></pre>

<p>I am not quite sure what I am doing wrong here but I think it might have to do with threading problems.</p>

<p>edit:</p>

<p>I changed the code to this now:</p>

<pre><code>        val toBeTested = viewModel.ocrAlert
            .subscribeOn(scheduler)
            .observeOn(scheduler)
            .test()

        viewModel.addImage(bitmap)

         toBeTested   
            .assertValue {
                it == date
            }
            .addTo(disposeBag)
</code></pre>
","1453253","","1453253","","2020-01-20 11:09:31","2020-01-20 11:09:31","UnitTesting async code rxjava/rxkotlin fails with latch = 1 error","<android><rx-java2><rx-kotlin>","0","16","1","","","CC BY-SA 4.0"
"59874945","1","59878149","","2020-01-23 09:14:08","","0","100","<p>I want to print at a time of ArrayList.</p>

<p>Before:</p>

<pre><code>class ExampleUnitTest {
    @Test
    fun test(){
        val stringArray = arrayOf(""10"", ""20"", ""30"", ""40"", ""30"", ""20"", ""10"", ""5"", ""20"", ""30"", ""20"", ""30"").map { it }
        println(stringArray.toString())
    }
}

# output is :
[10, 20, 30, 40, 30, 20, 10, 5, 20, 30, 20, 30]
</code></pre>

<p>After:</p>

<pre><code># I Want to output Like this :
10, 20, 30, 40, 30, 20, 10, 5, 20, 30, 20, 30
</code></pre>

<p>How can I do this coding by Reactivex Java(RxJava)</p>

<pre><code># something like... e.g..
Observable ...{
   ... ...
}.subscribeOn(Schedulers.io())
.subscribe({
   ... ...
})
</code></pre>
","12029427","","","","","2020-10-10 02:07:10","Kotlin: How to Output at a time the ArrayList from Rxjava","<java><android><kotlin><rx-java><rx-kotlin>","2","1","","","","CC BY-SA 4.0"
"59878149","2","","59874945","2020-01-23 12:04:04","","0","","<p>i got finished the problem by my self!</p>

<pre><code>val sample = listOf(""a"",""b"",""c"",""d"",""e"",""f"",""g"")
        Observable.fromIterable(sample.withIndex())
            .subscribeOn(Schedulers.io())
            .subscribe({ (index, item) -&gt;
                print(if(sample.size &gt; index) item else ""$item, "")
                println()
            },
            { e -&gt; e.printStackTrace() },
            { println(""finished!"") }
        )
</code></pre>
","12029427","","","","","2020-01-23 12:04:04","","","","0","","","","CC BY-SA 4.0"
"60065075","1","60095956","","2020-02-04 20:28:02","","1","65","<p>Good afternoon.
So I got a list with a list inside like this:</p>

<pre><code>    {
  ""category"" : [
    {
      ""name"": ""Bathroom"",
      ""products"": [
        {
          ""name"": ""Sink01""
        },
        {
          ""name"": ""Shower01""
        }
      ]
    },{
      ""name"": ""Kitchen"",
      ""products"": [
        {
          ""name"": ""Table""
        },
        {
          ""name"": ""Stove""
        }
      ]
    }
  ]
}
</code></pre>

<p>So if the user for example selects the category ""Bathroom"" I want to use rxjava to filter the list of products from the category ""Bathroom"" and if they select the category ""Kitchen"" I want to get the list of products from the category ""Kitchen"".</p>

<p>This is what I've tried so far:</p>

<pre><code>    fun getProducts(category: Category): Single&lt;MutableList&lt;Product&gt;&gt; {
         return service.getProductsByCategories().filter{ response -&gt;
             response.categoriesList.forEach {
                if (it.name == category.name) {
                  category.products
                }
             }
         }
    }
</code></pre>

<p>Right now I am getting ""Typed mismatch. Requieres: <code>Single&lt;MutableList&lt;Product&gt;&gt;</code>, Found: <code>Maybe&lt;MyResponse!&gt;!</code>""</p>

<p>Why is this happening?
What is the correct way to filter?</p>

<p>Thanks in advance.</p>

<p>Greetings</p>
","1344550","","61158","","2020-02-06 14:29:44","2020-02-06 14:29:44","How to do the filter operator from a list of a list in rxjava","<kotlin><rx-java><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"60088358","1","","","2020-02-06 05:41:04","","0","96","<p>I want to emit events after non periodic intervals and I want to set the interval for emission of each event programatically using Rxjava in Android. How do I do that?</p>
","12759574","","208273","","2020-03-12 03:53:25","2020-03-12 03:53:25","Emit events after non periodic intervals using rx java","<java><android><rx-java><rx-android><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"60095956","2","","60065075","2020-02-06 13:20:58","","1","","<p>You can unroll the <code>getProductsByCategories</code> response, filter for the right category, map in the product list, then convert it to the desired output type:</p>

<pre><code>getProductsByCategories()
.flattenAsObservable { it }
.filter { it.name == category.name }
.map { it.products }
.single( ArrayList&lt;Product&gt;() )
</code></pre>
","61158","","61158","","2020-02-06 14:25:21","2020-02-06 14:25:21","","","","4","","","","CC BY-SA 4.0"
"60162061","1","60162271","","2020-02-11 04:31:21","","3","1251","<p>I am calling one api which gives Http status code 400 </p>

<p>This is my NetworkBoundResourceNoDb</p>

<pre><code>public abstract class NetworkBoundResourceNoDb&lt;RequestType&gt; {

    private Observable&lt;Resource&lt;RequestType&gt;&gt; result;

    @MainThread
    protected NetworkBoundResourceNoDb() {
        Observable&lt;Resource&lt;RequestType&gt;&gt; source;
        source = createCall()
            .subscribeOn(Schedulers.io())
            .doOnError(t -&gt; onFetchFailed())
            .observeOn(AndroidSchedulers.mainThread());

        result = Observable.ambArray(source);
    }


    public Observable&lt;Resource&lt;RequestType&gt;&gt; getAsObservable() {return result;}

    protected boolean onFetchFailed() {
        return false;
    }


    @NonNull
    @MainThread
    protected abstract Observable&lt;Resource&lt;RequestType&gt;&gt; createCall();
}
</code></pre>

<p>This is API code </p>

<pre><code>@GET(""api/content/count"")
Observable&lt;List&lt;WordCountData&gt;&gt; wordCount();
</code></pre>

<p>This is repository Function</p>

<pre><code>    fun wordCount(): Observable&lt;Resource&lt;List&lt;WordCountData&gt;&gt;&gt;? {
    return object : NetworkBoundResourceNoDb&lt;List&lt;WordCountData&gt;&gt;() {

        override fun createCall(): Observable&lt;Resource&lt;List&lt;WordCountData&gt;&gt;&gt; {
            return courseApi.wordCount()
                .flatMap { learntWords -&gt;
                    Observable.just(
                        if (learntWords == null) Resource.error("""", emptyList())
                        else Resource.success(learntWords)
                    )
                }
        }

    }.asObservable
}
</code></pre>

<p>This is viewmodel Code</p>

<pre><code>private var wordCount = MutableLiveData&lt;Resource&lt;List&lt;WordCountData&gt;&gt;&gt;()

fun getWordCountLiveData() = wordCount

fun getWordCountList() {
    courseRepository.wordCount()?.subscribe { resource -&gt; getWordCountLiveData().postValue(resource) }
}
</code></pre>

<p>This is my view code</p>

<pre><code>private fun loadWordCount() {
    crViewModel = ViewModelProviders.of(this, viewModelFactory).get(CrViewModel::class.java)
    crViewModel.getWordCountLiveData().observe(this, androidx.lifecycle.Observer {
        resource -&gt; when {
        resource.isLoading -&gt; println(""loading"")
        resource.data != null -&gt; {
            drawChart(resource.data)
        }
        else -&gt; handleErrorResponse()
    }
    })
    crViewModel.getWordCountList()
}
</code></pre>

<p>I need to pass Http Status code to view. i am able to get the error in onFetchfailed in repository while implementing it with throwable parameter but not able to handle it after that</p>

<p>it gives  me ""io.reactivex.exceptions.OnErrorNotImplementedException: HTTP 400 "" Error</p>

<p>please help me thanks in advance  </p>
","6846277","","","","","2020-02-11 04:58:46","Error Handling of Rxjava in mvvm using retrofit","<android><mvvm><retrofit><rx-java><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"60162271","2","","60162061","2020-02-11 04:58:46","","1","","<p>man, you're asking for many questions in 1.</p>

<pre><code>fun getWordCountList() {
courseRepository.wordCount()?.subscribe { resource -&gt; getWordCountLiveData().postValue(resource) }
}
</code></pre>

<p>This is the chunk of code that triggers all of your other network code.
However, this lambda only has a success param, not an error param. Add a second lambda, and surround it by paranthesis, in order to account for both success and failure:</p>

<pre><code>.subscribe({
    successResponse -&gt; // handle success
}, 
{ error -&gt; // handle error
})
</code></pre>

<p>so, that should take care of at least the ""OnErrorNotImplementedException""</p>

<p>Error 400 usually means that your request is invalid, and/or you're passing the wrong set of parameters to your request. I can't help you there with the amount of info you gave us, and without knowing anything about your server.</p>

<p>Finally: ""I need to pass Http Status code to view"". What?? why? 
Your title even mentions architecture! Why does your view layer even care about the response code from a network call??</p>

<p>Don't do that. Sure, your view ""can"" know about the response code, but this is something the view layer should not know about at all.</p>

<p>I hope this helps.</p>
","1564652","","","","","2020-02-11 04:58:46","","","","2","","","","CC BY-SA 4.0"
"60256254","1","","","2020-02-17 05:10:11","","0","125","<p>I am getting:</p>

<blockquote>
  <p>io.reactivex.exceptions.OnErrorNotImplementedException: The exception
  was not handled due to missing onError handler in the subscribe()
  method call</p>
</blockquote>

<p>I had tried to add</p>

<pre><code>.doOnError { error -&gt;
            Log.i(""reverser code error"",error.localizedMessage)
       }.onErrorReturn { err -&gt;
          ""Return method""
     }
</code></pre>

<p>But it's not working.</p>
","8946399","","9141664","","2020-02-17 05:15:47","2020-02-17 05:37:59","How to handle errors on RxKotlin + Graphql","<android><kotlin><graphql><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"60367289","1","60367442","","2020-02-23 22:01:04","","0","130","<p>I'm trying to implement redux state update pattern using RXJava</p>

<pre><code>val subject=PublishSubject.create()
val subject1=PublishSubject.create()

// multiple threads posting 
// on subject and subject1 here. Concurrently 


subject.mergeWith(subject1)
       .scan(
             getInitState(),
             {state, event -&gt;
               // state update here 
             }
         )
        .subscribe({state -&gt;
          // use state here
        })
</code></pre>

<p>As you can see, I'm using <code>scan</code> operator to maintain the state. </p>

<p>How can I be sure that the state updates happen sequentially even when multiple threads are producing events? </p>

<p>Is there some mechanism in <code>scan</code> operator which makes the events stand in some queue while waiting for current state update function to finish?</p>

<p><strong>What I have done:</strong></p>

<p>I have successfully implemented this pattern in Android environment. It's really easy because if you always do the state update in </p>

<p><code>AndroidSchedulers.mainThread()</code> </p>

<p>And make state object immutable you are guaranteed to have atomic and sequential state update. But what happens if you don't have dedicated scheduler for state updates? What if you are not on Android?</p>

<p><strong>What I have researched:</strong></p>

<ul>
<li><p>I have read the source code for <code>scan</code> operator and there is no
waiting ""queue"" involved. Just simple state update and emission</p></li>
<li><p>I have also read SerializedSubject source code. There indeed is a waiting queue which serializes emissions. But what happens if I have two subjects? Serializing both of them doesn't mean that they don't interfere with each other.</p></li>
</ul>
","3904645","","","","","2020-02-23 22:32:47","Ensure sequential state update when using RXJava scan operator","<android><redux><rx-java2><rx-android><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"60367442","2","","60367289","2020-02-23 22:22:37","","2","","<p>To force execution on a single thread, you can explicitly create a single thread scheduler to replace <code>AndroidSchedulers.mainThread()</code>:  </p>

<pre><code>val singleThreadScheduler = Schedulers.single()
</code></pre>

<p>Even if the events are emitted on other threads, you can ensure you process them only on your single thread using <code>observeOn</code>:</p>

<pre><code>subject.mergeWith(subject1)
   .observeOn(singleThreadScheduler)
   .scan(
         getInitState(),
         {state, event -&gt;
           // state update here 
         }
     )
    .subscribe({state -&gt;
      // use state here
    })  
</code></pre>

<p>The difference between <code>observeOn</code> and <code>subscribeOn</code> can be pretty confusing, and logging the thread id can be useful to check everything is running on the thread you expect.</p>

<blockquote>
  <p><a href=""http://reactivex.io/documentation/scheduler.html"" rel=""nofollow noreferrer"">http://reactivex.io/documentation/scheduler.html</a></p>
</blockquote>
","6816469","","6816469","","2020-02-23 22:32:47","2020-02-23 22:32:47","","","","2","","","","CC BY-SA 4.0"
"60652490","1","","","2020-03-12 10:47:27","","0","135","<p>I have a function in repository that calls three APIs which return three different type of Objects. </p>

<pre><code>fun scanSource(code: String) =
    firstApi.DataV11Get(code)
        .flatMap {
            firstApi.sccGet(it.sscc)
        }
        .flatMap {
            lastApi.lsccGet(it.id)
        }
</code></pre>

<p>currently it is only returning the result of last API in the ViewModel .Now I want to have result of all of these in viewmodel.</p>

<p>plus the api must be sequential as they are using the data from the last API.</p>

<p>Also each API returns a different Object type.And I want all of three objects once all three calls are finished.</p>

<p>Thanks</p>
","2877863","","","","","2020-03-12 10:59:50","Combine three APIs' result in RxKotlin","<android><kotlin><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"60653309","1","60655058","","2020-03-12 11:34:31","","0","408","<p>I am trying to parse the data from the server to my mobile device and I am using <code>Rx</code> , <code>Kotlin</code> , <code>retrofit</code> for this </p>

<p><strong>ApiInterface.kt</strong></p>

<pre><code>@GET(""api/v1/admin/class/getUsers/learner/{classId}"")
    fun getStudentsRx(
        @Header(""access_token"") accessToken: String,
        @Path(""classId"") apiKey: String
    ): Observable&lt;StudentResultResponse&gt;
</code></pre>

<p><strong>I am trying to subscribe as follows:</strong></p>

<pre><code> private fun getServerDataDisposable(dataService: ApiInterface): Disposable {
        return dataService.getStudentsRx(accessToken,classId)
            .subscribeOn(Schedulers.newThread())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribeWith(object: DisposableSingleObserver&lt;List&lt;StudentModel&gt;&gt;(), Observer&lt;StudentResultResponse&gt; {

                override fun onSuccess(movies: List&lt;StudentModel&gt;) {
                }

                override fun onError(e: Throwable) {

                }

                override fun onChanged(t: StudentResultResponse?) {
                    TODO(""not implemented"") //To change body of created functions use File | Settings | File Templates.
                }

            })
    }
</code></pre>

<p><strong>I am getting error:</strong></p>

<p><a href=""https://i.stack.imgur.com/AaAyf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/AaAyf.png"" alt=""enter image description here""></a></p>
","1083093","","","","","2020-03-12 13:23:28","Using Observable in Kotlin to parse a API response","<android><kotlin><rx-java><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"60655058","2","","60653309","2020-03-12 13:23:28","","0","","<p>check below answer...</p>

<pre><code>private fun getServerDataDisposable(dataService: ApiInterface): Disposable {
    return dataService.getStudentsRx(accessToken,classId)
            .subscribeOn(Schedulers.newThread())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribeWith(object: DisposableSingleObserver&lt;StudentResultResponse&gt;(), Observer&lt;StudentResultResponse&gt; {

                override fun onSuccess(t: StudentResultResponse) {
                    TODO(""Not yet implemented"")
                }

                override fun onError(e: Throwable) {
                    TODO(""Not yet implemented"")
                }

                override fun onComplete() {
                    TODO(""Not yet implemented"")
                }

                override fun onNext(t: StudentResultResponse) {
                    TODO(""Not yet implemented"")
                }

            })
}
</code></pre>
","7229971","","","","","2020-03-12 13:23:28","","","","0","","","","CC BY-SA 4.0"
"60796695","1","","","2020-03-22 06:54:06","","0","106","<p>I am new to Rx and I am making one API call using Rx. It is working but the problem is that it is continuously making the API after I received response or error. I am using the MVVM pattern. </p>

<p>Here is my code how I am observing result in View Model:</p>

<pre><code>val usersList = getGitHubUsersUseCase.getUsers(since.toInt())

        usersList?.subscribeOn(Schedulers.io())
            ?.observeOn(AndroidSchedulers.mainThread())
            ?.subscribe({
                if (it.error == null) {
                    var sinceState = SinceState(since, since.isNotEmpty(), it.users)
                    stateLiveData.postValue(sinceState)
                } else {
                    var sinceState =
                        SinceState(since, since.isNotEmpty(), emptyList(), it.error?.message)
                    stateLiveData.postValue(sinceState)
                }
            }, {
                var sinceState = SinceState(since, since.isNotEmpty(), emptyList(), it.message)
                stateLiveData.postValue(sinceState)
            })
</code></pre>

<p>How do I stop observing once I received a response or an error? Am I missing something?</p>

<p>If I don't stop this continuously making calls, then it makes too many API calls and server start returning:</p>

<blockquote>
  <p>HTTP 403 forbidden</p>
</blockquote>
","4623481","","391691","","2020-03-23 00:01:08","2020-03-23 00:01:08","Android KotlinRx API call making continuously in background","<android><kotlin><rx-kotlin><rx-kotlin2>","1","4","","","","CC BY-SA 4.0"
"60905481","1","60930218","","2020-03-28 18:54:21","","0","46","<p>I'm failing to get into the ReactiveX mindset or the codebase I am working in is just poorly written.</p>

<p>Suppose I have some Observable A() and I need data from another Observable B() in order to do validation on data coming through A, how do I accomplish this in RxJava (would prefer RxKotlin implementation). Note that both A and B return a Single of a List of objects.</p>

<pre><code>fun B(): Single&lt;List&lt;Bar&gt;&gt; {
  ...
}

fun A() : Single&lt;List&lt;Foo&gt;&gt; {
  Single.just(readRecords()).map { record -&gt;
    // val bar = B.getAll()??? This seems like an anti-pattern and I'm not sure if it would necessarily be right to .subscribe()???

    if (bar.contains(record)) {
      // ... some validation
    }
  }
}
</code></pre>

<p>Update 1: Should emphasize that the validation requires multiple sources so you could have B, C, D, etc.</p>
","10303350","","10303350","","2020-03-30 13:55:31","2020-03-30 14:19:00","Using data from another observable","<rx-java><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"60930218","2","","60905481","2020-03-30 12:08:52","","0","","<p>So you can use <code>.map {}</code> operator:</p>

<pre><code>fun A() : Single&lt;List&lt;Foo&gt;&gt; {
    return B.getAll().map { allFromB -&gt;  
        val record = readRecords()
        if (allFromB.contains(record)) {
           // ... some validation
        }
        ...
    }
}
</code></pre>

<p><strong>UPDATE</strong>
if you have few of such Observables you need to use <code>Observables.combineLatest()</code> or <code>Observable.combineLatest()</code> (depends on RX version you use):</p>

<pre><code>fun B(): Single&lt;List&lt;BarB&gt;&gt; {
   ...
}

fun C(): Single&lt;List&lt;BarC&gt;&gt; {
   ...
}

fun D(): Single&lt;List&lt;BarD&gt;&gt; {
   ...
}

fun A() : Single&lt;List&lt;Foo&gt;&gt; {
    return Observable.combineLatest(B.getAll(), C.getAll(), D.getAll) { barB, barC, barD -&gt; 
            val record = readRecords()
            //Do your staff here with all this vals and return List&lt;Foo&gt;
        }
}
</code></pre>
","4597766","","4597766","","2020-03-30 14:19:00","2020-03-30 14:19:00","","","","1","","","","CC BY-SA 4.0"
"61201439","1","61202156","","2020-04-14 05:49:47","","1","74","<p>Trying to come with a offline-first app, I managed to make a working repository pattern which first check the cache, then the database and finally, the api. I do that like this:</p>

<pre><code>private fun cachedTopics(): Maybe&lt;List&lt;Topic&gt;&gt; { ... }
private fun databaseTopics(): Maybe&lt;List&lt;Topic&gt;&gt; { ... }
private fun apiTopics(): Maybe&lt;List&lt;Topic&gt;&gt; { ... }

Maybe.concat(cachedTopics(), databaseTopics(), apiTopics())
     .firstOrError()
     .subscribeOn(scheduler)
</code></pre>

<p>Now, the thing is that I save partial data in the database (not all topics). If a user is connected to internet and browse the data displayed will only be the data in the database. But that's not all the content a user should access (if they are connected to internet). I'm aware this is due to the <code>.firstOrError()</code> call.</p>

<p><strong>But I wonder if there is a way to concatenate the distinct results of database + api (api might fail and thus return 0 results) and return a Single.</strong> </p>

<h2>Edit</h2>

<p>To be clearer I want something like the following:</p>

<pre><code>IF CACHE IS NOT EMPTY
   RETURN DISTINCT(DB + CACHE)
ELSE
   UPDATE CACHE WITH API RESULT
   RETURN DISTINCT(DB + API)
</code></pre>

<p>Where API calls will automatically result in having nor results if it fails.</p>
","11269045","","11269045","","2020-04-14 07:02:23","2020-04-14 07:16:25","Repository pattern concatenating results in RXKotlin","<android><kotlin><repository-pattern><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"61202156","2","","61201439","2020-04-14 06:52:24","","1","","<p>Perhaps what you want here is <code>Maybe#switchIfEmpty</code> (docs <a href=""http://reactivex.io/RxJava/javadoc/io/reactivex/Maybe.html#switchIfEmpty-io.reactivex.MaybeSource-"" rel=""nofollow noreferrer"">here</a>)</p>

<p>Then you could do something like this:</p>

<pre><code>class Repository() {

    fun topics() {
        return cachedTopics.switchIfEmpty(databaseOrApiTopics());
    }


    private fun databaseOrApiTopics() = databaseTopics().switchIfEmpty(apiTopicsWithUpdate())

    private fun apiTopicsWithUpdate() = apiTopics().doOnComplete {
        // update db
        // update cache?
    }
}
</code></pre>

<p>UPDATE: if you want to combine results together, you can do this with the overload of <code>Maybe.flatMap</code> that takes a combiner. Something like:</p>

<pre><code>cachedTopics().switchIfEmpty(
    databaseTopics().flatMap { dbTopics -&gt;
        apiTopics().doOnComplete { /* updateDb(it) */ }
            .map { apiTopics -&gt; apiTopics + dbTopics }
    }
)
</code></pre>
","5241933","","5241933","","2020-04-14 07:16:25","2020-04-14 07:16:25","","","","1","","","","CC BY-SA 4.0"
"61225108","1","","","2020-04-15 09:11:08","","1","93","<p>If I have 2 apps and the user had logged in one of them. How can I make the user automatically login in the other app? So, one login in either app is sufficient for accessing both of them.</p>

<p>For e.g. like if I have Amazon app I don't have to login in to my Amazon prime app if I am already logged in Amazon app. </p>
","8416125","","9851608","","2020-04-15 12:05:06","2020-04-15 12:05:06","How to have single login in my all other apps like Amazon do","<android><kotlin><rx-kotlin>","1","4","","","","CC BY-SA 4.0"
"61399761","1","61400101","","2020-04-24 01:48:39","","0","111","<p>Learning android with a two friends and right now we're focusing on just UI portion. One friend gave us the task of creating a display with dashed line divider. We're trying to add it in the Adapter file so it can be loaded in our fragment as part of the recycler view but can't figure out how.</p>

<p>Here's the layout in where the dotted line drawable gets passed in </p>

<pre><code>&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;
&lt;LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
    xmlns:app=""http://schemas.android.com/apk/res-auto""
    android:layout_width=""match_parent""
    android:layout_height=""match_parent""&gt;
    &lt;ImageView
        android:id=""@+id/dashes""
        android:background=""@drawable/dashes_line""
        android:layout_width=""match_parent""
        android:layout_height=""match_parent""/&gt;
&lt;/LinearLayout&gt;
</code></pre>
","13373484","","13373484","","2020-04-24 02:43:35","2020-04-24 02:43:35","Android line divider","<android><kotlin><android-recyclerview><rx-kotlin><data-class>","2","0","","","","CC BY-SA 4.0"
"61400101","2","","61399761","2020-04-24 02:26:43","","0","","<p>this is a way you can set line divider for RecyclerView </p>

<pre><code>recyclerView.addItemDecoration(DividerItemDecoration(context, VERTICAL).apply {
           setDrawable(getDrawable(context, R.drawable.separator))
    })
</code></pre>

<p>You can change the drawable as you see fit.</p>

<p><strong>Update</strong>: add drawable separator.xml</p>

<pre><code>&lt;shape xmlns:android=""http://schemas.android.com/apk/res/android""
    android:shape=""line""&gt;
  &lt;size android:height=""3dp""/&gt;
  &lt;stroke
      android:color=""#000000""
      android:dashWidth=""10px""
      android:dashGap=""10px""
      android:width=""1dp""/&gt;
&lt;/shape&gt;
</code></pre>
","13265590","","13265590","","2020-04-24 02:42:04","2020-04-24 02:42:04","","","","4","","","","CC BY-SA 4.0"
"61443660","1","","","2020-04-26 15:49:47","","0","383","<p>I have a drawable that's being displayed in a layout. The drawable has default properties such as color and width. I'm creating a data class to be able to update those when the recycler view is created. The part that fills in the color in the middle is working. But I'm stuck on how to actually update the drawable width and the ImageView margins from the viewHolder.</p>

<p>mydrawable.xml
    
    
        
    </p>

<p>The layout file</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;
&lt;LinearLayout xmlns:android=""http://schemas.android.com/apk/res/android""
    xmlns:app=""http://schemas.android.com/apk/res-auto""
    android:layout_width=""match_parent""
    android:layout_height=""match_parent""&gt;
    &lt;ImageView
        android:id=""@+id/rect_outline""
        android:src=""@drawable/mydrawable""
        android:layout_width=""match_parent""
        android:layout_height=""match_parent""
        android:layout_gravity=""center""
        android:layout_marginStart=""12dp""
        android:layout_marginEnd=""12dp""
        app:layout_constraintBottom_toBottomOf=""parent""
        app:layout_constraintEnd_toEndOf=""parent""
        app:layout_constraintHorizontal_chainStyle=""spread""
        app:layout_constraintStart_toStartOf=""parent""
        app:layout_constraintTop_toTopOf=""parent""/&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p>The data class</p>

<pre><code>data class ImageData(
    val c: String
    val width: Int
    val marginLeft : Int
</code></pre>

<p>)</p>

<p>MyViewHoler.kt</p>

<pre><code>internal class MyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
fun bind(item: ImageData) {
   itemView.rect_outline.setColorFilter(Color.parseColor(item.c))

}
</code></pre>

<p>}</p>
","13373484","","","","","2020-04-26 16:53:44","Update Image width and Margins programmatically","<android><kotlin><android-recyclerview><rx-kotlin><data-class>","1","2","","","","CC BY-SA 4.0"
"62023546","1","62023948","","2020-05-26 13:43:52","","1","287","<p>How do to use operators so that i always get the previous and the current value? If possible i want to avoid creating state outside the pipe.</p>
<pre><code>- time -&gt;
1      2      3      4
|      |      |      |
Operations
       |      |      |
       (1,2)  (2,3)  (3,4)

</code></pre>
<p>Note that every value besides the first and the last one have to appear twice, so a simple buffer won't do.</p>
<p>I thought about combining <code>skip</code> with <code>merge</code> and <code>buffer</code> but merge does not seem to guarantee ordering.</p>
<pre><code>val s = PublishSubject.create&lt;Int&gt;()
s.mergeWith(s.skip(1)).buffer(2).subscribe{i -&gt; print(i)}
s.onNext(1)
s.onNext(2)
s.onNext(3)
s.onNext(4)


</code></pre>
<blockquote>
<p>output:<br />
[1, 2][2, 3][3, 4]</p>
</blockquote>
<pre><code>val o = Observable.just(1,2,3,4)
o.mergeWith(o.skip(1)).buffer(2).subscribe{i -&gt; print(i)}
</code></pre>
<blockquote>
<p>output:<br />
[1, 2][3, 4][2, 3][4]</p>
</blockquote>
<p>(the sole 4 is fine, and expected)</p>
","7479173","","7479173","","2021-07-16 16:33:33","2021-07-16 16:33:33","Rxjava - How to get the current and the previous item?","<kotlin><rx-java><rx-kotlin>","1","1","","","","CC BY-SA 4.0"
"62023948","2","","62023546","2020-05-26 14:03:44","","3","","<p>Looks like you still can use buffer:</p>

<pre class=""lang-kotlin prettyprint-override""><code>Observable.just(1, 2, 3, 4)
    .buffer(2, 1)
    .subscribe { println(it) }

// prints
// [1, 2]
// [2, 3]
// [3, 4]
// [4]
</code></pre>
","1554633","","","","","2020-05-26 14:03:44","","","","1","","","","CC BY-SA 4.0"
"62044835","1","","","2020-05-27 13:54:28","","0","50","<p>I believe there is some big gap in my understanding about RxJava</p>

<p>suppose we have this interface:</p>

<pre><code> interface SecretInterface {
    fun getSecretKey(): Single&lt;Int&gt;
  }

  interface Vault {
    fun openSecret(): Single&lt;String&gt;
  }
</code></pre>

<p>and then I have this test:</p>

<pre><code> @Test
  fun should_check_on_this() {
    val mockSecret = mock&lt;SecretInterface&gt; {
      on { this.getSecretKey() }.thenReturn(Single.just(1), Single.just(2),
          Single.just(3))
    }

    val mockVault = mock&lt;Vault&gt; {
      on { this.openSecret() }.thenReturn(Single.error(Exception(""no can do"")),
          Single.just(""secret opened""))
    }

    val complexStuff = mockSecret.getSecretKey().doOnSuccess {
      System.err.println(""onSuccess secret top $it"")
    }.flatMap {
      mockVault.openSecret()
    }.retryWhen {
      it.flatMapSingle {
        mockSecret.getSecretKey().doOnSuccess { System.err.println(""onSuccess secret bottom: $it"") }
      }
    }

    val test = complexStuff.test()
    test.assertValue { it == ""secret opened"" }
    verify(mockSecret, Times(3)).getSecretKey()
  }
</code></pre>

<p>the test failed, because mockSecret.getSecretKey() invocated only twice, but in output:</p>

<pre><code>onSuccess secret top 1
onSuccess secret bottom: 2
onSuccess secret top 1

org.mockito.exceptions.verification.TooFewActualInvocations: 
secretInterface.getSecretKey();
Wanted 3 times:
</code></pre>

<p>things that I can not understand is:</p>

<pre><code>    -It's already resubscribed, but how come still using old value?
    -How I can make it, that every time I resubscribed always return the latest value?
  in this case it should return 3 not 1.
</code></pre>

<p>thank you</p>
","6908091","","","","","2020-05-27 13:54:28","Rx java subscribe 3 times but invocation only 2 times","<kotlin><rx-java2><rx-kotlin>","0","2","","","","CC BY-SA 4.0"
"62258222","1","62260657","","2020-06-08 08:44:33","","0","994","<p>I can't convert this method to RxJava3 despite having upgraded the dependencies</p>

<pre><code>fun setSearchField(searchField: EditText) {
        searchDisposable = searchField.afterTextChangeEvents()
            .skipInitialValue()
            .debounce(400, TimeUnit.MILLISECONDS)
            .map { it.editable()?.toString() ?: """" }
            .distinctUntilChanged()
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(::onSearchQueryUpdated)
    }
</code></pre>

<p>Type mismatch.
Required:
io.reactivex.rxjava3.disposables.Disposable?
Found:
io.reactivex.disposables.Disposable!</p>

<pre><code>    def retrofit_version = '2.9.0'
    implementation ""io.reactivex.rxjava3:rxjava:3.0.4""
    implementation ""io.reactivex.rxjava3:rxkotlin:3.0.0""
    implementation ""io.reactivex.rxjava3:rxandroid:3.0.0""
    implementation ""com.jakewharton.rxbinding3:rxbinding:3.1.0""
    implementation ""com.squareup.retrofit2:retrofit:$retrofit_version""
    implementation ""com.squareup.retrofit2:converter-gson:$retrofit_version""
    implementation ""com.github.akarnokd:rxjava3-retrofit-adapter:3.0.0""
    implementation ""com.squareup.okhttp3:logging-interceptor:4.7.2""
</code></pre>

<p>How should I accurately clean  the project from RxJava2?</p>

<p>I tried Invalidate caches/Restart: nothing happened.</p>

<p><a href=""https://i.stack.imgur.com/Vy89v.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Vy89v.png"" alt=""enter image description here""></a></p>
","13072160","","13072160","","2020-06-08 09:25:33","2020-06-08 11:07:30","Can't migrate accurately from RxJava2 to RxJava3","<android><rx-java2><rx-kotlin><rx-binding><rx-java3>","1","2","","","","CC BY-SA 4.0"
"62260657","2","","62258222","2020-06-08 11:07:30","","3","","<p>Dependencies: ./gradlew :dependencies</p>

<pre><code>implementationDependenciesMetadata
+--- io.reactivex.rxjava3:rxjava:3.0.4
|    \--- org.reactivestreams:reactive-streams:1.0.3
+--- io.reactivex.rxjava3:rxkotlin:3.0.0
|    \--- io.reactivex.rxjava3:rxjava:3.0.0 -&gt; 3.0.4 (*)
+--- io.reactivex.rxjava3:rxandroid:3.0.0
|    \--- io.reactivex.rxjava3:rxjava:3.0.0 -&gt; 3.0.4 (*)
+--- com.jakewharton.rxbinding3:rxbinding:3.1.0
|    +--- androidx.annotation:annotation:1.0.0 FAILED
|    +--- org.jetbrains.kotlin:kotlin-stdlib:1.3.41 -&gt; 1.3.71
|    |    +--- org.jetbrains.kotlin:kotlin-stdlib-common:1.3.71
|    |    \--- org.jetbrains:annotations:13.0
|    +--- io.reactivex.rxjava2:rxjava:2.2.10
|    |    \--- org.reactivestreams:reactive-streams:1.0.2 -&gt; 1.0.3
|    \--- io.reactivex.rxjava2:rxandroid:2.1.1
|         \--- io.reactivex.rxjava2:rxjava:2.2.6 -&gt; 2.2.10 (*)
</code></pre>

<p>You see, that rxbinding3 has a transitive dependency to </p>

<pre><code>|    +--- io.reactivex.rxjava2:rxjava:2.2.10
</code></pre>

<p>Which overwrites RxJava3</p>

<h1>Solution:</h1>

<pre><code>implementation 'com.jakewharton.rxbinding4:rxbinding:4.0.0'
</code></pre>
","7057156","","","","","2020-06-08 11:07:30","","","","0","","","","CC BY-SA 4.0"
"62497713","1","","","2020-06-21 11:13:50","","0","42","<p>I'm trying to do calculating one by one, asynchronously.</p>
<pre><code>fun method1(): Int{
return 2+2
}

fun method2(value: Int): Int{
return value * 2
}

fun method3(value: Int): Int{
return value * 3
}
</code></pre>
<p>Now I want method 2 work after method 1 and take result from her. Also method 3 work after method 2 and take result from her.
Is it possible to do that with rxkotlin and make it in one stream ?</p>
","10405000","","10405000","","2020-06-21 11:22:35","2020-08-10 08:03:31","Combine 3 single results - one stream","<rx-java><reactive-programming><rx-java2><rx-kotlin>","2","0","","","","CC BY-SA 4.0"
"62767181","1","62767231","","2020-07-07 02:19:41","","0","120","<p>Excuse the pun, had to do it to em.</p>
<p>I have an observable that is declared like so:</p>
<pre><code>Observable
        .interval(20, TimeUnit.MILLISECONDS)
        .subscribe {
            val timeDiff = System.currentTimeMillis() - testSum
            Log.i(&quot;LOG&quot;, &quot;TIME DIFF: $timeDiff&quot;)
            testSum = System.currentTimeMillis()

            mVisualizer.getWaveForm(waveformByteArray)
            onWaveFormDataCaptureManual(waveformByteArray)
        }
</code></pre>
<p>And no matter what I try to do, this observable will not die. disposables.add() (which seems to be the answer in Java) gives me an unresolved reference error. Before that, I can't even save it to a variable either, as that also shows a lot of red on the screen.</p>
<p>FYI I've Googled this problem. Nothing works.</p>
","5196674","","","","","2020-07-07 02:33:05","To Kill an Observable","<android><kotlin><rx-java><reactivex><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"62767231","2","","62767181","2020-07-07 02:24:59","","4","","<p>You need to take the output disposable and dispose it</p>
<pre><code>import io.reactivex.disposables.Disposable  //required import

 var diposable:Disposable?=null   //global variable


   disposable= Observable
            .interval(20, TimeUnit.MILLISECONDS)
            .subscribe {
                val timeDiff = System.currentTimeMillis() - testSum
                Log.i(&quot;LOG&quot;, &quot;TIME DIFF: $timeDiff&quot;)
                testSum = System.currentTimeMillis()

                mVisualizer.getWaveForm(waveformByteArray)
                onWaveFormDataCaptureManual(waveformByteArray)
            }
</code></pre>
<p>to dispose use</p>
<pre><code> disposable?.dispose()
</code></pre>
<p>If you have multiple disposables then you can use <code>CompositeDisposable</code></p>
<pre><code> var compositeDisposable:CompositeDisposable= CompositeDisposable()

 val disposable= Observable
        .interval(20, TimeUnit.MILLISECONDS)
        .subscribe {
            val timeDiff = System.currentTimeMillis() - testSum
            Log.i(&quot;LOG&quot;, &quot;TIME DIFF: $timeDiff&quot;)
            testSum = System.currentTimeMillis()

            mVisualizer.getWaveForm(waveformByteArray)
            onWaveFormDataCaptureManual(waveformByteArray)
        }

     compositeDisposable.add(disposable)
    // you can add as many disposables as you want
</code></pre>
<p>to Dispose use</p>
<pre><code>   compositeDisposable.dispose()  //every thing is disposed
</code></pre>
","6478047","","6478047","","2020-07-07 02:33:05","2020-07-07 02:33:05","","","","0","","","","CC BY-SA 4.0"
"63131880","1","","","2020-07-28 10:18:44","","0","35","<p>Hello friends to improve the code below; Is there a way to directly &quot;bind&quot; the &quot;event.position&quot; value without having to subscribe?
Or better?</p>
<pre><code>var index: BehaviorRelay&lt;Int&gt; = BehaviorRelay.createDefault(0)

mainViewPager.pageScrollEvents().subscribe(
        { event -&gt;
            index.accept(event.position)
        }
    )
</code></pre>
<p>I think I'm looking for something like the following (This code will not work, just an example);</p>
<pre><code>mainViewPager.pageScrollEvents().position.bind(index)
</code></pre>
","10018819","","13727175","","2020-07-28 14:03:18","2020-07-28 14:03:18","Subscribe with Bind","<android><rx-java><rx-android><rx-kotlin>","0","2","","","","CC BY-SA 4.0"
"63499500","1","","","2020-08-20 06:32:20","","0","84","<p>Have been banging my head over this for a while, I am lost here in managing a requirement where I have to use Rx in Kotlin.</p>
<p>Let me explain.</p>
<p>There is a set of ids whose equivalent items needs to be deleted from server and eventually in local based on server success.</p>
<p>Basically</p>
<ol>
<li>Make network call to delete for a single <code>id</code>(Supported network call returns a <code>Completable</code>)</li>
<li>if <code>complete</code>(success) callback is received store the <code>id</code> in a <code>list</code> (memory)</li>
<li>Do step one and two for all <code>id</code> to delete</li>
<li>Once every network call is complete pass the list to delete from local DB</li>
</ol>
<p>So these functions are available which cannot be modified.</p>
<ol>
<li><code>fun deleteId(id: String): Completable { networkCall.deleteId(id) }</code></li>
<li><code>fun deleteIds(ids: List&lt;String&gt;): Unit { localDb.deleteId(ids) }</code></li>
</ol>
<p>This is what I have tried but obviously incomplete and stuck...</p>
<pre class=""lang-kotlin prettyprint-override""><code>val deleted = CopyOnWriteArrayList&lt;String&gt;()
val error = CopyOnWriteArrayList&lt;String&gt;()
items?.filter { it.isChecked }
    ?.map { Pair(it.id, dataManager.deleteId(it.id)) }
    ?.forEach { (Id, deleteOp) -&gt;
        deleteOp.subscribeOn(Schedulers.io())
                .subscribe(object: CompletableObserver {
                    override fun onComplete() { deleted.add(Id) }

                    override fun onSubscribe(d: Disposable) { disposableManager += d }

                    override fun onError(e: Throwable) { error.add(Id) }

                })
    }
</code></pre>
<p>So now there are multiple problems here, One of them is the requirement where I am unable to find a place to know that all requests are completed so as to initiate a localDb delete.</p>
<p>Is there a way where I can use <code>Flowable.fromIterable()</code> or <code>zip</code> or <code>merge</code> somehow following the chain of commands like above to achieve the above scenario?</p>
","1731048","","1731048","","2020-08-20 09:11:35","2020-08-20 13:23:21","How to perform operation based on result of multiple RxJava Completable results","<java><kotlin><rx-java><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"63777591","1","63787395","","2020-09-07 12:25:27","","3","4122","<p>I am new to Android development with Kotlin and I am struggling on finding any useful documentation on how to create a simple GET and POST requests with the best current practices as possible. I am coming from an Angular development and there we used a reactive development using RxJS.</p>
<p>Normally I would create a service file that would hold all my request functions, then I would use this service in whichever component and subscribe to the observable.</p>
<p>How would you do this in Android? Is there a good started example of things that have to be created. From the first look, everything looks so complicated and over-engineered</p>
","8358839","","","","","2020-09-08 05:05:18","Simple HTTP request example in Android using Kotlin","<android><kotlin><rx-android><rx-kotlin><rx-kotlin2>","3","1","1","","","CC BY-SA 4.0"
"63787395","2","","63777591","2020-09-08 05:05:18","","5","","<p>I suggest you to use the official recommendation of <code>OkHttp</code>, or the <a href=""https://github.com/kittinunf/fuel"" rel=""noreferrer""><code>Fuel</code></a> library for easier side and it also has bindings for deserialization of response into objects using popular Json / ProtoBuf libraries.</p>
<p><strong>Fuel</strong> example:</p>
<pre class=""lang-kotlin prettyprint-override""><code>// Coroutines way:
// both are equivalent
val (request, response, result) = Fuel.get(&quot;https://httpbin.org/ip&quot;).awaitStringResponseResult()
val (request, response, result) = &quot;https://httpbin.org/ip&quot;.httpGet().awaitStringResponseResult()

// process the response further:
result.fold(
    { data -&gt; println(data) /* &quot;{&quot;origin&quot;:&quot;127.0.0.1&quot;}&quot; */ },
    { error -&gt; println(&quot;An error of type ${error.exception} happened: ${error.message}&quot;) }
)

// Or coroutines way + no callback style:
try {
    println(Fuel.get(&quot;https://httpbin.org/ip&quot;).awaitString()) // &quot;{&quot;origin&quot;:&quot;127.0.0.1&quot;}&quot;
} catch(exception: Exception) {
    println(&quot;A network request exception was thrown: ${exception.message}&quot;)
}

// Or non-coroutine way / callback style:
val httpAsync = &quot;https://httpbin.org/get&quot;
    .httpGet()
    .responseString { request, response, result -&gt;
        when (result) {
            is Result.Failure -&gt; {
                val ex = result.getException()
                println(ex)
            }
            is Result.Success -&gt; {
                val data = result.get()
                println(data)
            }
        }
    }

httpAsync.join()
</code></pre>
<p><strong>OkHttp</strong> example:</p>
<pre class=""lang-kotlin prettyprint-override""><code>val request = Request.Builder()
    .url(&quot;http://publicobject.com/helloworld.txt&quot;)
    .build()

// Coroutines not supported directly, use the basic Callback way:
client.newCall(request).enqueue(object : Callback {
    override fun onFailure(call: Call, e: IOException) {
        e.printStackTrace()
    }

    override fun onResponse(call: Call, response: Response) {
        response.use {
            if (!response.isSuccessful) throw IOException(&quot;Unexpected code $response&quot;)

            for ((name, value) in response.headers) {
                println(&quot;$name: $value&quot;)
            }

            println(response.body!!.string())
        }
    }
})
</code></pre>
","11377112","","","","","2020-09-08 05:05:18","","","","1","","","","CC BY-SA 4.0"
"64571621","1","64573000","","2020-10-28 11:10:55","","1","44","<p>I have a method that returns an Observable. I have this case where, in case of error I need to check error type, and for some specific error I need to return MyObject instead of error.</p>
<p>Example:</p>
<pre><code>    override fun getSomething(param: String): Observable&lt;State&gt; {
        return someInterface.getSingleResult(param)
            .flatMapObservable {
                when(something) {
                    true -&gt; {
                        Observable.just(State.ACTIVE)
                    }
                    false -&gt; {
                        Observable.just(State.PAUSED)
                    }
                }
            }
            .onErrorReturn {
                 if(it is Something) {
                      State.INACTIVE
                 } else {
//                    returns Throwable  &lt;- don;t know how to handle this
                 } 
            } 
    }
</code></pre>
","3524475","","","","","2020-10-28 16:12:48","Rx how to return Throwable or Object based on error type","<android><kotlin><rx-java2><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"64573000","2","","64571621","2020-10-28 12:37:02","","3","","<p>I'm not sure I got it right, but would the following work for you?</p>
<pre><code>.onErrorResumeNext {
    if (it is Something) {
        Observable.just(State.INACTIVE)
    } else {
        Observable.error(it)
    }
}

fun testObservable(): Observable&lt;Int&gt; {
    return Observable.just(1, 2, 3)
            .onErrorResumeNext { error: Throwable -&gt;
                if (error is IllegalArgumentException) {
                    Observable.just(0)
                } else {
                    Observable.error(error)
                }
            }
}
</code></pre>
","10126399","","10126399","","2020-10-28 16:12:48","2020-10-28 16:12:48","","","","2","","","","CC BY-SA 4.0"
"64735549","1","","","2020-11-08 06:51:41","","0","28","<p><a href=""https://i.stack.imgur.com/0mo2bl.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0mo2bl.jpg"" alt=""Image"" /></a></p>
<p>I have got 3 seekbars on my screen, each controlling the R, G, B colour of the background.</p>
<p>I am using the combineLatest operator to combine the Observables.</p>
<p>The issue is that, the background colour only changes when I have all 3 of the seekbars changed.</p>
<p>Which operator should I use if I want the background colour to change, even if I only changing 1 seekbar?</p>
<pre><code>    override fun onStart() {
        super.onStart()

        val redColorStream = createSeekBarRedObservable()
        val greenColorStream = createSeekBarGreenObservable()
        val blueColorStream = createSeekBarBlueObservable()

        val colorPalette = Observable.combineLatest(redColorStream, greenColorStream, blueColorStream) { r,g,b -&gt;
            Color.rgb(r,g,b)
        }

        colorPalette
            .subscribe {
                main_activity.setBackgroundColor(it)
            }
    }
</code></pre>
","11007537","","","","","2020-11-08 06:51:41","RxKotlin: What is the correct operator in this case?","<android><rx-kotlin>","0","1","","","","CC BY-SA 4.0"
"65217193","1","65217381","","2020-12-09 12:55:24","","0","27","<p>could someone help, please?</p>
<p>I have these functions</p>
<pre><code>fun getBooks(): Single&lt;List&lt;Book&gt;&gt; {
    return getCollections()
        .map {
            it.map(::collectonToBook)
        }
}

fun getCollections(): Single&lt;List&lt;Collection&gt;&gt; {
   return db.fetchCollections()
       .filter(::isBook)
}

fun collectonToBook(collection: Collection): Maybe&lt;Book&gt; {
    return collection.toBook()
}
            
</code></pre>
<p>The problem is getBooks returns <code>Single&lt;List&lt;Maybe&lt;Book&gt;&gt;&gt;</code> when I need <code>Single&lt;List&lt;Book&gt;&gt;</code>. Can I do that inside the stream without calling blockingGet?</p>
","1158918","","","","","2020-12-09 13:05:58","Transform Single<List<Maybe<Book>>> to Single<List<Book>>","<kotlin><rx-java2><rx-kotlin>","1","0","1","","","CC BY-SA 4.0"
"65217381","2","","65217193","2020-12-09 13:05:58","","4","","<p>Try this:</p>
<pre class=""lang-kotlin prettyprint-override""><code>getCollections()                        // Single&lt;List&lt;Collection&gt;&gt;
.flattenAsFlowable { it }               // Flowable&lt;Collection&gt;
.concatMapMaybe { collectonToBook(it) } // Flowable&lt;Book&gt;
.toList()                               // Single&lt;List&lt;Book&gt;&gt;
</code></pre>
<p>In words, unwrap the inner <code>List</code> into its elements, transform the <code>Collection</code> into a <code>Book</code>, concatenate their respective <code>Maybe</code> sources, then finally collect the <code>Book</code>s into a <code>List</code> again.</p>
","61158","","","","","2020-12-09 13:05:58","","","","1","","","","CC BY-SA 4.0"
"65289300","1","65504254","","2020-12-14 12:51:18","","0","33","<p>My server api looks like this:</p>
<pre><code>data class ArticleDTO(val id: Int, val title: String, val typeId: Int)
data class Type(val id: Int, val name: String) 

interface API {
    fun getArticles(): Single&lt;List&lt;ArticleDTO&gt;&gt;
    fun getTypes(): Single&lt;List&lt;Type&gt;&gt;
}
</code></pre>
<p>And I have one model which I use in UI:</p>
<pre><code>data class Article(val title: String, val typeName: String)
</code></pre>
<p>I created map method:</p>
<pre><code>fun ArticleDTO.toArticle(type: Type) = Article(this.title, typeName = type.name)
</code></pre>
<p>And in the repository class I did this:</p>
<pre><code>fun getArticles() =
    Observables.combineLatest(api.getArticles().toObservable(), api.getTypes().toObservable())
        .flatMap {
            Observable.just(it.first.map { articleDTO -&gt;
                articleDTO
                    .toArticle(it.second.find { type -&gt; type.id == articleDTO.typeId }!!)
            })
        }
</code></pre>
<p>Is there a way to do it better?</p>
<p>And what if my api will looks like this:</p>
<pre><code>interface API {
    fun getArticles(): Single&lt;List&lt;ArticleDTO&gt;&gt;
    fun getTypes(typeId: Int): Single&lt;Type&gt;
}
</code></pre>
","8145152","","","","","2020-12-30 08:45:12","Which is right way to map few server models into one domains?","<android><rx-java><clean-architecture><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"65504254","2","","65289300","2020-12-30 08:45:12","","0","","<p>You can get rid of <code>flatMap</code> and <code>Observable.just</code></p>
<pre><code>fun getArticles() = Observables.combineLatest(api.getArticles().toObservable(), api.getTypes().toObservable())
        .map { (dtos, types) -&gt;
            dtos.map { articleDTO -&gt;
                articleDTO
                    .toArticle(types.find { type -&gt; type.id == articleDTO.typeId }!!)
            }
        }
</code></pre>
","4597766","","","","","2020-12-30 08:45:12","","","","2","","","","CC BY-SA 4.0"
"65587608","1","65588658","","2021-01-05 22:42:03","","0","23","<p>I have a queue of items that will send once the server is reachable:<br>
<code>val queueHistory: Observable&lt;QueuedItem&gt;</code></p>
<p>A QueuedItem is:<br>
<code>data class QueuedItem(val item: Item, val sent: Boolean = false)</code></p>
<p>The queueHistory never completes, it just records when an item is being queued to be sent <code>onNext(QueuedItem(item1, false)</code>, and then later records it was sent <code>onNext(QueuedItem(item1, true)</code>.</p>
<p><strong>What I want to do is get a current count of how many unsent items there are.</strong></p>
<p>The main source of my trouble is due to the list not completing, I was initially thinking of using <code>collect</code> but that needs a completed list.</p>
<p>I was playing around with using <code>scan</code> with something like<br>
<code>queueHistory.scan { items: ScannedItems, item -&gt; ScannedItems(arrayOf(*items, item), 0) }</code><br>
Where I could keep the current list of items I have encountered so far, but scan wants everything to be the same type.</p>
<p>Another idea I had was</p>
<pre><code>queueHistory
            .groupBy { it.item }
            .flatMapSingle { it.toList() }
            .map { it.size % 2 }
</code></pre>
<p>But toList() needs a finite list.</p>
<p>Any ideas would be appreciated!</p>
","103777","","","","","2021-01-06 00:46:28","Applying an operation to all previously emitted items","<rx-java><reactive-programming><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"65588658","2","","65587608","2021-01-06 00:46:28","","1","","<p>There is a <code>#scan</code> overload, which takes a seed value and a lambda, which takes two parameters (prev, current). The <code>prev</code> parameter is of the same type as the seed, the <code>current</code> parameter is of the same type as the upstream.</p>
<h2>Example</h2>
<pre><code>class So65587608 {
    @Test
    fun `65587608`() {
        val producer = PublishSubject.create&lt;QueuedItem&gt;()

        val map = producer.scan(mutableListOf&lt;QueuedItem&gt;(), { list, curr -&gt;
            // when send = true -&gt; remove
            if (curr.sent) {
                list.removeIf { it.item == curr.item }
            } else if (!list.any { it.item == curr.item }) {
                list.add(curr)
            }
            list.toMutableList()
        }).map { list -&gt; list as List&lt;QueuedItem&gt; }

        map.subscribe {
            println(it)
        }

        val test = map.test()

        producer.onNext(QueuedItem(&quot;1&quot;))
        producer.onNext(QueuedItem(&quot;1&quot;, true))
        producer.onNext(QueuedItem(&quot;2&quot;, true))
        producer.onNext(QueuedItem(&quot;3&quot;, true))
        producer.onNext(QueuedItem(&quot;4&quot;))
        producer.onNext(QueuedItem(&quot;5&quot;))
        producer.onNext(QueuedItem(&quot;4&quot;, true))
    }

    data class QueuedItem(val item: String, val sent: Boolean = false)
}
</code></pre>
<h2>Output</h2>
<pre><code>[] // seed value
[QueuedItem(item=1, sent=false)]
[]
[]
[]
[QueuedItem(item=4, sent=false)]
[QueuedItem(item=4, sent=false), QueuedItem(item=5, sent=false)]
[QueuedItem(item=5, sent=false)]
</code></pre>
<h2>Note</h2>
<p>You have to make a copy of the list each #scan iteration or use a immutable list from persistent data collections.</p>
<p>Furthermore this is probably not a good implementation, because the list is unbound, which could take all your memory. If the list is big enough, the linear search might take some time as well, which is probably not good. One should think how the loopup could be done better.</p>
","7057156","","","","","2021-01-06 00:46:28","","","","1","","","","CC BY-SA 4.0"
"65850433","1","","","2021-01-22 18:02:38","","0","30","<p>I have a list of events, and for each event, I have to subscribe to live updates(web socket).</p>
<p>I request each event as below.</p>
<pre><code>    private fun subscribeToEventUpdates(events: List&lt;Events&gt;): Flowable&lt;Result&lt;EventUpdateResult, EventUpdateError&gt;&gt; {
        val eventUpdates = events.map { subscribeToEventUpdatesUseCase.invoke(it.id)) }

        return Flowable.merge(eventUpdates)
    }
</code></pre>
<p>And I am trying to subscribe to the events as below.</p>
<pre><code>    private fun getUpdatesFoEvents(events: List&lt;Event&gt;) {
        eventUpdatesDisposable?.dispose()
        eventUpdatesDisposable = subscribeToEventUpdates(events)
            .distinctUntilChanged()
            .subscribe(
                { onEventUpdate(it) },
                { onEventUpdateFailure(it) }
            )
    }
</code></pre>
<p>When I log the <code>subscribeToEventUpdatesUseCase</code> I see that I receive the web socket updates but <code>subscribe</code> method in the <code>getUpdatesFoEvents</code> is never called.</p>
<p>How may I receive the updates? Any help would be appreciated.</p>
","2391964","","1115491","","2021-03-09 07:27:02","2021-03-09 07:27:02","Unable to subscribe to a Flowable","<java><rx-java><rx-kotlin><rx-java3>","0","1","","","","CC BY-SA 4.0"
"66539018","1","66543084","","2021-03-09 00:10:54","","0","47","<p>I have a <code>PublishSubject</code>:</p>
<pre><code>val myPublishSubject = remember {
    PublishSubject.create&lt;Long&gt;().apply {
        doOnNext {
            Logger.debug(TAG) { &quot;Got new Long $it&quot; }
        }
            .takeUntil(someObservable)
            .subscribe()
    }
}
</code></pre>
<p>and I have a service what gets a stream of Long values, somewhere in another function:</p>
<pre><code>while(notFinished){
    val newLong = getSomeLong()
    myPublishSubject.onNext(newLong)
}
</code></pre>
<p>Here, the upper <code>doOnNext{}</code> is logging forever. How can I for instance only allow first 20 Long values? <code>.take(20)</code> did not work!</p>
","15122239","","15122239","","2021-03-09 07:02:37","2021-03-09 08:14:36","How to doOnNext only consumes the first n items of a PublishSubject?","<kotlin><rx-java2><rx-android><android-jetpack-compose><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"66543084","2","","66539018","2021-03-09 08:14:36","","0","","<p><code>take(20)</code> should work, this test passes:</p>
<pre><code>@Test
fun consumeOnlyFirst20ValueTest() {
    val ps = PublishSubject.create&lt;Long&gt;()

    CoroutineScope(Dispatchers.Default).launch {
        for (i in 1L..1000L) {
            ps.onNext(i)
            delay(50)
        }
    }

    var i = 0
    ps.take(20)
            .doOnNext {
                i++
            }.subscribeOn(Schedulers.io())
            .subscribe()

    Thread.sleep(6000)
    assertEquals(20, i)
}
</code></pre>
","2318843","","","","","2021-03-09 08:14:36","","","","0","","","","CC BY-SA 4.0"
"66832744","1","66835123","","2021-03-27 15:01:18","","0","198","<p>My Question is so clear, I wanna know what is the reason that you prefer using third-party libraries like RxJava or RxKotlin, or using coroutines for setting item click listener for Recyclerview items click, dialogs button or anything else, instead of using Interfaces, is there any performance reason?
what is the difference between these tools?</p>
","9972675","","","","","2021-03-27 19:06:25","What is the benefit of using RxJava, RxKotlin, or Even Kotlin coroutines instead of Interfaces for On Click listener?","<android><android-studio><rx-java><kotlin-coroutines><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"66835123","2","","66832744","2021-03-27 19:06:25","","0","","<p>Onclicklistener used to handle clicks on activity
and
Rxjava used to manage threads</p>
","14963902","","","","","2021-03-27 19:06:25","","","","0","","","","CC BY-SA 4.0"
"67040162","1","67055925","","2021-04-10 23:25:57","","1","46","<p>I have a list of recurring elements in Kotlin, say:</p>
<pre><code>val result = arrayListOf&lt;String&gt;(&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;, &quot;AA&quot;, &quot;BB&quot;)
</code></pre>
<p>I would like to group them by their value along with how many times they appear, so the output would be pairs of:</p>
<pre><code>{&quot;AA&quot;, 2}, {&quot;BB&quot;, 2}, {&quot;CC&quot;, 1}
</code></pre>
<p>I have resolved the problem using in Kotlin as follows:</p>
<pre><code>val ans = result.map { it.value }
            .groupBy { it }
            .map { Pair(it.key, it.value.size) }
            .sortedByDescending { it.second }
</code></pre>
<p>I want to write same code in RxKotlin for learning and tried with the following but do not know how to apply <code>map</code>/<code>flatMap</code> to achieve the result.</p>
<pre><code>val source = Observable.fromIterable(result)
source.groupBy{ it }.subscribe { showresult(it) }
</code></pre>
","1154390","","10082297","","2021-04-10 23:28:30","2021-04-12 09:27:43","RxKotlin COUNT with GROUP BY and return a list","<kotlin><rx-java><rx-kotlin><rx-kotlin2>","1","2","","","","CC BY-SA 4.0"
"67055925","2","","67040162","2021-04-12 09:27:43","","0","","<p>Try something like this:</p>
<pre class=""lang-kotlin prettyprint-override""><code>source.groupBy { it }
.flatMapSingle { g -&gt; g.count().map { Pair(g.getKey(), it) } }
.toSortedList { a, b -&gt; b.second.compareTo(a.second) }
.subscribe { list -&gt; println(list) }
</code></pre>
","61158","","","","","2021-04-12 09:27:43","","","","1","","","","CC BY-SA 4.0"
"67128528","1","","","2021-04-16 16:00:22","","0","28","<p>So I have an object of contactId and I convert it to flux and then I query the contact details using each Id respectively and after that convert it to Mono using collectList method and map it to another object let's call it DomainContactDetails like this.</p>
<pre class=""lang-kotlin prettyprint-override""><code>Flux.just(identifier.regContactId, identifier.billingContactId ,identifier.adminContactId, identifier.techContactId)
      .flatMap { resellerGetContact(it) }
      .collectList()
      .map { DomainContactDetails.fromList(it) }
      .toFuture()
</code></pre>
<p>Are there anyways to collect flux element into key map instead of list. for now I'm using index of list to indentify which data belongs to the property</p>
<pre class=""lang-kotlin prettyprint-override""><code>data class DomainContactDetails(
  val registrantContact: ContactInfo,
  val billingContact: ContactInfo,
  val adminContact: ContactInfo,
  val techContact: ContactInfo
) {
  companion object {
    fun fromList(contacts: List&lt;ContactInfo&gt;) = DomainContactDetails(
      registrantContact = contacts[0],
      billingContact = contacts[1],
      adminContact = contacts[2],
      techContact = contacts[3]
    )
  }
}
</code></pre>
<p>I want it to be key map so it might be a bit better like this</p>
<pre class=""lang-kotlin prettyprint-override""><code>fun fromKeyMap(contacts: Map&lt;String, ContactInfo&gt;) = DomainContactDetails(
  registrantContact = contacts[&quot;reg&quot;],
  billingContact = contacts[&quot;bil&quot;],
  adminContact = contacts[&quot;adm&quot;],
  techContact = contacts[&quot;tec&quot;]
)
</code></pre>
","9740664","","8976","","2021-04-17 07:49:20","2021-04-17 07:49:20","How can I convert flux element to a key map mono","<kotlin><reactor><rx-kotlin>","1","0","","","","CC BY-SA 4.0"
"67394991","1","","","2021-05-05 03:54:49","","0","24","<p>I'm using kotlin/java to develop android apps and reactiveX is something new to me.</p>
<p>How do we append similar data in an array using reactiveX?</p>
<p>I have this data and I want to merge same dates and append their progress.</p>
<p>So how do we transform this data</p>
<pre><code>{
  &quot;data&quot;: [
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 1
    },
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 5
    },
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 2
    },
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 3
    },
    {
      &quot;date&quot;: &quot;05-06-22&quot;,
      &quot;progress&quot;: 2
    }
  ]
}
</code></pre>
<p>to</p>
<pre><code>{
  &quot;data&quot;: [
    {
      &quot;date&quot;: &quot;05-05-21&quot;,
      &quot;progress&quot;: 11
    },
    {
      &quot;date&quot;: &quot;05-06-22&quot;,
      &quot;progress&quot;: 2
    }
  ]
}
</code></pre>
","6104745","","6104745","","2021-05-05 04:19:06","2021-05-05 04:19:06","Merging data in an array using ReactiveX in Android","<android><kotlin><rx-java><reactivex><rx-kotlin>","0","0","","","","CC BY-SA 4.0"
"67589564","1","67796289","","2021-05-18 15:39:43","","0","44","<p>I'm using refCount to hold onto a BLE connection for 5 mins. This works well until I have a connection issue, refCount still keeps the connection and replay replays the error.</p>
<p>Is there a way I can make either make refCount disconnect as soon as there is an error, or make replay not replay errors?</p>
<pre><code>        bleDevice
            .establishConnection(false)
            .replay(1)
            .refCount(1, 5, TimeUnit.MINUTES)
</code></pre>
","103777","","","","","2021-06-01 21:36:04","refCount keeping connection even after an error","<rx-java><reactive-programming><rxandroidble><rx-kotlin>","1","4","","","","CC BY-SA 4.0"
"67796289","2","","67589564","2021-06-01 21:36:04","","1","","<p>The easy way to achieve what you want is by using RxJava 3 <code>refCount</code> operator. You can use an RxJava 2 &lt;=&gt; 3 interoperability library <a href=""https://github.com/akarnokd/RxJavaBridge"" rel=""nofollow noreferrer"">RxJavaBridge</a>.</p>
<pre><code>val connectionObservable = bleDevice
    .establishConnection(false)
    .`as`(RxJavaBridge.toV3Observable())
    .replay(1)
    .refCount(1, 5, TimeUnit.MINUTES)
    .to(RxJavaBridge.toV2Observable()) // optional if you want to stick to RxJava 3
</code></pre>
","6564880","","","","","2021-06-01 21:36:04","","","","0","","","","CC BY-SA 4.0"
"67960660","1","67966935","","2021-06-13 16:52:15","","0","103","<p>I am a newbie to RXKotlin/RXJava.
I am developing the background service in Android.</p>
<p>In my service, I have</p>
<ul>
<li>Bluetooth socket</li>
<li>TCP Socket</li>
</ul>
<p>Whenever the data is available on the Bluetooth socket, read and write to the TCP socket. And whenever data is received in the TCP socket, write to the Bluetooth socket.</p>
<p>Can someone help me:</p>
<ul>
<li>how to achieve this using Observables?</li>
<li>how to exchange the socket id information?</li>
<li>how to exchange the data?
Thanks</li>
</ul>
","16216084","","2801860","","2021-06-14 18:21:18","2021-06-14 18:21:18","RXKOTLIN/RXJAVA: Communication between the socket using Observables","<android><rx-java><rxjs-observables><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"67966935","2","","67960660","2021-06-14 08:16:13","","0","","<p>Please try using RxSubjects (<a href=""https://blog.mindorks.com/understanding-rxjava-subject-publish-replay-behavior-and-async-subject-224d663d452f"" rel=""nofollow noreferrer"">https://blog.mindorks.com/understanding-rxjava-subject-publish-replay-behavior-and-async-subject-224d663d452f</a>)</p>
<p>Let me take PublishSubject as an example here.</p>
<pre><code>//a publish subject which publishes int values
public PublishSubject&lt;Integer&gt; source = PublishSubject.create();
source.onNext(1);
source.onNext(2);
</code></pre>
<p>So above lines of code goes in Bluetooth socket class.</p>
<p>Now in TCP socket class, using the source, you can observe here.</p>
<pre><code>source
    .subscribe(
        {
           //result
        },
        {
           //error
        }
    )
</code></pre>
<p>Thats it.</p>
<p>Please make sure, the subscription happens before Bluetooth socket starts publishing data.</p>
","1151799","","","","","2021-06-14 08:16:13","","","","4","","","","CC BY-SA 4.0"
"68191518","1","","","2021-06-30 08:54:00","","0","104","<p>In my Android App I'm trying to save a file with input- and outputStream from the contentResolver. I'm using this saveImageExternal function in a Rx Completable.fromCallable and I got a FileNotFoundException because my uri was wrong, but the onError function from my observer was not called and the Completable completed. Why was onError not called? Can someone explain?</p>
<pre><code>private fun saveImageExternal(file: File, uri: Uri, context: Context) {
        val resolver = context.contentResolver
        val outputStream = FileOutputStream(file)
        val inputStream = resolver.openInputStream(uri)
        val buffer = ByteArray(4096)
        var length: Int
        if (inputStream != null) {
            while (inputStream.read(buffer).also { length = it } &gt; 0) {
                outputStream.write(buffer, 0, length)
            }
            outputStream.flush()
        }

    }
</code></pre>
<pre><code>Completable.fromCallable { saveImageExternal(file, uri, context) }
            .subscribeOn(Schedulers.io())
            .subscribe(object : CompletableObserver{
                override fun onSubscribe(d: Disposable) {
                    Timber.d(&quot;onSubscribe&quot;)
                }

                override fun onComplete() {
                   Timber.d(&quot;onComplete&quot;)
                }

                override fun onError(e: Throwable) {
                    Timber.d(&quot;onError&quot;) // never called 
                }

            })
</code></pre>
","14718579","","14718579","","2021-06-30 09:48:04","2021-06-30 09:48:04","Rx Error Handling in Completable.fromCallable","<android><rx-java><rx-kotlin><rx-java-completable>","0","1","","","","CC BY-SA 4.0"
"68667754","1","68668270","","2021-08-05 13:43:10","","3","58","<p>I am studying RxKotlin and the question arose: what is the difference between <code>defer()</code>  and  <code>defer{}</code></p>
","14729932","","","","","2021-08-05 14:14:12","What is the difference between defer() and defer{}","<kotlin><rx-java><rx-kotlin>","2","0","","","","CC BY-SA 4.0"
"68668270","2","","68667754","2021-08-05 14:14:12","","4","","<p><code>defer()</code> and <code>defer {}</code> is just two ways to write the same thing. Kotlin allows some shortcuts in some specific cases to help write more readable code.</p>
<p>Here is an example to rewrite some code.</p>
<p>Given the following function for instance:</p>
<pre><code>fun wrapFunctionCall(callback: (Int) -&gt; Int) {
   println(callback(3))
}
</code></pre>
<pre><code>wrapFunctionCall(x: Int -&gt; {
  x * x
})

// Most of the time parameter type can be infered, you can then let it go
wrapFunctionCall(x -&gt; {
  x * x
})

// Can omit parameter, and let it be name `it` by default
wrapFunctionCall({
  it * it
})

// wrapFunctionCall accepts a lambda as last parameter, you can pull it outside the parentheses. And as this is the only parameter, you can also omit the parenthesis
wrapFunctionCall {
  it * it
}
</code></pre>
<p><a href=""https://kotlinlang.org/docs/lambdas.html#function-types"" rel=""nofollow noreferrer"">https://kotlinlang.org/docs/lambdas.html#function-types</a></p>
","490961","","","","","2021-08-05 14:14:12","","","","0","","","","CC BY-SA 4.0"
"68865912","1","","","2021-08-20 17:16:38","","0","28","<p>Is it possible to call handler right at start of every minute? Mean check current time and call handler only when seconds are 00. Using RX2. Thanks.</p>
<p><code>Observable.interval(1, TimeUnit.MINUTES)</code></p>
","1621111","","","","","2021-08-20 17:16:38","Call handler right at start of every minute","<android><rx-java2><rx-kotlin>","0","2","","","","CC BY-SA 4.0"