Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"45872463","1","45872598","","2017-08-24 23:43:47","","0","735","<p>I have a data flow like this:</p>

<pre><code>Observable
    .fromFuture(
        CompletableFuture.supplyAsync { // First remote call returns Future&lt;List&lt;Type&gt;&gt;
            listOf(1, 2, 3, 57005, 5)
        },
        Schedulers.computation()
    )
    .flatMap { it.toObservable() } // I turn that list into a stream of single values to process them one by one
    .map {
        CompletableFuture.supplyAsync { // This remote call may fail if it does not like the input. I want to skip that failures and continue the stream like the fail never occurred.
            if (it == 0xDEAD) {
                throw IOException(""Dead value!"")
            }

            it
        }
    }
    .flatMap {
        Observable.fromFuture(it) // Turn that Futures into a stream of Observables once again
    }
    .doOnNext {
        println(it) // Debug
    }
    .blockingSubscribe()
</code></pre>

<p>I've replaced business logic (that actually return <code>Future</code>s) with <code>CompletableFuture.supplyAsync</code>.
And, yes, this is Kotlin, but I guess you got the intent.</p>

<p>When I comment ""dead"" value (<code>57005</code>, <code>0xDEAD</code>) the output is:</p>

<pre><code>1
4
9
25
</code></pre>

<p>But if that ""dead"" value appears in the stream, it fails:</p>

<pre><code>1
4
9
Exception in thread ""main"" java.lang.RuntimeException: java.util.concurrent.ExecutionException: java.io.IOException: Dead value!
    at io.reactivex.internal.util.ExceptionHelper.wrapOrThrow(ExceptionHelper.java:45)
    at io.reactivex.internal.operators.observable.ObservableBlockingSubscribe.subscribe(ObservableBlockingSubscribe.java:86)
    at io.reactivex.Observable.blockingSubscribe(Observable.java:5035)
    at by.dev.madhead.rx.TestKt.main(test.kt:41)
Caused by: java.util.concurrent.ExecutionException: java.io.IOException: Dead value!
    at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:357)
    at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1895)
...
</code></pre>

<p>I'm a newbie in RX, so quickly googled for a solution: <code>onExceptionResumeNext</code>: <code>Observable.fromFuture(it)</code> --> <code>Observable.fromFuture(it).onExceptionResumeNext { Observable.empty&lt;Int&gt;() }</code>. But now my application hangs forever (after producing the output I expect).
Looks like the stream never ends.</p>

<p>Should I ""shutdown"" that <code>Observable</code> somehow or what?
Or, more generally, is it a good approach when working with RX?
Should I rethink it in another way?</p>
","750510","","750510","","2018-12-18 01:14:32","2018-12-18 01:14:32","How to skip exceptions silently in RxJava2?","<rx-java><reactive-programming><rx-java2><rx-kotlin><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"46523605","1","","","2017-10-02 10:16:15","","1","758","<p>Using <code>RxJava2</code> <code>RxKotlin</code> and <code>Room</code>, I need to query the database for an open hunt. That means that I search for a hunt that contains an attribute called <code>closed</code> with value <code>false</code>. Once the hunt has been found, it needs to switch the query to that particular hunt.</p>

<p>I have 2 methods for those queries:</p>

<pre><code>getOpenHunt(teamId:String): Flowable&lt;List&lt;Hunt&gt;&gt;
getHunt(huntId:String): Flowable&lt;List&lt;Hunt&gt;&gt;
</code></pre>

<p>They both return a <code>List</code> because otherwise the query gets stuck when no hunt is found.</p>

<p>My idea is something like</p>

<pre><code>fun queryHunt(teamId:String):Flowable&lt;Optional&lt;Hunt&gt;&gt;{
   getOpenHunt(teamId)
      .map&lt;Optional&lt;Hunt&gt;&gt; {
                Optional.create(it.firstOrNull())
            }
      .switchToFlowableIf ( it is Optional.Some, getHunt(it.element().id)
}

//With switchToFlowableIf's being
fun &lt;E:Any&gt; switchToFlowableIf(condition: (E)-&gt;Boolean, newFlowable: Flowable&lt;E&gt;): Flowable&lt;E&gt;
//It should unsubscribe from getOpenHunt and subscribe to newFlowable
</code></pre>

<p>For reference, here is my <code>Optional</code> class</p>

<pre><code>sealed class Optional&lt;out T&gt; {
class Some&lt;out T&gt;(val element: T) : Optional&lt;T&gt;()
object None : Optional&lt;Nothing&gt;()

fun element(): T? {
    return when (this) {
        is Optional.None -&gt; null
        is Optional.Some -&gt; element
    }
}

companion object {
    fun &lt;T&gt; create(element: T?): Optional&lt;T&gt; {
        return if (element != null) {
            Optional.Some(element)
        } else {
            Optional.None
        }
    }
}
}
</code></pre>

<p>Is there a similar method already built in RxJava2? If not, how would you implement it?</p>
","1354302","","1354302","","2017-10-02 10:41:16","2017-10-02 13:30:56","Change observable on condition met - RxJava2","<android><kotlin><rx-java2><rx-kotlin2>","2","0","","","","CC BY-SA 3.0"
"46589849","1","46595044","","2017-10-05 15:47:35","","0","1132","<p>Here is short snippet of code:</p>

<pre><code>    val subject = BehaviorSubject.createDefault(emptyList&lt;Int&gt;())
    subject.onNext(Arrays.asList(1, 2, 3))
    subject.flatMapIterable { list: List&lt;Int&gt; -&gt; list }
            .subscribeBy(
                    onNext = { l(""on next"", it) },
                    onComplete = { l(""on complete"") }
            )
</code></pre>

<p>Why <code>onComplete</code> doesn't not call here? What I should do for working this code? Because in original code I can not use <code>.toList()</code> method. </p>
","4981663","","","","","2017-10-05 21:26:58","RxJava2: onComplete not called with flatMapIterable","<kotlin><rx-java2><rx-kotlin2>","1","5","","","","CC BY-SA 3.0"
"47009101","1","","","2017-10-30 06:19:00","","0","530","<p>I am using RxJava 2.* and I want to merge the results of two observables (one from retrofit and another from room) by using zip operator(feel free to suggest better).</p>

<p>Model objects that come from remote server are different from the one coming out of Room Database. </p>

<ol>
<li>I want to map the objects from Remote into that of local </li>
<li>Merge those two results </li>
<li>Display the result.</li>
</ol>

<p>My remote API looks like this : </p>

<pre><code>interface CategoryService{
@GET(""categories"")
fun getCategories(): Observable&lt;List&lt;Category&gt;&gt;
</code></pre>

<p>}</p>

<p>And my Room DAO query looks like this : </p>

<pre><code>@Query(""SELECT * FROM categories ORDER BY id"")
abstract fun categories(): Observable&lt;List&lt;KmagCategory&gt;&gt;
</code></pre>

<p>I have converted Observable> into Observable> like this :</p>

<pre><code>val newCategoryList : Observable&lt;List&lt;KmagCategory&gt;&gt; =settingService.getCategories().flatMap { list -&gt;
            Observable.fromIterable(list)
                    .map { item -&gt; KmagCategory(item.id, item.title, item.slug, item.isFav) }
                    .toList()
                    .toObservable()
        }
</code></pre>

<p>But when I try to zip these two observables like this :</p>

<pre><code>val combinedObservable : Observable&lt;List&lt;KmagCategory&gt;&gt; = Observables.zip(KMagApp.database?.categories()?.categories()!!,newSetting)
</code></pre>

<p>I get <strong>Type inference failed, Expected type mismatch</strong> 
<a href=""https://i.stack.imgur.com/KpPz7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KpPz7.png"" alt=""enter image description here""></a></p>
","2581314","","2581314","","2017-10-30 06:27:26","2017-10-30 08:11:49","Cannot zip Rxjava Observables","<java><android><kotlin><rx-java2><rx-kotlin2>","2","0","","","","CC BY-SA 3.0"
"47294290","1","47294652","","2017-11-14 20:04:16","","0","314","<p>I have a stream of <code>ResponseMessage</code> which can be of different subtypes. I would like to split the stream into streams where I can handle each type in its own stream.</p>

<p>My first try resulted in this which I can not see working out.</p>

<pre><code>file.readLines()
        .toObservable()
        .map { mapper.readValue(it, ResponseMessage::class.java) }
        .groupBy { when(it) {
            is MarketChangeMessage -&gt; it::class
            else -&gt; it::class
        }}
        .map { it.????? } //How can possible this work?
</code></pre>

<p>My question is now:
What is the idiomatic way to divide a stream into streams on one specific sub type?</p>
","3139545","","2597143","","2018-10-24 13:19:55","2018-10-24 13:19:55","RxJava/RxKotlin split stream depending on subtype","<kotlin><rx-java><rx-kotlin><rx-kotlin2><rx-javafx>","1","0","","","","CC BY-SA 3.0"
"47376858","1","","","2017-11-19 12:28:54","","1","414","<p>Im stuck getting the following example working as expected, I have tried using <code>zip</code> and <code>combineLatest</code> and as show below <code>withLatestFrom</code> however non of them gives the expected output.</p>
<pre><code>@Test
fun thereCanBeOnlyOne() {
    val s1 = BehaviorSubject.create&lt;Int&gt;()
    val s2 = BehaviorSubject.create&lt;Int&gt;()

    s2.withLatestFrom&lt;Int, Int, Int&gt;(s1)
            .subscribe { (a, b) -&gt;
                println(&quot;$a - $b&quot;)
            }

    s1.onNext(1)
    s1.onNext(2)
    s2.onNext(1)
    s2.onNext(2)
    s1.onNext(333)
    s2.onNext(444)
}
</code></pre>
<p>What I want is the following to print:</p>
<blockquote>
<p>2 - 1</p>
<p>2 - 2</p>
<p>333 - 444</p>
</blockquote>
","3139545","","-1","","2020-06-20 09:12:55","2017-11-19 12:42:14","Combine two subject only when one changes and get latest from other","<rx-java><rx-java2><reactivex><rx-kotlin><rx-kotlin2>","1","0","","","","CC BY-SA 3.0"
"47534447","1","","","2017-11-28 14:50:47","","16","9783","<p>Suppose you want to insert a Completable in your Observable chain, such as for each emitted element, there is a completable that runs and blocks until it completes, what option would you choose? (here the <code>Completable.complete()</code> is just to make an example)</p>

<ol>
<li><p><code>.flatMap { Completable.complete().andThen(Observable.just(it)) }</code></p></li>
<li><p><code>.doOnNext { Completable.complete().blockingAwait() }</code></p></li>
<li><p>something else?</p></li>
</ol>
","1855855","","","","","2018-04-26 05:27:53","Chain Completable into Observable flow","<rx-java><rx-java2><rx-kotlin><rx-kotlin2>","2","0","","","","CC BY-SA 3.0"
"47595813","1","47804468","","2017-12-01 14:43:49","","0","153","<p>could you please help me to group by the following json and return a hashMap in kotlin based on date with RxKotlin? is so easy with just kotlin but really stuck for Rxkotlin. thanks</p>

<p>val groupedTransactions =   accountTransactions.transactions
                    ?.groupBy { it.effectiveDate }</p>

<pre><code>""transactions"": [{
        ""id"": ""44e5b2bc484331ea24afd85ecfb212c8"",
        ""effectiveDate"": ""20/07/2017"",
        ""description"": ""Kaching TFR from JOHN CITIZEN&lt;br/&gt;xmas donation"",
        ""amount"": 12.00
    }, {
        ""id"": ""1506aeeb8c3a699b1e3c87db03156428"",
        ""effectiveDate"": ""20/07/2017"",
        ""description"": ""Wdl ATM CBA ATM CIRCULAR QUAY STATION NSW 221092 AUS"",
        ""amount"": -200.00,
        ""atmId"": ""129382""
    }, {
        ""id"": ""9a899bfd978511e9605774e1d5222b67"",
        ""description"": ""Savings"",
        ""effectiveDate"": ""19/07/2017"",
        ""amount"": 10.00
    }, {
        ""id"": ""1a6c48627cecaa2388b702fa33d751ff"",
        ""description"": ""PTAG COCA COLA AMATI"",
        ""effectiveDate"": ""12/07/2017"",
        ""amount"": -2.20
    }, {
        ""id"": ""7ecc19e1a0be36ba2c6f05d06b5d3058"",
        ""description"": ""Wdl ATM CBA ATM TOWN HALL SQUARE NSW 253432 AUS"",
        ""effectiveDate"": ""04/07/2017"",
        ""amount"": -50.00,
        ""atmId"": ""137483""
    }, {
        ""id"": ""b71bf065b640217dad602f86ac047722"",
        ""description"": ""BPAY - Telstra mobile"",
        ""effectiveDate"": ""04/07/2017"",
        ""amount"": -49.00
    },{
        ""id"": ""ef087651eb482bae4624478696f4ad4f"",
        ""description"": ""Transfer from REBECCA SHAW&lt;br/&gt;Lorem ipsum"",
        ""effectiveDate"": ""03/07/2017"",
        ""amount"": 150.00
    }, {
        ""id"": ""8cd283d8b7bacc277f2bae5e26ce6d1e"",
        ""description"": ""Savings"",
        ""effectiveDate"": ""01/07/2017"",
        ""amount"": 200.00
    }, {
        ""id"": ""04117d2d74f5331f3ee4955da27cca7a"",
        ""effectiveDate"": ""28/06/2017"",
        ""description"": ""Transfer - Saturday drinks"",
        ""amount"": -100.00
    }, {
        ""id"": ""821ae63dbe0c573eff8b69d451fb21bc"",
        ""effectiveDate"": ""21/06/2017"",
        ""description"": ""Wdl ATM CBA ATM CIRCULAR QUAY STATION NSW 221092 AUS"",
        ""amount"": -200.00,
        ""atmId"": ""129382""
    }]
</code></pre>
","1820178","","","","","2017-12-14 01:09:58","rxkotlin groupby is not working","<rx-kotlin2>","1","5","","","","CC BY-SA 3.0"
"47953791","1","47971299","","2017-12-23 15:40:44","","3","4132","<p>I know how to do this in <a href=""https://stackoverflow.com/questions/38811923/how-to-use-rxjava-combinelatest-operator-with-more-than-9-observables"">RxJava 2</a>.</p>

<p>And I know how <a href=""https://stackoverflow.com/questions/42725749/observable-combinelatest-type-inference-in-kotlin"">RxKotlin</a> helps with similar issues.</p>

<p>But it seems that RxKotlin.Observables doesn't have this helper function for the list overload and I cannot figure it out. How would you do this?</p>
","1067763","","","","","2018-12-12 19:50:43","How to use RxJava2 combineLatest with a list of observables in Kotlin","<kotlin><rx-java2><rx-kotlin2>","3","2","1","","","CC BY-SA 3.0"
"48141978","1","","","2018-01-07 22:04:08","","1","60","<p>I have the following design I'd like to create, but I'm not sure which Rx pattern matches it. The goal is more or less along the lines of a Single, but with a conditional check.</p>

<ul>
<li>There is one <code>Observable&lt;String&gt;</code>, and the possibility of any number of observers.</li>
<li>If a request is first made, the observable will execute some network request taking in the string, then emit a callback (much like a completable/single)</li>
<li>Any subsequent call with the same key will return the same result immediately</li>
<li>However, if 5 minutes has passed and the same call is made, we will refetch the data as it may have expired, then emit it to any listeners. This result will be saved for another 5 minutes, and the cycle repeats.</li>
<li>All data is stored based on the key sent, much like a flyweight pattern. Expiration is based off of the last request time of the specific key.</li>
</ul>

<p>My initial thought was to just make my own class with a concurrent hashmaps. However, this will mean I have to handle a lot of the threading mechanisms myself. I feel like RxJava will be a great solution to this, but I'm not sure if such patterns exist. Does anyone have an idea?</p>

<p>I get that the purpose of a <code>Single&lt;T&gt;</code> is meant to only retrieve a single response, so my terms may not be correct.</p>

<p>The following is my attempt, which I will be updating as I go</p>

<pre><code>/**
 * Created by Allan Wang on 07/01/18.
 *
 * Reactive flyweight to help deal with prolonged executions
 * Each call will output a [Single], which may be new if none exist or the old one is invalidated,
 * or reused if an old one is still valid
 *
 * Types:
 * T    input       argument for caller
 * C    condition   condition to check against for validity
 * R    response    response within reactive output
 */
abstract class RxFlyweight&lt;in T : Any, C : Any, R : Any&gt; {

    /**
     * Given an input emit the desired response
     * This will be executed in a separate thread
     */
    protected abstract fun call(input: T): R

    /**
     * Given an input and condition, check if
     * we may used cache data or if we need to make a new request
     * Return [true] to use cache, [false] otherwise
     */
    protected abstract fun validate(input: T, cond: C): Boolean

    /**
     * Given an input, create a new condition to be used
     * for future requests
     */
    protected abstract fun cache(input: T): C

    private val conditionals = mutableMapOf&lt;T, C&gt;()
    private val sources = mutableMapOf&lt;T, Single&lt;R&gt;&gt;()

    private val lock = Any()

    /**
     * Entry point to give an input a receive a [Single]
     * Note that the observer is not bound to any particular thread,
     * as it is dependent on [createNewSource]
     */
    operator fun invoke(input: T): Single&lt;R&gt; {
        synchronized(lock) {
            val source = sources[input]

            // update condition and retrieve old one
            val condition = conditionals.put(input, cache(input))

            // check to reuse observable
            if (source != null &amp;&amp; condition != null &amp;&amp; validate(input, condition))
                return source

            val newSource = createNewSource(input).cache()

            sources.put(input, newSource)
            return newSource
        }
    }

    /**
     * Open source creator
     * Result will then be created with [Single.cache]
     * If you don't have a need for cache,
     * you likely won't have a need for flyweights
     */
    open protected fun createNewSource(input: T): Single&lt;R&gt; =
            Single.fromCallable { call(input) }
                    .timeout(20, TimeUnit.SECONDS)
                    .subscribeOn(Schedulers.io())

    fun reset() {
        synchronized(lock) {
            sources.clear()
            conditionals.clear()
        }
    }

}
</code></pre>
","4407321","","4407321","","2018-01-07 23:48:21","2018-01-07 23:48:21","Resettable Single Rx pattern","<rx-java2><rx-kotlin2>","0","7","","","","CC BY-SA 3.0"
"48398348","1","48411925","","2018-01-23 09:35:22","","1","1068","<p>I have my observables defined like this </p>

<pre><code>    val initLoading = Observable.fromCallable { println(""${System.currentTimeMillis()}"") }
            .subscribeOn(Schedulers.computation())
            .delay(WAIT_TIME, TimeUnit.SECONDS)
            .map { ""loading ${System.currentTimeMillis()}"" }
            .observeOn(AndroidSchedulers.mainThread())

    val click = RxView.clicks(button).map { ""click ${System.currentTimeMillis()}"" }
    initLoading.concatWith(click)
            .subscribeBy(
                    onNext = { println(""result $it"") },
                    onError = { throw it }
            )
</code></pre>

<p><code>initialLoading</code> starts running at Activity's <code>onCreate</code> method. <code>click</code> is executed on button click. I have two cases and first is working, second isn't.</p>

<p><strong>case 1</strong> </p>

<p>activity starts and button is clicked <strong>after</strong> <code>WAIT_TIME</code> seconds. Output: </p>

<pre><code>   01-23 13:08:07.170  I/System.out: 1516698487170
   01-23 13:08:17.174  I/System.out: result loading 1516698497172
   01-23 13:08:29.258  I/System.out: result click 1516698509258
</code></pre>

<p><strong>case 2</strong></p>

<p>activity starts and button is clicked <strong>before</strong> <code>WAIT_TIME</code> period is over. Output</p>

<pre><code>   01-23 13:09:07.392 I/System.out: 1516698547392
   01-23 13:09:17.398 I/System.out: result loading 1516698557395
</code></pre>

<p>so, the problem is that the click event is lost. I want the click event to wait for the loading, and then continue working. in short, case 2 output should be the same as case 1.</p>

<p>How can i chive this using rx operators. I tried <code>merge</code> but it just combines both and click event doesn't wait for loading. </p>

<p>I also tried <code>reply, cache, publish, share</code> but couldn't get the right combination of them to work as I want. </p>
","3904645","","","","","2018-01-23 22:32:22","RxJava: Combining hot and cold observable to wait for each other","<android><rx-java><rx-java2><rx-kotlin><rx-kotlin2>","2","0","1","","","CC BY-SA 3.0"
"48423869","1","","","2018-01-24 13:39:20","","1","334","<p>I am developing an app that shows a list of items it fetches from the internet.
I have 2 buttons loadMore and refresh, loadMore - loads the next batch of items, refresh - load the items from the beginning.</p>

<p>I am using MVI (Model View Intent) pattern.
Just to make it simple i created an example using a list of numbers each number will represent a batch of items:</p>

<pre><code>    val loadSubject = BehaviorSubject.create&lt;Unit&gt;()
    val refreshSubject = PublishSubject.create&lt;Unit&gt;()

    val list = loadSubject.scanWith(
            { Observable.just(emptyList&lt;Int&gt;()) },
            { listObservable, _ -&gt;
                listObservable
                        .map { it + ++count }
                        .replay().autoConnect()
            }
    )
            .flatMap { it }
            .filter { it.isNotEmpty() }


    val listSubscription = {
        list.subscribe {
            //do whatever with the list
        }
    }

    refreshSubject.scanWith(
            listSubscription,
            { disposable, _ -&gt;
                disposable.dispose()
                listSubscription()
            }
    ).subscribe()
</code></pre>

<p>So now it would work perfectly but the subscription is in my Intent, I need a method with Rx that would do exact same thing but letting my View subscribe.</p>

<p>What I am trying to get is:</p>

<p>let say my list is <code>[1,2,3]</code></p>

<p>on loadMore press ill get <code>[1,2,3,4]</code></p>

<p>on refresh press ill get <code>[5]</code></p>
","7442122","","544406","","2018-01-25 08:26:31","2018-01-29 22:57:02","Rx how to create a list that updates or refreshes on request","<android><rx-java2><rx-android><rx-kotlin2>","2","6","1","","","CC BY-SA 3.0"
"48570561","1","48570680","","2018-02-01 19:43:36","","0","458","<p>I want to build a async operation that iterates chars in given string. I have a char array taken by <code>""mystring"".toCharArray()</code>. I want to iterate each 10th character by using RX.</p>

<p>I know i can do it with <a href=""https://developer.android.com/reference/android/os/AsyncTask.html"" rel=""nofollow noreferrer"">AsyncTask</a> and for-loops but i thought RX would be more elegant solution. I have read <a href=""http://reactivex.io/documentation/operators.html"" rel=""nofollow noreferrer"">documentations</a> but did not recognize how to do it.</p>

<p>Another idea in my mind to create a <a href=""http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/subjects/PublishSubject.html"" rel=""nofollow noreferrer"">PublishSubject</a> and fire <code>onNext()</code> in  a for-loop that index increments by 10 with subscription.</p>

<p>PS: <code>""mystring""</code> can be much more larger like a json, xml or etc. Please feel free to comment about ram profiling.</p>
","2886507","","2886507","","2018-02-02 06:35:48","2018-02-02 06:35:48","For-loop with RxJava2 or RxKotlin","<android><for-loop><android-asynctask><rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 3.0"
"48960693","1","49162279","","2018-02-24 08:01:19","","1","399","<p>I've just learned rxjava, rxkotlin, dagger and retrofit, but I don't know the approach to take when communicating with server/db and how to store information locally.
There are 3 questions at the end. Please help</p>

<pre><code>@Singleton
class MyInteractor @Inject constructor() {

@Inject lateinit var context: Context
@Inject lateinit var restClient: RestClient

private var subscriptions: MutableList&lt;Disposable&gt; = mutableListOf()
private var settingsSubject: BehaviorSubject&lt;SettingsDTO&gt; = BehaviorSubject.create()

fun initData() {
    initSettings()
}

fun unsubscribeAll() {
    subscriptions.forEach({ subscription -&gt; subscription.dispose() })
}

private fun initSettings() {
    val settingsObservable = restClient.getSettings()
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())

    val settingsServerSubscription = settingsObservable.subscribe({ response -&gt;
        run {
            settingsSubject.onNext(response.body())
        }
    }, {
       //TODO handle errors
    })
    subscriptions.add(settingsServerSubscription)


    //subscribe database to subject changes
    val settingsDatabaseSubscription = settingsSubject.subscribe { setting -&gt;
        //TODO save or update db
    }
    subscriptions.add(settingsDatabaseSubscription)
}

fun getSettings(callback: SettingsCallback) {
    callback.onFetchedSettings(settingsSubject.value)
}
}
</code></pre>

<ol>
<li>Do I need to save the Disposable subjects and unsubscribe? Or is done automatically? (I'm saving all of the subscriptions in a list then undispose all at once)</li>
<li>Is this the right approach? I'm initializing all settings in the initData method, and call it at creation of an activity. 
The data is stored in a behaviour subject (settingsSubject) and I subscribe on that subject to save changes in database,
so everytime I want to change a setting I'm calling the rest client and then update the subject (db will be updated because of the subscription)</li>
<li>On getSettings method, should I use the callback or just return the settingsSubject value?</li>
</ol>
","6949710","","6949710","","2018-02-24 10:46:47","2018-03-07 22:29:46","What is the right approach using rxkotlin or rxjava in android when communicating with server and db?","<android><dagger-2><rx-kotlin2>","1","0","","","","CC BY-SA 3.0"
"49076391","1","49077269","","2018-03-02 19:53:21","","2","145","<p>I'm facing this problem. Im using room to create the local database of my app. Let's say i have an Entity call User and a UserDao. It looks like this:</p>

<pre><code>@Dao
interface UserDao: BaseDao&lt;User&gt;{
    @Query(""SELECT * FROM user WHERE remote_id = :remoteId"")
    fun getUser(remoteId : Long) : Single&lt;User&gt;
}
</code></pre>

<p>Nothing weird in this point, but what i want to do is be able to Changue the type of return in these  functions. I want this because sometimes i need to get a Single but in other cases i need to get a Flowable. In this two cases the query is the same an the only thing than chagues is the type of return and i don't want to do something like this.</p>

<pre><code>@Dao
interface UserDao: BaseDao&lt;User&gt;{

    @Query(""SELECT * FROM user WHERE remote_id = :remoteId"")
    fun getUserSingle(remoteId : Long) : Single&lt;User&gt;

    @Query(""SELECT * FROM user WHERE remote_id = :remoteId"")
    fun getUserFlowable(remoteId : Long) : Flowable&lt;User&gt;
 } 
</code></pre>

<p>Any idea how to do this in a clean way? </p>
","5420543","","7756492","","2018-04-16 08:43:41","2018-04-16 08:43:41","How to implement different kinds of return to the same query using Room and Android Rx?","<android><rx-android><rx-kotlin2>","2","0","1","","","CC BY-SA 3.0"
"49215549","1","49215842","","2018-03-11 00:51:10","","1","116","<p>I have an rx chain that calls an API through Retrofit. I subscribe to my API service, with standard rx <code>subscribe({...})</code> method and pass a lambda to it. Unfortunately when  my call is finally completed, all the code I have added to be executed inside lambda is totally ignored. AndroidStudio suggested a fix which basically adds an inline function <code>run</code> to my lamda and... it magically works. I have no idea what's happening. Why does it not work without <code>run</code>? What does <code>run</code> do?</p>

<p>The code follows:</p>

<pre><code>valuesServiceApi.getValues()
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({ data -&gt;
                run { //&lt;- What's this?
                    val cs = data.creditReportInfo.score
                    view.setCreditScore(cs)
                    Logger.getLogger(""success:"").info(""credit score $cs"")
                }

            })
</code></pre>
","1939370","","","","","2018-03-11 03:44:54","Lambda's are ignored until ""run"" is added","<kotlin><rx-kotlin2>","2","0","","","","CC BY-SA 3.0"
"49257702","1","49280175","","2018-03-13 13:40:14","","0","1491","<p>What I trying to do is listen to socket data and convert into an observable string that my UI can Subscribe this event and do Change on UI </p>

<p>So far I created a class SocketConnection maintain in dagger connection happen properly and received data and able to do with interface correctly, but want to apply with rxkotlin. </p>

<p>Using Socket.io,kotlin</p>

<h3>SocketConnection class</h3>

<pre><code> class SocketConnection : SocketStreamListener {

    private var socket: Socket? = null

   var responseSocket :ResponseHandler?= null
    companion object {
        var instance = SocketConnection()

    }

    override fun createSocket(socketQuery: SocketQuery): Socket? {
        try {
            val okHttpClient = UnsafeOkHttpClient.getUnsafeOkHttpClient()
            IO.setDefaultOkHttpWebSocketFactory(okHttpClient)
            IO.setDefaultOkHttpCallFactory(okHttpClient)
            val opts = IO.Options()
            opts.reconnection = false
            opts.callFactory = okHttpClient
            opts.webSocketFactory = okHttpClient
            opts.query = ""userID="" + socketQuery.userID + ""&amp;token="" + socketQuery.token
            socket = IO.socket(CommonContents.BASE_API_LAYER, opts)
            L.d(""Socket object created"")
        } catch (e: URISyntaxException) {
            L.e(""Error creating socket"", e)
        }
        return socket
    }

    override fun createSocketListener(socket: Socket) {
        L.d(""inside the socket Listner"")
        socket.connect()?.on(Socket.EVENT_CONNECT, {
            L.d(""connected"")
            listenSocketEvents()
            //socketDataListener()
            createMessageListener()

        })?.on(Socket.EVENT_DISCONNECT,
                {
                    L.d(""disconnected"")
                    return@on
                })

    }


    /**
     * function used to listen a socket chanel data
     */
    private fun listenSocketEvents() {


       /* socket?.on(""1502"", { args -&gt;
      // This Will Work 
             L.d(""Socket market depth event successfully"")
            val socketData = args[0] as String
            L.d(socketData)
         //   instance.data = Observable.just(socketData)
            //data!!.doOnNext({ socketData })

            *//*
            data = args[0] as String
             for (i in 0 until arr.size) {
                 arr[i].socketStreamingData(data)
             }*//*

        })*/

    }

// This Will Not Work
    fun socketDataListener(): Observable&lt;String&gt;{
      return Observable.create({
          subscibe -&gt;
         // L.d(""Socket market depth event successfully"")
            socket?.on(""1502"", { args -&gt;
                L.d(""Socket market depth event successfully"")
                val socketData = args[0] as String
                subscibe.onNext(socketData)
            })

        })
    }

  }
</code></pre>

<h3>Repository</h3>

<pre><code>fun getSocketData(): Observable&lt;String&gt; {
   // L.e("""" + SocketConnection.instance.socketDataListener())
    return SocketConnection.instance.createMessageListener()
}
</code></pre>

<h3>ViewModel</h3>

<pre><code>fun getSocketData(): Observable&lt;String&gt;{
    return groupRepository.getSocketData()
}
</code></pre>

<h3>OnFragement (UI)</h3>

<pre><code>private fun getSocketUpdate(){
    subscribe(watchlistViewModel.getSocketData()
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe({
                L.d(""SocketData :  "" + it.count())

            }, {
                L.e(""Error"")
            }))
}
</code></pre>

<p>In this UI using disposable subscribe method into base class.</p>

<p>Please let me know what i doing wrong thanx in advance </p>
","9054548","","9054548","","2018-03-14 12:14:00","2018-03-14 14:22:45","RxKotlin with Socket.io in Android","<android><socket.io><kotlin><rx-kotlin2>","1","4","","","","CC BY-SA 3.0"
"49524051","1","","","2018-03-27 23:47:32","","0","342","<p>Can I use Rx Kotlin + Rx Android without adding Rx Java? Or Rx Kotlin is depended upon Rx Java.</p>
","1268634","","","","","2018-04-04 14:12:37","Is RxKotlin Depend upon RxJava in Android?","<rx-android><rx-kotlin2>","1","0","","","","CC BY-SA 3.0"
"49683093","1","49683405","","2018-04-05 23:35:57","","1","430","<p>my problem is this. I have the next code</p>

<pre><code>Observable.fromIterable(this)
            .flatMap { project -&gt;
                val date = async(CommonPool) {
                    App.db.projectResponseDao().getLastUpdate(project.uid.toString())
                }
                val query = ProjectQuery.builder().id(project.uid.toString()).date(date.await()).build()
                val baseGraphQlUrl = context.getString(R.string.base_graphql_url)
                val apolloCall: ApolloCall&lt;ProjectQuery.Data&gt; = ApiClient.getApolloClient(context.getSessionToken(), baseGraphQlUrl).query(query)
                val remoteObservable: Observable&lt;Pair&lt;Project, Response&lt;ProjectQuery.Data&gt;&gt;&gt; = Observable.combineLatest(
                        Observable.just(project),
                        Rx2Apollo.from(apolloCall),
                        BiFunction { localProject, response -&gt; Pair(localProject, response) })
                remoteObservable
            }
</code></pre>

<p>So, I'm getting a date from a Room table in my android application. I'm using an async method because the room queries need to be done in a different thread from UI. So, with the result, I want to build a new query to a remote database. The problem is I want to be sure that date is already initialized at the moment I create my query. With that in mind, I use await method, but an error is given to me. it said I cant call await function in a no suspend function. So, can you think of a way to solve this? or how to fix it? thank you </p>
","5420543","","1904517","","2018-04-11 06:05:44","2018-04-11 06:05:44","How to use await method inside a flatMap?","<android><kotlin><rx-java><kotlinx.coroutines><rx-kotlin2>","1","0","","","","CC BY-SA 3.0"
"49685851","1","49686992","","2018-04-06 05:20:03","","1","537","<p>I use RxJava 2 <code>Observable</code> to wrap barcode scanner in one of my app. This snippet show how I subscribe to <code>Observable</code> and listen to it's events</p>

<pre><code>override fun start() {
    disposables.addAll(subscribeToBarcodeReader(), loadUser())
}

private fun subscribeToBarcodeReader(): Disposable {
    return barcodeObservable
        .subscribeOn(bgScheduler)
        .observeOn(mainScheduler)
        .subscribeBy(
                onNext = { barcode -&gt; saveBarcode(barcode) },
                onComplete = { Log.d(TAG, ""Barcode observable complete"") },
                onError = { e -&gt; Log.d(TAG, ""Barcode observable error"", e) }
        )
}
</code></pre>

<p><code>barcodeObservable</code> is object of <code>Observable&lt;Barcode&gt;</code> type. This all works fine on real device with real barcode scanner. Now I want to unit test the <code>saveBarcode()</code> method and try to mock the <code>Observable&lt;Barcode&gt;</code> this way</p>

<pre><code>@RunWith(MockitoJUnitRunner::class)
class OrbFoldersPresenterTests {

    @Mock
    private lateinit var jobService: FolderJobService
    private val bgScheduler = TestScheduler()
    private val mainScheduler = TestScheduler()
    private val barcodeObservable: Observable&lt;Barcode&gt; = Observable.just(Barcode(
            ""2500020109205"", LocalDateTime.now().toString()))
    @Mock
    private lateinit var userStore: UserStore
    @Mock
    private lateinit var prefs: Preferences
    @Mock
    private lateinit var barcodeService: BarcodeReadService

    @Test
    fun testBarcodeSave() {
        val jobId = 201804040001
        val disposables = CompositeDisposable()

        whenever(userStore.authorizedUser()).thenReturn(Maybe.just(User()))

        val presenter = OrbFoldersPresenter(jobId, jobService, disposables, bgScheduler,
                mainScheduler, barcodeObservable, userStore, prefs, barcodeService)
        presenter.start()
    }
}
</code></pre>

<p>I'm expecting that when I call <code>presenter.start()</code> presenter must subscribe to <code>barcodeObservable</code> and receive <code>onNext()</code> event with object I've provided. But this isn't happening. What am I doing wrong? </p>
","1120398","","","","","2018-04-06 06:49:05","RxJava 2 mock Observable doesn't work","<android><kotlin><rx-java2><rx-kotlin2>","2","0","","","","CC BY-SA 3.0"
"49810518","1","49811822","","2018-04-13 06:23:15","","8","2429","<p>I'm having a scenario where I need to periodically call an API to check for a result. I'm using <code>Flowable.interval</code> to create an interval function which calls the API.</p>

<p>However, I'm having trouble with backpressure. In my example below, a new single is created on each tick in the interval. The desired effect is to only call the API if a call is not already in progress</p>

<pre><code>Flowable.interval(1, 1, TimeUnit.SECONDS).flatMap {
        System.out.println(""Delay $it"")

        //simulates API call
        Single.just(1L).doAfterSuccess {
            System.out.println(""NEW SINGLE!!!"")
        }.delay(4, TimeUnit.SECONDS).doAfterSuccess {
            System.out.println(""SINGLE SUCCESS!!!"")
        }.toFlowable()
    }.subscribeOn(Schedulers.io()).observeOn(Schedulers.computation()).blockingFirst()
</code></pre>

<p>I can solve this using a filter variable like so:</p>

<pre><code>var filter = true

Flowable.interval(1, 1, TimeUnit.SECONDS).filter {
    filter
}.flatMap {

    System.out.println(""Delay $it"")

    Single.just(1L).doOnSubscribe {
        filter = true
    }.doAfterSuccess {
        System.out.println(""NEW SINGLE!!!"")
    }.delay(4, TimeUnit.SECONDS).doAfterSuccess {
        System.out.println(""SINGLE!!!"")
        filter = true
    }.toFlowable()
}.subscribeOn(Schedulers.io()).observeOn(Schedulers.computation()).blockingFirst()
</code></pre>

<p>But it seems like a hacky solution. I've tired applying <code>onBackPressureDrop</code> after the <code>interval</code> function, but it has no effect.</p>

<p>Any suggestions? </p>
","565319","","","","","2018-04-13 08:12:54","RxJava Flowable.Interval backpressure when flatmap with single","<kotlin><rx-java2><rx-kotlin2>","1","1","0","","","CC BY-SA 3.0"
"50204067","1","","","2018-05-06 20:08:38","","1","89","<p>Nothing I've tried seems to solve my problem.</p>

<p>I have three buttons with with onClick behavior. Each of these buttons calls the same method <code>launchActivity</code> but with different parameters. <code>launchActivity</code> does some IO with the variables received from the <code>onClick</code> methods and then returns an intent. I would like to be able to implement a RxKotlin/Java Flowable to handle backpressure collectively across the three onClick methods so that I can implement <code>BackpressureStrategy.DROP</code>. So if <code>onClick1</code> was initiated <code>onClick2</code> would be dropped if initated while <code>launchActivity</code> was still processing <code>onClick1</code> on the <code>io()</code> thread.</p>

<pre><code>class ActivityLauncher {
  fun onClick1() {
    val intent = launchActivity(inFile1, outFile1)
    startActivity(intent)
  }

  fun onClick2() {
    val intent = launchActivity(inFile2, outFile2)
    startActivity(intent)
  }

  fun onClick3() {
    val intent = launchActivity(inFile3, outFile3)
    startActivity(intent)
  }

  fun launchActivity(in: File, out: File): Intent {
    // do IO with in and out files and create an intent
    return intent
  }
}
</code></pre>

<p>If I was to implement this as say a Single, I'd implement the <code>onClick</code> methods somewhat like:</p>

<pre><code>fun onClick() {
  Single.fromCallable(launchActivity(inFile, outFile)
      .observeOn(scheduler.io())
      .subscribeOn(scheduler.ui())
      .subscribe { i -&gt; startActivity(i) }
}
</code></pre>

<p>But I can't figure out how to call <code>launchActivity</code> from a shared Flowable that is accessible to all three <code>onClick</code> methods while still allowing them to pass in their unique <code>inFile</code> and <code>outFile</code> variables and enforcing backpressure.</p>

<p>The basic criteria is:</p>

<ul>
<li>Ensure <code>launchActivity</code> is run on the <code>io()</code> thread</li>
<li>Pass the unique arguments from each of the <code>onClick</code> methods to <code>launchActivity</code> each time <code>onClick[#]</code> is run.</li>
<li><code>BackpressureStrategy.DROP</code> is used to ensure only the first click in a series is processed in <code>launchActivity</code></li>
<li>The resulting <code>intent</code> from <code>launchActivity</code> is passed to <code>startActivity</code></li>
</ul>

<p>How do I implement a Flowable to allow this behavior?</p>
","6275844","","472495","","2018-05-08 10:23:30","2018-05-08 10:23:30","Implement shared Flowable in RxKotlin with dynamic parameters","<android><rx-java2><rx-android><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"50358932","1","","","2018-05-15 20:46:38","","0","1149","<p>I'm using RxJava2 with Kotlin. I don't know why but I always have this error :</p>

<blockquote>
  <p>io.reactivex.exceptions.OnErrorNotImplementedException: An operation is not implemented: not implemented</p>
</blockquote>

<p>So I add to my subscriber the onError callback, but now I have this error (inside the onError) :</p>

<blockquote>
  <p>kotlin.NotImplementedError: An operation is not implemented: not implemented</p>
</blockquote>

<p>This is my code :</p>

<pre><code>override fun getOpenBar(): Observable&lt;List&lt;Bar&gt;&gt; {

    val query: ParseQuery&lt;ParseObject&gt; = ParseQuery.getQuery(""Bar"")
    query.whereEqualTo(""isOpen"",true)
    return ParseObservable.find(query).toList().map { BarMapper.map(it) }.toObservable()
}
</code></pre>

<p>In my presenter :</p>

<pre><code>override fun onAttach(view: V?) {
    super.onAttach(view)
    getView()?.printDate()
    getView()?.showProgress()
    interactor?.getBar()?.compose(schedulerProvider.ioToMainObservableScheduler())?.subscribeBy(
            onNext = {if (it.isEmpty()) getView()?.printNoResult()
            else getView()?.printBarResult(it)
                getView()?.hideProgress()},

            onError = {Log.d(""TEST"",it.toString())}
    )
}
</code></pre>

<p>How to handle correctly error ? Thanks</p>
","4880751","","","","","2018-05-15 20:46:38","RxJava2 and Kotlin : OnErrorNotImplementedException","<android><kotlin><rx-java2><rx-android><rx-kotlin2>","0","6","","","","CC BY-SA 4.0"
"50401536","1","","","2018-05-17 22:52:14","","0","131","<p>The goal of this function is to create a stream that emits values periodically until it encounters one that matches a predicate. </p>

<p>Here is some skeleton code that I've come up with:</p>

<pre><code>class Watcher&lt;T : Any&gt;(
        /**
         * Emits the data associated with the provided id
         */
        private val callable: (id: String) -&gt; T,
        /**
         * Checks if the provided value marks the observable as complete
         */
        private val predicate: (id: String, value: T) -&gt; Boolean
) {

    private val watchPool: MutableMap&lt;String, Observable&lt;T&gt;&gt; = ConcurrentHashMap()

    fun watch(id: String): Observable&lt;T&gt; {
        // reuse obesrvable if exists
        val existing = watchPool[id]
        if (existing != null)
            return existing
        val value = callable(id)
        if (predicate(id, value)) return Observable.just(value)
        // create new observable to fetch until complete,
        // then remove from the map once complete
        val observable = Observable.fromCallable&lt;T&gt; {
            callable(id)
        }.repeatWhen { /* What to put here? */ }.doOnComplete {
            watchPool.remove(id)
        }.distinctUntilChanged()
        watchPool[id] = observable
        return observable
    }

}
</code></pre>

<p>As an example, if I have the following enums:</p>

<pre><code>enum class Stage {
    CREATED, PROCESSING, DELIVERING, FINISHED
}
</code></pre>

<p>And some callable that will retrieve the right stage, I should be able to pass the callable and a predicate checking if <code>stage == FINISHED</code>, and poll until I get the <code>FINISHED</code> event.</p>

<p>The issue I have is in generating an observable when the event received is not a final event. In that case, the observable should continue to poll for events until either it receives an event matching the predicate or until it has no more subscribers.</p>

<p>This observable should:</p>

<ul>
<li>Not poll until it receives at least one subscriber</li>
<li>Poll every x seconds</li>
<li>Mark itself as complete if <code>predicate</code> returns true</li>
<li>Complete itself if it ever goes from >0 subscribers to 0 subscribers</li>
</ul>

<p>The use of watch pools is simply to ensure that two threads watching the same id will not poll twice the number of times. Removal of observables from the map is also just so it doesn't pile up. For the same reason, observables that emit just one variable are not stored for reference.</p>

<p>How do I go about adding the functionality for the points added above?
I will link to one existing <a href=""https://github.com/ReactiveX/RxJava/issues/448"" rel=""nofollow noreferrer"">RxJava Github issue</a> that I found useful, but from what I'm aware, it doesn't allow for predicates dealing with the value emitted by the callable.</p>
","4407321","","","","","2018-05-18 03:05:16","RxObservable that repeats itself until an expected value is found","<rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"50727006","1","50747806","","2018-06-06 18:14:03","","0","57","<p>I want to look for an entire list of items to be found before I complete and if that entire list isn't found, then an exception (a Timeout or custom one) is to be thrown. Like the built in Observable.timer() but instead of the test passing once the first item is emitted, I want it to require all of the items in a list to be found. </p>

<p>Here is an example. Let's say I have some test function that emits Observable&lt;FoundNumber>. It looks like this:</p>

<pre><code>var emittedList: List&lt;String?&gt; = listOf(null, ""202"", ""302"", ""400"")

data class FoundNumber(val numberId: String?)

fun scanNumbers(): Observable&lt;FoundNumber&gt; = Observable
    .intervalRange(0, 
                   emittedList.size.toLong(), 
                   0, 
                   1, 
                   TimeUnit.SECONDS).map { index -&gt; 
                     FoundNumber(emittedList[index.toInt()]) }
</code></pre>

<p>That function will then be called to get numbers that will be compared to a list of expected numbers. It doesn't matter if there are additional numbers coming from scanForNumbers that aren't in the ""target"" list. They will just be ignored. Something like this:</p>

<pre><code>val expectedNumbers = listOf(""202"", ""302"",""999"")

        scanForNumbers(expectedNumbers)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeOn(Schedulers.io())
                .subscribe { value -&gt; Log.d(TAG, ""Was returned a $value"") }
</code></pre>

<p>So, the expected numbers (202, 302, and 999) don't exactly match with the numbers that will be emitted (202, 302, and 400). So, a timeout SHOULD occur, but with the built in version of Observable.timer(), it will not time out since at least one item was observed.</p>

<p>Here is kind of what I'd like to have. Anyone know how to code this up in RxJava/RxKotlin?</p>

<pre><code>fun scanForNumbers(targets: List&lt;String&gt;): Observable&lt;FoundNumber&gt; {
  val accumulator: Pair&lt;Set&lt;Any&gt;, FoundNumber?&gt; = targets.toSet() to null
    return scanNumbers()
        .SPECIAL_TIMEOUT_FOR_LIST(5, TimeUnit.SECONDS, List)
        .scan(accumulator) { acc, next -&gt;
            val (set, previous) = acc
            val stringSet:MutableSet&lt;String&gt; = hashSetOf()

            set.forEach { stringSet.add(it.toString()) }

            val item = if (next.numberId in stringSet) {
                next
            } else null
            (set - next) to item       // return set and nullable item
        }
        .filter { Log.d(TAG, ""Filtering on ${it.second}"")
                  it.second != null }  // item not null
        .take(targets.size.toLong())         // limit to the number of items
        .map { it.second }                   // unwrap the item from the pair
        .map { FoundController(it.numberId) }  // wrap in your class
}
</code></pre>

<p>How do you code, hopefully using RxJava/Kotlin, a means to timeout on a list as mentioned?</p>
","443654","","443654","","2018-06-06 18:38:20","2018-06-07 18:20:26","How can you create a timer that works on a List in Rx?","<rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"51072877","1","","","2018-06-27 23:49:45","","0","26","<p>I tried the following:</p>

<pre><code>$ git clone https://github.com/ReactiveX/RxKotlin.git    
$ cd RxKotlin/    
$ gradle build
</code></pre>

<p>It fails with:</p>

<blockquote>
  <p>...FAILURE: Build failed with an exception.</p>
  
  <ul>
  <li><p>Where: Build file '/home/myuser/RxKotlin/build.gradle' line: 13</p></li>
  <li><p>What went wrong: A problem occurred evaluating root project 'rxkotlin'.</p>
  
  <blockquote>
    <p>org/gradle/api/internal/project/AbstractProject</p>
  </blockquote></li>
  </ul>
</blockquote>
","1988515","","","","","2018-06-28 00:14:16","RxKotlin repo gradle build compilation fails with gradle 4.7 (JDK 1.8)","<kotlin><rx-kotlin><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"51110189","1","51110389","","2018-06-29 22:37:37","","1","105","<p>I've got an observable: <code>Observable.create&lt;Boolean&gt; {emitter = it}</code>, to which I push some values. I want it to publish a 'false' value, as soon as some specific time period has passed without any value being pushed to that emitter.</p>

<p>How is that possible with RxJava/Kotlin 2?</p>
","2728815","","","","","2018-06-30 15:02:20","Emit value if specific time has passed after last item","<java><kotlin><rx-java2><rx-android><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"51185759","1","51186490","","2018-07-05 07:39:56","","3","3527","<p>I have code that does blocking operation in while loop (downloads some data from a server). Client does not know how many items are going to be returned in each step. Loop breaks when N items are downloaded.</p>

<pre><code>val n = 10
val list = ArrayList&lt;T&gt;()

while (list.size &lt; n) {
    val lastItemId = list.last()?.id ?: 0
    val items = downloadItems(lastItemId)
    list.addAll(items)
}
</code></pre>

<p><code>downloadItems</code> performs blocking HTTP call and returns list. Now let's assume <code>downloadItems</code> changes and new return type is <code>Observable&lt;Item&gt;</code>. How could I change the code to use RxJava without performing something like <code>blockingGet</code>?</p>
","1740335","","1740335","","2018-07-05 16:54:07","2018-07-05 18:24:13","Converting loop with condition into RxJava stream","<android><rx-java><rx-java2><rx-kotlin><rx-kotlin2>","2","0","1","","","CC BY-SA 4.0"
"51280700","1","51281307","","2018-07-11 08:28:26","","0","1323","<p>I have a method that returns an Observable like this:</p>

<pre><code>open fun get(): Observable&lt;Response&gt; {

    return if (condition)
        getDataFromApi()
    else
        getDataFromDb()

}
</code></pre>

<p>and is subscribed as followed:</p>

<pre><code>                get()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(/*a object of class extending DefaultObserver*/)
</code></pre>

<p>I am facing this issue when getDataFromDb() is called and after a while getDataFromApi() is called as per condition. For first call it works fine but on second call onNext is called more then one time with the old data response from getDataFromDb(). Please let me know what I am doing wrong. I am a bit new to RxJava.</p>
","994926","","","","","2018-07-11 08:59:22","RxJava2 onNext() called multiple times?","<android><kotlin><rx-java2><rx-kotlin2>","1","3","1","","","CC BY-SA 4.0"
"51330784","1","51331375","","2018-07-13 18:13:27","","0","292","<p>Is any way to create an RxJava2 <code>Observable</code> to notify state changes? like:</p>

<pre><code>private var internalState = ""state1""
val state: Observable&lt;String&gt; = Observable(...)
...
fun updateState(newState: String) { ... } // !!! attention: I need to notify all subscribers about this new state
</code></pre>

<p>then use it every where like:</p>

<pre><code>// observe on state
state.subscribe(...)
</code></pre>

<p>this subscription must be called every state updates</p>
","1803735","","","","","2018-07-13 19:03:01","Rx Kotlin/Java Observable on state","<java><android><kotlin><rx-java2><rx-kotlin2>","1","1","","","","CC BY-SA 4.0"
"51403135","1","","","2018-07-18 13:22:04","","0","221","<p>I'm new to RxJava and am having a hard time with handling error cases. The application is in Kotlin but it probably won't make much of a difference. The scenario is basically user authentication and then performing an action but if the user is not authorized/has a bad auth token I generate an exception and want to cease processing. Right now I have my function that checks tokens and it looks like this. </p>

<pre><code>fun checkAuthority(authToken: AuthToken, requiredAuthority: Authority): Completable =
    authorityRepository.getAuthorities(authToken)
        .filter { it == requiredAuthority }
        .switchIfEmpty { subscriber -&gt; subscriber.onError(UnauthorizedException(""must have '$requiredAuthority' authority"")) }
        .ignoreElements()
</code></pre>

<p>Then I have a function that looks a bit like this that checks permissions then is supposed to do an operation if they are authorized. </p>

<pre><code>fun create(model: EntityCreate, authToken: AuthToken): Single&lt;Entity&gt; =
    checkAuthority(authToken, CAN_WRITE_ENTITY)
        .andThen(entityRepository.insert(model, OffsetDateTime.now(clock)))
</code></pre>

<p>What I want is that if the UnauthorizedException is generated to not execute the andThen. </p>

<p>Perhaps there is a gap in my understanding of the documentation but I've for instance tried putting <code>doOnError</code> to throw the Throwable before the <code>andThen</code>. I've tried <code>onErrorComplete</code> in the same place. No matter what I do the <code>andThen</code> eventually executes.</p>

<p>What would the pattern look like to abandon the <code>Completable</code> chain should the <code>subscriber.onError</code> line executes? </p>
","674989","","","","","2018-07-18 13:22:04","RxJava / RxKotlin - andThen still executing if previous step fails. How to stop?","<kotlin><rx-java2><rx-kotlin2>","0","4","","","","CC BY-SA 4.0"
"51499934","1","51502518","","2018-07-24 13:30:30","","1","130","<p>I have a problem with RxJava. 
I have a <code>getAll()</code> method, it's returning with a list. It's serves data from Room database.</p>

<pre><code>@Query(""SELECT * from decks ORDER BY id ASC"")
fun getAll(): Flowable&lt;List&lt;DeckEntity&gt;&gt;
</code></pre>

<p><code>DeckEntity</code> have an <code>id</code> and a <code>name</code> field.</p>

<p>I created an another class called it <code>PrepareItem</code>, because I want to box it with more parameter. (It will be an <code>Adapter</code> model) Check it:</p>

<pre><code>data class PrepareItem (
    var deckEntity: DeckEntity,
    var countsOfCards: Int
)
</code></pre>

<p>So, I want to call the <code>getAll()</code> and I want to map it to PrepareItem. It's working yet.</p>

<pre><code>deckRepository.getAll()
                .map {
                    it.map {
                        PrepareItem(it,0)
                    }
                }
</code></pre>

<p>But, there is the <code>countsOfCards is equal 0</code>. I want to make an another repository call, to get the value, and set it. Important! Every value need a single call to repository. So if I have 5 item, than I need to wait until 5 another call finished.</p>

<p>I tried, but I get confused.
(CODE UPDATED)</p>

<pre><code>fun mapper(item: DeckEntity) : Single&lt;PrepareItem&gt; {
    return cardRepository.getDueDatedCardsFromDeck(deckId = item.id!! /*TODO !!*/)
            .map {
                PrepareItem(item, it.size)
            }
}

val call = deckRepository.getAll()
                .flatMapIterable { item-&gt;item }
                .flatMapSingle {
                    mapper(it)
                }.toList()
                .toObservable()
                ...
</code></pre>

<p>The <code>onError</code> or <code>onComplete</code> never called. Why?</p>

<p>Anyone have good idea to How to do it? I want it keep out from repository.
Thank you!</p>

<p><strong>UPDATE:</strong></p>

<p><strong>Solution:</strong></p>

<p>Create a new class</p>

<pre><code>class DeckWithCards {

    @Embedded
    lateinit var deckEntity: DeckEntity

    @Relation(
            entity = CardEntity::class,
            entityColumn = ""deckId"",
            parentColumn = ""id"")
    lateinit var cards: List&lt;CardEntity&gt;

}
</code></pre>

<p>Add new fun to <code>DeckDao</code></p>

<pre><code>@Query(""SELECT * from decks ORDER BY id ASC"")
fun getAllWithCards(): Flowable&lt;List&lt;DeckWithCards&gt;&gt;
</code></pre>

<p>Thats all its works! Thank you for the answer. It helped me a lot !</p>
","5269276","","5269276","","2018-07-24 20:03:10","2018-08-15 11:44:53","RxJava make a call for every single list item","<android><kotlin><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"51667657","1","51671047","","2018-08-03 07:44:25","","0","2392","<p>I am using Room with RxJava/RxKotlin Flowable following <a href=""https://medium.com/google-developers/room-rxjava-acb0cd4f3757"" rel=""nofollow noreferrer"">this</a> article. I got it running but the got issue using it with ViewPager with 3 fragments.</p>

<p>I will walk you through my code little bit:</p>

<p>I have a viewpager with tab layout and three fragments(A, B, and favorites). First two fragments contain lists of data which can be added to favorite.</p>

<p>In favorite fragment, I am using Flowable to listen to changes made by A and B and update list accordingly. But what happens is when an item is made favorite in A and B, app crashes because the Flowable subscription in favorite fragment runs even when the fragment is not in foreground.</p>

<p>What I want is to be able to stop the subscription when the fragment is not in foreground and start in foreground.</p>

<p>I tried to stop it in onPause method of favorite fragment but flowable has no unsubscribe or dispose method.</p>

<p>My code is </p>

<pre><code>dbRepository?.getAllImportant()?.subscribeOn(Schedulers.io())
            ?.observeOn(AndroidSchedulers.mainThread())
            ?.subscribe(getFlowableSubscriber())
</code></pre>
","10009226","","10009226","","2018-08-03 10:36:36","2021-06-17 14:10:13","How to unsubscribe from Flowable in RxKotlin/RxJava?","<android-fragments><rx-java><rx-java2><rx-android><rx-kotlin2>","4","2","","","","CC BY-SA 4.0"
"51786847","1","51822996","","2018-08-10 12:44:07","","0","216","<p>I have an object that generates different strings in the random moments of time, and i need to sudscribe to this generator to take these strings and provide them to ui (maybe it will be multiple subscribers in different activities).
Suppose, i got the following code: </p>

<p>generator:</p>

<pre><code>class Generator {

    private var stringToGenerate = """"

    var subject: BehaviorSubject&lt;String&gt; = BehaviorSubject.create&lt;String&gt;()

    init {
        //seems like these instructions are skipped
        subject
                .subscribeOn(AndroidSchedulers.mainThread())
                .doOnNext { t -&gt; Log.i(""subject doOnNext"", Thread.currentThread().name + "" "" + Thread.currentThread().id) }
                .observeOn(AndroidSchedulers.mainThread())
                .map { _ -&gt; Log.i(""subject map"", Thread.currentThread().name + "" "" + Thread.currentThread().id) }

        //imitation of async creating of strings in separate thread
        timer(""timerThread"", false, 2000L, 2000L) {
            stringToGenerate = System.currentTimeMillis().toString()
            subject.onNext(stringToGenerate)
        }
    }
}
</code></pre>

<p>One of the activities that must consume generated strings:</p>

<pre><code>class TestActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(R.layout.activity_test)

        val wrongThreadObserver = object : Observer&lt;String&gt; {
            override fun onComplete() {
            }

            override fun onSubscribe(d: Disposable) {
            }

            override fun onNext(t: String) {
                Log.i(""wrongThreadObserver"", Thread.currentThread().name + "" "" + Thread.currentThread().id)
            }

            override fun onError(e: Throwable) {
            }
        }

        val generator = Generator()
        generator.subject.subscribe(wrongThreadObserver)

        //for correct work illustration
        val correctThreadObserver = object : Observer&lt;String&gt; {
            override fun onComplete() {
            }

            override fun onSubscribe(d: Disposable) {
            }

            override fun onNext(t: String) {
                Log.i(""correctThreadObserver"", Thread.currentThread().name + "" "" + Thread.currentThread().id)
            }

            override fun onError(e: Throwable) {
            }
        }

        val mainThreadSubject = BehaviorSubject.create&lt;String&gt;()
        mainThreadSubject
                .doOnNext { obj -&gt; Log.i(""correctThread doOnNext"", Thread.currentThread().name + "" "" + Thread.currentThread().id) }
                .subscribeOn(Schedulers.io())
                .observeOn(Schedulers.newThread())
                .subscribe(correctThreadObserver)
        mainThreadSubject.onNext(""test thread"")
        val handler = Handler()
        handler.postDelayed({ mainThreadSubject.onNext(""test thread 2"") }, 1000)
        handler.postDelayed({ mainThreadSubject.onNext(""test thread 3"") }, 2000)
    }
}
</code></pre>

<p>In this case <strong>correctThreadObserver</strong>, created just in activity, works fine, but <strong>wrongThreadObserver</strong> keeps work in timer thread, it seems like it ignoring instructions <strong>subscribeOn, ObserveOn, doOnNext</strong> in Generator, no matter where these instuctions called - in init, in timer thread, in activity by getting object to it from generator - <strong>wrongThreadObserver</strong> still work in timer thread. 
So log is:</p>

<blockquote>
  <p><em>I/correctThread doOnNext: main 2</em></p>
  
  <p><em>I/correctThreadObserver: RxNewThreadScheduler-1 941</em></p>
  
  <p><em>I/correctThread doOnNext: main 2</em></p>
  
  <p><em>I/correctThreadObserver: RxNewThreadScheduler-1 941</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
  
  <p><em>I/correctThread doOnNext: main 2</em></p>
  
  <p><em>I/correctThreadObserver: RxNewThreadScheduler-1 941</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
  
  <p><em>I/wrongThreadObserver: timerThread 937</em></p>
</blockquote>

<p>No <code>doOnNext</code> and no main thread for <code>wrongThreadObserver</code>
What i do wrong?</p>
","10208467","","9389285","","2018-08-10 12:58:15","2018-08-13 12:59:37","RxKotlin - Wrong subscribeOn, observeOn thread changing for Subject out of Activity?","<android><multithreading><kotlin-android-extensions><rx-kotlin><rx-kotlin2>","1","1","","","","CC BY-SA 4.0"
"52140160","1","","","2018-09-02 18:57:33","","0","221","<p>I have an Async call, in which callback listener I've put the emitter.onNext(). This async call is inside a for-in (I know the list size). I would like call onComplete() when last element has been emitted in onNext().</p>

<pre><code>for (anItem in itemList) {

     eventsQuery.get()
           .addOnCompleteListener { task -&gt;
               if (task.isComplete) {

                    emitter.onNext(myItemFromTask)

                    if(count == itemList.size){
                         emitter.onComplete()
                    }
                }
           }
 }
</code></pre>

<p>The count, as it is a async call, is not bein incremented in the proper way and the onComplete() is never called.</p>

<p>What is the proper way to handle with this situation? I need the onComplete to show the view and remove the loading/progress bar.</p>
","9697465","","9697465","","2018-09-02 22:02:05","2018-09-02 22:02:05","How to call emitter.onComplete() when emitter.onNext() are on async loop","<android><kotlin><reactive-programming><rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"52190121","1","","","2018-09-05 16:55:30","","0","2314","<p>I am new to the Rx world so please bear with me.</p>

<p>My code is in Kotlin but a Java code will help also.</p>

<p>I have 2 methods, one of them loads tasks from the database, if there are tasks, I want to send them to the server.</p>

<pre><code>fun getListFromDb(): Single&lt;List&lt;TaskEntity&gt;&gt; {
    return taskEntityDao.getAll()
}

 fun syncTasks(localTasks: TaskSyncRequest): Observable&lt;ApiResponse&lt;List&lt;TaskEntity&gt;&gt;&gt; {
    return taskServices.syncTasks(localTasks)
}
</code></pre>

<p>I know I can use flatmap to chain observables, but just couldn't get it working between Single and Observables.</p>
","10216356","","","","","2018-09-28 23:32:37","How to chain an Observable with a Single in RxJava?","<rx-java><rx-java2><flatmap><rx-kotlin><rx-kotlin2>","1","4","","","","CC BY-SA 4.0"
"52198674","1","","","2018-09-06 07:26:51","","0","85","<p>Having read the article <a href=""http://hannesdorfmann.com/android/mosby3-mvi-1"" rel=""nofollow noreferrer"">MODEL-VIEW-INTENT</a> written by Hannes Dorfmann, I designed my app using the MVI pattern.</p>

<p>This is my design chart of my application.<a href=""https://i.stack.imgur.com/bg0Nz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bg0Nz.png"" alt=""design chart""></a></p>

<p>I have two reusable fragments, BarFragment and ContentFragment. And my activity is made up of those two fragments.</p>

<p>The data flow is:</p>

<p>Step 1: The changeKeywordIntent() method gathers user's input from the search view in BarFragment.</p>

<pre><code>override fun changeKeywordIntent(): Observable&lt;String?&gt; {
    return RxSearchView.queryTextChangeEvents(view!!.search)
            .filter { it.isSubmitted }
            .map { it.queryText().toString() }
}
</code></pre>

<p>Step 2: To reuse the fragment, the intent is not subscribed by render() method directly. </p>

<p>On receiving the intent, the presenter emit an PartialViewState.ChangeKeyword(keyword) object to the partialViewStateSubject first. This partial view state will be reduced to ViewState and then, consumed by all the MvpView's render() method. I.E., the views will show that keyword at a proper position. </p>

<p>This is like a broadcast. </p>

<p>After the PartialViewState.ChangeKeyword(keyword) object has been rendered, the presenter calls a business logic and then emit a PartialViewState.ContentFirstPage(response.body()) start with a PartialViewState.Loading() object. </p>

<p>My question is in this step, Call which RxJava2 method can I ensure that before the second observable emit, the first observable is subscribed? And which method to create the second observable?</p>

<pre><code>intent(EmployeesBarView::changeKeywordIntent).flatMap { keyword -&gt;
            Observable.concat(
                    Observable.just(EmployeesScenarioPartialViewState.ChangeKeyword(keyword) as EmployeesScenarioPartialViewState),
                    Observable.someMethod {
                    // to ensure viewStateSubject.value is the value after PartialViewState.ChangeKeyword(keyword) has been subscribed, I don't know which method I should call
                        Observable.just(viewStateSubject.value).flatMap { viewState -&gt;
                            EmployeeStub.getInstance(activity.baseContext).query(toFilterLogicExpr(viewState.keyword), toOrderByListExpr(viewState.orderBy), toRangeExpr(0, viewState.pageSize), null).toObservable()
                                    .map { response -&gt; EmployeesScenarioPartialViewState.ContentFirstPage(response.body()) as EmployeesScenarioPartialViewState }
                                    .startWith(EmployeesScenarioPartialViewState.Loading())
                                    .onErrorReturn { error -&gt; EmployeesScenarioPartialViewState.Error(error.message) }
                        }
                    })
        }.subscribe(partialViewStateSubject::onNext).addTo(compositeDisposable)
</code></pre>

<p>Step 3: When a PartialViewState object is received, reduce it to a ViewState object and push the ViewState object to viewStateSubject. Key code is</p>

<pre><code>employeesScenarioViewStatePartialSubject
                .scan(initialEmployeesScenarioViewState(), ::reduceEmployeesScenarioViewState)
                .subscribe(employeesScenarioViewStateSubject::onNext)
                .addTo(compositeDisposable)
</code></pre>

<p>Step 4: All presenters subscribe viewStateSubject in bindIntents() method</p>

<pre><code>subscribeViewState(viewStateSubject.observeOn(AndroidSchedulers.mainThread())) { obj, state -&gt; obj.render(state) }
</code></pre>

<p>Step 5: render the viewState object, the code could be skipped in this question.</p>

<p>So my question is in step 2, could anyone help me with that code with RxJava2? Thank you.</p>
","7725586","","7725586","","2018-09-06 07:41:36","2018-12-19 03:56:33","How can I ensure the first Observable is subscribed before the second one emits in RxJava2?","<rx-java2><mosby><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"52358275","1","52358500","","2018-09-16 20:51:49","","0","3362","<p>This question is related to Android and life-cycles.
Previously, I would have a series of subjects and subscribe to them on creation.</p>

<p>Upon destruction, I would mark all the subjects as complete, assuming that it disposes all subscribers.</p>

<p>With Android Studio 3.1, I get warnings for any subscriber that ""isn't used"". The solution is to add them to a ""completable disposable"" that I then dispose upon destruction.</p>

<p>Is ""composite disposable"" all I need to properly cancel requests upon destruction? Did my previous way of marking subjects as complete do anything and is it necessary in this case?</p>

<p>As a code example:</p>

<pre><code>val observable: PublishSubject&lt;Int&gt; = PublishSubject.create()
val disposable = observable.subscribe { /* subscription */ }

fun onDestroy() {
    observable.onComplete() // is this line necessary or helpful?
    disposable.dispose()
}
</code></pre>
","4407321","","9530467","","2018-09-17 04:38:22","2018-09-17 04:38:22","Disposing of observables","<android><rx-java2><rx-kotlin2>","2","2","","","","CC BY-SA 4.0"
"52544735","1","","","2018-09-27 20:33:27","","2","995","<p>I have a data provider that has an <code>Observable&lt;Int&gt;</code> as part of the public API. My class under test maps this into a <code>Observable&lt;String&gt;</code>.</p>

<p>How do I create a mock so that it can send out different values on the data provider's observable?</p>

<p>I can do it using a <code>Fake</code> object, but that is a lot of work that I don't think is necessary with MockK.</p>

<p>Simplified code:</p>

<pre><code>interface DataProvider {
    val numberData:Observable&lt;Int&gt;
}

class FakeDataProvider():DataProvider {

    private  val _numberData = BehaviorSubject.createDefault(0)
    override val  numberData = _numberData.hide()

    // Note: the internals of this class cause the _numberData changes.
    // I can use this method to fake the changes for this fake object,
    // but the real class doesn't have this method.

    fun fakeNewNumber( newNumber:Int ) {
        _numberData.onNext( newNumber )
    }
}

interface ClassUnderTest {
    val stringData:Observable&lt;String&gt;

}
class MyClassUnderTest( dataProvider: DataProvider ):ClassUnderTest {

    override val stringData = dataProvider.numberData.map { ""string = "" + it.toString() }
}

class MockKTests {

    @Test fun testUsingFakeDataProvider() {

        val fakeDataProvider        = FakeDataProvider()
        val classUnderTest          = MyClassUnderTest( fakeDataProvider )

        val stringDataTestObserver  = TestObserver&lt;String&gt;()

        classUnderTest.stringData.subscribe( stringDataTestObserver )

        fakeDataProvider.fakeNewNumber( 1 )
        fakeDataProvider.fakeNewNumber( 2 )
        fakeDataProvider.fakeNewNumber( 3 )

        // Note we are expecting the initial value of 0 to also come through
        stringDataTestObserver.assertValuesOnly( ""string = 0"", ""string = 1"",""string = 2"",""string = 3"" )
    }

    // How do you write the mock to trigger the dataProvider observable?
    @Test fun testUsingMockDataProvider() {
        val mockDataProvider        = mockk&lt;DataProvider&gt;()

//        every { ... what goes here ... } just Runs

        val classUnderTest          = MyClassUnderTest( mockDataProvider )

        val stringDataTestObserver  = TestObserver&lt;String&gt;()

        classUnderTest.stringData.subscribe( stringDataTestObserver )


        // Note we are expecting the initial value of 0 to also come through
        stringDataTestObserver.assertValuesOnly( ""string = 0"", ""string = 1"",""string = 2"",""string = 3"" )
    }
}
</code></pre>
","5135551","","","","","2018-11-15 12:33:03","How to use MockK to mock an observable","<rx-kotlin><rx-kotlin2><mockk>","1","0","","","","CC BY-SA 4.0"
"52642493","1","","","2018-10-04 08:39:30","","1","59","<p>Probably an rx newbee question.</p>

<p>If I have two rx streams, which have some common parts, is there a possibility to extract and to reuse them?</p>

<p>Here is pseudo code example:</p>

<pre><code>someManager.getInfo(id) returns a Single&lt;SometInfo&gt;
</code></pre>

<p>This fun takes an id and should return just a single with status</p>

<pre><code>fun getStatus(id: String): Single&lt;Status&gt; =
    someManager.getInfo(id)
        .flattenAsObservable { it.items }
        .map { getSomeProp(it) } // from here
        .toList()
        .map { getStatus(it) }
        .doOnSuccess { getStatusRelay(id).accept(it) } // until here it's common
</code></pre>

<p>and this one doesn't take an id but already an object and should check if a status is ok</p>

<pre><code>fun isStatusOk(info: SomeInfo): Single&lt;Boolean&gt; =
    Observable.fromIterable(info.items)
        .map { getSomeProp(it) } // from here
        .toList()
        .map { getStatus(it) }
        .doOnSuccess { getStatusRelay(id).accept(it) } // until here it's common
        .map { it == Status.OK }
</code></pre>

<p>Thank you in advance</p>
","408780","","408780","","2018-10-04 08:53:42","2018-10-22 10:22:01","Reuse part of RxJava stream","<rx-java><rx-java2><rx-kotlin><rx-kotlin2>","2","3","","","","CC BY-SA 4.0"
"53034295","1","","","2018-10-28 17:32:42","","0","1509","<p>Unfortunately, I can't understand how to check Observable.</p>

<p>Depending on connection - I want to get my data from network or DB.</p>

<p>I have a method that checks network connection:</p>

<pre><code>companion object {
        fun isConnected() : Observable&lt;Boolean&gt; {
            val connectivityManager = MyApplication.applicationContext().getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
            val activeNetwork = connectivityManager.activeNetworkInfo
            val isConnectedException = activeNetwork != null &amp;&amp; activeNetwork.isConnectedOrConnecting
            return Observable.just(isConnectedException)
        }
    }
</code></pre>

<p>So if it's true I want to call my network method:</p>

<pre><code>override fun searchGroups(q: String): Observable&lt;List&lt;Group&gt;&gt; {
        return groupApi.searchGroups(GroupSearchRequest(q).toMap())
                .flatMap { groupResponse -&gt; Observable.just(groupResponse.response.items) }
                .doOnNext{ groupList -&gt; groupRepository.insertGroups(groupList)}
    }
</code></pre>

<p>and in the other case I want to call DB method:</p>

<pre><code>override fun getGroupsFromDB(q: String): Observable&lt;List&lt;Group&gt;&gt; {
        return groupRepository.findByName(q)
    }
</code></pre>

<p>Here is my try to do this, but I think there is problem because of nullable interactor, but still don't know what to do.</p>

<pre><code>compositeDisposable.add(
                NetworkManager.isConnected()
                        .flatMap {
                             if (it) {
                                interactor?.searchGroups(q)
                            } else {
                                interactor?.getGroupsFromDB(q)
                            }
                        }
    }
    )
</code></pre>

<p><a href=""https://i.stack.imgur.com/xpHpD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xpHpD.png"" alt=""enter image description here""></a></p>

<p>Could anybody please help me with that ?</p>

<p><strong>UPDATE</strong></p>

<p>So the problem was in nullable object <code>interactor</code>.</p>

<p>Could anybody please suggest the better way to not using <code>!!</code> for <code>interactor</code> object?</p>

<p><a href=""https://i.stack.imgur.com/n6mC6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/n6mC6.png"" alt=""enter image description here""></a></p>
","6812826","","1149924","","2018-11-02 10:45:15","2018-11-02 10:45:15","How to check Observable<Boolean>?","<kotlin><rx-java2><rx-kotlin2>","0","4","","","","CC BY-SA 4.0"
"53181063","1","","","2018-11-06 22:30:18","","0","121","<p>I am calling apis using retrofit and rxkotlin. But when I start fragment the app gets crash without any notification or does not show any error msg in the studio logcat. Here is the code.
From here I am call the apis interface</p>

<pre><code>try {
        if (disposable == null) {

            Log.e(""disposable"",""reached"")

            disposable = api.getUsers(api_key,
                    ""json"",
                    ""1"",
                    ""flickr.interestingness.getList"")
                    .subscribeOn(Schedulers.io())
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe (
                            {
                                data: FlickrPhoto? -&gt; Log.e(""flickr photo"",data!!.photo?.get(0)?.secret)
                            }

                    )

            Log.e(""disposable1"",""reached"")
        }
    }
    catch (e: Exception){
        Log.e(""flickr fragment"",e.toString())
    }
</code></pre>

<p>Here is the api interface code :</p>

<pre><code>interface API {

@GET(""services/rest"")
fun getUsers(@Query(""format"") format : String,
             @Query(""api_key"") api_key : String,
             @Query(""nojsoncallback"") nojsoncallback : String,
             @Query(""method"") method : String
) : Observable&lt;FlickrPhoto&gt;

companion object{
    fun createView():API{

        Log.e(""apis"",""creatview"")
        try {
            val retrofit = Retrofit.Builder()
                    .baseUrl(""https://api.flickr.com/"")
                    .addCallAdapterFactory(
                            RxJava2CallAdapterFactory.create())
                    .addConverterFactory(
                            GsonConverterFactory.create())
                    .build()


            Log.e(""retrofit"",retrofit.toString())

            return retrofit.create(API::class.java)
        }
        catch (e: Exception){
            Log.e(""api exception"",e.message)
        }
        Log.e(""apis"",""creatview retrofit null"")
        return null!!
    }

}
}
</code></pre>

<p>Here is the logcat:</p>

<pre><code>11-07 03:47:07.527 11627-11627/com.redvelvet.abhi.imagesmapling E/disposable: reached
11-07 03:47:07.529 11627-11627/com.redvelvet.abhi.imagesmapling E/apis: creatview
11-07 03:47:07.620 11627-11627/com.redvelvet.abhi.imagesmapling E/retrofit: retrofit2.Retrofit@ec11d24
11-07 03:47:07.751 11627-11627/com.redvelvet.abhi.imagesmapling E/disposable1: reached
</code></pre>
","7258452","","7258452","","2018-11-06 22:38:12","2018-11-06 22:38:12","App is crashing without showing any error?","<android-studio><retrofit2><rx-android><rx-kotlin2>","0","3","","","","CC BY-SA 4.0"
"53456441","1","53461407","","2018-11-24 08:23:26","","2","334","<p>I have a scenario where we i have an emmiter which constantly emits data like this</p>

<pre><code>fun subscribeForEvents(): Flowable&lt;InkChannel&gt; {
    return Flowable.create&lt;InkChannel&gt;({
        if (inkDevice.availableDeviceServices.contains(DeviceServiceType.EVENT_DEVICE_SERVICE)) {
            (inkDevice.getDeviceService(DeviceServiceType.EVENT_DEVICE_SERVICE) as EventDeviceService).subscribe(object : EventCallback {
                override fun onUserActionExpected(p0: UserAction?) {
                    it.onNext(InkChannel.UserActionEvent(p0))
                }

                override fun onEvent(p0: InkDeviceEvent?, p1: Any?) {
                    it.onNext(InkChannel.InkEvents&lt;Any&gt;(p0, p1))
                }

                override fun onUserActionCompleted(p0: UserAction?, p1: Boolean) {

                }
            }

            )
        }
    }, BackpressureStrategy.BUFFER).share()

}
</code></pre>

<p>now i have a service which i start on application launch and listen to it</p>

<pre><code>  inkDeviceBus.subscribeForEvents()
                .filter { it -&gt; (it as InkChannel.InkEvents&lt;*&gt;).event == InkDeviceEvent.STATUS_CHANGED }
                .map { it -&gt; it as InkChannel.InkEvents&lt;*&gt; }
                .map { it -&gt; it.value.toString() }
                .filter { value -&gt; value == ""CONNECTED"" || value == ""DISCONNECTED"" }
                .map { it -&gt; it == ""CONNECTED"" }
                .subscribeBy { b -&gt;
                    if (b) stopSelf()
                }
</code></pre>

<p>I have another activity MainActivity which is called upon launch where i observe the same event.
Now the issue is only the listener in the service gets the events and the activity is not receiving any events. </p>

<p>Now when i remove the listener form the service then activity starts receiving events. I have used the operator <strong>share</strong> for sharing the observable but it doesn't seem to work</p>
","6048312","","","","","2018-11-24 18:57:38","share() operator not working for Observable in Rxjava","<android><rx-java2><rx-android><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"53653297","1","53663648","","2018-12-06 14:12:15","","1","617","<p>I'm just starting using RxJava and I'm struggling to figure out how to use observables the right way.</p>

<p>Down below I have a pager and I'd like to call a web service on page scroll avoiding to many useless calls.</p>

<p>So I found that 'debounce' operator is what I am looking for but in my case it's not working and the web service is called everytime.. </p>

<pre><code>v.pager.addOnScrollListener(object : RecyclerView.OnScrollListener() {

    override fun onScrollStateChanged(recyclerView: RecyclerView?, newState: Int) {
        super.onScrollStateChanged(recyclerView, newState)
        if (newState == RecyclerView.SCROLL_STATE_IDLE) {

            val itemPosition : Int = layoutManager.findFirstCompletelyVisibleItemPosition();

            Observable.just(itemPosition).debounce(1500, TimeUnit.MILLISECONDS).map {
                  retrieveUserDetail(userList[itemPosition])
            }.observeOn(AndroidSchedulers.mainThread()).subscribe()

         }
    }
})
</code></pre>

<p>What's wrong with this code?</p>
","517354","","2649012","","2018-12-06 14:25:30","2018-12-07 05:15:24","Android Rx debounce operator","<android><android-viewpager><rx-java2><debounce><rx-kotlin2>","1","6","","","","CC BY-SA 4.0"
"53693673","1","53693797","","2018-12-09 15:09:24","","0","85","<p>I want <code>enable/disable</code> button when code &amp; name is not empty.</p>

<p><strong>My code:</strong></p>

<pre><code>btnAddItem.isEnabled = false

    val codeIsValid = RxTextView.textChanges(txvCode)
        .debounce(350, TimeUnit.MILLISECONDS)
        .map { code -&gt;
            code.isNotEmpty()
        }

    val nameIsValid = RxTextView.textChanges(edtName)
        .debounce(350, TimeUnit.MILLISECONDS)
        .map { name -&gt;
            name.isNotEmpty()
        }

    disposableEnableButtonSave = Observables.combineLatest(codeIsValid, nameIsValid) 
        { b1, b2 -&gt; b1 &amp;&amp; b2 }
        .subscribe {
            if (btnAddItem.isEnabled != it){
                btnAddItem.isEnabled = it //crash here.
            }
        }
</code></pre>

<p>But it error when run:</p>

<p><strong>Logcat:</strong></p>

<blockquote>
  <p>io.reactivex.exceptions.OnErrorNotImplementedException: Animators may only be run on Looper threads<br>
  android.util.AndroidRuntimeException: Animators may only be run on <code>Looper</code> threads</p>
</blockquote>

<p>code crash is <code>enable/disable</code> button.</p>

<pre><code>btnAddItem.isEnabled = it
</code></pre>
","1559039","","5191371","","2018-12-10 07:07:23","2018-12-10 07:07:23","Android rxKotlin crash in subcribe combineLatest","<android><kotlin><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"54028855","1","54029853","","2019-01-03 19:47:36","","1","923","<p>I try to write a transformation function which is used with <code>compose()</code> in order to reduce boilerplate code. It's pretty simple like this:</p>

<pre><code>    fun &lt;R&gt; withSchedulers(): ObservableTransformer&lt;R, R&gt; {
        return ObservableTransformer {
            it.subscribeOn(Schedulers.io())
              .observeOn(AndroidSchedulers.mainThread())
        }
    }
</code></pre>

<p>So everytime I want to subscribe to anything on <code>ioThread</code> and listen the result on <code>mainThread</code>, it's just few lines of code:</p>

<pre><code>    Observable.just(1)
        .compose(MyUtilClass.withSchedulers())
        .subscribe()
</code></pre>

<p>But there isn't <code>Observable</code> only, but we also have <code>Single</code>, <code>Completable</code>, <code>Maybe</code> and <code>Flowable</code>. So every time I want to combine them with my <code>withSchedulers()</code> function, I have to transform it into the new type (which I don't expect). </p>

<p>For example,</p>

<pre><code>Completable.fromAction { 
        Log.d(""nhp"", ""hello world"")
    }//.compose(MyUtilClass.withSchedulers()) &lt;-- This is not compiled
            .toObservable() &lt;--- I have to transform it into Observable
            .compose(MyUtilClass.withSchedulers())
            .subscribe()
</code></pre>

<p>So my question is, is there any way to write the above function to use with <code>compose()</code> for any kind of <code>Observable</code> (<code>Single</code>, <code>Completable</code>,...) ? Or we have to write different functions which use <code>ObservableTransformer</code>, <code>SingleTransformer</code>, ....?</p>
","5460066","","","","","2019-01-03 21:10:18","Customize ObservableTransformer with RxJav/RxKotlin2 when using with compose()","<java><android><rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"54148150","1","","","2019-01-11 14:08:06","","0","258","<p>onNext method of publishSubject is calling continuously(in uneven time, approximately in 1 milliseconds)
And requirement is to emit these item at every 1 second and data should not loss means should emit each item.</p>

<pre><code>    publishSubject.onNext(""Data1"");
    publishSubject.onNext(""Data2"");
    publishSubject.onNext(""Data3"");
    publishSubject.onNext(""Data4"");
    publishSubject.onNext(""Data5"");
    publishSubject.onNext(""Data6"");
    publishSubject.onNext(""Data7"");
</code></pre>

<p>and so on...
See Code Structure for Reference:</p>

<pre><code>var publishSubject = PublishSubject.create&lt;String&gt;()
publishSubject.onNext(stateObject) // Executing at every milliseconds...


publishSubject
        /* Business Logic Required Here ?? */
        .subscribeOn(Schedulers.computation())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe {
            // Should execute at every 1 second
        }
</code></pre>

<p>Please help, Thanks in Advance,</p>
","4051419","","","","","2019-01-25 09:30:22","How can we buffer items in each milliseconds and stream each item at constant time interval","<android><kotlin><rx-java><rx-java2><rx-kotlin2>","2","7","","","","CC BY-SA 4.0"
"54225878","1","","","2019-01-16 21:45:39","","0","412","<p>I have two different Observables which behaves as</p>

<p>Observable one behavior -> This will get created and one DisposableObserver will get subscribed to it and reacts to items emitted by the Observable One. This will be running continuously until app is closed.</p>

<p>Observable two behavior -> This will get created and get subscribed to a different Observer in a different time and after subscription this should emit values based on values emitted by Observable one after Observable two is subscribed. Once job is done Observable two subscription will be disposed but Observable one should continue.</p>

<p>How can I make second Observable emit values based on Observable one emitted values and dispose it after complete ?</p>
","3416215","","3416215","","2019-01-16 23:55:51","2019-01-17 14:03:55","One Observable should emit items based on another Observable emitted items and both Observables are not connected","<rx-java><rx-java2><rx-kotlin2>","2","0","","","","CC BY-SA 4.0"
"55139062","1","55163021","","2019-03-13 10:01:37","","0","140","<p>How to implement a <strong>Observable.concatEagerDelayError</strong> or an equivalent in RxJava2/RxKotlin2 ?</p>

<p>There is :</p>

<ul>
<li>Observable.concatEager</li>
<li>Observable.concatDelayError</li>
</ul>

<p>But not :</p>

<ul>
<li>Observable.concatEagerDelayError</li>
</ul>

<p>What i have :</p>

<pre><code>fun getAll(): Observable&lt;List&lt;User&gt;&gt; = Observable.concatArrayDelayError(
    // from db
    userDAO
        .selectAll()
        .subscribeOn(ioScheduler),
    // from api
    userAPI
        .getAll()
        .doOnNext { lstUser -&gt; Completable.concatArray(
            userDAO.deleteAll().subscribeOn(ioScheduler),
            userDAO.save(lstUser).subscribeOn(ioScheduler)
        ) }
        .subscribeOn(ioScheduler)
)
</code></pre>

<p>I want same behaviour but eagerly for selectAll() and getAll() because there is no reason to wait from db to launch network call.</p>
","4911053","","4911053","","2019-03-14 13:35:18","2019-03-14 13:41:31","How to concatEagerDelayError in RxJava2","<rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"55262210","1","","","2019-03-20 13:44:41","","3","797","<p>For unit testing in kotlin android, I have been using the mocking framework MockK. Have used RxKotlin. I have used Completable observable to notify the ViewModel about the status of API. Based on the completable, the status will be updated to success or failure in ViewModel. My question is how to mock the completable observable of RxKotlin using MockK and check the status in the unit test function based on the mocked completable.</p>

<p><strong>Snippet</strong></p>

<pre><code>val testObserver = TestObserver&lt;T&gt;()

every {
 mocked api call
} return completable

testobserver.assertComplete()
</code></pre>

<p><strong>unknown</strong></p>

<p>How to subscribe the testobserver with the completable return mock function call</p>
","9584758","","4775478","","2019-09-20 19:19:41","2019-09-20 19:19:41","How to mock completable of RxKotlin using MockK(Mock Framework)","<android><unit-testing><rx-java2><mockk><rx-kotlin2>","0","2","","","","CC BY-SA 4.0"
"55374888","1","55441869","","2019-03-27 10:23:52","","0","146","<h2>First, some background (maybe there is a better way of doing this):</h2>

<p>We have a module that emits incoming Bluetooth messages on a specific Observable. We then process this messages, and finally subscribe at the end to send messages forward. This processing could change at some time, which for most of the processing means recreating the intermediate Observables, and all observables that depend on it (as they would be processing invalid data now). </p>

<p>We would like to change it so recreating some part of the processing does not necessitate recreating everything that depends on it, mostly so we don't have to remember at all times what depended on what, and also so that operators with internal state (like buffer, scan or debounce) don't lose this internal state.</p>

<h2>The promising solution:</h2>

<p>By using a switchOnNext operator, we would solve this problem. Whenever an intermediate observable is recreated, we just add that to the origin of the switchOnNext and whoever subscribed to the output of the switchOnNext would instantly get the new results.</p>

<h2>The problem:</h2>

<p>If the processing after the switchOnNext has to change, it will stop getting results until the previous observable changes. This means that we have the oposite problem now. whenever some part changes, we have to recreate everything that it depends on, recursively. This is slightly better (much easier to keep track on what something depends on than everything that depends on it), but observables still lose the internal state as they have to be recreated.</p>

<p>This behavior seems to be against what the documentation says should happen, but it does not explicitly says one way or another.</p>

<h2>Example code:</h2>

<p>This code demonstrates the problem. </p>

<pre><code>import io.reactivex.Observable
import io.reactivex.subjects.PublishSubject

fun main() {
    //Observable of observables
    val publishSubject: PublishSubject&lt;Observable&lt;Int&gt;&gt; = PublishSubject.create()
    //Observable to subscribe to get the most recent values
    val observable: Observable&lt;Int&gt; = Observable.switchOnNext(publishSubject)

    observable.subscribe { println(""1: $it"") }
    //Now 1 is subscribed

    val obsAux1 = PublishSubject.create&lt;Int&gt;()

    observable.subscribe { println(""2: $it"") }
    //Now 1 and 2 are subscribed

    publishSubject.onNext(obsAux1)

    observable.subscribe { println(""3: $it"") }
    //Now 1, 2 and 3 are subscribed

    //Should print out from subscriptions 1, 2 and 3, but only 1 and 2 printed
    obsAux1.onNext(1)

    val obsAux2 = PublishSubject.create&lt;Int&gt;()

    publishSubject.onNext(obsAux2)

    observable.subscribe { println(""4: $it"") }
    //Now 1, 2, 3 and 4 are subscribed

    //Should not print anything
    obsAux1.onNext(2)
    //Should print out from subscriptions 1, 2, 3 and 4, but only 1, 2 and 3 printed
    obsAux2.onNext(3)
} 
</code></pre>

<p>Output of this code:</p>

<pre><code>1: 1
2: 1
1: 3
2: 3
3: 3
</code></pre>

<p>Expected output:</p>

<pre><code>1: 1
2: 1
3: 1 &lt;--- This is missing
1: 3
2: 3
3: 3
4: 3 &lt;--- This is missing
</code></pre>

<p>The first time obsAux1 emits, all three subscriptions should print, but only the ones before it was added to publishSubject print out. </p>

<p>The second time obsAux1 emits, nothing should print as obsAux2 has been inserted already. This works as expected</p>

<p>The first time obsAux2 emits, all four subscriptions should print. The third subscription prints as expected, which should that the subscription worked fine. But the fourth subscription is not printing anything, as it was added after obsAux2 was inserted to publishSubject.</p>
","3879384","","3879384","","2019-03-27 11:42:20","2019-03-31 14:22:06","switchOnNext operator does not emit for subscriptions after last inserted observable","<kotlin><rx-kotlin2>","2","4","","","","CC BY-SA 4.0"
"55401079","1","55401736","","2019-03-28 15:13:54","","0","153","<p>I am investigating the development of a <code>Kotlin</code> DSL for <code>RxKotlin</code> commands</p>

<p>I have something working however I would to improve my approach to setting Rx <code>Action</code>(s) and <code>Consumer</code>(s).</p>

<p>The Code I have currently resembles this:-</p>

<pre><code>@SequenceDsl
class ExperimentalBuilder {

    companion object {
        private val emptyAction = Action { }
        private val emptyConsumer: Consumer&lt;in Throwable&gt; = Consumer { }
    }


    var uuid: String = """"
    var onError: Consumer&lt;in Throwable&gt; = emptyConsumer
    var onComplete: Action = emptyAction
    var doFinally: Action = emptyAction
    var doLoginRefreshFail: Action = emptyAction

    fun build(): Experimental = Experimental(uuid, onError, onComplete, doFinally, doLoginRefreshFail)

}

import io.reactivex.Single
import io.reactivex.functions.Action
import io.reactivex.functions.Consumer
import io.reactivex.schedulers.Schedulers

data class Experimental(
    val uuid: String,
    val onError: Consumer&lt;in Throwable&gt;,
    val onComplete: Action,
    val doFinally: Action,
    val doLoginRefreshFail: Action
) : Morpheme() {

    override fun execute() {

        Single.just("""")
            .subscribeOn(Schedulers.single())
            .ignoreElement()
            .doOnSubscribe {disposable -&gt; COMPOSITE_DISPOSABLE.add(disposable) }
            .doOnComplete(onComplete)
            .doOnError(onError)
            .doFinally(doFinally)
            .doAfterTerminate(doAfterTerminate())
            .subscribe()
    }
}
</code></pre>

<p>and I use this code as follows:-</p>

<pre><code>  val experimental = Dsl().experimental {
            uuid = ""09876""

            onComplete = Action {
                Log.d(""EXPERIMENT"", ""ON COMPLETE"")
                Log.d(""EXPERIMENT"", ""ON COMPLETE"")
            }

            onError = Consumer {
                    throwable -&gt; Log.e(""EXPERIMENT"", ""ON ERROR"", throwable)
            }

            doFinally =  Action {
                Log.d(""EXPERIMENT"", ""DO FINALLY"")
            }

            doLoginRefreshFail =  Action {
                Log.d(""EXPERIMENT"", ""DO LOGIN REFRESH FAIL"")
            }
        }

        experimental.execute()

        Log.d(""DSL"", ""what $experimental"")
</code></pre>

<p>The code I would like to ""improve"" is this when setting either an <code>Action</code> or <code>Consumer</code></p>

<pre><code>  onComplete = Action {
    Log.d(""EXPERIMENT"", ""ON COMPLETE"")
    Log.d(""EXPERIMENT"", ""ON COMPLETE"")
  }

  onError = Consumer {
    throwable -&gt; Log.e(""EXPERIMENT"", ""ON ERROR"", throwable)
  }
</code></pre>

<p>Is this the only method I can use to set the ""onCompile"" Action?</p>

<p>e.g. Do I have to mention ""Action {}"" or is there a ""short-hand"" version I can use to achieve the same result?</p>
","423199","","","","","2019-03-28 15:44:31","How to set Rx Action Consumer in Kotlin DSL","<kotlin><dsl><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"55529892","1","55572460","","2019-04-05 07:02:44","","0","98","<p>Basically, I have two <code>Flowables F</code> and <code>G</code> and I want to use <code>combineLatest</code> on them, but I want the combined <code>Flowable</code> to already complete if <code>F</code> completes (even if <code>G</code> is still running).</p>

<p>Here is an example of what I what to achieve with an ugly solution:</p>

<pre><code>fun combineFandGbutTerminateIfFTerminates(F: Flowable&lt;Int&gt;, G: Flowable&lt;Int&gt;) : Flowable&lt;Pair&lt;Int, Int&gt;&gt; {
  val _F = F.share()
  val _G = G.takeUntil(_F.ignoreElements().toFlowable&lt;Nothing&gt;())
  val FandG = Flowables.combineLatest(_F, _G)
  return FandG
}
</code></pre>

<p>We can extract that into and extension function:</p>

<pre><code>fun&lt;T&gt; Flowable&lt;T&gt;.completeWith(other: Flowable&lt;*&gt;) : Flowable&lt;T&gt; {
    return takeUntil(other.ignoreElements().toFlowable&lt;Nothing&gt;())
}
</code></pre>

<p>Is there a nicer way to express that?</p>
","3612643","","3612643","","2019-04-05 07:26:04","2019-04-08 15:12:31","RxJava/RxKotlin: combineLatest that already completes if one source completes (not all)","<rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"55557230","1","55562345","","2019-04-07 08:54:57","","2","319","<p>I have a <code>Flowable&lt;T&gt;</code> and errors that are subtype of <code>IgnoreThisError</code> I want to ignore (resulting in graceful completion), all other errors should be propagated downstream.</p>

<p>Kotlin example:</p>

<pre><code>val f : Flowable&lt;T&gt; = ...
val g = f.onErrorComplete { it is IgnoreThisError }
</code></pre>

<p>This function onErrorComplete is what I need and does not exist...</p>
","3612643","","3612643","","2019-04-07 14:29:21","2019-04-08 15:29:00","RxJava: Ignore some errors in a Flowable","<kotlin><rx-java2><rx-kotlin2>","2","2","","","","CC BY-SA 4.0"
"55606278","1","55611376","","2019-04-10 06:44:33","","0","58","<p>I have a chain where I do some blocking IO calls (e.g. HTTP-call). I want the blocking call to consume a value, proceed without interrupting, but drop everything that is piling up meanwhile, and then consume the next value in the same manner.</p>

<p>Consider the following example:</p>

<pre><code>fun main() {
  Flowable.interval(100, TimeUnit.MILLISECONDS).onBackpressureLatest().map {
    Thread.sleep(1000)
    it
  }.blockingForEach { println(it) }
}
</code></pre>

<p>From a naive point of view, I would it expect to print something like <code>0, 10, 20, ...</code>, but it prints <code>0, 1, 2, ...</code>.</p>

<p>What am I doing wrong?</p>

<p>EDIT:</p>

<p>I thought about naively adding <code>debounce</code> to eat up the incoming stream:</p>

<pre><code>fun main() {
  Flowable.interval(100, TimeUnit.MILLISECONDS)
    .debounce(0, TimeUnit.MILLISECONDS)
    .map {
      Thread.sleep(1000)
      it
    }
    .blockingForEach { println(it) }
}
</code></pre>

<p>But, now I get a <code>java.lang.InterruptedException: sleep interrupted</code>.</p>

<p>EDIT:</p>

<p>What seems to work is the following:</p>

<pre><code>fun main() {
  Flowable.interval(100, TimeUnit.MILLISECONDS)
    .throttleLast(0, TimeUnit.MILLISECONDS)
    .map {
      Thread.sleep(1000)
      it
    }
    .blockingForEach { println(it) }
}
</code></pre>

<p>The output is as expected <code>0, 10, 20, ...</code>!!</p>

<p>Is that the correct way?</p>

<p>I noted that <code>throttleLast</code> will switch to the Computation-Scheduler. Is there a way to go back to the original scheduler?</p>

<p>EDIT:</p>

<p>I also get an occasional <code>java.lang.InterruptedException: sleep interrupted</code> with that variant.</p>
","3612643","","3612643","","2019-04-10 09:37:36","2019-04-10 11:25:08","Using `onBackpressureLatest` to drop intermediate messages in blocking Flowable","<rx-java2><rx-kotlin2>","1","4","","","","CC BY-SA 4.0"
"55606607","1","","","2019-04-10 07:04:51","","0","27","<p>Consider the following example:</p>

<pre><code>fun main() {
  Flowable.interval(1, TimeUnit.MILLISECONDS).map {
    Thread.sleep(1000)
    it
  }.blockingForEach { println(it) }
}
</code></pre>

<p>Do to missing backpressure, I would expect to get a <code>MissingBackpressureException</code> as written in the docs of <code>Flowable.interval</code>.</p>

<p>What am I getting wrong?</p>
","3612643","","","","","2019-04-10 07:04:51","No `MissingBackpressureException` exception with `Flowable.interval` and blocking chain","<rx-java2><rx-kotlin2>","0","5","","","","CC BY-SA 4.0"
"55727396","1","55737305","","2019-04-17 12:18:07","","0","182","<p>After struggling for a few days now, on what seems to be a simple task, I come to you guys:)</p>

<p>Idea is simple. I have two streams/observables, 'left' and 'right'.
I want items from 'right' to buffer/collect/aggregate to 'current' item in 'left'.<br>
Thus, each item in 'left' defines a new 'window', while all 'right' items will bind to that window, until a new 'left' item is emitted. So, to visualize:</p>

<p><strong>Task:</strong><br>
'left' &nbsp;&nbsp;&nbsp; : |- A - - - - - B - - C - - - -|<br>
'right' &nbsp; :       |- 1 - 2 - 3 -4 - 5 - 6 - - -|<br>
'result' : |- - - - - - - -x - - -y - - - -z| &nbsp;&nbsp;( <code>Pair&lt;Left, List&lt;Right&gt;&gt;</code>)<br>
<em>Where: <strong>A,1</strong> ; <strong>B,4</strong> (so x) ; <strong>C</strong> (so y) are emitted on the same time</em><br>
<em>So: &nbsp; &nbsp; &nbsp; x = Pair(A, [1,2,3]), &nbsp;&nbsp;y = Pair(B, [4, 5])</em><br>
<em>And: &nbsp; &nbsp;'right' &amp; 'result' complete/terminate when 'left' does</em><br>
<em>So: &nbsp; &nbsp; &nbsp;z = Pair(C, [6]) - emitted as a result of 'left' completing</em>  </p>

<p><strong>----</strong><br>
<strong>EDIT 2 - FINAL SOLUTION!</strong><br>
In order to aggregate 'right' items with the next 'left' and not the previous one, I changed the code to this much shorter/simpler one:  </p>

<pre><code>fun &lt;L, R&gt; Observable&lt;L&gt;.rightGroupJoin(right: Observable&lt;R&gt;): Observable&lt;Pair&lt;L, List&lt;R&gt;&gt;&gt; {
    return this.share().run {
        zipWith(right.buffer(this), BiFunction { left, rightList -&gt;
            Pair(left, rightList)
        })
    }
}  
</code></pre>

<p><strong>EDIT 1 - initial solution!</strong><br>
Taken from @Mark's (accepted) answer below, here's what I came up with.<br>
It is separated into smaller methods because I also do <code>multiRightGroupJoin()</code> to join in as many (right) streams as I want.  </p>

<pre><code>fun &lt;T, R&gt; Observable&lt;T&gt;.rightGroupJoin(right: Observable&lt;R&gt;): Observable&lt;Pair&lt;T, List&lt;R&gt;&gt;&gt; {
    return this.share().let { thisObservable -&gt;    //use 'share' to avoid multi-subscription complications, e.g. multi calls to **preceding** doOnComplete
        thisObservable.flatMapSingle { t -&gt;        //treat each 'left' as a Single
            bufferRightOnSingleLeft(thisObservable, t, right)
        }
    }
}
</code></pre>

<p>Where:  </p>

<pre><code>private fun &lt;T, R&gt; bufferRightOnSingleLeft(left: Observable&lt;*&gt;, leftSingleItem: T, right: Observable&lt;R&gt;)
    : Single&lt;Pair&lt;T, MutableList&lt;R&gt;&gt;&gt; {

    return right.buffer(left)                              //buffer 'right' until 'left' onNext() (for each 'left' Single) 
        .map { Pair(leftSingleItem, it) }
        .first(Pair(leftSingleItem, emptyList()))   //should be only 1 (list). THINK firstOrError
}  
</code></pre>

<p><strong>----</strong>  </p>

<p><strong>What I got so far</strong><br>
After much reading and the understanding that somehow there's no implementation for this out of the box, I've decided to use <code>groupJoin</code>, mostly using <a href=""https://leecampbell.com/2011/03/14/rx-part-9-join-window-buffer-and-group-join/"" rel=""nofollow noreferrer"">this link</a>, like so: <em>(many problems and places to improve here, don't use this code)</em>  </p>

<pre><code>private fun &lt;T, R&gt; Observable&lt;T&gt;.rightGroupJoin(right: Observable&lt;R&gt;): Observable&lt;Pair&lt;T, List&lt;R&gt;&gt;&gt; {

var thisCompleted = false //THINK is it possible to make the groupJoin complete on the left(this)'s onComplete automatically?
val thisObservable = this.doOnComplete { thisCompleted = true }
        .share() //avoid weird side-effects of multiple onSubscribe calls

//join/attach 'right/other' stream to windows (buffers), starting and ending on each 'this/left' onNext
return thisObservable.groupJoin(

    //bind 'right/other' stream to 'this/left'
    right.takeUntil { thisCompleted }//have an onComplete rule THINK add share() at the end?

    //define when windows start/end ('this/left' onNext opens new window and closes prev)
    , Function&lt;T, ObservableSource&lt;T&gt;&gt; { thisObservable }

    //define 'right/other' stream to have no windows/intervals/aggregations by itself
    // -&gt; immediately bind each emitted item to a 'current' window(T) above
    , Function&lt;R, ObservableSource&lt;R&gt;&gt; { Observable.empty() }

    //collect the whole 'right' stream in 'current' ('left') window
    , BiFunction&lt;T, Observable&lt;R&gt;, Single&lt;Pair&lt;T, List&lt;R&gt;&gt;&gt;&gt; { t, rObs -&gt;
        rObs.collect({ mutableListOf&lt;R&gt;() }) { acc, value -&gt;
            acc.add(value)
        }.map { Pair(t, it.toList()) }

    }).mergeAllSingles()
}  
</code></pre>

<p>I also used similar usage to create a <code>timedBuffer()</code> - same as <code>buffer(timeout)</code> but with a timestamp on each buffer(<code>List</code>) to know when it started. Basically by running the same code on an <code>Observable.interval(timeout)</code> (as the 'left')</p>

<p><strong>Problems / Questions (from the easiest to the hardest)</strong>  </p>

<ol>
<li>Is it the best way of doing something like that? Isn't it an overkill?</li>
<li>Is there a better way (must be) for completing the 'result' (and 'right') when 'left' is completed? Without this ugly boolean logic?</li>
<li><p>This usage seem to mess up the order of the rx. See code and print below:  </p>

<pre><code>leftObservable
.doOnComplete {
    log(""doOnComplete - before join"")
 }
.doOnComplete {
    log(""doOnComplete 2 - before join"")
 }
.rightGroupJoin(rightObservable)
.doOnComplete {
    log(""doOnComplete - after join"")
 }
</code></pre></li>
</ol>

<p>Prints (sometimes! Looks like a race condition) the following:<br>
<code>doOnComplete - before join</code><br>
<code>doOnComplete - after join</code><br>
<code>doOnComplete 2 - before join</code>  </p>

<ol start=""4"">
<li><p>On first run of the above code, <code>doOnComplete - after join</code> is not called, on the second time it's called <strong>twice</strong>. Third time is like the first, forth is like the second, etc...<br>
Both 3,4 are ran using this code. Probably has something to do with the subscribe {} usage? Note that I don't hold the disposable.
This stream finishes because I GC the 'left' observable</p>

<pre><code>leftObservable.subscribeOn().observeOn()
.doOnComplete{log...}
.rightGroupJoin()
.doOnComplete{log...}
.subscribe {}  
</code></pre></li>
</ol>

<p>Note1: adding <code>.takeUntil { thisCompleted }</code> after <code>mergeAllSingles()</code> seems to fix #4.   </p>

<p>Note2: After using this method to join multiple streams and applying 'Note1', it's apparent that the onComplete (before the groupJoin() call !!!) will be called as many times as there are 'right' Observables, probably meaning that the cause is the <code>right.takeUntil { thisCompleted }</code>, is it really important to close the 'right' stream?  </p>

<p>Note3: concerning Note1, it seems very much related to takeUntil vs. takeWhile. Using takeWhile lowers the doOnComplete calls, and it's somehow logical. Still trying to figure it out better.</p>

<ol start=""5"">
<li>Can you think of a multiGroupJoin, or in our case, multiRightGroupJoin, other than running zip on groupJoin * rightObservablesCount?</li>
</ol>

<p>Please ask anything you like. I know for a fact the my usage of the subscribe/disposable and the manual onComplete are not the way, I'm just not sure enough what is..</p>
","2774781","","2774781","","2019-04-24 17:39:03","2019-04-24 18:01:18","Rx (RxKotlin) - rightGroupJoin using groupJoin - merge / combine two observables of different types","<rxjs><rx-java><reactive-programming><rx-kotlin><rx-kotlin2>","2","0","1","","","CC BY-SA 4.0"
"56034425","1","56035352","","2019-05-08 06:01:34","","4","74","<p>I will be using observable transformer in my application for converting data from one type to another, so for this use i created a generic class with one parameter <code>&lt;T1&gt;</code> where T1 is the type am expecting to get the output</p>

<p>Example</p>

<pre><code>class Transformer&lt;T1&gt; {

    fun transform(): ObservableTransformer&lt;String, T1&gt; {

        return ObservableTransformer { data -&gt;

            data.map {

                if (T1 is Int) {       //getting compilation error like T1 is not an expression
                    return IntDataType
                }

                if (T1 is Double) { //getting compilation error like T1 is not an expression
                    return DoubleDataType
                }
            }
        }
    }
}
</code></pre>

<p>The above class is the transformer which gets the input as string and convert String to someData type based on given generic type T1<br>
So i will be calling the above like this</p>

<pre><code> getSomeData()
            .compose(Transformer&lt;Double&gt;().tranform())
            .map{ it: double
            } 
</code></pre>

<p>is there is any other solution to perform like this type of transformer ?
Any help</p>
","9344496","","1047418","","2019-05-08 10:04:08","2019-05-08 10:04:08","Android - Generic type as a Expressions In ObservableTransformer","<android><kotlin><rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"56053542","1","56054379","","2019-05-09 06:38:55","","2","547","<p>Since sealed is like enum object so i decided to use sealed class for network response, were it contains success or failure if it is success it contains data else error message<br>
Example</p>

<pre><code>  sealed class Result {
            sealed class Success : Result() {
                data class F1(val data: Any) : Success()
                data class F2(val data: Any) : Success()
            }

            sealed class Error : Result() {
                data class F1(val error: Any) : Error()
                data class F2(val error: Any) : Error()
            }
        }
</code></pre>

<p>the above Result class has either Success or Failure</p>

<pre><code> getSomeDataFromService()
                .filter {
                    it is Result.Success.F1
                }
                .map { it: Result
                    /*
                    i face problem here,my need is F1 data class but what i
                     got is Result ,i know that i can cast here, 
                    but i am eager to know for any other solution other than casting  
                     */


                }

}
</code></pre>

<p>is there is any other solution ?<br>
Any help</p>
","9344496","","","","","2019-05-09 07:36:03","Android - Kotlin Sealed class with Rxkotlin filter","<android><kotlin><rx-java><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"56130742","1","","","2019-05-14 12:39:54","","1","64","<p>I have a chaining operation in my application, Where i have a list of some data, i will iterate through the list with <code>iteratable observable</code> once the iteration completes, i will perform some other operation which does not depends on the previous list, so what i need is in between these two operation i need to block(or barrier) until the first completes and proceed with second one.</p>

<p>Example</p>

<pre><code>Observable.fromIterable(listOf(""A"",""B"",""C"",""D""))
          .map{
            doSomeTask(it)
          } 
   // I need a blocking here, once this iteration completes i will proceed with the below task, but i don't need of toList() to block since i don't want the data,       
          .map{
            doSomeOtherTask()
          }
</code></pre>

<p>Can anyone help me out with this ?</p>
","9344496","","9344496","","2019-05-14 12:58:08","2019-05-14 14:58:43","Block Chain in RxKotlin and Proceed","<android><kotlin><rx-java2><rx-kotlin2>","2","0","","","","CC BY-SA 4.0"
"56279571","1","","","2019-05-23 16:34:26","","0","85","<p>I have one observable with a list of String and another with a list of string lists.
I need to reuse first observable until every string is stetted</p>

<p>In short. I need to iterate through every element of the list's list and attach it to first observable list elements</p>

<p>I learned about retryWhen but don't know how to reuse first observable and continue on the second</p>

<pre><code>val cat = sheetsViewer.GOOGLE_SHEETS_ENDPOINT_IMPL.readSpreadSheet(spreadsheetId, ""A4:DA4"")
            .toObservable()
            .flatMap { Observable.fromIterable(it) }


val data = sheetsViewer.GOOGLE_SHEETS_ENDPOINT_IMPL.readSpreadSheet(spreadsheetId, range)
            .toObservable()
            .subscribeOn(Schedulers.computation())
            .flatMap { Observable.fromIterable(it) }
            .map {
                val newList = it.toMutableList()

                while (newList.size != 105)
                    newList.add("""")

                return@map newList
            }
</code></pre>

<p>I have list of strings {""a"", ""b""}
and second {{""a"", ""b""}, {""c"", ""d""}, {""e"", ""f""}}</p>

<p>I expect the output to be {""aa"", ""bb"", ""ca"", ""db"", ""ea"", ""fb""}</p>
","7624868","","8200936","","2019-05-24 11:42:27","2019-05-24 11:42:27","Is there a way to reuse one observable until second will get onComplete() in zip?","<java><kotlin><rx-java2><rx-kotlin2>","2","1","","","","CC BY-SA 4.0"
"56343675","1","56343797","","2019-05-28 13:46:15","","0","81","<p>I'm using room database and need to add rxKotlin to my project, so when I use this code:</p>

<pre><code>`implementation 'io.reactivex.rxjava2:rxkotlin:2.0.1'`
</code></pre>

<p>I get this error:</p>

<pre><code>`ERROR: Failed to resolve: io.reactivex.rxjava2:rxkotlin:2.0.1`
</code></pre>

<p>how can I fix it?</p>
","9470643","","1000551","","2019-05-28 15:25:07","2019-05-28 15:25:07","how to fix ""can't resolve rxkotlin"" in android","<android><kotlin><rx-kotlin2>","2","0","","","","CC BY-SA 4.0"
"56403533","1","","","2019-06-01 02:58:20","","1","276","<p>When I was trying to upgrade my Android Studio to 3.4, the update does not go smoothly rather, some dependencies break. In my case, the RxJava/RxKotlin dependencies are breaking without giving any clue. Even that is happening randomly as I have RxJava/RxKotlin Code in each of my <strong>4 modules</strong> but the dependency is failing in <strong>only one</strong> module. </p>

<p><a href=""https://i.stack.imgur.com/lmnlZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/lmnlZ.png"" alt=""enter image description here""></a></p>

<p><strong>What I tried :</strong>  </p>

<ol>
<li>Invalidate Cache and restart. </li>
<li>Delete /build *module/build/ *module/.gradle/  &amp; .gradle/  </li>
<li>Clean Project     </li>
<li><p>Try find answers on the internet and these are the closest but does not solve the problem. (They did not recommend to upgrade to 3.4)</p>

<p>i) <a href=""https://stackoverflow.com/questions/55742589/unresolved-reference-observable-in-android-studio-3-4"">Unresolved reference: Observable in Android Studio 3.4</a>
<strong>Explains</strong> the <strong>problem</strong> I have <strong>but</strong> the thread is moving to either <strong>not upgrading</strong> the Gradle (Which is last option for me) or making sure RxJava that is being used in the project or any of its library is 2.2.8). For that reason I tried explicitly adding RxJava 2.2.8 (I was not previously as I was getting it inside RxKotlin) and wrote a  resolutionStrategy to force Android studio to use RxJava 2.2.8 like this in that particular module i.e. <strong>domain</strong>, but did not solve the issue :</p>

<pre><code>configurations.all {
       resolutionStrategy.force 'io.reactivex.rxjava2:rxjava:2.2.8'
}
</code></pre>

<p>ii) <a href=""https://github.com/ReactiveX/RxKotlin/issues/216"" rel=""nofollow noreferrer"">RxKotlin is not resolved properly after updating Gradle to 3.4.0</a> which does not yet give any solution. And <strong>I am even suspicious</strong> <strong>if</strong> it's the <strong>issue</strong> with RxJava/<strong>RxKotlin</strong> or the <strong>Gradle plugin</strong> itself. Or even if it's the case with RxKotlin or any other libraries too.   </p></li>
</ol>

<p><strong>Edit: My dependencies in domain module looks like this :</strong> </p>

<pre><code>dependencies {
    implementation Deps.kotlinStdLib
    implementation Deps.rxKotlin
    implementation Deps.dagger
    implementation Deps.timber
    implementation Deps.mobiusCore
    implementation Deps.mapboxGeoJSONCore
}
</code></pre>
","2581314","","472495","","2019-08-11 00:30:01","2019-08-11 00:30:01","Cannot upgrading gradle Android Studio 3.4., Gradle 5 dependencies break randomly","<android><android-gradle-plugin><rx-java><rx-kotlin2><android-gradle-3.4.0>","1","2","","","","CC BY-SA 4.0"
"56424628","1","56432574","","2019-06-03 09:35:59","","1","68","<p>I will be using thread executors to do some background work with rxkotlin, I made threadpool size fixed to 3, but my problem is during my background operation it using only one thread out of 3, which slows down my background operation</p>

<p>Executor class</p>

<pre><code> class ThreadExe : Executor{

     companion object {
        private const val THREAD_POOL_SIZE = 3
    }

    private val executor: Executor = 
       Executors.newFixedThreadPool(THREAD_POOL_SIZE)

    override fun execute(runnable: Runnable) {
          executor.execute(runnable)
    }

}
</code></pre>

<p>The above is my executor class responsible for creating thread.<br>
I will be calling my background task like below</p>

<pre><code> getSomeDataFromNetworkProcessWithDB()
    .subscribeOn(Schedulers.from(ThreadExe()))
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe()
</code></pre>

<pre><code>
fun getSomeDataFromNetworkProcessWithDB() {
    Observable.fromIteratable(someDataList())
            .flatMap {
                getSomeNetworkData()
            }
            .flatMap {
                doSomeDbOperation()
            }
}
</code></pre>

<p>my problem with the above code is all these network and db operation is working sequentially with the same thread, since we have give the threadpool of size 3 it must send the 3 network request parallely, but the request is going sequentially<br>
Can anyone help me out this problem ?</p>
","9344496","","9344496","","2019-06-03 10:46:00","2019-06-03 18:17:11","Handling Executors in RxKotlin","<android><rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"56660075","1","","","2019-06-19 04:29:48","","1","90","<p>I have a list of items say for example list of integers, if any of the integer is null, i need to consume the error and proceed with the next item</p>

<p>For example</p>

<pre><code>Observable.fromIterable(listOf(1, 2, 3, null, 5))
                .map {
                    doSomeProcess(it)
                }
                .onErrorReturnItem(-1)
                .subscribeBy(
                        onNext = {
                           print(it)
                        },
                        onError = {

                        },
                        onComplete = {

                        })
</code></pre>

<p>I am expecting the output like this</p>

<pre><code>1
2
3
-1
5
</code></pre>

<p>But my problem is after <code>-1</code> it is not getting proceeded with item <code>5</code>, it stops there, Can anyone help me out with this ?</p>
","9344496","","","","","2019-06-19 06:49:24","How to handle errors in rxjava chain in android?","<android><rx-java><rx-kotlin><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"56740292","1","","","2019-06-24 16:03:53","","0","272","<p>I've tried some examples with viewmodels and databinding using BehaviorSubjects and other Observables. Now I have real (data class) object in Kotlin, which holds most of the state. It is basically pojo, but independent from viewmodel and has no observables.
I don't understand how can I bind this automatically to ex. TextView in android without creating external observable variables in viewmodel and some boilercode. I'd think this is something very common in mvvm pattern. Or am I missing something totally?</p>
","4070660","","4070660","","2019-06-24 16:17:42","2019-06-25 15:20:03","Model properties binding in android viewmodel","<rx-java><rx-java2><rx-android><rx-kotlin><rx-kotlin2>","1","1","","","","CC BY-SA 4.0"
"56771102","1","56778346","","2019-06-26 10:50:35","","0","226","<p>I need to handle error globally in my application for network service, i am using Rxjava2CallAdapterFactory in my retrofit service. So In order to handle error globally i searched through various sites and i got a solution. But i do know how this works.</p>

<pre><code>class RxErrorAdapter private constructor() : CallAdapter.Factory() {

    private val original = RxJava2CallAdapterFactory.create()

    override fun get(returnType: Type, annotations: Array&lt;Annotation&gt;, retrofit: Retrofit): CallAdapter&lt;*, *&gt;? {
        return Wrapper&lt;Any&gt;(original.get(returnType, annotations, retrofit)
                ?: return null)
    }

    private class Wrapper&lt;R&gt;(private val wrapped: CallAdapter&lt;R, *&gt;) : CallAdapter&lt;R, Any&gt; {

        override fun responseType(): Type {
            return wrapped.responseType()
        }

        override fun adapt(call: Call&lt;R&gt;): Any {
            val result = wrapped.adapt(call)
        }
    }


    companion object {
        fun create(): CallAdapter.Factory {
            return RxErrorAdapter()
        }
    }
}
</code></pre>

<p>Can anyone explain on this ?</p>
","9344496","","9344496","","2019-06-27 05:33:47","2019-06-27 05:33:47","RxJava2 Error Handling Wrapper For Retrofit Service","<android><retrofit><rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"57132058","1","57132969","","2019-07-21 09:56:21","","2","385","<p>I am need that i will be calling a completable method in the chain, after it completes, it needs to continue the chain with <code>Map</code> operator<br>
<strong>Example</strong></p>

<pre><code>Single.just(someOperation())
     .flatMapCompletable{
         completableMethod()
    }
     .map{ // i need to continue here with map or some other operator
         doSomeOperation()
    }
</code></pre>

<p>Can anyone help me out with this ?</p>
","9344496","","","","","2019-07-21 12:19:52","Convert Rxjava Completable to Map","<android><rx-java><rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"57195965","1","57197257","","2019-07-25 06:54:21","","0","40","<p>Suppose I have a <code>BehaviorProcessor</code> which contains some value <code>v</code>.</p>

<p>Now if I want to asynchronously request some data, which would depend on <code>v</code> I would do it like this:</p>

<pre><code>val res = v.flatMapSingle { asyncRequest(it) }
</code></pre>

<p>Now let's log all the invocations of this block (mapper)</p>

<pre><code>val res = v.flatMapSingle {
    println(""mapper"")
    asyncRequest(it)
}
</code></pre>

<p>It will print <code>mapper</code> multiple times, which means <code>asyncRequest</code> is being called multiple times, it seems every time some other dependant stream is being <code>subscribe</code>d to</p>

<p>I am trying to avoid multiple mapper invocations (thus avoiding multiple <code>asyncRequest</code> calls).</p>

<p>Is there a way to do so with standard rxjava2 utils?</p>
","4758683","","1712135","","2019-07-25 07:00:46","2019-07-25 08:13:25","How to avoid multiple mapper calls when using flatMapSingle","<rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"57251465","1","","","2019-07-29 10:03:56","","0","25","<p>There is a class, it has observable fields. I want to update <code>localData</code></p>

<p>when receiving remote data <code>remoteData</code>, for some reason I can not get data in <code>localData</code>, debugging does not go to a breakpoint even to <code>getIdsInDatumsRemote ()</code>. The <code>identifyDatumsForUpdate ()</code> method gets an empty Observable.</p>

<pre><code>class DiskDatumDataStore {

    var remoteData: Observable&lt;Data&gt;? = null

    var localData: Observable&lt;Data&gt;? = null

    override fun sync() {
        remoteDatums = getChangedRemoteData(lastUpdated!!, 1000)!!
        localDatums = remoteDatums!!.map {
            getIdsInDatumsRemote(it)
        }.map {
            it.map {
                it.toLong()
            }
        }.flatMap {
            getOldLocalData(it)
        }


        identifyDatumsForUpdate(datumsForUpdateLocal, datumsForUpdateRemote)
    }

    override fun getOldLocalData(remoteDatumsIds: List&lt;Long&gt;): Observable&lt;List&lt;DataLayerTypesOfResponsibility&gt;&gt; {
        return Observable.fromCallable { repository.getOldDatum(remoteDatumsIds) }      
    }
}
</code></pre>
","11851604","","11851604","","2019-07-29 10:10:01","2019-07-29 10:31:45","Dependence of one Observable on another RxJava2","<java><kotlin><rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"57280030","1","57304034","","2019-07-30 21:06:01","","0","31","<p>I've attached a function can be called from multiple viewModels, I'm trying to store each ""restaurant"" to the DB in a central function before returning this observable to a viewModel. </p>

<p>I'm new to rxandroid and I'm wondering if there is a way to perform a non-transformative and non-consuming action on each item before the final onNext() in subscribe(). </p>

<p>(Something like doOnEach() below):</p>

<pre><code>fun getData() : CompositeDisposable {
        return apiProvider!!.loadRestaurants()
            .flatMap { response : RestaurantOuterResponse? -&gt; Observable.fromArray(
                response!!.restaurants
            )}
            .doOnEach() { restaurant : Restaurant -&gt;
                ADBConnection.storeRestaurant(restaurant)
            }
    }
</code></pre>

<p>Two Solutions I've found so far was to:</p>

<ol>
<li>Have a function inside RestaurantOuterResponse to save all the values when the list of ""Restaurants"" is extracted in flatMap(). </li>
<li>Call the ADBConnection.storeRestaurant(restaurant) in onNext() in each individual viewModel.</li>
</ol>

<p>None of these are great solutions, is what I suggested in the right direction? Or is there a better way?</p>
","6382655","","","","","2019-08-01 07:39:28","Perform non-transformative action on each item in observable before onNext","<android><kotlin><rx-java><rx-java2><rx-kotlin2>","1","1","","","","CC BY-SA 4.0"
"57342833","1","57348985","","2019-08-03 23:48:27","","4","539","<p>Using a simple RxKotlin Single, I'm receiving either a <code>android.view.ViewRootImpl$CalledFromWrongThreadException</code> exception, or by adding <code>.observeOn(AndroidSchedulers.mainThread())</code>, I'm getting a <code>NetworkOnMainThread</code> exception. </p>

<pre><code>fun loadStaffCalendar() {
        var calendarParser = CalendarParser()
        calendarParser.getSingleBearCal()
            .subscribeOn(Schedulers.io())
            .subscribeBy(
                onError ={error(""Error loading calendar\n${it.message}"")},
                onSuccess = { responseBody -&gt;
                        println(""ResponseBody retrieved"")
                        var staffList = calendarParser.parseStringIntoSchedule(responseBody.string())
                        view.loadToAdapter(staffList)
                         println(staffList)

                }

            )
</code></pre>

<p>I can get the staffList to print in console, but as soon as I try to load it into the View's adapter, it crashes with an CalledFromWrongThread exception.</p>

<p>So here's the crash when I add <code>.observeOn(AndroidSchedulers.mainThread()):</code></p>

<pre><code>Process: com.offbroadwaystl.archdemo, PID: 21809
    io.reactivex.exceptions.UndeliverableException: The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | android.os.NetworkOnMainThreadException
        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)
        at io.reactivex.android.schedulers.HandlerScheduler$ScheduledRunnable.run(HandlerScheduler.java:126)
        at android.os.Handler.handleCallback(Handler.java:873)
        at android.os.Handler.dispatchMessage(Handler.java:99)
        at android.os.Looper.loop(Looper.java:193)
        at android.app.ActivityThread.main(ActivityThread.java:6669)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)
     Caused by: android.os.NetworkOnMainThreadException
        at android.os.StrictMode$AndroidBlockGuardPolicy.onNetwork(StrictMode.java:1513)
        at com.android.org.conscrypt.Platform.blockGuardOnNetwork(Platform.java:415)
        at com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read(ConscryptFileDescriptorSocket.java:527)
        at okio.InputStreamSource.read(Okio.kt:102) 
</code></pre>

<p>No additional network calls are made anywhere. Here's the rest:</p>

<pre><code>class CalendarParser : AnkoLogger {
    fun getSingleBearCal(): Single&lt;ResponseBody&gt; {
        val retrofit: Retrofit = Retrofit.Builder()
            .baseUrl(""https://www.brownbearsw.com/"")
            .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
            .build()
        val bearApi: BearApi = retrofit.create(BearApi::class.java)

        return bearApi.file
    }

    fun parseStringIntoSchedule(wholeSchedule: String): ArrayList&lt;StaffModel&gt; {
        var dateMap: HashMap&lt;LocalDate, String&gt; = HashMap()
        var endDelim = ""END:VEVENT""
        var events: List&lt;String&gt; = wholeSchedule.split(endDelim)
        var parsedStaffCal: ArrayList&lt;StaffModel&gt; = ArrayList()
        var today = LocalDate.now()
        // :: Pull event date from event data, pull staff list from ""SUMMARY"" line :: //
        events.forEach {
            var tempString = (it.substringAfterLast(""DATE:"", ""FAIL"").take(8))
            var dateTime: LocalDate = eightIntoDateTime(tempString)

            var summary: String = it.substringAfter(""SUMMARY:"", ""FAIL"")
                .let { it.substringBefore(""UID"").replace(""\\n"", ""\n"") }
            dateMap.put(dateTime, summary)
        }

        // ::Filter out all days before today:: //
        dateMap.forEach {
            if (!it.key.isBefore(today)) {
                val staffModel = StaffModel(it.key, it.value)
                parsedStaffCal.add(staffModel)
            }
        }
        //:: Sort chronologically :://
        parsedStaffCal.sortBy { it.localDate }

        return parsedStaffCal
    }

    fun eightIntoDateTime(s: String): LocalDate {
        return if (s.length == 8 &amp;&amp; s.isDigitsOnly()) { // &lt;-=-=-=-=-=- avoid potential formatting exceptions
            val dateString = (""${s.subSequence(0, 4)}-${s.subSequence(4, 6)}-${s.subSequence(6, 8)}"")
            LocalDate.parse(dateString)
        } else LocalDate.parse(""1999-12-31"")
    }  
</code></pre>

<p>Retrofit API:</p>

<pre><code>package com.offbroadwaystl.archdemo.schedule;

import io.reactivex.Single;
import okhttp3.ResponseBody;
import retrofit2.http.GET;
import retrofit2.http.Streaming;

public interface BearApi {
    @Streaming
    @GET(""url.goes.here.ics"")
    Single&lt;ResponseBody&gt; getFile();
}
</code></pre>
","10943915","","10943915","","2019-08-04 16:14:06","2019-08-04 17:53:04","Single causes either Network on Main Thread or View Root from Wrong Thread exceptions","<android><kotlin><rx-kotlin2>","2","3","","","","CC BY-SA 4.0"
"57529032","1","57530072","","2019-08-16 17:46:49","","1","147","<p>What I wanted to do is to have a Flowable with a backpressure buffer of one item that keeps the latest one produced from a stream.</p>

<p>I've tried to use Flowable.onBackpressureBuffer(1, () -> {}, BackpressureOverflowStrategy.DROP_OLDEST). However, it doesn't work as I expected</p>

<pre><code>  Flowable.range(0, 10_000)
      .onBackpressureBuffer(1, {}, BackpressureOverflowStrategy.DROP_OLDEST)
      .observeOn(Schedulers.computation())
      .subscribe {
        println(it)
        Thread.sleep(5)
      }
</code></pre>

<p>The output I expected is a sequence of integers, not necessarily contiguous, that should includes the last item 9,999. However, it only printed the first a few contiguous numbers like 0, 1, 2, 3, 4..., different each time, but not the last number 9,999.</p>
","10919945","","","","","2019-08-16 19:22:41","What's the behavior of onBackpressureBuffer in RxJava2","<java><kotlin><rx-java2><rx-kotlin2>","1","0","0","","","CC BY-SA 4.0"
"57738495","1","57746848","","2019-08-31 13:39:52","","1","38","<p>I'm writing messenger server on grpc with rxjava2 stubs, and I stuck on combining my singles.</p>

<p>I'm have tried some sort of</p>

<pre><code>  val user:Single&lt;User&gt; = getUser()
  val conversation:Single&lt;Conversation&gt; = getConversation(user.blockingGet())
  return conversation.map{
      someMethod(user.blockingGet(), conversation.it())
      it
  }
</code></pre>

<p>It looks so unbeauty then all of the examples, so is there a way to combine all of this singles to one line?</p>
","10064300","","","","","2019-09-01 14:31:18","How to handle a multiple singles?","<rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"57815436","1","57817329","","2019-09-06 03:43:44","","0","200","<p>If in ActivityA, it keep reference to </p>

<pre><code>private val subjectA: PublishSubject&lt;ObjectB&gt; = PublishSubject.create()
private var dispose: Disposable? = null
</code></pre>

<p>Does we need to call onComplete() method of subject in onDestroy() method of Activity</p>

<pre><code>override fun onDestroy() {
    subjectA.onComplete()
    dispose?.dispose()
    super.onDestroy()
}
</code></pre>
","2286345","","2649012","","2019-09-06 06:35:39","2019-09-06 07:11:43","Do we need to call onComplete() of subject in onDestroy() method of activity?","<android><rx-java><rx-java2><rx-kotlin2>","1","2","","","","CC BY-SA 4.0"
"57835667","1","","","2019-09-07 16:45:00","","0","64","<p>I am creating an application for fall detection and I am trying to implement RxKotlin to do it. To provide good data processing I'm taking sesnorEvent every 250ms and put it to the buffer (with last 10 seconds). Unfortunately, entire data in the buffer is the same event when I move my phone. Is the problem in my code or it just work like this?</p>

<p>Already I tried to use window and buffer, however, results are the same.
Target API of the app is 28, min API 21. SensorListener is placed in the foreground Service</p>

<pre><code>//initialization of the properties
private val proxy: BehaviorSubject&lt;SensorEvent&gt; = BehaviorSubject.create()
private var mSensorManager: SensorManager? = null
private var mAccelerometer: Sensor? = null
private lateinit var subscribe: Disposable

override fun onCreate() {
        super.onCreate()
        mSensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager
        mAccelerometer = mSensorManager!!.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
        mSensorManager!!.registerListener(this, mAccelerometer, SensorManager.SENSOR_DELAY_NORMAL)

        subscribe = Observable.interval(250, TimeUnit.MILLISECONDS)
            .map { proxy.value }
            .buffer(1, TimeUnit.SECONDS)
            .map {
                it.map { sensorEvent -&gt; calculateAcceleration(sensorEvent!!) }
            }
            .subscribe {

                    Log.d(""MySensor"", it.toString())

            }
    }

//Here I call onNext also log data for every called event
override fun onSensorChanged(event: SensorEvent?) {
        proxy.onNext(event!!)
        Log.d(""MySensor"", calculateAcceleration(event).toString())
    }



private fun calculateAcceleration(event: SensorEvent): Float {
        val axisX = event.values[0]
        val axisY = event.values[1]
        val axisZ = event.values[2]
        val acceleration = sqrt(axisX.pow(2) + axisY.pow(2) + axisZ.pow(2))
        //Log.d(""MyDataSave"", acceleration.toString())
        return acceleration
    }



</code></pre>

<p>I expect the output of the observable was like [11.234473, 9.768473, 13.23543], however, I get  [9.768473, 9.768473, 9.768473]. Main point is that the values in the buffer should be different after I move the phone during the buffer lifetime, but they are not.</p>
","12035106","","7615937","","2019-12-12 07:38:31","2019-12-12 07:38:31","Observable returns list of the same values","<android><kotlin><observable><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"57882282","1","57883043","","2019-09-11 04:46:09","","2","2894","<p>I am using rxjava for some uploading task to server, Whenever task initiated fragment or activity is destroyed i will be disposing the subscription to avoid memory leak, But what i want is even after the fragment/activity destroyed i need to continue the task running in the background, Is there is any way to achieve this ?</p>

<p>Example</p>

<pre><code>doSomeLongRunningBgTaks()
     .subscribe()
     .addTo(compositeDisposal)
</code></pre>

<pre><code>override onDestroy(){
  compositeDisposal.clear()
}
</code></pre>

<blockquote>
  <p>Is it mandatory to dispose the subscription all time ? if not when to use dispose ?</p>
</blockquote>
","9344496","","61158","","2019-09-11 08:48:44","2019-09-11 08:50:11","How to use Rxjava for long running background task","<android><rx-java><rx-java2><rx-kotlin2>","3","1","","","","CC BY-SA 4.0"
"58150946","1","","","2019-09-28 23:07:14","","0","152","<p>Let say that I have a source of number list and observable which can value each number in that list. (Below method are required to be used. They are part of API which I <strong>have to</strong> use)</p>

<pre><code>fun getNumberListSource() : Observable&lt;List&lt;Int&gt;&gt; {...}
fun getOddChecker(value: Int): Observable&lt;Boolean&gt; {...}
</code></pre>

<p>Let say source could look like this:</p>

<pre><code>class NumberSource {

    private val source = BehaviorSubject.create&lt;List&lt;Int&gt;&gt;()

    fun getNumberListSource(): Observable&lt;List&lt;Int&gt;&gt; = source.doOnNext { println(""doOnNext :)"") }

    fun start(){
        Thread {
            Thread.sleep(1000)
            source.onNext(listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))
            Thread.sleep(1000)
            source.onNext(listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))
            Thread.sleep(1000)

            source.onComplete()
        }.start()

    }
}
</code></pre>

<p>fun getOddChecker(i: Int) : Observable = Observable.just(i%2== 0)</p>

<p>at the end of the stream I need to have lists of odd numbers.
So I done that code:</p>

<pre><code>fun main() {
    val numberSource = NumberSource()
    numberSource.start()
    println(""== started =="")

    numberSource.getNumberListSource()
        .flatMap {
            Observable.fromIterable(it)
                .flatMap (
                    {getOddChecker(it)},
                    {a, b -&gt; a to b}
                )
                .filter { it.second }
                .map { it.first }
                .toList()
                .toObservable()
        }
        .subscribe({ println(""onNext: $it"")},{},{ print(""action:onComplete"")})

}
</code></pre>

<p>above code's output:</p>

<pre><code>== started == 
doOnNext :) 
onNext: [2, 4, 6, 8, 10, 12] 
doOnNext :) 
onNext: [2, 4, 6, 8, 10, 12] 
action:onComplete
</code></pre>

<p>Above code does what I want but I had to use <code>Pair</code> class. The part </p>

<pre><code>        .filter { it.second }
        .map { it.first }
</code></pre>

<p>seems not quite readable.
So is there any operator witch could simplify that code?      </p>
","1461568","","1461568","","2019-09-29 18:18:43","2019-09-29 18:42:26","How to filter list emitted by observable using result from another observable rx kotlin?","<rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"58290474","1","","","2019-10-08 16:29:00","","0","98","<p>After going through some discussions about when to dispose a <code>CompositeDisposable</code>, I wonder why we can't just add a <code>.dispose()</code> after <code>.subscribe()</code> in code.</p>

<pre><code>Observable.just(0)
    .doOnNext{...}
    .subscribe()
    .dispose()
</code></pre>

<p>What is actually happen if the code is like this? Is it ok to write like this? (instead of <code>.addTo(compositeDisposable)</code>)</p>
","5655480","","","","","2019-10-08 17:06:16","What is the problem of adding .dispose() after .subscribe()","<android><rx-java2><rx-kotlin2>","1","3","","","","CC BY-SA 4.0"
"58512028","1","58512127","","2019-10-22 20:42:11","","2","483","<p>I'm trying to create <strong>unit tests</strong> for the method of my ViewModel below, which uses <strong>RxJava/RxKotlin</strong>.</p>

<pre><code>fun doLogin(address: String, serial: String) {
    mLoading.value = true
    mCompositeDisposable.add(
        mRepository
            .doLogin(address, createJsonArray(serial, generatePinJSON()))
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribeBy(
                onSuccess = { json -&gt;
                    /** CODE **/
                },
                onError = { error -&gt;
                    /** CODE **/
                }
            )
    )
}
</code></pre>

<p>But when <strong>Schedulers.io()</strong> is invoked in the test method, it throws a NullPointerException.</p>

<p><strong>I've tried to use this approaches below:</strong></p>

<p><a href=""https://medium.com/@dbottillo/how-to-unit-test-your-rxjava-code-in-kotlin-d239364687c9"" rel=""nofollow noreferrer"">https://medium.com/@dbottillo/how-to-unit-test-your-rxjava-code-in-kotlin-d239364687c9</a> (Creating a Rule)</p>

<p><a href=""https://medium.com/@PaulinaSadowska/writing-unit-tests-on-asynchronous-events-with-rxjava-and-rxkotlin-1616a27f69aa"" rel=""nofollow noreferrer"">https://medium.com/@PaulinaSadowska/writing-unit-tests-on-asynchronous-events-with-rxjava-and-rxkotlin-1616a27f69aa</a> (Passing Schedulers to ViewModel)</p>

<p>In both approaches, it says to use <strong>Schedulers.trampoline()</strong> in test method. But it still throwing the error.</p>

<p>I'm running out of options, couldn't figure out why this happening.</p>

<p>Can someone help me?</p>

<p>Thanks.</p>
","7173179","","7173179","","2019-10-22 21:30:55","2019-10-22 21:30:55","Schedulers.io() Throwing NullPointerException in my Unit Tests","<android><unit-testing><rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"58733432","1","","","2019-11-06 15:22:43","","0","192","<p>I have this Android Kotlin code with a list of completables that are merged into a bigger one with <code>mergeDelayError()</code>, that has a timeout. When the timeout is reached, I get <code>java.util.concurrent.TimeoutException: The source did not signal an event for 250 milliseconds and has been terminated.</code></p>

<p>How can I tell which one of the small completables on the list reached the timeout without signaling/emitting anything (the actual list has more than two BTW). My ideal solution would replace such exception with something like: <code>Exception: The following operations reached a timeout: Check initial settings, Check server</code>, or at least an specific log line printed out by each timed-out completable.</p>

<p>I have no idea how to do this. My first guess would be simply adding a ""didEmit""  flag to each completable and check them one by one when the timeout is reached on the big completable, but it seems like a bad solution to me. </p>

<p>Any ideas appreciated. Thank you.</p>

<pre><code>        val smallCompletable1 = controller
        .checkInitialSettings()
        .doOnError {
            logError(it)
        }
        .ignoreElement()

        val smallCompletable2 = controller
        .checkServerStatus()
        .doOnError {
            logError(it)
        }
        .ignoreElement()

        val myCompletables: List&lt;Completable&gt; = listOf(
            smallCompletable1,
            smallCompletable2
        )

        val bigDisposable = Completable
        .mergeDelayError(myCompletables)
        .timeout(250, TimeUnit.MILLISECONDS)
        .subscribe(this::handleAllSucceeded, this::handleError)

        composition.add(bigDisposable)
</code></pre>
","1152134","","","","","2019-11-06 18:33:43","How to tell which Completables in a mergeDelayError did not signal on timeout","<android><observable><rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"59091578","1","59100045","","2019-11-28 14:58:57","","1","86","<p>To start I have the following Moshi json.</p>

<pre><code>@JsonClass(generateAdapter = true)
data class OrderDetails(
    @Json(name = ""_id"") val id: Int,
    @Json(name = ""status"") val status: String,
    @Json(name = ""tableNo"") val tableNo: Int,
    @Json(name = ""serverId"") val serverId: Int?,
    @Json(name = ""items"") val orderItems: List&lt;OrderDetailsItem&gt;
)
</code></pre>

<p>All these fields are expected to have data except for serverId.
This data is fetched from the server where I can allow the user to select order.</p>

<pre><code>onSeletedOrder
   .map { it.orderDetails.serverId } //blows up here apparently.
   .filterNotNull() //have tried this but it doesn't matter.
   .flatMap { findServerBy(it) }
   .map { ""${it.firstname} ${it.lastname}"" }
</code></pre>

<p>When I map to the serverId above I blow up with an NPE.
It's interesting that the map (even though it is optional) does an unsafe cast afterwards.
I'd expect it to maintain the optional-ness after the map.
I'm assuming this is because of the bridging backwards to RxJava.
Curious if anyone has a further explanation on why this is.</p>
","647323","","61158","","2019-11-28 17:01:51","2019-11-29 07:44:37","Unexpected NullPointException with RxKotlin when mapping optionals","<kotlin><rx-java2><rx-kotlin2>","3","3","","","","CC BY-SA 4.0"
"59408362","1","","","2019-12-19 11:02:03","","0","94","<p>I am trying to get my head around error handling in rxjava. I thought if i combine a stream of observables for instance in a zip() function that errors emitted by the observables within the zip would break the sequence and bubble up to the  subscriber onError function. However the only error caught there are the ones emmitted in the BiFunction. Errors emitted up the chain causes the system to crash. when i add onErrorReturn to the observable and return a fallback value the system still crashes. So for me that does not work as I expected. What am I missing?</p>

<pre><code>private fun getOneThing (): Single&lt;String&gt; {
    println(""getOneThing"")
    if (isOneBadCondition) {
        throw Exception()      //causes crash
    } else {
        return Single.just(""a string thing"")
    }

}

private fun getAnotherThing(): Single&lt;Boolean&gt; {
    println(""getAnotherThing"")
    if (isAnotherBadCondition) {
        throw Exception()   //causes crash
    } else {
        return Single.just(true)
    }
}

private fun createSomethingElse (): Int {
    println(""createAnother"")
    if (isBadCondition) {
        throw Exception()   //is handled onError
    } else {
        return 2
    }
}

fun errorHandlingTest() {
    Single.zip(
        getOneThing(),           //if I add onErrorReturn here it is not called after error
        getAnotherThing(),       //if I add onErrorReturn here it is not called after error
        BiFunction&lt;String, Boolean, Int&gt; { t1, t2 -&gt;
            createSomethingElse()
        }
    ).subscribeBy(
        onSuccess ={ println(it) },
        onError={ it.printStackTrace() })  //only error thrown by createSomethingElse() are caught here
}
</code></pre>
","1027594","","","","","2019-12-19 11:02:03","error not bubbling up from observables in rxjava zip function","<error-handling><rx-java2><rx-kotlin2>","0","3","","","","CC BY-SA 4.0"
"60227089","1","","","2020-02-14 13:15:12","","0","76","<p>In the android app, the process goes like that: at first, I fetch notes from local SQLite and then make Http calls for each note. I use composite disposable to hold all disposables and release them when activity is destroyed. The code looks something like that:</p>

<pre><code>class MyActivity : AppCompatActivity(){
    var compositeDisposable = CompositeDisposable()

    override fun onResume(){
        updateDatabaseData()
    }

    fun updateDatabaseData(){
        compositeDisposable.add(
            Observable.fromCallable{
                fetchDataFromDatabase()
            }
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .flatMap{
                Observable.fromIterable(it)
            }
            .flatMap{
                getUpdateStateObservable(it) // make remote HTTP call for every note in the list from local DB
            }
            .subscribe()
        )
    }

    fun getUpdateStateObservable(note:Note):UpdatedNote{
        Observable.fromCallable(
             // make HTTP call and build some UpdatedNote
        )
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
    }

    fun fetchDataFromDatabase():List&lt;Note&gt;{
        // fetch data from local DB
    }
}
</code></pre>

<p>And this code worked well until the moment when internet connection is lost. So every time HTTP calls in method <code>getUpdateStateObservable</code> is made an error is thrown. And <em>sometimes</em> it results in <code>io.reactivex.exceptions.UndeliverableException</code> pointing at line where network error in <code>getUpdateStateObservable</code> happens. And <em>sometimes it's not</em>. I've tried to use not a pool of threads but a single one as <code>Schedulers.single()</code> when making the HTTP request. And this works well. However, I'd like to process all those requests concurrently to speed them up.</p>

<p>Thanks</p>
","12898466","","9141664","","2020-02-14 13:58:39","2020-02-14 13:58:39","Why do I get UndeliverableException","<java><android><kotlin><rx-java2><rx-kotlin2>","0","2","","","","CC BY-SA 4.0"
"60603996","1","","","2020-03-09 15:44:10","","3","65","<pre><code>RxJava 2
</code></pre>

<p>I have the following where I am subscribing to 2 observables it works ok. I don't think its the best way. </p>

<p>I only want to subscribe to the second one <code>getSalesInfo</code> if the first one <code>getProductDetails</code> meets a condition. This is just a sample of what I am trying to do. If the condition is not met then nothing more will happen. </p>

<pre><code>fun main(args: Array&lt;String&gt;) {
    getProductDetails()
            .subscribeBy { productDetails -&gt;
                if (productDetails.productID == 1234) {
                    getSalesInfo().subscribeBy {
                        getSalesInfo()
                                .subscribeBy { saleInfo -&gt;
                                    println(saleInfo.salesReference)
                                }
                    }
                }
            }
}

fun getProductDetails(): Observable&lt;ProductDetails&gt; =
        Observable.just(ProductDetails(1234, ""Product One""))

fun getSalesInfo(): Observable&lt;SaleInfo&gt; =
        Observable.just(SaleInfo(""Sales Reference 1""))

data class ProductDetails(val productID: Int,
                          val productDescription: String)

data class SaleInfo(val salesReference: String)
</code></pre>

<p>Another alternative I have found is using <code>flatmap</code> that will return the second <code>SaleInfo</code> observable. I have to return a empty Observable in the else condition which doesn't look right. Is there a better way?</p>

<pre><code>getProductDetails()
            .flatMap { productDetails: ProductDetails -&gt;
                if (productDetails.productID == 1234) {
                    getSalesInfo()
                }
                else {
                    Observable.empty()
                }
            }
            .subscribeBy { saleInfo -&gt;
                println(""Using flatmap ${saleInfo.salesReference}"")
            }
</code></pre>

<p>Many thanks for any suggestions</p>
","70942","","70942","","2020-03-09 15:58:56","2020-03-12 17:56:16","Subscribing to 2 observables but only subscribe to the second one if a condition is true for the first one","<rx-java2><rx-kotlin2>","1","2","","","","CC BY-SA 4.0"
"60796695","1","","","2020-03-22 06:54:06","","0","97","<p>I am new to Rx and I am making one API call using Rx. It is working but the problem is that it is continuously making the API after I received response or error. I am using the MVVM pattern. </p>

<p>Here is my code how I am observing result in View Model:</p>

<pre><code>val usersList = getGitHubUsersUseCase.getUsers(since.toInt())

        usersList?.subscribeOn(Schedulers.io())
            ?.observeOn(AndroidSchedulers.mainThread())
            ?.subscribe({
                if (it.error == null) {
                    var sinceState = SinceState(since, since.isNotEmpty(), it.users)
                    stateLiveData.postValue(sinceState)
                } else {
                    var sinceState =
                        SinceState(since, since.isNotEmpty(), emptyList(), it.error?.message)
                    stateLiveData.postValue(sinceState)
                }
            }, {
                var sinceState = SinceState(since, since.isNotEmpty(), emptyList(), it.message)
                stateLiveData.postValue(sinceState)
            })
</code></pre>

<p>How do I stop observing once I received a response or an error? Am I missing something?</p>

<p>If I don't stop this continuously making calls, then it makes too many API calls and server start returning:</p>

<blockquote>
  <p>HTTP 403 forbidden</p>
</blockquote>
","4623481","","391691","","2020-03-23 00:01:08","2020-03-23 00:01:08","Android KotlinRx API call making continuously in background","<android><kotlin><rx-kotlin><rx-kotlin2>","1","4","","","","CC BY-SA 4.0"
"61030178","1","61041175","","2020-04-04 15:12:02","","0","60","<p>I'm new to RxJava and after a few days of trying everything I could find online I see that I really need help with this one.</p>

<p>I fetch a member in my repository with local and remote sources. I added some operators to return my remote source in priority (via debounce), and to filter out errors so it would return only 1 of the 2 if either remote is not available or the database is empty.</p>

<p>It works fine as long as something is returned by one of my 2 sources, but the problem occurs if both sources returns errors: as I filter out the errors, it doesn't return anything, and my subscribe is never called.</p>

<p>Maybe there is a simple solution but I have not found it so far, could someone help?</p>

<p>Here is my fetchMember() in my Repository:</p>

<pre><code>override fun fetchMember(): Observable&lt;MemberModel?&gt; {
    return Observable.concatArrayDelayError(memberLocalSource.fetchMember(), memberRemoteSource.fetchMember())
            .doOnNext { member -&gt;
                saveMember(member!!)
            }
            .materialize()
            .filter { !it.isOnError }
            .dematerialize { it -&gt; it }
            .debounce(400, TimeUnit.MILLISECONDS)
   }
</code></pre>

<p>And here is my viewmodel:</p>

<pre><code>fun fetchToken(username: String, password: String) {
    val loginDisposable = authApiService.loginWithJWT(username, password)
            .flatMap {
                isAuthenticated = isTokenValid(username, password, it)
                sharedPreferences.setHasValidCredentials(isAuthenticated)
                memberRepository.fetchMember()
            }
            .subscribeOn(Schedulers.io())
            .observeOn((AndroidSchedulers.mainThread()))
            .doOnError { throwable -&gt;
                throwable.printStackTrace()
            }
            .subscribe(
                    { member -&gt; 
                        memberLiveData.value = member
                        this.memberId = member!!.id.toString()
                        this.memberName = member.name.split("" "")[0]
                        if(isAuthenticated) {
                            authenticationState.value = AuthenticationState.AUTHENTICATED_VALID_MEMBER
                        } else {
                            authenticationState.value = AuthenticationState.UNAUTHENTICATED_VALID_MEMBER
                        }
                    },
                    { error -&gt;
                        if(isAuthenticated) {
                            authenticationState.value = AuthenticationState.AUTHENTICATED_INVALID_MEMBER
                        } else {
                            authenticationState.value = AuthenticationState.INVALID_AUTHENTICATION
                        }
                    })
    disposable.add(loginDisposable)
}

private fun isTokenValid(username: String, password: String, authResponse: AuthModel): Boolean {
    return if (authResponse.data != null) {
        false
    } else {
        tokenInterceptor.token = authResponse.token
        val tokenWithCredentials = AuthModel(authResponse.token, null, null, username, password)
        tokenRepository.saveToken(tokenWithCredentials)
        true
    }
}
</code></pre>
","2017921","","2017921","","2020-04-05 07:45:11","2020-04-05 10:27:54","RxJava ConcatArrayDelayError and filters: returning an error only if both sources fail","<android><observable><rx-java2><repository-pattern><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"61450873","1","61450938","","2020-04-27 02:36:04","","0","89","<p>I'm trying to convert the input streams into the file. So when user selects 1 image, it all works well. But when user selects multiple images, for example 4 then the below code is not working as expected; I see only 2 files path in Log statement. </p>

<pre><code>
compositeDisposable.add(Observable.fromIterable(inputStreamList)
                .map {
                    FileUtils.saveInputStreamToFile(it, directory, 500)
                }.toList()
                .toObservable()
                .subscribeOn(schedulerProvider.io())
                .subscribe({
                    it.forEach {file-&gt;
                        Log.d(""TAG"", ""Path ${file.path}"")
                    }
                    Log.d(""TAG"", ""Size ${it.size}"")
                }, {

                })
        )

</code></pre>

<p>Here's saveInputStreamToFile method </p>

<pre><code>
fun saveInputStreamToFile(input: InputStream, directory: File, height: Int): File? {
        val currentTime = dateFormat.format(Date())
        val imageName = ""_$currentTime""
        val temp = File(directory.path + File.separator + ""flab\$file\$for\$processing"")
        try {
            val final = File(directory.path + File.separator + imageName + "".$IMAGE_JPG"")
            val output = FileOutputStream(temp)
            try {
                val buffer = ByteArray(4 * 1024) // or other buffer size
                var read: Int = input.read(buffer)
                while (read != -1) {
                    output.write(buffer, 0, read)
                    read = input.read(buffer)
                }
                output.flush()
                saveBitmap(decodeFile(temp, height)!!, final.path, IMAGE_JPG, 80)
                return final
            } finally {
                output.close()
                temp.delete()
            }
        } finally {
            input.close()
        }
    }


</code></pre>

<p>I want the next input stream to be taken only once the current input stream is converted to file. How to achieve this? Please help</p>
","3128784","","","","","2020-04-27 03:02:53","How to make the map wait till the current index item is finished processing and then take the next item for processing using RxJava?","<android><kotlin><rx-java2><rx-android><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"61615794","1","","","2020-05-05 14:43:07","","0","128","<p>I have a publish subject with multiple subscribers: </p>

<p>Here is the class: </p>

<pre><code>class Real {

    private val publisher: PublishSubject&lt;String&gt; = PublishSubject.create()

    fun doPublish() {
        for (i in 1 until 20) {
            publisher.onNext(""$i Hello"")
        }
        publisher.onComplete()
    }

    fun doSubscribe() {
        publisher.subscribe {
            println(""Subscriber1 $it"")
        }

        publisher.subscribe {
            println(""Subscriber2 $it"")
        }

        publisher.subscribe {
            println(""Subscriber3 $it"")
        }

    }
}
</code></pre>

<p>I call <code>doSubscribe()</code> before I call <code>doPublish()</code>
The output is as follows: </p>

<pre><code> Task :Main.main()
Subscriber1 1 Hello
Subscriber2 1 Hello
Subscriber3 1 Hello
Subscriber1 2 Hello
Subscriber2 2 Hello
Subscriber3 2 Hello
Subscriber1 3 Hello
Subscriber2 3 Hello
Subscriber3 3 Hello
Subscriber1 4 Hello
Subscriber2 4 Hello
Subscriber3 4 Hello
Subscriber1 5 Hello
Subscriber2 5 Hello
Subscriber3 5 Hello
Subscriber1 6 Hello
Subscriber2 6 Hello
Subscriber3 6 Hello
Subscriber1 7 Hello
Subscriber2 7 Hello
Subscriber3 7 Hello
Subscriber1 8 Hello
Subscriber2 8 Hello
Subscriber3 8 Hello
Subscriber1 9 Hello
Subscriber2 9 Hello
Subscriber3 9 Hello
Subscriber1 10 Hello
Subscriber2 10 Hello
Subscriber3 10 Hello
Subscriber1 11 Hello
Subscriber2 11 Hello
Subscriber3 11 Hello
Subscriber1 12 Hello
Subscriber2 12 Hello
Subscriber3 12 Hello
Subscriber1 13 Hello
Subscriber2 13 Hello
Subscriber3 13 Hello
Subscriber1 14 Hello
Subscriber2 14 Hello
Subscriber3 14 Hello
Subscriber1 15 Hello
Subscriber2 15 Hello
Subscriber3 15 Hello
Subscriber1 16 Hello
Subscriber2 16 Hello
Subscriber3 16 Hello
Subscriber1 17 Hello
Subscriber2 17 Hello
Subscriber3 17 Hello
Subscriber1 18 Hello
Subscriber2 18 Hello
Subscriber3 18 Hello
Subscriber1 19 Hello
Subscriber2 19 Hello
Subscriber3 19 Hello
</code></pre>

<p>According to above program the first subscriber receives the event first followed by second and third, this is exactly as per the order of subscription. </p>

<p>Is this order of execution guaranteed? As I am not able to find relevant documentation regarding this. </p>
","2822178","","2822178","","2020-05-05 15:51:08","2020-05-06 08:48:23","Order of events received by subscribers of a Publish Subject","<kotlin><rx-java><rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"62216211","1","62217720","","2020-06-05 13:14:55","","0","354","<p>So I'm completely new to rx-java/rx-kotlin and haven't heard about it until I where to write a HTTP filter in Micronaut (<a href=""https://docs.micronaut.io/latest/guide/index.html#filters"" rel=""nofollow noreferrer"">https://docs.micronaut.io/latest/guide/index.html#filters</a>) which caught me off guard since I've only done regular JAX-RS filters.</p>

<p>So after doing some trial-and-error I came up with this. </p>

<pre><code> return Flowable.fromPublisher(remoteClient.getPermissions(userId))
        .subscribeOn(Schedulers.io())
        .onErrorReturn { e -&gt;
            logger.error(""Error when fetching users from remote service"", e)
            emptyList()
        }
        .switchMap { permissions -&gt;
            if (permissions.contains(somePermission)) {
                chain.proceed(request)
            } else {
                val response = HttpResponseFactory.INSTANCE.status(
                    HttpStatus.FORBIDDEN,
                    ""No user found""
                )
                Flowable.just(response)
            }
        }
</code></pre>

<p>Code is rewritten but point still stands. There's some room for improvement here.</p>

<p>What I'd like to do is to improve the exception handling and return a 500 in the case an exception is thrown (like if the remote service called by <code>remoteClient</code> isn't reachable. How can I accomplish this? I haven't got anything else to work other than the solution above to return an empty list for the next observer.</p>
","9602455","","9602455","","2020-06-05 13:38:10","2020-06-05 14:30:31","How to handle exception when doing request to external service and return status accordingly in Micronaut filter","<rx-java2><micronaut><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"63535869","1","","","2020-08-22 11:51:29","","0","97","<p>I have a scenario where I have to fetch some string asynchronously. I would like to create a method where I can listen to when this value is fetched successfully and then provided to the listener.
Now, this can be done easily via many ways including a callback listener or a lambda.</p>
<p>But what do I use so that all subsequent calls to this method, also provide the string back - without having to fetch it again, as it has already been fetched once. So a solution where the listener is still attached but is provided the value right away since it is available.
I know how to do this via old fashioned callback listeners, where the value is stored and then for subsequent calls it can be returned right away via the callback.</p>
<p>But is there a more compact/sophisticated way to do it, let's say via Rx?</p>
<p>Thanks.</p>
","966739","","","","","2020-08-23 08:20:53","RxJava/RxKotlin: Wait for value to be fetched async and then provide to all subscribers","<kotlin><asynchronous><listener><rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"63574115","1","63574703","","2020-08-25 07:36:11","","1","81","<p>I have the following class, which exposes a Single to fetch an ID.</p>
<p>This is used to fetch the ID on init of that class and later others can also use this to get the ID.</p>
<p>Any where else from where I subscribe to this Single, I am able to get the ID. But in the init method here, this method doesn't seem to start and fetch the ID.</p>
<p>Could someone please help me understand what I am missing?
Thanks</p>
<pre><code>class TestClass {

val idObservable: Single&lt;String&gt;
    get() {
        return Single.create {
            fetchId(it)
        }
    }

init {
    idObservable
        .subscribe { success, _ -&gt;
            Log.d(TAG, &quot;Id: $success&quot;)
        }
        .dispose()
}

private fun fetchId(emitter: SingleEmitter&lt;String&gt;) {
    Utils.fetchId(Consumer&lt;String&gt;{
        emitter.onSuccess(it)

    }, Consumer&lt;Throwable&gt;{
        emitter.onSuccess(&quot;&quot;)
    })
}
</code></pre>
<p>}</p>
","966739","","","","","2020-08-25 08:15:43","RxKotlin, RxJava: Observable/Single not starting","<observable><rx-java><rx-java2><publish-subscribe><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"63777591","1","63787395","","2020-09-07 12:25:27","","3","3703","<p>I am new to Android development with Kotlin and I am struggling on finding any useful documentation on how to create a simple GET and POST requests with the best current practices as possible. I am coming from an Angular development and there we used a reactive development using RxJS.</p>
<p>Normally I would create a service file that would hold all my request functions, then I would use this service in whichever component and subscribe to the observable.</p>
<p>How would you do this in Android? Is there a good started example of things that have to be created. From the first look, everything looks so complicated and over-engineered</p>
","8358839","","","","","2020-09-08 05:05:18","Simple HTTP request example in Android using Kotlin","<android><kotlin><rx-android><rx-kotlin><rx-kotlin2>","3","1","1","","","CC BY-SA 4.0"
"64273179","1","","","2020-10-09 02:36:34","","0","187","<p>I am getting callback event from an object twice sometime thrice but I need to collect only one object that will be the latest one. Is it possible with RX kotlin?</p>
","5751854","","","","","2021-04-26 10:15:27","RXKotlin - How to receive single event","<android><kotlin><rx-java><rx-kotlin2>","3","1","","","","CC BY-SA 4.0"
"65040953","1","65163363","","2020-11-27 16:48:09","","0","48","<p>I have a method which perform network request and return Observable with mutable list of data class.
Sometimes this method fails with 403 error. I need call YouTubeClient.getApiKey() method for getting new Api key and repeat request to network. How to do it? I read a lot of similar topics but didn't find working decision.</p>
<p>This code of utility method, when i try to call retryWhen() method</p>
<pre><code>private fun searchRequestWrapper(query: String): Observable&lt;MutableList&lt;Video&gt;&gt; {
    return youTubeClient.searchRequest(
        YouTubeClient.URL_SNIPPET,
        YouTubeClient.MAX_RESULT, query,
        YouTubeClient.API_KEY
    )
        .retryWhen { errors -&gt; errors
            .zipWith(Observable.range(1, 3)) { error, a -&gt;
                YouTubeClient.getApiKey()
                error
            }
        }
        .map {it.items}
}
</code></pre>
<p>Main method which call utility method inside itself below</p>
<pre><code>fun fetchVideos(query:String) {
    _networkState.set(NetworkState.LOADING)
    Log.e(&quot;NetworkState&quot;, networkState.get()?.status.toString())

    try {
        compositeDisposable.add(
            searchRequestWrapper(query)
            .flatMapIterable {it}
            .flatMap { video -&gt; videoInfoWrapper(video.videoId).subscribeOn(Schedulers.io()) }
            .toList()
            .subscribeOn(Schedulers.io())
            .subscribe({
                Log.e(&quot;new videosId&quot;,it.toString())
                downloadedVideosList.postValue(it)
                _networkState.set(NetworkState.LOADED)
                Log.e(&quot;NetworkState&quot;, networkState.get()?.status.toString())
                _networkState.set(NetworkState.WAITING)
                Log.e(&quot;NetworkState&quot;, networkState.get()?.status.toString())
            },{
                errorHandle(it)
            }))
    }
    catch (e: Exception){
        Log.e(&quot;fetchVideos&quot;,e.message)
    }
}
</code></pre>
","","user14618921","286934","","2020-11-27 16:51:47","2020-12-06 00:14:20","How to call a method multiple times using RxJava's method retryWhen?","<java><kotlin><rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"65818735","1","","","2021-01-20 22:40:15","","0","66","<p>Observable emits trade objects.
How to make operation on each emission into one result object?</p>
<p>Trade(tradeType: String, profit: BigDecimal)
Result(totalProfit: BigDecimal)</p>
<p>Example:</p>
<pre><code>trades
.scan(result: Result, currentTrade: Trade){
  result.totalProfit += currentTrade.profit
}
.subscribe(
 printLn(it.totalProfit)
)
</code></pre>
","1924107","","","","","2021-01-20 23:29:53","How to collect every observable emittion into one object in rxJava2/rxKotlin2?","<rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"
"67040162","1","67055925","","2021-04-10 23:25:57","","1","41","<p>I have a list of recurring elements in Kotlin, say:</p>
<pre><code>val result = arrayListOf&lt;String&gt;(&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;, &quot;AA&quot;, &quot;BB&quot;)
</code></pre>
<p>I would like to group them by their value along with how many times they appear, so the output would be pairs of:</p>
<pre><code>{&quot;AA&quot;, 2}, {&quot;BB&quot;, 2}, {&quot;CC&quot;, 1}
</code></pre>
<p>I have resolved the problem using in Kotlin as follows:</p>
<pre><code>val ans = result.map { it.value }
            .groupBy { it }
            .map { Pair(it.key, it.value.size) }
            .sortedByDescending { it.second }
</code></pre>
<p>I want to write same code in RxKotlin for learning and tried with the following but do not know how to apply <code>map</code>/<code>flatMap</code> to achieve the result.</p>
<pre><code>val source = Observable.fromIterable(result)
source.groupBy{ it }.subscribe { showresult(it) }
</code></pre>
","1154390","","10082297","","2021-04-10 23:28:30","2021-04-12 09:27:43","RxKotlin COUNT with GROUP BY and return a list","<kotlin><rx-java><rx-kotlin><rx-kotlin2>","1","2","","","","CC BY-SA 4.0"
"67293882","1","67295389","","2021-04-28 04:42:01","","0","46","<p>I'm trying to create a BLE service that will scan for devices and using rxKotlin create an observable that will allow another class to observe when a device is found. I'm confused on how to create the observable that will allow another class to subscribe and tutorials are all over the place. Can someone give me a pointer on how to do so or a good tutorial.</p>
<p>Bluetoothservice class callback where devices are discovered</p>
<pre><code>var foundDeviceObservable: Observable&lt;BluetoothDevice&gt; = Observable.create {  }

private val scanCallback = object : ScanCallback() {
    override fun onScanResult(callbackType: Int, result: ScanResult) {
        with(result.device) {
            var foundName = if (name == null) &quot;N/A&quot; else name
            foundDevice = BluetoothDevice(
                foundName,
                address,
                address,
                result.device.type.toString()
            )
            foundDeviceObservable.subscribe {
               //Update Observable value?
            }
        }
    }
}

class DeviceListViewModel(application: Application) : AndroidViewModel(application) {
    private val bluetoothService = BLEService()

    //Where I am trying to do logic with device
    fun getDeviceObservable(){
        bluetoothService.getDeviceObservable().subscribe{ it -&gt;
        
    }
}
</code></pre>
<p><strong>Solution</strong></p>
<p>Was able to find the solution after reading user4097210's reply. Just had to change the found device to</p>
<pre><code>var foundDeviceObservable: BehaviorSubject&lt;BluetoothDevice&gt; = BehaviorSubject.create()
</code></pre>
<p>and then call the next method in the callback</p>
<pre><code>private val scanCallback = object : ScanCallback() {
    override fun onScanResult(callbackType: Int, result: ScanResult) {
        with(result.device) {
            var foundName = if (name == null) &quot;N/A&quot; else name
            foundDevice = BluetoothDevice(
                foundName,
                address,
                address,
                result.device.type.toString()
            )
            foundDeviceObservable.onNext(foundDevice)
        }
    }
}
</code></pre>
","4990578","","4990578","","2021-04-30 00:59:58","2021-04-30 00:59:58","Android BLE RxKotlin","<android><kotlin><rx-java2><rx-kotlin2>","1","0","","","","CC BY-SA 4.0"