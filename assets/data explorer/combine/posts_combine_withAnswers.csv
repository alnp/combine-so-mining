Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"56487777","1","56508182","","2019-06-07 04:00:26","","10","6039","<p>I am trying to recreate the SwiftUI project demonstrated in Session 204  but am running into some peculiar issues.</p>

<p>I wrote this from watching the session found here: <a href=""https://developer.apple.com/videos/play/wwdc2019/204"" rel=""noreferrer"">https://developer.apple.com/videos/play/wwdc2019/204</a></p>

<p>Here is my code-</p>

<p>ContentView.swift:</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
struct ContentView : View {
    @ObjectBinding var store = RoomStore()

    var body: some View {
        NavigationView {
            List {
                Section {
                    Button(action: addRoom) {
                        Text(""Add Room"")
                    }
                }

                Section {

                    ForEach(store.rooms) { room in //Error: Cannot convert value of type '(Room) -&gt; RoomCell' to expected argument type '(_) -&gt; _'
                        RoomCell(room: room)
                    }
                    .onDelete(perform: delete)
                    .onMove(perform: move)
                }
            }
            .navigationBarTitle(Text(""Rooms"") )
            .NavigationBarItems(trailing: EditButton())
            .listStyle(.grouped)
        }
    }

    func addRoom() {
        store.rooms.append(Room(name: ""Hall 2"", capacity: 2000))
    }
    func delete(at offsets: IndexSet) {
        store.rooms.remove(atOffsets: offsets) //Error: Incorrect argument label in call (have 'atOffsets:', expected 'at:')
    }
    func move(from source: IndexSet, to destination: Int) {
        store.rooms.move(fromOffsets: source, toOffset: destination) //Error: Value of type '[Room]' has no member 'move'; did you mean 'remove'?
    }
}

#if DEBUG
struct ContentView_Previews : PreviewProvider {
    static var previews: some View {
        Group {
            ContentView(store: RoomStore(rooms: testData))
            ContentView(store: RoomStore(rooms: testData))
            .environment(\.sizeCategory, .extraExtraExtraLarge)
            ContentView(store: RoomStore(rooms: testData))
            .environment(\.colorScheme, .dark)
            ContentView(store: RoomStore(rooms: testData))
            .environment(\.layoutDirection, .rightToLeft)
            .environment(\.locale, Locale(identifier: ""ar""))
        }
    }
}
#endif
struct RoomCell : View {
    let room: Room
    var body: some View {
        return NavigationButton(destination: RoomDetail(room: room) )
        {
            Image(room.thumbnailName)
            .cornerRadius(8)
            VStack(alignment: .leading) {
                Text (room.name)
                Text (""\(room.capacity) peopje"")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
        }
    }
}
</code></pre>

<p>Room.swift:</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI

struct Room {
    var id = UUID()
    var name: String
    var capacity: Int
    var hasVideo: Bool = false
    var imageName: String { return name }
    var thumbnailName: String { return name + ""Thumb"" }

}

#if DEBUG

let testData = [
    Room(name: ""Observation Deck"", capacity: 6, hasVideo: true),
    Room(name: ""Executive Suite"", capacity: 8, hasVideo: false),
    Room(name: ""Charter Jet"", capacity: 16, hasVideo: true),
    Room(name: ""Dungeon"", capacity: 10, hasVideo: true),
    Room(name: ""Panorama"", capacity: 12, hasVideo: false),
    Room(name: ""Oceanfront"", capacity: 8, hasVideo: false),
    Room(name: ""Rainbow Room"", capacity: 10, hasVideo: true),
    Room(name: ""Pastoral"", capacity: 7, hasVideo: false),
    Room(name: ""Elephant Room"", capacity: 1, hasVideo: false),

]

#endif
</code></pre>

<p>RoomDetail.swift:</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
struct RoomDetail : View {
    let room: Room
    @State private var zoomed = false
    var body: some View { //Error: Function declares an opaque return type, but has no return statements in its body from which to infer an underlying type
        ZStack(alignment: .topLeading) {
            Image(room.imageName )
                .resizable()
                .aspectRatio(contentMode: zoomed ? .fill : .fit)
                .navigationBarTitle(Text(room.name), displayMode:
                    .inline)
                .tapAction { withAnimation(.basic(duration: 2)) {
                    self.zoomed.toggle() } }
            }
            .frame(minWidth: 0, maxWidth: .infinity, minHeight:
                0, maxHeight: .infinity)
            if room.hasVideo &amp;&amp; !zoomed {
                Image(systemName: ""video. fill"")
                    .font(.title)
                    .padding(.all)
                    .transition(.move(edge: .leading) )
            }
        }
}

#if DEBUG
struct RoomDetail_Previews : PreviewProvider {
    static var previews: some View {
        Group {
            NavigationView { RoomDetail(room: testData[0]) }
            NavigationView { RoomDetail(room: testData[1]) }
        }
}
}
#endif
</code></pre>

<p>RoomStore.swift:</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

class RoomStore : BindableObject {
    var rooms: [Room] {
        didSet { didChange.send(Void()) } //Solved
    }
    init(rooms: [Room] = []) {
        self.rooms = rooms
    }
    var didChange = PassthroughSubject&lt;Void, Never&gt;()
}
</code></pre>

<p>Error messages included in context, as comments, in above code.</p>
","11430555","","11430555","","2019-06-08 01:22:47","2020-01-18 00:25:55","Issues While Trying To Recreate SwiftUI-based App From WWDC Session","<swift><swiftui>","7","1","2","","","CC BY-SA 4.0"
"56498019","1","56501154","","2019-06-07 16:18:47","","3","897","<p>In Swift, this crashes at runtime:</p>

<pre><code>class EmptyData: BindableObject {
    let didChange = PassthroughSubject&lt;EmptyData, Never&gt;()
}

struct RandomView : View {
    @EnvironmentObject var emptyData: EmptyData
    @EnvironmentObject var emptyData2: EmptyData

    var body: some View {
        Text(""Hello World!"")
    }
}
</code></pre>

<p>and in the <code>SceneDelegate.swift</code>:</p>

<pre><code>func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
    let window = UIWindow(frame: UIScreen.main.bounds)
    // The emptyData variables are not initialized as seen below
    window.rootViewController = UIHostingController(rootView: RandomView())
    self.window = window
    window.makeKeyAndVisible()
}
</code></pre>

<blockquote>
  <p>Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)</p>
</blockquote>

<p>Fixing the problem isn't that hard, but rather strange:</p>

<pre><code>window.rootViewController = UIHostingController(rootView: RandomView().environmentObject(EmptyData()))
</code></pre>

<p>So what's happening here? I pass <code>EmptyData()</code> and SwiftUI decides that both <code>emptyData</code> and <code>emptyData2</code> should be initialized with the same object reference? I can pass also other environmentobjects that do not even exists as variables in the <code>RandomView</code> instance:</p>

<pre><code>window.rootViewController = UIHostingController(rootView: RandomView().environmentObject(EmptyData()).environmentObject(SomeData()))
</code></pre>

<p>And SwiftUI just happily run, although <code>SomeData()</code> isn't used anywhere in the instance of <code>RandomView()</code> and should trigger a compile time error in my opinion.</p>

<p>Why are uninitialized values permitted at compile time without initializing them when initializing the object and why are we free to pass environment instances without doing anything with them? Looks a bit like Javascript to me, I loved the strong static safe typing in Swift... I don't see right away why the member-wise initializer just generates an initializer which takes the environment variables as it's parameter.</p>
","7715250","","","","","2019-06-08 01:50:46","Why/when are uninitialized non-optional values allowed in Swift for EnvironmentObjects?","<swift><swiftui>","2","0","1","","","CC BY-SA 4.0"
"56500147","1","56503347","","2019-06-07 19:20:13","","1","2674","<p>Im using the new SwiftUI. I have a <code>UserUpdate</code> class which is a <code>Bindable Object</code> and I want to modify these variables and automatically Update the UI. </p>

<p>I update these Values successfully but the views in my UI struct isn't updating when I change the variable in the <code>UserUpdate</code> class. </p>

<p>It <strong>only</strong> changes when I modify the <code>@EnviromentObject</code> variable in the UI struct itself.</p>

<p>That's my Bindable Object Class:</p>

<pre><code>final class UserUpdate: BindableObject {
    let didChange = PassthroughSubject&lt;Any, Never&gt;()

    var allUsers: [User] = [] {
        didSet {
            print(allUsers)
            didChange.send(allUsers)
        }
    }

    var firstName: String = """" {
        didSet {
            didChange.send(firstName)
        }
    }

    var lastName: String = """" {
        didSet {
            didChange.send(lastName)
        }
    }
}
</code></pre>

<p>That's my User class:</p>

<pre><code>struct User: Identifiable {
    let id: Int
    let firstName, lastName: String
}
</code></pre>

<p>Here's how I configure my UI:</p>

<pre><code>struct ContentView : View {
    @EnvironmentObject var bindableUser: UserUpdate

    var body: some View {
        NavigationView {
            VStack(alignment: .leading) {
                Text(""All Users:"").bold().padding(.leading, 10)
                List {
                    ForEach(bindableUser.allUsers) { user in
                        Text(""\(user.firstName) \(user.lastName)"")
                    }
                }
            }
        }
    }
}
</code></pre>

<p><strong>Here I modify the variables in <code>UserUpdate</code>:</strong></p>

<pre><code>class TestBind {
    static let instance = TestBind()

    let userUpdate = UserUpdate()

    func bind() {
        let user = User(id: userUpdate.allUsers.count, firstName: ""Heyy"", lastName: ""worked"")
        userUpdate.allUsers.append(user)
    }
}
</code></pre>
","11411002","","1226963","","2019-06-07 22:24:19","2019-06-08 10:04:37","How to use BindableObjects (EnviromentObject)?","<ios><swift><swiftui>","2","5","","","","CC BY-SA 4.0"
"56505189","1","56505224","","2019-06-08 09:40:36","","3","1565","<p>I'm trying to use the new <strong>Combine</strong> framework with the <strong>Notification Center</strong> as Apple explained in this video:
<a href=""https://developer.apple.com/videos/play/wwdc2019/721/"" rel=""nofollow noreferrer"">https://developer.apple.com/videos/play/wwdc2019/721/</a></p>

<p>You can find it in the slide 21.</p>

<p>It seems that my project does not read the Combine framework apis.</p>

<pre><code>import Combine
import Foundation

let trickNamePublisher = NotificationCenter.default.publisher(for: .newTrickDownloaded)
</code></pre>

<p>And i'm getting this error:</p>

<p><strong>Value of type 'NotificationCenter' has no member 'publisher'</strong></p>
","6747915","","6747915","","2019-06-08 09:47:15","2019-06-18 23:46:44","iOS Swift: Value of type 'NotificationCenter' has no member 'publisher'","<ios><swift><combine>","2","0","1","","","CC BY-SA 4.0"
"56513863","1","56513996","","2019-06-09 10:37:00","","3","697","<p>I'm playing around with SwiftUI using an EnvironmentObject for my data source. I'm wondering how I can mock this when using the PreviewProvider.</p>

<p>Example code below:</p>

<pre><code>struct ListView: View {
    @State private var query: String = ""Swift""
    @EnvironmentObject var listData: ListData

    var body: some View {
        NavigationView {
            List(listData.items) { item in
                ListItemCell(item: item)
            }
        }.onAppear(perform: fetch)
    }

    private func fetch() {
        listData.fetch()
    }
}

struct ListView_Previews: PreviewProvider {
    static var previews: some View {
        How do I mock this?
        // ListView(listData: EnvironmentObject&lt;ListData&gt;)
    }
}

class ListData: BindableObject {
    var items: [ListItem] = [] {
        didSet {
            didChange.send(self)
        }
    }

    var didChange = PassthroughSubject&lt;ListData, Never&gt;()

    func fetch() {
        // async call that updates my items
        self?.items = someNetworkResponse
    }
}
</code></pre>
","3418097","","3418097","","2019-06-09 10:42:28","2019-06-09 10:56:00","Mocking an EvironmentObject in PreviewProvider","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"56522258","1","56522391","","2019-06-10 07:31:14","","9","3552","<p>I watched the WWDC 2019 session ""Combine in Practice"" (<a href=""https://developer.apple.com/videos/play/wwdc2019/721/"" rel=""noreferrer"">https://developer.apple.com/videos/play/wwdc2019/721/</a>).</p>

<p>In the video they used the following syntax to create a publisher:</p>

<pre class=""lang-swift prettyprint-override""><code>@Published var someName: String = """"
</code></pre>

<p>They did this so that <code>someName</code> becomes a publisher. However, Xcode doesn't like this syntax and gives me an error:</p>

<blockquote>
  <p>Unknown attribute 'Published</p>
</blockquote>

<p>I have no idea why. I'm using the Xcode 11 beta on macOS Catalina.</p>

<p>Any ideas?</p>
","3134192","","1045055","","2019-06-10 08:32:22","2019-06-25 20:07:24","IOS 13 Combine Framework - @Published not working (""Unknown attribute 'Published'"")","<ios><swift><combine>","2","0","","","","CC BY-SA 4.0"
"56533059","1","56540726","","2019-06-10 20:22:20","","12","7074","<p>Trying to get current location with using swiftUI. Below code, couldn't initialize with didUpdateLocations delegate.   </p>

<pre><code>class GetLocation : BindableObject {
    var didChange = PassthroughSubject&lt;GetLocation,Never&gt;()

    var location : CLLocation {
        didSet {
            didChange.send(self)
        }
    }
    init() {}
}
</code></pre>
","7257782","","14684839","","2020-12-03 16:26:02","2021-04-04 16:13:22","How to get Current Location with SwiftUI?","<swift><xcode><swiftui><cllocation>","3","1","5","","","CC BY-SA 4.0"
"56548040","1","56548508","","2019-06-11 16:24:45","","4","1324","<p>I've been trying to follow the 'Introducing SwiftUI - Building Your First App' WWDC 19 video. No sample code is provided for this talk but I've been creating it as the presenter goes along. When trying to create a store though I get an  error that 'Cannot invoke 'send' with no arguments' from the line: </p>

<pre><code>didSet { didChange.send() }
</code></pre>

<p>I'm new to programming and struggling to troubleshoot. </p>

<pre><code>import SwiftUI
import Combine

class ReferenceStore : BindableObject {
    var references: [Reference] {
        didSet { didChange.send() }
    }

    init(references: [Reference] = []) {
        self.references = references
    }

    var didChange = PassthroughSubject&lt;Void, Never&gt;()
}
</code></pre>

<p>I'm using Xcode 11 beta and MacOS Catalina if it helps.</p>
","11632288","","","","","2019-07-25 19:21:49","How to fix ""Cannot invoke 'send' with no arguments"" in Swift 5.1","<swift><swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"56551108","1","56551175","","2019-06-11 20:14:06","","7","2652","<p>I am using Combine and SwiftUI to do some async stuff, the point is that I don't know how to receive the response from the asynchronous operation in the main thread. The <a href=""https://developer.apple.com/documentation/combine/publisher/3204743-receive"" rel=""noreferrer"">apple doc</a> says that it can be used the RunLoop.main, but currently in Swift 5.0 it isn't a Scheduler. So any ideas about this?</p>

<p>I have tried to use as per apple doc, but no luck.</p>

<pre class=""lang-swift prettyprint-override""><code>anyPublisher
    .receiveOn(on: RunLoop.main)
</code></pre>
","4536762","","","","","2019-06-17 18:55:19","How to change thread using combine Publisher?","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"56551131","1","56551323","","2019-06-11 20:16:04","","48","19688","<p><a href=""https://developer.apple.com/tutorials/swiftui/handling-user-input"" rel=""noreferrer"">This tutorial by Apple about SwiftUI</a> uses a dollar sign to bind data, and I‘m having trouble finding more information about this data binding in SwiftUI.</p>

<pre><code>Toggle(isOn: $showFavoritesOnly) {
</code></pre>

<blockquote>
  <p>You use the $ prefix to access a binding to a state variable, or one of its properties.</p>
</blockquote>

<p>Is this some sort of <code>inout</code> type parameter? That uses the ampersand to pass it on.</p>
","1009013","","1265393","","2022-04-15 19:48:03","2022-04-15 19:48:03","What does the dollar sign do in Swift / SwiftUI?","<swift><swiftui><combine>","2","1","5","","","CC BY-SA 4.0"
"56552993","1","56612756","","2019-06-11 23:51:15","","4","1471","<p>I was experimenting with SwiftUI and came across a problem while implementing the data model for one of my List. My plan was to create a protocol <code>CardProtocol</code> as the data protocol for the elements of my lists and then have a CoreData implementation of the protocol as well as a dummy one for unit testing and Canvas use. If you are using a data collection in SwiftUI <code>List</code> the single elements need to conform to the <code>Identifiable</code> protocol.  </p>

<p>The code looks like this:</p>

<pre><code>import SwiftUI
import Combine


final class CardsModel: BindableObject {
    var cards: [CardProtocol] = []
    let didChange = PassthroughSubject&lt;CardsModel, Never&gt;()
}

protocol CardProtocol: Identifiable {
    var id: Int { get set }
    var firstName: String? { get set }
    var lastName: String? { get set }
    var email: String? { get set }
    var phone: String? { get set }
}
</code></pre>

<p>This will not even compile as the <code>Identifiable</code> protocol has 2 associated types which needs to be specified if the protocol is to be used for a variable definition.</p>

<pre><code>/// A type that can be compared for identity equality.
public protocol Identifiable {

    /// A type of unique identifier that can be compared for equality.
    associatedtype ID : Hashable

    /// A unique identifier that can be compared for equality.
    var id: Self.ID { get }

    /// The type of value identified by `id`.
    associatedtype IdentifiedValue = Self

    /// The value identified by `id`.
    ///
    /// By default this returns `self`.
    var identifiedValue: Self.IdentifiedValue { get }
}
</code></pre>

<p>The exact error being <code>error: protocol 'CardProtocol' can only be used as a generic constraint because it has Self or associated type requirements</code>.
Now <code>ID</code> is not an issue and can be fixed, but <code>IdentifiedValue</code> it's by nature different in the CoreData and the dummy implementation.</p>

<p>The only reasonable solution that I found was to remove compliance to <code>Identifiable</code> from the protocol and reintroduce it later in the View using <code>cardsModel.cards.identified(by: \.id)</code>. Is there any better way out of this, that let me keep the Identifiable compliance at protocol level?</p>
","2028375","","2028375","","2019-06-15 16:30:27","2019-06-15 17:44:22","Indentifiable Protocol extension for SwiftUI list data","<ios><swift><swiftui><combine>","2","2","","","","CC BY-SA 4.0"
"56555709","1","56555883","","2019-06-12 06:15:00","","25","2965","<p>I am trying to use <code>environmentObject</code> in a watchOS6 app to bind my data model to my view.</p>

<p>I have created a simple, stand-alone Watch app in Xcode 11.</p>

<p>I created a new <code>DataModel</code> class</p>

<pre><code>import Combine
import Foundation
import SwiftUI

final class DataModel: BindableObject {

    let didChange = PassthroughSubject&lt;DataModel,Never&gt;()

    var aString: String = """" {
        didSet {
            didChange.send(self)
        }
    }

}
</code></pre>

<p>In my <code>ContentView</code> struct I bind this class using <code>@EnvironmentObject</code> - </p>

<pre><code>struct ContentView : View {

    @EnvironmentObject private var dataModel: DataModel

    var body: some View {
        Text($dataModel.aString.value)
    }
}
</code></pre>

<p>Finally, I attempt to inject an instance of the <code>DataModel</code> into the environment in the <code>HostingController</code> class -</p>

<pre><code>class HostingController : WKHostingController&lt;ContentView&gt; {
    override var body: ContentView {
        return ContentView().environmentObject(DataModel())
    }
}
</code></pre>

<p>But, I get an error:</p>

<pre><code>Cannot convert return expression of type '_ModifiedContent&lt;ContentView, _EnvironmentKeyWritingModifier&lt;DataModel?&gt;&gt;' to return type 'ContentView'
</code></pre>

<p>The error is because the <code>WKHostingController</code> is a generic that needs a concrete type - <code>WKHostingController&lt;ContentView&gt;</code> in this case.  </p>

<p>A similar approach works perfectly with <code>UIHostingController</code> in an iOS app because <code>UIHostingController</code> isn't a generic class.</p>

<p>Is there some other way to inject the environment to a watchOS view?</p>
","3418066","","","","","2020-04-08 20:45:53","Using environmentObject in watchOS","<swift><apple-watch><watchos><swiftui><watchos-6>","3","1","6","","","CC BY-SA 4.0"
"56571316","1","56691371","","2019-06-12 22:54:27","","3","1716","<p>In Apple's WWDC videos on <code>Swift Combine</code>, they always use <code>NSNotificationCenter</code> as the publisher of messages. However, a <code>Publisher</code> does not appear to have any ability to actually send a message on demand. That functionality appears to be in <code>Subject</code>.</p>

<p>Am I correct in assuming that a <code>Subject</code> must therefor be the root object of any chain of <code>Publishers</code>? Apple provides two built-in subjects called: <code>CurrentValueSubject</code> and <code>PassthroughSubject</code>.</p>

<p>But I assume I can write my own <code>Subject</code> using the appropriate protocols? </p>
","48321","","310175","","2019-06-20 18:27:31","2019-06-20 18:27:31","In Swift Combine, is the ""root"" object always a Subject?","<swift><swift5><combine>","1","0","2","","","CC BY-SA 4.0"
"56579501","1","56689905","","2019-06-13 11:31:52","","15","8970","<p>In Apple's 2019 WWDC video <code>Swift Combine in Practice</code>, they demonstrate using a <code>debounce</code> publisher to slow down the rate of messages. </p>

<pre><code>return $username
  .debounce(for: 0.5, scheduler: RunLoop.main)
  .removeDuplicates()
  .eraseToAnyPublisher()
</code></pre>

<p>However, anytime I attempt to use it in a similar fashion, I get the following error: </p>

<blockquote>
  <p>Cannot invoke 'debounce' with an argument list of type '(for: Double, scheduler: RunLoop)'</p>
</blockquote>

<p>The <code>debounce()</code> signature is: </p>

<pre><code>public func debounce&lt;S&gt;(for dueTime: S.SchedulerTimeType.Stride, 
                          scheduler: S,
                            options: S.SchedulerOptions? = nil) -&gt; 
                                    Publishers.Debounce&lt;Self, S&gt; where S : Scheduler
</code></pre>

<p><code>SchedulerTimeType.Stride</code> appears to be initializable with a numeric but it's not working for me or my inexperience with Swift Generics is on display. </p>

<p>What is the correct way to call this? </p>

<p><strong>Edit</strong></p>

<p>Duplicate of <a href=""https://stackoverflow.com/questions/56564967"">this question...</a></p>

<p>Searching for generic words like ""Combine"" is, for now, rather challenging... </p>

<p><em>macOS 10.15, Xcode 11</em></p>
","48321","","310175","","2019-06-20 18:27:22","2019-06-23 01:44:35","What is the correct syntax for using Publishers.debounce() in Swift Combine?","<swift><swift5><combine>","1","1","1","","","CC BY-SA 4.0"
"56599013","1","56600399","","2019-06-14 13:16:34","","-2","455","<p>i want to signup users when they click the signup button in my app. When the signup is complete and successfully created a user on the server side I want to present the next screen and <strong>only</strong> then. </p>

<p>In normal way I have a PresentationButton and set the destination and when somebody clicked the button the next screen is presented directly, but now it's async. </p>

<p>How to handle that?</p>

<p>Currently I have this PresentationButton:</p>

<pre><code>PresentationButton(
                Text(isSignIn ? ""SignIn"" : ""Next"").font(.headline).bold()
                    .frame(width: 100)
                    .padding(10)
                    .foregroundColor(.white)
                    .background(Color.blue)
                    .cornerRadius(20)
                , destination: HomeScreen()
            )
</code></pre>

<p>That's with the suggestion by Uro Arangino:</p>

<pre><code>struct PasswordView : View {
    @State private var password = """"
    @State private var showNextScreen = false

    var loginMode: LoginType

    @ObjectBinding var signupManager = SignUpManager()

    var body: some View {
        VStack {
//            if self.signupManager.showModal { self.showNextScreen.toggle() } &lt;- Can't do this

            TwitterNavigationView(backBtnOn: false)
            middleView()
            Spacer()
            bottomView()
        }
    }

    func bottomView() -&gt; some View {
        return VStack(alignment: .trailing) {
            Divider()
            BindedPresentationButton(
                showModal: $showNextScreen,
                label: getCustomText((Text(""Registrieren""))),
                destination: HomeTabView(),
                onTrigger: {
                    let user = User(name: ""rezo"", username: ""ja lol ey"", profileDescription: ""YAS"", email: ""dbjdb@dedde.de"", telephoneNumber: nil, profileImage: UIImage(named: ""twitter-logo"")!, bannerImage: UIImage(systemName: ""star"")!)
                    self.signupManager.signIn(forUser: user, password: ""ultraSecure"", loginMode: .email)
//                UserDefaults.standard.set(true, forKey: ""loggedIn"")
            })
        }.padding([.leading, .trailing]).padding(.top, 5).padding(.bottom, 10)
    }
}
</code></pre>

<p>My bindable object class</p>

<pre><code>final class SignUpManager: BindableObject {
let didChange = PassthroughSubject&lt;SignUpManager, Never&gt;()

var showModal: Bool = false {
    didSet {
        didChange.send(self)
    }
}

func signIn(forUser user: User, password: String, loginMode: LoginType) {
    if loginMode == .email {
        LoginService.instance.signupWithEmail(user: user, andPassword: password, completion: handleCompletion)
    } else {
        LoginService.instance.login(withPhoneNumber: user.telephoneNumber!, completion: handleCompletion)
    }
}

private func handleCompletion(_ status: Bool) {
    if status {
        showModal = true
    }
}
</code></pre>

<p>}</p>
","11411002","","11411002","","2019-06-14 23:59:22","2019-06-14 23:59:22","Async Next Screen Presentation in SwiftUI","<ios><swift><swiftui>","1","1","","","","CC BY-SA 4.0"
"56601592","1","56601729","","2019-06-14 15:51:56","","2","2332","<p>For an class in <code>SwiftUI</code> to conform to <code>BindableObject</code>, it has to have a Publisher, usually <code>didChange</code>, which in all of the SwiftUI documentation and videos I've seen so far, is a <code>PassthroughSubject</code>.</p>

<p>For example, if you have a class called <code>TestObject</code>, <code>didChange</code> might equal <code>PassthroughSubject&lt;TestObject, Never&gt;()</code>. I understand that the first type is the type of the data that the <code>PassthroughSubject</code> passes on, but what is <code>Never</code>? What is its purpose and are there any scenarios where the second type is not <code>Never</code>?</p>
","5140471","","","","","2019-10-14 09:39:13","What is Never in PassthroughSubject?","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"56610266","1","56610508","","2019-06-15 12:10:42","","6","2087","<p>I have a view</p>

<pre><code>struct CustomImageView : View {
    var body: some View {
        Image(""someImage"")
    }
}
</code></pre>

<p>when i reference this view outside, i cannot make the image resizable.
I know i can pass parameters, but i was looking for a neater way to do this through modifiers?</p>

<pre><code>VStack {
   CustomImageView()
      .resizable()    // This does not work
}
</code></pre>

<p>resizable seems to only work with the image directly.
Does anyone know how to make the CustomImageView resizable? </p>

<p><strong>Update:</strong> I understand i can use a parameter, but is there anyway to do it using modifiers? Resizable was only one property, but there are other properties. And listing them all as indvidual variables will be too much </p>

<p><strong>Implemented Answer based on @matteo-pacini</strong>
It uses AlamofireImage to load a remote image in ImageView.</p>

<pre><code>struct RemoteImage : View {
    var url: URLConvertible
    @ObjectBinding var imageLoader = AlamofireImageLoader()

    private (set) var _resizable: (capInsets: EdgeInsets, resizingMode: Image.ResizingMode) = (EdgeInsets(), .stretch)

    var body: some View {
        Image(uiImage: imageLoader.image)
            .resizable(capInsets: _resizable.capInsets, resizingMode: _resizable.resizingMode)
            .onAppear() {
                self.imageLoader.loadImage(url: self.url)
            }
    }

    func resizable(capInsets: EdgeInsets = EdgeInsets(), resizingMode: Image.ResizingMode = .stretch) -&gt; RemoteImage {
        return RemoteImage(url: url, _resizable: (capInsets, resizingMode))
    }
}

class AlamofireImageLoader: BindableObject {
    var didChange = PassthroughSubject&lt;Void, Never&gt;()
    var image = UIImage() {
        didSet {
            DispatchQueue.main.async {
                self.didChange.send(Void())
            }
        }
    }

    convenience init(url: URLConvertible) {
        self.init()
        loadImage(url: url)
    }

    func loadImage(url: URLConvertible) {
        Alamofire.request(url).responseImage { response in
            if let image = response.result.value {
                self.image = image
            }
        }
    }
}
</code></pre>
","433073","","433073","","2019-06-15 17:32:02","2020-07-16 14:49:26","How to make a custom Image resizable() with SwiftUI","<ios><swift><swiftui>","4","0","1","","","CC BY-SA 4.0"
"56622860","1","56638991","","2019-06-16 21:48:41","","1","883","<p><strong>This issue would ideally be deleted because it is related to obsolete beta version of Xcode only.</strong></p>
<p>[WWDC Video 721 Combine in Practice][1] seems to indicate that RunLoop.main should be a valid scheduler to use in Combine with <code>delay</code> or <code>debounce</code> but I'm seeing compile errors with Xcode claiming that RunLoop doesn't conform to scheduler. Am I doing something wrong or is this just an issue with the first beta of Xcode.</p>
<pre><code>ContentView.swift:95:77: error: argument type 'RunLoop' does not conform to expected type 'Scheduler'
        return delayPublisher.debounce(for: .seconds(5), scheduler: RunLoop.main).eraseToAnyPublisher()
</code></pre>
<p>I've raised FB6160439.</p>
<p>[1]: <a href=""https://developer.apple.com/videos/play/wwdc2019/721/"" rel=""nofollow noreferrer"">https://developer.apple.com/videos/play/wwdc2019/721/</a> (slides 79, 80, 211).</p>
","1476206","","1476206","","2021-06-21 13:38:00","2021-06-21 13:38:00","What should the scheduler be for delay and debounce in Combine? (Xcode 11 beta 1 only)","<swift><xcode><combine>","1","1","1","","","CC BY-SA 4.0"
"56657106","1","56657168","","2019-06-18 21:11:36","","2","2962","<p>I'd like to handle a series of network calls in my app. Each call is asynchronous and <code>flatMap()</code> seems like the right call. However, <code>flatMap</code> processes all arguments at the same time and I need the calls to be sequential -- the next network call starts only after the previous one is finished. I looked up an RxSwift <a href=""https://stackoverflow.com/questions/47906030/rxswift-how-to-chain-observables-sequentially"">answer</a> but it requires <code>concatMap</code> operator that Combine does not have. Here is rough outline of what I'm trying to do, but <code>flatMap</code> fires all <code>myCalls</code> at the same time.</p>

<pre><code>Publishers.Sequence(sequence: urls)
  .flatMap { url in
    Publishers.Future&lt;Result, Error&gt; { callback in 
        myCall { data, error in 
            if let data = data {
                callback(.success(data))
            } else if let error = error {
                callback(.failure(error))
            }
        }
    }
  }
</code></pre>
","2981130","","1000551","","2019-12-07 10:02:20","2019-12-07 10:02:20","How to schedule a synchronous sequence of asynchronous calls in Combine?","<ios><swift><combine>","2","0","","","","CC BY-SA 4.0"
"56677669","1","56826472","","2019-06-20 00:56:43","","0","1333","<p>I’m trying to change to the main thread in the downstream with <code>.receive(on: DispatchQueue.main)</code> but then I don’t receive inputs when using either <code>.subscribe(:)</code> or <code>.sink(receiveValue:)</code>. If I don’t change threads I do receive the proper inputs. </p>

<p><strong>Publisher</strong></p>

<pre class=""lang-swift prettyprint-override""><code>extension URLSessionWebSocketTask {
  struct ReceivePublisher: Publisher {
    typealias Output = Message
    typealias Failure = Error

    let task: URLSessionWebSocketTask

    func receive&lt;S&gt;(subscriber: S) where S: Subscriber, Output == S.Input, Failure == S.Failure {
      task.receive { result in
        switch result {
        case .success(let message): _ = subscriber.receive(message)
        case .failure(let error): subscriber.receive(completion: .failure(error))
        }
      }
    }
  }
}

extension URLSessionWebSocketTask {
  func receivePublisher() -&gt; ReceivePublisher {
    ReceivePublisher(task: self)
  }
}
</code></pre>

<p><strong>Subscriber</strong></p>

<pre class=""lang-swift prettyprint-override""><code>extension ViewModel: Subscriber {
  typealias Input = URLSessionWebSocketTask.Message
  typealias Failure = Error

  func receive(subscription: Subscription) {}

  func receive(_ input: URLSessionWebSocketTask.Message) -&gt; Subscribers.Demand {
    // Handle input here.
    // When using `.receive(on:)` this method is not called when should be.
    return .unlimited
  }

  func receive(completion: Subscribers.Completion&lt;Error&gt;) {}
}
</code></pre>

<p><strong>Subscribe</strong></p>

<pre class=""lang-swift prettyprint-override""><code>socketTask.receivePublisher()
      .receive(on: DispatchQueue.main)
      .subscribe(viewModel)
socketTask.resume()
</code></pre>
","3058601","","3058601","","2019-06-20 04:26:03","2019-07-19 20:25:48","Not receiving inputs when using `.receive(on: DispatchQueue.main)`","<ios><swift><combine>","1","6","","","","CC BY-SA 4.0"
"56686026","1","56747738","","2019-06-20 12:28:47","","29","5699","<p>From within a property wrapper in Swift, can you someone refer back to the instance of the class or struck that owns the property being wrapped? Using <code>self</code> doesn't obviously work, nor does <code>super</code>. </p>

<p>I tried to pass in <code>self</code> to the property wrapper's <code>init()</code> but that doesn't work either because <code>self</code> on <code>Configuration</code> is not yet defined when <code>@propertywrapper</code> is evaluated.</p>

<p>My use case is in a class for managing a large number of settings or configurations. If any property is changed, I just want to notify interested parties that <em>something</em> changed. They don't really need to know which value just, so use something like <code>KVO</code> or a <code>Publisher</code> for each property isn't really necessary.</p>

<p>A property wrapper looks ideal, but I can't figure out how to pass in some sort of reference to the owning instance that the wrapper can call back to.</p>

<p>References: </p>

<p><a href=""https://github.com/DougGregor/swift-evolution/blob/property-wrappers/proposals/0258-property-wrappers.md"" rel=""noreferrer"">SE-0258</a></p>

<pre><code>enum PropertyIdentifier {
  case backgroundColor
  case textColor
}

@propertyWrapper
struct Recorded&lt;T&gt; {
  let identifier:PropertyIdentifier
  var _value: T

  init(_ identifier:PropertyIdentifier, defaultValue: T) {
    self.identifier = identifier
    self._value = defaultValue
  }

  var value: T {
    get {  _value }
    set {
      _value = newValue

      // How to callback to Configuration.propertyWasSet()?
      //
      // [self/super/...].propertyWasSet(identifier)
    }
  }
}

struct Configuration {

  @Recorded(.backgroundColor, defaultValue:NSColor.white)
  var backgroundColor:NSColor

  @Recorded(.textColor, defaultValue:NSColor.black)
  var textColor:NSColor

  func propertyWasSet(_ identifier:PropertyIdentifier) {
    // Do something...
  }
}
</code></pre>
","48321","","1033581","","2019-06-25 06:22:05","2020-06-04 12:53:19","Can a Swift Property Wrapper reference the owner of the property its wrapping?","<swift><swift5><combine>","4","6","4","","","CC BY-SA 4.0"
"56704744","1","56705200","","2019-06-21 13:48:55","","1","215","<p>I'm experiencing weird behavior with SwiftUI and xCode 11 Beta 2, and I'm wondering whether it's related to wrong code or the beta-state. I have following code:</p>

<pre><code>import SwiftUI
import Combine

struct ContentView : View {

    @EnvironmentObject var persistence: Persistence

    var modal = Modal(SignupView())

    var body: some View {
        VStack {
            Text(""Hello \(persistence.userNickname)"")
            Button(action: {
                self.persistence.isLoggedIn.toggle()
            }) {
                Text(""Swap"")
            }
            }.presentation(persistence.isLoggedIn ? nil : modal)
    }
}


struct SignupView: View {

    @EnvironmentObject var persistence: Persistence

    var body: some View {
        Text(""Please Login"")
    }

}
</code></pre>

<p>If I <strong>comment out</strong> the <code>@EnvironmentObject var persistence: Persistence</code> in the <code>SignupView</code>, the App works and the presentation of the modal view <strong>works flawlessly</strong>. </p>

<p>In contrast, if I keep the <code>@EnvironmentObject var persistence: Persistence</code> in the <code>SignupView</code> <strong>uncommented</strong> (hence as active code), the <strong>app crashes</strong> at startup somewhere in the <code>AppDelegate</code> without leaving any Stacktrace... <code>Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)</code></p>

<p>The Persistence Object is of type <code>BindableObject</code> and correctly added as <code>.environmentObject</code> to the <code>ContenView</code> in the <code>SceneDelegate</code>. The <code>isLoggedIn</code> Property is set to <code>false</code></p>

<p>Any clue whether I'm just dealing with a Beta or real issue?</p>
","2548205","","","","","2020-06-06 03:43:19","SwiftUI or Beta-State leads to crash?","<ios><swift><swiftui>","2","0","1","","","CC BY-SA 4.0"
"56709268","1","56710685","","2019-06-21 19:16:47","","0","143","<p>I have a SwiftUI view that has a <code>@ObjectBinding progression: Progressable</code> like this:</p>

<pre><code>struct ProgressBarComponent : View {
  @ObjectBinding var progression: Progressable
  var progressAnimation: Animation {
    Animation
    .spring(stiffness: 43, initialVelocity: 3.2)
    .speed(3)
    .delay(0.07)
  }

  var body: some View {
    VStack {
      HStack {
        Text(self.progression.name)
          .font(.subheadline)
          .color(.gray)
        Spacer()
        Text(self.progression.description)
          .font(.subheadline)
          .color(.gray)
      }
        .padding(.bottom, -8)
        .padding(.horizontal, 4)
      ZStack {
        GeometryReader { geometry in
          Capsule()
          .fill(
            Color(.displayP3,
              red: 150 / 255,
              green: 150 / 255,
              blue: 150 / 255,
              opacity: 0.1)
          )
          .overlay(
            ZStack(alignment: .leading) {
              Circle()
                .fill(self.progression.gradient)
                .position(x: 7, y: 7)
              Capsule()
                .size(
                  width: geometry.size.width * self.progression.progress,
                  height: geometry.size.height)
                .fill(self.progression.gradient)
                .animation(self.progressAnimation)
            }
          )
        }
      }
        .frame(width: nil, height: 14, alignment: .leading)
    }
      .padding()
  }
}
</code></pre>

<p>The protocol I created looks like this:</p>

<pre><code>protocol Progressable: BindableObject {
  var name: String { get }
  var description: String { get }
  var progress: CGFloat { get }
  var gradient: LinearGradient { get set }
}
</code></pre>

<p>Finally, I have a class, <code>BaseNutrient</code> that implements <code>Progressable</code> protocol:</p>

<pre><code>class BaseNutrient: Progressable {
  let unitFormatter = NumberFormatter()

  var didChange = PassthroughSubject&lt;BaseNutrient, Never&gt;()

  var name: String
  var description: String {
    get {
      return
        ""\(unitFormatter.string(from: NSNumber(value: Float(current)))!) / \(unitFormatter.string(from: NSNumber(value: Float(total)))!) \(unit.rawValue)""
    }
  }

  var unit: NutrientUnit

  var current: CGFloat
  var total: CGFloat
  var progress: CGFloat {
    get {
      return current / total
    }
  }

  var gradient: LinearGradient

  init(name: String, unit: NutrientUnit, total: CGFloat, colors: [Color] = [Color(red: 239.0 / 255, green: 120.0 / 255, blue: 221.0 / 255), Color(red: 239.0 / 255, green: 172.0 / 255, blue: 120.0 / 255)], start: CGFloat = 0) {
    self.name    = name
    self.unit    = unit
    self.total   = total
    self.current = start

    unitFormatter.locale = Locale.current
    unitFormatter.numberStyle = .decimal
    unitFormatter.maximumFractionDigits = 0

    gradient = LinearGradient(gradient: .init(colors: colors), startPoint: .init(x: 0.0, y: 0),
        endPoint: .init(x: 1.0, y: 0))
  }

  func addProgress(_ progress: CGFloat) {
    current += progress
    if current &gt; total {
      current = total
    }
    didChange.send(self)
  }

  func removeProgress(_ progress: CGFloat) {
    current -= progress
    if current &lt; 0 {
      current = 0
    }
    didChange.send(self)
  }

}
</code></pre>

<p>If I use <code>BaseNutrient</code> as the type in place of <code>Progressable</code> in the SwiftUI view everything compiles and runs fine. If I use the protocol <code>Progressable</code> instead, the build never finishes and just hangs, never giving me any errors. Does anyone know what could be happening?</p>
","2580259","","","","","2019-06-21 21:31:19","@ObjectBinding Does Not Work with a Protocol","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"56717392","1","56717393","","2019-06-22 16:54:27","","5","3599","<p>In WWDC 2019 video 721, the basis of the main example starts like this:</p>

<pre><code>let trickNamePublisher = NotificationCenter.default.publisher(for: .newTrickDownloaded)
    .map { notification in
        return notification.userInfo?[""data""] as! Data
    }
</code></pre>

<p>That seems inadvisable. What happens if there's no <code>userInfo</code>, or it contains no <code>""data""</code> key, or it isn't a Data? We'll force-unwrap <code>nil</code> and crash. What's the best practice here?</p>
","341994","","341994","","2019-06-22 18:14:42","2019-06-22 18:14:42","Avoiding forced unwrapping in Swift Combine framework","<swift><optional><ios13><combine>","1","6","","","","CC BY-SA 4.0"
"56720441","1","56724607","","2019-06-23 01:47:31","","10","8028","<p>I have been able to save data in a Realm database, but have been unable to show the results in a SwiftUI <code>List</code>.</p>

<p>I know I have the data and have no problem printing the results in the console.</p>

<p>Is there a way to convert Realm <code>Result</code> into a format that can be displayed on a SwiftUI <code>List</code>?</p>

<pre><code>import SwiftUI
import RealmSwift
import Combine

class Dog: Object {
    @objc dynamic var name = """"
    @objc dynamic var age = 0

    override static func primaryKey() -&gt; String? {
        return ""name""
    }
}

class SaveDog {
    func saveDog(name: String, age: String) {
        let dog = Dog()
        dog.age  = Int(age)!
        dog.name = name

        // Get the default Realm
        let realm = try! Realm()

     print(Realm.Configuration.defaultConfiguration.fileURL!)

        // Persist your data easily
        try! realm.write {
        realm.add(dog)
        }

        print(dog)
    }
}

class RealmResults: BindableObject {
    let didChange = PassthroughSubject&lt;Void, Never&gt;()

    func getRealmResults() -&gt; String{
        let realm = try! Realm()
        var results = realm.objects(Dog.self) { didSet 
 {didChange.send(())}}
        print(results)
        return results.first!.name
    }
}

struct dogRow: View {
    var dog = Dog()
    var body: some View {
        HStack {
            Text(dog.name)
            Text(""\(dog.age)"")
        }
    }

}

struct ContentView : View {

    @State var dogName: String = """"
    @State var dogAge: String = """"

    let saveDog = SaveDog()
    @ObjectBinding var savedResults = RealmResults()
    let realm = try! Realm()

    let dogs = Dog()

    var body: some View {
        VStack {
            Text(""Hello World"")
            TextField($dogName)
            TextField($dogAge)
            Button(action: {
                self.saveDog.saveDog(name: self.dogName, 
                age:self.dogAge)
//                self.savedResults.getRealmResults()
            }) {
                Text(""Save"")
            }
            //insert list here to show realm data

            List(0 ..&lt; 5) { 
             item in
                Text(self.savedResults.getRealmResults())
            } //Displays the same thing 5 times
        }
    }
}

#if DEBUG
struct ContentView_Previews : PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
#endif
</code></pre>

<p>Some of the code probably may not make sense because I was attempting several approaches to see if anything would work. </p>

<p>This line, for example, will display the result in the List View.</p>

<pre><code>return results.first!.name
</code></pre>

<p>If I just return results, nothing displays in the List Text View.</p>

<p>As I have commented below I will attempt the ForEach approach when I have time.  That looks promising.</p>
","6190779","","6190779","","2019-06-23 14:59:41","2020-07-24 22:09:49","How to display Realm Results in SwiftUI List?","<swift><realm><swiftui>","4","6","8","","","CC BY-SA 4.0"
"56724566","1","56911058","","2019-06-23 13:55:17","","48","8947","<p>When using new Combine framework you can specify the scheduler on which to receive elements from the publisher.</p>

<p>Is there a big difference between <code>RunLoop.main</code> and <code>DispatchQueue.main</code> in this case when assigning publisher to UI element? The first one returns the run loop of the main thread and the second queue associated with the main thread. </p>
","4386014","","","","","2022-02-21 17:17:03","RunLoop vs DispatchQueue as Scheduler","<swift><grand-central-dispatch><nsrunloop><combine>","5","0","19","","","CC BY-SA 4.0"
"56727451","1","56796398","","2019-06-23 20:21:37","","3","1804","<p>I was playing with Combine framework lately and was wondering if it is possible to create some smart extension to get text changes as Publisher.</p>

<p>Let's say I've got two UITextFields:</p>

<pre><code>firstTextField.textPub.sink {
    self.viewModel.first = $0
}

secondTextField.textPub.sink {
    self.viewModel.second = $0
}
</code></pre>

<p>where first and second variable is just `@Published var first/second: String = """"</p>

<pre><code>extension UITextField {
    var textPub: AnyPublisher&lt;String, Never&gt; {
        return NotificationCenter.default
            .publisher(for: UITextField.textDidChangeNotification)
            .map {
                guard let textField = $0.object as? UITextField else { return """" }
                return textField.text ?? """"
            }
            .eraseToAnyPublisher()
    }
}
</code></pre>

<p>This doesn't work because I'm using shared instance of NotificationCenter so when I make any change to any of textFields it will propagate new value to both <code>sink</code> closures. Do you think is there any way to achieve something similar to <code>rx.text</code> available in RxSwift? I was thinking about using <code>addTarget</code> with closure but it would require using associated objects from Objective-C.</p>
","4386014","","","","","2020-03-08 15:58:36","Multiple UITextFields and textDidChangeNotification notification","<swift><uikit><combine>","2","0","","","","CC BY-SA 4.0"
"56735382","1","58117295","","2019-06-24 11:14:40","","11","11465","<p>I'm trying to execute an action every time a <code>textField</code>'s value is changed.</p>

<pre><code>@Published var value: String = """"

var body: some View {            
     $value.sink { (val) in
        print(val)
     }
     return TextField($value)       
}
</code></pre>

<p>But I get below error.</p>

<blockquote>
  <p>Cannot convert value of type 'Published' to expected argument type 'Binding'</p>
</blockquote>
","10208552","","25122","","2019-06-24 21:44:09","2020-03-28 11:49:36","How to observe a TextField value with SwiftUI and Combine?","<ios><swiftui><combine>","4","0","2","","","CC BY-SA 4.0"
"56773951","1","56774251","","2019-06-26 13:26:01","","14","3962","<p>i'm implementing a little app with new iOS framework SwiftUI. I'm using <code>@EnvironmentObject</code> to bind my data to view. All works, but the Canvas crash and not show nothing. Why?</p>

<pre><code>struct CompetitionsListSwiftUIView : View {

    @EnvironmentObject var competitionsViewModel: CompetitionsViewModel

    var body: some View {
        List(self.competitionsViewModel.competitions.identified(by: \.id)) { competition in
                CompetitionCellSwiftUIView(competition: competition)
            }
    }
}

#if DEBUG
struct CompetitionsListSwiftUIView_Previews : PreviewProvider {
    static var previews: some View {
        CompetitionsListSwiftUIView()
    }
}
#endif
</code></pre>

<p>The error message of the Canvas is this:</p>

<pre><code>Error Domain=render service Code=12 ""Rendering service was interrupted"" UserInfo={NSLocalizedDescription=Rendering service was interrupted}
</code></pre>
","6761616","","","","","2019-06-26 13:40:11","Crash on Canvas SwiftUI","<ios><swift><swiftui><combine>","1","0","3","","","CC BY-SA 4.0"
"56782078","1","56786412","","2019-06-26 23:22:22","","38","31477","<p>Using Apple's new Combine framework I want to make multiple requests from each element in a list. Then I want a single result from a reduction of all the the responses. Basically I want to go from list of publishers to a single publisher that holds a list of responses.</p>

<p>I've tried making a list of publishers, but I don't know how to reduce that list into a single publisher. And I've tried making a publisher containing a list but I can't flat map a list of publishers.</p>

<p>Please look at the ""createIngredients"" function </p>

<pre><code>func createIngredient(ingredient: Ingredient) -&gt; AnyPublisher&lt;CreateIngredientMutation.Data, Error&gt; {
    return apollo.performPub(mutation: CreateIngredientMutation(name: ingredient.name, optionalProduct: ingredient.productId, quantity: ingredient.quantity, unit: ingredient.unit))
            .eraseToAnyPublisher()
}

func createIngredients(ingredients: [Ingredient]) -&gt; AnyPublisher&lt;[CreateIngredientMutation.Data], Error&gt; {
    // first attempt
    let results = ingredients
            .map(createIngredient)
    // results = [AnyPublisher&lt;CreateIngredientMutation.Data, Error&gt;]

    // second attempt
    return Publishers.Just(ingredients)
            .eraseToAnyPublisher()
            .flatMap { (list: [Ingredient]) -&gt; Publisher&lt;[CreateIngredientMutation.Data], Error&gt; in
                return list.map(createIngredient) // [AnyPublisher&lt;CreateIngredientMutation.Data, Error&gt;]
            }
}
</code></pre>

<p>I'm not sure how to take an array of publishers and convert that to a publisher containing an array.</p>

<p>Result value of type '[AnyPublisher]' does not conform to closure result type 'Publisher'</p>
","10178157","","614065","","2020-01-31 11:10:06","2021-12-17 11:29:34","Swift Combine: How to create a single publisher from a list of publishers?","<swift><combine>","4","2","7","","","CC BY-SA 4.0"
"56823604","1","56826204","","2019-06-30 08:57:20","","1","2055","<p>I've got to two String publishers and one computed property which returns AnyPublisher. Logic is quite simple but I would like to know if there is any way to propagate initial value. I think it should be somehow possible since publishers have initial values.</p>

<p>In VC I'm assigning new values to Publishers from ViewModel (from textField).</p>

<pre><code>firstTextField.addTarget(self, action: #selector(firstTextFieldDidChange(_:)), for: .editingChanged)
secondTextField.addTarget(self, action: #selector(secondTextFieldDidChange(_:)), for: .editingChanged)

@objc private func firstTextFieldDidChange(_ textField: UITextField) {
 viewModel.firstPublisher = textField.text ?? """"
}
@objc private func secondTextFieldDidChange(_ textField: UITextField) {
 viewModel.secondPublisher = textField.text ?? """"
}
</code></pre>

<p>And then I'm assigning Publisher (combineLatest) to my button:</p>

<pre><code>_ = viewModel.validatedText
   .receive(on: RunLoop.main)
   .assign(to: \.isEnabled, on: button)
</code></pre>

<p>In VM I've got two Publishers:</p>

<pre><code>@Published var firstPublisher: String = """"
@Published var secondPublisher: String = """"
</code></pre>

<p>and CombineLatest:</p>

<pre><code>var validatedText: AnyPublisher&lt;Bool, Never&gt; {
    return Publishers.CombineLatest($firstPublisher, $secondPublisher) {
        return !($0.isEmpty || $1.isEmpty)
        }.eraseToAnyPublisher()
}
</code></pre>

<p>validatedText only starts publishing new values when I start typing in both text fields. I tried assigning some new values in init of VM for example (to first and second Publisher) but it also didn't work. Is there any way to do it or I will have to set initial state of button (disable it) without using combine?</p>
","4386014","","","","","2019-06-30 16:08:46","Triggering CombineLatest to propagate initial value in Combine","<swift><reactive-programming><combinelatest><combine>","1","0","","","","CC BY-SA 4.0"
"56841842","1","56842343","","2019-07-01 20:08:49","","1","6440","<p>I tried creating a list of custom classes in SwiftUI, but keep having problems with the UI updates. I made my class conform to <code>BindableObject</code> and it calls the <code>didChange.send()</code> function correctly when a property changes, but the change doesn't seem to get passed through to the array, as the view does not update, when I change a property of my custom class in the array.</p>

<p>Here is a basic example of what I mean:</p>

<pre class=""lang-swift prettyprint-override""><code>class Media: BindableObject, Identifiable {
    typealias PublisherType = PassthroughSubject&lt;Void, Never&gt;
    var didChange = PublisherType()

    var id: Int {
        didSet {
            didChange.send()
        }
    }
    var name: String {
        didSet {
            print(""Name changed from \(oldValue) to \(self.name)"")
            didChange.send()
        }
    }

    init(id: Int, name: String) {
        self.id = id
        self.name = name
    }
}

struct ContentView : View {
    @State private var media = [
        Media(id: 0, name: ""Name 0""),
        Media(id: 1, name: ""Name 1""),
        Media(id: 2, name: ""Name 2""),
        Media(id: 3, name: ""Name 3""),
    ]

    var body: some View {
        VStack {
            List(media) { media in
                Text(media.name)
            }
            HStack {
                Button(action: {
                    self.media.first!.name = ""Name \(Int.random(in: 100...199))""
                }) {
                    Text(""Change"")
                }
                Button(action: {
                    self.media.append(Media(id: 4, name: ""Name 4""))
                }) {
                    Text(""Add"")
                }
            }
        }
    }
}
</code></pre>

<p>When pressing the ""Change"" button, it just changes the name of the first media object in the array, which does not result in a re-rendering of the view. When I press the ""Add"" button, he adds an object to the array, therefore re-rendering the UI and also displaying the changed name of the first object (from pressing ""Change"").</p>

<p>Now my question is, if there is a way to link the publisher of <code>Media</code> to the publisher of <code>Array&lt;Media&gt;</code>, so that when the <code>Media</code> Publisher fires, the <code>Array&lt;Media&gt;</code> Publisher fires too and therefore causes the view to re-render.</p>

<p>When I move the <code>Text(media.name)</code> in a separate view (which holds the media as a <code>@State</code> property, it works as intended, as the subview itself request the re-render.</p>

<p>But assuming I don't want to use a custom view but just a simple <code>Text</code> view, is there any way to make this happen?</p>
","3426509","","","","","2019-11-14 03:37:46","Create a List with an array of custom classes in SwiftUI","<swift><list><swiftui><combine>","1","0","2","","","CC BY-SA 4.0"
"56871714","1","56890158","","2019-07-03 13:52:18","","4","1714","<p>I've got a strange crash in <strong>SwiftUI / Xcode 11 beta 3</strong> with code like the one below (I've kept only the bare minimum to show the behavior):</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

final class AppData: BindableObject  {
    let didChange = PassthroughSubject&lt;AppData, Never&gt;()

    init() { }
}

struct ContentView : View {
    var body: some View {
        NavigationView {
            NavigationLink(destination: DetailView() ) {
                Text(""link"")
            }
        }
    }
}

struct DetailView : View {
    @EnvironmentObject var appData: AppData
//  @ObjectBinding var appData = AppData() -&gt; Works 

    var body: some View {
        List {
            Text(""A"")
            Text(""B"")
            Text(""C"")
        }
    }
}

</code></pre>

<p>The <code>BindableObject</code> is injected in <code>SceneDelegate.swift</code> like this:</p>

<pre class=""lang-swift prettyprint-override""><code>....
        // Use a UIHostingController as window root view controller
        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(rootView: ContentView()
                                           .environmentObject(AppData()))
            self.window = window
            window.makeKeyAndVisible()
        }
....
</code></pre>

<p>When following the <code>NavigationLink</code> it crashes with </p>

<p><code>Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)</code></p>

<p>If I remove the <code>List</code> view from the detail view it works OK. The same if I use <code>@ObjectBinding</code> instead (like in the commented line in my code).</p>

<p>The same code used to work in previous betas. </p>
","554203","","1033581","","2019-07-05 02:04:26","2019-07-05 02:04:26","Xcode 11 beta 3 crashing when using NavigationLink, @EnvironmentObject and List together","<swiftui><xcode11><combine>","2","3","1","","","CC BY-SA 4.0"
"56874689","1","56875265","","2019-07-03 16:41:26","","4","2538","<p>I would like to wrap a simple callback so that it would be able to be used as a Combine <code>Publisher</code>. Specifically the <a href=""https://developer.apple.com/documentation/coredata/nspersistentcontainer/1640568-loadpersistentstores"" rel=""nofollow noreferrer"">NSPersistentContainer.loadPersistentStore</a> callback so I can publish when the container is ready to go.</p>

<pre class=""lang-swift prettyprint-override""><code>func createPersistentContainer(name: String) -&gt; AnyPublisher&lt;NSPersistentContainer, Error&gt; {
  // What goes here?
  // Happy path: send output NSPersistentContainer; send completion.
  // Not happy path: send failure Error; send completion.
}
</code></pre>

<p>For instance, what would the internals of a function, <code>createPersistentContainer</code> given above, look like to enable me to do something like this in my <code>AppDelegate</code>.</p>

<pre class=""lang-swift prettyprint-override""><code>final class AppDelegate: UIResponder, UIApplicationDelegate {

  let container = createPersistentContainer(name: ""DeadlyBattery"")
    .assertNoFailure()
    .eraseToAnyPublisher()

  // ...

}
</code></pre>

<p>Mostly this boils down to, how do you wrap a callback in a <code>Publisher</code>?</p>
","247730","","","","","2020-07-28 14:05:30","Make a Publisher from a callback","<swift><combine>","3","0","","","","CC BY-SA 4.0"
"56879734","1","57453172","","2019-07-04 01:56:23","","12","4366","<p>I want to use a <code>@State</code> variable both for the UI and for computing a value.</p>

<p>For example, let's say I have a <code>TextField</code> bound to <code>@State var userInputURL: String = ""https://""</code>. How would I take that <code>userInputURL</code> and connect it to a publisher so I can <code>map</code> it into a <code>URL</code>.</p>

<p>Pseudo code:</p>

<pre class=""lang-swift prettyprint-override""><code>$userInputURL.publisher()
      .compactMap({ URL(string: $0) })
      .flatMap({ URLSession(configuration: .ephemeral).dataTaskPublisher(for: $0).assertNoFailure() })
      .eraseToAnyPublisher()
</code></pre>
","247730","","228600","","2019-07-31 12:35:46","2022-06-26 15:58:58","Convert a @State into a Publisher","<swift><swiftui><combine>","4","0","3","","","CC BY-SA 4.0"
"56892346","1","56895248","","2019-07-04 17:34:44","","3","650","<p>When launching my app on an iPad running the iOS 13 beta 2 build I receive a SIGABRT. This build works fine on the simulator</p>

<p><code>dyld: Symbol not found: _$s7Combine6FutureCyxq_GAA9PublisherAAMc</code>
<code>Expected in: /System/Library/Frameworks/Combine.framework/Combine</code></p>

<p>I thought maybe it was a linking problem, but Combine does not appear in the list of libraries available to link.</p>

<p>Does anyone have a work around or am I sunk until the next beta?</p>

<hr>

<p>Here is my code snippet:</p>

<pre><code>class ViewController: UIViewController {

    var future: AnyPublisher&lt;String, Error&gt;?

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
        future = ViewController.makeNumberString(50)
        future?.sink { result in
            print(""FUTURE DONE: \(result)"")
        }
    }

    static func makeNumberString(_ number: Int) -&gt; AnyPublisher&lt;String, Error&gt; {
        return Combine.Future&lt;Int, Error&gt; { complete in
            DispatchQueue.global(qos: .userInitiated).async {
                complete(.success(number))
            }
        }
        .map { number in
            return ""\(number)""
        }
        .eraseToAnyPublisher()
    }
}
</code></pre>
","5171701","","1000551","","2019-12-07 10:01:50","2019-12-07 10:01:50","iOS 13 Public Beta 2 - Combine.Future ""dyld: Symbol not found""","<ios><swift><beta><combine>","2","2","","","","CC BY-SA 4.0"
"56910228","1","57473649","","2019-07-05 23:52:57","","5","8256","<p>I am trying to replicate the ""Wizard School Signup""-example which was given in the WWDC 2019 session ""Combine in Practice"" <a href=""https://developer.apple.com/videos/play/wwdc2019/721/"" rel=""noreferrer"">https://developer.apple.com/videos/play/wwdc2019/721/</a> starting at 22:50 using SwiftUI (as opposed to UIKit, which was used during the session).</p>

<p>I have created all the publishers from the example: validatedEMail, validatedPassword and validatedCredentials. While validatedEMail and validatedPassword work just fine, validatedCredentials, which consumes both publishers using CombineLatest, never fires</p>

<pre class=""lang-swift prettyprint-override""><code>//
//  RegistrationView.swift
//
//  Created by Lars Sonchocky-Helldorf on 04.07.19.
//  Copyright © 2019 Lars Sonchocky-Helldorf. All rights reserved.
//

import SwiftUI
import Combine

struct RegistrationView : View {
    @ObjectBinding var registrationModel = RegistrationModel()

    @State private var showAlert = false
    @State private var alertTitle: String = """"
    @State private var alertMessage: String = """"

    @State private var registrationButtonDisabled = true

    @State private var validatedEMail: String = """"
    @State private var validatedPassword: String = """"

    var body: some View {
        Form {
            Section {
                TextField(""Enter your EMail"", text: $registrationModel.eMail)
                SecureField(""Enter a Password"", text: $registrationModel.password)
                SecureField(""Enter the Password again"", text: $registrationModel.passwordRepeat)
                Button(action: registrationButtonAction) {
                    Text(""Create Account"")
                }
                .disabled($registrationButtonDisabled.value)
                    .presentation($showAlert) {
                        Alert(title: Text(""\(alertTitle)""), message: Text(""\(alertMessage)""))
                }
                .onReceive(self.registrationModel.validatedCredentials) { newValidatedCredentials in
                    self.registrationButtonDisabled = (newValidatedCredentials == nil)
                }
            }

            Section {
                Text(""Validated EMail: \(validatedEMail)"")
                    .onReceive(self.registrationModel.validatedEMail) { newValidatedEMail in
                        self.validatedEMail = newValidatedEMail != nil ? newValidatedEMail! : ""EMail invalid""
                }
                Text(""Validated Password: \(validatedPassword)"")
                    .onReceive(self.registrationModel.validatedPassword) { newValidatedPassword in
                        self.validatedPassword = newValidatedPassword != nil ? newValidatedPassword! : ""Passwords to short or don't matchst""
                }
            }
        }
        .navigationBarTitle(Text(""Sign Up""))
    }

    func registrationButtonAction() {
        let trimmedEMail: String = self.registrationModel.eMail.trimmingCharacters(in: .whitespaces)

        if (trimmedEMail != """" &amp;&amp; self.registrationModel.password != """") {
            NetworkManager.sharedInstance.registerUser(NetworkManager.RegisterRequest(uid: trimmedEMail, password: self.registrationModel.password)) { (status) in
                if status == 200 {
                    self.showAlert = true
                    self.alertTitle = NSLocalizedString(""Registration successful"", comment: """")
                    self.alertMessage = NSLocalizedString(""please verify your email and login"", comment: """")
                } else if status == 400 {
                    self.showAlert = true
                    self.alertTitle = NSLocalizedString(""Registration Error"", comment: """")
                    self.alertMessage = NSLocalizedString(""already registered"", comment: """")
                } else {
                    self.showAlert = true
                    self.alertTitle = NSLocalizedString(""Registration Error"", comment: """")
                    self.alertMessage = NSLocalizedString(""network or app error"", comment: """")
                }
            }
        } else {
            self.showAlert = true
            self.alertTitle = NSLocalizedString(""Registration Error"", comment: """")
            self.alertMessage = NSLocalizedString(""username / password empty"", comment: """")
        }
    }
}

class RegistrationModel : BindableObject {
    @Published var eMail: String = """"
    @Published var password: String = """"
    @Published var passwordRepeat: String = """"

    public var didChange = PassthroughSubject&lt;Void, Never&gt;()

    var validatedEMail: AnyPublisher&lt;String?, Never&gt; {
        return $eMail
            .debounce(for: 0.5, scheduler: RunLoop.main)
            .removeDuplicates()
            .flatMap { username in
                return Future { promise in
                    self.usernameAvailable(username) { available in
                        promise(.success(available ? username : nil))
                    }
                }
        }
        .eraseToAnyPublisher()
    }

    var validatedPassword: AnyPublisher&lt;String?, Never&gt; {
        return Publishers.CombineLatest($password, $passwordRepeat)
            .debounce(for: 0.5, scheduler: RunLoop.main)
            .map { password, passwordRepeat in
                guard password == passwordRepeat, password.count &gt; 5 else { return nil }
                return password
        }
        .eraseToAnyPublisher()
    }

    var validatedCredentials: AnyPublisher&lt;(String, String)?, Never&gt; {
        return Publishers.CombineLatest(validatedEMail, validatedPassword)
            .map { validatedEMail, validatedPassword in
                guard let eMail = validatedEMail, let password = validatedPassword else { return nil }
                return (eMail, password)
        }
        .eraseToAnyPublisher()
    }


    func usernameAvailable(_ username: String, completion: (Bool) -&gt; Void) {
        let isValidEMailAddress: Bool = NSPredicate(format:""SELF MATCHES %@"", ""[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"").evaluate(with: username)

        completion(isValidEMailAddress)
    }
}

#if DEBUG
struct RegistrationView_Previews : PreviewProvider {
    static var previews: some View {
        RegistrationView()
    }
}
#endif
</code></pre>

<p>I expected the form button to get enabled when a valid username (valid E-Mail-address) and two matching passwords with the right length are provided. The two Publishers responsible for those two tasks work, I can see the validatedEMail and the validatedPassword in the user interface in the two Texts which I added for debugging purposes.</p>

<p>Just the third Publisher (also compare to the code shown in the Video from above at 32:20) never fires. I did set breakpoints in those Publishers, in the validatedPassword Publisher at line:</p>

<pre class=""lang-swift prettyprint-override""><code>guard password == passwordRepeat, password.count &gt; 5 else { return nil }
</code></pre>

<p>which stopped there just fine but a similar breakpoint in the validatedCredentials Publisher at line:</p>

<pre class=""lang-swift prettyprint-override""><code>guard let eMail = validatedEMail, let password = validatedPassword else { return nil }
</code></pre>

<p>was never reached.</p>

<p>What did I do wrong?</p>

<p><strong>Edit:</strong></p>

<p>In order to make the above code run under Xcode-beta 11.0 beta 4 <code>didChange</code> needs to be replaced with <code>willChange</code></p>
","2960387","","2960387","","2019-07-23 09:23:53","2019-09-02 09:35:52","Swift Combine: subsequent Publisher that consumes other Publishers (using CombineLatest) doesn't ""fire""","<swift><swiftui><ios13><combine>","3","0","3","","","CC BY-SA 4.0"
"56947312","1","57173681","","2019-07-09 07:23:45","","5","1373","<p>With the arrival of combine framework, is there a need to use operation queues anymore. For example, apple uses operation queues almost all over the place in WWDC app. So if we use SwiftUI with combine(asynchronous programming), will there be a need to use Operation Queues?</p>
","3972195","","","","","2019-07-24 00:37:54","Using operation queues with combine framework","<nsoperationqueue><swiftui><combine>","1","2","2","2020-10-31 11:39:40","","CC BY-SA 4.0"
"56958539","1","56959721","","2019-07-09 18:20:48","","2","2641","<p>I'm working on rewriting my Hacker News reader to use Combine more heavily. I'm have two functions which both return an <code>AnyPublisher</code>, one of them get's the ids of a bunch of HN stories from the server and the other one fetches a story by it's id. I'm not sure how I could loop over the results of <code>fetchStoryIds</code>, run <code>fetchStory</code> with the id and end up with an array of <code>Story</code> objects with Combine.</p>

<pre><code>import Combine
import Foundation

struct HackerNewsService {
    private var session = URLSession(configuration: .default)
    static private var baseURL = ""https://hacker-news.firebaseio.com/v0""

    private func fetchStoryIds(feed: FeedType) -&gt; AnyPublisher&lt;[Int], Error&gt; {
       let url = URL(string: ""\(HackerNewsService.baseURL)/\(feed.rawValue.lowercased())stories.json"")!

        return session.dataTaskPublisher(for: url)
            .retry(1)
            .map { $0.data }
            .decode(type: [Int].self, decoder: JSONDecoder())
            .eraseToAnyPublisher()
    }

    private func fetchStory(id: Int) -&gt; AnyPublisher&lt;Story, Error&gt; {
        let url = URL(string: ""\(HackerNewsService.baseURL)/item/\(id).json"")!

        return session.dataTaskPublisher(for: url)
            .map { $0.data }
            .decode(type: Story.self, decoder: JSONDecoder())
            .eraseToAnyPublisher()
    }
}
</code></pre>

<p>Before I started the rewrite, I used this code to loop over the ids and get the stories.</p>

<pre><code>func fetchStories(feed: FeedType, completionHandler: @escaping ([Story]?, Error?) -&gt; Void) {
        fetchStoryIds(feed: feed) { (ids, error) in
            guard error == nil else {
                completionHandler(nil, error)
                return
            }

            guard let ids = ids else {
                completionHandler(nil, error)
                return
            }

            let dispatchGroup = DispatchGroup()

            var stories = [Story]()

            for id in ids {
                dispatchGroup.enter()

                self.fetchStory(id: id) { (story, error) in
                    guard error == nil else {
                        dispatchGroup.leave()
                        return
                    }

                    guard let story = story else {
                        dispatchGroup.leave()
                        return
                    }

                    stories.append(story)

                    dispatchGroup.leave()
                }
            }

            dispatchGroup.notify(queue: .main) {
                completionHandler(stories, nil)
            }
        }
    }
}
</code></pre>
","","user7885981","1226963","","2019-07-09 18:21:41","2019-07-09 20:00:58","How can I loop over the output of a publisher with Combine?","<swift><combine>","1","6","","","","CC BY-SA 4.0"
"56998702","1","57022803","","2019-07-12 00:02:20","","5","3912","<p>I'd like to create a repeat functionality that creates a loop in my code using Combine. I noticed that Combine does not have a repeat publisher via this great repo: <a href=""https://github.com/freak4pc/rxswift-to-combine-cheatsheet"" rel=""noreferrer"">https://github.com/freak4pc/rxswift-to-combine-cheatsheet</a>. Heres the code that I wrote that works to repeat 2 states. How do I reduce this to something more readable or create my own repeat function?</p>

<pre><code>toggleShouldDisplay = Just&lt;Void&gt;(())
  .delay(for: 2, scheduler:RunLoop.main)
  .map({ _ in
    self.shouldDisplay = true
    self.didChange.send(())
  })
  .delay(for: 2, scheduler: RunLoop.main)
  .map({ _ in
    self.shouldDisplay = false
    self.didChange.send(())
  })
  .setFailureType(to: NSError.self)
  .tryMap({ _ in
    throw NSError()
  })
  .retry(.max) // I might hit Int.max if I reduce the delays
  .sink(receiveValue: { _ in
    //Left empty
  })
</code></pre>
","283460","","","","","2019-07-18 11:57:47","Swift Combine .repeat","<swift><reactive-programming><combine>","2","0","","","","CC BY-SA 4.0"
"57004311","1","57005108","","2019-07-12 09:38:18","","1","1328","<p>I want to delete an object which is marked as <code>@ObjectBinding</code>, in order to clean up some <code>TextFields</code> for example.</p>

<p>I tried to set the object reference to nil, but it didn't work.</p>

<pre><code>import SwiftUI
import Combine

class A: BindableObject {
    var didChange = PassthroughSubject&lt;Void, Never&gt;()

    var text = """" { didSet { didChange.send() } }
}

class B {
    var property = ""asdf""
}

struct DetailView : View {
    @ObjectBinding var myObject: A = A()    //@ObjectBinding var myObject: A? = A() -&gt; Gives an error.
    @State var mySecondObject: B? = B()

    var body: some View {

        VStack {
            TextField($myObject.text, placeholder: Text(""Enter some text""))
            Button(action: {
                self.test()
            }) {
                Text(""Clean up"")
            }
        }
    }

    func test() {
        //myObject = nil
        mySecondObject = nil
    }
}
</code></pre>

<p>If I try to use an optional with <code>@ObjectBinding</code>, I'm getting the Error </p>

<blockquote>
  <p>""Cannot convert the value of type 'ObjectBinding' to specified type
  'A?'"".</p>
</blockquote>

<p>It just works with <code>@State</code>.</p>

<p>Regards</p>
","11774595","","6550949","","2019-07-12 10:04:15","2019-07-12 10:27:25","How to delete an object in SwiftUI which is marked with @ObjectBinding?","<swift><swiftui>","2","2","1","","","CC BY-SA 4.0"
"57008251","1","57010239","","2019-07-12 13:44:45","","0","1062","<p>Description: </p>

<p>I have a model that has the following hierarchy:</p>

<ul>
<li><strong>Recipe</strong>   </li>
<li>...steps (an array)</li>
<li>...<strong>currentStep</strong></li>
<li>......<strong>parameters (an array)</strong></li>
<li>.........minimum</li>
<li>.........maximum</li>
<li>.........default</li>
<li>.........<strong>current</strong></li>
</ul>

<p>The model works well. I can add steps, parameters, and set the current step to an <code>@EnvironmentObject</code> called <code>recipe</code>. </p>

<p>I've created a sample project <a href=""https://github.com/justdfd/ListBug"" rel=""nofollow noreferrer"">here</a> with I two lists of steps and parameters, along with three buttons to add a single step among three hard-coded ones, each containing an array of 0, 1, or 3 parameters.</p>

<p>The top list is the step rows, each being a button to populate the bottom list. The bottom list is the parameter list, each containing a label and a slider in a <code>VStack</code>.</p>

<p>All works fine, except when i am (a) binding the slider to my model <strong>and</strong> (b) the list contains more sliders (row) than the current step now has. I get an <code>index out of range error</code>. </p>

<p>If I bind the slider value to a local variable, it all works. Here's the relevant code:</p>

<pre><code>class Recipe: BindableObject {
    var didChange = PassthroughSubject&lt;Void, Never&gt;()
    var currentStep = Step() {
        didSet {
            didChange.send(())
        }
    }
}

struct Parameter: Identifiable {
    var id:Int = 0
    var name = """"
    var minimum:Float = 0
    var maximum:Float = 100
    var `default`:Float = 30
    var current:Float = 30
}

struct StepRow: View {
    @EnvironmentObject var recipe: Recipe
    var step: Step!

    init(step: Step) {
        self.step = step
    }
    var body: some View {
        Button(action: {
            self.setCurrentStep()
        }) {
            HStack {
                Text(step.name).font(Font.body.weight(.bold))
            }.frame(height: 50)
        }
    }
    func setCurrentStep() {
        recipe.currentStep = step
    }
}
struct ParameterRow: View {
    @EnvironmentObject var recipe: Recipe
    @State var sliderValue:Float = 30
    var parameter: Parameter!

    init(parameter: Parameter) {
        self.parameter = parameter
    }

    var body: some View {
        VStack {
            Text(parameter.name)
            Slider(

                // This works, swap these two lines to duplicate the index out of range error by:
                // - Adding step 1, step 2, step 3, and finally step 4
                // - Tapping each step in the step list in order, the first three will work but the last one won't

                //value: $recipe.currentStep.parameters[parameter.id].current,
                value: self.$sliderValue,

                from: parameter.minimum,
                through: parameter.maximum,
                by: 1.0
            )
        }
    }
}
struct ContentView : View {
    @EnvironmentObject var recipe: Recipe
    var body: some View {
        VStack {
            List {
                ForEach(recipe.steps) { step in
                    StepRow(step: step)
                }
            }
            List {
                ForEach(recipe.currentStep.parameters) { parameter in
                    ParameterRow(parameter: parameter)
                }
            }
        }
    }
}
</code></pre>

<p>Again, a working example of this is project <a href=""https://github.com/justdfd/ListBug"" rel=""nofollow noreferrer"">here</a>.</p>
","","user7014451","","user7014451","2019-07-12 16:56:05","2019-07-12 17:16:22","Index out of range when binding a Slider value to a nested array in EnvironmentObject","<swiftui><combine>","1","7","1","","","CC BY-SA 4.0"
"57008629","1","57022259","","2019-07-12 14:05:43","","1","3568","<p>On the click of a button I am trying to download a new random image and update the view. When the app loads it displays the downloaded image. When the button is clicked the image seems to download but the view is never updated and displays the place holder image. Am I missing something here, any ideas? Here is a simplified version.</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI

struct ContentView : View {

    @State var url = ""https://robohash.org/random.png""

    var body: some View {
        VStack {
            Button(action: {
                self.url = ""https://robohash.org/\(Int.random(in:0 ..&lt; 10)).png""
            }) {
                Text(""Get Random Robot Image"")
            }
            URLImage(url: url)
        }

    }
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>class ImageLoader: BindableObject {

    var downloadedImage: UIImage?
    let didChange = PassthroughSubject&lt;ImageLoader?, Never&gt;()

    func load(url: String) {

        guard let imageUrl = URL(string: url) else {
            fatalError(""Image URL is not correct"")
        }

        URLSession.shared.dataTask(with: imageUrl) { data, response, error in
            guard let data = data, error == nil else {
                DispatchQueue.main.async {
                    self.didChange.send(nil)
                }
                return
            }

            self.downloadedImage = UIImage(data: data)
            DispatchQueue.main.async {
                print(""downloaded image"")
                self.didChange.send(self)
            }
        }.resume()
    }
}

</code></pre>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI

struct URLImage : View {

    @ObjectBinding private var imageLoader = ImageLoader()
    var placeholder: Image

    init(url: String, placeholder: Image = Image(systemName: ""photo"")) {
        self.placeholder = placeholder
        self.imageLoader.load(url: url)
    }

    var body: some View {
        if let uiImage = self.imageLoader.downloadedImage {
            print(""return downloaded image"")
            return Image(uiImage: uiImage)
        } else {
            return placeholder
        }
    }
}
</code></pre>
","4842671","","","","","2019-07-13 19:36:10","Updating image view in SwiftUI after downloading image","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"57031248","1","57141857","","2019-07-14 21:23:53","","3","1312","<p>I'm currently playing with Combine and SwiftUI and have built a prototype app using the MVVM pattern. The app utilises a timer and the state of the button controlling this is bound (inelegantly) to the view model utilising a PassThroughSubject.</p>

<p>When the button is pressed, this should toggle the value of a state variable; the value of this is passed to the view model's subject (using .send) which should send a single event per button press. However, there appears to be recursion or something equally weird going on as multiple events are sent to the subject and a runtime crash results without the UI ever being updated.</p>

<p>It's all a bit puzzling and I'm not sure if this is a bug in Combine or I've missed something. Any pointers would be much appreciated. Code below - I know it's messy ;-) I've trimmed it down to what appears to be relevant but let me know if you need more.</p>

<p>View:</p>

<pre><code>struct ControlPanelView : View {
    @State private var isTimerRunning = false
    @ObjectBinding var viewModel: ControlPanelViewModel

    var body: some View {
        HStack {
            Text(""Case ID"") // replace with binding to viewmode

            Spacer()
            Text(""00:00:00"") // repalce with binding to viewmodel

            Button(action: {
                self.isTimerRunning.toggle()
                self.viewModel.apply(.isTimerRunning(self.isTimerRunning))
                print(""Button press"")
            }) {
                isTimerRunning ? Image(systemName: ""stop"") : Image(systemName: ""play"")
            }

        }
//            .onAppear(perform: { self.viewModel.apply(.isTimerRunning(self.isTimerRunning)) })
            .font(.title)
            .padding(EdgeInsets(top: 0, leading: 32, bottom: 0, trailing: 32))
    }
}
</code></pre>

<p>Viewmodel:</p>

<pre><code>final class ControlPanelViewModel: BindableObject, UnidirectionalDataType {

    typealias InputType = Input
    typealias OutputType = Output

    private let didChangeSubject = PassthroughSubject&lt;Void, Never&gt;()
    private var cancellables: [AnyCancellable] = []

    let didChange: AnyPublisher&lt;Void, Never&gt;

    // MARK:- Input
...
    private let isTimerRunningSubject = PassthroughSubject&lt;Bool, Never&gt;()
....


    enum Input {
...
        case isTimerRunning(Bool)
...
    }
    func apply(_ input: Input) {
        switch input {
...
        case .isTimerRunning(let state): isTimerRunningSubject.send(state)
...
        }
    }

    // MARK:- Output
    struct Output {
        var isTimerRunning = false
        var elapsedTime = TimeInterval(0)
        var concernId = """"
    }
    private(set) var output = Output() {
        didSet { didChangeSubject.send() }
    }

    // MARK:- Lifecycle
    init(timerService: TimerService = TimerService()) { 
        self.timerService = timerService

        didChange = didChangeSubject.eraseToAnyPublisher()

        bindInput()
        bindOutput()
    }

    private func bindInput() {
        utilities.debugSubject(subject: isTimerRunningSubject)

        let timerToggleStream = isTimerRunningSubject
            .subscribe(isTimerRunningSubject)

...

        cancellables += [
            timerToggleStream,
            elapsedTimeStream,
            concernIdStream
        ]
    }

    private func bindOutput() {
        let timerToggleStream = isTimerRunningSubject
            .assign(to: \.output.isTimerRunning, on: self)
...
        cancellables += [
            timerToggleStream,
            elapsedTimeStream,
            idStream
        ]

    }

}
</code></pre>
","2733214","","","","","2019-07-22 08:25:35","Unexpected events emitted by Swift Combine PassThroughSubject","<swift><swiftui><combine>","2","3","0","","","CC BY-SA 4.0"
"57054916","1","57055111","","2019-07-16 10:11:35","","1","3284","<p>I'm testing the Combine framework and using BindableObject as a notification hub for passing data among several views in a SwiftUI ContentView.</p>

<p>One of the views is a table. I click on a row and the value is detected in the print checkpoint, so the bindableobject receives the update.</p>

<p>Problem is, the new string is not broadcasted to the receiving end on the ContentView. </p>

<p>I'm new to this.</p>

<p>View controller with a table view .swift (broadcaster):</p>

<pre><code>import SwiftUI
import Combine

final public class NewestString: BindableObject {

    public var didChange = PassthroughSubject&lt;NewestString, Never&gt;()

    var newstring: String {
        didSet {
            didChange.send(self)
            print(""Newstring: \(newstring)"") //&lt;-- Change detected
        }
    }

    init(newstring: String) {
        self.newstring = newstring
    }

    public func update() {
        didChange.send(self)
        print(""--Newstring: \(newstring)"")

    }

}



final class AViewController: UIViewController {

    @IBOutlet weak var someTableView: UITableView!
    var returnData = NewestString(newstring:""--"")

    override func viewDidLoad() {
        super.viewDidLoad()

    }

}

/// [.....] More extensions here

extension AViewController: UITableViewDelegate {

    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
        let completion = someResults[indexPath.row]

    //// [......] More code here

        self.returnData.newstring = ""Test string"" //&lt;--- change caused 
        }
    }
}

</code></pre>

<p>Main content View (broadcast destination):</p>

<pre><code>import SwiftUI
import Combine

struct PrimaryButton: View {
    var title: String = ""DefaultTitle""
    var body: some View {
        Button(action: { print(""tapped"") }) {
            Text(title)
        }
   }

}


struct MyMiniView: View {
    @State var aTitle: String = ""InitialView""
    var body: some View {
        VStack{
            PrimaryButton(title: aTitle)
            }
    }
}


struct ContentView: View {

    @State private var selection = 0
    @ObjectBinding var desiredString: NewestString = NewestString(newstring: ""Elegir destino"") // &lt;-- Expected receiver

    var body: some View {

        TabbedView(selection: $selection){

            ZStack() {

                MyMiniView(aTitle: self.desiredString.newstring ?? ""--"")
               // expected end use of the change, that never happens
[...]
}

struct AView: UIViewControllerRepresentable {

    typealias UIViewControllerType = AViewController


    func makeUIViewController(context: UIViewControllerRepresentableContext&lt;AView&gt;) -&gt; AViewController {


        return UIStoryboard(name: ""MyStoryboard"", bundle: nil).instantiateViewController(identifier: String(describing: AViewController.self)) as! AViewController

    }

    func updateUIViewController(_ uiViewController: AViewController, context: UIViewControllerRepresentableContext&lt;AView&gt;) {
        //
    }


</code></pre>

<p>It compiles, runs and prints the change, but no update happens to the MyMiniView's PrimaryButton.</p>
","11780343","","11780343","","2019-07-16 13:50:13","2019-07-17 09:03:15","SwiftUI ObjectBinding won't receive didchange update from bindable object using combine","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"57100026","1","57113930","","2019-07-18 17:42:17","","2","1698","<p>I have a service file which gets and sends data to a backend. Is it possible to push push data from the service to a View and let the UI get the changes(not like a global var) like with a @State.</p>

<p>@EnviornmentObject isn't working read only
Global vars are not working because the don't inform the UI</p>

<pre><code>import SwiftUI
import SocketIO
import Combine

let manager = SocketManager(socketURL: URL(string: ""http://localhost:30000/ios"")!, config: [.log(true), .compress])
let socket = manager.defaultSocket

class Socket: BindableObject {
    let didChange = PassthroughSubject&lt;Socket,Never&gt;()
    var sliderValue: Float = 6 {
        willSet {
            print(newValue)
            didChange.send(self)
        }
    }
    static let sharedInstance = Socket()
    init() {

        socket.on(clientEvent: .connect) {data, ack in
            print(""socket connected"")
            self.sliderValue = 8 
        }

    }


    func establishConnection() {
        socket.connect()
    }

    func closeConnection() {
        socket.disconnect()
    }
}
</code></pre>

<p>HomeView:</p>

<pre><code>import SwiftUI

struct HomeView : View {
    @EnvironmentObject var socketData: Socket

    var body: some View {
        VStack {
            Text(""Hello World"")
            Slider(value: $socketData.sliderValue, from: 0.0, through: 10.0)
            Text(String(socketData.sliderValue))
        }
    }
}
</code></pre>
","9381064","","9381064","","2019-07-19 05:13:55","2019-07-31 16:36:22","Is it possible to have a Service in SwiftUI and push data to a View and update the UI?","<swift><service><websocket><swiftui><combine>","2","6","1","","","CC BY-SA 4.0"
"57105699","1","57105830","","2019-07-19 04:48:05","","8","2075","<p>The new Xcode 11 beta 4 has removed <code>Publishers.Once</code> struct from the Combine framework. What is the alternative?</p>

<p><code>Just</code> seems the likely candidate, however, it cannot be used for returning a publisher in methods with return type <code>AnyPublisher&lt;Bool, Error&gt;</code> as the associated <code>Failure</code> type for <code>Just</code> <a href=""https://developer.apple.com/documentation/combine/just/failure"" rel=""noreferrer"">is <code>Never</code>.</a></p>

<p>For example in the following method, I could return a <code>Publishers.Once</code> since the associated <code>Failure</code> type wasn't <code>Never</code>.</p>

<pre><code>func startSignIn() -&gt; AnyPublisher&lt;Void, Error&gt; {
    if authentication.provider == .apple { 
        let request = ASAuthorizationAppleIDProvider().createRequest()
        request.requestedScopes = [.email, .fullName]

        let controller = ASAuthorizationController(authorizationRequests: [request])
        controller.delegate = self
        controller.performRequests()

        return Publishers.Once(()).eraseToAnyPublisher()
    } else {
        return SignInManager.service.startSignIn(auth: authentication)
            .map { (auth) -&gt; Void in
                self.authentication = auth
        }.eraseToAnyPublisher()
    }
}
</code></pre>

<p>But now when I change it back to <code>Just</code> I get a compile error complaining that <code>Just</code> cannot be returned since the method should return a publisher with an associated <code>Failure</code> type.</p>

<pre><code>func startSignIn() -&gt; AnyPublisher&lt;Void, Error&gt; {
    if authentication.provider == .apple { 
        let request = ASAuthorizationAppleIDProvider().createRequest()
        request.requestedScopes = [.email, .fullName]

        let controller = ASAuthorizationController(authorizationRequests: [request])
        controller.delegate = self
        controller.performRequests()

        return Just(()).eraseToAnyPublisher() //Error Here
    } else {
        return SignInManager.service.startSignIn(auth: authentication)
            .map { (auth) -&gt; Void in
                self.authentication = auth
        }.eraseToAnyPublisher()
    }
}
</code></pre>

<p>Isn't there any alternative to <code>Publishers.Once</code> which can also have associated failure types? </p>
","2603900","","2603900","","2019-07-19 04:53:08","2019-11-09 04:29:59","What’s the alternative for 'Publishers.Once'?","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"57114142","1","57114657","","2019-07-19 14:02:35","","0","5338","<p>I use a socket.io websocket to get data from my backend and I push it with an environmentObject to the View(SwiftUI) but the problem is that I can't get the data because it is of type Any</p>

<p>I already tried to use ""guard var data = socketData else { return }"" but there is this error:
Initializer for conditional binding must have Optional type, not '[Any]'</p>

<pre><code>import SwiftUI
import SocketIO
import Combine

let manager = SocketManager(socketURL: URL(string: ""http://localhost:30000/ios"")!, config: [.log(true), .compress])
let socket = manager.defaultSocket

class Socket: BindableObject {
    let didChange = PassthroughSubject&lt;Socket,Never&gt;()
    var days: String = ""Loading..."" {
        didSet {
            didChange.send(self)
        }
    }
    static let sharedInstance = Socket()
    init() {

        socket.on(clientEvent: .connect) {data, ack in
            print(""socket connected"")
        }
        socket.on(""dailyWeather"") {data, ack in
            print(""just a test"")
            var data = data as String //Here is the current error
            /*do {
                let decoder = JSONDecoder()
                decoder.keyDecodingStrategy = .convertFromSnakeCase
                let city = try decoder.decode(day.self, from: data)
                self.weatherData.city = city.name
            } catch {
                print(error)
            }*/
            self.days = ""cur""
        }
    }


    func establishConnection() {
        socket.connect()
    }

    func closeConnection() {
        socket.disconnect()
    }
}
</code></pre>

<p>Error:
Cannot convert value of type '[Any]' to type 'String' in coercion</p>
","9381064","","","","","2019-07-19 14:34:10","How to fix 'Cannot convert value of type '[Any]' to type 'String' in coercion' error in swift","<swift><websocket><socket.io><swiftui>","1","3","","","","CC BY-SA 4.0"
"57127878","1","57128303","","2019-07-20 19:23:17","","11","5981","<p>I have a simple master/detail interface where the detail view modifies an item in an array. Using the below, the model is updated properly, but SwiftUI doesn't refresh the View to reflect the change.</p>

<p>Model:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ProduceItem: Identifiable {
    let id = UUID()
    let name: String
    var inventory: Int
}

final class ItemStore: BindableObject {
    var willChange = PassthroughSubject&lt;Void, Never&gt;()

    var items: [ProduceItem] { willSet { willChange.send() } }

    init(_ items: [ProduceItem]) {
        self.items = items
    }
}
</code></pre>

<p>Master view that displays a list of ProduceItems (an ItemStore is inserted into the environment in the SceneDelegate):</p>

<pre class=""lang-swift prettyprint-override""><code>struct ItemList: View {
    @EnvironmentObject var itemStore: ItemStore

    var body: some View {
        NavigationView {
            List(itemStore.items.indices) { index in
                NavigationLink(destination: ItemDetail(item: self.$itemStore.items[index])) {
                    VStack(alignment: .leading) {
                        Text(self.itemStore.items[index].name)
                        Text(""\(self.itemStore.items[index].inventory)"")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            }
            .navigationBarTitle(""Items"")
        }
    }
}
</code></pre>

<p>Detail view that lets you change the inventory value of an item:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ItemDetail: View {
    @Binding var item: ProduceItem

    var body: some View {
        NavigationView {
            Stepper(value: $item.inventory) {
                Text(""Inventory is \(item.inventory)"")
            }
            .padding()
            .navigationBarTitle(item.name)
        }
    }
}
</code></pre>

<p>Tapping on the stepper in the ItemDetail view modifies the item in the store, but the text of the stepper doesn't change. Navigating back to the list confirms the model has been changed. Also, I confirmed that the store calls <code>willChange.send()</code> to its publisher. I would assume that the <code>send()</code> call updates the ItemStore in the environment and the detail view's <code>@Binding</code> property should be notified of the change and refresh the display (but it doesn't).</p>

<p>I tried changing ItemDetail's item property to use <code>@State</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>@State var item: ProduceItem = ProduceItem(name: ""Plums"", inventory: 7)
</code></pre>

<p>In this case, the model is item is updated when using the stepper and the view is refreshed, displaying the updated inventory. Can anyone explain why using the <code>@Binding</code> property doesn't refresh the interface, but a local <code>@State</code> property does?</p>
","3791229","","2598316","","2019-07-20 20:57:38","2019-07-20 20:57:38","SwiftUI @Binding doesn't refresh View","<swiftui><combine>","1","3","3","","","CC BY-SA 4.0"
"57128132","1","57128604","","2019-07-20 19:59:29","","0","769","<p>SUMMARY:
I'm creating an app with three views and the same ""Settings"" button that navigates to a list view at the top right of each view. When I select the Setting icon, it shows a slider, a stepper, and a toggle in the list view that pops up. </p>

<p>I was able to use the below code to initialize the values, and while running the app I was able to change the data in the Settings view, but the issue I am having is the data is not retained when I exit the settings view. </p>

<p>Xcode 11 Beta 4 updated from didChange to willChange as part of an update to BindableObject, which may be part of my issue since it may not be implemented the same way.</p>

<p>ISSUE:
1) When exiting the settings view, data does not update in my main view.</p>

<p>2) When I select Settings view again, it shows the initialized values and not my previous changed values.</p>

<p>EXPECTED OUTCOME:
I would like my Profile data to update with the new values defined in the Settings app</p>

<p>My datastore (Profile.swift)</p>

<pre><code>import SwiftUI
import Combine

class Profile: BindableObject {

    var willChange = PassthroughSubject&lt;Void, Never&gt;()

    var test1 = 16 { willSet { update() }}
    var test2: Double = 10 { willSet { update() }}
    var test3 = true { willSet { update() }}

    func update() {
        willChange.send()
    }
}
</code></pre>

<p>My Settings View (ProfileSummary.swift)</p>

<pre><code>import SwiftUI


struct ProfileSummary: View {
    //var profile: Profile
    @ObjectBinding var profile = Profile()
    var body: some View {
        List {
                Stepper(value: $profile.test1, in: 12...22) {
                    Text(""Test1 Size: \(profile.test1)"")
                }
            Text(""Quiz Settings"")
                .bold()
            HStack {
                Text(""   Test2: \(Int(profile.test2))"")
                Slider(value: $profile.test2, from: 1.0, through: 107.0, by: 1.0)
            }
            Toggle(isOn: $profile.test3) {
                Text(""   Change to Test3"")
            }

        }
    }
}

#if DEBUG
struct ProfileSummary_Previews: PreviewProvider {
    static var previews: some View {
        ProfileSummary()
    }
}
#endif
</code></pre>

<p>My main view (Test_List.swift):</p>

<pre><code>import SwiftUI
import UIKit



struct Test_List : View {

    @ObjectBinding var profile: Profile = Profile()

    @State var showingProfile = false
    var profileButton: some View {
        Button(action: { self.showingProfile.toggle() }) {
            Text(""Settings"")
                .padding()
        }
    }

    var body: some View {
        NavigationView {
            VStack(alignment: .center){
            Text(""Test1: \(profile.test1)"")
            Text(""Test2: \(profile.test2)"")

            Spacer()

        }
            .navigationBarTitle(Text(""View3""))
            .navigationBarItems(trailing: profileButton)
            .sheet(isPresented: $showingProfile) {
                ProfileSummary()
            }
        }
    }
}


#if DEBUG
struct Test_List_Previews : PreviewProvider {
    static var previews: some View {
        Test_List()
    }
}
#endif
</code></pre>
","10843666","","","","","2019-07-20 21:07:00","Saving data using Bindable Object in SwiftUI Xcode 11 Beta 4","<ios><swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"57133806","1","57134190","","2019-07-21 13:49:35","","6","9177","<p>I have a <code>SwiftUI</code> native Watch app I Am working on. I have a <code>Combine</code> based class that allows me to store `\userDefaults, one of which is a simple toggle.</p>

<pre><code>import SwiftUI  
import Foundation  
import Combine  


class MeetingSetup: BindableObject {  

    let willChange = PassthroughSubject&lt;Void, Never&gt;()  

    var twitterEnabled: Bool = false {  
        didSet {  
            willChange.send()  
        }  
    }  

    init() {  
        let prefs:UserDefaults = UserDefaults(suiteName: ""group.com.appname"")!  
        twitterEnabled = prefs.bool(forKey: ""keyTwitterEnabledBool"")  
    }  
} 
</code></pre>

<p>In the <code>SwiftUI</code> I am getting the error messages that <code>Bool</code> is not convertible to <code>Binding&lt;Bool&gt;</code></p>

<pre><code>import SwiftUI  
import Combine  

struct SetupView : View {  

    @ObjectBinding var meetingSetup: MeetingSetup = delegate.meetingSetup  

    var body: some View {  

                HStack{  
                    Toggle(isOn: self.meetingSetup.twitterEnabled){  // &lt;== 'Bool' in not convertible to 'Binding&lt;Bool&gt;'  
                        Text(""Twitter"")  
                    }  
    }  
} 
</code></pre>

<p>I don't understand why this is getting the message since the code is <code>@ObjectBinding</code>, should it not be <code>Binding&lt;Bool&gt;</code> by definition?  If not how do I address this correctly??</p>
","373749","","10151808","","2019-07-21 17:15:59","2019-07-21 17:15:59","'Bool' is not convertible to 'Binding<Bool>' in SwiftUI","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"57140530","1","57141285","","2019-07-22 06:51:33","","12","12812","<p>as the title suggests, I'm trying to pass data from one child view (A), to another child view (B) through the parent view (P).</p>

<p>The parent view looks like this:</p>

<pre><code>@State var rectFrame: CGRect = .zero 

var body: some View {
    childViewA(rectFrame: $rectFrame)
    childViewB()
}
</code></pre>

<p>where <code>childViewA</code> obtains a <code>CGRect</code> that <code>childViewB</code> needs.</p>

<p><code>childViewA</code> looks like this:</p>

<pre><code>@Binding var rectFrame: CGRect

var body: some View {
    // Very long code where rectFrame is obtained and printed to console correctly
}
</code></pre>

<p>How do I pass <code>rectFrame</code> to <code>childViewB</code>? Everything I've tried so far returns <code>CGRect.zero</code> in <code>childViewB</code> despite printing the correct values in both the <code>parentView</code> and <code>childViewA</code>.</p>

<p>In order to try and pass the value to <code>childViewB</code>, I've rewritten <code>parentView</code> like this:</p>

<pre><code>@State var rectFrame: CGRect = .zero 

var body: some View {
    childViewA(rectFrame: $rectFrame)
    childViewB(rectFrame: $rectFrame.value)
}
</code></pre>

<p>with <code>childViewB</code> having the following structure:</p>

<pre><code>var rectFrame: CGRect = CGRect.zero

var body: some View {

}
</code></pre>

<p>But that just prints <code>CGRect.zero</code> every time.</p>

<p>I've recently tried <code>@ObjectBinding</code> but I've struggled with it, so if anyone could help me out with this specific example, I'd be very grateful.</p>

<pre><code>class SourceRectBindings: BindableObject {
    let willChange = PassthroughSubject&lt;Void, Never&gt;()

    var sourceRect: CGRect = .zero {
        willSet {
            willChange.send()
        }
    }
}
</code></pre>
","4283749","","4283749","","2019-07-22 07:04:28","2021-09-23 20:26:03","How do I pass data from a child view to a parent view to another child view in SwiftUI?","<swiftui><combine>","4","4","8","","","CC BY-SA 4.0"
"57152031","1","57152088","","2019-07-22 18:44:44","","0","141","<p>I have a class that fetches the user's current location, and I want to be able to pass the most-recently fetched <code>CLLocation</code> or an <code>Error</code> to a <code>SwiftUI</code> <code>View</code>.</p>

<p>Below is the class that is responsible for location-fetching:</p>

<pre class=""lang-swift prettyprint-override""><code>class LocationProvider: NSObject, BindableObject, CLLocationManagerDelegate {

    // MARK: - BindableObject

    var willChange = PassthroughSubject&lt;CLLocation, Error&gt;()

    // MARK: - CLLocationManagerDelegate

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        willChange.send(location)
    }

    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        willChange.send(completion: .failure(.unknown))
    }

}
</code></pre>

<p>I get the following compilation error: <code>Type 'LocationProvider' does not conform to protocol 'BindableObject'</code> when I use <code>Error</code> as the failure type. However, if I change <code>Error</code> to <code>Never</code>, then the file compiles successfully.</p>

<p>What do I need to change so that I can pass a <code>CLLocation</code> or an <code>Error</code>?</p>
","3720634","","1000551","","2019-12-07 10:01:12","2019-12-07 10:01:12","Apple Combine's PassthroughSubject not Compiling","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"57153221","1","57172058","","2019-07-22 20:22:30","","14","7349","<p>I use an OAuth framework which creates authenticated requests asynchronously like so:</p>

<pre><code>OAuthSession.current.makeAuthenticatedRequest(request: myURLRequest) { (result: Result&lt;URLRequest, OAuthError&gt;) in
            switch result {
            case .success(let request):
                URLSession.shared.dataTask(with: request) { (data, response, error) in
                    // ...
                }
             // ...
             }
        }
</code></pre>

<p>I am trying to make my OAuth framework use Combine, so I know have a Publisher version of the <code>makeAuthenticatedRequest</code> method i.e.:</p>

<pre><code>public func makeAuthenticatedRequest(request: URLRequest) -&gt; AnyPublisher&lt;URLRequest, OAuthError&gt;
</code></pre>

<p>I am trying to use this to replace the call site above like so:</p>

<pre><code>OAuthSession.current.makeAuthenticatedRequestPublisher(request)
    .tryMap(URLSession.shared.dataTaskPublisher(for:))
    .tryMap { (data, _) in data } // Problem is here
    .decode(type: A.self, decoder: decoder)
</code></pre>

<p>As noted above, the problem is on turning the result of the publisher into a new publisher. How can I go about doing this?</p>
","801860","","","","","2019-07-23 20:54:10","Combine turn one Publisher into another","<ios><swift><combine>","1","0","5","","","CC BY-SA 4.0"
"57153729","1","57154365","","2019-07-22 21:07:13","","5","4525","<p>I'm having an issue getting an audio file to play when the function is called.</p>

<p>I am using an AVAudioPlayer to try and play the file following the instructions form here:
<a href=""https://www.hackingwithswift.com/example-code/media/how-to-play-sounds-using-avaudioplayer"" rel=""noreferrer"">https://www.hackingwithswift.com/example-code/media/how-to-play-sounds-using-avaudioplayer</a>
After the button is pressed in the view, it calls a func to play the sound, but from what I can tell, nothing is played. There are no errors thrown, and the file is found. The app also uses a speech synthesizer when a button is pushed, and that plays fine.</p>

<p>I looked around stack overflow and followed the instructions from here:
<a href=""https://stackoverflow.com/questions/57068891/where-to-place-code-for-audio-playback-in-a-swiftui-app"">Where to place code for audio playback in a SwiftUI app</a></p>

<p>But still the audio is not played when the button is pushed.</p>

<p>Here is the func:</p>

<pre class=""lang-swift prettyprint-override""><code>    func playSound() {
        var sound = AVAudioPlayer()

        if let path = Bundle.main.path(forResource: ""TryAgain"", ofType: ""wav"") {
            do {
                sound = try AVAudioPlayer(contentsOf: URL(fileURLWithPath: path))
                print(""Playing sound"")
                sound.play()
            } catch {
                print( ""Could not find file"")
            }
        }
</code></pre>

<p>Here is the class:</p>

<pre class=""lang-swift prettyprint-override""><code>class Player: BindableObject {

    let willChange = PassthroughSubject&lt;Player, Never&gt;()

    var isPlaying: Bool = false {
        willSet {
            willChange.send(self)
        }
    }

    func playSound() {
        var sound = AVAudioPlayer()

        if let path = Bundle.main.path(forResource: ""TryAgainWav"", ofType: ""wav"") {
            do {
                sound = try AVAudioPlayer(contentsOf: URL(fileURLWithPath: path))
                print(""Playing sound"")
                sound.play()
            } catch {
                print( ""Could not find file"")
            }
        }
    }
}
</code></pre>

<p>Update: Not sure if this helps, but I built this in with IB instead of SwiftUI and noticed the same message is printed in the console when I click the button to play the audio file:</p>

<p>2019-07-22 11:29:41.075568-0700 PlaySoundPrac[13952:46549155] [plugin] AddInstanceForFactory: No factory registered for id  F8BB1C28-BAE8-11D6-9C31-00039315CD46</p>

<p>Any help would be greatly appreciated</p>
","11821262","","11821262","","2019-07-22 21:53:19","2020-09-29 01:14:34","Audio not playing in SwiftUI","<swift><swiftui>","2","1","1","","","CC BY-SA 4.0"
"57168609","1","57365773","","2019-07-23 16:32:00","","5","5162","<p>I am new to Swift and even more so to SwiftUI. I started to create a little basic project. I use Github API to fetch repositories list. </p>

<p>So I created a ""Search Bar"" like since SwiftUI doesn't have a SearchBar component. I would like to perform the fetch operation everytime my Textfield content is changed. </p>

<p>I don't want the fetch method to be called too often. I decided to debounce it. I'm facing a problem, I don't find/understand example. </p>

<p>I tried to implement a debounce solution but it doesn't work, my application just crash. </p>

<p>Here's my BindableObject</p>

<pre><code>import SwiftUI
import Combine

class ReposStore: BindableObject {

    private var service: GithubService

    let didChange = PassthroughSubject&lt;Void, Never&gt;()

    @Published var searchText: String = """"

    var repos: [Repository] = [] {
        didSet {
            didChange.send()
        }
    }

    var error: String = """" {
        didSet {
            didChange.send()
        }
    }

    var test: String = """" {
        didSet {
            didChange.send()
        }
    }

    private var cancellable: AnyCancellable? = nil

    init(service: GithubService) {
        self.service = service


        cancellable = AnyCancellable($searchText
            .removeDuplicates()
            .debounce(for: 2, scheduler: DispatchQueue.main)
            .flatMap { self.fetch(matching: $0) }
            .assign(to: \.test, on: self)
        )
    }

    func fetch(matching query: String = """") {
        print(""### QUERY \(query)"")
        self.service.getUserRepositories(matching: query) { [weak self] result in
            DispatchQueue.main.async {
                print(""### RESULT HERE \(result)"")
                switch result {
                case .success(let repos): self?.repos = repos
                case .failure(let error): self?.error = error.localizedDescription
                }
            }
        }
    }
}
</code></pre>

<p>And this is my View</p>

<pre><code>import SwiftUI

struct RepositoryList : View {
    @EnvironmentObject var repoStore: ReposStore
    @State private var userName: String = """"

    var body: some View {

        VStack {
            NavigationView {
                VStack(spacing: 0) {

                    HStack {
                        Image(systemName: ""magnifyingglass"").background(Color.blue).padding(.leading, 10.0)
                        TextField($repoStore.repoUser, placeholder: Text(""Search"")).background(Color.red)
                            .padding(.vertical, 4.0)
                            .padding(.trailing, 10.0)
                    }
                    .border(Color.secondary, width: 1, cornerRadius: 5)
                        .padding()

                    List {
                        ForEach(self.repoStore.repos) { repository in
                            NavigationLink(
                                destination: RepositoryDetail(repository: repository).environmentObject(self.repoStore)
                            ) {
                                RepositoryRow(repository: repository)
                            }
                        }

                    }.navigationBarTitle(Text(""Repositories""))
                }
            }
        }
    }
</code></pre>

<p>I tried to use a Timer and schedule and action every 8 seconds but this method cause my application to crash. </p>

<p>More, I don't really know if it's a good practice to declare a function with ""@objc"" annotation ... </p>

<p>Could someone help me to implement a correct way to debounce a method inside a BindableObject ? </p>

<p>Thank you in advance :)</p>
","7215553","","7215553","","2019-07-24 16:17:24","2019-08-05 20:34:57","Debounce method call from BindableObject in SwiftUI","<swift><swiftui><combine>","1","6","4","","","CC BY-SA 4.0"
"57199922","1","57201744","","2019-07-25 10:33:46","","23","18605","<p>I've been watching the <a href=""https://developer.apple.com/videos/play/wwdc2019/226/"" rel=""noreferrer"">Data Flow Through SwiftUI WWDC talk</a>. They have a slide with a sample code where they use a Timer publisher that gets connected to a SwiftUI View, and updates the UI with the time.</p>

<p>I'm working on some code where I want to do the exact same thing, but can't figure out how this <code>PodcastPlayer.currentTimePublisher</code> is implemented, and then hooked to the UI struct. I have also watched all the videos about Combine.</p>

<p>How can I achieve this?</p>

<p>The sample code:</p>

<pre><code>struct PlayerView : View {
  let episode: Episode
  @State private var isPlaying: Bool = true
  @State private var currentTime: TimeInterval = 0.0

  var body: some View {
    VStack { // ...
      Text(""\(playhead, formatter: currentTimeFormatter)"")
    }
    .onReceive(PodcastPlayer.currentTimePublisher) { newCurrentTime in
      self.currentTime = newCurrentTime
    }
  }
}
</code></pre>
","901034","","13302","","2019-07-28 07:02:34","2022-04-16 11:07:45","Create a Timer Publisher using Swift Combine","<swift><swiftui><publisher><combine>","5","0","7","","","CC BY-SA 4.0"
"57270850","1","57272955","","2019-07-30 11:42:30","","17","9896","<p>In the following code ""Test"" should be printed in the console when the Button is pressed, but it's not. The event is not send through the publisher.
Any idea what happened with PassthroughSubject in Xcode 11 Beta 5 ?
(in Xcode 11 Beta 4 it works well)</p>

<pre><code>var body: some View {  

    let publisher = PassthroughSubject&lt;String, Never&gt;()

    publisher.sink { (str) in  
        print(str)  
    }  
    return Button(""OK"") {  
        publisher.send(""Test"")  
    }  
}
</code></pre>

<p>P.S. I know there are other ways to print a string when a button is pressed, I just wanna show a simple send-receive example</p>
","10208552","","7786555","","2019-07-30 12:55:12","2019-11-09 09:37:52",".send() and .sink() do not seem to work anymore for PassthroughSubject in Xcode 11 Beta 5","<swiftui><combine>","2","0","6","","","CC BY-SA 4.0"
"57275156","1","57325015","","2019-07-30 15:25:36","","3","620","<p>I had a <code>@Published</code> variable to indicate my user state in one of my repository classes.</p>

<pre class=""lang-swift prettyprint-override""><code>@Published public var state: UserState = .initial
</code></pre>

<p>In testing, I used <code>sink</code> to easily observe the changes and fullfill the expectation my test was waiting for.</p>

<p>The original test code looked like this:</p>

<pre class=""lang-swift prettyprint-override""><code>sub = Authentication.shared.$state.receive(on: DispatchQueue.main).sink(receiveValue: { state in
    expectation.fulfill()
})
Authentication.shared.login(with: Credentials(email: ""gujci@gmail.com"", password: ""asdasd""))
</code></pre>

<p>Which resulted in a compiler error like the following <code>Abort trap: 6</code></p>

<pre><code>Global is external, but doesn't have external or weak linkage!
i64* @""$s14TestRepository14AuthenticationC6_state33_B23F0E9C543FDF10733C02EF2F1E18CCLL7Combine9PublishedVyAA9UserStateOGvpWvd""
&lt;unknown&gt;:0: error: fatal error encountered during compilation; please file a bug report with your project and the crash log
&lt;unknown&gt;:0: note: Broken module found, compilation aborted!
Stack dump:
...
</code></pre>

<p>The project where this occurs is in a separate swift package than the application.</p>

<p>When I have tried to use it from the application (no from tests) the result was the same. Also, I have tried other publishers eg. <code>Just</code> and <code>Future</code> returning from the network calls, all of them worked fine with <code>sink</code>.</p>

<p>I had this issue since beta 4, but never tried in previous ones, might be present in those as well. I have noticed there were huge changes for Combine between beta 4 and 5, yet, the error persists.</p>

<p>Has anybody managed to use the <code>sink</code> function on a <code>@Published</code> variable from an external library without such errors?</p>

<p>If I have misinterpreted something, please correct me, for now I have to assume, the problem is at Apple's end.</p>
","3308103","","","","","2019-08-02 10:50:13","Xcode 11 beta 5 Abort trap: 6 error when calling sink on @Published variable","<swift><beta><xcode11><combine>","1","0","1","","","CC BY-SA 4.0"
"57289150","1","57289622","","2019-07-31 10:55:43","","6","1334","<p>in the code provided below I am having an issue that the <code>DetailViewModel</code> is being recreated. That happens because the <code>ContentView</code> updates, which also recreates all the <code>NavigationLink</code>s and destinations. Because of this the state within the <code>DetailViewModel</code> is reset.</p>

<p>This is some example code:</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

struct ContentView: View {

    let items = [""Item A"", ""Item B"", ""Item C""]

    @State var contentViewUpdater = 0

    var body: some View {
        NavigationView {
            VStack {
                Button(""Update ContentView: \(contentViewUpdater)"") {
                    self.contentViewUpdater += 1
                }
                List(items, id: \.self) { item in
                    // How to prevent DetailViewModel from recreating after this ContentView receives an update?
                    NavigationLink(destination: DetailView(model: DetailViewModel(item: item))) {
                        Text(item)
                    }
                }
            }
        }
    }
}

final class DetailViewModel: ObservableObject {
    let item: String
    @Published var counter = 0

    init(item: String) {
        self.item = item
    }
}

struct DetailView: View {
    @ObservedObject var model: DetailViewModel

    var body: some View {
        VStack {
            Text(""Counter for \(model.item): \(model.counter)"")
            Button(""Increase counter"") {
                self.model.counter += 1
            }
        }
    }
}

#if DEBUG
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
#endif
</code></pre>

<p>Here is a screenrecording of the issue. The <code>DetailViewModel.counter</code> var resets if <code>ContentView</code> updates.</p>

<p><a href=""https://i.stack.imgur.com/2tJBp.gif"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/2tJBp.gif"" alt=""screenrecording""></a></p>

<p>How can you prevent the state in <code>DetailViewModel</code> from resetting when the parent view updates?</p>
","4583267","","","","","2019-07-31 11:22:36","How to reuse view model instance for destination view in a NavigationLink","<ios><swift><swiftui>","2","1","2","","","CC BY-SA 4.0"
"57289462","1","57300762","","2019-07-31 11:13:31","","3","4452","<p>So, I want to have a <code>Text</code> that changes its content based on the contents of my CoreData Model. To do that I used a computed property in Xcode beta 4 but it doesn't seem to work anymore. Either that's a bug or there is some other issue I don't see?</p>

<p>The problem I have exactly is that my View (and the computed property) don't seem to get updated when <code>self.objectWillChange.send()</code> is called in my store.</p>

<p>I also tried to 'export' my var into the store and get it from there, with the same result...</p>

<hr>

<p><strong>EDIT:</strong>
I just tried the same with another class and it didn't work with just <code>objectWillChange.send()</code> but only with <code>@Published</code> however, even that stopped working if the class inherited from NSObject...</p>

<hr>

<p>I just found out: with </p>

<pre class=""lang-swift prettyprint-override""><code>struct Today: View {
    @EnvironmentObject var myStore: DateStore
    var hasPlans: Bool {
        guard let plans = myStore.getPlans() else { return false }
        return plans.isEmpty
    }

    var body: some View{
        VStack{
            Text(hasPlans ? ""I have plans"":""I have time today"")
            Button(action: {
                self.myStore.addPlans(for: Date())
            }) {
                Text(""I have plans"")
            }
    }
}

class DateStore: NSObject, ObservableObject, NSFetchedResultsControllerDelegate {
    private var fetchedResultsController: NSFetchedResultsController&lt;DateStore&gt;
    //...
    public func addPlans(for date: Date){
        //{...}
        if let day = self.dates.first(where: { $0.date == date}){
            day.plans += 1
            saveChanges()
        }else{
            self.create(date: dayDate)
        }
    }

    func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {
        self.objectWillChange.send()
    }
}


</code></pre>

<p>That's a very simplified version of my problem and I know that my DataModel works because the values change and <code>self.objectWillChange.send()</code> is called, but my View isn't updated for some reason....</p>
","9506784","","9506784","","2019-07-31 12:16:48","2019-08-01 01:49:17","Computed (NSObject) Properties in SwiftUI don't update the view","<swift><core-data><swiftui><computed-properties><combine>","3","5","1","","","CC BY-SA 4.0"
"57302033","1","57302695","","2019-08-01 04:57:12","","13","7397","<p>I am trying to make individually moveable objects. I am able to successfully do it for one object but once I place it into an array, the objects are not able to move anymore.</p>

<p>Model: </p>

<pre><code>class SocialStore: ObservableObject {
    @Published var socials : [Social]

    init(socials: [Social]){
        self.socials = socials
    }
}

class Social : ObservableObject{
    var id: Int
    var imageName: String
    var companyName: String
    @Published var pos: CGPoint

    init(id: Int, imageName: String, companyName: String, pos: CGPoint) {
        self.id = id
        self.imageName = imageName
        self.companyName = companyName
        self.pos = pos
    }

    var dragGesture : some Gesture {
        DragGesture()
            .onChanged { value in
                self.pos = value.location
                print(self.pos)
        }
    }
}
</code></pre>

<p>Multiple image (images not following drag): </p>

<pre><code>struct ContentView : View {
    @ObservedObject var socialObject: SocialStore = SocialStore(socials: testData)

    @ObservedObject var images: Social = testData[2]

    var body: some View {
        VStack {
            ForEach(socialObject.socials, id: \.id) { social in
                Image(social.imageName)
                    .position(social.pos)
                    .gesture(social.dragGesture)
            }
        }
    }
}
</code></pre>

<p>Single image (image follow gesture):</p>

<pre><code>struct ContentView : View {
    @ObservedObject var socialObject: SocialStore = SocialStore(socials: testData)

    @ObservedObject var images: Social = testData[2]

    var body: some View {
        VStack {
            Image(images.imageName)
                .position(images.pos)
                .gesture(images.dragGesture)
        }
    }
}
</code></pre>

<p>I expect the individual items to be able to move freely . I see that the coordinates are updating but the position of each image is not.</p>
","10200990","","","","","2019-09-24 09:19:52","Published works for single object but not for array of objects","<xcode><swiftui><xcode11><combine>","4","0","6","","","CC BY-SA 4.0"
"57306886","1","57307459","","2019-08-01 10:23:24","","5","4252","<p>I went through the WWDC video of ""Introducing Combine"" where it was said that whenever a publisher value gets updated the CombineLatest gets called and updated. But the snippet I created works oddly.</p>

<pre><code>class Mango {
    var enableButton = false
    @Published var userName = ""admin""
    @Published var password = ""poweruser""
    @Published var passwordAgain = ""poweruser""
    var validatePassword: AnyCancellable {
        Publishers.CombineLatest($password, $passwordAgain).map { (password, reenterpass) -&gt; String? in
            print(""Is Password Same to \(password)? :"", password == reenterpass)
            guard password == reenterpass else { return nil }
            return password
        }.eraseToAnyPublisher()
            .map { (str) -&gt; Bool in
            print(""In Map"", str != nil)
            guard str != nil else { return false }
            return true
        }.assign(to: \.enableButton, on: self)
    }

    init() {
        validatePassword
    }

    func checkSub() {
        print(""1. Is password same? -&gt;"",enableButton)
        password = ""nopoweruser""
        print(""2. Is password same? -&gt;"",enableButton)
    }
}

</code></pre>

<p>When I initialize and call the function checkSub() where the publisher 'password' is updated the CombineLatest does not get called. Why is it behaving oddly?</p>

<p><strong>Input:</strong></p>

<pre><code>let mango = Mango()&lt;br&gt;
mango.checkSub()
</code></pre>

<p><strong>Output:</strong> </p>

<pre><code>Is Password Same to poweruser? : true  
In Map true  
1. Is password same? -&gt; true  
2. Is password same? -&gt; true
</code></pre>
","2582169","","1200262","","2019-08-01 11:06:50","2019-08-01 11:06:50","Issues with Swift's Combine framework CombineLatest","<ios><swift><swift5.1>","1","1","1","","","CC BY-SA 4.0"
"57315409","1","57321795","","2019-08-01 18:55:59","","52","29400","<p>It seems to me that Apple is encouraging us to give up using <code>UIViewController</code> in SwiftUI, but without using view controllers, I feel a little bit powerless. What I would like is to be able to implement some sort of <code>ViewModel</code> which will emit events to <code>View</code>.</p>
<p><strong>ViewModel</strong>:</p>
<pre><code>public protocol LoginViewModel: ViewModel {
  var onError: PassthroughSubject&lt;Error, Never&gt; { get }
  var onSuccessLogin: PassthroughSubject&lt;Void, Never&gt; { get }
}
</code></pre>
<p><strong>View</strong>:</p>
<pre><code>public struct LoginView: View {
  fileprivate let viewModel: LoginViewModel
  
  public init(viewModel: LoginViewModel) {
    self.viewModel = viewModel
  }
  
  public var body: some View {
    NavigationView {
      MasterView()
        .onReceive(self.viewModel.onError, perform: self.handleError)
        .onReceive(self.viewModel.onSuccessLogin, perform: self.handleSuccessfullLogin)
    }
  }

  func handleSuccessfullLogin() {
    //push next screen
  }
  
  func handleError(_ error: Error) {
    //show alert
  }
}
</code></pre>
<p>Using SwiftUI, I don't know how to push another controller if login is successful</p>
<p>Also, I would appreciate any advice about how to implement what I want in a better way. Thanks.</p>
","6061098","","6061098","","2020-12-19 16:50:05","2021-10-25 13:32:15","Push View programmatically in callback, SwiftUI","<ios><swift><swiftui>","6","2","7","","","CC BY-SA 4.0"
"57348512","1","57349279","","2019-08-04 16:52:23","","7","6119","<p>I am currently doing a project using SwiftUI and Combine. I'm on Xcode11 Beta 5. I would like to fetch my Github repositories, display them and then be able to bookmark some of them.</p>

<p>I'm able to fetch them and display them. I'm using Combine with @Published property wrapper to update my views. To now, everything worked as expected. </p>

<p>So I moved on to the next step, bookmarking repositories. I would like to use Realm to persist these repositories.</p>

<p>My problem is that, I have an Observable class which have a <strong>@Published</strong> array of Repository. Repository is a decodable class. In my Repository class I have a simple class property <strong>isFavorite</strong> set to false for now. </p>

<p>In my repositories list, when I click on a repository to see details, I would like to have the possibility to bookmark it. So I retrieve its index by its id from my array of Repository and set its property <strong>isFavorite</strong> to true. But my view doesn't update. I mean I have a conditional rendering and it's stuck to false. </p>

<p>Here's my code :</p>

<pre><code>import SwiftUI
import Combine

struct RepositoryList : View {
    @ObservedObject var store: Store

    func move(from source: IndexSet, to destination: Int) {
        store.repositories.swapAt(source.first!, destination)
    }

    @State private var isTapped = false
    @State private var bgColor = Color.white

    var body: some View {
        NavigationView {
            VStack {
                List {
                    Section(header: Text(""\(String(store.repositories.count)) repositories"")) {
                        ForEach(store.repositories) { repository in
                            NavigationLink(destination: RepositoryDetail(store: self.store, repository: repository)) {
                                RepositoryRow(repository: repository)
                            }.padding(.vertical, 8.0)
                        }.onDelete { index in
                            self.store.repositories.remove(at: index.first!)
                        }.onMove(perform: move)
                    }
                }
            }
        }.navigationBarTitle(""Github user"").navigationBarItems(trailing: EditButton())
    }
}

struct RepositoryDetail : View {
    @ObservedObject var store: Store
    var repository: Repository

    var repoIndex: Int {
        let repoIndex = store.repositories.firstIndex(where: {$0.id == repository.id})!
        print(""### IS FAVORITE \(String(store.repositories[repoIndex].isFavorite))"")
        return repoIndex
    }

    var body: some View {
        VStack(alignment: .leading) {
            Text(String(store.repositories[repoIndex].isFavorite))
            Button(action: { self.store.repositories[self.repoIndex].isFavorite.toggle() }) {
                if (self.store.repositories[self.repoIndex].isFavorite) {
                    Image(systemName: ""star.fill"").foregroundColor(Color.yellow)
                } else {
                    Image(systemName: ""star"").foregroundColor(Color.gray)
                }
            }
        }.navigationBarTitle(Text(repository.name), displayMode: .inline)
    }
}

class Store: ObservableObject {
    private var cancellable: AnyCancellable? = nil
    @Published var repositories: [Repository] = []

    init () {
        var urlComponents = URLComponents(string: ""https://api.github.com/users/Hurobaki/repos"")!
        var request = URLRequest(url: urlComponents.url!)
        request.addValue(""application/json"", forHTTPHeaderField: ""Content-Type"")

        cancellable = URLSession.shared.send(request: request)
            .decode(type: [Repository].self, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { completion in
                print(""### .sink() received the completion"", String(describing: completion))
                switch completion {
                case .finished:
                    break
                case .failure(_):
                   print(""### ERROR"")
                }
            }, receiveValue: { repositories in
                self.repositories = repositories
            })

    }
}

class Repository: Decodable, Identifiable {
    var id: Int = 0
    var name: String = """"
    var desc: String? = nil

    var isFavorite = false

    private enum CodingKeys: String, CodingKey {
        case id, name
        case desc = ""description""
    }
}
</code></pre>

<p>I don't know why my Button component never display <code>Image(systemName: ""star.fill"").foregroundColor(Color.yellow)</code> When I print <strong>isFavorite</strong> property its value changes from true to false and vice versa but my view doesn't update.</p>

<p>I did the tutorial from Apple Developer where they do exactly the same thing, so I don't know why I have this error, what am I missing ?  </p>

<p>Some help would be really appreciated and / or reviews on my code :) </p>

<p>Thank you</p>

<p>PS: In order not to post an even longer code I have uploaded it on Pastebin
<a href=""https://pastebin.com/zjDwQSGq"" rel=""noreferrer"">https://pastebin.com/zjDwQSGq</a></p>
","7215553","","7215553","","2019-08-04 17:06:48","2022-04-17 16:07:54","Swift Combine - @Published property Array","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"57360838","1","57366566","","2019-08-05 14:38:39","","12","2694","<p>I found this question <a href=""https://stackoverflow.com/questions/56699418/swiftui-putting-multiple-bindableobjects-into-environment/56699552#56699552"">SwiftUI: Putting multiple BindableObjects into Envionment</a></p>

<p>the answer said environmentObject(ObservableObject) returns modified view, therefore I can make call chain for multiple environmentObject.</p>

<p>like</p>

<pre class=""lang-swift prettyprint-override""><code>let rootView = ContentView()
     .environmentObject(firstBindable)
     .environmentObject(secondBindable)
</code></pre>

<p>and I wonder what is result if firstBindable and secondBindable are same type. how <code>.environmentObject()</code> knows what is exect value which is a programmer intended to set between <code>firstBindable</code> and <code>secondBindable</code>.</p>

<p>so I tested this</p>

<ol>
<li>I made an ObservableObject class</li>
</ol>

<pre class=""lang-swift prettyprint-override""><code>final class TempStr: ObservableObject {
    @Published var tmpStr = ""temp""

    init(initStr: String) {
        tmpStr = initStr
    }
}
</code></pre>

<ol start=""2"">
<li>made call chain of environmentObject from sceneDelegate</li>
</ol>

<pre><code>window.rootViewController
  = UIHostingController(rootView:
      TestView()
        .environmentObject(TempStr(initStr: ""1st"")) 
        .environmentObject(TempStr(initStr: ""2nd""))
</code></pre>

<ol start=""3"">
<li>and used values from View</li>
</ol>

<pre><code>struct TestView: View {
  @EnvironmentObject var tmp1: TempStr
  @EnvironmentObject var tmp2: TempStr

   var body: some View {
      Text(tmp1.tmpStr + "" "" + tmp2.tmpStr)
   }
}
</code></pre>

<ol start=""4"">
<li>result was '1st 1st'</li>
</ol>

<p>And if my code calls one .environmentObject() like</p>

<pre><code>TestView().environmentObject(TempStr(initStr: ""1st"")) 
</code></pre>

<p>both tmp1 and tmp2 from TestView have same value <code>TempStr(initStr: ""1st"")</code>. it looks like <code>.environmentObject()</code> call sets all values of same type.</p>

<p><br></p>

<p>Actually, I knew that it couldn't work but I just tried it for using this question.</p>

<p>I wonder what is correct way of achieving my goal.</p>

<p>Thanks</p>
","2889247","","","","","2019-08-05 21:59:08","How to set multiple EnvironmentObjects which are same type","<observable><publish><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"57399838","1","57455621","","2019-08-07 17:50:49","","8","1892","<p>I'm trying to wrap my head around Combine.</p>

<p>Here's a method I want to translate into Combine, so that it would return AnyPublisher.</p>

<pre class=""lang-swift prettyprint-override""><code>func getToken(completion: @escaping (Result&lt;String, Error&gt;) -&gt; Void) {
    dispatchQueue.async {
        do {
            if let localEncryptedToken = try self.readTokenFromKeychain() {
                let decryptedToken = try self.tokenCryptoHelper.decrypt(encryptedToken: localEncryptedToken)
                DispatchQueue.main.async {
                    completion(.success(decryptedToken))
                }
            } else {
                self.fetchToken(completion: completion)
            }
        } catch {
            DispatchQueue.main.async {
                completion(.failure(error))
            }
        }
    }
}
</code></pre>

<p>The whole thing executes on a separate dispatch queue because reading from Keychain and decryption can be slow.</p>

<p>My first attempt to embrace Combine</p>

<pre class=""lang-swift prettyprint-override""><code>func getToken() -&gt; AnyPublisher&lt;String, Error&gt; {
    do {
        if let localEncryptedToken = try readTokenFromKeychain() {
            let decryptedToken = try tokenCryptoHelper.decrypt(encryptedToken: localEncryptedToken)
            return Result.success(decryptedToken).publisher.eraseToAnyPublisher()
        } else {
            return fetchToken() // also rewritten to return AnyPublisher&lt;String, Error&gt;
        }
    } catch {
        return Result.failure(error).publisher.eraseToAnyPublisher()
    }
}
</code></pre>

<p>But how would I move reading from Keychain and decryption onto separate queue? It probably should look something like</p>

<pre><code>func getToken() -&gt; AnyPublisher&lt;String, Error&gt; {
    return Future&lt;String, Error&gt; { promise in
        self.dispatchQueue.async {
            do {
                if let localEncryptedToken = try self.readTokenFromKeychain() {
                    let decryptedToken = try self.tokenCryptoHelper.decrypt(encryptedToken: localEncryptedToken)
                    promise(.success(decryptedToken))
                } else {
                    // should I fetchToken().sink here?
                }
            } catch {
                promise(.failure(error))
            }
        }    
    }.eraseToAnyPublisher()
}
</code></pre>

<p>How would I return a publisher from my private method call? (see comment in code)</p>

<p>Are there any prettier solutions?</p>
","4933617","","4933617","","2019-08-07 20:08:16","2019-08-12 04:25:11","Translating async method into Combine","<swift><combine>","2","1","2","","","CC BY-SA 4.0"
"57424157","1","57424336","","2019-08-09 05:55:26","","17","12994","<p>I built a <code>LoadingView</code> with SwiftUI for showing some loading stuff in my app while I'm fetching remote data from an API. I am on Xcode Version 11.0 beta 5.</p>

<p>This is the <code>LoadingView</code>:</p>

<pre><code>struct LoadingView&lt;Content&gt;: View where Content: View {

    @Binding var isShowing: Bool
    var content: () -&gt; Content

    var body: some View {

        GeometryReader { geometry in

            ZStack(alignment: .center) {

                self.content()
                    .disabled(self.isShowing)
                    .blur(radius: self.isShowing ? 3 : 0)

                VStack {
                    Text(""Loading..."")
                    ActivityIndicator(isAnimating: .constant(true), style: .large)
                }
                .frame(width: geometry.size.width / 2,
                       height: geometry.size.height / 5)
                    .background(Color.white)
                    .foregroundColor(Color.primary)
                    .cornerRadius(5)
                    .opacity(self.isShowing ? 1 : 0)
            }
        }
    }
}
</code></pre>

<p>This is my DataStore. It is declared as <code>ObservableObject</code> and has more than one <code>@Published</code> property. Also it does some remote fetching from an API:</p>

<pre><code>class CharacterStore: ObservableObject {

    @Published private(set) var isLoading = false


    // Fetches some stuff from a remote api
    func fetch() {

        self.isLoading = true

        myService.getCharacters { (result) in
            DispatchQueue.main.async {
                self.isLoading = false
            }
        }
    }
}
</code></pre>

<p>And finally this is the View I want to show my <code>LoadingView</code> with the content of <code>ContentView</code> in it. Of course I am setting the <code>@EnvironmentObject</code> before showing this view.</p>

<pre><code>struct ContentView: View {

    @EnvironmentObject var charStore: CharacterStore

    var body: some View {

        LoadingView(isShowing: self.$charStore.isLoading) { // Here I get the error

            // Show some Content here
            Text("""")
        }
    }
}
</code></pre>

<p>The problem is that I want to bind <code>self.$charStore.isLoading</code> to <code>LoadingView</code>. In this line i get the following error:</p>

<blockquote>
  <p>Generic parameter 'Subject' could not be inferred</p>
</blockquote>

<p>I tried in several ways but none of these things work. Btw: If I use a <code>@State</code> property in <code>ContentView</code> it just works fine like this:</p>

<pre><code>struct ContentView: View {

    @EnvironmentObject var charStore: CharacterStore

    @State var loads: Bool = false

    var body: some View {

        LoadingView(isShowing: self.$loads) { // Here I get no error

            // Show some Content here
            Text("""")
        }
    }
}
</code></pre>

<p>Am I missing a thing? If you need further informations let me know i can provide more content if needed.</p>

<p>Thanks for the help!</p>
","5650076","","","","","2019-08-09 11:30:47","SwiftUI: Generic parameter 'Subject' could not be inferred","<swift><swiftui><swift5><combine>","2","0","4","","","CC BY-SA 4.0"
"57428780","1","57458139","","2019-08-09 11:06:09","","5","2260","<p>I want a variable to be an EnvironmentObject and I also want it to be persisted, so that it's the same every time that I relaunch my app. </p>

<p>To achieve that, I have already created the following propertyWrapper: </p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation

@propertyWrapper
struct UserDefault&lt;T: Codable&gt; {
    let key: String
    let defaultValue: T

    var wrappedValue: T {
        get {
            if let encodedValue = UserDefaults.standard.object(forKey: key) as? Data {
                let decoder = JSONDecoder()
                let decodedValue = try! decoder.decode(T.self, from: encodedValue)
                return decodedValue
            } else {
                return defaultValue
            }
        } set {
            let encoder = JSONEncoder()
            let encodedValue = try! encoder.encode(newValue)
            UserDefaults.standard.set(encodedValue, forKey: key)
        }
    }
}
</code></pre>

<p>But already having a property wrapper means that I can't use the @Published property wrapper from Combine. (Using two property wrappers on one variable doesn't sound like a good idea, and I haven't found a way to get that working.)</p>

<p>I solved that problem by making a custom <code>objectWillChange</code> let constant and calling its <code>.send(input:)</code> method in willSet for every variable. </p>

<p>So this is my DataStore class:</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

final class DataStore: ObservableObject {
    let objectWillChange = PassthroughSubject&lt;DataStore, Never&gt;()

    @UserDefault(key: ""the text"", defaultValue: ""Hello world!"")
    var text: String {
        willSet {
            objectWillChange.send(self)
        }
    }
}
</code></pre>

<p>And this is my View:</p>

<pre class=""lang-swift prettyprint-override""><code>struct StartView : View {
    @EnvironmentObject var dataStore: DataStore
    var body: some View {
        VStack {
            TextField(""Enter text"", text: $dataStore.text)
            Button(""Reset text"", action: {
                self.dataStore.text = ""Hello World!""
            })
        }
    }
}
</code></pre>

<p>But somehow I really believe that there should be a more beautiful way than making a custom objectWillChange. Is there a way to make a single property wrapper that covers both the persisting and the ""publishing""? Or should I do something completely different, to reach my goal?</p>

<p>Thanks!</p>
","11432719","","","","","2019-09-17 22:03:39","SwiftUI: How to persist an @EnvironmentObject variable?","<swift><swiftui>","2","0","1","","","CC BY-SA 4.0"
"57446192","1","57451252","","2019-08-10 22:45:46","","1","801","<p>Just getting to grips with Combine and have come across an issue where I need to call a method in my class when it receives a value from a <code>Publisher</code>, in this case a <code>Notification</code> from <code>NotificationCenter</code>...</p>

<p>Here's the subscription...</p>

<pre><code>let subscribe = NotificationCenter.default.publisher(for: Notification.Name(rawValue: ""LocalTalkNotificationReceivedData""), object: nil)
    .map( {
        ($0.object as! Data)
    } )
    .sink(receiveValue: {
        self.interpretIncoming(data: $0)
    })
</code></pre>

<p>What I get told by the compiler is <code>Use of unresolved identifier 'self'</code>.
It's late, I'm kinda tired, anyone got an idea?
Xcode 11 beta 5 on Catalina beta 5 btw...</p>

<p>Complete file:</p>

<pre><code>import Foundation
import Combine
import SwiftUI

public class MessageData: ObservableObject, Identifiable {
public var peerData: [Peer] = [Peer]()
public var messageData: [Message] = [Message]()
public var objectWillChange = PassthroughSubject&lt;Void, Never&gt;()
let subscribe = NotificationCenter.default.publisher(for: Notification.Name(rawValue: ""LocalTalkNotificationReceivedData""), object: nil)
    .map( {
        ($0.object as! Data)
    } )
    .sink(receiveValue: {
        self.interpretIncoming(data: $0)
    })

init() {
    self.setupDummyData()
}

private func setupDummyData() {
    self.peerData = self.load(""peerData.json"")
    self.messageData = self.load(""messageData.json"")
}

func addMessage(message: String, sender: MessageSource, name: String) {
    let newMessage = Message(id: Date().hashValue,
                             content: message,
                             source: sender,
                             correspondent: name)
    self.messageData.append(newMessage)
    self.objectWillChange.send()
}

func load&lt;T: Decodable&gt;(_ filename: String, as type: T.Type = T.self) -&gt; T {
    let data: Data

    guard let file = Bundle.main.url(forResource: filename, withExtension: nil)
        else {
            fatalError(""Couldn't find \(filename) in main bundle."")
    }

    do {
        data = try Data(contentsOf: file)
    } catch {
        fatalError(""Couldn't load \(filename) from main bundle:\n\(error)"")
    }

    do {
        let decoder = JSONDecoder()
        return try decoder.decode(T.self, from: data)
    } catch {
        fatalError(""Couldn't parse \(filename) as \(T.self):\n\(error)"")
    }
}

func interpretIncoming(data sent: Data) {
    do {
        let receivedTransmission = try NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(sent) as! [String: Any]
        self.addMessage(message: receivedTransmission[""messagePayload""] as! String,
                        sender: .them,
                        name: receivedTransmission[""messageSender""] as! String)
    } catch {
        print(""FAILED DECODING THING"")
    }
}
</code></pre>

<p>}</p>
","417085","","417085","","2019-08-10 23:01:46","2019-08-11 15:24:11","How to reference self in a Subscriber in Combine in Swift","<swift><nsnotificationcenter><publisher><subscriber><combine>","2","2","","","","CC BY-SA 4.0"
"57455076","1","57463089","","2019-08-12 02:33:48","","6","3711","<p>I want to get data from REST API and in order to do that, I need to first get an array of IDs - 1st call. After that, I need to do an API call using each ID. I don't want to use completionHandlers but Combine. I started with dataTaskPublishers but I am not sure how can I chain them to work properly 🤔</p>

<p>Here is my code so far:</p>

<pre class=""lang-swift prettyprint-override""><code>   private func getIDs(for type: DataType) -&gt; AnyPublisher&lt;[ID], Error&gt; {
        guard let url = URL(string: ""url"")
            else { fatalError(""Wrong URL"") }

        return session.dataTaskPublisher(for: url)
            .receive(on: RunLoop.main)
            .map { $0.data }
            .decode(type: [ID].self, decoder: decoder)
            .eraseToAnyPublisher()
    }

    private func getData(with id: ID) -&gt; AnyPublisher&lt;MyData, Error&gt; {
        guard let url = URL(string: ""url_with_id"")
            else { fatalError(""Wrong URL"") }
        return session.dataTaskPublisher(for: url)
            .receive(on: RunLoop.main)
            .map { $0.data }
            .decode(type: MyData.self, decoder: decoder)
            .eraseToAnyPublisher()
    }
</code></pre>

<p>I am not really sure how can I connect them to get something that is assignable to my state variable - array of MyData.</p>
","7482031","","","","","2020-04-13 22:05:44","How to chain multiple API calls using dataTaskPublisher?","<ios><swift><swiftui><combine>","1","1","1","","","CC BY-SA 4.0"
"57478134","1","57479187","","2019-08-13 12:52:14","","14","8439","<p>I'm trying to learn Combine with SwiftUI and I'm struggling how to update my view (from UIKit) with <code>ObservableObject</code> (previously <code>BindableObject</code>). The issue is that, obviously, method <code>updateUIView</code> will not fire once the <code>@Published</code> object sends the notification it was changed.</p>

<pre><code>class DataSource: ObservableObject {
    @Published var locationCoordinates = [CLLocationCoordinate2D]()
    var value: Int = 0

    init() {
        Timer.scheduledTimer(withTimeInterval: 3, repeats: true) { timer in
            self.value += 1
            self.locationCoordinates.append(CLLocationCoordinate2D(latitude: 52, longitude: 16+0.1*Double(self.value)))
        }
    }
}

struct MyView: UIViewRepresentable {
    @ObservedObject var dataSource = DataSource()

    func makeUIView(context: Context) -&gt; MKMapView {
        MKMapView(frame: .zero)
    }

    func updateUIView(_ view: MKMapView, context: Context) {
        let newestCoordinate = dataSource.locationCoordinates.last ?? CLLocationCoordinate2D(latitude: 52, longitude: 16)
        let annotation = MKPointAnnotation()
        annotation.coordinate = newestCoordinate
        annotation.title = ""Test #\(dataSource.value)""
        view.addAnnotation(annotation)
    }
}
</code></pre>

<p>How to bind that <code>locationCoordinates</code> array to the view in such a way, that a new point is in fact added each time it refreshes?</p>
","849616","","","","","2021-11-27 12:34:04","How to update UIViewRepresentable with ObservableObject","<swift><uikit><mapkit><swiftui><combine>","3","1","","","","CC BY-SA 4.0"
"57481380","1","57598143","","2019-08-13 15:53:51","","0","174","<p>I am trying to run a simple project with the following:</p>

<p><code>@Published var currentPlacemark: CLPlacemark? = nil</code></p>

<ul>
<li>XCode11 Beta5(11M382q)</li>
<li>iOS13(17A5556d)</li>
</ul>

<p>Getting the following error:
<code>dyld: Symbol not found: _$s7Combine9PublishedV9PublisherCyx_GAadAM</code></p>

<p>Anyone else encountered this?</p>

<p>Code example:</p>

<pre><code>import SwiftUI
import Combine

class MyFoo {
  @Published var bar: String = """"
}

struct ContentView: View {
    var body: some View {
        Text(""Hello World"")
    }
}

#if DEBUG
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        let foo = MyFoo()
      foo.bar = ""asas""
        let barSink = foo.$bar
            .sink() {
                print(""bar value: \($0)"")
        }
        return ContentView()
    }
}
#endif
</code></pre>
","8323518","","1000551","","2019-12-07 10:01:02","2019-12-07 10:01:02","Combine @Published could not be found - Xcode11 Beta 5(11M382q)","<ios><swift><xcode><ios13><combine>","1","9","","","","CC BY-SA 4.0"
"57488322","1","57488466","","2019-08-14 04:49:48","","1","2886","<p>I would like to conditionally display different views in my application - if a certain boolean is true, one view will be displayed. If it is false, a different view will be displayed. This boolean is within an ObservableObject class, and is changed from one of the views that will be displayed.</p>

<p><strong>PracticeStatus.swift (the parent view)</strong></p>

<pre><code>import Foundation
import SwiftUI
import Combine

class PracticeStatus: ObservableObject  {
    @Published var showResults:Bool = false
}
</code></pre>

<p><strong>PracticeView.swift (the parent view)</strong></p>

<pre><code>struct PracticeView: View {
    @EnvironmentObject var practiceStatus: PracticeStatus

    var body: some View {
        VStack {
            if practiceStatus.showResults {
                ResultView()
            } else {
                QuestionView().environmentObject(PracticeStatus())
            }
        }
    }
}
</code></pre>

<p><strong>QuestionView.swift</strong></p>

<pre><code>struct QuestionView: View {
    @EnvironmentObject var practiceStatus: PracticeStatus

    var body: some View {
        VStack {
            ...
            Button(action: {
                self.practiceStatus.showResults = true
            }) { ... }
            ...
        }
    }
}
</code></pre>

<p>However, this code doesn't work. When the button within <code>QuestionView</code> is pressed, ResultView is not displayed. Does anybody have a solution? Thanks!</p>
","6510011","","6510011","","2019-08-14 05:26:09","2019-08-14 06:04:15","SwiftUI - Using 'ObservableObject' and @EnvironmentObject to Conditionally Display View","<swift><class><struct><observable><swiftui>","1","0","","","","CC BY-SA 4.0"
"57513437","1","57598001","","2019-08-15 17:05:58","","0","284","<p>I'm using Xcode 11 Beta 5 (11M382q), and iphone x with iOS 13 beta 6 and I am having this runtime error when trying to use Combine:</p>

<blockquote>
  <p>dyld: Symbol not found: _$s7Combine9PublishedV9PublisherCyx_GAadAMc</p>
</blockquote>

<p>I have a Core class that is an <code>ObservableObject</code></p>

<pre><code>import SwiftUI
import Combine

open class Core: ObservableObject {
    @Published public var userId = """"

    public var isUserValid: AnyPublisher&lt;Bool, Never&gt; {
    return $userId.debounce(for: 0.5, scheduler: RunLoop.main).removeDuplicates().map { (user: String) in
      return user.isEmpty
    }.eraseToAnyPublisher()
  }
}
</code></pre>

<p>And a simple view</p>

<pre><code>import SwiftUI
import Combine

struct LoginView: View {
    @EnvironmentObject var core: Core
    @State var isLoading: Bool = false
    @State var submitButtonEnabled: Bool = false

    var body: some View {
        VStack {
            VStack(alignment: .center) {
                Image(""logo"")
                    .frame(minWidth: Constants.logoWidth, minHeight: Constants.logoHeight, alignment: .center)
                    .padding(.top, Constants.logoTopPadding)
                    .animation(.default)
                    .scaledToFit()
             }
        }

        CircularButton(isLoading: $isLoading, image: Constants.submitButtonArrowImageName) {
            // Button Action
        }
        .padding(.top, Constants.submitButtonTopPadding)
        .disabled($submitButtonEnabled.value)
        .onReceive(self.core.isUserValid) { value in
          self.submitButtonEnabled = value
        }
    }
}
</code></pre>

<p>What's wrong with my code? I Just want a MVVM architecture using reactive programming to disable or enable a button.</p>
","4687709","","13302","","2019-08-19 13:20:49","2019-08-21 19:20:33","Runtime error using Combine: dyld: Symbol not found: _$s7Combine9PublishedV9PublisherCyx_GAadAMc","<swift><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"57527036","1","57527346","","2019-08-16 15:09:25","","-2","607","<p>Can someone please break this code example down for me? <code>zip</code> and <code>reduce</code> makes some sense, but what's going on with <code>combine:</code> is confusing me. Any help would be greatly appreciated.</p>

<pre><code>let a = [5, 6, 7]
let b = [3, 6, 10]

let pointsAlice = zip(a, b).reduce(0, combine: { $0 + ($1.0 &gt; $1.1 ? 1 : 0) } )
let pointsBob = zip(b, a).reduce(0, combine: { $0 + ($1.0 &gt; $1.1 ? 1 : 0) } )

print(""\(pointsAlice) \(pointsBob)"") // 1 1
</code></pre>
","8729720","","1630618","","2019-08-16 15:12:46","2019-08-16 16:23:51","Explanation of zip, reduce and combine in Swift","<swift><zip><reduce><combine>","1","0","","","","CC BY-SA 4.0"
"57532976","1","57533298","","2019-08-17 03:09:34","","0","1966","<p>Please forgive me for my lack of knowledge, I'm trying to make my first iOS App, and my goal is to import all of my contacts into a swiftui view: </p>

<pre><code>//ContentView.swift
import SwiftUI

struct ContentView: View {
    var contact = contactData
    @ObservedObject var contacts = ContactList()

    var body: some View {
        NavigationView {
            List {
                ForEach(contact) { item in
                    VStack(alignment: .leading) {
                        HStack {
                            Text(item.contactName)
                        }
                    }
                }
                .onDelete { index in
                    self.contacts.contact.remove(at: index.first!)
                }
            }
            .navigationBarTitle(Text(""Contacts""))
            .navigationBarItems(
                trailing: EditButton()
            )
        }
    }
}

#if DEBUG
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
#endif

struct Contacts: Identifiable {
    var id = UUID()
    var contactName: String
}

let contactData = [
    Contacts(contactName: ""Foo Bar""),
    Contacts(contactName: ""Johnny Appleseed"")
]
</code></pre>

<p>and</p>

<pre><code>//ContactList.swift
import Combine

class ContactList: ObservableObject {
    @Published var contact: [Contacts] = contactData
}
</code></pre>

<p>Using the Combine API and the <code>.onDelete</code> function, I would like to delete multiple contacts (currently not a feature in iOS), then return them back into the contacts app.</p>

<p>I'm stuck though at pulling in the contact list, and I've tried multiple different ways of doing this with Swift like: <a href=""https://stackoverflow.com/questions/33973574/fetching-all-contacts-in-ios-swift"">Fetching all contacts in iOS Swift?</a></p>

<pre><code>var contacts = [CNContact]()
let keys = [CNContactFormatter.descriptorForRequiredKeysForStyle(.FullName)]
let request = CNContactFetchRequest(keysToFetch: keys)

do {
    try self.contactStore.enumerateContactsWithFetchRequest(request) {             
        (contact, stop) in
        // Array containing all unified contacts from everywhere
        contacts.append(contact)
    }
} 
catch {
    print(""unable to fetch contacts"")
}
</code></pre>

<p>But that hasn't seemed to work properly without throwing a bunch of errors. I'm not so worried about deletion at the moment, but more primarily focused on just importing the contacts.</p>

<p>Does anyone know if there's a good way to do this using SwiftUI and the Contacts API? or can at least point me in the right direction? I understand I am on a Xcode 11 Beta 5, which may cause problems with deprecation of different API's, but it seems that the Contact API has been relatively unchanged in Xcode 11.</p>
","2763130","","","","","2019-08-17 04:44:57","Allowing SwiftUI to import all Contacts and delete specific ones","<ios><swift><swiftui>","1","1","1","","","CC BY-SA 4.0"
"57538560","1","57538931","","2019-08-17 17:38:36","","2","263","<p>I am trying to make a navigation UI similar to the Slack app where I have the Home Screen which Overlays the Menu Navigation screen. I created a ViewModifier which makes the Home Screen Draggable. Now I need to add functionality such that when the ""Home"" is tapped on the blue Menu screen, the white Home View animates back to the center. My idea was to keep track of the NavigationState in a global AppState:</p>

<pre><code>enum NavigationSelection {
  case menu
  case home
}

final class AppState: ObservableObject {
  let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()
  @Published var currentNavigationSelection: NavigationSelection = .home 
}
</code></pre>

<p>Then when the user taps ""Home"", have it update the AppState's currentNavigationSelection, and have the Draggable view determine its offset based on the currentNavigationSelection. I'm really not sure about this approach and I'm having a tough time thinking about it in the new SwiftUI style. Any suggestions would be much appreciated.</p>

<p><a href=""https://i.stack.imgur.com/XALx1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/XALx1.png"" alt=""enter image description here""></a></p>

<p>The view hierarchy looks like this:</p>

<pre><code> var body: some View {
    ZStack {
        Menu()
        HomeTabView()
    }
}
</code></pre>

<p>And the HomeTabView has a draggable ViewModifier applied: </p>

<pre><code>struct Slidable: ViewModifier {

  @EnvironmentObject var app: AppState

  @State private var viewState = SlidableViewDragState.normal.defaultPosition
  @State private var currentPosition: SlidableViewDragState = .normal {
    didSet {
        self.viewState = self.currentPosition.defaultPosition
    }
  }

  func body(content: Content) -&gt; some View {
    return content
        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight:
        .infinity, alignment: Alignment.topLeading)
        .offset(self.viewState)
        .animation(.interactiveSpring())
    .gesture(
        DragGesture()
            .onChanged({ (value) in
                self.viewState = self.currentPosition.applyXTranslation(x: value.translation.width)
            })
            .onEnded({ (value) in
                if value.translation.width &lt; 0 &amp;&amp; self.currentPosition == .normal {
                    return
                }
                if abs(value.translation.width) &gt; self.currentPosition.switchThreshold {
                    self.currentPosition = self.currentPosition.oppositePosition
                    if self.currentPosition == .menuVisible {
                        self.app.currentNavigationSelection = .menu
                    }
                } else {
                    self.viewState = self.currentPosition.defaultPosition
                }
            })
    )
  }
}
</code></pre>
","2066353","","2066353","","2019-08-17 19:26:27","2019-08-18 06:57:46","SwiftUI Navigation similar to Slack","<swift><swiftui>","1","1","2","","","CC BY-SA 4.0"
"57543855","1","57597385","","2019-08-18 10:55:08","","34","11571","<p>I have such code</p>

<pre><code>func request(request: URLRequest) -&gt; AnyPublisher&lt;Data, Error&gt; {
    return Just(request)
        .flatMap { request in
            RequestManager.request(request) // returns AnyPublisher&lt;Data, Error&gt;
    }
    .eraseToAnyPublisher()
}
</code></pre>

<p>and I'm getting compile error:</p>

<blockquote>
  <p>Instance method flatMap(maxPublishers:_:) requires the types
  Just.Failure (aka Never) and Error be equivalent</p>
</blockquote>

<p>And it's clear, because <code>Just</code> has <code>Never</code> as <code>Failure</code> and <code>.flatMap</code> requires  <code>Error</code> as <code>Failure</code>, so <code>Never</code> != <code>Error</code></p>

<p>I see 2 approaches:</p>

<ul>
<li><p>using <em>right</em> Publisher, instead of <code>Just</code>, but I didn't find good candidate for this.</p></li>
<li><p>using some operator like <code>.mapError</code>, <code>.mapError { $0 as Error }</code>, but I'm not sure that it's great idea.</p></li>
</ul>

<p>Any ideas how to handle it?</p>

<p><strong>UPDATE:</strong></p>

<p>it makes more sense to use</p>

<pre><code>.setFailureType(to: Error.self)
</code></pre>

<p>or </p>

<pre><code>.mapError { $0 as Error }
</code></pre>
","3785970","","3785970","","2019-08-22 08:06:12","2020-09-22 18:06:51","Using Just with flatMap produce Failure mismatch. Combine","<swift><combine>","3","0","3","","","CC BY-SA 4.0"
"57544230","1","57544688","","2019-08-18 11:45:48","","0","239","<p>I want to use code such as the following: </p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine
import SwiftUI

final class DataStore: ObservableObject {
    @Published var bools: [Bool] = [true, false]
}

struct ContentView: View {
    @EnvironmentObject var dataStore: DataStore
    var body: some View {
        HStack {
            Spacer()
            Toggle(isOn: $dataStore.bools[0]) {
                Text(dataStore.bools[0] ? ""On"" : ""Off"")
            }
            Spacer()
            Toggle(isOn: $dataStore.bools[1]) {
                Text(dataStore.bools[1] ? ""On"" : ""Off"")
            }
            Spacer()
        }
    }
}
</code></pre>

<p>(Actually this code is quite useless, but it's just about that I want to pass an element of an array as a binding to a subview.)</p>

<p>In Xcode beta 2 this worked, but since beta 5 I get the following warning on both the ""Toggle"" lines:</p>

<blockquote>
  <p>'subscript(_:)' is deprecated: See Release Notes for migration path.
  And the app crashes when I try to launch it. </p>
</blockquote>

<p>Indeed, I have read the <a href=""https://developer.apple.com/documentation/ios_ipados_release_notes/ios_ipados_13_beta_7_release_notes"" rel=""nofollow noreferrer"">release notes</a>, and I believe that the issue has something to do with that ""the Binding structure’s conditional conformance to the Collection protocol is removed"".<br>
The problem is that I don't understand how to use the sample code that they give with the code that I want to use. Can someone help me with that?</p>
","11432719","","1226963","","2019-08-18 13:56:06","2019-08-20 04:51:46","Xcode 11 beta 5: "" 'subscript(_:)' is deprecated: See Release Notes for migration path. ""","<swift><swiftui>","2","1","","","","CC BY-SA 4.0"
"57564070","1","57568597","","2019-08-19 21:17:39","","1","201","<p>I have some <code>TextField(s)</code> with “.text” values that are supposed to be populated by a method called within “<strong>init()</strong>” (can be moved) that asynchronously calls a completion handler with a <code>struct</code> of data from the network.</p>

<p>The thing is... the user can also <strong>begin typing into them manually</strong> in the meantime and the completion callback <strong>shouldn’t overwrite the manually edited values</strong>.</p>

<p>I’m not sure how to:</p>

<ol>
<li>Update the values of the <code>@State String</code> variables to replace the existing values only if they haven’t been modified by the user yet... while <strong>also</strong> having them be mutable by the end-user.</li>
<li>Update N number of the <code>@State</code> values from the same request at once. One request is used to pull <strong>all</strong> of the data in, so mapping into a single value while having it be mutable as noted above is a head scratcher at the moment.</li>
</ol>

<p>It seems like a job for Combine, just not sure where to start yet.</p>
","963901","","","","","2019-08-20 07:25:33","Asynchronously populate/pre-fill multiple, user mutable `@State` values when using SwiftUI?","<swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"57579380","1","57579475","","2019-08-20 18:10:25","","1","174","<p>In order to make my code testable, I'm trying to adhere to <a href=""https://en.wikipedia.org/wiki/Liskov_substitution_principle"" rel=""nofollow noreferrer"">Liskov's substitution principle</a> by having my SwiftUI views depend on protocols rather than concrete types. This allows me to easily swap implementations and allows me to easily build mocks for testing. Here's an example of what I'm trying to do:</p>

<pre class=""lang-swift prettyprint-override""><code>protocol DashboardViewModel: ObservableObject {

  var orders: [Order] { get }
}
</code></pre>

<p>My <code>DashboardViewModel</code> needs to communicate changes back to its dependents, so I've also attached <code>ObservableObject</code> as a transitive requirement.</p>

<p>This seems to be a problem. You <strong>cannot</strong> achieve LSP if you have associated type requirements. Here's the error I got from my SwiftUI view class that depended on my view model:</p>

<pre class=""lang-swift prettyprint-override""><code>struct DashboardView: View {
  @ObservedObject var viewModel: DashboardViewModel
}
</code></pre>

<blockquote>
  <p>Protocol 'DatastoreProtocol' can only be used as a generic constraint because it has Self or associated type requirements</p>
</blockquote>

<p>I ended up doing this instead:</p>

<pre class=""lang-swift prettyprint-override""><code>protocol DashboardViewModel {

  var orders: [Order] { get }
  var objectWillChange: AnyPublisher&lt;Void, Never&gt; { get }
}
</code></pre>

<p>This also requires dependents to do additional work to observe for state changes. This takes away the conveniences of using property wrappers - mainly the ability for dependents to observe for state changes using <code>@ObservedObject</code>. Using this alternative leads us to code like this:</p>

<pre class=""lang-swift prettyprint-override""><code>struct DashboardView: View {
  let viewModel: DashboardViewModel

  var viewModelSubscriber: AnyCancellable!

  // MARK: - Used only to force a re-render of this view
  @State private var reload = false

  init(viewModel: DashboardViewModel) {
    self.viewModel = viewModel
    viewModelSubscriber = viewModel.objectWillChange.sink { _ in
      self.reload.toggle()
    } 
  }    
}
</code></pre>

<p>This is a tad distasteful to look at:</p>

<ol>
<li><p>Created a <code>@State</code> variable that is only used to force an update of the view, because we cannot utilize SwiftUI property wrappers to observe for state changes</p></li>
<li><p>Created a <code>AnyCancellable!</code> variable to hold a subscription to <code>objectWillChange</code> from the view model. This is necessary to detect state changes from the <code>DashboardViewModel</code></p></li>
<li><p>Added the subscription call in the initializer that only toggles the <code>@State</code> variable to force a retrieval of new data from the view model</p></li>
</ol>

<p>I feel like there should be a much better way of handling this. Looking for help!</p>
","4211945","","","","","2019-08-20 18:18:54","LSP and SwiftUI","<swift><swiftui>","1","1","","","","CC BY-SA 4.0"
"57580748","1","57581319","","2019-08-20 19:57:05","","2","1379","<p>Since updating to Xcode Beta 6 earlier today my application will no longer build, it was working fine in Beta 5 and earlier.</p>

<p>This is the code from the file with the error message, although I'm aware at the moment this doesn't necessarily mean this is where the error actually lies.</p>

<pre><code>import SwiftUI

struct JobView_Table : View {

    @ObservedObject var jobList: JobDetailViewModel = JobDetailViewModel()

    var body: some View {

        NavigationView {

            List {
                ForEach($jobList.jobDetails) { job in
                    NavigationLink(destination: JobDetailHost(jobDetails: job)) { // ERROR: ""Type of expression is ambiguous without more context""
                        JobView_List(jobDetails: job)
                    }
                }
            }

            .navigationBarTitle(Text(""My Jobs""))
            .onAppear(perform: fetchData)
            .onAppear(perform: {
                print(""Hello!"")
            })

        }
    }

    private func fetchData() {
        return(jobList.updateDetails())
    }
}

</code></pre>

<p>The struct containing the data conforms correctly to the following protocols.</p>

<pre><code>struct JobDetails: Codable, Identifiable, Equatable, Hashable { 
    ...

    ...
}
</code></pre>

<p>This is the class which provides the data to <code>JobView_Table</code>.</p>

<pre><code>import Foundation
import UIKit
import Combine

class JobDetailViewModel: ObservableObject, Identifiable {

    @Published var jobDetails: [JobDetails] = []

    func updateDetails() {
        self.jobDetails = DataManager().fetchJobList()
    }

}
</code></pre>

<p>And finally the target view which is linked to via the <code>NavigationLink</code>.</p>

<pre><code>struct JobDetailHost: View {

    @Environment(\.editMode) var mode
    @Binding var jobDetails: JobDetails


    var body: some View {

        VStack {
            JobDetailView(jobDetails: jobDetails)
        }
        .navigationBarItems(trailing: EditButton())
    }

}
</code></pre>

<p>I notice that some others seem to be having similar problems, i.e. in the two questions listed below, but exploring the answers in these questions is not helping me at this moment.
<a href=""https://stackoverflow.com/questions/57568662/swiftui-xcode-11-beta-5-6-type-of-expression-is-ambiguous-without-more-contex"">SwiftUI Xcode 11 beta 5 / 6: Type of expression is ambiguous without more context</a></p>

<p><a href=""https://stackoverflow.com/questions/57569554/swiftui-why-does-foreachstrings-text-bindingstring-not-build?noredirect=1&amp;lq=1"">SwiftUI: Why does ForEach($strings) (text: Binding) not build?</a></p>

<p><strong>EDIT:</strong></p>

<p>I have tried implementing the suggestion from Fabian, this has got rid of the error, however no content is being populated in the list. </p>

<p>This is the adjusted <code>List</code> code, which compiles successfully but when running the application the list is not populated.</p>

<pre><code>List {
    ForEach(jobList.jobDetails.indexed(), id: \.1.id) { (index, job) in
            NavigationLink(destination: JobDetailHost(jobDetails: self.$jobList.jobDetails[index])) {
                        Text(job.jobName)
                    }
     }
}
</code></pre>

<p>The following does not use the <code>ForEach</code> and discards the <code>NavigationLink</code>, and still doesn't work.</p>

<pre><code>List(jobList.jobDetails.indexed(), id: \.1.id) { (index, job) in
                Text(job.jobName)
            }
</code></pre>
","11826694","","1265393","","2019-08-22 03:56:23","2019-08-22 21:28:50","Xcode Beta 6 ""Type of expression is ambiguous without more context"" navigationlink","<swift><xcode><swiftui>","1","0","3","","","CC BY-SA 4.0"
"57582568","1","58357504","","2019-08-20 23:09:54","","1","1908","<p>In a operator chain like this you used to be able to return Publishers.Just(defaultValue) but it is deprecated and I can't find a way to do this functionality anymore. What is the new way to return a defaultValue?</p>

<pre><code> $query
    .throttle(for: 0.5, scheduler: DispatchQueue.main, latest: true)
    .removeDuplicates()
    .map { query -&gt; AnyPublisher&lt;[Repo], Never&gt; in
       guard query.count &gt;= 3 else {
          return Publishers.Just([])
                   .eraseToAnyPublisher()
          }
          return API().search(with: query)
               .retry(3)
               .eraseToAnyPublisher()
          }
</code></pre>
","2066353","","","","","2019-10-12 19:00:37","iOS combine Publishers.Just deprecated","<swift><swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"57585359","1","57585649","","2019-08-21 06:06:10","","3","1091","<p>I'm attempting to dismiss a modal after its intended action is completed, but I have no idea how this can be currently done in SwiftUI. This modal is triggered by a <code>@State</code> value change. Would it be possible to change this value by observing a notification of sorts?</p>

<p>Desired actions: Root -> Initial Modal -> Presents Children -> Dismiss modal from any child</p>

<p>Below is what I've tried</p>

<p>Error: <strong>Escaping closure captures mutating 'self' parameter</strong></p>

<pre><code>struct AContentView: View {
    @State var pageSaveInProgress: Bool = false

    init(pages: [Page] = []) { 
    // Observe change to notify of completed action
        NotificationCenter.default.publisher(for: .didCompletePageSave).sink { (pageSaveInProgress) in
            self.pageSaveInProgress = false
        }
    }

    var body: some View {
        VStack {
        //ETC
            .sheet(isPresented: $pageSaveInProgress) {
                    ModalWithChildren()
            }
        }
    }
}
</code></pre>

<p>ModalWithChildren test action</p>

<pre><code>
Button(action: {
    NotificationCenter.default.post(
        name: .didCompletePageSave, object: nil)}, 
        label: { Text(""Close"") })
</code></pre>
","5222077","","5540925","","2020-02-14 16:40:53","2020-02-14 16:40:53","SwiftUI : Dismiss modal from child view","<ios><swift><uiview><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"57610220","1","57618193","","2019-08-22 13:13:55","","1","2463","<p>I am trying to use Core Location to get the CLRegionState to update elements in a SwiftUI app.  I am using XCode 11 beta 6 and have iOS 13 beta 7 on my device.</p>
<p>There are two problems that I can see:</p>
<ol>
<li><p>The app crashes and the error <code>Thread 1: EXC_BAD_ACCESS</code> appears on line <code>147</code> (...ScrollView {... )</p>
</li>
<li><p>The CLRegionState is never called or does not update.</p>
</li>
</ol>
<p>I am basing this off of Paul Hudson's tutorial on SwiftUI Beacon Detector (which I have not been able to make work either), and modifying it to use CLRegionState instead of beacon proximity .</p>
<p>Here is the code:</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import CoreLocation
import Combine

class MYLocationManager: NSObject, ObservableObject, CLLocationManagerDelegate {
      
  var locationManager: CLLocationManager?
  var willChange = PassthroughSubject&lt;Void, Never&gt;()
  var lastRegionState = CLRegionState.unknown
        
  override init() {
    super.init()
    locationManager = CLLocationManager()
    locationManager?.delegate = self
    locationManager?.requestWhenInUseAuthorization()
  }
        
  func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
    checkLocationAuthorization()
  }
        
  func update(state: CLRegionState) {
    lastRegionState = state
    willChange.send(())
  }
        
  func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    guard let location = locations.last else { return }

    print(&quot;Your location is \(location)&quot;)
    update(state: .unknown)
  }
        
  func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
    print(error)
  }
        
  func startScanning() {         
    // temporary coordinates
    var workCoordinates: CLLocationCoordinate2D {
      return CLLocationCoordinate2D(
        latitude: 43.486525,
        longitude: -11.912542)
    }
            
    var homeCoordinates = CLLocationCoordinate2D(
                                  latitude: 43.499541,
                                  longitude: -11.875079)
            
    let workRegion: CLCircularRegion = CLCircularRegion(center: workCoordinates, radius: 100, identifier: &quot;Work&quot;)
            
    let homeRegion: CLCircularRegion = CLCircularRegion(center: homeCoordinates, radius: 100, identifier: &quot;Home&quot;)
            
    locationManager!.startMonitoring(for: workRegion)
    locationManager!.startMonitoring(for: homeRegion)
    locationManager!.requestState(for: workRegion)
    locationManager!.requestState(for: homeRegion)
  }
        
  func locationManager(_ manager: CLLocationManager, didDetermineState state: CLRegionState, for region: CLRegion) {
    switch state {
      case .inside:
        switch region.identifier {
      case &quot;Work&quot;:
        print(&quot;You are at work&quot;)
      case &quot;Home&quot;:
        print(&quot;You are at home&quot;)
      default:
        print(&quot;unknown&quot;)
    }
      default:
      break
    }
  }
        
  func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {       
    switch region.identifier {
      case &quot;Work&quot;:
        print(&quot;Work**********&quot;)
        //self.taskTypeSegCtrl.selectedSegmentIndex = 0
      case &quot;Home&quot;:
        print(&quot;Home*********8&quot;)
        //self.taskTypeSegCtrl.selectedSegmentIndex = 1
      default:
        break
    }
  }
        
  func checkLocationAuthorization() {
    switch CLLocationManager.authorizationStatus() {
      case .authorizedWhenInUse:
        startScanning()
        break
      case .authorizedAlways:
        startScanning()
        break
      case .denied:
        // show an alert instructing them howto turn on permissions
        break
      case .notDetermined:        
        print(&quot;Location authorization is not determined.&quot;)
        locationManager!.requestAlwaysAuthorization()
        break
      case .restricted:
        break
      @unknown default:
        fatalError()
    }
  }
}


struct ContentView: View {
  @Environment(\.managedObjectContext) var managedObjectContext
        
  @FetchRequest(entity: Task.entity(),
                      sortDescriptors: [NSSortDescriptor(
                        keyPath: \Task.name, ascending: true)])
  var tasks: FetchedResults&lt;Task&gt;
        
  var locationManager = CLLocationManager()
        
  @ObservedObject var location: MYLocationManager = MYLocationManager()
        
  @State private var taskName = &quot;&quot;
  @State private var taskType = 0
  @State private var selectedTask = &quot;&quot;
  @State private var numberOfTaps = 0
  @State private var regionState = CLRegionState.unknown
        
  var body: some View {
            
    ScrollView {
      VStack {
        TextField(&quot;Enter a task name&quot;, text: $taskName)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                    Picker(selection: $taskType, label: Text(&quot;Task type&quot;)) {
                        Text(&quot;Work&quot;).tag(1)
                        Text(&quot;Home&quot;).tag(2)
                    }.pickerStyle(SegmentedPickerStyle())
                    
        Text(selectedTask)
                    
        Button(action: {
          let task = Task(context: self.managedObjectContext)
          task.name = self.taskName
          task.type = Int16(self.taskType)
           do {
             try self.managedObjectContext.save()
          } catch {
            // handle the Core Data error
          }
           self.taskName = &quot;&quot;
        }) {
            Text(&quot;Save Task&quot;)
        }.padding()
                    
         Button(action: {
             if self.numberOfTaps &lt; self.tasks.count {
               let task = self.tasks[self.numberOfTaps].name
               self.selectedTask = task ?? &quot;No task...&quot;
               self.numberOfTaps = self.numberOfTaps + 1
            } else {
               self.selectedTask = &quot;No more tasks!  Have a wonderful day.&quot;
            }
          }) {
            Text(&quot;Next Task&quot;)
          }
                    
          List {
            ForEach(tasks, id: \.self) { task in
              VStack(alignment: .leading, spacing: 6) {
                Text(task.name ?? &quot;Unknown&quot;)
                  .font(.headline)
                Text(&quot;Task type \(task.type)&quot;)
                  .font(.caption)
            }
          }.onDelete(perform: removeTask)
        }
      }   .frame(width: 300, height: 400, alignment: .top)
          .padding()
          .border(Color.black)
                
      if regionState == .inside {
        Text(&quot;inside&quot;)
      } else if regionState == .outside {
        Text(&quot;outside&quot;)
      } else {
        Text(&quot;unknown&quot;)
      }          
                
      Spacer()
    }
  }
        
        
  func removeTask(at offsets: IndexSet) {
    for index in offsets {
      let task = tasks[index]
      managedObjectContext.delete(task)
      do {
        try managedObjectContext.save()
      } catch {
        // handle the Core Data error
      }
    }
  }
        
  func showTask(at offsets: IndexSet) {
    for index in offsets {
      let task = tasks[index]
      selectedTask = task.name ?? &quot;No task...&quot;
    }
  }
}

#if DEBUG
struct ContentView_Previews: PreviewProvider {
  static var previews: some View {
    ContentView()
  }
}
#endif
</code></pre>
<p>After implementing the changes made by Fabian, here is the content of the console log:</p>
<pre><code>Granted: true
2019-08-22 14:30:07.051062-0600 AppName[4452:2089841] locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus)
2019-08-22 14:30:07.052803-0600 New1Thing[4452:2089841] startScanning
2019-08-22 14:30:07.054319-0600 New1Thing[4452:2089841] Current location: &lt;+**.49945068,-***.87504490&gt; +/- 65.00m (speed -1.00 mps / course -1.00) @ 8/22/19, 2:30:07 PM **** Daylight Time
</code></pre>
","6190779","","3096087","","2020-12-03 10:21:23","2020-12-03 10:21:23","SwiftUI with Core Location as ObservableObject crashes","<ios><swift><xcode><swiftui><core-location>","2","0","3","","","CC BY-SA 4.0"
"57614160","1","58141381","","2019-08-22 17:12:12","","1","769","<p>I am using SwiftUI to make an app and storing the data on ICloud. Because all the code I can find relates to Swift and viewDidLoad and TableView, however this do not apply. I have written code and seems to retrieve it but will not return it to the ObservableObject to be able to display in the SwiftUI</p>

<p>The ObservableObject file:-</p>

<pre><code>import SwiftUI
import Combine

final class ObservedData: ObservableObject {
    @Published var venues = venuesData
}
</code></pre>

<p>The query to retrieve data</p>

<pre><code>import SwiftUI
import CloudKit

var venuesData: [Venue] = loadVenues()

func loadVenues() -&gt; [Venue] {

    var data = [Venue]()

    let pred = NSPredicate(value: true)
    let sort = NSSortDescriptor(key: ""id"", ascending: true)
    let query = CKQuery(recordType: ""DeptfordHopData"", predicate: pred)
    query.sortDescriptors = [sort]

    let operation = CKQueryOperation(query: query)
    operation.desiredKeys = [""id"",""name"", ""address""]
    operation.resultsLimit = 50

    var newVenues = [Venue]()

    operation.recordFetchedBlock = { record in
        let venue = Venue()
        venue.racordID = record.recordID
        venue.id = record[""id""]
        venue.name = record[""name""]
        venue.address = record[""address""]
        newVenues.append(venue)
    }

    operation.queryCompletionBlock = {(cursor, error) in
        DispatchQueue.main.async {
            if error == nil {
                data = newVenues
            } else {
                print(error!.localizedDescription)
            }
        }
    }

    CKContainer.default().publicCloudDatabase.add(operation)

    return data
}
</code></pre>

<p>I have got data showing when do break in data but does not pass to venueData</p>
","10118276","","10118276","","2019-09-10 07:45:59","2021-06-20 01:21:26","How to retrieve data from CloudKit using SwiftUI","<swift><cloudkit><swiftui>","1","0","1","","","CC BY-SA 4.0"
"57632126","1","57632350","","2019-08-23 19:38:33","","1","2362","<p>I was looking for an example for a DataStore in SwiftUI and found this example.</p>

<pre><code>import SwiftUI
import Combine

class MyDatabase: ObservableObject {
    let didChange = PassthroughSubject&lt;MyDatabase, Never&gt;()

    var contacts: [Contact] = [
        Contact(id: 1, name: ""Anna""), Contact(id: 2, name: ""Beto""),
        Contact(id: 3, name: ""Jack""), Contact(id: 4, name: ""Sam"")
    ] {
        didSet {
            didChange.send(self)
        }
    }

    struct Contact: Identifiable{
        var id: Int
        var name: String
    }
}

struct ContactsList: View {
    @EnvironmentObject private var database: MyDatabase

    var body: some View {
        NavigationView {
            List($database.contacts) { contact in
                NavigationLink(destination: ContactDetail(contact: contact)) {
                    Text(verbatim: contact.value.name)
                    //here Error 1: Types of expression....
                }
            }
            .navigationBarTitle(Text(""Contacts""))
        }
    }
}

struct ContactDetail: View {
    @Binding var contact: MyDatabase.Contact

    var body: some View {
        VStack {
            TextField($contact[\.name])
                .textFieldStyle(.roundedBorder)
                .font(.title)
                .padding()
            //here Error 2: Types of expression....
            Spacer()
        }
        .navigationBarTitle(Text(""Edit""), displayMode: .inline)
    }
}

</code></pre>

<p>However, after testing it, I got the below error multiple times:</p>

<blockquote>
  <p>Type of expression is ambiguous without more context</p>
</blockquote>

<p>I also tried following tutorial for the same solution <a href=""https://mecid.github.io/2019/07/03/managing-data-flow-in-swiftui/"" rel=""nofollow noreferrer"">https://mecid.github.io/2019/07/03/managing-data-flow-in-swiftui/</a>
but I got the same errors.
Did anything changes regarding the Bindings in the latest beta?
Im running Beta 6</p>
","","user9804767","1181535","","2019-08-23 20:02:38","2019-08-23 20:17:39","SwiftUI: Type of expression is ambiguous without more context, When passing ObservableObject between Views","<ios><swiftui><combine>","1","1","","2019-08-24 11:09:16","","CC BY-SA 4.0"
"57638220","1","57639858","","2019-08-24 13:04:28","","4","409","<h1>Info</h1>

<p>My app is crashing on Apple Watches running watchOS 4 &amp; 5. Some new features (ie <code>Combine</code>), depend on watchOS 6, and the use of these methods are explicitly marked with </p>

<pre><code>@available(watchOSApplicationExtension 6.0.0, *)
</code></pre>

<p>The application was created with Xcode 9/10 (I forget exactly which), and targets watchOS 4. Now when it's built with Xcode 11, and has files which depend on Combine, it crashes on a watchOS 5 Apple Watch.</p>

<p>The error is </p>

<pre><code>dyld: Library not loaded: /System/Library/Frameworks/Combine.framework/Combine
  Referenced from: /private/var/containers/Bundle/Application/7A361FAB-EBE7-483D-BFD7-E915F15B5B14/Chirp WatchKit App.app/PlugIns/Chirp WatchKit Extension.appex/Chirp WatchKit Extension
  Reason: image not found
</code></pre>

<p>Clearly, <code>Combine</code>, isn't playing nicely. </p>

<p>Also, it will not launch in a watchOS 5 simulator, and the error is slightly more telling:</p>

<pre><code>dyld: Library not loaded: /System/Library/Frameworks/Combine.framework/Combine
  Referenced from: /Users/willbishop/Library/Developer/CoreSimulator/Devices/C6F36860-E70A-45E6-AC3B-E54DBCEA7C7A/data/Containers/Bundle/Application/1B2EC7C4-731F-4EC1-B23F-09A0B49CD055/Chirp WatchKit App.app/PlugIns/Chirp WatchKit Extension.appex/Chirp WatchKit Extension
  Reason: no suitable image found.  Did find:
    /System/Library/Frameworks/Combine.framework/Combine: mach-o, but wrong architecture
</code></pre>

<h1>What I've Tried:</h1>

<ul>
<li><p>I thought it may be as I had watchOS 6 dependent code, mixed alongside watchOS 5 files. However, after moving the code into seperate files, the issue persists.</p></li>
<li><p>Cleaning the project</p></li>
<li><p>Removing <code>Derived Data/</code></p></li>
</ul>

<p>Despite that, no luck. I assume it's a build setting somewhere, but I wouldn't have the faintest clue of which one.</p>
","7102356","","1000551","","2019-12-07 10:00:49","2019-12-07 10:00:49","No suitable image for Combine found on watchOS 5.2 crash","<swift><xcode><clang><watchos><combine>","1","0","","","","CC BY-SA 4.0"
"57690243","1","59043496","","2019-08-28 10:24:22","","12","7740","<p>What is the role of AnyPublisher in Combine, and why in many examples, including in<a href=""https://developer.apple.com/videos/play/wwdc2019/721/"" rel=""noreferrer"">WWDC Combine In practice, 27:40</a> they return AnyPublisher, using <code>.eraseToAnyPublisher</code>, and not just return a Publisher?</p>

<p>The <a href=""https://developer.apple.com/documentation/combine/anypublisher"" rel=""noreferrer"">Apple Documents</a> says </p>

<blockquote>
  <p>Use AnyPublisher to wrap a publisher whose type has details you don’t want to expose to subscribers or other publishers.</p>
</blockquote>

<p>But can anyone give an example of where it can be useful?</p>
","6276472","","","","","2020-10-28 22:07:05","Publisher vs AnyPublisher in Combine","<swift><combine>","2","1","2","","","CC BY-SA 4.0"
"57732284","1","57736611","","2019-08-30 19:27:06","","2","1755","<p>I've been trying a simple feature to add new entries to a List. The View will just add a new generated. item (no need for user input).</p>

<pre><code>struct PeopleList: View {
@ObservedObject var people: PersonStore
var body: some View {
    NavigationView {
        VStack {
            Section {
                Button(action: add) {
                    Text(""Add"")
                }
            }
            Section {
                List {
                    ForEach(people.people) { person in

                        NavigationLink(destination: PersonDetail(person: person)) {
                            PersonRow(person: person)
                        }
                    }
                }
            }
        }
    }
    .navigationBarTitle(Text(""People""))
    .listStyle(GroupedListStyle())
}

func add() {
    let newID = (people.people.last?.id ?? 0) + 1

    self.people.people.append(Person(id: newID, name: """"))
}
}
</code></pre>

<p>This used to work in previous betas, but for some reason it's not working anymore. When I click on Add, the App does call the <code>add()</code> function and adds the new entry to the array, but the View is not updated at all.</p>

<p>These are the support classes:</p>

<pre><code>    class PersonStore: ObservableObject {

    var people: [Person] {
        willSet {
            willChange.send()
        }
    }

    init(people: [Person] = []) {
        self.people = people
    }

    var willChange = PassthroughSubject&lt;Void, Never&gt;()
}

class Person: ObservableObject, Identifiable {

    var id: Int = 0 {
        willSet {
            willChange.send()
        }
    }

    var name: String {
        willSet {
            willChange.send()
        }
    }

     init(id: Int, name: String) {
        self.id = id
        self.name = name
    }

    var willChange = PassthroughSubject&lt;Void, Never&gt;()
}

#if DEBUG

let data = [
    Person(id: 1, name: ""David""),
    Person(id: 2, name: ""Anne""),
    Person(id: 3, name: ""Carl""),
    Person(id: 4, name: ""Amy""),
    Person(id: 5, name: ""Daisy""),
    Person(id: 6, name: ""Mike""),
]

#endif
</code></pre>

<p>And the support views:</p>

<pre><code>struct PersonRow: View {

    @ObservedObject var person: Person

    var body: some View {
        HStack {
            Image(systemName: ""\(person.id).circle"")
            Text(person.name)
        }.font(.title)
    }
}

struct PersonDetail: View {

    @ObservedObject var person: Person

    var body: some View {
        HStack {

            Text(""This is \(person.name)"")
        }.font(.title)
    }
}
</code></pre>

<p>I've found someone with a problem that looks a bit related here:
<a href=""https://stackoverflow.com/questions/57702108/swiftui-view-content-not-reloading-if-observedobject-is-a-subclass-of-uiviewco"">SwiftUI: View content not reloading if @ObservedObject is a subclass of UIViewController. Is this a bug or am I missing something?</a>
and here:
<a href=""https://stackoverflow.com/questions/57127878/swiftui-binding-doesnt-refresh-view"">SwiftUI @Binding doesn&#39;t refresh View</a></p>
","3497463","","3497463","","2019-08-31 07:27:28","2019-08-31 13:25:12","SwiftUI with Xcode 11 beta 7 not updating contents of List / ForEach","<swift><swiftui><xcode11><swiftui-list>","1","0","","","","CC BY-SA 4.0"
"57736028","1","57743808","","2019-08-31 07:24:24","","7","6372","<p>In Xcode 11 beta 5 or 6 my existing code that relied on <code>URLSession.DataTaskPublisher</code> stopped working. It seems like <code>DataTaskPublisher</code> is never publishing any values but I can't work out why.</p>

<p>I've tried with <code>.sink</code> and <code>.handleEvents</code> as subscribers. I've tested .sink with a <code>Just</code> publisher and confirmed it receives a value there.</p>

<p>I've also tried both giving the <code>DataTaskPublisher</code> a <code>URL</code> and giving it a <code>URLRequest</code>. I've tried a request to an API including an authorization header, as well as basic requests to google.com and apple.com. I've tried using <code>URLSession.shared</code> and creating a new instance of <code>URLSession</code>. I've also tried with and without <code>map</code> and <code>decode</code> operators.</p>

<p>I've used <code>XCTest</code> expectations to confirm that the test times out every single time, even if I give it a 4-minute timeout.</p>

<p>I just made a new example project and replicated the problem with the following code in the root view controller:</p>

<pre class=""lang-swift prettyprint-override""><code>override func viewDidLoad() {
        super.viewDidLoad()

        print(""view did load"")

        URLSession.shared.dataTaskPublisher(for: URL(string: ""http://apple.com"")!)
            .handleEvents(receiveSubscription: { (sub) in
                print(sub)
            }, receiveOutput: { (response) in
                print(response)
            }, receiveCompletion: { (completion) in
                print(completion)
            }, receiveCancel: {
                print(""cancel"")
            }, receiveRequest: { (demand) in
                print(demand)
            })
    }
</code></pre>

<p>The project prints ""view did load"" but nothing else ever prints. Any ideas about where I'm going wrong here? Thanks!</p>
","4451268","","","","","2019-10-22 00:32:56","Why doesn't URLSession.DataTaskPublisher ever publish values?","<swift><xcode11><combine>","1","2","1","","","CC BY-SA 4.0"
"57759387","1","57759538","","2019-09-02 15:19:29","","0","214","<p>I am trying to make a trivia app but am getting stuck on parsing the json received. I also would like to know how I can use the data with swift UI</p>

<p>I have tried to make a object for it to be stored but can't seem to get it.</p>

<p>Here is the JSON I receive</p>

<pre><code>{""response_code"":0,""results"":[{""category"":""Entertainment: Film"",""type"":""multiple"",""difficulty"":""medium"",""question"":""In Mulan (1998), who is the leader of the Huns?"",""correct_answer"":""Shan Yu"",""incorrect_answers"":[""Chien-Po"",""Li Shang"",""Fa Zhou""]}]}
</code></pre>

<p>Their also can be many dictionaries in the results</p>

<p>Here is what I am using to get and decode data</p>

<pre><code>import Foundation
import SwiftUI
import Combine

class NetworkingManager :ObservableObject {
    init(amount:Int) {
        guard let url = URL(string: ""https://opentdb.com/api.php?amount=\(String(amount))"") else {return }

        URLSession.shared.dataTask(with: url) {(data,_,_) in
            guard let data = data else{return }
            let decoder = JSONDecoder()
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            let question =  try! decoder.decode(TriviaQuestion.self, from: data)
            print(question.responseCode)
        }.resume()
    }
}
</code></pre>

<p>Here is my struct</p>

<pre><code>struct TriviaQuestion : Codable{
    var responseCode:Int
    var results:Array&lt;Dictionary&lt;String,String&gt;&gt;

}
</code></pre>

<p>in the try statement it won't let me create the TriviaQuestion object because it has a list in the incorect_answers key. I also do not know if I am putting the Observable object in the correct format. Here is the actual error.</p>

<blockquote>
  <p>Fatal error: 'try!' expression unexpectedly raised an error: Swift.DecodingError.typeMismatch(Swift.String, Swift.DecodingError.Context(codingPath: [CodingKeys(stringValue: ""results"", intValue: nil), _JSONKey(stringValue: ""Index 0"", intValue: 0), _JSONKey(stringValue: ""incorrect_answers"", intValue: nil)], debugDescription: ""Expected to decode String but found an array instead."", underlyingError: nil)): file /Users/shorya/Desktop/Quick Trivia/Quick Trivia/NetworkingManager.swift, line 21
  2019-09-02 10:59:28.608392-0400 Quick Trivia[15807:307693] Fatal error: 'try!' expression unexpectedly raised an error: Swift.DecodingError.typeMismatch(Swift.String, Swift.DecodingError.Context(codingPath: [CodingKeys(stringValue: ""results"", intValue: nil), _JSONKey(stringValue: ""Index 0"", intValue: 0), _JSONKey(stringValue: ""incorrect_answers"", intValue: nil)], debugDescription: ""Expected to decode String but found an array instead."", underlyingError: nil)): file /Users/shorya/Desktop/Quick Trivia/Quick Trivia/NetworkingManager.swift, line 21</p>
</blockquote>
","12010550","","2844215","","2019-09-02 20:37:35","2019-09-02 20:37:35","How can I have a string and an int in a swift dictionary that is decoded from json","<json><swift>","1","0","","","","CC BY-SA 4.0"
"57760772","1","57760803","","2019-09-02 17:22:56","","4","4178","<p>Seems like Combine (shipped with Xcode 11 beta 7) lacks a <a href=""http://reactivex.io/documentation/operators/distinct.html"" rel=""nofollow noreferrer""><code>distinct</code></a> operator? </p>

<p>Can anyone help me build one? :) </p>
","1311272","","","","","2019-09-25 02:21:36","Swift Combine: no `distinct` operator?","<ios><swift><swiftui><xcode11><combine>","2","0","","","","CC BY-SA 4.0"
"57766270","1","57779331","","2019-09-03 06:43:09","","3","1085","<p>I want my app to periodically fetch new records and stores them in Core Data. I have a label on my UI that should display the number of elements for a particular record and I want that number to be updated as more records are added into the database. As an exercise, I want to use Combine to accomplish it.</p>

<p>I'm able to display the number of elements in the database when the app launches, but the number doesn't get updated when new data enters into the database (I verified that new data was being added by implementing a button that would manual refresh the UI).</p>

<p>Here's the code that displays the correct number of elements on launch but doesn't update when new records are added:</p>

<pre class=""lang-swift prettyprint-override""><code>let replayRecordFetchRequest: NSFetchRequest&lt;ReplayRecord&gt; = ReplayRecord.fetchRequest()

_ = try? persistentContainer.viewContext.fetch(replayRecordFetchRequest).publisher.count().map { String(format: Constants.Strings.playsText, $0) }.assign(to: \.text, on: self.playsLabel)
</code></pre>

<p>Here's a code snippet from the WWDC 2019 Session 230 talk that I adapted but this doesn't work at all (the subscriber is never fired):</p>

<pre class=""lang-swift prettyprint-override""><code>let replayRecordFetchRequest: NSFetchRequest&lt;ReplayRecord&gt; = ReplayRecord.fetchRequest()

if let replayRecords = try? replayRecordFetchRequest.execute() {
    _ = replayRecords.publisher.count().map { String(format: Constants.Strings.playsText, $0) }.assign(to: \.text, on: self.playsLabel)
}
</code></pre>
","5481276","","","","","2019-09-03 22:13:59","How to use Combine to assign the number of elements returned from a Core Data fetch request?","<swift><core-data><combine>","1","0","2","","","CC BY-SA 4.0"
"57768427","1","59740480","","2019-09-03 09:06:04","","11","8294","<p>I'm trying to achieve something similar to scenario presented below (create URL, request to server, decode json, error on every step wrapped in custom <code>NetworkError</code> enum):</p>

<pre class=""lang-swift prettyprint-override""><code>enum NetworkError: Error {
    case badUrl
    case noData
    case request(underlyingError: Error)
    case unableToDecode(underlyingError: Error)
}

//...
    func searchRepos(with query: String, success: @escaping (ReposList) -&gt; Void, failure: @escaping (NetworkError) -&gt; Void) {
        guard let url = URL(string: searchUrl + query) else {
            failure(.badUrl)
            return
        }

        session.dataTask(with: url) { data, response, error in
            guard let data = data else {
                failure(.noData)
                return
            }

            if let error = error {
                failure(.request(underlyingError: error))
                return
            }

            do {
                let repos = try JSONDecoder().decode(ReposList.self, from: data)

                DispatchQueue.main.async {
                    success(repos)
                }
            } catch {
                failure(.unableToDecode(underlyingError: error))
            }
        }.resume()
    }
</code></pre>

<p>My solution in Combine works:</p>

<pre class=""lang-swift prettyprint-override""><code>    func searchRepos(with query: String) -&gt; AnyPublisher&lt;ReposList, NetworkError&gt; {
        guard let url = URL(string: searchUrl + query) else {
            return Fail(error: .badUrl).eraseToAnyPublisher()
        }

        return session.dataTaskPublisher(for: url)
            .mapError { NetworkError.request(underlyingError: $0) }
            .map { $0.data }
            .decode(type: ReposList.self, decoder: JSONDecoder())
            .mapError { $0 as? NetworkError ?? .unableToDecode(underlyingError: $0) }
            .subscribe(on: DispatchQueue.global())
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
</code></pre>

<p>but I really don't like this line</p>

<pre><code>.mapError { $0 as? NetworkError ?? .unableToDecode(underlyingError: $0) }
</code></pre>

<p>My questions:</p>

<ol>
<li>Is there better way to map errors (and replace line above) using chaining in Combine? </li>
<li>Is there any way to include first <code>guard let</code> with <code>Fail(error:)</code> in chain?</li>
</ol>
","2369731","","2369731","","2019-09-03 11:47:45","2020-01-14 23:07:13","Swift Combine chaining .mapError()","<swift><combine>","2","0","5","","","CC BY-SA 4.0"
"57796877","1","57806993","","2019-09-04 23:59:19","","7","7786","<p>Before this question gets marked as duplicate of <a href=""https://stackoverflow.com/questions/57199922/create-a-timer-publisher-using-swift-combine"">this other question</a>, I am trying to understand how the publisher works as it behaves in a way I do not expect.</p>

<p>Using the same example as the answer from the question previously stated:
</p>

<pre><code>// Let's define the view model with my view...
import Combine
import SwiftUI

class TimerViewModel: ObservableObject {
  private let cancellable: AnyCancellable?

  let intervalPublisher = Timer.TimerPublisher(
                            interval: 1.0, 
                            runLoop: .main, 
                            mode: .default)

  init() {
    self.cancellable = timerPublisher.connect() as? AnyCancellable
  }

  deinit {
    self.cancellable?.cancel()
  }
}

struct Clock : View {
  @EnvironmentObject var viewModel: TimerViewModel
  @State private var currentTime: String = ""Initial""


  var body: some View {
    VStack {
      Text(currentTime)
    }
    .onReceive(timer.intervalPublisher) { newTime in
      self.currentTime = String(describing: newTime)
    }
  }
}
</code></pre>

<p>At this stage, all I wanted to do is my view model to publish the value directly. I don't want to have to declare the view will be receiving these sorts of values.</p>

<p>Ideally, I want to turn my publisher into a published properly... I though that the following code would work:</p>

<pre class=""lang-swift prettyprint-override""><code>// Let's define the view model with my view...
import Combine
import SwiftUI

class TimerViewModel: ObservableObject {
  private let cancellable: AnyCancellable?
  private let assignCancellable: AnyCancellable?

  let intervalPublisher = Timer.TimerPublisher(
                            interval: 1.0, 
                            runLoop: .main, 
                            mode: .default)
 @Published var tick: String = ""0:0:0""

  init() {
    cancellable = intervalPublisher.connect() as? AnyCancellable

    assignCancellable = intervalPublisher
                              .map { new in String(describing: new) }
                              .assign(to: \TimerViewModel.tick, on: self)
  }

  deinit {
    cancellable?.cancel()
    assignCancellable?.cancel()
  }
}

struct Clock : View {
  @EnvironmentObject var viewModel: TimerViewModel
  @State private var currentTime: String = ""Initial""


  var body: some View {
    VStack {
      Text(currentTime)
      Text(viewModel.tick) // why doesn't this work?
    }
    .onReceive(timer.intervalPublisher) { newTime in
      self.currentTime = String(describing: newTime)
    }
  }
}
</code></pre>

<p>What am I doing wrong for my <code>assign</code>?</p>

<p>Why isn't triggering?</p>

<p><em>Edit: the environment object was set on the <code>SceneDelegate</code> once the Clock view was created. The code excluded is attached below:</em></p>

<pre class=""lang-swift prettyprint-override""><code>    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).

        // Create the SwiftUI view that provides the window contents.
        let view = Clock().environmentObject(TimerViewModel())

        // Use a UIHostingController as window root view controller.
        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(rootView: view)
            self.window = window
            window.makeKeyAndVisible()
        }
    }
</code></pre>
","332948","","332948","","2019-09-05 12:03:56","2021-04-11 20:43:38","Swift Combine: Using timer publisher in an observable object","<swift><xcode><swiftui><xcode11><combine>","3","4","2","","","CC BY-SA 4.0"
"57808811","1","57831518","","2019-09-05 15:35:32","","5","6141","<p>I have a content view and I want to track dynamically the height.</p>

<p>I have implemented this solution but i encounter this Exception :</p>

<blockquote>
  <p>Fatal error: Accessing State outside View.body: file</p>
</blockquote>

<p>What can i do to have keyboardHeight dynamic which can update my UI </p>

<pre><code>struct ContentView: View {

    @State var keyboardHeight: CGFloat = 0
    var cancellables: Set&lt;AnyCancellable&gt; = []

    init() {
        NotificationCenter.default.publisher(for: UIResponder.keyboardWillChangeFrameNotification)
        .merge(with: NotificationCenter.default.publisher(for: UIResponder.keyboardWillHideNotification))
        .compactMap({ notification in
          guard let keyboardFrameValue: NSValue = notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue else { return nil }
          let keyboardFrame = keyboardFrameValue.cgRectValue
          if keyboardFrame.origin.y == UIScreen.main.bounds.height {
            return 0
          } else {
            return keyboardFrame.height - (UIApplication.shared.windows.first?.safeAreaInsets.bottom ?? 0)
          }
        })
        .assign(to: \.keyboardHeight, on: self)
        .store(in: &amp;cancellables)
    }

    var body: some View {
        VStack{
            ZStack(alignment: Alignment.bottom) {
                List {
                    Text(""Default text"").foregroundColor(Color.red)
                }
                TextField(""Placeholder"", text: .constant(""""))
                    .frame(minHeight: 30)
                    .cornerRadius(8.0)
                    .padding(10)
                    .background(Color.blue)
            }
            Spacer()
                .frame(height: keyboardHeight)
        }
    }
}
</code></pre>
","2611161","","1226963","","2019-09-05 15:37:50","2019-09-07 07:11:18","Accessing state variable in SwiftUI View outside the body","<swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"57814264","1","57820808","","2019-09-06 00:13:33","","3","4485","<p>I load endpoints from a RESTful server from which some are multipage. They are denoted by an 'x-pages' field in the header response. I want to create a publisher that will return all of the objects from all of pages as a single array.</p>

<p>There is a compilation error on the last return statement.</p>

<pre><code>Cannot convert return expression of type 'AnyPublisher&lt;AnyPublisher&lt;[T], LoadingError&gt;, LoadingError&gt;\' to return type 'AnyPublisher&lt;[T], LoadingError&gt;'
</code></pre>

<p>How do I fix this ""embedded"" publisher?</p>

<pre><code>import Combine
import Foundation

enum LoadingError: Error {
    case url(URLError)
    case decode(Error)
    case couldNotDetermieLastPageNumber(URL)
}

func multipageDataTaskPublishter&lt;T&gt;(for endpoint: Endpoint) -&gt; AnyPublisher&lt;[T], LoadingError&gt; where T: Decodable {
    assert(endpoint.page == 1)
    let publisher = URLSession.shared.dataTaskPublisher(for: endpoint.url)
        .retry(1)
        .mapError { LoadingError.url($0) }
        .map { (arg) -&gt; AnyPublisher&lt;[T], LoadingError&gt; in
            let (_, response) = arg
            guard
                let header = response as? HTTPURLResponse,
                let xpages = header.value(forHTTPHeaderField: ""x-pages""),
                let lastPage = Int(xpages)
            else {
                return Fail(error: LoadingError.couldNotDetermieLastPageNumber(endpoint.url))
                    .eraseToAnyPublisher()
            }

            let publishers = (1...lastPage).map { page -&gt; AnyPublisher&lt;[T], LoadingError&gt; in
                let next = endpoint.for(page: page)
                return URLSession.shared.dataTaskPublisher(for: next.url)
                    .retry(1)
                    .mapError { LoadingError.url($0) }
                    .map { $0.data }
                    .decode(type: [T].self, decoder: JSONDecoder())
                    .mapError { LoadingError.decode($0) }
                    .eraseToAnyPublisher()
            }
            return Publishers.Sequence(sequence: publishers)
                .flatMap { $0 }
                .reduce([], +)
                .eraseToAnyPublisher()
        }
    return publisher.eraseToAnyPublisher()
}
</code></pre>

<p>I could add a Sink immediately after the guard to read the lastPage value when the multipage publisher is created. Then with the <code>let publishers = ...</code> section lifted out of map up one level, my Publishers.Sequence return value would be correct. But this seems wrong on many levels; split execution, not composable.</p>

<p>Additionally I realize that my implementation loads the first page twice. Splitting the pipeline and merging Data payloads later would be better and I want to get to that solution but I need to wrap my head around this problem first. If this is a hopeless cause, then so be it and any idiomatic Combine solution will be accepted.</p>
","2256008","","2890168","","2019-09-14 08:39:10","2019-09-14 08:39:10","How Can I Flatten An AnyPublisher<AnyPublisher<>>?","<swift><combine>","1","1","1","","","CC BY-SA 4.0"
"57833890","1","57835011","","2019-09-07 12:55:25","","2","1062","<p>I have an object which I want to send throughout multiple listeners/subscribers, so I was checking out Combine and I saw 2 different kind of publishers, namely <code>NotificationCenter.Publisher</code> and <code>PassThroughSubject</code>. I am confused why anyone would use a <code>NotificationCenter.Publisher</code> over <code>PassThroughSubject</code>. </p>

<p>I came up with the code below, demonstrating both ways. To summarize:</p>

<ul>
<li><code>NotificationCenter.Publisher</code> needs to have a <code>Notification.Name</code> static property</li>
<li>Isn't really that typesafe (since I can post a different kind of object for the same <code>Notification.Name</code>/different publisher for the same <code>Notification.Name</code>)</li>
<li>Posting a new value needs to be done on <code>NotificationCenter.default</code> (not the publisher itself)</li>
<li>An explicit downcast to the used type in the <code>map</code> closure</li>
</ul>

<p>In what scenarios someone will use <code>NotificationCenter.Publisher</code> over <code>PassThroughSubject</code>? </p>

<pre><code>import UIKit
import Combine

let passThroughSubjectPublisher = PassthroughSubject&lt;String, Never&gt;()
let notificationCenterPublisher = NotificationCenter.default.publisher(for: .name).map { $0.object as! String }

extension Notification.Name {
    static let name = Notification.Name(rawValue: ""someName"")
}


class PassThroughSubjectPublisherSubscriber {
    init() {
        passThroughSubjectPublisher.sink { (_) in
            // Process
        }
    }
}

class NotificationCenterPublisherSubscriber {
    init() {
        notificationCenterPublisher.sink { (_) in
            // Process
        }
    }
}

class PassThroughSubjectPublisherSinker {
    init() {
        passThroughSubjectPublisher.send(""Henlo!"")
    }
}

class NotificationCenterPublisherSinker {
    init() {
        NotificationCenter.default.post(name: .name, object: ""Henlo!"")
    }
}
</code></pre>
","7715250","","","","","2019-09-09 17:34:46","NotificationCenter.Publisher VS PassThroughSubject","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"57836990","1","57837054","","2019-09-07 19:48:36","","6","4994","<p>How do I build a dynamic list with @Binding-driven controls without having to reference the array manually? It seems obvious but using List or ForEach to iterate through the array give all sorts of strange errors.</p>

<pre><code>struct OrderItem : Identifiable {
    let id = UUID()
    var label : String
    var value : Bool = false
}

struct ContentView: View {
    @State var items = [OrderItem(label: ""Shirts""),
                        OrderItem(label: ""Pants""),
                        OrderItem(label: ""Socks"")]
    var body: some View {
        NavigationView {
            Form {
                Section {
                    List {
                        Toggle(items[0].label, isOn: $items[0].value)
                        Toggle(items[1].label, isOn: $items[1].value)
                        Toggle(items[2].label, isOn: $items[2].value)
                    }
                }
            }.navigationBarTitle(""Clothing"")
        }
    }
}
</code></pre>

<p>This doesn't work:</p>

<pre><code>            ...
                Section {
                    List($items, id: \.id) { item in
                        Toggle(item.label, isOn: item.value)
                    }
                }
            ...
</code></pre>

<blockquote>
  <p>Type '_' has no member 'id'</p>
</blockquote>

<p>Nor does:</p>

<pre><code>            ...
                Section {
                    List($items) { item in
                        Toggle(item.label, isOn: item.value)
                    }
                }
            ...
</code></pre>

<blockquote>
  <p>Generic parameter 'SelectionValue' could not be inferred</p>
</blockquote>
","1696358","","","","","2021-06-08 17:43:01","SwiftUI dynamic List with @Binding controls","<swiftui><combine><swiftui-list>","2","1","","","","CC BY-SA 4.0"
"57878111","1","57884978","","2019-09-10 20:56:59","","2","3483","<p>I have an app in which it shows me data from an API. I made a service that gets the data, where URL(string = """") is the url of the API:</p>

<pre><code>class Webservice {

    func getAllMatches(completion: @escaping ([Matches.Matchs]?) -&gt; ()) {

        guard let url = URL(string: ""API"")
            else {
                fatalError(""URL is not correct!"")
        }
        URLSession.shared.dataTask(with: url) { data, _, _ in

            let matchs = try! JSONDecoder().decode([Matches.Matchs].self, from: data!)
            DispatchQueue.main.async {
                completion(matchs)
            }
        }.resume()
    }

}
</code></pre>

<p>Then I made a ViewModel in which the API fields were set:</p>

<pre><code>class MatchListViewModel: ObservableObject {

    @Published var matches = [MatchViewModel]()


    init() {
        fetchMatch()


    }

    func fetchMatch() {

        Webservice().getAllMatches { matches in

            if let matches = matches {
                self.matches = matches.map(MatchViewModel.init)
            }
        }
    }

}


class MatchViewModel {

    let id = UUID()

    var match: Matches.Matchs

    init(match: (Matches.Matchs)) {
        self.match = match
    }


    var championship: String {
        return self.match.championship.name
    }

    var local_Name: String {
        return self.match.local.name
    }

    var local_Image: String  {
        return self.match.local.image
    }

    var local_goals: Double {
        return self.match.local_goals
    }

    var local_penalty_goals: Double {
        return self.match.local_penalty_goals
    }
    var stadium_Name: String {
        return self.match.stadium.name
    }

}
</code></pre>

<p>In the API, there is a field that shows an image, which is contained in a URL, I leave an example:</p>

<pre><code>""local"":{  
     ""slug"":""nombre"",
     ""name"":""nombre"",
     ""short_name"":""nombre"",
     ""image"":""https://s3.amazonaws.com/funx-futbol/dashboard/ad.png""
 },
</code></pre>

<p>My question is: How can I display that image via that URL? The API query works, as it brings me the information I require, but I need to show me the image through that link, which I have not achieved.</p>

<p>Thanks for reading!</p>

<p><a href=""https://i.stack.imgur.com/Tc1Md.png"" rel=""nofollow noreferrer"">error</a></p>
","9397255","","7948372","","2021-02-26 10:46:56","2021-02-26 10:46:56","How can I display an image by an API URL? Swift","<swift><swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"57930789","1","57930874","","2019-09-13 22:00:30","","3","935","<p>I'm having trouble getting the most simple implementation of the Combine pattern to work, subscribing to a UITextField textDidChangeNotification.</p>

<pre><code>import UIKit
import Combine

class ViewController: UIViewController {

    let textField = UITextField()

    override func viewDidLoad() {
        super.viewDidLoad()

        view.addSubview(textField)
        textField.frame = CGRect(x: 100, y: 0, width: view.frame.width, height: 100)
        textField.placeholder = ""Search""

        let sub = NotificationCenter.default.publisher(for: UITextField.textDidChangeNotification, object: textField)
            .sink { (notification) in
                print(""123"")
        }
    }

}

</code></pre>

<p>I must be missing something super simple, but this basic pattern is exactly copied from the Documentation and other tutorials.</p>

<p>Thanks for the help.</p>
","9267909","","","","","2021-06-29 19:36:14","Simple Swift Combine subscribing to textDidChangeNotification","<swift><frp><combine>","1","0","","","","CC BY-SA 4.0"
"57938881","1","57939476","","2019-09-14 20:06:03","","2","2593","<p>say I have an array of <code>Person</code> structs like this:</p>

<pre class=""lang-swift prettyprint-override""><code>struct Person {
    var name: String
}

var persons = [Person(name: ""A""), Person(name: ""B""), Person(name: ""C"")]

let publisher = CurrentValueSubject&lt;[Person], Never&gt;(persons)

// subscribe to changes to the array
let subscription: AnyCancellable = publisher.sink { (persons) in
    print(""The array has changed"")
}

var currentPersons = publisher.value
currentPersons[0].name = ""Changed""
publisher.send(currentPersons)
</code></pre>

<p>This works. It publishes every time anything in the array changes or if something is deleted or added.</p>

<p>But what if I wanted to additionally be able to subscribe to only one element in the array? Can I do that? I simply can't figure it out.</p>
","3134192","","","","","2019-09-14 21:42:46","Swift Combine Framework - How to properly observe an array?","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"57944611","1","57944663","","2019-09-15 13:35:05","","0","72","<p>I created a class to get the current heading with CLLocationManagerDelegate for my SwiftUI app, but I have the <code>Property 'self.heading' not initialized at super.init call</code> error. I don't know why. I do not think I need to specify a parameter because my class does not take any parameters during its call ?</p>

<p>My LocationManager class:</p>

<pre><code>class LocationManager: NSObject, CLLocationManagerDelegate, ObservableObject {

  var locationManager: CLLocationManager?
  var objectWillChange = PassthroughSubject&lt;Void, Never&gt;()

  @Published var heading: Double {
    willSet {
      objectWillChange.send()
    }
  }

  override init() {
    super.init()

    locationManager = CLLocationManager()
    locationManager!.delegate = self
    locationManager!.desiredAccuracy = kCLLocationAccuracyBest
    locationManager!.requestWhenInUseAuthorization()
  }

  func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {
    self.heading = newHeading.trueHeading.degreesToRadians
  }

}
</code></pre>

<p><a href=""https://i.stack.imgur.com/gwhg2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gwhg2.png"" alt=""Screen of error""></a></p>
","7037428","","","","","2019-09-15 13:49:37","I don't understand Property 'self.heading' not initialized at super.init call error in my code","<swift><cllocationmanager><swiftui>","1","0","","","","CC BY-SA 4.0"
"57980476","1","59972188","","2019-09-17 18:58:36","","27","7545","<p>I don't quite understand how to properly store subscribers inside a class so that they persist but don't prevent the object from being deinitialized. Here's an example where the object won't deinit:</p>

<pre class=""lang-swift prettyprint-override""><code>import UIKit
import Combine

class Test {
    public var name: String = """"

    private var disposeBag: Set&lt;AnyCancellable&gt; = Set()

    deinit {
        print(""deinit"")
    }

    init(publisher: CurrentValueSubject&lt;String, Never&gt;) {
        publisher.assign(to: \.name, on: self).store(in: &amp;disposeBag)
    }
}

let publisher = CurrentValueSubject&lt;String, Never&gt;(""Test"")

var test: Test? = Test(publisher: publisher)
test = nil

</code></pre>

<p>When I replace the <code>assign</code> with a <code>sink</code> (in which I properly declare <code>[weak self]</code>) it actually does deinit properly (probably because the <code>assign</code> accesses <code>self</code> in a way that causes problems).</p>

<p>How can I prevent strong reference cycles when using <code>.assign</code> for instance?</p>

<p>Thanks</p>
","3134192","","","","","2022-07-19 20:35:30","How to prevent strong reference cycles when using Apple's new Combine framework (.assign is causing problems)","<swift><combine>","5","1","4","","","CC BY-SA 4.0"
"57982334","1","57987236","","2019-09-17 21:33:09","","2","484","<p>I'm trying to write a URL Validator in Swift w/ Combine and having a SwiftUI view subscribe to it. It seems to work fine in the simulator but crashes on my dev phone (running 13.1).</p>

<p>Scenario... User types into a UITextField which is connected to the urlString var in the view model. When that changes I clean the string, create a URL, and then do a HEAD test with URLSession. This all works in the sim, but on tap of the text field on the device it crashes the app and I'm not getting any good stack traces. Any ideas?</p>

<pre class=""lang-swift prettyprint-override""><code>static func testURLPublisher(string: String) -&gt; AnyPublisher&lt;URL?, Never&gt; {

        let validatedURL = try? validateURL(string: string)

        guard let urlToCheck = validatedURL else {
            return Just(nil).eraseToAnyPublisher()
        }

        var request = URLRequest(url: urlToCheck)
        request.httpMethod = ""HEAD""

        let publisher = URLSession.shared.dataTaskPublisher(for: request)
            .handleEvents(receiveSubscription: { _ in
                networkActivityPublisher.send(true)
            }, receiveCompletion: { _ in
                networkActivityPublisher.send(false)
            }, receiveCancel: {
                networkActivityPublisher.send(false)
            })
            .tryMap { data, response -&gt; URL? in
                // URL Responded - Check Status Code
                guard let urlResponse = response as? HTTPURLResponse, ((urlResponse.statusCode &gt;= 200 &amp;&amp; urlResponse.statusCode &lt; 400) || urlResponse.statusCode == 405) else {
                        throw URLValidatorError.serverError(""Could not find the a servr at: \(urlToCheck)"")
                }
                        return urlResponse.url?.absoluteURL
            }
        .catch { err in
            return Just(nil)
        }
        .eraseToAnyPublisher()
        return publisher
    }
</code></pre>

<p>The view that is using it looks like this...</p>

<pre class=""lang-swift prettyprint-override""><code>class NewSiteViewModel: ObservableObject {

    @Published var validatedURL: URL?

    //@Published var secretKey: String?
    @Published var urlString: String = """"

    @Published var isValidURL: Bool = false

    private var cancellable = Set&lt;AnyCancellable&gt;()

    init() {
        $urlString
        .dropFirst(1)
            .throttle(for: 0.5, scheduler: DispatchQueue(label: ""Validator""), latest: true)
            .removeDuplicates()
            .compactMap { string -&gt; AnyPublisher&lt;URL?, Never&gt; in
                return URL.testURLPublisher(string: string)
            }
            .switchToLatest()
            .receive(on: RunLoop.main)
            .sink { recievedURL in
                guard let url = recievedURL else {
                    self.validatedURL = nil
                    self.isValidURL = false
                    return
                }
                self.validatedURL = url
                self.isValidURL = true

            }
            .store(in: &amp;cancellable)
    }
}

</code></pre>
","6109747","","","","","2019-09-18 21:32:58","URL Verification Publisher","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"58012913","1","58014049","","2019-09-19 14:08:13","","4","3000","<pre><code>    struct Flashcard : View {
      @State var frontText = newArray[randomNum].kana
      @State var backText = newArray[randomNum].romaji

      var body: some View {
        let zstack = ZStack {
          Frontside(kanatext: frontText)
            .background(Color.yellow)
            .rotation3DEffect(.degrees(self.showResults ? 180.0 : 0.0), axis: (x: 0.0, y: 1.0, z: 0.0))
            .zIndex(self.showResults ? 0 : 1)
            .frame(width: 300, alignment: .center)
            .cornerRadius(25)
         }
      }

public struct Frontside: View
{
    @State public var kanatext: String = """"

    public var body: some View
    {
        Text(self.kanatext)
            .font(.title)
            .fontWeight(.black)
            .padding(32)
    }
}
</code></pre>

<p>In my code snippet above, when I update the @State var frontText, I'm expecting my view to refresh and display the frontText. But for some reason  it won't show the new frontText when it is used in my Frontside struct. If I just print Text(frontText) in my view, it will always refresh as the variable changes. What am I missing for it to refresh properly whenever frontText is updated? Thanks. </p>
","58521","","7948372","","2021-02-26 10:46:32","2021-02-26 10:46:32","View not updating after @state variable changes","<swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"58064859","1","58153405","","2019-09-23 14:40:48","","0","549","<p>Apple says:</p>

<blockquote>
  <p>Combine also provides a built-in publisher for any
  property that’s compliant with Key-Value Observing.</p>
</blockquote>

<p>So, I have an instance of UITextView inside of a view controller view which should emit a signal via publisher when a user taps a keyboard but it doesn't happens. Below a snipet of code which explains my way of subscribing to a publisher</p>

<pre><code>class MyViewController : UIViewController {

    var t = UITextView(frame: .init(x: 0, y: 0, width: 100, height: 20))


    override func viewDidLoad() {
    super.viewDidLoad()

        t.publisher(for: \UITextView.text)
            .receive(on: RunLoop.main)
            .sink { (str) in
                print(str)
        }

        view.addSubview(t)
    }
}
</code></pre>
","1180728","","1000551","","2019-12-07 09:59:40","2019-12-07 09:59:40","UITextView publisher doesn't publish a signal when a user taps a keyboard","<ios><swift><combine>","2","0","","","","CC BY-SA 4.0"
"58067075","1","58070916","","2019-09-23 17:01:51","","21","25314","<p>I am getting the above error and couldn't figure out how to solve it. I have an array of objects that contain a boolean value, and need to show a toggle for each of these boolean.</p>

<p>Below is the code.</p>

<pre><code>class Item: Identifiable {
    var id: String
    var label: String
    var isOn: Bool
}

class Service: ObservableObject {
    var didChange = PassthroughSubject&lt;Void, Never&gt;()

    var items: [Item] {
        didSet {
            didChange.send(())
        }
    }
}

struct MyView: View {
    @ObservedObject var service: Service

    var body: some View {
        List {
            ForEach(service.items, id: \.self) { (item: Binding&lt;Item&gt;) in
                Section(header: Text(item.label)) {  // Error: Initializer 'init(_:)' requires that 'Binding&lt;String&gt;' conform to 'StringProtocol'
                    Toggle(isOn: item.isOn) {
                        Text(""isOn"")
                    }
                }
            }
        }
        .listStyle(GroupedListStyle())
    }
}
</code></pre>
","1366265","","","","","2019-09-24 14:45:49","Error: Initializer 'init(_:)' requires that 'Binding<String>' conform to 'StringProtocol'","<swift><swiftui><combine>","1","0","2","","","CC BY-SA 4.0"
"58069967","1","58070552","","2019-09-23 20:44:49","","3","2292","<p>I want to create <code>MyViewModel</code> which gets data from network and then updates the arrray of results. <code>MyView</code> should subscribe to the <code>$model.results</code> and show <code>List</code> filled with the results.</p>

<p>Unfortunately I get an error about ""Type of expression is ambiguous without more context"".</p>

<p>How to properly use <code>ForEach</code> for this case?</p>

<pre><code>import SwiftUI
import Combine

class MyViewModel: ObservableObject {
    @Published var results: [String] = []

    init() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            self.results = [""Hello"", ""World"", ""!!!""]
        }
    }
}

struct MyView: View {
    @ObservedObject var model: MyViewModel

    var body: some View {
        VStack {
            List {
                ForEach($model.results) { text in
                    Text(text)
                 // ^--- Type of expression is ambiguous without more context
                }
            }
        }
    }
}

struct MyView_Previews: PreviewProvider {
    static var previews: some View {
        MyView(model: MyViewModel())
    }
}
</code></pre>

<p>P.S. If I replace the model with <code>@State var results: [String]</code> all works fine, but I need have separate <code>class MyViewModel: ObservableObject</code> for my purposes</p>
","1062636","","1062636","","2019-09-23 20:52:14","2019-09-24 12:45:46","How to bind an array and List if the array is a member of ObservableObject?","<swift><swiftui><combine><swiftui-list>","1","0","1","","","CC BY-SA 4.0"
"58082208","1","58083118","","2019-09-24 14:10:37","","5","1687","<p>We have the practice of using safe subscript when accessing any element in a collection. Below is the extension we have.</p>

<pre><code>extension Collection {
    subscript(safe index: Index) -&gt; Element? {
        return indices.contains(index) ? self[index] : nil
    }
}
</code></pre>

<p>But when I try to use this with a binding object, it gives me an error saying</p>

<blockquote>
  <p>Extraneous argument label 'safe:' in subscript</p>
</blockquote>

<p>Below is the problematic code</p>

<pre><code>struct MyView: View {
    @ObservedObject var service: service

    var body: some View {
        List {
            ForEach(service.items.indices) { index in
                Toggle(isOn: self.$service.items[safe: index]?.isOn ?? false) {  // Error: Extraneous argument label 'safe:' in subscript
                    Text(""isOn"")
                }
            }
        }
    }
}
</code></pre>
","1366265","","1366265","","2019-09-24 15:11:26","2019-09-24 15:11:26","SwiftUI: Safe subscript for binding array","<swift><swiftui><combine>","2","3","1","","","CC BY-SA 4.0"
"58087559","1","58160320","","2019-09-24 20:17:39","","4","5856","<p>Hi I was just wondering is it possible to create a generic class confirming to ObservableObject protocol which can be used by more then one ContentViews.</p>

<p>If i can do that then I will be able make my ContentView and Model class completely generic and reusable.</p>

<p>An example of what i would like to achieve:</p>

<pre><code>protocol ContentViewModelType: ObservableObject {
    var propertyToInitialiseView: [String] { get }
}

struct ContentView: View {
    @ObservedObject var viewModel: some ViewModel

    var body: some View {
        Text(""Hello World"")
    }
}
</code></pre>

<p>If I can do that any class can implement ContentViewModelType and become a model for ContentView which makes it generic and reusable. For example</p>

<pre><code>class ViewModel: ObservableObject {
    var objectWillChange = PassthroughSubject&lt;ViewModel, Never&gt;()
}
</code></pre>

<p>But when i try to initialise ContentView that xcode gives me a type error.</p>

<p><a href=""https://i.stack.imgur.com/jzyPC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jzyPC.png"" alt=""enter image description here""></a></p>

<p>I thought the whole point of introducing some keyword was so that we can use protocol as type for those protocols that have associated type as a requirement and hence this should work. But it gives an error.</p>

<p>If anyone has any references or knowledge about this problem that they could share or possibly a solution for this it would be great.</p>

<p>Thanks in advance.</p>
","2506972","","","","","2019-09-30 00:56:04","Can I create a generic ObservableObject class which can be used by multiple ContentViews?","<ios><swift><swiftui><xcode11><combine>","3","3","1","","","CC BY-SA 4.0"
"58103186","1","58104451","","2019-09-25 16:52:16","","23","28552","<p>In my SwiftUI app, I need to get data from ObservedObject each time the value change. I understood that we could do that with .onReceive? I don't understand well the documentation of Apple about it. I don't know how I can do this.</p>
<p>My code:</p>
<pre><code>import SwiftUI
import CoreLocation

struct Compass: View {
  
  @StateObject var location = LocationManager()
  @State private var angle: CGFloat = 0
  
  var body: some View {
    VStack {
      Image(&quot;arrow&quot;)
        .resizable()
        .aspectRatio(contentMode: .fit)
        .frame(width: 300, height: 300)
        .modifier(RotationEffect(angle: -CGFloat(self.angle.degreesToRadians)))
        .onReceive(location, perform: {
          withAnimation(.easeInOut(duration: 1.0)) {
            self.angle = self.location.heading
          }
        })
      
      Text(String(self.location.heading.degreesToRadians))
        .font(.system(size: 20))
        .fontWeight(.light)
        .padding(.top, 15)
    }
  }
}

struct RotationEffect: GeometryEffect {
  var angle: CGFloat

  var animatableData: CGFloat {
    get { angle }
    set { angle = newValue }
  }

  func effectValue(size: CGSize) -&gt; ProjectionTransform {
    return ProjectionTransform(
      CGAffineTransform(translationX: -150, y: -150)
        .concatenating(CGAffineTransform(rotationAngle: angle))
        .concatenating(CGAffineTransform(translationX: 150, y: 150))
    )
  }
}
</code></pre>
<p>In my LocationManager class, I have a heading Published variable, this is the variable I want check.</p>
<p>I need to get data each time the value of heading change to create an animation when my arrow move. For some raisons I need to use CGAffineTransform.</p>
","7037428","","259521","","2020-12-28 16:30:21","2021-06-16 17:40:19","How can I get data from ObservedObject with onReceive in SwiftUI?","<swift><swiftui><combine>","4","0","5","","","CC BY-SA 4.0"
"58159101","1","58163243","","2019-09-29 20:51:37","","1","2559","<p>I am trying to leverage SwiftUI and Combine to store user defaults for my application. Looking at suggestions in a few other posts, I have updated my code as you see below.  However, I am now getting the error of ""Referencing instance method 'send()' on 'Subject' requires the types 'Setup' and 'Void' be equivalent"".  It has been suggested that I change ""Setup"" to void in the PassthroughSubject, however this then gives a hard crash in the app at startup - "" Fatal error: No observable object of type Setup.Type found.""</p>

<p>I am at a bit of loss... any pointers would be welcomed.</p>

<pre><code>    ==============  DataStoreClass ============

import SwiftUI
import Foundation
import Combine

class Setup: ObservableObject {

    private var notificationSubscription: AnyCancellable?

    let objectWillChange = PassthroughSubject&lt;Setup,Never&gt;()

    @UserDefault(key: ""keyValueBool"", defaultValue: false)
    var somevalueBool: Bool {
        didSet{
            objectWillChange.send()  // &lt;====== Referencing instance method 'send()' on 'Subject' requires the types 'Setup' and 'Void' be equivalent
        }
    }
    init() {

        notificationSubscription = NotificationCenter.default.publisher(for: UserDefaults.didChangeNotification).sink { _ in
                   self.objectWillChange.send()
        }
    }
}


============= property wrapper ===========
import Foundation

@propertyWrapper
struct UserDefault&lt;T&gt; {
    let key: String
    let defaultValue: T

    var wrappedValue: T {
        get {
            UserDefaults(suiteName: ""group.com.my.app"")!.value(forKey: key) as? T ?? defaultValue
        } set {
            UserDefaults(suiteName: ""group.com.my.app"")!.set(newValue, forKey: key)
        }
    }
}
</code></pre>
","373749","","","","","2019-09-30 07:23:16","Referencing instance method requires equivalency (SWIFT)","<swift><swiftui><combine>","3","1","1","","","CC BY-SA 4.0"
"58187541","1","58214122","","2019-10-01 14:58:06","","6","5772","<p>I have an AppState that can be observed:</p>

<pre><code>class AppState: ObservableObject {

    private init() {}
    static let shared = AppState()

    @Published fileprivate(set) var isLoggedIn = false

}
</code></pre>

<p>A View Model should decide which view to show based on the state (<code>isLoggedIn</code>):</p>

<pre class=""lang-swift prettyprint-override""><code>class HostViewModel: ObservableObject, Identifiable {

    enum DisplayableContent {
        case welcome
        case navigationWrapper
    }

    @Published var containedView: DisplayableContent = AppState.shared.isLoggedIn ? .navigationWrapper : .welcome

}
</code></pre>

<p>In the end a <code>HostView</code> observes the <code>containedView</code> property and displays the correct view based on it.</p>

<p>My problem is that <code>isLoggedIn</code> is not being observed with the code above and I can't seem to figure out a way to do it. I'm quite sure that there is a simple way, but after 4 hours of trial &amp; error I hope the community here can help me out.</p>
","6333824","","6333824","","2019-10-03 07:16:44","2020-07-20 16:47:40","Updating a @Published variable based on changes in an observed variable","<swift><combine>","4","3","3","","","CC BY-SA 4.0"
"58203531","1","61086087","","2019-10-02 14:24:38","","67","31259","<p>In imperative Swift, it is common to use computed properties to provide convenient access to data without duplicating state. </p>

<p>Let's say I have this class made for imperative MVC use:</p>

<pre class=""lang-swift prettyprint-override""><code>class ImperativeUserManager {
    private(set) var currentUser: User? {
        didSet {
            if oldValue != currentUser {
                NotificationCenter.default.post(name: NSNotification.Name(""userStateDidChange""), object: nil)
                // Observers that receive this notification might then check either currentUser or userIsLoggedIn for the latest state
            }
        }
    }

    var userIsLoggedIn: Bool {
        currentUser != nil
    }

    // ...
}
</code></pre>

<p>If I want to create a reactive equivalent with Combine, e.g. for use with SwiftUI, I can easily add <code>@Published</code> to stored properties to generate <code>Publisher</code>s, but not for computed properties. </p>

<pre class=""lang-swift prettyprint-override""><code>    @Published var userIsLoggedIn: Bool { // Error: Property wrapper cannot be applied to a computed property
        currentUser != nil
    }
</code></pre>

<p>There are various workarounds I could think of. I could make my computed property stored instead and keep it updated. </p>

<p>Option 1: Using a property observer:</p>

<pre class=""lang-swift prettyprint-override""><code>class ReactiveUserManager1: ObservableObject {
    @Published private(set) var currentUser: User? {
        didSet {
            userIsLoggedIn = currentUser != nil
        }
    }

    @Published private(set) var userIsLoggedIn: Bool = false

    // ...
}
</code></pre>

<p>Option 2: Using a <code>Subscriber</code> in my own class:</p>

<pre class=""lang-swift prettyprint-override""><code>class ReactiveUserManager2: ObservableObject {
    @Published private(set) var currentUser: User?
    @Published private(set) var userIsLoggedIn: Bool = false

    private var subscribers = Set&lt;AnyCancellable&gt;()

    init() {
        $currentUser
            .map { $0 != nil }
            .assign(to: \.userIsLoggedIn, on: self)
            .store(in: &amp;subscribers)
    }

    // ...
}
</code></pre>

<p>However, these workarounds are not as elegant as computed properties. They duplicate state and they do not update both properties simultaneously. </p>

<p>What would be a proper equivalent to adding a <code>Publisher</code> to a computed property in Combine?</p>
","5468365","","","","","2022-08-10 11:24:10","An equivalent to computed properties using @Published in Swift Combine?","<ios><swift><swiftui><reactive><combine>","7","5","13","","","CC BY-SA 4.0"
"58226604","1","58242311","","2019-10-03 20:41:42","","6","2788","<p>I follow a pattern in my Rx code, I usually have an Observable trigger which I flatMap to create another Observable for a network request. A simplified example:</p>

<pre><code>enum ViewModelError: Error {
  case bang
}

enum DataTaskError: Error {
  case bang
}

func viewModel(trigger: Observable&lt;Void&gt;,
               dataTask: Observable&lt;Result&lt;SomeType, DataTaskError&gt;&gt;) -&gt; Observable&lt;Result&lt;AnotherType, ViewModelError&gt;&gt; {
  let apiResponse = trigger
    .flatMap { dataTask }
}
</code></pre>

<p>The Combine equivalent I'm having some trouble with. I could use a Result as the Output type and use Never as the Failure type but that feels like a misuse of the API.</p>

<pre><code>func viewModel(trigger: AnyPublisher&lt;Void, Never&gt;,
               dataTask: AnyPublisher&lt;SomeType, DataTaskError&gt;) -&gt; AnyPublisher&lt;AnotherType, ViewModelError&gt; {
  let apiResponse = trigger
    .flatMap { dataTask }
}
</code></pre>

<p>I get a compilation error:</p>

<pre><code>Instance method 'flatMap(maxPublishers:_:)' requires the types 'Never' and 'DataTaskError' be equivalent
</code></pre>

<p>I could use mapError and cast both of the errors to Error, but I need a DataTaskError to be able to create my ViewModelError.</p>

<p>This feels like it shouldn't be so difficult, and it seems like a fairly common use case. I'm likely just misunderstanding some fundamentals, a point in the right direction would be greatly appreciated.</p>
","5165429","","","","","2019-11-07 23:56:49","How to flatMap two Publishers with different Failure types in Combine","<ios><swift><frp><combine>","1","4","1","","","CC BY-SA 4.0"
"58227096","1","58234908","","2019-10-03 21:26:04","","17","8449","<p>Is there a way to transform a given <code>AnyPublisher&lt;AnyType, SomeError&gt;</code> to <code>AnyPublisher&lt;AnyType, Never&gt;</code>?</p>
","5165429","","","","","2020-02-22 18:08:17","Set a given Publishers Failure type to Never in Combine","<ios><swift><frp><combine>","2","0","1","","","CC BY-SA 4.0"
"58228777","1","58229375","","2019-10-04 01:29:50","","5","1293","<p>I'm creating a new watchOS app using SwiftUI and Combine trying to use a MVVM architecture, but when my viewModel changes, I can't seem to get a Text view to update in my View.</p>

<p>I'm using watchOS 6, SwiftUI and Combine. I am using @ObservedObject and @Published when I believe they should be used, but changes aren't reflected like I would expect.</p>

<pre><code>// Simple ContentView that will push the next view on the navigation stack
struct ContentView: View {
    var body: some View {
        NavigationLink(destination: NewView()) {
            Text(""Click Here"")
        }
    }
}

struct NewView: View {
    @ObservedObject var viewModel: ViewModel

    init() {
        viewModel = ViewModel()
    }

    var body: some View {
        // This value never updates
        Text(viewModel.str)
    }
}

class ViewModel: NSObject, ObservableObject {
    @Published var str = """"
    var count = 0

    override init() {
        super.init()

        // Just something that will cause a property to update in the viewModel
        Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            self?.count += 1
            self?.str = ""\(String(describing: self?.count))""

            print(""Updated count: \(String(describing: self?.count))"")
        }
    }
}
</code></pre>

<p><code>Text(viewModel.str)</code> never updates, even though the viewModel is incrementing a new value ever 1.0s. I have tried <code>objectWillChange.send()</code> when the property updates, but nothing works. </p>

<p>Am I doing something completely wrong?</p>
","589019","","","","","2019-10-04 04:13:46","Why won't my SwiftUI Text view update when viewModel changes using Combine?","<watchkit><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"58251478","1","58278910","","2019-10-05 19:07:03","","7","6698","<p>I am trying to decode the downloaded JSON into a structure with the following code.</p>

<pre class=""lang-swift prettyprint-override""><code>static func request(url: URL) -&gt; AnyPublisher&lt;SomeDecodableStruct, Error&gt; {
    return URLSession.shared.dataTaskPublisher(for: url)
        .map { $0.data }
        .decode(type: SomeDecodableStruct.self, decoder: JSONDecoder())
        .eraseToAnyPublisher()
}
</code></pre>

<p>However, if processing fails, I would like you to return information on whether the request processing failed or the decoding processing failed.
Therefore, I defined the <code>FailureReason</code> enum that conforms to the <code>Error</code> protocol as follows.</p>

<pre class=""lang-swift prettyprint-override""><code>enum FailureReason : Error {
    case sessionFailed(error: URLError)
    case decodingFailed
}

static func request(url: URL) -&gt; AnyPublisher&lt;SomeDecodableStruct, FailureReason&gt; {
    // ???
}
</code></pre>

<p>How do I define a <code>request(url:)</code> that satisfies this <code>FailureReason</code>?</p>
","12169817","","","","","2019-10-08 01:00:48","What is the best way to handle errors in Combine?","<swift><swiftui><combine>","2","0","2","","","CC BY-SA 4.0"
"58260429","1","58260784","","2019-10-06 19:07:45","","0","630","<p>I am working on a SwiftUI screen that updates multiple values in the UserDefaults, to allow the app to persist basic settings.  I am trying to use Combine and SwiftUI, as this is a native WatchOS app.</p>

<p>The basic View is giving me an error that I believe has to do with the propertyWrapper for UserDefaults, but as I have never worked with propertyWrappers (or Combine for that matter) I am un able to figure out how to fix this. </p>

<p>here's the property wrapper:</p>

<pre><code>import Foundation

@propertyWrapper
struct UserDefault&lt;T&gt; {
    let key: String
    let defaultValue: T

    init(_ key: String, defaultValue: T) {
        self.key = key
        self.defaultValue = defaultValue
    }

    var wrappedValue: T {
        get {
            UserDefaults(suiteName: ""group.com.my.app"")!.value(forKey: key) as? T ?? defaultValue
        } set {
            UserDefaults(suiteName: ""group.com.my.app"")!.set(newValue, forKey: key)
        }
    }
}
</code></pre>

<p>As you can see it wraps all the Key Pairs for the UserDefaults.</p>

<p>My class is similarly very simple, consisting of two bools and a double</p>

<pre><code>import SwiftUI
import Foundation
import Combine

class Setup: ObservableObject {

    private var notificationSubscription: AnyCancellable?

    let objectWillChange = PassthroughSubject&lt;Setup,Never&gt;()

    @UserDefault(""keyOpt1Enabled"", defaultValue: false)
    var opt1Enabled: Bool {
        willSet{
            objectWillChange.send(self)
        }
    }

    @UserDefault(""keyOpt2Enabled"", defaultValue: false)
    var opt2Enabled: Bool {
        willSet{
            objectWillChange.send(self)
        }
    }

    @UserDefault(""keyValueDouble"", defaultValue: Double(0.00))
    var someValueDouble: Double {
        willSet{
            objectWillChange.send(self)
        }

    }
    init() {

        notificationSubscription = NotificationCenter.default.publisher(for: UserDefaults.didChangeNotification).sink { _ in
                   self.objectWillChange.send(self)
        }
    }
}
</code></pre>

<p>The problem is that in SwiftUI I am using a TextField to allow for entering and updating the double value</p>

<pre><code>
    @ObservedObject var setup: Setup = Setup()

    private var currencyFormatter: NumberFormatter = {
        let f = NumberFormatter()
        f.numberStyle = .currency
        return f
    }()


    var body: some View {
        ScrollView{
            HStack{
                TextField(self.$setup.someValueDouble,
                          formatter: currencyFormatter,
                          placeholder: ""0.00"",
                          onEditingChanged: {_ in
                            print(""editing changed"")
                          },
                          onCommit: {
                            print(""updated"")
                            }
                )
            }

            HStack{
                Button(action: {
                    self.setup.opt1Enabled = false
                    self.setup.opt2Enabled = true
                } ) {
                    Text(verbatim: ""Opt 1"")
                        .font(Font.system(size: 16, design: Font.Design.rounded))
                }
                .background(setup.opt1Enabled ? Color.blue : Color.gray)
                .disabled(self.setup.opt1Enabled)
                .cornerRadius(5)

                Button(action: {
                    self.setup.opt1Enabled = true
                    self.setup.opt2Enabled = false
                }) {
                    Text(verbatim: ""Opt 2"")
                }
                .background(setup.opt2Enabled ? Color.blue : Color.gray)
                .disabled(self.setup.opt2Enabled)
            }
        }
    }
}
</code></pre>

<p>The TextField then gives the message that the Generic parameter 'Label' could not be inferred. Xcode offers to ""Fix"" this but the end results is TextField which is obviously incomplete, but the only view in this whole program is ""ContentView"" which is invalid.</p>
","373749","","","","","2019-10-06 19:58:34","Cannot invoke initializer for type 'TextField<_>' with propertyWrapper of UseDefaults","<properties><wrapper><swiftui><combine>","1","0","2","","","CC BY-SA 4.0"
"58289023","1","58289157","","2019-10-08 14:58:46","","4","524","<p>I tried to make a timer on SwiftUI, which worked just fine:</p>

<pre><code>import SwiftUI
import Combine    
struct ContentView: View {
let currentTimePublisher  = Timer.TimerPublisher(interval: 1.0, runLoop: .main, mode: .default)
    .autoconnect()

@State private var currentTime = Date()
var body: some View {

    VStack{
        Text(""Time is:"")
        Text(""\(currentTime)"")
        }.onReceive(currentTimePublisher) { (date) in
            self.currentTime = date
        }
    }
}
</code></pre>

<p>However, I tried to put the VStack in anything scrollable, be List, or ScrollView, I was not updating when I was scrolling the screen. It worked just fine when I didn't scroll.</p>

<p>I also put the TimerPublisher on the main thread as you can see, but that didn't change anything.</p>

<p>How can I make the SwiftUI update the time while I'm scrolling/interacting?</p>
","6276472","","77567","","2019-10-08 16:11:17","2019-10-08 16:11:17","Timer.TimerPublisher doesn’t fire while scrolling","<ios><swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"58297176","1","58297743","","2019-10-09 04:42:15","","28","6800","<p>I'm building an app using SwiftUI and would like a way to convert a <code>Binding&lt;Value?&gt;</code> to a <code>Binding&lt;Value</code>>.</p>

<p>In my app I have an <code>AvatarView</code> which knows how to render an image for a particular user.</p>

<pre class=""lang-swift prettyprint-override""><code>struct AvatarView: View {
  @Binding var userData: UserData

  ...
}
</code></pre>

<p>My app holds a <code>ContentView</code> that owns two bindings: a dictionary of users by id, and the id of the user whose avatar we should be showing.</p>

<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
  @State var userById: Dictionary&lt;Int, UserData&gt;
  @State var activeUserId: Int

  var body: some View {
    AvatarView(userData: $userById[activeUserId])
  }
}
</code></pre>

<p>Problem: the above code doesn't combine because <code>$userById[activeUserId]</code> is of type <code>Binding&lt;UserData?&gt;</code> and <code>AvatarView</code> takes in a <code>Binding&lt;UserData&gt;</code>.</p>

<p>Things I tried...</p>

<ul>
<li><p><code>$userById[activeUserId]!</code> doesn't work because it's trying to unwrap a <code>Binding&lt;UserData?&gt;</code>. You can only unwrap an <code>Optional</code>, not a <code>Binding&lt;Optional&gt;</code>.</p></li>
<li><p><code>$(userById[activeUserId]!)</code> doesn't work for reasons that I don't yet understand, but I think something about <code>$</code> is resolved at compile time so you can't seem to prefix arbitrary expressions with <code>$</code>.</p></li>
</ul>
","1026198","","1026198","","2019-10-09 05:12:20","2019-10-09 09:03:12","How can I unwrap an optional value inside a binding in Swift?","<ios><swift><swiftui><combine>","1","2","9","","","CC BY-SA 4.0"
"58331932","1","58391367","","2019-10-10 22:31:11","","0","1261","<p>I’m trying to learn Swift, SwiftUI, and Combine and am new to iOS in general. Eventually I want to have a list that you can search, filter, and sort.</p>

<p>So far I have filtering working when I use <code>onEditingChanged</code> within the TextField but that requires hitting enter. I just can’t figure out how to trigger <code>activePeople</code> to update when the TextField <code>filterText</code>  changes so that the <code>activePeople</code> list filters <em>while</em> you type.</p>

<p>I’ve gotten a version to work when I filter the list within a ForEach in the view (see commented out code) but eventually the filtering and sorting will get more complicated and it seems to make more sense to have it outside of that view. Let me know if this is not the right approach for whatever reason.</p>

<p>Here’s the code so far:</p>

<pre><code>import Combine
import SwiftUI

class Model: ObservableObject {
    @Published var filterText: String = “”
    @Published var activePeople: [Person] = []

    private var allPeople : [Person] = [
        Person( id: 1000, name: “Alexa” ),
        Person( id: 1001, name: “Anaïs” ),
        Person( id: 1002, name: “Earl” ),
        Person( id: 1003, name: “Elba” ),
        Person( id: 1004, name: ""Emil” ),
        Person( id: 1005, name: “Janeth” ),
        Person( id: 1006, name: “Joselyn” ),
        Person( id: 1007, name: “Lupita” ),
        Person( id: 1008, name: “Mellie” ),
        Person( id: 1009, name: “Vanita” ),
    ]

    init() {
        activePeople = allPeople
    }

    func filterList() {
        if ( filterText == “” ) {
            activePeople = allPeople
        } else {
            activePeople = allPeople.filter( { $0.name.localizedStandardContains( filterText ) } )
        }
    }

}

struct Person: Identifiable {
    var id: Int
    var name: String
}

</code></pre>

<pre><code>import SwiftUI

struct ContentView: View {
    @EnvironmentObject private var model: Model

    var body: some View {
        VStack {
            Form {
                Section {
                    TextField(“Filter Text”, text: $model.filterText, onEditingChanged: {_ in self.model.filterList()}
                    )
                }
                Section {
                    Text( ""Filtered by: \(model.filterText)” )
                    ForEach( model.activePeople ) { person in
//                        if ( self.model.filterText == “” || person.name.localizedStandardContains( self.model.filterText )) {
                            Text( person.name )
//                        }
                    }
                }
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
            .environmentObject(Model())
    }

}

</code></pre>
","12197617","","","","","2019-10-15 09:23:52","How do you have a TextField value change trigger an update to another piece of data in SwiftUI?","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"58332467","1","58332754","","2019-10-10 23:47:52","","4","876","<p>I am currently getting a list of sites from a Firebase Firestore and then returning them to a list in SwiftUI.  Each list item has a label and Toggle.  The list of sites is dynamic so could be anywhere from 1-30+.  How can I create an @State or similar bindable to observe each toggle's state.</p>

<p>I am currently rendering to UI with the following</p>

<pre class=""lang-swift prettyprint-override""><code>@State private var SiteA = false
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>Form {
     Section (header: Text(""Select Sites"")) {
     ForEach(siteData.sites) { site in
         HStack {
             Toggle(isOn: self.$SiteA) {
                 Text(site.name)
                 Spacer()
             }
         }
     }
     }
}
</code></pre>

<p>Sites are retrieved using a Bindable object</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine
import Firebase
import FirebaseFirestore

struct Message: Identifiable {
    var title: String
    var messageBody: String
    var sentBy: String
    var targetSite: String
    var expired: Bool
    var timeStamp: Timestamp
    var emergency: Bool
    var id: String
}

struct Site: Identifiable {
    var id: String
    var name: String
}

class FirestoreMessages : ObservableObject {
    var db = Firestore.firestore()
    var didChange = PassthroughSubject&lt;FirestoreMessages, Never&gt;()
    @Published var messages: [Message] = [] {
        didSet{ didChange.send(self) }
    }
    @Published var sites: [Site] = [] {
        didSet { didChange.send(self) }
    }

    func listen() {
        db.collection(""messages"")
            .whereField(""expired"", isEqualTo: false)
            .addSnapshotListener { (snap, error) in
            if error != nil {
                print(""Firebase Snapshot Error: \(error?.localizedDescription ?? """")"")
            } else {

                self.messages.removeAll()

                for doc in snap!.documents {
                    let title = doc[""title""] as! String
                    let messageBody = doc[""body""] as! String
                    let sentBy = doc[""sentBy""] as! String
                    let targetSite = doc[""targetSite""] as! String
                    let expired = doc[""expired""] as! Bool
                    let timeStamp = doc[""timeStamp""] as! Timestamp
                    let emergency = doc[""emergency""] as! Bool
                    let id = doc.documentID

                    let message = Message(
                        title: title,
                        messageBody: messageBody,
                        sentBy: sentBy,
                        targetSite: targetSite,
                        expired: expired,
                        timeStamp: timeStamp,
                        emergency: emergency,
                        id: id)

                    self.messages.append(message)
                }
            }
        }
    }

    func getSites() {
        db.collection(""sites"")
            .order(by: ""name"", descending: false)
            .getDocuments() { (querySnapshot, err) in
            if let err = err {
                print(""Error getting docs: \(err)"")
            } else {
                self.sites.removeAll()

                for document in querySnapshot!.documents {
                    let doc = document.data()

                    let id = document.documentID
                    let name = doc[""name""] as! String

                    let site = Site(id: id, name: name)

                    self.sites.append(site)
                }
            }
        }
    }
}
</code></pre>

<p>How can I create an <code>@State</code> unique to each list item to monitor their states individually?</p>
","4889516","","","","","2019-10-12 15:19:13","SwiftUI - Dynamically add @State for UI Toggle","<swift><swiftui>","1","0","1","","","CC BY-SA 4.0"
"58353161","1","58408210","","2019-10-12 10:25:47","","3","2140","<p>I'm having a problem of updates in my application.
I can't understand very well what is going on with the data flow between the subviews.</p>

<h2>This is my current structure</h2>

<ul>
<li><p><strong>ViewModel</strong>: ObsebsrvableObject</p></li>
<li><p><strong>MainView</strong> with ObservedObject (viewModel)</p>

<ul>
<li><strong>ChildView</strong> with a list from MainView observed object (just the list is passed as a normal array - not bindable)

<ul>
<li><strong>NephewView</strong> with the list passed to the childView, still as a normal array</li>
</ul></li>
</ul></li>
</ul>

<h2>What is happening:</h2>

<p>Every time I modify the list, the MainView updates triggering a new rebuild of ChildView, but the NephewView does not update</p>

<h2>What I would like to have:</h2>

<p>I would like to update the Main, the Child and the NephewView views every time the observedObject get an update</p>

<h2>Problem:</h2>

<p>I can't understand why if the Child View rebuild, the nephew doesn't.</p>

<h2>Example Code</h2>

<pre><code>class ViewModel: ObservableObject {

    let userData = UserData.shared

    var canceller: AnyCancellable?

    @Published var items: [Items]


    init() {
      items = []
      canceller = userData.objectWillChange
        .throttle(for: 5, scheduler: RunLoop.main, latest: true)
        .sink(receiveCompletion: { data  in
            DispatchQueue.main.async { [weak self] in
                guard let self = self else { return }
                self.items = data.items
            }
        },
        receiveValue: { _ in
            DispatchQueue.main.async { [weak self] in
                guard let self = self else { return }
                self.items = data.items
            }
        })
   }
 }

struct MainView: View {

  @ObservedObject var model = ViewModel()


  var body: some View {
      ChildView(items: model.items)
  }
}

struct ChildView: View {

  let items: [Items]


  var body: some View {
      NephewView(items: items)
  }
}

struct NephewView: View {

  let items: [Items]

  var body: some View {
      List...
  }
}
</code></pre>

<p>The sink works properly, it's just the UI part that does not get updates.
Maybe the way I'm updating the publisher is wrong?</p>
","6747915","","6747915","","2019-10-12 11:41:35","2019-10-16 07:42:41","iOS SwiftUI: Data Flow Flow in Subviews @ObservedObject","<ios><swift><swiftui><combine>","1","3","1","","","CC BY-SA 4.0"
"58364345","1","59198850","","2019-10-13 14:10:08","","1","1621","<p>In RxSwift we can check if a <code>*Subject</code> has any observer, using <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Subjects/PublishSubject.swift#L24-L29"" rel=""nofollow noreferrer""><code>hasObserver</code></a>, how can I do this in Combine on e.g. a <code>PassthroughSubject</code>?</p>
","1311272","","","","","2019-12-05 15:54:56","Swift Combine: Check if Subject has observer?","<swift><rx-swift><combine>","2","0","","","","CC BY-SA 4.0"
"58364436","1","58368290","","2019-10-13 14:20:30","","3","1807","<p>How can I convert a publisher of array a certain element, to just a publisher of said element (but with more events)?</p>

<p>e.g. how can I convert</p>

<p><code>AnyPublisher&lt;[Int], Never&gt;</code> to <code>AnyPublisher&lt;Int, Never&gt;</code>?</p>

<p>I think maybe what RxSwift offers with its <a href=""https://github.com/ReactiveX/RxSwift/blob/c6c0c540109678b96639c25e9c0ebe4a6d7a69a9/RxSwift/Observables/Sequence.swift#L34-L36"" rel=""nofollow noreferrer""><code>from</code> operator</a> is similar to what I want to do.</p>

<p>I guess I want the inverse of Combine <a href=""https://developer.apple.com/documentation/combine/publisher/3204692-collect"" rel=""nofollow noreferrer""><code>collect</code></a>?</p>
","1311272","","1311272","","2019-10-13 14:27:33","2021-03-19 09:56:19","Swift Combine: How can I convert `AnyPublisher<[Foo], *>` to `AnyPublisher<Foo, *>`?","<swift><rx-swift><combine>","2","0","1","","","CC BY-SA 4.0"
"58383895","1","61035663","","2019-10-14 20:49:36","","12","4746","<p>I have some code that is built using RxSwift, and I'm playing around with converting it to use Apple's Combine framework.</p>

<p>One pattern which is very common is the use of <code>Observable.create</code> for one-shot observables (usually network requests). Something like this:</p>

<pre><code>func loadWidgets() -&gt; Observable&lt;[Widget]&gt; {
  return Observable.create { observer in
    // start the request when someone subscribes
    let loadTask = WidgetLoader.request(""allWidgets"", completion: { widgets in
      // publish result on success
      observer.onNext(widgets)
      observer.onComplete()
    }, error: { error in
      // publish error on failure
      observer.onError()
    })
    // allow cancellation
    return Disposable {
      loadTask.cancel()
    }
  }
}
</code></pre>

<p>I'm trying to map that across to Combine and I haven't been able to quite figure it out. The closest I've been able to get is using Future for something like this:</p>

<pre><code>func loadWidgets() -&gt; AnyPublisher&lt;[Widget], Error&gt; {
  return Future&lt;[Widget], Error&gt; { resolve in
    // start the request when someone subscribes
    let loadTask = WidgetLoader.request(""allWidgets"", completion: { widgets in
      // publish result on success
      resolve(.success(widgets))
    }, error: { error in
      // publish error on failure
      resolve(.failure(error))
    })
    // allow cancellation ???
  }
}
</code></pre>

<p>As you can see, it does most of it, but there's no ability to cancel.
Secondarily, future doesn't allow multiple results.</p>

<p>Is there any way to do something like the Rx <code>Observable.create</code> pattern which allows cancellation and optionally multiple results?</p>
","234","","","","","2020-04-04 22:35:30","Swift Combine alternative to Rx Observable.create","<swift><combine>","3","0","3","","","CC BY-SA 4.0"
"58403338","1","58983628","","2019-10-15 22:23:48","","22","4991","<p>I would like to use Combine's <a href=""https://developer.apple.com/documentation/combine/published"" rel=""noreferrer""><code>@Published</code></a> attribute to respond to changes in a property, but it seems that it signals before the change to the property has taken place, like a <code>willSet</code> observer. The following code:</p>

<pre><code>import Combine

class A {
    @Published var foo = false
}

let a = A()
let fooSink = a.$foo.dropFirst().sink { _ in // `dropFirst()` is to ignore the initial value
    print(""foo is now \(a.foo)"")
}

a.foo = true
</code></pre>

<p>outputs:</p>

<blockquote>
  <p>foo is now false</p>
</blockquote>

<p>I'd like the sink to run after the property has changed like a <code>didSet</code> observer so that <code>foo</code> would be true at that point. Is there an alternative publisher that signals then, or a way of making <code>@Published</code> work like that?</p>
","98286","","","","","2022-07-06 09:15:22","Is there an alternative to Combine's @Published that signals a value change after it has taken place instead of before?","<swift><combine>","5","0","5","","","CC BY-SA 4.0"
"58406287","1","58406402","","2019-10-16 05:28:47","","85","18426","<p>I have a SwiftUI view that takes in an EnvironmentObject called <code>appModel</code>. It then reads the value <code>appModel.submodel.count</code> in its <code>body</code> method. I expect this to bind my view to the property <code>count</code> on <code>submodel</code> so that it re-renders when the property updates, but this does not seem to happen.</p>

<p>Is this a bug? And if not, what is the idiomatic way to have views bind to nested properties of environment objects in SwiftUI?</p>

<p>Specifically, my model looks like this...</p>

<pre><code>class Submodel: ObservableObject {
  @Published var count = 0
}

class AppModel: ObservableObject {
  @Published var submodel: Submodel = Submodel()
}
</code></pre>

<p>And my view looks like this...</p>

<pre><code>struct ContentView: View {
  @EnvironmentObject var appModel: AppModel

  var body: some View {
    Text(""Count: \(appModel.submodel.count)"")
      .onTapGesture {
        self.appModel.submodel.count += 1
      }
  }
}
</code></pre>

<p>When I run the app and click on the label, the <code>count</code> property does increase but the label does not update.</p>

<p>I can fix this by passing in <code>appModel.submodel</code> as a property to <code>ContentView</code>, but I'd like to avoid doing so if possible.</p>
","1026198","","","","","2022-06-25 19:05:02","How to tell SwiftUI views to bind to nested ObservableObjects","<ios><swift><swiftui><combine>","14","2","27","","","CC BY-SA 4.0"
"58428623","1","58431723","","2019-10-17 08:54:07","","1","800","<p>I've tried the example from the <a href=""https://developer.apple.com/documentation/combine/observableobject#3374830"" rel=""nofollow noreferrer"">ObservableObject documentation</a>.</p>

<pre class=""lang-swift prettyprint-override""><code>class Contact: ObservableObject {
    @Published var name: String = ""me""
    @Published var age: Int = 7
}
</code></pre>

<p>When I make a Swift Playground with the code:</p>

<pre class=""lang-swift prettyprint-override""><code>let c = Contact()
c.objectWillChange.sink { print(""This prints"") }
c.age += 1
</code></pre>

<p><code>objectWillChange</code> triggers and the line prints.</p>

<p>So far so good.</p>

<p>I now make a View in SwiftUI:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
    @ObservedObject var contact = Contact
    ...
</code></pre>

<p>I create this View in the AppDelegate, and do:</p>

<pre class=""lang-swift prettyprint-override""><code>   contentView.contact.objectWillChange.sink { print(""This doesn't print."") }
</code></pre>

<p>I've connected the contact to various controls, and changing any fields updates all the controls. Doing <code>onReceive(contact.objectWillChange)</code> also works fine. But not connecting to it in the AppDelegate. I've tried logging <code>deinit()</code> to make sure we're talking about the same object. I've tried using <code>ImmediateScheduler</code>. No dice. Why is this not working?</p>
","163983","","","","","2019-10-17 11:36:25","SwiftUI: Why doesn't ObservedObject work in AppDelegate?","<swift><macos><swiftui><appkit><combine>","1","4","","","","CC BY-SA 4.0"
"58437861","1","58440744","","2019-10-17 17:27:11","","14","4321","<p>I have two classes nested in another class, which is an observable object in a SwiftUI view. Even though properties in the nested classes are declared as @Published, their values (when they change) do not update in the main view.</p>

<p>A similar question has been asked here, and I could use it to get it to work for one of the two subclasses, but not both.</p>

<p><a href=""https://stackoverflow.com/questions/58406287/how-to-tell-swiftui-views-to-bind-to-nested-observableobjects"">How to tell SwiftUI views to bind to nested ObservableObjects</a></p>

<p>This is the model:</p>

<pre><code>class Submodel1: ObservableObject {
  @Published var count = 0
}

class Submodel2: ObservableObject {
  @Published var count = 0
}

class Model: ObservableObject {
  @Published var submodel1: Submodel1 = Submodel1()
  @Published var submodel2: Submodel2 = Submodel2()
}
</code></pre>

<p>And this is the main view:</p>

<pre><code>struct ContentView: View {
  @ObservedObject var model: Model = Model()

  var body: some View {
    VStack {
      Text(""Count: \(model.submodel1.count)"")
        .onTapGesture {
          self.model.submodel1.count += 1
        }
      Text(""Count: \(model.submodel2.count)"")
        .onTapGesture {
          self.model.submodel2.count += 1
        }
    }
  }
}
</code></pre>

<p>Adding this to the model class (see previous Stackoverflow question) works for updating on submodel1 changes, but not both:</p>

<pre><code>  var anyCancellable: AnyCancellable? = nil
  init() {
      anyCancellable = submodel1.objectWillChange.sink { (_) in
          self.objectWillChange.send()
      }
   }
</code></pre>

<p>What I'm looking for is some way to pass on changes of both the submodel1 and submodel2 to my view.</p>
","12234199","","","","","2019-10-17 21:17:32","How to tell SwiftUI views to bind to more than one nested ObservableObject","<ios><swift><swiftui><combine>","1","1","7","","","CC BY-SA 4.0"
"58442827","1","58454328","","2019-10-18 01:40:54","","6","8661","<p>I have created a custom text field and I'd like to take advantage of Combine. In order to be notified whenever text changes in my text field, I currently use a custom modifier. It works well, but I want this code could inside my CustomTextField struct. </p>

<p>My CustomTextField struct conforms to UIViewRepresentable. Inside this struct, there is a NSObject class called Coordinator and it conforms to UITextFieldDelegate. </p>

<p>I'm already using other UITextField delegate methods, but couldn't find one that does exactly what I already do with my custom modifier. Some methods are close, but don't quite behave the way I want them to. Anyway, I feel it would be best to put this new custom textFieldDidChange method in the Coordinator class. </p>

<p><strong>Here is my custom modifier</strong></p>

<pre><code>private let textFieldDidChange = NotificationCenter.default
    .publisher(for: UITextField.textDidChangeNotification)
    .map { $0.object as! UITextField}


struct CustomModifer: ViewModifier {

     func body(content: Content) -&gt; some View {
         content
             .tag(1)
             .onReceive(textFieldDidChange) { data in

                //do something

             }
    }
}
</code></pre>

<p>My CustomTextField is used in a SwiftUI view, with my custom modifier attached to it. I’m able to do things when ever there are changes to the text field. The modifier is also using Combine. It works great, but I don't want this functionality to be in the form of a modifier. I want to use it in my Coordinator class, along with my UITextFieldDelegate methods.</p>

<p><strong>This is my CustomTextField</strong></p>

<pre><code>struct CustomTextField: UIViewRepresentable {

    var isFirstResponder: Bool = false
    @EnvironmentObject var authenticationViewModel: AuthenticationViewModel

    func makeCoordinator() -&gt; Coordinator {
        return Coordinator(authenticationViewModel: self._authenticationViewModel)
    }

    class Coordinator: NSObject, UITextFieldDelegate {

        var didBecomeFirstResponder = false
        @EnvironmentObject var authenticationViewModel: AuthenticationViewModel

        init(authenticationViewModel: EnvironmentObject&lt;AuthenticationViewModel&gt;)
        {
            self._authenticationViewModel = authenticationViewModel
        }

        // Limit the amount of characters that can be typed in the field
        func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool {

            let currentText = textField.text ?? """"
            guard let stringRange = Range(range, in: currentText) else { return false }
            let updatedText = currentText.replacingCharacters(in: stringRange, with: string)
            return updatedText.count &lt;= 14
        }

        /* I want to put my textFieldDidChange method right here */

        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * */


        func textFieldDidEndEditing(_ textField: UITextField) {

            textField.resignFirstResponder()
            textField.endEditing(true)
        }

    }

    func makeUIView(context: Context) -&gt; UITextField {

        let textField = UITextField()
        textField.delegate = context.coordinator
        textField.placeholder = context.coordinator.authenticationViewModel.placeholder
        textField.font = .systemFont(ofSize: 33, weight: .bold)
        textField.keyboardType = .numberPad

        return textField
    }

    func updateUIView(_ uiView: UITextField, context: Context) {

        let textField = uiView
        textField.text = self.authenticationViewModel.text
    }
}

struct CustomTextField_Previews: PreviewProvider {

    static var previews: some View {
        CustomTextField()
            .previewLayout(.fixed(width: 270, height: 55))
            .previewDisplayName(""Custom Textfield"")
            .previewDevice(.none)
    }
}
</code></pre>

<p>I've been watching videos about Combine and I'd like to start utilising it in a new app I'm building. I really think it's the right thing to use in this situation, but still not quite sure how to pull this off. I'd really appreciate an example.</p>

<p><strong>To summarise:</strong></p>

<p>I want to add a function called textFieldDidChange to my Coordinator class, and it should be triggered every time there is a change to my text field. It must utilise Combine.</p>

<p>Thanks in advance</p>
","439688","","439688","","2019-10-18 17:34:33","2020-05-22 14:08:05","How can I use Combine to track UITextField changes in a UIViewRepresentable class?","<swift><uitextfield><swiftui><uitextfielddelegate><combine>","3","4","6","","","CC BY-SA 4.0"
"58448055","1","58448734","","2019-10-18 09:36:33","","0","449","<p>I would like to assign a result form a notification center publisher to the variable <code>alert</code>. The Error that I get is:</p>

<pre><code>Cannot use instance member 'alerts' within property initializer; property initializers run before 'self' is available
</code></pre>

<p>Could Someone help me out here?</p>

<pre><code>import Foundation
import SwiftUI
import Combine

final class PublicAlerts: ObservableObject{

    init () {
        fetchAlerts()
    }

    var alerts = [String](){
        didSet {
            didChange.send(self)
        }
    }

    private func fetchPublicAssets(){
        backEndService().fetchAlerts()
    }

    let publicAssetsPublisher = NotificationCenter.default.publisher(for: .kPublicAlertsNotification)
        .map { notification in
            return notification.userInfo?[""alerts""] as! Array&lt;String&gt;
        }.sink {result in
            alerts = result
        }

    let didChange = PassthroughSubject&lt;PublicAlerts, Never&gt;()
}
</code></pre>

<p>Later I will use <code>alerts</code> this in SwiftUI as a List </p>
","4129110","","","","","2019-10-18 10:14:17","How to assign sink result to variable","<swift><swiftui><nsnotificationcenter><combine>","1","0","","","","CC BY-SA 4.0"
"58469965","1","58470201","","2019-10-20 04:10:03","","1","221","<p>I had a problem with JSON decoding. I understand why the error occurs, but I don’t understand how to fix it. Most likely the error is in extra square brackets somewhere in the model. Model obtained from quicktype.io</p>

<pre><code>import Combine
import SwiftUI

class NewsAPI: ObservableObject {

    @Published var articles: Articles = [Article]()

    func loadNews() {
        guard let url: URL = URL(string: ""https://newsapi.org/v2/top-headlines?country=ru&amp;category=technology&amp;apiKey=376a97643c6c4633afe57427b71e8ebd"") else { return }
        URLSession.shared.dataTask(with: url) { (data, response, error) in
            do {
                guard let json = data else { return }
                let swift = try JSONDecoder().decode(Articles.self, from: json)
                DispatchQueue.main.async {
                    self.articles = swift
                }
            }
            catch {
                print(error)
            }
        }
        .resume()
    }
}

import Foundation

public typealias Articles = [Article]

public struct Welcome: Codable, Hashable {
    public let status: String?
    public let totalResults: Int?
    public let articles: [Article]?

    public init(status: String?, totalResults: Int?, articles: [Article]?) {
        self.status = status
        self.totalResults = totalResults
        self.articles = articles
    }
}

public struct Article: Codable, Hashable {
    public let source: Source?
    public let author: String?
    public let title: String?
    public let articleDescription: String?
    public let url: String?
    public let urlToImage: String?
    public let publishedAt: Date?
    public let content: String?

    enum CodingKeys: String, CodingKey {
        case source, author, title
        case articleDescription
        case url, urlToImage, publishedAt, content
    }

    public init(source: Source?, author: String?, title: String?, articleDescription: String?, url: String?, urlToImage: String?, publishedAt: Date?, content: String?) {
        self.source = source
        self.author = author
        self.title = title
        self.articleDescription = articleDescription
        self.url = url
        self.urlToImage = urlToImage
        self.publishedAt = publishedAt
        self.content = content
    }
}

public struct Source: Codable, Hashable {
    public let id: String?
    public let name: String?

    public init(id: String?, name: String?) {
        self.id = id
        self.name = name
    }
}
</code></pre>
","12245359","","1226963","","2019-10-20 04:23:29","2019-10-20 05:16:58","Error decoding JSON. typeMismatch(Swift.Array<Any>, Swift.DecodingError","<json><swift><codable>","1","0","","","","CC BY-SA 4.0"
"58477630","1","58508396","","2019-10-20 21:50:33","","0","522","<p>I have two views - a MasterView and DetailView. When opening the DetailView, I initialise a new class that tracks data about the view (in the real implementation, the detail view involves a game).</p>

<p>However, when I press the back button from the DetailView to return to the MasterView, and then press the button to return to the DetailView, my class is unchanged. However, I would like to re-initialise a new copy of this class (in my case to re-start the game) whenever I move from the MasterView to the DetailView.</p>

<p>I have condensed the problem to this code:</p>

<pre><code>import SwiftUI
import Combine

class Model: ObservableObject {
    @Published var mytext: String = ""mytext""
}

struct MasterView: View {
    var body: some View {
        NavigationView {
            NavigationLink(destination: DetailView(model: Model())) {
                Text(""press me"")
            }
        }
    }
}

struct DetailView: View {
    @ObservedObject var model: Model = Model()

    var body: some View {
        TextField(""Enter here"", text: $model.mytext)
    }
}


struct MasterView_Previews: PreviewProvider {
    static var previews: some View {
        MasterView()
    }
}
</code></pre>

<p>I would like to create a new instance of <code>Model</code> every time I click the NavigationLink to the detail view, but it seems like it always refers back to the same original instance - I can see this by typing a change into the text field of the DetailView, which persists if I go back and forward again.</p>

<p>Is there any way of doing this?</p>
","12234199","","","","","2019-10-22 16:13:48","How to re-initialise classes in a SwiftUI NavigationView","<ios><swift><swiftui>","1","6","","","","CC BY-SA 4.0"
"58493262","1","58494465","","2019-10-21 19:54:46","","1","919","<p>Is there a way to use Combine to Encode an object to <code>urlRequest.httpBody</code> or return the error from decoding as AnyPublisher with a certain error type.</p>

<p>I'm unable to get this to work and there seems to be no code examples for encoding objects using combine. Having to force cast the encoding error to be AnyPublisher doesn't seem right / is unsafe.</p>

<p>Thanks</p>

<pre><code>func create(object: ExampleObject, token: Token) -&gt; AnyPublisher&lt;ExampleObject, API.Error&gt; {

    let url = API.EndPoint.players.url
    var urlRequest = URLRequest(url: url)
    urlRequest.httpMethod = ""POST""
    urlRequest.addValue(""application/json"", forHTTPHeaderField: ""Content-Type"")
    urlRequest.addValue(""Bearer \(token)"", forHTTPHeaderField: ""Authorization"")
    do {
        // is there a safe combine way to encode this
        urlRequest.httpBody = try JSONEncoder().encode(object)
    } catch {
        // Is there a better way to handle this
        return error as! AnyPublisher&lt;ExampleObject, API.Error&gt;
    }

    return session
        .dataTaskPublisher(for: urlRequest)
        .map(\.data)
        .decode(type: ExampleObject.self, decoder: JSONDecoder())
        .mapError { error in
            switch error {
            case is URLError:
                return API.Error.addressUnreachable
            default:
                return API.Error.invalidResponse
            }
        }
        .eraseToAnyPublisher()
}
</code></pre>
","6049579","","","","","2019-10-21 21:38:51","Using Combine to encode object to httpBody in URLRequest","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"58498567","1","58728403","","2019-10-22 06:51:16","","1","243","<p>I tried to make a generic method that takes in a <code>TopLevelEncoder</code> and a <code>TopLevelDecoder</code> in order to make it injectable (eg. <code>JSONEncoder</code> in production code and <code>CustomEncoder</code> for testing). Since both of the protocols have associated types I have constraint their type rather than just doing <code>encoder: TopLevelEncoder = JSONEncoder()</code>. I came up with this method:</p>

<pre><code>func test&lt;Encoder, Decoder&gt;(
    encoder: Encoder = JSONEncoder(),
    decoder: Decoder = JSONDecoder()
) where Encoder: TopLevelEncoder, Decoder: TopLevelDecoder {
    //encode and decode
}
</code></pre>

<p>The compiler gives me following error message: <code>Default argument value of type 'JSONEncoder' cannot be converted to type 'Encoder'</code>. I don't understand how it can not be converted to type <code>Encoder</code> since <code>JSONEncoder</code> inherits from <code>TopLevelEncoder</code>.</p>

<p>I might be misunderstanding how generics and <code>associatedType</code> work but I can't wrap my head around this error message either. Could someone help me out?</p>

<p>I have seen other approaches for this problem like creating a new protocol like <code>AnyEncoder</code> and extend <code>JSONEncoder</code> with it. But in my opinion it would just be cleaner to use the existing protocol. Also my method requires a <code>TopLevelDecoder</code> since I am using the <code>URLSessions</code>s <code>.dataTaskPublisher</code> (<code>.decode(...)</code>).</p>
","5410199","","","","","2019-11-06 11:26:26","Default argument value of type 'JSONEncoder' cannot be converted to type 'Encoder' (TopLevelEncoder)","<swift><generics><dependency-injection><combine>","1","3","","","","CC BY-SA 4.0"
"58514673","1","60512197","","2019-10-23 02:34:34","","4","462","<p>When I pass a property which is declared as <code>@Published</code> to a generic function, I get an error referring to the published value. It's fine anywhere else where I use the variable, just not when passing into the generic function. </p>

<p>Error:</p>

<pre><code>error: cannot convert value 'user' of type 'User?' to expected type 'Published&lt;User?&gt;.Publisher?', use wrapper instead
</code></pre>

<p>Here's the playground code:</p>

<pre class=""lang-swift prettyprint-override""><code>struct User {}

class Test {
    @Published var user: User?
}

func normalFunc(_ argument: User?) -&gt; User? {
    return argument
}

func genericFunc&lt;T&gt;(_ argument: T?) -&gt; T? {
    return argument
}

let test = Test()
normalFunc(test.user) // Ok
genericFunc(test.user) // Error
</code></pre>

<p>The best I have been able to do is wrap the value in parenthesis, like so:</p>

<pre><code>genericFunc((test.user)) // Ok!
</code></pre>
","359532","","359532","","2020-03-03 17:02:05","2020-03-03 17:02:41","How to access the wrapped value of a @Published property when passing to generic function","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"58525674","1","58548503","","2019-10-23 14:54:48","","1","641","<p>i'm try to learn SwiftUI, i'm try to update my list automatically once I insert the value.
but i'm getting a big issue! my list not update when I use a sheet or a navigation view to insert data, it only work if I load data from my contentView.</p>

<p>(and I don't understand why, the class DataManager is ObservableObject and more over it work perfectly if I load data with 3 textfield in the content view)</p>

<p>here below my project:
I have a Data Model</p>

<pre><code>
import Foundation
import Combine

class DataModel: Codable, Identifiable {
    var id: UUID = UUID()
    var airportName : String
    var metar : String
    var taf : String

init(airportName: String, metar: String, taf: String) {
    self.airportName = airportName
    self.metar = metar
    self.taf = taf
}
}
</code></pre>

<p>I have a DataManager </p>

<pre><code>import SwiftUI
import Combine

class DataManager: ObservableObject {
    let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()


    var storage : [DataModel] = [] {
        willSet {
            objectWillChange.send()
        }
    }
    typealias Storage = [DataModel]

    var filePath : String = """"

    init() { caricaDati() }

    func caricaDati() {
        // creiamo il percorso al file
        filePath = cartellaDocuments() + ""test.plist""

        // usiamo NSFileManager per sapere se esiste un file a quel percorso
        if FileManager.default.fileExists(atPath: filePath) {

            // se c'è de-archiviamo il file di testo nell'array
            // serve il blocco do try catch
            do {
                // proviamo a caricare il file dal percorso creato in precedenza
                let data = try Data(contentsOf: URL(fileURLWithPath: filePath))
                // creiamo il decoder
                let decoder = PropertyListDecoder()
                // proviamo a decodificare il file nell'array
                storage = try decoder.decode(Storage.self, from: data)
            } catch {
                // se non ce la fa scriviamo in console l'errore
                debugPrint(error.localizedDescription)
            }

        }
    }

    func salva() {
        objectWillChange.send()
        let encoder = PropertyListEncoder()
        encoder.outputFormat = .xml // impostiamo l'output corretto
        // serve il blocco do try catch
        do {
            // proviamo a codificare l'array
            let data = try encoder.encode(storage)
            // proviamo a salvare l'array codificato nel file
            try data.write(to: URL(fileURLWithPath: filePath))
        } catch {
            // se non ce la fa scriviamo in console l'errore
            debugPrint(error.localizedDescription)
        }
    }

    func newData (nomeApt: String, metar: String, taf: String) {
        let newadd = DataModel(airportName: nomeApt, metar: metar, taf: taf)
        objectWillChange.send()
        storage.append(newadd)
        objectWillChange.send()
        salva()
    }

    func cartellaDocuments() -&gt; String {
        let paths = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)
        //print(paths[0])
        return paths[0]
    }
}
</code></pre>

<p>as you can see Datamanager is ObservableObject! and I have a simple function (newData) to add the value to the array storage.</p>

<p>now my problem is :
if I add data via 3 textfield in the ContentView() my List update automatically with no issue at all</p>

<pre><code>import SwiftUI

struct ContentView: View {
    @ObservedObject var dm : DataManager
    @State var isAddPresented : Bool = false
    @State var nomeApt : String = """"
    @State var metar : String = """"
    @State var taf : String = """"

    var body: some View {

        VStack {
            Button(action: {
                           self.dm.newData(nomeApt: self.nomeApt, metar: self.metar, taf: self.taf)

                       }) {
                           Text(""Add from below"")
                       }
            TextField(""name apt"", text: $nomeApt)
            TextField(""name apt"", text: $metar)
            TextField(""name apt"", text: $taf)

            Button(action: {
                self.isAddPresented = true
            }) {
                Text(""open view to add"")
            }.sheet(isPresented: $isAddPresented) {
                Add(dm: DataManager(), dismissFlag: self.$isAddPresented)
            }
            List(dm.storage) { item in
                HStack {
                    Text(item.airportName)
                    Text(item.metar)
                    Text(item.taf)
                }
            }

        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView(dm: DataManager())
    }
}

</code></pre>

<p>but if I use a sheet to add the same data, using the same function the List not update immediately!</p>

<p>here my second view:</p>

<pre><code>import SwiftUI

struct Add: View {
   @ObservedObject var dm : DataManager
    @State var nomeApt : String = """"
    @State var metar : String = """"
    @State var taf : String = """"
    @Binding var dismissFlag: Bool

    var body: some View {
        VStack {
            Spacer()
            TextField(""name apt"", text: $nomeApt)
            TextField(""name apt"", text: $metar)
            TextField(""name apt"", text: $taf)
            Button(action: {
                self.dm.newData(nomeApt: self.nomeApt, metar: self.metar, taf: self.taf)
                self.dismissFlag = false
            }) {
                Text(""Aggiungi"")
            }
            Spacer()
        }
    }
}

struct Add_Previews: PreviewProvider {
    static var previews: some View {
        Add(dm: DataManager(), dismissFlag: bindBool())
    }
}

func bindBool() -&gt; Binding&lt;Bool&gt; {
    var boolVariable : Bool = true
    let boolVariableBinding : Binding&lt;Bool&gt; = Binding(get: { boolVariable },
                                                      set: { boolVariable = $0 })
    return boolVariableBinding
}
</code></pre>

<p>what I totally don't understand is, why if I load the data from the content view my list update automatically, but if I use a navigation view of a sheet view this not work.</p>

<p>thanks in advance for the help</p>
","9962676","","","","","2019-10-24 20:08:49","ObservedObject List Update","<arrays><swift><xcode><observable><combine>","1","0","","","","CC BY-SA 4.0"
"58530722","1","58531613","","2019-10-23 20:41:42","","4","2375","<p>I hope I'm wrong, but I have not been able to find a SwiftUI equivalent to an editable
UITextView. So, I built one using UIViewRepresentable. Populating both a SwiftUI Text
and my own view with the ObservableObject works - but updates made in my view are
not propagated to the ObservableObject. I must be missing something important with
the Binding concept. Any guidance would be appreciated.</p>

<pre><code>import SwiftUI
import Combine

struct ContentView: View {

    @ObservedObject var myOText: MyOText

    var body: some View {
        ScrollView {
            VStack {
                Text(""This is a bound Text View"")
                    .padding(.top, 10)
                    .font(.headline)

                Text(myOText.inTheCourse)
                    .lineLimit(3)
                    .padding()

                Text(""This is a multi-line UITextView wrapper:"")
                    .font(.headline)

                MultilineTextView(myOText: myOText)
                    .frame(height: 100)
                    .padding()

                Spacer()
            }
        }
    }
}

struct MultilineTextView: UIViewRepresentable {

    @ObservedObject var myOText: MyOText

    func makeUIView(context: Context) -&gt; UITextView {
        let view = UITextView()
        view.isScrollEnabled = true
        view.isEditable = true
        view.isUserInteractionEnabled = true
        view.textAlignment = .center
        view.font = UIFont(name: ""Times New Roman"", size: 20)
        return view
    }

    func updateUIView(_ uiView: UITextView, context: Context) {
        uiView.text = myOText.inTheCourse
    }
}

class MyOText: ObservableObject {
    @Published var inTheCourse: String = ""When in the Course of human events, it becomes necessary for one people to dissolve the political bands which have connected them ...""
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView(myOText: MyOText())
    }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/YfFMS.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YfFMS.png"" alt=""enter image description here""></a> 
Xcode Version 11.2 beta 2 (11B44), iOS 13.</p>
","2698617","","","","","2019-10-23 22:13:43","SwiftUI Wrapper for UITextView not updating ObservedObject","<xcode><swiftui><combine>","1","2","1","","","CC BY-SA 4.0"
"58531681","1","58752876","","2019-10-23 22:20:52","","0","515","<p>I have two pieces of code to decode json data (local and remote). Both work. I am also able to visualize my local data, however not the remote data. They are exactly the same (just the location of the json file and the imageUrl differs). In my TestView.swift code, which is used for both cases, I have given two comments that point to my problem.</p>

<p>My issue: How do I need to define testData:[Test] for the remote case, which is well defined for the local case?</p>

<p>What is missing? Please help. I am new to Xcode and SwiftUI so any help will be greatly appreciated.</p>

<p>P.S. Basically I am trying to build on two Swift Tutorials (on YouTube), i.e. Build a Complex UI with SwiftUI from Start to Finish, SwiftUI Fetching JSON and Image Data with BindableObject.</p>

<p>//  Data.swift</p>

<pre><code>import SwiftUI
import Combine
</code></pre>

<p>// 1.) This first piece of code  decodes local json data and correctly visualize it</p>

<pre><code>let testData:[Test] = load(""test.json"")

func load&lt;T:Decodable&gt;(_ filename:String, as type:T.Type = T.self) -&gt; T {
    let data:Data
    guard let file = Bundle.main.url(forResource: filename, withExtension: nil)
        else {
            fatalError(""Couldn't find \(filename) in main bundle."")
    }
    do {
        data = try Data(contentsOf: file)
    } catch {
        fatalError(""Couldn't load \(filename) from main bundle:\n\(error)"")
    }

    do {
        let decoder = JSONDecoder()
        return try decoder.decode(T.self, from: data)
    } catch {
        fatalError(""Couldn't parse \(filename) as \(T.self):\n\(error)"")
    }
}

struct Test_Previews: PreviewProvider {
    static var previews: some View {
        TestView()
    }
}
</code></pre>

<p>// 2.) This 2nd piece of code decodes remote json data but does not visualize it</p>

<pre><code>class testDatas: ObservableObject {

    @Published var tests:[Test] = [Test]()

    func getAllTests() {
        let file = URLRequest(url: URL(string: ""https://myurl/test.json"")!)
        let task = URLSession.shared.dataTask(with: file) { (data, _, error) in
        guard error == nil else { return }

            do {
                let tests = try JSONDecoder().decode([Test].self, from: data!)

                DispatchQueue.main.async {
                        self.tests = tests
                    print(tests)

                }
            } catch {
                print(""Failed To decode: "", error)
            }
        }
        task.resume()
    }
        init() {
            getAllTests()
    }
        init(tests: [Test]) {
            self.tests = tests
    }
}

struct Test_Previews: PreviewProvider {
    static var previews: some View {
        TestView()
    }
}
</code></pre>

<p>//  TestView.swift (used for both decode cases)</p>

<pre><code>import SwiftUI

// testData needed here only for the remote case, but this might be wrong and the problem?
let testData:[Test] = [Test]()

struct TestView: View {

    // testDatas needed here only for the remote case to decode json data)
    @ObservedObject var fixer: testDatas = testDatas()

    @EnvironmentObject var loader: ImageLoader

    var categories:[String:[Test]] {
        .init(
            grouping: testData,
            by: {$0.category.rawValue}
        )
    }

    var body: some View {
        NavigationView{
            List (categories.keys.sorted(), id: \String.self) {key in TestRow(categoryName: ""\(key).environmentObject(ImageLoader(with: key.imageUrl)) Tests"".uppercased(), tests: self.categories[key]!)
                .frame(height: 320)
                .padding(.top)
                .padding(.bottom)
            }
            .navigationBarTitle(Text(""TEST""))
        }
    }

}

class ImageLoader:ObservableObject
{
    @Published var data:Data = Data()
    func getImage(imageURL:String) {
        guard let test = URL(string: imageURL) else { return }

        URLSession.shared.dataTask(with: test) { (data, response, error) in
            DispatchQueue.main.async {
                if let data = data {
                    self.data = data
                }
            }
            print(data as Any)
        }.resume()
    }
    init(imageURL:String) {
        getImage(imageURL: imageURL)
    }
}

struct TestView_Previews: PreviewProvider {
    @ObservedObject var imageLoader: ImageLoader
    init(test:String)
    {
        imageLoader = ImageLoader(imageURL: test)
    }
    static var previews: some View {
        TestView()
    }
}
</code></pre>
","12265655","","12265655","","2019-10-24 06:49:43","2019-11-07 16:16:01","No images despite successful decoding of json data with SwiftUI","<swift><swiftui>","1","0","1","","","CC BY-SA 4.0"
"58552287","1","58552850","","2019-10-25 04:40:44","","4","4397","<p>I'm new to Swift and iOS development and try to learn by following the official SwiftUI tutorials. I got errors in section 5(<a href=""https://developer.apple.com/tutorials/swiftui/handling-user-input"" rel=""nofollow noreferrer"">https://developer.apple.com/tutorials/swiftui/handling-user-input</a>). I followed each step meticulously and after I did section 5 step 1, Xcode popped up an error ""Use of undeclared type 'UserData'"". I tried to ignore and followed through. However, my LandmarkList, LandmarkDetail, SceneDelegate files warned me of the same error. I even checked the completed version of the project that I downloaded from the tutorial page. They looked exactly the same except the parts that I haven't done. Does anyone here have a similar experience as mine or can you kindly offer some suggestions? Thank you!</p>

<p>I'm using Xcode 11 and Swift 5.</p>

<p>This is the UserData class I created under the Models folder.</p>

<pre><code>import Combine
import SwiftUI

final class UserData: ObservableObject {
    @Published var showFavoritesOnly = false
    @Published var landmarks = landmarkData
}
</code></pre>

<p>This is the rootview file that keeps prompting errors.</p>

<pre><code>import SwiftUI

struct LandmarkList: View {
    @EnvironmentObject private var userData: UserData  // Use of undeclared type 'UserData'

    var body: some View {
        NavigationView {
            List { // Unable to infer complex closure return type; add explicit type to disambiguate
                Toggle(isOn: $userData.showFavoritesOnly){ // Use of unresolved identifier '$userData'
                    Text(""Favorites Only"")
                }

                ForEach(userData.landmarks) { landmark in
                    if !self.userData.showFavoritesOnly || landmark.isFavorite {
                        NavigationLink(destination: LandmarkDetail(landmark: landmark)
                            .environmentObject(self.userData)) {
                            LandmarkRow(landmark: landmark)
                        }
                    }
                }
            }
            .navigationBarTitle(Text(""Landmarks""))
        }
    }
}

struct LandmarkList_Previews: PreviewProvider {
    static var previews: some View {
        ForEach([""iPhone SE"", ""iPhone XS Max""], id: \.self) { deviceName in
            LandmarkList()
                .previewDevice(PreviewDevice(rawValue: deviceName))
                .previewDisplayName(deviceName)
        }
        .environmentObject(UserData()) // Use of unresolved identifier 'UserData'
    }
}
</code></pre>
","6164341","","1226963","","2019-10-25 04:42:28","2020-02-25 19:25:07","How to fix ""Use of undeclared type"" error in Swift 5.1?","<swift><swiftui>","3","1","1","","","CC BY-SA 4.0"
"58559908","1","58584005","","2019-10-25 13:53:25","","14","9386","<p>I've seen how to transition to Combine using a Publisher from some <code>NotificationCenter</code> code, but have not seen how to do it for something like:</p>

<pre><code>        NotificationCenter.default.addObserver(
        self,
        selector: #selector(notCombine),
        name: NSNotification.Name(rawValue: ""notCombine""),
        object: nil
    )
</code></pre>

<p>I've seen that this is available as a Publisher, but I <strong>don't have a <code>selector</code></strong> and am not sure what to do for it:</p>

<pre><code>        NotificationCenter.default.publisher(
        for: Notification.Name(rawValue: ""notCombine"")
    )
</code></pre>

<p>Does anyone know? Thanks!</p>
","4205674","","","","","2019-10-29 18:07:26","Combine: Going from Notification Center addObserver with selector to Notification publisher","<swift><combine>","2","0","7","","","CC BY-SA 4.0"
"58565086","1","58567001","","2019-10-25 20:06:53","","0","891","<p>I am trying to display results of a realmdb query in a SwiftUI list but have trouble when deleting database objects. </p>

<p>I am trying to use something like this: </p>

<pre><code>final class DBData: ObservableObject{

let didChange = PassthroughSubject&lt;DBData, Never&gt;()

private var notificationTokens: [NotificationToken] = []
var events = try! Realm().objects(ADMEvent.self)
@Published var events: [ADMEvent] = []
init() {
    // Observe changes in the underlying model
    self.notificationTokens.append(posts.observe { _ in
        self.events = Array(self.posts)
        self.didChange.send(self)
    })
}
}
</code></pre>

<p>Which works if I display items In a list but the moment I use realm.deleteAll() the app crashes because it looks like Swift UI's list implementation is trying to diff the list, accessing the now invalidated realm db objects. </p>

<p>There are like 3 or 4 similar questions on stack overflow but they are all out of date in one way or another, or work but still have this issue when it comes to deletion. </p>

<p>Thanks!</p>
","582141","","","","","2020-04-24 21:20:33","How can I properly map RealmDB Results objects to SwiftUI Lists?","<swift><swiftui><combine><swiftui-list><realm-database>","2","0","1","","","CC BY-SA 4.0"
"58572631","1","58575017","","2019-10-26 16:29:38","","4","966","<p>I am trying to wrap my head around SwiftUI and Combine. I want to keep some text in the UI up-to-date with a value. In this case, it's the battery level of the device, for example.</p>

<p>Here is my code. First of all, it seems like this is quite a bit of code to achieve what I want to do, so I'm wondering if I may be able to do without some of it. Also, this code used to run over the summer, but now it crashes, probably due to changes in SwiftUI and Combine.</p>

<p>How can this be fixed to work with the current version of SwiftUI and Combine? And, is it possible to cut back on the amount of code here to do the same thing?</p>

<pre><code>import SwiftUI
import Combine

class ViewModel: ObservableObject {

    var willChange = PassthroughSubject&lt;Void, Never&gt;()

    var batteryLevelPublisher = UIDevice.current
        .publisher(for: \.batteryLevel)
        .receive(on: RunLoop.main)

    lazy var batteryLevelSubscriber = Subscribers.Assign(object: self,
                                                         keyPath: \.batteryLevel)

    var batteryLevel: Float = UIDevice.current.batteryLevel {
        didSet {
            willChange.send()
        }
    }

    init() {
        batteryLevelPublisher.subscribe(batteryLevelSubscriber)
    }
}

struct ContentView: View {

    @ObservedObject var viewModel = ViewModel()

    var body: some View {
        Text(""\(Int(round(viewModel.batteryLevel * 100)))%"")
    }
}
</code></pre>
","241163","","","","","2019-11-27 21:28:24","What is the most concise way to display a changing value with Combine and SwiftUI?","<ios><swift><swiftui><combine>","2","0","2","","","CC BY-SA 4.0"
"58588286","1","58593154","","2019-10-28 09:16:39","","2","744","<p>I have a simple TextField for telephone input, and want to format it each time it being changed. </p>

<p>I'm using PhoneNumberKit and it works fine, but i do not understand how to call formatting func after the value in textField have changed.</p>

<p>Telephone Formatting function. </p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import PhoneNumberKit
import Combine

func formatTelephone(telephone : String) -&gt; String
    {

        do {
            let phoneNumber =  PartialFormatter().formatPartial(telephone)

            print(phoneNumber)
            return phoneNumber
        }
        catch {
            print(""Generic parser error"")

        }
    }
</code></pre>

<p>It does something like this:</p>

<pre><code>formatTelephone(""79152140700"") -&gt; ""7 (915) 214 08-00"" 
formatTelephone(""791521"") -&gt; ""7 (915) 21"" 
</code></pre>

<p>and i have a TextField like that</p>

<pre><code>TextField(""915 214 07 00"" , text: $telephoneManager.telephone)
</code></pre>

<p>After each input of a digit the whole textfield label needs to be formatted by a func and show user's input in a better way.</p>
","11911126","","","","","2019-10-28 14:51:22","How to format TextField input string by function?","<ios><swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"58603932","1","59030337","","2019-10-29 08:46:46","","8","8630","<p>How would you detect a change of value of a Datepicker while using SwiftUI and Combine?
I need to invoke a method whenever the datepicker wheel is moved, to update a Text and a Slider.</p>

<p>I have looked for specific methods to identify the value change (using UIKit it was possible to associate an action to an event), but apparently I haven't found anything useful in the documentation (I've tried the onTapGesture methods, but that's not what I want, since it forces the user to tap the picker to update the other views, whereas I would like to have an automatic update whenever the user moves the wheel).</p>

<pre><code>import SwiftUI

struct ContentView: View {

    private var calendar = Calendar.current

    @State private var date = Date()
    @State private var weekOfYear = Double(Calendar.current.component(.weekOfYear, from: Date()) )
    @State private var lastWeekOfThisYear = 53.0
    @State private var weekDay: String = { () -&gt; String in 
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = ""EEEE""
        let weekDay = dateFormatter.string(from: Date())
        return weekDay
    }()

    var body: some View {

        VStack {

            // Date Picker
            DatePicker(selection: $date, displayedComponents: .date, label:{ Text(""Please enter a date"") }
            )
            .labelsHidden()
            .datePickerStyle(WheelDatePickerStyle())
            .onTapGesture {
                self.updateWeekAndDayFromDate()
            }

            // Week number and day
            Text(""Week \(Int(weekOfYear.rounded()))"")
            Text(""\(weekDay)"")

            // Slider
            Slider(value: $weekOfYear, in: 1...lastWeekOfThisYear, onEditingChanged: { _ in
                    self.updateDateFromWeek()
                })
            }

    }

    func updateWeekAndDayFromDate() {
        // To do
    }

    func updateDateFromWeek() {
        // To do
    }

    func setToday() {
        // To do
    }

    func getWeekDay(_ date: Date) -&gt; String {
        //To do
    }
}
</code></pre>

<p>I guess this could be solved using Combine (observableobject, published, sink, etc.), but I'm not experienced yet with Combine, therefore I'd like to ask for some help... any ideas? :)</p>

<p>Thanks a lot!</p>
","7304357","","7304357","","2019-10-29 09:21:44","2022-07-01 14:18:06","How to detect a value change of a Datepicker using SwiftUI and Combine?","<events><datepicker><swiftui><combine><valuechangelistener>","4","2","2","","","CC BY-SA 4.0"
"58630233","1","58630312","","2019-10-30 16:50:33","","2","259","<p>I am trying to change the view when the user login, which is when the <strong>isAuthenticated</strong> is updated in the <strong>Authentication</strong> class, but it never gets the new value, I am not sure if I am understanding everything correctly.</p>

<p><strong>Authentication</strong></p>

<pre><code>class Authentication: ObservableObject{

    @Published var email: String = """"
    @Published var password: String = """"
    @Published var isAuthenticated : Bool = false

    func login(){
        AppDelegate._bc.authenticateEmailPassword(email,
                                                  password: password,
                                                  forceCreate: false,
                                                  completionBlock: onAuthenticate,
                                                  errorCompletionBlock: onAuthenticateFailed,
                                                  cbObject: nil)
    }

    func onAuthenticate(serviceName:String?, serviceOperation:String?, jsonData:String?, cbObject: NSObject?) {

        /............./

        UserDefaults.standard.set(true, forKey: ""HasAuthenticated"")
        self.isAuthenticated.toggle()
        print(""Login DONE!"")
    }
}
</code></pre>

<p>Everything is okay till now, the user gets authenticated, it prints ""Login DONE!"" and it updates the <strong>isAuthenticated</strong> value to true.</p>

<p>But in the <strong>AuthView</strong> it does not receive the new value</p>

<p><strong>AuthView</strong></p>

<pre><code>struct AuthView: View {

    @ObservedObject var auth = Authentication()

    var body: some View {
        NavigationView{
            VStack{
                /............./

                LoginView()

                NavigationLink(destination: ProfileView(), isActive: $auth.isAuthenticated) {
                    Text("""")
                }
            }
        }
    }
}
</code></pre>

<p>And here where I call the <strong>login</strong> function</p>

<p><strong>LoginView</strong></p>

<pre><code>struct LoginView: View{

    @ObservedObject var auth = Authentication()

    var body: some View {
        VStack(){
            Button(action: {
                self.auth.login()
            }) {
                LoginButtonContent(state: ""Login"")
            }
        }
    }
}
</code></pre>
","8738893","","","","","2019-10-30 16:55:34","Getting the updated value from @ObservedObject in SwiftUI","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"58643094","1","63524550","","2019-10-31 12:10:16","","53","15386","<p>In a SwiftUI <code>View</code> i have a <code>List</code> based on <code>@FetchRequest</code> showing data of a <code>Primary</code> entity and the via relationship connected <code>Secondary</code> entity.
The <code>View</code> and its <code>List</code> is updated correctly, when I add a new <code>Primary</code> entity with a new related secondary entity.</p>

<p>The problem is, when I update the connected <code>Secondary</code> item in a detail view, the database gets updated, but the changes are not reflected in the <code>Primary</code> List.
Obviously, the <code>@FetchRequest</code> does not get triggered by the changes in another View.</p>

<p>When I add a new item in the primary view thereafter, the previously changed item gets finally updated.</p>

<p>As a workaround, i additionally update an attribute of the <code>Primary</code> entity in the detail view and the changes propagate correctly to the <code>Primary</code> View.</p>

<p>My question is:
How can I force an update on all related <code>@FetchRequests</code> in SwiftUI Core Data?
Especially, when I have no direct access to the related entities/<code>@Fetchrequests</code>?</p>

<p><a href=""https://i.stack.imgur.com/XKkJl.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/XKkJl.png"" alt=""Data Structure""></a></p>

<pre><code>import SwiftUI

extension Primary: Identifiable {}

// Primary View

struct PrimaryListView: View {
    @Environment(\.managedObjectContext) var context

    @FetchRequest(
        entity: Primary.entity(),
        sortDescriptors: [NSSortDescriptor(key: ""primaryName"", ascending: true)]
    )
    var fetchedResults: FetchedResults&lt;Primary&gt;

    var body: some View {
        List {
            ForEach(fetchedResults) { primary in
                NavigationLink(destination: SecondaryView(primary: primary)) {
                VStack(alignment: .leading) {
                    Text(""\(primary.primaryName ?? ""nil"")"")
                    Text(""\(primary.secondary?.secondaryName ?? ""nil"")"").font(.footnote).foregroundColor(.secondary)
                }
                }
            }
        }
        .navigationBarTitle(""Primary List"")
        .navigationBarItems(trailing:
            Button(action: {self.addNewPrimary()} ) {
                Image(systemName: ""plus"")
            }
        )
    }

    private func addNewPrimary() {
        let newPrimary = Primary(context: context)
        newPrimary.primaryName = ""Primary created at \(Date())""
        let newSecondary = Secondary(context: context)
        newSecondary.secondaryName = ""Secondary built at \(Date())""
        newPrimary.secondary = newSecondary
        try? context.save()
    }
}

struct PrimaryListView_Previews: PreviewProvider {
    static var previews: some View {
        let context = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext

        return NavigationView {
            PrimaryListView().environment(\.managedObjectContext, context)
        }
    }
}

// Detail View

struct SecondaryView: View {
    @Environment(\.presentationMode) var presentationMode

    var primary: Primary

    @State private var newSecondaryName = """"

    var body: some View {
        VStack {
            TextField(""Secondary name:"", text: $newSecondaryName)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .padding()
                .onAppear {self.newSecondaryName = self.primary.secondary?.secondaryName ?? ""no name""}
            Button(action: {self.saveChanges()}) {
                Text(""Save"")
            }
            .padding()
        }
    }

    private func saveChanges() {
        primary.secondary?.secondaryName = newSecondaryName

        // TODO: ❌ workaround to trigger update on primary @FetchRequest
        primary.managedObjectContext.refresh(primary, mergeChanges: true)
        // primary.primaryName = primary.primaryName

        try? primary.managedObjectContext?.save()
        presentationMode.wrappedValue.dismiss()
    }
}
</code></pre>
","6104836","","12450141","","2020-01-31 11:22:59","2022-03-21 22:12:20","How to update @FetchRequest, when a related Entity changes in SwiftUI?","<core-data><swiftui><combine>","6","3","25","","","CC BY-SA 4.0"
"58647265","1","58651543","","2019-10-31 16:06:22","","3","1567","<p>I want an Combine operator similar to RxSwift's <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Take.swift#L19-L28"" rel=""nofollow noreferrer""><code>take(_ n: Int)</code></a>, I written this and it seems to be working:</p>

<h1><code>first(_ n)</code> implementation</h1>

<pre class=""lang-swift prettyprint-override""><code>public extension Publisher where Failure == Never {
    /// Publishes the first `n` elements of a stream, then finishes.
    func first(_ numberOfElements: Int) -&gt; AnyPublisher&lt;Output, Failure&gt; {
        collect(numberOfElements)   // ""Buffer""
            .first()                // ""release and complete (finish)""

             // Publisher&lt;[Output]&gt; -&gt; Publisher&lt;Output&gt;
            .map { $0.publisher }.switchToLatest()  
            .eraseToAnyPublisher()
    }
}
</code></pre>

<h1>Alternative solution?</h1>

<p>Or can you come up with an alternative solution which is even better?</p>

<p>The <code>take</code> (but I named it <code>first</code>, to mirror the Combine native operator <a href=""https://developer.apple.com/documentation/combine/publisher/3204710-first"" rel=""nofollow noreferrer""><code>first</code></a> - <em>""Publishes the first element of a stream, then finishes.""</em>) operator is really convenient when writing tests, where I want a Publisher to finish after just <code>n</code> elements.</p>
","1311272","","1311272","","2019-10-31 17:58:48","2019-10-31 21:46:57","Swift Combine: `first(_ n: Int)` equivalent to RxSwift `take(_ n: Int)`?","<ios><swift><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"58672761","1","71093025","","2019-11-02 16:00:03","","3","5865","<p>Using iOS13.2, Swift-5.1.2, Xcode-11.2, I try the following:</p>

<p>I want to use a TextField. The user shall only be able to enter x-amount of characters into the TextField.</p>

<p>My code looks as follows:</p>

<pre><code>import Combine
import SwiftUI

class Entry: ObservableObject {

  @Published var entry = """" {
    didSet {
        entry = String(entry.prefix(6)) // trying to limit to 6 characters
    }
  }
}
</code></pre>

<p>And in the above code, there is already the exception line. </p>

<p>I can see that the <code>didSet{...}</code> is wrong (since we end up in an endless loop setting/didSetting again and again)...</p>

<p><strong>What is a better way to limit a TextField to x-amount of characters ?</strong></p>

<p>Here is the rest of the code:</p>

<pre><code>struct NumberView: View {
    var body: some View {

        Group {
            HStack {
                Spacer()
                NumberIcon(number: 1)
                NumberIcon(number: 2)
                NumberIcon(number: 3)
                NumberIcon(number: 4)
                NumberIcon(number: 5)
                NumberIcon(number: 6)
                Spacer()
            }
         }
    }
}
</code></pre>

<pre><code>struct NumberIcon: View {
    @ObservedObject private var entry = Entry()
    var number: Int = 0
    var body: some View {
        TextField("" "", text: $entry.entry, onEditingChanged: { editing in
            print(editing)
            print(self.$entry)
        })
            .padding()
            .foregroundColor(Color.black)
            .background(Color.green)
            .font(.largeTitle)
            .lineLimit(1)
            .cornerRadius(16.0)
            .clipped()
            .keyboardType(.numberPad)
    }
}

struct NumberView_Previews: PreviewProvider {
    static var previews: some View {
        NumberView()
    }
}
</code></pre>

<p>I know that there are UIKit wrapper possibilities to use the good-old <code>shouldChangeCharactersIn</code> delegate methods form UITextFieldDelegate - but I would like to implement the character limitation purely with SwiftUI (no UIKit code). How can I do that ?</p>
","3826232","","","","","2022-02-12 15:04:31","Limit TextField to x amount of characters using SwiftUI","<swift><textfield><swiftui><combine>","4","0","1","","","CC BY-SA 4.0"
"58673424","1","58677131","","2019-11-02 17:18:27","","4","2633","<p>When I call a backend service (login, value check…) I use a Notification publisher on the concerned Views to manage the update asynchronously. 
I want to unsubscribe to the notifications when the view disappear, or « pause » the publisher. 
I went first with the simple « assign » option from the WWDC19 Combine and related SwiftUI talks, then I looked at this <a href=""https://stackoverflow.com/q/56491881/2999457"">great post</a> and the onReceive modifier. However the view keeps updating with the published value even when the view is not visible.</p>

<p>My questions are: </p>

<ol>
<li>Can I « pause » this publisher when the view is not visible ?</li>
<li>Should I really be concerned by this, does it affect resources (the backend update could trigger a big refresh on list and images display) or should I just let SwiftUI manage under the hood ?</li>
</ol>

<p>The sample code:
<strong>Option 1: onReceive</strong></p>

<pre><code>struct ContentView: View {

    @State var info:String = ""???""
    let provider = DataProvider() // Local for demo purpose, use another pattern

    let publisher = NotificationCenter.default.publisher(for: DataProvider.updated)
    .map { notification in
        return notification.userInfo?[""data""] as! String
    }
    .receive(on: RunLoop.main)

    var body: some View {
        TabView {
            VStack {
                Text(""Info: \(info)"")
                Button(action: {
                    self.provider.startNotifications()
                }) {
                    Text(""Start notifications"")
                }
            }
           .onReceive(publisher) { (payload) in
                    self.info = payload
            }
            .tabItem {
                Image(systemName: ""1.circle"")
                Text(""Notifications"")
            }
            VStack {
                Text(""AnotherView"")
            }
            .tabItem {
                Image(systemName: ""2.circle"")
                Text(""Nothing"")
            }
        }
    }
}
</code></pre>

<p><strong>Option 2: onAppear / onDisappear</strong></p>

<pre><code>struct ContentView: View {

    @State var info:String = ""???""
    let provider = DataProvider() // Local for demo purpose, use another pattern

    @State var cancel: AnyCancellable? = nil

    var body: some View {
        TabView {
            VStack {
                Text(""Info: \(info)"")
                Button(action: {
                    self.provider.startNotifications()
                }) {
                    Text(""Start notifications"")
                }
            }
            .onAppear(perform: subscribeToNotifications)
            .onDisappear(perform: unsubscribeToNotifications)
            .tabItem {
                Image(systemName: ""1.circle"")
                Text(""Notifications"")
            }
            VStack {
                Text(""AnotherView"")
            }
            .tabItem {
                Image(systemName: ""2.circle"")
                Text(""Nothing"")
            }
        }
    }

    private func subscribeToNotifications() {
       // publisher to emit events when the default NotificationCenter broadcasts the notification
        let publisher = NotificationCenter.default.publisher(for: DataProvider.updated)
            .map { notification in
                return notification.userInfo?[""data""] as! String
            }
            .receive(on: RunLoop.main)

        // keep reference to Cancellable, and assign String value to property
        cancel = publisher.assign(to: \.info, on: self)
    }

    private func unsubscribeToNotifications() {
       guard cancel != nil else {
            return
        }
        cancel?.cancel()
    }
}
</code></pre>

<p>For this test, I use a dummy service:</p>

<pre><code>class DataProvider {   
    static let updated = Notification.Name(""Updated"")
    var payload = ""nothing""    
    private var running = true

    func fetchSomeData() {
        payload = Date().description
        print(""DEBUG new payload : \(payload)"")
        let dictionary = [""data"":payload] // key 'data' provides payload
        NotificationCenter.default.post(name: DataProvider.updated, object: self, userInfo: dictionary)
    }

    func startNotifications() {
        running = true
        runNotification()
    }

    private func runNotification() {
        if self.running {
            self.fetchSomeData()
            let soon = DispatchTime.now().advanced(by: DispatchTimeInterval.seconds(3))
            DispatchQueue.main.asyncAfter(deadline: soon) {
                self.runNotification()
            }
        } else {
            print(""DEBUG runNotification will no longer run"")
        }
    }

    func stopNotifications() {
        running = false
    }   
}
</code></pre>
","2999457","","2999457","","2019-11-05 11:03:33","2019-11-05 15:28:32","Pausing a Notification publisher in SwiftUI","<ios><swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"58675046","1","58708381","","2019-11-02 20:33:15","","4","2899","<p>I have a publisher which takes a network call and returns an array of IDs. I now need to call another network call for each ID to get all my data. And I want the final publisher to have the resulting object.</p>

<p>First network result:</p>

<pre><code>""user"": {
   ""id"": 0,
   ""items"": [1, 2, 3, 4, 5]
}
</code></pre>

<p>Final object:</p>

<pre><code>struct User {
    let id: Int
    let items: [Item]
    ... other fields ...
}
struct Item {
    let id: Int
    ... other fields ...
}
</code></pre>

<p>Handling multiple network calls:</p>

<pre><code>userPublisher.flatMap { user in
    let itemIDs = user.items
    return Future&lt;[Item], Never&gt;() { fulfill in
        ... OperationQueue of network requests ...
    }
}
</code></pre>

<p>I would like to perform the network requests in parallel, since they are not dependent on each other. I'm not sure if Future is right here, but I'd imagine I would then have code to do a
DispatchGroup or OperationQueue and fulfill when they're all done. Is there more of a Combine way of doing this?</p>

<p>Doe Combine have a concept of splitting one stream into many parallel streams and joining the streams together?</p>
","359532","","","","","2020-05-17 16:10:43","How to process an array of task asynchronously with swift combine","<swift><combine>","1","0","3","","","CC BY-SA 4.0"
"58676249","1","58713969","","2019-11-02 23:43:33","","25","8619","<p>So I'm digging into combine and this question came up.</p>

<p>Is there any real difference between using <code>CurrentValueSubject</code> (and setting its value using <code>currentValueSubject.value</code>) or using a <code>@Published var</code> and accessing its publisher with a <code>$</code>? I mean I know one returns a <code>Subject</code> instead of a <code>Publisher</code>, but the only real difference I could find is that <code>CurrentValueSubject</code> is way more useful because you can declare it on a protocol.</p>

<p>I really don't understand how <code>@Published</code> can be useful if we can just use <code>PassthroughSubject</code>, am I missing something here? 
<strong>Mind you, this is using UIKit</strong>, it may have other uses for SwiftUI.</p>

<p>Thank you.</p>
","2126207","","5175709","","2022-04-17 13:55:10","2022-05-25 13:07:16","Difference between CurrentValueSubject and @Published","<ios><swift><combine><currentvaluesubject><property-wrapper-published>","5","0","3","","","CC BY-SA 4.0"
"58694448","1","59338381","","2019-11-04 13:29:20","","3","1349","<p>I'm writing a project in Combine and SwiftUI with backward compatibility for iOS 12/11 with RxSwift, RxCocoa and UIKit. My project is based on a lot of protocols, associated types and generics. When I'm running the project on iOS 13 it works fine but on iOS 12 the app suddenly crash.</p>

<p>I'm trying a Redux architecture with some changes. I have reducers, actions (as enums), stores and store providers (a store provider is intended to instantiate two stores: rxstore  and a combinestore . (i know it's not the best way to do that but I would like to understand why the bug occurs). </p>

<p>Also I have a so called <code>ReduxArchiver</code> and a <code>ReduxArchiverElement</code>. This one (<code>ReduxArchiver</code>) is like a listener or a delegate intended to handle and save redux store changes. (also I know it's not the best solution). When a store have a new state the <code>ReduxArchiver</code> handle the change, modify data as needed and decide to save or not the state on disk. Archiver is also intended to load app states from disk when a store is instantiated.</p>

<p>The error is <code>Thread 1: EXC_BAD_ACCESS (code=1, address=0x10)</code> and appears when I'm instantiating an object of <code>ReduxArchiver</code> type. It happens because of the instantiation of <code>ReduxArchiverElement&lt;T: Codable&gt;</code> array (see the code below or here: <a href=""https://github.com/mariusjcb/CrossReduxSOA"" rel=""nofollow noreferrer"">https://github.com/mariusjcb/CrossReduxSOA</a> )</p>

<p>Sometimes it appears in console:</p>

<pre><code>libMobileGestalt MobileGestalt.c:890: MGIsDeviceOneOfType is not supported
 on this platform.
</code></pre>

<p>I don't know if it's my fault or just a swift bug because of too many associated types/generics in the project.</p>

<p>I have both combine and swiftui linked as weak frameworks so there is no problem with missing SwiftUI/Combine.</p>

<p>Also my frameworks and libraries are embedded in target settings as <code>Embed &amp; Sign</code>.</p>

<p>The actual error:</p>

<pre><code>Thread 1: EXC_BAD_ACCESS (code=1, address=0x10)
</code></pre>

<p>When I'm doing po $arg1:</p>

<pre><code>// On #0    0x0000000108f6a93f in swift_getWitnessTable ():
(lldb) po $arg1
&lt;nil&gt;

// On #16   0x0000000108f6b308 in swift_getAssociatedTypeWitness ():
(lldb) po $arg1
error: Couldn't materialize: couldn't read the value of register rdi
error: errored out in DoExecute, couldn't PrepareToExecuteJITExpression
</code></pre>

<p>When I'm examinating the $rdi:</p>

<pre><code>//Xcode: 11.2
(lldb) register read
General Purpose Registers:
       rbx = 0x000000010ff7bdb8  libswiftCore.dylib`InitialAllocationPool + 4304
       rbp = 0x00007ffee39a3990
       rsp = 0x00007ffee39a3960
       r12 = 0x000000010cc69448  Models`protocol requirements base descriptor for Redux.Reducer
       r13 = 0x00000000000000ff
       r14 = 0x000000010cc69478  Models`associated type descriptor for StateType
       r15 = 0x000000010d1ba718  type metadata for Reducers.ExampleReducer
       rip = 0x000000010fea2308  libswiftCore.dylib`swift_getAssociatedTypeWitness + 152
13 registers were unavailable.

//Xcode 11.1
(lldb) register read --all 
General Purpose Registers:
       rax = 0x0000000000000000
       rbx = 0x0000000105d1db74  Models`protocol conformance descriptor for Models.ExampleModel : Swift.Identifiable in Models + 16
       rcx = 0x0000000000000000
       rdx = 0x0000000000030000
       rdi = 0x0000000000000000
       rsi = 0x0000000105d1db78  Models`protocol conformance descriptor for Models.ExampleModel : Swift.Identifiable in Models + 20
       rbp = 0x00007ffeea8fa960
       rsp = 0x00007ffeea8fa8d0
        r8 = 0x0000000000000000
        r9 = 0x0000000105d1db50  Models`protocol conformance descriptor for Models.ExampleModel : Swift.Encodable in Models + 20
       r10 = 0x0000000108fc10a4  libswiftCore.dylib`method descriptor for Swift.Encodable.encode(to: Swift.Encoder) throws -&gt; ()
       r11 = 0x0000000000000001
       r12 = 0x0000000105d9c3b0  Models`__unnamed_24
       r13 = 0x0000000000000000
       r14 = 0x0000000105d1db74  Models`protocol conformance descriptor for Models.ExampleModel : Swift.Identifiable in Models + 16
       r15 = 0x0000000105d1db64  Models`protocol conformance descriptor for Models.ExampleModel : Swift.Identifiable in Models
       rip = 0x0000000108f6a93f  libswiftCore.dylib`swift_getWitnessTable + 447
    rflags = 0x0000000000000247
        cs = 0x000000000000002b
        fs = 0x0000000000000000
</code></pre>

<p>Instantiation of the object:</p>

<pre><code>// In AppDelegate (as property):
// ...

let state = ExampleStoreBuilder.build()

// The Build Method from ExampleStoreBuilder

let archiveListeners = [GenericReduxArchiverLogger(""example_archiver"")]
        var listeners: [ReduceStoreOutputDelegate] = [GenericReduxStoreLogger(""example_logger"")]
ERROR&gt;&gt; let defaultStoreArchiver = ExampleArchiver&lt;ExampleRxStore&gt;(outputDelegates: archiveListeners) &lt;&lt;&lt;&lt; Error: EXC_BAD_ACCESS

        listeners.append(defaultStoreArchiver)
        listeners.append(contentsOf: archiveListeners)
        if #available(iOS 13.0, *) {
            listeners.append(ExampleArchiver&lt;ExampleCombineStore&gt;(outputDelegates: archiveListeners))
        }

        let reducer = ExampleReduceBuilder.build()
        let initialState = defaultStoreArchiver.statesHistory.last?.state ?? .emptyState
        return ReduxState&lt;ExampleStoreProvider&lt;ExampleReducer&gt;&gt;(initialState,
                                                              reducedBy: reducer,
                                                              outputDelegates: listeners)
</code></pre>

<p>The EXC_BAD_ACCESS from let defaultStoreArchiver is located in ExampleArchiver on the line: </p>

<pre><code>public var statesHistory = [ReduxArchiveElement&lt;StoreType.ReducerType.StateType&gt;]()
</code></pre>

<p>ReduxArchiverElement is defined as:</p>

<pre><code>public struct ReduxArchiveElement&lt;T: Codable&gt;: Codable {
    public let date: Date
    public let state: T

    public init(date: Date, state: T) {
        self.date = date
        self.state = state
    }
}
</code></pre>

<p>finally the StoreType and Reducer are defined as:</p>

<pre><code>// ReduceStoreInitializable protocol
public protocol ReduceStoreInitializable {
    associatedtype ReducerType: Reducer
...


// Store:
public protocol ReduceStore: class, ReduceStoreInitializable {
    var reducer: ReducerType! { get set }
...

// Reducer:
public protocol Reducer: class {
    associatedtype ActionType
    associatedtype ItemType: Codable
    associatedtype StateType: Codable
    associatedtype ErrorType: Error
</code></pre>

<p>About the actual error the stack looks like:</p>

<pre><code>Thread 1 Queue : com.apple.main-thread (serial)

* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x10)
    frame #0: 0x00000001063746e4 libswiftCore.dylib`swift_getWitnessTable + 392
    frame #1: 0x0000000105802e38 Models`lazy protocol witness table accessor for type ExampleModel and conformance ExampleModel at &lt;compiler-generated&gt;:0
    frame #2: 0x0000000105802cf4 Models`instantiation function for generic protocol witness table for ExampleModel at &lt;compiler-generated&gt;:0
    frame #3: 0x0000000106374c08 libswiftCore.dylib`swift_getWitnessTable + 1708
    frame #4: 0x0000000106385ee8 libswiftCore.dylib`swift::TargetProtocolConformanceDescriptor&lt;swift::InProcess&gt;::getWitnessTable(swift::TargetMetadata&lt;swift::InProcess&gt; const*) const + 496
    frame #5: 0x0000000105112fd8 ExampleApp-SwiftUI`swift::swift50override_conformsToProtocol(swift::TargetMetadata&lt;swift::InProcess&gt; const*, swift::TargetProtocolDescriptor&lt;swift::InProcess&gt; const*, swift::TargetWitnessTable&lt;swift::InProcess&gt; const* (*)(swift::TargetMetadata&lt;swift::InProcess&gt; const*, swift::TargetProtocolDescriptor&lt;swift::InProcess&gt; const*)) + 60
    frame #6: 0x00000001063607fc libswiftCore.dylib`swift::_conformsToProtocol(swift::OpaqueValue const*, swift::TargetMetadata&lt;swift::InProcess&gt; const*, swift::TargetProtocolDescriptorRef&lt;swift::InProcess&gt;, swift::TargetWitnessTable&lt;swift::InProcess&gt; const**) + 44
    frame #7: 0x00000001063863b0 libswiftCore.dylib`swift::_checkGenericRequirements(llvm::ArrayRef&lt;swift::TargetGenericRequirementDescriptor&lt;swift::InProcess&gt; &gt;, std::__1::vector&lt;void const*, std::__1::allocator&lt;void const*&gt; &gt;&amp;, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 1160
    frame #8: 0x0000000106383410 libswiftCore.dylib`(anonymous namespace)::DecodedMetadataBuilder::createBoundGenericType(swift::TargetContextDescriptor&lt;swift::InProcess&gt; const*, llvm::ArrayRef&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const*&gt;, swift::TargetMetadata&lt;swift::InProcess&gt; const*) const + 576
    frame #9: 0x0000000106382ac4 libswiftCore.dylib`swift::Demangle::TypeDecoder&lt;(anonymous namespace)::DecodedMetadataBuilder&gt;::decodeMangledType(swift::Demangle::Node* const&amp;) + 2832
    frame #10: 0x0000000106382100 libswiftCore.dylib`swift::Demangle::TypeDecoder&lt;(anonymous namespace)::DecodedMetadataBuilder&gt;::decodeMangledType(swift::Demangle::Node* const&amp;) + 332
    frame #11: 0x00000001063819e8 libswiftCore.dylib`swift_getTypeByMangledNodeImpl(swift::MetadataRequest, swift::Demangle::Demangler&amp;, swift::Demangle::Node*, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 460
    frame #12: 0x00000001063817a8 libswiftCore.dylib`swift::swift_getTypeByMangledNode(swift::MetadataRequest, swift::Demangle::Demangler&amp;, swift::Demangle::Node*, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 520
    frame #13: 0x0000000106381d18 libswiftCore.dylib`swift_getTypeByMangledNameImpl(swift::MetadataRequest, llvm::StringRef, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 648
    frame #14: 0x0000000106380110 libswiftCore.dylib`swift::swift_getTypeByMangledName(swift::MetadataRequest, llvm::StringRef, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 520
    frame #15: 0x0000000106376a6c libswiftCore.dylib`swift_getAssociatedTypeWitnessSlowImpl(swift::MetadataRequest, swift::TargetWitnessTable&lt;swift::InProcess&gt;*, swift::TargetMetadata&lt;swift::InProcess&gt; const*, swift::TargetProtocolRequirement&lt;swift::InProcess&gt; const*, swift::TargetProtocolRequirement&lt;swift::InProcess&gt; const*) + 492
    frame #16: 0x0000000106375018 libswiftCore.dylib`swift_getAssociatedTypeWitness + 176
    frame #17: 0x00000001056df53c Stores`ExampleArchiver.init(storeLocation=nil, outputDelegates=1 value, self=0x00000001c0463840) at ExampleArchiver.swift:18:85
    frame #18: 0x00000001056df38c Stores`ExampleArchiver.__allocating_init(storeLocation:outputDelegates:) at ExampleArchiver.swift:0
    frame #19: 0x00000001056ebc48 Stores`static ExampleStoreBuilder.build(self=Stores.ExampleStoreBuilder) at ExampleStoreBuilder.swift:23:64
    frame #20: 0x0000000105000d20 ExampleApp-SwiftUI`AppDelegate.init() at AppDelegate.swift:17:36
    frame #21: 0x0000000105000e28 ExampleApp-SwiftUI`@objc AppDelegate.init() at &lt;compiler-generated&gt;:0
    frame #22: 0x000000018e4a8a00 UIKit`_UIApplicationMainPreparations + 1688
    frame #23: 0x000000018e39d724 UIKit`UIApplicationMain + 184
    frame #24: 0x0000000105001404 ExampleApp-SwiftUI`main at AppDelegate.swift:14:7
  * frame #25: 0x0000000183e11fc0 libdyld.dylib`start + 4

</code></pre>

<p>for #16 0x0000000106375018 in swift_getAssociatedTypeWitness () the actual assembly looks like:</p>

<pre><code>libswiftCore.dylib`swift_getAssociatedTypeWitness:
    0x106374f68 &lt;+0&gt;:   stp    x24, x23, [sp, #-0x40]!
    0x106374f6c &lt;+4&gt;:   stp    x22, x21, [sp, #0x10]
    0x106374f70 &lt;+8&gt;:   stp    x20, x19, [sp, #0x20]
    0x106374f74 &lt;+12&gt;:  stp    x29, x30, [sp, #0x30]
    0x106374f78 &lt;+16&gt;:  add    x29, sp, #0x30            ; =0x30 
    0x106374f7c &lt;+20&gt;:  mov    x23, x0
    0x106374f80 &lt;+24&gt;:  sub    x8, x4, x3
    0x106374f84 &lt;+28&gt;:  lsr    x8, x8, #3
    0x106374f88 &lt;+32&gt;:  ldr    x0, [x1, w8, uxtw #3]
    0x106374f8c &lt;+36&gt;:  tbnz   w0, #0x0, 0x106374fa8     ; &lt;+64&gt;
    0x106374f90 &lt;+40&gt;:  mov    x1, #0x0
    0x106374f94 &lt;+44&gt;:  ldp    x29, x30, [sp, #0x30]
    0x106374f98 &lt;+48&gt;:  ldp    x20, x19, [sp, #0x20]
    0x106374f9c &lt;+52&gt;:  ldp    x22, x21, [sp, #0x10]
    0x106374fa0 &lt;+56&gt;:  ldp    x24, x23, [sp], #0x40
    0x106374fa4 &lt;+60&gt;:  ret    
    0x106374fa8 &lt;+64&gt;:  mov    x19, x4
    0x106374fac &lt;+68&gt;:  mov    x20, x3
    0x106374fb0 &lt;+72&gt;:  mov    x21, x2
    0x106374fb4 &lt;+76&gt;:  mov    x22, x1
    0x106374fb8 &lt;+80&gt;:  adr    x0, #0xcd130              ; swift_getAssociatedTypeWitnessSlow::Predicate
    0x106374fbc &lt;+84&gt;:  nop    
    0x106374fc0 &lt;+88&gt;:  adr    x1, #0x3690               ; swift_getAssociatedTypeWitnessSlow::$_8::__invoke(void*)
    0x106374fc4 &lt;+92&gt;:  nop    
    0x106374fc8 &lt;+96&gt;:  mov    x2, #0x0
    0x106374fcc &lt;+100&gt;: bl     0x106385ad4               ; swift_once
    0x106374fd0 &lt;+104&gt;: nop    
    0x106374fd4 &lt;+108&gt;: ldr    x8, #0xcd10c              ; swift_getAssociatedTypeWitnessSlow::Override
    0x106374fd8 &lt;+112&gt;: cbz    x8, 0x106375000           ; &lt;+152&gt;
    0x106374fdc &lt;+116&gt;: adr    x5, #0x18a4               ; swift_getAssociatedTypeWitnessSlowImpl(swift::MetadataRequest, swift::TargetWitnessTable&lt;swift::InProcess&gt;*, swift::TargetMetadata&lt;swift::InProcess&gt; const*, swift::TargetProtocolRequirement&lt;swift::InProcess&gt; const*, swift::TargetProtocolRequirement&lt;swift::InProcess&gt; const*)
    0x106374fe0 &lt;+120&gt;: nop    
    0x106374fe4 &lt;+124&gt;: mov    x0, x23
    0x106374fe8 &lt;+128&gt;: mov    x1, x22
    0x106374fec &lt;+132&gt;: mov    x2, x21
    0x106374ff0 &lt;+136&gt;: mov    x3, x20
    0x106374ff4 &lt;+140&gt;: mov    x4, x19
    0x106374ff8 &lt;+144&gt;: blr    x8
    0x106374ffc &lt;+148&gt;: b      0x106374f94               ; &lt;+44&gt;
    0x106375000 &lt;+152&gt;: mov    x0, x23
    0x106375004 &lt;+156&gt;: mov    x1, x22
    0x106375008 &lt;+160&gt;: mov    x2, x21
    0x10637500c &lt;+164&gt;: mov    x3, x20
    0x106375010 &lt;+168&gt;: mov    x4, x19
    0x106375014 &lt;+172&gt;: bl     0x106376880               ; swift_getAssociatedTypeWitnessSlowImpl(swift::MetadataRequest, swift::TargetWitnessTable&lt;swift::InProcess&gt;*, swift::TargetMetadata&lt;swift::InProcess&gt; const*, swift::TargetProtocolRequirement&lt;swift::InProcess&gt; const*, swift::TargetProtocolRequirement&lt;swift::InProcess&gt; const*)
-&gt;  0x106375018 &lt;+176&gt;: b      0x106374f94               ; &lt;+44&gt;    &lt;&lt;&lt; Thread 1: EXC_BAD_ACCESS (code=1, address=0x10)
</code></pre>

<p>also for #0 0x00000001063746e4 in swift_getWitnessTable () the asm looks like:</p>

<pre><code>    0x106374660 &lt;+260&gt;:  adr    x26, #0xb57a0             ; AllocationPool
    0x106374664 &lt;+264&gt;:  nop    
    0x106374668 &lt;+268&gt;:  str    x21, [sp, #0x30]
    0x10637466c &lt;+272&gt;:  ldar   x24, [x28]
    0x106374670 &lt;+276&gt;:  cbnz   x24, 0x1063747c8          ; &lt;+620&gt;
    0x106374674 &lt;+280&gt;:  b      0x106374688               ; &lt;+300&gt;
    0x106374678 &lt;+284&gt;:  add    x8, x24, #0x8             ; =0x8 
    0x10637467c &lt;+288&gt;:  csel   x28, x24, x8, lo
    0x106374680 &lt;+292&gt;:  ldar   x24, [x28]
    0x106374684 &lt;+296&gt;:  cbnz   x24, 0x1063747c8          ; &lt;+620&gt;
    0x106374688 &lt;+300&gt;:  cbnz   x23, 0x1063747b0          ; &lt;+596&gt;
    0x10637468c &lt;+304&gt;:  ldrsw  x9, [x20]
    0x106374690 &lt;+308&gt;:  cbz    w9, 0x1063746a8           ; &lt;+332&gt;
    0x106374694 &lt;+312&gt;:  and    x8, x9, #0xfffffffffffffffe
    0x106374698 &lt;+316&gt;:  add    x8, x8, x20
    0x10637469c &lt;+320&gt;:  tbz    w9, #0x0, 0x1063746ac     ; &lt;+336&gt;
    0x1063746a0 &lt;+324&gt;:  ldr    x8, [x8]
    0x1063746a4 &lt;+328&gt;:  b      0x1063746ac               ; &lt;+336&gt;
    0x1063746a8 &lt;+332&gt;:  mov    x8, #0x0
    0x1063746ac &lt;+336&gt;:  ldr    w12, [x20, #0xc]
    0x1063746b0 &lt;+340&gt;:  ubfx   x9, x12, #6, #1
    0x1063746b4 &lt;+344&gt;:  add    x10, x21, x9, lsl #2
    0x1063746b8 &lt;+348&gt;:  ubfx   x11, x12, #8, #8
    0x1063746bc &lt;+352&gt;:  madd   x9, x11, x14, x10
    0x1063746c0 &lt;+356&gt;:  ubfx   x13, x12, #16, #1
    0x1063746c4 &lt;+360&gt;:  add    x9, x9, x13, lsl #2
    0x1063746c8 &lt;+364&gt;:  tbnz   w12, #0x10, 0x1063746d4   ; &lt;+376&gt;
    0x1063746cc &lt;+368&gt;:  mov    x10, #0x0
    0x1063746d0 &lt;+372&gt;:  b      0x1063746dc               ; &lt;+384&gt;
    0x1063746d4 &lt;+376&gt;:  mul    x11, x11, x14
    0x1063746d8 &lt;+380&gt;:  ldr    w10, [x10, x11]
    0x1063746dc &lt;+384&gt;:  add    x9, x9, x10, lsl #3
    0x1063746e0 &lt;+388&gt;:  ldrh   w9, [x9, #0x2]
-&gt;  0x1063746e4 &lt;+392&gt;:  ldr    w8, [x8, #0x10]   &lt;&lt;&lt; ERROR; I don't understand this line... :(
</code></pre>
","4222398","","4222398","","2019-11-05 21:14:57","2020-02-04 20:05:50","iOS 12 error swift_getAssociatedTypeWitnessSlowImpl EXC_BAD_ACCESS in assembly code","<ios><swift><uikit><swiftui><combine>","2","2","1","","","CC BY-SA 4.0"
"58701826","1","58702685","","2019-11-04 22:12:13","","22","6043","<p>With SwiftUI (Xcode 11.1), I've got some Views set up with 2-way bindings (using <strong>@Binding</strong>).  Two-way updating works great.</p>

<p>However, how can I instantiate the view from the PreviewProvider?</p>

<p>For example:</p>

<pre><code>struct AddProjectView: View {

    @Binding public var showModal: Bool

    var body: some View {

        return VStack {
            Text(""Add Project View"")
            Button(""Dismiss"") {
                self.showModal = false
            }
        }
    }
}
</code></pre>

<p>I can't do this, because ""true"" is not a Binding:</p>

<pre><code>struct AddProjectView_Previews: PreviewProvider {
    static var previews: some View {
        AddProjectView(showModal: true)
    }
}
</code></pre>

<p>And I can't do this because ""<em>Property wrappers are not yet supported on local properties</em>"":</p>

<pre><code>struct AddProjectView_Previews: PreviewProvider {
    static var previews: some View {
        @Binding var show = true
        return AddProjectView(showModal: $show)
    }
}
</code></pre>

<p>How do we do this?</p>

<p>Thanks!!</p>
","4044855","","","","","2019-12-27 15:11:51","SwiftUI How to instantiate PreviewProvider when View requires @Binding in initializer","<xcode><swiftui><combine>","3","0","4","","","CC BY-SA 4.0"
"58719113","1","58753199","","2019-11-05 20:38:08","","0","392","<p>I need to define testData:[Test] that refers to @Published var tests:[Test] within </p>

<p>class NetworkManager: ObservableObject (see code).</p>

<p>I have tried the following definition:</p>

<pre><code>/// The app does not compile with this definition
//let testData:[Test] = NetworkManager(tests: Test)

/// The app works with this definition, but shows no remote json data
let testData:[Test] = NetworkManager().tests

class NetworkManager: ObservableObject {

@Published var tests:[Test] = [Test]()

func getAllTests() {
    let file = URLRequest(url: URL(string: ""https://my-url/remote.json"")!)
    let task = URLSession.shared.dataTask(with: file) { (data, _, error) in
    guard error == nil else { return }

        do {
            let tests = try JSONDecoder().decode([Test].self, from: data!)

            DispatchQueue.main.async {
                    self.tests = tests
                print(tests)

            }
        } catch {
            print(""Failed To decode: "", error)
        }
    }
    task.resume()
}
    init() {
        getAllTests()
}
    init(tests: [Test]) {
        self.tests = tests
}
}
</code></pre>

<p>The code below works fine </p>

<pre><code>/// The app works with this definition and shows the local json data
let testData:[Test] = load(""local.json"")

func load&lt;T:Decodable&gt;(_ filename:String, as type:T.Type = T.self) -&gt; T {
let data:Data
guard let file = Bundle.main.url(forResource: filename, withExtension: nil)
    else {
        fatalError(""Couldn't find \(filename) in main bundle."")
}
do {
    data = try Data(contentsOf: file)
} catch {
    fatalError(""Couldn't load \(filename) from main bundle:\n\(error)"")
}

do {
    let decoder = JSONDecoder()
    return try decoder.decode(T.self, from: data)
} catch {
    fatalError(""Couldn't parse \(filename) as \(T.self):\n\(error)"")
}
}
</code></pre>

<p>However, for the first part I get the error message:</p>

<p>""Cannot convert value of type 'Test.Type' to expected argument type '[Test]'""</p>

<p>What am I missing here? Any help is highly appreciated.</p>

<p>Additional info in response to the answer and question that shows how testData is used:</p>

<pre><code>import SwiftUI
import Combine

struct Test: Hashable, Codable, Identifiable {
    var id:Int
    var imageName:String
    var imageUrl:String
    var category:Category
    var description:String

    enum Category: String, CaseIterable, Codable, Hashable {
        case t1 = ""test1""
        case t2 = ""test2""
        case t3 = ""test3""
    }
}

class NetworkManager: ObservableObject {

      @Published var tests:[Test] = [Test]()
      private var subscriptions = Set&lt;AnyCancellable&gt;()

      func getAllTests() {
        let file = URLRequest(url: URL(string: ""https://my-url/remote.json"")!)
        URLSession
          .shared
          .dataTaskPublisher(for: file)
          .map(\.data)
          .decode(type: [Test].self, decoder: JSONDecoder())
          .replaceError(with: [])
          .receive(on: RunLoop.main)
          .assign(to: \.tests, on: self)
          .store(in: &amp;subscriptions)
      }
      init() {
        getAllTests()
      }
      init(tests: [Test]) {
        self.tests = tests
      }
    }

let testData:[Test] = NetworkManager().tests

struct ContentView: View {

var categories:[String:[Test]] {
    .init(
        grouping: testData,
        by: {$0.category.rawValue}
    )
}

var body: some View {
    NavigationView{
        List (categories.keys.sorted(), id: \String.self) {key in TestRow(categoryName: ""\(key) - Case"".uppercased(), tests: self.categories[key]!)
            .frame(height: 320)
            .padding(.top)
            .padding(.bottom)
        }
        .navigationBarTitle(Text(""TEST""))
    }
}

}

struct TestRow: View {

var categoryName:String
var tests:[Test]

    var body: some View {

        VStack {

            Text(self.categoryName)
                .font(.title)
                .multilineTextAlignment(.leading)

                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(alignment: .top) {
                        ForEach(self.tests, id: \.self) { tests in

                            NavigationLink(destination:
                                TestDetail(test: tests)) {
                                TestItem(test: tests)
                                    .frame(width: 300)
                                    .padding(.trailing, 30)
                                  Spacer()

                        }}
                }
                .padding(.leading)
            }
        }

    }
}

struct TestDetail: View {

    var test:Test
    var body: some View {
        List{
        ZStack(alignment: .bottom) {

            Image(test.imageUrl)
                .resizable()
                .aspectRatio(contentMode: .fit)
            Rectangle()
                .padding()
                .frame(height: 80.0)
                .opacity(0.25)
                .blur(radius: 10)
            HStack{
                VStack(alignment: .leading) {
                    Text(test.imageName)
                        .padding()
//                    .color(.white)
                    .colorScheme(.light)
                    .font(.largeTitle)
            }
            .padding(.leading)
            .padding(.bottom)
            Spacer()
            }
        }
            .listRowInsets(EdgeInsets())
            VStack(alignment: .leading) {
                Text(test.description)
//                  .padding(.bottom)
//                  .color(.primary)
                    .colorScheme(.light)
                    .font(.body)
                    .lineLimit(nil)
                    .lineSpacing(12)

                HStack {
                    Spacer()
                    OrderButton()
                    Spacer()
                }.padding(.top, 50)
            }.padding(.top)
            .padding(.bottom)
        }
        .edgesIgnoringSafeArea(.top)
    .navigationBarHidden(true)
    }
}

struct TestItem: View {

    var test:Test
    var body:some View{
        VStack(spacing: 16.0)
        {
            Image(test.imageUrl)
            .resizable()
            .renderingMode(.original)
            .aspectRatio(contentMode: .fill)
            .frame(width: 300, height: 170)
            .cornerRadius(10)
            .shadow(radius: 10)

            VStack(alignment: .leading, spacing: 5.0)
            {
            Text(test.imageName)
//                .color(.primary)
                .font(.headline)
            Text(test.description)
                .font(.subheadline)
                //                .color(.secondary)
                .multilineTextAlignment(.leading)
                .lineLimit(2)
                .frame(height: 40)
            }
        }
    }
}

struct OrderButton : View {
    var body: some View {
        Button(action: {}) {
            Text(""Order Now"")
        }.frame(width: 200, height: 50)
            .foregroundColor(.white)
            .font(.headline)
            .background(Color.blue)
        .cornerRadius(10)
    }
}

class ImageLoader:ObservableObject
{
    @Published var data:Data = Data()
    func getImage(imageURL:String) {
        guard let test = URL(string: imageURL) else { return }

        URLSession.shared.dataTask(with: test) { (data, response, error) in
            DispatchQueue.main.async {
                if let data = data {
                    self.data = data
                }
            }
            print(data as Any)
        }.resume()
    }
    init(imageURL:String) {
        getImage(imageURL: imageURL)
    }
}

struct ContentView_Previews: PreviewProvider {
    @ObservedObject var imageLoader: ImageLoader
    init(test:String)
    {
        imageLoader = ImageLoader(imageURL: test)
    }
    static var previews: some View {
        ContentView()
    }
}
</code></pre>

<p>// local.json</p>

<pre><code>[
{
""id"":101,
""imageName"":""test-f1a"",
""imageUrl"":""test-f1a"",
""description"":""test1a"",
""category"":""test1""
},
...
]
</code></pre>

<p>// remote.json</p>

<pre><code>[
{
""id"":101,
""imageName"":""test-f1a"",
""imageUrl"":""https://my-url/test-f1a"",
""description"":""test1a"",
""category"":""test1""
},
...
]
</code></pre>
","12265655","","12265655","","2019-11-06 23:45:36","2019-11-07 16:32:25","How to refer to @Published var within: class NetworkManager: ObservableObject","<ios><swift><swiftui><ios13><jsondecoder>","2","3","","","","CC BY-SA 4.0"
"58726165","1","58726243","","2019-11-06 08:46:19","","1","913","<p>I have this simple MapView and I have an ObservedObject datasource to update but is not work.</p>

<p>This is the content view:</p>

<pre><code>struct ContentView: View {
    @ObservedObject var trackingOnMapViewModel = TrackingOnMapViewModel()

    var body: some View {
        ZStack {
            MapView(selectedRegion: $trackingOnMapViewModel.selectedRegion)
                .edgesIgnoringSafeArea(.vertical)
            VStack {
                Spacer()
                Button(action: {
                    self.trackingOnMapViewModel.selectNextRegion()
                }) {
                    Text(""Next"")
                        .padding()
                }
            }
        }
    }
}
</code></pre>

<p>This is a simple mapview:</p>

<pre><code>struct MapView: UIViewRepresentable {
    @Binding var selectedRegion: MKCoordinateRegion

    func makeUIView(context: Context) -&gt; MKMapView {
        print(""MapView - makeUIView"")
        let map = MKMapView()
        return map
    }

    func updateUIView(_ mapView: MKMapView, context: Context) {
        print(""MapView - updateUIView"")
        mapView.setRegion(selectedRegion, animated: true)
    }
}
</code></pre>

<p>And this is the datasource:</p>

<pre><code>class TrackingOnMapViewModel: ObservableObject {

    var regions: [MKCoordinateRegion] = [
        MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 10.0, longitude: 10.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)),
        MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 20.0, longitude: 20.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)),
        MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 30.0, longitude: 30.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)),
        MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 40.0, longitude: 40.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0))
    ]

    var selectedRegion: MKCoordinateRegion = MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 0.0, longitude: 0.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0))

    var currentIndex = 0


    func selectNextRegion() {
        print(""TrackingOnMapViewModel - selectNextLandmark"")
        currentIndex = currentIndex &lt; regions.count-1 ? currentIndex + 1 : 0
        self.selectedRegion = regions[currentIndex]
        print(""selectedRegion - \(selectedRegion)"")
    }
}
</code></pre>

<p>In this case the map is not updated.</p>

<p>If I put the logic to the ContentView without the ObservedObject like this:</p>

<pre><code>struct ContentView: View {
//    @ObservedObject var trackingOnMapViewModel = TrackingOnMapViewModel()

@State var regions: [MKCoordinateRegion] = [
    MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 10.0, longitude: 10.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)),
    MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 20.0, longitude: 20.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)),
    MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 30.0, longitude: 30.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)),
    MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 40.0, longitude: 40.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0))
]

@State var selectedRegion: MKCoordinateRegion = MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 0.0, longitude: 0.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0))

@State var currentIndex = 0

var body: some View {
    ZStack {
        MapView(selectedRegion: $selectedRegion)
            .edgesIgnoringSafeArea(.vertical)
        VStack {
            Spacer()
            Button(action: {
                self.selectNextRegion()
            }) {
                Text(""Next"")
                    .padding()
            }
        }
    }
}

private func selectNextRegion() {
    print(""ContentView - selectNextLandmark"")
    currentIndex = currentIndex &lt; regions.count-1 ? currentIndex + 1 : 0
    self.selectedRegion = regions[currentIndex]
}
</code></pre>

<p>}</p>

<p>then the map is updating.</p>

<p>Could you help me with this?</p>
","2645599","","","","","2019-11-06 08:51:48","How to update UIViewRepresentable map through Binding and ObservedObject","<binding><mapkit><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"58743004","1","58760988","","2019-11-07 06:19:38","","18","21735","<p>my first view can get all the data from API request, then opened second view to change the API request data, it crashed.</p>

<p>below is the error</p>

<pre><code>Fatal error: No ObservableObject of type NetworkManager found.
A View.environmentObject(_:) for NetworkManager may be missing as an ancestor of this view.: file /BuildRoot/Library/Caches/com.apple.xbs/Sources/Monoceros_Sim/Monoceros-39.3/Core/EnvironmentObject.swift, line 55
2019-11-07 12:00:01.961425-0800 EarthQuake[73703:5913116] Fatal error: No ObservableObject of type NetworkManager found.
A View.environmentObject(_:) for NetworkManager may be missing as an ancestor of this view.: file /BuildRoot/Library/Caches/com.apple.xbs/Sources/Monoceros_Sim/Monoceros-39.3/Core/EnvironmentObject.swift, line 55
</code></pre>

<p>This is swift file to fetch data from API, then save data to posts</p>

<pre><code>import Foundation
import Combine

final class NetworkManager: ObservableObject {

    @Published var posts = [Post]()


    func fetchData() {

         //some code to fetch data, then save to posts

    }

}
</code></pre>

<p><strong>In my first list view file: EarthQuakeList.swift</strong></p>

<pre><code>
import SwiftUI

struct EarthQuakeList: View {

    @EnvironmentObject var networkManager: NetworkManager

    //@ObservedObject var networkManager = NetworkManager()

    var body: some View {

        NavigationView {
            List(networkManager.posts) { post in
                NavigationLink(destination: EarthQuakeDetail(detail: post.properties, location: post.locationCoordinate)) {
                    ListRow(magnitude: post.properties.mag ?? 0.0, place: post.properties.place)

                }

            }
          .navigationBarTitle(Text(""Today""))      
            .navigationBarItems(

                    trailing:
                    VStack {

                        Button(action: {
                            print(""Edit button tapped"")
                            self.showEditPage.toggle()
                        }) {
                            //Top right icon
                            Image(systemName: ""pencil.circle"")
                                .resizable()
                                .frame(width: 20, height: 20, alignment: .center)
                        }.sheet(isPresented: $showEditPage) { 
                            return EditPage().environmentObject(self.networkManager)

                        }

                    }




            )



        }
        .onAppear {
            //Call function to fetch data
            self.networkManager.fetchData()
        }
    }
}
</code></pre>

<p>Everything works well, I can see all the data, but when I do the same thing in my second view file, I get the data back, but it does not update for the first view</p>

<p><strong>In my second editing view file: EditPage.swift</strong></p>

<pre><code>import SwiftUI

struct EditPage: View {

    //@ObservedObject var networkManager = NetworkManager()

    @EnvironmentObject var networkManager: NetworkManager

    var body: some View {

        VStack {
            Text(""Edite"")


        }
        .onAppear(){

            //I called the same function to get data as in first view file, but it is not updating the list view 
            self.networkManager.fetchData()


        }

    }
}
</code></pre>

<p><strong>SceneDelegate.swift</strong></p>

<pre><code>import UIKit
import SwiftUI

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?


    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {

        //Set up environment object
        let contentView = EarthQuakeList().environmentObject(NetworkManager())

        // Use a UIHostingController as window root view controller.
        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(
                rootView: contentView
            )
            self.window = window
            window.makeKeyAndVisible()
        }
    }
</code></pre>

<p>So I am expecting second view file to call function <em>self.networkManager.fetchData()</em> to get data from API call, then update list view in first swift file <strong>EarthQuakeList</strong>, the issue is I am just getting correct data back, the view is not updating with new data</p>
","9500769","","9500769","","2019-11-08 05:40:04","2022-07-28 11:10:43","SwiftUI @EnvironmentObject error: may be missing as an ancestor of this view","<swift><xcode><swiftui><ios13>","4","3","4","","","CC BY-SA 4.0"
"58754458","1","58754640","","2019-11-07 17:51:10","","0","854","<p>RxJava has a <a href=""http://reactivex.io/documentation/operators/takeuntil.html"" rel=""nofollow noreferrer""><code>takeUntil</code></a> operator, documentation describes it as:</p>

<blockquote>
  <p>discard any items emitted by an Observable after a second Observable emits an item or terminates</p>
</blockquote>

<p>The last part is what I want to achieve using <code>Combine</code>. But I haven't found any equivalent operator. The only similar operator I find is <a href=""https://developer.apple.com/documentation/combine/publisher/3235804-prefix"" rel=""nofollow noreferrer""><code>prefix: untilOutputFrom</code></a>, documentation:</p>

<blockquote>
  <p>Republishes elements until another publisher emits an element.</p>
</blockquote>

<p>So given:</p>

<pre class=""lang-swift prettyprint-override""><code>fooPublisher.prefix(untilOutputFrom: barPublisher)
</code></pre>

<p>Does not act like I want it, because it only finishes when <code>barPublisher</code> emits an element. But I would like some operator finishing when <code>barPublisher</code> completes.</p>

<p>Did I miss something here? Does the operator I want actually exist under some other name?</p>
","1311272","","","","","2019-11-07 18:03:51","Swift Combine: `prefix(untilCompletionFrom)`?","<ios><swift><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"58784475","1","58878219","","2019-11-09 23:29:32","","16","10132","<p>I'm creating a SwiftUI app that includes Firebase to enable logging into an account, extremely simple, just a ui form with password and email fields, then a button to submit. Once the user signs in I store the firebase user object in an EnvironmentObject so the rest of the views will have access to it. The problem with the app currently is that once the user logs in and the user data is stored in the EnvironmentObject, the view is supposed to update to the changed state of this to show a different screen, but it seems the view still thinks the EnvironmentObject is equal to nil. Do views not automatically change to updates in an EnvironmentObject like they do for state variables perhaps? </p>

<p>I've made sure the EnvironmentObject is setup properly and passed to both the preview and SceneDelegate</p>

<p>Made sure that the app is indeed successfully logging in the user by printing account information to the console upon sign in, yet the view itself will only display nil for account information, it seems it wont access the updated EnvironmentObject with the user info. </p>

<pre><code>import SwiftUI
import Firebase
import Combine

struct ContentView: View {

    @EnvironmentObject var session: SessionStore

    @State var emailTextField: String = """"
    @State var passwordTextField: String = """"

    @State var loading = false
    @State var error = false

    var body: some View {
        VStack {
            if (session.session != nil) {
                Home()
            } else {
                Form {
                    TextField(""Email"", text: $emailTextField)
                    SecureField(""Password"", text: $passwordTextField)
                    Button(action: signIn) {
                        Text(""Sign in"")
                    }
                }

                Text(""Session: \(session.session?.email ?? ""no user"")"")
            }
        }.onAppear(perform: getUser)
    }

    func getUser () {
        session.listen()
    }

    func signIn () {
        loading = true
        error = false
        session.signIn(email: emailTextField, password: passwordTextField) { (result, error) in
            self.loading = false
            if error != nil {
                self.error = true
            } else {
                self.emailTextField = """"
                self.passwordTextField = """"
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView().environmentObject(SessionStore())
    }
}



class SessionStore : ObservableObject {

    var didChange = PassthroughSubject&lt;SessionStore, Never&gt;()
    var session: User? { didSet { self.didChange.send(self) }}
    var handle: AuthStateDidChangeListenerHandle?

    func listen () {
        // monitor authentication changes using firebase
        handle = Auth.auth().addStateDidChangeListener { (auth, user) in
            if let account = user {
                // if we have a user, create a new user model
                print(""Got user: \(account)"")
                self.session = User(
                    uid: account.uid,
                    displayName: account.displayName,
                    email: account.email
                )
                print(""Session: \(self.session?.email ?? ""no user"")"")
            } else {
                // if we don't have a user, set our session to nil
                self.session = nil
            }
        }
    }

    func signUp(
        email: String,
        password: String,
        handler: @escaping AuthDataResultCallback
        ) {
        Auth.auth().createUser(withEmail: email, password: password, completion: handler)
    }

    func signIn(
        email: String,
        password: String,
        handler: @escaping AuthDataResultCallback
        ) {
        Auth.auth().signIn(withEmail: email, password: password, completion: handler)
    }

    func signOut () -&gt; Bool {
        do {
            try Auth.auth().signOut()
            self.session = nil
            return true
        } catch {
            return false
        }
    }

    func unbind () {
        if let handle = handle {
            Auth.auth().removeStateDidChangeListener(handle)
        }
    }
}

class User {
    var uid: String
    var email: String?
    var displayName: String?

    init(uid: String, displayName: String?, email: String?) {
        self.uid = uid
        self.email = email
        self.displayName = displayName
    }

}
</code></pre>

<p>As you can see in the view, it is supposed to render login fields when user is not logged in, and when the user is logged in the view should display another view. That other view is not displaying.</p>
","5200455","","","","","2021-10-31 02:25:09","SwiftUI view is not updating to EnvironmentObject change","<ios><swift><swiftui>","2","2","7","","","CC BY-SA 4.0"
"58810366","1","58860756","","2019-11-12 00:24:57","","3","4813","<p>I have a progress bar and a text field, both are updated depending on each other's input:</p>

<pre><code>class ViewModel: ObservableObject {
    @Published var progressBarValue: Double {
        didSet {
            textFieldValue = String(progressBarValue)
        }
    }
    @Published var textFieldValue: String {
        didSet {
            progressBarValue = Double(progressBarValue)
        }
    }
}
</code></pre>

<p>Since updating one updates the other, I end up having an infinite recursion in my code.</p>

<p>Is there a way to workaround this with Combine or plain swift code?</p>
","646960","","","","","2019-11-14 15:49:28","Two-way binding in Swift Combine","<swift><two-way-binding><combine>","2","1","","","","CC BY-SA 4.0"
"58813300","1","58816887","","2019-11-12 06:39:54","","1","1113","<p>I have ViewModel which looks like this:</p>

<pre><code>class ItemsListViewModel : ObservableObject{

     var response : ItemsListResponse? = nil    
     var itemsList : [ListItem] = []    
     var isLoading = true    
     let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()


     func getItems() {
         self.isLoading = true

         ApiManager.shared.getItems()
        .sink(receiveCompletion: {completion in
        }, receiveValue: {               
            self.response = data   
            self.isLoading = false
            self.objectWillChange.send()                
        })    
   }
}
</code></pre>

<p>When I receive data from network request I use <code>self.objectWillChange.send()</code> to notify view, but view do not react to this.</p>

<p>My views : </p>

<p><strong>ItemsView</strong></p>

<pre><code>struct ItemsView: View {      

    var body: some View {
        VStack{
           Text(""Some Title"")
           ItemsListView()
        }
    }
}
</code></pre>

<p><strong>ItemsListView</strong></p>

<pre><code>struct ItemsListView: View {      
    @ObservedObject var myViewModel = ItemsListViewModel()

    var body: some View {
        VStack{
           Text(""\(self.myViewModel.response?.total"")
        }.onAppear{
             self.myViewModel.getItems()                   
        }
    }
}
</code></pre>

<p>But the interesting thing, that if I use <strong>ItemsListView</strong> not inside 
 <strong>ItemsView</strong> everything works perfectly. How can i solve this problem?</p>
","6125859","","6125859","","2019-11-12 10:26:01","2019-11-12 10:38:17","objectWillChange do not update view","<ios><swift><swiftui>","2","3","","","","CC BY-SA 4.0"
"58814755","1","58898411","","2019-11-12 08:31:36","","15","5521","<p>I created a function that returns a custom Publisher in Swift Combine using the code below:</p>

<pre class=""lang-swift prettyprint-override""><code>func customPubliher() -&gt; AnyPublisher&lt;Bool, Never&gt; {
    return Future&lt;Bool, Never&gt; { promise in
        promise(.success(true))
    }.eraseToAnyPublisher()
}
</code></pre>

<p>Then I subscribed to this publisher using the following code:</p>

<pre class=""lang-swift prettyprint-override""><code>customPublisher()
    .subscribe(on: DispatchQueue.global())
    .map { _ in
        print(Thread.isMainThread)
    }
    .sink(receiveCompletion: { _ in }, receiveValue: { value in
        // Do something with the value received
    }).store(in: &amp;disposables)
</code></pre>

<p>But even though I added the line <code>.subscribe(on: DispatchQueue.global())</code> when I do the subscription, the code is <strong>not</strong> executed in a different queue (the <code>print</code> in the <code>.map</code> outputs true).</p>

<p>However, if I replace my custom publisher for one of built-in Combine publishers, for example <code>Just()</code> (see below), the same code is executed fine on a different queue:</p>

<pre class=""lang-swift prettyprint-override""><code>Just(true)
    .subscribe(on: DispatchQueue.global())
    .map { _ in
        print(Thread.isMainThread)
    }
    .sink(receiveCompletion: { _ in }, receiveValue: { value in
        // Do something with the value received
    }).store(in: &amp;disposables)
</code></pre>

<p>The <code>.map</code> on the code above outputs false.</p>

<p>What am I doing wrong when I use my custom publisher? I want it to run on a different queue, exactly like the <code>Just()</code> publisher does.</p>
","856979","","856979","","2019-11-12 11:09:51","2020-07-01 01:24:47","Make custom Publisher run on a different DispatchQueue on Swift Combine","<ios><swift><combine>","1","1","2","","","CC BY-SA 4.0"
"58816265","1","58817233","","2019-11-12 10:03:09","","4","5141","<p>It might sound like a trivial task but I can't find a proper solution for this problem. Possibly I haven't internalized the ""SwiftUI-ish"" way of thinking yet.</p>

<p>I have a view with a button. When the view loads, there is a condition (already logged in?) under which the view should directly go to the next view. If the button is clicked, an API call is triggered (login) and if it was successful, the redirect to the next view should also happen.</p>

<p>My attempt was to have a model (ObservableObject) that holds the variable ""shouldRedirectToUploadView"" which is a PassThroughObject. Once the condition onAppear in the view is met or the button is clicked (and the API call is successful), the variable flips to true and tells the observer to change the view.</p>

<p>Flipping the ""shouldRedirectToUploadView"" in the model seems to work but I can't make the view re-evaluate that variable so the new view won't open.</p>

<p>Here is my implementation so far:</p>

<p><strong>The model</strong></p>

<pre><code>import SwiftUI
import Combine

class SboSelectorModel: ObservableObject {

    var didChange = PassthroughSubject&lt;Void, Never&gt;()

    var shouldRedirectToUpdateView = false {
        didSet {
            didChange.send()
        }
    }

    func fetch(_ text: String) {
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            self.shouldRedirectToUpdateView = true
        }
    }
}
</code></pre>

<p><strong>The view</strong></p>

<pre><code>import SwiftUI

struct SboSelectorView: View {
    @State var text: String = """"
    @ObservedObject var model: SboSelectorModel

    var body: some View {
        return ZStack {
            if (model.shouldRedirectToUpdateView) {
                UpdateView()
            }
            else {
                Button(action: {
                    self.reactOnButtonClick()
                }) {
                    Text(""Start"")
                }
            }
        }.onAppear(perform: initialActions)
    }

    public func initialActions() {
        self.model.shouldRedirectToUpdateView = true
    }

    private func reactOnButtonClick() {
        self.model.fetch()
    }
}
</code></pre>

<p>In good old UIKit I would have just used a ViewController to catch the action of button click and then put the new view on the navigation stack. How would I do it in SwiftUI?</p>

<p>In the above example I would expect the view to load, execute the <strong>onAppear()</strong> function which executes <strong>initialActions()</strong> to flip the model variable what would make the view react to that change and present the <strong>UploadView</strong>. Why doesn't it happen that way?</p>

<p>There are SO examples like <a href=""https://stackoverflow.com/questions/56754117/programatically-navigate-to-new-view-in-swiftui?rq=1"">Programatically navigate to new view in SwiftUI</a> or <a href=""https://stackoverflow.com/questions/56966739/show-a-new-view-from-button-press-swift-ui"">Show a new View from Button press Swift UI</a> or <a href=""https://stackoverflow.com/questions/56527840/how-to-present-a-view-after-a-request-with-urlsession-in-swiftui?rq=1"">How to present a view after a request with URLSession in SwiftUI?</a> that suggest the same procedure. However it does not seem to work for me. Am I missing something?</p>

<p>Thank you in advance!</p>
","2102328","","2102328","","2019-11-12 10:50:17","2019-12-25 10:39:00","SwiftUI: How to show next view after button click + API call","<ios><swift><swiftui>","2","0","3","","","CC BY-SA 4.0"
"58881050","1","58881214","","2019-11-15 16:24:30","","2","574","<p>I am using UserDefaults and Combine in SwiftUI. </p>

<p><strong>My UserDefault.swift file:</strong></p>

<pre><code>import SwiftUI

struct UserDefault&lt;T&gt; {
    let key: String
    let defaultValue:T

    var wrappedValue:T {
        get {
            return UserDefaults.standard.object(forKey: key) as? T ?? defaultValue
        } set {
            UserDefaults.standard.set(newValue, forKey: key)
        }
    }
}
</code></pre>

<p>When using this struct in the following class as follows:</p>

<p><strong>DataStore.swift file:</strong></p>

<pre><code>import SwiftUI
import Combine

final class DataStore : ObservableObject { //(1)
    let didChange = PassthroughSubject&lt;DataStore, Never&gt;()

    @UserDefault(key: ""firstLaunch"", defaultValue: true) //(2)
    var firstLaunch:Bool{
        didSet{
            didChange.send(self)
        }
    }
}
</code></pre>

<p>In the above code, I am getting 2 errors:</p>

<p><strong>(1):Class 'DataStore' has no initializers</strong></p>

<p><strong>(2):Generic struct 'UserDefault' cannot be used as an attribute</strong></p>

<p>I think there is a change or depreciation in swift 5.1, but I am unable to find it.  </p>
","10537037","","1226963","","2019-11-15 16:26:24","2019-11-15 16:35:53","Error Using property Wrapper in class swift 5.1","<swift><swiftui><swift5><combine>","2","2","","","","CC BY-SA 4.0"
"58882952","1","58883195","","2019-11-15 18:44:17","","1","2725","<p>I have problem with showing JSON Data in SwiftUI, I get the data from Genius API I currently search for song and can confirm that I get the data extracted correctly; example I can print out the title of the result:</p>

<p><a href=""https://i.stack.imgur.com/cOADC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/cOADC.png"" alt=""enter image description here""></a></p>

<p>This is how I fetch the data </p>

<pre><code>class NetworkManager: ObservableObject {
    var objectWillChange = PassthroughSubject&lt;NetworkManager, Never&gt;()

    var fetchedSongsResults = [hits]() {
        willSet {
            objectWillChange.send(self)
        }
    }

    init() {
        fetchSongs()
    }

    func fetchSongs() {
        guard let url = URL(string: ""https://api.genius.com/search?q=Sia"") else { return }
        var urlRequest = URLRequest(url: url)
        urlRequest.setValue(""Bearer TOKEN"", forHTTPHeaderField: ""Authorization"")

      URLSession.shared.dataTask(with: urlRequest) {data, response, error in
            guard let data = data else { return }
            //print(String(decoding: data, as: UTF8.self))
            let songs = try! JSONDecoder().decode(feed.self, from: data)
            DispatchQueue.main.async {
                self.fetchedSongsResults = songs.response.hits

            }
        }.resume()
    }
}
</code></pre>

<p>So when I get the data I save to the variable fetchedSongsResults and this seems correctly but for what ever reason when I try to print the count for example it says that i empty and also I can't loop through the fetchedSongsResults using a list or ForEach this is how, (which I believe s because I have not made the model identifiable) I tried to print the count of fetchedSongsResults, </p>

<p>This initialized outside the body (just so you know)</p>

<pre><code>@State var networkManager = NetworkManager()
</code></pre>

<p>This is inside the body </p>

<pre><code>Text(""\(networkManager.fetchedSongsResults.count)"")
</code></pre>

<p>If your are wondering how my structure looks like when I decode the JSON Data then here it is</p>

<pre><code>struct feed: Codable {
   var meta: meta
   var response: response
}

struct meta: Codable {
   var status: Int
}

struct response: Codable {
   var hits: [hits]
}

struct hits: Codable {
   var index: String
   var type: String
   var result: song
}

struct song: Codable, Identifiable {
   var id: Int
   var header_image_thumbnail_url: String
   var url: String
   var title: String
   var lyrics_state: String
   var primary_artist: artist

}

struct artist: Codable {
   var name: String
}
</code></pre>
","9912566","","1033581","","2019-11-16 00:09:31","2019-11-16 00:09:31","How do you display JSON Data in swiftUI","<json><swift><swiftui><urlsession>","1","3","1","","","CC BY-SA 4.0"
"58889764","1","58890084","","2019-11-16 10:30:58","","1","194","<p>I tried to follow the code snippet of WWDC 2019's <a href=""https://developer.apple.com/videos/play/wwdc2019/721/"" rel=""nofollow noreferrer"">Combine in Practice</a> talk (starting at minute 26:00) or see <a href=""https://devstreaming-cdn.apple.com/videos/wwdc/2019/721ga0kflgr4ypfx/721/721_combine_in_practice.pdf?dl=1"" rel=""nofollow noreferrer"">slides</a> 179 ff. but it won't compile and looking at the API some parts don't make sense to me (e.g., calling <code>CombineLatest.init(A, B)</code> with a third argument of type <code>closure</code>. I tried to adapt the examples so they compile.</p>

<h1>Question Part 1/2: Can someone help me out and let me know if I am misunderstanding the WWDC 2019 code snippets?</h1>

<h2>First code snippet (slide 179)</h2>

<pre><code>@Published var password: String = """"
@Published var passwordAgain: String = """"

var validatedPassword: CombineLatest&lt;Published&lt;String&gt;, Published&lt;String&gt;, String?&gt; {
    return CombineLatest($password, $passwordAgain) { password, passwordAgain in
        guard password == passwordAgain, password.count &gt; 8 else { return nil }
        return password
    }
}
</code></pre>

<p>I can only get this snippet to at least return me the <code>Publisher from</code>CombineLatest`</p>

<ul>
<li>adding the <code>Publishers</code> enum to the namespace of <code>CombineLatest</code></li>
<li>removing the trailing closure</li>
<li>adding <code>.Publisher</code> to <code>Published&lt;String&gt;</code></li>
</ul>

<pre><code>@Published var password: String = """"
@Published var passwordAgain: String = """"

var validatedPassword: Publishers.CombineLatest&lt;Published&lt;String&gt;.Publisher, Published&lt;String&gt;.Publisher&gt; {
    return Publishers.CombineLatest($password, $passwordAgain)
}
</code></pre>

<h3>Second code snippet (slide 185)</h3>

<pre><code>@Published var password: String = """"
@Published var passwordAgain: String = """"

var validatedPassword: Map&lt;CombineLatest&lt;Published&lt;String&gt;, Published&lt;String&gt;, String?&gt;&gt; {
    return CombineLatest($password, $passwordAgain) { password, passwordAgain in
        guard password == passwordAgain, password.count &gt; 8 else { return nil }
        return password
    }
    .map { $0 == ""password1"" ? nil : $0 }
}
</code></pre>

<p>I can get this snippet to compile when:</p>

<ul>
<li>doing all of the steps listed for the first snippet</li>
<li>Adding <code>Publishers.</code> in front of <code>Map</code></li>
<li>moving the <code>&lt;&gt;</code> to the correct position</li>
<li>returning <code>Publishers.Map</code> explicitly and by using the correct parameter <code>upstream:</code></li>
</ul>

<pre><code>@Published var password: String = """"
@Published var passwordAgain: String = """"

var validatedPassword: Publishers.Map&lt;Publishers.CombineLatest&lt;Published&lt;String&gt;.Publisher, Published&lt;String&gt;.Publisher&gt;, String?&gt; {
        return Publishers.Map(upstream: Publishers.CombineLatest($password, $passwordAgain)) { password, passwordAgain in
            guard password == passwordAgain, password.count &gt; 8 else { return nil }
            return password
    }
</code></pre>

<p>or when including the <code>.map {}</code> from the slide:</p>

<ul>
<li>by wrapping the var type in another <code>Publishers.Map&lt;..., String?&gt;</code></li>
</ul>

<pre><code>@Published var password: String = """"
@Published var passwordAgain: String = """"
var validatedPassword: Publishers.Map&lt;Publishers.Map&lt;Publishers.CombineLatest&lt;Published&lt;String&gt;.Publisher, Published&lt;String&gt;.Publisher&gt;, String?&gt;, String?&gt; {
        return Publishers.Map(upstream: Publishers.CombineLatest($password, $passwordAgain)) { password, passwordAgain in
            guard password == passwordAgain, password.count &gt; 8 else { return nil }
            return password
    }
    .map { $0 == ""password1"" ? nil : $0 }
}
</code></pre>

<h1>Question Part 2/2: What would be the swifty way to do this? e.g, by using something like this (which does not compile):</h1>

<pre><code>@Published var password: String = """"
@Published var passwordAgain: String = """"

var validatedPassword: AnyPublisher&lt;String?, Never&gt; {
    return Just($password)
        .combineLatest($passwordAgain) { password, passwordAgain in
            guard password == passwordAgain, password.count &gt; 8 else { return nil }
            return password
    }
    .map{ $0 == ""password1"" ? nil : $0 }
    .eraseToAnyPublisher()
}
</code></pre>
","3209393","","3209393","","2019-11-16 11:11:55","2019-11-16 11:40:05","Mistake in WWDC 2019 ""Combine in Practice"" Code example for CombineLatest?","<swift><generics><swiftui><combine><combinelatest>","1","0","","","","CC BY-SA 4.0"
"58906088","1","58906714","","2019-11-17 23:11:35","","2","968","<p>I am practicing trying to switch views using observable objects in SwiftUI, but my code isn't working.  I know I can do this with @State, but I would like to get this working with observable objects.  When I click on the image in the content view, the image doesn't change. Can someone help me?</p>

<p><strong>ContentView.swift</strong></p>

<pre><code>import SwiftUI

struct ContentView: View {

    @ObservedObject var viewRouter: ViewRouter


    var body: some View {

        VStack {

            Button(action: {self.viewRouter.currentPage = ""Page2""}) {
                Image(viewRouter.currentPage)
            }

            if viewRouter.currentPage == ""Page1"" {
                Page1(viewRouter: viewRouter)

            }else if viewRouter.currentPage == ""Page2"" {
                Page2(viewRouter: viewRouter)
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView(viewRouter: ViewRouter())
    }
  }
</code></pre>

<p><strong>ViewRouter.swift</strong></p>

<pre><code>import Foundation
import SwiftUI
import Combine

class ViewRouter: ObservableObject {

    let objectWillChange = PassthroughSubject&lt;ViewRouter, Never&gt;()

   @Published var currentPage: String = ""Page1""

  }
</code></pre>

<p><strong>Page1.swift</strong></p>

<pre><code>import SwiftUI

struct Page1: View {

    @ObservedObject var viewRouter:ViewRouter

    var body: some View {
        VStack {
         Image(""ET-LondonBridge"")
        }
    }
}

struct Page1_Previews: PreviewProvider {
    static var previews: some View {
        Page1(viewRouter: ViewRouter())
    }
}
</code></pre>

<p><em>Page2.swift</em></p>

<pre><code>import SwiftUI

struct Page2: View {

    @ObservedObject var viewRouter:ViewRouter

    var body: some View {
        VStack {
            Image(""BigBen"")
                .aspectRatio(contentMode: .fit)
        }
    }
}

struct Page2_Previews: PreviewProvider {
    static var previews: some View {
        Page2(viewRouter: ViewRouter())
    }
}
</code></pre>
","12369273","","","","","2019-11-18 00:56:34","Switching Views With Observable Objects in SwiftUI","<swift><navigation><observable><swiftui>","1","0","","","","CC BY-SA 4.0"
"58916886","1","58917498","","2019-11-18 14:33:48","","0","7599","<p>I'm doing a page which consists of 5 Options with radio buttons. When we tap on an option the colour of the element should change. I'm fetching those options from API response. I'm using the MVVM model. I am attaching the code below. </p>

<p>What I'm struggling with is when I change a boolean value, it is not changing!!!</p>

<p><strong>View Model code</strong> </p>

<pre><code>import Foundation
import Combine

class DCListViewModel: ObservableObject {
    @Published var DCList = [DCViewModel]()

    init() {
        fetchDcs()
    }

    func fetchDcs() {
        ARMServices().getAllDc { (dcArr) in
            if let dcArr = dcArr {
                for dc in dcArr{
                    self.DCList.append(DCViewModel(dc: dc, isSelected: false))
                }
            }
        }
    }
}


class DCViewModel {
    var id = UUID()
    var dcStruct: DC
    var isSelected: Bool

    init(dc: DC, isSelected: Bool) {
        self.dcStruct = dc
        self.isSelected = isSelected
    }

    var url: String {
        return self.dcStruct.url  ?? ""empty URL""
    }

    var dc: String {
        return self.dcStruct.dc ?? ""empty dc name""
    }
}
</code></pre>

<p><strong>View Page Code</strong></p>

<pre><code>struct SelectTableView: View {

    var body: some View {
        NavigationView {

                VStack {
                    DCListView(dcList: self.dcListVM.DCList)
                        .padding(.horizontal)
                }
            .navigationBarTitle(""Select the Data Centre"")
        }
    }
}


struct DCListView: View{
    var dcList: [DCViewModel]

    init(dcList: [DCViewModel]) {
        self.dcList = dcList
    }

    var body: some View {
        ForEach(self.dcList, id: \.id) { dc in
            Button(action: {
                print(""Tapped"")
                dc.isSelected.toggle()
            }){
                ZStack {
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(dc.isSelected ? Color.init(""borderSelected""): Color.init(""border""))
                        .frame(height: 56)
                        .foregroundColor(.clear)

                    HStack {
                        Text(dc.dc)
                            .font(.custom(""Montserrat"", size: 16))
                            .fontWeight(.medium)
                            .foregroundColor(dc.isSelected ? Color.init(""borderSelected"") : .white)
                            .padding()

                        Spacer()

                        ZStack {
                            Circle()
                                .stroke(dc.isSelected ? Color.init(""borderSelected"") : Color(""circleBorder""))
                                .frame(width: 18, height: 18)
                                .padding()

                            Circle()
                                .frame(width: 10, height: 10)
                                .foregroundColor(dc.isSelected ? Color.init(""borderSelected""): Color.clear)
                        }
                    }
                }
            }
        }
    }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/KjsyJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KjsyJ.png"" alt=""The page looks like this""></a></p>
","11134288","","","","","2021-10-06 13:19:27","SwiftUI: How to change @Published object value. Changing a value of a published variable is not working","<ios><swift><swiftui>","3","0","","","","CC BY-SA 4.0"
"58917729","1","58919279","","2019-11-18 15:18:52","","1","199","<p>How do I figure out the flatMap, reduce, etc. to turn this into an array of ProductRep?</p>

<p>I'm currently getting <code>Cannot convert value of type 'Publishers.Map&lt;URLSession.DataTaskPublisher, [StoreService.ProductRep]?&gt;' to closure result type 'StoreService.ProductRep'</code> - because I don't really understand how to turn a <code>Publishers.Map</code> into the actual thing. 
This is intended to be part of a larger network of publishers and subscribers using map/flatMap.</p>

<pre><code>let mapResult: [ProductRep] = parsePageURIs(firstPage, jsonDict)
            .map { pageUri in self.importProductsPublisher(pageUri, urlSession: urlSession, firstPage: false) }
            .map { publisher in publisher.map {(productsData, productsResponse) in
                    return self.handleImportProductsResponse(data: productsData, response: productsResponse, category: category, urlSession: urlSession)
                }
        }
func importProductsPublisher(_ uri: String, urlSession: URLSession, firstPage: Bool) -&gt; URLSession.DataTaskPublisher { /* Start the network query */ }
func handleImportProductsResponse(data: Data, response: URLResponse, category: CategoryRep, urlSession: URLSession) -&gt; [ProductRep]? { /* Handle the result of the network query and parse into an array of items (ProductRep) */ }
</code></pre>
","79252","","","","","2019-11-18 16:55:26","Convert '[Publishers.Map<URLSession.DataTaskPublisher, [ProductRep]?>]' to [ProductRep]","<swift><functional-programming><combine>","1","0","","","","CC BY-SA 4.0"
"58919537","1","58920937","","2019-11-18 16:58:50","","6","698","<p>I am creating a compass application in swiftUI.  It works, but when I add animation to move the compass, the behavior below appears:</p>

<p><a href=""https://i.stack.imgur.com/B5CPR.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B5CPR.gif"" alt=""application screen shot""></a></p>

<p>For example, when it goes from the 5° orientation to 350° it decides to do a complete turn. It is not the natural behavior for a compass.</p>

<p>My ContentView code:</p>

<pre><code>import SwiftUI
import CoreLocation

struct ContentView: View {

  var locationManager = CLLocationManager()
  @ObservedObject var location: LocationProvider = LocationProvider()
  @State var angle: CGFloat = 0

  var body: some View {
    GeometryReader { geometry in
      VStack {
        Rectangle()
          .frame(width: 10, height: 30)
          .background(Color(.red))
          .foregroundColor(Color(.clear))
        Spacer()
        Text(String(Double(self.location.currentHeading).stringWithoutZeroFraction) + ""°"")
          .font(.system(size: 40))
          .foregroundColor(Color(.black))
        Spacer()
      }
      .frame(width: 300, height: 300, alignment: .center)
      .border(Color(.black))
      .onReceive(self.location.heading) { heading in
        withAnimation(.easeInOut(duration: 0.2)) {
          self.angle = heading
        }
      }
      .modifier(RotationEffect(angle: self.angle))
    }.background(Color(.white))
  }
}

struct RotationEffect: GeometryEffect {
  var angle: CGFloat

  var animatableData: CGFloat {
    get { angle }
    set { angle = newValue }
  }

  func effectValue(size: CGSize) -&gt; ProjectionTransform {
    return ProjectionTransform(
      CGAffineTransform(translationX: -150, y: -150)
        .concatenating(CGAffineTransform(rotationAngle: -CGFloat(angle.degreesToRadians)))
        .concatenating(CGAffineTransform(translationX: 150, y: 150))
    )
  }
}

public extension CGFloat {
  var degreesToRadians: CGFloat { return self * .pi / 180 }
  var radiansToDegrees: CGFloat { return self * 180 / .pi }
}

public extension Double {
  var degreesToRadians: Double { return Double(CGFloat(self).degreesToRadians) }
  var radiansToDegrees: Double { return Double(CGFloat(self).radiansToDegrees) }

  var stringWithoutZeroFraction: String {
    return truncatingRemainder(dividingBy: 1) == 0 ? String(format: ""%.0f"", self) : String(self)
  }
}

struct ContentView_Previews: PreviewProvider {
  static var previews: some View {
    ContentView()
  }
}
</code></pre>

<p>Here, I'm using the <code>CGAffineTransform</code> to rotate the compass with a matrix animation to solve the problem. I thought this would work because when I used this method in UIKit, the problem did not exist.</p>

<p>My LocationProvider code:</p>

<pre><code>import SwiftUI
import CoreLocation
import Combine

public class LocationProvider: NSObject, CLLocationManagerDelegate, ObservableObject {

  private let locationManager: CLLocationManager
  public let heading = PassthroughSubject&lt;CGFloat, Never&gt;()

  @Published var currentHeading: CGFloat {
    willSet {
      heading.send(newValue)
    }
  }

  public override init() {
    currentHeading = 0
    locationManager = CLLocationManager()
    super.init()
    locationManager.delegate = self
    locationManager.desiredAccuracy = kCLLocationAccuracyBest
    locationManager.startUpdatingHeading()
    locationManager.requestWhenInUseAuthorization()
  }

  public func updateHeading() {
    locationManager.startUpdatingHeading()
  }

  public func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {
    DispatchQueue.main.async {
      self.currentHeading = CGFloat(newHeading.trueHeading)
    }
  }
}
</code></pre>

<p>How can I resolve this problem?</p>
","7037428","","2565958","","2019-11-18 17:59:55","2019-11-19 14:23:36","How can I fix my compass application that makes a complete turn when going 359° from 0°?","<swift><swiftui><360-degrees>","2","4","1","","","CC BY-SA 4.0"
"58926143","1","58927372","","2019-11-19 03:22:10","","2","274","<p>I'm reading data from Firestore using <code>.addSnapshotListener</code> and parsing it to a custom model <code>Thought</code></p>

<p>For each document in my Firestore collection I append a new <code>Thought</code> object to a <code>@Published var thoughts</code> and iterate through <code>thoughts</code> in a <code>List</code>.</p>

<pre><code>struct Thought: Identifiable {

    public var id: String?
    public var name: String
    public var thought: String
    public var color: String
}

class Observer: ObservableObject {

    @Published var thoughts = [Thought]()

    init(){

        self.thoughts.removeAll()

        let db = Firestore.firestore()

        db.collection(""thoughts"")
        .addSnapshotListener { querySnapshot, error in
            guard let documents = querySnapshot?.documents else {
                print(""Error fetching documents: \(error!)"")
                return
            }

            for document in documents {

                var thoughtModel = Thought(id: """", name: """", thought: """", color: """")

                thoughtModel.name = document.data()[""name""] as! String
                thoughtModel.thought = document.data()[""thought""] as! String
                thoughtModel.color = document.data()[""color""] as! String

                self.thoughts.append(thoughtModel)
            }
        }
    }
}

struct ThoughtsView: View {

    @ObservedObject var observer = Observer()

    var body: some View {
        VStack {
            List {
                ForEach(self.observer.thoughts, id: \.name) { thought in

                    ThoughtCard(color: thought.color,
                                thought: thought.thought,
                                name: thought.name)
                }
            }
        }
    }
}
</code></pre>

<p>When I make changes or add a document in my Firestore collection all objects are appended to my <code>List</code> instead of my <code>List</code> just being updated like I expect. In other words, if I have 3 items in my <code>List</code>, and I change a value in one of the Firestore documents I end up with 6 items in my <code>List</code> consisting of the original 3, and a duplicate of the original 3 (modified).</p>

<p>How do I properly update my <code>List</code>?</p>
","6035021","","","","","2019-11-19 05:43:17","Why is my SwiftUI List appending all objects again instead of updating existing objects?","<swift><google-cloud-firestore><swiftui><combine><swiftui-list>","1","1","","","","CC BY-SA 4.0"
"58937678","1","58977297","","2019-11-19 15:36:18","","2","1514","<p>My apologies if this is not the right question to ask, as I am completely new to SwiftUI and iOS programming in general.  The question indicates what I want to do, and the error I'm getting I believe is a red herring because of the SwiftUI compiler.  It's likely that I am taking the incorrect approach to solving this problem altogether.</p>

<p>I am using XCode Version 11.2.1 (11B500)</p>

<p>View utilizing the ObservedObject:</p>

<pre class=""lang-swift prettyprint-override""><code>struct Results: View {
    var jobId: String
    @ObservedObject var jobDetailService: JobDetailService

    init(jobId: String) {
        self.jobId = jobId
        jobDetailService = JobDetailService(jobId: jobId)
    }

    var body: some View {
        //... view code here
    }

}
</code></pre>

<p>And it is within this view that I am getting the error (at the ZStack line) ""Generic parameter 'C0' could not be inferred"".  When I comment out the <code>NavigationLink</code> block, the error goes away.  Further, when the <code>Results</code> view does not depend on the <code>jobId</code> parameter (and we construct <code>JobDetailService</code> inline with <code>@ObservedObject var jobDetailService = JobDetailService()</code>, this all works.  However, I need to be able to pass the <code>jobId</code> parameter to the <code>JobDetailService</code> in order to make the network call to fetch and publish the data.</p>

<pre class=""lang-swift prettyprint-override""><code>struct JobList: View {
    @ObservedObject var jobListService = JobListService()

    var body: some View {
        NavigationView {
            List(jobListService.jobs) {job in
                ZStack {
                    JobCard(name: job.fullName, date: job.lastUpdated)
                    NavigationLink(destination: Results(jobId: job.jobId)) {
                        EmptyView()
                    }
                }
            }
        }
     }
 }

</code></pre>
","4215892","","4215892","","2019-11-19 15:48:29","2019-11-21 14:30:25","How to initialize an ObservedObject from a view created with a NavigationLink?","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"58938988","1","58941035","","2019-11-19 16:42:37","","1","771","<p>Sample of what I need:</p>

<p><a href=""https://i.stack.imgur.com/3me3X.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3me3X.gif"" alt=""введите сюда описание изображения""></a>
.</p>

<p>As there is absent <code>.onAnimationCompleted { // Some work... }</code> its pretty problematic.</p>

<p>Generally I need the solution that will have a following characteristics:</p>

<ol>
<li><strong>Most short and elegant way of playing some ping-pong animation ONCE.</strong> Not infinite!</li>
<li><strong>Make code reusable.</strong> As example - made it as ViewModifier.</li>
<li><strong>To have a way to call animation externally</strong></li>
</ol>

<p>my code:</p>

<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    @State var descr: String = """"
    @State var onError = PassthroughSubject&lt;Void, Never&gt;()

    var body: some View {
        VStack {
            BlurredTextField(title: ""Description"", text: $descr, onError: $onError)
            Button(""Commit"") {
                if self.descr.isEmpty {
                    self.onError.send()
                }
            }
        }
    }
}

struct BlurredTextField: View {
    let title: String
    @Binding var text: String
    @Binding var onError: PassthroughSubject&lt;Void, Never&gt;
    @State private var anim: Bool = false
    @State private var timer: Timer?
    @State private var cancellables: Set&lt;AnyCancellable&gt; = Set()
    private let animationDiration: Double = 1

    var body: some View {
        TextField(title, text: $text)
            .blur(radius: anim ? 10 : 0)
            .animation(.easeInOut(duration: animationDiration))
            .onAppear {
                self.onError
                    .sink(receiveValue: self.toggleError)
                    .store(in: &amp;self.cancellables)
        }
    }

    func toggleError() {
        timer?.invalidate()// no blinking hack
        anim = true
        timer = Timer.scheduledTimer(withTimeInterval: animationDiration, repeats: false) { _ in
            self.anim = false
        }
    }
}
</code></pre>
","4423545","","3088606","","2019-11-19 19:31:30","2020-11-25 22:31:18","SwiftUI: how to play ping-pong animation once? Correct way to play animation forward and backward?","<swift><swiftui>","2","1","0","","","CC BY-SA 4.0"
"58942207","1","58942349","","2019-11-19 20:20:08","","5","2144","<p>I've got a view with two text fields and a save button. How can I possibly change my button's state depending on the contents of the text fields (I'd like to enable the button only in case all text fields are not empty)? Here's my current code:</p>

<pre><code>// The variables associated with text fields
@State var name: String = """"
@State var type: String = """"

// I'd like to associate this variable with
// my button's disabled / enabled state,
// but the function responsible for it doesn't accept bindings
@State var canSave: Bool = false

var body: some View {
    Form {
        TextField(""Name"", text: $name)
        TextField(""Type"", text: $type)

        Button(action: {
            // ...
        }, label: {
            Text(""Save"")
        })
            .disabled(!canSave) // no bindings allowed here; what to use indead?
    }
}
</code></pre>

<p>I have an idea that I should use <code>combineLatest</code> from the newest Combine framework. But whatever I try to google leads me to RxSwift-related topics and not actual Combine implementation.</p>
","9850339","","9850339","","2019-11-20 10:13:24","2019-11-20 10:13:24","SwiftUI: Enable save button only when the inputs are not empty","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"58945952","1","58983929","","2019-11-20 02:57:22","","0","454","<p>The following pipeline:</p>

<pre><code>enum MyError: Error {
  case oops
}
let cancel = Fail&lt;Int, Error&gt;(error: MyError.oops)
  .print(""1&gt;"")
  .print(""2&gt;"")
  .sink(receiveCompletion: { status in
    print(""status&gt;"", status)
  }) { value in
    print(""value&gt;"", value)
}

</code></pre>

<p>Outputs:</p>

<pre><code>1&gt;: receive subscription: (Empty)
2&gt;: receive subscription: (Print)
2&gt;: request unlimited
1&gt;: request unlimited
1&gt;: receive error: (oops)
2&gt;: receive error: (oops)
status&gt; failure(__lldb_expr_126.MyError.oops)
</code></pre>

<h3>The problem</h3>

<p>However, if I insert a <code>receive(on:)</code> operator into the previous pipeline:</p>

<pre><code>enum MyError: Error {
  case oops
}
let cancel = Fail&lt;Int, Error&gt;(error: MyError.oops)
  .print(""1&gt;"")
  .receive(on: RunLoop.main)
  .print(""2&gt;"")
  .sink(receiveCompletion: { status in
    print(""status&gt;"", status)
  }) { value in
    print(""value&gt;"", value)
}
</code></pre>

<p>the output is:</p>

<pre><code>1&gt;: receive subscription: (Empty)
1&gt;: receive error: (oops)
</code></pre>

<p>The <code>receive</code> operator seems to short-circuit the pipeline. I haven't seen it happen for other publishers, just when I use a <code>Fail</code> or <code>PassthroughSubject</code> publisher.</p>

<p><strong>Is this expected behavior? If so, what's the reason for it?</strong></p>

<hr>

<h3>Workaround</h3>

<p>Here's an example of creating a failing publisher that works with the <code>receive(on:)</code> publisher:</p>

<pre><code>struct FooModel: Codable {
  let title: String
}

func failPublisher() -&gt; AnyPublisher&lt;FooModel, Error&gt; {
  return Just(Data(base64Encoded: """")!)
    .decode(type: FooModel.self, decoder: JSONDecoder())
    .eraseToAnyPublisher()
}

let cancel = failPublisher()
  .print(""1&gt;"")
  .receive(on: RunLoop.main)
  .print(""2&gt;"")
  .sink(receiveCompletion: { status in
    print(""status&gt;"", status)
  }) { value in
    print(""value&gt;"", value)
}
</code></pre>
","1102215","","1102215","","2019-11-20 05:19:07","2019-11-21 21:19:36","Why does Combine's receive(on:) operator swallow errors?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"58957327","1","58959008","","2019-11-20 14:58:50","","8","10745","<p>I have a basic view that displays a list that fetches data from an API. I want to implement an activity indicator while the data is being retrieved from the API. In MVC we could use a delegate and protocol and make the view controller inherit the protocol, and after the model has finished fetching the data we call the delegate to tell the view controller that the data has finished retrieving (now hide the activity indicator, etc.). How to achieve a similar thing in SwiftUI and it's MVVM style?</p>

<p>I have tried implementing an activity indicator from this question, I just don't get how and when to stop it: <a href=""https://stackoverflow.com/questions/56496638/activity-indicator-in-swiftui"">Activity indicator in SwiftUI</a></p>

<p>My SourcesViewModel (it fetches news article sources from newsapi.org)</p>

<pre><code>import UIKit

class SourcesViewModel: Identifiable {

    let id = UUID()

    let source: Sources

    init(source: Sources) {
        self.source = source
    }

    var name: String {
        return self.source.sourceName
    }

    var description: String {
        return self.source.sourceDescription
    }
}
</code></pre>

<p>My SourcesListViewModel:</p>

<pre><code>import Combine

class SourcesListViewModel: ObservableObject {

    init() {
        fetchSources()
    }

    @Published var sources = [SourcesViewModel]()
    private func fetchSources() {
        NetworkManager.shared.getSourceData { (sources) in
            self.sources = sources.map(SourcesViewModel.init)
        }
    }
}
</code></pre>

<p>Lastly, my SourcesView:</p>

<pre><code>import SwiftUI

struct SourcesView: View {
    @ObservedObject var model = SourcesListViewModel()

    var body: some View {
        ActivityIndicatorView(isShowing: .constant(true)) {
            NavigationView {
                List(self.model.sources) { source in
                    VStack(alignment: .center) {
                        Text(source.name)

                        Text(source.description)
                            .foregroundColor(.secondary)
                            .lineLimit(3)
                    }
                    .navigationBarTitle(Text(""Sources""), displayMode: .inline)
                }
            }
        }
    }
}


struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        SourcesView()
    }
}
</code></pre>

<p>The result:</p>

<p><a href=""https://i.stack.imgur.com/sgkQX.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/sgkQX.png"" alt=""how to stop loading""></a></p>
","8950538","","","","","2019-11-20 17:35:44","Displaying activity indicator while loading async request in SwiftUI","<ios><swift><cocoa><swiftui>","2","0","4","","","CC BY-SA 4.0"
"58963760","1","58963944","","2019-11-20 21:36:47","","1","64","<p><a href=""https://streamable.com/3wtus"" rel=""nofollow noreferrer"">https://streamable.com/3wtus</a></p>

<p>I first display a login screen, which has a green background, then the user taps login, and sees the profile view, which has a green unwanted thing at the top. </p>

<p>My goal is to use the NavigationView on my whole screen. You can clearly see that the views are overlapping.</p>

<p>Here is my code for presenting the views:</p>

<p><strong>ViewRouter</strong></p>

<pre><code>class ViewRouter: ObservableObject {
   let objectWillChange = PassthroughSubject&lt;ViewRouter,Never&gt;()

   var currentPage: String = ""login"" {
      didSet {
          objectWillChange.send(self)
      }
   }
}
</code></pre>

<p><strong>MotherView</strong></p>

<pre><code>struct MotherView: View {
   @State var page = ""login""
   @ObservedObject var viewRouter: ViewRouter
   @State var user = """"
   @State var pass = """"
   @State var login = false
   @State var signup = false

   var body: some View {
       ZStack {
           LinearGradient(gradient: .init(colors: [Color(""1""),Color(""2"")]), startPoint: .leading, endPoint: .trailing).edgesIgnoringSafeArea(.all)
           if viewRouter.currentPage == ""login"" {
               Login(login: $login, signup: $signup, user: $user, pass: $pass, viewRouter: viewRouter)

           } else if viewRouter.currentPage == ""main"" {
               Main()
          }
       }.alert(isPresented: $login) {

        Alert(title: Text(self.user), message: Text(self.pass), dismissButton: .none)

       }.sheet(isPresented: $signup) {

        signUp(signup: self.$signup)
       }
     }
  }
</code></pre>

<p><strong>Main</strong></p>

<pre><code>struct Main: View {
   var body: some View {

        TabView {
            Profile()
                .tabItem {
                    Image(systemName: ""1.circle"")
                    Text(""Profile"")

                }.tag(0)

            Text(""Leaderboards"")
                .tabItem {
                    Image(systemName: ""2.circle"")
                    Text(""Leaderboards"")

                }.tag(1)

            Text(""News"")
                .tabItem {
                    Image(systemName: ""3.circle"")
                    Text(""News"")
                }.tag(2)
        }
    }
}
</code></pre>

<p><strong>Profile</strong></p>

<pre><code>struct Profile: View {
var body: some View {
    NavigationView{
        Text(""Profile"")
        .navigationBarTitle(""Profile"", displayMode: .large)
    }
   }
}
</code></pre>

<p>I have tried to set an offset and padding to the <strong>NavigationView</strong> in the <strong>Profile</strong> struct, but it did not result in anything.</p>
","10112162","","8867780","","2019-11-21 06:57:06","2019-11-21 06:57:06","How do I remove the spacing between the NavigationView and the top view? (Profile view)","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"58977360","1","58978323","","2019-11-21 14:33:01","","1","1483","<p>I am having troubles with running view methods on published property value change. My playground sample code looks like this:</p>

<pre><code>class MyFoo: ObservableObject {
    @Published var bar: String
    init(bar: String) {
        self.bar = bar
    }

    func setNewText(newString: String) {
        self.bar = newString
    }

    func runFunctions() {
        setNewText(newString: ""Test"")
    }
}

struct TestView: View {
    @ObservedObject let foo = MyFoo(bar: ""bar0"")

    init(){
        let barSink = foo.$bar
            .sink() { //THIS IS WHERE I GET ERROR ""Escaping closure captures mutating 'self' parameter""
                self.printResult(result: $0)
            }
    }

    func printResult(result: String) {
        print(result)
    }
}

let a = TestView()
</code></pre>

<p>Basically I know why I get this error in closure but I don't know how to go around it. Is this the right approach for running view methods on VM published property value changed? </p>

<p>I need this because I am using custom spinner that is not SwiftUI ready so I cant bind to it, and the only way to show/hide it is by calling its methods.</p>

<p>Any help would be most appreciated</p>
","2707795","","2707795","","2019-11-21 15:24:13","2019-11-21 15:26:27","SwiftUI run method on view when Published view model member value changes","<ios><swift><xcode><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"58984109","1","59007863","","2019-11-21 21:34:02","","3","1543","<p>I am having some trouble avoiding index out of range errors when modifying an array that a child view depends on a bound object from.</p>
<p>I have a parent view called WorkoutList. WorkoutList has an EnvironmentObject of ActiveWorkoutStore. ActiveWorkoutStore is an ObservableObject that has an array of Workout objects. I have a list of active workouts being retrieved from ActiveWorkoutStore. I'm using a ForEach loop to work with the indices of these active workouts and pass an object binding to a child view called EditWorkout as a destination for a NavigationLink. EditWorkout has a button to finish a workout, which removes it from ActiveWorkoutStore's array of workouts and adds it to WorkoutHistoryStore. I'm running into trouble when I remove this object from ActiveWorkoutStore's activeWorkouts array, immediately causing an index out of range error. I'm suspecting this is because the active view relies on a bound object that I've just deleted. I've tried a couple permutations of this, including passing a workout to EditWorkout, then using its id to reference a workout in ActiveWorkoutStore to perform my operations, but run into similar troubles. I've seen a lot of examples online that follow this pattern of leveraging ForEach to iterate over indices and I've mirrored it as best I can tell, but I suspect I may be missing a nuance to the approach.</p>
<p>I've attached code samples below. Let me know if you have any questions or if there's anything else I should include! Thanks in advance for your help!</p>
<h1>WorkoutList (Parent View)</h1>
<pre><code>import SwiftUI

struct WorkoutList: View {
    @EnvironmentObject var activeWorkoutsStore: ActiveWorkoutStore
    @State private var addExercise = false
    @State private var workoutInProgress = false

    var newWorkoutButton: some View {
        Button(action: {
            self.activeWorkoutsStore.newActiveWorkout()
        }) {
            Text(&quot;New Workout&quot;)
            Image(systemName: &quot;plus.circle&quot;)
        }
    }

    var body: some View {
        NavigationView {
            Group {
                if activeWorkoutsStore.activeWorkouts.isEmpty {
                    Text(&quot;No active workouts&quot;)
                } else {
                    List {
                        ForEach(activeWorkoutsStore.activeWorkouts.indices.reversed(), id: \.self) { activeWorkoutIndex in
                            NavigationLink(destination: EditWorkout(activeWorkout: self.$activeWorkoutsStore.activeWorkouts[activeWorkoutIndex])) {
                                Text(self.activeWorkoutsStore.activeWorkouts[activeWorkoutIndex].id.uuidString)
                            }
                        }
                    }
                }
            }
            .navigationBarTitle(Text(&quot;Active Workouts&quot;))
            .navigationBarItems(trailing: newWorkoutButton)
        }
    }
}
</code></pre>
<h1>EditWorkout (Child View)</h1>
<pre><code>//
//  EditWorkout.swift
//  workout-planner
//
//  Created by Dominic Minischetti III on 11/2/19.
//  Copyright © 2019 Dominic Minischetti. All rights reserved.
//

import SwiftUI

struct EditWorkout: View {
    @EnvironmentObject var workoutHistoryStore: WorkoutHistoryStore
    @EnvironmentObject var activeWorkoutStore: ActiveWorkoutStore
    @EnvironmentObject var exerciseStore: ExerciseStore
    @Environment(\.presentationMode) var presentationMode
    @State private var addExercise = false
    @Binding var activeWorkout: Workout
    
    var currentDayOfWeek: String {
        let weekdayIndex = Calendar.current.component(.weekday, from: Date())
        return Calendar.current.weekdaySymbols[weekdayIndex - 1]
    }

    var chooseExercisesButton: some View {
        Button (action: {
            self.addExercise = true
        }) {
            HStack {
                Image(systemName: &quot;plus.square&quot;)
                Text(&quot;Choose Exercises&quot;)
            }
        }
        .sheet(isPresented: self.$addExercise) {
            AddWorkoutExercise(exercises: self.$activeWorkout.exercises)
                .environmentObject(self.exerciseStore)

        }
    }
    
    var saveButton: some View {
        Button(action: {
            self.workoutHistoryStore.addWorkout(workout: self.$activeWorkout.wrappedValue)
            self.activeWorkoutStore.removeActiveWorkout(workout: self.$activeWorkout.wrappedValue)
            self.presentationMode.wrappedValue.dismiss()
        }) {
            Text(&quot;Finish Workout&quot;)
        }
        .disabled(self.$activeWorkout.wrappedValue.exercises.isEmpty)
    }

    var body: some View {
        Form {
            Section(footer: Text(&quot;Choose which exercises are part of this workout&quot;)) {
                chooseExercisesButton
            }
            Section(header: Text(&quot;Exercises&quot;)) {
                if $activeWorkout.wrappedValue.exercises.isEmpty {
                    Text(&quot;No exercises&quot;)
                } else {
                    ForEach(activeWorkout.exercises.indices, id: \.self) { exerciseIndex in
                        NavigationLink(destination: EditWorkoutExercise(exercise: self.$activeWorkout.exercises[exerciseIndex])) {
                            VStack(alignment: .leading) {
                                Text(self.activeWorkout.exercises[exerciseIndex].name)
                                Text(&quot;\(self.activeWorkout.exercises[exerciseIndex].sets.count) Set\(self.activeWorkout.exercises[exerciseIndex].sets.count == 1 ? &quot;&quot; : &quot;s&quot;)&quot;)
                                    .font(.footnote)
                                    .opacity(0.5)
                            }
                        }
                    }
                    saveButton
                }
            }
        }
        .navigationBarTitle(Text(&quot;Edit Workout&quot;), displayMode: .inline )
    }
}
</code></pre>
<h1>ActiveWorkoutStore</h1>
<pre><code>import Foundation
import Combine

class ActiveWorkoutStore: ObservableObject {
    @Published var activeWorkouts: [Workout] = []
    
    func newActiveWorkout() {
        activeWorkouts.append(Workout())
    }
    
    func saveActiveWorkout(workout: Workout) {
        let workoutIndex = activeWorkouts.firstIndex(where: { $0.id == workout.id })!
        
        activeWorkouts[workoutIndex] = workout
    }
    
    func removeActiveWorkout(workout: Workout) {
        if let workoutIndex = activeWorkouts.firstIndex(where: { $0.id == workout.id }) {
            activeWorkouts.remove(at: workoutIndex)
        }
    }
}
</code></pre>
<h1>Workout</h1>
<pre><code>import SwiftUI

struct Workout: Hashable, Codable, Identifiable {
    var id = UUID()
    var date = Date()
    var exercises: [WorkoutExercise] = []
}
</code></pre>
","7257981","","-1","","2020-06-20 09:12:55","2019-11-23 12:56:59","'Fatal error: index out of range' when deleting bound object in view","<swift><swiftui>","1","3","0","","","CC BY-SA 4.0"
"58996403","1","58996712","","2019-11-22 14:34:31","","16","3851","<p>I'm trying to display an activity indicator when performing an async request.
What I did is creating an ActivityTracker object that will track life cycle of a publisher.
This ActivityTracker is an ObservableObject and will be stored in the view model which also is an ObservableObject.</p>

<p>It seems that this kind of setup isn't refreshing the View. Here's my code:</p>

<pre><code>struct ContentView: View {
    @ObservedObject var viewModel = ContentViewModel()

    var body: some View {
        VStack(spacing: 16) {
            Text(""Counter: \(viewModel.tracker.count)\nPerforming: \(viewModel.tracker.isPerformingActivity ? ""true"" : ""false"")"")

            Button(action: {
                _ = request().trackActivity(self.viewModel.tracker).sink { }
            }) {
                Text(""Request"")
            }
        }
    }
}

class ContentViewModel: ObservableObject {
    @Published var tracker = Publishers.ActivityTracker()
}

private func request() -&gt; AnyPublisher&lt;Void, Never&gt; {
    return Just(()).delay(for: 2.0, scheduler: RunLoop.main)
        .eraseToAnyPublisher()
}

extension Publishers {
    final class ActivityTracker: ObservableObject {
        // MARK: Properties

        @Published var count: Int = 0

        var isPerformingActivity: Bool {
            return count &gt; 0
        }

        private var cancellables: [AnyCancellable] = []
        private let counterSubject = CurrentValueSubject&lt;Int, Never&gt;(0)
        private let lock: NSRecursiveLock = .init()

        init() {
            counterSubject.removeDuplicates()
                .receive(on: RunLoop.main)
                .print()
                .sink { [weak self] counter in
                    self?.count = counter
                }
                .store(in: &amp;cancellables)
        }

        // MARK: Private methods

        fileprivate func trackActivity&lt;Value, Error: Swift.Error&gt;(
            ofPublisher publisher: AnyPublisher&lt;Value, Error&gt;
        ) {
            publisher
                .receive(on: RunLoop.main)
                .handleEvents(
                    receiveSubscription: { _ in self.increment() },
                    receiveOutput: nil,
                    receiveCompletion: { _ in self.decrement() },
                    receiveCancel: { self.decrement() },
                    receiveRequest: nil
                )
                .print()
                .sink(receiveCompletion: { _ in }, receiveValue: { _ in })
                .store(in: &amp;cancellables)
        }

        private func increment() {
            lock.lock()
            defer { lock.unlock() }
            counterSubject.value += 1
        }

        private func decrement() {
            lock.lock()
            defer { lock.unlock() }
            counterSubject.value -= 1
        }
    }
}

extension AnyPublisher {
    func trackActivity(_ activityTracker: Publishers.ActivityTracker) -&gt; AnyPublisher {
        activityTracker.trackActivity(ofPublisher: self)
        return self
    }
}
</code></pre>

<p>I also tried to declare my ActivityTracker as <code>@Published</code> but same result, my text is not updated.
Note that storing the activity tracker directly in the view will work but this is not what I'm looking for.</p>

<p>Did I miss something here ?</p>
","1224751","","","","","2020-09-28 20:17:09","ObservedObject inside ObservableObject not refreshing View","<ios><swift><swiftui><combine>","2","0","7","","","CC BY-SA 4.0"
"58998940","1","59381886","","2019-11-22 17:17:46","","1","975","<pre><code>publisher.collect(&lt;#T##strategy: Publishers.TimeGroupingStrategy&lt;Scheduler&gt;##Publishers.TimeGroupingStrategy&lt;Scheduler&gt;#&gt;)
</code></pre>

<p>I couldn't find any example anywhere and the <a href=""https://developer.apple.com/documentation/combine/publishers/timegroupingstrategy"" rel=""nofollow noreferrer"">documentation</a> is bland... free <a href=""https://heckj.github.io/swiftui-notes/#reference-collectbytime"" rel=""nofollow noreferrer"">Using Combine</a> book has nothing interesting as well.</p>
","12106051","","","","","2019-12-17 20:50:16","How to use collect(.byTime) or collect(.byTimeOrCount) in Combine","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"59018112","1","59024012","","2019-11-24 13:24:58","","1","226","<p>I have an array of strings that I would like to map into different objects. I'm using map to transform the array to another, but it's very nested:</p>

<pre><code>$favorites
    .map { articleIDs in
        articleIDs.compactMap { id in
            state.articles.first { $0.id == id }
        }
    }
    .assign(to: \Self.favorites, on: self)
    .store(in: &amp;cancellable)
</code></pre>

<p>Is there a shorthand to applying a transform to each individual item? I was originally trying to do this but it didn't work:</p>

<pre><code>state.$favorites
    .mapEach { id in state.articles.first { $0.id == id } }
    .assign(to: \Self.favorites, on: self)
    .store(in: &amp;cancellable)
</code></pre>
","235334","","235334","","2019-11-24 23:06:50","2019-11-25 16:52:58","How to avoid nesting closures when mapping Combine arrays?","<swift><combine>","1","4","","","","CC BY-SA 4.0"
"59018880","1","59019302","","2019-11-24 14:46:39","","16","5379","<p>In the Combine framework, we can throw a generic <code>Error</code> protocol type while using <code>tryMap</code>.</p>

<p>However, how can we be more specific about the <code>Error</code> type?</p>

<p>For example,</p>

<pre class=""lang-swift prettyprint-override""><code>let publisher = urlSession.dataTaskPublisher(for: request).tryMap { (data, response) -&gt; (Data, HTTPURLResponse) in
      guard let response = response as? HTTPURLResponse else {
        throw URLError(.cannotParseResponse)
      }
      return (data, response)
}
</code></pre>

<p>How to specify the <code>Error</code> type of this <code>publisher</code>? I'd like to use <code>URLError</code> instead of <code>Error</code>.</p>

<p>I found the method <code>setFailureType(to:)</code> in the <code>Combine</code> framework. However, it is not available to <code>tryMap(_:)</code>.</p>
","2949840","","","","","2021-06-24 08:56:27","Swift Combine: How to specify the Error type of tryMap(_:)?","<ios><swift><xcode><macos><combine>","2","0","1","","","CC BY-SA 4.0"
"59029071","1","59038211","","2019-11-25 09:51:07","","1","550","<p>I have a time selection subview with two wheel pickers, one for minutes and one for seconds. The values are bound to two (local) state variables in the parent view. I'm looking for a way to have a global state variable ""time"" changed every time when either one of the two local variables changes. I don't want to directly bind the two state variables for min/sec to the global state as I want only one variable there holding the time in seconds only. So there should be a conversion time = min * 60 + seconds.</p>

<p>I'm struggling to find a way of detecting a value change of the two local state variables.</p>

<p>Here's the subview:</p>

<pre><code>struct TimePicker: View {
    var min: Binding&lt;Int&gt;
    var sec: Binding&lt;Int&gt;

    var body: some View {
        HStack() {
            Spacer()
            Picker(selection: min, label: EmptyView()) {
                ForEach((0...9), id: \.self) { ix in
                    Text(""\(ix)"").tag(ix)
                }
            }.frame(width: 40).clipped().pickerStyle(WheelPickerStyle())
            Text(""Min."")
            Picker(selection: sec, label: EmptyView()) {
                ForEach((0...59), id: \.self) { ix in
                    Text(""\(ix)"").tag(ix)
                }
            }.frame(width: 40).clipped().pickerStyle(WheelPickerStyle())
            Text(""Sec."")
            Spacer()
        }
    }
}
</code></pre>
","10826194","","","","","2019-11-25 18:40:21","How to call a function when a @State variable changes","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"59034299","1","59039703","","2019-11-25 14:42:31","","4","917","<p>Using SwiftUI I want to press a button and have it switch the class which is used to filter an image.</p>

<p>In SwiftUI, the button would do something like what follows:</p>

<pre><code>@ObservedObject var currentFilter = FilterChoice()
...
var body: some View {..
  Button(action:{
    print(""clicked"")
    var newFilter = Luminance()
    self.currentFilter = newFilter
  }) {
     Text(""Switch to Luminance Filter"")
  }
}
</code></pre>

<p>There is an ObservableObject:</p>

<pre><code>class FilterChoice: ObservableObject {  
    @Published var filter = Luminance()
}
</code></pre>

<p>Which is consumed by a UIViewRepresentable:</p>

<pre><code>struct FilteredPhotoView: UIViewRepresentable {
  @ObservedObject var currentFilter = FilterChoice()

  func makeUIView(context: Context) -&gt; UIView {
     ...
     // Code works and pulls correct filter but can not be changed
     let className = currentFilter.filter
     let filteredImage = testImage.filterWithOperation(className)
     ...   
  }...
</code></pre>

<p>Currently, FilteredPhotoView is properly returning the filtered image.</p>

<p>But how can ObservedObject be used to change a CLASS?</p>

<p>In other words, the ObservedObject sets the class correctly here:</p>

<pre><code>class FilterChoice: ObservableObject {
   @Published var filter = Luminance()    
}
</code></pre>

<p>But how can this ObservableObject be changed so that the class can be changed in SwiftUI? For example, I want to click a button and the filter should be changed to another class (for example:</p>

<pre><code>new filter = ColorInversion()
</code></pre>

<p>I think I understand how ObservableObjects work but I can't get it to work as a change of class rather than something simple like a string value.</p>
","4406080","","1015258","","2019-11-25 16:07:29","2019-11-25 20:35:25","SwiftUI = ObservableObject as Choice of Class","<swift><uikit><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"59035693","1","59035865","","2019-11-25 16:00:21","","0","47","<p>I have to fetch JSON result from geocode goodle API.</p>

<p>JSON result:</p>

<pre><code>{
  ""plus_code"" : {
  ""compound_code"" : ""2V6X+23 Ostritz, Germania"",
  ""global_code"" : ""9F3P2V6X+23""
  },
  ""results"" : [
  {
     ""address_components"" : [
            {
              ""long_name"" : ""Unnamed Road"",
              ""short_name"" : ""Unnamed Road"",
              ""types"" : [ ""route"" ]
            },
            {
              ""long_name"" : ""Ostritz"",
              ""short_name"" : ""Ostritz"",
              ""types"" : [ ""locality"", ""political"" ]
            },
            {
              ""long_name"" : ""Görlitz"",
              ""short_name"" : ""GR"",
              ""types"" : [ ""administrative_area_level_3"", ""political"" ]
            },
            {
              ""long_name"" : ""Dresden"",
              ""short_name"" : ""DD"",
              ""types"" : [ ""administrative_area_level_2"", ""political"" ]
            }
     ],
     ""formatted_address"" : ""Unnamed Road, 02899 Ostritz, Germania"",
     ""geometry"" : {
            ""bounds"" : {
                  ""northeast"" : {
                    ""lat"" : 51.0103607,
                    ""lng"" : 14.898013
                    },
                  ""southwest"" : {
                    ""lat"" : 51.0093767,
                    ""lng"" : 14.8962029
                    }
             },
            ""location"" : {
                 ""lat"" : 51.0097477,
                 ""lng"" : 14.8972969
                 },
                 ""location_type"" : ""GEOMETRIC_CENTER"",
                 ""viewport"" : {
                    ""northeast"" : {
                        ""lat"" : 51.01121768029149,
                        ""lng"" : 14.8984569302915
                       },
                    ""southwest"" : {
                        ""lat"" : 51.0085197197085,
                        ""lng"" : 14.8957589697085
                       }
                   }
            },
           ""place_id"" : ""ChIJ6egabgkhCUcRznhL6gAPj_w"",
           ""types"" : [ ""route"" ]
     },
     {
     ""address_components"" : [
        {
           ""long_name"" : ""Ostritz"",
           ""short_name"" : ""Ostritz"",
           ""types"" : [ ""locality"", ""political"" ]
        },
        {
           ""long_name"" : ""Circondario di Görlitz"",
           ""short_name"" : ""GR"",
           ""types"" : [ ""administrative_area_level_3"", ""political"" ]
        },
        {
           ""long_name"" : ""Dresda"",
           ""short_name"" : ""DD"",
           ""types"" : [ ""administrative_area_level_2"", ""political"" ]
        },
        {
           ""long_name"" : ""Sassonia"",
           ""short_name"" : ""SN"",
           ""types"" : [ ""administrative_area_level_1"", ""political"" ]
        },
        {
           ""long_name"" : ""Germania"",
           ""short_name"" : ""DE"",
           ""types"" : [ ""country"", ""political"" ]
        }
     ],
     ""formatted_address"" : ""Ostritz, Germania"",
     ""geometry"" : {
        ""bounds"" : {
           ""northeast"" : {
              ""lat"" : 51.06239919999999,
              ""lng"" : 14.964849
           },
           ""southwest"" : {
              ""lat"" : 50.9721983,
              ""lng"" : 14.87143
           }
        },
        ""location"" : {
           ""lat"" : 51.01573639999999,
           ""lng"" : 14.9314311
        },
        ""location_type"" : ""APPROXIMATE"",
        ""viewport"" : {
           ""northeast"" : {
              ""lat"" : 51.06239919999999,
              ""lng"" : 14.964849
           },
           ""southwest"" : {
              ""lat"" : 50.9721983,
              ""lng"" : 14.87143
           }
        }
     },
     ""place_id"" : ""ChIJKfHi7N8gCUcR2V02pmCO3mU"",
     ""types"" : [ ""locality"", ""political"" ]
  },
  ........ 
  ........
 ],
 ""status"" : ""OK""
}
</code></pre>

<p>Model:</p>

<pre><code>import Foundation

struct Postgeo: Codable {
   let plus_code: Plus_code
   let results: [Results]
   let status: String
}

struct Results: Codable {
   let address_components: [Address_components]
   let formatted_address: String
   let geometry: Geometry
   let place_id: String
   let plus_code: Plus_coderes
   let types: [String]
 }

 struct Geometry: Codable {
   let location: Location
   let location_type: String
   let viewport: Viewport
 }

 struct Plus_code: Codable {
   let compound_code, global_code: String
 }

 struct Address_components: Codable {
   let long_name, short_name: String
   let types: [String]
 }

 struct Location: Codable {
   let lat, lng: Double
 }

 struct Northeast: Codable {
   let lat, lng: Double
 }
</code></pre>

<p>APIManage:</p>

<pre><code>import Foundation
import Combine

class APIManager: ObservableObject {
   let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()


   var postgeos = Postgeo.self {
      willSet {
          objectWillChange.send()
      }
   }

   init() {
      guard let url = URL(string: ""&lt;url&gt;"") else {
        fatalError(""Invalid URL"")
      }

      URLSession.shared.dataTask(with: url) { data, response, error in

          guard let json = data else { return }

          let postgeo = try? JSONDecoder().decode(Postgeo.self, from: json)

          print(postgeo)

          DispatchQueue.main.async {
              self.postgeos = postgeo
          }
          print(""API values fetched Successfully"")
      }.resume()
  }
}
</code></pre>

<p>At debug i have error: </p>

<blockquote>
  <p>Cannot assign value of type 'Postgeo?' to type 'Postgeo.Type'</p>
</blockquote>

<p>on row <code>self.postgeos = postgeo</code></p>

<p>If I comment this row, i have correct result from <code>print(postgeo)</code></p>

<p>I have adapted a Json fetch code for swiftui that works fine with Json that starts with '[', but the result json from geocode google api starts with '{'. </p>

<p>How can I fix this error?</p>

<p>Thank you.</p>
","5525200","","7948372","","2019-11-25 20:24:01","2019-11-25 20:24:01","SwitUI fetch JSON result from API geocode google","<json><swift><fetch><xcode11.2>","1","0","","","","CC BY-SA 4.0"
"59036863","1","59067605","","2019-11-25 17:08:54","","7","5553","<p>I am trying to make a <code>ObservableObject</code> that has properties that wrap a <code>UserDefaults</code> variable.</p>

<p>In order to conform to <code>ObservableObject</code>, I need to wrap the properties with <code>@Published</code>. Unfortunately, I cannot apply that to computed properties, as I use for the <code>UserDefaults</code> values.</p>

<p>How could I make it work? What do I have to do to achieve <code>@Published</code> behaviour?</p>
","5727960","","5727960","","2020-06-04 12:02:42","2020-10-15 19:57:13","Add @Published behaviour for computed property","<swift><swiftui><combine><property-wrapper>","4","1","7","","","CC BY-SA 4.0"
"59040013","1","59040171","","2019-11-25 20:59:34","","6","4818","<p>I am playing around with Swift UI. I created a table view (a List) containing all my desired elements. Also the TextField change is working when pressing enter on the keyboard. Nice to build so fast a table view ;).</p>

<p>But now I want to track every change on the textfield. Every time user enter another text I want to send a request which triggers a search.</p>

<p>How could this be done in my code? I read also this documentation here <a href=""https://developer.apple.com/documentation/combine/receiving_and_handling_events_with_combine"" rel=""noreferrer"">https://developer.apple.com/documentation/combine/receiving_and_handling_events_with_combine</a></p>

<p>I don't now how to use it in my struct.</p>

<p>The proposed solution here <a href=""https://stackoverflow.com/questions/57875550/textfield-changes-in-swiftui"">TextField changes in SwiftUI</a> does not work (anymore)</p>

<p>I would be thankful for every hint and every idea you can share with me. I am looking for hours for a solution :(.</p>

<p>My code looks like this:</p>

<pre><code>import Foundation
import SwiftUI

struct MyListView: View {
    @ObservedObject var viewModel: MyViewModel

    @State private var query = """"

    var body: some View {

        NavigationView {
            List {
                // how to listen for changes here?
                // if I add onEditingChange here, Get the value only after the user finish search (by pressing enter on the keyboard)
                TextField(String.localizedString(forKey: ""search_bar_hint""), text: self.$query) {
                    self.fetchListing()
                } 

                ForEach(viewModel.myArray, id: \.id) { arrayObject in
                    MyRow(arrayObj: arrayObject)
                }
            }
            .navigationBarTitle(navigationBarTitle())
        }
        .onAppear(perform: fetchListing)
    }

    private func fetchListing() {
        query.isEmpty ? viewModel.fetchRequest(for: nil) : viewModel.fetchRequest(for: query)
    }

    private func navigationBarTitle() -&gt; String {
        return query.isEmpty ? String.localizedString(forKey: ""my_title"") : query
    }
}
</code></pre>
","4017243","","","","","2020-07-26 09:14:32","Observe changes on SwiftUI TextField","<ios><swift><combine><swift5.2>","2","0","3","","","CC BY-SA 4.0"
"59047426","1","59052169","","2019-11-26 09:15:30","","1","441","<p>I have such <code>ObservableObject</code> that I am injecting into views hierarchy by using <code>environmentObject()</code>.</p>

<pre><code>class MenuModel: ObservableObject {

    @Published var selection: Int = 0
    @Published var isMenuOpen: Bool = false

    @Published var tabItems : [TabItem] = [TabItem]()
//    {
//        didSet {
//            objectWillChange.send()
//        }
//    }
    @Published var menuItems : [MenuItem] = [MenuItem]()
//    {
//        didSet {
//            objectWillChange.send()
//        }
//    }

    //var objectWillChange = PassthroughSubject&lt;Void, Never&gt;()
}
</code></pre>

<p>And here are issues I do not really understand well: 
1. Above code with works correctly, as all properties are @Published. 
2. But If I change it to something like this </p>

<pre><code>class Click5MenuModel: ObservableObject {

    @Published var selection: Int = 0
    @Published var isMenuOpen: Bool = false

    var tabItems : [TabItem] = [TabItem]()
    {
        didSet {
            objectWillChange.send()
        }
    }
    var menuItems : [MenuItem] = [MenuItem]()
    {
        didSet {
            objectWillChange.send()
        }
    }

    var objectWillChange = PassthroughSubject&lt;Void, Never&gt;()
}
</code></pre>

<p>Then @Published properties stop refreshing Views that depends on this ObservableObject! 
Why is that. I also tried to add <code>didSet</code> with <code>objectWillChange.send()</code> but this also causes some odd behaviour and code is a little bit awkward. </p>

<p>Does this mean that I can only use <strong>ONLY @Published</strong> or <strong>ONLY  objectWillChange</strong> approach?</p>
","4415642","","","","","2019-11-26 13:35:21","SwiftUI ObservableObject used as EnvironmentObject odd behaviour","<swiftui><combine><observableobject>","1","2","","","","CC BY-SA 4.0"
"59049974","1","59050148","","2019-11-26 11:30:07","","6","3870","<h2>Problem:</h2>
<p>Passing down the view model and modifying it from the children, won't refresh the parent.</p>
<h2>What I want:</h2>
<p>Whenever I modify the view model from the child view, the parent refresh too.</p>
<h2>Problem description:</h2>
<p>I'm looking for a way to pass down a <code>ViewModel ObservedObject</code> to some child views.</p>
<p>This is my struct:</p>
<pre><code>struct Parent: View {
    @ObservedObject viewModel: ViewModel

     var body: some View {
            NavigationView {
                Form {
                    ScrollView(showsIndicators: false) {
                         Section {
                            ChildViewOne(model: viewModel)
                        }
                        
                        Section {
                            ChildViewTwo(model: viewModel)
                        }
                        
                        Section {
                            ChildViewThree(model: viewModel)
                        }
                    }
                }
            }
        }
}

struct AnyChild: View {
    @ObservedObject viewModel: ViewModel

     var body: some View {
            // some stuff
        }
}
</code></pre>
<p>In this way, whenever I modify from the child views the view model, the children rebuild correctly, but the parent won't, and the scrollview does not resize correctly.</p>
<p>I would like to pass down to the children the viewModel like a Binding object, so the parent will refresh too.</p>
<p>But I don't know how to do. Any help?</p>
<h2>Solution:</h2>
<p>I had a specific problem with the <code>Form</code> when I've removed everything worked fine.</p>
<p>But still the correct solution as <strong>@Alladinian</strong> wrote is to use the  <code>@EnvironmentObject</code></p>
","6747915","","-1","","2020-06-20 09:12:55","2019-11-26 15:12:26","iOS SwiftUI: ObservableObject from parent to child","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"59055022","1","59059838","","2019-11-26 16:08:46","","4","612","<p>In <a href=""http://developer.apple.com/reference/combine"" rel=""nofollow noreferrer"">Combine</a> framework there's a concept of a <a href=""https://developer.apple.com/documentation/combine/subscribers/demand"" rel=""nofollow noreferrer"">demand</a>, which allows signalling backpressure to <a href=""https://developer.apple.com/documentation/combine/publisher"" rel=""nofollow noreferrer"">publishers</a>.</p>

<p>Suppose I have a simple publisher:</p>

<pre class=""lang-swift prettyprint-override""><code>let numbers = Publishers.Sequence&lt;ClosedRange&lt;Int&gt;, Error&gt;(sequence: 0...100)
</code></pre>

<p>I would like to download certain URLs that use these numbers as arguments. I also would like a next download to start only after a previous download has finished.</p>

<p>A naive approach then would look like this:</p>

<pre class=""lang-swift prettyprint-override""><code>let subscription = numbers.sink(receiveCompletion: { _ in }, receiveValue: {
  let url = URL(string: ""https://httpbin.org/get?value=\($0)"")!
  URLSession.shared.dataTask(with: url) { 
    $0.map { print(String(data: $0, encoding: .utf8)!) }
  }.resume()
})
</code></pre>

<p>Unfortunately, this wouldn't satisfy the requirement of waiting for a previous download to complete before starting the next one. As far as I know, <code>sink</code> function would return a value of type <a href=""https://developer.apple.com/documentation/combine/anycancellable"" rel=""nofollow noreferrer""><code>AnyCancellable</code></a>, not of type <a href=""https://developer.apple.com/documentation/combine/subscription"" rel=""nofollow noreferrer""><code>Subscription</code></a>. If the latter was the case, we could call the <a href=""https://developer.apple.com/documentation/combine/subscription/3213720-request"" rel=""nofollow noreferrer""><code>request</code></a> function on the <code>subscription</code> with a specific demand after an upload completes.</p>

<p>What would be the best way to control demand of a subscription provided by <code>sink</code> or any other standard Combine <code>Subscriber</code>?</p>
","442427","","442427","","2019-11-26 21:48:47","2019-11-26 21:48:47","How to adjust Combine's Publisher demand without a custom Subscriber?","<swift><reactive-programming><combine>","1","2","3","","","CC BY-SA 4.0"
"59056881","1","59335347","","2019-11-26 18:00:02","","0","1239","<p>I have written a List with SwiftUI. I also have a TextField object which is used as a search bar. My code looks like this:</p>

<pre><code>import SwiftUI

struct MyListView: View {
    @ObservedObject var viewModel: MyViewModel

    @State private var query = """"

    var body: some View {

        NavigationView {
            List {
                // how to listen for changes here?
                // if I add onEditingChange here, Get the value only after the user finish search (by pressing enter on the keyboard)
                TextField(String.localizedString(forKey: ""search_bar_hint""), text: self.$query) {
                    self.fetchListing()
                } 

                ForEach(viewModel.myArray, id: \.id) { arrayObject in
                    NavigationLink(destination: MyDetailView(MyDetailViewModel(arrayObj: arrayObject))) {
                         MyRow(arrayObj: arrayObject)
                    }
                }
            }
            .navigationBarTitle(navigationBarTitle())
        }
        .onAppear(perform: fetchListing)
    }

    private func fetchListing() {
        query.isEmpty ? viewModel.fetchRequest(for: nil) : viewModel.fetchRequest(for: query)
    }

    private func navigationBarTitle() -&gt; String {
        return query.isEmpty ? String.localizedString(forKey: ""my_title"") : query
    }
}
</code></pre>

<p>The problem I have now is that the List remains behind the keyboard :(. How can I set the list padding bottom or edge insets (or whatever else works, I am totally open) so that the scrolling of the list ends above the keyboard? The list „size“ should also adjust automatically depending on if keyboard will be opened or closed. </p>

<p>Problem looks like this: </p>

<p><a href=""https://i.stack.imgur.com/xdtGX.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xdtGX.gif"" alt=""enter image description here""></a></p>

<p>Please help me with any advice on this, I really have no idea how to do this :(. I am a SwiftUI beginner who is trying to learn it :). </p>
","4017243","","12047322","","2019-11-26 20:34:45","2019-12-14 13:02:13","SwiftUI List with TextField adjust when keyboard appears/disappears","<ios><xcode><swiftui><combine><swift5.2>","2","1","","","","CC BY-SA 4.0"
"59059519","1","59123718","","2019-11-26 21:22:33","","1","210","<p>Scenario: <br/>
I'm playing around with accessing &amp; displaying remote images to learn Combine's assorted notification flags/protocols.
<p></p>

<p>One Goal: <br/>
Accessing a bad URL should <em>immediately</em> display an Alert().
<p>
Reality: <br/>
Alert is displayed <em>AFTER</em> then second request and beyond.</p>

<p><a href=""https://i.stack.imgur.com/DCtYp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DCtYp.png"" alt=""enter image description here""></a></p>

<p><p>
Here's the main (calling) view:</p>

<pre><code>import Combine
import SwiftUI

struct ContentView: View {
    @EnvironmentObject var settings: MySettings
    @State private var url: String = ""https://garbage.com""  // ...purposely set to display alert.
    @State private var image: URLImage = URLImage()
    @State private var angelFish: Image = Image(""QueenAngelfish"")
    @State private var isPresented = false

    var body: some View {
        ZStack {
            Color.green
            NavigationView {
                VStack {
                    Button(action: {
                        self.url = ""garbage.com""
                        self.isPresented = self.image.imageLoader.isPresented
                        self.image.imageLoader.load(url: URL(string: self.url)!)
                    }) {
                        Text(""Get An Image"")
                    }

                    angelFish
                        .resizable()
                        .frame(width: 300, height: 200, alignment: .center)
                        .padding()
                    image
                        .alert(isPresented: $isPresented, content: { () -&gt; Alert in
                            Alert(title: Text(verbatim: ""Unable to Acquire Image.""))
                        })

                }.navigationBarTitle(Text(settings.name))
            }
        }
    }
}
</code></pre>

<p><p>
Here's the access engine: <p></p>

<pre><code>import Combine
import SwiftUI

enum ImageURLError: Error {
    case dataIsNotAnImage
}

struct URLImage: View {
    @EnvironmentObject var settings: MySettings
    @ObservedObject var imageLoader: ImageLoader
    var placeholder: Image

    init() {
        self.placeholder = Image(systemName: ""photo"")
        self.imageLoader = ImageLoader()
    }

    var body: some View {
        VStack {
            imageLoader.image == nil ?
                placeholder : Image(uiImage: imageLoader.image!)
            Button(action: {
                self.settings.name = ""Happy Thanks Giving""
                self.settings.isPresented = true
            }, label: {
                Text(""Touch Me"")
            })
        }
    }
}

// =====================================================================================================

class ImageLoader: ObservableObject {
    let id: String = UUID().uuidString
    var didChange = PassthroughSubject&lt;Void, Never&gt;()

    @Published var isPresented = false

    @Published var image: UIImage? {
        didSet {
            DispatchQueue.main.async {
                self.didChange.send()
            }
        }
    }

    // ---------------------------------------------------------------------------

    func load(url: URL) {
        print(""Hello Ric: "", #function)

        URLSession.shared.dataTask(with: url) { data, _, error in
            DispatchQueue.main.async {
                if error != nil {
                    self.isPresented = true
                    self.didChange.send()   // ...attempting to activate alert().
                    return
                }

                self.image = UIImage(data: data!)
            }

        }.resume()
    }
}
</code></pre>

<p><p></p>

<p>This code purposely creates an error due to a bad URL. <br/>
I tried to immediately notify the calling routine via passing the boolean 'isPresented' flag as an '@Published' variable
<p>
Expected Result: <br/>
Displayed Alert.
<p>
Actual Result: <br/>
Alert is displayed AFTER &amp; beyond the initial attempt.
<p>
Question: How do I perform an INSTANT Alert display?</p>
","715747","","","","","2019-12-01 08:09:25","Why the Delayed Alert Display?","<alert><swiftui><combine>","1","0","0","","","CC BY-SA 4.0"
"59061582","1","59069315","","2019-11-27 01:01:56","","5","1057","<p>I can specify the scheduler as <code>RunLoop.main</code>, but I could not find a native way to provide the associated <code>RunLoop.Mode</code> mode to receive elements from a publisher.</p>

<p><strong>Why do I need this:</strong> I'm updating a tableView cell from my publisher but the UI does not update if the user is scrolling, it then updates as soon as the user interaction or scroll stops. <a href=""https://stackoverflow.com/questions/4109898/my-custom-ui-elements-are-not-being-updated-while-uiscrollview-is-scrolled/4136988"">This is a known behaviour for scrollViews</a> but I want my content to be displayed as soon as possible, and being able to specify the run loop tracking mode would fix this.</p>

<p><strong>Combine API:</strong> I do not think the <code>receive(on:options:)</code> method <a href=""https://developer.apple.com/documentation/combine/publisher/3204743-receive"" rel=""noreferrer"">have any matching options</a> to provide this. I think internally, if I call <code>receive(on:RunLoop.main)</code> then <code>RunLoop.main.perform { }</code> is called. This perform method can take <a href=""https://developer.apple.com/documentation/foundation/runloop/2091880-perform"" rel=""noreferrer"">the mode as parameter</a> but this is not exposed to the Combine API.</p>

<hr>

<p><strong>Current Idea:</strong> To go around this I could do the perform action myself and not use the Combine API, so instead of doing this:</p>

<pre><code>cancellable = stringFuture.receive(on: RunLoop.main) // I cannot specify the mode here
                          .sink { string in
    cell.textLabel.text = string
}
</code></pre>

<p>I could do this:</p>

<pre><code>cancellable = stringFuture.sink { string in
    RunLoop.main.perform(inModes: [RunLoop.Mode.common]) { // I can specify it here
        cell.textLabel.text = string
    }
}
</code></pre>

<p>But this is not ideal.</p>

<p><strong>Ideal Solution:</strong> I was wondering how could I wrap this into my own implementation of a publisher function to have something like this:</p>

<pre><code>cancellable = stringFuture.receive(on: RunLoop.main, inMode: RunLoop.Mode.common)
                          .sink { string in
    cell.textLabel.text = string
}
</code></pre>

<p>Were the API of this function could be something like this:</p>

<pre><code>extension Publisher {
    public func receive(on runLoop: RunLoop, inMode: RunLoop.Mode) -&gt; AnyPublisher&lt;Future.Output, Future.Failure&gt; {

        // How to implement this?

    }
}
</code></pre>
","596857","","","","","2020-02-25 06:27:29","Is there a way to specify the run loop & mode to to receive elements from a publisher","<swift><uikit><combine><runloop>","2","0","2","","","CC BY-SA 4.0"
"59064289","1","59078334","","2019-11-27 06:29:00","","2","1612","<p>I've successfully set up authentication within my app using Google Sign-In to where I am able to return a Firebase User. I am attempting to set up a Sign-In screen that is only shown when there is no authenticated Firebase User, however with my current code the Sign-In screen is always visible even though I am consistently returning an authenticated user.</p>

<p>I've implemented the <code>didSignInFor</code> function in <code>AppDelegate</code></p>

<pre><code>func sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error?) {
      // ...
      if let error = error {
        print(error.localizedDescription)
        return
      }

      guard let authentication = user.authentication else { return }
      let credential = GoogleAuthProvider.credential(withIDToken: authentication.idToken,
                                                        accessToken: authentication.accessToken)
      // ...
        Auth.auth().signIn(with: credential) { (authResult, error) in
            if let error = error {
                print(error.localizedDescription)
                return
            }
            let session = FirebaseSession.shared

            if let user = Auth.auth().currentUser {
                session.user = User(uid: user.uid, displayName: user.displayName, email: user.email)
                print(""User sign in successful: \(user.email!)"")
            }
        }
    }
</code></pre>

<p>as well as a few lines in <code>didFinishLaunchingWithOptions</code> that sets the <code>isLoggedIn</code> property of my <code>ObservableObject</code> <code>FirebaseSession</code></p>

<pre><code>func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
        // Override point for customization after application launch.

        FirebaseApp.configure()

        let auth = Auth.auth()

        if auth.currentUser != nil {
            FirebaseSession.shared.isLoggedIn = true
            print(auth.currentUser?.email!)
        } else {
            FirebaseSession.shared.isLoggedIn = false
        }

        //Cache
        let settings = FirestoreSettings()
        settings.isPersistenceEnabled = false

        GIDSignIn.sharedInstance().clientID = FirebaseApp.app()?.options.clientID
        GIDSignIn.sharedInstance().delegate = self

        return true
    }
</code></pre>

<p>My <code>ObservableObject</code></p>

<pre><code>class FirebaseSession: ObservableObject {

        static let shared = FirebaseSession()
        init () {}

        //MARK: Properties
        @Published var user: User?
        @Published var isLoggedIn: Bool?

        @Published var items: [Thought] = []

        var ref: DatabaseReference = Database.database().reference(withPath: ""\(String(describing: Auth.auth().currentUser?.uid ?? ""Error""))"")

        //MARK: Functions
        func listen() {
            _ = Auth.auth().addStateDidChangeListener { (auth, user) in

                if auth.currentUser != nil {
                    self.isLoggedIn = true
                }

                if let user = user {
                    self.user = User(uid: user.uid, displayName: user.displayName, email: user.email)
                } else {
                    self.user = nil
                }
            }
        }
    }
</code></pre>

<p>Finally, I perform my authentication check in the main view of my app here accessing <code>FirebaseSession</code> via my <code>ObservedObject</code></p>

<pre><code>struct AppView: View {

    @ObservedObject var session = FirebaseSession.shared

    @State var modalSelection = 1
    @State var isPresentingAddThoughtModal = false

    var body: some View {
        NavigationView {
            Group {
                if session.isLoggedIn == true {
                    ThoughtsView()
                } else {
                    SignInView()
                }
            }
        }
    }
}
</code></pre>

<p>As mentioned above my check doesn't seem to work. Even though my user is authenticated, <code>SignInView</code> is always visible.</p>

<p>How can I successfully check my user authentication each time my app loads?</p>

<p><strong>UPDATE</strong></p>

<p>I am now able to check authentication when the app loads, but after implementing Sohil's solution I am not observing realtime changes to my <code>ObservableObject</code> <code>FirebaseSession</code>. I want to observe changes to <code>FirebaseSession</code> so that after a new user signs in, the body of <code>AppView</code> will be redrawn and present <code>ThoughtsView</code> instead of <code>SignInView</code>. Currently I have to reload the app in order for the check to occur after authentication.</p>

<p>How do I observe changes to <code>FirestoreSession</code> from <code>AppView</code>?</p>
","6035021","","6035021","","2019-11-27 17:41:52","2020-05-22 23:21:51","Checking user authentication using Google Sign In and SwiftUI","<ios><swift><firebase-authentication><swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"59074995","1","59079883","","2019-11-27 16:51:46","","3","2348","<p>I'm trying to work out how I can correctly pass an object or a set of values between two ViewModels in a parent-child relationship so that when the child ViewModel is updated the change bubbles back up to the parent.</p>

<p>This is pretty simple when just using SwiftUI views and binding directly to the stores but I wanted to keep my business logic for field validation and so on separate from the SwiftUI views.</p>

<p>The code below shows the child updating (as expected) when the parent gets updated, but I need to somehow pass the changed values in the child back up to the parent. I'm very new to mobile app development and still learning so I'm sure I'm missing something quite simple.</p>

<pre><code>import SwiftUI
import Combine

struct Person: Hashable {
  var givenName: String
  var familyName: String
}

// my person store - in the real app it's backed by coredata
class PersonStore: ObservableObject {
  @Published var people: [Person] = [
    Person(
      givenName: ""Test"",
      familyName: ""Person""
    )
  ]
  static let shared = PersonStore()
}

// app entrypoint
struct PersonView: View {
  @ObservedObject var viewModel: PersonView_ViewModel = PersonView_ViewModel()

  var body: some View {
    NavigationView {
      VStack {
        List(viewModel.people.indices, id: \.self) { idx in
          NavigationLink(destination: PersonDetailView(viewModel: PersonDetailView_ViewModel(personIndex: idx))) {
            Text(self.viewModel.people[idx].givenName)
          }
        }
      }
    }
  }
}

class PersonView_ViewModel: ObservableObject {
  @Published var people: [Person] = PersonStore.shared.people
}

// this is the detail view
struct PersonDetailView: View {
  @ObservedObject var viewModel: PersonDetailView_ViewModel

  var body: some View {
    Form {
      Section(header: Text(""Parent View"")) {
        VStack {
          TextField(""Given Name"", text: self.$viewModel.person.givenName)
          Divider()
          TextField(""Family Name"", text: self.$viewModel.person.familyName)
        }
      }
      PersonBasicDetails(viewModel: PersonBasicDetails_ViewModel(person: viewModel.person))
    }
  }
}

// viewmodel associated with detail view
class PersonDetailView_ViewModel: ObservableObject {
  @Published var person: Person

  init(personIndex: Int) {
    self.person = PersonStore.shared.people[personIndex]
  }
}

// this is the child view - in the real app there are multiple sections which are conditionally rendered
struct PersonBasicDetails: View {
  @ObservedObject var viewModel: PersonBasicDetails_ViewModel

  var body: some View {
    Section(header: Text(""Child View"")) {
      VStack {
        TextField(""Given Name"", text: self.$viewModel.person.givenName)
        Divider()
        TextField(""Family Name"", text: self.$viewModel.person.familyName)
      }
    }
  }
}

class PersonBasicDetails_ViewModel: ObservableObject {
  @Published var person: Person

  init(person: Person) {
    self.person = person
  }
}

struct PersonView_Previews: PreviewProvider {
  static var previews: some View {
    PersonView()
  }
}
</code></pre>
","12440639","","","","","2020-05-22 04:14:22","Bidirectional binding with SwiftUI and Combine","<swiftui><combine>","2","0","2","","","CC BY-SA 4.0"
"59092948","1","59095500","","2019-11-28 16:20:35","","0","837","<p>Here's a head-scratcher: implementing a simple wrapper on an ObservableObject property negates SwiftUI updates. </p>

<p>The purpose of the property wrapper is to provide a getter / setter to UserDefaults. The property wrapper works fine. But it stifles SwiftUI updates. </p>

<p>Things I've tried:</p>

<p>-Adding @Published wrapper in addition to my custom wrapper. But Swift at the moment doesn't support composable wrappers (e.g. more than one property wrapper at a time).</p>

<p>-Manually adding a PassthoughSubject publisher, to replicate @Published functionality.</p>

<p>The latter also doesn't fix view updates on property value change.</p>

<p>The only workaround I've found is to abandon property wrappers. I end up having to set state in two places, 1) on the @Published property, and 2) in UserDefaults. This seems clunky, and anti-pattern of duplicating state.</p>

<p>Is this a known-issue?  </p>

<p>Full compiling code is at <a href=""https://github.com/taskcruncher/propertyWrapperSwiftUIBug.git"" rel=""nofollow noreferrer"">https://github.com/taskcruncher/propertyWrapperSwiftUIBug.git</a>. The 'works' branch is where I've had to duplicate state. The 'broken' branch is below, where using a custom property wrapper breaks SwiftUI updates.</p>

<p><strong>ContentView.swift</strong></p>

<pre><code>import Combine
//https://www.avanderlee.com/swift/property-wrappers/

@propertyWrapper
struct PersistInUserDefaults&lt;T&gt; {
    let key: String
    let defaultValue: T

    var wrappedValue: T {
        get {
            return UserDefaults.standard.object(forKey: key) as? T ?? defaultValue
        }
        set {
            UserDefaults.standard.set(newValue, forKey: key)
        }
    }
}


class AppleUser: ObservableObject {

    static var shared = AppleUser()

    let subject = PassthroughSubject&lt;String, Never&gt;()

    @PersistInUserDefaults(key: ""appleID"", defaultValue: """") var appleID: String {willSet {

        subject.send(newValue) // problem here: does not trigger UI updates 
        }}
}


struct ContentView: View {

    @ObservedObject var appleUser: AppleUser

    var body: some View {

        return VStack {
            Text(appleUser.appleID)

        }.onAppear{

            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                         self.appleUser.appleID = ""Sven"" 
                     }


            DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
                self.appleUser.appleID = ""Olaf""
            }//update not reflected in UI

            DispatchQueue.main.asyncAfter(deadline: .now() + 3.5) {
                          self.appleUser.appleID = ""Anna""
                      }//update not reflected in UI

        }
    }

}
</code></pre>

<p><strong>SceneDelegate.swift</strong></p>

<pre><code>    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {

        let contentView = ContentView(appleUser: AppleUser.shared)

        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(rootView: contentView)
            self.window = window
            window.makeKeyAndVisible()
        }

    }
</code></pre>
","4705368","","4705368","","2019-11-30 10:36:15","2019-11-30 10:36:15","Using Swift 5.1 Property Wrapper seems to break SwiftUI updates. Known issue?","<ios><swift><swiftui>","1","0","1","","","CC BY-SA 4.0"
"59098343","1","59121796","","2019-11-29 03:14:50","","3","1478","<p>I am trying to transition an app from UIKit to SwiftUI which depends on basic DynamoDB resources but I have hit a snag in forcing the view to refresh as data is added to the list. I have been at this set of code for hours trying different things and I thought I might see if anyone might know why the 'SessionsData' seems to be thrown away and will not accumulate the 'Sessions' objects.</p>

<p>Does anyone have any quick thoughts???</p>

<pre><code>class SessionsData: ObservableObject {

    let didChange = PassthroughSubject&lt;SessionsData, Never&gt;()
    @Published var data: [Sessions] = [] {
        didSet {
            didChange.send(self)
        }
    }

    init() {
        load()
    }

    func load() {
        let dynamoDBObjectMapper = AWSDynamoDBObjectMapper.default()
        let scanExpression = AWSDynamoDBScanExpression()
        scanExpression.limit = 20

        var temp : [Sessions] = []

        dynamoDBObjectMapper.scan(Sessions.self, expression: scanExpression).continueWith(block: { (task:AWSTask&lt;AWSDynamoDBPaginatedOutput&gt;!) -&gt; Any? in
            if let error = task.error as NSError? {
                 print(""The request failed. Error: \(error)"")
             } else if let paginatedOutput = task.result {
                for session in paginatedOutput.items as! [Sessions] {
                    print(""Item Found"")
                    temp.append(session)
                }
                DispatchQueue.main.async {
                    self.data = temp
                    self.didChange.send(self)
                }
             }
            print(self.data.count)
            return true
         })
    }
}
</code></pre>

<pre><code>struct Events: View {

    @ObservedObject var sessionsData = SessionsData()


    var body: some View {...}
}

</code></pre>
","12454606","","7948372","","2019-11-29 07:36:06","2019-12-01 01:25:36","How do I load data using ObservableObject in SwiftUI?","<amazon-dynamodb><swiftui><combine>","2","2","1","","","CC BY-SA 4.0"
"59103163","1","59103792","","2019-11-29 10:35:34","","10","3209","<p>I'm using swiftUI and combine, I'have some business logic in my VM. Some results have to dismiss my view.</p>

<p>I'v used this one in some views :</p>

<pre><code>@Environment(\.presentationMode) var presentationMode: Binding&lt;PresentationMode&gt;

self.presentationMode.wrappedValue.dismiss()

</code></pre>

<p>I want to something similar in my view model.</p>
","2114456","","2114456","","2019-12-02 08:31:37","2021-12-30 07:19:55","Dismiss view from view model [MODAL PAGE]","<swift><swiftui><combine>","2","2","1","","","CC BY-SA 4.0"
"59104353","1","59104948","","2019-11-29 11:58:24","","0","876","<p>Here is my code for the two classes. I am not sure what is happening here?
The textfield is not updating the @Published 'cityInput' variable.</p>

<p>I am trying to have the user enter the name of their city and then use that variable to call a weather API for the city they entered. However when I print the variable (cityInput) or use it, it remains the default. It isn't updated</p>

<pre><code>import SwiftUI

struct ContentView: View {
   @ObservedObject var networkingManager = NetworkingManager()

   var body: some View {
      NavigationView {
          VStack {
            Text(""Please Enter a City Name"")
            TextField(""City Name, i.e Sydney"", text: $networkingManager.inputCity)
            NavigationLink(destination: ForecastView()) {
                    Text(""Go"")
                 }
            }
           .padding()
           .navigationBarTitle(""Weather"")
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}


import Foundation
import SwiftUI
import Combine

class NetworkingManager : ObservableObject {
    @Published var inputCity = ""Sydney""
    @Published var weatherList = [WeatherInfoList]()
    var weatherCity = CityInformation(name: ""Sydney"", country: ""AU"")

    func load() {
        let apiKey = ""d81d2f91438e7897ceb3c457c25""
        guard let url = URL(string: ""https://api.openweathermap.org/data/2.5/forecast?q=Sydney&amp;units=metric&amp;APPID=\(apiKey)"") else {
            return
        }
        print(""City is: \(inputCity)"")
        URLSession.shared.dataTask(with: url) { (data, response, err) in
            guard let data = data else { return }
            let weatherInfo = try! JSONDecoder().decode(WeatherAPIResponse.self, from: data)
            DispatchQueue.main.async {
                self.weatherCity = weatherInfo.city
                self.weatherList = weatherInfo.list
            }
        }.resume()
    }
}



import SwiftUI

struct ForecastView: View {
    @ObservedObject var networkingManager = NetworkingManager()

    var body: some View {
        NavigationView {
            VStack {
                List(networkingManager.weatherList, id: \.dt) { weather in
                    VStack(alignment: .leading) {
                        Text(weather.date)
                            .font(.headline)
                    Text(""\(self.networkingManager.weatherCity.name), \(self.networkingManager.weatherCity.country)"")
                    }
                    Spacer()
                    Text(""\(weather.main.rTemp)°C "")
                    Image(systemName: ""cloud.sun.fill"") 
                }
            }.onAppear() {
                self.networkingManager.load()
            }
            .padding()
            .navigationBarTitle(""Weather Forecast"")
        }
    }
}

struct ForecastView_Previews: PreviewProvider {
    static var previews: some View {
        ForecastView()
    }
}
</code></pre>
","1975231","","10584330","","2019-11-29 20:35:27","2019-11-29 20:35:27","TextField Input not updating @Published ObservedObject in other class (SwiftUI)","<ios><swift><xcode><swiftui>","1","0","0","","","CC BY-SA 4.0"
"59122903","1","59147976","","2019-12-01 05:49:40","","3","62","<p>I have a flow which transforms data, acts on it, transform it again, and acts on that. For example:</p>

<pre><code>// Current code
Just(0)
    .map({ $0 + 1 })
    .map({ funcX($0); return $0 })
    .map({ $0 + 1 })
    .map({ funcY($0); return $0 })
    ...
</code></pre>

<p>I know reactive programming is about streams, but I would like to call <code>funcX</code> without needing to return the value. Is there a function which passes in the value and automatically passes along the value? Something like:</p>

<pre><code>// Hypothetical
Just(0)
    .map({ $0 + 1 })
    .call({ funcX($0) })
    .map({ $0 + 1 })
    .call({ funcY($0) })
    ...
</code></pre>

<p>Note: The above swift needs more syntax to actually compile, just is an example.</p>
","359532","","","","","2019-12-02 23:09:54","Is there a reactive function which executes and passes the original value?","<swift><reactive-programming><combine>","2","0","1","","","CC BY-SA 4.0"
"59129575","1","59166622","","2019-12-01 20:16:43","","1","850","<p>I'm trying to display images from a list of objects stored in <code>Firebase</code>. Initially the image loads fine, but if I switch to a different view and return to the list view the image never loads again.</p>

<p><a href=""https://i.stack.imgur.com/8zGi1.gif"" rel=""nofollow noreferrer"">Gif of the described bug</a></p>

<p><strong>The image data seems to be saved as expected on both load attempts:</strong>
<a href=""https://i.stack.imgur.com/WEEbk.png"" rel=""nofollow noreferrer"">here</a></p>

<p><strong>Below is my code</strong> for the image loader, which uses a url to fetch the images from Firebase Storage, and the list row that contains the image.</p>

<p><strong>ImageLoader.swift</strong></p>

<pre><code>import Foundation
import SwiftUI
import Firebase
import FirebaseFirestore

class ImageLoader: ObservableObject {
    @Published var dataIsValid = false
    var data:Data?

    func loadImage(url: String) {
        let imageRef = Storage.storage().reference(forURL: url)
        imageRef.getData(maxSize: 1 * 1024 * 1024) { data, error in
            if let error = error {
                print(""\(error)"")
            }
            guard let data = data else { return }
            DispatchQueue.main.async {
                print(self.dataIsValid)
                self.dataIsValid = true
                self.data = data
            }
        } 
    }

    func imageFromData() -&gt; UIImage {
        UIImage(data: self.data!)!
    }
}
</code></pre>

<hr>

<p><strong>ListRow.swift</strong></p>

<pre><code>import SwiftUI
import Combine

struct EventRow: View {
    @ObservedObject var imageLoader = ImageLoader()
    var imageUrl: String

    var body: some View {
        HStack {
            Image(uiImage: self.imageLoader.dataIsValid ? self.imageLoader.imageFromData() : UIImage())
            .resizable()
            .frame(width: 100.0, height: 140.0)
            .background(Color.gray)
            .clipShape(RoundedRectangle(cornerRadius: 5.0))

        }
        .onAppear {
            self.imageLoader.loadImage(url: self.imageUrl)
        }
    }
}
</code></pre>
","12464655","","10584330","","2019-12-02 08:21:11","2019-12-04 02:19:06","Firebase image is empty after switching views in SwiftUI","<ios><swift><firebase><firebase-storage><swiftui>","1","3","","","","CC BY-SA 4.0"
"59148845","1","59165563","","2019-12-03 01:07:34","","3","1493","<p>I have been working on an app with a compass in it that updates its heading based on <a href=""https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/LocationHeadingProxy.swift"" rel=""nofollow noreferrer"">this example</a> for publishing heading changes and <a href=""https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/HeadingViewController.swift"" rel=""nofollow noreferrer"">this example</a> for creating a publisher to deal with those changes.</p>

<p>I'm very new to reactive programming, but the issue I'm running into seems like a common problem, so I wanted to post it and see if someone can help.</p>

<p>Sometimes it works for a little while, with new headings coming from the publisher and updating the UI, but then stops working. Other times, it doesn't ever start updating (an error is being delivered before any heading updates). In either case, it makes sense that the events would stop since a failure completion event is being sent to the publisher:</p>

<pre><code>func locationManager(_ manager: CLLocationManager,
                     didFailWithError error: Error) {

    headingPublisher.send(completion: Subscribers.Completion.failure(error))

    print(""error: \(error.localizedDescription)"")
}
</code></pre>

<p>First, I'm trying to figure out what these errors are so I can try to deal with them better... is the error really worth stopping the publisher? I am wondering what kind of error can happen mid-stream of heading updates, since heading updates resume after the error, even though the publisher stops. I tried printing the error, but all I get is this, which doesn't seem helpful:
<code>error: The operation couldn’t be completed. (kCLErrorDomain error 0.)</code></p>

<p>I am not great at iOS, so if anyone has suggestions for how to get a better error description here please let me know.</p>

<p>Second, I'm wondering how I can ignore errors from the publisher on the subscription, if that's what I should be doing, so <code>.sink</code> will keep getting heading updates even after there is an error. Here's my publisher code below, based on the example:</p>

<pre><code>    _ = headingProxy
        .publisher
        .receive(on: RunLoop.main)
        .sink(receiveCompletion: { completion in },
              receiveValue: { [weak self] (heading) in
                self?.currentHeadingAccuracy = heading.headingAccuracy
                self?.currentHeading = heading.trueHeading
        })
        .store(in: &amp;cancellableSet)
</code></pre>

<p>I realize I could just not ever send the error to the publisher (is that what I should do? have a specific publisher just for the heading updates that never sends errors?) but I am assuming the person who made this included sending the error to the publisher with good reason, and that it may be a best practice to deal with it on the subscription side instead, or that there is some best-practice for recovering after an error.</p>
","241163","","1000551","","2019-12-07 09:59:23","2019-12-07 09:59:23","What is the best practice for dealing with errors in a publisher in Combine? (Publishing heading updates from CoreLocation)","<ios><swift><core-location><combine>","1","1","1","","","CC BY-SA 4.0"
"59153373","1","59173416","","2019-12-03 08:58:28","","-1","262","<p>I have a <code>List</code> with <code>NavigationLink</code> in  <code>NavigationView</code> and a <code>Button</code> for show a modal.</p>

<p>When I show detail no problem, but if I open modal and show detail not working.
My device (iPhone XS) freeze with CPU 100%.</p>

<p><strong>Code modal :</strong> </p>

<pre><code>
import SwiftUI
import Combine

struct RoomFormView: View {
    @ObservedObject var viewModel : RoomFormViewModel
    @Binding var show : Bool

    var body: some View {
        NavigationView {
            VStack(alignment: .leading, spacing: 5) {
                Text(""Nom de la pièce"")
                TextField(""Nom"", text: self.$viewModel.name) {
                    HelperView.closeKeyboard()
                }
                Spacer().frame(width: nil, height: 15, alignment: .center)
                Text(""Etage"")
                TextField(""Etage"", text: self.$viewModel.floor) {
                    HelperView.closeKeyboard()
                }
                Spacer()
                }.padding(22)
            .navigationBarItems(leading: Button(action: {
                self.show = false
            }) {
                Text(""Annuler"")
            }, trailing:                     Button(action: {
                HelperView.closeKeyboard()
                self.viewModel.validate()
                self.show = false
            }, label: {
                Text(""Valider"")
                })).navigationBarTitle(""Ajouter une pièce"")
        }
    }
}

</code></pre>
","4145483","","4145483","","2019-12-04 10:00:47","2019-12-07 11:03:05","SwiftUI Freeze device","<ios><swift><swiftui>","1","3","","","","CC BY-SA 4.0"
"59206514","1","59206913","","2019-12-06 03:37:27","","1","205","<p>I have problem, that UI gets ugly updated from zero to some number. <em>Problem is when removing all items and adding new items to array UI gets updated</em> because this array is marked with <strong><em>@Published</em></strong> property wrapper. More detailed explanation about problem:</p>

<ol>
<li>At stage 1 (marked in the code snapshot) removing items from the list. </li>
<li>In this case UI gets updated and count in the UI updates to zero.</li>
<li>After some time when fetch is done and new items are added into array
(stage 2).  </li>
<li>Then UI gets update with new items count.</li>
<li>Problem is that here is ugly count update from zero to some number in the UI.</li>
</ol>

<p>Is here a way to disable distributing event for class members which are marked with @Published property wrapper?</p>

<pre><code>class ItemsProvider: ObservableObject {
    @Published var items: [Item] = []

    func fetchUsing(query: Query, completion: @escaping (Error?) -&gt; Void) {
        self.items.removeAll() // 1. Removing old items.

        query.getDocuments { (result, error) in
            result?.forEach {
                self.items.append(try? $0.data(as: Item.self)) // 2. Adding new items.
            }
            completion(error)
        }
    }
}
</code></pre>
","1151916","","","","","2019-12-06 04:31:55","Disable sending events for @Published variables in the ObservableObject","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"59219019","1","59219318","","2019-12-06 19:14:40","","11","4037","<p>I'm looking for an equivalent of AppKit's <a href=""https://developer.apple.com/documentation/swiftui/nshostingview"" rel=""noreferrer"">NSHostingView</a> for UIKit so that I can embed a SwiftUI view in UIKit. Unfortunately, UIKit does not have an equivalent class to <code>NSHostingView</code>. The closest we have as an equivalent of <a href=""https://developer.apple.com/documentation/swiftui/nshostingcontroller"" rel=""noreferrer"">NSHostingController</a>, named <a href=""https://developer.apple.com/documentation/swiftui/uihostingcontroller"" rel=""noreferrer"">UIHostingController</a>. Since a view controller contains a view, we should be able to <a href=""https://stackoverflow.com/a/24236625/35690"">call the appropriate UIViewController embedding methods</a>, and then grab the <code>view</code> and use it directly.</p>

<p><a href=""https://developer.apple.com/videos/play/wwdc2019/231/?time=452"" rel=""noreferrer"">There</a> <a href=""https://stackoverflow.com/questions/56433826/include-swiftui-views-in-existing-uikit-application"">are</a> <a href=""https://stackoverflow.com/questions/56631892/addsubview-swiftui-view-to-uikit-uiview-in-swift"">many</a> <a href=""https://sarunw.com/posts/swiftui-in-uikit/"" rel=""noreferrer"">articles</a> that explain that this is <em>the way</em> to embed a SwiftUI view inside UIKit. However, they typically fall short in explaining how you would communicate from <strong>UIKit ➡️ SwiftUI</strong>. For example, imagine I implemented a SwiftUI view that acts as a progress bar, periodically, I'd like the progress to be updated. I want my legacy/UIKit code to update the SwiftUI view to display the new progress.</p>

<p>The <a href=""https://stackoverflow.com/a/56827040/35690"">only article I found</a> that came close to explaining how to manipulate an embedded view's content suggested we do so by using <code>@ObservedObject</code>:</p>

<pre><code>import UIKit
import SwiftUI
import Combine

class CircleModel: ObservableObject {
    var didChange = PassthroughSubject&lt;Void, Never&gt;()

    var text: String { didSet { didChange.send() } }

    init(text: String) {
        self.text = text
    }
}

struct CircleView : View {
    @ObservedObject var model: CircleModel

    var body: some View {
        ZStack {
            Circle()
                .fill(Color.blue)
            Text(model.text)
                .foregroundColor(Color.white)
        }
    }
}

class ViewController: UIViewController {
    private weak var timer: Timer?
    private var model = CircleModel(text: """")

    override func viewDidLoad() {
        super.viewDidLoad()

        addCircleView()
        startTimer()
    }

    deinit {
        timer?.invalidate()
    }
}

private extension ViewController {
    func addCircleView() {
        let circleView = CircleView(model: model)
        let controller = UIHostingController(rootView: circleView)
        addChild(controller)
        controller.view.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(controller.view)
        controller.didMove(toParent: self)

        NSLayoutConstraint.activate([
            controller.view.widthAnchor.constraint(equalTo: view.widthAnchor, multiplier: 0.5),
            controller.view.heightAnchor.constraint(equalTo: view.heightAnchor, multiplier: 0.5),
            controller.view.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            controller.view.centerYAnchor.constraint(equalTo: view.centerYAnchor)
        ])
    }

    func startTimer() {
        var index = 0
        timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { [weak self] _ in
            index += 1
            self?.model.text = ""Tick \(index)""
        }
    }
}

</code></pre>

<p>This seems to make sense as the timer should trigger a chain of events that update the view:</p>

<ol>
<li>✅ <code>self?.model.text = ""Tick 1""</code> (In <code>ViewController.startTimer()</code>).</li>
<li>✅ <code>didChange.send()</code> (In <code>CircleModel.text.didSet</code>)</li>
<li>❌ <code>Text(model.text)</code> (In <code>CircleView.body</code>)</li>
</ol>

<p>As you can see by the indicators (which specify if something was run or not), the problem is that <code>didChange.send()</code> never triggers a re-run of <code>CircleView.body</code>.</p>

<p>How do I communicate from UIKit > SwiftUI to manipulate a SwiftUI view that was embedded in UIKit?</p>
","35690","","35690","","2019-12-06 19:23:04","2019-12-06 19:37:50","How do I update a SwiftUI View that was embedded into UIKit?","<ios><swift><uikit><swiftui>","1","1","1","","","CC BY-SA 4.0"
"59224781","1","59248313","","2019-12-07 09:50:05","","9","4090","<p>I want to make a network request more than one time when some error occurs using retry() from Swift/Combine. The block inside the publisher is called once only which means one only one request is made for a real app when error happens. My code is:</p>

<pre class=""lang-swift prettyprint-override""><code>import UIKit
import Combine
import PlaygroundSupport

enum TestFailureCondition: Error {
    case invalidServerResponse
}

var backgroundQueue: DispatchQueue = DispatchQueue(label: ""backgroundQueue"")

var failPublisher: AnyPublisher&lt;(Data, URLResponse), Error&gt; {
    Future&lt;(Data, URLResponse), Error&gt; { promise in
        print(""Attempt to call"")
        backgroundQueue.asyncAfter(deadline: .now() + Double.random(in: 1..&lt;3)) {
            promise(.failure(TestFailureCondition.invalidServerResponse))
        }
    }
    .eraseToAnyPublisher()
}

let cancellable = failPublisher
.print(""(1)&gt;"")
.retry(3)
.print(""(2)&gt;"")
.sink(receiveCompletion: { fini in
    print("" ** .sink() received the completion:"", String(describing: fini))


    PlaygroundPage.current.finishExecution()
}, receiveValue: { stringValue in
    print("" ** .sink() received \(stringValue)"")
})

PlaygroundPage.current.needsIndefiniteExecution = true
</code></pre>

<p>I expect that <code>backgroundQueue.asyncAfter(deadline)</code> is called three time before some error happens. Does anyone know why?</p>
","6305934","","","","","2019-12-29 12:12:07","Swift. Combine. Is there any way to call a publisher block more than once when retry?","<swift><combine>","2","2","1","","","CC BY-SA 4.0"
"59240848","1","59243722","","2019-12-08 23:26:35","","1","111","<p><strong>Scenario:</strong> Attempting to broadcast a variable value via an <em>ObservableObject</em>.
<br/>
<strong>Problem:</strong> I'm only getting the default value; not the <em>assigned</em> value.
<p>
Here's the origin. <br/>
Button #1 starts a function to get data.
<br/>
Button #2 retrieves the ObservedObject's revised value
<p>
I removed some of the vestigial code to make the presentation simpler:
<p></p>

<pre><code>struct ContentView: View {
    @ObservedObject var networkManager = NetworkManager()

    let fontCustom = Font.custom(""Noteworthy"", size: 23.0)

    var body: some View {
        ZStack {
        // ...
        // ...
 HStack {
         Button(
              action: {
                  NetworkManager().getCalculatorIDs()
              },
              label: { 
                 Text(""1"")
              }
         )

        Button(
             action: {
                 self.calculator.calculate(""2"");
                 print(self.networkManager.calculationID)  // stop and check.                            
             },
             label: { Text(""2"") }
        )
// ...
// ...
}
}
</code></pre>

<p><p>
So I tap Button #1 then tap Button #2 to check if the <em>ObservedObject</em> has the <em>generated id value</em>.  <p>
I'm expecting an alphanumeric id value in the print(). <p>
Instead, I got the original value:<br/></p>

<pre><code>Royal Turkey
(lldb) 
</code></pre>

<p><p>
Here's the ObservableObject:
<p></p>

<pre><code>struct CalculationIdentifier: Decodable {
    let id: String
    let tokens: [String]
}

class NetworkManager: ObservableObject {
    @Published var calculationID = ""Royal Turkey""
    @Published var isAlert = false
    @Published var name = ""Ric Lee""

    let calculations = ""https://calculator-frontend-challenge.herokuapp.com/Calculations""

    func getCalculatorIDs() {
        let urlRequest = URLRequest(url: URL(string: calculations)!)
        let configuration = URLSessionConfiguration.ephemeral

        let task = URLSession(configuration: configuration).dataTask(with: urlRequest) { data, _, error in

            DispatchQueue.main.async {
                do {
                    let result = try JSONDecoder().decode([CalculationIdentifier].self, from: data!)
                    if !result.isEmpty {
                        self.calculationID = (result[0] as CalculationIdentifier).id
                        print(""Inside do{}. result = \(result)"")
                        self.isAlert = true
                    } else {
                        print(#function, ""Line:"", #line, "": No Result"")
                    }
                } catch {
                    print(error)
                }
            }
        }

        task.resume()
    }
}
</code></pre>

<p><p>
BTW: Here's the <em>local</em> console output, the string value of 'id' should have been passed to the host as an <em>ObservedObject</em> value:</p>

<pre><code>Inside do{}. result = [RicCalculator2.CalculationIdentifier(id: ""d3dd3b1e-d9f6-4593-8c85-b8fd3d018383"", tokens: [])]
</code></pre>

<p><p>
So I do have a bona fide id value to send.
<p>
Why only the original value? <br/>
What am I missing?<p>
...do I need to do a 'send' or something?</p>
","715747","","715747","","2019-12-08 23:36:53","2019-12-09 06:39:54","ObservedObject only passes its default value; not its assigned value. Why?","<combine><observableobject><observedobject>","1","0","","","","CC BY-SA 4.0"
"59253731","1","59271206","","2019-12-09 17:20:45","","-1","981","<p>I am getting the following compiler-time error, for a Swift publisher solution I am working on:</p>

<p><code>Instance method 'store(in:)' requires that 'Set&lt;[AnyCancellable]&gt;' conform to 'RangeReplaceableCollection'</code></p>

<p>My code block is as follows:</p>

<pre><code>public class APIService {
    static let baseURL = URL(string: ""https://api.recommendations.samba.tv"")!
    var apiKey: String

    var logger = Logger(label: ""com.samba.tv.recommendations"")

    private var subscriptions = Set&lt;AnyCancellable&gt;()

    private let jsonDecoder: JSONDecoder = {
        let jsonDecoder = JSONDecoder()
        jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = ""yyyy-mm-dd""
        jsonDecoder.dateDecodingStrategy = .formatted(dateFormatter)
        return jsonDecoder
    }()


    /// Defines the type of API error returbed,
    /// An enumerating type to classify the types of errors that can occur. Returns an `Error`, such as `noResponse`. Specific errors with messages will return both an error message and code.
    enum APIError: Error, LocalizedError {
        case missingCredentials
        case urlError(URLError)
        case responseError(Int)
        case decodingError(DecodingError)
        case genericError

        var localizedDescription: String {
            switch self {
            case .missingCredentials:
                return ""Missing credentials""
            case .urlError(let error):
                return error.localizedDescription
            case .decodingError(let error):
                return error.localizedDescription
            case .responseError(let status):
                return ""Bad response code: \(status)""
            case .genericError:
                return ""An unknown error has been occured""
            }
        }
    }

    /// Obtain Endpoint complete with baseURL
    ///
    /// An enumeration type, with an in-line function. This method constructs the entire URL, using the `baseURL` variable declared prior.
    /// By passing the specific enum type, such as `.popular(param)`, along with a `Popular` parameter, which is optional.
    enum Endpoint {
        case popular(popularParam: Popular?)

        func path() -&gt; URLComponents {
            switch self {
            case let .popular(popularParam):
                var queryItems = [URLQueryItem]()
                let urlString = ""\(baseURL)/popularity""
                var components = URLComponents(url: URL(string: urlString)!, resolvingAgainstBaseURL: true)!

                if let countryCode = popularParam?.country {
                    queryItems.append(URLQueryItem(name: ""country_code"", value: countryCode.rawValue))
                }
                if let namespace = popularParam?.namespace {
                        queryItems.append(URLQueryItem(name: ""response_namespace"", value: namespace.rawValue))
                }
                if let contentType = popularParam?.contentType {
                            queryItems.append(URLQueryItem(name: ""content_type"", value: contentType.rawValue))
                }
                if let genres = popularParam?.genres {
                    let genreArrayString = genres.compactMap({String($0.rawValue)}).joined(separator: "","")
                                queryItems.append(URLQueryItem(name: ""genre_ids"", value: genreArrayString))
                }
                components.queryItems = queryItems
                return components
            }
        }
    }

    init(key: String) {
        apiKey = key
    }

    /// Generic `GET` function, facilitating calls by passing in an `Endpoint` along with any parameters.
    /// It returns a `Result&lt;T, APIError&gt;`.
    ///  The method also inserts the required header parameters, including `apiKey`, and will fail if it is not valid, or missing.
    func GET&lt;T: Codable&gt;(endpoint: Endpoint,
                         params: [String: String]?) -&gt; Future&lt;[T], APIError&gt; {

//        guard let apiKey = APIService.shared.apiKey else {
//            throw APIError.missingCredentials
//        }

        return Future&lt;[T], APIError&gt; { promise in


            var components = endpoint.path()
            var request = URLRequest(url: components.url!)
            request.addValue(""Bearer \(self.apiKey)"", forHTTPHeaderField: ""Authorization"")
            request.addValue(""application/json"", forHTTPHeaderField: ""accept"")

            if let params = params {
                for (_, value) in params.enumerated() {
                    components.queryItems?.append(URLQueryItem(name: value.key, value: value.value))
                }
            }

            request.httpMethod = ""GET""

            URLSession.shared.dataTaskPublisher(for: request)
            .tryMap{ data, response -&gt; Data in
                guard let httpResponse = response as? HTTPURLResponse, 200...299 ~= httpResponse.statusCode else {
                    throw APIError.responseError((response as? HTTPURLResponse)?.statusCode ?? 500)
                }
                return data
            }
            .decode(type: PaginatedResponse.self, decoder: self.jsonDecoder)
            .receive(on: RunLoop.main)
                .sink(receiveCompletion: { (completion) in
                    if case let .failure(error) = completion {
                        switch error {
                        case let urlError as URLError:
                            promise(.failure(.urlError(urlError)))
                        case let decodingError as DecodingError:
                            promise(.failure(.decodingError(decodingError)))
                        case let apiError as APIError:
                            promise(.failure(apiError))
                        default:
                            promise(.failure(.genericError))
                        }
                    }
                }, receiveValue: { promise(.success($0.results)) })
                .store(in: &amp;self.subscriptions)
            }

    }

}
</code></pre>

<p>The error appears in the last line, for <code>.store(in:....</code>. 
<a href=""https://i.stack.imgur.com/BGEkq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BGEkq.png"" alt=""enter image description here""></a></p>

<h2>Question</h2>

<p>How do I resolve the error? </p>

<h2>Additional referenced classes</h2>

<p><em>PaginatedResponse.swift</em></p>

<pre><code>import Foundation

struct PaginatedResponse&lt;T: Codable&gt;: Codable {
    let paginator: Paginator
    let results: [T]
}

</code></pre>

<p><em>ContentItem.swift</em></p>

<pre><code>struct ContentItem: Codable, Equatable {
    enum ContentID: Codable {
        case text(String)
        case number(Int)

        case empty
    }
    enum SeriesID: Codable {
        case text(String)
        case number(Int)

        case empty
    }

    enum CodingKeys: String, CodingKey {
        case contentID = ""content_id""
        case seriesID = ""series_id""
        case rank = ""rank""
        case score = ""score""
    }

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        rank = try values.decode(Int.self, forKey: .rank)
        score = try values.decode(Float.self, forKey: .score)
        seriesID = try values.decode(SeriesID.self, forKey: .seriesID)
        contentID = try values.decode(ContentID.self, forKey: .contentID)
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(score, forKey: .score)
        try container.encode(rank, forKey: .rank)
        try container.encode(seriesID, forKey: .seriesID)
        try container.encode(contentID, forKey: .contentID)
    }


    let rank: Int
    let score: Float
    let seriesID: SeriesID
    let contentID: ContentID

}

extension ContentItem.SeriesID: Equatable, Hashable {

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .text(let text):
            try container.encode(text)
        case .number(let number):
            try container.encode(number)
        case .empty:
            break
        }
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(self.hashValue)
    }


    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let text = try? container.decode(String.self) {
            self = .text(text)
        } else if let number = try? container.decode(Int.self) {
            self = .number(number)
        } else {
            //assertionFailure(""Unknown id type"")
            self = .empty
        }
    }

}

extension ContentItem.ContentID: Equatable, Hashable {

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .text(let text):
            try container.encode(text)
        case .number(let number):
            try container.encode(number)
        case .empty:
            break
        }
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(self.hashValue)
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let text = try? container.decode(String.self) {
            self = .text(text)
        } else if let number = try? container.decode(Int.self) {
            self = .number(number)
        } else {
//            assertionFailure(""Unknown id type"")
            self = .empty
        }
    }

}
</code></pre>
","163845","","163845","","2019-12-10 00:25:05","2019-12-10 16:03:23","In Swift Combine Publisher, I am getting conform to 'RangeReplaceableCollection' error","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"59259921","1","59260001","","2019-12-10 03:47:41","","41","24386","<h1>Aim:</h1>

<p>I have a model which is an <code>ObservableObject</code>. It has a <code>Bool</code> property, I would like to use this <code>Bool</code> property to initialise a <code>@Binding</code> variable.</p>

<h1>Questions:</h1>

<ol>
<li>How to convert an <code>@ObservableObject</code> to a <code>@Binding</code> ?</li>
<li>Is creating a <code>@State</code> the only way to initialise a <code>@Binding</code> ?</li>
</ol>

<h1>Note:</h1>

<ul>
<li>I do understand I can make use of <code>@ObservedObject</code> / <code>@EnvironmentObject</code>, and I see it's usefulness, but I am not sure a simple button needs to have access to the entire model. </li>
<li>Or is my understanding incorrect ?</li>
</ul>

<h1>Code:</h1>

<pre><code>import SwiftUI
import Combine
import SwiftUI
import PlaygroundSupport

class Car : ObservableObject {

    @Published var isReadyForSale = true
}

struct SaleButton : View {

    @Binding var isOn : Bool

    var body: some View {

        Button(action: {

            self.isOn.toggle()
        }) {
            Text(isOn ? ""On"" : ""Off"")
        }
    }
}

let car = Car()

//How to convert an ObservableObject to a Binding
//Is creating an ObservedObject or EnvironmentObject the only way to handle a Observable Object ?

let button = SaleButton(isOn: car.isReadyForSale) //Throws a compilation error and rightly so, but how to pass it as a Binding variable ?

PlaygroundPage.current.setLiveView(button)
</code></pre>
","1046037","","","","","2022-05-01 09:55:08","Binding value from an ObservableObject","<swift><swiftui><combine>","4","0","8","","","CC BY-SA 4.0"
"59263207","1","59263632","","2019-12-10 08:42:49","","1","129","<p>I have my data coming back from an api call using Combine this way:</p>

<pre><code>[Animals.Dog(id: nil, name: ""Bobby"", age: 4), Animals.Dog(id: nil, name: ""Cronos"", age: 2), Animals.Dog(id: nil, name: ""Willy"", age: 2), Animals.Dog(id: nil, name: ""Rex"", age: 8)]
finished
</code></pre>

<p>When populating my List with the array of animals, only the first item is populated. But this same first item is displayed as much animals as they are. In this case, the first item is populated 4 times and I cannot see the three other dogs on my List. </p>

<p>Where are my data hidden?</p>

<pre><code>import SwiftUI
import Combine

struct AnimalsView: View {

  @State private var dogs = [Dog]()

  private let networkRequest = NetworkRequest()

  //MARK: - Body
  var body: some View {
    VStack(spacing: 20) {
      TitleView()

      //MARK: Dogs list view
      List(dogs) {
        AnimalCell(name: $0.name,
                   age: $0.age)
      }
      .modifierViewList()
    }
    .onAppear {
      _ = networkRequest.downloadAnimals()
        .sink(receiveCompletion: {
          print($0)
        },receiveValue: { (animal) in
          self.dogs = animal.dogs
          print(animal.dogs)
        })
    }
  }
}

//MARK: Network request
extension NetworkRequest {
  func downloadAnimals() -&gt; AnyPublisher&lt;Animal, Error&gt; {
    URLSession.shared
      .dataTaskPublisher(for: EndPoint.rates.url)
      .receive(on: networkQueue)
      .map(\.data)
      .decode(type: Animal.self, decoder: JSONDecoder())
      .mapError { (error) -&gt; NetworkRequest.Error in
        switch error {
        case is URLError:
          return Error.addressUnreachable(EndPoint.rates.url)
        default:
          return Error.invalidResponse
        }
    }
    .eraseToAnyPublisher()
  }
}
</code></pre>
","10408494","","10408494","","2019-12-10 08:58:47","2019-12-10 10:57:34","Why is my SwiftUI List not being populating with all my data?","<swift><list><api><swiftui>","2","0","","","","CC BY-SA 4.0"
"59274296","1","59276234","","2019-12-10 19:43:38","","9","6786","<p>I am discovering Combine. I wrote methods that make HTTP requests in a ""combine"" way, for example:</p>

<pre class=""lang-swift prettyprint-override""><code>func testRawDataTaskPublisher(for url: URL) -&gt; AnyPublisher&lt;Data, Error&gt; {
    var request = URLRequest(url: url,
                             cachePolicy: .useProtocolCachePolicy,
                             timeoutInterval: 15)
    request.httpMethod = ""GET""

    return urlSession.dataTaskPublisher(for: request)
        .tryMap {
            return $0.data
        }
        .eraseToAnyPublisher()
}
</code></pre>

<p>I would like to call the method multiple times and do a task after all, for example:</p>

<pre class=""lang-swift prettyprint-override""><code>let myURLs: [URL] = ...

for url in myURLs {
    let cancellable = testRawDataTaskPublisher(for: url)
        .sink(receiveCompletion: { _ in }) { data in
            // save the data...
        }
}
</code></pre>

<p>The code above won't work because I have to store the cancellable in a variable that belongs to the class.
The first question is: is it a good idea to store many (for example 1000) cancellables in something like <code>Set&lt;AnyCancellable&gt;</code>??? Won't it cause memory leaks?</p>

<pre class=""lang-swift prettyprint-override""><code>var cancellables = Set&lt;AnyCancellable&gt;()

...

    let cancellable = ...

    cancellables.insert(cancellable) // ???
</code></pre>

<p>And the second question is: how to start a task when all the cancellables are finished? I was thinking about something like that</p>

<pre class=""lang-swift prettyprint-override""><code>class Test {
    var cancellables = Set&lt;AnyCancellable&gt;()

    func run() {
        // show a loader

        let cancellable = runDownloads()
            .receive(on: RunLoop.main)
            .sink(receiveCompletion: { _ in }) { _ in
                // hide the loader
            }

        cancellables.insert(cancellable)
    }

    func runDownloads() -&gt; AnyPublisher&lt;Bool, Error&gt; {
        let myURLs: [URL] = ...

        return Future&lt;Bool, Error&gt; { promise in
            let numberOfURLs = myURLS.count
            var numberOfFinishedTasks = 0

            for url in myURLs {
                let cancellable = testRawDataTaskPublisher(for: url)
                    .sink(receiveCompletion: { _ in }) { data in
                        // save the data...
                        numberOfFinishedTasks += 1

                        if numberOfFinishedTasks &gt;= numberOfURLs {
                            promise(.success(true))
                        }
                    }

                cancellables.insert(cancellable)
            }
        }.eraseToAnyPublisher()
    }

    func testRawDataTaskPublisher(for url: URL) -&gt; AnyPublisher&lt;Data, Error&gt; {
        ...
    }
}
</code></pre>

<p>Normally I would use <code>DispatchGroup</code>, start multiple HTTP tasks and consume the notification when the tasks are finished, but I am wondering how to write that in a modern way using Combine.</p>
","3278728","","1102215","","2019-12-11 03:43:43","2019-12-11 07:54:22","Apple Combine framework: How to execute multiple Publishers in parallel and wait for all of them to finish?","<swift><combine>","1","0","5","","","CC BY-SA 4.0"
"59286892","1","59335239","","2019-12-11 13:28:43","","3","119","<p>I've created a view for setting a time (minutes and seconds). It uses two wheel pickers bound to two state variables.</p>

<p>Now I'd like to use that view at different places in the app, but I don't like the interface with two seperate variables for the time. Instead, I'd like to have just one bound variable holding the time in seconds (so time = 185 would translate to 3 minutes and 5 seconds).</p>

<p>Is it possible to have some sort of ""adapter"" between bindings?</p>

<p>Here's the view:</p>

<pre><code>import SwiftUI

struct TimePicker: View {
    var minutes: Binding&lt;Int&gt;
    var seconds: Binding&lt;Int&gt;

    var body: some View {
        HStack() {
            Spacer()
            Picker(selection: minutes, label: EmptyView()) {
                ForEach((0...9), id: \.self) { ix in
                    Text(""\(ix)"").tag(ix)
                }
                }.pickerStyle(WheelPickerStyle()).frame(width: 50).clipped()
            Text(""Min."")
            Picker(selection: seconds, label: EmptyView()) {
                ForEach((0...59), id: \.self) { ix in
                    Text(""\(ix)"").tag(ix)
                }
                }.pickerStyle(WheelPickerStyle()).frame(width: 50).clipped()
            Text(""Sec."")
            Spacer()
        }
    }
}
</code></pre>
","10826194","","","","","2022-06-21 15:18:14","How to translate bindings in a view?","<binding><swiftui><combine>","1","3","1","","","CC BY-SA 4.0"
"59292764","1","59294149","","2019-12-11 19:29:23","","6","1420","<p>Here is my pipeline:</p>

<pre><code>URLSession.shared
      .dataTaskPublisher(for: urlRequest)
      .map { $0.data }
      .mapError { ...... }
      .eraseToAnyPublisher()
      .decode(type: MyObject.self, decoder: JSONDecoder())
      .receive(on: RunLoop.main)
      .catch { [weak self] error -&gt; Just&lt;MyObject&gt; in
        guard let self = self else { return Just(emptyPayload) }
        self.hasError = true
        return Just(emptyPayload)
    }
    .sink(
      receiveCompletion: { [weak self] _ in
        print(""i'm here"")
      },
      receiveValue: { [weak self] value in
        print(""value"")
      }
    )
</code></pre>

<p>Why is sink never called?</p>
","1366265","","1102215","","2019-12-11 21:13:18","2019-12-12 02:14:01","Why is sink never called in my combine pipeline?","<swift><nsurlsession><combine>","1","2","","2019-12-11 21:16:48","","CC BY-SA 4.0"
"59303651","1","59308544","","2019-12-12 11:32:53","","-2","617","<p>I would like to verify if some <code>CurrentValueSubject</code> has any subscriptions added. Is there any way to verify this?</p>
","4528716","","","","","2019-12-13 09:50:55","Combine - test if CurrentValueSubject has any subscribers","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"59327319","1","59327783","","2019-12-13 17:32:22","","0","61","<p>I need to append something to my anchor.
I am trying to do this in a function of my class, but i declared this anchor in my viewcontroller.</p>

<p>This anchor is not recognized in my class. How do I reach this anchor?</p>

<p><strong>viewController.swift:</strong></p>

<pre><code>import UIKit
import RealityKit
import Combine

class ViewController: UIViewController {

    @IBOutlet var arView: ARView!

    override func viewDidLoad() {
        super.viewDidLoad()

        let gameAnchor = AnchorEntity(plane: .horizontal)
        arView.scene.addAnchor(gameAnchor)

        //generate random width en distance
        let randomDistance = Double.random(in: 0.07...0.25)
        let randomWidth = Double.random(in: 0.01...0.05)

        //make a new platform
        let newPlatform = Platform(width: randomWidth, heigth: 0.1, depth: 0.05, distance: randomDistance)
        newPlatform.makePlatform()
    }
}
</code></pre>

<p><strong>My class:</strong></p>

<pre><code>import Foundation
import RealityKit

class Platform {
    var width: Double = 0.05
    var heigth: Double = 0.1
    var depth: Double = 0.05
    var distance: Double = 0.1

    init(width: Double, heigth: Double, depth: Double, distance: Double) {
        self.width = width
        self.heigth = heigth
        self.depth = depth
        self.distance = distance
    }

    func makePlatform() {
        let platformMesh = MeshResource.generateBox(width: Float(width), height: 0.1, depth: 0.05)
        let platformMaterial = SimpleMaterial(color: .red, isMetallic: false)
        let newPlatform = ModelEntity(mesh: platformMesh, materials: [platformMaterial])
        newPlatform.position.x = Float(distance)
        newPlatform.position.y = 0.05

        //append it to my anchor
        ///gameAnchor.addChild(newPlatform)
    }
}
</code></pre>
","12398510","","6599590","","2020-01-27 21:10:09","2020-01-27 21:10:09","How to reach variable from viewcontroller in a custom class?","<swift><xcode><class><realitykit>","1","5","","","","CC BY-SA 4.0"
"59330610","1","59330861","","2019-12-13 22:33:06","","2","205","<p>In the iOS 13 Combine framework, there are three <code>collect</code> operator methods. The first two are obvious but the third uses types I can't figure out.</p>

<pre><code> collect(_:options:)
</code></pre>

<p><a href=""https://developer.apple.com/documentation/foundation/timer/timerpublisher/3329497-collect"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/foundation/timer/timerpublisher/3329497-collect</a></p>

<pre><code>func collect&lt;S&gt;(_ strategy: Publishers.TimeGroupingStrategy&lt;S&gt;, 
    options: S.SchedulerOptions? = nil) 
    -&gt; Publishers.CollectByTime&lt;Timer.TimerPublisher, S&gt; 
    where S : Scheduler
</code></pre>

<p>Can anyone give an example of how one would call this method?</p>
","341994","","","","","2019-12-18 00:06:27","Combine framework third `collect` method","<ios><ios13><combine>","2","0","","","","CC BY-SA 4.0"
"59335797","1","59337643","","2019-12-14 13:58:33","","3","1940","<p>I've seen several posts about this, but so far none of the solutions seem to be working for me.</p>

<p>I'm trying to create an array of Identifiable items using ForEach -- with both a <code>Text()</code> and <code>Toggle()</code> view inside. The array is stored in a <code>@Published</code> property of an <code>@ObservableObject</code>.</p>

<p>I'm currently looping through the indices to create the toggle bindings (as suggested in <a href=""https://stackoverflow.com/questions/57631225/using-foreach-loop-with-binding-causes-index-out-of-range-when-array-shrinks-sw"">other posts</a>). </p>

<p>Everything appears to be working, until I try to delete a row. </p>

<p>(Specifically the last row - which triggers a ""Fatal error: Index out of range"" every time.)</p>

<p>Any help would be greatly appreciated!</p>

<pre class=""lang-swift prettyprint-override""><code>struct Rule: Identifiable {
  let id: String
  var displayName: String
  var isEnabled: Bool
}

class UserData: ObservableObject {
  @Published var rules: [Rule] = []
}

struct RuleListView: View {
  @ObservableObject var userData: UserData

  var body: some View {
    List {
      ForEach(userData.rules.indices, id: \.self) { index in
        HStack {
          Toggle(
            isOn: self.$userData.rules[index].isEnabled
          ) { Text(""Enabled"") }
          Text(self.userData.rules[index].displayName)
        }
      }
      .onDelete(perform: delete)
    }
  }

  func delete(at offsets: IndexSet) {
    userData.rules.remove(atOffsets: offsets)
  }
}

</code></pre>
","10311552","","4546641","","2019-12-14 21:59:13","2020-05-17 06:44:33","SwiftUI: ForEach using Array/Index crashes when rows are deleted","<swift><swiftui><combine><swiftui-list>","1","1","","","","CC BY-SA 4.0"
"59342986","1","59355728","","2019-12-15 10:27:45","","3","1256","<p>Let's say that I've this simple chain that from an HTTP request creates a publisher for <code>&lt;T, APIManagerError&gt;</code></p>

<pre><code>   func run&lt;T:Decodable&gt;(request:URLRequest)-&gt;AnyPublisher&lt;T, APIManagerError&gt;{
        return URLSession.shared.dataTaskPublisher(for: request)
            .map{$0.data}
            .decode(type: T.self, decoder: JSONDecoder())
            .eraseToAnyPublisher()// it should run mapError before this point
    }
</code></pre>

<p>This code produces this error since I'm returning Error instead of <code>APIManagerError</code>.</p>

<pre><code>Cannot convert return expression of type 
'AnyPublisher&lt;T, Publishers.Decode&lt;Upstream, Output, Coder&gt;.Failure&gt;' 
(aka 'AnyPublisher&lt;T, Error&gt;') 
to return type 'AnyPublisher&lt;T, RestManagerError&gt;'
</code></pre>

<p>I know that to fix the issue I need to add a mapError after <code>.decode</code>.  </p>

<pre><code>.mapError{error in 
    APIManagerError.error(""Decode Fail"")
}
</code></pre>

<p>but I can't really understand what is reported with the error message before the ""aka"" part that is quite clear instead</p>

<p>How do you read the error <code>Publishers.Decode&lt;Upstream, Output, Coder&gt;.Failure</code>? specifically what does it mean the <code>.Failure</code> part? where can I find the <code>Failure</code> in the Swift Doc?  </p>
","499990","","","","","2019-12-16 21:12:01","Swift `Failure` keyword meaning in a Swift Combine chain error","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"59345963","1","59468331","","2019-12-15 16:45:18","","6","1510","<p>Let's say that: </p>

<p>• My application is a client of a Socket server. </p>

<p>• I'm free to write the Socket client implementation to fit with <code>Combine</code> as I prefer </p>

<p>I've implemented 2 solutions, one with <code>CurrentValueSubject</code> (quite easy) and a second with a custom subscription and a custom publisher that I'm not sure about. I really don't know which is the best way to bridge the code that I'm using to handle server messages with Combine. </p>

<p>Here is my code: </p>

<p>To simulate the socket server I've create a fake <code>SocketServerManager</code> that generates some events every <code>N</code> seconds: </p>

<pre><code>protocol SocketServerManagerDelegate{
    func newEvent(event:String)
}

class SocketServerManager {

    let timing: Double
    var timerHandler:Timer? = nil
    var delegates:[SocketServerManagerDelegate] = []

    init(timing:Double){
        self.timing = timing
    }

    func start(){
        // Just start a timer that calls generateEvent to simulate some events
        timerHandler = Timer.scheduledTimer(withTimeInterval: timing, repeats: true){
            [weak self] _ in
            self?.generateEvent()
        }
        timerHandler?.fire()
    }


    private func generateEvent(){
        let events = [""New Player"", ""Player Disconnected"", ""Server Error""]
        let currentEvent = events.randomElement

        for delegate in delegates{
           delegate.newEvent(event: currentEvent)
        }
    }            
}
</code></pre>

<h2>Custom Publisher and Subscription</h2>

<p>My custom subscription keeps  a reference to an instance of the server manager and to the subscriber. 
Also, it implements a <code>SocketServerManager</code> delegate. So that when the server has a new event it calls the subscription that can now send the <code>receive</code> event on the subscriber <strong>(This is the choice where I have A LOT OF doubts...)</strong></p>

<pre><code>class EventSubscription&lt;S:Subscriber&gt;:Subscription, SocketServerManagerDelegate 
    where S.Input == String{

    private var subscriber:S?
    private unowned var server:SocketServerManager

    init(sub:S, server:EventsServer){
        self.subscriber = sub
        self.server = server
    }

    func request(_ demand: Subscribers.Demand) {}

    func cancel() {
        subscriber = nil
    }

    // HERE IS WHERE I SEND THE EVENT TO THE SUBSCRIBER since this subscription 
    is a delegate of the server manager 
    func newEvent(event: Event) {
        _ = subscriber?.receive(event) 
    }
}
</code></pre>

<p>The publisher has nothing special...it will just create the subscription with the <code>receive</code> function. Also it appends the subscription to the list of delegates registered on the server so that the <code>generatesEvents</code> function can broadcast the event through the delegates (hence, through the subscriptions).</p>

<pre><code>// PUBLISHER CODE ----------
func receive&lt;S&gt;(subscriber: S)
    where S:Subscriber,
    EventsPublisher.Failure == S.Failure,
    EventsPublisher.Output == S.Input {

        let subscription = EventSubscription(sub:subscriber, server: self.server)
        server.delegates.append(subscription)
        subscriber.receive(subscription: subscription)
}
</code></pre>

<p>What do you think about this implementation? to me it seems quite clunky, but I really don't know how to bridge the events from the Server Manager to Subscribers. </p>
","499990","","","","","2022-06-21 14:32:10","Swift Combine Subscriptions, right flow and architectural choices","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"59365370","1","59417496","","2019-12-16 22:53:49","","0","597","<p>I'm trying to flip the answer to this question on it's head:</p>

<p><a href=""https://stackoverflow.com/questions/58240070/whats-the-idiomatic-way-to-control-a-nested-uiview-in-swiftui"">What&#39;s the idiomatic way to control a nested UIView in SwiftUI</a></p>

<p>And publish the events from the child (<code>WebView</code>) and subscribe in the <code>ParentView</code>.</p>

<p>I can pass the eventSender in the constructor of the <code>WebView</code> like:</p>

<pre><code>WebView(eventSender: eventSender)
</code></pre>

<p>Then the <code>WebView</code> should be able to send events but how to I subscribe to the published events in the <code>ParentView</code>?</p>

<p>Does anyone have an elegant solution?</p>

<p>Ordinarily I would use <code>@EnvironmentObject</code> but these do not seem to work with <code>UIViewRepresentable</code>.</p>

<p>UPDATE - I've created a gist here of the issue: <a href=""https://gist.github.com/mattlaver/45519a58de65a304b10acaee663b06a2"" rel=""nofollow noreferrer"">https://gist.github.com/mattlaver/45519a58de65a304b10acaee663b06a2</a></p>

<p>Note that my childView is a class, not a struct as it needs to inherit from NSObject to be able to use the navigationDelegate.</p>

<p>I want to close this view (navigate back to before it was shown when the navigationDelegate kicks in).</p>
","117859","","117859","","2019-12-18 21:40:53","2019-12-19 22:09:49","Publish a message from child to parent View","<swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"59367202","1","59386819","","2019-12-17 03:25:05","","13","6543","<p>Using the new Combine framework in iOS 13.</p>

<p>Suppose I have an upstream publisher sending values at a highly irregular rate - sometimes seconds or minutes may go by without any values, and then a stream of values may come through all at once. I'd like to create a custom publisher that subscribes to the upstream values, buffers them and emits them at a regular, known cadence when they come in, but publishes nothing if they've all been exhausted.</p>

<p><strong>For a concrete example:</strong></p>

<ul>
<li>t = 0 to 5000ms: no upstream values published</li>
<li>t = 5001ms: upstream publishes ""a""</li>
<li>t = 5002ms: upstream publishes ""b""</li>
<li>t = 5003ms: upstream publishes ""c""</li>
<li>t = 5004ms to 10000ms: no upstream values published</li>
<li>t = 10001ms: upstream publishes ""d""</li>
</ul>

<p><strong>My publisher subscribed to the upstream would produce values every 1 second:</strong></p>

<ul>
<li>t = 0 to 5000ms: no values published</li>
<li>t = 5001ms: publishes ""a""</li>
<li>t = 6001ms: publishes ""b""</li>
<li>t = 7001ms: publishes ""c""</li>
<li>t = 7001ms to 10001ms: no values published</li>
<li>t = 10001ms: publishes ""d""</li>
</ul>

<p>None of the existing publishers or operators in Combine seem to <em>quite</em> do what I want here. </p>

<ul>
<li><a href=""https://developer.apple.com/documentation/combine/publisher/3204760-throttle"" rel=""noreferrer""><code>throttle</code></a> and <a href=""https://developer.apple.com/documentation/combine/publisher/3204702-debounce"" rel=""noreferrer""><code>debounce</code></a> would simply sample the upstream values at a certain cadence and drop ones that are missing (e.g. would only publish ""a"" if the cadence was 1000ms)</li>
<li><a href=""https://developer.apple.com/documentation/combine/publisher/3204704-delay"" rel=""noreferrer""><code>delay</code></a> would add the same delay to every value, but not space them out (e.g. if my delay was 1000ms, it would publish ""a"" at 6001ms, ""b"" at 6002ms, ""c"" at 6003ms)</li>
<li><a href=""https://developer.apple.com/documentation/combine/publisher/3235802-buffer"" rel=""noreferrer""><code>buffer</code></a> seems promising, but I can't quite figure out how to use it - how to force it to publish a value from the buffer on demand. When I hooked up a sink to <code>buffer</code> it seemed to just instantly publish all the values, not buffering at all.</li>
</ul>

<p>I thought about using some sort of combining operator like <code>zip</code> or <code>merge</code> or <code>combineLatest</code> and combining it with a Timer publisher, and that's probably the right approach, but I can't figure out exactly how to configure it to give the behavior I want.</p>

<p><strong>Edit</strong></p>

<p>Here's a marble diagram that hopefully illustrates what I'm going for:</p>

<pre><code>Upstream Publisher:
-A-B-C-------------------D-E-F--------|&gt;

My Custom Operator:
-A----B----C-------------D----E----F--|&gt;
</code></pre>

<p><strong>Edit 2: Unit Test</strong></p>

<p>Here's a unit test that should pass if <code>modulatedPublisher</code> (my desired buffered publisher) works as desired. It's not perfect, but it stores events (including the time received) as they're received and then compares the time intervals between events, ensuring they are no smaller than the desired interval.</p>

<pre><code>func testCustomPublisher() {
    let expectation = XCTestExpectation(description: ""async"")
    var events = [Event]()

    let passthroughSubject = PassthroughSubject&lt;Int, Never&gt;()
    let cancellable = passthroughSubject
        .modulatedPublisher(interval: 1.0)
        .sink { value in
            events.append(Event(value: value, date: Date()))
            print(""value received: \(value) at \(self.dateFormatter.string(from:Date()))"")
        }

    // WHEN I send 3 events, wait 6 seconds, and send 3 more events
    passthroughSubject.send(1)
    passthroughSubject.send(2)
    passthroughSubject.send(3)

    DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(6000)) {
        passthroughSubject.send(4)
        passthroughSubject.send(5)
        passthroughSubject.send(6)

        DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(4000)) {

            // THEN I expect the stored events to be no closer together in time than the interval of 1.0s
            for i in 1 ..&lt; events.count {
                let interval = events[i].date.timeIntervalSince(events[i-1].date)
                print(""Interval: \(interval)"")

                // There's some small error in the interval but it should be about 1 second since I'm using a 1s modulated publisher.
                XCTAssertTrue(interval &gt; 0.99)
            }
            expectation.fulfill()
        }
    }

    wait(for: [expectation], timeout: 15)
}
</code></pre>

<p>The closest I've gotten is using <code>zip</code>, like so:</p>

<pre><code>public extension Publisher where Self.Failure == Never {
    func modulatedPublisher(interval: TimeInterval) -&gt; AnyPublisher&lt;Output, Never&gt; {
        let timerBuffer = Timer
        .publish(every: interval, on: .main, in: .common)
        .autoconnect()

      return timerBuffer
        .zip(self, { $1 })                  // should emit one input element ($1) every timer tick
        .eraseToAnyPublisher()
    }
}
</code></pre>

<p>This properly attunes the first three events (1, 2, and 3), but not the second three (4, 5, and 6). The output:</p>

<pre><code>value received: 1 at 3:54:07.0007
value received: 2 at 3:54:08.0008
value received: 3 at 3:54:09.0009
value received: 4 at 3:54:12.0012
value received: 5 at 3:54:12.0012
value received: 6 at 3:54:12.0012
</code></pre>

<p>I believe this is happening because <code>zip</code> has some internal buffering capacity. The first three upstream events are buffered and emitted on the Timer's cadence, but during the 6 second wait, the Timer's events are buffered - and when the second set ups upstream events are fired, there are already Timer events waiting in the queue, so they're paired up and fired off immediately.</p>
","1722048","","1722048","","2019-12-17 21:12:00","2020-07-20 21:02:21","Swift Combine: Buffer upstream values and emit them at a steady rate?","<ios><swift><combine>","4","5","8","","","CC BY-SA 4.0"
"59383862","1","59385541","","2019-12-18 00:11:47","","4","905","<h2>Xcode 11.3, Swift 5.1.3</h2>

<p>I am trying currently to create a custom property wrapper that allows me to link variables to a Firebase database. When doing this, to make it update the view, I at first tried to use the <code>@ObservedObject @Bar var foo = []</code>. But I get an error that multiple property wrappers are not supported. Next thing I tried to do, which would honestly be ideal, was try to make my custom property wrapper update the view itself upon being changed, just like <code>@State</code> and <code>@ObservedObject</code>. This both avoids needing to go down two layers to access the underlying values and avoid the use of nesting property wrappers. To do this, I checked the SwiftUI documentation and found out that they both implement the <code>DynamicProperty</code> protocol. I tried to use this too but failed because I need to be able to update the view (call <code>update()</code>) from within my Firebase database observers, which I cannot do since <code>.update()</code> is mutating. </p>

<p>Here is my current attempt at this:</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Firebase
import CodableFirebase
import Combine 

@propertyWrapper
final class DatabaseBackedArray&lt;Element&gt;: ObservableObject where Element: Codable &amp; Identifiable {
    typealias ObserverHandle = UInt
    typealias Action = RealtimeDatabase.Action
    typealias Event = RealtimeDatabase.Event

    private(set) var reference: DatabaseReference

    private var currentValue: [Element]

    private var childAddedObserverHandle: ObserverHandle?
    private var childChangedObserverHandle: ObserverHandle?
    private var childRemovedObserverHandle: ObserverHandle?

    private var childAddedActions: [Action&lt;[Element]&gt;] = []
    private var childChangedActions: [Action&lt;[Element]&gt;] = []
    private var childRemovedActions: [Action&lt;[Element]&gt;] = []

    init(wrappedValue: [Element], _ path: KeyPath&lt;RealtimeDatabase, RealtimeDatabase&gt;, events: Event = .all,
         actions: [Action&lt;[Element]&gt;] = []) {
        currentValue = wrappedValue
        reference = RealtimeDatabase()[keyPath: path].reference

        for action in actions {
            if action.event.contains(.childAdded) {
                childAddedActions.append(action)
            }
            if action.event.contains(.childChanged) {
                childChangedActions.append(action)
            }
            if action.event.contains(.childRemoved) {
                childRemovedActions.append(action)
            }
        }

        if events.contains(.childAdded) {
            childAddedObserverHandle = reference.observe(.childAdded) { snapshot in
                guard let value = snapshot.value, let decodedValue = try? FirebaseDecoder().decode(Element.self, from: value) else {
                    fatalError(""Could not decode value from Firebase."")
                }
                self.objectWillChange.send()
                self.currentValue.append(decodedValue)
                self.childAddedActions.forEach { $0.action(&amp;self.currentValue) }
            }
        }
        if events.contains(.childChanged) {
            childChangedObserverHandle = reference.observe(.childChanged) { snapshot in
                guard let value = snapshot.value, let decodedValue = try? FirebaseDecoder().decode(Element.self, from: value) else {
                    fatalError(""Could not decode value from Firebase."")
                }
                guard let changeIndex = self.currentValue.firstIndex(where: { $0.id == decodedValue.id }) else {
                    return
                }
                self.objectWillChange.send()
                self.currentValue[changeIndex] = decodedValue
                self.childChangedActions.forEach { $0.action(&amp;self.currentValue) }
            }
        }
        if events.contains(.childRemoved) {
            childRemovedObserverHandle = reference.observe(.childRemoved) { snapshot in
                guard let value = snapshot.value, let decodedValue = try? FirebaseDecoder().decode(Element.self, from: value) else {
                    fatalError(""Could not decode value from Firebase."")
                }
                self.objectWillChange.send()
                self.currentValue.removeAll { $0.id == decodedValue.id }
                self.childRemovedActions.forEach { $0.action(&amp;self.currentValue) }
            }
        }
    }

    private func setValue(to value: [Element]) {
        guard let encodedValue = try? FirebaseEncoder().encode(currentValue) else {
            fatalError(""Could not encode value to Firebase."")
        }
        reference.setValue(encodedValue)
    }

    var wrappedValue: [Element] {
        get {
            return currentValue
        }
        set {
            self.objectWillChange.send()
            setValue(to: newValue)
        }
    }

    var projectedValue: Binding&lt;[Element]&gt; {
        return Binding(get: {
            return self.wrappedValue
        }) { newValue in
            self.wrappedValue = newValue
        }
    }

    var hasActiveObserver: Bool {
        return childAddedObserverHandle != nil || childChangedObserverHandle != nil || childRemovedObserverHandle != nil
    }
    var hasChildAddedObserver: Bool {
        return childAddedObserverHandle != nil
    }
    var hasChildChangedObserver: Bool {
        return childChangedObserverHandle != nil
    }
    var hasChildRemovedObserver: Bool {
        return childRemovedObserverHandle != nil
    }

    func connectObservers(for event: Event) {
        if event.contains(.childAdded) &amp;&amp; childAddedObserverHandle == nil {
            childAddedObserverHandle = reference.observe(.childAdded) { snapshot in
                guard let value = snapshot.value, let decodedValue = try? FirebaseDecoder().decode(Element.self, from: value) else {
                    fatalError(""Could not decode value from Firebase."")
                }
                self.objectWillChange.send()
                self.currentValue.append(decodedValue)
                self.childAddedActions.forEach { $0.action(&amp;self.currentValue) }
            }
        }
        if event.contains(.childChanged) &amp;&amp; childChangedObserverHandle == nil {
            childChangedObserverHandle = reference.observe(.childChanged) { snapshot in
                guard let value = snapshot.value, let decodedValue = try? FirebaseDecoder().decode(Element.self, from: value) else {
                    fatalError(""Could not decode value from Firebase."")
                }
                guard let changeIndex = self.currentValue.firstIndex(where: { $0.id == decodedValue.id }) else {
                    return
                }
                self.objectWillChange.send()
                self.currentValue[changeIndex] = decodedValue
                self.childChangedActions.forEach { $0.action(&amp;self.currentValue) }
            }
        }
        if event.contains(.childRemoved) &amp;&amp; childRemovedObserverHandle == nil {
            childRemovedObserverHandle = reference.observe(.childRemoved) { snapshot in
                guard let value = snapshot.value, let decodedValue = try? FirebaseDecoder().decode(Element.self, from: value) else {
                    fatalError(""Could not decode value from Firebase."")
                }
                self.objectWillChange.send()
                self.currentValue.removeAll { $0.id == decodedValue.id }
                self.childRemovedActions.forEach { $0.action(&amp;self.currentValue) }                
            }
        }
    }

    func removeObserver(for event: Event) {
        if event.contains(.childAdded), let handle = childAddedObserverHandle {
            reference.removeObserver(withHandle: handle)
            self.childAddedObserverHandle = nil
        }
        if event.contains(.childChanged), let handle = childChangedObserverHandle {
            reference.removeObserver(withHandle: handle)
            self.childChangedObserverHandle = nil
        }
        if event.contains(.childRemoved), let handle = childRemovedObserverHandle {
            reference.removeObserver(withHandle: handle)
            self.childRemovedObserverHandle = nil
        }
    }
    func removeAction(_ action: Action&lt;[Element]&gt;) {
        if action.event.contains(.childAdded) {
            childAddedActions.removeAll { $0.id == action.id }
        }
        if action.event.contains(.childChanged) {
            childChangedActions.removeAll { $0.id == action.id }
        }
        if action.event.contains(.childRemoved) {
            childRemovedActions.removeAll { $0.id == action.id }
        }
    }

    func removeAllActions(for event: Event) {
        if event.contains(.childAdded) {
            childAddedActions = []
        }
        if event.contains(.childChanged) {
            childChangedActions = []
        }
        if event.contains(.childRemoved) {
            childRemovedActions = []
        }
    }
}

struct School: Codable, Identifiable {
    /// The unique id of the school.
    var id: String

    /// The name of the school.
    var name: String

    /// The city of the school.
    var city: String

    /// The province of the school.
    var province: String

    /// Email domains for student emails from the school.
    var domains: [String]
}

@dynamicMemberLookup
struct RealtimeDatabase {
    private var path: [String]

    var reference: DatabaseReference {
        var ref = Database.database().reference()
        for component in path {
            ref = ref.child(component)
        }
        return ref
    }

    init(previous: Self? = nil, child: String? = nil) {
        if let previous = previous {
            path = previous.path
        } else {
            path = []
        }
        if let child = child {
            path.append(child)
        }
    }

    static subscript(dynamicMember member: String) -&gt; Self {
        return Self(child: member)
    }

    subscript(dynamicMember member: String) -&gt; Self {
        return Self(child: member)
    }

    static subscript(dynamicMember keyPath: KeyPath&lt;Self, Self&gt;) -&gt; Self {
        return Self()[keyPath: keyPath]
    }

    static let reference = Database.database().reference()

    struct Event: OptionSet, Hashable {
        let rawValue: UInt
        static let childAdded = Event(rawValue: 1 &lt;&lt; 0)
        static let childChanged = Event(rawValue: 1 &lt;&lt; 1)
        static let childRemoved = Event(rawValue: 1 &lt;&lt; 2)

        static let all: Event = [.childAdded, .childChanged, .childRemoved]
        static let constructive: Event = [.childAdded, .childChanged]
        static let destructive: Event = .childRemoved
    }

    struct Action&lt;Value&gt;: Identifiable {

        let id = UUID()
        let event: Event
        let action: (inout Value) -&gt; Void

        private init(on event: Event, perform action: @escaping (inout Value) -&gt; Void) {
            self.event = event
            self.action = action
        }

        static func on&lt;Value&gt;(_ event: RealtimeDatabase.Event, perform action: @escaping (inout Value) -&gt; Void) -&gt; Action&lt;Value&gt; {
            return Action&lt;Value&gt;(on: event, perform: action)
        }
    }
}
</code></pre>

<p>Usage example:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {

    @DatabaseBackedArray(\.schools, events: .all, actions: [.on(.constructive) { $0.sort { $0.name &lt; $1.name } }])
    var schools: [School] = []

    var body: some View {
        Text(""School: "").bold() +
            Text(schools.isEmpty ? ""Loading..."" : schools.first!.name)
    }
}
</code></pre>

<p>When I try to use this though, the view never updates with the value from Firebase even though I am positive that the <code>.childAdded</code> observer is being called.</p>

<hr>

<p>One of my attempts at fixing this was to store all of these variables in a singleton that itself conforms to <code>ObservableObject</code>. This <em>solution</em> is also ideal as it allows the variables being observed to be shared throughout my application, preventing multiples instances of the same date and allowing for a single source of truth. Unfortunately, this too did not update the view with the fetched value of <code>currentValue</code>.</p>

<pre class=""lang-swift prettyprint-override""><code>class Session: ObservableObject {

    @DatabaseBackedArray(\.schools, events: .all, actions: [.on(.constructive) { $0.sort { $0.name &lt; $1.name } }])
    var schools: [School] = []

    private init() {
        //Send `objectWillChange` when `schools` property changes
        _schools.objectWillChange.sink {
            self.objectWillChange.send()
        }
    }

    static let current = Session()

}


struct ContentView: View {

    @ObservedObject
    var session = Session.current

    var body: some View {
        Text(""School: "").bold() +
            Text(session.schools.isEmpty ? ""Loading..."" : session.schools.first!.name)
    }
}
</code></pre>

<hr>

<p>Is there any way to make a custom property wrapper that also updates a view in SwiftUI?</p>
","9272855","","9272855","","2019-12-18 04:31:04","2021-05-09 02:51:13","Custom Property Wrapper that Updates View Swift","<swift><firebase><firebase-realtime-database><swiftui><property-wrapper>","2","8","1","","","CC BY-SA 4.0"
"59393618","1","59403832","","2019-12-18 13:58:25","","3","5948","<p>How can I, using SwiftUI and Combine, have a state of the uppermost View depend on a state of its contained SubView, determined by criteria among others dependent on <em>its</em> contained SubSubView?</p>

<hr>

<h2>The scenario</h2>

<p>I have the following View hierarchy: V1 contains V2, which contains V3.</p>

<ol>
<li><p>V1 is a general, mostly decorative, 'wrapper' of a specific settings view V2 and holds a ""Save"" button. The button's disabled state of type <code>Bool</code> should depend on the save-ability state of V2.</p></li>
<li><p>V2 is a specific settings view. <em>Which</em> type of V2, the specific settings shown, may differ depending on the rest of my program. It is guaranteed to be able to determine its save-ability. It contains a Toggle and V3, a MusicPicker. V2's save-ability is dependent on criteria processing V3's selection-state and its Toggle-state.</p></li>
<li><p>V3 is a general 'MusicPicker' view with a selection-state of type <code>Int?</code>. It could be used with any parent, communicating bidirectionally its selection-state.</p></li>
</ol>

<p>A <code>Binding</code> should normally be used to communicate back and forth between 2 views. As such, there could be a binding between V1 and V2 and V2 and V3. However, V2 cannot/should not react to a binding's value change of V3 and communicate this (along with other criteria) back to V1, as far as I know/understand. I may use <code>ObservableObject</code>s to share a save-ability with V1 and V2 and to share a selection-state with V2 and V3, but it is unclear to me how to integrate V3's ObservableObject changes with other criteria to set V1's ObservableObject.</p>

<h2>The examples</h2>

<h3>Using <code>@State</code> and <code>@Binding</code></h3>

<pre><code>/* V1 */
struct SettingsView: View {
    @State var saveable = false

    var body: some View {
        VStack {
            Button(action: saveAction){
                Text(""Save"")
            }.disabled(!saveable)
            getSpecificV2(saveable: $saveable)
        }
    }

    func getSpecificV2(saveable: Binding&lt;Bool&gt;) -&gt; AnyView {
        // [Determining logic...]
        return AnyView(SpecificSettingsView(saveable: saveable))
    }

    func saveAction(){
        // More code...
    }
}

/* V2 */
struct SpecificSettingsView: View {
    @Binding var saveable: Bool

    @State var toggled = false
    @State var selectedValue: Int?

    var body: some View {
        Form {
            Toggle(""Toggle me"", isOn: $toggled)
            CustomPicker(selected: $selectedValue)
        }
    }

    func someCriteriaProcess() -&gt; Bool {
        if let selected = selectedValue {
            return (selected == 5)
        } else {
            return toggled
        }
    }
}

/* V3 */
struct CustomPicker: View {
    @Binding var selected: Int?

    var body: some View {
        List {
            Text(""None"")
                .onTapGesture {
                    self.selected = nil
            }.foregroundColor(selected == nil ? .blue : .primary)
            Text(""One"")
                .onTapGesture {
                    self.selected = 1
            }.foregroundColor(selected == 1 ? .blue : .primary)
            Text(""Two"")
                .onTapGesture {
                    self.selected = 2
            }.foregroundColor(selected == 2 ? .blue : .primary)
        }
    }
}
</code></pre>

<p>In this example code, I would need to essentially have <code>saveable</code> be dependent on <code>someCriteriaProcess()</code>.</p>

<h3>Using <code>ObservableObject</code></h3>

<p>In response to Tobias' answer, a possible alternative would be to use <code>ObservableObject</code>s.</p>

<pre><code>/* V1 */
class SettingsStore: ObservableObject {
  @Published var saveable = false
}

struct SettingsView: View {
    @ObservedObject var store = SettingsStore()

    var body: some View {
        VStack {
            Button(action: saveAction){
                Text(""Save"")
            }.disabled(!store.saveable)
            getSpecificV2()
        }.environmentObject(store)
    }

    func getSpecificV2() -&gt; AnyView {
        // [Determining logic...]
        return AnyView(SpecificSettingsView())
    }

    func saveAction(){
        // More code...
    }
}

/* V2 */
struct SpecificSettingsView: View {
    @EnvironmentObject var settingsStore: SettingsStore
    @ObservedObject var pickerStore = PickerStore()

    @State var toggled = false
    @State var selectedValue: Int?

    var body: some View {
        Form {
            Toggle(""Toggle me"", isOn: $toggled)
            CustomPicker(store: pickerStore)
        }.onReceive(pickerStore.objectWillChange){ selected in
            print(""Called for selected: \(selected ?? -1)"")
            self.settingsStore.saveable = self.someCriteriaProcess()
        }
    }

    func someCriteriaProcess() -&gt; Bool {
        if let selected = selectedValue {
            return (selected == 5)
        } else {
            return toggled
        }
    }
}

/* V3 */

class PickerStore: ObservableObject {
    public let objectWillChange = PassthroughSubject&lt;Int?, Never&gt;()
    var selected: Int? {
        willSet {
            objectWillChange.send(newValue)
        }
    }
}

struct CustomPicker: View {
    @ObservedObject var store: PickerStore

    var body: some View {
        List {
            Text(""None"")
                .onTapGesture {
                    self.store.selected = nil
            }.foregroundColor(store.selected == nil ? .blue : .primary)
            Text(""One"")
                .onTapGesture {
                    self.store.selected = 1
            }.foregroundColor(store.selected == 1 ? .blue : .primary)
            Text(""Two"")
                .onTapGesture {
                    self.store.selected = 2
            }.foregroundColor(store.selected == 2 ? .blue : .primary)
        }
    }
}
</code></pre>

<p>Using the <code>onReceive()</code> attachment, I try to react to any changes of the <code>PickerStore</code>. Although the action fires and the debug prints correctly, no UI change is shown.</p>

<hr>

<h2>The question</h2>

<p>What is (in this scenario) the most appropriate approach to react to a change in V3, process this with other states in V2, and correspondingly change a state of V1, using SwiftUI and Combine?</p>
","2204668","","2204668","","2019-12-18 17:53:50","2019-12-19 05:40:49","How to use SwiftUI and Combine to propagate state changes of child View to parent View?","<swift><swiftui><combine>","3","0","3","","","CC BY-SA 4.0"
"59415161","1","59415264","","2019-12-19 18:30:23","","0","129","<p>For context, I am using swift &amp; MVVM architecture to manage a list of data, and a table view that displays it. Reactive patterns (RxSwift or Combine) work well for letting me reload my entire table view when the view model's list data changes. </p>

<p>ViewModel (using RxSwift):</p>

<pre><code>var tableData = BehaviorRelay&lt;[String]&gt;(value: [""First Item"", ""Second Item""])
</code></pre>

<p>ViewController:</p>

<pre><code>var tableView = UITableView()
var disposeBag = DisposeBag()
var viewModel = ViewModel()

init() {
    ...
    viewModel.tableData.subscribe(onNext: { _ in 
       self.tableView.reloadData()
    }).disposed(by: disposeBag)
}
</code></pre>

<p>But what if only one item has been inserted or deleted from <code>tableData</code>? In this case, I don't want to call <code>tableView.reloadData()</code>, instead I'd like to use <code>tableView.insertRows(at: &lt;[IndexPath]&gt;, with: &lt;UITableView.RowAnimation&gt;)</code> or <code>tableView.deleteRows(at: &lt;[IndexPath]&gt;, with: &lt;UITableView.RowAnimation&gt;)</code>. In order to do this, I need to be able to subscribe to the index paths that have been inserted or removed, instead of the list data as a whole. Does any one know what the most efficient way to do this? </p>
","3707524","","","","","2019-12-19 18:39:32","How to use reactive programming to subscribe to single-item changes (insertions or deletions) in an array of data?","<ios><swift><reactive-programming><rx-swift><combine>","1","0","","","","CC BY-SA 4.0"
"59428026","1","59430629","","2019-12-20 15:52:45","","17","9218","<p>I was using PromiseKit successfully in a project until Xcode 11 betas broke PK v7. In an effort to reduce external dependencies, I decided to scrap PromiseKit. The best replacement for handling chained async code seemed to be Futures using the new Combine framework.</p>
<p>I am struggling to replicate the simple PK syntax using Combine</p>
<p><strong>ex. simple PromiseKit chained async call syntax</strong></p>
<pre class=""lang-swift prettyprint-override""><code>getAccessCodeFromSyncProvider.then{accessCode in startSync(accessCode)}.then{popToRootViewController}.catch{handleError(error)}
</code></pre>
<blockquote>
<p>I understand:</p>
<blockquote>
<p>A Swift standard library implementation of async/await would solve this problem (<em>async/await does not yet exist, despite lots of chatter and involvement from <a href=""https://gist.github.com/lattner/429b9070918248274f25b714dcfc7619"" rel=""noreferrer"">Chris Latter himself</a></em>)</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>I could replicate using Semaphores (<em>error-prone?</em>)</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>flatMap can be used to chain Futures</p>
</blockquote>
</blockquote>
<p>The async code I'd like should be able to be called on demand, since it's involved with ensuring user is logged in. I'm wrestling with two conceptual problems.</p>
<ol>
<li><p>If I wrap Futures in a method, with <code>sink</code> to handle result, it seems that the method goes out of scope before subscriber is called by <code>sink</code>.</p>
</li>
<li><p>Since Futures execute only once, I worry that if I call the method multiple times I'll only get the old, stale, result from the first call. To work around this, maybe I would use a PassthroughSubject? This allows the Publisher to be called on demand.</p>
</li>
</ol>
<p>Questions:</p>
<ol>
<li>Do I have to retain every publisher and subscriber outside of the
calling method</li>
<li>How can I replicate simple chained async using the Swift standard library and then embed this in a swift instance method I can call on-demand to restart the chained async calls from the top??</li>
</ol>
<pre class=""lang-swift prettyprint-override""><code>//how is this done using Combine?
func startSync() {
 getAccessCodeFromSyncProvider.then{accessCode in startSync(accessCode)}.catch{\\handle error here}
}
</code></pre>
","4705368","","4705368","","2020-06-30 11:26:32","2021-05-02 18:10:01","How to replicate PromiseKit-style chained async flow using Combine + Swift","<swift><asynchronous><combine>","4","3","7","","","CC BY-SA 4.0"
"59431603","1","59434642","","2019-12-20 21:39:10","","2","200","<p>I created a button under <code>navigationBarItems</code>, and this button opens a new <code>sheet</code>, and the new sheet will pop up a window to ask user locations. However, in the new sheet, CLLocationManager() has been called twice, and location permission pop up window will disappear in a few seconds. When you create a regular button, the location pop up windown will be stay there until you select one of the options, and CLLocationManager() will only be called one time.</p>

<h2>Code</h2>

<p><strong>ConentView.swift</strong></p>

<pre><code>import SwiftUI

struct ContentView: View {


    @State var show = false
    @State var showEditPage = false

    var body: some View {


        NavigationView {
            List {
                Text(""Text"")
                Button(""Location button"") {
                    print(""Location button tapped"")
                    self.show.toggle()
                }.sheet(isPresented: $show) {
                    NewPage()
                }
            }
            .navigationBarItems(

                trailing:
                VStack {

                    Button(action: {
                        print(""BarItemButton tapped"")
                        self.showEditPage.toggle()
                    }) {
                        //Top right icon
                        Text(""BarItemButton"")
                    }.sheet(isPresented: $showEditPage) {
                        //Open sheet page
                        NewPage()
                    }

                }//End of trailing VStack
            )

        }

    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>

<p><strong>NewPage.swift</strong></p>

<pre><code>import SwiftUI

struct NewPage: View {

    @ObservedObject var locationManager = LocationManager()

    var body: some View {

        Text(""New Page"")


    }
}

struct NewPage_Previews: PreviewProvider {
    static var previews: some View {
        NewPage()
    }
}
</code></pre>

<p><strong>LocationManager.swift</strong></p>

<pre><code>import SwiftUI
import Foundation
import CoreLocation
import Combine

class LocationManager: NSObject, ObservableObject {

    private let locationManager = CLLocationManager()
    let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()

    override init() {
        super.init()
        self.locationManager.delegate = self
        self.locationManager.desiredAccuracy = kCLLocationAccuracyBest

        self.locationManager.requestWhenInUseAuthorization()
        self.locationManager.startUpdatingLocation()

        print(""In LocationManger.swift @initi, this is called"")
    }

    @Published var locationStatus: CLAuthorizationStatus? {
        willSet {
            objectWillChange.send()
        }
    }

    @Published var lastLocation: CLLocation? {
        willSet { objectWillChange.send() }
    }

}

extension LocationManager: CLLocationManagerDelegate {

    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        self.locationStatus = status

        print(""In LocationManger.swift @Func locationManager, Status is updaing"")

    }

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        self.lastLocation = location
        print(""Location is updating"")

    }

}
</code></pre>

<h2>GitHub</h2>

<p>You can feel free to download the project to try it on your laptop to see the issue:
<a href=""https://github.com/skysf/SwiftUI-navigationBarItems-issue"" rel=""nofollow noreferrer"">Github Example Project</a></p>

<h2>Screenshot</h2>

<p><a href=""https://i.stack.imgur.com/EFyU8.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/EFyU8.png"" alt=""enter image description here""></a></p>
","9500769","","9500769","","2019-12-20 23:09:40","2019-12-21 08:23:05","SwfitUI navigationBarItems calls location permission twice","<swift><xcode><navigation><uinavigationbar><swiftui>","1","2","","","","CC BY-SA 4.0"
"59442379","1","59516582","","2019-12-22 07:24:22","","0","82","<p>I am stuck with this issue and tried various ways but no luck. Below code used to work few days back. However, its not working now. I tried with the Xcode version 11.1 and works like charm. Can someone let me know what could be the reason or a workaround?</p>

<p>Issue is whenever I typed in a key, it does not fire the corresponding method using the dispatchqueue.</p>

<p>Current Swift version: 11.3</p>

<pre><code>Code snippet:

 init(
    weatherFetcher: WeatherFetchable,
    scheduler: DispatchQueue = DispatchQueue(label: ""WeatherViewModel"")
  ) {
    self.weatherFetcher = weatherFetcher
    _ = $city
      .dropFirst(1)
      .debounce(for: .seconds(0.5), scheduler: DispatchQueue.global())
      .sink(receiveValue: fetchWeather(forCity:))
  }
</code></pre>

<p>Reference code:
<a href=""https://www.raywenderlich.com/4161005-mvvm-with-combine-tutorial-for-ios"" rel=""nofollow noreferrer"">https://www.raywenderlich.com/4161005-mvvm-with-combine-tutorial-for-ios</a></p>
","1007451","","1007451","","2019-12-22 23:05:38","2019-12-29 03:08:01","Issue with the DispatchQueue not working in Swift","<ios><swift><xcode><combine>","1","0","","","","CC BY-SA 4.0"
"59446365","1","59505799","","2019-12-22 17:11:26","","0","161","<p>I'm quite new to <code>Combine</code> and, instead of running all my tasks into the <code>viewModel</code>, I'm trying to better isolate the code that has to do with business logic.  </p>

<p>Let's take a <code>SignIn</code> service as example. The service receives <code>username</code> and <code>password</code> and return <code>token</code> and <code>userID</code>. </p>

<p>The exposed call of the service is <code>signIn</code> that internally calls a private func <code>networkCall</code>. I'd like to implement the two functions to return a <code>Publisher</code>. 
The role of <code>networkCall</code> should be calling the API and storing the received token, while the role of <code>signIn</code> is only to return a success or a failure. </p>

<p>This is my code, where I'm also highlighting where I'm getting stuck.
In general I don't know where is the right place to work with the information received from the API (and store the token). At the moment I'm doing it inside a <code>.map</code> call but it sounds wrong to me. Could you share some advice to improve this logic and especially explain which is the right place to run the business logic... I'm supposing that <code>.map</code> is not the right place! and <code>.sink</code> will just stop the chain.</p>

<pre><code>struct SignInResponse:Codable{
    var token:String
    var userID:String
}

class SignInService {

    // Perform the API call
    private func networkCall(with request:SignInRequest)-&gt;AnyPublisher&lt;SignInResponse, ServiceError&gt;{
        return URLSession.DataTaskPublisher(request: request, session: .shared)
        .decode(type: SignInResponse.self, decoder: JSONDecoder())
        .mapError{error in return ServiceError.error}
        .eraseToAnyPublisher()
    }

    func signIn(username:String, password:String)-&gt;AnyPublisher&lt;Result&lt;String, ServiceError&gt;, Never&gt;{
        let request = SignInRequest(with username:username, password:password)

        return networkCall(with: request)
            .map{ (response) -&gt; Result&lt;String, ServiceError&gt; in

                if response.token != """"{
                    // THIS SOUNDS EXTREMELLY WRONG. I SHOULD NOT USE MAP TO HANDLE THE TOKEN -------
                    self.storage.save(key: ""token"", value: response.token)
                    return Result.success(response.userID)
                }else{
                    return Result.failure(ServiceError.unknown)
                }
            }
            .replaceError(with: Result.failure(ServiceError.unknown))
            .eraseToAnyPublisher()
    }
    ...... 
}
</code></pre>

<p>From the model I call SignIn in this way: </p>

<pre><code>func requestsSignIn(){

    if let username = username, let password = password{
        cancellable = service.signIn(username: username, password: password)
            .sink(receiveValue: { (result) in
                switch result{
                case .failure(let error):
                    self.errorMessage = error.localizedDescription
                case .success(let userID):
                    // the sigin succeeded do something here

                }
            })
    }
}
</code></pre>
","499990","","","","","2019-12-28 02:56:18","Consecutive Combine Publishers. Isolating business logic in a Simple Sign In flow example","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"59452113","1","59452575","","2019-12-23 08:24:45","","1","415","<p>I made a &quot;State&quot; Object for my App in EnvironmentObject
Like this:</p>
<pre><code>class AppState: ObservableObject {
    @Published var counter = Counter()
}
</code></pre>
<p>To add this to my App I use:</p>
<pre><code>window.rootViewController = UIHostingController(rootView: contentView.environmentObject(state))
</code></pre>
<p>The counter is a background task</p>
<pre><code>class Counter: ObservableObject {
    
    @Published var amount: Double
    
    var timer = Timer()
    
    init() {
        self.amount = 0.0
        self.timer = Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(setCoords), userInfo: nil, repeats: true)
    }
    
    @objc private func setCoords() {
        DispatchQueue.main.async() { () -&gt; Void in
            self.amount = self.amount + 0.1
            print(self.amount)
        }
    }  
}
</code></pre>
<p>And in my View I have:</p>
<pre><code>struct ContentView: View {

    @EnvironmentObject var state: AppState
    @State var isVisible = true
    
    var body: some View {
        VStack {
            Button(action: {
                self.isVisible.toggle()
            }) {
               Text(&quot;Button&quot;)
            }
            if isVisible {
                Text(state.counter.amount.description)
            }
        }
    }
}
</code></pre>
<p>So basically, what I was hoping was that I see the counter in my UI update after every second. But the UI does not update. I see the print statement fire every second and if I trigger the UI update from the UI Button <code>self.isVisible.toggle()</code> then the counter will also update.</p>
<p>How could I solve this problem without moving the counter into the View or implementing it in the state object?</p>
","4129110","","13302","","2021-07-11 12:54:55","2021-07-11 12:55:03","Publisher inside a Publisher does not trigger SwiftUi re-render","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"59455385","1","59455515","","2019-12-23 12:27:21","","5","2142","<p>I'm using sink method to call function when variable value changed.
Code working on iOS 13.2.2 but not on iOS 13.3. Function segmentedChanged not called when segmentedSelected variable changed.</p>

<pre><code>public class ChooseViewModel: ObservableObject {

    @Published var segmentedSelected = Int()


    init() {
        _ = $segmentedSelected
                .debounce(for: .seconds(0.1), scheduler: DispatchQueue.main)
                .sink(receiveValue: self.segmentedChanged(indexValue:))

    }

    func segmentedChanged(indexValue segIndex: Int) {
      print(segIndex)
    }

}
</code></pre>
","9515003","","","","","2019-12-23 12:37:27",".sink method from Combine not working on iOS 13.3","<ios><xcode><swiftui><combine><ios13.3>","1","0","1","","","CC BY-SA 4.0"
"59456502","1","59458194","","2019-12-23 13:51:32","","0","769","<p>I can't understand why in this code, if I call <code>send</code> on the <code>subject</code> after the subject has been subscribed to <code>publisher</code>, it seems that the events are not received by the <code>subscriber</code>. </p>

<p>While if I move the <code>send</code> calls before the <code>subscribe</code> function all the items are listed (10,20,1,2,3) </p>

<pre><code>    let publisher = [1,2,3].publisher
    let subject = PassthroughSubject&lt;Int, Never&gt;()
    let subscriber = subject.sink { print(""value :\($0)"")}

    publisher.subscribe(subject)
    subject.send(10)
    subject.send(30)
</code></pre>

<p>This prints </p>

<pre><code>value: 1
value: 2
value: 3
</code></pre>

<p>while this:</p>

<pre><code>    let publisher = [1,2,3].publisher
    let subject = PassthroughSubject&lt;Int, Never&gt;()
    let subscriber = subject.sink { print(""value :\($0)"")}

    subject.send(10)
    subject.send(30)           
    publisher.subscribe(subject)
</code></pre>

<p>prints </p>

<pre><code>value: 10
value: 30
value: 1
value: 2
value: 3
</code></pre>
","499990","","","","","2019-12-23 16:06:13","Combine subscribe and send from subject, why does order matter?","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"59461539","1","59475444","","2019-12-23 21:34:29","","4","2216","<p>I'm trying to handle the responses that arrive from a <code>DataTaskPublisher</code> reading its response status code. </p>

<p>When status code is greater than 299, I'd like to return a <code>ServiceError</code> type as Failure. In every examples that I've seen I've used <code>.mapError</code> and <code>.catch</code>... in this specific case, from a <code>.flatMap</code>, I really don't know how to handle the publisher response to return the Error instead of the <code>TResponse</code>...</p>

<pre><code>    return URLSession.DataTaskPublisher(request: urlRequest, session: .shared)
        .mapError{error in return ServiceError.request}
        .flatMap{ data, response -&gt; AnyPublisher&lt;TResponse, ServiceError&gt; in

            if let httpResponse = response as? HTTPURLResponse,
                (200...299).contains(httpResponse.statusCode){

                return Just(data)
                    .decode(type: TResponse.self, decoder: JSONDecoder())
                    .mapError{error in return ServiceError.decode}
                    .eraseToAnyPublisher()
            }else{
                //???? HOW TO HANDLE THE ERROR?
            }
        }
        .receive(on: RunLoop.main)
        .eraseToAnyPublisher()
</code></pre>
","499990","","","","","2021-09-24 20:25:59","handling HTTP status code with URLSession and Combine","<swift><urlsession><combine>","3","0","","","","CC BY-SA 4.0"
"59464845","1","59468903","","2019-12-24 06:41:41","","2","1802","<p>My View doesn't update when I change a property in an Array in the <code>ObservableObject</code> Class. I even declared a <code>objectWillChange</code> property and called it manually but the View just updated randomly or not how i want to. I don't understand this.</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import SocketIO
import Combine

class SocketService: ObservableObject {
    static let instance = SocketService()

    let manager = SocketManager(socketURL: URL(RequestURL.base_url)!)
    let socket: SocketIOClient
//    let objectWillChange = ObservableObjectPublisher()

    @Published var allMessages: [Message] = []
//        {
//        willSet {
//            self.objectWillChange.send()
//        }
//    }
    @Published var writtenUsers: [PreviewMessage] = []
//        {
//        willSet {
//            self.objectWillChange.send()
//        }
//    }

    init() {
        socket = manager.defaultSocket
        setSocketEvents()
    }

    // This method is called
    func recieve_read_all_messages() {
        socket.on(""recieve-read-all-messages"") { (data, ack) in
            guard let arr = data as? [[String: Any]] else { return }
            guard let userID = arr[0][""userID""] as? Int else {
                print(""no userID, \(#function), line: \(#line)""); return
            }

            // self.objectWillChange.send()
            for msg in self.allMessages {
                // Here im trying to change the property in the array
                msg.content.readStatus = .read
            }
    }    
}

</code></pre>

<p>Even when i directly change this property the view doesn't update</p>

<pre class=""lang-swift prettyprint-override""><code>@EnvironmentObject private var socketService: SocketService

var body: some View {
    VStack {
         List(filteredMessages, id: \.content.uuid, rowContent: chatSpeechBubbleView)
         sendView
    }
}

private func chatSpeechBubbleView(forMessage message: Message) -&gt; some View {
        ChatSpeechBubble(message: message)
    }

private var sendView: some View {
        Button(action: sendMessage) {
            SFSymbol(.paperplane_fill)
                .fontSize(20)
                .foregroundColor(.white)
                .rotate(.degrees(45))
                .padding(10)
                .padding(.trailing, 5)
                .backgroundColor(.blue)
                .clipCircle()
        }
        .padding(.bottom, 2)
    }

    func sendMessage() {
        for msg in socketService.allMessages {            
            msg.content.readStatus = .read
        }
    }
</code></pre>

<p>My other view where it should be updated:</p>

<pre class=""lang-swift prettyprint-override""><code>struct DoubleCheckmark: View {
    var messageContent: MessageContent

    var body: some View {
        HStack(spacing: 0) {
            SFSymbol(.checkmark)
                .resizable()
                .scaledToFit()
            SFSymbol(.checkmark)
                .resizable()
                .scaledToFit()
                .padding(.leading, -9)
        }
        .height(13)
        .foregroundColor(self.messageContent.readStatus == .read ? .blue : .gray)
    }
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>struct ChatSpeechBubble: View {

    // MARK: - init variables
    var message: Message

    // MARK: - normal variables
    var ownSendMessage: Bool {
        message.fromUser.id == UDService.shared.user.id
    }

    // MARK: - Body
    var body: some View {
        messageContent
    }

    private var messageContent: some View {
        HStack(alignment: .bottom) {
            if message.content.text != nil {
                Text(message.content.text!)
                    .foregroundColor(.black)
            }
            if message.content.imageURL != nil {
                Spacer(minLength: 0)
            }
            Text(message.content.timeHourMinute)
                .font(.caption)
                .foregroundColor(.gray)

            if ownSendMessage {
                DoubleCheckmark(messageContent: self.message.content)
            }
        }
    }
}
</code></pre>
","11411002","","11411002","","2019-12-24 08:23:59","2021-11-24 12:04:07","SwiftUI View doesn't update","<ios><swift><swiftui><swift5><combine>","1","0","","","","CC BY-SA 4.0"
"59468389","1","59473283","","2019-12-24 11:50:07","","1","198","<p>I'm trying to validate user's email and password using two separate function calls. </p>

<p>Both functions return AnyPublisher publishers, and I use combineLatest to collect the returned values (each validate call returns the string it's validating) into a tuple.</p>

<p>Then I'm using flatMap to make a network request to sign the user up using the values returned by combineLatest, however the flatMap operator never gets called. </p>

<pre><code>validator.validate(text: email, with: [.validEmail])
  .combineLatest(validator.validate(text: password, with: [.notEmpty]))
  .flatMap { credentials in
    return self.userSessionRepository.signUp(email: credentials.0, password: credentials.1)
  }
  .sink(receiveCompletion: { completion in
    switch completion {
    case .failure(let error):
      print(error)
      self.indicateErrorSigningIn(error)
    case .finished:
      self.goToSignInNavigator.navigateToOtp()
    }
  }, receiveValue: { _ in })
  .store(in: &amp;subscriptions)
</code></pre>

<p>signUp(email:password:) returns AnyPublisher</p>

<p>Here's the validator function:</p>

<pre><code>public func validate(text: String, with rules: [Rule]) -&gt; AnyPublisher&lt;String, ErrorMessage&gt; {
  rules.publisher
    .compactMap { $0.check(text) }
    .setFailureType(to: ErrorMessage.self)
    .flatMap {
      Fail&lt;Void, ErrorMessage&gt;(error: ErrorMessage(title: ""Error"", message: $0.description))
    }
    .map { text }
    .eraseToAnyPublisher()
}
</code></pre>

<p>And the signUp function:</p>

<pre><code>public func signUp(email: String, password: String) -&gt; AnyPublisher&lt;Void, ErrorMessage&gt; {
  remoteAPI.signUp(email: email, password: password)
    .flatMap(dataStore.save)
    .mapError { error -&gt; ErrorMessage in
      return ErrorMessage(title: ""Error"", message: error.description)
    }
    .eraseToAnyPublisher()
}
</code></pre>

<p>It calls these two functions:</p>

<pre><code>public func signUp(email: String, password: String) -&gt; AnyPublisher&lt;Confirmation, RemoteError&gt; {
  guard email == ""john.doe@email.com"" else {
    return Fail&lt;Confirmation, RemoteError&gt;(error: .invalidCredentials)
      .eraseToAnyPublisher()
  }

  return Just(Confirmation(otp: """", nonce: ""abcd""))
    .setFailureType(to: RemoteError.self)
    .eraseToAnyPublisher()
}

public func save(confirmation: Confirmation) -&gt; AnyPublisher&lt;Void, RemoteError&gt; {
  self.nonce = confirmation.nonce

  return Empty().eraseToAnyPublisher()
}
</code></pre>

<p>I'm not sure what's wrong, though it's likely my not understanding Combine enough, as I've just started learning it recently. </p>
","","user11042303","","","","2019-12-24 20:48:35","flatMap doesn't get invoked","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"59521928","1","59522376","","2019-12-29 17:58:23","","4","2349","<p>How can I mock <code>URLSession.DataTaskPublisher</code>? I have a class <code>Proxy</code> that require to inject a <code>URLSessionProtocol</code> </p>

<pre><code>protocol URLSessionProtocol {
    func loadData(from url: URL) -&gt; URLSession.DataTaskPublisher
}
</code></pre>

<pre><code>class Proxy {

    private let urlSession: URLSessionProtocol

    init(urlSession: URLSessionProtocol) {
        self.urlSession = urlSession
    }

    func get(url: URL) -&gt; AnyPublisher&lt;Data, ProxyError&gt; {
        // Using urlSession.loadData(from: url)
    }

}

</code></pre>

<p>This code was originally used with the traditional version of <code>URLSession</code> with the completion handler. It was perfect since I could easily mock <code>URLSession</code> for testing like Sundell's solution here: <a href=""https://www.swiftbysundell.com/articles/mocking-in-swift/"" rel=""nofollow noreferrer"">Mocking in Swift</a>.</p>

<p>Is it possible to do the same with the Combine Framework? </p>
","6453483","","","","","2020-06-26 22:46:28","How to mock URLSession.DataTaskPublisher","<ios><swift><mocking><urlsession><combine>","3","0","2","","","CC BY-SA 4.0"
"59537131","1","59685330","","2019-12-30 21:40:51","","0","62","<p>I am looking for a way how to pass further data that was received in the previous <code>POST</code> request. Below is my code. 
Actual result: <code>authtoken</code> and <code>sms_id</code> become an empty <code>String</code>.
Some clarifications: The second <code>POST</code> request is called in the next screen in the sequence when the first is completed. TIA.</p>

<pre><code>import SwiftUI
import Combine

enum APIError: Error {
 case responseProblem
 case decodingProblem
 case encodingProblem
}

class NetworkService: ObservableObject {

@Published var user: UserRegisterRequest?
@Published var userRegistered: UserRegistered?

let uuid = UIDevice.current.identifierForVendor?.uuidString
let appid = ""com.website.me""
var authToken = """"
var sms_id = """"

func postPhoneValidation(_ phone: String, completion: @escaping (Result&lt;UserRegisterRequest, APIError&gt;) -&gt; Void) {

    do {
        guard let url = URL(string: APIRequests.postPhoneValidation) else { fatalError() }

        let body: [String: Any] = [""phone"" : phone]

        let finalBody = try JSONSerialization.data(withJSONObject: body)

        var request = URLRequest(url: url)
        request.httpMethod = ""POST""
        request.httpBody = finalBody

        request.setValue(uuid, forHTTPHeaderField: ""X-AUTH-Device"")
        request.setValue(appid, forHTTPHeaderField: ""X-AUTH-AppID"")

        URLSession.shared.dataTask(with: request) { data, response, _ in

            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,

                let jsondata = data else {

                completion(.failure(.responseProblem))
                return
            }

            do {
                let validatedPhoneDictionary = try JSONDecoder().decode(UserRegisterRequest.self, from: jsondata)

                self.authToken = validatedPhoneDictionary.auth_token

                self.sms_id = validatedPhoneDictionary.sms_id

                completion(.success(validatedPhoneDictionary))

                print(validatedPhoneDictionary)



            } catch {
                completion(.failure(.decodingProblem))
            }

        }
        .resume()

    } catch {
        completion(.failure(.encodingProblem))
    }
}

func postSignUp(_ otpSms: String, completion: @escaping (Result&lt;UserRegistered, APIError&gt;) -&gt; Void) {
    do {
        guard let url = URL(string: APIRequests.postSignUp) else { fatalError() }

        let body : [String: Any] = [""otpSms"" : otpSms, ""sms_id"" : self.sms_id]


        let finalBody = try! JSONSerialization.data(withJSONObject: body)

        var request = URLRequest(url: url)


        request.httpMethod = ""POST""

        request.httpBody = finalBody

        request.setValue(uuid, forHTTPHeaderField: ""X-AUTH-Device"")
        request.setValue(appid, forHTTPHeaderField: ""X-AUTH-AppID"")
        request.setValue(self.authToken, forHTTPHeaderField: ""X-AUTH-Token"")


        URLSession.shared.dataTask(with: request) { data, response, _ in

            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200,

                let jsondata = data else {

                completion(.failure(.responseProblem))
                return
            }

            do {
                let registeredUser = try JSONDecoder().decode(UserRegistered.self, from: jsondata)

                completion(.success(registeredUser))

                print(registeredUser)



            } catch {
                completion(.failure(.decodingProblem))
            }

        }
        .resume()
    }
}
}
</code></pre>
","9325884","","","","","2020-01-10 16:18:37","Passing data to the next POST request from that was fetched in the previous one [Swift / SwiftUI]","<json><swift><post>","1","2","","","","CC BY-SA 4.0"
"59552487","1","59552828","","2020-01-01 12:26:07","","11","8276","<p>I want to listen to notifications when the app goes to the background and comes back. I'm trying to use the NotificationCenter publishers and have the SwiftUI view listen to them.<br/>
I can use a few methods to do it and I'm trying to use two of them but the interesting thing is, that although all seem legit when I put the subscriber in the <code>init()</code> method, it just does not work. <br/>
I tried to put it on the <code>main</code> thread but still no success.<br/>
Does anyone have any idea why?<br/>
Here's my code:</p>

<pre><code>struct ContentView: View {
    @State var isActive = true
    @State var cancellables = Set&lt;AnyCancellable&gt;()
    var body: some View {
        ZStack {
            Image(""background"")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)                        
        }
        .onReceive(NotificationCenter.default.publisher(for: UIApplication.willResignActiveNotification)) { _ in
            self.isActive = false
        }
        .onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification), perform: {_ in
            self.isActive = true
        })
    }

    init() {
        NotificationCenter.default.publisher(for: UIApplication.willResignActiveNotification)
         //   .receive(on: RunLoop.main)
            .sink(receiveValue: { _ in
                print(""init"")
            }
            .store(in: &amp;cancellables)
    }
}
</code></pre>

<p>Strangely the listener in the <code>onReceive</code> modifier works like a charm. In the <code>init()</code> the <code>print(""init"")</code> never gets called.</p>
","5767040","","5268185","","2020-01-01 13:34:10","2020-01-16 13:16:45","SwiftUI with NotificationCenter publishers","<swiftui><combine><notificationcenter>","2","0","1","","","CC BY-SA 4.0"
"59556654","1","59556908","","2020-01-01 22:34:33","","0","171","<p>In my compass application, I display heading but the performances are not high: when I turn device quickly, all degrees are not displayed. I search the same performances that the natif compass application by Apple.
For example, when the angle pass 359 to 0 degree, I make a vibration to notif user. But sometime the vibration not appear.</p>

<p>My LocationProvider class:</p>

<pre><code>import SwiftUI
import CoreLocation
import Combine

public class LocationProvider: NSObject, CLLocationManagerDelegate, ObservableObject {

  private let locationManager: CLLocationManager
  public let heading = PassthroughSubject&lt;CGFloat, Never&gt;()

  @Published var currentHeading: CGFloat {
    willSet {
      heading.send(newValue)
    }
  }

  public override init() {
    currentHeading = 0
    locationManager = CLLocationManager()
    super.init()
    locationManager.delegate = self
    locationManager.desiredAccuracy = kCLLocationAccuracyBest
    locationManager.startUpdatingHeading()
    locationManager.requestWhenInUseAuthorization()
  }

  public func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {
    self.currentHeading = CGFloat(newHeading.trueHeading)
  }
}
</code></pre>

<p>My contentView:</p>

<pre><code>import SwiftUI
import CoreLocation

struct ContentView: View {

  @ObservedObject var location: LocationProvider = LocationProvider()

  @State var angle: CGFloat = 0

  var body: some View {
    VStack {
      Text(String(Double(-self.location.currentHeading + 360).stringWithoutZeroFraction) + ""°"")
        .font(.system(size: 80))
    }
    .onReceive(self.location.heading) { heading in
      compassTapticFeedback(-heading + 360)
    }
  }
}

public extension Double {
  var stringWithoutZeroFraction: String {
    return String(format: ""%.0f"", self)
  }
}

// Taptic feednack
func tapticFeedback(_ type: String) {
  switch type {
    case ""heavy"":
      let tapticFeedback = UIImpactFeedbackGenerator(style: .heavy)
      tapticFeedback.prepare()
      tapticFeedback.impactOccurred()
    case ""medium"":
      let tapticFeedback = UIImpactFeedbackGenerator(style: .medium)
      tapticFeedback.prepare()
      tapticFeedback.impactOccurred()
    case ""light"":
      let tapticFeedback = UIImpactFeedbackGenerator(style: .light)
      tapticFeedback.prepare()
      tapticFeedback.impactOccurred()
    default:
      let tapticFeedback = UIImpactFeedbackGenerator(style: .medium)
      tapticFeedback.prepare()
      tapticFeedback.impactOccurred()
  }
}

func compassTapticFeedback(_ angle: CGFloat) {
  switch Int(angle) {
    case 0:
      tapticFeedback(""heavy"")
    case 30:
      tapticFeedback(""heavy"")
    case 60:
      tapticFeedback(""heavy"")
    case 90:
      tapticFeedback(""heavy"")
    case 120:
      tapticFeedback(""heavy"")
    case 250:
      tapticFeedback(""heavy"")
    case 180:
      tapticFeedback(""heavy"")
    case 210:
      tapticFeedback(""heavy"")
    case 240:
      tapticFeedback(""heavy"")
    case 270:
      tapticFeedback(""heavy"")
    case 300:
      tapticFeedback(""heavy"")
    case 330:
      tapticFeedback(""heavy"")
    default:
      return
  }
}
</code></pre>

<p>May be it's because I do a lot of calculs on the angle to get a value without zero fraction? I don't know. Even if I don't sure that it the cause.</p>
","7037428","","","","","2020-01-02 00:05:06","How to display data from Observable Object with high performances in swiftUI?","<swift><swiftui><core-location>","1","0","","","","CC BY-SA 4.0"
"59563141","1","59565473","","2020-01-02 12:10:48","","1","730","<p>Im trying to create a networking layer, using <code>Combine</code> framework. I have a few functions already implemented, which are working fine. Some of these api calls are requiring an <code>access token</code>, and there are calls to obtain and refresh this token. Now the problem Im facing is that I would like the functions that require this token, to automatically try to refresh it before executing - only if it needs refreshing, or if I get an error. Right now I have functions like this:</p>

<pre><code>static func login(with parameters: CredentialsRequest) -&gt; AnyPublisher&lt;LoggedUser, RequestError&gt; 
static func refreshToken(_ token: Token) -&gt; AnyPublisher&lt;Token, RequestError&gt;
static func activeGames(token: Token) -&gt; AnyPublisher&lt;[Game], RequestError&gt;
</code></pre>

<p>Token has a property: <code>requiresRefresh: Bool</code></p>

<p>How could I make the function <code>activeGames</code> still return the type <code>AnyPublisher&lt;[Game], RequestError&gt;</code>, but work in such a way, that if first checks if token needs to be refreshed and if so, it waits before it's refreshed?</p>
","4528716","","","","","2020-01-03 09:32:33","Swift Combine - perform tasks in given sequence","<ios><swift><combine>","1","1","2","","","CC BY-SA 4.0"
"59565999","1","63231492","","2020-01-02 15:37:33","","16","12407","<p>I'm looking for the best way to create a bind between <code>textfields</code> and <code>ViewModel</code>. 
At the moment I'm creating a <code>@State</code> for each textfield and I'm manually sending the value from textfield to the viewModel properties when needed. I'm pretty sure this is not the best way to go... Is there a way to bind the <code>TextField</code> with the <code>ViewModel</code> property? </p>

<p>This is my current code: </p>

<pre><code>struct SigninView: View {
    @State var username:String = """"
    @State var password:String = """"

    var viewModel:SignInViewModel

    var body: some View {
        VStack(alignment: .leading, spacing: 15.0){

            DefaultTextField(placeholder: ""username"", value: $username)
            DefaultTextField(placeholder: ""password"", value: $password)

            Spacer()

            FillButton(title:""Sign In""){
                ///// IS THIS CORRECT?
                self.viewModel.email = self.username
                self.viewModel.password = self.password
                //------------------
                self.viewModel.signin()
            }
        }.padding()
    }
}
</code></pre>

<p>The view model is something like: </p>

<pre><code>class SignInViewModel:ObservableObject{

    var username:String? = nil
    var password:String? = nil
</code></pre>
","499990","","","","","2022-04-24 06:26:19","Binding ViewModel and TextFields with SwiftUI","<ios><swiftui><combine>","2","0","2","","","CC BY-SA 4.0"
"59568889","1","59569036","","2020-01-02 19:22:42","","4","352","<p>I am very new to SwiftUI and Combine, and even though I have plenty of experience with Swift, and a bit with ReactiveKit, I am finding it hard to get some basic stuff to work.</p>

<p>For example, I am trying to add an <code>isLoggedIn</code> property on my ViewModel, which should simply ""forward"" the <code>UserManager</code> class' <code>isLoggedIn</code> property. With ReactiveKit this is rather trivial but with SwiftUI/Combine I can't get is to work. The value is only set once, and then never updated again.</p>

<pre class=""lang-swift prettyprint-override""><code>class UserManager: ObservableObject {
  @Published private(set) var isLoggedIn = false

  // This class has all the actual logic for logging in, 
  // keeping track of the logged in user and the auth status, etc.
}

class ViewModel: ObservableObject {
  @Published var isLoggedIn = false

  private let userManager: UserManager

  init(userManager: UserManager) {
    self.userManager = userManager
    isLoggedIn = userManager.isLoggedIn // &lt;- this doesn't work
    userManager.$isLoggedIn.assign(to: \.isLoggedIn, on: self) // &lt;- neither does this
  }

  func logout() {
    userManager.logout()
  }
}

struct ContentView: View  {
  @ObservedObject var viewModel: ViewModel

  var body: some View {
    // this will use viewModel.isLoggedIn at some point
  }
}
</code></pre>
","403425","","","","","2020-10-22 19:52:33","How to ""forward"" a @Published value","<swiftui><combine>","2","0","2","","","CC BY-SA 4.0"
"59573754","1","59573797","","2020-01-03 05:48:56","","4","826","<p>I am trying to bind the value of <code>query</code> to a search box sitting in a <code>SwiftUI</code> view.</p>

<pre><code>class DataSet: ObservedObject {

... 

@Published var query: String = """"

init() {
    let sub = AnySubscriber&lt;String, Never&gt;(
        receiveSubscription: nil,
        receiveValue: { query in
            print(query)
            return .unlimited
        })
    self.$query.subscribe(sub)
}

...
}
</code></pre>

<p>When the user changes the value of the <code>query</code> I'd like to filter some other property in my <code>ObservedObject</code>. Yet I cannot find anywhere in the documentation how do I subscribe to changes to <code>query</code> property.</p>
","1646086","","2876009","","2020-01-03 08:21:47","2020-01-03 08:21:47","Subscribing to changes to @Published","<ios><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"59587303","1","59587459","","2020-01-04 01:54:51","","4","3692","<p>I'm trying to build an app with SwiftUI, and I'm just getting started with Combine framework. My first simple problem is that I'd like a single variable that defines when the app has been properly initialized. I'd <em>like</em> it to be driven by some nested objects, though. For example, the app is initialized when the account object is initialized, the project object is initialized, etc. My app could then use GlobalAppState.isInitialized, instead of inspected each nested object.</p>

<pre><code>class GlobalAppState: ObservableObject {

    @Published var account: Account = Account()
    @Published var project: Project = Project()

    @Published var isInitialized: Bool {
        return self.account.initialized &amp;&amp; self.project.initialized;
    }
}
</code></pre>

<p>I get the error <code>Property wrapper cannot be applied to a computed property</code></p>

<p>So...clearly, this is currently disallowed. Is there a way I can work around this??? I'd like to be able to use <code>GlobalAppState.initialized</code> as a flag in the app. More to the point, something like <code>GlobalAppState.project.currentProject</code>, which would be a computed property returning the currently selected project, etc...</p>

<p>I can see this pattern being used in a thousand different places! Any help would be wildly appreciated...</p>

<p>Thanks!</p>
","482425","","","","","2020-01-04 03:46:07","@Published for a computed property (or best workaround)","<ios><swift><swiftui><combine>","2","0","2","","","CC BY-SA 4.0"
"59593139","1","59594915","","2020-01-04 17:28:58","","9","2631","<p>As we know, usually publishers are struct. What will change if it is a class?</p>

<p>Let's consider we have 1 publisher which emits 1 value and 2 subscribers, which subscribes to it.</p>

<pre><code>let p1 = Just(20)
let s1 = p1.print().sink { _ in }
let s2 = p1.print().sink { _ in }

// s1 - receive value: (20)
// s2 - receive value: (20)
</code></pre>

<p>in print logs, we can see that both subscribers got value (20).</p>

<p>If we open the documentation of share() operator, we will see</p>

<blockquote>
  <p>share() - Returns a publisher as a class instance.</p>
</blockquote>

<p>So it just changes semantic of the publisher from value to reference. In our example, we don't pass <code>p1</code> publisher to any function or assign to any object and that's why for me there is no difference publisher is struct or class ...
But if I add <code>share()</code> operator behavior will be different, <code>s2</code> won't get value. </p>

<pre><code>let p1 = Just(20).share() // !
let s1 = p1.print().sink { _ in }
let s2 = p1.print().sink { _ in }

// s1 - receive value: (20)
</code></pre>

<p>I saw some examples with <code>URLSession.shared.dataTaskPublisher(\_: URL)</code> or with some ""delayed"" publishers, when <code>s2</code> also gets value, but it's still unclear for me how just changing semantic of publisher change its behaviour in such way.</p>
","3785970","","8261341","","2020-01-04 17:58:29","2020-03-02 02:24:17","Understanding share() in Combine","<swift><combine>","2","0","2","","","CC BY-SA 4.0"
"59593220","1","59597039","","2020-01-04 17:37:15","","3","3392","<p>I have a fairly large project that I started with storyboards and xibs. Now I'm implementing some new views using swiftui. This is the code I'm using to do that:</p>

<pre><code>func goToSchedule() {
    let scheduleController = ScheduleController()
    let vc = UIHostingController(rootView: ScheduleView().environmentObject(scheduleController))
    if let topController = UIApplication.topViewController() {
        topController.present(vc, animated: true, completion: nil)
    }
}
</code></pre>

<p>But I have a problem when I dismiss (swipping down) the view and open it again, every time I do it creates an extra copy of the environment object, this object is a class that handles a tcp connection, the shortened code is as follows:</p>

<pre><code>class ScheduleController: ObservableObject, NetworkDelegate {
    var didChange = PassthroughSubject&lt;Void, Never&gt;()
    @Published var timers = [ScheduleTimer]()
    let connection = tcpNetwork()
    init() {
        connection.delegate = self
    }
    func send(data: String) {
        self.connection.sendMsg(data)
    }
    func processData(data: String) {
    // long function where the received data is parsed and the timers array is updated
}}
</code></pre>

<p>The view is this:</p>

<pre><code>struct ScheduleView: View {
@EnvironmentObject var scheduleController: ScheduleController

var body: some View {
    NavigationView {
      List {
        ForEach(scheduleController.timers, id: \.self) { timer in
            TimerRow(id: timer.id, name: timer.name, startTimer: timer.start, endTimer: timer.end, isActive: timer.isActive)
        }
      }}
</code></pre>
","12001503","","13860","","2020-02-13 22:06:52","2020-02-13 22:06:52","How to clean up environment object after Swiftui view is dismissed?","<swift><swiftui><deinit>","1","2","","","","CC BY-SA 4.0"
"59593765","1","59593842","","2020-01-04 18:45:02","","2","939","<p>I have a <code>@Published</code> property in a singleton class which is observed in a view model class and it only received the first initial value and not after that. Why?</p>

<p>View</p>

<pre><code>import SwiftUI

struct ContentView: View {

    @ObservedObject var viewModel = ContentViewModel(singletonService: SingletonService.shared)

    var body: some View {
        NavigationView {
            Form {
                Text(""Hello World"")
            }.navigationBarItems(trailing: Button(""Increase Number"", action: {
                SingletonService.shared.increaseNumber()
            }))
        }
    }
}
</code></pre>

<p>ViewModel</p>

<pre><code>import Combine

class ContentViewModel: ObservableObject {

    init(
        singletonService: SingletonService
    ) {
        let cencellable = singletonService.$number.sink(receiveValue: { print($0) })
        // Never called after the first time
    }

}
</code></pre>

<p>Singleton</p>

<pre><code>import Combine

class SingletonService {

    static let shared = SingletonService()

    @Published var number = 0

    func increaseNumber() {
        number += 1
    }

}
</code></pre>
","2577123","","","","","2020-01-04 18:52:57","@Published property in singleton not emitting events after the first one","<ios><swift><functional-programming><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"59596627","1","59802785","","2020-01-05 02:54:24","","1","1444","<p>I have a class called <code>QueryObserver</code> that can produce <em>multiple results over time</em>, given back as callbacks (closures). You use it like this:</p>

<pre class=""lang-swift prettyprint-override""><code>let observer = QueryObserver&lt;ModelType&gt;(query: query) { result in
  switch result {
  case .success(let value):
    print(""result: \(value)"")
  case .failure(let error):
    print(""error: \(error)"")
  }
}
</code></pre>

<p>(<code>QueryObserver</code> is actually a wrapper around Firebase Firestore's unwieldy <code>query.addSnapshotListener</code> functionality, in case you were wondering. Using modern <code>Result</code> type instead of a callback with multiple optional parameters.)</p>

<p>In an older project I am using ReactiveKit and have an extension that turns all this into a <code>Signal</code>, like so:</p>

<pre class=""lang-swift prettyprint-override""><code>extension QueryObserver {
  public static func asSignal(query: Query) -&gt; Signal&lt;[T], Error&gt; {
    return Signal { observer in
      let queryObserver = QueryObserver&lt;T&gt;(query: query) { result in
        switch result {
        case .success(let value):
          observer.receive(value)
        case .failure(let error):
          if let firestoreError = error as? FirestoreError, case .noSnapshot = firestoreError {
            observer.receive([])
          } else {
            observer.receive(completion: .failure(error))
          }
        }
      }

      return BlockDisposable {
        queryObserver.stopListening()
      }
    }
  }
}
</code></pre>

<p>In a brand new project though, I am using Combine and am trying to rewrite this. So far as I have managed to write this, but it doesn't work. Which makes sense: the <code>observer</code> is not retained by anything so it's immediately released, and nothing happens.</p>

<pre class=""lang-swift prettyprint-override""><code>extension QueryObserver {
  public static func asSignal(query: Query) -&gt; AnyPublisher&lt;[T], Error&gt; {
    let signal = PassthroughSubject&lt;[T], Error&gt;()

    let observer = QueryObserver&lt;T&gt;(query: query) { result in
      switch result {
      case .success(let value):
        print(""SUCCESS!"")
        signal.send(value)
      case .failure(let error):
        if let firestoreError = error as? FirestoreError, case .noSnapshot = firestoreError {
          signal.send([])
        } else {
          signal.send(completion: .failure(error))
        }
      }
    }

    return signal.eraseToAnyPublisher()
  }
}
</code></pre>

<p>How do I make the Combine version work? How can I wrap existing async code? The only examples I found used <code>Future</code> for one-off callbacks, but I am dealing with multiple values over time.</p>

<p>Basically I am looking for the ReactiveKit-to-Combine version of <a href=""https://github.com/DeclarativeHub/ReactiveKit#wrapping-asynchronous-calls-into-signals"" rel=""nofollow noreferrer"">this</a>.</p>
","403425","","403425","","2020-01-06 01:02:35","2020-01-18 16:54:26","Wrapping asynchronous code in Swift's Combine publisher","<swift><combine><reactivekit>","1","1","","","","CC BY-SA 4.0"
"59598351","1","59598371","","2020-01-05 08:58:22","","1","4103","<p>I get errors called</p>

<pre><code>Value of type '[Voucher]' has no member 'currency'.
Value of type '[Voucher]' has no member 'shopName'.
Value of type '[Voucher]' has no member 'value'.
</code></pre>

<p>Here I get the errors (ContentView):</p>

<pre><code>@ObservedObject var voucherData = VoucherData()

var body: some View {
    NavigationView {
        ZStack {
            List(voucherData.voucherList) { voucher in
                NavigationLink(destination: EditView(value: self.$voucherData.voucherList.value, currency: self.$voucherData.voucherList.currency, shopName: self.$voucherData.voucherList.shopName)) {
                            VStack() { ...
</code></pre>

<p>And here in an other file the list is defined:</p>

<pre><code>import SwiftUI
import Combine

struct Voucher : Identifiable {
    var value : String = """"
    var currency : String = """"
    var shopName : String = """"
}

final class VoucherData: ObservableObject {
    @Published var voucherList: [Voucher] = [
        .init(value: ""20"", currency: ""USD"", shopName: ""FlyBurger"")]
}
</code></pre>
","12655584","","","","","2020-01-05 09:01:47","SwiftUI - Error - Value of type has no member","<ios><swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"59605344","1","59607167","","2020-01-06 00:13:01","","0","287","<p>I have an <code>NSFetchedResultsController</code> and a dynamic table view. My table view cells have a text label. How should I bind objects from the fetched results controller to the cell?</p>

<p>In <a href=""https://developer.apple.com/videos/play/wwdc2019/230/"" rel=""nofollow noreferrer"">WWDC 2019 230</a>, there’s a code snippet where a core data object is bound to a view...</p>

<pre><code>if let tag = try? fetchRequest.execute().first {
  nameSubscription = tag.publisher(for: \.name).assign(to: \.text, on: tagLabel)
  colorSubscription = tag.publisher(for: \.color).map({ $0 as? UIColor}).assign(to: \.textColor, on: tagLabel)
}
</code></pre>

<p>Where should this happen in the context of a table view controller with a cell that has a label? Where should the subscriber (<code>AnyCancellable</code>) go? Will I need a collection of subscribers since there’s an indefinite number of cells?</p>
","6191825","","6191825","","2020-01-06 05:16:41","2020-01-06 06:38:48","How can I bind an NSManagedObject to a table/collection view cell using Combine?","<ios><core-data><uikit><combine>","2","1","","","","CC BY-SA 4.0"
"59612115","1","59612323","","2020-01-06 12:26:17","","1","796","<p>i am learning SwiftUI and trying to implement a simple Timer with the MVVM-pattern. But the view of the Timer is not re-rendered. What is the problem?</p>

<pre><code>// Timer Model

import Foundation

class TimerModel {
    let label: String = ""Counter""
    var count: Int = 0
}
</code></pre>

<pre><code>// Timer View Model

import Foundation
import SwiftUI
import Combine

class TimerViewModel: ObservableObject {

    @Published var timerModel: TimerModel = TimerModel()

    var label: String {
        return self.timerModel.label
    }

    var count: Int {
        return self.timerModel.count
    }

    func startTimer() {
        Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { (timer) in

            DispatchQueue.main.async {
                self.timerModel.count += 1
            }

        }
    }
}
</code></pre>

<pre><code>// Timer View 

import SwiftUI
import Combine

struct TimerView: View {

    @ObservedObject var timerViewModel: TimerViewModel

    init() {
        self.timerViewModel = TimerViewModel()
    }

    var body: some View {
        VStack {
            Text(""\(self.timerViewModel.label): \(self.timerViewModel.count)"")
            Button(action: {
                self.timerViewModel.startTimer()
            }, label: {
                Text(""Start"")
            })
        }
    }
}

struct TimerView_Previews: PreviewProvider {
    static var previews: some View {
        TimerView()
    }
}
</code></pre>

<pre><code>// Content View 

import SwiftUI

struct ContentView: View {

    var body: some View {
        TimerView()
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

</code></pre>

<p>The count property of the Timer Model in the Timer View Model is changed every second, but the Timer View is not re-rendered. Thanks for any idea to implement the MVVM-pattern.</p>
","9821982","","","","","2020-01-06 12:41:45","How to implement the MVVM-Pattern in SwiftUI? The View is not re-rendered","<swift><xcode><mvvm><swiftui>","1","0","","","","CC BY-SA 4.0"
"59635077","1","59635790","","2020-01-07 19:42:27","","6","4687","<p>I have a model type which looks like this:</p>

<pre><code>enum State {
    case loading
    case loaded([String])
    case failed(Error)

    var strings: [String]? {
        switch self {
        case .loaded(let strings): return strings
        default: return nil
        }
    }
}

class MyApi: ObservableObject {
    private(set) var state: State = .loading

    func fetch() {
        ... some time later ...
        self.state = .loaded([""Hello"", ""World""])
    }
}
</code></pre>

<p>and I'm trying to use this to drive a SwiftUI View.</p>

<pre><code>struct WordListView: View {
    @EnvironmentObject var api: MyApi

    var body: some View {
        ZStack {
            List($api.state.strings) {
                Text($0)
            }
        }
    }
}
</code></pre>

<p>It's about here that my assumptions fail. I'm trying to get a list of the strings to render in my <code>List</code> when they are loaded, but it won't compile.</p>

<p>The compiler error is <code>Generic parameter 'Subject' could not be inferred</code>, which after a bit of googling tells me that bindings are two-way, so won't work with both my <code>private(set)</code> and the var on the State enum being read-only.</p>

<p>This doesn't seem to make any sense - there is no way that the view should be able to tell the api whether or not it's loading, that definitely should be a one-way data flow!</p>

<p>I guess my question is either </p>

<ol>
<li>Is there a way to get a one-way binding in SwiftUI - i.e. some of the UI will update based on a value it cannot change.</li>
</ol>

<p>or</p>

<ol start=""2"">
<li>How should I have architected this code! It's very likely that I'm writing code in a style which doesn't work with SwiftUI, but all the tutorials I can see online neatly ignore things like loading / error states.</li>
</ol>
","13000","","1027644","","2020-01-07 20:06:59","2020-01-07 20:55:12","Binding to a read-only property in SwiftUI","<swift><swiftui><combine>","1","4","3","","","CC BY-SA 4.0"
"59637100","1","59692095","","2020-01-07 22:40:39","","14","2420","<p><strong>Ground of Being</strong>: It will help, before reading, to know that you cannot assign a UIImage to an image view outlet's <code>image</code> property through the keypath <code>\UIImageView.image</code>. Here's the property:</p>

<pre><code>@IBOutlet weak var iv: UIImageView!
</code></pre>

<p>Now, will this compile?</p>

<pre><code>    let im = UIImage()
    let kp = \UIImageView.image
    self.iv[keyPath:kp] = im // error
</code></pre>

<p>No!</p>

<blockquote>
  <p>Value of optional type 'UIImage?' must be unwrapped to a value of type 'UIImage'</p>
</blockquote>

<p>Okay, now we're ready for the actual use case.</p>

<hr>

<p>What I'm actually trying to understand is how the Combine framework <code>.assign</code> subscriber works behind the scenes. To experiment, I tried using my own Assign object. In my example, my publisher pipeline produces a UIImage object, and I assign it to the <code>image</code> property of a UIImageView property <code>self.iv</code>.</p>

<p>If we use the <code>.assign</code> method, this compiles and works:</p>

<pre><code>URLSession.shared.dataTaskPublisher(for: url)
    .map {$0.data}
    .replaceError(with: Data())
    .compactMap { UIImage(data:$0) }
    .receive(on: DispatchQueue.main)
    .assign(to: \.image, on: self.iv)
    .store(in:&amp;self.storage)
</code></pre>

<p>So, says I to myself, to see how this works, I'll remove the <code>.assign</code> and replace it with my own Assign object:</p>

<pre><code>let pub = URLSession.shared.dataTaskPublisher(for: url)
    .map {$0.data}
    .replaceError(with: Data())
    .compactMap { UIImage(data:$0) }
    .receive(on: DispatchQueue.main)

let assign = Subscribers.Assign(object: self.iv, keyPath: \UIImageView.image)
pub.subscribe(assign) // error
// (and we will then wrap in AnyCancellable and store)
</code></pre>

<p>Blap! We can't do that, because <code>UIImageView.image</code> is an Optional UIImage, and my publisher produces a UIImage plain and simple.</p>

<p>I tried to work around this by unwrapping the Optional in the key path:</p>

<pre><code>let assign = Subscribers.Assign(object: self.iv, keyPath: \UIImageView.image!)
pub.subscribe(assign)
</code></pre>

<p>Cool, that compiles. But it crashes at runtime, presumably because the image view's image is initially <code>nil</code>.</p>

<p>Now I can work around all of this just fine by adding a <code>map</code> to my pipeline that wraps the UIImage up in an Optional, so that all the types match correctly. But my question is, how does this <em>really</em> work? I mean, why don't I have to do that in the first code where I use <code>.assign</code>? Why am I able to specify the <code>.image</code> keypath there? There seems to be some trickery about how key paths work with Optional properties but I don't know what it is.</p>

<hr>

<p>After some input from Martin R I realized that if we type <code>pub</code> explicitly as producing <code>UIImage?</code> we get the same effect as adding a <code>map</code> that wraps the UIImage in an Optional. So this compiles and works</p>

<pre><code>let pub : AnyPublisher&lt;UIImage?,Never&gt; = URLSession.shared.dataTaskPublisher(for: url)
    .map {$0.data}
    .replaceError(with: Data())
    .compactMap { UIImage(data:$0) }
    .receive(on: DispatchQueue.main)
    .eraseToAnyPublisher()

let assign = Subscribers.Assign(object: self.iv, keyPath: \UIImageView.image)
pub.subscribe(assign)
let any = AnyCancellable(assign)
any.store(in:&amp;self.storage)
</code></pre>

<p>This still doesn't explain how the original <code>.assign</code> works. It appears that it is able to <em>push</em> the optionality of the type <em>up</em> the pipeline into the <code>.receive</code> operator. But I don't see how that is possible.</p>
","341994","","341994","","2020-01-08 20:16:59","2022-08-03 15:40:43","How does Swift ReferenceWritableKeyPath work with an Optional property?","<swift><optional><combine><swift-keypath>","1","7","5","","","CC BY-SA 4.0"
"59659292","1","59659918","","2020-01-09 07:45:48","","1","513","<p>I have the following method (named: <code>stories</code>) from Combine's book by Ray Wenderlich that fetches stories from <a href=""https://hacker-news.firebaseio.com/v0/"" rel=""nofollow noreferrer"">Hacker News Public API</a> as follows:</p>

<p>Model Object:</p>

<pre><code>public struct Story: Codable {
  public let id: Int
  public let title: String
  public let by: String
 public let time: TimeInterval
 public let url: String
}

extension Story: Comparable {
  public static func &lt; (lhs: Story, rhs: Story) -&gt; Bool {
  return lhs.time &gt; rhs.time
  }
}

extension Story: CustomDebugStringConvertible {
   public var debugDescription: String {
   return ""\n\(title)\nby \(by)\n\(url)\n-----""
  }
}
</code></pre>

<p>API Struct:</p>

<pre><code>struct API {
  enum Error: LocalizedError {
   case addressUnreachable(URL)
   case invalidResponse

var errorDescription: String? {
  switch self {
  case .invalidResponse: return ""The server responded with garbage.""
  case .addressUnreachable(let url): return ""\(url.absoluteString) is unreachable.""
    }
   }
 }

enum EndPoint {
   static let baseURL = URL(string: ""https://hacker-news.firebaseio.com/v0/"")!

   case stories
   case story(Int)

   var url: URL {
  switch self {
  case .stories:
    return EndPoint.baseURL.appendingPathComponent(""newstories.json"")
  case .story(let id):
    return EndPoint.baseURL.appendingPathComponent(""item/\(id).json"")
     }
   }
 }


var maxStories = 10


private let decoder = JSONDecoder()
private let apiQueue = DispatchQueue(label: ""API"", qos: .default, attributes: .concurrent)

func story(id: Int) -&gt; AnyPublisher&lt;Story, Error&gt; {
    URLSession.shared.dataTaskPublisher(for: EndPoint.story(id).url)
        .receive(on: apiQueue)
        .map(\.data)
        .decode(type: Story.self, decoder: decoder)
        .catch{ _ in Empty&lt;Story, Error&gt;() }
        .eraseToAnyPublisher()
}

func mergedStories(ids storyIDs: [Int]) -&gt; AnyPublisher&lt;Story, Error&gt; {
    let storyIDs = Array(storyIDs.prefix(maxStories))
    precondition(!storyIDs.isEmpty)
    let initialPublisher = story(id: storyIDs[0])
    let remainder = Array(storyIDs.dropFirst())
    return remainder.reduce(initialPublisher) { combined, id in //Swift's reduce method
        combined
        .merge(with: story(id: id))
        .eraseToAnyPublisher()
    }
}

func stories() -&gt; AnyPublisher&lt;[Story], Error&gt; {
    URLSession.shared
        .dataTaskPublisher(for: EndPoint.stories.url)
        .map(\.data)
        .decode(type: [Int].self, decoder: decoder)
        .mapError { error -&gt; API.Error in
            switch error {
            case is URLError:
                return Error.addressUnreachable(EndPoint.stories.url)
            default:
                return Error.invalidResponse
            }
    }
    .filter { !$0.isEmpty }
    .flatMap { storyIDs in
        print(""StoryIDs are \(storyIDs)"") //the print statement that causes the error
       return self.mergedStories(ids: storyIDs)
    }
    .scan([]) { stories, story -&gt; [Story] in
        stories + [story] //&lt;--- Error fires here
    }
    .map { $0.sorted() }
    .eraseToAnyPublisher()
  }
}
</code></pre>

<p>Consumer Code:</p>

<pre><code>let api = API()
var subscriptions = Set&lt;AnyCancellable&gt;()
api.stories()
.sink(receiveCompletion: { print($0) },
      receiveValue: { print($0) })
.store(in: &amp;subscriptions)
</code></pre>

<p>The method works perfectly without putting in the <code>print(""storyIDs are \(storyIDs)"")</code> statement, once this print statement is placed, a weird compiler error fires at the line: <code>stories + [story]</code>  which says:</p>

<blockquote>
  <p><code>'[Any]' is not convertible to 'Array&lt;Story&gt;'</code></p>
</blockquote>

<p>I don't know what does this misleading error mean in such case ? </p>
","1056118","","1056118","","2020-01-09 08:33:25","2020-01-09 11:26:06","Combine weird compile error after placing a print statement in a flatMap operator closure","<ios><swift><combine>","1","4","","","","CC BY-SA 4.0"
"59674534","1","59674949","","2020-01-10 01:50:05","","0","276","<p>I am trying to make a SwiftUI view about chemistry. I decided to create a description view where information about each element is displayed. I want to call a function to generate the electron configuration, but it gives me an error with seemingly no useful information. When I try to call a function in the view, I get this error: </p>

<pre><code>Error Domain=com.apple.dt.ultraviolet.service Code=12 ""Rendering service was interrupted"" UserInfo={NSLocalizedDescription=Rendering service was interrupted}
</code></pre>

<p>I have tried switching how I call the functions but nothing has worked.</p>

<p>Here is the code</p>

<p>Element Object:</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

struct Element: Decodable, Identifiable, Hashable {
    public var id: Int
    public var name: String
    public var symbol: String
    public var atomicMass: Double
    public var atomicRadius: Double
    public var density: Double
    public var eConfig: [Int]

    /*
     -- electron config layout
     [2, 2, 6, ...] -&gt; 1s2 2s2 2p6 ...
     */

    func createOrbital() -&gt; String {
        var orbital: String = """"

        // MARK: Orbital Loop
        for (index, val) in self.eConfig.enumerated() {
            let block = orbitalBlock(from: index)!
            var level = getRow(from: index)!

            // MARK: Subtraction rules
            if block == ""d"" {
                level -= 1
            } else if block == ""f"" {
                level -= 2
            }

            orbital += String(level)
            orbital += String(block)
            orbital += superscript(from: val)
        }

        return orbital
    }
}

func superscript(from val: Int) -&gt; String {
    let str = String(val)
    let supers = [
        ""0"": ""\u{2070}"",
        ""1"": ""\u{00B9}"",
        ""2"": ""\u{00B2}"",
        ""3"": ""\u{00B3}"",
        ""4"": ""\u{2074}"",
        ""5"": ""\u{2075}"",
        ""6"": ""\u{2076}"",
        ""7"": ""\u{2077}"",
        ""8"": ""\u{2078}"",
        ""9"": ""\u{2079}""]

    var newStr = """"
    for char in str {
        let key = String(char)
        newStr.append(Character(supers[key]!))
    }
    return newStr
}

func orbitalBlock(from index: Int) -&gt; String? {
    switch (index) {
    case 1...4, 11, 12, 19, 20, 37, 38, 55, 56, 87, 88:
        return ""s""
    case 5...10, 13...18, 31...36, 49...54, 81...86, 113...118:
        return ""p""
    case 21...30, 39...48, 72...80, 104...112:
        return ""d""
    case 57...71, 89...103:
        return ""f""
    default:
        return nil
    }
}

func getRow(from index: Int) -&gt; Int? {
    switch (index) {
    case 1...2:
        return 1
    case 3...10:
        return 2
    case 11...18:
        return 3
    case 19...36:
        return 4
    case 37...54:
        return 5
    case 55...86:
        return 6
    case 87...118:
        return 7
    default:
        return nil
    }
}
</code></pre>

<p>Element View:</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI


struct ElementDetailView: View {
    public var element: Element
    private var orbital: String

    init(element: Element) {
        self.element = element
        self.orbital = element.createOrbital()
    }

    var body: some View {
        VStack {
            Text(orbital)
        }
    }
}



struct ElementDetailView_Previews: PreviewProvider {
    static var previews: some View {
        ElementDetailView(element: Element(id: 1, name: ""Hydrogen"", symbol: ""H"", atomicMass: 2.0, atomicRadius: 2.0, density: 2.0, eConfig: [1]))
    }
}
</code></pre>
","9406193","","","","","2020-01-10 03:46:57","Error with no useful explanation in SwiftUI view and struct","<swift><swiftui>","2","0","","","","CC BY-SA 4.0"
"59676570","1","59679010","","2020-01-10 06:35:44","","0","938","<p>I've got a question about the <code>zip</code> operator in Combine in combination with backpressure.</p>

<p>Take the following code snippet:</p>

<pre><code>let sequencePublisher = Publishers.Sequence&lt;Range&lt;Int&gt;, Never&gt;(sequence: 0..&lt;Int.max)
let subject = PassthroughSubject&lt;String, Never&gt;()

let handle = subject
    .zip(sequencePublisher.print())
    .print()
    .sink { letters, digits in
        print(letters, digits)
    }

subject.send(""a"")
</code></pre>

<p>When executing this in the playground, the following is the output:</p>

<pre><code>receive subscription: (0..&lt;9223372036854775807)
receive subscription: (Zip)
request unlimited
request unlimited
receive value: (0)
receive value: (1)
receive value: (2)
receive value: (3)
receive value: (4)
receive value: (5)
receive value: (6)
receive value: (7)
...
</code></pre>

<p>When executing it on an iOS device, the code crashes after a few seconds because of memory issues.</p>

<p>The underlying reason can be seen in the fourth line above where <code>zip</code> requests an unlimited amount of values from the <code>sequencePublisher</code>. Since the <code>sequencePublisher</code> provides the whole range of <code>Int</code> values, this causes memory overflows.</p>

<p>What I think to know:</p>

<ul>
<li><code>zip</code> waits for one value of each publisher before combining them and pushing them on </li>
<li>backpressure is used to control the demand from a subscriber to a publisher</li>
</ul>

<p>My expectation would be that <code>zip</code> only requests one value from each publisher, waits for them to arrive and only requests the next values when it received one from each. </p>

<p>In this particular case I tried to build a behaviour where a sequence number is assigned to every value that is produced by the  <code>subject</code>. However, I could imagine that this is always a problem when <code>zip</code> combines values from publishers that publish with very different frequencies. </p>

<p>Utilising backpressure in the <code>zip</code> operator seems to be perfect tool to solve that issue. Do you know why this isn't the case? Is this a bug or intentional? If intentional, why?</p>

<p>Thanks guys</p>
","1668608","","1668608","","2020-01-10 06:47:23","2020-08-23 09:20:22","Swift Combine: Unexpected backpressure behaviour with zip operator","<ios><swift><reactive-programming><combine>","2","0","1","","","CC BY-SA 4.0"
"59689442","1","59693022","","2020-01-10 21:47:10","","3","2570","<p>I feel like I can sort of understand why what I'm doing isn't working but I'm still trying to wrap my head around Combine and SwiftUI so any help here would be welcome.</p>

<p>Consider this example:</p>

<p>Single view app that stores some strings in UserDefaults, and uses those strings to display some Text labels. There are three buttons, one to update the title, and one each to update the two UserDefaults-stored strings to a random string.</p>

<p>The view is a dumb renderer view and the title string is stored directly in an ObservableObject view model. The view model has a published property that holds a reference to a UserSettings class that implements property wrappers to store the user defined strings to UserDefaults.</p>

<p>Observations:</p>

<p>• Tapping ""Set A New Title"" correctly updates the view to show the new value</p>

<p>• Tapping either of the ""Set User Value"" buttons does change the value internally, however the view does not refresh. 
If ""Set A New Title"" is tapped after one of these buttons, the new values are shown when the view body rebuilds for the title change.</p>

<p>View:</p>

<pre><code>import SwiftUI

struct ContentView: View {
    @ObservedObject var model = ViewModel()

    var body: some View {
        VStack {
            Text(model.title).font(.largeTitle)
            Form {
                Section {
                    Text(model.settings.UserValue1)
                    Text(model.settings.UserValue2)
                }

                Section {
                    Button(action: {
                        self.model.title = ""Updated Title""
                    }) { Text(""Set A New Title"") }
                    Button(action: {
                        self.model.settings.UserValue1 = ""\(Int.random(in: 1...100))""
                    }) { Text(""Set User Value 1 to Random Integer"") }
                    Button(action: {
                        self.model.settings.UserValue2 = ""\(Int.random(in: 1...100))""
                    }) { Text(""Set User Value 2 to Random Integer"") }
                }

                Section {
                    Button(action: {
                        self.model.settings.UserValue1 = ""Initial Value One""
                        self.model.settings.UserValue2 = ""Initial Value Two""
                        self.model.title = ""Initial Title""
                    }) { Text(""Reset All"") }
                }

            }
        }
    }
}
</code></pre>

<p>ViewModel:</p>

<pre><code>import Combine

class ViewModel: ObservableObject {

    @Published var title = ""Initial Title""

    @Published var settings = UserSettings()

}
</code></pre>

<p>UserSettings model:</p>

<pre><code>import Foundation
import Combine

@propertyWrapper struct DefaultsWritable&lt;T&gt; {
    let key: String
    let value: T

    init(key: String, initialValue: T) {
        self.key = key
        self.value = initialValue
    }

    var wrappedValue: T {
        get { return UserDefaults.standard.object(forKey: key) as? T ?? value }
        set { return UserDefaults.standard.set(newValue, forKey: key) }
    }
}



final class UserSettings: NSObject, ObservableObject {
    let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()

    @DefaultsWritable(key: ""UserValue"", initialValue: ""Initial Value One"") var UserValue1: String {
        willSet {
            objectWillChange.send()
        }
    }
    @DefaultsWritable(key: ""UserBeacon2"", initialValue: ""Initial Value Two"") var UserValue2: String {
        willSet {
            objectWillChange.send()
        }
    }

}
</code></pre>

<p>When I put a breakpoint on <code>willSet { objectWillChange.send() }</code> in UserSettings I see that the objectWillChange message is going to the publisher when I would expect it to so that tells me that the issue is likely that the view or the view model is not properly subscribing to it. I know that if I had UserSettings as an <code>@ObservedObject</code> on the view this would work, but I feel like this should be done in the view model with Combine.</p>

<p>What am I missing here? I'm sure it's really obvious...</p>
","12482631","","","","","2022-04-25 13:19:23","Passing an ObservableObject model through another ObObject?","<ios><swift><swiftui><combine><observableobject>","1","0","1","","","CC BY-SA 4.0"
"59690913","1","59691976","","2020-01-11 01:32:41","","15","3984","<p>Im trying to test a simple publisher within the Combine framework and SwiftUI.  My test tests a published bool named isValid in my view model.  My view model also has a published username string, that when changes and becomes 3 characters or more isValid is assigned the value.  Here is the view model.  I am sure I am not understanding how publishers work in a test environment, timing etc...  Thanks in advance. </p>

<pre><code>public class UserViewModel: ObservableObject {
  @Published var username = """"
  @Published var isValid = false
  private var disposables = Set&lt;AnyCancellable&gt;()

  init() {
    $username
      .receive(on: RunLoop.main)
      .removeDuplicates()
      .map { input in
        print(""~~~&gt; \(input.count &gt;= 3)"")
        return input.count &gt;= 3
    }
    .assign(to: \.isValid, on: self)
    .store(in: &amp;disposables)
  }
}
</code></pre>

<p>Here is my view, not really important here</p>

<pre><code>struct ContentView: View {
  @ObservedObject private var userViewModel = UserViewModel()
  var body: some View {
    TextField(""Username"", text: $userViewModel.username)
  }
}
</code></pre>

<p>Here is my test file and single test that fails</p>

<pre><code>class StackoverFlowQuestionTests: XCTestCase {
  var model = UserViewModel()

    override func setUp() {
        model = UserViewModel()
    }

    override func tearDown() {
    }

    func testIsValid() {
      model.username = ""1""
      XCTAssertFalse(model.isValid)
      model.username = ""1234""
      XCTAssertTrue(model.isValid) //&lt;----- THIS FAILS HERE
    }

}
</code></pre>
","1302387","","","","","2022-07-21 12:23:56","How do I properly test a var that changes through a publisher in my viewModel in XCTestCase","<swift><swiftui><combine>","3","0","5","","","CC BY-SA 4.0"
"59698091","1","59700392","","2020-01-11 19:50:30","","3","3081","<p>I've created a custom Publisher for use with a Realm database which seems to function as expected in isolation but doesn't want to play nicely with SwiftUI.</p>

<p>I've isolated the issue to the interface between the view model and SwiftUI. The view model appears to behave as expected based on the results from the various property observers and .print() statements I've dropped in for the bug hunt but outside the scope of the view model, the view model's data repository (represented by the 'state' property) is reported as empty hence the blank UI. </p>

<p>Interestingly, if I replace my Combine code with a straight array conversion of the Realm Results query the UI is displayed as expected (although I haven't implemented notification tokens for a dynamic update when items are added/deleted, etc). </p>

<p>I suspect I can't see the wood for all the trees so an outside perspective and guidance would be very much appreciated :-)</p>

<p>Codebase below - I've left out Apple-generated boilerplate for the most part.</p>

<p><strong>SceneDelegate:</strong></p>

<pre><code>class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?


    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).

        // Create the SwiftUI view that provides the window contents.
        let patientService = MockPatientService()
        let viewModel = AnyViewModel(PatientListViewModel(patientService: patientService))
        print(""#(function) viewModel contains \(viewModel.state.patients.count) patients"")
        let contentView = PatientListView()
            .environmentObject(viewModel)

        // Use a UIHostingController as window root view controller.
        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(rootView: contentView)
            self.window = window
            window.makeKeyAndVisible()
        }
    }
</code></pre>

<p><strong>Patient.swift</strong></p>

<pre><code>import Foundation
import RealmSwift

@objcMembers final class Patient: Object, Identifiable {
    dynamic let id: String = UUID().uuidString
    dynamic var name: String = """"

    required init() {
        super.init()
    }

    init(name: String) {
        self.name = name
    }
}
</code></pre>

<p><strong>PatientService</strong></p>

<pre><code>import Foundation
import RealmSwift

@objcMembers final class Patient: Object, Identifiable {
    dynamic let id: String = UUID().uuidString
    dynamic var name: String = """"

    required init() {
        super.init()
    }

    init(name: String) {
        self.name = name
    }
}
</code></pre>

<p><strong>ViewModel</strong></p>

<pre><code>import Foundation
import Combine

protocol ViewModel: ObservableObject where ObjectWillChangePublisher.Output == Void {
    associatedtype State // the type of the state of a given scene
    associatedtype Input // inputs to the view model that are transformed by the trigger method

    var state: State { get }
    func trigger(_ input: Input)
}

final class AnyViewModel&lt;State, Input&gt;: ObservableObject { // wrapper enables ""effective"" (not true) type erasure of the view model
    private let wrappedObjectWillChange: () -&gt; AnyPublisher&lt;Void, Never&gt;
    private let wrappedState: () -&gt; State
    private let wrappedTrigger: (Input) -&gt; Void


    var objectWillChange: some Publisher {
        wrappedObjectWillChange()
    }

    var state: State {
        wrappedState()
    }

    func trigger(_ input: Input) {
        wrappedTrigger(input)
    }

    init&lt;V: ViewModel&gt;(_ viewModel: V) where V.State == State, V.Input == Input {
        self.wrappedObjectWillChange = { viewModel.objectWillChange.eraseToAnyPublisher() }
        self.wrappedState = { viewModel.state }
        self.wrappedTrigger = viewModel.trigger
    }
}

extension AnyViewModel: Identifiable where State: Identifiable {
    var id: State.ID {
        state.id
    }
}
</code></pre>

<p><strong>RealmCollectionPublisher</strong></p>

<pre><code>import Foundation
import Combine
import RealmSwift

// MARK: Custom publisher - produces a stream of Object arrays in response to change notifcations on a given Realm collection
extension Publishers {
    struct Realm&lt;Collection: RealmCollection&gt;: Publisher {
        typealias Output = Array&lt;Collection.Element&gt;
        typealias Failure = Never // TODO: Not true but deal with this later

        let collection: Collection

        init(collection: Collection) {
            self.collection = collection
        }

        func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {
            let subscription = RealmSubscription(subscriber: subscriber, collection: collection)
            subscriber.receive(subscription: subscription)
        }
    }
}

// MARK: Convenience accessor function to the custom publisher
extension Publishers {
    static func realm&lt;Collection: RealmCollection&gt;(collection: Collection) -&gt; Publishers.Realm&lt;Collection&gt; {
        return Publishers.Realm(collection: collection)
    }
}

// MARK: Custom subscription
private final class RealmSubscription&lt;S: Subscriber, Collection: RealmCollection&gt;: Subscription where S.Input == Array&lt;Collection.Element&gt; {
    private var subscriber: S?
    private let collection: Collection
    private var notificationToken: NotificationToken?

    init(subscriber: S, collection: Collection) {
        self.subscriber = subscriber
        self.collection = collection

        self.notificationToken = collection.observe { (changes: RealmCollectionChange) in
            switch changes {
            case .initial:
                // Results are now populated and can be accessed without blocking the UI
                print(""Initial"")
                subscriber.receive(Array(collection.elements))
            case .update(_, let deletions, let insertions, let modifications):
                print(""Updated"")
                subscriber.receive(Array(collection.elements))
            case .error(let error):
                fatalError(""\(error)"")
                #warning(""Impl error handling - do we want to fail or log and recover?"")
            }
        }
    }

    func request(_ demand: Subscribers.Demand) {
        // no impl as RealmSubscriber is effectively just a sink
    }

    func cancel() {
        print(""Cancel called on RealnSubscription"")
        subscriber = nil
        notificationToken = nil
    }

    deinit {
        print(""RealmSubscription de-initialised"")
    }
}
</code></pre>

<p><strong>PatientListViewModel</strong></p>

<pre><code>class PatientListViewModel: ViewModel {
    @Published var state: PatientListState = PatientListState(patients: [AnyViewModel&lt;PatientDetailState, Never&gt;]()) {
        willSet {
            print(""Current PatientListState : \(newValue)"")
        }
    }

    private let patientService: PatientService
    private var cancellables = Set&lt;AnyCancellable&gt;()

    init(patientService: PatientService) {
        self.patientService = patientService

        // Scenario 1 - This code sets state which is correctly shown in UI (although not dynamically updated)
        let viewModels = patientService.allPatientsAsArray()
            .map { AnyViewModel(PatientDetailViewModel(patient: $0, patientService: patientService)) }
        self.state = PatientListState(patients: viewModels)

        // Scenario 2 (BUGGED) - This publisher's downstream emissions update dynamically, downstream outputs are correct and the willSet observer suggests .assign is working
        // but the UI does not reflect the changes (if the above declarative code is removed, the number of patients is always zero)
        let publishedState = Publishers.realm(collection: patientService.allPatientsAsResults())
            .print()
            .map { results in
                results.map { AnyViewModel(PatientDetailViewModel(patient: $0, patientService: patientService)) } }
            .map { PatientListState(patients: $0) }
            .eraseToAnyPublisher()
            .assign(to: \.state, on: self)
            .store(in: &amp;cancellables)
    }

    func trigger(_ input: PatientListInput) {
        switch(input) {
        case .delete(let indexSet):
            let patient = state.patients[indexSet.first!].state.patient
            patientService.deletePatient(patient)
            print(""Deleting item at index \(indexSet.first!) - patient is \(patient)"")
            #warning(""Know which patient to remove but need to ensure the state is updated"")
        }
    }

    deinit {
        print(""Viewmodel being deinitialised"")
    }
}
</code></pre>

<p><strong>PatientListView</strong></p>

<pre><code>struct PatientListState {
    var patients: [AnyViewModel&lt;PatientDetailState, Never&gt;]
}

enum PatientListInput {
    case delete(IndexSet)
}


struct PatientListView: View {
    @EnvironmentObject var viewModel: AnyViewModel&lt;PatientListState, PatientListInput&gt; 

    var body: some View {
        NavigationView {

            VStack {
                Text(""Patients: \(viewModel.state.patients.count)"")

                List {
                    ForEach(viewModel.state.patients) { viewModel in
                        PatientCell(patient: viewModel.state.patient)
                    }
                    .onDelete(perform: deletePatient)

                }
                .navigationBarTitle(""Patients"")
            }
        }
    }

    private func deletePatient(at offset: IndexSet) {
        viewModel.trigger(.delete(offset))
    }
}
</code></pre>

<p><strong>PatientDetailViewModel</strong></p>

<pre><code>class PatientDetailViewModel: ViewModel {
    @Published private(set) var state: PatientDetailState
    private let patientService: PatientService
    private let patient: Patient

    init(patient: Patient, patientService: PatientService) {
        self.patient = patient
        self.patientService = patientService
        self.state = PatientDetailState(patient: patient)
    }

    func trigger(_ input: Never) {
        // TODO: Implementation
    }
}
</code></pre>

<p><strong>PatientDetailView</strong></p>

<pre><code>struct PatientDetailState {
    let patient: Patient
    var name: String {
        patient.name
    }
}

extension PatientDetailState: Identifiable {
    var id: Patient.ID {
        patient.id
    }
}

struct PatientDetailView: View {
    var body: some View {
        Text(/*@START_MENU_TOKEN@*/""Hello, World!""/*@END_MENU_TOKEN@*/)
    }
}

struct PatientDetailView_Previews: PreviewProvider {
    static var previews: some View {
        PatientDetailView()
    }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/7T1EE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7T1EE.png"" alt=""**Using arrays:**""></a>
<a href=""https://i.stack.imgur.com/uVDYn.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uVDYn.png"" alt=""**Using custom Publisher**""></a></p>
","2733214","","","","","2020-01-12 02:11:45","Combine & SwiftUI with a custom Publisher - unexpected behaviour when using .assign subscriber","<swift><realm><swiftui><combine>","1","0","2","","","CC BY-SA 4.0"
"59712847","1","59713607","","2020-01-13 08:25:38","","2","1975","<p>I have LocationManager class that works well. This is part of LocationManager class. </p>

<pre><code>  var headingDegree = PassthroughSubject&lt;Double, Never&gt;()

  func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {
    headingDegree.send(-newHeading.magneticHeading)
  }
</code></pre>

<p><code>headingDegree</code> is the value I want to send to my ViewModel. I debugged it to make sure it has correct values, and it does. </p>

<p>So, in my view model,</p>

<pre><code>class CompassViewViewModel: ObservableObject {
 @Published var degree: Double = 0.0
 @State var cancellable = Set&lt;AnyCancellable&gt;()

 func update() {
    LocationManager.shared.headingDegree.sink {
      self.degree = $0
    }
    .store(in: &amp;cancellable)
  }

</code></pre>

<p>I sinked my <code>headingDegree</code>. This is the part that brings my problems. If I put breakpoints in <code>update()</code> function, <code>self.degree = $0</code> is never called. </p>

<p>This is how my View looks like. </p>

<pre><code>struct CompassView: View {
  @ObservedObject var viewModel: CompassViewViewModel

  init(viewModel: CompassViewViewModel) {
    self.viewModel = viewModel
  }

 var body: some View {
    ZStack {
      Text(""aa"")
        .font(.footnote)
    }
      .onAppear {
        self.viewModel.update()
    }
  }
}
</code></pre>

<p>Could you tell me why my sink() is not called? </p>
","11258185","","11258185","","2020-01-13 08:40:54","2020-07-08 08:53:27","sink() is not called in combine swift","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"59725439","1","59773983","","2020-01-13 23:02:40","","0","690","<p>I've never come across a witness table error before but this is my first venture into testing custom Publishers and, if I was to guess, I suspect there is something weird and wonderful going on with threading based on how mangled the witness name is. Completely out at sea here so a pointer (or pointers!) would be much appreciated.</p>

<p><strong>Custom publisher</strong></p>

<pre><code>// MARK: Custom publisher - produces a stream of Object arrays in response to change notifcations on a given Realm collection
extension Publishers {
    struct Realm&lt;Collection: RealmCollection&gt;: Publisher {
        typealias Output = Array&lt;Collection.Element&gt;
        typealias Failure = Never // TODO: Not true but deal with this later

        let collection: Collection

        init(collection: Collection) {
            self.collection = collection
        }

        func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {
            let subscription = RealmSubscription(subscriber: subscriber, collection: collection)
            subscriber.receive(subscription: subscription)
        }
    }
}

// MARK: Convenience accessor function to the custom publisher
extension Publishers {
    static func realm&lt;Collection: RealmCollection&gt;(collection: Collection) -&gt; Publishers.Realm&lt;Collection&gt; {
        return Publishers.Realm(collection: collection)
    }
}

// MARK: Custom subscription
private final class RealmSubscription&lt;S: Subscriber, Collection: RealmCollection&gt;: Subscription where S.Input == Array&lt;Collection.Element&gt; {
    private var subscriber: S?
    private let collection: Collection
    private var notificationToken: NotificationToken?

    init(subscriber: S, collection: Collection) {
        self.subscriber = subscriber
        self.collection = collection

        self.notificationToken = collection.observe { (changes: RealmCollectionChange) in
            switch changes {
            case .initial:
                // Results are now populated and can be accessed without blocking the UI
                print(""Initial"")
                let _ = subscriber.receive(Array(collection.elements)) // ERROR THROWN HERE 
            //            case .update(_, let deletions, let insertions, let modifications):
            case .update(_, _, _, _):
                print(""Updated"")
                let _ = subscriber.receive(Array(collection.elements))
            case .error(let error):
                fatalError(""\(error)"")
                #warning(""Impl error handling - do we want to fail or log and recover?"")
            }
        }
    }

    func request(_ demand: Subscribers.Demand) {
        // no impl as RealmSubscriber is effectively just a sink
    }

    func cancel() {
        print(""Cancel called on RealnSubscription"")
        subscriber = nil
        notificationToken = nil
    }
}
</code></pre>

<p><strong>Service class</strong></p>

<pre><code>protocol RealmServiceType {
    func all&lt;Element&gt;(_ type: Element.Type, within realm: Realm) -&gt; AnyPublisher&lt;Array&lt;Element&gt;, Never&gt; where Element: Object

    @discardableResult
    func addPatient(_ name: String, to realm: Realm) throws -&gt; AnyPublisher&lt;Patient, Never&gt;

    func deletePatient(_ patient: Patient, from realm: Realm)
}

extension RealmServiceType {
    func all&lt;Element&gt;(_ type: Element.Type) -&gt; AnyPublisher&lt;Array&lt;Element&gt;, Never&gt; where Element: Object {
        print(""Called \(#function)"")
        return all(type, within: try! Realm())
    }
}

final class TestRealmService: RealmServiceType {
    private let patients = [
        Patient(name: ""Tiddles""), Patient(name: ""Fang""), Patient(name: ""Phoebe""), Patient(name: ""Snowy"")
    ]

    init() {
        let realm = try! Realm()
        guard realm.isEmpty else { return }
        try! realm.write {
            for p in patients {
                realm.add(p)
            }
        }
    }

    func all&lt;Element&gt;(_ type: Element.Type, within realm: Realm) -&gt; AnyPublisher&lt;Array&lt;Element&gt;, Never&gt; where Element: Object {
        return Publishers.realm(collection: realm.objects(type).sorted(byKeyPath: ""name"")).eraseToAnyPublisher()
    }


    func addPatient(_ name: String, to realm: Realm) throws -&gt; AnyPublisher&lt;Patient, Never&gt; {
        let patient = Patient(name: name)
        try! realm.write {
            realm.add(patient)
        }
        return Just(patient).eraseToAnyPublisher()
    }

    func deletePatient(_ patient: Patient, from realm: Realm) {
        try! realm.write {
            realm.delete(patient)
        }
    }

}
</code></pre>

<p><strong>Test case</strong></p>

<pre><code>class AthenaVSTests: XCTestCase {
    private var cancellables = Set&lt;AnyCancellable&gt;()
    private var service: RealmServiceType?

    override func setUp() {
        service = TestRealmService()
    }

    override func tearDown() {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
        service = nil
        cancellables.removeAll()
    }

    func testRealmPublisher() {
        var outcome = [""""]
        let expectation = self.expectation(description: #function)
        let expected = [""Tiddles"", ""Fang"", ""Phoebe"", ""Snowy""]

        let _ = service?.all(Patient.self)
            .sink(receiveCompletion: { _ in
                expectation.fulfill() },
                  receiveValue: { value in
                    outcome += value.map { $0.name }
            })
            .store(in: &amp;cancellables)

        waitForExpectations(timeout: 2, handler: nil)

        XCTAssert(outcome == expected, ""Expected \(expected) Objects but got \(outcome)"")
    }
}
</code></pre>

<p><strong>Error message</strong></p>

<p>failed to demangle witness for associated type 'Iterator' in conformance 'RealmSwift.Results: Sequence' from mangled name '10RealmSwift11RLMIteratorVyxG'
2020-01-13 22:46:07.159964+0000 AthenaVS[3423:171342] failed to demangle witness for associated type 'Iterator' in conformance 'RealmSwift.Results: Sequence' from mangled name '10RealmSwift11RLMIteratorVyxG'</p>

<p>The error is thrown when attempting to execute code in the Realm notification observer within RealmSubscription (I've flagged it in the code above), specifically:</p>

<pre><code>let _ = subscriber.receive(Array(collection.elements))
</code></pre>

<p>Ideas?</p>
","2733214","","","","","2020-01-16 16:27:56","Failed to demangle witness error when using Realm in a custom Publisher","<swift><realm><combine>","1","5","","","","CC BY-SA 4.0"
"59728852","1","59729053","","2020-01-14 06:58:52","","2","643","<p>@Published ObservedObjects SwiftUI Updates not Happening</p>

<p>I have created a very basic ObservableObject app and some bindings are updated
correctly and some are not. I must be missing something simple. Two views only - the
start view and a second view. I only use Text, Button and Toggle - just to test 
this concept.</p>

<p>I want to store startup property values in UserDefaults. That part seems to work
fine. When I make changes on the second page, they are updated on that page, and the
UserDefaults are correctly written. However, on returning to the start view, the
Published bindings are not updated. Interestingly, the UserDefaults are updated.</p>

<p>The main view simply displays the values of the bindings and user defaults. </p>

<p>The start view:</p>

<pre><code>import SwiftUI

struct ContentView: View {
    @State private var showUtilities = false
    @ObservedObject var userDefaultManager = UserDefaultsManager()

    var body: some View {
        NavigationView {
            VStack{
                Group { //group 1
                    Text(""Published userDefaultManager.name:"")
                    Text(""\(UserUtilities().makeSubString(stringIn: self.userDefaultManager.name, count: 24))"")
                        .padding(.bottom, 30)
                        .lineLimit(0)

                    Text(""UserDefaults.standard.value:"")
                    Text(""\(UserUtilities().makeSubString(stringIn: UserDefaults.standard.value(forKey: ""name"") as! String, count: 24))"")
                    .padding(.bottom, 30)
                    .lineLimit(0)

                    Text(""Published userDefaultsManager.enableBiometrics:"")
                    Text(String(self.userDefaultManager.enableBiometrics))
                        .padding(.bottom, 30)
                        .font(.headline)
                } //group 1

                Group { //group 2
                    Text(""UserDefaults.standard.bool:"")
                    Text(String(UserDefaults.standard.bool(forKey: AppDelegate.eb)))
                        .padding(.bottom, 30)
                        .font(.headline)
                    Button(action: {
                        self.showUtilities.toggle()
                    }) {
                        Text(""Show Utilities"")
                    }
                    .frame(width: 200)
                    .padding()
                    .font(.headline)
                }//group 2

            }//vstack
            .navigationBarTitle(""Read the Values"")
            .sheet(isPresented: $showUtilities) {
                UserUtilities()
            }
        }
    }
}
</code></pre>

<p>The second view: </p>

<pre><code>import SwiftUI
import Combine

struct UserUtilities: View {
    @ObservedObject var userDefaultManager = UserDefaultsManager()

    var body: some View {
        NavigationView {
            VStack {
                Toggle(isOn: self.$userDefaultManager.enableBiometrics) {
                    Text(""Enable Biometric Login"")
                }
                .padding(EdgeInsets(top: 50, leading: 50, bottom: 30, trailing: 50))

                //this does not update
                Text(""Published name is \(UserUtilities().makeSubString(stringIn: self.userDefaultManager.name, count: 24))"")
                    .padding(EdgeInsets(top: 0, leading: 0, bottom: 30, trailing: 0))

                Text(""UserDefaults name is \(UserUtilities().makeSubString(stringIn: UserDefaults.standard.value(forKey: ""name"") as! String, count: 24))"")
                    .padding(EdgeInsets(top: 0, leading: 0, bottom: 30, trailing: 0))

                \\this does not update
                Text(""Published enableBiometrics is ""  + String(self.userDefaultManager.enableBiometrics) )

                Text(""UserDefaults is "" + String(UserDefaults.standard.bool(forKey: AppDelegate.eb)) )
                    .padding(.bottom, 20)

                Button(action: {
                    self.userDefaultManager.name = UUID().uuidString
                }) {
                    Text(""Change the Published name"")
                }
                .padding()
                .font(.headline)

            }
            .navigationBarTitle(""User Utilities"", displayMode: .inline)
        }
    }//body

    func makeSubString(stringIn: String, count: Int) -&gt; String {
        if stringIn.count &gt; count {
            let modString = stringIn.dropFirst(count)
            let returnString = String(modString)
            return returnString
        }
        return ""can't get substring""
    }
}
</code></pre>

<p>My UserDefault Manager:</p>

<pre><code>import SwiftUI
import Combine

class UserDefaultsManager: ObservableObject {
    @Published var name = UserDefaults.standard.value(forKey: ""name"") as! String {
           didSet {
               UserDefaults.standard.set(self.name, forKey: ""name"")
           }
    }

    @Published var enableBiometrics: Bool = UserDefaults.standard.bool(forKey: AppDelegate.eb) {
        didSet {
            UserDefaults.standard.set(self.enableBiometrics, forKey: AppDelegate.eb)
        }
    }
}
</code></pre>

<p>And for completeness - in the AppDelegate:</p>

<pre><code>static let eb = ""enablebiometrics""
@ObservedObject var userDefaultManager = UserDefaultsManager()
</code></pre>

<p>In didFinishLaunchingWithOptions:</p>

<pre><code>    if UserDefaults.standard.value(forKey: AppDelegate.eb) == nil {
        UserDefaults.standard.set(false, forKey: AppDelegate.eb)
    }

    userDefaultManager.enableBiometrics = UserDefaults.standard.bool(forKey: AppDelegate.eb)

    if UserDefaults.standard.value(forKey: ""name"") == nil {
        UserDefaults.standard.set(""set in AppDelegate"", forKey: ""name"")
    }

    userDefaultManager.name = UserDefaults.standard.value(forKey: ""name"") as! String
</code></pre>

<p>Any guidance would be appreciated. Xcode 11.3 (11C29)</p>
","2698617","","286618","","2020-01-15 20:38:49","2020-01-15 20:38:49","@Published ObservedObjects SwiftUI Updates not Happening","<xcode><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"59743938","1","59829746","","2020-01-15 01:14:12","","31","8356","<p>How do I get the asynchronous pipelines that constitute the Combine framework to line up synchronously (serially)?</p>

<p>Suppose I have 50 URLs from which I want to download the corresponding resources, and let's say I want to do it one at a time. I know how to do that with Operation / OperationQueue, e.g. using an Operation subclass that doesn't declare itself finished until the download is complete. How would I do the same thing using Combine?</p>

<p>At the moment all that occurs to me is to keep a global list of the remaining URLs and pop one off, set up that one pipeline for one download, do the download, and in the <code>sink</code> of the pipeline, repeat. That doesn't seem very Combine-like.</p>

<p>I did try making an array of the URLs and map it to an array of publishers. I know I can ""produce"" a publisher and cause it to publish on down the pipeline using <code>flatMap</code>. But then I'm still doing all the downloading simultaneously. There isn't any Combine way to walk the array in a controlled manner — or is there?</p>

<p>(I also imagined doing something with Future but I became hopelessly confused. I'm not used to this way of thinking.)</p>
","341994","","","","","2021-03-22 15:15:32","Combine framework serialize async operations","<ios><swift><combine>","8","0","11","","","CC BY-SA 4.0"
"59752064","1","59798557","","2020-01-15 13:04:40","","2","56","<p>I would appreciate a practical advice how to handle this problem, because I'm completely lost.</p>

<p>I have a Contentview presenting a task for user and three button with options for answer. Choosing any of the options user gets immediate response whether the answer right or wrong and a new task immediately presented. As well as, there are three counter that counts general number of answered tasks per session, and respectively number of right and wrong answers per session.</p>

<p>Also I have a toggle that is responsible to fix one of condition for following tasks.</p>

<p>The problem is, that once I click this toggle it accepts a new value, but it is reflected on new task only after user answers old task.  Simply speaking it works only with the next task, though I would like the view updated to new task with this fixed condition immediately and task presented before toggling wouldn't be counted as an answer.</p>

<p><em>ContentView.swift</em></p>

<pre><code>    import SwiftUI
    import Combine

    struct ContentView: View {

        @EnvironmentObject var myVM: MyViewModel

        var body: some View {

            VStack (spacing: 5) {

                TitleView()

                Spacer()

                CountersAndToggleView()

                MainTaskView(numberOfPlayersInText: self.myVM.multiplayer, figureOne: self.myVM.figureOne, figureTwo: self.myVM.figureTwo)

                AnswerOptionsButtonsRow(option1: self.myVM.answerOpt_1, option2: self.myVM.answerOpt_2, option3: self.my.answerOpt_3, correctAnswer: self.my.correctAnswer)

         }
      }
</code></pre>

<p><em>CountersAndToggleView.swift</em></p>

<pre><code>    import SwiftUI
    import Combine

    struct CountersAndToggleView: View {

        @EnvironmentObject var myVM: MyViewModel


        var body: some View {
            HStack {
                VStack {

                        CounterView(counter: myVM.masterCounter, progressIndicatorColor: .gray, backGroundColor: .white)
                        HStack {
                        CounterView(counter: myVM.correctCounter, progressIndicatorColor: .green, backGroundColor: .white)
                        CounterView(counter: myVM.wrongCounter, progressIndicatorColor: .red, backGroundColor: .white)
                    }
                }

                Spacer()

                VStack {
                    Text(""Fix multiplayer"")
                        .font(.system(size: 15, design: .rounded))

                    VStack {

                        Toggle(""Multiplyer"", isOn: $myVM.multiplayerFixed)
                                .labelsHidden()
                        }                 
                }
            }
            .padding(.horizontal, 45)
        }
</code></pre>

<p><em>myViewModel.swift</em></p>

<pre><code>    import SwiftUI
    import Combine

    final class MyViewModel: ObservableObject {

        @Published var multiplayer: Int = 1

        @Published var figureOne: String = """"
        @Published var figureTwo: String = """"

        @Published var masterCounter = 0
        @Published var correctCounter = 0
        @Published var wrongCounter = 0

        @Published var multiplayerFixed: Bool = False

        init() {
             self.generateFigures()
             self.randomMultiplayer()
        }

        .... other functions
        }
</code></pre>

<p>I would like that once multiplayerFixed in CountersAndToggleView changed, the mainTaskView in ContentView would be fully updated assuming generations of new figures and value of multiplayer as it is fixed.</p>

<p>As I wrote, in reality it happens only after user answers previous task and push button.</p>

<p>Could you please advise what I do wrongly? and What should be changed?</p>

<p>Thank you in advance.</p>
","12714919","","12714919","","2020-01-18 07:54:47","2020-01-18 07:54:47","App do not update view immediately though the property has been changed","<ios><swift><mvvm><swiftui>","1","0","","","","CC BY-SA 4.0"
"59767427","1","59812117","","2020-01-16 10:19:10","","5","1872","<p>I am working with a web API which delivers results up to a given limit (<code>pageSize</code> parameter of the request). If the number of results surpasses this limit, the response message is pre-populated with an URL to which the follow-up request can be made to fetch more results. If there are even more results, this is again indicated in the same manner.</p>

<p>My intend is to fetch all results at once.</p>

<hr/>

<p>Currently I have something like the following request and response structures:</p>

<pre class=""lang-swift prettyprint-override""><code>// Request structure
struct TvShowsSearchRequest {
    let q: String
    let pageSize: Int?
}

// Response structure
struct TvShowsSearchResponse: Decodable {
    let next: String?
    let total : Int
    let searchTerm : String
    let searchResultListShow: [SearchResult]?
}
</code></pre>

<p>When resolving the problem '<strong>old style</strong>' using completion handlers, I had to write a handler, which is triggering a 'handle more' request with the URL of the response:</p>

<pre class=""lang-swift prettyprint-override""><code>func handleResponse(request: TvShowsSearchRequest, result: Result&lt;TvShowsSearchResponse, Error&gt;) -&gt; Void {
    switch result {
    case .failure(let error):
        fatalError(error.localizedDescription)
    case .success(let value):
        print(""&gt; Total number of shows matching the query: \(value.total)"")
        print(""&gt; Number of shows fetched: \(value.searchResultListShow?.count ?? 0)"")

        if let moreUrl = value.next {
            print(""&gt; URL to fetch more entries \(moreUrl)"")

            // start recursion here: a new request, calling the same completion handler...
            dataProvider.handleMore(request, nextUrl: moreUrl, completion: handleResponse)
        }
    }
}

let request = TvShowsSearchRequest(query: ""A"", pageSize: 50)
dataProvider.send(request, completion: handleResponse)
</code></pre>

<p>Internally the <code>send</code> and <code>handleMore</code> functions are both calling the same <code>internalSend</code> which is taking the <code>request</code> and the <code>url</code>, to call afterwards <code>URLSession.dataTask(...)</code>, check for HTTP errors, decode the response and call the completion block.</p>

<hr/>

<p>Now I want to use the Combine framework and use a Publisher which is providing the paged responses automatically, without the need to call for another Publisher.</p>

<p>I have therefore written a <code>requestPublisher</code> function which takes <code>request</code> and the (initial) <code>url</code> and returns a <code>URLSession.dataTaskPublisher</code> which checks for HTTP errors (using <code>tryMap</code>), <code>decode</code> the response.</p>

<p>Now I have to ensure that the Publisher automatically ""renews"" itself whenever the last emitted value had a valid <code>next</code> URL and the completion event occurs.</p>

<p>I've found that there is a <code>Publisher.append</code> method which would exactly do this, but the problem I had so far: I want to append only under a certain condition (=valid <code>next</code>).</p>

<p>The following pseudo-code illustrates it:</p>

<pre class=""lang-swift prettyprint-override""><code>func requestPublisher(for request: TvShowsSearchRequest, with url: URL) -&gt; AnyPublisher&lt;TvShowsSearchResponse, Error&gt; {
    // ... build urlRequest, skipped here ...

    let apiCall = self.session.dataTaskPublisher(for: urlRequest)
        .tryMap { data, response -&gt; Data in
            guard let httpResponse = response as? HTTPURLResponse else {
                throw APIError.server(message: ""No HTTP response received"")
            }
            if !(200...299).contains(httpResponse.statusCode) {
                throw APIError.server(message: ""Server respondend with status: \(httpResponse.statusCode)"")
            }
            return data
        }
        .decode(type: TvShowsSearchResponse.self, decoder: JSONDecoder())
        .eraseToAnyPublisher()
    return apiCall
}


// Here I'm trying to use the Combine approach

var moreURL : String?

dataProvider.requestPublisher(request)
    .handleEvents(receiveOutput: {
        moreURL = $0.next   // remember the ""next"" to fetch more data
    })
    .append(dataProvider.requestPublisher(request, next: moreURL))  // this does not work, because moreUrl was not prepared at the time of creation!!
    .sink(receiveCompletion: { print($0) }, receiveValue: { print($0) })
    .store(in: &amp;cancellableSet)
</code></pre>

<p>I suppose there are people out there who have already resolved this problem in a reactive way. Whenever I find a doable solution, it involves again recursion. I don't think this is how a proper solution should look like.</p>

<p>I'm looking for a Publisher which is sending the responses, without me providing a callback function. Probably there must be a solution using Publisher of Publishers, but I'm not yet understanding it.</p>

<hr/>

<p>After the comment of @kishanvekariya I've tried to build everything with multiple publishers:</p>

<ol>
<li><p>The <code>mainRequest</code> publisher which is getting the response to the ""main"" request.</p></li>
<li><p>A new <code>urlPublisher</code> which is receiving all the <code>next</code> URLs of the ""main"" or any follow-up requests.</p></li>
<li><p>A new <code>moreRequest</code> publisher which is fetching for each value of <code>urlPublisher</code> a new request, sending all <code>next</code> URLs back to the <code>urlPublisher</code>.</p></li>
</ol>

<p>Then I tried to attach the <code>moreRequest</code> publisher to the <code>mainRequest</code>  with <code>append</code>.</p>

<pre class=""lang-swift prettyprint-override""><code>var urlPublisher = PassthroughSubject&lt;String, Error&gt;()

var moreRequest = urlPublisher
    .flatMap {
        return dataProvider.requestPublisher(request, next: $0)
            .handleEvents(receiveOutput: {
                if let moreURL = $0.next {
                    urlPublisher.send(moreURL)
                }
            })
    }

var mainRequest = dataProvider.requestPublisher(request)
    .handleEvents(receiveOutput: {
        if let moreURL = $0.next {
            urlPublisher.send(moreURL)
        }
    })
    .append(moreRequest)
    .sink(receiveCompletion: { print($0) }, receiveValue: { print($0) })
    .store(in: &amp;cancellableSet)
</code></pre>

<p>But this still does not work... I always get the result of the ""main"" request. All follow up requests are missing.</p>
","6238009","","6238009","","2020-01-16 20:54:57","2021-09-23 06:00:43","What Combine operator/approach can be used to load all pages of ""paged API""?","<ios><swift><combine>","2","3","0","","","CC BY-SA 4.0"
"59773295","1","59776960","","2020-01-16 15:48:02","","16","7098","<p>I was trying to use the SwiftUI <code>@Environment</code> property wrapper, but I can't manage to make it work as I expected. Please, help me understanding what I'm doing wrong. </p>

<p>As an example I have an object that produces an integer once per second:</p>

<pre><code>class IntGenerator: ObservableObject {
    @Published var newValue = 0 {
        didSet {
            print(newValue)
        }
    }

    private var toCanc: AnyCancellable?

    init() {
        toCanc = Timer.TimerPublisher(interval: 1, runLoop: .main, mode: .default)
            .autoconnect()
            .map { _ in Int.random(in: 0..&lt;1000) }
            .assign(to: \.newValue, on: self)
    }
}
</code></pre>

<p>This object works as expected since I can see all the integers generated on the console log. Now, let's say we want this object to be an environment object accessible from all over the app and from whoever. Let's create the related environment key:</p>

<pre><code>struct IntGeneratorKey: EnvironmentKey {
    static let defaultValue = IntGenerator()
}

extension EnvironmentValues {
    var intGenerator: IntGenerator {
        get {
            return self[IntGeneratorKey.self]
        }
        set {
            self[IntGeneratorKey.self] = newValue
        }
    }
}
</code></pre>

<p>Now I can access this object like this (for example from a view):</p>

<pre><code>struct TestView: View {
    @Environment(\.intGenerator) var intGenerator: IntGenerator

    var body: some View {
        Text(""\(intGenerator.newValue)"")
    }
}
</code></pre>

<p>Unfortunately, despite the <code>newValue</code> being a <code>@Published</code> property I'm not receiving any update on that property and the <code>Text</code> always shows 0. I'm sure I'm missing something here, what's going on? Thanks.</p>
","1291872","","","","","2022-06-30 06:47:17","SwiftUI: observe @Environment property changes","<ios><swift><swiftui>","3","3","7","","","CC BY-SA 4.0"
"59779962","1","59811596","","2020-01-17 01:13:06","","3","847","<p>The declarative syntax of Swift Combine looks odd to me and it appears that there is a lot going on that is not visible.</p>

<p>For example the following code sample builds and runs in an Xcode playground:</p>

<pre><code>[1, 2, 3]

.publisher
.map({ (val) in
        return val * 3
    })

.sink(receiveCompletion: { completion in
  switch completion {
  case .failure(let error):
    print(""Something went wrong: \(error)"")
  case .finished:
    print(""Received Completion"")
  }
}, receiveValue: { value in
  print(""Received value \(value)"")
})
</code></pre>

<p>I see what I assume is an array literal instance being created with [1, 2, 3].  I guess it is an array literal but I'm not accustomed to seeing it ""declared"" without also assigning it to a variable name or constant or using _=.</p>

<p>I've put in an intentional new line after and then .publisher.  Is Xcode ignoring the whitespace and newlines?  </p>

<p>Because of this style, or my newness to visually parsing this style, I mistakenly thought "", receiveValue:"" was a variadic parameter or some new syntax, but later realized it is actually an argument to .sink(...).</p>
","2246630","","2246630","","2020-01-18 00:42:59","2020-01-19 15:37:18","swift combine declarative syntax","<swift><variadic><combine>","2","2","","","","CC BY-SA 4.0"
"59787109","1","59797226","","2020-01-17 12:10:51","","3","2216","<p>I use the following piece of code to generate a cold <code>RxSwift Observable</code>:</p>

<pre><code>func doRequest&lt;T :Mappable&gt;(request:URLRequestConvertible) -&gt; Observable&lt;T&gt; {
        let observable = Observable&lt;T&gt;.create { [weak self] observer in
        guard let self = self else { return Disposables.create() }
        self.session.request(request).validate().responseObject { (response: AFDataResponse&lt;T&gt;) in
            switch response.result {
                case .success(let obj):
                    observer.onNext(obj)
                    observer.onCompleted()
                case .failure(let error):
                    let theError = error as Error
                    observer.onError(theError)
            }
        }
         return Disposables.create()
    }
    return observable
}
</code></pre>

<p>where <code>Mappable</code> is an <a href=""https://github.com/tristanhimmelman/ObjectMapper"" rel=""nofollow noreferrer"">ObjectMapper</a> based type, and <code>self.session</code> is an Alamofire's <code>Session</code> object.</p>

<p>I can't find an equivalent to <code>Observable.create {...}</code> in Apple's <code>Combine</code> framework. What I only found is <code>URLSession.shared.dataTaskPublisher(for:)</code> which creates a publisher using Apple's <code>URLSession</code> class.</p>

<p>How can I convert the above observable to an Alamofire Combine's publisher ?</p>

<p><strong>EDIT</strong>:
using the solution provided by rob, I ended up with the following:</p>

<pre><code> private let apiQueue = DispatchQueue(label: ""API"", qos: .default, attributes: .concurrent)

  func doRequest&lt;T&gt;(request: URLRequestConvertible) -&gt; AnyPublisher&lt;T, AFError&gt; where T : Mappable {

       Deferred { [weak self] () -&gt; Future&lt;T, AFError&gt; in

          guard let self = self else {
              return Future&lt;T, AFError&gt; { promise in  
promise(.failure(.explicitlyCancelled))  }
        }

          return Future { promise in
            self.session
            .request(request)
            .validate()
            .responseObject { (response: AFDataResponse&lt;T&gt;) in
                promise(response.result)
            }
        }
    }
    .handleEvents(receiveCompletion: { completion in
        if case .failure (let error) = completion {
                //handle the error
        }
    })
    .receive(on: self.apiQueue)
    .eraseToAnyPublisher()
}
</code></pre>

<p><strong>EDIT2:</strong> I have to remove the private queue since it's not needed, Alamofire does the parsing the decoding on its own, so remove the queue and its usages (<code>.receive(on: self.apiQueue)</code>)</p>
","1056118","","1056118","","2020-01-22 05:06:09","2020-01-22 05:06:09","Creating a Combine's publisher like RxSwift's Observable.Create for an Alamofire request","<ios><swift><alamofire><rx-swift><combine>","1","1","","","","CC BY-SA 4.0"
"59792756","1","59793389","","2020-01-17 18:06:26","","5","3212","<p>I'm trying to write a custom Combine <code>Publisher</code> that will send decibel and timestamps from an <code>AVAudioEngine</code> tap. After going through numerous tutorials and the WWDC videos, I <em>still</em> can't find an example of how a <code>Publisher</code> keeps track of the <code>Subscriber</code>s that have subscribed to it.</p>

<pre><code>public typealias AudioVolume = Double

public struct AudioVolumePublisher: Publisher {
    public typealias Output = AudioVolume
    public typealias Failure = Error
}

public class AudioVolumeSubscription&lt;S: Subscriber&gt;: NSObject, Subscription {
    private var subscriber: S?
    public var combineIdentifier = CombineIdentifier()

    public init(for subscriber: S) {
        self.subscriber = subscriber
    }

    public func request(_ demand: Subscribers.Demand) {
        ...
    }

    public func cancel() {
        subscriber = nil
    }
}

</code></pre>

<p>I assume that the <code>AudioVolumePublisher</code> should store a list of its active subscribers, but adding a property like</p>

<pre><code>var subscribers = [S]()
</code></pre>

<p>won't compile because <code>Subscriber</code> has associated types. Is this even the right approach to handling <code>Subscriber</code>s, and if so, what's the best way to store them? Is type erasure my only practical option?</p>
","665456","","665456","","2020-01-17 18:20:52","2020-01-17 20:08:21","Swift Combine custom Publisher: Storing a reference to an array of Subscribers?","<swift><combine>","1","1","2","","","CC BY-SA 4.0"
"59800861","1","59800885","","2020-01-18 13:03:50","","1","1148","<p>I have a strange problem with the SwiftUI Alert view. In an ObservableObject, I do some network requests and in case of a error I will show a alert. This is my simplified model:</p>

<pre class=""lang-swift prettyprint-override""><code>class MyModel: ObservableObject {
    let objectWillChange = ObservableObjectPublisher()

    @Published var isError: Bool = false

    public func network() {
        Service.call() {
            self.isError = true

            DispatchQueue.main.async {
                self.objectWillChange.send()
            }
        }
    }
}
</code></pre>

<p><code>Service.call</code> is a dummy for my network request. My view looks like:</p>

<pre class=""lang-swift prettyprint-override""><code>struct MyView: View {
    @ObservedObject var model: MyModel

    var body: some View {
        …
        .alert(isPresented: self.$model.isError) {
            print(""Error Alert"")
            return Alert(title: Text(""Alert""))
        }
    }
}
</code></pre>

<p>On the first call, everything works and the alert is shown. For all further calls,<code>print(""Error Alert"")</code> will be executed and <em>Error Alert</em> appears in the console, but the alert is not shown.</p>

<p>Does anyone have any idea why Alert is only shown once?</p>
","3941413","","3941413","","2020-01-18 13:25:31","2020-01-18 13:45:18","SwiftUI – Alert is only showing once","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"59809842","1","59827709","","2020-01-19 12:04:28","","2","809","<p>I'm currently building a SwiftUI app and used a networking library from github (<a href=""https://github.com/borchero/Squid"" rel=""nofollow noreferrer"">GitHub/Squid</a>) to implement the api calls. </p>

<p>It works fine except when the request fails, then the library internal debug messages indicate an error (404 in my test), but the Combine subscriber never receives a completion signal. </p>

<p>I created a new request that will try to fetch and decode the users of ""jsonplaceholder.typicode.com"".</p>

<pre><code>import Foundation
import Squid

struct GetUsersFromMockApiRequest: JsonRequest {
    typealias Result = [User]

    var routes: HttpRoute {
        [""users""]
    }
}
</code></pre>

<p>User is just a simple struct: </p>

<pre><code>struct User: Decodable {
    let id: Int
    let username: String
    let name: String
}
</code></pre>

<p>In my ApiRequestManager.swift file I declared a function to request the scheduling:</p>

<pre><code>public func getUsersFromMockApi() -&gt; Response&lt;GetUsersFromMockApiRequest&gt; {
    return GetUsersFromMockApiRequest().schedule(with: ApiService(apiUrl: ""jsonplaceholder.typicode.com""))
}
</code></pre>

<p>And in my view where I want to call the api, I have a cancellable set and a instance of the ApiRequestManager.</p>

<pre><code>@State private var cancellableSet: Set&lt;AnyCancellable&gt; = []
private let requestManager = ApiRequestManager()
</code></pre>

<p>Now the last step is to call a function on the press of a button which executes the following code:</p>

<pre><code>self.requestManager.getUsersFromMockApi()
  .print(""Debug:"")
  .sink(receiveCompletion: { completion in
    switch completion {
    case .failure:
      print(""ApiCall failed."")
    case .finished:
      print(""ApiCall finished."")
    }
  }) { result in
    print(""Received users from apiCall: \(result)"")
  }
  .store(in: &amp;cancellableSet)
</code></pre>

<p>If the api request is sucessfull, everything works out fine. But as soon as it hits any error the sink will get any signals / completion at all.</p>

<p>I tried to print every message that the subscriber received, breakOnError and also followed the library step by step to find out if he even throws an error. It does correctly check the HTTP response code against the accepted status codes in the schedule() function in the NetworkScheduler.swift file and throws a custom error <code>throw Squid.Error.requestFailed(statusCode: statusCode, response: response.data)</code> on line 285.</p>

<p>However with my lacking debug and combine knowledge I have a hard time following the throw afterwards. </p>
","12741764","","12741764","","2020-01-19 12:10:40","2020-01-20 16:47:23","Combine sink does not complete when publisher fails","<network-programming><swiftui><combine>","1","0","0","","","CC BY-SA 4.0"
"59829402","1","59970789","","2020-01-20 18:58:49","","1","683","<p>I have the following Problem:</p>

<pre><code>struct Item {
    var foo: Int

    init(_ iFoo: Int = 0){
        self.foo = iFoo
    }
}

class TestObject {
    @Published var items = [Item(1), Item(2), Item(3), Item(4)]

    private var avg:Double = 0.0{
        didSet{
            print(""didSet: avg: '\(self.avg)'"")
        }
    }

    private var cancellableSet: Set&lt;AnyCancellable&gt; = []
    private var isItemChangedPublisher: AnyPublisher&lt;[Item], Never&gt;{
        self.$items
            .eraseToAnyPublisher()
    }

    init(){
        self.isItemChangedPublisher
            .map{ items in
                var sum = 0
                for item in items{
                    sum += item.foo
                }
                return Double(sum)/Double(items.count)}
            .assign(to: \.avg, on: self)
            .store(in: &amp;cancellableSet)
    }

    func changeItem(at index: Int, to value: Int){
        if self.items.count &lt; index{
            self.items.append(Item(value))
        }else{
            self.items[index].foo = value
        }
    }

    func getAvg() -&gt; Double{
        //Request: Items changed --&gt; Change Value of avg here
        //Set Value of avg only if items has changed AND ""Request"" is called
        //  - don't set the new Value if Items has not changed and ""Request"" is called
        //  - don't set the new Value if Items has changed, but ""Request"" is not called
        return self.avg
    }
}

var bar = TestObject()

bar.changeItem(at: 2, to: 20)
bar.changeItem(at: 0, to: 3)

print(""1. avg: '\(bar.getAvg())'"")

bar.changeItem(at: 2, to: 20)

print(""2. avg: '\(bar.getAvg())'"")

bar.changeItem(at: 2, to: 30)

print(""3. avg: '\(bar.getAvg())'"")

bar.changeItem(at: 2, to: 20)
</code></pre>

<p>The Value of <code>var avg</code> is set every Time I change the items-Array. I understand that this is the intended behavior. </p>

<p>But is there any way to update the Variable <code>avg</code> only if the items-Array has changed AND something like a ""Request"" is called. 
If only the items have been changed the Variable <code>avg</code> should not be update, also if only the ""Request"" is called, but no items have been changed, the Variable shouldn't be updated.</p>

<p>I don't have any clue how to do this.</p>

<p>Do you have any idea to do this with the combine framework or with another solution?</p>

<p>Edit - 23.Jan.2020:</p>

<p>I could do something like that:</p>

<pre><code>import Combine

struct Item: Equatable {
    var foo: Int

    init(_ iFoo: Int = 0){
        self.foo = iFoo
    }
}

class TestObject {
    @Published var items = [Item(1), Item(2), Item(3), Item(4)]

    private var newAverage: Double? {
        didSet{
            print(""didSet: items changed --&gt; newAverage: '\(String(describing: self.newAverage))'"")
        }
    }

    private var average:Double = 0.0{
        didSet{
            print(""didSet: average: '\(self.average)'"")
        }
    }

    private var cancellable: AnyCancellable?
    private var isItemChangedPublisher: AnyPublisher&lt;[Item], Never&gt;{
        self.$items
            .eraseToAnyPublisher()
    }

    init(){
        cancellable = self.isItemChangedPublisher
            .removeDuplicates()
            .map{Double($0.map{$0.foo}.reduce(0, +))/Double($0.count)}
            .sink{self.newAverage = $0}
    }

    func changeItem(at index: Int, to value: Int){
        if self.items.count &lt; index{
            self.items.append(Item(value))
        }else{
            self.items[index].foo = value
        }
    }

    func getAverage() -&gt; Double{
        if self.newAverage != nil{
            self.average = self.newAverage!
            self.newAverage = nil
        }
        return self.average
    }
}

var bar = TestObject()

bar.changeItem(at: 2, to: 20)
bar.changeItem(at: 0, to: 20)
print(""1. avg: '\(bar.getAverage())'"")
bar.changeItem(at: 1, to: 20)
print(""2. avg: '\(bar.getAverage())'"")
bar.changeItem(at: 1, to: 20)
print(""3. avg: '\(bar.getAverage())'"")
bar.changeItem(at: 3, to: 20)

/*
 prints:
 didSet: items changed --&gt; newAverage: 'Optional(2.5)'
 didSet: items changed --&gt; newAverage: 'Optional(6.75)'
 didSet: items changed --&gt; newAverage: 'Optional(11.5)'
 didSet: average: '11.5'
 didSet: items changed --&gt; newAverage: 'nil'
 1. avg: '11.5'
 didSet: items changed --&gt; newAverage: 'Optional(16.0)'
 didSet: average: '16.0'
 didSet: items changed --&gt; newAverage: 'nil'
 2. avg: '16.0'
 3. avg: '16.0'
 didSet: items changed --&gt; newAverage: 'Optional(20.0)'
 */
</code></pre>

<p>But, I'm still looking for a solution with combine only (without the dirty solution with the <code>newAverage</code> variable).</p>

<p>I also tried a solution with a custom DispatchQueue (it is just an attempt, not a good solution or idea):</p>

<pre><code>import Combine
import SwiftUI

struct Item: Equatable {
    var foo: Int

    init(_ iFoo: Int = 0){
        self.foo = iFoo
    }
}

struct MyQueue {
//    let queue = DispatchQueue(label: ""myQueue"", attributes: .concurrent, target: .global())
    let queue = DispatchQueue(label: ""myQueue"")

    init(){
        self.queue.suspend()
    }

    func releaseData(){
        self.queue.resume()
        self.queue.suspend()
    }
}

class TestObject {
    @Published var items = [Item(1), Item(2), Item(3), Item(4)]

    private var average:Double = 0.0{
        didSet{
            print(""didSet: average: '\(self.average)'"")
        }
    }

    private var cancellable: AnyCancellable?
    let myQueue = MyQueue()
    private var isItemChangedPublisher: AnyPublisher&lt;[Item], Never&gt;{
        self.$items
            .eraseToAnyPublisher()
    }

    init(){
        cancellable = self.isItemChangedPublisher
            .removeDuplicates()
            .map{ items in
                Double(items.map{ $0.foo }.reduce(0, +))/Double(items.count)}
            .buffer(size: 1, prefetch: .keepFull, whenFull: .dropOldest) //The Buffer changes nothing
            .receive(on: self.myQueue.queue)
            .assign(to: \.average, on: self)
    }

    func changeItem(at index: Int, to value: Int){
        if self.items.count &lt; index{
            self.items.append(Item(value))
        }else{
            self.items[index].foo = value
        }
    }

    func getAverage() -&gt; Double{
        self.myQueue.releaseData()
        return self.average
    }
}
var bar = TestObject()

bar.changeItem(at: 2, to: 20)
bar.changeItem(at: 0, to: 20)
print(""1. avg: '\(bar.getAverage())'"")
bar.changeItem(at: 1, to: 20)
print(""2. avg: '\(bar.getAverage())'"")
bar.changeItem(at: 1, to: 20)
print(""3. avg: '\(bar.getAverage())'"")
bar.changeItem(at: 3, to: 20)

/*
 Prints:

 didSet: average: '2.5'
 1. avg: '2.5'
 didSet: average: '6.75'
 didSet: average: '11.5'
 2. avg: '11.5'
 didSet: average: '16.0'
 3. avg: '16.0'


 But im looking for:

 didSet: average: '11.5' (because 2.5 and 6.5 are dropped)
 1. avg: '11.5'
 didSet: average: '16.0'
 2. avg: '16.0'
 3. avg: '16.0'
 */
</code></pre>

<p>but that doesn't work either...</p>
","12523385","","8160252","","2020-01-29 17:51:53","2020-01-31 09:37:35","Change Variable only if other Variables have changed and Update is requested","<ios><swift><combine>","1","4","0","","","CC BY-SA 4.0"
"59852494","1","59852665","","2020-01-22 04:10:23","","0","244","<p>i try to replace the addObserver method with Notification publisher
But i cant make it work , hope someone can help </p>

<p>i try to setup the publisher under viewDidLoad and receive notification from another swiftui . Since i cant make it work ,So I make it under viewWillAppear within the same swift file for debugging . In the below coding , I can only receive it from the old school method and the method from viewWillAppear not from the viewDidLoad . The setup in viewDidLoad not working and if i miss out let temp2 = under viewWillAppear , it didnt work too . Is that a bugs for combine?</p>

<p>Result is 
BBBB
CCCC</p>

<pre><code>    override func viewDidLoad() {
    super.viewDidLoad()

    NotificationCenter.default.addObserver(forName: .dismissSwiftUI, object: nil, queue: .main) { (_) in
        print(""BBBB"")
    }
    let abc = NotificationCenter.default.publisher(for: .dismissSwiftUI).sink { (_) in
        print(""AAAA"")
    }
}


override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
    //        self.checkIfProfitSetup()
    let temp2 = NotificationCenter.default.addObserver(forName: .dismissSwiftUI, object: nil, queue: .main) { (_) in
        print(""CCCC"")
    }

    NotificationCenter.default.post(name: .dismissSwiftUI ,object: nil)
}
</code></pre>
","2598401","","","","","2020-01-22 04:33:41","Combine: Problem when replace addObserver with Notification publisher","<combine>","1","0","","","","CC BY-SA 4.0"
"59868393","1","59868521","","2020-01-22 21:18:15","","4","10103","<p>I've implemented a List with a search bar in SwiftUI. Now I want to implement paging for this list. When the user scrolls to the bottom of the list, new elements should be loaded. My problem is, how can I detect that the user scrolled to the end? When this happens I want to load new elements, append them and show them to the user.</p>

<p>My code looks like this:</p>

<pre><code>import Foundation
import SwiftUI

struct MyList: View {
    @EnvironmentObject var webService: GetRequestsWebService

    @ObservedObject var viewModelMyList: MyListViewModel

    @State private var query = """"

    var body: some View {

        let binding = Binding&lt;String&gt;(
            get: { self.query },
            set: { self.query = $0; self.textFieldChanged($0) }
        )

        return NavigationView {
            // how to detect here when end of the list is reached by scrolling?
            List {
                // searchbar here inside the list element
                TextField(""Search..."", text: binding) {
                    self.fetchResults()
                }

                ForEach(viewModelMyList.items, id: \.id) { item in
                    MyRow(itemToProcess: item)
                }
            } 
            .navigationBarTitle(""Title"")
        }.onAppear(perform: fetchResults)

    }

    private func textFieldChanged(_ text: String) {        
        text.isEmpty ? viewModelMyList.fetchResultsThrottelt(for: nil) : viewModelMyList.fetchResultsThrottelt(for: text)
    }

    private func fetchResults() {
        query.isEmpty ? viewModelMyList.fetchResults(for: nil) : viewModelMyList.fetchResults(for: query)
    }
}
</code></pre>

<p>Also a little bit special this case, because the list contains the search bar. I would be thankful for any advice because with this :).</p>
","4017243","","","","","2020-08-20 16:49:41","SwiftUI pagination for List object","<ios><swift><list><swiftui><combine>","3","0","3","","","CC BY-SA 4.0"
"59880753","1","59881488","","2020-01-23 14:23:08","","0","343","<p>I am trying to figure out a way to insert multiple arrays of views in a VStack in SwiftUI using <code>collect()</code> operator. </p>

<pre><code>struct ChatsTab: View {
    var subscriptions = Set&lt;AnyCancellable&gt;()
    var body: some View {
        VStack {
            [""A"", ""B"", ""C"", ""D"", ""E""].publisher.collect(2).sink(receiveCompletion: { _ in
                // Do nothing on completion
            }) { (stringArray) in
                HStack {
                    Text(stringArray[0])
                    Text(stringArray[1])
                }
            }
        .store(in: &amp;subscriptions)
        }
    }
}
</code></pre>

<p>But I'm getting this below error: </p>

<pre><code>Cannot convert value of type '()' to closure result type '_'
</code></pre>

<p>I want to do this with <code>collect</code> only so I can add my text views in pair. I know I have other options but I want to get it done with <code>collect</code> only.</p>
","10678413","","","","","2020-01-23 15:03:57","How to create views in SwiftUI using collect","<swift><swiftui><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"59925393","1","59937796","","2020-01-27 05:08:00","","0","315","<p>I have an <code>ObservedObject</code> that I pass values into based on user inputs from the form's <code>TextFields</code>.  However, I want the user to have the option to use CoreLocation.  When they change the toggle, I want the input value for one of the <code>TextFields</code> to switch to my <code>CoreLocation</code> publisher.  Here are the code snippets:</p>

<pre><code>@EnvironmentObject var locationManager: LocationManager
@ObservedObject var calculator: CalculatorObject
@State var useGPS: Bool = false

if self.useGPS {
   //I'm not sure what to put here
   //I’ve tried several options to set the binding element of the
   //   CalculatorObject to the speed object of the
   //   locationManager but they don’t change the values within
   //   the calculations. 
}

var body: Some View {
    VStack {
       Toggle(isOn: $useGPS) {
          Text(""Use GPS for Ground Speed"")
       }

       if useGPS {
          Text(locationManager.locationInfo.speed)
       } else {
          TextField(""Ground Speed"", text: self.$calculator.groundSpeed)
       }
    }
}
</code></pre>

<p>I have tried a number of different options, but I cannot seem to get the data from the location manager to pass it's data to the <code>CalculatorObject.</code> I have verified that when I change the toggle, the UI <em>is</em> showing the changing speed, so I am sure that the location publisher is working. I'm not clear on how to change the binding source here.</p>
","9701514","","7271020","","2020-01-27 06:44:11","2020-01-27 19:39:39","How do I change an object's binding source based on a boolean (SwiftUI)?","<swift><swiftui><core-location><combine>","2","0","0","","","CC BY-SA 4.0"
"59948428","1","59949936","","2020-01-28 12:07:21","","0","122","<p>I have an observable object with two properties</p>

<pre><code>class Demo: ObservableObject {
  @Published var propertyA: Bool
  @Published var propertyB: Bool
}
</code></pre>

<p>Now I want to add a derived property ""propertyC"" that is ""true"" if both propertyA and propertyB are true.</p>

<p>I found similar questions with answers that didn't satisfy me. I'm looking for a solution that uses the Combine Framework and not a ""didSet"" method as my real world project computes the derived property from more than two other properties.</p>

<p>When I'm using the derived propertyC in a SwiftUI view it should trigger a refresh whenever propertyA or propertyB changes even if I don't use those in the view. </p>
","10826194","","","","","2022-06-27 06:15:22","How to implement derived property using Combine?","<swift><combine>","2","6","","","","CC BY-SA 4.0"
"59972398","1","59977197","","2020-01-29 17:20:05","","1","1887","<p>iOS 13, Swift 5, Xcode 11.3.1</p>

<p>Learning SwiftUI. I put this together, and it works, but is it correct.</p>

<p>In <strong>External.swift</strong></p>

<pre><code>class BlobModel: ObservableObject {
  @Published var score: String = """" 
}

var globalBlob = BlobModel()
</code></pre>

<p>In <strong>ContentView.swift</strong></p>

<pre><code>struct ContentView: View {

@ObservedObject var globalBlob:BlobModel

var body: some View {
  Text(""\(globalBlob.score)"")
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
      ContentView(globalBlob: globalBlob)
    }
}
</code></pre>

<p>When I write to the globalBlob in <strong>External.swift</strong> it updates the display. </p>

<pre><code>globalBlob.score = backToString
</code></pre>

<p>But globalBlob is a global variable, which is surely poor coding practice. Is there a better way I should have done this?</p>
","3069232","","3069232","","2020-01-29 18:36:26","2020-01-29 23:43:08","SwiftUI setting up external variables that will trigger a view refresh","<swift><global-variables><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"59990481","1","59994211","","2020-01-30 16:33:06","","0","122","<p>I'm relatively new to the Functional Reactive programming world, and still trying to wrap my head around the concepts. I'm utilizing an SDK to make some network requests - specifically to query a remote database. The SDK returns a publisher, and I have a working pipeline that transforms that result into model objects. Here's that working pipeline:</p>

<pre><code>let existingClaimQuery = ""SELECT Id, Subject, CaseNumber FROM Case WHERE Status != 'Closed' ORDER BY CaseNumber DESC""
let requestForOpenCases = RestClient.shared.request(forQuery: existingClaimQuery, apiVersion: RestClient.apiVersion)
caseCancellable = RestClient.shared
  .publisher(for: requestForOpenCases)
  .receive(on: RunLoop.main)
  .tryMap({restresponse -&gt; [String:Any] in
    let json = try restresponse.asJson() as? [String:Any]
    return json ?? RestClient.JSONKeyValuePairs()
  })
  .map({json -&gt; [[String:Any]] in
    let records = json[""records""] as? [[String:Any]]
    return records ?? [[:]]
  })
  .map({
    $0.map{(item) -&gt; Claim in
      return Claim(
        id: item[""Id""] as? String ?? ""None Listed"",
        subject: item[""Subject""] as? String ?? ""None Listed"",
        caseNumber: item[""CaseNumber""] as? String ?? ""0""
      )
    }
  })
  .mapError{error -&gt; Error in
    print(error)
    return error
  }
  .catch{ error in
    return Just([])
  }
.assign(to: \.claims, on: self)
</code></pre>

<p>I went to work on another section of the code, and realized I <em>often</em> need to do this same process - write a query, create a request for that query, and process it through a pipeline that ultimately returns a [[String:Any]]. </p>

<p>So here's the million dollar question. What's the <em>right</em> way to encapsulate this pipeline such that I can re-use it without having to copy/pasta the entire pipeline all over the code base? This is my ... attempt at it, but it feels ...wrong?</p>

<pre><code>class QueryStream: ObservableObject {

  var query: String = """"
  private var queryCancellable: AnyCancellable?

  @Published var records: [[String:Any]] = [[String:Any]]()

  func execute(){
    let queryRequest = RestClient.shared.request(forQuery: query, apiVersion: RestClient.apiVersion)

    queryCancellable = RestClient.shared.publisher(for: queryRequest)
      .receive(on: RunLoop.main)
      .tryMap({restresponse -&gt; [String:Any] in
        let json = try restresponse.asJson() as? [String:Any]
        return json ?? [String:Any]()
      })
      .map({json -&gt; [[String:Any]] in
        let records = json[""records""] as? [[String:Any]]
        return records ?? [[:]]
      })
      .mapError{error -&gt; Error in
        print(error)
        return error
      }
      .catch{ error in
        return Just([])
      }
    .assign(to: \.records, on: self)
  }

}
</code></pre>

<p>This still requires a pipeline to be written for each use. I feel like there should be some way to have a one off promise like pipeline that would allow for </p>

<pre><code>let SomeRecords = QueryStream(""Query here"").execute()
</code></pre>

<p>Am I too n00b? overthinking it? What's the stack's wisdom?</p>
","1132573","","","","","2020-01-31 22:43:53","What's the proper method for creating re-usable pipelines with Combine?","<swift><combine>","2","1","","","","CC BY-SA 4.0"
"60017564","1","60019566","","2020-02-01 13:59:10","","6","1253","<p>I have a LoginView that shows a RegisterView if the user is not logged in, and a ContentView if he is logged in:</p>

<pre><code>struct LoginView: View {
    @EnvironmentObject var userManager: UserManager
    var body: some View {
        Group {
            if userManager.isRegistered {
                ContentView()
            } else {
                RegisterView()
            }
        }
    }
}
</code></pre>

<p><code>ContentView</code> have three <code>ObservedObject</code> properties, that uses combine to fetch content from a server with rest api's.</p>

<pre><code>struct ContentView: View {
    @EnvironmentObject var userManager: UserManager
    @ObservedObject var usersStore = UsersStore()
    @ObservedObject var rolesStore = RolesStore()
    @ObservedObject var elementsStore = ElementsStore()

    var body: some View {
        NavigationView {
            ZStack {
                Image(""stell"")
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .opacity(0.1)

                VStack(alignment: .leading, spacing: 5) {
                    NavigationLink(destination: UsersView(usersStore: usersStore) ) {
                        Text(""Users"")
                    }
                    NavigationLink(destination: RolesView(rolesStore: rolesStore)) {
                        Text(""Roles"")
                    }
                    NavigationLink(destination: ElementsView(elements: $elementsStore.elements)) {
                        Text(""Elements"")
                    }
                }.font(.title).padding(20)
            }.navigationBarTitle(Text(""STELL""))
        }
    }
}
</code></pre>

<p>The problem I have is that I want to reference <code>userManager</code> from any of the observedObjects, e.g. when the rest api's returns <code>401 Unauthorized</code> when the session token has expired. Then I want the ObservedObject to set the <code>isRegistered</code> flag in <code>userManager</code> to <code>false</code> so the <code>RegisterView</code> is automatically shown. But how can I do that? I can't set a reference to <code>userManager</code> in any of the ObservedObject property initializers, because the compiler complains about property initializers is run before <code>self</code> is available.</p>
","6394244","","","","","2022-05-14 16:16:26","Reference EnvironmentObject in ObservableObject","<swiftui><combine><observableobject>","1","0","1","","","CC BY-SA 4.0"
"60033588","1","60047197","","2020-02-03 05:33:04","","1","1281","<pre class=""lang-swift prettyprint-override""><code>let a = Just(""a"")
let b = Just(""b"")
_ = Publishers.CombineLatest(a, b).map { a, b in
    print(a, b)
}
</code></pre>

<p>This is my simple <code>CombineLatest</code> test. I am calling this method in <code>onAppear</code> function. 
However, my <code>print(a,b)</code> is not called. How should I fix my code to run <code>print(a, b)</code> ? </p>
","11258185","","5130481","","2020-02-03 08:25:32","2020-02-03 21:10:17","CombineLatest in Combine is not fired","<swift><combine><combinelatest>","1","2","","","","CC BY-SA 4.0"
"60054800","1","64747762","","2020-02-04 09:56:00","","0","1173","<p>I have main View which has ViewModel and it's declared like this </p>

<p><code>@ObservedObject var viewModel = ViewModel()</code></p>

<p>Everything works perfectly but when I move the app to background and then to foreground the View recreates itself as well as my viewModel and everything stored in viewModel disappears. </p>

<p>In this case making ViewModel a singleton class will solve the problem but making all ViewModels singleton classes is not a good idea. </p>

<p>Is there a workaround for this ?  </p>
","5903004","","4056108","","2020-02-04 10:41:51","2020-11-09 08:01:34","SwiftUI View memory lifecycle","<ios><swift><xcode><swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"60075802","1","60088674","","2020-02-05 12:25:29","","2","270","<p>Loading a anchor using LoadAnchorAsync(contentsOf: URL) does not work. Here is my code:</p>

<pre><code>if let url = url {
    let loadRequest = Entity.loadAnchorAsync(contentsOf: url)
    _ = loadRequest.sink(receiveCompletion: { completion in
        // handle completion
    }, receiveValue: { anchor in
        self.arView.scene.addAnchor(anchor)
    })
} else {
        fatalError(""no url"")
}
</code></pre>

<p>but this crashes every time with an error:</p>

<p>Thread 27: EXC_BREAKPOINT (code=1, subcode=0x1051e0dfc)</p>

<p><a href=""https://i.stack.imgur.com/lfHgJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/lfHgJ.png"" alt=""enter image description here""></a></p>

<p>Update: If i wrap the entire code block in an DispatchQueue.main.async block it doenst crash but neither reveiceCompletion or recieveValue gets called</p>
","8432840","","8432840","","2020-02-05 12:31:42","2020-02-06 06:09:57","Loading anchor from url async doesnt work","<swift><augmented-reality><arkit><combine><realitykit>","2","0","0","","","CC BY-SA 4.0"
"60109976","1","60110142","","2020-02-07 08:50:08","","2","1106","<p>I have a simple <code>SwiftUI</code> list that displays numbers asynchronously from a <code>Combine</code> publisher, when I add a <code>View</code> at the top of the list to act as a header view, I face a weird <em>shrink</em> or <em>flicker</em> happens for the header at the time the <code>Content View</code> gets redrawn when the data returns from the publisher:</p>

<p>here's the view-model class that has the publisher:</p>

<pre><code>class ViewModel: ObservableObject {
    @Published var items: [Int] = []
    var subscriptions = Set&lt;AnyCancellable&gt;()

    init() {
            (0...10)
            .publisher
            .delay(for: .seconds(3), scheduler: DispatchQueue.main) //to simulate async call
            .sink { (value) in
            self.items.append(value)
        }
        .store(in: &amp;subscriptions)
    }
}
</code></pre>

<p>and here's the <code>ContentView</code> struct that interacts with the above view model:</p>

<pre><code>struct ContentView: View {
    @ObservedObject var viewModel: ViewModel
    var body: some View {

        List {
            VStack {
                Rectangle()
                Text(""Some Text"")
                Text(""Some Other Very Long Text Some Other Some Other Long Text"")
            }
            .background(Color.red)

            ForEach(viewModel.items, id: \.self) {  item in
                Text(""\(item)"")
            }
        }
    }
}
</code></pre>

<p>and here's the result:</p>

<p><a href=""https://i.stack.imgur.com/WXY5k.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/WXY5k.gif"" alt=""enter image description here""></a></p>

<p>I've tried to separate the <code>VStack</code> at the top of the list into an external <code>View</code> but nothing changed.</p>

<p>what's causing this weird shrink and is there a way to avoid it ?</p>
","1056118","","","","","2020-02-07 08:59:39","SwiftUI: adding a View at the top of a dynamic List causes the View to shrink","<ios><swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"60123470","1","60141681","","2020-02-08 02:41:45","","1","120","<p>Formatting the published value in my model (as computed property) I've got very strange error </p>

<pre><code>class Model: ObservableObject {
    @Published var value = 0.0
    var progress: String {
        String(format: ""%.2f %%"", value) // Expression type 'String' is ambiguous without more context
    }
}
</code></pre>

<p>I found a ""workaround""</p>

<pre><code>class Model: ObservableObject {
    @Published var value = 0.0
    var progress: String {
        String(format: ""%.2f %%"", value * 1) // No error :-)
    }
}
</code></pre>

<p>Can somebody explain this strange behavior?</p>
","3441734","","220819","","2020-02-10 07:03:42","2020-02-10 10:56:39","strange error while formatting a string from published value","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"60131928","1","60136273","","2020-02-08 22:44:42","","0","348","<p>I have a map based app so I want to have an app-wide property for the current position of the map.</p>

<p>I'm initializing it in SceneDelegate</p>

<pre><code>    let currentPosition = CurrentPosition()
    let mainView = MainView(appState: AppState(), selectedWeatherStation: nil).environmentObject(currentPosition)
</code></pre>

<p>I have it declared in <code>MainView</code> as an <code>@EnvironmentObject</code></p>

<pre><code>struct MainView: View {
    @State var appState: AppState
    @State var selectedWeatherStation: WeatherStation? = nil

    @EnvironmentObject var currentPosition: CurrentPosition
</code></pre>

<p>and I inject it into my <code>UIViewRepresentable</code> child</p>

<pre><code> MapView(weatherStations: $appState.appData.weatherStations,
                    selectedWeatherStation: $selectedWeatherStation).environmentObject(currentPosition)
                    .edgesIgnoringSafeArea(.vertical)
</code></pre>

<p>in <code>MapView</code></p>

<pre><code>struct MapView: UIViewRepresentable {
    @Binding var weatherStations: [WeatherStation]
    @Binding var selectedWeatherStation: WeatherStation?

    @EnvironmentObject var currentPosition: CurrentPosition
</code></pre>

<p>i have a final subclass </p>

<pre><code>final class Coordinator: NSObject, MKMapViewDelegate {
        @EnvironmentObject var currentPosition: CurrentPosition
</code></pre>

<p>which acts as my mapview delegate, where I want to update the <code>currentPosition</code></p>

<pre><code>  func mapViewDidChangeVisibleRegion(_ mapView: MKMapView) {
            currentPosition = CurrentPosition(northEast: mapView.northEastCoordinate, southWest: mapView.southWestCoordinate)
        }
</code></pre>

<p>But this assignament
<code>currentPosition = CurrentPosition(northEast: mapView.northEastCoordinate, southWest: mapView.southWestCoordinate)</code>
will throw an error
<code>Cannot assign to property: 'currentPosition' is a get-only property</code>
and I really have no idead what I'm doing wrong.</p>

<p>The purpose is to update the position each time the user moves the map so I can perform a request to my API with the current coordinates.</p>

<p>CurrentPosition is declared as follows</p>

<pre><code>class CurrentPosition: ObservableObject {
    @Published var northEast = CLLocationCoordinate2D()
    @Published var southWest = CLLocationCoordinate2D()

    init(northEast: CLLocationCoordinate2D = CLLocationCoordinate2D(), southWest: CLLocationCoordinate2D = CLLocationCoordinate2D()) {
        self.northEast = northEast
        self.southWest = southWest
    }
}
</code></pre>
","2984775","","","","","2020-02-09 11:53:10","Trying to assign to an @EnvironmentObject from a child view to a parent fails as EnvironmentObject is read-only","<swift><mapkit><swiftui><combine><uiviewrepresentable>","1","2","","","","CC BY-SA 4.0"
"60136350","1","60141414","","2020-02-09 11:57:37","","1","251","<p>I have an <code>ObservableObject</code></p>

<pre><code>
class CurrentPosition: ObservableObject {
    @Published var northEast = CLLocationCoordinate2D()
    @Published var southWest = CLLocationCoordinate2D()


    init(northEast: CLLocationCoordinate2D = CLLocationCoordinate2D(), southWest: CLLocationCoordinate2D = CLLocationCoordinate2D()) {
        self.northEast = northEast
        self.southWest = southWest
    }

    func updateCoordinates(from mapView: MKMapView) {
        self.northEast = mapView.northEastCoordinate
        self.southWest = mapView.southWestCoordinate
    }
}
</code></pre>

<p>which I want to update from a MapView</p>

<pre><code>struct MapView: UIViewRepresentable {
    @Binding var weatherStations: [WeatherStation]
    @Binding var selectedWeatherStation: WeatherStation?

    @EnvironmentObject var currentPosition: CurrentPosition

    func makeUIView(context: Context) -&gt; MKMapView {
        let map = MKMapView()
        map.showsUserLocation = true
        map.delegate = context.coordinator
        return map
    }

    func updateUIView(_ uiView: MKMapView, context: Context) {
        updateAnnotations(from: uiView)
    }

    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self)
    }


    final class Coordinator: NSObject, MKMapViewDelegate {
        var control: MapView

        init(_ control: MapView) {
            self.control = control
        }

        func mapView(_ mapView: MKMapView, regionDidChangeAnimated animated: Bool) {
            control.currentPosition.updateCoordinates(from: mapView)
        }

    }
}
</code></pre>

<p>and pass it to an <code>AppState</code> object</p>

<pre><code> MapView(weatherStations: $appState.appData.weatherStations,
                        selectedWeatherStation: $selectedWeatherStation).environmentObject(self.currentPosition)
                    .edgesIgnoringSafeArea(.vertical).onReceive(currentPosition.objectWillChange) { () in
                        self.appState.currentPosition = self.currentPosition
                }}
</code></pre>

<p>which in turn passes it to my API client</p>

<pre><code>class AppState: ObservableObject {
    @Published var appData = AppData(weatherStations: [WeatherStation]())
    var currentPosition: CurrentPosition! {
        didSet {
            api.currentPosition = self.currentPosition
        }
    }
}
</code></pre>

<p>My issues is that it gets passed each time one of my <code>CurrentPosition</code> properties gets updated, meaning it first gets passed when <code>northEast</code> gets updated, than when <code>southWest</code> gets updated.</p>

<p>How can I pass it only one, when both finished updating?</p>
","2984775","","","","","2020-02-09 21:16:15","SwiftUI be notified when all properties of an ObservableObject are updated","<swift><mvvm><swiftui><xcode11><combine>","1","0","","","","CC BY-SA 4.0"
"60148544","1","60167304","","2020-02-10 10:35:31","","3","4449","<p>This one I've been researching for a few days, scouring the Swift &amp; SwiftUI docs, SO, forums, etc. and can't seem to find an answer.</p>

<p>Here is the problem;</p>

<p>I have a SwiftUI custom View that does some state determination on a custom API request class to a remote resource. The View handles showing loading states and failure states, along with its body contents being passed through via ViewBuilder so that if the state from the API is successful and the resource data is loaded, it will show the contents of the page.</p>

<p>The issue is, the ViewBuilder contents does not re-render when the subclassed ObservedObject updates. The Object updates in reaction to the UI (when buttons are pressed, etc.) but the UI never re-renders/updates to reflect the change within the subclassed ObservedObject, for example the ForEach behind an array within the subclassed ObservedObject does not refresh when the array contents change. If I move it out of the custom View, the ForEach works as intended.</p>

<p>I can confirm the code compiles and runs. Observers and <code>debugPrint()</code>'s throughout show that the <code>ApiObject</code> is updating state correctly and the View reflects the <code>ApiState</code> change absolutely fine. It's just the <code>Content</code> of the ViewBuilder. In which I assume is because the ViewBuilder will only ever be called once.</p>

<p><strong>EDIT</strong>: The above paragraph should have been the hint, the <code>ApiState</code> updates correctly, but after putting extensive logging into the application, the UI was not listening to the publishing of the subclassed ObservedObject. The properties were changing and the state was too, but the UI wasn't being reactive to it.
Also, the next sentence turned out to be false, I tested again in a VStack and the component still didn't re-render, meaning I was looking in the wrong place!</p>

<p>If this is the case, how does <code>VStack</code> and other such elements get around this?
Or is it because my <code>ApiObjectView</code> is being re-rendered on the state change, in which causes the child view to 'reset'? Although in this circumstance I'd expect it to then take on the new data and work as expected anyway, its just never re-rendering.</p>

<p>The problematic code is in the <code>CustomDataList.swift</code> and <code>ApiObjectView.swift</code> below. I've left comments to point in the right direction.</p>

<p>Here is the example code;</p>

<pre class=""lang-swift prettyprint-override""><code>// ApiState.swift
// Stores the API state for where the request and data parse is currently at.
// This drives the ApiObjectView state UI.

import Foundation

enum ApiState: String
{
    case isIdle

    case isFetchingData
    case hasFailedToFetchData

    case isLoadingData
    case hasFailedToLoadData

    case hasUsableData
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>// ApiObject.swift
// A base class that the Controllers for the app extend from.
// These classes can make data requests to the remote resource API over the
// network to feed their internal data stores.

class ApiObject: ObservableObject
{
    @Published var apiState: ApiState = .isIdle

    let networkRequest: NetworkRequest = NetworkRequest(baseUrl: ""https://api.example.com/api"")

    public func apiGetJson&lt;T: Codable&gt;(to: String, decodeAs: T.Type, onDecode: @escaping (_ unwrappedJson: T) -&gt; Void) -&gt; Void
    {
        self.apiState = .isFetchingData

        self.networkRequest.send(
            to: to,
            onComplete: {
                self.apiState = .isLoadingData

                let json = self.networkRequest.decodeJsonFromResponse(decodeAs: decodeAs)

                guard let unwrappedJson = json else {
                    self.apiState = .hasFailedToLoadData
                    return
                }

                onDecode(unwrappedJson)

                self.apiState = .hasUsableData
            },
            onFail: {
                self.apiState = .hasFailedToFetchData
            }
        )
    }
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>// DataController.swift
// This is a genericised example of the production code.
// These controllers build, manage and serve their resource data.
// Subclassed from the ApiObject, inheriting ObservableObject

import Foundation
import Combine

class CustomDataController: ApiObject
{
    @Published public var customData: [CustomDataStruct] = []

    public func fetch() -&gt; Void
    {
        self.apiGetJson(
            to: ""custom-data-endpoint "",
            decodeAs: [CustomDataStruct].self,
            onDecode: { unwrappedJson in
                self.customData = unwrappedJson
            }
        )
    }
}
</code></pre>

<p>This is the View that has the problem with re-rendering its <code>ForEach</code> on the <code>ObservedObject</code> change to its bound array property.</p>

<pre class=""lang-swift prettyprint-override""><code>// CustomDataList.swift
// This is the SwiftUI View that drives the content to the user as a list
// that displays the CustomDataController.customData.
// The ForEach in this View 

import SwiftUI

struct CustomDataList: View
{
    @ObservedObject var customDataController: CustomDataController = CustomDataController()

    var body: some View
    {
        ApiObjectView(
            apiObject: self.customDataController,
            onQuit: {}
        ) {
            List
            {
                Section(header: Text(""Custom Data"").padding(.top, 40))
                {
                    ForEach(self.customDataController.customData, id: \.self, content: { customData in
                        // This is the example that doesn't re-render when the
                        // customDataController updates its data. I have
                        // verified via printing at watching properties
                        // that the object is updating and pushing the
                        // change.

                        // The ObservableObject updates the array, but this ForEach
                        // is not run again when the data is changed.

                        // In the production code, there are buttons in here that
                        // change the array data held within customDataController.customData.

                        // When tapped, they update the array and the ForEach, when placed
                        // in the body directly does reflect the change when
                        // customDataController.customData updates.
                        // However, when inside the ApiObjectView, as by this example,
                        // it does not.

                        Text(customData.textProperty)
                    })
                }
            }
            .listStyle(GroupedListStyle())
        }
        .navigationBarTitle(Text(""Learn""))
        .onAppear() {
            self.customDataController.fetch()
        }
    }
}

struct CustomDataList_Previews: PreviewProvider
{
    static var previews: some View
    {
        CustomDataList()
    }
}
</code></pre>

<p>This is the custom View in question that doesn't re-render its Content.</p>

<pre class=""lang-swift prettyprint-override""><code>// ApiObjectView
// This is the containing View that is designed to assist in the UI rendering of ApiObjects
// by handling the state automatically and only showing the ViewBuilder contents when
// the state is such that the data is loaded and ready, in a non errornous, ready state.
// The ViewBuilder contents loads fine when the view is rendered or the state changes,
// but the Content is never re-rendered if it changes.
// The state renders fine and is reactive to the object, the apiObjectContent
// however, is not.

import SwiftUI

struct ApiObjectView&lt;Content: View&gt;: View {
    @ObservedObject var apiObject: ApiObject

    let onQuit: () -&gt; Void

    let apiObjectContent: () -&gt; Content

    @inlinable public init(apiObject: ApiObject, onQuit: @escaping () -&gt; Void, @ViewBuilder content: @escaping () -&gt; Content) {
        self.apiObject = apiObject
        self.onQuit = onQuit
        self.apiObjectContent = content
    }

    func determineViewBody() -&gt; AnyView
    {
        switch (self.apiObject.apiState) {
            case .isIdle:
                return AnyView(
                    ActivityIndicator(
                        isAnimating: .constant(true),
                        style: .large
                    )
                )

            case .isFetchingData:
                return AnyView(
                    ActivityIndicator(
                        isAnimating: .constant(true),
                        style: .large
                    )
                )

            case .isLoadingData:
                return AnyView(
                    ActivityIndicator(
                        isAnimating: .constant(true),
                        style: .large
                    )
                )

            case .hasFailedToFetchData:
                return AnyView(
                    VStack
                    {
                        Text(""Failed to load data!"")
                            .padding(.bottom)

                        QuitButton(action: self.onQuit)
                    }
                )

            case .hasFailedToLoadData:
                return AnyView(
                    VStack
                    {
                        Text(""Failed to load data!"")
                            .padding(.bottom)

                        QuitButton(action: self.onQuit)
                    }
                )

            case .hasUsableData:
                return AnyView(
                    VStack
                    {
                        self.apiObjectContent()
                    }
                )
        }
    }

    var body: some View
    {
        self.determineViewBody()
    }
}

struct ApiObjectView_Previews: PreviewProvider {
    static var previews: some View {
        ApiObjectView(
            apiObject: ApiObject(),
            onQuit: {
                print(""I quit."")
            }
        ) {
            EmptyView()
        }
    }
}
</code></pre>

<p>Now, all the above code works absolutely fine, if the <code>ApiObjectView</code> isn't used and the contents placed in the View directly.</p>

<p>But, that is horrendous for code reuse and architecture, this way its nice and neat, but doesn't work.</p>

<p>Is there any other way to approach this, e.g. via a <code>ViewModifier</code> or a <code>View</code> extension?</p>

<p>Any help on this would be really appreciated.</p>

<p>As I said, I can't seem to find anyone with this problem or any resource online that can point me in the right direction to solve this problem, or what might be causing it, such as outlined in documentation for ViewBuilder.</p>

<p>EDIT: To throw something interesting in, I've since added a countdown timer to <code>CustomDataList</code>, which updates a label every 1 second. <strong>IF</strong> the text is updated by that timer object, the view is re-rendered, but <strong>ONLY</strong> when the text on the label displaying the countdown time is updated.</p>
","4494375","","4494375","","2020-02-11 11:01:07","2020-02-11 11:01:07","SwiftUI custom View's ViewBuilder doesn't re-render/update on subclassed ObservedObject update","<ios><swift><swiftui><observedobject><viewbuilder>","1","0","","","","CC BY-SA 4.0"
"60149906","1","60152554","","2020-02-10 11:56:15","","6","4037","<p>I am currently trying to implement the merging of two publishers. But I can't find a solution for my use case. </p>

<p>I want to merge 2 publishers that both emit an array of structs of the same type. I want the combined publisher to emit values when either one of the merged publishers emit a new value. </p>

<p>Basically this would be a use case for <code>Publishers.CombineLatest</code>, but since my underlying publishers both emit values of the same type a <code>merge</code> would be more fitting here. But <code>Publishers.Merge</code> will not remember the last values of the merged publishers.</p>

<p>Therefore I would like to have a <code>Publishers.CombineLatest</code> behaviour with a <code>Publishers.Merge</code> operation. Is there something inside the Combine framework which can accomplish this kind of behaviour ? </p>

<p><strong>Rough example what should happen:</strong></p>

<pre><code>Definitions:

PublisherA: emits -&gt; [Value]
PublisherB emits -&gt; [Value]

CombinedAB: -&gt; [Value]


PublisherA changes: CombinedAB -&gt; [NewA, OldB]
PublisherB changes: CombinedAB -&gt; [OldA, NewB]
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>
let a = CurrentValueSubject&lt;[Int], Never&gt;([""a"", ""b"", ""c""])
let b = CurrentValueSubject&lt;[Int], Never&gt;([""d"", ""e"", ""f""])

let combined = Publisher.AnyThing(a, b)

combined.sink {
   print($0)
}


b.send([""g"", ""h"", ""i""])


Outputs:
[""a"", ""b"", ""c"", ""d"", ""e"", ""f""]
[""a"", ""b"", ""c"", ""g"", ""h"", ""i""]

</code></pre>

<p>So it's basically a <code>Publishers.CombineLatest</code> but without emitting a tuple of (NewA,OldB) but instead already merged, because both values have the same type.</p>

<p>Any help is much appreciated.</p>
","4454752","","4454752","","2020-02-10 14:51:10","2021-09-12 05:04:10","Combine Publishers.Merge but with Publishers.combineLatest behaviour","<swift><combine>","2","2","","","","CC BY-SA 4.0"
"60157510","1","60171763","","2020-02-10 19:57:43","","1","870","<p>I am looking to trigger a SwiftUI function by physically shaking the device.  Since motion detection is not a capability of SwiftUI at this time, I need to use UIKit integration along with a coordinator to return a Bool value which will indicate that the device has been shaken, thereby triggering the SwiftUI function.</p>

<p>The following code all works great in recognizing the shaking of the device (this is proven by the separate “makeShakerSound()” function which plays a soundclip upon being shaken and it works great).  Besides the working code to recognize the shaking, I also included the code used to call ShakableViewRepresentable(isShaken: $shakeOccurred) from ContentView, below.</p>

<p>I created an EnvironmentObject to flag that the device has been shaken, and used objectWillChange to announce that a change has occurred.  </p>

<p>My problem is this:  When the shaking motion is detected, the shaking sound effect works great, but my ContentView is not updated for the change in the environmental object myDevice.isShaken.  I thought using objectWillChange might take care of this, but it doesn't.  What am I missing?  </p>

<p>My apologies - I'm a bit new at this.</p>

<pre><code>/* CREATE AN ENVIRONMENTAL OBJECT TO INDICATE DEVICE HAS BEEN SHAKEN */

import Combine
import SwiftUI

class MyDevice: ObservableObject {
    // let objectWillChange = ObservableObjectPublisher()
    var isShaken: Bool = false {
        willSet {
            self.objectWillChange.send()
        }
    }
}


/* DETECT SHAKE GESTURE AND FLAG THAT SHAKING HAS OCCURRED */

import UIKit
import SwiftUI

struct ShakableViewRepresentable: UIViewControllerRepresentable {

    class Coordinator: NSObject {
        var parent: ShakableViewRepresentable
        init(_ parent: ShakableViewRepresentable) {
            self.parent = parent
        }
    }

    func makeCoordinator() -&gt; ShakableViewRepresentable.Coordinator {
        Coordinator(self)
    }

    func makeUIViewController(context: Context) -&gt; ShakableViewController {
        ShakableViewController()
    }
    func updateUIViewController(_ uiViewController: ShakableViewController, context: Context) {}
}

class ShakableViewController: UIViewController {

    override func motionBegan(_ motion: UIEvent.EventSubtype, with event: UIEvent?) {
        guard motion == .motionShake else { return }

         /* SHAKING GESTURE WAS DETECTED */
        myDevice?.isShaken = true       /* ContentView doesn't update! */
        makeShakerSound()       /* This works great */

        /* I’M TRYING TO TRIGGER A FUNCTION IN SWIFTUI BY SHAKING THE DEVICE:  Despite setting the myDevice.isShaken environment object to ""true"", my ContentView doesn't update when the shaking gesture is detected.   */

    }
}


ContentView.swift

    @EnvironmentObject var myDevice: MyDevice

    var body: some View {
        NavigationView {

            ZStack {

                /* DETECT SHAKE GESTURE - This works */
                ShakableViewRepresentable()
                    .allowsHitTesting(false)

                VStack {
                    /* SHOW CURRENT STATE OF myDevice.isShaken - Doesn't update */
                    Text(self.myDevice.isShaken ? ""The device has been shaken"" : ""No shaking has occurred"")
                    Text(""Device was shaken: \(self.myDevice.isShaken.description)"")
                }

/* more views below */
</code></pre>
","12874585","","12874585","","2020-02-11 15:34:11","2020-02-11 16:41:01","Setting EnvironmentObject from a Shake Gesture (using UIKit) in SwiftUI doesn't update View","<ios><uikit><swiftui><combine><shake>","1","0","1","","","CC BY-SA 4.0"
"60157828","1","60167853","","2020-02-10 20:20:47","","0","173","<p>I have a strange issue where the textfield gets deleted after selecting another textfield.</p>

<p>I have an <code>EnvironmentObject</code></p>

<pre><code>func applicationDidFinishLaunching(_ aNotification: Notification) {
        // Create the SwiftUI view that provides the window contents.
        let shellInteractor = ShellInteractor()
        let contentView = ContentView().environmentObject(shellInteractor)
}
</code></pre>

<p>injected in the view</p>

<pre><code>struct ContentView: View {
    @EnvironmentObject var shellInteractor: ShellInteractor

    var body: some View {
        ScrollView {
            VStack {
                HStack {
                    Text(""Enter target bundle identifier:"")
                    TextField(""com.mycompany.app"", text: $shellInteractor.bundleId)
                }.padding()
                HStack {
                    Text(""Enter icon badge count:"")
                    TextField(""0"", text: $shellInteractor.badgeNumber)
                }.padding()
                HStack {
                    Text(""Enter message identifier:"")
                    TextField(""ABCDEFGHIJ"", text: $shellInteractor.messageId)
                }.padding()

                Text(""Found Running Sim: "")
                Text(self.shellInteractor.shellOutput).fontWeight(.semibold)
                Button(action: {
                    self.shellInteractor.sendNotification()
                }) {
                    Text(""SEND!!!"")
                    .fontWeight(.semibold)
                }.padding()
            }.padding()
        }
    }
}
</code></pre>

<pre><code>class ShellInteractor: ObservableObject {
    @Published var shellOutput: String = """"

    public var badgeNumber: String = """"
    public var messageId: String = """"
    public var bundleId: String = """"
}
</code></pre>

<p>As I said, when I enter a text in any of the textfields and select another text field or tap the <code>TAB</code> key (basically when losing focus), the textfield deletes the text and shows the placeholder again.</p>
","2984775","","","","","2020-02-11 11:30:05","macOS SwiftUI Textfield gets deleted after losing focus","<macos><swiftui><textfield><combine>","1","0","","","","CC BY-SA 4.0"
"60164640","1","60165493","","2020-02-11 08:27:47","","3","1567","<p>I'm building a graphics app for iOS. Here is my code.</p>

<pre><code>class Group {

    /// All the shapes contained in the group
    public var shapes: CurrentValueSubject&lt;[Shape], Never&gt;

    /// The frame of the group
    var frame: CurrentValueSubject&lt;CGRect, Never&gt;

    /// The path to be calculated and displayed to users from the contained shapes
    var cgPath: CurrentValueSubject&lt;CGPath, Never&gt;
}

class Shape {
    var path: CurrentValueSubject&lt;Path, Never&gt;  = .init(Path())
}

struct Path {
    public var points = [CGPoint]()
}
</code></pre>

<p>So, here is what I want to do but don't know how to do it with Combine. </p>

<p>I want <code>Group</code> to observe it's own <code>frame</code>, <code>shapes</code>, and the <code>path</code> of it's shapes (I need to merge all this), so every time each of they change, I can calculate the new CGPath to display and assign it to the <code>cgPath</code> property (which will be observed by the View that draws everything).</p>

<p>Please, let me know if this is possible or if there is a better approach to all this.</p>

<p>Thanks in advance.</p>
","705309","","","","","2020-02-11 09:38:10","Swift Combine - Observe property in object inside array of N objects and merge with other properties","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"60173183","1","60173385","","2020-02-11 16:15:45","","2","1591","<p>I have a simple question that I can see only <code>dataTaskPublisher</code> in <a href=""https://developer.apple.com/documentation/foundation/urlsession"" rel=""nofollow noreferrer"">documentation</a> with which I was able to call a get web service but how can I call a post web service which can return a publisher?</p>
","8487592","","","","","2020-02-11 16:27:48","How to call a post web service with UrlSession.DataTaskPublisher?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"60198065","1","60215469","","2020-02-12 22:52:00","","0","1152","<p>I have an app where users can sign up and login using Firebase. However, I can not seem to alert the user of any errors in the view.</p>

<p>First we have a <strong>UserStore</strong> which is a <code>ObservableObject</code> and is initialised as an <code>EnvironmentObject</code> when setting up the view in the <code>SceneDelegate</code>. </p>

<pre><code>let appView = AppView().environmentObject(userStore)

  if let windowScene = scene as? UIWindowScene {
        let window = UIWindow(windowScene: windowScene)
        window.rootViewController = UIHostingController(rootView: appView)
        self.window = window
        window.makeKeyAndVisible()

}
</code></pre>

<p>Then we sign up or login to the View like so. </p>

<p><strong>In View</strong> </p>

<pre><code>self.userStore.logIn(email: self.email, password: self.password)
self.isLoggingIn = true

if self.userStore.failedToLogin {
   self.isLoggingIn = false
   self.alertTitle = ""There seems to be a problem""
   self.alertBody = self.userStore.errorMessage
   self.showingAlert = true
}
</code></pre>

<p>Then the actual method should update the UserStore property values which then update the view and display an alert, however, this is not the case. </p>

<p><strong>SignIn</strong> </p>

<pre><code>// Session Properties
@Published var isLoggedIn = false {didSet{didChange.send() }}
@Published var isNewUser = false {didSet{didChange.send() }}
@Published var failedToCreateAccount = false {didSet{didChange.send() }}
@Published var failedToLogin = false {didSet{didChange.send() }}
@Published var errorMessage = """" {didSet{didChange.send() }}

init () {
  handle = Auth.auth().addStateDidChangeListener { (auth, user) in
    if let user = user {
      self.session = user
      self.isLoggedIn = true
      //Change isNewUser is user document exists?
   } else {
      self.session = nil
      self.isLoggedIn = false
    }
  }
}

func logIn(email: String, password: String) {

    Auth.auth().signIn(withEmail: email, password: password) { [weak self] user, error in

        print(""Signed In"")

        if(error != nil) {
            print(""Failed to login"")

            self!.failedToLogin = true
            self!.errorMessage = (""\(String(describing: error))"")
            print(error!)
            return
        } else if error == nil {
            print(""Success Logging In"")

        }
    }
}
</code></pre>

<p>The AppView determines which view is loaded depending if the user is logged in.</p>

<p><strong>AppView</strong></p>

<pre><code>        if !userStore.isLoggedIn {
            LoginView().transition(.opacity)
        }

        if userStore.isLoggedIn  {
            ContentView().transition(.opacity)
        }
</code></pre>

<p>Atm error messages are not shown; the login view is also shown shortly before the main view.</p>

<p>How can I correctly display error messages in the view ? </p>
","4556409","","4556409","","2020-02-13 19:56:58","2020-06-14 00:51:42","Handling Firebase Auth error in SwiftUI Combine app","<swift><firebase><firebase-authentication><swiftui><combine>","2","3","1","","","CC BY-SA 4.0"
"60218009","1","60219175","","2020-02-13 23:29:25","","0","1330","<p>In the example below, ""2"" will never be printed, since the error is a completion event, stopping the publisher from sending any more events. That's very clear to me.</p>

<pre class=""lang-swift prettyprint-override""><code>import Combine

enum TestError: Error {
  case ohnoes
}

let publisher = PassthroughSubject&lt;Int, Error&gt;()

publisher
  .sink(receiveCompletion: { completion in
  print(completion)
}) { int in
  print(int)
}

publisher.send(1)
publisher.send(completion: .failure(TestError.ohnoes))
publisher.send(2)
</code></pre>

<p>Sadly, even <code>replaceError</code> and <code>catch</code> won't stop the completion event, so the pipeline will still end.</p>

<p>So my question is, how can I replace the error with a <code>nil</code> value and prevent the completion event? Basically I want to transform <code>AnyPublisher&lt;Int, Error&gt;</code> into <code>AnyPublisher&lt;Int?, Never&gt;</code>, for those cases where I simply don't care about the error at all, and just want to keep receiving future values.</p>

<p>With ReactiveKit I had this extension:</p>

<pre class=""lang-swift prettyprint-override""><code>extension Signal {
  func errorToOptional() -&gt; Signal&lt;Element?, Never&gt; {
    return Signal&lt;Element?, Never&gt; { observer in
      self.observe { event in
        switch event {
        case .next(let element):
          observer.receive(element)
        case .failed:
          observer.receive(nil)
        case .completed:
          observer.receive(completion: .finished)
        }
      }
    }
  }
}
</code></pre>

<p>And it worked great. But the Combine types make creating extensions like these very difficult (if not impossible?).</p>
","403425","","","","","2020-02-14 02:28:39","Combine: can I replace an error with nil?","<swift><combine><reactivekit>","1","2","","","","CC BY-SA 4.0"
"60222064","1","60222152","","2020-02-14 07:49:08","","1","1715","<p>I have a SwiftUI view that displays the result of a CoreData query.<br>
In it's parent view I want to display the count of the query (without querying one more time).<br>
I tried to pass the count to the parent in a Binding, but I get the warning ""Modifying state during view update, this will cause undefined behavior."" an it does not work.</p>

<pre><code>import SwiftUI

struct CD_Main: View {
  @State var count = 0

    var body: some View {
      VStack {
        Text(""count in main: \(count)"")
        CD_Query(c: $count)
      }
    }
}

struct CD_Query: View {
  @Binding var c : Int

  @Environment(\.managedObjectContext) var moc
  @FetchRequest(entity: Item.entity(), sortDescriptors: [], predicate: nil) var items: FetchedResults&lt;Item&gt;

  var body: some View {
  c = items.count // Produces: Modifying state during view update, this will cause undefined behavior.
    return VStack {
      Text(""Count Innen: \(items.count) "")
      List(items, id: \.self) {
        item in
        Text(item.title)
      }
    }
  }
}
</code></pre>

<p>Any ideas how to set the Binding correctly or how else to pass the count to the parent?</p>
","1165251","","","","","2020-02-14 07:56:07","return count from a SwiftUI CoreData View","<ios><core-data><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"60223041","1","60226849","","2020-02-14 09:01:41","","3","960","<p>I have a simple <code>Deferred Publisher</code> that reads data from disk and I display the data in a <code>SwiftUI List</code>, the <code>Publisher</code> works well most of the time, but <strong><em>sometimes</em></strong> it doesn't behave well, it just loses its value (which's an array of <code>Model</code> objects) and completes with <code>finished</code> message. I've tried a workaround mentioned <a href=""https://forums.swift.org/t/combine-receive-on-runloop-main-loses-sent-value-how-can-i-make-it-work/28631/5"" rel=""nofollow noreferrer"">here</a> to use the <code>buffer</code> operator to keep the value in buffer because I believe the <code>Combine's Publisher</code> by design won't pass the data downstream if there is no demand requested by subscribers and hence dropping this data and completes, however using <code>buffer</code> didn't solve the issue.</p>

<p>The code I have:</p>

<pre><code>enum FileError: Error {
    case someError
}

class ViewModel: ObservableObject {
    @Published var modelArray = [Model]()
    private var subscriptions = Set&lt;AnyCancellable&gt;()
    func readData() {
        DataSource()
            .readFromBundle(resource: ""Sample"", type: ""json"")
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { completion in
                print(""Completion: \(completion)"")
            }) { array in
                self.modelArray = array
        }.store(in: &amp;subscriptions)
    }
}
struct ContentView: View {
    @ObservedObject var viewModel: ViewModel

    var body: some View {
        VStack {
            List(self.viewModel.modelArray) { model in
                Text(""\(model.name)"")
            }
        }
        .onAppear {
            self.viewModel.readData()
        }
    }
}

struct Model: Codable, Identifiable {
    var id: Int
    var name: String
}

class DataSource {
    private let readQueue = DispatchQueue(label: ""ReadQueue"", qos: .default, attributes: .concurrent)

    func readFromBundle (resource: String, type:String) -&gt; AnyPublisher&lt;[Model], FileError&gt; {
            Deferred {
                 Future { promise in
                    guard let url = Bundle.main.url(forResource: ""Sample"", withExtension: ""json""),
                      let data = try? Data(contentsOf: url),
                      let modelArray = try? JSONDecoder().decode([Model].self, from: data)
                      else {
                        promise(.failure(.someError))
                        return
                    }
                      promise(.success(modelArray))
                }
            }
           .receive(on: self.readQueue)
           .eraseToAnyPublisher()
        }
}
</code></pre>

<p><a href=""https://www.dropbox.com/s/2vuit169xl8gspq/Test.zip?dl=0"" rel=""nofollow noreferrer"">This is a link</a> to download a working sample project.</p>

<p><strong>EDIT:</strong></p>

<p>Environment: Xcode 11.3.1, iOS 13.3 iPhone 11 Pro Max simulator and device.</p>

<p>gif screenshot (notice the console output) </p>

<p><a href=""https://i.stack.imgur.com/WmWDI.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/WmWDI.gif"" alt=""enter image description here""></a></p>

<p><strong><em>EDIT2:</em></strong></p>

<p>if I add any downstream publishers, like <code>combineLatest</code> for example just before <code>sink</code> in the consumer function <code>readData()</code> then a new behavior introduced, which's chaining an async publisher (readFromBundle) with a sync publisher (<code>combineLatest</code>) will result in the value will not deliver at all on <code>iOS 13.3+</code> devices and will sometimes deliver on devices below <code>iOS 13.3</code>, as stated on <a href=""https://forums.swift.org/t/combine-receive-on-runloop-main-loses-sent-value-how-can-i-make-it-work/28631/39"" rel=""nofollow noreferrer"">this link</a>.</p>
","1056118","","1056118","","2020-02-15 10:36:49","2021-03-04 10:11:16","Combine: Publisher sometimes loses value and completes","<ios><swiftui><combine>","4","7","","","","CC BY-SA 4.0"
"60236376","1","60236422","","2020-02-15 06:18:44","","2","440","<p>Hello this is an error I do not know how to fix. from this tutorial: </p>

<p><a href=""https://medium.com/flawless-app-stories/reusable-image-cache-in-swift-9b90eb338e8d"" rel=""nofollow noreferrer"">Reusable Image Cache in Swift</a></p>

<p><a href=""https://i.stack.imgur.com/Bkqya.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Bkqya.png"" alt=""5""></a>
Code:</p>

<pre><code>final class ImageLoader {

private let cache = ImageCache()

func loadImage(from url: URL) -&gt; AnyPublisher&lt;UIImage?, Never&gt; {
    if let image = cache[url] {
        return Just(image).eraseToAnyPublisher()
    }
    return URLSession.shared.dataTask(with: url)
        .map { (data, response) -&gt; UIImage? in return UIImage(data: data) }
        .catch { error in return Just(nil) }
        .handleEvents(receiveOutput: {[unowned self] image in
            guard let image = image else { return }
            self.cache[url] = image
        })
        .subscribe(on: .background)
        .receive(on: RunLoop.main)
        .eraseToAnyPublisher()
}
}
</code></pre>

<p><strong>Update:</strong></p>

<p><strong>If You Use dataTaskPublisher:</strong>
<a href=""https://i.stack.imgur.com/7eN2F.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7eN2F.png"" alt=""enter image description here""></a></p>
","5178841","","5178841","","2020-02-15 06:40:12","2022-07-14 14:01:41","URLSessionDataTask has no member 'map' Swift 5","<ios><swift><xcode>","1","4","1","","","CC BY-SA 4.0"
"60236845","1","60237018","","2020-02-15 07:42:52","","0","1212","<p>Im trying to figure how to use <a href=""https://medium.com/flawless-app-stories/reusable-image-cache-in-swift-9b90eb338e8d"" rel=""nofollow noreferrer"">Reusable Image Cache in Swift</a> with a UIImageView. I am trying to simply assign the ImageLoader() variable's, actual image to a UIImageView so I can use it as a UIImage.</p>

<p><strong>Code:</strong></p>

<pre><code>let loader = ImageLoader()

myImage.image = loader.loadImage(from: myUrl)
</code></pre>

<p>maybe:</p>

<pre><code>loader.loadImage(from: myUrl)

myImage.image = loader(image)
</code></pre>

<p>But this give a cannot call value of non-function type 'ImageLoader' error</p>

<p><strong>Code:</strong></p>

<pre><code>final class ImageLoader {

private let cache = ImageCache()

func loadImage(from url: URL) -&gt; AnyPublisher&lt;UIImage?, Never&gt; {
    if let image = cache[url] {
        return Just(image).eraseToAnyPublisher()
    }
    return URLSession.shared.dataTaskPublisher(for: url)
        .map { UIImage(data: $0.data) }
        .catch { error in return Just(nil) }
        .handleEvents(receiveOutput: {[unowned self] image in
            guard let image = image else { return }
            self.cache[url] = image
        })
        .subscribe(on: DispatchQueue.global(qos: .background))
        .receive(on: RunLoop.main)
        .eraseToAnyPublisher()
}
}
</code></pre>
","5178841","","5178841","","2020-02-15 07:59:37","2020-02-15 08:22:58","How to get UIImage from AnyPublisher<UIImage?, Never> Swift 5 (Combine framework)","<ios><swift><xcode>","1","0","","","","CC BY-SA 4.0"
"60237114","1","60640121","","2020-02-15 08:34:40","","6","7140","<p>I have a problem with a deallocation of a variable: cache</p>

<p>This is from the tutorial <a href=""https://medium.com/flawless-app-stories/reusable-image-cache-in-swift-9b90eb338e8d"" rel=""noreferrer"">Reusable Image Cache in Swift</a></p>

<p><a href=""https://i.stack.imgur.com/H5T9o.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/H5T9o.png"" alt=""enter image description here""></a></p>

<p><strong>Error:</strong></p>

<p>Fatal error: Attempted to read an unowned reference but object 0x280208080 was already deallocated  Fatal error: Attempted to read an unowned reference but object 0x280208080 was already deallocated</p>

<p><strong>Code:</strong></p>

<pre><code>final class ImageLoader {

private let cache = ImageCache()

func loadImage(from url: URL) -&gt; AnyPublisher&lt;UIImage?, Never&gt; {
    if let image = cache[url] {
        return Just(image).eraseToAnyPublisher()
    }
    return URLSession.shared.dataTaskPublisher(for: url)
        .map { UIImage(data: $0.data) }
        .catch { error in return Just(nil) }
        .handleEvents(receiveOutput: {[unowned self] image in
            guard let image = image else { return }
            self.cache[url] = image
        })
        .subscribe(on: DispatchQueue.global(qos: .background))
        .receive(on: RunLoop.main)
        .eraseToAnyPublisher()
}
}
</code></pre>
","5178841","","","","","2022-03-07 22:19:14","Attempted to read an unowned reference but object was already deallocated Swift 5","<ios><swift><xcode>","2","3","","","","CC BY-SA 4.0"
"60241335","1","60241460","","2020-02-15 17:33:55","","3","1223","<p>For some reason when I type in the search field it does not print out Xcode console the ""str"". What am I missing here? I followed his tutorial <a href=""https://www.letsbuildthatapp.com/course_video?id=5232"" rel=""nofollow noreferrer"">https://www.letsbuildthatapp.com/course_video?id=5232</a></p>

<pre><code>import UIKit

class SearchViewController: UIViewController {

    let searchController = UISearchController(searchResultsController: nil)

    var sink: Any?

    override func viewDidLoad() {
        super.viewDidLoad()

        setupSearchBarListener()

        navigationItem.searchController = searchController

        navigationController?.navigationBar.prefersLargeTitles = true
        navigationItem.title = ""Contact""

        searchController.obscuresBackgroundDuringPresentation = false

        view.backgroundColor = .white
    }

    fileprivate func setupSearchBarListener() {

        let publisher = NotificationCenter.default.publisher(for: UISearchTextField.textDidChangeNotification, object: searchController.searchBar.searchTextField)
        publisher
            .map {
            ($0.object as! UISearchTextField).text
        }
            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)
            .sink { (str) in
                print(str ?? """")
        }

    }
}
</code></pre>
","10655230","","","","","2020-02-15 18:46:10","Somehow combine with search controller not working, any idea?","<ios><swift><xcode><uikit><combine>","1","0","1","","","CC BY-SA 4.0"
"60242270","1","60243156","","2020-02-15 19:17:48","","1","115","<p>I have the following model object that I use to populate a <code>List</code> with a <code>Toggle</code> for each row, which is bound to <code>measurement.isSelected</code></p>

<pre><code>final class Model: ObservableObject {

    struct Measurement: Identifiable {
        var id = UUID()
        let name: String
        var isSelected: Binding&lt;Bool&gt;

        var selected: Bool = false

        init(name: String) {
            self.name = name

            let selected = CurrentValueSubject&lt;Bool, Never&gt;(false)
            self.isSelected = Binding&lt;Bool&gt;(get: { selected.value }, set: { selected.value = $0 })
        }
    }

    @Published var measurements: [Measurement]
    @Published var hasSelection: Bool = false  // How to set this?

    init(measurements: [Measurement]) {
        self.measurements = measurements
    }
}
</code></pre>

<p>I'd like the <code>hasSelection</code> property to be true whenever any <code>measurement.isSelected</code> is <code>true</code>. I'm guessing somehow <code>Model</code> needs to observe changes in <code>measurements</code> and then update its <code>hasSelection</code> property… but I've no idea where to start!</p>

<p>The idea is that <code>hasSelection</code> will be bound to a <code>Button</code> to enable or disable it.</p>

<hr>

<p><code>Model</code> is used as follows…</p>

<pre><code>struct MeasurementsView: View {

    @ObservedObject var model: Model

    var body: some View {
        NavigationView {
            List(model.measurements) { measurement in
                MeasurementView(measurement: measurement)
            }
            .navigationBarTitle(""Select Measurements"")
            .navigationBarItems(trailing: NavigationLink(destination: NextView(), isActive: $model.hasSelection, label: {
                Text(""Next"")
            }))
        }
    }
}

struct MeasurementView: View {
    let measurement: Model.Measurement
    var body: some View {
        HStack {
            Text(measurement.name)
                .font(.subheadline)
            Spacer()
            Toggle(measurement.name, isOn: measurement.isSelected)
                .labelsHidden()
        }
    }
}
</code></pre>

<hr>

<p>For info, here's a screenshot of what I'm trying to achieve. A list of selectable items, with a navigation link that is enabled when one or more is selected, and disabled when no items are selected.</p>

<p><a href=""https://i.stack.imgur.com/KnPgil.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KnPgil.png"" alt=""enter image description here""></a></p>
","123632","","123632","","2020-02-16 17:16:32","2020-02-16 18:32:25","How to add an observable property when other properties change","<swiftui><combine>","2","3","","","","CC BY-SA 4.0"
"60295544","1","60307697","","2020-02-19 08:02:28","","5","1438","<p>In <code>Combine</code>, using only the built-in operators, is there a way to skip an operator on the first value but then apply that operator for all subsequent values? </p>

<p>Consider the following: </p>

<pre><code>publisher
  .debounce(...)
  .sink(...)
</code></pre>

<p>In this arrangement, <code>debounce</code> will wait for the specified timeout to elapse before passing on the value to <code>sink</code>. However, there are many times when you only want <code>debounce</code> to kick-in after the first element. For example, if the user is trying to filter a list of contacts, it's very possible that they only enter one letter into a text field. If that's the case, the application should probably start filtering immediately, without having to wait for the <code>debounce</code> to timeout.</p>

<p>I'm aware of the <code>Drop</code> publishers, but I can't seem to find a combination of them that will perform more of a ""skip"" operation such that the <code>sink</code> receives every value, but the <code>debounce</code> is ignored on the first value. </p>

<p>Something like the following: </p>

<pre><code>publisher
  .if_first_element_passthrough_to_sink(...), else_debounce(...)
  .sink(...)
</code></pre>

<p>Is something like this possible with the built-in operators? </p>

<p><strong>Clarification</strong></p>

<p>Some clarification since my original posting wasn't as clear as it should have been... The answer provided by Asperi below is very close, but ideally the first element in a sequence is always delivered, then <code>debounce</code> would kick in. </p>

<p>Imagine the user is typing the following: </p>

<blockquote>
  <p>A B C ... (pauses typing for a few seconds) ... D ... (pauses) ... E F G</p>
</blockquote>

<p>What I would like is: </p>

<ul>
<li><code>A</code>, <code>D</code> and <code>E</code> are delivered immediately.</li>
<li><code>B C</code> is coalesced into just <code>C</code> using <code>debounce</code></li>
<li><code>F G</code> is coalesced into just <code>G</code> using <code>debounce</code></li>
</ul>
","48321","","48321","","2020-02-19 21:51:17","2020-02-20 09:53:41","How do you apply a Combine operator only after the first message has been received?","<ios><swift><macos><combine>","2","0","","","","CC BY-SA 4.0"
"60306102","1","60306248","","2020-02-19 17:30:58","","0","748","<p>The issue can be seen in the following playground. There are four published values that will be updated asynchronously (an image and three strings). When all four of them have been initialized or subsequently changed then the UI will need to be updated. When I try to capture this data flow using CombineLatest4 the compiler immediately objects to the fourth argument with the message <code>Extra argument in call</code>. (<strong>Note:</strong> the following code doesn't actually do anything since it only has a publisher, but it is sufficient to produce the error message in Playground).</p>

<pre><code>import Combine
import UIKit

struct CustomerUpdates
{
    @Published var photo: UIImage!
    @Published var firstName: String!
    @Published var lastName: String!
    @Published var id: String!

    typealias customerTuple =
        (   photo: UIImage,
            firstName: String,
            lastName: String,
            id: String )
    var validatedCustomer: AnyPublisher&lt; customerTuple, Never &gt;
    {
        return Publishers.CombineLatest4( $photo,
                                          $firstName,
                                          $lastName,
                                          $id )
        {
            photo, firstName, lastName, id in
            if      photo == nil
                ||  firstName == nil
                ||  lastName == nil
                ||  id == nil
            {
                return nil
            }
            return ( photo!, firstName!, lastName!, id! )
        }
        .compactMap
        .return( on: RunLoop.main )
    }
}
</code></pre>

<p>My question is, why does the compiler flag the fourth argument (the ""id"")? Apple's documentation for the CombineLatest4 generic struct says:</p>

<blockquote>
  <p>A publisher that receives and combines the latest elements from four
  publishers.</p>
</blockquote>
","7366424","","7366424","","2020-02-19 17:40:52","2020-02-20 09:47:10","""Extra argument"" error when using CombineLatest from the Combine framework","<ios><swift><compiler-errors><combine>","2","0","","","","CC BY-SA 4.0"
"60355280","1","60357810","","2020-02-22 18:15:59","","2","72","<p>In the Combine framework, what is the <code>Never</code> type exactly?</p>

<p>I don't mean how is it used or what does it signify; I understand that. I mean what is the what-it-is-to-be-a-Never (as Aristotle would say).</p>

<p>I ask because I can't find a declaration of any <code>Never</code> other than this one:</p>

<blockquote>
  <p><a href=""https://developer.apple.com/documentation/swift/never"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/swift/never</a></p>
</blockquote>

<p>But the Combine framework <code>Never</code> cannot be that <code>Never</code>, because the Combine <code>Never</code> has to be usable as a <code>Failure</code> type, and a <code>Failure</code> type can only be an <code>Error</code> adopter:</p>

<blockquote>
  <p><a href=""https://developer.apple.com/documentation/combine/subscriber/3213651-failure"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/combine/subscriber/3213651-failure</a></p>
</blockquote>

<p>But I can find no declaration that the <code>Never</code> in my first link adopts the <code>Error</code> protocol as required by my second link.</p>

<p>So I would expect to be able to find either (1) a place where that <code>Never</code> is declared to adopt the <code>Error</code> protocol or (2) the declaration of a completely different <code>Never</code>. But I can't find it.</p>
","341994","","1271826","","2020-02-23 00:00:47","2020-02-23 00:00:47","What is the ontological status of the Combine framework's Never type?","<ios><combine>","1","0","","","","CC BY-SA 4.0"
"60377801","1","60378223","","2020-02-24 14:17:01","","2","790","<p>I just started to learn SwiftUI, but did not have time to Combine. I don’t understand much about this.
How to pass a value to the progress of downloading in ProgressView.
how to configure ODRManager and how to transfer the value when downloading is in progress, not 0 and immediately 1, but 0.0 ... 0.1.0.2 ... 0.8,0.9,1.0
I would like to know different ways and means only SwiftUI, and using Combine or other methods.</p>

<p>Thanks a lot .</p>

<p>SwiftUI Code</p>

<pre><code>import SwiftUI

struct ProgressView: View {

    @Binding var value: Float

    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                Rectangle()
                    .frame(width: geometry.size.width, height: geometry.size.height)
                    .opacity(0.3)
                    .foregroundColor(.gray)

                Rectangle()
                    .frame(width: min(CGFloat(self.value) * geometry.size.width, geometry.size.width), height: geometry.size.height)
                    .foregroundColor(.blue)
                    .animation(.linear)
            }.cornerRadius(45.0)
        }
    }
}

struct ContentView: View {

    @State var progressValue: Float = 0.0

    var body: some View {
        VStack {
            Button(action: { //here is the function to download from ondemand }) {
                Text(""Download"")
                    .padding(.init(top: 10, leading: 30, bottom: 10, trailing: 30))
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(14)

            }
            .padding(.bottom, 30)

            ProgressView(value: $progressValue)
                .environmentObject(self.manager)
                .frame(width: 250, height: 20)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()

    }
}

</code></pre>

<p>OnDemand manager code</p>

<pre><code>class ODRManager: NSObject {
    var resourceRequest : NSBundleResourceRequest?
    var progress:Float = 0.0 

    func fetchODRResourceWithName(fileName: String) {
        guard self.resourceRequest == nil else {return}
        self.resourceRequest = NSBundleResourceRequest(tags: [fileName])
        progress = Float((resourceRequest?.progress.fractionCompleted)!)
        self.resourceRequest!.progress.addObserver(self, forKeyPath: ""fractionCompleted"", options: .new, context: nil)
        self.resourceRequest?.conditionallyBeginAccessingResources(completionHandler: { (resourceAvailable) in
            if !resourceAvailable {
                self.resourceRequest!.beginAccessingResources { err in
                    guard err == nil else {
                        print(err as Any)
                        return
                    }
                  print(""downloading.."")
                }
            } else { 
               print(""was downloaded"")
            }
        })
    }

    func stopDownloadingFile() {
        guard self.resourceRequest != nil else {
            return
        }
        self.resourceRequest!.endAccessingResources()
        self.resourceRequest!.progress.removeObserver(self, forKeyPath: ""fractionCompleted"")
        self.resourceRequest!.progress.cancel()
        self.resourceRequest = nil
    }

    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if keyPath == ""fractionCompleted"" {
            DispatchQueue.main.async { [weak self] in
                self.progress = Float((self?.resourceRequest!.progress.fractionCompleted)!)
            }
        }
    }
}
</code></pre>
","9000279","","","","","2020-02-24 14:45:00","How to pass the value of progress in SwiftUI(maybe with combine)?","<swiftui><key-value-observing><combine>","2","0","1","","","CC BY-SA 4.0"
"60381905","1","60381982","","2020-02-24 18:26:06","","0","209","<p>I can see the Foundation header that defines <code>NSObject.KeyValueObservingPublisher</code>. But I can't find the header that defines the <code>publish(for:)</code> method that returns this publisher. And I can’t find it in the documentation. </p>

<p>It must involve NSObject, because only an NSObject can be observed with KVO. And it must come in the forms <code>publisher(for:)</code> and <code>publisher(for:options:)</code>, because that's what code completion offers me in Xcode. But <em>where</em> is code completion getting that information <em>from?</em></p>
","341994","","341994","","2020-02-25 11:13:52","2020-04-08 20:11:25","Where is the header that defines the `publisher(for:)` method that yields a KeyValueObservingPublisher?","<ios><combine>","1","0","","","","CC BY-SA 4.0"
"60386000","1","60390057","","2020-02-25 00:40:50","","7","2015","<p>I'm trying to use the Combine framework NSObject.KeyValueObservingPublisher. I can see how to produce this publisher by calling <code>publisher(for:options:)</code> on an NSObject. But I'm having two problems:</p>

<ul>
<li><p>I can include <code>.old</code> in the <code>options</code>, but no <code>.old</code> value ever arrives. The only values that appear are the <code>.initial</code> value (when we subscribe) and the <code>.new</code> value (each time the observed property changes). I can suppress the <code>.initial</code> value but I can't suppress the <code>.new</code> value or add the <code>.old</code> value.</p></li>
<li><p>If the <code>options</code> are <code>[.initial, .new]</code> (the default), I see no way to distinguish whether the value I'm receiving is <code>.initial</code> or <code>.new</code>. With ""real"" KVO I get an NSKeyValueChangeKey or an NSKeyValueObservedChange that tells me what I'm getting. But with the Combine publisher, I don't. I just get unmarked values.</p></li>
</ul>

<p>It seems to me that these limitations make this publisher all but unusable except in the very simplest cases. Are there any workarounds?</p>
","341994","","","","","2020-02-25 21:53:34","How to use Combine framework NSObject.KeyValueObservingPublisher?","<ios><combine>","2","2","1","","","CC BY-SA 4.0"
"60406189","1","60406282","","2020-02-26 03:11:38","","2","1243","<pre><code>import UIKit
import Combine

class ViewController: UIViewController {

    @IBOutlet weak var allowMessageSwitch: UISwitch!
    @IBOutlet weak var sendButton: UIButton!
    @IBOutlet weak var messageLabel: UILabel!

    @Published var canSendMessages: Bool = false
    @Published var newMsg: String = """"

    private var switchSubscriber: AnyCancellable?
    private var btnSubscriber: AnyCancellable?


    override func viewDidLoad() {
        allowMessageSwitch.isOn = false
        super.viewDidLoad()
        setupProcesscingChain()
    }

    func setupProcesscingChain() {
        switchSubscriber = $canSendMessages.receive(on: DispatchQueue.main).assign(to: \.isEnabled, on: sendButton)

        btnSubscriber = $newMsg.receive(on: DispatchQueue.main).assign(to: \.text, on: messageLabel)
    }

    @IBAction func didSwitch (_ sender: UISwitch) {
        canSendMessages = sender.isOn
    }

    @IBAction func sendMessage( _ sender: Any) {
    }


}
</code></pre>

<p>I am getting error in </p>

<pre><code>btnSubscriber = $newMsg.receive(on: DispatchQueue.main).assign(to: \.text, on: messageLabel)
</code></pre>

<p>error msg is </p>

<blockquote>
  <p>Type of expression is ambiguous without more context</p>
</blockquote>

<p>I dont understand why label does not work as Switcher (bool) </p>

<p>I assume it is because <code>\.isEnabled</code> is not optional, and <code>\.text</code> is optional..??</p>

<p>how can I make this work with the same format. this is for practice and to understand how Combine works.. please help!</p>
","12139943","","1271826","","2020-02-26 04:51:09","2020-02-26 04:51:09","Swift Combine question with UILabel subscribe","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"60416549","1","60418000","","2020-02-26 14:49:45","","3","4628","<p>I am creating a Contact Class to fetch user's phoneNumbers asynchronously. </p>

<p>I created 3 functions that leveraged on the new Combine framework's Future. </p>

<pre><code>func checkContactsAccess() -&gt; Future&lt;Bool, Never&gt;  {
    Future { resolve in
            let authorizationStatus = CNContactStore.authorizationStatus(for: .contacts)

        switch authorizationStatus {
            case .authorized:
                return resolve(.success(true))

            default:
                return resolve(.success(false))
        }
    }
}
</code></pre>

<pre><code>func requestAccess() -&gt; Future&lt;Bool, Error&gt;  {
    Future { resolve in
        CNContactStore().requestAccess(for: .contacts) { (access, error) in
            guard error == nil else {
                return resolve(.failure(error!))
            }

            return resolve(.success(access))
        }
    }
}
</code></pre>

<pre><code>func fetchContacts() -&gt; Future&lt;[String], Error&gt;  {
   Future { resolve in
            let contactStore = CNContactStore()
            let keysToFetch = [
                CNContactFormatter.descriptorForRequiredKeys(for: .fullName),
                CNContactPhoneNumbersKey,
                CNContactEmailAddressesKey,
                CNContactThumbnailImageDataKey] as [Any]
            var allContainers: [CNContainer] = []

            do {
                allContainers = try contactStore.containers(matching: nil)
            } catch {
                return resolve(.failure(error))
            }

            var results: [CNContact] = []

            for container in allContainers {
                let fetchPredicate = CNContact.predicateForContactsInContainer(withIdentifier: container.identifier)

                do {
                    let containerResults = try contactStore.unifiedContacts(matching: fetchPredicate, keysToFetch: keysToFetch as! [CNKeyDescriptor])
                    results.append(contentsOf: containerResults)
                } catch {
                    return resolve(.failure(error))
                }
            }

            var phoneNumbers: [String] = []

            for contact in results {
                for phoneNumber in contact.phoneNumbers {
                    phoneNumbers.append(phoneNumber.value.stringValue.replacingOccurrences(of: "" "", with: """"))
                }
            }

            return resolve(.success(phoneNumbers))
        }
}
</code></pre>

<p>Now how do I combine these 3 Future into a single future? </p>

<p>1) Check if permission is available</p>

<p>2) If true fetchContacts asynchronously</p>

<p>3) If false requestAccess asynchronously then fetchContacts asynchronously</p>

<p>Any tips or tricks of how you will handle this better are also welcomed</p>

<pre><code>func getPhoneNumbers() -&gt; Future&lt;[String], Error&gt; {
...
}
</code></pre>
","9930296","","9930296","","2020-02-26 15:27:47","2020-10-29 02:33:04","Using Combine's Future to replicate async await in Swift","<swift><asynchronous><async-await><combine>","2","6","1","","","CC BY-SA 4.0"
"60423149","1","60426960","","2020-02-26 21:51:58","","1","68","<p>I am trying to create a basic sign up screen. The screen appears fine however when I click submit, and an error is returned, the <code>@State</code> variables (such as <code>$viewModel.firstName</code> and <code>$lastname</code> reset back to empty strings, so my user loses all their progress.</p>

<p>Sign Up Screen</p>

<pre><code>struct SignUpScreen: View {

    @State
    var firstName: String = """"
    @State
    var lastName: String = """"
    @State
    var birthday: String = """"
    @State
    var number: String = """"
    @State
    var email: String = """"
    @State
    var password: String = """"
    @State
    var confirmPassword: String = """"

    @ObservedObject
    var viewModel: SignUpViewModel = SignUpViewModel()


    var body: some View {
        ZStack {
            VStack {
                VClearBackground()
                Spacer()
            }
            ScrollView {
                VStack(alignment: .leading) {
                    Group {
                        PreHeaderText(header: ""Get Started"")
                            .alignmentGuide(.leading, computeValue: {d in
                                d[.leading]
                            })
                            .padding(EdgeInsets.init(top: 32, leading: 0, bottom: 0, trailing: 0))
                        HeaderText(header: ""Create Account"")
                        EditText(hint: ""John"", text: $viewModel.firstName, label: ""FIRST NAME"", textContentType: UITextContentType.name)
                        EditText(hint: ""Doe"", text: $lastName, label: ""LAST NAME"", textContentType: UITextContentType.name)
                        EditText(hint: ""01/01/2001"", text: $birthday, label: ""BIRTHDAY"")
                        EditText(hint: ""(123) 456-7890)"", text: $number, label: ""MOBILE NUMBER"", textContentType: UITextContentType.telephoneNumber, keyboardType: UIKeyboardType.phonePad)
                        EditText(hint: ""email@exmaple.com"", text: $email, label: ""EMAIL"", textContentType: UITextContentType.emailAddress)
                        EditText(hint: ""********"", text: $password, label: ""PASSWORD"", textContentType: UITextContentType.newPassword)
                        EditText(hint: ""********"", text: $confirmPassword, label: ""CONFIRM PASSWORD"", textContentType: UITextContentType.newPassword)
                    }
                    Group {
                        if self.viewModel.error != nil {
                            HStack {
                                Spacer()
                                Text(viewModel.error ?? """")
                                    .foregroundColor(ColorTheme.error.color)
                                Spacer()
                            }
                            .padding()
                        }
                        HStack {
                            Spacer()
                            VowerButton(text: ""Submit"") {
                                self.viewModel.signUp(firstName: self.viewModel.firstName, lastName: self.lastName, email: self.email, birthday: self.birthday, phoneNumber: self.number, password: self.password, confirmPassword: self.confirmPassword)
                            }
                            Spacer()
                        }
                        .padding()

                        HStack {
                            Spacer()
                            NavigationLink(destination: LoginScreen(), isActive: $viewModel.goToLogin) {
                                CtaText(text: ""Have an account?"", cta: ""Login"") {
                                    self.viewModel.onGoToLoginClicked()
                                }
                            }
                            .padding()
                            Spacer()
                        }

                        Spacer()
                    }
                }
            }
            .padding(EdgeInsets.init(top: 16, leading: 16, bottom: 16, trailing: 16))
            .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .leading)
        }
        .background(LinearGradient(gradient: Gradient(colors: [.black, ColorTheme.brandPurple.color]), startPoint: .top, endPoint: .bottom))
        .edgesIgnoringSafeArea(.all)
    }
}
</code></pre>

<p>Sign Up ViewModel</p>

<pre><code>class SignUpViewModel : ObservableObject {
    @State
    var firstName: String = """"

    @Published
    var error: String? = nil

    @Published
    var goHome: Bool = false

    @Published
    var goToLogin: Bool = false

    func onGoToLoginClicked() {
        self.goToLogin = true
    }

    func signUp(firstName: String, lastName: String, email: String, birthday: String, phoneNumber: String, password: String, confirmPassword: String) {
        if (firstName.count &lt; 3) {
            error = ""Please enter first name""
            return
        }
        if (lastName.count &lt; 3) {
            error = ""Please enter last name""
            return
        }
        if (!email.isEmail()) {
            error = ""Pleaes enter valid email""
            return
        }
        if (birthday.isEmpty) {
            error = ""Pleae enter valid birthday""
            return
        }
        if (!phoneNumber.isDigits) {
            error = ""Please enter valid phone number""
            return
        }
        if (password.count &lt; 8) {
            error = ""Please enter a password that is at least 8 characters long""
        }
        if (password != confirmPassword) {
            error = ""Password do not match""
        }
        Auth.auth().createUser(withEmail: email, password: password, completion: { authResult, error in
            if authResult != nil {
                self.goHome = true
            } else {
                self.error = error?.localizedDescription
            }
        })
    }
}
</code></pre>

<p>EditText View</p>

<pre><code>struct EditText: View {

    var hint: String
    @Binding
    var text: String
    var label: String = """"
    var defaultValue =  """"
    var textContentType: UITextContentType? = .none
    var keyboardType: UIKeyboardType = .default

    private func initializeDefaultValue() {
        DispatchQueue.main.async {
            self.text = self.defaultValue
        }
    }

    var body: some View {
        initializeDefaultValue()
        return VStack(alignment: .leading) {
            Text(label).font(.system(size: 12)).bold()
                .foregroundColor(ColorTheme.text.color)
            HStack {
                TextField(hint, text: $text)
                .lineLimit(1)
                .textContentType(textContentType)
                .keyboardType(keyboardType)
                    .foregroundColor(ColorTheme.text.color)
            }
            Divider().background(Color(ColorTheme.brandBlue.value))
        }
        .padding(EdgeInsets.init(top: 12, leading: 0, bottom: 8, trailing: 0))
    }
}
</code></pre>
","1120154","","","","","2020-02-27 05:46:24","Why do my @State objects not retain their value?","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"60424909","1","60425069","","2020-02-27 01:07:53","","8","3329","<p>I’m following this tutorial for SwiftUI amplify app where I came across this error when creating a final class which conforms to Bindable object.</p>

<p><code>Error:Use of undeclared type 'BindableObject'</code></p>

<pre><code>import Combine  
import SwiftUI  
import AWSAppSync  

final class TalkStore: BindableObject {
/*
    Required by SwiftUI
*/
    let didChange = PassthroughSubject&lt;TalkStore, Never&gt;()
    var listTalks: [ListTodosQuery.Data.ListTodo.Item] {
        didSet {
            didChange.send(self)
        }
    }

    //We will be using this later.
    private let appSyncClient: AWSAppSyncClient!

/*
    Init if running app is using SwiftUI Content View
*/
    init(talks: [ListTodosQuery.Data.ListTodo.Item]) {
        self.appSyncClient = nil
        self.listTalks = talks
    }
}
</code></pre>

<p>Is it possible that Apple has changed the class name?<br>
How do I find that out?</p>
","9183841","","10749567","","2020-02-27 05:08:19","2020-02-27 05:08:19","Error: Use of undeclared type BindableObject","<ios><swift><swiftui><aws-amplify>","1","0","","","","CC BY-SA 4.0"
"60427043","1","60427134","","2020-02-27 05:54:57","","1","269","<p>I'm working on an SDK, and have developed a nice concise Combine pipeline method that accepts a generic parameter that's used to decode json with. Effectively, it's a re-usable combine pipeline for JSON -> <code>Decodable</code>.
Works really well. Here's what that pipeline looks like: </p>

<pre><code>func records&lt;Record: Decodable&gt;(forRequest request:RestRequest ) -&gt; AnyPublisher&lt;[Record], Never&gt; {
return NetworkService.publisher(for: request)
  .tryMap({ (response) -&gt; Data in
    response.asData()
  })
  .decode(type: Wrapper&lt;Record&gt;.self, decoder: JSONDecoder())
  .map({ (record) -&gt; [Record] in
    record.records
  })
  .catch({ _ in
    Just([Record]())
  })
  .eraseToAnyPublisher()
}
</code></pre>

<p>Usage:</p>

<pre><code>contactsCancellable = NetworkService.records(forRequest: request)
  .receive(on: RunLoop.main)
  .assign(to: \.contacts, on: self)
</code></pre>

<p>It's my understanding that Swift+Combine is inferring the generic parameter type from the <code>assign(to:, on:)</code> call.</p>

<p>But the powers that be want a non-Combine version, and I'm really struggling to figure out how to help Swift infer the type. I tried building a direct analog like this:</p>

<pre><code>func fetchRecords&lt;Record: Decodable&gt;(forRequest request: RestRequest,
                   _ completionBlock: @escaping (Result&lt;[Record], RestClientError&gt;) -&gt; Void) {

RestClient.shared.send(request: request) { result in
   switch result {
     case .success(let response):
       do {
          let decoder = JSONDecoder()
          let wrapper = try decoder.decode(Wrapper&lt;Record&gt;.self, from: response.asData())
          completionBlock(.success(wrapper.records))
       } catch {
          completionBlock(.success([Record]()))
       }
     case .failure(let err):
       completionBlock(.failure(err))
    }
  }
}
</code></pre>

<p>This <em>compiles</em> however, executing that method like this:</p>

<pre><code>NetworkService.fetchRecords(forRequest: request) { records in
  print(records)
}
</code></pre>

<p>Results in a lovingly cryptic error Generic parameter 'Record' could not be inferred </p>

<p>How can I specify that generic Record 'type' - anything that conforms to Decodable, in this non-combine version?</p>

<p>Ps: Here's that Wrapper struct:</p>

<pre><code>struct Wrapper&lt;R: Decodable&gt;: Decodable {
  var totalSize: Int
  var done: Bool
  var records: [R]
}
</code></pre>
","1132573","","220819","","2020-02-27 06:00:32","2020-02-27 06:50:02","Swift Type Inference with Generic method","<swift><generics><type-inference>","1","2","1","","","CC BY-SA 4.0"
"60428303","1","60444607","","2020-02-27 07:35:39","","5","2389","<p>How to convert <code>URLSession.DataTaskPublisher</code> to <code>Future</code> in Combine framework.
In my opinion, the Future publisher is more appropriate here because the call can emit only one response and fails eventually.</p>

<p>In RxSwift there is helper method like <code>asSingle</code>.</p>

<p>I have achieved this transformation using the following approach but have no idea if this is the best method.</p>

<pre><code>        return Future&lt;ResponseType, Error&gt;.init { (observer) in
        self.urlSession.dataTaskPublisher(for: urlRequest)
            .tryMap { (object) -&gt; Data in
            //......
            }
            .receive(on: RunLoop.main)
            .sink(receiveCompletion: { (completion) in
                if case let .failure(error) = completion {
                    observer(.failure(error))
                }
            }) { (response) in
                observer(.success(response))
            }.store(in: &amp;self.cancellable)
    }
}
</code></pre>

<p>Is there any easy way to do this?</p>
","1401983","","1401983","","2020-02-28 07:15:52","2021-02-03 22:59:39","Convert URLSession.DataTaskPublisher to Future publisher","<ios><swift><combine>","3","4","","","","CC BY-SA 4.0"
"60439788","1","60440663","","2020-02-27 18:42:12","","2","5079","<p>I don't manage to trigger the onReceive method in a SwiftUI View whenever a variable from ObservedObject changes.</p>

<p>I tried two methods: using <strong>@Publish</strong> and using <strong>PassthroughSubject&lt;></strong></p>

<p><strong>Here is the ViewModel</strong> </p>

<pre><code>class MenuViewModel: ObservableObject {

@Published var selectedItems = Set&lt;UUID&gt;()
@Published var currentFocusItem: UUID?

// Output
let newItemOnFocus = PassthroughSubject&lt;(UUID?), Never&gt;()

// This function gets called good :)
func tapOnMenuItem(_ item: MenuItem) {
    if selectedItems.contains(item.id) {
        //These changes should trigger the onReceive?
        currentFocusItem = item.id  
        newItemOnFocus.send(item.id)
    } else {
        selectedItems.insert(item.id)
        currentFocusItem = nil
        newItemOnFocus.send(nil)
    }
}
}
</code></pre>

<p><strong>Here is the View</strong> when trying to catch the changes in <strong>@Published</strong> var currentFocusItem</p>

<pre><code>struct MenuView: View {

    @ObservedObject private var viewModel: MenuViewModel
    @State var showPicker = false
    @State private var menu: Menu = Menu.mockMenu()


    init(viewModel: MenuViewModel = MenuViewModel()) {
        self.viewModel = viewModel
    }

    var body: some View {
        VStack {
            List(menu.items, selection: $viewModel.selectedItems) { item in
                MenuItemView(item: item)
            }

            Divider()
            getBottomView(showPicker: showPicker)
        }

        .navigationBarTitle(""Title"")
        .navigationBarItems(trailing: Button(action: closeModal) {
            Image(systemName: ""xmark"")
        })
        .onReceive(viewModel.$currentFocusItem, perform: { itemUUID in
            self.showPicker = itemUUID != nil // &lt;-- This only gets called at launch time
        })           
    }
}
</code></pre>

<p><strong>The View</strong> in the same way but trying to catch the <strong>PassthroughSubject&lt;></strong></p>

<pre><code>.onReceive(viewModel.newItemOnFocus, perform: { itemUUID in
            self.showPicker = itemUUID != nil // &lt;-- This never gets called
        })
</code></pre>

<p><strong>----------EDIT----------</strong> </p>

<p>Adding MenuItemView, although viewModel.tapOnMenuItem gets always called, so I am not sure if it's very relevant</p>

<p><strong>MenuItemView</strong> is here:</p>

<pre><code>struct MenuItemView: View {

    var item: MenuItem
    @ObservedObject private var viewModel: MenuViewModel = MenuViewModel()
    @State private var isSelected = false

    var body: some View {
        HStack(spacing: 24) {
            Text(isSelected ? "" 1 "" : item.icon)
                .font(.largeTitle)
                .foregroundColor(.blue)
                .bold()
            VStack(alignment: .leading, spacing: 12) {
                Text(item.name)
                    .bold()
                Text(item.description)
                    .font(.callout)
            }
            Spacer()
            Text(""\(item.points)\npoints"")
                .multilineTextAlignment(.center)
        }
        .padding()
        .onTapGesture {
            self.isSelected = true
            self.viewModel.tapOnMenuItem(self.item). // &lt;-- Here tapOnMenuItem gets called
        }
    }

    func quantityText(isItemSelected: Bool) -&gt; String {
        return isItemSelected ? ""1"" : item.icon
    }
}
</code></pre>

<p>What am I doing wrong?</p>
","3891891","","3891891","","2020-02-27 19:37:49","2020-02-27 19:42:19","onReceive not getting called in SwiftUI View when ObservedObject changes","<ios><swift><mvvm><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"60445468","1","60446560","","2020-02-28 04:53:32","","2","118","<p>I have a <code>TextField</code> which is user editable, but may also be updated by changes to a <code>ViewModel</code>.</p>

<p>There seems to be some arcane magic determining when my <code>TextField</code> updates itsself, however.</p>

<p>Here's a playground:</p>

<pre class=""lang-swift prettyprint-override""><code>import Combine
import SwiftUI

class ViewModel: ObservableObject {

    @Published var text: String = ""0""

    private var cancellables: [AnyCancellable] = []

    init() {
        // output what the value of `text` is, whenever it changes
        let c = $text.print().sink { _ in }
        cancellables.append(c)
    }

    func fetch() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            self.text += ""3""
        }
    }

    deinit { print(""deinit"") }
}

struct V: View {

    @ObservedObject var viewModel = ViewModel()

    init() {
        viewModel.text += ""1""
    }

    var body: some View {
        TextField(""TextField"", text: $viewModel.text)
            .onAppear { self.viewModel.text += ""2"" }
            .onAppear { self.viewModel.fetch() }
    }
}

var v: V? = V()

DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
    v = nil
}
</code></pre>

<p>I can see from the <code>print()</code> in <code>ViewModel.init()</code> that <code>ViewModel.text</code> is updated as expected. Final value: <code>0123</code>.</p>

<p><strong>What I don't understand: why does the <code>TextField</code> value stop updating when it reaches <code>012</code>?</strong></p>
","969305","","969305","","2020-02-28 12:58:59","2020-02-28 12:58:59","Why does binding not work between View and ViewModel in Playgrounds?","<swift><swiftui>","2","0","","","","CC BY-SA 4.0"
"60452433","1","60453592","","2020-02-28 13:09:01","","2","346","<p>Imagine I have a view with some mutable state, but that the state might need to be updated to reflect changes in another object (e.g. a <code>ViewModel</code>).</p>

<p>How can I implement that in SwiftUI?</p>

<p>I've tried the following, but can't get the view to reflect updates coming from the <code>ViewModel</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>class ViewModel: ObservableObject {

    @Published var text: String = ""loading""

    private var task: AnyCancellable?

    func fetch() {
        task = Just(""done"")
            .delay(for: 1, scheduler: RunLoop.main)
            .assign(to: \.text, on: self)
    }
}

struct ContentView: View {

    @ObservedObject var viewModel = ViewModel()

    @State var viewText = ""idle""

    private var bind: AnyCancellable?

    init() {
        viewText = viewModel.text
        bind = viewModel
            .$text
            .print()
            .assign(to: \.viewText, on: self)
    }

    var body: some View {
        VStack {
            TextField(titleKey: ""editable text"", text: $viewText)
            Text(viewText)
            Text(viewModel.text)
        }
        .onAppear {
            self.viewModel.fetch()
        }
    }
}
</code></pre>

<p>The <code>TextField</code> and the first <code>Text</code> element get their content from <code>ContentView.viewText</code>, the second <code>Text</code> goes directly to the source: <code>ViewModel.text</code>.</p>

<p>As expected, the second <code>Text</code> shows <code>""loading""</code> and then <code>""done""</code>. The first <code>Text</code> never changes from <code>""idle""</code>.</p>
","969305","","969305","","2020-02-29 22:16:42","2020-02-29 22:16:42","How can I update view state in response to external changes?","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"60457051","1","60482150","","2020-02-28 18:01:46","","0","162","<p>When I type in my EditText view to fill out all the required information and then click submit. Everything I typed disappears. I want this text to remain. I am guessing there is something wrong with my <code>@State</code> objects but cannot figure out what.</p>

<p>SignUpViewModel</p>

<pre><code>class SignUpViewModel : ObservableObject {

    @Published
    var error: String? = nil

    @Published
    var goHome: Bool = false

    @Published
    var goToLogin: Bool = false

    func onGoToLoginClicked() {
        self.goToLogin = true
    }

    func signUp(firstName: String, lastName: String, email: String, birthday: String, phoneNumber: String, password: String, confirmPassword: String) {
        if (firstName.count &lt; 3) {
            error = ""Please enter first name""
            return
        }
        if (lastName.count &lt; 3) {
            error = ""Please enter last name""
            return
        }
        if (!email.isEmail()) {
            error = ""Pleaes enter valid email""
            return
        }
        if (birthday.isEmpty) {
            error = ""Pleae enter valid birthday""
            return
        }
        if (!phoneNumber.isDigits) {
            error = ""Please enter valid phone number""
            return
        }
        if (password.count &lt; 8) {
            error = ""Please enter a password that is at least 8 characters long""
        }
        if (password != confirmPassword) {
            error = ""Password do not match""
        }
        Auth.auth().createUser(withEmail: email, password: password, completion: { authResult, error in
            if authResult != nil {
                self.goHome = true
            } else {
                self.error = error?.localizedDescription
            }
        })
    }
}
</code></pre>

<p>SignUp View</p>

<pre><code>struct SignUpScreen: View {

    @State
    var firstName: String = """"
    @State
    var lastName: String = """"
    @State
    var birthday: String = """"
    @State
    var number: String = """"
    @State
    var email: String = """"
    @State
    var password: String = """"
    @State
    var confirmPassword: String = """"

    @EnvironmentObject
    var viewModel: SignUpViewModel


    var body: some View {
        ZStack {
            VStack {
                VClearBackground()
                Spacer()
            }
            ScrollView {
                VStack(alignment: .leading) {
                    Group {
                        PreHeaderText(header: ""Get Started"")
                            .alignmentGuide(.leading, computeValue: { d in
                                d[.leading]
                            })
                            .padding(EdgeInsets.init(top: 32, leading: 0, bottom: 0, trailing: 0))
                        HeaderText(header: ""Create Account"")
                        EditText(hint: ""Huey"", text: $firstName, label: ""FIRST NAME"", textContentType: UITextContentType.name)
                        EditText(hint: ""Freeman"", text: $lastName, label: ""LAST NAME"", textContentType: UITextContentType.name)
                        EditText(hint: ""04-19-1994"", text: $birthday, label: ""BIRTHDAY"")
                        EditText(hint: ""(281) 456-7890)"", text: $number, label: ""MOBILE NUMBER"", textContentType: UITextContentType.telephoneNumber, keyboardType: UIKeyboardType.phonePad)
                        EditText(hint: ""email@exmaple.com"", text: $email, label: ""EMAIL"", textContentType: UITextContentType.emailAddress)
                        EditText(hint: ""********"", text: $password, label: ""PASSWORD"", textContentType: UITextContentType.newPassword)
                        EditText(hint: ""********"", text: $confirmPassword, label: ""CONFIRM PASSWORD"", textContentType: UITextContentType.newPassword)
                    }
                    Group {
                        if self.viewModel.error != nil {
                            HStack {
                                Spacer()
                                Text(viewModel.error ?? """")
                                    .foregroundColor(ColorTheme.error.color)
                                Spacer()
                            }
                            .padding()
                        }
                        HStack {
                            Spacer()
                            VowerButton(text: ""Submit"") {
                                self.viewModel.signUp(firstName: self.firstName, lastName: self.lastName, email: self.email, birthday: self.birthday, phoneNumber: self.number, password: self.password, confirmPassword: self.confirmPassword)
                            }
                            Spacer()
                        }
                        .padding()

                        HStack {
                            Spacer()
                            NavigationLink(destination: LoginScreen(), isActive: $viewModel.goToLogin) {
                                CtaText(text: ""Have an account?"", cta: ""Login"") {
                                    self.viewModel.onGoToLoginClicked()
                                }
                            }
                            .padding()
                            Spacer()
                        }

                        Spacer()
                    }
                }
            }
            .padding(EdgeInsets.init(top: 16, leading: 16, bottom: 16, trailing: 16))
            .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .leading)
        }
        .background(LinearGradient(gradient: Gradient(colors: [.black, ColorTheme.brandPurple.color]), startPoint: .top, endPoint: .bottom))
        .edgesIgnoringSafeArea(.all)
    }
}
</code></pre>

<p>EditText View</p>

<pre><code>struct EditText: View {

    var hint: String
    @Binding
    var text: String
    var label: String = """"
    var defaultValue =  """"
    var textContentType: UITextContentType? = .none
    var keyboardType: UIKeyboardType = .default

    private func initializeDefaultValue() {
        DispatchQueue.main.async {
            self.text = self.defaultValue
        }
    }

    var body: some View {
        initializeDefaultValue()
        return VStack(alignment: .leading) {
            Text(label).font(.system(size: 12)).bold()
                .foregroundColor(ColorTheme.text.color)
            HStack {
                TextField(hint, text: $text)
                .lineLimit(1)
                .textContentType(textContentType)
                .keyboardType(keyboardType)
                    .foregroundColor(ColorTheme.text.color)
            }
            Divider().background(Color(ColorTheme.brandBlue.value))
        }
        .padding(EdgeInsets.init(top: 12, leading: 0, bottom: 8, trailing: 0))
    }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/eUVYr.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/eUVYr.gif"" alt=""Preview""></a></p>
","1120154","","1120154","","2020-03-01 18:37:28","2020-03-02 03:24:07","Why does Text disappear when i click submit?","<ios><swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"60467247","1","60534193","","2020-02-29 16:23:57","","2","3604","<p>Today again one combine problem I currently run in and I hope that someone of you can help. How can normal unit tests be written for ObservableObjects classes which contain @Published attributes? How can I subscribe in my test to them to get the result object which I can assert?</p>

<p>The injected mock for the web service works correctly, <code>loadProducts()</code> function set exactly the same elements from the mock in the <code>fetchedProducts</code> array. </p>

<p>But I don't know currently how to access this array in my test after it is filled by the function because it seems that I cannot work with expectations here, <code>loadProducts()</code> has no completion block.</p>

<p>The code looks like this:</p>

<pre><code>class ProductsListViewModel: ObservableObject {
    let getRequests: GetRequests
    let urlService: ApiUrls

    private let networkUtils: NetworkRequestUtils

    let productsWillChange = ObservableObjectPublisher()

    @Published var fetchedProducts = [ProductDTO]()
    @Published var errorCodeLoadProducts: Int?

    init(getRequestsHelper: GetRequests, urlServiceClass: ApiUrls = ApiUrls(), utilsNetwork: NetworkRequestUtils = NetworkRequestUtils()) {
        getRequests = getRequestsHelper
        urlService = urlServiceClass
        networkUtils = utilsNetwork
    }


    // nor completion block in the function used
    func loadProducts() {
        let urlForRequest = urlService.loadProductsUrl()

        getRequests.getJsonData(url: urlForRequest) { [weak self] (result: Result&lt;[ProductDTO], Error&gt;) in
            self?.isLoading = false
            switch result {
            case .success(let productsArray):
                // the products filled async here
                self?.fetchedProducts = productsArray
                self?.errorCodeLoadProducts = nil
            case .failure(let error):
                let errorCode = self?.networkUtils.errorCodeFrom(error: error)
                self?.errorCodeLoadProducts = errorCode
                print(""error: \(error)"")
            }
        }
    }
}
</code></pre>

<p>The test I try to write looks like this at the moment:</p>

<pre><code>import XCTest
@testable import MyProject

class ProductsListViewModelTest: XCTestCase {
    var getRequestMock: GetRequests!
    let requestManagerMock = RequestManagerMockLoadProducts()

    var productListViewModel: ProductsListViewModel!

    override func setUp() {
        super.setUp()

        getRequestMock = GetRequests(networkHelper: requestManagerMock)
        productListViewModel = ProductsListViewModel(getRequestsHelper: getRequestMock)
    }

    func test_successLoadProducts() {
        let loginDto = LoginResponseDTO(token: ""token-token"")
        UserDefaults.standard.save(loginDto, forKey: CommonConstants.persistedLoginObject)

        productListViewModel.loadProducts()

        // TODO access the fetchedProducts here somehow and assert them
    }
}

</code></pre>

<p>The Mock looks like this:</p>

<pre><code>class RequestManagerMockLoadProducts: NetworkRequestManagerProtocol {
    var isSuccess = true

    func makeNetworkRequest&lt;T&gt;(urlRequestObject: URLRequest, completion: @escaping (Result&lt;T, Error&gt;) -&gt; Void) where T : Decodable {
        if isSuccess {
            let successResultDto = returnedProductedArray() as! T
            completion(.success(successResultDto))
        } else {
            let errorString = ""Cannot create request object here""
            let error = NSError(domain: ErrorDomainDescription.networkRequestDomain.rawValue, code: ErrorDomainCode.unexpectedResponseFromAPI.rawValue, userInfo: [NSLocalizedDescriptionKey: errorString])

            completion(.failure(error))
        }
    }

    func returnedProductedArray() -&gt; [ProductDTO] {
        let product1 = ProductDTO(idFromBackend: ""product-1"", name: ""product-1"", description: ""product-description"", price: 3.55, photo: nil)
        let product2 = ProductDTO(idFromBackend: ""product-2"", name: ""product-2"", description: ""product-description-2"", price: 5.55, photo: nil)
        let product3 = ProductDTO(idFromBackend: ""product-3"", name: ""product-3"", description: ""product-description-3"", price: 8.55, photo: nil)
        return [product1, product2, product3]
    }
}
</code></pre>
","4017243","","4017243","","2020-03-01 07:31:19","2020-05-17 16:22:14","Write unit tests for ObservableObject ViewModels with Published results","<swift><xcode><unit-testing><swiftui><combine>","2","0","1","","","CC BY-SA 4.0"
"60473348","1","60473693","","2020-03-01 08:35:37","","1","850","<p>Experimenting with Combine, I've seen the <code>AnyCancellable.store(in:)</code> method for retaining Subscribers. I've been wondering with this setup:</p>

<pre><code>class Controller
{
  static var cancellables = Set&lt;AnyCancellable&gt;()
}

let label = UILabel(frame: .zero)
</code></pre>

<p>if there an advantage over retaining a <code>Subscriber</code> with this:</p>

<pre><code>Controller.$value
  .assign(to: \UILabel.text, on: label)
  .store(in: &amp;cancellables)
</code></pre>

<p>over this:</p>

<pre><code>let subscriber = Controller.$value
  .assign(to: \UILabel.text, on: label)

Controller.cancellables.insert(subscriber)
</code></pre>

<p>or if it's mainly stylistic. Both seem to work in testing.</p>
","6205653","","","","","2020-03-01 09:27:58","Advantage of AnyCancellable.store(in:) over Set<AnyCancellable>.insert(:)","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"60480652","1","60482411","","2020-03-01 23:13:13","","3","3236","<p>I'm trying to pause my AVPlayer when the item finishes playing. What is the best way to do this with SwiftUI? I don't know much about notifications, where to declare them, etc. Is there a way to use Combine for this? Sample code would be awesome! Thank you in advance.</p>

<p>UPDATE:</p>

<p>With help from the answer below, I managed to make a class which takes an AVPlayer and publishes a notification when the item ends. You can subscribe to the notification with the following:</p>

<p>Class:</p>

<pre><code>import Combine
import AVFoundation

class PlayerFinishedObserver {

    let publisher = PassthroughSubject&lt;Void, Never&gt;()

    init(player: AVPlayer) {
        let item = player.currentItem

        var cancellable: AnyCancellable?
        cancellable = NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: item).sink { [weak self] change in
            self?.publisher.send()
            print(""Gotcha"")
            cancellable?.cancel()
        }
    }
}
</code></pre>

<p>Add to your struct:</p>

<pre><code>let finishedObserver: PlayerFinishedObserver
</code></pre>

<p>Subscribe on some View:</p>

<pre><code>.onReceive(finishedObserver.publisher) {
                print(""Gotcha!"")
            }
</code></pre>
","12506105","","12506105","","2020-03-11 17:04:48","2020-03-11 17:04:48","Struggling with NotificationCenter/Combine in SwiftUI/AVPlayer","<swift><swiftui><avplayer><combine><notificationcenter>","1","0","2","","","CC BY-SA 4.0"
"60482098","1","60483313","","2020-03-02 03:16:36","","13","7801","<p>Basically I try to figure out when my viewModel get updated, it will notify view and it will refresh whole body. How to avoid that. For example if my view GoLiveView already present another view BroadcasterView, and later my goLiveViewModel get updated, GoLiveView will be refreshed, and  it will create BroadcasterView again , because showBroadcasterView = true. And it will cause so many issues down the road, because of that. </p>

<pre><code>struct GoLiveView: View {

@ObservedObject var goLiveViewModel = GoLiveViewModel()
@EnvironmentObject var sessionStore: SessionStore
@State private var showBroadcasterView = false
@State private var showLiveView = false

init() {
    goLiveViewModel.refresh()
}

var body: some View {
    NavigationView {
        List(goLiveViewModel.rooms) { room in // when goLiveViewModed get updated 
            NavigationLink(destination: LiveView(clientRole: .audience, room: room, showLiveView: $showLiveView))) {
                LiveCell(room: room)

            }
        }.background(Color.white)
        .navigationBarTitle(""Live"", displayMode: .inline)
        .navigationBarItems(leading:
            Button(action: {
                self.showBroadcasterView = true
        }, label: {
            Image(""ic_go_live"").renderingMode(.original)
        })).frame(maxWidth: .infinity, maxHeight: .infinity)
            .background(Color(red: 34/255, green: 34/255, blue: 34/255))

        .sheet(isPresented: $showBroadcasterView) { // here is problem, get called many times, hence reload whole body ,and create new instances of BroadcasterView(). Because showBroadcasterView = is still true.

                BroadcasterView(broadcasterViewModel: BroadcasterViewModel(showBroadcasterView: $showBroadcasterView))
                    .environmentObject(self.sessionStore)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .background(Color.clear)
            }

    }
}
</code></pre>

<p>this is my GoliveViewModel </p>

<pre class=""lang-swift prettyprint-override""><code>typealias RoomsFetchOuput = AnyPublisher&lt;RoomsFetchState, Never&gt;

enum RoomsFetchState: Equatable {

    static func == (lhs: RoomsFetchState, rhs: RoomsFetchState) -&gt; Bool {
        switch (lhs, rhs) {
        case (.loading, .loading): return true
        case (.success(let lhsrooms), .success(let rhsrooms)):
            return lhsrooms == rhsrooms
        case (.noResults, .noResults): return true
        case (.failure, .failure): return true
        default: return false
        }
    }

    case loading
    case success([Room])
    case noResults
    case failure(Error)
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>class GoLiveViewModel: ObservableObject {

    private lazy var webServiceManager = WebServiceManager()
    @Published var rooms = [Room]()
    private lazy var timer = Timer()
    private var cancellables: [AnyCancellable] = []

    init() {
        timer = Timer.scheduledTimer(timeInterval: 4.0, target: self, selector: #selector(refresh) , userInfo: nil, repeats: true) //  call every 4 second refresh
    }

    func fetch() -&gt; RoomsFetchOuput {
        return webServiceManager.fetchAllRooms()
            .map ({ result -&gt; RoomsFetchState in
                switch result {
                case .success([]): return .noResults
                case let .success(rooms): return .success(rooms)
                case .failure(let error): return .failure(error)
                }
            })
            .eraseToAnyPublisher()

        let isLoading: RoomsFetchOuput = .just(.loading)
        let initialState: RoomsFetchOuput = .just(.noResults)

        let idle: RoomsFetchOuput = Publishers.Merge(isLoading, initialState).eraseToAnyPublisher()

        return Publishers.Merge(idle, rooms).removeDuplicates().eraseToAnyPublisher()

    }

    @objc func refresh() {
         cancellables.forEach { $0.cancel() }
          cancellables.removeAll()
        fetch()
            .sink { [weak self] state in
                guard let self = self else { return }
                switch state {
                case let .success(rooms):
                    self.rooms = rooms
                case .failure: print(""failure"")
                // show error alert to user
                case .noResults: print(""no result"")
                self.rooms = []
                // hide spinner
                case .loading:  print("".loading"")
                    // show spinner
                }
        }
        .store(in: &amp;cancellables)
    }
}
</code></pre>
","12990846","","9982386","","2020-03-02 05:12:39","2022-04-14 12:19:10","SwiftUI how to prevent view to reload whole body","<swift><xcode><swiftui><combine>","1","0","8","","","CC BY-SA 4.0"
"60487628","1","60487739","","2020-03-02 11:08:44","","1","1061","<p>I have these two Codable objects :</p>

<pre><code>struct Parent: Codable {
    let name: String
    let children: [Child]
}

struct Child: Codable {
    let name: String
} 
</code></pre>

<p>That I have created to match this json :</p>

<pre><code>{
    name: ""test""
    children: (
        {
          name: ""test2""
        },
        {
          name: ""test3""
        }
     )
}
</code></pre>

<p>I retrieve the json and decode it to a Parent object using these methods :</p>

<pre><code>func parent(_ url: String) -&gt; AnyPublisher&lt;Parent, Error&gt; { 
    return dataFromURL(url)
        .map(\.value)
        .eraseToAnyPublisher()
}

struct Result&lt;T&gt; {
    let value: T
    let response: URLResponse
}

func dataFromURL&lt;T: Decodable&gt;(_ url: String, _ decoder: JSONDecoder = JSONDecoder()) -&gt; AnyPublisher&lt;Result&lt;T&gt;, Error&gt; {
    let request = URLRequest(url: URL(string:url)!)
    return URLSession.shared
        .dataTaskPublisher(for: request)
        .tryMap { result -&gt; Result&lt;T&gt; in
            let value = try decoder.decode(T.self, from: result.data)
            return Result(value: value, response: result.response)
        }
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
}
</code></pre>

<p>It works, but I would like a method to retrieve the array of children, instead of the Parent object, like this :</p>

<pre><code>func children(_ url: String) -&gt; AnyPublisher&lt;[Child], Error&gt;  
</code></pre>

<p>But I don't know what I need to change.. Any help would be appreciated, thanks !</p>
","5120292","","","","","2020-03-02 13:38:39","iOS - Combine - Change Publisher type to child type","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"60490860","1","60491553","","2020-03-02 14:24:54","","1","1830","<p>I want to show a view, after my App received an APNS-Push Notification. I'm using SwiftUI. I followed this tutorial (<a href=""https://blckbirds.com/post/how-to-navnigate-between-views-in-swiftui-by-using-an-environmentobject/"" rel=""nofollow noreferrer"">https://blckbirds.com/post/how-to-navnigate-between-views-in-swiftui-by-using-an-environmentobject/</a>) to create a motherView and a ViewRouter.</p>

<p>MotherView looks like that:</p>

<pre><code>struct MotherView: View {

//    MARK: - Properties
    @EnvironmentObject var viewRouter: ViewRouter
    @State private var isMenuVisible: Bool = false

    var body: some View {
        VStack {
            if viewRouter.currentPage == Constants.Views.login {
                Login_SwiftUIView()
            } else if viewRouter.currentPage == Constants.Views.main {
                MainView(withMenu: $isMenuVisible)
            } else if viewRouter.currentPage == Constants.Views.menu {
                Menu_SwiftUI(withMenu: $isMenuVisible)
            } else if viewRouter.currentPage == Constants.Views.push {
                PushView()
            }
        }
    }
}
</code></pre>

<p>ViewRouter is a ObservableObjectClass</p>

<pre><code>class ViewRouter: ObservableObject {

    let objectWillChange = PassthroughSubject&lt;ViewRouter,Never&gt;()

    var currentPage: Constants.Views = Constants.Views.login {
        didSet {
            objectWillChange.send(self)
        }
    }
}
</code></pre>

<p>The AppDelegate calls this function, after receiving a Push-Notification:</p>

<pre><code>func presentView(with pushNotification: [String: AnyObject]) {
    //Here I want to set the viewRouter.currentPage = Constants.View.push
}
</code></pre>

<p>What would be your suggestions to solve this problem?</p>
","8642838","","8642838","","2020-06-08 18:31:07","2020-06-08 18:31:07","Display a view after receiving APNS with SwiftUI","<ios><swift><swiftui><apple-push-notifications>","1","0","1","","","CC BY-SA 4.0"
"60493121","1","60533823","","2020-03-02 16:38:57","","0","597","<p>I have a setup like this with an error shown below</p>

<pre><code>enum DataError: Error {
    case failed(error: Error)
}

enum UIError: Error {
    case failed(error: Error)
}

struct SomeData {

}

func foo() -&gt; AnyPublisher&lt;Result&lt;[SomeData]?, DataError&gt;, Never&gt; {
    ...
}

func foo2() -&gt; AnyPublisher&lt;Result&lt;[SomeData]?, UIError&gt;, Never&gt; {
    return foo()
            .mapError { error -&gt; UIError 
                switch error {
                    ....
                }

                return UIError.failed(error: $0)
            }
            .eraseToAnyPublisher() ===&gt; // Error Cannot convert return expression of type 'AnyPublisher&lt;Result&lt;[SomeData]?, DataError&gt;, UIError&gt;' to return type 'AnyPublisher&lt;Result&lt;[T], UIError&gt;, Never&gt;'
}
</code></pre>

<p>The error message seem pretty straight forward but cant quite resolve it.</p>
","3355301","","","","","2020-03-04 19:59:11","Publisher mapError with the Combine Framework","<swift><combine>","2","1","","","","CC BY-SA 4.0"
"60495494","1","60521560","","2020-03-02 19:35:16","","12","5811","<p>I want to achieve the following: Whenever someone triggers a CoreData save (ie. <code>NSManagedObjectContextDidSave</code> notification gets sent), I'd like to perform some <strong>background</strong> calculation based the changed NSManagedObject. Concrete example: Assume in a notes app, I want to asynchronously calculate the total number of words in all notes.</p>
<p>The problem currently lies with the fact that NSManagedObject context is explicitly bound to thread and you are discouraged from using <code>NSManagedObject</code>s outside this thread.</p>
<p>I have setup two <code>NSManagedObjectContext</code>s in my <code>SceneDelegate</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>let context = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext
let backgroundContext = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.newBackgroundContext()
</code></pre>
<p>I also have subscribed to the notification via <code>NotificationCenter.default.publisher(for: .NSManagedObjectContextDidSave)</code> and am receiving a save notification <em>twice</em> after I trigger only <em>one</em> <code>managedObjectContext.save()</code>. However, both notifications are sent from the same thread (which is the UIThread) and all <code>NSManagedObjects</code> in the user dictionary have a <code>.managedObjectContext</code> which is the <code>viewContext</code> and not the <code>backgroundContext</code>.</p>
<p>My idea was to filter the notifications based on whether or not the associated <code>NSManagedObjectContext</code> was the background one as I assumed that the notification is also sent on the (private) DispatchQueue but it seems all notifications are sent on the UIThread and the background context is never used.</p>
<p>Any idea on how to solve this? Is this a bug? How can I retrieve notifications based on the <code>backgroundContext</code> with downstream tasks being run on the associated DispatchQueue?</p>
","1138434","","814730","","2021-08-10 18:55:13","2021-08-10 18:55:13","How to: Using Combine to react to CoreData changes in the background","<ios><swift><core-data><swift5><combine>","3","2","12","","","CC BY-SA 4.0"
"60534430","1","60539275","","2020-03-04 20:45:48","","0","579","<p>I want to add a value to Firestore. When finished I want to return the added value. The value does get added to Firestore successfully. However, the value does not go through sink.</p>

<p>This is the function that does not work:</p>

<pre><code>func createPremium(user id: String, isPremium: Bool) -&gt; AnyPublisher&lt;Bool,Never&gt; {
    let dic = [""premium"":isPremium]
    return Future&lt;Bool,Never&gt; { promise in
        self.db.collection(self.dbName).document(id).setData(dic, merge: true) { error in
            if let error = error {
                print(error.localizedDescription)
            } else {
                /// does get called
                promise(.success(isPremium))

            }
        }
    }.eraseToAnyPublisher()
}
</code></pre>

<p>I made a test function that works:</p>

<pre><code>func test() -&gt; AnyPublisher&lt;Bool,Never&gt; {
    return Future&lt;Bool,Never&gt; { promise in
        promise(.success(true))
    }.eraseToAnyPublisher()
}


    premiumRepository.createPremium(user: userID ?? ""1234"", isPremium: true)
        .sink { receivedValue in
            /// does not get called
            print(receivedValue)
    }.cancel()

    test()
        .sink { recievedValue in
            /// does get called
            print(""Test"", recievedValue)
    }.cancel()
</code></pre>

<p>Also I have a similar code snippet that works:</p>

<pre><code>func loadExercises(category: Category) -&gt; AnyPublisher&lt;[Exercise], Error&gt; {
    let document = store.collection(category.rawValue)
    return Future&lt;[Exercise], Error&gt; { promise in
        document.getDocuments { documents, error in
            if let error = error {
                promise(.failure(error))
            } else if let documents = documents {
                var exercises = [Exercise]()
                for document in documents.documents {
                    do {
                        let decoded = try FirestoreDecoder().decode(Exercise.self, from: document.data())
                        exercises.append(decoded)
                    } catch let error {
                        promise(.failure(error))
                    }
                }
                promise(.success(exercises))
            }
        }
    }.eraseToAnyPublisher()
}
</code></pre>

<p>I tried to add a buffer but it did not lead to success.</p>
","8887336","","","","","2020-03-05 06:22:17","Future Combine sink does not recieve any values","<swift><future><combine><publisher>","1","1","","","","CC BY-SA 4.0"
"60550577","1","60551057","","2020-03-05 17:03:17","","14","3341","<p>How to convert <code>Just&lt;[Int]&gt;</code> to <code>AnyPublisher&lt;[Int], Error&gt;</code>. When I use <code>eraseToAnyPublisher()</code> the type is <code>AnyPublisher&lt;[Int], Never&gt;</code> which is not the same as <code>AnyPublisher&lt;[Int], Error&gt;</code></p>

<p>For example I have a simple function which I want to mock temporary </p>

<pre><code>func getAllIds() -&gt; AnyPublisher&lt;[Int], Error&gt; {
    return Just&lt;[Int]&gt;([]).eraseToAnyPublisher()
}
</code></pre>

<p>Any ideas? </p>
","1401983","","","","","2020-03-06 00:41:27","Combine convert Just to AnyPublisher","<ios><swift><combine>","1","1","1","","","CC BY-SA 4.0"
"60552914","1","60555961","","2020-03-05 19:46:08","","2","895","<p>I am trying to build a <code>VOIP</code> app using lib called <code>VailerSIPLib</code>. As the library was built using <code>Obj-C</code> and heavily using <code>NotificationCenter</code> to to publish the changes the active states all over the place. </p>

<p>I currently at the <code>CallView</code> part of the project, I can manage to start, end, reject calls. However, I need to implement <code>connectionStatus</code> in the view which will give information about the call like duration, ""connecting.."", ""disconnected"", ""ringing"" etc. </p>

<p>The below code is all in <code>CallViewModel: ObservableObject</code>;</p>

<p><strong>Variables:</strong></p>

<pre><code>var activeCall: VSLCall!
@Published var connectionStatus: String = """"
</code></pre>

<p><strong>Initializer:</strong></p>

<pre><code>override init(){
        super.init()
        NotificationCenter.default.addObserver(self, selector: #selector(self.listen(_:)), name: Notification.Name.VSLCallStateChanged, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(self.buildCallView(_:)), name: Notification.Name.CallKitProviderDelegateInboundCallAccepted, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(self.buildCallView(_:)), name: Notification.Name.CallKitProviderDelegateOutboundCallStarted, object: nil)
    }
</code></pre>

<p><strong>Methods:</strong></p>

<pre><code>func setCall(_ call: VSLCall) {
    self.activeCall = call
    self.activeCall.observe(\.callStateText) { (asd, change) in
        print(""observing"")
        print(""\(String(describing: change.oldValue)) to \(String(describing: change.newValue)) for \(call.callId)"")
    } 
}

@objc func listen(_ notification: Notification) {
       if let _ = self.activeCall {
           print(self.activeCall.callStateText)
       }    
}

@objc func buildCallView(_ notification: Notification) {
    print(""inbound call"")
    self.isOnCall = true 
}
</code></pre>

<p><strong>Problem:</strong></p>

<p>It prints out every thing except the <code>completionBlock</code> in <code>setCall(_:)</code>. <code>listen(_:)</code> function validates that the state of the <code>activeCall</code> is changing and I would want to use that directly, however it does not work correct all the time. It should be triggered when the call is answered with <code>callState</code> value of <code>.confirmed</code> but sometime it does. This how I will know that it is time start the timer. </p>

<p>Other point is, in the example project of the <code>VialerSIPLib</code> they used <code>self.activeCall.addObserver(_:)</code> and it works fine. The problem for that is it throws a runtime error at the method something like <code>didObservedValueChange(_:)</code> and logs <code>An -observeValueForKeyPath:ofObject:change:context: message was received but not handled.</code></p>

<p>Finally there is yellow warning at the <code>activeCall.observe(_:)</code> says </p>

<blockquote>
  <p><code>Result of call to 'observe(_:options:changeHandler:)' is unused</code>
  which I could not find anything related to it.</p>
</blockquote>
","1404324","","1244403","","2020-03-05 19:49:21","2020-03-06 01:00:30","SwiftUI - KV Observe completion from Combine does not get triggered","<swift><swiftui><key-value-observing><combine>","1","0","1","","","CC BY-SA 4.0"
"60560933","1","60562584","","2020-03-06 09:19:57","","2","1837","<p>I consider what is the difference</p>
<pre><code>@Published var isLoggedIn: Bool = false 

var isLoggedIn: AnyPublisher&lt;Bool, Never&gt; 
</code></pre>
<p>I know in the case of first I can use it directly in SwiftUI View i.e. create binding with $ sign and then for example use <code>if $isLoggedIn.animation()</code></p>
<p>But how can I achieve the same with <code>AnyPublisher&lt;Bool, Never&gt;</code> it seems that there I need to call somewhere <strong>assign</strong> or <strong>sink</strong> and <strong>store()</strong>. To make it work. So creating binding from it in SwiftUI seems to be impossible like <code>if $isLoggedIn.animation</code></p>
<p>Limitation of @Published is that I cannot make there custom observing. for example UserDefaults which I can do via AnyPublisher from UserDefaults.publisher.</p>
<p>As now it seems I need to have both and make <code>AnyPublisher</code> update <code>@Published var</code></p>
<p>But I've thought that @Published is property wrapper that has underneath regular AnyPublisher so why I cannot make binding in SwiftUI view directly from AnyPublisher?</p>
","4415642","","214143","","2021-09-29 16:36:24","2021-09-29 16:36:24","What is the difference between @Published and normal AnyPublisher property in ObservableObject","<swiftui><combine>","2","1","1","","","CC BY-SA 4.0"
"60568858","1","60568944","","2020-03-06 17:24:19","","7","1028","<p>Consider the following code (you can c&amp;p it directly into a playground):</p>

<pre><code>class Foo: ObservableObject {
    @Published var bar = ""bar""
}

let foo = Foo()
let someSubscriber = foo.$bar
    .sink { value in
        print(""value is \(value)"")
    }
</code></pre>

<p>Although Foo has just been initialised once and it's member <code>bar</code> never changed, the sink executes it's <code>receiveValue</code> closure immediately. Is there any way to prevent this initial call from happening, e.g. is there an operator I might have overlooked?</p>
","239880","","","","","2020-03-06 19:52:02","Prevent sink receiveValue closure from being called immediately","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"60570901","1","60571151","","2020-03-06 20:06:52","","7","2299","<p>I'm running into an issue where in Combine where I have a boolean @Published property. </p>

<p>When I set it to true,
the sink closure is run and I can look at the value being received. It's true. But when I compare it against the actual property that I am observing, they are different.</p>

<p>This bit of code can be simply run in a playground. I'm not sure how this works or why the values would be different</p>

<pre><code>class TestModel {
    @Published var isLoading = false
}

let model = TestModel()

model.$isLoading.sink { (isLoading) in
    if isLoading != model.isLoading {
        print(""values NOT same"")
    }
}

model.isLoading = true
</code></pre>
","3786510","","","","","2020-03-06 20:26:56","Swift Combine sink value is different from value of @Published property","<swift><combine>","1","0","2","","","CC BY-SA 4.0"
"60578918","1","60591513","","2020-03-07 15:05:54","","0","1260","<p>This is what I am doing:</p>

<p>-> Login/Signup to Firebase using FirebaseAuthentification</p>

<p>-> Listining to AuthStateDidChangeListenerHandle</p>

<p>-> I store extra user information in Firestore, therefore I check if the user exists in Firestore</p>

<p>-> If the user does not exist I create an empty user</p>

<p>-> If everything was successful I return a Future Publisher via callback (I want to change that as well)</p>

<p>This is the checkLoginState function:</p>

<pre><code>func checkLoginState(completion: @escaping (AnyPublisher&lt;AccountDetails,Error&gt;) -&gt; Void) {
    self.handler = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
        guard let safeSelf = self else { return }
        completion(Future&lt;AccountDetails,Error&gt; { promise in
            if let user = user {
                print(user)
                print(auth)

                safeSelf.checkIfUserIsInDatabase(user: user.uid) { result in
                    switch result {
                    case .success(let isAvailable):
                        if isAvailable {
                             promise(.success(AccountDetails(userUID: user.uid,name: user.displayName, loggedIn: true, premiumUser: false)))
                        } else {
                            safeSelf.createEmptyUser(user: user.uid,email: user.email) { result in
                                switch result {
                                case .success(_):
                                    promise(.success(AccountDetails(userUID: user.uid,name: user.displayName, loggedIn: true, premiumUser: false)))
                                case .failure(let error):
                                    print(error)
                                }
                            }
                        }
                    case .failure(let error):
                        print(error)
                    }
                }
            } else {
                promise(.success(AccountDetails(userUID: nil, loggedIn: false, premiumUser: false)))
            }
            }.eraseToAnyPublisher()
        )
    }
}
</code></pre>

<p>These are my current functions:</p>

<pre><code>private func checkIfUserIsInDatabase(user id: String, completion: @escaping (Result&lt;Bool,Error&gt;) -&gt; Void)

private func createEmptyUser(user id: String, email:String?, completion: @escaping (Result&lt;Bool,Error&gt;) -&gt; Void)
</code></pre>

<p>Thats what I want to use:</p>

<pre><code>private func checkIfUserIsInDatabase(user id: String) -&gt; AnyPublisher&lt;Bool,Error&gt;

private func createEmptyUser(user id: String) -&gt; AnyPublisher&lt;Bool,Error&gt;

func checkLoginState() -&gt; AnyPublisher&lt;AccountDetails,Error&gt;
</code></pre>

<p>I had something like that, but it does not work, also looks confusing:</p>

<pre><code>func checkLoginState(completion: @escaping (AnyPublisher&lt;AccountDetails,Error&gt;) -&gt; Void) {
    self.handler = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
        guard let safeSelf = self else { return }
        completion(Future&lt;AccountDetails,Error&gt; { promise in
            if let user = user {
                print(user)
                print(auth)

                safeSelf.checkIfUserIsInDatabase(user: user.uid)
                    .sinkToResult { value in
                        switch value {
                        case .success(let isUserInDatabase):
                            if isUserInDatabase {
                                promise(.success(AccountDetails(userUID: user.uid,name: user.displayName, loggedIn: true, premiumUser: false)))
                            } else {
                                safeSelf.createEmptyUser(user: user.uid)
                                    .sinkToResult { value in
                                        switch value {
                                        case .success( _):
                                            promise(.success(AccountDetails(userUID: user.uid,name: user.displayName, loggedIn: true, premiumUser: false)))
                                        case .failure(let error):
                                            print(error)
                                        }
                                }
                            }
                        case .failure(let error):
                            print(error)
                        }

                }
            } else {
                promise(.success(AccountDetails(userUID: nil, loggedIn: false, premiumUser: false)))
            }
        }.eraseToAnyPublisher()
        )
    }
}
</code></pre>
","8887336","","","","","2020-03-08 19:56:01","Transform callback approach to reactive with Combine","<swift><firebase><future><combine><publisher>","2","8","1","","","CC BY-SA 4.0"
"60579822","1","60579823","","2020-03-07 16:37:26","","0","38","<p>The <a href=""https://developer.apple.com/documentation/combine/publisher/3204685-append"" rel=""nofollow noreferrer"">documentation</a> on the Combine Framework's <code>append</code> operator says:</p>

<blockquote>
  <p>This operator produces no elements until this publisher finishes. It then produces this publisher’s elements, followed by the given publisher’s elements.</p>
</blockquote>

<p>So I would expect the first publisher's elements to be produced all at once, with no regard for the timing by which they are actually published by the first publisher. But that is not the case. </p>

<p>For example:</p>

<pre><code>    [1,2,3,4].publisher.flatMap(maxPublishers: .max(1)) {
        Just($0).delay(for: 1, scheduler: DispatchQueue.main)
    }.append( Just(100) )
</code></pre>

<p>As you can see, the first publisher produces <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> at one-second intervals. According to the documentation, <code>append</code> should <em>wait</em> until all four values have been produced — that is, for four seconds — and then republish those values at all once. But that isn't what happens. What I see is just what the first publisher itself produces, namely, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> at one-second intervals. What's going on?</p>
","341994","","","","","2020-03-07 16:37:26","Timing of values in Combine Framework's `append` operator?","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"60581820","1","60581908","","2020-03-07 20:13:37","","2","639","<p>I get the error </p>

<blockquote>
  <p>Cannot assign to property: 'viewModel' is a get-only property
  When trying to use @EnvironmentObject of generic type.</p>
</blockquote>

<pre><code>import SwiftUI
import Combine

protocol HasCount {
    var count: Int { get set }
    var countPublished: Published&lt;Int&gt; { get set }
    var countPublisher: Published&lt;Int&gt;.Publisher { get set }
}

struct SomeView&lt;ViewModelType: ObservableObject &amp; HasCount&gt;: View {
    @EnvironmentObject var viewModel: ViewModelType

    var body: some View {
        return VStack {
            Text(""text"")
            .onAppear {
                self.viewModel.count = 1
            }
        }
    }
}
</code></pre>

<p>Any idea how to get around this?</p>
","5881884","","","","","2020-03-07 20:24:57","Using @EnvironmentObject I get: ""Cannot assign to property: 'viewModel' is a get-only property""","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"60593147","1","60596388","","2020-03-08 23:47:46","","0","115","<p>I am trying to port this class in swift to Kotlin. Is there a Kotlin way of achieving extensions and to reduce the state(get the state)</p>

<pre><code>public final class MutateNode {
public var onSubscribe: (() -&gt; Void)?
public var onPublish: ((State) -&gt; Void)?
public var leafs: [Node]

public init(leafs: [Node], onSubscribe: (() -&gt; Void)? = nil, onPublish: ((State) -&gt; Void)? = nil) {
    self.leafs = leafs
    self.onPublish = onPublish
    self.onSubscribe = onSubscribe
}
}

extension MutateNode: ControlNode {
public var state: AnyPublisher&lt;State, Never&gt; {
    guard !leafs.isEmpty else {
        return Just(.failure)
            .eraseToAnyPublisher()
    }
    return leafs.reduce(into: Just(.failure).eraseToAnyPublisher()) { (resultPublisher, nextChild) in
        resultPublisher = resultPublisher.flatMap { state in
            state == .success ? Just(state).eraseToAnyPublisher() : nextChild.state.eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
    .handleEvents(
        receiveSubscription: { [weak self] _ in self?.onSubscribe?() },
        receiveOutput: { [weak self] state in self?.onPublish?(state) }
    )
    .eraseToAnyPublisher()
}
</code></pre>

<p>}</p>
","899611","","","","","2020-03-09 07:42:47","Kotlin equivalent for extensions and reduce","<swift><generics><kotlin><closures><combine>","1","0","","","","CC BY-SA 4.0"
"60614782","1","60615059","","2020-03-10 09:34:44","","0","45","<p>I execute my code in Playground:</p>

<pre><code>import PlaygroundSupport
import Combine

PlaygroundPage.current.needsIndefiniteExecution = true

var s = ""a""
let sb = s.publisher
    .sink(receiveValue: {
        print(""rec: \($0)"")
    })

let s0 = Timer.publish(every: 1.0, on: .main, in: .common)
.autoconnect()
.sink(receiveValue: {_ in
    print(""tiktok..."")
    s.append(""not work!"")
})
s.append(""not work too!"")
</code></pre>

<p>My Question is why s.publisher can't be triggered even though I changed s value???</p>
","5487391","","5487391","","2020-03-10 10:05:55","2020-03-10 10:05:55","Why String.publisher can't be triggered?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"60617914","1","60620163","","2020-03-10 12:42:40","","1","2017","<p>I use two publishers in View:</p>

<p>A: String.publisher</p>

<p>B: ObservableObject include one @Published String type</p>

<p>If I monitoring publisher A,I get a infinite loop.
But monitoring publisher B is OK!</p>

<pre><code>    import SwiftUI
    import Combine

    class Model: ObservableObject{
        @Published var someBool = false
        @Published var name:String = """"
    }

    struct ContentView: View {
        // Publisher A
        @State var name = """"
        // Publisher B
        @ObservedObject var model = Model()

        var body: some View {
            VStack {
                // Plan A: lead to infinite loop!!!
                TextField(""Input Name"", text: $name)
                // Plan B: It's OK
                //TextField(""Input Name"", text: $model.name)

                .onReceive(name.publisher.reduce("""", {t,c in
                    t + String(c)
                })) {text in
                    print(""change to \(text)"")
                    self.model.someBool.toggle()    //Plan A: infinite loop!!!
                }
                /*
                .onReceive(model.$name){name in
                    print(""change to \(name)"")
                    self.model.someBool.toggle()    //Plan B: It's OK!!!
                }
                */
            }
        }
    }
</code></pre>

<p>Although I changed model.someBool value in onReceive(),But Plan B is fine, Plan A lead to infinite loop.
Why is That??? Thanks :)</p>
","5487391","","","","","2020-11-20 15:35:33","onReceive String.publisher lead to infinite loop","<swift><swiftui><combine>","1","6","","","","CC BY-SA 4.0"
"60620295","1","60621000","","2020-03-10 15:02:10","","1","2213","<p>I'm trying to load data into a SwiftUI view using Firebase/Firestore. The data loads from the database but doesn't get passed into the view.</p>

<p>I know it loads because I print it once it has loaded.</p>

<p>I have a HomeView.Swift file as follows:</p>

<pre><code>import SwiftUI
import Firebase

struct HomeView: View {
    let data = GetIphonesData()
    var body: some View {
        NavigationView {
            if (data.data.count == 0) {
                Loader()
                .navigationBarTitle(""Loading"", displayMode: .inline)
            } else {
                List() {
                    Section(header: Text(""iPhone"")) {
                        ForEach(data.data , id: \.id) { iphone in
                            ProductNavigationLinkView(model: iphone)
                        }
                    }
                }.listStyle(GroupedListStyle())
                .navigationBarTitle(""Home"", displayMode: .inline)
            }
        }
    }
}
</code></pre>

<p>And I have a GetIphoneData.Swift class as follows:</p>

<pre><code>import Foundation
import Firebase
import Combine

class GetIphonesData : ObservableObject {
    @Published var data = [Iphone]()

    init() {
        let db = Firestore.firestore()

        db.collection(""iphones"").addSnapshotListener { (snap, err) in
            if err != nil {
                print((err?.localizedDescription)!)
                return
            } else {
                print(""no errors"")
                for i in snap!.documentChanges {
                    let id = i.document.documentID
                    let name = i.document.get(""name"") as! String

                    self.data.append(Iphone(id: id,
                                            name: name))
                }
                print(self.data)
            }
        }
    }
}
</code></pre>
","10975170","","","","","2020-03-10 21:42:35","How to load data into a view in SwiftUI with firebase/firestore","<swift><database><firebase><google-cloud-firestore><swiftui>","1","0","1","","","CC BY-SA 4.0"
"60622272","1","60623463","","2020-03-10 16:47:34","","0","1477","<p>I just started using combine swift to handle the data request and response.</p>

<p>The Json data returned is a nested data which I will only need one part of it. 
such as:</p>

<pre><code>{
""page"": 1,
""data"": [
{
""id"": 1,
""title"": ""news-1"",
""content"": ""content 1""
},
{
""id"": 2,
""title"": ""news-2"",
""content"": ""content 2""
},
{
""id"": 3,
""title"": ""news-3"",
""content"": ""content 3""
}
],
""time"": 202021313,
""description"" :""xxxx""
}
</code></pre>

<p>I will need to use the <code>data</code> array.</p>

<p>Fetch functions below:</p>

<pre><code>    func fetchData() throws -&gt; URLSession.DataTaskPublisher {
        let headers = [
            ""Content-Type"": ""application/json"",
            ""cache-control"": ""no-cache"",
        ]

        guard let url = URL(string: endpointStr ) else {
            throw APIError.invalidEndpoint
        }

        var request = URLRequest(url: url,
        cachePolicy: .useProtocolCachePolicy,
        timeoutInterval: 10.0)

        request.httpMethod = ""GET""
        request.allHTTPHeaderFields = headers

        let session = URLSession.shared
        return session.dataTaskPublisher(for: request)
    }
</code></pre>

<pre><code>        let publisher = try? fetchData()
        let decoder = JSONDecoder()
        let cancellable = publisher?
            .receive(on: DispatchQueue.main)
            .map {
                 $0.data
            }
            .decode(type: DataModel.self, decoder: decoder)
            .sink(receiveCompletion: { (completion) in
            switch completion {
            case .failure(let error):
                print(""Error:"")
                print(error)
            case .finished:
                print(""DONE - get Publisher"")
            }
        }, receiveValue: { data in
            print(data.title)
        })
</code></pre>

<p>The data it returned is the complete json data, is there any elegant way to get only the array of data and convert into an array of [DataModel] and handle the data in receiveValue.</p>

<p>I have tried to edit map with no luck:</p>

<pre><code>            .map {
                if let dataString = String(data: $0.data, encoding: .utf8) {
                    let dataDic = APIService.convertToDictionary(text: dataString)
                    if let DataArray = dataDic?[""data""] {
                        return listDataDic! 
                    }
                 return $0.data
                }
</code></pre>
","3262769","","","","","2020-03-10 18:02:56","How can I read the nested json data by using swift combine","<json><swift><combine>","1","0","0","","","CC BY-SA 4.0"
"60624851","1","60627981","","2020-03-10 19:43:03","","13","5127","<p>I see how to use <code>.retry</code> directly, to resubscribe after an error, like this:</p>

<pre><code>    URLSession.shared.dataTaskPublisher(for:url)
        .retry(3)
</code></pre>

<p>But that seems awfully simple-minded. What if I think that this error might go away if I wait awhile? I could insert a <code>.delay</code> operator, but then the delay operates even if there is no error. And there doesn't seem to be a way to apply an operator conditionally (i.e. only when there's an error).</p>

<p>I see how I could work around this by writing a RetryWithDelay operator from scratch, and indeed such an operator has been written by third parties. But is there a way to say ""delay if there's an error"", purely using the operators we're given?</p>

<p>My thought was that I could use <code>.catch</code>, because its function runs only if there is an error. But the function needs to return a publisher, and what publisher would we use? If we return <code>somePublisher.delay(...)</code> followed by <code>.retry</code>, we'd be applying <code>.retry</code> to the wrong publisher, wouldn't we?</p>
","341994","","341994","","2020-03-11 13:29:05","2021-04-02 08:19:42","Combine framework retry after delay?","<ios><swift><combine>","4","0","3","","","CC BY-SA 4.0"
"60633154","1","60633415","","2020-03-11 09:47:09","","2","7497","<p>I do see a lot of similar questions in stack-overflow, but seems no one is similar with my case. I'm new to Combine frame work, and it took me this whole afternoon to figure out what is wrong, however still stuck at here...</p>

<p>Xcode gives me below error, what I do is using TMDB's API and to decode it into my Actor model. And it failed on this line <code>let result = try self.decoder.decode(TMDBActorsResult.self, from: output.data)</code>. Could you give me some hint what is going on with this <code>adult</code>?</p>

<blockquote>
  <p>ERROR: keyNotFound(CodingKeys(stringValue: ""adult"", intValue: nil), Swift.DecodingError.Context(codingPath: [CodingKeys(stringValue: ""results"", intValue: nil), _JSONKey(stringValue: ""Index 0"", intValue: 0), CodingKeys(stringValue: ""knownFor"", intValue: nil), _JSONKey(stringValue: ""Index 0"", intValue: 0)], debugDescription: ""No value associated with key CodingKeys(stringValue: \""adult\"", intValue: nil) (\""adult\"")."", underlyingError: nil))</p>
</blockquote>

<p>Also I check the url is working and here is the return data from TMDB API:</p>

<p><a href=""https://i.stack.imgur.com/DWA73.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DWA73.png"" alt=""enter image description here""></a></p>

<p><a href=""https://i.stack.imgur.com/SgnWT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/SgnWT.png"" alt=""enter image description here""></a></p>

<p><strong>/// Model for Actor</strong></p>

<pre><code>import SwiftUI


struct TMDBActorsResult: Codable {
    let page: Int?
    let results: [Actor]
    let totalResults: Int?
    let totalPages: Int?
}

struct Actor: Codable {
    let profilePath: String?
    let adult: Bool
    let id: Int?
    let name: String?
    let popularity: CGFloat?
    let knownFor: [Production]?
    let knownForDepartment: String?
    let gender: Int?
}

// MARK: Used for two objects with media type = (Movie or TV)
struct Production: Codable {
    let posterPath: String?
    let adult: Bool
    let overview: String?
    let releaseDate: String?
    let originalTitle: String?
    let genreIds: [Int]?
    let id: Int?
    let mediaType: String?
    let originalLanguage: String?
    let title: String?
    let backdropPath: String?
    let popularity: Double?
    let voteCount: Int?
    let video: Bool
    let voteAverage: Double?
    let firstAirDate: String?
    let originCountry: [String]?
    let name: String?
    let originalName: String?
}
</code></pre>

<p><strong>/// The JSON decoding part.</strong></p>

<pre><code>import Foundation
import Combine

enum HTTPError: LocalizedError {
    case statusCode
    case post
}

struct WebService {

    private var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        return decoder
    }()

    private var session: URLSession = {
        let config = URLSessionConfiguration.default
        config.urlCache = URLCache.shared
        config.waitsForConnectivity = true
        config.requestCachePolicy = .reloadIgnoringLocalCacheData
        return URLSession(configuration: config, delegate: nil, delegateQueue: nil)
    }()

    private func createPublisher&lt;T: Codable&gt;(for url: URL) -&gt; AnyPublisher&lt;T, Error&gt; {
        print(""Pblisher URL: \(url)"")
        return session.dataTaskPublisher(for: url)
            .tryMap { output in
                guard let response = output.response as? HTTPURLResponse, response.statusCode == 200 else {
                    print(""Response: \(output.response)"")

                    do {
                        let ss = try self.decoder.decode(Response.self, from: output.data)
                        print(""ss:  \(ss)"")
                    } catch {
                        print(error)
                    }
                    throw HTTPError.statusCode
                }

                do {
                    let result = try self.decoder.decode(TMDBActorsResult.self, from: output.data)
                    print(""Result: \(result)"")
                } catch {
                    print(""ERROR: \(error)"")
                }
                return output.data
            }
            .decode(type: T.self, decoder: decoder)
            .eraseToAnyPublisher()
    }

    func getSectionsPublisher() -&gt; AnyPublisher&lt;TMDBActorsResult, Error&gt; {
        createPublisher(for: TMDBClient.Endpoints.popularActors.url).eraseToAnyPublisher()
    }

}


</code></pre>

<p>/ / / <strong>Update,</strong> As vadian's comment, I try to modify my data model to using enum associated value, as below code showed, but it gives me error <code>Instance method 'decode(_:forKey:)' requires that 'MediaType' conform to 'Decodable'</code>. I release that the different is that my model is using <code>type</code> in the items but not in the root Media struct.</p>

<pre><code>let jsonString = """"""
[{""name"": ""Popular Movies"",
""description"": ""Basic movie description"",
""items"": [ { ""id"": 15, ""budget"": 10, ""type"": ""movies"",""name"": ""Sample movie"", ""movieSPT"": """"}]
},
{""name"": ""Popular TV Shows"",
""description"": ""Basic shows description"",
""items"": [ { ""id"": 15, ""adult"": false, ""type"": ""tvshows"",""title"": ""Sample show"", ""showSPT"": """"}]
}
]
""""""
let data = Data(jsonString.utf8)


struct Movie : Decodable {
    let id: Int
    let name, movieSPT: String
    let type: String
    let budget: Int
}

struct TVShow : Decodable {
    let id: Int
    let title, showSPT: String
    let type: String
    let adult: Bool
}

enum MediaType {
    case movie([Movie]), tvShow([TVShow])
}

struct Media : Decodable {
    let name : String
    let description : String
    let items : MediaType

    private enum CodingKeys : String, CodingKey { case name, description, type, items }

    init(from decoder : Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.name = try container.decode(String.self, forKey: .name)
        self.description = try container.decode(String.self, forKey: .description)
        self.items = try container.decode(MediaType.self, forKey: .items)
        // type = try container.decode(String.self, forKey: .type)
        if items.type == ""movies"" {
            let movieData = try container.decode([Movie].self, forKey: .items)
            // print(""AAA: \(movieData)"")
            items = .movie(movieData)
        } else { // add better error handling
            let showData = try container.decode([TVShow].self, forKey: .items)
            items = .tvShow(showData)
        }

    }
}

do {
    let result = try JSONDecoder().decode([Media].self, from: data)
    print(result)
} catch {
    print(error)
}
</code></pre>

<p><strong>Add JSON Data</strong>, <code>known_for</code> is an [object], which object could Movie type or TV type.</p>

<pre><code>{
  ""page"": 1,
  ""total_results"": 10000,
  ""total_pages"": 500,
  ""results"": [
    {
      ""popularity"": 57.168,
      ""known_for_department"": ""Acting"",
      ""name"": ""Thassapak Hsu"",
      ""id"": 1910848,
      ""profile_path"": ""/1fmjgN8EvDj1TiEJk2Zs4y0T40O.jpg"",
      ""adult"": false,
      ""known_for"": [
        {
          ""original_name"": ""萌妻食神"",
          ""genre_ids"": [
            35,
            10765,
            10766
          ],
          ""media_type"": ""tv"",
          ""name"": ""Cinderella Chef"",
          ""origin_country"": [],
          ""vote_count"": 5,
          ""first_air_date"": ""2018-04-23"",
          ""backdrop_path"": ""/rnzmWKEiWPb8GC1mlqQojj8ccWj.jpg"",
          ""original_language"": ""zh"",
          ""id"": 79574,
          ""vote_average"": 9,
          ""overview"": """",
          ""poster_path"": ""/xb40Li6ff1BK0pVOxV4lutssCrR.jpg""
        },
        {
          ""original_name"": ""外星女生柴小七"",
          ""genre_ids"": [
            35,
            10765
          ],
          ""media_type"": ""tv"",
          ""name"": ""My Girlfriend is an Alien"",
          ""origin_country"": [
            ""CN""
          ],
          ""vote_count"": 2,
          ""first_air_date"": ""2019-08-19"",
          ""backdrop_path"": ""/kCl7piWv3pypgYfyLFi7ZgFGlYV.jpg"",
          ""original_language"": ""zh"",
          ""id"": 92779,
          ""vote_average"": 9,
          ""overview"": ""The alien girl Chai Xiaoqi tells the story of Fang Xiaoqi, the overbearing president of the alien girl who died from the \""Cape Town Planet\"", who was suffering from the \""rainy weather heterosexual amnesia\"". A high-energy hilarious and romantic cross-star love story. The female host Chai Xiaoqi is not only an alien, but also a true-handed witch. Once she inhales the hormones emitted by the males in the earth, she will fall into the \""flowery state\"" and suffer from various diseases. The fun and ridiculously ridiculous romance will restore the singularity of the girl in the perfection of the girl. In order to survive on the human earth, Chai Xiaoqi will use his various super powers to solve one accident after another, like a roller coaster. The ups and downs will make the audience hooked. The male lord is cold and is an alternative overbearing president. When it rains, he will forget the opposite sex that appears around him. For this reason, he and the female host will launch various \""fighting and fighting\"" laughter dramas. The experience of high sweetness and romance is expected to be Strongly slammed the girl's heart when it was broadcast."",
          ""poster_path"": ""/5e2owvs9TWVsuIacTFxJGPp6KVW.jpg""
        },
        {
          ""original_name"": ""Devil Lover เผลอใจ..ให้นายปีศาจ"",
          ""id"": 74640,
          ""media_type"": ""tv"",
          ""name"": ""Devil Lover เผลอใจ..ให้นายปีศาจ"",
          ""vote_count"": 0,
          ""vote_average"": 0,
          ""first_air_date"": ""2015-10-07"",
          ""poster_path"": ""/moThN7iERydEHI2RbfrmhCp69R4.jpg"",
          ""genre_ids"": [
            35
          ],
          ""original_language"": ""th"",
          ""backdrop_path"": ""/iRYOwW6DRIRwDYVmRWA8nbfaV2c.jpg"",
          ""overview"": """",
          ""origin_country"": [
            ""TH""
          ]
        }
      ],
      ""gender"": 2
    },
    {
      ""popularity"": 39.35,
      ""known_for_department"": ""Acting"",
      ""gender"": 1,
      ""id"": 2487703,
      ""profile_path"": ""/jRdDoFoHq36hg4kYxxiLa5DRYUW.jpg"",
      ""adult"": false,
      ""known_for"": [
        {
          ""poster_path"": ""/d9PhCnofBEeQGR3lwywTjWKBiXj.jpg"",
          ""id"": 449924,
          ""vote_count"": 346,
          ""video"": false,
          ""media_type"": ""movie"",
          ""adult"": false,
          ""backdrop_path"": ""/ekP6EVxL81lZ4ivcqPsoZ72rY0h.jpg"",
          ""genre_ids"": [
            28,
            18,
            36
          ],
          ""original_title"": ""葉問4"",
          ""original_language"": ""cn"",
          ""title"": ""Ip Man 4: The Finale"",
          ""vote_average"": 6,
          ""overview"": ""Following the death of his wife, Ip Man travels to San Francisco to ease tensions between the local kung fu masters and his star student, Bruce Lee, while searching for a better future for his son."",
          ""release_date"": ""2019-12-20""
        }
      ],
      ""name"": ""Vanda Lee""
    },
    {
      ""popularity"": 28.664,
      ""known_for_department"": ""Acting"",
      ""gender"": 1,
      ""id"": 556435,
      ""profile_path"": ""/5MgWM8pkUiYkj9MEaEpO0Ir1FD9.jpg"",
      ""adult"": false,
      ""known_for"": [
        {
          ""release_date"": ""2019-05-30"",
          ""id"": 496243,
          ""vote_count"": 5120,
          ""video"": false,
          ""media_type"": ""movie"",
          ""vote_average"": 8.6,
          ""title"": ""Parasite"",
          ""genre_ids"": [
            35,
            18,
            53
          ],
          ""original_title"": ""기생충"",
          ""original_language"": ""ko"",
          ""adult"": false,
          ""backdrop_path"": ""/TU9NIjwzjoKPwQHoHshkFcQUCG.jpg"",
          ""overview"": ""All unemployed, Ki-taek's family takes peculiar interest in the wealthy and glamorous Parks for their livelihood until they get entangled in an unexpected incident."",
          ""poster_path"": ""/7IiTTgloJzvGI1TAYymCfbfl3vT.jpg""
        },
....
</code></pre>
","10158398","","10158398","","2020-03-14 13:59:03","2020-03-14 16:55:25","Swift: ERROR: keyNotFound(CodingKeys(stringValue: ""adult"", intValue: nil)","<swift><combine><jsondecoder>","1","0","","","","CC BY-SA 4.0"
"60640143","1","60651885","","2020-03-11 16:05:45","","10","6391","<p>I noticed that</p>

<pre><code>textField.publisher(for: \.text)
</code></pre>

<p>delivers events when editing finishes, but not for every character/editing change. How do I get a Publisher, that sends evens for every change?
In ReactiveSwift it would be</p>

<pre><code>textField.reactive.continousTextValues()
</code></pre>

<p>And in RxSwift it would be just (<a href=""https://stackoverflow.com/questions/45633173/how-do-you-get-a-signal-every-time-a-uitextfield-text-property-changes-in-rxswif"">How do you get a signal every time a UITextField text property changes in RxSwift</a>)</p>

<pre><code>textField.rx.text
</code></pre>

<p>Approaches I took:</p>

<ul>
<li>checking the <code>publisher(for:options:)</code> method, but there are no appropriate options for the desired outcome.</li>
<li>adding a target/action <code>textField.addTarget(self, action: #selector(theTextFieldDidChange), for: .editingChanged)</code> (<a href=""https://stackoverflow.com/questions/7010547/uitextfield-text-change-event"">UITextField text change event</a>)</li>
<li>doing essentially the same as the previous step by connecting the action via interface builder, both leading to extra work and cluttered code.</li>
<li>Watching the 2019 WWDC videos about Combine. They were not dealing with textfields, but using <code>@Published</code> variables instead, hiding were the values actually came from - (or did I miss something?).</li>
</ul>

<p>I have no clue at the moment, how to do this and I feel the tendency to go back to ReactiveSwift, but I wanted to ask you, before taking this step backwards.</p>
","1836024","","","","","2022-01-13 13:59:42","Swift Combine - How to get a Publisher that delivers events for every character change of UITextField's text property","<ios><swift><uitextfield><combine>","4","2","3","","","CC BY-SA 4.0"
"60646857","1","60647296","","2020-03-12 02:36:53","","3","2335","<p>I'm working in SwiftUI and have an AudioPlayer type that is a subclass of AVPlayer; it publishes AVPlayer's timeControllerStatus(?) (.playing, .paused, and others?). Rather than subclassing AVPlayer, I would like to pass in an AVPlayer and have it notify me using .onReceive in some View. Here is the current, functional type I have:</p>

<pre><code>import AVKit
import Combine

class AudioPlayer: AVPlayer, ObservableObject {
    @Published var buffering: Bool = false

    override init() {
        super.init()
        registerObservers()
    }

    private func registerObservers() {
        self.addObserver(self, forKeyPath: ""timeControlStatus"", options: [.old, .new], context: nil)
    }

    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {

        if keyPath == ""timeControlStatus"", let change = change, let newValue = change[NSKeyValueChangeKey.newKey] as? Int, let oldValue = change[NSKeyValueChangeKey.oldKey] as? Int {
            let oldStatus = AVPlayer.TimeControlStatus(rawValue: oldValue)
            let newStatus = AVPlayer.TimeControlStatus(rawValue: newValue)
            if newStatus != oldStatus {
                DispatchQueue.main.async {[weak self] in
                    if newStatus == .playing || newStatus == .paused {
                        self?.buffering = false
                    } else {
                        self?.buffering = true
                    }
                }
            }
        }
    }
}
</code></pre>

<p>And here is an example of a class like the one I would like (taken from <a href=""https://medium.com/@chris.mash/avplayer-swiftui-part-4-better-player-observing-3e5c3f24419d"" rel=""nofollow noreferrer"">Chris Mash's tutorial on SwiftUI &amp; AVPlayer</a>):</p>

<pre><code>import Combine
import AVFoundation

class PlayerItemObserver {
    let publisher = PassthroughSubject&lt;Bool, Never&gt;()
    private var itemObservation: NSKeyValueObservation?

    init(player: AVPlayer) {
        // Observe the current item changing
        itemObservation = player.observe(\.currentItem) { [weak self] player, change in
            guard let self = self else { return }
            // Publish whether the player has an item or not
            self.publisher.send(player.currentItem != nil)
        }
    }

    deinit {
        if let observer = itemObservation {
            observer.invalidate()
        }
    }
}
</code></pre>

<p>Your help is much appreciated.</p>
","12506105","","","","","2020-03-12 07:42:00","SwiftUI Combine for .onReceive notifications with AVPlayer","<swift><notifications><swiftui><avplayer><combine>","2","1","6","","","CC BY-SA 4.0"
"60658644","1","60659366","","2020-03-12 16:56:08","","1","198","<p>I'm trying to display data from <code>Contentful</code> into my <code>SwiftUI</code> app but I'm hitting an issue.</p>

<p>The goal is to display a list of movies and have them tappable. When I select a movie I want to get the data for that movie, so the title &amp; movie trailer for example. </p>

<p>But in my selectable row I'm getting <code>Use of undeclared type 'movie'</code> and in my movies View I'm getting <code>Use of undeclared type 'fetcher'</code></p>

<p>Here's what I have tried below:</p>

<pre><code>import SwiftUI
import Combine
import Contentful

struct Movie: Codable, Identifiable, FieldKeysQueryable, EntryDecodable {

    static let contentTypeId: String = ""movies""

    // FlatResource Memberes.
    let id: String
    var updatedAt: Date?
    var createdAt: Date?
    var localeCode: String?

    var title: String
    var movieId: String
    var movieTrailer: String

    enum FieldKeys: String, CodingKey {

        case title, movieId, movieTrailer
    }

    enum CodingKeys: String, CodingKey {
        case id = ""id""
        case title = ""title""
        case movieId = ""movieId""
        case movieTrailer = ""movieTrailer""
    }
}

public class MovieFetcher: ObservableObject {

    @Published var movies = [Movie]()

    init() {
        getArray(id: ""movies"") { (items) in
            items.forEach { (item) in
                self.movies.append(Movie(id: item.id, title: item.title, movieId: item.movieId, movieTrailer: item.movieTrailer))
            }
        }
    }

    func getArray(id: String, completion: @escaping([Movie]) -&gt; ()) {

        let client = Client(spaceId: spaceId, accessToken: accessToken, contentTypeClasses: [Movie.self])

        let query = QueryOn&lt;Movie&gt;.where(contentTypeId: ""movies"")

        client.fetchArray(of: Movie.self, matching: query) { (result: Result&lt;ArrayResponse&lt;Movie&gt;&gt;) in
            switch result {
            case .success(let array):
                DispatchQueue.main.async {
                    completion(array.items)
                }
            case .error(let error):
                print(error)
            }
        }
    }
}

struct moviesView : View {

    @ObservedObject var fetcher = MovieFetcher()

    @State var selectMovie: Movie? = nil

    @Binding var show: Bool

    var body: some View {
        HStack(alignment: .bottom) {
            if show {
                ScrollView(.horizontal) {
                    Spacer()

                    HStack(alignment: .bottom, spacing: 30) {
                        ForEach(fetcher.movies, id: \.self) { item in
                            selectableRow(movie: item, selectMovie: self.$selectMovie)
                        }
                    }
                    .frame(minWidth: 0, maxWidth: .infinity)
                }
                .padding(.leading, 46)
                .padding(.bottom, 26)
            }
        }
    }
}

struct selectableRow : View {

    var movie: Movie

    @Binding var selectedMovie: Movie?

    @State var initialImage = UIImage()

    var urlString = ""\(urlBase)\(movie.movieId).png?""

    var body: some View {
        ZStack(alignment: .center) {
            if movie == selectedMovie {
                Image("""")
                .resizable()
                .frame(width: 187, height: 254)
                .overlay(
                    RoundedRectangle(cornerRadius: 13)
                Image(uiImage: initialImage)
                .resizable()
                .cornerRadius(13.0)
                .frame(width: 182, height: 249)
                .onAppear {
                    guard let url = URL(string: self.urlString) else { return }
                    URLSession.shared.dataTask(with: url) { (data, response, error) in
                        guard let data = data else { return }
                        guard let image = UIImage(data: data) else { return }

                        RunLoop.main.perform {
                            self.initialImage = image
                        }

                    }.resume()
                }
            } else {
                Image(uiImage: initialImage)
                .resizable()
                .cornerRadius(13.0)
                .frame(width: 135, height: 179)
                .onAppear {
                    guard let url = URL(string: self.urlString) else { return }
                    URLSession.shared.dataTask(with: url) { (data, response, error) in
                        guard let data = data else { return }
                        guard let image = UIImage(data: data) else { return }

                        RunLoop.main.perform {
                            self.initialImage = image
                        }

                    }.resume()
                }
            }
        }
        .onTapGesture {
            self.selectedMovie = self.movie
        }
    }
}
</code></pre>
","899345","","899345","","2020-03-12 21:34:17","2020-03-12 21:34:17","Trouble displaying data from Contentful in SwiftUI","<ios><swift><xcode><swiftui><contentful>","1","0","","","","CC BY-SA 4.0"
"60664231","1","60664863","","2020-03-13 02:46:34","","1","315","<p>When I launch the application it does load the data but when it is building a model it crashes with the following error: </p>

<p><img src=""https://i.stack.imgur.com/g63zF.png"" alt=""A screen of the error""></p>

<p>The following code is from my GetIphonesData.swift class: </p>

<pre><code>import Foundation
import Firebase
import Combine

class GetIphonesData : ObservableObject {
    @Published var data = [Iphone]()

    init() {
        let db = Firestore.firestore()

        db.collection(""iphones"").addSnapshotListener { (snap, err) in
            DispatchQueue.main.async {
                if let err = err {
                    print(""Error getting documents: \(err)"")
                } else {
                    for i in snap!.documents {
                        let iphone = Iphone(id: i.documentID,
                                                name: i.get(""name"") as! String,
                                                models: i.get(""model"") as! String,
                                                yearReleased: i.get(""yearReleased"") as! String,
                                                storageVariants: i.get(""storageVariants"") as! String,
                                                colors: i.get(""colors"") as! String,
                                                batteryCapacity: i.get(""batteryCapacity"") as! String,
                                                cameraResolution: i.get(""cameraResolution"") as! String,
                                                screenSize: i.get(""screenSize"") as! String,
                                                screenResolution: i.get(""screenResolution"") as! String,
                                                sensors: i.get(""sensors"") as! String,
                                                memory: i.get(""memory"") as! String)

                        self.data.append(iphone)
                    }
                }
            }
        }
    }
}

</code></pre>

<p>When I print the data it prints. When I have 1 item in the database it works but once I add more items into the database it crashes. Is there a fix to this or is there a reason to it at all?</p>
","10975170","","209103","","2020-03-13 03:35:57","2020-03-13 04:28:23","When getting data from Firebase Firestore my SwiftUI application crashes with an error. What could this be caused by?","<ios><swift><firebase><google-cloud-firestore><swiftui>","1","0","","","","CC BY-SA 4.0"
"60667976","1","60668133","","2020-03-13 09:33:34","","2","2536","<p>SwiftUI and Combine noob here, I isolated in a playground the problem I am having. Here is the playground.</p>

<pre class=""lang-swift prettyprint-override""><code>final class ReactiveContainer&lt;T: Equatable&gt; {
    @Published var containedValue: T?
}

class AppContainer {
    static let shared = AppContainer()

    let text = ReactiveContainer&lt;String&gt;()
}

struct TestSwiftUIView: View {

    @State private var viewModel = ""test""

    var body: some View {
        Text(""\(viewModel)"")
    }

    init(textContainer: ReactiveContainer&lt;String&gt;) {

        textContainer.$containedValue.compactMap {
            print(""compact map \($0)"")
            return $0
        }.assign(to: \.viewModel, on: self)
    }
}

AppContainer.shared.text.containedValue = ""init""


var testView = TestSwiftUIView(textContainer: AppContainer.shared.text)
print(testView)

print(""Executing network request"")
DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
    AppContainer.shared.text.containedValue = ""Hello world""
    print(testView)
}
</code></pre>

<p>When I run the playground this is what's happening:</p>

<pre><code>compact map Optional(""init"")
TestSwiftUIView(_viewModel: SwiftUI.State&lt;Swift.String&gt;(_value: ""test"", _location: nil))
Executing network request
TestSwiftUIView(_viewModel: SwiftUI.State&lt;Swift.String&gt;(_value: ""test"", _location: nil))
</code></pre>

<p>So as you can see, two problems there:</p>

<ul>
<li><p>The compact map closure is only called once, on subscription but not when the dispatch is ran</p></li>
<li><p>The assign operator is never called</p></li>
</ul>

<p>I have been trying to solve this these past few hours without any success. Maybe someone with a top knowledge in SwiftUI/Combine could help me, thx !</p>

<p><strong>EDIT</strong></p>

<p>Here is the working solution:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {

    @State private var viewModel = ""test""
    let textContainer: ReactiveContainer&lt;String&gt;

    var body: some View {
        Text(viewModel).onReceive(textContainer.$containedValue) { (newContainedValue) in
            self.viewModel = newContainedValue ?? """"
        }
    }

    init(textContainer: ReactiveContainer&lt;String&gt;) {
        self.textContainer = textContainer
    }
}
</code></pre>
","2614946","","2614946","","2020-03-19 17:58:03","2021-07-07 10:16:26","@Published and .assign not reacting to value update","<ios><swift><swiftui><combine><publisher>","3","1","","","","CC BY-SA 4.0"
"60683077","1","65042821","","2020-03-14 13:06:02","","2","1534","<p>I'm <strong>trying to read HTML formatted content using SwiftUI,</strong> I tried using several different methods to load the HTML string but the string was not displayed. I'm using XCode 11.2.1, I will appreciate your help.</p>

<pre><code>import SwiftUI
import Combine
import WebKit

struct SubChapterDetails: View {
    let sentDescription: String
    let webView = WKWebView()

    var body: some View {
           VStack {
               Text(""Testing HTML Content"")
               Spacer()
               HTMLStringView(htmlContent: ""&lt;h1&gt;This is HTML String&lt;/h1&gt;"")  //It doesn't displays this when the code is executed
               Spacer()
           }
       }
}

struct SubChapterDetails_Previews: PreviewProvider {
    static var previews: some View {
        SubChapterDetails(sentDescription: """")
    }
}

struct HTMLStringView: UIViewRepresentable {
    let htmlContent: String

    func makeUIView(context: Context) -&gt; WKWebView {
        return WKWebView()
    }

    func updateUIView(_ uiView: WKWebView, context: Context) {
        uiView.loadHTMLString(htmlContent, baseURL: nil)
    }
}
</code></pre>
","4799887","","","","","2020-11-27 19:29:05","Reading HTML String using SwiftUI","<html><swift><swiftui>","1","3","1","","","CC BY-SA 4.0"
"60689807","1","60690133","","2020-03-15 04:41:38","","2","1475","<pre><code>notificationCenterPublisher = NotificationCenter.default
            .publisher(for: .NSManagedObjectContextObjectsDidChange, object: context)
            .map { (notification) -&gt; (CoreDataContextObserverState) in
                self.handleContextObjectDidChangeNotification(notification: notification)
            }
            .eraseToAnyPublisher()
</code></pre>

<p>I have the method handleContextObjectDidChangeNotification doing the mapping.</p>

<p>Right now notificationCenterPublisher is of type <code>AnyPublisher&lt;CoreDataContextObserverState, Never&gt;</code></p>

<p>But I want to make it <code>AnyPublisher&lt;CoreDataContextObserverState, Error&gt;</code> and have handleContextObjectDidChangeNotification have some way of indicating an error has occured. </p>

<p>How do I do that?</p>
","56952","","","","","2020-03-15 05:55:16","How to change error type from Never to Error in Combine?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"60699070","1","60699115","","2020-03-16 00:37:20","","7","5188","<p>I have a method that returns a Future:</p>

<pre><code>func getItem(id: String) -&gt; Future&lt;MediaItem, Error&gt; {
  return Future { promise in
    // alamofire async operation
  }
}
</code></pre>

<p>I want to use it in another method and covert <code>MediaItem</code> to <code>NSImage</code>, which is a synchronous operation.  I was hoping to simply do a <code>map</code> or <code>flatMap</code> on the original Future but it creates a long Publisher that I cannot erased to <code>Future&lt;NSImage, Error&gt;</code>.</p>

<pre><code>func getImage(id: String) -&gt; Future&lt;NSImage, Error&gt; {
  return getItem(id).map { mediaItem in
    // some sync operation to convert mediaItem to NSImage
    return convertToNSImage(mediaItem)  // this returns NSImage
  }
}
</code></pre>

<p>I get the following error:</p>

<p><code>Cannot convert return expression of type 'Publishers.Map&lt;Future&lt;MediaItem, Error&gt;, NSImage&gt;' to return type 'Future&lt;NSImage, Error&gt;'</code></p>

<p>I tried using <code>flatMap</code> but with a similar error. I can <code>eraseToAnyPublisher</code> but I think that hides the fact that <code>getImage(id: String</code> returns a Future.</p>

<p>I suppose I can wrap the body of <code>getImage</code> in a future but that doesn't seem as clean as chaining and mapping.  Any suggestions would be welcome.</p>
","3845803","","","","","2021-04-16 23:43:58","Mapping Swift Combine Future to another Future","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"60702699","1","60704282","","2020-03-16 08:41:03","","6","805","<p><code>ContentView2</code> view is not refreshed when <code>model.value</code> changes, if <code>Model</code> conforms to <code>ObservableObject</code> directly instead of inheriting <code>SuperModel</code> then it works fine</p>

<pre><code>class SuperModel: ObservableObject {

}

class Model: SuperModel {
    @Published var value = """"
}

struct ContentView2: View {

    @ObservedObject var model = Model()

    var body: some View {
        VStack {
            Text(model.value)
            Button(""change value"") {
                self.model.value = ""\(Int.random(in: 1...10))""
            }
        }

    }
}
</code></pre>
","10208552","","","","","2020-03-16 10:40:03","View refreshing not triggered when ObservableObject is inherited in SwiftUI","<ios><swift><swiftui><combine>","3","2","","","","CC BY-SA 4.0"
"60707748","1","60737883","","2020-03-16 14:25:30","","1","133","<p>ListView displays a list of items added to favorites.</p>

<p>Go to DetailView and remove the item from your favorites.</p>

<p>And when I return to the list view, I want to update it to the latest list.</p>

<p>How do you do it?</p>

<h2>Code</h2>

<h3>ListView.swift</h3>

<p>A list of 3x3 card types is displayed.</p>

<pre><code>struct ListView: View {
    @ObservedObject var fetcher = DataFetcher()
    private let columns: Int = 3

    var body: some View {
        GeometryReader { geometry in
            NavigationView {
                ScrollView() {
                    VStack {
                        ForEach(0..&lt;self.fetcher.dataCount/self.columns) { rowIndex in
                            HStack {
                                ForEach(0..&lt;self.columns) { columnIndex in
                                    self.getCell(
                                        item: self.getItem(rowIndex: rowIndex, columnIndex: columnIndex),
                                        width: self.cellWidth(width: geometry.size.width),
                                        height: self.cellHeight(width: geometry.size.width))
                                }
                            }
                        }

                      if (self.fetcher.dataCount % self.columns &gt; 0) {
                          HStack {
                              ForEach(0..&lt;self.fetcher.dataCount % self.columns) { lastColumnIndex in
                                  self.getCell(
                                      item: self.getItem(lastColumnIndex: lastColumnIndex),
                                      width: self.cellWidth(width: geometry.size.width),
                                      height: self.cellHeight(width: geometry.size.width))
                              }
                              Spacer()
                          }
                      }
                  }
                  .frame(maxWidth: .infinity)
                }
                .navigationBarTitle(""list"")
            }
        }
    }

    private func cellWidth(width: CGFloat) -&gt; CGFloat {
        return (width  - 60) / CGFloat(columns)
    }

    private func cellHeight(width: CGFloat) -&gt; CGFloat {
        return cellWidth(width: (width)) * 1.414
    }

    private func getItem(rowIndex: Int, columnIndex: Int) -&gt; TrackModel {
        return fetcher.data[columns * rowIndex + columnIndex]
    }

    private func getItem(lastColumnIndex: Int) -&gt; TrackModel {
        return self.fetcher.data[self.columns * (self.fetcher.dataCount / self.columns) + lastColumnIndex]
    }

    private func getCell(item: ItemModel, width: CGFloat, height: CGFloat) -&gt; AnyView {
        return AnyView(
            NavigationLink(
                destination: etailView(itemModel: item)
            ) {
                ItemRow(itemModel: item)
                .frame(width: width, height: height)
            }
            .buttonStyle(PlainButtonStyle())
        )
    }
}
</code></pre>

<p>　
　　　</p>

<h3>DataFetcher.swift</h3>

<p>Firestore has a collection of ""users"" and ""items"". </p>

<p>Each user's document has a collection of ""items"". </p>

<p>""items"" has a reference type ""item"" and the value is ""items / documentID"".</p>

<pre><code>class DataFetcher: ObservableObject {
    typealias PublisherType = PassthroughSubject
    @Published var data: [TrackModel] = []
    @Published var dataCount: Int = 0
    private let userDefaults = UserDefaults.standard
    private let uid: String
    private var db: Firestore!
    private let dispatchGroup = DispatchGroup()
    private let dispatchQueue = DispatchQueue(label: ""queue"")

    init() {
        db = Firestore.firestore()
        uid = self.userDefaults.object(forKey: ""userDataUid"") as! String
        fetchData()
    }

    private func fetchData() {
        self.db.collection(""users"").document(uid).collection(""items"").getDocuments { (snaps, err) in
            if let err = err {
                print(""Error getting documents: \(err)"")
            }

            guard let snaps = snaps else { return }

            for document in snaps.documents {
                self.dispatchGroup.enter()
                self.dispatchQueue.async(group: self.dispatchGroup) { [weak self] in
                    self?.asyncProcess(document: document) { (snap2: DocumentSnapshot) -&gt; Void in
                        self!.data.append(TrackModel(
                            documentId: snap2.documentID,
                            title: snap2.data()![""title""] as! String,
                            image: snap2.data()![""image""] as! String
                        ))
                        self?.dispatchGroup.leave()
                    }
                }
            }

            self.dispatchGroup.notify(queue: .main) {
                self.dataCount = self.data.count
            }
        }
    }

    func asyncProcess(document: QueryDocumentSnapshot, completion: @escaping (_ snap: DocumentSnapshot) -&gt; Void) {
        let refarence: DocumentReference = document.data()[""item""] as! DocumentReference

        refarence.getDocument { (snap, err) in
            completion(snap!)
        }
    }
}
</code></pre>

<h2>Postscript</h2>

<p>When I went to the detail screen with Modal and returned to the list screen, I could not fetch.</p>

<p>what should I do?</p>

<pre><code>Button(action: {
    self.modalPresented.toggle()
}) {
    Text(""Go to Detail"")

}
.sheet(isPresented: self.$modalPresented) {
    DetailView(onDismiss: {
        self.modalPresented = false
        self.fetcher.fetchData()
    })
}
</code></pre>
","12003672","","12003672","","2020-03-18 12:49:49","2020-03-18 12:49:49","I want to update the displayed list to the latest state when returning from the transition destination with SwiftUI","<swift><firebase><google-cloud-firestore><swiftui>","1","0","","","","CC BY-SA 4.0"
"60710997","1","60711837","","2020-03-16 17:59:41","","0","1915","<p>So I'm adding an Image to my SwiftUI list by getting(fetching) the path to the image and then using the image path to fetch the image from that url/path.</p>

<p><strong>Grabbing the data/path</strong></p>

<pre><code>class Webservice {
    func getAllPosts(completion: @escaping ([Post]) -&gt; ()) {
        guard let url = URL(string: ""http://localhost:8000/albums"")
     else {
     fatalError(""URL is not correct!"")
    }

        URLSession.shared.dataTask(with: url) { data, _, _ in

            let posts = try!

                JSONDecoder().decode([Post].self, from: data!); DispatchQueue.main.async {
                    completion(posts)
            }
        }.resume()
    }
}
</code></pre>

<p><strong>Variables</strong></p>

<pre><code>struct Post: Codable, Hashable, Identifiable {

    let id: String
    let title: String
    let path: String
    let description: String
}
</code></pre>

<p><strong>Setting the variables in <code>Post</code> to the posts in <code>completion(posts)</code> in <code>class Webservice</code>.</strong></p>

<pre><code>final class PostListViewModel: ObservableObject {

    init() {
        fetchPosts()
    }

    @Published var posts = [Post]()

    private func fetchPosts() {
        Webservice().getAllPosts {
            self.posts = $0
        }
    }


}
</code></pre>

<p><strong>Fetch image from url/path</strong></p>

<pre><code>class ImageLoader: ObservableObject {
    var didChange = PassthroughSubject&lt;Data, Never&gt;()
    var data = Data() {
        didSet {
            didChange.send(data)
        }
    }

    init(urlString:String) {
        guard let url = URL(string: urlString) else { return }
        let task = URLSession.shared.dataTask(with: url) { data, response, error in
            guard let data = data else { return }
            DispatchQueue.main.async {
                self.data = data
            }
        }

        task.resume()
    }
}
</code></pre>

<p><strong>Set @State image</strong></p>

<pre><code>struct ImageView: View {
    @ObservedObject var imageLoader:ImageLoader
    @State var image:UIImage = UIImage()

    init(withURL url:String) {
        imageLoader = ImageLoader(urlString:url)
    }

    var body: some View {

            Image(uiImage: image)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(width:100, height:100)
                .onReceive(imageLoader.didChange) { data in
                self.image = UIImage(data: data) ?? UIImage()
        }
    }
}
</code></pre>

<p><strong>Then display my image in a list using <code>ImageView</code> with the url/path from the data I fetched in the beginning which gets passed into <code>ImageLoader</code> to grab the image and set @State image in <code>ImageView</code></strong></p>

<pre><code>struct ContentView: View {
   init() {
            Webservice().getAllPosts {
                print($0)
            }
        }

    @ObservedObject var model = PostListViewModel()

        var body: some View {

                List(model.posts) { post in
                 VStack {
                    Text(post.title)
                    ImageView(withURL: ""http://localhost:8000/\(post.path)"")
                    Text(post.description)


                }
            }

        }

}
</code></pre>

<p>This code works to get the image at first but once I start scrolling here and there the images start to disappear. Why is this happening and how do I fix it?</p>

<p><strong>Edit:</strong> I was told to cache the images to prevent loading again. Does anyone know how I would do that?</p>
","3750856","","3750856","","2020-03-16 18:44:33","2021-09-11 19:08:49","Images disappear in List as I scroll SwiftUI/Swift","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"60711337","1","60712803","","2020-03-16 18:25:51","","1","1233","<p>Lets say I have a publisher like this:</p>

<pre><code>NotificationCenter.default.publisher(for: NSNotification.Name.NSManagedObjectContextObjectsDidChange)
  .map { notification in /.. do something ../}
</code></pre>

<p>how do I make it so that in my block, I stop the publisher from emitting? </p>

<p>I could make it a trymap and then throw an error. But it's so weird to have to throw just to indicate a lack of results (in this case, let's say a non relevant NSManagedObject change)</p>
","56952","","","","","2020-03-16 20:34:54","How to write publisher that conditionally publish?","<swift><combine>","3","1","","","","CC BY-SA 4.0"
"60715143","1","60715429","","2020-03-17 01:28:27","","4","469","<p>So I'm much more familiar with <code>RxSwift</code> than <code>Combine</code>. A good way I manage mutable/immutable interfaces is I do something like this in <code>RxSwift</code></p>

<pre><code>
protocol SampleStream {
   /// An immutable interface. 
   var streamInfo: Observable&lt;String?&gt; { get} 
}

protocol MutableSampleStream: SampleStream {
   /// A mutable interface. 
   func updateStream( _ val: String?)
}

func SampleStreamImpl: MutableSampleStream {

   // Returns the immutable version of the stream.
   // If I pass down SampleStream as a dependency, then nothing else can write to this stream.
   // When they subscribe, they immediately get a value though since it's a behavior subject. 
   var streamInfo: Observable&lt;String?&gt; {
      return streamInfoSubject.asObservable()
   }

   private var streamInfoSubject = BehaviorSubject&lt;String?&gt;(value: nil) 

   func updateStream { }
}

</code></pre>

<p>How can I do something similar using <code>Combine</code>? Combine's <code>currentValueSubject</code> doesn't appear to have a way to cast this down to a non-read write version. Or am I missing something? </p>

<p>In my app, I don't want to directly pass down a <code>currentValueSubject</code> since I know for a fact I only want this stream updated from one place. Everywhere else should just read from the stream and not have write capability. </p>
","9718260","","","","","2020-03-17 02:20:08","How can I cast a currentValueSubject to non-mutable observable?","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"60721207","1","60730608","","2020-03-17 11:12:15","","2","2379","<p>I use Combine in viewModels to update the views. But if I store the AnyCancellable objects into a set of AnyCancellable, the deinit method is never called. I use the deinit to cancel all cancellables objects.</p>

<pre><code>struct View1: View {

    @ObservedObject var viewModel:ViewTextModel = ViewTextModel()
    @Injected var appActions:AppActions

    var body: some View {
        VStack {
            Text(self.viewModel.viewText)

            Button(action: {
                self.appActions.goToView2()
            }) {
                Text(""Go to view \(self.viewModel.viewText)"")
            }
        }
    }
}
</code></pre>

<pre><code>class ViewTextModel: ObservableObject {
    @Published var viewText: String

    private var cancellables = Set&lt;AnyCancellable&gt;()

    init(state:AppState) {
        // initial state
        viewText = ""view  \(state.view)""
        // updated state
        state.$view.removeDuplicates().map{ ""view \($0)""}.assign(to: \.viewText, on: self).store(in: &amp;cancellables)
    }

    deinit {
        cancellables.forEach { $0.cancel() }
    } 
}
</code></pre>

<p>Each time the view is rebuilt, a new viewmodel is instantiated but the old one is not destroyed. <code>viewText</code> attribute is updated on each instance with <code>state.$view.removeDuplicates().map{ ""view \($0)""}.assign(to: \.viewText, on: self).store(in: &amp;cancellables)</code></p>

<p>If I don't store the cancellable object in the set, <code>deinit</code> is called but <code>viewText</code> is not updated if the state's changed for the current view.</p>

<p>Do you have an idea of ​​how to manage the update of the state without multiplying the instances of the viewmodel ?</p>

<p>Thanks</p>
","8649394","","","","","2021-10-20 13:18:00","How to deinit ViewModel with combine framework when views disappears","<swiftui><state><viewmodel><combine><deinit>","1","2","1","","","CC BY-SA 4.0"
"60722806","1","60724483","","2020-03-17 12:51:37","","1","270","<p>I'm looking for a way of observing <code>@State</code> or <code>@Binding</code> value changes in <code>onReceive</code>. I can't make it work, and I suspect it's not possible, but maybe there's a way of transforming them to <code>Publisher</code> or something while at the same time keeping the source updating value as it's doing right now?</p>

<p>Below you can find some context why I need this:</p>

<p>I have a parent view which is supposed to display half modal based on this library: <a href=""https://github.com/AndreaMiotto/PartialSheet"" rel=""nofollow noreferrer"">https://github.com/AndreaMiotto/PartialSheet</a></p>

<p>For this purpose, I've created a <code>@State private var modalPresented: Bool = false</code> and I'm using it to show and hide this modal view. This works fine, but my parent initializes this modal immediately after initializing self, so I completely loose the <code>onAppear</code> and <code>onDisappear</code> modifiers. The problem is that I need <code>onAppear</code> to perform some data fetching every time this modal is being presented (ideally I'd also cancel network task when modal is being dismissed).</p>
","1911042","","","","","2020-03-17 14:33:27","Observing Binding or State variables","<ios><swift><swiftui><combine>","1","1","1","","","CC BY-SA 4.0"
"60732790","1","60733341","","2020-03-18 02:40:11","","0","33","<p>Is it acceptable for a pipeline of publishers to have consumers subscribe to the different parts of the chain? </p>

<p>In theory the subscribers can do processing and filtering in its own pipeline. But I find that having a 'ready made' publisher makes it easy for the consumer. I see that this is not the pattern generally used for Combine. Is there a downside to this that I am missing?</p>

<pre><code>import UIKit
import Combine

class Publisher {
    var rootPublisher = [1, 2, 3, 4, 5].publisher
    var evenPublisher: AnyPublisher&lt;Int, Never&gt;

    init () {
        evenPublisher = rootPublisher.filter { num in num % 2 == 0 }.eraseToAnyPublisher()
    }
}

class Consumer {
    let publisher = Publisher()
    func numbers () {
        publisher.rootPublisher.sink { int in
            print(int)
        }
    }
    func evenNumbers() {
        publisher.evenPublisher.sink { int in
            print(int)
        }
    }
}

Consumer().numbers()
Consumer().evenNumbers()
</code></pre>
","56952","","2322778","","2020-03-18 03:26:36","2020-03-18 04:03:07","Is it appropriate to have different layers of Publishers for different subscribers?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"60740197","1","60748919","","2020-03-18 13:03:14","","1","319","<p>I'm trying to build an Instagram clone app using SwiftUI.</p>

<p>I'm fetching the data through <code>Firebase</code> and trying to achieve a UI update every time the data in the server changes.</p>

<p>For some reason, when I first open the app and fetch the data, the <code>body</code> of my view gets called, but the UI doesn't change. I even put a breakpoint and saw the <code>body</code> gets called and contains the correct information, it's just the UI which doesn't get updated.</p>

<p>I have a few tabs in my app, and when I switch to another tab (which doesn't contain anything but a <code>Text</code> yet), suddenly the UI <strong>does</strong> gets updated.</p>

<p>Please see the gif below:</p>

<p><a href=""https://i.stack.imgur.com/ji4WT.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ji4WT.gif"" alt=""gif""></a></p>

<p>Here is my code:</p>

<p><strong>HomeView</strong>:</p>

<pre><code>struct HomeView: View {
    @ObservedObject private var fbData = firebaseData

    var body: some View {
        TabView {
            //Home Tab
            NavigationView {
                ScrollView(showsIndicators: false) {
                    ForEach(self.fbData.posts.indices, id: \.self) { postIndex in
                        PostView(post: self.$fbData.posts[postIndex])
                            .listRowInsets(EdgeInsets())
                            .padding(.vertical, 5)
                    }
                }
                .navigationBarTitle(""Instagram"", displayMode: .inline)
                .navigationBarItems(leading:
                    Button(action: {
                        print(""Camera btn pressed"")
                    }, label: {
                        Image(systemName: ""camera"")
                            .font(.title)
                    })
                , trailing:
                    Button(action: {
                        print(""Messages btn pressed"")
                    }, label: {
                        Image(systemName: ""paperplane"")
                            .font(.title)
                    })
                )
            } . tabItem({
                Image(systemName: ""house"")
                    .font(.title)
            })

            Text(""Search"").tabItem {
                Image(systemName: ""magnifyingglass"")
                    .font(.title)
            }

            Text(""Upload"").tabItem {
                Image(systemName: ""plus.app"")
                    .font(.title)
            }

            Text(""Activity"").tabItem {
                Image(systemName: ""heart"")
                    .font(.title)
            }

            Text(""Profile"").tabItem {
                Image(systemName: ""person"")
                    .font(.title)
            }
        }
        .accentColor(.black)
        .edgesIgnoringSafeArea(.top)
    }
}
</code></pre>

<p><strong>FirebaseData</strong>:</p>

<pre><code>let firebaseData = FirebaseData()

class FirebaseData : ObservableObject {
    @Published var posts = [Post]()

    let postsCollection = Firestore.firestore().collection(""Posts"")

    init() {
        self.fetchPosts()
    }

    //MARK: Fetch Data
    private func fetchPosts() {
        self.postsCollection.addSnapshotListener { (documentSnapshot, err) in
            if err != nil {
                print(""Error fetching posts: \(err!.localizedDescription)"")
                return
            } else {
                documentSnapshot!.documentChanges.forEach { diff in
                    if diff.type == .added {
                        let post = self.createPostFromDocument(document: diff.document)
                        self.posts.append(post)
                    } else if diff.type == .modified {
                        self.posts = self.posts.map { (post) -&gt; Post in
                            if post.id == diff.document.documentID {
                                return self.createPostFromDocument(document: diff.document)
                            } else {
                                return post
                            }
                        }
                    } else if diff.type == .removed {
                        for index in self.posts.indices {
                            if self.posts[index].id == diff.document.documentID {
                                self.posts.remove(at: index)
                            }
                        }
                    }
                }
            }
        }
    }

    private func createPostFromDocument(document: QueryDocumentSnapshot) -&gt; Post {
        let data = document.data()

        let id = document.documentID
        let imageUrl = data[""imageUrl""] as! String
        let authorUsername = data[""authorUsername""] as! String
        let authorProfilePictureUrl = data[""authorProfilePictureUrl""] as! String
        let postLocation = data[""postLocation""] as! String
        let postDescription = data[""postDescription""] as! String
        let numberOfLikes = data[""numberOfLikes""] as! Int
        let numberOfComments = data[""numberOfComments""] as! Int
        let datePosted = (data[""datePosted""] as! Timestamp).dateValue()
        let isLiked = data[""isLiked""] as! Bool

        return Post(id: id, imageUrl: imageUrl, authorUsername: authorUsername, authorProfilePictureUrl: authorProfilePictureUrl, postLocation: postLocation, postDescription: postDescription, numberOfLikes: numberOfLikes, numberOfComments: numberOfComments, datePosted: datePosted, isLiked: isLiked)
    }
}
</code></pre>

<p>If you need me to post more code please let me know.</p>

<p>Update:</p>

<p><strong>PostView</strong>:</p>

<pre><code>struct PostView: View {
    @Binding var post: Post

    var body: some View {
        VStack(alignment: .leading) {
            //Info bar
            HStack {
                WebImage(url: URL(string: post.authorProfilePictureUrl))
                    .resizable()
                    .frame(width: 40, height: 40)
                    .clipShape(Circle())

                VStack(alignment: .leading, spacing: 2) {
                    Text(post.authorUsername).font(.headline)
                    Text(post.postLocation)
                }

                Spacer()

                Button(action: {
                    print(""More options pressed"")
                }, label: {
                    Image(systemName: ""ellipsis"")
                        .font(.title)
                        .foregroundColor(.black)
                }).buttonStyle(BorderlessButtonStyle())
            }
            .padding(.horizontal)

            //Main Image
            WebImage(url: URL(string: post.imageUrl))
              .resizable()
              .aspectRatio(contentMode: .fit)

            //Tools bar
            HStack(spacing: 15) {
                Button(action: {
                    self.post.isLiked.toggle()
                    print(""Like btn pressed"")
                }, label: {
                    Image(systemName: post.isLiked ? ""heart.fill"" : ""heart"")
                        .font(.title)
                        .foregroundColor(.black)
                }).buttonStyle(BorderlessButtonStyle())

                Button(action: {
                    print(""Comments btn pressed"")
                }, label: {
                    Image(systemName: ""message"")
                        .font(.title)
                        .foregroundColor(.black)
                }).buttonStyle(BorderlessButtonStyle())

                Button(action: {
                    print(""Share btn pressed"")
                }, label: {
                    Image(systemName: ""paperplane"")
                        .font(.title)
                        .foregroundColor(.black)
                }).buttonStyle(BorderlessButtonStyle())

                Spacer()

                Button(action: {
                    print(""Bookmark btn pressed"")
                }, label: {
                    Image(systemName: ""bookmark"")
                        .font(.title)
                        .foregroundColor(.black)
                }).buttonStyle(BorderlessButtonStyle())
            }.padding(8)

            Text(""Liked by \(post.numberOfLikes) users"")
                .font(.headline)
                .padding(.horizontal, 8)

            Text(post.postDescription)
                .font(.body)
                .padding(.horizontal, 8)
                .padding(.vertical, 5)

            Button(action: {
                print(""Show comments btn pressed"")
            }, label: {
                Text(""See all \(post.numberOfComments) comments"")
                    .foregroundColor(.gray)
                    .padding(.horizontal, 8)
            }).buttonStyle(BorderlessButtonStyle())

            Text(post.datePostedString)
                .font(.caption)
                .foregroundColor(.gray)
                .padding(.horizontal, 8)
                .padding(.vertical, 5)
        }
    }
}
</code></pre>

<p><strong>Post</strong>:</p>

<pre><code>struct Post : Identifiable, Hashable {
    var id: String
    var imageUrl: String
    var authorUsername: String
    var authorProfilePictureUrl: String
    var postLocation: String
    var postDescription: String
    var numberOfLikes: Int
    var numberOfComments: Int
    var datePostedString: String

    var isLiked: Bool

    init(id: String, imageUrl: String, authorUsername: String, authorProfilePictureUrl: String, postLocation: String, postDescription : String, numberOfLikes: Int, numberOfComments: Int, datePosted: Date, isLiked: Bool) {
        self.id = id
        self.imageUrl = imageUrl
        self.authorUsername = authorUsername
        self.authorProfilePictureUrl = authorProfilePictureUrl
        self.postLocation = postLocation
        self.postDescription = postDescription
        self.numberOfLikes = numberOfLikes
        self.numberOfComments = numberOfComments

        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = ""MMMM dd, yyyy""
        self.datePostedString = dateFormatter.string(from: datePosted)

        self.isLiked = isLiked
    }
}
</code></pre>

<p>Thank you!</p>
","8421180","","8421180","","2020-03-18 15:04:02","2020-03-18 23:46:54","View doesn't get updated when using ObservableObject","<ios><swift><iphone><swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"60780725","1","60785254","","2020-03-20 19:46:23","","3","1134","<p>I am trying to use the iOS 13 Combine framework in conjunction with some UIKit controls. I want to set up a viewcontroller that contains a switch that enables/disables a button whenever the switch is toggled on/off. According to Apple's documentation, UIKit controls have built-in support for Combine publishers, etc. so this should be possible.</p>

<p>I have a viewcontroller that contains a UISwitch and a UIButton, as shown here:</p>

<p><a href=""https://i.stack.imgur.com/Mf4qG.png"" rel=""nofollow noreferrer"">link to screenshot of my viewcontroller</a></p>

<p>and here is my code:</p>

<pre class=""lang-swift prettyprint-override""><code>import Combine
import UIKit

class ViewController: UIViewController {

    @IBOutlet weak var mySwitch: UISwitch!
    @IBOutlet weak var myButton: UIButton!

    var myCancellable: AnyCancellable?

    override func viewDidLoad() {
        super.viewDidLoad()

        mySwitch.isOn = true // Set initial state of switch

        myButton.setTitle(""Enabled"", for: .normal)
        myButton.setTitle(""Disabled"", for: .disabled)

        myCancellable = mySwitch.publisher(for: \.isOn)
                                .subscribe(on: RunLoop.main)
                                .assign(to: \.isEnabled, on: myButton)
    }
}
</code></pre>

<p>The above code should (or so I thought) emit the value of the switch's <code>.isOn</code> property, whenever that property changes, and assign the value to the button's <code>.isEnabled</code> property. If it is running the way I would expect, that means that when the switch is toggled ON the button title should read ""Enabled"" and the button should be enabled. When the UISwitch is toggled OFF, then the button title should read ""Disabled"" and the button should be disabled.</p>

<p>But it does not behave the way I am expecting. The value from the switch's publisher is only emitted once, when the publisher is first set up inside <code>viewDidLoad()</code>. When tapping on the switch to toggle it on or off, it never emits a value ever again. I can tell it is at least emitting the value once, because if I change the initial state of the switch to either on or off, the button is set to the expected state when the viewcontroller is loaded.</p>

<p>Typically you are supposed to keep a strong reference to the publisher, or else the publisher/subscriber will be terminated immediately, so that's why I am holding a reference with the <code>myCancellable</code> variable. But this does not fix the issue, the values are still not emitted when tapping on the switch.</p>

<p>Does anyone have any ideas on how to fix this?  This seems like it should be a simple ""Hello World"" type of example using Combine, and I don't know what I am missing here.</p>
","9196483","","","","","2020-03-21 07:08:13","iOS Combine Framework - Publisher Only Publishes Once and Then Never Again","<ios><swift><reactive-programming><combine>","1","0","1","","","CC BY-SA 4.0"
"60781658","1","60782044","","2020-03-20 21:09:20","","0","51","<p>so I have this file which gets a JSON array from an api endpoint, then is supposed to assign it to an observable object variable so it can be retrieved and iterated through in a foreach loop. I'm still really new to Swift but it looks as so;</p>

<pre><code>import SwiftUI
import Combine
import Foundation

public struct ActivityModel: Codable {
    public let id: Int
    public let name: String
    public let activity_desc: String?
}


public struct ActivitiesModel2: Codable {
    public let location: String
    public let popular: [String:ActivityModel]
}

public struct ActivitiesModel: Codable {
    public let activities: ActivitiesModel2
}

public class ActivityFetcher: ObservableObject {
    var activities: [ActivitiesModel]()

    init(){
        guard let url = URL(string: ""http://mywebsite.com/api/loadapi"") else { return }

        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = ""POST""

        URLSession.shared.dataTask(with: urlRequest) { (data, response, error) in

            do {
                if let d = data {
                    let decodedLists = try JSONDecoder().decode(ActivitiesModel.self, from: d)
                    DispatchQueue.main.async {
                        self.activities = [decodedLists]
                    }
                    print(self.activities)
                    print(decodedLists)
                } else {
                    print(""No Data"")
                }
            } catch {
                print(""Error"")
            }

        }.resume()
    }
}
</code></pre>

<p>The code works fine up to the point where I try to equate self.activities to decodedLists, because while printing decodedLists returns the correct array from the JSON API, printing self.activities after I define it as equal to decodedLists only returns: ""[]"". Why it returns an empty array when it is clearly defined when printing decodedLists is beyond me. I tried removing the brackets, thinking maybe it's converting a dictionary to an array and failing, but I can't remove any of the brackets without returning an error.</p>
","12422326","","","","","2020-03-20 21:48:17","Swift, issue assigning array to variable","<arrays><swift><dictionary><combine>","1","1","","","","CC BY-SA 4.0"
"60785013","1","60797035","","2020-03-21 06:16:16","","2","962","<p>I am getting an infinite loop, onReceive is called infinitely when using a protocol with @Published variable. To use @Published variable in a protocol I am using this <a href=""https://stackoverflow.com/a/58471595/5881884"">stackoverflow answer</a>. 
This line in MyImageView:</p>

<pre><code>if self.viewModel.answered {
</code></pre>

<p>seems to cause a call in </p>

<pre><code>onReceive { self.viewModel.objectWillChange
</code></pre>

<p>inside ContentView.</p>

<p>Any idea how to make this work?</p>

<p>This is the entire code:</p>

<p>EnvObject:</p>

<pre><code>import UIKit
import SwiftUI
import Combine
import Foundation

protocol MyProtocol: AnyObject {
    var answered: Bool { get set }
    var answeredPublished: Published&lt;Bool&gt; { get }
    var answeredPublisher: Published&lt;Bool&gt;.Publisher { get }
}

class GameViewModel: ObservableObject &amp; MyProtocol {

    @Published var answered = false
    var answeredPublished: Published&lt;Bool&gt; { _answered }
    var answeredPublisher: Published&lt;Bool&gt;.Publisher { $answered }

}
</code></pre>

<p>Views:</p>

<pre><code>import SwiftUI

struct MyImageView: View {
    @EnvironmentObject var viewModel: GameViewModel

    var body: some View {
        if self.viewModel.answered {
            print(""not nil"")
            return AnyView(Image(""clearImage"")
                .resizable()
                .scaledToFit()
            )
        }
        else {
            print(""nil"")
            return AnyView(
                Text(self.viewModel.answered ? ""true"" : ""false"")
            )
        }
    }
}

struct ViewBelow&lt;ViewModel: ObservableObject &amp; MyProtocol&gt;: View {
    @EnvironmentObject var viewModel: ViewModel

    var body: some View {
        Text(""below"")
        .onReceive(self.viewModel.objectWillChange,

           perform: { _ in
               print(""onReceive target"")
           }
        )
    }
}


struct ContentView: View {
    @EnvironmentObject var viewModel: GameViewModel
    var body: some View {
        GeometryReader {
            geo in
            VStack {
                MyImageView()

                ViewBelow&lt;GameViewModel&gt;()
            }
        }
    }
}
</code></pre>

<p>SceneDelegate
    import UIKit
    import SwiftUI</p>

<pre><code>class SceneDelegate: UIResponder, UIWindowSceneDelegate {
    var window: UIWindow?
    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {

        let contentView = ContentView().environmentObject(GameViewModel())

        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(rootView: contentView)
            self.window = window
            window.makeKeyAndVisible()
        }
    }
}
</code></pre>
","5881884","","5881884","","2020-03-21 16:45:36","2020-03-22 07:51:36","onReceive called infinitely in swiftUI","<swift><swiftui>","1","4","","","","CC BY-SA 4.0"
"60792028","1","60792635","","2020-03-21 18:56:57","","0","52","<p>For an instance as below example JSON data, I want to keep the object which has content &amp; video property, and ignore the ones doesn't have them. Objects like 2nd, 3rd with only address and error property should be ignored.</p>

<p><strong>/ / JSON data example</strong></p>

<pre><code>[
  {
    ""content"": ""asdhh"",
    ""url"": ""dasddd"",
    ""country"": ""kkjkkj"",
    ""address"": ""aksjdkasjd""
  },
  {
    ""address"": ""aabbccdd""
  },
  {
    ""error"": ""error description""
  }
]
</code></pre>

<p>I try to use <code>if video.content != nil &amp;&amp; video.url != nil</code> to control the displaying of VideoListRow in ForEach loop. But it turns out that I couldn't call the video.property in the ForEach closure. So how could I ignore the unwanted parsed back data and only show the wanted object, in this case only the first object was wanted. </p>

<pre><code>var body: some View {
        List {
            ForEach(self.model.videos) { video in
                if video.content != nil &amp;&amp; video.url != nil {
                  VStack(spacing: 0) {
                      VideoListRow(video: url)
                  }
                }
            }
        }.onAppear() {
            self.model.getVideoBundle()
        }
    }
</code></pre>

<p><strong>// Change my code to add filter:</strong>
The minor modification is to use <code>||</code> but not <code>&amp;&amp;</code>. Because I want to keep the object, which has only one of content and url, that one is valid. Only if it doesn't include two of them, then ignore it.</p>

<pre><code>ForEach(
    self.model.videos.filter { (video) -&gt; Bool in
        video.content != nil || video.url != nil
    }
) { video in
    VStack(spacing: 0) {
        VideoListRow(video: url)
    }
}
</code></pre>
","10158398","","10158398","","2020-03-22 02:25:56","2020-03-22 02:25:56","How to ignore some objects in JSON parsed back data?","<json><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"60795062","1","60805267","","2020-03-22 01:26:55","","-1","294","<p>I just implemented multiple windows in my app and am having trouble checking when a core data item was updated in the window right next to it. It seems like Apple's Combine can fix this problem by adding a subscriber to the core data item to listen for changes, but all the documentation I'm finding on Combine is with SwiftUI and I'm using UIKit. </p>

<p>Can anyone help me add a subscriber to the core data item listen for any changes to it?</p>
","8203300","","","","","2020-03-22 21:37:48","How to use Combine to tell when a Core Data object changed","<swift><xcode><core-data><combine>","1","0","1","","","CC BY-SA 4.0"
"60799509","1","60808062","","2020-03-22 12:49:02","","3","5798","<p>I don't know how to deal with errors in a Combine flow. I would like to be able to catch errors from a Combine function. </p>

<p><strong>Could anyone help in explaining what I'm doing wrong here and how I should handle <em>catching</em> an error with Combine?</strong></p>

<blockquote>
  <p>Note: The function below is just an example to illustrate a case where an error <em>could</em> be caught instead of crashing the app.</p>
</blockquote>

<pre><code>func dataFromURL&lt;T: Decodable&gt;(_ url: String, _ decoder: JSONDecoder = JSONDecoder()) -&gt; AnyPublisher&lt;T, Error&gt; {
    // 1) Example: If the URL is not well-formatted, I would like to /create/raise/return an error (in a Combine way)

    // 2) Instead of the forced unwrapping here, I would also prefer to raise a catchable error if the creation of the request fails
    let request = URLRequest(url: URL(string:url)!)

    // 3) Any kind of example dealing with potential errors, etc

    return urlSession
        .dataTaskPublisher(for: request)
        .tryMap { result -&gt; T in
            return try decoder.decode(T.self, from: result.data)
        }
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
} 

// function in another file:
func result() {
     // I would like to be able to catch or handle errors in this function

     dataFromURL(""test"").print()   

    // Example : if error 1), else if error 2) etc
}
</code></pre>

<p>As explained in the comments, I would like to be able to catch any error outside the <code>dataFromURL</code> function, but in a ""Combine way"". </p>

<p>I used a URL data fetching as an example, but it could be with anything else.</p>

<p>What is the recommended way to raise and catch errors with the Combine flow? Is it to return a Publisher with a specific error for example? If so, how can I do it?</p>

<hr>

<p><strong>EDIT</strong></p>

<p>Without Combine, I would just have thrown an error, added the <code>throws</code> keyword to the function, and would have caught the error in the <code>result</code> function. </p>

<p>But I would have expected Combine to have a simpler or more elegant way to achieve this. For example, maybe something that can be thrown at any time:</p>

<pre><code>guard &lt;url is valid&gt; else {
    return PublisherError(URLError.urlNotValid)
}
</code></pre>

<p>And could have been caught like this:</p>

<pre><code>dataFromURL
.print()
.onError { error in
   // handle error here
}
.sink { result in
    // no error
}
</code></pre>
","5120292","","814730","","2020-03-22 16:39:41","2020-03-23 04:45:58","Handling errors in Combine (Swift, iOS)","<ios><swift><combine>","1","6","2","","","CC BY-SA 4.0"
"60821502","1","60825556","","2020-03-23 21:03:01","","0","516","<p>I am trying to build an application which receives a JSON Object from an API endpoint, which then I want to list out in the view. I've watched a lot of videos on this topic, but in each video they use very simplistic JSON Objects as examples and therefore the code they write doesn't really seem to transfer over, giving me errors no matter how I try to format it. The code is as follows</p>

<pre><code>import SwiftUI
import Combine
import Foundation

public struct ActivityModel: Codable, Identifiable {
    public let id: Int
    public let name: String
    public let activity_desc: String?
}


public struct ActivitiesModel2: Codable {
    public let location: String
    public let popular: [String:ActivityModel]
}

public struct ActivitiesModel: Codable {
    public let activities: ActivitiesModel2
}

public class ActivityFetcher: ObservableObject {
    var activities: ActivitiesModel?

    init(){
        guard let url = URL(string: ""https://mywebsite.com/api/loadapi"") else { return }

        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = ""POST""

        URLSession.shared.dataTask(with: urlRequest) { (data, response, error) in

            do {
                if let d = data {
                    let decodedLists = try JSONDecoder().decode(ActivitiesModel.self, from: d)
                    DispatchQueue.main.async {
                        self.activities = decodedLists
                    }
                } else {
                    print(""No Data"")
                }
            } catch {
                print(""Error"")
            }

        }.resume()
    }
}

struct ActivityGuestView: View {
    let networkingServiceGeneral = NetworkingServiceGeneral()

    @ObservedObject var viewRouter: ViewRouter

    @ObservedObject var fetcher = ActivityFetcher()

    var body: some View {
        // This is where my issues start
        List(fetcher.activities?.activities.popular) { result in
            VStack {
                Text(result.name)
                Text(result.activity_desc)
                    .font(.system(size: 11))
                    .foregroundColor(Color.gray)
            }
        }
    }
}
</code></pre>

<p>This code, as I put it, gives me 5 errors. They are the following;</p>

<pre><code>    - Initializer 'init(_:rowContent:)' requires that '(key: String, value: ActivityModel)' conform to Identifiable
    - Initializer 'init(_:rowContent:)' requires that '[String : ActivityModel]' conform to 'RandomAccessCollection'
    -Value of optional type '[String : ActivityModel]?' must be unwrapped to a value of type '[String : ActivityModel]'
    - Coalesce using '??' to provide a default when the optional value contains 'nil'
    - Force-unwrap using '!' to abort execution if the optional value contains 'nil'
</code></pre>

<p>Some of these errors have options to fix it, but when I press fix it adds code but doesn't actually fix the error so I figured to just include them anyways. I'm still fairly new to Swift, but I know what some of it is asking, particularly the conforming to Identifiable, but it says that struct ActivitiesModel does not conform to identifiable when I try to add the tag, and the JSON Object doesn't have an ID for that section, so I can't ask the ID to make it identifiable.</p>

<p>Any help would be greatly appreciated, this has kind of been a wall right now.</p>

<p>Here's the JSON</p>

<pre><code>""activities"": {
        ""location"": ""Dallas"",
        ""popular"": {
            ""10"": {
                ""id"": 38,
                ""name"": ""Adventure Landing Dallas"",
                ""activity_desc"": ""Aquatic complex chain with additional land attractions including mini-golf, laser tag &amp; go-karts."",
            },
            ""12"": {
                ""id"": 40,
                ""name"": ""Jumpstreet"",
                ""activity_desc"": ""None provided."",
            },
        }
    }
}
</code></pre>
","6611009","","","","","2020-03-24 05:45:41","Swift ForEach Issues with JSON Dictionary","<ios><arrays><json><swift><combine>","1","3","","","","CC BY-SA 4.0"
"60831048","1","61795578","","2020-03-24 12:26:54","","1","317","<p>I am having problems finding out why my dataTask returns an empty result.
While going through My NetworkingManager class it appeared that it never enters the URLSession.shared.dataTask. Does anyone know why?</p>
<p>Her is my NetworkingManager which is being used in the ContentView of the app:</p>
<pre><code>class NetworkingManager: ObservableObject {
    var didChange = PassthroughSubject&lt;NetworkingManager, Never&gt;()
    
    var showList = ShowResultsAPI(results: []) {
        didSet {
            didChange.send(self)
        }
    }
    
    init() {
        guard let url = URL(string:  &quot;www.json.url&quot;) else {
            return }
        URLSession.shared.dataTask(with: url) { (data, _, _) in
            guard let data = data else {
                return }
            
            let showList = try! JSONDecoder().decode(ShowResultsAPI.self, from: data)

            DispatchQueue.main.async {
                self.showList = showList
            }

        }.resume()
    }
}

</code></pre>
","13115834","","13115834","","2021-10-18 07:26:41","2021-10-18 07:26:41","JSON networking request not entering URLSession.shared.dataTask","<json><swift><nsurlsessiondatatask>","3","2","","","","CC BY-SA 4.0"
"60832461","1","61008261","","2020-03-24 13:53:33","","0","340","<p>I have trouble decoding json data using SwiftUI, I have the following json.</p>

<pre><code>{
    ""data"": [
        {
            ""id"": ""project:xxxxxx"",
            ""project_manager"": {
                ""employee_id"": ""employee:xxxxxx"",
                ""id"": ""employee:xxxxxx"",
                ""person_id"": ""person: xxxxxx"",
                ""name"": ""Peter Post""
            },
            ""project_status"": {
                ""id"": ""projectstatus:xxxxxx"",
                ""label"": ""active""
            },
            ""created"": ""2019-01-08 15:39:59"",
            ""modified"": ""2019-01-24 14:39:13"",
            ""created_at"": ""2019-01-08 15:39:59"",
            ""updated_at"": ""2019-01-24 14:39:13"",
            ""url"": ""https://url.com/projects/project/view?id=000"",
...
</code></pre>

<p>I'm decoding the json with the following code</p>

<pre><code>import Foundation

struct Projects: Decodable {
    let data: [Data]
}

struct Data : Decodable, Identifiable {
    let id: String
    let url: String
    let organization: Organization?
    let project_status: ProjectStatus?
}

struct Organization : Decodable, Identifiable {
    let id: String?
    let name: String?
}

struct ProjectStatus: Decodable, Identifiable {
    let id: String?
    let label: String?
}
</code></pre>

<pre><code>import Foundation
import SwiftUI
import Combine

class NetworkingManager: ObservableObject {
    @Published var projectList = Projects(data: [])


    init() {  
        var request = URLRequest(url: URL(string: ""https://api-url/projects"")!,timeoutInterval: Double.infinity)
        request.addValue(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"", forHTTPHeaderField: ""Authentication-Key"")
        request.addValue(""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"", forHTTPHeaderField: ""Authentication-Secret"")

        URLSession.shared.dataTask(with: request) { (data, _, _) in
            guard let data = data else { return }

            let projectList = try! JSONDecoder().decode(Projects.self, from: data)

            DispatchQueue.main.async {
                self.projectList = projectList
                print(self.projectList)
            }
        }.resume()
    }
}
</code></pre>

<pre><code>import SwiftUI

struct ContentView : View {
    @ObservedObject var networkingManager = NetworkingManager()

    var body: some View {
        VStack {
            List(networkingManager.projectList.data, id: \.id) { project in
                HStack {
                    Text(project.id)
                    Text(project.url)

                }

            }
        }
    }
}

struct ContentView_Previews : PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>

<p>This results in a list of id and url string values but my question is: How can I list multiple levels of the json files. Do I have to decode each level of the json I want to use or is there a better way?</p>
","4814721","","4814721","","2020-03-24 14:12:30","2020-04-03 08:55:10","Decode multiple layers of a nested JSON with Swift","<json><swift>","1","0","","","","CC BY-SA 4.0"
"60832875","1","60833041","","2020-03-24 14:16:21","","0","202","<p>Is there any handy way to convert <code>Binding&lt;Error?&gt;</code> to <code>Binding&lt;Bool&gt;</code>? I'm having view model that has one of the property <code>@published var error: Error?</code>. I would like to show an alert if there is an error. But <code>Alert</code> accepts only <code>Binding&lt;Bool&gt;</code> as a parameter.</p>

<p>I was able to accomplish this by using introducing another property but this seems to me like not the most efficient way.</p>

<p>Code with the additional property</p>

<pre><code>class SampleViewModel: ObservableObject {

    @Published
    var error: Error? {
        didSet {
            isError = error != nil
        }
    }

    @Published
    var isError: Bool = false
}

struct SampleView: View {
    @ObservedObject
    var viewModel: SampleViewModel

    var body: some View {
        EmptyView().alert(isPresented: $viewModel.isError) { () -&gt; Alert in
            Alert(title: Text(""Error""), message: Text(viewModel.error!.localizedDescription), dismissButton: .default(Text(""OK"")))
        }
    }
}
</code></pre>
","1401983","","","","","2020-03-24 14:25:36","How to convert Binding<Error?> to Binding<Bool>","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"60844286","1","60851629","","2020-03-25 07:09:01","","1","955","<p>I am combining two publishers to determine what the center coordinate of a map view should be. The two publishers are:</p>

<ol>
<li>The user's initial location determined by a <code>CLLocationManager</code> (the first location reported once the <code>CLLocationManager</code> begins sending location updates).</li>
<li>The user's current location if the ""center map on current location"" button is tapped.</li>
</ol>

<p>In code:</p>

<pre><code>    class LocationManager: NSObject, ObservableObject {

        // The first location reported by the CLLocationManager.
        @Published var initialUserCoordinate: CLLocationCoordinate2D?
        // The latest location reported by the CLLocationManager.
        @Published var currentUserCoordinate: CLLocationCoordinate2D?
        // What the current map view center should be.
        @Published var coordinate: CLLocationCoordinate2D = CLLocationCoordinate2D(latitude: 42.35843, longitude: -71.05977) // Default coordinate.

        // A subject whose `send(_:)` method is being called elsewhere every time the user presses a button to center the map on the user's location.
        var centerButtonTappedPublisher: PassthroughSubject&lt;Bool, Never&gt; = PassthroughSubject&lt;Bool, Never&gt;()

        // The combined publisher that is where all my troubles lie.
        var coordinatePublisher: AnyPublisher&lt;CLLocationCoordinate2D, Never&gt; {
            Publishers.CombineLatest($initialUserCoordinate, centerButtonTappedPublisher)
                .map { initialCoord, centerButtonTapped in
                    var latestCoord = initialCoord
                    if centerButtonTapped {
                        latestCoord = self.currentUserCoordinate
                    }
                    return latestCoord
                }
                .replaceNil(with: CLLocationCoordinate2D(latitude: 42.35843, longitude: -71.05977))
                .eraseToAnyPublisher()
        }

        private var cancellableSet: Set&lt;AnyCancellable&gt; = []

        //... Other irrelevant properties

        private override init() {
            super.init()

            coordinatePublisher
                .receive(on: RunLoop.main)
                .assign(to: \.coordinate, on: self)
                .store(in: &amp;cancellableSet)

            //... CLLocationManager set-up
        }
    }

    extension LocationManager: CLLocationManagerDelegate {

        //...

        func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
            // We are only interested in the user's most recent location.
            guard let location = locations.last else { return }
            let latestCoord = location.coordinate
            if initialUserCoordinate == nil {
                initialUserCoordinate = latestCoord
            }
            currentUserCoordinate = latestCoord
        }

        //...

    }
</code></pre>

<p>Both publishers, <code>$initialUserCoordinate</code> and <code>centerButtonTappedPublisher</code>, publish updates - I have confirmed this. However, the combined publisher <code>coordinatePublisher</code> only fires when the ""center map on current location"" button is tapped. It never fires when the <code>initialUserCoordinate</code> property is first set.</p>

<p><a href=""https://stackoverflow.com/questions/56910228/swift-combine-subsequent-publisher-that-consumes-other-publishers-using-combin"">This question</a> suggests adding a <code>.receive(on: RunLoop.main)</code> after the <code>Publishers.CombineLatest($initialUserCoordinate, centerButtonTappedPublisher)</code> but this does not work for me.</p>

<p>What am I doing wrong?</p>
","4752920","","4752920","","2020-03-25 07:35:59","2020-03-25 15:09:22","Swift Combine's CombineLatest does not fire in response to an update to one of its publishers","<swift><combine><combinelatest>","1","0","","","","CC BY-SA 4.0"
"60862050","1","60881207","","2020-03-26 06:34:44","","4","1493","<p>I have a map view which has a button that, when pressed, should center the map on the user's current location. I am trying to achieve this using Swift's Combine framework. I tried solving this by adding a <code>@State</code> property called <code>mapCenter</code> and assigning to this property in Combine's <code>assign(to:on:)</code> subject, as follows:</p>

<pre><code>struct MapWithButtonView: View {

    // What the current map view center should be.
    @State var mapCenter = CLLocationCoordinate2D(latitude: 42.35843, longitude: -71.05977)

    // A subject whose `send(_:)` method is being called from within the CenterButton view to center the map on the user's location.
    private var centerButtonTappedPublisher = PassthroughSubject&lt;Bool, Never&gt;()

    // A publisher that turns a ""center button tapped"" event into a coordinate.
    private var centerButtonTappedCoordinatePublisher: AnyPublisher&lt;CLLocationCoordinate2D?, Never&gt; {
        centerButtonTappedPublisher
            .map { _ in LocationManager.default.currentUserCoordinate }
            .eraseToAnyPublisher()
    }

    private var coordinatePublisher: AnyPublisher&lt;CLLocationCoordinate2D, Never&gt; {
        Publishers.Merge(LocationManager.default.$initialUserCoordinate, centerButtonTappedCoordinatePublisher)
            .replaceNil(with: CLLocationCoordinate2D(latitude: 42.35843, longitude: -71.05977))
            .eraseToAnyPublisher()
    }

    private var cancellableSet: Set&lt;AnyCancellable&gt; = []

    init() {
        // This does not result in an update to the view... why not?
        coordinatePublisher
            .receive(on: RunLoop.main)
            .handleEvents(receiveSubscription: { (subscription) in
                    print(""Receive subscription"")
                }, receiveOutput: { output in
                    print(""Received output: \(String(describing: output))"")
                }, receiveCompletion: { _ in
                    print(""Receive completion"")
                }, receiveCancel: {
                    print(""Receive cancel"")
                }, receiveRequest: { demand in
                    print(""Receive request: \(demand)"")
                })
            .assign(to: \.mapCenter, on: self)
            .store(in: &amp;cancellableSet)
    }

    var body: some View {
        ZStack {
            MapView(coordinate: mapCenter)
                .edgesIgnoringSafeArea(.all)

            CenterButton(buttonTappedPublisher: centerButtonTappedPublisher)
        }
    }
}
</code></pre>

<p>The <code>MapView</code> is a <code>UIViewRepresentable</code> view and looks like this:</p>

<pre><code>struct MapView: UIViewRepresentable {
    // The center of the map.
    var coordinate: CLLocationCoordinate2D

    func makeUIView(context: Context) -&gt; MKMapView {
        let mapView = MKMapView(frame: .zero)
        mapView.showsUserLocation = true
        return mapView
    }

    func updateUIView(_ view: MKMapView, context: Context) {
        let span = MKCoordinateSpan(latitudeDelta: 0.02, longitudeDelta: 0.02)
        let region = MKCoordinateRegion(center: coordinate, span: span)
        view.setRegion(region, animated: true)
    }
}
</code></pre>

<p>The <code>CenterButton</code> is a simple button that looks like this:</p>

<pre><code>struct CenterButton: View {
    var buttonTappedPublisher: PassthroughSubject&lt;Bool, Never&gt;

    var body: some View {
        Button(action: {
            self.buttonTappedPublisher.send(true)
        }) {
            Image(systemName: ""location.fill"")
                .imageScale(.large)
                .accessibility(label: Text(""Center map""))
        }
    }
}
</code></pre>

<p>And the <code>LocationManager</code> is an <code>ObservableObject</code> which publishes the user's current and initial location:</p>

<pre><code>class LocationManager: NSObject, ObservableObject {

    // The first location reported by the CLLocationManager.
    @Published var initialUserCoordinate: CLLocationCoordinate2D?
    // The latest location reported by the CLLocationManager.
    @Published var currentUserCoordinate: CLLocationCoordinate2D?

    private let locationManager = CLLocationManager()

    static let `default` = LocationManager()

    private override init() {
        super.init()

        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.pausesLocationUpdatesAutomatically = true
        locationManager.activityType = .other
        locationManager.requestWhenInUseAuthorization()
    }
}

extension LocationManager: CLLocationManagerDelegate {

    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        switch status {
        case .authorizedAlways, .authorizedWhenInUse:
            NSLog(""Location authorization status changed to '\(status == .authorizedAlways ? ""authorizedAlways"" : ""authorizedWhenInUse"")'"")
            enableLocationServices()
        case .denied, .restricted:
            NSLog(""Location authorization status changed to '\(status == .denied ? ""denied"" : ""restricted"")'"")
            disableLocationServices()
        case .notDetermined:
            NSLog(""Location authorization status changed to 'notDetermined'"")
        default:
            NSLog(""Location authorization status changed to unknown status '\(status)'"")
        }
    }

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        // We are only interested in the user's most recent location.
        guard let location = locations.last else { return }
        // Use the location to update the location manager's published state.
        let coordinate = location.coordinate
        if initialUserCoordinate == nil {
            initialUserCoordinate = coordinate
        }
        currentUserCoordinate = coordinate
    }

    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        NSLog(""Location manager failed with error: \(error)"")
    }

    // MARK: Helpers.

    private func enableLocationServices() {
        locationManager.startUpdatingLocation()
    }

    private func disableLocationServices() {
        locationManager.stopUpdatingLocation()
    }
}
</code></pre>

<p>Unfortunately, the above does not work. The view is never updated when the <code>CenterButton</code> is tapped. I ended up solving this problem by using an <code>ObservableObject</code> view model object with a <code>@Published var mapCenter</code> property, however I don't know why my initial solution using <code>@State</code> does not work. What is wrong with updating <code>@State</code> as I have done above?</p>

<p>Note that if trying to reproduce this, you will need to add the <code>NSLocationWhenInUseUsageDescription</code> key with a value such as ""This app needs access to your location"" in your <code>Info.plist</code> file in order to be able to grant location permissions.</p>
","4752920","","4752920","","2020-03-27 22:32:31","2020-09-24 11:35:35","Assigning to @State in Combine's `assign(to:on:)` subject does not result in view update","<swift><swiftui><combine><swiftui-state>","3","5","","","","CC BY-SA 4.0"
"60869404","1","60875639","","2020-03-26 14:22:08","","2","886","<p>I am trying to make an HTTP GET request using Combine to the <a href=""https://myLink.com"" rel=""nofollow noreferrer"">https://myLink.com</a> URL (this is a fake URL, the one that I use is a real API link and it works, but I can't post it), but when I call the function I get the following error:</p>

<p>Task &lt;18F5A03A-96DF-4309-B263-B6B0CB275779>.&lt;1> finished with error [-999] Error Domain=NSURLErrorDomain Code=-999 ""cancelled"" UserInfo={NSErrorFailingURLStringKey=<a href=""https://myLink.com"" rel=""nofollow noreferrer"">https://myLink.com</a>, NSLocalizedDescription=cancelled, NSErrorFailingURLKey=<a href=""https://myLink.com"" rel=""nofollow noreferrer"">https://myLink.com</a>}</p>

<p>Here is my code:</p>

<pre><code>import SwiftUI
import Foundation
import Combine

struct ContentView: View {
   var body: some View {
      Button(action: {
         loadPatients()
      })
      {
         Text(""Load Patients"")
      }
   }
}

//MARK: - Your object to retrieve from JSON
struct Doctor: Codable, Identifiable {
  let id = UUID()
  let patients: [Patients]
}

struct Patients: Codable {
  let id: String
  let name: String
  let phone: String
}

class Network {

  // Handle your request errors
  enum Error: LocalizedError {
    case invalidResponse
    case addressUnreachable(URL)

    var errorDescription: String? {
      switch self {
      case .invalidResponse:
        return ""The server responded with garbage.""
      case .addressUnreachable(let url):
        return ""\(url.absoluteString) is unreachable.""
      }
    }
  }

  // Add your url
  let urlRequest = URL(string: ""https://coronavirus-med.herokuapp.com/api/v1/doctor/getPatients/bogdand"")!

  // Networking on concurrent queue
  let networkQueue = DispatchQueue(label: ""Networking"",
                                   qos: .default,
                                   attributes: .concurrent)

  // Combine network call (This replace your previous code)
  func downloadPatients() -&gt; AnyPublisher&lt;Doctor, Error&gt; {
    URLSession.shared
      .dataTaskPublisher(for: urlRequest)
      .receive(on: networkQueue)
      .map(\.data)
      .decode(type: Doctor.self, decoder: JSONDecoder())
      .mapError { (error) -&gt; Network.Error in
        switch error {
        case is URLError:
          return Error.addressUnreachable(self.urlRequest)
        default:
          return Error.invalidResponse
        }
    }
    .eraseToAnyPublisher()
  }
}

let networkRequest = Network()

//MARK: - Call this function where you want to make your call
func loadPatients() {
  _ = networkRequest.downloadPatients()
    .sink(
      receiveCompletion: {
        print(""Received Completion: \($0)"") },
      receiveValue: { doctor in
        // doctor is your response and [0].name is your first patient name
        print(doctor.patients[0].name) }
  )
}
</code></pre>

<p>I found another question on StackOverflow addressing this error, but the answer just says what the error means, but not how to solve it. They said that it means that a request is made before another one is finished, but I don't make any requests before this one, I even tried to run this in a new empty project but it still gives me the same error.</p>

<p>I was on iOS 13.2 and Xcode 11.2 and I updated to iOS 13.4 and Xcode 11.4, still the same error.</p>

<p>This is the JSON response:</p>

<pre><code>{
    ""code"": 200,
    ""status"": ""success"",
    ""patients"": [
        {
            ""_id"": ""5e77c7bbc7cbd30024f3eadb"",
            ""name"": ""Bogdan Patient"",
            ""username"": ""bogdanp"",
            ""phone"": ""0732958473""
        },
        {
            ""_id"": ""5e77c982a2736a0024e895fa"",
            ""name"": ""Robert Patient"",
            ""username"": ""robertp"",
            ""phone"": ""0739284756""
        }
    ]
}
</code></pre>
","11508444","","11508444","","2020-03-26 21:55:06","2020-03-26 21:55:06","""Task finished with error [-999]"" in SwiftUI","<ios><swift><httprequest><swiftui>","1","0","","","","CC BY-SA 4.0"
"60872783","1","61084310","","2020-03-26 17:21:50","","0","82","<p>I have an app that's using the <code>.colorInvert()</code> modifier on a SwiftUI Image that was working as intended on iOS 13.3.1 and prior, but results in a crash on iOS 13.4. The only console error displayed is: </p>

<pre><code>“precondition failure: type check failed: 104, expected Image, got _ColorInvertEffect”
</code></pre>

<p>It still runs as intended (with no crash) on simulator and devices running iOS 13.1 - 13.3.1</p>

<p>Except of code below:</p>

<pre><code>import SwiftUI
import Combine
import RealmSwift

struct ReleaseDetailView: View {
    @State private var witnessSignatureImage: Image?
    ...

    var release: ModelRelease

var body: some View {
Form {
...
Section(header: Text(""WITNESS"")) {
                    Text(""Name: \(release.witnessFirstName) \(release.witnessLastName)"")
                    if witnessSignatureImage != nil {
                        if colorScheme == .dark {
                            witnessSignatureImage?
                                .resizable()
                                .scaledToFit()
                                .colorInvert()
                        } else {
                            witnessSignatureImage?
                                .resizable()
                                .scaledToFit()
                        }
                    } else {
                        Text(""Witness signature not found."")
                            .foregroundColor(Color.red)
                    }
                } .onAppear(perform: self.loadWitnessSignatureImage)
            }
...
    func loadWitnessSignatureImage() {
        guard let witnessSignatureData = release.witnessSignature?.storedData() else {
            return
        }

        let img = UIImage(data: witnessSignatureData)
        witnessSignatureImage = Image(uiImage: img!)
    }
}
</code></pre>
","13068471","","13068471","","2020-03-27 00:00:27","2020-04-07 16:03:17","""precondition failure: type check failed: 104, expected Image, got _ColorInvertEffect"" with .colorInvert() in SwiftUI on iOS 13.4","<swift><xcode><swiftui>","1","2","","","","CC BY-SA 4.0"
"60887833","1","60888143","","2020-03-27 14:17:33","","2","61","<p>In DoctorHomePage I have a grouped list and above the list I want to add a text view, but the text view doesn't show only if I change the font to a bigger one, but it is too big and I want it smaller. Here is my code:</p>

<pre><code>import SwiftUI
import Combine

struct DoctorHomePage: View {

    @Binding var shouldPopToRootView : Bool

    @State private var curent: Int? = nil
    @State private var isActive: Bool = false
    @State private var id = 0
    let defaults = UserDefaults.standard
    let networkRequest = Network()
    @State var cancelable: AnyCancellable? = nil
    @State var localPatients : [Patients] = []

    var body: some View {
        NavigationView {
            VStack {
                NavigationLink(destination: ContentView(), tag: 1, selection: $curent) {
                    EmptyView()
                }
                Text(""Welcome, doctor!"") // this is the text that I want to add
                .font(.system(size: 30)).fontWeight(.ultraLight)
                .padding(.top, 50)
                // PATIENT LIST
                List(localPatients) { patient in
                    VStack(alignment: .leading) {
                        Text(patient.name)
                    }
                }.listStyle(GroupedListStyle())
                    .onAppear(perform: {
                    self.loadPatients()
                    connCode = self.defaults.integer(forKey: ""doctorID"")
                    self.id = connCode
                })

            }.edgesIgnoringSafeArea([.top, .bottom])
        }.navigationBarBackButtonHidden(true)
        .navigationBarHidden(true)
    }
}
</code></pre>

<p>Here are some screen shots to help you understand the problem:
<a href=""https://i.stack.imgur.com/VIjfQ.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/VIjfQ.jpg"" alt=""enter image description here""></a></p>

<p>The first image is with no text view.</p>

<p>The second image is with the font size of 60.</p>

<p>The third image is with the font size of 30.</p>
","11508444","","","","","2020-03-27 14:34:23","Text view in SwiftUI doesn't show only with bigger font","<ios><swift><text><textview><swiftui>","1","0","","","","CC BY-SA 4.0"
"60888539","1","60888871","","2020-03-27 14:57:54","","1","813","<p>In the following Playground example, the UI updates with the current date correctly, however when navigating away from the page and coming back the timer does not resume ticking:</p>

<pre><code>  import SwiftUI
  import PlaygroundSupport

  struct MainTabView: View {
    let timer = Timer.publish(every: 1, on: .main, in: .common)

    @State var time = Date()

    var body: some View {
        TabView {
            VStack {
                Text(""\(time)"").onReceive(self.timer) { self.time = $0 }
            }
            .onAppear { _ = self.timer.connect() }
            .tabItem {
                Text(""Page 1"")
            }

            Text(""Page 2"").tabItem {
                Text(""Page 2"")
            }

            Text(""Page 3"").tabItem {
                Text(""Page 3"")
            }
        }
    }
}

PlaygroundPage.current.setLiveView(MainTabView())
</code></pre>

<p>How do I have the timer start updating again when the page starts showing? </p>

<p>I have seen solutions that involve wrapping the Timer in another class, but nothing that can be done in the View.</p>

<p>I thought calling in <code>connect()</code>  in <code>onAppear {}</code> would do it.</p>
","24391","","","","","2020-03-27 15:17:15","How do I resume a published timer in SwiftUI after navigating to a different page?","<swift><timer><swiftui><combine><publisher>","2","0","","","","CC BY-SA 4.0"
"60895845","1","60898132","","2020-03-28 00:22:40","","0","60","<p>I am looking for a way to write swift code faster. SO I am wondering if there is i can combine </p>

<pre><code>    grassColor.backgroundColor
</code></pre>

<p>Into into something like </p>

<pre><code>   let combine = grassColor.backgroundColor
</code></pre>

<p>So I could code this instead of have to type grassColor.backgroundColor = .red every time. </p>

<pre><code>@objc func fanColorRed(){
    combine = .red

}

@objc func fanColorBlue(){
    combine = .blue
 }
@objc func fanColorYellow(){
    combine = .yellow

 }
@objc func fanColorOrange(){
    combine = .orange

 }
</code></pre>
","","user13124361","","","","2020-03-28 06:49:19","combine imageview and background image into one string","<swift><dictionary><object><var><combine>","1","0","","","","CC BY-SA 4.0"
"60900554","1","60900635","","2020-03-28 11:30:01","","20","10029","<p>In Swift you can define default values on a struct that can be overwritten on initialization:</p>

<pre class=""lang-swift prettyprint-override""><code>struct myStruct {
    var a: Int = 1
}
var instance1 = myStruct() // instance1.a -&gt; 1 
var instance2 = myStruct(a: 10) // instance2.a -&gt; 10
</code></pre>

<p>However when I try to apply this to Bindings in a SwiftUI view I get an error:</p>

<pre class=""lang-swift prettyprint-override""><code>struct MyView: View {
    @Binding var a: Bool = Binding.constant(true)
    var body: some View {
        Text(""MyView"")
    }
}
</code></pre>

<pre><code>Argument labels '(wrappedValue:)' do not match any available overloads
</code></pre>

<p>I want to create a view which by default uses a constant boolean value but that can be overwritten by a ""real"" Binding:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ContainerView: View {
    @State var hasSet = false
    var body: some View {
        Group {
            MyView(a: $hasSet)
            MyView() // should be equivalent to MyView(a: .constant(true))
        }
    }
}
</code></pre>

<p>Is it possible to define such a default value for a Binding in SwiftUI?</p>
","6482408","","","","","2022-04-15 08:59:48","SwiftUI Binding default value (Argument labels '(wrappedValue:)' do not match any available overloads)","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"60903039","1","60906250","","2020-03-28 15:51:29","","1","402","<p>I want to create a method <code>authenticate</code> which, using Combine, allows the user to login with my API.</p>

<p>I am trying to add now a precondition, so that if the provided username is empty, my method does not touch the network. I want to make an early exist at this point, providing an error back to the Subscriber.</p>

<p>Please find below an snippet of my code. How could I return an error from the early exist in line 4?</p>

<pre><code>func authenticate(username: String, password: String) -&gt; AnyPublisher&lt;User, Error&gt; {

        guard !username.isEmpty else {
            // How to return an error to the subscribers from here?????
            return
        }

        let parameters: [String: Any] = [
            ""username"": username,
            ""password"": password
        ]

        var request = URLRequest(endpoint: Endpoint.login)
        request.addValue(""application/json"", forHTTPHeaderField: ""Content-Type"")
        request.httpBody = try? JSONSerialization.data(withJSONObject: parameters, options: [])

        return URLSession.shared.dataTaskPublisher(for: request)
            .map { $0.data }
            .decode(type: AuthenticationResult.self, decoder: JSONDecoder())
            .map { $0.user }
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }
</code></pre>
","3750435","","","","","2020-03-28 19:56:53","Combine: how to early exit with error from a guard precondition","<ios><swift><combine>","1","1","","","","CC BY-SA 4.0"
"60904627","1","60904659","","2020-03-28 17:49:46","","1","1706","<p>I am trying to make the navigation bar transparent using init(), but I get the error ""Return from initializer without initializing all stored properties"" and I don't know how to solve it. Here is my code:</p>

<pre><code>import SwiftUI

struct DoctorHomePage: View {

    @Binding var shouldPopToRootView : Bool
    @State var hiddingNavBar = true
    @State private var curent: Int? = nil
    @State private var profileSegue: Int? = nil
    @State private var isActive: Bool = false
    let defaults = UserDefaults.standard
    let networkRequest = Network()
    @State var cancelable: AnyCancellable? = nil
    @State var localPatients : [Patients] = []
    @Environment(\.colorScheme) var colorScheme: ColorScheme
    @State private var isShowing = false

    init() {
        UINavigationBar.appearance().backgroundColor = .clear
        UINavigationBar.appearance().setBackgroundImage(UIImage(), for: .default)
    } // I get the error here

    var body: some View {
        NavigationView {
            VStack {
               Text(""Hello, World!"")
            }
        }
    }
}
</code></pre>
","11508444","","","","","2020-03-28 17:51:50","""Return from initializer without initializing all stored properties"" error in SwiftUI","<ios><swift><swiftui><init>","1","1","","","","CC BY-SA 4.0"
"60907882","1","61880291","","2020-03-28 22:39:52","","0","782","<p>I have just updated my Xcode to 11.4 from 11.3 and my project written in SwiftUI started to behave differently. I used to call <code>toggle()</code> function for boolean values and it used to trigger <code>didSet</code> property observer, however, it is not working any more.</p>

<p>Let' say we have a <code>State</code> property called <code>isSettingOn</code>. I used to call this:</p>

<p><code>isSettingOn.toggle()</code></p>

<p>which was triggering <code>didSet</code> observer of the property. Now, only if I call this:</p>

<p><code>isSettingOn = true</code></p>

<p>it is working.</p>

<p>My projects are all based on this behaviour and now this change basically broke everything. Does anyone know if I am actually doing anything wrong here?</p>

<p><strong>Edit:</strong> </p>

<p>Demo code added:</p>

<pre><code>struct ContentView: View {

    @State var isSettingOn: Bool = true {
        didSet {
            print(""didSet isSettingOn"")
        }
    }

    var body: some View {
        Button(action: {
            self.isSettingOn = true // will trigger didSet
            self.isSettingOn.toggle() // won't trigger didSet
        }) {
            Text(""Toggle isSettingOn"")
        }
    }
}
</code></pre>
","2739567","","2739567","","2020-03-29 08:35:14","2020-05-18 22:47:33","SwiftUI toggle() function on Published values stopped triggering didSet with Swift 5.2","<swift><swiftui><combine><swift5.2><xcode11.4>","1","5","","","","CC BY-SA 4.0"
"60919082","1","60920017","","2020-03-29 18:42:20","","1","499","<p>I have backend API /search?q=New Je which is return list of JSON cities</p>

<ul>
<li>""city"": ""New Jersey""</li>
<li>""city"": ""New Jenny Lind""</li>
<li>""city"": ""New Jerusalem""</li>
<li>...</li>
</ul>

<p>I have a class </p>

<pre><code>final class LocationStore: ObservableObject{
     @Published var List : [LocationModel] = []
     func search(q: String) {
         call backend search API and assign to List
     }

}
</code></pre>

<p>and I have search TextField in my view.</p>

<p>How to call search api and assign to my list when user type in search TextField. Need to show dropdown after type 3 character in TextField </p>
","6029177","","","","","2020-03-29 19:59:49","SwiftUI combine search text","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"60926829","1","60935207","","2020-03-30 08:40:32","","0","279","<p>I have the following class, I want to test that if an object subscribed to ""elapsedTime"" published property, it will receive updates whenever the property changes.</p>

<pre><code>class SampleSegmentTimer {
    @Published var elapsedTime: DateComponents?
    private var subs = Set&lt;AnyCancellable&gt;()

    func start(tickingEvery interval: TimeInterval = 1) {
        Timer.publish(every: interval, on: .main, in: .common)
            .autoconnect()
            .map(transform)
            .assign(to: \.elapsedTime, on: self)
            .store(in: &amp;subs)
    }

    private func transform(_ date: Date) -&gt; DateComponents {
        // do some calculation
        DateComponents()
    }
}
</code></pre>

<p>I want to write test like the following:</p>

<pre><code>func testStart() {
        // Given
        let segmentTimer = SampleSegmentTimer()
        var elapsedTimes = [DateComponents?]()
        let elapsedTimeSub = segmentTimer.$elapsedTime.sink { elapsedTimes.append($0) }

        // When
        segmentTimer.start(tickEvery: 1) // I want to wait 3 seconds to let it tick 3 times

        // Then
        XCTAssertEqual(elapsedTimes.count, 3)
}
</code></pre>
","5929027","","5929027","","2020-03-30 10:57:17","2020-03-30 16:37:35","Is there a way to a @Published property that it's actually getting updated and publishing?","<swift><unit-testing><combine>","1","18","","","","CC BY-SA 4.0"
"60933304","1","60933745","","2020-03-30 14:55:04","","2","794","<p>I want to hide my <code>NavigationBar</code> while scrolling, actually It must hide automatically but when I tried with multiple views It doesn't work. Also, It works when I remove custom views and capsulate <code>List</code> with <code>NavigationView</code>. But I need <code>SearchBar</code> and <code>StatusView</code> view. Is there any suggestion? </p>

<p>By the way, I run it on the device, I use canvas here for demonstration purposes. </p>

<p>Thank you.</p>

<pre><code>var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                SearchBar(searchText: $viewModel.searchText)
                StatusView(status: $viewModel.status)
                Divider()
                List(0...viewModel.characters.results.count, id: \.self) { index in
                    if index == self.viewModel.characters.results.count {
                        LastCell(vm: self.viewModel)
                    } else {
                        ZStack {
                            NavigationLink(destination: DetailView(detail: self.viewModel.characters.results[index])) {
                                EmptyView()
                            }.hidden()
                            CharacterCell(character: self.viewModel.characters.results[index])
                        }
                    }
                }
                .navigationBarTitle(""Characters"", displayMode: .large)
            }

        }
        .onAppear {
            self.viewModel.getCharacters()
        }
    }
</code></pre>

<p><img src=""https://thumbs.gfycat.com/DelightfulSomberAnnelida-mobile.mp4"" alt=""image description""></p>
","6657192","","6657192","","2020-03-30 15:24:55","2020-08-21 19:58:05","SwiftUI NavigationBar not disappearing while scrolling","<ios><swift><uikit><swiftui><combine>","2","0","1","","","CC BY-SA 4.0"
"60934884","1","60938897","","2020-03-30 16:19:35","","0","2584","<p>I would like to update some variables with values received when handling a newly published value. For example, given:  </p>

<pre><code>class ProductViewModel: ObservableObject {
    @Published var PublishedX: Int = 0
    @Published var PublishedY: Int = 0
    @Published var PublishedProduct: Int = 0
    // ...
    init() {
        productPublisher = Publishers.CombineLatest(external.XPublisher, internal.YPublisher)
            // .assignAndContinue(\.PublishedX, \.PublishedY) // something like this
            .flatMap(MyPublishers.secretMultiplication)
            .assign(to: \.PublishedProduct, on: self)
     }
 }
</code></pre>

<p>I would like to also assign the new values of XPublisher and YPublisher to variables (PublishedX and PublishedY respectively).</p>

<p>Is there a way to set these two variables and then continue handling the event?</p>
","24391","","24391","","2020-03-30 17:41:33","2021-04-23 15:39:43","Is there a way to call assign() more than once in Swift Combine?","<swift><combine><observableobject>","2","6","","","","CC BY-SA 4.0"
"60982476","1","60984532","","2020-04-02 00:33:16","","2","284","<p>This question will probably come off as very basic, and something that probably can be found through searching, but despite my efforts of searching StackOverflow and just google I can't find any up-to-date thread or post regarding how to handle the different responses of a REST API, and, as I've found out, having an up-to-date thread is important to save trouble down the road when errors occur. So, to jump into it, I have an API endpoint on my server for logging in. It responds, as one would assume, with either two cases given login credentials;</p>

<p>If the login information succeeds, it returns this JSON Object:</p>

<pre><code>{
    ""user"": {
        ""id"": 1,
        ""type"": ""user"",
        ""name"": ""username"",
        ""api_token"": ""accesstokenhere""
    },
    ""access_token"": ""accesstokenhere""
}
</code></pre>

<p>If it doesn't succeed, it gives this response</p>

<pre><code>{
    ""message"": ""Invalid credentials""
}
</code></pre>

<p>Now I  have the login screen for my app, upon pressing ""log in"", submit the information to the server and get this response back, which is not of issue and very well documented. I have the following code so far:</p>

<pre><code>import SwiftUI
import Combine
import Foundation

public struct UserModel: Decodable {
    let id: Int
    let username: String
    let age: Int

    enum CodingKeys: String, CodingKey {
        case id = ""id""
        case username = ""name""
        case age = ""age""
    }
}

public struct UserResponse: Decodable {
    public let user: UserModel
    public let accessToken: String

    enum CodingKeys: String, CodingKey {
        case user = ""user""
        case accessToken = ""access_token""
    }
}


public class UserFetcher: ObservableObject {
    public let objectWillChange = PassthroughSubject&lt;UserFetcher,Never&gt;()

    @Published var hasFinished: Bool = false {
        didSet {
            objectWillChange.send(self)
        }
    }
    var user: UserResponse?

    @Published var incorrectLogin: Bool = false {
        didSet {
            objectWillChange.send(self)
        }
    }

    init(){
        guard let url = URL(string: ""https://mywebsite.com/api/login"") else { return }

        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = ""POST""

        URLSession.shared.dataTask(with: urlRequest) { (data, response, error) in

            do {
                if let d = data {
                    let decodedRes = try JSONDecoder().decode(UserResponse.self, from: d)
                    DispatchQueue.main.async {
                        self.user = decodedRes
                        self.hasFinished = true
                        print(""Dispatching"")
                    }
                } else {
                    print(""No Data"")
                }
            } catch {
                print(""Error"")
            }

        }.resume()
    }
}
</code></pre>

<p>I have taken this section in its entirety except for minor tweaks to fit the different object from another file I have for a similar task, albeit that it has no alternate responses and so I didn't have to handle any other types of data responses.</p>

<p>I'm still fairly new to swift, so I have basic understanding of do-try-catch syntax, but I don't how I would catch different response models or where to place them in my code to prevent any errors from happening.</p>

<p>Ideally, I would like it to toggle the incorrectLogin variable, which can be observed and trigger a popup saying incorrect login information, as all login screens do when you input incorrect credentials. If it doesn't, it should just toggle the hasFinished variable and leave incorrectLogin as false, and then I would use the user model to do all of the behind the scenes stuff.</p>

<p>Again, I'm still fairly new to swift, I'm sure there's probably security issues here or something else I'm overlooking, and please, let me know if that's the case.</p>
","6611009","","","","","2022-05-26 13:52:19","Swift - Different output based on JSON response contents","<json><swift><rest>","1","0","","","","CC BY-SA 4.0"
"60983172","1","60984945","","2020-04-02 02:04:24","","3","2165","<p>I'm struggling to learn SwiftUI and Combine syntax and am trying to understand how to create a reusable publisher that will check if a String is empty.</p>

<p>I've got a SwiftUI with 5 TextFields which using @Binding to connect them to my data model object.</p>

<pre><code>class DataWhatIsLoanPayment: ObservableObject {
    // Input
    @Published var pv = """"
    @Published var iyr = """"
    // a bunch more fields...

    // Output
    @Published var isvalidform = false
}
</code></pre>

<p>I want to enable the Calculate button once all of the fields are filled in (isEmpty == false). </p>

<p>I'm following along with <a href=""https://peterfriese.dev/swift-combine-love/"" rel=""nofollow noreferrer"">https://peterfriese.dev/swift-combine-love/</a>, and I was able to get my SwiftUI to properly enable/disable my Calculate button by creating an <code>isValidPVPublisher</code> and an <code>isValidIYRPublisher</code> and combing them in an <code>isValidFormPublisher</code>, like so:</p>

<pre><code>private var isValidPVPublisher: AnyPublisher&lt;Bool, Never&gt; {
    $pv
        .debounce(for: 0.8, scheduler: RunLoop.main)
        .removeDuplicates()
        .map { input in
            return input.isEmpty == false
        }
        .eraseToAnyPublisher()
}

private var isValidIYRPublisher: AnyPublisher&lt;Bool, Never&gt; {
    $iyr
        .debounce(for: 0.8, scheduler: RunLoop.main)
        .removeDuplicates()
        .map { input in
            return input.isEmpty == false
        }
        .eraseToAnyPublisher()
}


private var isValidFormPublisher: AnyPublisher&lt;Bool, Never&gt; {
    Publishers.CombineLatest(isValidPVPublisher, isValidIYRPublisher)
        .map { pvIsValid, iyrIsValid in
            return pvIsValid &amp;&amp; iyrIsValid
        }
        .eraseToAnyPublisher()
}

init() {        
    isValidFormPublisher
        .receive(on: RunLoop.main)
        .assign(to: \.isValidForm, on: self)
        .store(in: &amp;cancellableSet)
}
</code></pre>

<p>However, I'm going to have a lot more than 2 fields, and I'm going to have a lot of other forms in my app in which I will want to check if my fields are empty. And repeating <code>.debounce(for: 0.8, scheduler: RunLoop.main).removeDuplicates().map { input in return input.isEmpty == false }.eraseToAnyPublisher()</code> over and over again is a bad idea. </p>

<p>I want to create a reusable <code>NotEmptyPublisher</code>, or something like that, which takes a field binding, like my <code>$pv</code> and sets up the chain as show in the <code>isValidPVPublisher</code> above. So I can have something like:</p>

<pre><code>// Something like this, but I'm not sure of the syntax...
private var isValidPVPublisher = NotEmptyPublisher(field:$pv)
// instead of ...
private var isValidPVPublisher: AnyPublisher&lt;Bool, Never&gt; {
    $pv
        .debounce(for: 0.8, scheduler: RunLoop.main)
        .removeDuplicates()
        .map { input in
            return input.isEmpty == false
        }
        .eraseToAnyPublisher()
}
</code></pre>

<p>But I'm having a great deal of trouble parsing a lot of Swift syntax that I'm not familiar with and I can't seem to figure out how to do it, and every example I find on the web is just defining the publisher chain inline instead of in a reusable fashion. </p>

<p>Any help? How can I create a reusable publisher so that I don't have to repeat these inline publishers which all do the same thing?</p>
","416631","","","","","2020-04-03 22:01:46","SwiftUI and Combine, how to create a reusable publisher to check if a string is empty","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"60988047","1","60988887","","2020-04-02 09:15:08","","4","659","<p>Given a List in SwiftUI, once panning begins, updating of views in the list seems to pause until the scrolling has been stopped. Is there a way to prevent this?</p>

<p>Consider the following code:</p>

<pre><code>class Model: ObservableObject, Identifiable {
    @Published var offset: CGFloat = 0

    let id = UUID()
    private var timer: Timer!

    init() {
        timer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true, block: { _ in
            self.update()
        })
    }

    func update() {
        offset = CGFloat.random(in: 0...300)
    }
}

struct ContentView: View {
    @ObservedObject var model1 = Model()
    @ObservedObject var model2 = Model()
    @ObservedObject var model3 = Model()
    @ObservedObject var model4 = Model()

    var body: some View {
        List {
            ForEach([model1, model2, model3, model4]) {
                Rectangle()
                    .foregroundColor(.red)
                    .frame(width: $0.offset, height: 30, alignment: .center)
                    .animation(.default)
            }
        }
    }
}
</code></pre>

<p>Will result in this behaviour:</p>

<p><a href=""https://i.stack.imgur.com/49ten.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/49ten.gif"" alt=""Video of result""></a></p>
","666211","","","","","2020-04-02 19:08:16","SwiftUI stops updates during scrolling of List","<swiftui><combine>","2","1","1","","","CC BY-SA 4.0"
"61000353","1","61003639","","2020-04-02 20:16:09","","0","82","<p>I am trying to trigger a download when my app becomes active, but I can't figure out how to do it.</p>

<p>This is my code</p>

<pre><code>NotificationCenter.default.publisher(for: UIApplication.didBecomeActiveNotification).map{ _ in
    return self.urlSession.dataTaskPublisher(for: url)
}
.tryMap{ element in
    guard let httpResponse = element.response as? HTTPURLResponse,
    httpResponse.statusCode == 200 else {
        throw URLError(.badServerResponse)
    }

.....
</code></pre>

<p>I have no idea how to get this to work. I constantly get a compile error stating:</p>

<p><code>Value of type 'URLSession.DataTaskPublisher' has no member 'response'</code></p>

<p>Why does my return statement return the complete publisher and not its result?</p>

<p>If I remove the <code>NotificationCenter</code> part and call <code>tryMap</code> directly on <code>dataTaskPublisher</code> like this:</p>

<pre><code>        self.urlSession.dataTaskPublisher(for: url)
        .tryMap{ element in

</code></pre>

<p>the compiler does not complain.</p>

<p>Pretty confused here :) </p>
","251824","","","","","2020-04-03 01:11:20","Using Combine to trigger download on app activation not compiling","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"61008563","1","61013742","","2020-04-03 09:13:17","","0","62","<p>i have this code, and if i set my published variable with +=, didSet will not be called. An explicit addition works, is this a bug or intended?</p>

<pre><code>import SwiftUI

class Model : ObservableObject {

    @Published var counter : Int = 0 {
        didSet {
            print(""did set called"")
        }
    }
}

struct ContentView: View {

    @EnvironmentObject var model : Model

    var body: some View {
        VStack {
            Text(""\(model.counter)"")
            Button(action: {
                print(""before"")
                self.model.counter += 1
                print(""after"")
            }) {
                Text(""Add +="")
            }
            Button(action: {
                print(""before"")
                self.model.counter = self.model.counter + 1
                print(""after explicit +"")
            }) {
                Text(""Add"")
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView().environmentObject(Model())
    }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/BF6F1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BF6F1.png"" alt=""enter image description here""></a></p>
","8457280","","8457280","","2020-04-03 10:19:16","2020-04-03 14:08:43","is += not calling didSet, but explicit + does call it, a bug?","<swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"61020336","1","61021350","","2020-04-03 21:00:01","","0","687","<p>I'm using Combine to write a simple web scraper. I'm trying to map the returned data to a string of HTML, throwing <code>ScraperError</code>s at each possible failure point. At the end, I want to pass this string to my <code>htmlSubject</code>, which is a <code>PassthroughSubject&lt;String, ScraperError&gt;</code>, for further processing.</p>

<pre class=""lang-swift prettyprint-override""><code>    urlSubscription = URLSession.shared
            .dataTaskPublisher(for: url)
            .mapError { _ -&gt; ScraperError in // Explicitly stating my failure type is ScraperError
                ScraperError.unreachableSite
            }
            .tryMap { (data, response) -&gt; String in
                guard let html = String(data: data, encoding: .utf8) else {
                    throw ScraperError.readFailed
                }

                return html
            }
            .subscribe(htmlSubject) // &lt;-- Not allowed because failure type is now Error
</code></pre>

<p>However, I'm finding that <code>.tryMap</code> is erasing my <code>ScraperError</code> to a regular <code>Error</code>, preventing me from chaining my <code>htmlSubject</code> to the end:</p>

<blockquote>
  <p>Instance method 'subscribe' requires the types 'Error' and
  'ScraperError' be equivalent.</p>
</blockquote>

<p>Is there an obvious way around this that I'm missing, or am I getting tripped up conceptually? I'm thinking of this chain as building blocks in a large function that maps <code>&lt;(Data, URLResponse), URLError&gt;</code> to <code>&lt;String, ScraperError&gt;</code>. </p>

<p>Any help is appreciated.</p>
","2432804","","","","","2021-01-20 14:22:35","Preserving Failure Type with Combine's tryMap","<swift><reactive-programming><combine>","2","1","","","","CC BY-SA 4.0"
"61034743","1","61044439","","2020-04-04 21:02:49","","2","624","<p>I'm dealing with a legacy libraries where I'm not at liberty to modify their code, and am trying to use Combine to weave them into something more easy to use. My situation is that a method call can either return a response, or a response and two notifications. The response-only is a success scenario, the response + 2 notifications is an error scenario. I want to combine both response and payload from the two notifications into an error that I can pass on to my app. The really fun thing is that I don't have a guarantee if the response or notifications come first, nor which of the notifications comes first. The notifications come in on a different thread than the response. The good thing is that they come in ""just about the same time"".</p>

<p>For handling a notification, I do</p>

<pre class=""lang-swift prettyprint-override""><code>firstNotificationSink = notificationCenter.publisher(for: .firstErrorPart, object: nil)
  .sink { [weak self] notification in
    // parse and get information about the error
  }

secondNotificationSink = notificationCenter.publisher(for: .secondErrorPart, object: nil)
  .sink { [weak self] notification in
    // parse and get more information about the error
  }
</code></pre>

<p>and asking the legacy library for a response is:</p>

<pre class=""lang-swift prettyprint-override""><code>func doJob() -&gt; String {
  let resultString = libDoStuff(reference)
}
</code></pre>

<p>Is there a way for me to use Combine to merge these three signals into one, given i.e. a 50ms timeframe? Meaning, if I get the result and two notifications, I have an error response I can pass on to my app, and if I have only the result and no notifications arrived in 50ms, then I can pass that success response to my app?</p>
","80246","","","","","2020-04-05 14:55:43","Swift Combine: combining three signals into one","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"61050314","1","61052839","","2020-04-05 22:21:44","","0","124","<p>I'm somewhat new to Combine and reactive programming in general. I think I've come across two different ways to do the same thing, but I'm wondering why I should chose one over the other.</p>

<p>I have a simple model that stores and publishes values related to the Apple Watch status. Below are the two different ways I think I'm doing the same thing.</p>

<p>In this first approach, I'm using a separate <code>AnyCancellable?</code> for each <code>Publisher</code>:</p>

<pre><code>class WatchConnectivityModel: ObservableObject {

    init() {
        activationState = WCSession.default.activationState
        isWatchAppInstalled = WCSession.default.isWatchAppInstalled
        isComplicationEnabled = WCSession.default.isComplicationEnabled

        assignPublishers()
    }

    @Published var activationState: WCSessionActivationState
    @Published var isWatchAppInstalled: Bool
    @Published var isComplicationEnabled: Bool

    private var activationStateStream: AnyCancellable?
    private var isWatchAppInstalledStream: AnyCancellable?
    private var isComplicationEnabledStream: AnyCancellable?

    private func assignPublishers() {
        activationStateStream = WCSession.default
            .publisher(for: \.activationState)
            .receive(on: RunLoop.main)
            .assign(to: \.activationState, on: self)

        isWatchAppInstalledStream = WCSession.default
            .publisher(for: \.isWatchAppInstalled)
            .receive(on: RunLoop.main)
            .assign(to: \.isWatchAppInstalled, on: self)

        isComplicationEnabledStream = WCSession.default
            .publisher(for: \.isComplicationEnabled)
            .receive(on: RunLoop.main)
            .assign(to: \.isComplicationEnabled, on: self)
    }
}
</code></pre>

<p>Here is my second approach, but instead of separate <code>AnyCancellable?</code> objects I'm using a single <code>Set&lt;AnyCancellable&gt;</code> along with <code>.store(in: &amp;self.cancellableSet)</code> on each <code>Publisher</code>:</p>

<pre><code>class WatchConnectivityModel: ObservableObject {

    init() {
        activationState = WCSession.default.activationState
        isWatchAppInstalled = WCSession.default.isWatchAppInstalled
        isComplicationEnabled = WCSession.default.isComplicationEnabled

        assignPublishers()
    }

    @Published var activationState: WCSessionActivationState
    @Published var isWatchAppInstalled: Bool
    @Published var isComplicationEnabled: Bool

    private var cancellableSet: Set&lt;AnyCancellable&gt; = []

    private func assignPublishers() {
        _ = WCSession.default
            .publisher(for: \.activationState)
            .receive(on: RunLoop.main)
            .assign(to: \.activationState, on: self)
            .store(in: &amp;self.cancellableSet)

        _ = WCSession.default
            .publisher(for: \.isWatchAppInstalled)
            .receive(on: RunLoop.main)
            .assign(to: \.isWatchAppInstalled, on: self)
            .store(in: &amp;self.cancellableSet)

        _ = WCSession.default
            .publisher(for: \.isComplicationEnabled)
            .receive(on: RunLoop.main)
            .assign(to: \.isComplicationEnabled, on: self)
            .store(in: &amp;self.cancellableSet)
    }
}
</code></pre>

<p>I'm guessing that the first approach would be better if I need to manually do something to one of the three specific streams, however I don't need to in this case. Other than that, is there anything that makes one of these approaches a better choice than the other? Is there anything major that I'm missing when it comes to memory management going with one over the other?</p>

<p>The second one seems a little weird to me because of the whole <code>_ =</code> part, because that seems like an extra artifact that's hard to explain: why am I assigning this whole thing to nothing? The first option avoids that possible confusion.</p>
","241163","","","","","2020-04-06 04:10:27","Which is better when creating multiple Publishers in Combine? AnyCancellable for each or Set<AnyCancellable> with .store(in: &self.cancellableSet)?","<ios><combine>","1","0","","","","CC BY-SA 4.0"
"61056787","1","66943597","","2020-04-06 09:35:11","","10","2221","<p>I'm seeing some struct vs class behavior that I don't really don't understand, when trying to assign a value using Combine.</p>

<p>Code:</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

struct Passengers {
  var women = 0
  var men = 0
}

class Controller {
  @Published var passengers = Passengers()
  var cancellables = Set&lt;AnyCancellable&gt;()
  let minusButtonTapPublisher: AnyPublisher&lt;Void, Never&gt;

  init() {
    // Of course the real code has a real publisher for button taps :)
    minusButtonTapPublisher = Empty&lt;Void, Never&gt;().eraseToAnyPublisher()

    // Works fine:
    minusButtonTapPublisher
      .map { self.passengers.women - 1 }
      .sink { [weak self] value in
        self?.passengers.women = value
      }.store(in: &amp;cancellables)

    // Doesn't work:
    minusButtonTapPublisher
      .map { self.passengers.women - 1 }
      .assign(to: \.women, on: passengers)
      .store(in: &amp;cancellables)
  }
}
</code></pre>

<p>The error I get is <code>Key path value type 'ReferenceWritableKeyPath&lt;Passengers, Int&gt;' cannot be converted to contextual type 'WritableKeyPath&lt;Passengers, Int&gt;'</code>.</p>

<p>The version using <code>sink</code> instead of <code>assign</code> works fine, and when I turn <code>Passengers</code> into a class, the <code>assign</code> version also works fine. My question is: why does it only work with a class? The two versions (sink and assign) really do the same thing in the end, right? They both update the <code>women</code> property on <code>passengers</code>.</p>

<p>(When I do change <code>Passengers</code> to a class, then the <code>sink</code> version no longer works though.)</p>
","403425","","403425","","2020-04-06 09:41:19","2021-04-04 16:44:54","Combine: can't use `.assign` with structs - why?","<swift><combine>","2","8","1","","","CC BY-SA 4.0"
"61057760","1","61072790","","2020-04-06 10:31:31","","0","240","<p>Hy,</p>

<p>I have an app where I want to get the current location of the user to autocomplete the location in a TextField and if is not the correct one to let the user written the desired location.</p>

<p>What I tried:</p>

<pre><code>final class ViewModel: NSObject, ObservableObject, CLLocationManagerDelegate {
      var locationManager: CLLocationManager

      public let objectWillChange = PassthroughSubject&lt;String,Never&gt;()

      public private(set) var latestLocation: String = """" {
            willSet {
                objectWillChange.send(newValue)
            }
       }

       override init() {
         locationManager = CLLocationManager()
         super.init()
         locationManager.delegate = self
         locationManager.desiredAccuracy = kCLLocationAccuracyBest
         locationManager.requestWhenInUseAuthorization()

         if CLLocationManager.locationServicesEnabled(){
             locationManager.startUpdatingLocation()
          }
        }   

       func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
          let userLocation :CLLocation = locations[0] as CLLocation

           let geocoder = CLGeocoder()
           geocoder.reverseGeocodeLocation(userLocation) { (placemarks, error) in
                 if (error != nil){
                  print(""error in reverseGeocode"")
         }

          let placemark = placemarks! as [CLPlacemark]

          if placemark.count&gt;0 {
            let placemark = placemarks![0]

            self.latestLocation = ""\(String(describing: placemark.locality))""
            }
        }   
}
</code></pre>

<p>And this is the SwiftUI file:</p>

<pre><code>struct FormView: View {
      @ObservedObject var viewModel: ViewModel = ViewModel()

          @State private var location: String = """"

          var body: some View {
               return Form {

                     TextField(title: $location) 
                           .onReceive(self.viewModel.objectWillChange) { value in
                               self.location = value
                           }                    
               }
I ALSO TRYIED THIS:
    //        .onReceive(self.viewModel.$latestLocation) { value in
    //            self.location = value
                  }
    }
</code></pre>

<p>What I see is that the location gets updated on View first and after in ViewModel, so always my TextField text is empty. </p>
","11995597","","","","","2020-04-07 04:19:48","Update SwiftUI view when location value from ViewModel is changed","<swift><swiftui>","1","0","1","","","CC BY-SA 4.0"
"61073146","1","61073374","","2020-04-07 05:04:17","","21","11599","<p>I am trying to validate user input in a TextField by removing certain characters using a regular expression. Unfortunately, I am running into problems with the didSet method of the <code>text</code> var calling itself recursively. </p>

<pre><code>import SwiftUI
import Combine

class TextValidator: ObservableObject {

    @Published var text = """" {
        didSet {
            print(""didSet"")
            text = text.replacingOccurrences(
                of: ""\\W"", with: """", options: .regularExpression
            ) // `\W` is an escape sequence that matches non-word characters.
        }
    }

}


struct ContentView: View {

    @ObservedObject var textValidator = TextValidator()

    var body: some View {
        TextField(""Type Here"", text: $textValidator.text)
            .padding(.horizontal, 20.0)
            .textFieldStyle(RoundedBorderTextFieldStyle())

    }
}
</code></pre>

<p>On the <a href=""https://docs.swift.org/swift-book/LanguageGuide/Properties.html#ID617"" rel=""noreferrer"">swift docs</a> (see the AudioChannel struct), Apple provides an example in which a property is re-assigned within its own didSet method and explicitly notes that this does not cause the didSet method to be called again. I did some testing in a playground and confirmed this behavior. However, things seem to work differently when I use an <code>ObservableObject</code> and a <code>Published</code> variable.</p>

<p><strong>How do I prevent the didSet method from calling itself recursively?</strong></p>

<p>I tried the examples in this <a href=""https://stackoverflow.com/questions/56476007/swiftui-textfield-max-length"">post</a>, but none of them worked. Apple may have changed things since then, so this post is NOT a duplicate of that one.</p>

<p>Also, setting the text back to <code>oldValue</code> within the <code>didSet</code> method upon encountering invalid characters would mean that if a user pastes text, then the entire text would be removed, as opposed to only the invalid characters being removed. So that option won't work.</p>
","12394554","","12394554","","2020-04-07 05:12:16","2022-02-15 07:41:01","SwiftUI validate input in textfields","<swift><swiftui>","6","0","1","","","CC BY-SA 4.0"
"61102801","1","61106205","","2020-04-08 14:12:54","","9","1626","<p>I'm using a <code>dataTaskPublisher</code> to fetch some data:</p>

<pre><code>func downloadData(_ req: URLRequest) {
  self.cancelToken = dataTaskPublisher(for: req).sink { /* ... */ }
}
</code></pre>

<p>If the function is called while the request is in progress, I would like to return.</p>

<p>Currently I either:<br>
1. Set the <code>cancelToken</code> to nil in the sink or<br>
2. Crate and manage a <code>isDownloading</code> variable.  </p>

<p>Is there a built-in way to check if the <code>dataTaskPublisher</code> is running (and optionally its progress)? </p>
","24391","","12299030","","2020-04-08 14:29:36","2020-04-11 16:36:16","How do I check the current progress of URLSession.dataTaskPublisher?","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"61115014","1","61115238","","2020-04-09 06:14:41","","2","940","<p>I'm trying to understand the Combine methodology of making a JSON network call. I'm
clearly missing something basic.</p>

<p>The closest I get fails with the URLSession cancelled.</p>

<pre><code>class NoteDataStore: ObservableObject {

    @Published var notes: [MyNote] = []

    init() {
        getWebserviceNotes()
    }

    func getWebserviceNotes() {

        let pub = Webservice().fetchNotes()
            .sink(receiveCompletion: {_ in}, receiveValue: { (notes) in
            self.notes = notes
            })
        }
    }
}//class
</code></pre>

<p>The data element:</p>

<pre><code>struct MyNote: Codable, Identifiable {
    let id = UUID()
    var title: String
    var url: String
    var thumbnailUrl: String

    static var placeholder: MyNote {
        return MyNote(title: ""No Title"", url: """", thumbnailUrl: """")
    }
}
</code></pre>

<p>The network setup:</p>

<pre><code>class Webservice {
    func fetchNotes() -&gt; AnyPublisher&lt;[MyNote], Error&gt; {
        let url = ""https://jsonplaceholder.typicode.com/photos""
        guard let notesURL = URL(string: url) else { fatalError(""The URL is broken"")}

        return URLSession.shared.dataTaskPublisher(for: notesURL)
            .map { $0.data }
            .decode(type: [MyNote].self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }
}
</code></pre>

<p>The console output is:</p>

<blockquote>
  <p>Task &lt;85208F00-BC24-44AA-B644-E0398FE263A6>.&lt;1> finished with error
  [-999] Error Domain=NSURLErrorDomain Code=-999 ""cancelled""
  UserInfo={NSErrorFailingURLStringKey=<a href=""https://jsonplaceholder.typicode.com/photos"" rel=""nofollow noreferrer"">https://jsonplaceholder.typicode.com/photos</a>,
  NSLocalizedDescription=cancelled,
  NSErrorFailingURLKey=<a href=""https://jsonplaceholder.typicode.com/photos"" rel=""nofollow noreferrer"">https://jsonplaceholder.typicode.com/photos</a>}</p>
</blockquote>

<p>Any guidance would be appreciated. Xcode 11.4</p>
","2698617","","12299030","","2020-04-09 06:33:43","2020-04-09 18:53:07","SwiftUI Combine URLSession JSON Network Call","<ios><json><xcode><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"61116079","1","61116276","","2020-04-09 07:33:09","","0","200","<p>I am very new to Combine and I am trying to get two SwiftUI sliders to update to and from a third value which represents the ‘single source of truth’ for their respective values. </p>

<p>Each slider has a range from 0…1 but uses a different function to determine its value. In the example below, if the true value is 0.5, the first slider sets and gets that directly (0.5) while the second slider uses the value squared (0.25). </p>

<p>The example works, but I get the impression that this isn’t really the proper way to do it. I get infinite recursion if the guard statements are removed in the Model. Can anyone show me the correct way to do this? Thanks!</p>

<p>Here is the Model:</p>

<pre><code>import SwiftUI

class Model : ObservableObject{

    @Published var trueValue: CGFloat = 0{
        didSet{
            slider1Value = trueValue
            slider2Value = trueValue * trueValue
        }
    }

    @Published var slider1Value: CGFloat = 0{
        didSet{
            guard oldValue != slider1Value else { return }

            trueValue = slider1Value
        }
    }

    @Published var slider2Value: CGFloat = 0{
        didSet{
            guard oldValue != slider2Value else { return }

            trueValue = slider2Value.squareRoot()
        }
    }
}

</code></pre>

<p>Here is the ContentView:</p>

<pre><code>
struct ContentView: View {
    @EnvironmentObject var model: Model

    var body: some View {
        GeometryReader{ geometry in
            VStack{
                ProportionalSlider(value: self.$model.slider1Value, width: geometry.size.width - 20)
                    .frame(width: geometry.size.width, height: 18)
                ProportionalSlider(value: self.$model.slider2Value, width: geometry.size.width - 20)
                    .frame(width: geometry.size.width, height: 18)
            }
        }
    }
}

</code></pre>

<p>And here is the ProportionalSlider:</p>

<pre><code>
struct ProportionalSlider: View {
    @Binding var value: CGFloat
    var width: CGFloat

    var body: some View{
        let gesture =  DragGesture(minimumDistance: 0)
            .onChanged({ mouse in         
                let clamped = min(self.width, max(0, mouse.location.x))
                self.value = clamped/self.width
            })

        return GeometryReader{ geometry in
            ZStack{
                ZStack(alignment: .leading){
                    Capsule().fill(Color.blue).frame(width: self.width, height: 15)
                       .gesture(gesture)
                    Capsule().fill(Color.red).frame(width: self.value * self.width, height: 15)
                       .gesture(gesture)
                }
            }
        }
    }
}

</code></pre>
","2234184","","","","","2020-04-09 08:20:49","How to get two SwiftUI sliders to update to and from a third value which represents the ‘single source of truth’ for their respective values","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61143246","1","61162973","","2020-04-10 15:12:23","","3","258","<p>Suppose I have a custom subscriber that requests one value on subscription and then an additional value three seconds after it receives the previous value:</p>

<pre><code>class MySubscriber: Subscriber {
    typealias Input = Int
    typealias Failure = Never

    private var subscription: Subscription?

    func receive(subscription: Subscription) {
        print(""Subscribed"")

        self.subscription = subscription
        subscription.request(.max(1))
    }

    func receive(_ input: Int) -&gt; Subscribers.Demand {
        print(""Value: \(input)"")

        DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(3)) {
            self.subscription?.request(.max(1))
        }

        return .none
    }

    func receive(completion: Subscribers.Completion&lt;Never&gt;) {
        print(""Complete"")
        subscription = nil
    }
}
</code></pre>

<p>If I use this to subscribe to an infinite range publisher, back pressure is handled gracefully, with the publisher waiting 3 seconds each time until it receives the next demand to send a value:</p>

<pre><code>(1...).publisher.subscribe(MySubscriber())

// Prints values infinitely with ~3 seconds between each:
//
//     Subscribed
//     Value: 1
//     Value: 2
//     Value: 3
//     ...
</code></pre>

<p>But if I add a <code>map</code> operator then <code>MySubscriber</code> never even receives a subscription; <code>map</code> appears to have synchronously requested <code>Demand.Unlimited</code> upon receiving its subscription and the app infinitely spins as <code>map</code> tries to exhaust the infinite range:</p>

<pre><code>(1...).publisher
    .map { value in
        print(""Map: \(value)"")
        return value * 2
    }
    .subscribe(MySubscriber())

// The `map` transform is executed infinitely with no delay:
//
//     Map: 1
//     Map: 2
//     Map: 3
//     ...
</code></pre>

<p>My question is, why does <code>map</code> behave this way? I would have expected <code>map</code> to just pass its downstream demand to the upstream. Since <code>map</code> is supposed to be for transformation rather than side effects, I don't understand what the use case is for its current behavior.</p>

<h1>EDIT</h1>

<p>I implemented a version of map to show how I think it ought to work:</p>

<pre><code>extension Publishers {
    struct MapLazily&lt;Upstream: Publisher, Output&gt;: Publisher {
        typealias Failure = Upstream.Failure

        let upstream: Upstream
        let transform: (Upstream.Output) -&gt; Output

        init(upstream: Upstream, transform: @escaping (Upstream.Output) -&gt; Output) {
            self.upstream = upstream
            self.transform = transform
        }

        public func receive&lt;S: Subscriber&gt;(subscriber: S) where S.Input == Output, S.Failure == Upstream.Failure {
            let mapSubscriber = Subscribers.LazyMapSubscriber(downstream: subscriber, transform: transform)
            upstream.receive(subscriber: mapSubscriber)
        }
    }
}

extension Subscribers {
    class LazyMapSubscriber&lt;Input, DownstreamSubscriber: Subscriber&gt;: Subscriber {
        let downstream: DownstreamSubscriber
        let transform: (Input) -&gt; DownstreamSubscriber.Input

        init(downstream: DownstreamSubscriber, transform: @escaping (Input) -&gt; DownstreamSubscriber.Input) {
            self.downstream = downstream
            self.transform = transform
        }

        func receive(subscription: Subscription) {
            downstream.receive(subscription: subscription)
        }

        func receive(_ input: Input) -&gt; Subscribers.Demand {
            downstream.receive(transform(input))
        }

        func receive(completion: Subscribers.Completion&lt;DownstreamSubscriber.Failure&gt;) {
            downstream.receive(completion: completion)
        }
    }
}

extension Publisher {
    func mapLazily&lt;Transformed&gt;(transform: @escaping (Output) -&gt; Transformed) -&gt; AnyPublisher&lt;Transformed, Failure&gt; {
        Publishers.MapLazily(upstream: self, transform: transform).eraseToAnyPublisher()
    }
}
</code></pre>

<p>Using this operator, <code>MySubscriber</code> receives the subscription immediately and the <code>mapLazily</code> transform is only executed when there is demand:</p>

<pre><code>(1...).publisher
    .mapLazily { value in
        print(""Map: \(value)"")
        return value * 2
    }
    .subscribe(MySubscriber())

// Only transforms the values when they are demanded by the downstream subscriber every 3 seconds:
//
//     Subscribed
//     Map: 1
//     Value: 2
//     Map: 2
//     Value: 4
//     Map: 3
//     Value: 6
//     Map: 4
//     Value: 8
</code></pre>

<p>My guess is that the particular overload of <code>map</code> defined for <code>Publishers.Sequence</code> is using some kind of shortcut to enhance performance. This breaks for infinite sequences, but even for finite sequences eagerly exhausting the sequence regardless of the downstream demand messes with my intuition. In my view, the following code:</p>

<pre><code>(1...3).publisher
    .map { value in
        print(""Map: \(value)"")
        return value * 2
    }
    .subscribe(MySubscriber())
</code></pre>

<p>ought to print:</p>

<pre><code>Subscribed
Map: 1
Value: 2
Map: 2
Value: 4
Map: 3
Value: 6
Complete
</code></pre>

<p>but instead prints:</p>

<pre><code>Map: 1
Map: 2
Map: 3
Subscribed
Value: 2
Value: 4
Value: 6
Complete
</code></pre>
","642233","","642233","","2020-04-11 19:20:32","2020-04-13 13:14:15","Why does `Publishers.Map` consume upstream values eagerly?","<swift><combine><backpressure>","1","4","","","","CC BY-SA 4.0"
"61145309","1","61293161","","2020-04-10 17:17:53","","0","348","<p>I'm relatively new to reactive programming concepts, and I'm trying to build a simple view model to update <code>@Published Bool</code> values that are used to keep UI updated with SwiftUI.</p>

<p>This particular model is setting up those <code>Bool</code> values based on other values from the <code>WatchConnectivity</code> framework as they change over time.</p>

<p>Even though this is a simple example and it's working, I feel like I'm missing opportunities to reduce redundancy.</p>

<p>Specifically, it feels weird that I am repeating the logic used to set up the initial values of <code>appNotInstalled</code> and <code>complicationNotInstalled</code> later when I use <code>Publishers.CombineLatest</code> and <code>Publishers.CombineLatest3</code>.</p>

<p>Even though the initial values are passed through the publishers, so they go through the <code>CombineLatest</code> pipelines and set the initial values, it feels wrong to arbitrarily set the published variables to <code>true</code> or <code>false</code>, but the compiler is making me set initial values for them somewhere.</p>

<p>If I don't set initial values, I get the <code>Variable 'self.appNotInstalled' used before being initialized</code> error.</p>

<p>Is there a way I can avoid setting initial values, without making them nil, or another way to avoid duplicating the logic used to determine their values?</p>

<p>Here's the working code I have:</p>

<pre><code>class WatchConnectivityModel: ObservableObject {

    // values used to show/hide UI
    @Published var appNotInstalled: Bool
    @Published var complicationNotInstalled: Bool

    private var cancellables: [AnyCancellable] = []

    init() {

        // initialize based on the values of everything at class init
        let activated = WCSession.default.activationState == .activated
        let appInstalled = WCSession.default.isWatchAppInstalled
        let complicationInstalled = WCSession.default.isComplicationEnabled
        appNotInstalled = !(activated &amp;&amp; appInstalled)
        complicationNotInstalled = activated &amp;&amp; appInstalled &amp;&amp; !complicationInstalled

        // set up the publishers for any changes
        let activationStatePublisher = WCSession.default.publisher(for: \.activationState)
        let isWatchAppInstalledPublisher = WCSession.default
            .publisher(for: \.isWatchAppInstalled)
        let isComplicationEnabledPublisher = WCSession.default
            .publisher(for: \.isComplicationEnabled)

        // set up assignment of appNotInstalled for changes
        Publishers.CombineLatest(activationStatePublisher.removeDuplicates(),
                                 isWatchAppInstalledPublisher.removeDuplicates())
            .map { (state, installed) in
                // repeated logic from above
            return !(state == .activated &amp;&amp; installed)
        }.receive(on: RunLoop.main)
            .assign(to: \.appNotInstalled, on: self)
            .store(in: &amp;cancellables)

        // set up assignment of complicationNotInstalled for changes
        Publishers.CombineLatest3(activationStatePublisher.removeDuplicates(),
                                  isWatchAppInstalledPublisher.removeDuplicates(),
                                  isComplicationEnabledPublisher.removeDuplicates())
            .map { (state, appInstalled, complicationInstalled) in
                // repeated logic again
                return state == .activated &amp;&amp; appInstalled &amp;&amp; !complicationInstalled
        }.receive(on: RunLoop.main)
            .assign(to: \.complicationNotInstalled, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>
","241163","","241163","","2020-04-18 17:19:43","2020-04-18 17:19:43","Using Combine to set up Publishers and while also satisfying requirement for initial values on non-nil variables","<swift><swiftui><combine><watchconnectivity>","1","4","","","","CC BY-SA 4.0"
"61171372","1","61194209","","2020-04-12 12:20:17","","3","270","<p>It seems <code>View.onReceive</code> doesn't cancel subscription after that view disappeared. Action keeps getting called when no Child view on screen. 
How can I keep that subscription alive while the view is visible only?</p>

<pre><code>struct BugDemo: View {
    var body: some View {
        NavigationView {
            NavigationLink(""Go to child"", destination: Child())
        }
    }
}

struct Child: View {
    @State private var date: Date = Date()

    var body: some View {
        Text(DateFormatter.localizedString(from: date, dateStyle: .medium, timeStyle: .medium))
            .navigationBarTitle(""Child"")
            .onReceive(PublisherHolder.shared.publisher) {
                print(""Child.onReceive"")
                self.date = $0
            }
            .onDisappear {
                print(""Child.onDisappear"")
            }
    }
}

private class PublisherHolder {
    static let shared = PublisherHolder()
    lazy var publisher: AnyPublisher&lt;Date, Never&gt; = {
        Timer.publish(every: 1, on: .main, in: .default)
            .autoconnect()
            .print()
            .eraseToAnyPublisher()
    }()
}
</code></pre>
","1434829","","","","","2020-04-13 18:25:33","View.onReceive doesn't cancel subscription when the view removed from hierarchy","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61177698","1","61177954","","2020-04-12 20:27:18","","3","220","<p>how to fix this method declaration to let Payload be fully omitted when not needed, now it needs Generic Type to be provided even though it should use default <code>nil</code> value. I ended with duplicating this method with Payload part omitted to get rid of this error but looking for any hints so I can deduplicate my code again.</p>

<p>Thanks in advance</p>

<pre><code>func prepareRequest&lt;Payload: Encodable&gt;(for url: URL, method: String = ""GET"", payload: Payload? = nil) -&gt; AnyPublisher&lt;URLRequest, Never&gt; {
// ...
}
</code></pre>
","1285959","","","","","2020-04-12 21:15:54","Swift Optional Generics Type required even though parameter is nil","<swift><generics>","2","0","","2020-04-12 21:20:59","","CC BY-SA 4.0"
"61178868","1","61180001","","2020-04-12 22:11:00","","70","20746","<p>So I'm trying to learn SwiftUI and Combine. I usually start new tech by making a simple tip calculator. </p>

<p>I seem to be getting a random ""Extra argument in call."" error while coding 
Here is my SwiftUI File</p>

<pre><code>import SwiftUI

internal enum ReceiptRowType {
    case subtotal
    case tax
    case total
    case tip
    case grandTotal
}

struct TipView: View {
    @ObservedObject internal var adBannerView: BannerAdView = BannerAdView()
    @ObservedObject internal var receiptViewModel: ReceiptViewModel

    private let percentageFormatter: NumberFormatter = {
        let f = NumberFormatter()
        f.numberStyle = .percent
        return f
    }()

    var body: some View {
        ZStack {
            Color.white
                .scaledToFit()

            VStack {
                if adBannerView.adHasLoaded {
                    adBannerView
                        .frame(maxHeight: adBannerView.adHeight)
                        .animation(.easeInOut(duration: 2.0))
                }

                BorderView()

                Text(ARCHLocalizedStrings.receipt)
                    .foregroundColor(Color.gray)

                BorderView()

                HStack {
                    Spacer()

                    Button(action: {
                        self.receiptViewModel.addNewReceiptItem()
                    }) {
                        Text(ARCHLocalizedStrings.buttonTitleAddItem)
                    }
                }

                BorderView()

                ScrollView {
                    ForEach(receiptViewModel.receiptItems) { receiptItem in
                        ItemView(receiptItem: receiptItem)

                        if receiptItem != self.receiptViewModel.receiptItems.last {
                            Divider()
                        }
                    }
                }

                BorderView()

                BottomOfReceiptRow(receiptViewModel: receiptViewModel,
                                   type: ReceiptRowType.subtotal,
                                   title: ARCHLocalizedStrings.subtotal)

                BottomOfReceiptRow(receiptViewModel: receiptViewModel,
                                   type: ReceiptRowType.tax,
                                   title: ARCHLocalizedStrings.tax)
            }
            .padding(.horizontal, ARCHSwiftUILayoutConstants.defaultPaddingAndSpacing)
        }
    }
}

struct BorderView: View {
    var body: some View {
        Text(""================================"")
            .lineLimit(1)
            .foregroundColor(Color.gray)
            .minimumScaleFactor(0.5)
    }
}

struct ItemView: View {
    @ObservedObject var receiptItem: ReceiptItemViewModel

    var body: some View {
        HStack {
            TextField(receiptItem.name, text: $receiptItem.name)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .foregroundColor(Color.gray)
                .multilineTextAlignment(TextAlignment.leading)

            TextField(""Price"", value: $receiptItem.price, formatter: ARCHUtilities.currencyFormatter)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .foregroundColor(Color.gray)
                .multilineTextAlignment(TextAlignment.trailing)
                .minimumScaleFactor(0.5)
                .frame(width: ARCHSwiftUILayoutConstants.widthForCurrency)
        }
    }
}

struct BottomOfReceiptRow: View {
    @ObservedObject internal var receiptViewModel: ReceiptViewModel

    internal var type: ReceiptRowType
    internal var title: String

    var body: some View {
        HStack {
            Spacer()

            Text(title)
                .foregroundColor(Color.gray)

            if type == ReceiptRowType.subtotal {
                Text(""\(receiptViewModel.subtotal)"")
                    .foregroundColor(Color.gray)
                    .frame(width: ARCHSwiftUILayoutConstants.widthForCurrency)
            } else if type == ReceiptRowType.tax {
                Text(""\(receiptViewModel.taxRate)"")
                    .foregroundColor(Color.gray)
                    .frame(width: ARCHSwiftUILayoutConstants.widthForCurrency)
            } else if type == ReceiptRowType.total {
                Text(""\(receiptViewModel.total)"")
                    .foregroundColor(Color.gray)
                    .frame(width: ARCHSwiftUILayoutConstants.widthForCurrency)
            } else if type == ReceiptRowType.tip {

            } else if type == ReceiptRowType.grandTotal {
                Text(""\(receiptViewModel.grandTotal)"")
                    .foregroundColor(Color.gray)
                    .frame(width: ARCHSwiftUILayoutConstants.widthForCurrency)
            }
        }
    }
}

struct TipView_Previews: PreviewProvider {
    static var previews: some View {
        TipView(receiptViewModel: ReceiptViewModel())
    }
}
</code></pre>

<p>However, if I add another view on the TipView body (Any View) I seem to get a ""Extra argument in call"" error. </p>

<p><a href=""https://i.stack.imgur.com/GCAXk.png"" rel=""noreferrer"">Picture of error here</a></p>

<p>Does anyone know what's going on? </p>
","2593831","","","","","2020-04-13 00:33:35","SwiftUI: Random ""Extra argument in call"" error","<swiftui><combine>","2","3","3","","","CC BY-SA 4.0"
"61190398","1","61200321","","2020-04-13 14:46:01","","6","3422","<p>I have a custom <code>ViewModifier</code> which simply returns the same content attached with a <code>onReceive</code> modifier, the <code>onReceive</code> is not triggered, here is a sample code that you can copy, paste and run in <code>XCode</code>:</p>

<pre><code>import SwiftUI
import Combine

class MyViewModel: ObservableObject {
    @Published var myProperty: Bool = false
}
struct ContentView: View {
    @ObservedObject var viewModel: MyViewModel

    var body: some View {
        Text(""Hello, World!"")
        .modifier(MyOnReceive(viewModel: viewModel))
            .onTapGesture {
                self.viewModel.myProperty = true
        }
    }
}

struct MyOnReceive: ViewModifier {
    @ObservedObject var viewModel: MyViewModel

    func body(content: Content) -&gt; some View {
        content
            .onReceive(viewModel.$myProperty) { theValue in
                print(""The Value is \(theValue)"") // &lt;--- this is not executed
        }
    }
}
</code></pre>

<p>is <code>SwiftUI</code> designed to disallow <code>onReceive</code> to execute inside a <code>ViewModifier</code> or is it a bug ? I have a view in my real life project that gets bigger with some business logic put inside <code>onReceive</code>, so I need to clean that view by separating it from <code>onReceive</code>.</p>
","1056118","","","","","2021-11-16 16:39:17","SwiftUI: ViewModifier doesn't listen to onReceive events","<ios><swift><swiftui>","2","5","2","","","CC BY-SA 4.0"
"61207937","1","61208499","","2020-04-14 12:40:36","","1","1243","<p>Trying to solve the challenge from the milestone via <code>Combine</code>, but stuck on a error:</p>

<pre><code>Value of type 'Published&lt;[User]&gt;.Publisher' has no member 'store'
</code></pre>

<p>Source code:</p>

<pre class=""lang-swift prettyprint-override""><code>import Combine
import Foundation


// MARK: Main model from API
struct User: Decodable, Identifiable {
    let id: UUID
    let isActive: Bool
    let name: String
    let age: Int
    let company: String
    let email: String
    let address: String
    let about: String
    let registered: Date
    let tags: [String]
    let friends: [Friend]
}

// MARK: - Friend array API
struct Friend: Decodable {
    let id: String
    let name: String
}


final class ViewModel: ObservableObject {
    @Published var model = [User]()

    private var subscriptions: Set&lt;AnyCancellable&gt; = []

    // Error: Value of type 'Published&lt;[User]&gt;.Publisher' has no member 'store'
    init() { $model.store(in: &amp;subscriptions )}
}

extension ViewModel {
    // MARK: - Make request to API
    func fetch() -&gt; AnyPublisher&lt;User, Error&gt; {
        guard let mainURL = URL(string: ""https://www.hackingwithswift.com/samples/friendface.json"") else {
            fatalError(""404: Not found"")
        }

        return URLSession.shared.dataTaskPublisher(for: mainURL)
            .map(\.data)
            .decode(type: User.self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }
}

</code></pre>

<p>I don't understand, where do I need to create a Publisher?</p>
","8377355","","8377355","","2020-04-14 13:01:52","2020-04-14 13:19:42","@Published class has no member .store | Combine SwiftUI","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"61212263","1","61212823","","2020-04-14 16:10:54","","9","2162","<p>I'm new to Combine and I'd like to get a seemingly simple thing. Let's say I have a collection of integer, such as:</p>

<pre><code>let myCollection = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>I'd like to publish each element with a delay of, for example, 0.5 seconds. </p>

<pre><code>print 0
wait for 0.5secs
print 1
wait for 0.5secs
and so forth
</code></pre>

<p>I can easily get the sequence publisher and print the elements like this:</p>

<pre><code>let publisherCanc = myCollection.publisher.sink { value in
    print(value)
}
</code></pre>

<p>But in this case all the values are printed immediately. How can I print the values with a delay? In Combine there's a <code>.delay</code> modififer, but it's not for what I need (indeed, <code>.delay</code> delays the entire stream and not the single elements). If I try:</p>

<pre><code>let publisherCanc = myCollection.publisher.delay(for: .seconds(0.5), scheduler: RunLoop.main).sink { value in
    print(value)
}
</code></pre>

<p>All I get it's just an ""initial"" delay, then the elements are printed immediately. </p>

<p>Thanks for your help.</p>
","1291872","","","","","2021-05-25 14:24:12","Combine: publish elements of a sequence with some delay","<ios><swift><combine>","3","3","1","","","CC BY-SA 4.0"
"61216852","1","61230138","","2020-04-14 20:41:33","","6","1711","<p>I want to do an asynchronous job with Future.
But the below <strong>.sink() closures</strong> never get called.
It seems that the instance of Future was released right after it was called.</p>

<pre><code>    Future&lt;Int, Never&gt; { promise in
        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {
            promise(.success(1))
        }
    }
    .receive(on: DispatchQueue.main)
    .sink(receiveCompletion: { completion in
        print(completion)
    }, receiveValue: {
        print($0)
    })
</code></pre>

<p>So I replaced <strong>.sink() closures</strong> to <strong>.subscribe(Subscribers.Sink())</strong> like below. It works fine.
But the problem is I don't understand why it works fine. :(
It looks the same to me.
What is the difference between these two codes? And when can I use <strong>.sink()</strong>, and when can I not?</p>

<pre><code>    Future&lt;Int, Never&gt; { promise in
        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {
            promise(.success(1))
        }
    }
    .receive(on: DispatchQueue.main)
    .subscribe(Subscribers.Sink(receiveCompletion: { completion in
        print(completion)
    }, receiveValue: {
        print($0)
    }))
</code></pre>

<p>Thanks in advance.</p>
","2848557","","","","","2020-04-15 15:47:48","What's the difference between .sink and Subscribers.Sink?","<swift><swiftui><combine>","1","1","3","","","CC BY-SA 4.0"
"61249506","1","61250761","","2020-04-16 11:49:29","","2","1670","<h1>Overview:</h1>

<ul>
<li>I have a class called Player and a class called Song.</li>
<li>Player contains a Song</li>
<li>A view is showing the song title</li>
</ul>

<h1>Aim:</h1>

<p>When I change the player.song.title, the view needs to be updated.</p>

<h1>Problem:</h1>

<p>When the song's attributes changes, it wouldn't update the view automatically. Only when a new song is assigned will the changes be reflected.</p>

<h1>My Attempts:</h1>

<p>I have made 2 attempts (code below), both work as expected.</p>

<h1>Questions:</h1>

<ul>
<li>Is there a better way to do it ? (It seems like a common problem, one would encounter.)
Are my attempts reasonable and is attempt 2 better?</li>
<li>Or is there something fundamentally flawed with my design? (I was hoping to have the song inside the player because it represented the <strong>current</strong> song).</li>
</ul>

<h1>Original Code (view wouldn't be updated):</h1>

<h2>Model</h2>

<pre><code>import Foundation
import Combine

class Player : ObservableObject {

    @Published var duration = 0
    @Published var song     : Song

    init(song: Song) {
        self.song = song
    }
}

class Song : ObservableObject {

    @Published var id     : Int
    @Published var title  : String
    @Published var artist : String

    init(id: Int,
         title: String,
         artist: String) {

        self.id     = id
        self.title  = title
        self.artist = artist
    }
}
</code></pre>

<h2>View</h2>

<pre><code>import SwiftUI

struct ContentView: View {

    @ObservedObject var player : Player

    var body: some View {

        VStack {
            Text(String(player.duration))
            Text(player.song.title)
            Text(player.song.artist)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {

        let song = Song(id: 1, title: ""title1"", artist: ""artist1"")
        let player = Player(song: song)

        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            player.song.title = ""title2""
        }

        return ContentView(player: player)
    }
}
</code></pre>

<h3>Attempt1 - Using CombineLatest</h3>

<p><strong>Problem</strong>: It is not very scalable as the number of properties in a song increases.</p>

<pre><code>class Player : ObservableObject {

    @Published var duration = 0
    @Published var song     : Song
    private var songChangeCanceller : AnyCancellable?

    init(song: Song) {
        self.song = song

        songChangeCanceller = song.$title.combineLatest(song.$artist, song.$id).sink { _, _, _ in
            self.objectWillChange.send()
        }
    }
}
</code></pre>

<h3>Attemp2: Uses objectWillChange.sink</h3>

<pre><code>class Player : ObservableObject {

    @Published var duration = 0
    @Published var song     : Song

    private var songChangeCanceller : AnyCancellable?
    private var songAttributesChangeCanceller : AnyCancellable?

    init(song: Song) {
        self.song = song

        songChangeCanceller = $song.sink { newSong in

            self.songAttributesChangeCanceller = newSong.objectWillChange.sink { _ in
                self.objectWillChange.send()
            }
        }
    }
}
</code></pre>
","1046037","","","","","2020-04-16 13:16:21","SwiftUI Observe Changes","<swift><swiftui><combine><observableobject>","2","0","1","","","CC BY-SA 4.0"
"61272203","1","61273595","","2020-04-17 12:55:43","","4","777","<p>I'm trying to create chunks of a stream in Apple's Combine framework.</p>

<p>What I'm going for is something like this:</p>

<pre><code>Stream a:
--1-2-3-----4-5---&gt;

Stream b:
--------0-------0-&gt;

a.chunk(whenOutputFrom: b)

-------[1, 2, 3]---[4, 5]--&gt;
</code></pre>

<p>Can this be implemented in Combine?</p>
","4239752","","","","","2020-06-22 05:22:10","Swift Combine Chunk Operator","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"61286999","1","61289601","","2020-04-18 09:34:09","","0","262","<p>I'm working on Log In and Sign Up pages using Firebase Auth by email&amp;password.</p>

<p>What is done successfully:</p>

<p>If the session (login or sign up) isn't <strong>nil</strong>, then user goes to a Welcome Back  View.</p>

<p>The question is next:</p>

<p>I don't want a new user to go to <strong>""Welcome Back ""</strong> View, instead, I want him after pressing ""Sign Up"" button (is session isn't <strong>nil</strong> to go to a new View - ""Upload Your Photo View""</p>

<p>My Session Store Class (@ObservableObject):</p>

<pre><code> @Published var session: User? {didSet{self.didChange.send(self)}}
 var didChange = PassthroughSubject&lt;SessionStore, Never&gt;()
var handle: AuthStateDidChangeListenerHandle?
let currentuser = Auth.auth().currentUser




func listen(){
    handle = Auth.auth().addStateDidChangeListener({(auth, user) in
        if let user = user{
            self.session = User(uid: user.uid, email: user.email)
        } else {
            self.session = nil
        }

    })
}

func signUp(email: String, password: String, fullname: String, username: String, handler: @escaping AuthDataResultCallback){
    Auth.auth().createUser(withEmail: email, password: password,  completion: handler)


}

func signIn(email: String, password: String, handler: @escaping AuthDataResultCallback){
    Auth.auth().signIn(withEmail: email, password: password){ (res,err) in
        if err != nil{
            return
        }

    }
</code></pre>

<p>}</p>

<pre><code>func signOut(){
    do{
        try Auth.auth().signOut()
        self.session = nil
    }catch{
        print(""Error signing out"")
    }
}

func unbind() {
    if let handle = handle {
        Auth.auth().removeStateDidChangeListener(handle)
    }
}

deinit {
    unbind()
}

func addUsername(username: String){
    session?.username = username
}
func addFullname(fullname: String){
    session?.fullname = fullname
}


class User:ObservableObject{

var uid: String
var email: String?
var username: String?
var fullname: String?

    init(uid:String, email:String?){

    self.uid = uid
    self.email = email

}

}}
</code></pre>

<p>My Content View Looks like that :</p>

<p>Group{
                if (session.session != nil){</p>

<pre><code>                Button(action: {
                    try! Auth.auth().signOut()
                    UserDefaults.standard.set(false, forKey: ""status"")
                    NotificationCenter.default.post(name: NSNotification.Name(""statusChange""), object: nil)
                }){
                    Text(""Log out"")
                }
                ExploreView()

            }else{

                        AuthView()

            }
        }.onAppear(perform: getUser)
</code></pre>
","12256385","","209103","","2020-04-18 13:52:17","2020-04-18 13:52:17","How open one screen if a new user registered successfully, and other when existing user logged in succesfully using SwiftUI?","<swift><google-cloud-firestore><firebase-authentication><swiftui>","1","6","","","","CC BY-SA 4.0"
"61291017","1","61293575","","2020-04-18 14:44:18","","2","95","<p>I have a ""Swifty"" version of NSPredicate that is based on a simple closure. This makes it composable but I'd like to find a way of implementing error messages to give the user feedback in the UI. </p>

<p>The problem arises when I attempt to compose two predicates with a logical AND - with my current implementation (which kept the predicate very simple), I can't find a meaningful way of generating an error message from the component predicates. An obvious solution would be to add a computed property to the predicate that will re-evaluate the predicate and return an error (if applicable) but that seems very inefficient. </p>

<p>I started to look into exposing error messages via a Combine Publisher but this got out of control quickly and seems unnecessarily complex. I've concluded that I now can't see the wood for the trees now and could do with a bit of a steer. Code base follows...</p>

<p>Predicate:</p>

<pre><code>public struct Predicate&lt;Target&gt; {
    // MARK: Public roperties
    var matches: (Target) -&gt; Bool
    var error: String

    // MARK: Init
    init(_ matcher: @escaping (Target) -&gt; Bool, error: String = """") {
        self.matches = matcher
        self.error = error
    }

    // MARK: Factory methods
    static func required&lt;LosslessStringComparabke: Collection&gt;() -&gt; Predicate&lt;LosslessStringComparabke&gt; {
        .init( { !$0.isEmpty }, error: ""Required field"")
    }

    static func characterCountMoreThan&lt;LosslessStringComparable: Collection&gt;(count: Int) -&gt; Predicate&lt;LosslessStringComparable&gt; {
        .init({ $0.count &gt;= count }, error: ""Length must be at least \(count) characters"")
    }

    static func characterCountLessThan&lt;LosslessStringComparable: Collection&gt;(count: Int) -&gt; Predicate&lt;LosslessStringComparable&gt; {
        .init( { $0.count &lt;= count }, error: ""Length must be less than \(count) characters"")
    }

    static func characterCountWithin&lt;LosslessStringComparable: Collection&gt;(range: Range&lt;Int&gt;) -&gt; Predicate&lt;LosslessStringComparable&gt; {
        .init({ ($0.count &gt;= range.lowerBound) &amp;&amp; ($0.count &lt;= range.upperBound) }, error: ""Length must be between \(range.lowerBound) and \(range.upperBound) characters"")
    }
}


// MARK: Overloads

// e.g. let uncompletedItems = list.items(matching: \.isCompleted == false)
func ==&lt;T, V: Equatable&gt;(lhs: KeyPath&lt;T, V&gt;, rhs: V) -&gt; Predicate&lt;T&gt; {
    Predicate { $0[keyPath: lhs] == rhs }
}

// r.g. let uncompletedItems = list.items(matching: !\.isCompleted)
prefix func !&lt;T&gt;(rhs: KeyPath&lt;T, Bool&gt;) -&gt; Predicate&lt;T&gt; {
    rhs == false
}


func &gt;&lt;T, V: Comparable&gt;(lhs: KeyPath&lt;T, V&gt;, rhs: V) -&gt; Predicate&lt;T&gt; {
    Predicate { $0[keyPath: lhs] &gt; rhs }
}


func &lt;&lt;T, V: Comparable&gt;(lhs: KeyPath&lt;T, V&gt;, rhs: V) -&gt; Predicate&lt;T&gt; {
    //    Predicate { $0[keyPath: lhs] &lt; rhs }
    Predicate({ $0[keyPath: lhs] &lt; rhs }, error: ""\(rhs) must be less than \(lhs)"")
}


func &amp;&amp;&lt;T&gt;(lhs: Predicate&lt;T&gt;, rhs: Predicate&lt;T&gt;) -&gt; Predicate&lt;T&gt; {
    return Predicate({ lhs.matches($0) &amp;&amp; rhs.matches($0) }, error: ""PLACEHOLDER: One predicate failed"")
}

func ||&lt;T&gt;(lhs: Predicate&lt;T&gt;, rhs: Predicate&lt;T&gt;) -&gt; Predicate&lt;T&gt; {
    Predicate({ lhs.matches($0) || rhs.matches($0) }, error: ""PLACEHOLDER: Both predicates failed"")
}
</code></pre>

<p>Validator (consumes predicates):</p>

<pre><code>public enum ValidationError: Error, CustomStringConvertible {
    case generic(String)

    public var description: String {
        switch self {
        case .generic(let error): return error
        }
    }
}

public struct Validator&lt;ValueType&gt; {
    private var predicate: Predicate&lt;ValueType&gt;

    func validate(_ value: ValueType) -&gt; Result&lt;ValueType, ValidationError&gt; {
        switch predicate.matches(value) {
        case true:
            return .success(value)
        case false:
            return .failure(.generic(predicate.error)) // TODO: placeholder
        }
    }

    init(predicate: Predicate&lt;ValueType&gt;) {
        self.predicate = predicate
    }
}
</code></pre>

<p>Validator struct is utilised by a property wrapper:</p>

<pre><code>@propertyWrapper
public class ValidateAndPublishOnMain&lt;ValueType&gt; where ValueType: LosslessStringConvertible { // Type constraint specifically for SwiftUI text controls
   @Published private var value: ValueType

    private var validator: Validator&lt;ValueType&gt;

    public var wrappedValue: ValueType {
        get { value }
        set { value = newValue }
    }

    // need to also force validation to execute when the textfield loses focus
    public var projectedValue: AnyPublisher&lt;Result&lt;ValueType, ValidationError&gt;, Never&gt; {
        return $value
            .receive(on: DispatchQueue.main)
            .map { value in
                self.validator.validate(value)
        }
        .eraseToAnyPublisher()
    }

    public init(wrappedValue initialValue: ValueType, predicate: Predicate&lt;ValueType&gt;) {
        self.value = initialValue
        self.validator = Validator(predicate: predicate)
    }
}
</code></pre>

<p>...and finally, use of the property wrapper in SwiftUI (and associated view model)</p>

<pre><code>public class ViewModel: ObservableObject {
    @ValidateAndPublishOnMain(predicate: .required() &amp;&amp; .characterCountLessThan(count: 5))
    var validatedData = """" {
        willSet { objectWillChange.send() }
    }

    var errorMessage: String = """"
    private var cancellables = Set&lt;AnyCancellable&gt;()

    init() {
        setupBindings()
    }

    private func setupBindings() {
        $validatedData
            .map { value in
                switch value {
                case .success: return """"
                case .failure(let error): return error.description
                }
        }
        .assign(to: \.errorMessage, on: self)
        .store(in: &amp;cancellables)
    }
}

struct ContentView: View {
    @ObservedObject var viewModel = ViewModel()
    @State private var error = """"

    var body: some View {
        VStack {
            HStack {
                Text(""Label"")
                TextField(""Data here"", text: $viewModel.validatedData)
                    .textFieldStyle(RoundedBorderTextFieldStyle())

            }.padding()

            Text(""Result: \(viewModel.validatedData)"")
            Text(""Errors: \(viewModel.errorMessage)"")
        }
        .onAppear {
            self.viewModel.objectWillChange.send() // ensures UI shows requirements immediately
        }
    }
}
</code></pre>
","2733214","","","","","2020-04-18 17:43:14","Implementing a composable predicate type with embedded error messages / user feedback","<swift><swiftui><predicate>","1","3","","","","CC BY-SA 4.0"
"61295078","1","61297221","","2020-04-18 19:30:29","","0","185","<p>I have the following code which should indicate a memory leak. but it actually doesn't when I test it with Xcode leak instrument.
Does this mean that there's actually no memory leak, or the instrument may be wrong?</p>

<pre><code>private func initTimePublisher() {
        timer.publish(every: tickInterval, on: runloop, in: runloopMode)
            .autoconnect()
            .map { self.durationCalculator.activeDuration(between: self.startDate!, and: $0) }
            .assign(to: \.activeDuration, on: self) // This should be a retain cycle which causes a memory like right?
            .store(in: &amp;subs)
}
</code></pre>
","5929027","","752890","","2020-04-18 19:50:56","2020-04-18 22:37:49","Is the leak instrument in Xcode instruments accurate?","<swift><instruments><combine>","1","0","","","","CC BY-SA 4.0"
"61295242","1","61295668","","2020-04-18 19:44:02","","0","282","<p>I currently have a struct, which has a computed property called ""answerArray"". I want to compare this array of values with another array of values that is stored in an Environment object. </p>

<pre><code>struct CandidateModel {
@EnvironmentObject var model: CardViewModel

let index: Int
var name: String
var answers: [AnswerModel]
var answerArray: [Double] {
    get {
        var arr: [Double] = []
        for i in answers {
            if i.isKeyIssue {
            // If answer is a key issue
                arr.append(i.score * 1.5)
                // Apply multiplier and append to answer array
            }
            else {arr.append(i.score)}
            // otherwise just append to list
        }
        return arr
    }
}
var scoreArray: [Double] {
    get {

        var compScoreArray: [Double] = []

        for i in 0...self.model.getAnswerList().count - 1 {
            let questionDifference = abs(self.answerArray[i] - self.model.answerList[i])
            compScoreArray.append(questionDifference)
        }

        return compScoreArray
    }
}
</code></pre>

<p>I when attempt to access this property I get the following error:</p>

<pre><code>Thread 1: Fatal error: No ObservableObject of type CardViewModel found. A View.environmentObject(_:) for CardViewModel may be missing as an ancestor of this view.
</code></pre>

<p>I am simply trying to update the scoreArray property in the CandidateModel as the answerList property in my environment object changes. How could I better implement this? </p>

<p>Here is my View Code:</p>

<pre><code>struct SentimentComparisonBarView: View {
@EnvironmentObject var model: CardViewModel

var body: some View {
    HStack {
      // 2
        Image(""Jobs_Economy"")
            .renderingMode(.template)
            .resizable()
            .scaledToFit()
            .frame(width: 50)
            .foregroundColor(Color.init(#colorLiteral(red: 0.3942148186, green: 0.3146163453, blue: 0.4587302703, alpha: 1)))

        Text(""Jobs/Economy"")
            .frame(width: 120, alignment: .leading)
          // 3
          Rectangle()
            .fill(Color.init(#colorLiteral(red: 0.5201314092, green: 0.3027745485, blue: 0.49252671, alpha: 1)))
            .frame(width: CGFloat(2 * 10.0), height: 5.0)
          // 4
          Spacer()
            Text(""Low"")
                .padding(.horizontal, 10)

        Button(""Test"") {
            print(self.model.presidentialCandidates[0].scoreArray)
        }

    }
}
</code></pre>
","8898639","","8898639","","2020-04-18 21:04:21","2020-04-18 21:04:21","Access environment object property within a struct's computed property","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61303466","1","61382527","","2020-04-19 11:19:58","","13","3757","<p>I am trying to add a close button to the modally presented View's navigation bar. However, after dismiss, my view models <strong>deinit</strong> method is never called. I've found that the problem is where it captures the <strong>self</strong> in <strong>navigationBarItem</strong>'s. I can't just pass a <code>weak self</code> in <strong>navigationBarItem</strong>'s action, because View is a struct, not a class. Is this a valid issue or just a lack of knowledge?</p>

<pre><code>struct ModalView: View {

    @Environment(\.presentationMode) private var presentation: Binding&lt;PresentationMode&gt;
    @ObservedObject var viewModel: ViewModel

    var body: some View {

        NavigationView {
            Text(""Modal is presented"")
            .navigationBarItems(leading:
                Button(action: {
                    // works after commenting this line
                    self.presentation.wrappedValue.dismiss()
                }) {
                    Text(""close"")
                }

            )
        }
    }
}
</code></pre>
","7876148","","","","","2022-06-05 11:18:31","SwiftUI - memory leak in NavigationView","<ios><swift><memory-leaks><swiftui><combine>","4","0","2","","","CC BY-SA 4.0"
"61306309","1","61367084","","2020-04-19 14:49:48","","1","636","<h1>Overview:</h1>

<ul>
<li>I have a async task to fetch from the database</li>
<li>I have created a Future for the async task (fetching from the database).</li>
</ul>

<h1>Question:</h1>

<ul>
<li>How can execute custom code when the Future is cancelled?</li>
</ul>

<h1>Purpose:</h1>

<ul>
<li>I would like the database connection to be closed when the subscription is cancelled.</li>
</ul>

<p>For example, I would like to use <code>Combine</code> to rewrite this helper method:</p>

<pre class=""lang-swift prettyprint-override""><code>// Similar to https://developer.apple.com/documentation/coredata/nspersistentcontainer/1640564-performbackgroundtask
func withDatabaseFTSContext(block: @escaping (FMDatabase?) -&gt; Void) {
  queue.async {
    guard let database = self.database else {
      block(nil)
      return
    }

    database.open()
    let simpleTokenizer = FMSimpleTokenizer(locale: nil)
    FMDatabase.registerTokenizer(simpleTokenizer, withKey: ""simple"")
    database.installTokenizerModule()

    block(database)

    database.close()
  }
}
</code></pre>

<p>Could I leverage <code>Combine</code> to rewrite this method to return <code>FMDatabase</code> as a parameter of a publisher?</p>

<p>I was attempting to use <code>Combine</code> but it does not work. The database will be closed before <code>cancel()</code></p>

<pre class=""lang-swift prettyprint-override""><code>private func withDatabaseFTSContext() -&gt; AnyPublisher&lt;FMDatabase?, Never&gt; {
  return Future&lt;FMDatabase?, Never&gt; { promise in
    self.queue.async {
      guard let database = self.database else {
        promise(.success(nil))
        return
      }

      database.open()
      let simpleTokenizer = FMSimpleTokenizer(locale: nil)
      FMDatabase.registerTokenizer(simpleTokenizer, withKey: ""simple"")
      database.installTokenizerModule()

      promise(.success(database))

      database.close() // When to close this database? Currently it will be closed before `cancel()`
    }
  }.eraseToAnyPublisher()
}
</code></pre>
","2949840","","1046037","","2020-04-20 12:49:18","2020-04-22 14:04:15","Combine: How to clean up resources while an AnyCancellable is being cancelled?","<swift><swiftui><combine>","1","7","","","","CC BY-SA 4.0"
"61309091","1","61315780","","2020-04-19 17:54:33","","2","1363","<p>I have an ObservableObject which is supposed to hold my application state:</p>

<pre class=""lang-swift prettyprint-override""><code>final class Store: ObservableObject {
  @Published var fetchInterval = 30
}
</code></pre>

<p>now, that object is being in injected at the root of my hierarchy and then at some component down the tree I'm trying to access it and bind it to a TextField, namely:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ConfigurationView: View {
  @EnvironmnetObject var store: Store

  var body: some View {
    TextField(""Fetch interval"", $store.fetchInterval, formatter: NumberFormatter())
    Text(""\(store.fetchInterval)""
  }
}
</code></pre>

<ol>
<li>Even though the variable is binded (with <code>$</code>), the property is not being updated, the initial value is displayed correctly but when I change it, the textfield changes but the binding is not propagated</li>
<li>Related to the first question, is, how would I receive an event once the value is changed, I tried the following snippet, but nothing is getting fired (I assume because the textfield is not correctly binded...</li>
</ol>

<pre class=""lang-swift prettyprint-override""><code>$fetchInterval
           .debounce(for: 0.8, scheduler: RunLoop.main)
           .removeDuplicates()
           .sink { interval in
               print(""sink from my code \(interval)"")
           }
</code></pre>

<p>Any help is much appreciated.</p>

<p>Edit: I just discovered that for text variables, the binding works fine out of the box, ex:</p>

<pre class=""lang-swift prettyprint-override""><code>// on store
@Published var testString = ""ropo""

// on component
TextField(""Ropo"", text: $store.testString)
Text(""\(store.testString)"")
</code></pre>

<p>it is only on the int field that it does not update the variable correctly</p>

<p>Edit 2: 
Ok I have just discovered that only changing the field is not enough, one has to press <code>Enter</code> for the change to propagate, which is not what I want, I want the changes to propagate every time the field is changed...</p>
","3107926","","3107926","","2020-04-19 18:34:18","2020-04-21 11:24:44","SwiftUI, how to bind EnvironmnetObject Int property to TextField?","<ios><swift><macos><swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"61318725","1","61318762","","2020-04-20 09:04:11","","1","528","<p>I want to extract String value from Observed Object</p>

<p>This is example code</p>

<pre><code>import SwiftUI
import Combine


class SetViewModel : ObservableObject {
  private static let userDefaultTextKey = ""textKey""
  @Published var text: String = UserDefaults.standard.string(forKey: SetViewModel.userDefaultTextKey) ?? """"
  private var canc: AnyCancellable!

  init() {
    canc = $text.debounce(for: 0.2, scheduler: DispatchQueue.main).sink { newText in
        UserDefaults.standard.set(newText, forKey: SetViewModel.userDefaultTextKey)
    }
  }

  deinit {
    canc.cancel()
  }
}


struct SettingView: View {
  @ObservedObject var viewModel = SettingViewModel()
  var body: some View {
    ZStack {
        Rectangle().foregroundColor(Color.white).edgesIgnoringSafeArea(.all).background(Color.white)
        VStack {
            TextField(""test"", text: $viewModel.text).textFieldStyle(BottomLineTextFieldStyle()).foregroundColor(.red)
            Text($viewModel.text) //I want to get String Value from $viewModel.text

        }
    }
  }
}
</code></pre>

<p>I want to use <code>""$viewModel.text""</code>'s String value. How can I do this?</p>
","13292453","","472495","","2020-04-20 15:23:09","2020-04-20 15:23:09","How to extract String value from Observed Object in Swift","<ios><swift><swiftui><observedobject>","2","0","","","","CC BY-SA 4.0"
"61322293","1","61322571","","2020-04-20 12:15:17","","3","2021","<p>I have made a SwiftUI app that repeatedly fetches telemetry data to update custom views. The views use a variable stored in an EnvironmentObject.</p>

<pre><code>struct updateEO{
    @EnvironmentObject var settings:UserSettings
    func pushSettingUpdate(telemetry: TelemetryData) {
        settings.info = telemetry
        print(settings.info)
    }
}

class DownloadTimer : ObservableObject {
    var timer : Timer!
    let didChange = PassthroughSubject&lt;DownloadTimer,Never&gt;()
    @Published var telemetry = TelemetryData()
    func start() {
        connectToClient()
        self.timer?.invalidate()
        self.timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) {
            _ in
            guard let url = URL(string: ""http://127.0.0.1:25555/api/telemetry"") else {
                print(""Invalid URL"")
                return
            }

            let request = URLRequest(url: url)

            URLSession.shared.dataTask(with: request) { data, response, error in
                if let data = data {
                    if let decodedResponse = try? JSONDecoder().decode(TelemetryData.self, from: data) {
                        DispatchQueue.main.async {
                            updateEO().pushSettingUpdate(telemetry: decodedResponse)
                        }
                        return
                    }
                }
            }.resume()
        }
    }
}

</code></pre>

<p>At runtime, when the telemetry is passed to the <code>pushSettingUpdate(telemetry: decodedResponse)</code>, the app crashes with an error of 'Fatal error: No ObservableObject of type UserSettings found.'.
I understand I may need to pass the struct the EnvironmentObject but I am not sure on how to do that. Any help would be much appreciated. Thanks! :)</p>
","13121858","","","","","2021-03-22 08:31:09","Pass EnvironmentObject to an ObservableObject class","<ios><swift><swiftui>","1","0","2","2020-04-20 12:41:57","","CC BY-SA 4.0"
"61328231","1","61333515","","2020-04-20 17:17:04","","0","425","<p>I have three publishers. Two which already produced value, and one that may or may not do it. I need to combine them and produce output.</p>

<pre><code>var changeDay = NotificationCenter.Publisher.init(center: .default, name: .NSCalendarDayChanged

    var someDate: AnyPublisher&lt;Date, Never&gt; {
        Publishers.CombineLatest3($someInputBool, $someInputDate, changeDay).map { (a, b, c) -&gt; Date in
            return &lt;someDate based on a and b, but if day changes, the result will be different.&gt;
        }.eraseToAnyPublisher()
    }
</code></pre>

<p>If the day hasn't yet changed, the CombineLatest3 won't return anything as it waits for the initial value from c before running the clousure. How can I make sure the CombineLatest3 returns even if one publisher hasn't emitted a single value? I'm using <code>c</code> as a trigger here to recompute my custom date.</p>
","8693775","","","","","2020-04-20 23:08:39","How to make CombineLatest3 return result if one publisher hasn't produced any values?","<ios><swift><uikit><combine>","1","0","","","","CC BY-SA 4.0"
"61335519","1","61336518","","2020-04-21 03:35:36","","9","13469","<p>I have a problem with observed object in SwiftUI.
I can see changing values of observed object on the View struct.
However in class or function, even if I change text value of TextField(which is observable object) but ""self.codeTwo.text still did not have changed.</p>

<p>here's my code sample (this is my ObservableObject)</p>

<pre><code>class settingCodeTwo: ObservableObject {

private static let userDefaultTextKey = ""textKey2""
@Published var text: String = UserDefaults.standard.string(forKey: settingCodeTwo.userDefaultTextKey) ?? """"

private var canc: AnyCancellable!

     init() {
        canc = $text.debounce(for: 0.2, scheduler: DispatchQueue.main).sink { newText in
        UserDefaults.standard.set(newText, forKey: settingCodeTwo.userDefaultTextKey)

    }
}


   deinit {
     canc.cancel()
   }

}
</code></pre>

<p>and the main problem is... ""self.codeTwo.text"" never changed!</p>

<pre><code>class NetworkManager: ObservableObject {


@ObservedObject var codeTwo = settingCodeTwo()
@Published var posts = [Post]()


func fetchData() {
    var urlComponents = URLComponents()
    urlComponents.scheme = ""http""



    urlComponents.host = ""\(self.codeTwo.text)"" //This one I want to use observable object




    urlComponents.path = ""/mob_json/mob_json.aspx""
    urlComponents.queryItems = [
        URLQueryItem(name: ""nm_sp"", value: ""UP_MOB_CHECK_LOGIN""),
        URLQueryItem(name: ""param"", value: ""1000|1000|\(Gpass.hahaha)"")
    ]

    if let url = urlComponents.url {
        print(url)
        let session = URLSession(configuration: .default)
        let task = session.dataTask(with: url) { (data, response, error) in
            if error == nil {
                let decoder = JSONDecoder()
                if let safeData = data {
                    do {
                        let results = try decoder.decode(Results.self, from: safeData)

                        DispatchQueue.main.async {
                            self.posts = results.Table
                        }   
                    } catch {
                        print(error)
                    }
                }
            }
        }
        task.resume()
    }

}
}
</code></pre>

<p>and this is view, I can catch change of the value in this one</p>

<pre><code>import SwiftUI
import Combine



struct SettingView: View {

  @ObservedObject var codeTwo = settingCodeTwo()
  var body: some View {
    ZStack {
        Rectangle().foregroundColor(Color.white).edgesIgnoringSafeArea(.all).background(Color.white)
        VStack {


            TextField(""test"", text: $codeTwo.text).textFieldStyle(BottomLineTextFieldStyle()).foregroundColor(.blue)

            Text(codeTwo.text)
        }
    }
}
}
</code></pre>

<p>Help me please.</p>
","13292453","","12299030","","2020-04-21 05:28:21","2020-04-21 05:30:24","SwiftUI: How can I catch changing value from observed object when I execute function","<ios><swiftui><combine><observableobject><observedobject>","2","0","","","","CC BY-SA 4.0"
"61359307","1","62241442","","2020-04-22 07:15:44","","0","895","<p>I have a ScrollView with a HStack of views that would animate depending on their own position. To do that, I am using a GeometryReader that would read the current global position of each view and when a certain position is reached the view would switch from out of focus to in-focus state and do some transformations and change the @State variable to indicate that the view is in focus so that other parts of the view can act on that.</p>

<p>Fairly simple, right? Unfortunately, when I change the @State from within the GeometryReader, the state change wouldn't happen. Therefore I built a simplified version to demonstrate the issue. </p>

<p>Here is the code: </p>

<pre><code>import SwiftUI

struct GeometryReaderTest: View {
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            //
            HStack(spacing: 40){
                ForEach(0..&lt;10) { _ in
                    SlideView()
                }
            }
        }

    }
}

struct SlideView : View {
    //
    @State var isInFocus : Bool = false
    var body: some View {
        ZStack {
            Rectangle().fill( isInFocus ? Color.green : Color.orange).frame(width: UIScreen.main.bounds.width - 60, height: 120, alignment: .center)
            MyContent(isInFocus: self.$isInFocus)
        }

    }
}

struct MyContent : View {
    @Binding var isInFocus : Bool

    var body: some View {
        GeometryReader { geo in

            self.toggleFocusState(geometry: geo)
        }
    }

    func toggleFocusState(geometry : GeometryProxy)-&gt; some View{
        let distance = geometry.frame(in: .global).origin.x.magnitude


        self.isInFocus = distance &lt; 120


        return VStack {
            Text(""Focused: \(self.isInFocus ? ""Yes"" : ""Nope"" )"")
             Text(""Distance: \(distance)"")
            Button(action: {
                //
                self.isInFocus.toggle()
            }) {
                Text(""Toggle"")
            }
        }
    }
}

struct GeometryReaderTest_Previews: PreviewProvider {
    static var previews: some View {
        GeometryReaderTest()
    }
}
</code></pre>

<p>When you tap on the ""toggle"" button, which also runs from within the GeometryReader, the @State  variable would change successfully and the change would be reflected. </p>

<p>When you actually scroll the ScrollView and leave it to naturally scroll through, nothing will happen. It would not update even after it stops. </p>

<p>see here: <a href=""https://streamable.com/d3op74"" rel=""nofollow noreferrer"">https://streamable.com/d3op74</a></p>

<p>When you slowly scroll through the ScrollView and not lift your finger, the @State variable would change.</p>

<p>here: <a href=""https://streamable.com/7m15t9"" rel=""nofollow noreferrer"">https://streamable.com/7m15t9</a></p>

<p>If you introduce a delay with DispatchQueue.main.asyncAfter() like this:</p>

<pre><code>DispatchQueue.main.asyncAfter(deadline: .now() + 0.0) {
            self.isInFocus = distance &lt; 120
        }
</code></pre>

<p>even if the delay is 0, the @State change would work as you scroll through, no matter how fast however this time the toggle button wouldn't function(which makes sense, since the GeometryReader would re-calculate and overturn the action taken by the button).</p>

<p>here: <a href=""https://streamable.com/q3ylu1"" rel=""nofollow noreferrer"">https://streamable.com/q3ylu1</a></p>

<p>Can please someone explain what is going on here? Is this an intended behaviour or a bug?</p>
","1781521","","1781521","","2020-04-22 07:29:15","2020-06-07 05:57:17","SwiftUI would not reflect changes to a @Binding @State variable when the change is made from within a GeometryReader","<swift><combine><swiftui><geometryreader>","1","2","1","","","CC BY-SA 4.0"
"61360848","1","61384265","","2020-04-22 08:43:31","","2","1678","<p>I want to create a Swift Combine publisher which achieves the following:</p>

<ul>
<li>The publisher should be triggered by changes in <em>either</em> <a href=""https://github.com/sindresorhus/Defaults#observe-changes-to-a-key"" rel=""nofollow noreferrer"">Defaults</a> (a <code>UserDefaults</code> Swift package) <em>or</em> changes in GRDB sqlite database values (using <a href=""https://github.com/groue/GRDBCombine#database-observation"" rel=""nofollow noreferrer"">GRDBCombine</a>).</li>
<li>The updated <code>UserDefaults</code> received from the <a href=""https://github.com/sindresorhus/Defaults#observe-changes-to-a-key"" rel=""nofollow noreferrer"">Defaults</a> publisher should be used <em>within</em> the database query in the <a href=""https://github.com/groue/GRDBCombine#database-observation"" rel=""nofollow noreferrer"">GRDBCombine</a> publisher.</li>
</ul>

<p>Here is a simplified version of what I have tried so far:</p>

<pre><code>func tasksPublisher() -&gt; AnyPublisher&lt;[Task], Never&gt; {
    Defaults.publisher(.myUserDefault)
        .flatMap { change in
            let myUserDefault = change.newValue

            return ValueObservation
                .tracking { db in
                    try Task.
                        .someFilter(myUserDefault)
                        .fetchAll(db)
                }
                .removeDuplicates()
                .publisher(in: database)
                .eraseToAnyPublisher()
        }
        .eraseToAnyPublisher()
}
</code></pre>

<p>However, this publisher produces the following error (edited according to the simplified version of my publisher above):</p>

<blockquote>
  <p><code>Cannot convert return expression of type 'AnyPublisher&lt;Publishers.FlatMap&lt;_, AnyPublisher&lt;Defaults.KeyChange&lt;Int&gt;, Never&gt;&gt;.Output, Publishers.FlatMap&lt;_, AnyPublisher&lt;Defaults.KeyChange&lt;Int&gt;, Never&gt;&gt;.Failure&gt;' (aka 'AnyPublisher&lt;_.Output, Never&gt;') to return type 'AnyPublisher&lt;[Task], Never&gt;'</code></p>
</blockquote>

<p>My bet is that there is a problem with the two publishers having different values: <code>[Task]</code> and <code>Defaults.KeyChange&lt;Int&gt;</code>. However, I cannot find a way to work around this.</p>
","2906284","","","","","2020-04-23 10:02:31","How can I create a Swift Combine publisher from two publishers A and B where publisher B consumes the value from publisher A?","<swift><combine><userdefaults><grdb><grdbcombine>","1","0","","","","CC BY-SA 4.0"
"61361004","1","61370886","","2020-04-22 08:51:41","","0","773","<p>And what shall we use instead?<br>
I'm surprised that nobody asked this before.</p>
","2167345","","","","","2021-07-15 21:14:55","Why don't we have tryFlatMap operator in Combine?","<swift><combine>","2","2","","","","CC BY-SA 4.0"
"61361788","1","61361941","","2020-04-22 09:34:03","","6","2451","<p>I'm currently getting familiar with SwiftUI and Combine frameworks. And I'm not really getting the difference between these two approaches. When we have to keep track of some data (say, a list of tasks), we can declare a @State variable, and it's change will automatically send notification and update current view. However, it looks like it can also be done this way:</p>

<pre><code>class TaskList: ObservableObject{
    //a list that's going to be modified and updated on different occasions
    @Published var list: [String]
}

class TodoListView {
    @ObservedObject var todoList = TaskList()
}
</code></pre>

<p>So, I missing a point - <strong>how are @State and @ObservedObject approaches different and which one is preferable under which circumstances?</strong></p>

<p>Thanks!</p>
","6029661","","","","","2020-10-01 09:51:00","@State vs @ObservableObject - which and when?","<swift><swiftui><combine>","2","1","2","","","CC BY-SA 4.0"
"61362821","1","61424222","","2020-04-22 10:26:43","","0","880","<p>One of the requirements of my application is the ability to start multiple timers, for reporting purposes.</p>

<p>I've tried to store the timers and seconds passed in an <code>@EnvironmentObject</code> with <code>@Published</code> variables, but every time the object refreshes, any view that observes the <code>@EnvironmentObject</code> refreshes too.</p>

<p>Example</p>

<pre class=""lang-swift prettyprint-override""><code>class TimerManager: ObservableObject {
   @Published var secondsPassed: [String: Int]
   var timers: [String:AnyCancellable]

   func startTimer(itemId: String) {
      self.secondsPassed[itemId] = 0
      self.timers[itemId] = Timer
          .publish(every: 1, on: .main, in: .default)
          .autoconnect()
          .sink(receiveValue: { _ in
                self.secondsPassed[itemId]! += 1
          })
   }

   func isTimerValid(itemId: String) -&gt; Bool {
       return self.timers[itemId].isTimerValid
   }

   // other code...
}
</code></pre>

<p>So for example, if in any other view I need to know if a particular timer is active by calling a function <code>isTimerValid</code>, I need to include this <code>@EnvironmentObject</code> in that view, and it won't stop refreshing it because the timer changes <code>secondsPassed</code> which is <code>Published</code>, causing lags and useless redrawings.</p>

<p>So one thing I did was to cache the <code>itemId</code> of the active timers somewhere else, in a <code>static</code> <code>struct</code> that I update every time I start or stop a timer. </p>

<p>It seemed a bit hacky, so lately I've been thinking to move all this into a Singleton, like this for example </p>

<pre class=""lang-swift prettyprint-override""><code>class SingletonTimerManager {

   static let singletonTimerManager = SingletonTimerManager()

   var secondsPassed: [String: Int]
   var timers: [String:AnyCancellable]

   func startTimer(itemId: String) {
      self.secondsPassed[itemId] = 0
      self.timers[itemId] = Timer
          .publish(every: 1, on: .main, in: .default)
          .autoconnect()
          .sink(receiveValue: { _ in
                self.secondsPassed[itemId]! += 1
          })
   }

   // other code...
}
</code></pre>

<p>and <strong>only let some Views</strong> observe the changes to <code>secondsPassed</code>. On the plus side, I can maybe move the timer on the background thread.</p>

<p>I've been struggling how to do this properly.</p>

<p>These are my <code>Views</code> (albeit a very simple extract)</p>

<pre><code>struct ContentView: View {

    // set outside the ContentView
    var selectedItemId: String

    // timerValue: set by a publisher?

    var body: some View {
        VStack {  
            ItemView(seconds: Binding.constant(timerValue))
        }
    }
}

struct ItemView: View {
    @Binding var seconds: Int

    var body: some View {
        Text(""\(self.seconds)"")
    }
}
</code></pre>

<p>I need to somehow observe the <code>SingletonChronoManager.secondsPassed[selectedItemId]</code> so the <code>ItemView</code> updates in real time. </p>
","4663815","","13860","","2020-05-09 11:52:03","2020-05-09 11:52:03","Observe singleton timer value changes with Publisher in Combine","<swift><timer><swiftui><combine>","2","0","0","","","CC BY-SA 4.0"
"61377460","1","61379103","","2020-04-23 00:43:55","","1","826","<p>I was experimenting with Combine and SwiftUI but stuck in updating state basically I want to update my state in the view every time ObservableObject changes, 
here's the example.</p>

<pre><code>class XViewModel: ObservableObject {
    @Published var tVal: Bool = false
    private var cancellables = Set&lt;AnyCancellable&gt;()

    func change() {
        Just(true)
            .delay(for: 3.0, scheduler: RunLoop.main)
            .receive(on: RunLoop.main)
            .assign(to: \.tVal, on: self)
            .store(in: &amp;self.cancellables)
    }
}

</code></pre>

<p>I have viewModel and one publisher and delayed publisher which triggers after 3 seconds.</p>

<pre><code>struct ContentView: View {
    @ObservedObject var viewModel = XViewModel()
    @State var toggleVal: Bool = false
    private var cancellables = Set&lt;AnyCancellable&gt;()

    init() {
        self.viewModel.$tVal
            .sink { newVal in
            print(newVal)
        }
        .store(in: &amp;cancellables)        

        self.viewModel
            .$tVal.assign(to: \.toggleVal, on: self)
            .store(in: &amp;cancellables)

        viewModel.change()
    }

    var body: some View {
        VStack {
            Toggle(isOn: self.$viewModel.tVal) {
                Text(""Toggle"")

            Toggle(isOn: self.$toggleVal) {
                Text(""Toggle from View"")
            }
    }

}
</code></pre>

<p>What I expected is </p>

<pre><code>viewModel.Just triggers
viewModel.tVal publisher triggers
view.toggleVal state triggers 
updates UI 
</code></pre>

<p>But it seems although everything is updated it doesn't update state. Is there any way to update State or it wasn't meant to be updated at all and I need to bind my views directly to the viewModel's tVal value which is publisher.</p>

<p>Thanks.</p>
","2103088","","","","","2020-04-23 03:56:53","Updating State from ObservableObject publisher","<swift><swiftui><reactive-programming><swift5>","1","0","","","","CC BY-SA 4.0"
"61381303","1","61383029","","2020-04-23 07:08:48","","1","419","<p>I am trying to do keyboard adaptive behaviour. I've subscribed on <code>keyboardWillShowNotification</code> and <code>keyboardWillHideNotification</code>, I receive all these events as expected. But I have a problem with <code>keyboardWillShowNotification</code>: I receive it once after pressing keyboard's button:</p>

<p><a href=""https://i.stack.imgur.com/4ddeX.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/4ddeX.gif"" alt=""Example""></a></p>

<p>Here is code of mine listener:</p>

<pre><code>import SwiftUI
import Combine

// MARK: - View

struct ContentView: View {
    @State private var text: String = """"

    var body: some View {
        VStack{
            Text(text)
            Spacer()
            TextField(""Input your text"", text: $text)
            .textFieldStyle(RoundedBorderTextFieldStyle())
        }
        .padding()
        .keyboardAdaptive()
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

// MARK: - Keyboard hacks

extension Notification {
    var keyboardHeight: CGFloat {
        return (userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect)?.height ?? 0
    }
}

extension Publishers {
    static var keyboardHeight: AnyPublisher&lt;CGFloat, Never&gt; {
        let willShow = NotificationCenter.default.publisher(for: UIApplication.keyboardWillShowNotification)
            .map { (n: Notification) -&gt; CGFloat in
                print(""will show"")
                return n.keyboardHeight
            }

        let willHide = NotificationCenter.default.publisher(for: UIApplication.keyboardWillHideNotification)
            .map { (n: Notification) -&gt; CGFloat in
                print(""will hide"")
                return CGFloat(0)
            }

        return MergeMany(willShow, willHide)
            .eraseToAnyPublisher()
    }
}

// MARK: -- Detect focused element
extension UIResponder {
    static var currentFirstResponder: UIResponder? {
        _currentFirstResponder = nil
        UIApplication.shared.sendAction(#selector(UIResponder.findFirstResponder(_:)), to: nil, from: nil, for: nil)
        return _currentFirstResponder
    }

    private static weak var _currentFirstResponder: UIResponder?

    @objc private func findFirstResponder(_ sender: Any) {
        UIResponder._currentFirstResponder = self
    }

    var globalFrame: CGRect? {
        guard let view = self as? UIView else { return nil }
        return view.superview?.convert(view.frame, to: nil)
    }
}

// MARK: -- Keyboard Adaptive Modifier

struct KeyboardAdaptive: ViewModifier {
    @State private var bottomPadding: CGFloat = 0

    func body(content: Content) -&gt; some View {
        GeometryReader { geometry in
            content
                .padding(.bottom, self.bottomPadding)
                .onReceive(Publishers.keyboardHeight) { keyboardHeight in
                    let keyboardTop = geometry.frame(in: .global).height - keyboardHeight
                    let focusedTextInputBottom = UIResponder.currentFirstResponder?.globalFrame?.maxY ?? 0
                    self.bottomPadding = max(0, focusedTextInputBottom - keyboardTop - geometry.safeAreaInsets.bottom)
            }
            .animation(.easeOut(duration: 0.16))
        }
    }
}

extension View {
    func keyboardAdaptive() -&gt; some View {
        ModifiedContent(content: self, modifier: KeyboardAdaptive())
    }
}
</code></pre>

<p>I am a new guy in mobile development, can anyone help me with this?</p>
","2114208","","2114208","","2020-04-23 08:04:29","2020-11-11 13:14:51","iOS: How to stop receive keyboardWillShowNotification after keyboard keypress","<ios><swift><swiftui>","2","2","1","","","CC BY-SA 4.0"
"61402122","1","61403996","","2020-04-24 06:01:44","","2","1974","<p>New to Combine &amp; reactive programming here so the help is very much appreciated.</p>

<p>I have the following scenario: I'd like to build a UI where a user can filter down content via various 'filter' buttons on the page. When a user taps one of the buttons, I need to shoot off an API request to get the data.</p>

<p>Now, I have a publisher that provides me with the 'state' of these selections, and I've structured my code like this:</p>

<pre><code>        state
            .publisher /* sends whenever 'state' updates behind the scenes */
            .debounce(for: 1.0, scheduler: DispatchQueue.main)
            .map { /*  create some URL request */ }
            .flatMap {
                URLSession.shared.dataTaskPublisher(for: someRequest)
                    .map { $0.data }
                    .decode(type: MyResponseType.self, decoder: JSONDecoder())
        }.sink(receiveCompletion: { (completion) in
            /// cancelled
        }) { (output) in
             /// go show my results
             /// Ideally, this is only called when the most recent API call finishes!
        }.store(in: &amp;cancellables)
</code></pre>

<p>However, this implementation has a bug in the following scenario: If one event makes it through to the flatMap to fire off a request, and a subsequent event does the same before the network call completes, then we will call the completion handler twice.</p>

<p>Preferably, we are somehow a canceling the inner pipeline so we only execute the completion handler with the most recent event.</p>

<p>How can I 'cancel' that inner pipeline (the one started by the dataTaskPublisher) when new events come down the pipeline without tearing down the outer pipeline?</p>
","1284996","","","","","2020-04-24 20:23:36","Combine: How to cancel a flatMap'ed publisher","<ios><swift><reactive-programming><combine>","1","0","1","","","CC BY-SA 4.0"
"61404517","1","61480024","","2020-04-24 08:50:20","","5","4235","<p>I'm having a hard time with dealing with Combine. After the publisher is complete I want to update a value but whenever I update that value the memory is allocated and never goes away.</p>

<p>Whenever I try to assign image there is a leak. If I don't assign no leak.</p>

<p>EDIT: Reproducible example here: <a href=""https://github.com/peterwarbo/MemoryAllocation"" rel=""noreferrer"">https://github.com/peterwarbo/MemoryAllocation</a></p>

<p>This is what my code looks like:</p>

<pre><code>final class CameraController: ObservableObject {

    private var storage = Set&lt;AnyCancellable&gt;()    
    var image: UIImage?

    func capture(_ image: UIImage) {

        PhotoLibrary.saveImageToTemporaryDirectory(image) // AnyPublisher&lt;URL, Error&gt;
            .zip(PhotoLibrary.saveImage(image, location: self.locationObserver.location) // AnyPublisher&lt;UIImage, Error&gt;)
            .sink(receiveCompletion: { [weak self] (completion) in
                switch completion {
                case let .failure(error):
                    Log.error(error)
                    self?.handleCaptureError(error)
                case .finished: break
                }
            }) { [weak self] (value) in
                print(value.1) // no leak
                self.image = value.1 // leak

            }
            .store(in: &amp;self.storage)
     }
}
</code></pre>

<p>I've also tried instead of using <code>sink</code>:</p>

<pre><code>.receive(
    subscriber: Subscribers.Sink(
        receiveCompletion: { [weak self] completion in
            switch completion {
            case let .failure(error):
                Log.error(error)
                self?.handleCaptureError(error)
            case .finished: break
            }
        },
        receiveValue: { value in
            print(value.1) // no leak
            self.image = value.1 // leak            
        }
    )
)
</code></pre>
","294661","","294661","","2020-04-28 10:22:46","2021-08-09 12:12:54","swift combine sink receiveValue memory leak","<swift><memory-leaks><combine>","3","0","2","","","CC BY-SA 4.0"
"61409425","1","61414644","","2020-04-24 13:23:10","","0","740","<p>This code adds all the data in a single array. In HomeViev I use to Foreach and I added to data to list. But I have to split the data in two. status collection has two type ""active"" and ""closed"" but I don't know how can I filter</p>

<pre><code>import SwiftUI
import Combine
import Firebase

let dbCollection = Firestore.firestore().collection(""Signals"")

class FirebaseSession : ObservableObject {

    @Published var session: User? { didSet { self.didChange.send(self) }}
    @Published var data = [Signal]()

    var didChange = PassthroughSubject&lt;FirebaseSession, Never&gt;()
    var handle: AuthStateDidChangeListenerHandle?


    func listen () {
        handle = Auth.auth().addStateDidChangeListener { (auth, user) in
            if let user = user {
                print(""Got user: \(user)"")
                self.session = User(uid: user.uid, email: user.email)
                self.readData()
            } else {
                self.session = nil
            }
        }
    }

    func readData() {
        dbCollection.addSnapshotListener { (documentSnapshot, err) in
            if err != nil {
                print((err?.localizedDescription)!)
                return
            }else {
                print(""read data success"")
            }

            documentSnapshot!.documentChanges.forEach { i in
</code></pre>

<p>// Read real time created data from server</p>

<pre><code>            if i.type == .added {
                let id = i.document.documentID
                let symbol = i.document.get(""symbol"") as? String ?? """"
                let status = i.document.get(""status"") as? String ?? """"
                self.data.append(Signal(id: id, symbol: symbol, status: status))
            }
</code></pre>

<p>// Read real time modify data from server</p>

<pre><code>            if i.type == .modified {
                self.data = self.data.map { (eachData) -&gt; Signal in
                    var data = eachData
                    if data.id == i.document.documentID {
                        data.symbol = i.document.get(""symbol"") as! String
                        data.status = i.document.get(""status"") as? String ?? """"
                        return data
                    }else {
                        return eachData
                    }
                }
            }
</code></pre>

<p>// When data is removed...</p>

<pre><code>            if i.type == .removed {
                let id = i.document.documentID
                for i in 0..&lt;self.data.count{
                    if self.data[i].id == id{
                        self.data.remove(at: i)
                        return
                    }
                }
            }
        }
    }
}
</code></pre>

<p>}</p>
","13268651","","209103","","2020-04-24 14:44:32","2020-04-25 12:38:23","Filter Firebase Data SwiftUI","<swift><firebase><google-cloud-firestore><swiftui>","1","0","","","","CC BY-SA 4.0"
"61447762","1","64192666","","2020-04-26 20:37:38","","3","414","<p>I have a list with selecting rows and a search bar. <strong>Search bar freezes up the list</strong>, but I fixed that using <code>id(UUID())</code></p>
<p>It created another problem, in which when user taps on a row, <strong>scroll jumps to top</strong>. Sometimes, when selecting few rows it <strong>crashes</strong> with this error: <code>precondition failure: attribute failed to set an initial value: 96</code></p>
<pre><code>struct ContentView: View {

@ObservedObject var viewModel = ViewModel()
@State private var searchText: String = &quot;&quot;
@State private var selected = Set&lt;Model&gt;()

var body: some View {
    VStack {
        SearchBar(text: $searchText, placeholder: &quot;Search&quot;)
        List(
            viewModel.strings.filter({ searchText.isEmpty ? true : $0.title.lowercased().contains(searchText.lowercased()) })
        , selection: $selected) { model in
            MultipleSelectionRow(selectedItems: self.$selected, model: model)
        }
        .id(UUID()) /// This line causes strange behaviour.
    }
  }
}
</code></pre>
<p>The full project is available on <a href=""https://gitlab.com/dosboxd/question"" rel=""nofollow noreferrer"">GitLab</a> with other screencasts and files like selection view, search bar and viewModel.</p>
<p><a href=""https://i.stack.imgur.com/2oybe.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2oybe.gif"" alt=""Screencast shows jumping scroll view"" /></a></p>
","11318219","","11318219","","2020-10-04 08:39:31","2020-10-04 08:42:07","SwiftUI: List scrolls up on selection of a row when there's `.id(UUID())`","<ios><swift><swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"61465392","1","61466234","","2020-04-27 18:02:00","","1","79","<p>For my understanding, I've written the following code which expands / collapses a section inside of a list.</p>

<pre><code>struct WORKING_CollapsableListView: View {
  @State var sectionExpansionStates = [true, true, true]

  var body: some View {
    VStack {
      List {
          Section(header: CollapsableSectionHeader(expansionState: self.$sectionExpansionStates[0])) {
            if self.sectionExpansionStates[0] {
              ForEach(0..&lt;10) { item in
                Text(""\(item) is \(self.sectionExpansionStates[0] ? ""Expanded"" : ""Collapsed"")"")
                  .frame(height: self.sectionExpansionStates[0] ? 10 : 10)
              }
            }
          }

        Section(header: CollapsableSectionHeader(expansionState: self.$sectionExpansionStates[1])) {
          if self.sectionExpansionStates[1] {
            ForEach(0..&lt;10) { item in
              Text(""\(item) is \(self.sectionExpansionStates[1] ? ""Expanded"" : ""Collapsed"")"")
                .frame(height: self.sectionExpansionStates[1] ? 10 : 10)
            }
          }
        }
        Section(header: CollapsableSectionHeader(expansionState: self.$sectionExpansionStates[2])) {
          if self.sectionExpansionStates[2] {
            ForEach(0..&lt;10) { item in
              Text(""\(item) is \(self.sectionExpansionStates[2] ? ""Expanded"" : ""Collapsed"")"")
                .frame(height: self.sectionExpansionStates[2] ? 10 : 10)
            }
          }
        }
      }
    }
  }
}

struct CollapsableSectionHeader: View {
  @Binding var expansionState: Bool

  var body: some View {
    Button(action: {
      self.expansionState.toggle()
    }) {
      Text(""HEADER: \(expansionState ? ""Expanded"" : ""Collapsed"")"")
        .bold()
    }
  }
}
</code></pre>

<p>This works as expected. However the following code does NOT work. All I've done is replaced the multiple sections with a <code>ForEach</code>. This code should be identical in its behavior, but nothing happens when I tap on the section headers. What am I missing? It's as though the binding isn't working.</p>

<pre><code>struct NOT_WORKING_CollapsableListView: View {
  @State var sectionExpansionStates = [true, true, true]

  var body: some View {
    VStack {
      List {
        ForEach(0 ..&lt; 3) { section in
          Section(header: CollapsableSectionHeader(expansionState: self.$sectionExpansionStates[section])) {
            if self.sectionExpansionStates[section] {
              ForEach(0..&lt;10) { item in
                Text(""\(item) is \(self.sectionExpansionStates[section] ? ""Expanded"" : ""Collapsed"")"")
                  .frame(height: self.sectionExpansionStates[section] ? 10 : 10)
              }
            }
          }
        }
      }
    }
  }
}
</code></pre>
","3900270","","","","","2022-07-03 07:49:09","Binding in SwiftUI fails to work inside of a loop","<xcode><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"61469571","1","61472904","","2020-04-27 22:33:07","","1","280","<p>I have a logon screen followed by an overview screen. When the user is successful at logon, the logon response sends back a list of items, which I want to display on the subsequent overview screen.</p>

<p>I can see the response being successfully mapped but the overview view is not receiving any update to the @ObservedObject. I could be missing something obvious but I've been through a bunch of articles and haven't managed to get anything working. Any help appreciated!</p>

<p><strong>Logon view</strong></p>

<pre><code>import SwiftUI

struct LogonView: View {

    @State private var username: String = """"
    @State private var password: String = """"
    @State private var inputError: Bool = false
    @State private var errorMessage: String = """"
    @State private var loading: Bool? = false
    @State private var helpShown: Bool = false
    @State private var successful: Bool = false


    //MARK:- UIView
    var body: some View {

        NavigationView {

            VStack {

                VStack {
                    TextField(""Username"", text: $username)
                        .padding(.horizontal)
                        .disabled(loading! ? true : false)
                    Rectangle()
                        .frame(height: 2.0)
                        .padding(.horizontal)
                        .foregroundColor(!inputError ? Color(""SharesaveLightGrey"") : Color(""SharesaveError""))
                        .animation(.easeInOut)
                }.padding(.top, 80)


                VStack {
                    SecureField(""Password"", text: $password)
                        .padding(.horizontal)
                        .disabled(loading! ? true : false)
                    Rectangle()
                        .frame(height: 2.0)
                        .padding(.horizontal)
                        .foregroundColor(!inputError ? Color(""SharesaveLightGrey"") : Color(""SharesaveError""))
                        .animation(.easeInOut)
                }.padding(.top, 40)



                if (inputError) {
                    HStack {
                        Text(errorMessage)
                            .padding(.top)
                            .padding(.horizontal)
                            .foregroundColor(Color(""SharesaveError""))
                            .animation(.easeInOut)
                            .lineLimit(nil)
                            .font(.footnote)
                        Spacer()
                    }
                }


                SharesaveButton(action: {self.submit(user: self.username, pass: self.password)},
                       label: ""Log on"",
                       loading: $loading,
                       style: .primary)
                    .padding(.top, 40)
                .animation(.interactiveSpring())


                NavigationLink(destination: OverviewView(), isActive: $successful) {
                    Text("""")
                }

                Spacer()

            }
            .navigationBarTitle(""Hello."")
            .navigationBarItems(
                trailing: Button(action: { self.helpShown = true }) {
                     Text(""Need help?"").foregroundColor(.gray)
                })
                .sheet(isPresented: $helpShown) {
                    SafariView( url: URL(string: ""http://google.com"")! )
            }

        }
    }


    //MARK:- Functions
    private func submit(user: String, pass: String) {

        loading = true
        inputError = false
        let resultsVM = ResultsViewModel()

        resultsVM.getGrants(user: user, pass: pass,

        successful: { response in
            self.loading = false
            if ((response) != nil) { self.successful = true }
        },

        error: { error in
            self.inputError = true
            self.loading = false
            self.successful = false
            switch error {
            case 401:
                self.errorMessage = ""Your credentials were incorrect""
            default:
                self.errorMessage = ""Something went wrong, please try again""
            }
        },

        failure: { fail in
            self.inputError = true
            self.loading = false
            self.successful = false
            self.errorMessage = ""Check your internet connection""
        })
    }
}

</code></pre>

<p><strong>Results View Model</strong></p>

<pre><code>import Foundation
import Moya
import Combine
import SwiftUI

class ResultsViewModel: ObservableObject {

    @Published var results: Results = Results()

    func getGrants(
        user: String,
        pass: String,
        successful successCallback: @escaping (Results?) -&gt; Void,
        error errorCallback: @escaping (Int) -&gt; Void,
        failure failureCallback: @escaping (MoyaError?) -&gt; Void
        )
    {
        let provider = MoyaProvider&lt;sharesaveAPI&gt;()

        provider.request(.getSharesave(username: user, password: pass)) { response in

            switch response.result {

            case .success(let value):
                do {
                    let data = try JSONDecoder().decode(Results.self, from: value.data)
                    self.results = data
                    successCallback(data)

                } catch {
                    let errorCode = value.statusCode
                    errorCallback(errorCode)
                }

            case .failure(let error):
                failureCallback(error)
            }
        }
    }

}
</code></pre>

<p><strong>Overview View</strong></p>

<pre><code>import SwiftUI
import Combine

struct OverviewView: View {

    @ObservedObject var viewModel: ResultsViewModel = ResultsViewModel()

    var body: some View {

        let text = ""\(self.viewModel.results.market?.sharePrice ?? 0.00)""

        return List {
            Text(text)
        }           
    }
}
</code></pre>
","13420081","","","","","2020-04-28 04:57:02","SwiftUI/Combine no updates to @ObservedObject from @Published","<ios><swift><swiftui><combine><observedobject>","2","0","","","","CC BY-SA 4.0"
"61471559","1","61496925","","2020-04-28 02:17:38","","0","1524","<p>I'm trying to wrap my head around Combine, and as I refactor code I'm running into some confusion when I try to re-compose to avoid repeating myself.</p>

<p>In this case, I have a value I want to update any time:</p>

<ul>
<li>A specific subject changes</li>
<li>The app comes to the foreground</li>
<li>A 3-second refresh timer fires</li>
</ul>

<p>Since the 3-second refresh timer doesn't publish anything until the first time it fires, I'm assuming I need multiple publishers.</p>

<p>I'm always only using the value from the subject, and ignoring any values sent from the foreground notification and timer.</p>

<p>Here is some example code, where I am processing the value based on only one publisher:</p>

<pre><code>import UIKit
import Combine

class DataStore {

    @Published var fillPercent: CGFloat = 0

    private var cancellables: [AnyCancellable] = []

    // how much the glass can hold, in milliliters
    private let glassCapacity: Double = 500

    // how full the glass is, in milliliters
    private var glassFillLevelSubject = CurrentValueSubject&lt;Double,Never&gt;(250)

    // a publisher that fires every three seconds
    private let threeSecondTimer = Timer
        .publish(every: 3,
                 on: RunLoop.main,
                 in: .common)
        .autoconnect()

    // a publisher that fires every time the app enters the foreground
    private let willEnterForegroundPublisher = NotificationCenter.default
        .publisher(for: UIApplication.willEnterForegroundNotification)

    init() {
        // publisher that fires any time the glass level changes or three second timer fires
        let glassLevelOrTimerPublisher = Publishers.CombineLatest(glassFillLevelSubject, threeSecondTimer)
            // is there shorthand to only return the first item? like .map{ $0 }?
            .map { glassFillLevel, timer -&gt; Double in
                return glassFillLevel
            }
            .eraseToAnyPublisher()

        // publisher that fires any time the glass level changes or three second timer fires
        let glassLevelOrForegroundPublisher = Publishers.CombineLatest(glassFillLevelSubject, willEnterForegroundPublisher)
            .map{ glassFillLevel, notification -&gt; Double in
                return glassFillLevel
            }
            .eraseToAnyPublisher()

        // how can I define map and everything after it as something, and then subscribe it to the two publishers above?
        glassLevelOrTimerPublisher
            .map{ fillLevelInMilliliters in

                let fillPercent = fillLevelInMilliliters / self.glassCapacity

                return CGFloat(fillPercent)
            }
            .assign(to: \.fillPercent, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>

<p>I think what I want to do here is somehow separate out <code>.map</code> and everything after it, and somehow subscribe that to both publishers above.</p>

<p>I tried this, as a way to isolate everything after <code>.map</code> to make it reusable:</p>

<pre><code>    let fillPercentStream = Publishers.Map{ fillLevelInMilliliters in

        let fillPercent = fillLevelInMilliliters / self.glassCapacity

            return CGFloat(fillPercent)
        }
        .assign(to: \.fillPercent, on: self)
        .store(in: &amp;cancellables)
</code></pre>

<p>But that gave me an error that said <code>Missing argument for parameter 'upstream' in call</code> so I tried adding something for that parameter, and ended up with this:</p>

<pre><code>    let fillPercentStream = Publishers.Map(upstream: AnyPublisher&lt;Double,Never&gt;, transform: { fillLevelInMilliliters in

            let fillPercent = fillLevelInMilliliters / self.glassCapacity

            return CGFloat(fillPercent)
        })
        .assign(to: \.fillPercent, on: self)
        .store(in: &amp;cancellables)
</code></pre>

<p>Then, I end up in a chain of compiler errors: <code>Unable to infer complex closure return type; add explicit type to disambiguate</code> and it suggests I specify <code>-&gt; CGFloat</code> in <code>.map</code>, which I added, but then it tells me I should change <code>CGFloat</code> to <code>_</code> and I end up with more errors.</p>

<p>Is this even something I'm supposed to be able to do with Combine? Am I going about this all the wrong way? How can I properly re-use the <code>.map</code> and <code>.assign</code> chain with two different publishers?</p>

<p>I'm somewhat new to Combine and reactive programming in general, so if you have other suggestions to improve how I'm doing everything here please tell me.</p>
","241163","","","","","2020-04-29 07:59:59","Swift Combine: How can I create a reusable Publishers.Map to connect to multiple upstream Publishers?","<ios><combine>","1","0","","","","CC BY-SA 4.0"
"61482485","1","61482723","","2020-04-28 14:20:23","","1","1910","<p>I am trying to refactor some code where I am currently mixing a Combine publisher with a callback closure.</p>

<p>The code does a login request to a REST endpoint. On failure, I want the caller of the function to receive the error payload (a challenge), on success, the caller doesn't need to do anything. So it's a bit of a weird situation where the caller is ONLY interested in the error.</p>

<p>Currently I am doing it like this (simplified code):</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

struct Challenge {
  let id: Int
}

struct MyError: Error {
  let challenge: Challenge?
}

class UserManager {
  @Published var user: String?

  private func doRequest(username: String, password: String) -&gt; AnyPublisher&lt;String, MyError&gt; {
    // In the real world this does a request to a REST API, returning either a User object or an error containing a Challenge.
    return Fail(outputType: String.self, failure: MyError(challenge: Challenge(id: 1)))
      .eraseToAnyPublisher()
  }

  func login(username: String, password: String, next: @escaping (Challenge) -&gt; ()) -&gt; AnyCancellable {
    doRequest(username: username, password: password)
      .catch { error -&gt; AnyPublisher&lt;String, Never&gt; in
        if let challenge = error.challenge {
          next(challenge)
        }
        return Empty().eraseToAnyPublisher()
      }
      .sink(
        receiveValue: { [weak self] user in
          self?.user = user
        }
      )
  }
}

let userManager = UserManager()
var anyCancellables = Set&lt;AnyCancellable&gt;()

userManager.login(username: ""hello"", password: ""world"") { challenge in
  print(""received challenge!"")
}
.store(in: &amp;anyCancellables)
</code></pre>

<p>As you can see, the <code>login</code> function takes a parameter called <code>next</code>, and the publisher itself handles the value inside the <code>sink</code> operator. It doesn't feel good to combine a publisher with a closure like this, ideally I'd like the <code>login</code> function to have this signature:</p>

<pre class=""lang-swift prettyprint-override""><code>func login(username: String, password: String) -&gt; AnyPublisher&lt;Challenge, Never&gt;
</code></pre>

<p>But when I want to write such a function I am running into the problem where I can't use a <code>sink</code> within the <code>login</code> function itself, since that transforms the return type into a <code>AnyCancellable</code>. Basically I want to turn the error into the publisher's output, and also handle the actual value inside the <code>login</code> function. How is this possible?</p>
","403425","","","","","2020-04-28 14:31:07","Swift Combine: turn error into the publisher's output","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"61505904","1","61518872","","2020-04-29 15:46:01","","0","1801","<p>I can't seem to parse my local JSON file that I created for a simple app idea in SwiftUI, and I'm new to app development. I tried some methods but it didn't work. Trying to figure out anything I miss in parsing and making it into ListView. What do I want to do is to parse the language and the sentence, and in this instance, the sentence in my 3 objects contains different amounts of sentences I want to parse, like sentence1, sentence1b, etc. (Edit: Showing you two different code errors and the Json snippet)</p>

<ol>
<li>JSON File Snippet</li>
</ol>

<pre><code>[
    {
    ""name"": ""English"",
    ""id"": 1,
    ""sentence"": {
        ""sentence1"": ""I eat the apple"",
        ""sentence2"": ""It is John's apple"",
        ""sentence3"": ""I give John the apple"",
        ""sentence4"": ""We give him the apple"",
        ""sentence5"": ""He gives it to John"",
        ""sentence6"": ""She gives it to him"",
        ""sentence7"": ""Is the apple red?"",
        ""sentence8"": ""The apples are red"",
        ""sentence9"": ""I must give it to him"",
        ""sentence10"": ""I want to give it to her"",
        ""sentence11"": ""I'm going to know tomorrow"",
        ""sentence12"": ""I can't eat the apple""
    }
},
{
    ""name"": ""Mandarin"",
    ""id"": 2,
    ""sentence"": {
        ""sentence1"": ""我吃的苹果"",
        ""sentence1a"": ""我吃的蘋果"",
        ""sentence1b"": ""Wǒ chī de píngguǒ"",
        ""sentence2"": ""之是约翰的苹果"",
        ""sentence2a"": ""之是約翰的蘋果"",
        ""sentence2b"": ""Zhī shì Yuēhàn de píngguǒ"",
        ""sentence3"": ""我给约翰的苹果"",
        ""sentence3a"": ""我給約翰的蘋果"",
        ""sentence3b"": ""Wǒ gěi Yuēhàn de píngguǒ"",
        ""sentence4"": ""我们给约翰的苹果"",
        ""sentence4a"": ""我們給約翰的蘋果"",
        ""sentence4b"": ""Wǒ men gěi Yuēhàn de píngguǒ"",
        ""sentence5"": ""他把它交给约翰"",
        ""sentence5a"": ""他把它交給約翰"",
        ""sentence5b"": ""Tā bǎ tā jiāo gěi Yuēhàn"",
        ""sentence6"": ""她给了它"",
        ""sentence6a"": ""她給了它"",
        ""sentence6b"": ""Tā gěi le tā"",
        ""sentence7"": ""苹果是红色的吗?"",
        ""sentence7a"": ""蘋果是紅色的嗎?"",
        ""sentence7b"": ""Píngguǒ shì hóngsè de ma?"",
        ""sentence8"": ""苹果是红色的"",
        ""sentence8a"": ""苹果是红色的"",
        ""sentence8b"": ""Píngguǒ shì hóngsè de"",
        ""sentence9"": ""我必须给他"",
        ""sentence9a"": ""我必須給他"",
        ""sentence9b"": ""Wǒ bìxū gěi tā"",
        ""sentence10"": ""我想给他"",
        ""sentence10a"": ""我想給他"",
        ""sentence10b"": ""Wǒ xiǎng gěi tā"",
        ""sentence11"": ""我明天要知道"",
        ""sentence11a"": ""我明天要知道"",
        ""sentence11b"": ""Wǒ míngtiān yào zhīdào"",
        ""sentence12"": ""我不吃的苹果"",
        ""sentence12a"": ""我不吃的蘋果"",
        ""sentence12b"": ""Wǒ bù chī de píngguǒ""
    }
},
{
    ""name"": ""French"",
    ""id"": 3,
    ""sentence"": {
        ""sentence1"": ""Je mange la pomme"",
        ""sentence2"": ""C’est la pomme de John"",
        ""sentence3"": ""Je donne la pomme à John"",
        ""sentence4"": ""On lui donne la pomme"",
        ""sentence5"": ""Il la donne à John"",
        ""sentence6"": ""Elle la lui donne"",
        ""sentence7"": ""Est-ce que la pomme est rouge? or Elle est rouge, la pomme?"",
        ""sentence8"": ""Les pommes est rouges"",
        ""sentence9"": ""Je dois la lui donner"",
        ""sentence10"": ""Je veux la lui donner"",
        ""sentence11"": ""Je le saurai demain"",
        ""sentence12"": ""Je ne peux pas manger la pomme""
    }
}
]
</code></pre>

<ol start=""2"">
<li>Attempt error 1 - Using UIKit</li>
</ol>

<pre><code>struct AppData: Codable {

    var name: String
    var id: Int
    var sentence: String
}

public class DataLoader {

    @Published var appData = [AppData]()

    init() {
        load()
        sort()
    }

    func load() {

        if let fileLocation = Bundle.main.url(forResource: ""twelveData"", withExtension: ""json"") {

            // do catch in case of error
            do {
                let data = try Data(contentsOf: fileLocation)
                let jsonDecoder = JSONDecoder()
                let dataFromJson = try JSONDecoder.decode([AppData].self, from: data)

                self.appData = dataFromJson
            } catch {
                print(error)
            }
        }
    }
    func sort(){
        self.appData = self.appData.sorted(by: {$0.id &lt; $1.id})
    }
}
</code></pre>

<ol start=""3"">
<li>Attempt error 2</li>
</ol>

<pre><code>import SwiftUI
import Foundation
import Combine

struct TwelveData: Codable, Identifiable {
    public var id: Int
    public var name: String
    public var sentence: String

    enum CodingKeys: String, CodingKey {
        case id = ""id""
        case name = ""language""
        case sentence = ""sentence""
    }
}

class TwelveSentences: ObservableObject {
    @Published var twelveData = [TwelveData]()

    init() {
        guard let path = Bundle.main.url(forResource: ""twelveData"", withExtension: ""json"") else { return }
        do {
            let data = try Data(contentsOf: path)
            DispatchQueue.main.async {
                self.twelveData = try JSONDecoder().decode([TwelveData].self, from: data)
            }
        } catch {
            print(""error:\(error)"")
        }
    }
}

struct ContentView: View {
    @ObservedObject var fetch = TwelveData()

    var body: some View {
        NavigationView {
            List(fetch.TwelveData) { TwelveData in
                VStack {
                    Text(TwelveData.name)

            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
}
</code></pre>
","13434388","","13434388","","2020-04-30 04:22:27","2020-04-30 13:43:23","How can I parse a local JSON file to a ListView in SwiftUI? New to app development here","<ios><swift><parsing><listview><swiftui>","2","3","","","","CC BY-SA 4.0"
"61516063","1","61517142","","2020-04-30 04:42:26","","0","2137","<p>Trying to update the mapview of the Project 14 of 100daysOfSwiftUI to show my current location, the problem i can´t zoom in move around</p>

<p>i have this code i add <code>@Binding var currentLocation : CLLocationCoordinate2D</code> and <code>view.setCenter(currentLocation, animated: true)</code> to my MapView so i have a button that send thats value and the view actually move so slow to the location but then i can move away anymore</p>

<pre><code>import SwiftUI
import MapKit

struct MapView: UIViewRepresentable {

    @Binding var centerCoordinate: CLLocationCoordinate2D
    @Binding var selectedPlace: MKPointAnnotation?
    @Binding var showingPlaceDetails: Bool
    @Binding var currentLocation : CLLocationCoordinate2D

    var annotations: [MKPointAnnotation]

    func makeUIView(context: Context) -&gt; MKMapView {
        let mapView = MKMapView()
        mapView.delegate = context.coordinator
        return mapView
    }

    func updateUIView(_ view: MKMapView, context: Context) {

        if annotations.count != view.annotations.count {
            view.removeAnnotations(view.annotations)
            view.addAnnotations(annotations)
        }

        view.setCenter(currentLocation, animated: true)

    }

    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self)
    }

 class Coordinator: NSObject, MKMapViewDelegate{

    var parent: MapView
    init(_ parent: MapView) {
        self.parent = parent
    }

    func mapViewDidChangeVisibleRegion(_ mapView: MKMapView) {
         parent.centerCoordinate = mapView.centerCoordinate
     }

     func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -&gt; MKAnnotationView? {
         let identifier = ""PlaceMark""
         var annotationView = mapView.dequeueReusableAnnotationView(withIdentifier: identifier)
         if annotationView == nil {
             annotationView = MKPinAnnotationView(annotation: annotation, reuseIdentifier: identifier)
             annotationView?.canShowCallout = true
             annotationView?.rightCalloutAccessoryView = UIButton(type: .detailDisclosure)

         } else {
             annotationView?.annotation = annotation
         }

         return annotationView
     }

     func mapView(_ mapView: MKMapView, annotationView view: MKAnnotationView, calloutAccessoryControlTapped control: UIControl) {
         guard let placemark = view.annotation as? MKPointAnnotation else {return}
         parent.selectedPlace = placemark
         parent.showingPlaceDetails = true

     }

    }
}
</code></pre>

<p>an this is my swiftUI view</p>

<pre><code>...
    @State private var currentLocation = CLLocationCoordinate2D()

    var body: some View {
        ZStack{

            MapView(centerCoordinate: $centerCoordinate, selectedPlace: $selectedPlace, showingPlaceDetails: $showingPlaceDetails, currentLocation: $currentLocation ,  annotations: locations)
           // MapView(centerCoordinate: $centerCoordinate, selectedPlace: $selectedPlace, showingPlaceDetails: $showingPlaceDetails, annotations: locations)
                .edgesIgnoringSafeArea(.all)
            VStack{
                Spacer()
                HStack{
                    Spacer()
                    Button(action: {
                        self.getCurrentLocation()
                    }){
                        ButtonIcon(icon: ""location.fill"")
                    }
                }
                .padding()
            }
        }
        .onAppear(perform: getCurrentLocation)
    }

    func getCurrentLocation() {

        let lat = locationManager.lastLocation?.coordinate.latitude ?? 0
        let log = locationManager.lastLocation?.coordinate.longitude ?? 0

        self.currentLocation.latitude = lat
        self.currentLocation.longitude = log

    }
    ...
</code></pre>

<p><em>UPDATE</em></p>

<p>thanks for the support I using this class to call <code>locationManager.requestWhenInUseAuthorization()</code></p>

<pre><code>import Foundation
import CoreLocation
import Combine

class LocationManager: NSObject, ObservableObject {

    override init() {
        super.init()
        self.locationManager.delegate = self
        self.locationManager.desiredAccuracy = kCLLocationAccuracyBest
        self.locationManager.requestWhenInUseAuthorization()
        self.locationManager.startUpdatingLocation()
    }

    @Published var locationStatus: CLAuthorizationStatus? {
        willSet {
            objectWillChange.send()
        }
    }

    @Published var lastLocation: CLLocation? {
        willSet {
            objectWillChange.send()
        }
    }

    var statusString: String {
        guard let status = locationStatus else {
            return ""unknown""
        }

        switch status {
        case .notDetermined: return ""notDetermined""
        case .authorizedWhenInUse: return ""authorizedWhenInUse""
        case .authorizedAlways: return ""authorizedAlways""
        case .restricted: return ""restricted""
        case .denied: return ""denied""
        default: return ""unknown""
        }

    }

    let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()

    private let locationManager = CLLocationManager()
}

extension LocationManager: CLLocationManagerDelegate {

    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        self.locationStatus = status
        print(#function, statusString)
    }

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        self.lastLocation = location
        print(#function, location)
    }

}

</code></pre>

<p>i just want to center my mapview on my current location when i press the button</p>
","7195689","","7195689","","2020-04-30 16:33:10","2020-04-30 17:47:59","Update MapView with current location on SwiftUI","<swift><swiftui><mkmapview>","1","2","","","","CC BY-SA 4.0"
"61520841","1","61521049","","2020-04-30 10:04:23","","1","1530","<p>Sometimes my viewmodel uses a <code>@Published</code> property or a <code>PassthroughSubject</code>, but I don't want this to be writeable to the outside world. Easy enough, turn it into a public <code>AnyPublisher</code> and keep the writable one private, like this:</p>

<pre class=""lang-swift prettyprint-override""><code>class ViewModel {
  @Published private var _models = [""hello"", ""world""]

  var models: AnyPublisher&lt;[String], Never&gt; {
    return $_models.eraseToAnyPublisher()
  }
}

let viewModel = ViewModel()
viewModel.models.sink { print($0) }
</code></pre>

<p>But what if you want to be able to read the value ""on demand"" as well? For example for this situation:</p>

<pre class=""lang-swift prettyprint-override""><code>extension ViewController: UICollectionViewDelegate {
  func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
    print(viewModel.models[indexPath.row])
  }
}

</code></pre>

<p>Obviously, the above code doesn't work. </p>

<p>I thought about using a <code>CurrentValueSubject</code>, but its value is writable too, plus I'm having a hard time turning a Publisher into a CurrentValueSubject anyway. </p>

<p>My current solution is to add something like this on the viewmodel:</p>

<pre class=""lang-swift prettyprint-override""><code>class ViewModel {
  @Published private var _models = [""hello"", ""world""]
  @Published var selectedIndex: Int?

  var models: AnyPublisher&lt;[String], Never&gt; {
    return $_models.eraseToAnyPublisher()
  }

  var selectedModel: AnyPublisher&lt;String, Never&gt; {
    return models.combineLatest($selectedIndex.compactMap { $0 }).map { value, index in
      value[index]
    }.eraseToAnyPublisher()
  }
}

let viewModel = ViewModel()
viewModel.models.sink { print($0) }

viewModel.selectedModel.sink { print($0) }
viewModel.selectedIndex = 1
</code></pre>

<p>But it's a bit of a chore to add the <code>selectedIndex</code> property, the <code>selectedModel</code> publisher, set the selectedIndex and subscribe to the publisher.. all because I want to be able to read the current value of <code>viewModel.models</code> (and not have it writable).</p>

<p>Any better solutions?</p>
","403425","","","","","2020-04-30 10:15:53","Swift Combine: turn a publisher into a read-only CurrentValueSubject","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"61540210","1","61545671","","2020-05-01 09:51:29","","-1","772","<p>I have a Boolean property with published, then I subscribe to that publisher, every time the boolean value changed, my publisher sends a new value</p>

<pre><code>@Published var booleanProperty: Bool = false
let subscription = $booleanProperty
     .sink { newBool in
        print(newBool)
     }
</code></pre>

<p>my question is, is there an <strong>operator</strong> to ignoring the publishing value if it was similar to the latest one.</p>

<p>like publisher send [true,true, false, false]
I just get [true,false]</p>
","13446911","","","","","2020-05-01 15:37:51","Ignore last value if it was similar to one before in, Operator Combine framework","<ios><swift><combine>","1","3","","","","CC BY-SA 4.0"
"61540292","1","61540669","","2020-05-01 09:58:31","","1","455","<p>I've got a <code>URLSession.shared.dataTaskPublisher</code>, which I store in a Set of <code>AnyCancellable</code>-s. When I receive a value and after that the completion, I want this AnyCancellable to be removed from the Set.</p>

<p>How do I identify this certain AnyCancellable and how do I remove it? Or what is the best way to handle these cases? I checked and it doesn't automatically get removed from the bag once I receive a completion value.</p>

<pre><code>class RandomClass {
    private var cancellableBag: Set&lt;AnyCancellable&gt;()

    func someMethod() {
        let request = URLRequest(...)
        URLSession.shared.dataTaskPublisher(for: request)
            .sink(...)
            .store(in: &amp;self.cancellableBag)
    }
}
</code></pre>
","7761488","","","","","2020-05-01 10:23:48","How do I cancel one certain AnyCancellable in a Set<AnyCancellable>?","<ios><swift><macos><combine>","1","0","","","","CC BY-SA 4.0"
"61553264","1","61579804","","2020-05-02 01:18:09","","21","8070","<p>I'm just learning how to use Combine. I have experience with Rx (RxSwift and RxJava) and I'm noticing that it's quite similar.</p>

<p>However, one thing that is quite different (and kind of annoying) is that the <code>Publisher</code> protocol doesn't use generics for its <code>Output</code> and <code>Failure</code> types; it uses associated types instead.</p>

<p>What this means is that I can't specify a polymorphic <code>Publisher</code> type (such as <code>Publisher&lt;Int, Error&gt;</code>) and simply return any type that conforms to <code>Publisher</code> with those types. I need to use <code>AnyPublisher&lt;Int, Error&gt;</code> instead, and I am forced to include <code>eraseToAnyPublisher()</code> all over the place.</p>

<p>If this is the only option, then I'll put up with it. However, I also recently learned about opaque types in Swift, and I'm wondering if I might be able to use them to get around this.</p>

<p>Is there a way for me to have, say, a function that returns <code>some Publisher</code> and use specific types for <code>Output</code> and <code>Failure</code>?</p>

<p>This seems like a perfect case for opaque types, but I can't figure out if there's a way for me to both use an opaque type and specify the associated types.</p>

<p>I'm picturing something like this:</p>

<pre class=""lang-swift prettyprint-override""><code>func createPublisher() -&gt; some Publisher where Output = Int, Failure = Error {
    return Just(1)
}
</code></pre>
","1234443","","77567","","2020-05-03 18:47:11","2021-05-27 18:14:51","Is there a way to avoid using AnyPublisher/eraseToAnyPublisher all over the place?","<swift><combine><opaque-types>","3","2","8","","","CC BY-SA 4.0"
"61557327","1","61572405","","2020-05-02 09:45:38","","4","2067","<p>Fairly new to Combine.
A common scenario using access tokens and refresh token.</p>

<p>You get a 401 and you need to handle it (call some service to refresh the token) before retrying the initial call again </p>

<pre><code>func dataLoader(backendURL: URL) -&gt; AnyPublisher&lt;Data, Error&gt; {
    let request = URLRequest(url: backendURL)
    return dataPublisher(for: request)
        // We get here when a request fails
        .tryCatch { (error) -&gt; AnyPublisher&lt;(data: Data, response: URLResponse), URLError&gt; in
          guard error.errorCode == 401 else {  // UPS - Unauthorized request
                throw error
            }

          // We need to refresh token and retry -&gt; HOW?
          // And try again 
          // return dataPublisher(for: request) 
        }
        .tryMap { data, response -&gt; Data in
            guard let httpResponse = response as? HTTPURLResponse,
                httpResponse.statusCode == 200 else {

                throw CustomError.invalidServerResponse
            }
            return data
        }
        .eraseToAnyPublisher()
}
</code></pre>

<p>How would I go about wrapping this ""token refresh service""?</p>
","7544918","","7544918","","2020-05-02 22:18:59","2020-05-03 09:41:41","401 retry mechanism using Combine Publishers","<ios><swift><networking><mobile><combine>","1","2","2","","","CC BY-SA 4.0"
"61568086","1","61568671","","2020-05-03 00:20:11","","0","175","<p>I've got a situation where I'm trying to determine if an arbitrary number of boolean checks (user defined conditionals) are <code>true</code>. It seems like a job for CombineLatest combined with AllSatisfy... the problem being that CombineLatest only supports a fixed number of elements (2, 3 or 4). Is there some pattern other than using repeated 2-element CombineLatest publishers which combine each result with another of the publishers?</p>

<p>Ideally, I'd like something along the lines of:</p>

<p><code>Publishers.CombineLatestMany(arrayOfPublishers).allSatisfy { ... }</code></p>

<p>and not:</p>

<p><code>Publishers.CombineLatest(pubA, pubB).combineLatest(pubC).combineLatest(pubD) ...</code></p>
","630517","","","","","2020-05-03 23:14:26","How to perform an ""all"" operation on an arbitrary number of Bool Publishers in Combine?","<ios><swift><combine>","1","3","","","","CC BY-SA 4.0"
"61571960","1","61572075","","2020-05-03 09:02:18","","4","2735","<p>I'm writing an application using the <code>MVVM</code> pattern. And I'm wondering know how to create the <code>CoreData</code> stack so it can be accessed from various places in my app.</p>
<p>First approach is to create a persistent container in the <code>AppDelegate</code> and then inject this service to my ViewModels (simultaneously passing the <code>managedObjectContext</code> as an environment variable to my Views).</p>
<p>This way, however, accessing context throughout the app is more difficult: e.g. in decoding network responses, as they don't have access to the <code>managedObjectContext</code>:</p>
<pre><code>protocol APIResource {
    associatedtype Response: Decodable
    ...
}

extension APIResource {
    func decode(_ data: Data) -&gt; AnyPublisher&lt;Response, APIError&gt; {
        Just(data)
            // how can I access context here to pass it to JSONDecoder?
            .decode(type: Response.self, decoder: JSONDecoder())
            .mapError { error in
                .parsing(description: error.localizedDescription)
            }
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>The other solution I've seen is to use a singleton. I can access it from anywhere in the project but how can I create it <em>in the right way</em>?</p>
<p>What if I wan't to modify some object in the <em>main</em> and the <em>background</em> queue at the same time? Or what if both queues want to modify the same object?</p>
","8697793","","8697793","","2020-09-25 16:56:56","2020-09-25 16:56:56","Accessing Core Data Stack in MVVM application","<ios><swift><core-data><singleton>","1","2","0","","","CC BY-SA 4.0"
"61599817","1","61601624","","2020-05-04 19:11:16","","2","468","<p>After scouring a few different resources on Combine, including Joseph Heck and Donny Wals's books, I'm close to understanding chaining of DataTaskPublishers but failing in connecting them together into one series of chained operators.  I seem to be getting hung up on the fact that the errors between the output of the first publisher doesn't match the expected input of the second.  Both Publisher extensions work when not connected, so I am sure it is a lack of ability in joining the two.  I would have thought mapError() would have worked but it does not want to compile.</p>

<p>Here's the setup:</p>

<p>Given two custom publishers:</p>

<pre><code>extension Publisher where Output == MKCoordinateRegion, Failure == URLError {

func toRegionDataTask() -&gt; AnyPublisher&lt;URLSession.DataTaskPublisher.Output, URLError&gt; {
    return self
        .flatMap({ region -&gt; URLSession.DataTaskPublisher in
                  ...
                  ... 
                  ...
                  return URLSession.shared.dataTaskPublisher(for: request)       
                  })
        .eraseToAnyPublisher()
    }
}
</code></pre>

<p>and </p>

<pre><code>extension Publisher where Output == [String], Failure == Never {

func toGeographiesDataTask() -&gt;  AnyPublisher&lt;URLSession.DataTaskPublisher.Output, URLError {
    return self
        .setFailureType(to: URLError.self)
        .flatMap({ ids -&gt; URLSession.DataTaskPublisher in
                   ...
                   ...
                   ...
                  return URLSession.shared.dataTaskPublisher(for: request)
                 })
         .eraseToAnyPublisher()
}
</code></pre>

<p>}</p>

<p>I then have a function that tries to chain the two together like so:</p>

<pre><code>   let passthroughSubj = PassthroughSubject&lt;MKCoordinateRegion,URLError&gt;()

    passthroughSubj
    .toRegionDataTask()                                         // returns &lt;DataTaskPublisher, URLError&gt;
    .map { $0.data }                                            // returns &lt;FlatMap, ?&gt;
    .decode(type: ApiResponse.self, decoder:JSONDecoder())      // returns &lt;ApiResonse, ?&gt;
    .map {$0.body.data(using: .utf8)! }                         // returns &lt;Data, ?&gt;
    .decode(type: AmznResponse.self, decoder: JSONDecoder())    // returns &lt;AmznResponse, ?&gt;
    .map ({ response -&gt; [AmznItem] in                           //
                return response.contents                        // returns &lt;[AmznItem], ?&gt;
    })
    .map ({ items -&gt; [String] in                                // returns &lt;[String], Never&gt; ?
            var ids = [String]()
            for item in items {
                    ids.append(item.geoid)
            }
            return ids
            })
//
//        .toGeographiesDataTask()                                  // get error ""Referencing instance method
//        .map { $0.data }                                          // 'toGeographiesDataTask()' on 'Publisher'
//        .decode(type: ApiResponse.self, decoder:JSONDecoder())    // requires the types 'Error' and 'Never'
//        .map {$0.body.data(using: .utf8)! }                       // be equivalent""
//        .decode(type: AmznResponse.self, decoder: JSONDecoder())
//        .map { $0.contents }
//
    .sink(receiveCompletion: { (completion) in
        switch completion {
        case .failure(let error):
            print(error)
        case .finished:
            print(""DONE"")
        }
        }, receiveValue: { data in
           print(data)
        })
    .store(in: &amp;cancellables)

passthroughSubj.send(region1)
</code></pre>

<p>If I uncomment the second custom publisher, I get the error message shown on the right.  My understanding was that the .map was returning &lt;[String],Never> but eventually because the DataTaskPublisher could fail I need to map it to URLError instead.  But no combination of .mapError seems to compile either.</p>

<p>Am I missing something fundamental here?  Seems like an easy problem to fix but I'm not finding anything sticking out.</p>

<p>I have seen examples where you use .flatMap to chain these together but since I am transforming the output of one into an input for the second custom publisher that didn't seem possible.</p>

<p>Any help or pointers would be very welcome!  Thanks.</p>
","1569095","","1569095","","2020-05-04 20:20:51","2020-05-04 21:08:05","How to successfully match Failure mappings between two Publishers (Never and URLError)","<combine>","2","0","1","","","CC BY-SA 4.0"
"61604322","1","61627939","","2020-05-05 01:34:26","","0","1215","<p>I have an app that needs to check a status on a server:</p>

<ul>
<li>every 30 seconds</li>
<li>whenever the app enters the foreground</li>
</ul>

<p>I'm doing this by merging two publishers, then calling <code>flatMap</code> the merged publisher's output to trigger the API request.</p>

<p>I have a function that makes an API request and returns a publisher of the result, also including logic to check the response and throw an error depending on its contents.</p>

<p>It seems that once a <code>StatusError.statusUnavailable</code> error is thrown, the <code>statusSubject</code> stops getting updates. How can I change this behavior so the <code>statusSubject</code> continues getting updates after the error? I want the API requests to continue every 30 seconds and when the app is opened, even after there is an error.</p>

<p>I also have a few other points where I'm confused about my current code, indicated by comments, so I'd appreciate any help, explanation, or ideas in those areas too.</p>

<p>Here's my example code:</p>

<pre><code>import Foundation
import SwiftUI
import Combine

struct StatusResponse: Codable {
    var response: String?
    var error: String?
}

enum StatusError: Error {
    case statusUnavailable
}

class Requester {

    let statusSubject = CurrentValueSubject&lt;StatusResponse,Error&gt;(StatusResponse(response: nil, error: nil))

    private var cancellables: [AnyCancellable] = []

    init() {
        // Check for updated status every 30 seconds
        let timer = Timer
            .publish(every: 30,
                      tolerance: 10,
                      on: .main,
                      in: .common,
                      options: nil)
            .autoconnect()
            .map { _ in true } // how else should I do this to be able to get these two publisher outputs to match so I can merge them?

        // also check status on server when the app comes to the foreground
        let foreground = NotificationCenter.default
            .publisher(for: UIApplication.willEnterForegroundNotification)
            .map { _ in true }

        // bring the two publishes together
        let timerForegroundCombo = timer.merge(with: foreground)

        timerForegroundCombo
            // I don't understand why this next line is necessary, but the compiler gives an error if I don't have it
            .setFailureType(to: Error.self)
            .flatMap { _ in self.apiRequest() }
            .subscribe(statusSubject)
            .store(in: &amp;cancellables)
    }

    private func apiRequest() -&gt; AnyPublisher&lt;StatusResponse, Error&gt; {
        let url = URL(string: ""http://www.example.com/status-endpoint"")!
        var request = URLRequest(url: url)
        request.httpMethod = ""GET""
        request.setValue(""application/json"", forHTTPHeaderField: ""Content-Type"")

        return URLSession.shared.dataTaskPublisher(for: request)
            .mapError { $0 as Error }
            .map { $0.data }
            .decode(type: StatusResponse.self, decoder: JSONDecoder())
            .tryMap({ status in
                if let error = status.error,
                    error.contains(""status unavailable"") {
                    throw StatusError.statusUnavailable
                } else {
                    return status
                }
            })
            .eraseToAnyPublisher()
    }
}
</code></pre>
","241163","","","","","2020-05-06 05:30:09","How can I continue URLSession dataTaskPublisher or another Publisher after error?","<ios><swift><combine>","2","2","","","","CC BY-SA 4.0"
"61612379","1","61612674","","2020-05-05 11:46:56","","2","95","<p>I have a problem in SwiftUI. When I try to launch my simulator, an error occurred.
The simulator launch well but after a few seconds, an error message appears :</p>

<pre><code>Fatal error: No ObservableObject of type UserStore found. A View.environmentObject(_:) for
UserStore may be missing as an ancestor of this view.: file SwiftUI, line 0 2020-05-05
13:08:36.521073+0200 PLAN.YOUR.TRIP[55476:1340155] Fatal error: No ObservableObject of type
UserStore found. A View.environmentObject(_:) for UserStore may be missing as an ancestor
of this view.: file SwiftUI, line 0
(lldb) 
</code></pre>

<p>This come from a file in which I use an other file named UserStore to connect my project to Firebase, this is where the error occurred :</p>

<pre><code> if user.showLogin { //     &lt;--- RIGHT HERE

            ZStack {
                LoginView(showLogin: $showLogin)

                VStack {
                    HStack {

                        Spacer()

                        Image(systemName: ""xmark.circle"")
                            .resizable()
                            .frame(width: 36, height: 36)
                            .foregroundColor(Color(.systemGray6))
                            .background(Color.gray.opacity(0.5))
                            .clipShape(Circle())
                            .padding()
                            .onTapGesture {
                                self.user.showLogin = false
                        }
                    }
               }
          }
</code></pre>

<p>The error says that there is a problem "" No ObservableObject of type UserStore found "" but I've created a file named "" UserStore "" in which I've put this :</p>

<pre><code>import SwiftUI
import Combine

class UserStore: ObservableObject {
    @Published var isLogged = false
    @Published var showLogin = false
    @Published var showReg = false
}
</code></pre>

<p>And to link this to my other file in which I use the @EnvironmentObject like this :</p>

<pre><code>struct Home: View {
    @State var showProfile = false
    @EnvironmentObject var user: UserStore
    @State var showLogin = false
    @State var showReg = false
</code></pre>

<p>I can't understand the error because this exact same code was working yesterday but I've tried to uninstall an extension called "" Hero "" which was unused on my project and a suggestion said me to update my code into swift 5, this what I've done but after this a lot of other error appeared. I decided to recreate a project with the exact same construction and files, reinstall cocoa pods with the same code (without the "" Hero pod "") and the bundle id is the same so this is not a problem between the Firebase and my project ... </p>

<p>I know this content is repetitive here but I've don't find anything working for me in all the other forum.</p>

<p>Sorry for my English which is not the best...</p>

<p>Please Help. Thanks</p>
","13474128","","4667835","","2020-05-05 11:49:17","2020-05-05 12:02:19","Thread 1: Fatal error: No ObservableObject of type UserStore found. A View.environmentObject(_:)","<ios><swift><swiftui>","1","1","","","","CC BY-SA 4.0"
"61641077","1","61641411","","2020-05-06 17:09:37","","0","1076","<p>I was trying to create a dynamic Form using SwiftUI and Combine, that loads options of an input (in the example, <code>number</code>) based on another input (in the example, <code>myString</code>).</p>

<p>The problem is that the Combine stack get executed continuously, making lots of network requests (in the example, simulated by the delay), even if the value is never changed. </p>

<p>I think that the expected behavior is that <code>$myString</code> publishes values only when it changes.</p>

<pre><code>class MyModel: ObservableObject {

    // My first choice on the form
    @Published var myString: String = ""Jhon""

    // My choice that depends on myString
    @Published var number: Int?

    var updatedImagesPublisher: AnyPublisher&lt;Int, Never&gt; {
        return $myString
            .removeDuplicates()
            .print()
            .flatMap { newImageType in
                return Future&lt;Int, Never&gt; { promise in

                    print(""Executing..."")

                    // Simulate network request
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        let newNumber = Int.random(in: 1...200)
                        return promise(.success(newNumber))
                    }
                }
        }
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
    }
}

struct ContentView: View {

    @ObservedObject var model: MyModel = MyModel()

    var body: some View {
        Text(""\(model.number ?? -100)"")
            .onReceive(model.updatedImagesPublisher) { newNumber in
                self.model.number = newNumber
            }
    }
}
</code></pre>
","5928873","","","","","2020-05-06 17:27:45","Combine @Published property send values also when not updated","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"61653848","1","61653980","","2020-05-07 09:01:54","","1","701","<p>I'm passing to TextField published variable </p>

<pre><code>TextField(""First name"", text: $state.firstName)
</code></pre>

<p>I want to control imputes: Ignore spaces, if it's entered from the left</p>

<p>Where and how can I do it?</p>
","1752613","","","","","2020-05-07 09:29:41","Ignore left whitespaces on imput in TextField SwiftUI Combine","<swift><swiftui><textfield><combine>","2","0","2","","","CC BY-SA 4.0"
"61699032","1","61956883","","2020-05-09 15:16:27","","3","181","<p>I don't understand how implementing in SwiftUI a simple picker showing a list of values that retain the selected value switching between different views. I'm able to use the selected value to update the Model via Combine framework by the way.</p>

<p>here's the code, but the <code>onAppear{}</code>/<code>onDisappear{}</code> doesn't work as expected:</p>

<pre><code>struct CompanyView: View {

    @ObservedObject var dataManager: DataManager = DataManager.shared

    @State var selTipoAzienda = 0

    var body: some View {
        VStack {
            companyPhoto
            Text(""Company view"")
            Form {
                Picker(selection: $selTipoAzienda, label: Text(""Tipo Azienda"")) {
                    ForEach(0 ..&lt;  self.dataManager.company.tipoAziendaList.count) {
                        Text(self.dataManager.company.tipoAziendaList[$0])
                    }
                }
            }

            Button(action:  {self.dataManager.cambiaTipoAzienda(tipoAzienda: self.dataManager.company.tipoAziendaList[self.selTipoAzienda]) }) {
                Image(systemName: ""info.circle.fill"")
                    .font(Font.system(size: 28))
                    .padding(.horizontal, 16)
            }
        }
//        .onAppear{
//            self.selTipoAzienda = self.dataManager.company.tipoAziendaList.firstIndex(of: self.dataManager.company.tipoAzienda) ?? 0
//        }
//        .onDisappear{
//            self.dataManager.cambiaTipoAzienda(tipoAzienda: self.dataManager.company.tipoAziendaList[self.selTipoAzienda])
//        }
    }

</code></pre>

<p>I think binding and didSet would be the answer but I don't know how they have to be implemented</p>
","1937003","","12456741","","2020-05-27 00:35:46","2020-05-27 00:35:46","persistent value in a picker changing views in SwiftUI","<swift><forms><picker><combine>","1","1","","","","CC BY-SA 4.0"
"61702864","1","61746224","","2020-05-09 19:55:54","","2","1062","<p>I am trying to use Combine to perform a POST request. When doing my http request that I used before, my Credentials object comes back with status code 200, so all good. But when I am trying to use the Combine framework, it just returns an error. </p>

<pre><code>finished with error [-999] Error Domain=NSURLErrorDomain Code=-999 ""cancelled""
</code></pre>

<p>How to solve this issue to make my Combine POST request works as expected?</p>

<p>My Combine request that doesn't work and need to be fixed:</p>

<pre><code>func demoLogin() -&gt; AnyPublisher&lt;Credentials, Error&gt; {
  let url = URL(string: ""https://web-api/auth/create-demo-account"")!

  var urlRequest = URLRequest(url: url)
  urlRequest.httpMethod = ""POST""

  return URLSession.shared
    .dataTaskPublisher(for: urlRequest)
    .receive(on: DispatchQueue.main)
    .map(\.data)
    .decode(
      type: Credentials.self,
      decoder: JSONDecoder())
    .eraseToAnyPublisher()
}
</code></pre>

<p>So this is where I sink the value:</p>

<pre><code>final class OnboardingViewModel: ObservableObject {

  private var subscriptions = Set&lt;AnyCancellable&gt;()

  func demoLogin() {
    AuthRequest.shared.demoLogin()
      .sink(
        receiveCompletion: { print($0) },
        receiveValue: {
          print(""Receive value:\nLogin: \($0.login)\nToken: \($0.token)"") })
      .store(in: &amp;subscriptions)
  }
}
</code></pre>

<p>This is the SwiftUI view where the button asks for the call:</p>

<pre><code>struct CredentialsButtons: View {

  @ObservedObject var viewModel = OnboardingViewModel()

  var body: some View {
    VStack {
      Button(action: { self.viewModel.demoLogin() }) {
        Text(""Try demo"")
          .font(.subheadline)
          .fontWeight(.medium)
          .foregroundColor(.blue)
      }
    }
  }
}
</code></pre>

<p>My request that works normally:</p>

<pre><code>  func demoLogin(completion: @escaping (NetworkResult&lt;Credentials&gt;) -&gt; Void) {
    let url = URL(string: ""https://web-api/auth/create-demo-account"")!

    var urlRequest = URLRequest(url: url)
    urlRequest.httpMethod = ""POST""

    let dataTask = authSession.dataTask(with: urlRequest) { data, response, error in
      guard let httpResponse = response as? HTTPURLResponse,
        httpResponse.statusCode == 200,
        let jsonData = data else {
          completion(.failure)
          return
      }
      do {
        let credentials = try JSONDecoder().decode(Credentials.self, from: jsonData)
        completion(.success(credentials))
      }
      catch {
        completion(.failure)
      }
    }
    dataTask.resume()
  }
</code></pre>
","10408494","","10408494","","2020-05-10 08:12:16","2020-05-12 07:37:46","Why is my Combine httpMethod post request not working?","<swift><httprequest><combine>","2","6","","","","CC BY-SA 4.0"
"61705304","1","61705737","","2020-05-09 23:43:51","","1","10723","<p>I'm using Combine and it happens to me many times that I have the need to emit Publishers with single values.</p>

<p>For example when I use flat map and I have to return a Publisher with a single value as an error or a single object I use this code, and it works very well:</p>

<pre><code>return AnyPublisher&lt;Data, StoreError&gt;.init(
           Result&lt;Data, StoreError&gt;.Publisher(.cantDownloadProfileImage)
        )
</code></pre>

<p>This creates an AnyPublisher of type <code>&lt;Data, StoreError&gt;</code> and emits an error, in this case: <code>.cantDownloadProfileImage</code></p>

<p>Here a full example how may usages of this chunk of code.</p>

<pre><code>func downloadUserProfilePhoto(user: User) -&gt; AnyPublisher&lt;UIImage?, StoreError&gt; {
        guard let urlString = user.imageURL,
            let url = URL(string: urlString)
            else {
                return AnyPublisher&lt;UIImage?, StoreError&gt;
                    .init(Result&lt;UIImage?, StoreError&gt;
                        .Publisher(nil))
        }
        return NetworkService.getData(url: url)
            .catch({ (_) -&gt; AnyPublisher&lt;Data, StoreError&gt; in
                return AnyPublisher&lt;Data, StoreError&gt;
                    .init(Result&lt;Data, StoreError&gt;
                        .Publisher(.cantDownloadProfileImage))
            })
            .flatMap { data -&gt; AnyPublisher&lt;UIImage?, StoreError&gt; in
                guard let image = UIImage(data: data) else {
                    return AnyPublisher&lt;UIImage?, StoreError&gt;
                        .init(Result&lt;UIImage?, StoreError&gt;.Publisher(.cantDownloadProfileImage))
                }
                return AnyPublisher&lt;UIImage?, StoreError&gt;
                    .init(Result&lt;UIImage?, StoreError&gt;.Publisher(image))
        }
        .eraseToAnyPublisher()
    }
</code></pre>

<p>Is there an easier and shorter way to create an AnyPublisher with a single value inside?</p>

<p>I think I should use the <code>Just()</code> object in somehow, but I can't understand how, because the documentation at this stage is very unclear.</p>
","6747915","","6747915","","2020-05-10 00:03:02","2021-04-10 16:26:25","iOS Swift Combine: Emit Publisher with single value","<ios><swift><combine>","2","1","3","","","CC BY-SA 4.0"
"61716602","1","61716820","","2020-05-10 18:08:30","","3","1309","<p>I have a button that triggers my view state. As I have now added a network call, I would like my view model to replace the @State with its @Publihed variable to perform the same changes. </p>

<p>How to use my @Published in the place of my @State variable?</p>

<p>So this is my SwiftUI view:</p>

<pre><code>struct ContentView: View {

  @ObservedObject var viewModel = OnboardingViewModel()

  // This is the value I want to use as @Publisher
  @State var isLoggedIn = false

  var body: some View {
    ZStack {
      Button(action: {
        // Before my @State was here
        // self.isLoggedIn = true
        self.viewModel.login()
      }) {
        Text(""Log in"")
      }

      if isLoggedIn {
        TutorialView()
      }
    }
  }
}
</code></pre>

<p>And this is my model: </p>

<pre><code>final class OnboardingViewModel: ObservableObject {

  @Published var isLoggedIn = false

  private var subscriptions = Set&lt;AnyCancellable&gt;()

  func demoLogin() {
    AuthRequest.shared.login()
      .sink(
        receiveCompletion: { print($0) },
        receiveValue: {
          // My credentials
          print(""Login: \($0.login)\nToken: \($0.token)"")
          DispatchQueue.main.async {
            // Once I am logged in, I want this
            // value to change my view.
            self.isLoggedIn = true } })
      .store(in: &amp;subscriptions)
  }
}
</code></pre>
","10408494","","","","","2021-07-28 21:15:19","How to swap my @State of my SwiftUI view for my view model @Published variable?","<swiftui><combine><observableobject>","2","0","1","","","CC BY-SA 4.0"
"61718329","1","61718990","","2020-05-10 20:31:25","","1","172","<p>I have a test which verifies that a message is being published when a new device is available: </p>

<pre class=""lang-swift prettyprint-override""><code>let deviceConnectedPublisher = NotificationCenter.default.publisher(for: .deviceAdded)
            .compactMap { $0.object as AnyObject as? ConnectableDevice }

let sink = deviceConnectedPublisher.sink { _ in
    expectation.fulfill()
}
</code></pre>

<p>this works just fine but I have a compiler warning: </p>

<blockquote>
  <p>Initialization of immutable value 'sink' was never used; consider replacing with assignment to '_' or removing it</p>
</blockquote>

<p>However if I take the compiler's advice and change it to</p>

<pre class=""lang-swift prettyprint-override""><code>let _ = deviceConnectedPublisher.sink { _ in
    expectation.fulfill()
}
</code></pre>

<p>then my test times out, and subsequently fails. Is there a better way to be declaring my sink? Is there some way to tell the compiler it's wrong? Should this be filed as a bug? I understand why the compiler thinks that the variable is unused, but it seems like there should be a way to disable the warning in this case --or more likely-- I'm doing something not-as-intended.</p>
","601830","","","","","2020-05-10 21:30:02","Compiler warning for unused immutable sink, but using _ causes test to fail","<swift><swift5><combine>","2","0","","","","CC BY-SA 4.0"
"61742146","1","61742903","","2020-05-12 01:18:53","","8","3206","<p>I'm starting to experiment with SwiftUI and I have a situation where I want the latest combination of 5 sliders. I had everything working with 4 sliders, using <code>CombineLatest4</code>, then realized I need another slider, but there's no <code>CombineLatest5</code>.</p>
<p>Any help appreciated.</p>
<p>To clarify the working 4-slider version:</p>
<pre><code>Publishers
    .CombineLatest4($slider1, $slider2, $slider3, $slider4)
    .debounce(for: 0.3, scheduler: DispatchQueue.main)
    .subscribe(subscriber)
</code></pre>
","4321521","","1974224","","2021-10-26 06:12:05","2022-01-24 17:30:35","SwiftUI and CombineLatest with more than 4 values","<swiftui><combine>","4","0","","","","CC BY-SA 4.0"
"61753570","1","61758399","","2020-05-12 13:55:22","","3","477","<p>In the code below, an array of app objects is used to create an array of publishers which are merged into an array release objects.</p>

<pre class=""lang-swift prettyprint-override""><code>apps.map { latestRelease(app: $0) }.merge()
</code></pre>

<p>Here is how latest release is done.</p>

<pre class=""lang-swift prettyprint-override""><code>func latestRelease(app: App) -&gt; AnyPublisher&lt;Release, Error&gt; {
    do {
        let request = try requestFactory.make(.get, ""apps/\(app.owner.name)/\(app.name)/releases/latest"")

        return publisherFactory.make(for: request)
            .mapError{ $0 as Error }
            .map { data, _ in data }
            .decode(type: Release.self, decoder: decoder)
            .eraseToAnyPublisher()
    } catch {
        return Fail(error: error)
            .eraseToAnyPublisher()
    }
}
</code></pre>

<p>The network requests are done with a factory.</p>

<pre class=""lang-swift prettyprint-override""><code>struct AppCenterPublisherFactory: DataTaskPublisherFactory {
    let session: URLSession

    init(session: URLSession = .shared) {
        session.configuration.httpMaximumConnectionsPerHost = 1
        self.session = session
    }

    func make(for request: URLRequest) -&gt; URLSession.DataTaskPublisher {
        return session.dataTaskPublisher(for: request)
    }
}
</code></pre>

<p>The problem is the release publishers make network requests immediately. This causes the server to return 429 Too Many Requests. How can I queue up URLSession.DataTaskPublisher requests so that only one is made at a time <strong><em>with a delay between each request</em></strong>?</p>
","1298400","","","","","2020-05-12 17:43:09","How can I queue up URLSession.DataTaskPublisher requests so that only one is made at a time?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"61762410","1","61766270","","2020-05-12 21:35:54","","1","148","<p>I am trying to create a DataModel for my SwiftUI Screen.
The problem I am facing is that I use Core NFC to scan a NFCTag (perform some tasks) and then I want to update the SwiftUI Screen. The data fetch/manipulation occurs asynchronous.</p>

<p><strong>View</strong></p>

<pre><code>struct NFCTest: View {

    @EnvironmentObject var nfcController: NFCController


    var body: some View {
        VStack {
            Button(action: {
                self.nfcController.beginScanning()
            }) {
                Text(""Button"")
            }
</code></pre>

<p><strong>NFCController</strong></p>

<pre><code>final class NFCController: UIViewController, ObservableObject {

@Published var someObject :ObjectStruct //someObject contains a @Published var someVar    
//Tag detected
    func doSomeAsyncCalls {
    //calling functions in other swift files. runs async on another thread. Should change someVar at the end of the calculation
    }
</code></pre>

<p>Now the problem is that nested Observable Objects to do not work in SwiftUI. I tried to make an observable var in NFCController and inside that var I created a published var. But the change is not triggered in SwiftUI.</p>

<p>Are there any concepts to solve this async data flow problem?</p>
","558801","","","","","2020-05-13 04:09:02","How to connect asyc data fetch using Core NFC and Swift UI?","<swift><swiftui><combine><core-nfc>","1","1","","","","CC BY-SA 4.0"
"61763286","1","61791588","","2020-05-12 22:46:44","","0","97","<p>I have been using SwiftUI lately, and I have managed to write in ContentView.swift as my rootView, including 2 buttons to change to other ""pages"" or ""screens"" within an app. Currently, I am able to move between Two views in my code. I used ObservableObjects(viewRouter : ViewRouter) in each ""screen"" swift file. I decided to write a third screen to pop up for a user to view. After including the same structures and ways to bring up that view : The Button's Action for the third view is not being ran. <strong>There are no errors in compiling, the app will build!</strong> But, the ThirdScreen is not visible when clicking the button inside FirstScreen.</p>

<p>Here is the Main View ContentView:</p>

<pre><code>
import SwiftUI

struct ContentView: View {
    @State var screen: String = ""FirstScreen"" //Declares the first state
    @EnvironmentObject var viewRouter : ViewRouter //References our other swift file.

    var body : some View {
        VStack {
            if viewRouter.currentScreen == ""FirstScreen"" {
                FirstScreen()
                    } else if viewRouter.currentScreen == ""SecondScreen"" {
                SecondScreen()
                    .transition(.slide)
            } else if viewRouter.currentScreen == ""ThirdScreen"" {
                ThirdScreen()
                    .transition(.opacity)
            }
struct ContentView_Previews: PreviewProvider { //Looks fine, its the previews
    static var previews: some View {
        ContentView().environmentObject(ViewRouter())}}
</code></pre>

<p>Here is the FirstScreen file with its structure below:</p>

<pre><code>import Foundation
import UIKit
import SwiftUI
struct FirstScreen : View {
    @EnvironmentObject var viewRouter : ViewRouter
    var body : some View {
    VStack {
    Button(action: {
            print(""The info button has been clicked."")
        self.viewRouter.currentScreen = ""SecondScreen"" //Heres an action
           }) {
               Image(systemName: ""info"")
                   .padding()
                   .background(Color.green)
                   .font(.largeTitle)
                   .foregroundColor(Color.orange)
                   .frame(width: 300, height: 600)           
           }     
           Button(action: {
               print(""You have erased it."")
            self.viewRouter.currentScreen = ""ThirdScreen"" //This action does not happen.
           }) {
               Image(systemName: ""trash"")
               .padding()
                   .background(Color.red)
                   .font(.largeTitle)
                   .foregroundColor(Color.white)
                   .frame(width: 426, height: 620)
}}}}
struct FirstScreen_previews : PreviewProvider {
    static var previews: some View {
        FirstScreen().environmentObject(ViewRouter())
    }
}
</code></pre>

<p>Here is the code for my ThirdScreen which should be loaded in from ViewRouter and the change from clicking the button from the FirstScreen's Swift file.</p>

<pre><code>import Foundation
import UIKit
import SwiftUI
struct ThirdScreen : View {
    @EnvironmentObject var viewRouter : ViewRouter
    var body : some View {
        VStack {
            Text(""You step a bit off balance"")
                .font(.largeTitle)
                .foregroundColor(Color.red)
            Text(""You stand up, shaking, under a pass"")
                .font(.callout)
            Text(""It looks to be a wrong step. Maybe you head back?"")
                .font(.caption)
                .foregroundColor(Color.gray)
            Button(action :{self.viewRouter.currentScreen = ""FirstScreen""}){
                Image(systemName: ""capslock"" )
                    .frame(width: 209, height: 308)
                    .foregroundColor(Color.green)
}}}}
struct Third_preview : PreviewProvider {
    static var previews: some View {
        ThirdScreen().environmentObject(ViewRouter())
    }
}
</code></pre>

<p>Here is the ViewRouter.swift which works fine to manage screens.</p>

<pre><code>import Foundation
import Combine
import SwiftUI
class ViewRouter: ObservableObject {
    let objectWillChange = PassthroughSubject&lt;ViewRouter, Never&gt;()
    var currentScreen : String = ""FirstScreen"" {
        didSet {
            withAnimation(){
            objectWillChange.send(self)
        }
    }
}
}
</code></pre>

<p>Lastly, my correctly working SecondScreen.swift. This file is probably redundant, but I included it on the off chance that something good is working inside this file. As buttons work inside to change views.</p>

<pre><code>import Foundation
import UIKit
import SwiftUI
struct SecondScreen : View {
    @EnvironmentObject var viewRouter : ViewRouter

    var body : some View {
    VStack { 
 Button(action: {self.viewRouter.currentScreen = ""FirstScreen""}) {
            Image(systemName: ""arrowshape.turn.up.left"" )
            .padding()
            .cornerRadius(18)
                .frame(width: 180, height: 400)
}}}}
struct SecondScreen_previews : PreviewProvider{
    static var previews : some View {
        SecondScreen().environmentObject(ViewRouter())
    }
}
</code></pre>

<p>Thank you extremely for helping me here. I would love to continue making Screen files as the they are below, I just wonder why my third screen isn't pulled up. I will be responding quickly as I continue to troubleshoot this. Thank you!</p>
","13520978","","","","","2020-05-14 07:23:24","Pointing to All Three views inside SwiftUI from a ViewRouter and ObservableObjects or environmentObject's","<swift><view><swiftui><observableobject>","1","2","","","","CC BY-SA 4.0"
"61785359","1","64642330","","2020-05-13 21:41:29","","2","871","<p>I have an AccountService class that holds a User object. The user object gets set async from a network request.
In my UI I'm displaying the user and want to keep changes up to date. I'm using the Swift Combine  Framework to do this.</p>

<h1>Question: Is there a way to avoid nested subscribers on an object?</h1>

<p>I wrote some test code to illustrate this:</p>

<pre class=""lang-swift prettyprint-override""><code>import UIKit
import Combine

class User: ObservableObject, CustomDebugStringConvertible {
    @Published
    var name: String

    init(name: String) {
        self.name = name
    }

    var debugDescription: String {
        return self.name
    }
}

class AccountService {

    @Published
    var user: User? = nil

    var userCancel: AnyCancellable?
    var userContentCancel: AnyCancellable?
    init() {
        self.userCancel = self.$user.sink { (user) in
            print(""Set user: \(String(describing: user))"")

            guard let user = user else { return }
            self.userContentCancel = user.$name.sink { _ in
                print(""new name: \(String(describing: self.user))"")
            }
        }
    }

    func setUseru(user: User) {
        self.user = user
    }

    func changeUserName(name: String) {
        self.user?.name = name
    }
}

let x = AccountService()
x.setUseru(user: User(name: ""Philipp""))
x.changeUserName(name: ""Tom"")
x.setUseru(user: User(name: ""Anna""))
</code></pre>

<p><em>Run in Playgroud Xcode Version 11.4.1, Swift 5</em></p>

<h2>Output</h2>

<pre><code>Set user: nil
Set user: Optional(Philipp)
new name: nil
new name: Optional(Philipp)
Set user: Optional(Anna)
new name: Optional(Tom)
</code></pre>

<p>Ideally I'd like only to listen to <code>self.$user.sink</code> for when the object is set <strong>AND</strong> for when the content of the object changes. 
I've played around with <code>self.objectWillChange.send()</code> when setting the username, but I'm not able to trigger the outer publisher.</p>

<p>I'm looking for a way to get rid of</p>

<pre class=""lang-swift prettyprint-override""><code>guard let user = user else { return }
self.userContentCancel = user.$name.sink { _ in
    print(""new name: \(String(describing: self.user))"")
}
</code></pre>

<p>in my implementation and just drive everything from the same <code>self.$user.sink { (user) in</code> implementation.</p>
","366967","","","","","2020-11-02 08:46:35","Swift Combine, Avoid nested subscribers on optionals","<ios><swift><swift5><combine>","1","4","0","","","CC BY-SA 4.0"
"61802005","1","61802360","","2020-05-14 16:05:16","","3","117","<p>I am currently trying to learn Swift+Combine, but I even fail at replicating a simple tutorial.</p>

<p>My current playground project looks as follows:</p>

<pre><code>import Combine
import Foundation

let future = Future&lt;Int, Never&gt; { promise in
    DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
        print(""hello"")
        promise(.success(1))
    }
}

future.sink(receiveCompletion: { print($0) },
            receiveValue: { print($0) })

print(""end"")

DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
    print(future)
}
</code></pre>

<p>I would have expected as output:</p>

<pre><code>end
hello
1
finished
Combine.Future&lt;Swift.Int, Swift.Never&gt;
</code></pre>

<p>But when I run this code, the output only displays:</p>

<pre><code>end
hello
Combine.Future&lt;Swift.Int, Swift.Never&gt;
</code></pre>

<p>It seems to swallow the whole sink. At first I thought maybe the future was already deleted by the time the DispatchQueue fired its callback, but this does not seem to be the case.</p>

<p>Can someone explain to me what I am doing wrong?</p>
","11936252","","","","","2020-05-14 16:22:14","Future with asynchronous resolve does not fire","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"61803003","1","61803807","","2020-05-14 16:55:42","","4","1819","<p>I would like to have one <code>Subject</code> (similar to <code>CurrentValueSubject</code>) I can publish into, but that validates the value I'm sending. For example, I would like to validate that the input is forced between a range of values, like 1 and 10. If higher than the max, pass the maximum, if lower then the min, pass the minimum.</p>

<p>Please don't tell me to filter the result on the subscribing code because that's what I'm trying to avoid. That duplication.</p>

<p>Pseudo code would be: </p>

<pre class=""lang-swift prettyprint-override""><code>let intSubject = ValidatedValueSubject&lt;Int&gt;(value: 5, min: 1, max: 10)

intSubject.sink { value in  print(value) }

intSubject.send(-10)
intSubject.send(5)
intSubject.send(15)
</code></pre>

<p>I would like this to produce: </p>

<pre><code>5
1
5
10
</code></pre>

<p>Obviously with <code>CurrentValueSubject</code> I can't achieve that effect. 
I tried to create my own custom Subject but I can't seem to make it work. </p>

<p>Something tells me I should look at my problem differently because I guess this is too easy to need a custom <code>Subject</code>.</p>

<p>The use case: </p>

<p>I have a settings class which is updated on a Settings screen, and everywhere else, when the value change I want the screens to react accordingly. The <code>ValidatedValueSubject</code> lives inside this Settings object. </p>

<p>The Settings need to expose the <code>Subject</code> so any screens can react upon changes to the property. </p>

<p>My approach to the custom <code>Subject</code>is as follows:</p>

<pre class=""lang-swift prettyprint-override""><code>final class QualitySubject: Subject {

    public typealias Output = Int
    public typealias Failure = Never

    public private(set) var value: Output
    private let max: Output
    private let min: Output

    init(value: Output, max: Output, min: Output) {
        self.min = min
        self.max = max
        self.value = value
        self.value = validated(value)
    }

    private func validated(_ value: Output) -&gt; Int {
        return max(min, min($0, max))
    }

    var subscription: [???? QualitySubscription ?????] = []

    public func send(_ value: Output) {
        self.value = validated(value)
        subscription.subscriber.receive(value)
    }

    public func send(completion: Subscribers.Completion&lt;Failure&gt;) {
        print(""completion"")
    }

    public func send(subscription: Subscription) {
        print(""send subscription"")
    }


    public func receive&lt;S&gt;(subscriber: S) where S : Subscriber, S.Failure == Failure, S.Input == Output {
        let qualitySubscription = QualitySubscription(value: value, subscriber: subscriber)
        subscriber.receive(subscription: qualitySubscription)

        // I think I should save a reference to the subscription so I could forward new values afterwards (on send method) but I can't because of generic constraints.
    }
}

</code></pre>
","919445","","919445","","2020-05-14 20:52:32","2021-03-25 12:31:25","Swift Combine create a custom Subject","<swift><combine>","2","0","2","","","CC BY-SA 4.0"
"61810575","1","61811165","","2020-05-15 02:12:13","","0","2622","<p>I have attached an onReceive modifier to a view in SwiftUI. The purpose of the subscription is to respond to changes in an @Published property <code>greeting</code>, part of a view Model object.</p>

<p>The view contains a Segmented Picker. The segmented picker uses another property in the view model -- <code>index</code>.</p>

<p>Inexplicably, when user changes the segmented picker selection the onReceive block is called, even though the Publisher <code>greeting</code> has not changed. </p>

<pre><code>
import SwiftUI
import Combine


class Model: ObservableObject {
    @Published var selectedIndex = 0
    @Published var greeting = ""initial""

}

struct ContentView: View {
    @ObservedObject var model: Model = Model()
    let pickerTitles = [""One"", ""Two"", ""Three""]

    var body: some View {
        VStack {
            return Picker(""Options"", selection: $model.selectedIndex) {
                ForEach(0 ..&lt; pickerTitles.count) { index in
                    Text(self.pickerTitles[index])
                }

            }.pickerStyle(SegmentedPickerStyle())
        }
        .onReceive([model.greeting].publisher){str in
            print(str)
        }

    }
}
</code></pre>

<p>What's going on? Above code is the entirety of the codebase. </p>

<p>RE: SUMMARY
I specify a Publisher in .onReceive block. That specified property -- <code>greeting</code> -- never changes. When another property -- <code>index</code> -- is changed by the Picker in the same ObservedObject, the .onReceive block is mysteriously called.</p>

<p><a href=""https://i.stack.imgur.com/8c42b.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8c42b.jpg"" alt=""enter image description here""></a></p>
","4705368","","4705368","","2020-05-15 03:09:38","2020-05-15 03:20:52","Why is onReceive block on SwiftUI View called when Publisher argument doesn't have any new values to emit?","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"61816898","1","61816964","","2020-05-15 10:16:49","","1","62","<p>I'm trying to update a view with a simple Observable pattern, but it doesn't happen for some reason. The Publisher gets updated, but the subscriber doesn't. I've simplified to the code below. When you click the Add button, the view doesn't get updated and also the variable.</p>

<p>I'm using this function (NetworkManager.shared.saveNew()), because I update after a CloudKit notification. If you know a workaround, I'd be pleased to know!</p>

<pre><code>import SwiftUI
import Combine

public class NetworkManager: ObservableObject {
    static let shared = NetworkManager()

    @Published var list = [DataSource]()

    init() {
        self.list = [DataSource(id: ""Hello"", action: [1], link: ""http://hello.com"", year: 2020)]
    }

    func saveNew(item: DataSource) {
        self.list.append(item)

    }
}

struct DataSource: Identifiable, Codable {

    var id: String
    var action: [Int]
    var link: String
    var year: Int

    init(id: String, action: [Int], link: String, year: Int) {
        self.id = id
        self.action = action
        self.link = link
        self.year = year
    }
}


struct ContentView: View {

    @ObservedObject var list = NetworkManager()

    var body: some View {
        VStack {
            Button(""Add"") {
                NetworkManager.shared.saveNew(item: DataSource(id: ""GoodBye"", action: [1], link: ""http://goodbye"", year: 2030))

            }
            List(list.list, id:\.id) { item in
                Text(item.id)
            }
        }

    }
}
</code></pre>
","11144632","","","","","2020-05-15 10:21:38","@ObservedObject does not get updated","<ios><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61827121","1","61827238","","2020-05-15 19:42:07","","1","46","<p>In my application, I have the need to reinstantiate an <code>@EnvironmentObject</code> at the tap of a button. Where is the right spot to do that?</p>

<p>Here's a screenshot of my view - in the Archived Objects list, I want to have immutable objects. So, when I tap <code>Archive Object</code>, I want to add the current object to the array and create a new current object.</p>

<p><a href=""https://i.stack.imgur.com/myoh1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/myoh1.png"" alt=""enter image description here""></a></p>

<p>A simplified version of the app looks as follows.</p>

<p>I instantiate the object in the <code>SceneDelegate</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?

    var myObject = MyObject()
    let myObjects = MyObjects()

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {

        let contentView = ContentView()
            .environmentObject(myObject)
            .environmentObject(myObjects)

        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(rootView: contentView)
            self.window = window
            window.makeKeyAndVisible()
        }
    }

    //.....
}
</code></pre>

<p>Here's my models:</p>

<pre class=""lang-swift prettyprint-override""><code>class MyObject: ObservableObject, Identifiable {
    @Published var id = UUID()
}

class MyObjects: ObservableObject {
    @Published var values: [MyObject] = [
        MyObject(),
        MyObject()
    ]
}
</code></pre>

<p>In my view, I have the need to put my current object to an (archive) array and then create a new current object to work with. Here's what I'm trying:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {

    @EnvironmentObject var currentObject: MyObject
    @EnvironmentObject var objects: MyObjects

    var sceneDelegate: UISceneDelegate {
        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
            let sd = windowScene.delegate as? SceneDelegate else { fatalError() }
        return sd
    }

    var body: some View {
        VStack {
            Form {
                Section(header: Text(""Current Object"")) {
                    Text(currentObject.id.uuidString)
                }
                Section(header: Text(""Archived Objects"")) {
                    List(objects.values, id: \.id) { object in
                        Text(object.id.uuidString)

                    }
                    Button(action: {
                        self.objects.values.append(self.currentObject)

// as the environment object is get only, I cannot reinstantiate it here...
//                        self.currentObject = MyObject()
                    }) {
                        Text(""Archive Object"")
                    }
                }
            }

            Spacer()
        }
    }
}
</code></pre>
","3855266","","","","","2020-05-17 07:22:28","Reinstantiate an @EnvironmentObject in a view","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61840311","1","61886255","","2020-05-16 16:47:28","","7","850","<p>I have a problem when I enter a character within a TextField (Within <strong>ExerciseSetView</strong>), I have to re-click the text box to make it so I can enter another character. If I remove the bindings from the Textfield I can enter text fluidly. </p>

<p>I think it has something to do with my presenter class and the <strong>updateSet</strong> function recreating a set instance because I have to replace some values two levels deep within an array.</p>

<pre><code>//
//  ContentView.swift
//  test
//
//

import SwiftUI
import Combine
import CoreData

class WorkoutExerciseSetVM: Hashable, ObservableObject {
    @Published public var id: Int
    @Published public var reps: String
    @Published public var weight: String

    init(id: Int, reps: String, weight: String) {
        self.id = id
        self.reps = reps
        self.weight = weight
    }

    static func ==(lhs: WorkoutExerciseSetVM, rhs: WorkoutExerciseSetVM) -&gt; Bool {
        return ObjectIdentifier(lhs) == ObjectIdentifier(rhs)
    }

    func hash(into hasher: inout Hasher) { return hasher.combine(ObjectIdentifier(self)) }
}

class WorkoutExerciseVM: Hashable, ObservableObject {
    @Published public var id: UUID
    @Published public var name: String
    @Published public var sets: [WorkoutExerciseSetVM]

    init(id: UUID, name: String, sets: [WorkoutExerciseSetVM]) {
        self.id = id
        self.name = name
        self.sets = sets
    }

    static func ==(lhs: WorkoutExerciseVM, rhs: WorkoutExerciseVM) -&gt; Bool {
        return ObjectIdentifier(lhs) == ObjectIdentifier(rhs)
    }

    func hash(into hasher: inout Hasher) { return hasher.combine(ObjectIdentifier(self)) }
}

class WorkoutVM: Hashable, ObservableObject {
    @Published public var id = UUID()
    @Published public var name: String
    @Published public var exercises: [WorkoutExerciseVM]
    @Published public var started: Date? = Date()
    @Published public var completed: Date? = Date()

    init(id: UUID, name: String, exercises: [WorkoutExerciseVM], started: Date?, completed: Date?) {
        self.id = id
        self.name = name
        self.exercises = exercises
        self.started = started
        self.completed = completed
    }

    static func ==(lhs: WorkoutVM, rhs: WorkoutVM) -&gt; Bool {
        return ObjectIdentifier(lhs) == ObjectIdentifier(rhs)
    }

    func hash(into hasher: inout Hasher) { return hasher.combine(ObjectIdentifier(self)) }
}

class WorkoutPresenter: ObservableObject {
    @Published public var id: UUID
    @Published public var exercises: [WorkoutExerciseVM]
    @Published public var name: String
    @Published public var started: Date?
    @Published public var completed: Date?

    init(routine: WorkoutVM) {

        self.id = UUID()
        self.name = routine.name
        self.started = Date()
        self.completed = nil
        self.exercises = routine.exercises.map{ exercise in
            return WorkoutExerciseVM(
                id: UUID(),
                name: exercise.name,
                sets: [
                    WorkoutExerciseSetVM(id: 1, reps: ""0"", weight: ""0"")
                ]
            )
        }
    }

    func removeExercise(id: UUID) {
        let exerciseId = id.uuidString;
        self.exercises = self.exercises.filter{$0.id.uuidString != exerciseId}
    }

    func addSet(id: UUID) {
        let exerciseId = id.uuidString;

        self.exercises = self.exercises.map {
            if ($0.id.uuidString == exerciseId) {
                if ($0.sets.count == 0) {
                    $0.sets.append(WorkoutExerciseSetVM(id: 1, reps: ""0"", weight: ""0""))
                }

                if let lastSet = $0.sets.last {
                    $0.sets.append(WorkoutExerciseSetVM(id: lastSet.id + 1, reps: lastSet.reps, weight: lastSet.weight))
                }
            }

            return $0
        }
    }

    func updateSet(id: UUID, set: WorkoutExerciseSetVM) {
        let exerciseId = id.uuidString

        self.exercises = self.exercises.map{
            if $0.id.uuidString == exerciseId {
                $0.sets = $0.sets.map{(oldExerciseSet) -&gt; WorkoutExerciseSetVM in
                    if oldExerciseSet.id == set.id {
                        return set
                    }

                    return oldExerciseSet
                }

                return $0
            }

            return $0;
        }
    }

    func removeSet(id: UUID) {
        let exerciseId = id.uuidString;

        self.exercises = self.exercises.map{(exercise) -&gt; WorkoutExerciseVM in
            if exercise.id.uuidString == exerciseId {
                let newExercise = exercise

                if newExercise.sets.count &gt; 1 {
                    newExercise.sets.removeLast()
                }

                return newExercise
            }

            return exercise;
        }
    }
}

struct ContentView: View {
    var body: some View {
        VStack {
            WorkoutView(presenter: WorkoutPresenter(routine: WorkoutVM(id: UUID(), name: ""Test"", exercises: [WorkoutExerciseVM(id: UUID(), name: ""Exercise"", sets: [WorkoutExerciseSetVM(id: 1, reps: ""0"", weight: ""0"")])], started: nil, completed: nil)))
        }

    }
}

struct WorkoutView: View {
    @ObservedObject var presenter: WorkoutPresenter
    var body: some View {
        return GeometryReader { geo in
            ZStack {
                VStack {
                    ScrollView {
                        ForEach(self.presenter.exercises, id: \.self) { exercise in
                            ExerciseView(presenter: self.presenter, exercise: exercise)
                        }
                    }
                }
            }
        }
    }
}

struct ExerciseView: View {
    @ObservedObject var presenter: WorkoutPresenter
    var exercise: WorkoutExerciseVM
    var body: some View {
        VStack {
            VStack(alignment: .leading) {
                VStack {
                    VStack {
                        ForEach(exercise.sets, id: \.self) { exerciseSet in
                            ExerciseSetView(
                                set: exerciseSet,
                                onUpdate: { newExerciseSet in
                                    self.presenter.updateSet(id: self.exercise.id, set: newExerciseSet)
                                }
                            )
                        }
                    }
                }
            }
            HStack {
                Button(action: {
                    self.presenter.addSet(id: self.exercise.id)
                }) {
                    HStack {
                        Image(systemName: ""plus"")
                        Text(""Add Set"")
                    }

                }
                Button(action: {
                    self.presenter.removeSet(id: self.exercise.id)
                }) {
                    HStack {
                        Image(systemName: ""minus"")
                        Text(""Remove Set"")
                    }

                }
            }

        }

    }
}

struct ExerciseSetView: View {
    var set: WorkoutExerciseSetVM
    var onUpdate: (_ set: WorkoutExerciseSetVM) -&gt; Void
    var body: some View {
        let repBinding = Binding(
            get: {
                String(self.set.reps)
            },
            set: {
                if ($0 as String?) != nil {
                    self.onUpdate(WorkoutExerciseSetVM(id: self.set.id, reps: $0 , weight: self.set.weight))
                }
            }
        )

        let weightBinding = Binding(
            get: {
                String(self.set.weight)
            },
            set: {
                if ($0 as String?) != nil {
                    self.onUpdate(WorkoutExerciseSetVM(id: self.set.id, reps: self.set.reps, weight: $0 ))
                }
            }
        )

        return HStack {
            Spacer()
// textfield that isn't working
            TextField("""", text: repBinding)
            Spacer()
// textfield that isn't working
            TextField("""", text: weightBinding)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>
","1228006","","1228006","","2020-05-16 19:52:40","2020-05-19 08:13:28","TextField in SwiftUI loses focus when I enter a character","<swift><swift4.2><swiftui>","1","2","1","","","CC BY-SA 4.0"
"61841254","1","61968621","","2020-05-16 17:57:32","","17","6123","<p>I'm having a bit of a mental block using the iOS Combine framework.</p>

<p>I'm converting some code from ""manual"" fetching from a remote API to using Combine. Basically, the API is SQL and REST (in actual fact it's Salesforce, but that's irrelevant to the question). What the code used to do is call a REST query method that takes a completion handler. What I'm doing is replacing this everywhere with a Combine Future. So far, so good.</p>

<p>The problem arises when the following scenario happens (and it happens a lot):</p>

<ol>
<li><p>We do a REST query and get back an array of ""objects"".</p></li>
<li><p>But these ""objects"" are not completely populated. Each one of them needs additional data from some related object. So for each ""object"", we do another REST query using information from that ""object"", thus giving us <em>another</em> array of ""objects"".</p></li>
<li><p>This might or might not allow us to finish populating the first ""objects"" — or else, we might have to do <em>another</em> REST query using information from each of the <em>second</em> ""object"", and so on.</p></li>
</ol>

<p>The result was a lot of code structured like this (this is pseudocode):</p>

<pre><code>func fetchObjects(completion: @escaping ([Object] -&gt; Void) {
    let restQuery = ...
    RESTClient.performQuery(restQuery) { results in
        let partialObjects = results.map { ... }
        let group = DispatchGroup()
        for partialObject in partialObjects {
            let restQuery = ... // something based on partialObject
            group.enter()
            RESTClient.performQuery(restQuery) { results in
                group.leave()
                let partialObjects2 = results.map { ... }
                partialObject.property1 = // something from partialObjects2
                partialObject.property2 = // something from partialObjects2
                // and we could go down yet _another_ level in some cases
            }
        }
        group.notify {
            completion([partialObjects])
        }
    }
}
</code></pre>

<p>Every time I say <code>results in</code> in the pseudocode, that's the completion handler of an asynchronous networking call.</p>

<p>Okay, well, I see well enough how to chain asynchronous calls in Combine, for example by using Futures and <code>flatMap</code> (pseudocode again):</p>

<pre><code>let future1 = Future...
future1.map {
    // do something
}.flatMap {
    let future2 = Future...
    return future2.map {
        // do something
    }
}
// ...
</code></pre>

<p>In that code, the way we form <code>future2</code> can depend upon the value we received from the execution of <code>future1</code>, and in the <code>map</code> on <code>future2</code> we can modify what we received from upstream before it gets passed on down the pipeline. No problem. It's all quite beautiful.</p>

<p>But that doesn't give me what I was doing in the pre-Combine code, namely <em>the loop</em>. Here I was, doing <em>multiple</em> asynchronous calls in a <em>loop</em>, held in place by a DispatchGroup before proceeding. The question is:</p>

<p><em>What is the Combine pattern for doing that?</em></p>

<p>Remember the situation. I've got an <em>array</em> of some object. I want to <em>loop</em> through that array, doing an asynchronous call for <em>each</em> object in the loop, fetching new info asynchronously and modifying that object on that basis, before proceeding on down the pipeline. And each loop might involve a further <em>nested</em> loop gathering even <em>more</em> information asynchronously:</p>

<pre><code>Fetch info from online database, it's an array
   |
   V
For each element in the array, fetch _more_ info, _that's_ an array
   |
   V
For each element in _that_ array, fetch _more_ info
   |
   V
Loop thru the accumulated info and populate that element of the original array 
</code></pre>

<p>The old code for doing this was horrible-looking, full of nested completion handlers and loops held in place by DispatchGroup <code>enter</code>/<code>leave</code>/<code>notify</code>. <em>But it worked</em>. I can't get my Combine code to work the same way. How do I do it? Basically my pipeline output is an array of something, I feel like I need to split up that array into individual elements, do something <em>asynchronously</em> to each element, and put the elements back together into an array. How?</p>

<hr>

<p>The way I've been solving this works, but doesn't scale, especially when an asynchronous call needs information that arrived several steps <em>back</em> in the pipeline chain. I've been doing something like this (I got this idea from <a href=""https://stackoverflow.com/a/58708381/341994"">https://stackoverflow.com/a/58708381/341994</a>):</p>

<ol>
<li><p>An array of objects arrives from upstream.</p></li>
<li><p>I enter a <code>flatMap</code> and <code>map</code> the array to an array of publishers, each headed by a Future that fetches further online stuff related to <em>one</em> object, and followed by a pipeline that produces the <em>modified</em> object.</p></li>
<li><p>Now I have an array of pipelines, each producing a single object. I <code>merge</code> that array and produce that publisher (a MergeMany) from the <code>flatMap</code>.</p></li>
<li><p>I <code>collect</code> the resulting values back into an array.</p></li>
</ol>

<p>But this still seems like a lot of work, and even worse, it doesn't scale when each sub-pipeline itself needs to spawn an array of sub-pipelines. It all becomes incomprehensible, and information that used to arrive easily into a completion block (because of Swift's scoping rules) no longer arrives into a subsequent step in the main pipeline (or arrives only with difficulty because I pass bigger and bigger tuples down the pipeline).</p>

<p>There must be some simple Combine pattern for doing this, but I'm completely missing it. Please tell me what it is.</p>
","341994","","341994","","2020-05-23 20:43:38","2020-08-18 16:48:45","Combine framework: how to process each element of array asynchronously before proceeding","<ios><swift><combine>","2","7","8","","","CC BY-SA 4.0"
"61846563","1","61848870","","2020-05-17 03:23:08","","8","2185","<p>How to convert:</p>

<pre><code>func getResults(completion: ([Result]?, Error) -&gt; Void)
</code></pre>

<p>Into</p>

<pre><code>var resultsPublisher: AnyPublisher&lt;[Result], Error&gt;
</code></pre>

<p>Just a scheme how I see it is (this syntax doesn't exist):</p>

<pre><code>var resultsPublisher: AnyPublisher&lt;[Result], Error&gt; {
  let publisher: AnyPublisher = ... // init
  getResults { results, error in
     guard let results = results else {
       publisher.produce(error: error) // this syntax doesn't exist
       return
     }

     publisher.produce(results: results)  // this syntax doesn't exist

  }

  return publisher
}
</code></pre>

<p>I need that because some 3d party SDKs use <code>completion closures</code> and I want to write extensions to them that return <code>Publishers</code>.</p>
","1328838","","","","","2020-05-17 10:45:45","Combine: Convert Closure into Publisher","<ios><closures><swiftui><combine><publisher>","1","3","3","","","CC BY-SA 4.0"
"61851184","1","61853563","","2020-05-17 11:41:03","","0","584","<p>I would like to use the <code>collect</code> method of Combine to split an array of objects into Array of multiples Arrays which would correspond to Rows in a Collection View (eg: <code>[Item, Item, Item, Item, Item]</code> would become <code>[[Item, Item, Item], [Item, Item]]</code> and so on)</p>

<p>My data is coming from two publisher that I'm chaining to merge my data into a single type consumed by my view.</p>

<p>Here is my code :</p>

<pre><code>APIClient().send(APIEndpoints.searchMovies(for: text)).flatMap { response -&gt; AnyPublisher&lt;APIResponseList&lt;TVShow&gt;, Error&gt; in
            movies = response.results.map { SearchItemViewModel(movie: $0)}
            return APIClient().send(APIEndpoints.searchTVShows(for: text))
        }
        .map { response -&gt; [SearchItemViewModel] in
            tvShows = response.results.map { SearchItemViewModel(tvShow: $0)}
            let concatItems = tvShows + movies
            return concatItems.sorted { $0.popularity &gt; $1.popularity }
        }
        .collect(3)
        .sink(receiveCompletion: { (completion) in
            switch completion {
            case .failure:
                self.state = .error
                self.items = []
            case .finished:
                break
            }
        }, receiveValue: { (response) in
            self.state = .data
            self.items = response
        })
            .store(in: &amp;disposables)
</code></pre>

<p>My problem currently is that inside my <code>sink</code> <code>receiveValue</code> closure, the <code>response</code> parameter doesn't equal the expected result, it just group all my items into an array like this : <code>[Item, Item, Item, Item, Item]</code> -> <code>[[Item, Item, Item, Item, Item]]</code>
It seems that the <code>collect</code> method is not working as expected, any idea about how I could fix this ? </p>
","8324584","","","","","2020-05-17 15:13:30","How to use Combine collect method after a map","<swift><combine>","2","6","","","","CC BY-SA 4.0"
"61851434","1","61851744","","2020-05-17 12:00:59","","4","1151","<p>I have 3d party library (<code>Firestore</code>) that has this method</p>

<pre><code>func listenToEvents(handler: ([Result], Error) -&gt; Void)
</code></pre>

<p><code>handler</code> in this method is called many times (after any updates of the data). I want to convert it to <code>Publisher</code> </p>

<p>Here is my code now:</p>

<pre><code>var resultsPublisher: AnyPublisher&lt;[Result], Error&gt; {
    Deferred { 
        Future { promise in
           libraryObject.listenToEvents { results, error in // called multiple times
              guard let results = results else {
                 promise(.failure(error))
                 return
              }

              // this can't be called several times,
              // because Future's promise is supposed to be called only once
              promise(.success(results))
           }
         }
    }
    .eraseToAnyPublisher()
}
</code></pre>

<p>So my <code>Publisher</code> produces value only once, because <code>Future</code> works this way. Are there any other <code>Publishers</code> (or may be a different approach) to accomplish that?</p>
","1328838","","506441","","2020-05-18 01:08:09","2022-05-29 09:24:45","Combine: Publisher like Future but with multiple values","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61889158","1","61889295","","2020-05-19 10:46:53","","6","3907","<p>I have ViewModel with disposable Set defined this way </p>

<pre><code>class ViewModel { 


 private var disposables = Set&lt;AnyCancellable&gt;()

 func sync() { 
    repo.syncObjects()
            .handleEvents(receiveCancel: {
                print(""Synced objects: CANCELED!"")
            })
            .sink(receiveCompletion: { completion in
                switch completion {
                case .failure(let error):
                    print(""Synced objects: \(error)"")
                case .finished:
                    print(""Synced objects: finished"")
                }
            }) { objects in
                print(""Synced objects: \(objects)"")
            }.store(in: &amp;disposables)
 }

  deinit { print(""ViewModel deinit"") }
}
</code></pre>

<p>I am calling sync() in onAppear in SwiftUI view. Then I am fast switching screens and ViewModel referenced from SwiftUI view is deallocated by ARC like deinit is called but subscriptions seems to remain alive and disposable reference does not cancel subscription it fetches data from Network and saved them in Core Data and prints Synced objects: objects, Synced objects: finished. And keeps being alive even when I stop switching screens for several seconds to complete old requests. </p>

<p>Should I manually cancel AnyCancellable? shouldn't it be cancelled automagically?</p>
","4415642","","","","","2022-06-02 22:05:10","Swift Combine how Set<AnyCancellable> works?","<swift><subscription><combine><disposable>","1","1","","","","CC BY-SA 4.0"
"61898505","1","61898814","","2020-05-19 18:48:01","","0","118","<p>I'm trying to download a text file that has fixed width data elements and create
an array of data (eventually I would store this in Core Data).</p>

<p>This is an example of the data in this file:</p>

<p>USC00054542  37.2000 -103.4833 1770.9 CO KIM 5 SW<br>
USC00054546  37.1150 -103.2986 1602.3 CO KIM 10SSE<br>
USC00054584  39.2833 -104.4333 1937.0 CO KIOWA 5 SE<br>
USC00054585  39.3000 -104.5167 1998.0 CO KIOWA 4 SW<br>
USC00054592  39.6167 -102.5833 1220.1 CO KIRK<br>
USC00054603  38.7658 -102.8031 1311.2 CO KIT CARSON</p>

<p>I created a struct for the object that would be on each line:                                  </p>

<pre><code>struct RawStation: Codable, Identifiable {
    var id = UUID()
    var station: String
    var lat: String
    var long: String
    var elevation: String
    var name: String
    var region: String
    var postal: String
}
</code></pre>

<p>I tried several ways of decoding this file but have had no success. Here is the 
attempt to use the PropertyListDecoder       </p>

<pre><code>class Webservice {
    func fetchTextFile() {
        let stationURL = URL(string: ""https://www1.ncdc.noaa.gov/pub/data/ghcn/daily/ghcnd-stations.txt"")!
        var s: [RawStation]?

        if let data = try? Data(contentsOf: stationURL) {
          let decoder = PropertyListDecoder()
          s = try? decoder.decode([RawStation].self, from: data)
        }

        do {
            let data = try Data(contentsOf: stationURL)
            let decoder = PropertyListDecoder()
            s = try decoder.decode([RawStation].self, from: data)
        } catch {
            // Handle error
            print(error)
        }
        print(s as Any)
    } 
}
</code></pre>

<p>The error message: 
dataCorrupted(Swift.DecodingError.Context(codingPath: [], debugDescription: ""The given data was not a valid property list."", underlyingError: Optional(Error Domain=NSCocoaErrorDomain Code=3840 ""Unexpected character A at line 1"" UserInfo={NSDebugDescription=Unexpected character A at line 1, kCFPropertyListOldStyleParsingError=Error Domain=NSCocoaErrorDomain Code=3840 ""Expected ';' or '=' after key at line 1"" UserInfo={NSDebugDescription=Expected ';' or '=' after key at line 1}})))</p>

<p>The url for the file is ""<a href=""https://www1.ncdc.noaa.gov/pub/data/ghcn/daily/ghcnd-stations.txt"" rel=""nofollow noreferrer"">https://www1.ncdc.noaa.gov/pub/data/ghcn/daily/ghcnd-stations.txt</a>""</p>

<p>Sadly, the data does not appear to be available as a JSON file.</p>

<p>Xcode 11.4.1 Any guidance would be appreciated.</p>
","2698617","","12299030","","2020-05-19 18:51:25","2020-05-20 11:32:42","Swift Fetch and Parse Fixed Width Text File","<ios><xcode><combine>","1","0","","","","CC BY-SA 4.0"
"61945967","1","61949664","","2020-05-22 00:31:19","","0","201","<p>Here's my code</p>

<p><strong>Coffee struct and core data NSManaged</strong></p>

<pre><code>import Foundation
import SwiftUI
import Combine

struct CoffeeItem: Identifiable{
    var id = UUID()
    var title: String
    var favorite: Bool
}

extension CoffeeItem {
    static func all() -&gt; [CoffeeItem] {
        return [
            CoffeeItem(title: ""Cappuccino"", favorite: UserDefaults.standard.bool(forKey: ""Cappuccino"")),
            CoffeeItem(title: ""Macchiato"", favorite: UserDefaults.standard.bool(forKey: ""Macchiato"")),
            CoffeeItem(title: ""Espresso"", favorite: UserDefaults.standard.bool(forKey: ""Espresso"")),
            CoffeeItem(title: ""Ristretto"", favorite: UserDefaults.standard.bool(forKey: ""Ristretto""))
        ]
    }
}
</code></pre>

<p>.</p>

<pre><code>import CoreData

class CoffeeFavorite: NSManagedObject {
    @NSManaged var title: String
}
</code></pre>

<p><strong>Main view</strong></p>

<pre><code>struct CoffeeSection: View {
    //Core Data
    @Environment(\.managedObjectContext) var managedObjectContext
    @FetchRequest(entity: CoffeeFavorite.entity(), sortDescriptors: [NSSortDescriptor(key: ""title"", ascending: true)]) var coffeeFavorite: FetchedResults&lt;CoffeeFavorite&gt;

    @State var coffeeItems = CoffeeItem.all()

    var body: some View {
        List {
            ForEach(0 ..&lt; self.coffeeItems.count) { item in
                HStack {
                    Text(self.coffeeItems[item].title)
                        .fontWeight(.heavy)
                        .padding()

                    Spacer()

                    Image(systemName: self.coffeeItems[item].favorite ? ""heart.fill"" : ""heart"")
                        .padding()
                        .onTapGesture {
                            self.addItem(item: self.coffeeItems[item].title)
                            self.coffeeItems[item].favorite.toggle()
                            UserDefaults.standard.set(self.coffeeItems[item].favorite, forKey: self.coffeeItems[item].title)
                    }
                }
            }
        }
    }


    func addItem(item: String) {
        let newItem = CoffeeFavorite(context: managedObjectContext)
        newItem.title = item
        saveFavorites()
    }
    func saveFavorites() {
        do {
            try managedObjectContext.save()
        } catch {
            print(error)
        }
    }
}
</code></pre>

<p><strong>Favorite view</strong></p>

<pre><code>struct FavoritesList: View {
    //Core Data
    @Environment(\.managedObjectContext) var managedObjectContext
    @FetchRequest(entity: CoffeeFavorite.entity(), sortDescriptors: [NSSortDescriptor(key: ""title"", ascending: false)]) var coffeeFavorite: FetchedResults&lt;CoffeeFavorite&gt;

    var body: some View {
        List {
            ForEach(coffeeFavorite, id: \.self) { item in
                Text(item.title)

            }
            .onDelete(perform: deleteItem)
        }
    }

    func deleteItem(indexSet: IndexSet) {
        let source = indexSet.first!
        let favorites = coffeeFavorite[source]
        managedObjectContext.delete(favorites)

        saveFavorites()
    }

    func saveFavorites() {
        do {
            try managedObjectContext.save()
        } catch {
            print(error)
        }
    }
}
</code></pre>

<p>I have a main view with 4 coffee items and a heart on the right that when is tapped it adds that item title to core data and I can see it in my favorite view. I can delete my core item from the favorite view with .onDelete(perform: ...) but I want to do the same in my main view by tapping the heart so when I toggle it I add and delete that item from core data.
How can I make it work simultaneously on both views??</p>
","13419268","","","","","2020-05-22 07:16:57","Remove core data item after being added SwiftUI","<swift><core-data><swiftui>","1","2","","","","CC BY-SA 4.0"
"61959647","1","61960839","","2020-05-22 16:31:39","","6","2614","<p>I'm working on an iOS application adopting the MVVM pattern, using SwiftUI for designing the Views and Swift Combine in order to glue together my Views with their respective ViewModels.
In one of my ViewModels I've created a <code>Publisher</code> (type <code>Void</code>) for a button press and another one for the content of a <code>TextField</code> (type <code>String</code>). 
I want to be able to combine both Publishers within my ViewModel in a way that the combined Publisher only emits events when the button Publisher emits an event while taking the latest event from the String publisher, so I can do some kind of evaluation on the <code>TextField</code> data, every time the user pressed the button. So my VM looks like this:</p>

<pre><code>import Combine
import Foundation

public class MyViewModel: ObservableObject {
    @Published var textFieldContent: String? = nil
    @Published var buttonPressed: ()

    init() {
        // Combine `$textFieldContent` and `$buttonPressed` for evaulation of textFieldContent upon every button press... 
    }
}
</code></pre>

<p>Both publishers are being pupulated with data by SwiftUI, so i will omit that part and let's just assume both publishers receive some data over time.</p>

<p>Coming from the RxSwift Framework, my goto solution would have been the <a href=""https://rxmarbles.com/#withLatestFrom"" rel=""noreferrer"">withLatestFrom</a> operator to combine both observables.
Diving into the Apple Documentation of <a href=""https://developer.apple.com/documentation/combine/publisher"" rel=""noreferrer"">Publisher</a> in the section ""Combining Elements from Multiple Publishers"" however, I cannot find something similar, so I expect this kind of operator to be missing currently.</p>

<p>So my question: Is it possible to use the existing operator-API of the Combine Framework to get the same behavior in the end like <code>withLatestFrom</code>? </p>
","7210997","","","","","2021-08-02 16:28:29","Swift Combine operator with same functionality like `withLatestFrom` in the RxSwift Framework","<ios><swift><swiftui><combine>","3","10","2","","","CC BY-SA 4.0"
"61971886","1","61972365","","2020-05-23 12:17:48","","6","2672","<p>I'm using SwiftUI and I want to animate a view as soon as it appears (the explicit type of animation does not matter) for demo purposes in my app.
Let's say I just want to scale up my view and then scale it down to its original size again, I need to be able to animate the view to a new state and back to the original state right afterward.
Here's the sample code of what I've tried so far:</p>

<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    @State private var shouldAnimate = false
    private var scalingFactor: CGFloat = 2    

    var body: some View {
        Text(""hello world"")
        .scaleEffect(self.shouldAnimate ? self.scalingFactor : 1)
        .onAppear {
            let animation = Animation.spring().repeatCount(1, autoreverses: true)
            withAnimation(animation) {
                self.shouldAnimate.toggle()
            }
        }
    }
</code></pre>

<p>Obviously this does not quite fulfill my requirements, because <code>let animation = Animation.spring().repeatCount(1, autoreverses: true)</code> only makes sure the animation (to the new state) is being repeated by using a smooth <code>autoreverse = true</code> setting, which still leads to a final state with the view being scaled to <code>scalingFactor</code>.</p>

<p>So neither can I find any property on the <code>animation</code> which lets my reverse my animation back to the original state automatically (without me having to interact with the view after the first animation), nor did I find anything on how to determine when the first animation has actually finished, in order to be able to trigger a new animation.</p>

<p>I find it pretty common practice to animate some View upon its appearance, e.g. just to showcase that this view can be interacted with, but ultimately not alter the state of the view. For example animate a bounce effect on a button, which in the end sets the button back to its original state. Of course I found several solutions suggesting to interact with the button to trigger a reverse animation back to its original state, but that's not what I'm looking for.</p>
","7210997","","","","","2022-05-28 06:30:44","SwiftUI animation and subsequent reverse animation to original state","<ios><swift><animation><swiftui>","2","0","","","","CC BY-SA 4.0"
"61976783","1","61977019","","2020-05-23 18:29:42","","0","49","<p>I have two dictionaries - one is a dictionary of nouns identified in sentences by a classifier; the other is a dictionary of noun phrases identified by a regex parser. The keys of both dictionaries are the strings of the sentence numbers.
I want to substitute the noun phrases for the nouns if they coincide.</p>

<p>output_classifier looks like this:</p>

<pre><code>{'47': ['staff_7', 'food_11', 'portion_17', 'portobello_25', 'gorgonzola_27', '/_28',  'sausage_29', 'appetizer_30', 'lobster_33', 'risotto_34']}
</code></pre>

<p>output regex parser looks like this:</p>

<pre><code>{'47': ['portion_17 size_18', 'sausage_29 appetizer_30', 'lobster_33 risotto_34']}
</code></pre>

<p>i want to keep the individual words if they are not in the regex parser, and substitue the phrases - getting rid of the original single words. </p>

<p>intended output:</p>

<pre><code>{'47': ['staff_7', 'food_11', 'portion_17 size_18', 'portobello_25', 'gorgonzola_27', '/_28',  'sausage_29 appetizer_30', 'lobster_33 risotto_34']}
</code></pre>

<p>I can't seem to get rid of the individual words after I have substituted. </p>
","12997669","","","","","2020-05-23 19:05:52","How do I substitute one value for another in dictionaries when there is a partial match: python","<python><dictionary><combine>","2","0","","","","CC BY-SA 4.0"
"61999061","1","62002695","","2020-05-25 08:59:33","","4","981","<p>I have this simple subscription where my <code>subject</code> is eminting strings. Just for curiosity I would like to know if my subscription is cancelled. </p>

<p>Afaik a pipeline that has been cancelled will not send any completions.
Are there some ways do achieve this? </p>

<p>The use case would be that I can cancel all subscriptions and receive a completion on this. Where I can clean up stuff a reflect this probably. </p>

<pre><code>PlaygroundPage.current.needsIndefiniteExecution = true

var disposeBag: Set&lt;AnyCancellable&gt; = .init()

let subject = PassthroughSubject&lt;String, Never&gt;()

subject.sink(receiveCompletion: { completion in
    switch completion {
    case .failure(let error):
        print(""Failed with: \(error.localizedDescription)"")
    case .finished:
        print(""Finished"")
    }
}) { string in
    print(string)
}.store(in: &amp;disposeBag)

subject.send(""A"")
disposeBag.map { $0.cancel() }
subject.send(""B"")
</code></pre>
","4142753","","","","","2022-05-20 17:08:16","Get status of cancellation of my subscription in Combine iOS","<ios><swift><combine>","1","5","2","","","CC BY-SA 4.0"
"61999575","1","61999769","","2020-05-25 09:29:52","","0","540","<p>I have 2 asynchronous return values from 2 different classes, one from HealthKit, the other from MotionManager. My goal is to combine these values and output them in a swiftui View, where it refreshes every second. I know I have to look at the combine framework here, but I don't know where to start. I can't find a lot of tutorials which describe Swiftui + Combine. I know I have to look at .combineLatest but do I have to write my own Publisher and Subscriber, or can I use @Published property wrapper I have here (@Published var motionData = MotionData() and @Published var heartRateValue: Double  = 0.0) ? </p>

<p><em>My MotionManager Class:</em></p>

<pre><code>struct MotionValues {
    var rotationX: Double = 0.0
    var rotationY: Double = 0.0
    var rotationZ: Double = 0.0
    var pitch: Double = 0.0
    var roll: Double = 0.0
    var yaw: Double = 0.0
}


class MotionManager: ObservableObject {

    @Published var motionValues = MotionValues()

    private let manager = CMMotionManager()

    func startMotionUpdates() {
        manager.deviceMotionUpdateInterval = 1.0
        manager.startDeviceMotionUpdates(to: .main) { (data, error) in

            guard let data = data, error == nil else {
                print(error!)
                return
            }

            self.motionValues.rotationX = data.rotationRate.x
            self.motionValues.rotationY = data.rotationRate.y
            self.motionValues.rotationZ = data.rotationRate.z

            self.motionValues.pitch = data.attitude.pitch
            self.motionValues.roll = data.attitude.roll
            self.motionValues.yaw = data.attitude.yaw
        }
    }

    func stopMotionUpdates() {
        manager.stopDeviceMotionUpdates()
        resetAllMotionData()
    }

    func resetAllMotionData() {
        self.motionValues.rotationX = 0.0
        self.motionValues.rotationY = 0.0
        self.motionValues.rotationZ = 0.0
        self.motionValues.pitch = 0.0
        self.motionValues.roll = 0.0
        self.motionValues.yaw = 0.0
    }
}
</code></pre>

<p><em>My HealthKitManager Class:</em></p>

<pre><code>class HealthKitManager: ObservableObject {

    private var healthStore = HKHealthStore()
    private var heartRateQuantity = HKUnit(from: ""count/min"")
    private var activeQueries = [HKQuery]()

    @Published var heartRateValue: Double  = 0.0

    func autorizeHealthKit() {

        let heartRate = HKObjectType.quantityType(forIdentifier: .heartRate)!
        let heartRateVariability = HKObjectType.quantityType(forIdentifier: .heartRateVariabilitySDNN)!

        let HKreadTypes: Set = [heartRate, heartRateVariability]

        healthStore.requestAuthorization(toShare: nil, read: HKreadTypes) { (success, error) in
            if let error = error {
                print(""Error requesting health kit authorization: \(error)"")
            }
        }
    }

    func fetchHeartRateData(quantityTypeIdentifier: HKQuantityTypeIdentifier ) {

        let devicePredicate = HKQuery.predicateForObjects(from: [HKDevice.local()])
        let updateHandler: (HKAnchoredObjectQuery, [HKSample]?, [HKDeletedObject]?, HKQueryAnchor?, Error?) -&gt; Void = {
        query, samples, deletedObjects, queryAnchor, error in
            guard let samples = samples as? [HKQuantitySample] else {
                return
            }
            self.process(samples, type: quantityTypeIdentifier)
        }
        let query = HKAnchoredObjectQuery(type: HKObjectType.quantityType(forIdentifier: quantityTypeIdentifier)!, predicate: devicePredicate, anchor: nil, limit: HKObjectQueryNoLimit, resultsHandler: updateHandler)
        query.updateHandler = updateHandler
        healthStore.execute(query)
        activeQueries.append(query)
    }

    private func process(_ samples: [HKQuantitySample], type: HKQuantityTypeIdentifier) {
        for sample in samples {
            if type == .heartRate {
                DispatchQueue.main.async {
                    self.heartRateValue = sample.quantity.doubleValue(for: self.heartRateQuantity)
                }
            }
        }
    }

    func stopFetchingHeartRateData() {
        activeQueries.forEach { healthStore.stop($0) }
        activeQueries.removeAll()
        DispatchQueue.main.async {
            self.heartRateValue = 0.0
        }

    }  
}
</code></pre>

<p>I started with creating a combinedViewModel but I'm stuck here and don't know if this is the way to go: </p>

<pre><code>class CombinedViewModel: ObservableObject {

    @Published var motionManager: MotionManager = MotionManager()
    @Published var healthManager: HealthKitManager = HealthKitManager()

    var anyCancellable: AnyCancellable?

    init() {
        anyCancellable = Publishers
            .CombineLatest(motionManager.$motionValues,healthManager.$heartRateValue)
            .sink(receiveValue: {
                // Do something
            }
        })
    }
}
</code></pre>

<p>Where do I need to focus ? Do I need to learn the combine framework completely to write my own publishers and subscribers, or is there something available with @Published that can do the job ? Or do I need to go for another approach with my CombinedViewModel?</p>

<p>added contentView for reference:</p>

<pre><code>struct ContentView: View {

    @State var isActive: Bool = false

    private var motion = MotionManager()
    private var health = HealthKitManager()

    @ObservedObject var combinedViewModel = CombinedViewModel(managerOne: motion, managerTwo: health)

    private var motionValues: MotionValues {
        return combinedViewModel.combinedValues.0
    }

    private var heartRateValue: Double {
        return combinedViewModel.combinedValues.1
    }


    var body: some View {
        ScrollView {
            VStack(alignment: .leading) {
                Indicator(title: ""X:"", value: motionValues.rotationX)
                Indicator(title: ""Y:"", value: motionValues.rotationY)
                Indicator(title: ""Z:"", value: motionValues.rotationZ)
                Divider()
                Indicator(title: ""Pitch:"", value: motionValues.pitch)
                Indicator(title: ""Roll:"", value: motionValues.roll)
                Indicator(title: ""Yaw:"", value: motionValues.yaw)
                Divider()
                Indicator(title: ""HR:"", value: heartRateValue)
            }
            .padding(.horizontal, 10)
            Button(action: {
                self.isActive.toggle()
                self.isActive ? self.start() : self.stop()
            }) {
                Text(isActive ? ""Stop"" : ""Start"")
            }
            .background(isActive ? Color.green : Color.blue)
            .cornerRadius(10)
            .padding(.horizontal, 5)
        }.onAppear {
            self.health.autorizeHealthKit()
        }
    }

    private func start() {
        self.motion.startMotionUpdates()
        self.health.fetchHeartRateData(quantityTypeIdentifier: .heartRate)
    }

    private func stop() {
        self.motion.stopMotionUpdates()
        self.health.stopFetchingHeartRateData()
    }

}
</code></pre>
","4795917","","4795917","","2020-05-25 10:39:07","2020-05-25 10:39:07","Combine asynchronous return values in SwiftUI","<swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"62002405","1","62002504","","2020-05-25 12:27:54","","2","573","<p>I have a swift application that communicates with a small BLE device. I'm able to send requests and get answers from the device but I struggle updating values displayed on my swiftui view.</p>

<p>Here's what I tried:</p>

<ol>
<li>With a callback:</li>
</ol>

<p>In the BleConnection.swift file, implementing all BLE stuff, I declared a callback <code>var onResponse: (([UInt8]) -&gt; Void)? = nil</code>
When a response is received from the device, the data is pushed to the view with the callback:</p>

<pre><code>    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
...
            if self.onResponse != nil {
                    self.onResponse!(characteristic.value!.bytes)
                }
            }
        }
    }
</code></pre>

<p>In the ReaderInformations.swift file, where there is the swiftui view, I implemented the callback and tried to update a component displayed value with a <code>@State var</code> but it didn't work out. The print() in the callback is well printed in the console but the component not updated. I then read that only internal method to the view could update a state var.</p>

<ol start=""2"">
<li>With Combine:
I updated the peripheral(didUpdateValueFor) and sent the BLE device response like this:</li>
</ol>

<pre><code>let passThroughSubjectPublisher = PassthroughSubject&lt;[UInt8], Never&gt;()

    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
...
            passThroughSubjectPublisher.send(characteristic.value!.bytes)  
        }
    }
</code></pre>

<p>and in the view:</p>

<pre><code>struct ReaderInformations: View {
    var ble: BleConnection
    @State private var status: String = ""status"" 
    private var cancelSet: Set&lt;AnyCancellable&gt; = []


    init(bleInstance: BleConnection) {
        passThroughSubjectPublisher.sink(receiveValue: { response in. // Escaping closure captures mutating 'self' parameter
             switch response[0] {
                 self.status = ""TEST"".   // This error because of the self
             ...
             }
        }).store(in: &amp;cancelSet)
    }
</code></pre>

<p>I doesn't work either, because I tried in the init to access a member not even instantiated yet.</p>

<p>So here I am with no idea how to do. How would you guys manage this?</p>
","3579265","","","","","2020-05-25 12:34:25","SwiftUI: How to process BLE response and display new values","<ios><swift><swiftui><bluetooth-lowenergy>","1","0","","","","CC BY-SA 4.0"
"62002597","1","62003459","","2020-05-25 12:41:20","","3","1338","<p>I am trying to build a publisher that emits true when any of 5 other publisher emits true. I've managed to build a working version but it feels very icky, with the CombineLatest4 + CombineLatest and especially all the <code>$0.0 || $0.1 || $0.2 || $0.3</code> code.</p>

<p>I've tried Merge5, but that simply returns the value of the last value that was set it seems.</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

class Test {
  @Published var one = false
  @Published var two = false
  @Published var three = false
  @Published var four = false
  @Published var five = false
}

let test = Test()

var anyTrue = Publishers.CombineLatest4(test.$one, test.$two, test.$three, test.$four)
  .map { $0.0 || $0.1 || $0.2 || $0.3 }
  .combineLatest(test.$five)
  .map { $0.0 || $0.1 }

anyTrue.sink {
  print($0)
}

test.three = true
test.one = false
</code></pre>

<p>Is there a cleaner less repetitive way to do this?</p>
","403425","","","","","2020-05-25 13:30:48","Swift Combine: merge multiple publishers and emit `true` when any of them emits `true`","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62014417","1","62014533","","2020-05-26 03:56:21","","1","268","<p>i am trying to use a publisher, but i got this error: ""Escaping closure captures non-escaping parameter 'promise'"" in the Timer. line.
How can i solve this?   </p>

<pre><code> extension OperationQueue {

        func publisher&lt;Output, Failure: Error&gt;(_ block: @escaping (Future&lt;Output, Failure&gt;.Promise) -&gt; Void) -&gt; AnyPublisher&lt;Output, Failure&gt; {
            Future&lt;Output, Failure&gt; { promise in
                self.addOperation {
                    block(promise)
                }
            }.eraseToAnyPublisher()
        }
    }

    struct ContentView: View {


        func getDataViaPublisher()-&gt;AnyPublisher&lt;String,Error&gt; {

            OperationQueue.main.publisher { promise in

                Timer.scheduledTimer(withTimeInterval: Double.random(in: 1...3), repeats: false) { (timer) in. // &lt;&lt;&lt;&lt;&lt; error here
                    promise(.success(""Chris""))
                }
            }
        }
</code></pre>
","8457280","","","","","2020-05-26 04:09:31","Escaping closure captures non-escaping parameter 'promise'","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62014524","1","62014863","","2020-05-26 04:07:56","","1","2764","<p>In Combine how do you make a publisher that sends one value but never completes?</p>

<p>In the following code receiveCompletion gets called but I don't want it to:</p>

<pre class=""lang-swift prettyprint-override""><code>Just(1)
    .sink(
        receiveCompletion: {
            print(""Completion: \($0)"")
    },
        receiveValue: {
            print(""Value: \($0)"")
    }
)
</code></pre>

<p>How can I emit just one value but not complete...?</p>
","12587089","","","","","2020-05-26 08:32:24","In Combine how do you make a publisher that sends one value but never completes?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"62029382","1","62030142","","2020-05-26 18:57:04","","6","1808","<p>I am trying to observe changes of a <code>bool</code> value contained in an <code>ObservableObject</code> which is a value in an <code>enum</code> case. Here is an example of what I am trying to achieve but with the current approach I receive the error <code>Use of unresolved identifier '$type1Value'</code>.</p>

<pre><code>import SwiftUI
import Combine

class ObservableType1: ObservableObject {
    @Published var isChecked: Bool = false
}

enum CustomEnum {
    case option1(ObservableType1)
}

struct Parent: View {
    var myCustomEnum: CustomEnum
    var body: AnyView {
        switch myCustomEnum {
        case .option1(let type1Value):
            AnyView(Child(isChecked: $type1Value.isChecked)) // &lt;- error here
        }
    }
}

struct Child: View {
    @Binding var isChecked: Bool
    var body: AnyView {
        AnyView(
            Image(systemName: isChecked ? ""checkmark.square"" : ""square"")
            .onTapGesture {
                self.isChecked = !self.isChecked
        })
    }
}
</code></pre>

<p>I am trying to update the value of <code>isChecked</code> from the interface but since I want to have the <code>ObservableObject</code> which contains the property in an <code>enum</code> like <code>CustomEnum</code> not sure how to do it or if it is even possible. I went for an enum because there will be multiple enum options with different <code>ObservableObject</code> values and the <code>Parent</code> will generate different subviews depending on the <code>CustomEnum</code> option. If it makes any relevance the <code>Parent</code> will receive the <code>myCustomEnum</code> value from an <code>Array</code> of <code>CustomEnum</code> values. Is this even possible? If not, what alternatives do I have? Thank you!</p>
","1310984","","","","","2022-06-03 14:21:49","SwiftUI two-way binding to value inside ObservableObject inside enum case","<ios><swift><binding><swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"62037727","1","62048039","","2020-05-27 07:35:00","","9","4676","<p>I know in general a publisher is more powerful than a closure, however I want to ask and discuss a specific example:</p>

<pre><code>func getNotificationSettingsPublisher() -&gt; AnyPublisher&lt;UNNotificationSettings, Never&gt; {
   let notificationSettingsFuture = Future&lt;UNNotificationSettings, Never&gt; { (promise) in
      UNUserNotificationCenter.current().getNotificationSettings { (settings) in
         promise(.success(settings))
      }
   }
   return notificationSettingsFuture.eraseToAnyPublisher()
}
</code></pre>

<p>I think this is a valid example of a Future publisher and it could be used here instead of using a completion handler. Let's do something with it:</p>

<pre><code>func test() {
    getNotificationSettingsPublisher().sink { (notificationSettings) in
       // Do something here        
    }
}
</code></pre>

<p>This works, however it will tell me that the result of sink (<code>AnyCancellable</code>) is unused. So whenever I try to get a value, I need to either store the cancellable or assign it until I get a value.</p>

<p>Is there something like sinkOnce or an auto destroy of cancellables? Sometimes I don't need tasks to the cancelled. I could however do this:</p>

<pre><code>func test() {
   self.cancellable = getNotificationSettingsPublisher().sink { [weak self] (notificationSettings) in
      self?.cancellable?.cancel()
      self?.cancellable = nil
   }
}
</code></pre>

<p>So once I receive a value, I cancel the subscription. (I could do the same in the completion closure of sink I guess).</p>

<p>What's the correct way of doing so? Because if I use a closure, it will be called as many times as the function is called, and if it is called only once, then I don't need to cancel anything.</p>

<p>Would you say normal completion handlers could be replaced by Combine and if so, how would you handle receiving one value and then cancelling?</p>

<p>Last but not least, the completion is called, do I still need to cancel the subscription? I at least need to update the cancellable and set it to nil right? I assume storing subscriptions in a set is for long running subscriptions, but what about single value subscriptions?</p>

<p>Thanks</p>
","1582047","","","","","2020-05-27 16:28:24","Swift Combine publishers vs completion handler and when to cancel","<swift><combine>","1","2","2","","","CC BY-SA 4.0"
"62071908","1","62079390","","2020-05-28 18:25:13","","0","401","<p>All of my API endpoints return a response which looks something like this in Postman:</p>

<pre><code>{
    ""statusCode"": 401,
    ""error"": ""Unauthorized"",
    ""message"": ""Missing authentication""
}
</code></pre>

<p>What I would like to do is make the request, and have access to these properties in Swift. There will be some cases where I use the error message property's value in the front of the app. This will be determined by the statusCode returned.</p>

<p>What I have right now is this:</p>

<pre><code>    private var cancellable: AnyCancellable?
    let url = URL(string: ""http://abc336699.com/create"")
    self.cancellable = URLSession.shared.dataTaskPublisher(for: url!)
      .map { $0.data }
</code></pre>

<p>Prior to this, I tried tryMap, but the type of error it returned didn't give me the flexibility I wanted. I then moved on and tried Almofire, but it seemed like an over kill for what I want to do.</p>

<p>I wanted to check what is being returned in the response I get, but I get the following error:</p>

<pre><code>Cannot assign value of type 'Publishers.Map&lt;URLSession.DataTaskPublisher, Data&gt;' to type 'AnyCancellable'
</code></pre>

<p>I want simple access to my response errors so I can integrate the API throughout the app using combine.</p>
","439688","","","","","2020-05-29 20:34:53","How do I read the property values of a JSON error object using Combine in Swift?","<swift><swiftui><combine>","1","6","1","","","CC BY-SA 4.0"
"62077556","1","62077753","","2020-05-29 02:08:41","","0","112","<p>I recently discovered that usage of the new Combine SDK in a macOS necessitates a minimum deployment target of 10.15. </p>

<p>Admittedly, I am new to macOS development. It is surprising to me that a library of this nature would have strict dependencies on the latest OS version.</p>

<p>My mental model (which is apparently missing key information) tells me either (a) the SDK uses new syscalls introduced in 10.15 or (b) macOS binaries are dynamically-linked and not statically-linked as I had assumed.</p>

<p>Is it some other (c)?</p>
","13538737","","","","","2020-05-29 16:45:12","Why does Combine require macOS 10.15 and above?","<swift><macos><appkit><combine>","1","0","","","","CC BY-SA 4.0"
"62090286","1","62095757","","2020-05-29 16:13:58","","6","839","<p>I am trying to set up a publisher that will publish a set of integers and at some point may fail. It's slightly contrived but hopefully illustrates principle. Example below.</p>

<pre><code>enum NumberError: Int, Error {
   case isFatal, canContinue
}

struct Numbers {
    let p = PassthroughSubject&lt;Int, NumberError&gt;()

    func start(max: Int) {

        let errorI = Int.random(in: 1...max)
        for i in (1...max) {
            if errorI == i {
                p.send(completion: .failure(NumberError.canContinue))
            } else {
                p.send(i)
            }
        }
        p.send(completion: .finished)

    }
}
</code></pre>

<p>I then subscribe using:</p>

<pre><code>let n = Numbers()
let c = n.p
    .catch {_ in return Just(-1)}

    .sink(receiveCompletion: {result in
        switch result {
        case .failure:
            print(""Error"")
        case .finished:
            print(""Finished"")
        }
    }, receiveValue: {
        print($0)
    })

n.start(max: 5)
</code></pre>

<p>This works in that it replaces errors with -1 but I would then like to continue receiving values. Does anyone know if this is possible?
Having read and looked around it seems that flatMap may be the way to go but I can't work out what publisher to use in the closure? Any help much appreciated.</p>
","11302366","","","","","2020-05-29 22:59:33","How to continue subscribing to publisher after error?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62093956","1","62105001","","2020-05-29 20:13:18","","0","543","<p>I have a problem when trying to use a bool as part of a swift struct.</p>

<pre><code>struct MapPrefs: Identifiable {
    var id = UUID()
    var name: String
    var isShown: Bool

}
</code></pre>

<p>An array of these prefs are provided by a store to a swift-UI view</p>

<pre><code>class MapPrefsStore : ObservableObject {

    var willChange = PassthroughSubject&lt;Void, Never&gt;()

    @Published var MapPrefs: [MapPrefs] {
        didSet { willChange.send(()) }
    }

    init(mapPrefs: [MapPrefs]) {
        self.MapPrefs = mapPrefs
    }

}
</code></pre>

<p>The Settings View Observes the Store and passes the array to a cell view</p>

<pre><code>struct SettingsView: View {


    @ObservedObject var mapPrefsStore = MapPrefsStore(mapPrefs: MapPrefsTestData)


    var body: some View {

        NavigationView {
            List {

                 Section(header: Text(""Map Preferences""), footer: Text("""")) {

                    ForEach(mapPrefsStore.MapPrefs) { mapPrefs in
                        MapPrefsCell(mapPrefs: mapPrefs)
                    }
                    .onMove(perform: moveMap)
                                }
                .background(Color.clear)
            }
            .navigationBarTitle(Text(""Settings""))
            .navigationBarItems(trailing: EditButton())
            .listStyle(GroupedListStyle())
        }
    }
    func moveMap(from source: IndexSet, to destination: Int) {
        guard let sourceIndex = Array(source).first else { return }
        mapPrefsStore.MapPrefs.insert(mapPrefsStore.MapPrefs.remove(at: sourceIndex), at: destination)
    }
}

struct MapPrefsCell : View {
    let mapPrefs: MapPrefs

    var body: some View {

        Toggle(isOn: mapPrefs.isShown) {
            Text(mapPrefs.name)
        }
    }
}
}
</code></pre>

<p>this gives me the following error </p>

<p><code>Cannot convert value of type 'Bool' to expected argument type 'Binding&lt;Bool&gt;'</code></p>

<p>I can't figure out how to allow the called function (MapPrefsCell) the ability to access the isShown property.  I tried various combinations of adding the $ sign.</p>
","333661","","333661","","2020-05-29 20:30:12","2020-05-30 15:55:13","Using Bool In Struct in SwiftUI","<swift>","2","0","1","","","CC BY-SA 4.0"
"62095182","1","62095636","","2020-05-29 21:57:36","","7","3602","<p>If you use Combine for network requests with <code>URLSession</code>, then you need to save the <code>Subscription</code> (aka, the <code>AnyCancellable</code>) - otherwise it gets immediately deallocated, which cancels the network request. Later, when the network response has been processed, you want to deallocate the subscription, because keeping it around would be a waste of memory. </p>

<p>Below is some code that does this. It's kind of awkward, and it may not even be correct. I can imagine a race condition where network request could start and complete on another thread before <code>sub</code> is set to the non-nil value.</p>

<p>Is there a nicer way to do this?</p>

<pre><code>class SomeThing {
    var subs = Set&lt;AnyCancellable&gt;()
    func sendNetworkRequest() {
        var request: URLRequest = ...
        var sub: AnyCancellable? = nil            
        sub = URLSession.shared.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: MyResponse.self, decoder: JSONDecoder())
            .sink(
                receiveCompletion: { completion in                
                    self.subs.remove(sub!)
                }, 
                receiveValue: { response in ... }
            }
        subs.insert(sub!)
</code></pre>
","327572","","","","","2021-11-10 05:23:27","With Combine, how to deallocate the Subscription after a network request","<swift><combine><urlsession>","3","0","2","","","CC BY-SA 4.0"
"62096858","1","62096938","","2020-05-30 01:47:19","","1","843","<p>I’m trying to change a view based on a selection made with a button. I’m using Combine and SwiftUI.</p>

<p>I create a view router class with a <code>@Published</code> var:</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import SwiftUI
import Combine

class ViewRouter: ObservableObject {

    @Published var currentView = ""folder""

}
</code></pre>

<p>I have my button struct:</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

struct MultiButton: View {
    @ObservedObject var viewRouter = ViewRouter()
    @State var showButton = false

    var body: some View {
        GeometryReader { geometry in
            ZStack{

                // open multi button
                Button(action: {

                    withAnimation {
                        self.showButton.toggle()
                    }
                }) {
                    Image(systemName: ""gear"")
                        .resizable()
                        .frame(width: 40, height: 40, alignment: .center)
                }
                if self.showButton {

                    Multi()
                    .offset(CGSize(width: -30, height: -100))
                }
            }


        }
    }
}

struct MultiButton_Previews: PreviewProvider {
    static var previews: some View {
        MultiButton()
    }
}

struct Multi: View {

 @ObservedObject var viewRouter = ViewRouter()

    var body: some View {
        HStack(spacing: 10) {
            ZStack {

                Button(action: {
                    self.viewRouter.currentView = ""folder""
                     debugPrint(""\(self.viewRouter.currentView)"")
                }) {
                    ZStack{

                    Circle()
                        .foregroundColor(Color.blue)
                        .frame(width: 70, height: 70)
                    Image(systemName: ""folder"")
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .padding(20)
                        .frame(width: 70, height: 70)
                        .foregroundColor(.white)
                    }.shadow(radius: 10)
                }
            }

            Button(action: {
                self.viewRouter.currentView = ""setting""
                debugPrint(""\(self.viewRouter.currentView)"")
            }, label: {
                ZStack {
                    Circle()
                        .foregroundColor(Color.blue)
                        .frame(width: 70, height: 70)
                    Image(systemName: ""gear"")
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .padding(20)
                        .frame(width: 70, height: 70)
                        .foregroundColor(.white)
                }.shadow(radius: 10)
            })
        }
            .transition(.scale)
    }
}
</code></pre>

<p>And the <code>contentView</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

struct ContentView: View {
    @ObservedObject var viewRouter = ViewRouter()
    var body: some View {
        VStack{

            MultiButton()

            if viewRouter.currentView == ""folder"" {
                Text(""folder"")
            } else if viewRouter.currentView == ""setting""{
                Text(""setting"")
            }
        }
    }
}
</code></pre>

<p>Why is my text is not changing from the folder to setting the base when the button is pressEd?</p>

<p>The var is <code>@Published</code>; it should publish the change and update the main view.</p>

<p>Did I miss something?</p>
","9962676","","3025856","","2020-05-30 07:32:45","2020-05-30 07:32:45","SwiftUI: changing view using ""if else""","<swift><xcode><swiftui><observable><combine>","1","0","","","","CC BY-SA 4.0"
"62104905","1","62112098","","2020-05-30 15:47:55","","-1","185","<p>I'm trying to model my data with the <strong>Model, View, Viewmodel framework.</strong></p>

<p>In my project, i have a <strong>Model called Category</strong> which is a class. 
Each Category have and id, a name and a var isActive of type bool.</p>

<p>I'm currently displaying a Hstack ScrollView with all my categories as buttons.
<a href=""https://i.stack.imgur.com/Gout5.jpg"" rel=""nofollow noreferrer"">Click here to visually see my view.</a></p>

<p>I added a <strong>OnTapGesture on each category button</strong> to change the size of the button when tapped.
My problem is that <strong>i can have more than one category selected at the same time</strong>.</p>

<p>I'm wondering <strong>what's the best way to structure my data so that i can only select one category</strong>.</p>

<p>Should i delete the isActive variable on my Category Model ? 
What should i try next ?</p>

<p>Category Model - </p>

<pre><code>Category Model
struct Category: Identifiable {

    var id = UUID().uuidString
    var category: categories
    var isActive: Bool

}

/// Represent all possible categories cases
enum categories: String, CaseIterable {
    case love = ""❤️""
    case family = ""👨‍👩‍👦‍👦""
    case urgent = ""🆘""
    case sex = ""🔥""
    case funny = ""😂""
    case school = ""🤓""
    case sport = ""🏅""
}

#if DEBUG
let categoryTest = [
    Category(category: .love, isActive: false),
    Category(category: .family, isActive: false),
    Category(category: .urgent, isActive: false),
    Category(category: .sex, isActive: false),
    Category(category: .funny, isActive: false),
    Category(category: .school, isActive: false),
    Category(category: .sport, isActive: false)
]
#endif
</code></pre>

<p>CategoriesView - </p>

<pre><code>//Categories View - Looping all categories &amp; CategoryView - The way i display each category and add the Tap Gesture
import SwiftUI
import Foundation
import Combine

struct CategoriesView: View {

    @ObservedObject var categoriesVM = CategoriesViewModel()

    var body: some View {
        VStack(alignment: .leading) {

            Text(""Catégories"")
                .font(.title).bold()
                .offset(y: 20)

            ScrollView(.horizontal, showsIndicators: false) {
                HStack {
                    ForEach(categoriesVM.categoryViewModel) { categoryVM in
                        CategoryView(categoryVM: categoryVM)
                    }

                }
            }
        }
        .padding(.leading, 15)
    }
}

struct CategoriesView_Previews: PreviewProvider {
    static var previews: some View {
        CategoriesView()
    }
}


struct CategoryView: View {
    @ObservedObject var categoryVM: CategoryViewModel

    var onComit: (Category) -&gt; (Void) = { _ in }

    var body: some View {
        HStack {

            Text(categoryVM.category.category.rawValue)
                .font(.system(size: self.categoryVM.category.isActive ? 26 : 22, weight: .bold))
            .frame(
                width: self.categoryVM.category.isActive ? 80 : 60,
                height: self.categoryVM.category.isActive ? 80 : 60
            )
            .background(Color.white)
            .clipShape(RoundedRectangle(cornerRadius: 10, style: .continuous))
            .shadow(color: Color.black.opacity(0.1), radius: 10, x: 10, y: 10)
            .onTapGesture {
                self.categoryVM.category.isActive.toggle()
                print(""Tapped, state: \(self.categoryVM.category.isActive)"")
            }

        }
        .frame(height: 130)
    }
}
</code></pre>

<p>Category View Model - </p>

<pre><code>import SwiftUI
import Foundation
import Combine

class CategoryViewModel: ObservableObject, Identifiable {

    @Published var category: Category
    var id: String = """"
    private var cancellables = Set&lt;AnyCancellable&gt;()
//    @Published var categoryIcon = """"

    init(category: Category) {
        self.category = category

        $category // (7)
        .map { $0.id }
        .assign(to: \.id, on: self)
        .store(in: &amp;cancellables)

}

}
</code></pre>

<p>Categories View Model - </p>

<pre><code>import SwiftUI
import Foundation
import Combine

class CategoriesViewModel: ObservableObject, Identifiable {

    @Published var categoryViewModel = [CategoryViewModel]()

    private var cancellables =  Set&lt;AnyCancellable&gt;()

    init() {
        self.categoryViewModel = categoryTest.map { category in
            CategoryViewModel(category: category)
        }
    }
}
</code></pre>
","10104942","","","","","2020-05-31 05:47:50","SwiftUI - Only one object property true in Array","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"62108591","1","62109143","","2020-05-30 20:57:17","","3","872","<p>When attempting to send a background request with <code>URLSession</code>'s <code>dataTaskPublisher</code> method:</p>

<pre class=""lang-swift prettyprint-override""><code>URLSession(configuration: URLSessionConfiguration.background(withIdentifier: ""example"")) 
     .dataTaskPublisher(for: URL(string: ""https://google.com"")!) 
     .map(\.data) 
     .sink(receiveCompletion: { print($0) }) { print($0) }
</code></pre>

<p>I receive the error</p>

<pre><code>Completion handler blocks are not supported in background sessions. Use a delegate instead.
</code></pre>

<p>This makes sense to me, <code>sink</code> is a bunch of completion handlers. So, I tried to build a <code>Subscriber</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>class ExampleSubscriber: Subscriber {
    typealias Input = Data

    typealias Failure = URLError

    func receive(subscription: Subscription) {
        subscription.request(.max(1))
    }

    func receive(_ input: Data) -&gt; Subscribers.Demand {
        print(input)

        return Subscribers.Demand.none
    }

    func receive(completion: Subscribers.Completion&lt;URLError&gt;) {}

}
</code></pre>

<p>and subscribe with the <code>Subscriber</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>URLSession(configuration: URLSessionConfiguration.background(withIdentifier: ""example""))
    .dataTaskPublisher(for: URL(string: ""https://google.com"")!)
    .map(\.data)
    .subscribe(ExampleSubscriber())
</code></pre>

<p>and I receive the same error:</p>

<pre><code>Completion handler blocks are not supported in background sessions. Use a delegate instead.
</code></pre>

<p>Is it possible to perform a background request using <code>dataTaskPublisher</code> or do I <em>have</em> to use a delegate to <code>URLSession</code>?</p>
","1352094","","","","","2020-05-31 09:17:29","Background URLSession + Combine?","<swift><combine>","1","3","1","","","CC BY-SA 4.0"
"62116329","1","62116825","","2020-05-31 12:36:41","","3","484","<p>Let's say I have:</p>

<ul>
<li>structure <code>Document</code>, which represents text document.</li>
<li><code>EditorView</code>  — an <code>NSTextView</code>, wrapped with Combine, which binds to <code>Document.content&lt;String&gt;</code>. </li>
</ul>

<p><code>Document</code> is a part of complex <code>store:ObservableObject</code>, so it can be bouneded to <code>EditorView</code> instance.</p>

<p>When I first create binding, it works as expected — editing NSTextView changes value in <code>Document.content</code>.</p>

<pre class=""lang-swift prettyprint-override""><code>let document1 = Document(...)
let document2 = Document(...)
var editor = EditorView(doc: document1)
</code></pre>

<p>But if change binding to another Document...</p>

<pre class=""lang-swift prettyprint-override""><code>editor.doc = document2
</code></pre>

<p>...then <code>updateNSView</code> can see new <code>document2</code>. But inside Coordiantor's <code>textDidChange</code>  has still refrence to <code>document1</code>.</p>

<pre class=""lang-swift prettyprint-override""><code>func textDidChange(_ notification: Notification) {
    guard let textView = notification.object as? NSTextView else {
        return
    }

    self.parent.doc.content = textView.string
    self.selectedRanges = textView.selectedRanges
}
</code></pre>

<p>So, initially, when i set new bindint, NSTextView changes it content to <code>document2</code>, but as I type, coordinator sends changes to <code>document1</code>.</p>

<p>Is it true, that Coordiantor keeps it's own copy of <code>parent</code>, and even if parent changes (<code>@Binding doc</code> is updated), it still references to old one?</p>

<p>How to make Coordinator reflect parent's bindings changes?</p>

<p>Thank you!</p>

<pre class=""lang-swift prettyprint-override""><code>struct Document: Identifiable, Equatable {
    let id: UUID = UUID()
    var name: String
    var content: String
}

struct EditorView: NSViewRepresentable {
    @Binding var doc: Document

    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self)
    }

    func makeNSView(context: Context) -&gt; CustomTextView {
        let textView = CustomTextView(
            text: doc.content,
            isEditable: isEditable,
            font: font
        )
        textView.delegate = context.coordinator

        return textView
    }

    func updateNSView(_ view: CustomTextView, context: Context) {
        view.text = doc.content
        view.selectedRanges = context.coordinator.selectedRanges

    }
}


// MARK: - Coordinator

extension EditorView {

    class Coordinator: NSObject, NSTextViewDelegate {
        var parent: EditorView
        var selectedRanges: [NSValue] = []

        init(_ parent: EditorView) {
            self.parent = parent
        }

        func textDidBeginEditing(_ notification: Notification) {
            guard let textView = notification.object as? NSTextView else {
                return
            }

            self.parent.doc.content = textView.string
            self.parent.onEditingChanged()
        }

        func textDidChange(_ notification: Notification) {
            guard let textView = notification.object as? NSTextView else {
                return
            }

            self.parent.doc.content = textView.string
            self.selectedRanges = textView.selectedRanges
        }

        func textDidEndEditing(_ notification: Notification) {
            guard let textView = notification.object as? NSTextView else {
                return
            }

            self.parent.doc.content = textView.string
            self.parent.onCommit()
        }
    }
}

// MARK: - CustomTextView

final class CustomTextView: NSView {
    private var isEditable: Bool
    private var font: NSFont?

    weak var delegate: NSTextViewDelegate?

    var text: String {
        didSet {
            textView.string = text
        }
    }
    // ...
</code></pre>
","1275294","","1275294","","2020-05-31 16:34:17","2020-05-31 16:34:17","How to make Swift Coordinator reflect parent's bindings changes?","<swift><swiftui><appkit><combine>","1","0","","","","CC BY-SA 4.0"
"62124297","1","62124578","","2020-06-01 01:05:51","","0","63","<p><a href=""https://rxjs-dev.firebaseapp.com/api/index/function/iif"" rel=""nofollow noreferrer"">iif</a> is a useful operator that can decide which Observable to subscribe to at runtime. Is there an equivalent in Swift Combine framework with publisher? If not, what's a good workaround?</p>
","3808183","","","","","2020-06-01 01:48:17","Combine equivalent of RxJS iif","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62131257","1","62141356","","2020-06-01 11:36:09","","0","1984","<p>I may be going about this the wrong way, but I have a function with which I want to emit multiple values over time. But I don’t want it to start emitting until something is subscribed to that object. I’m coming to combine from RxSwift, so I’m basically trying to duplicated Observable.create() in the RxSwift world. The closest I have found is returning a Future, but futures only succeed or fail (so they are basically like a Single in RxSwift.) </p>

<p>Is there some fundamental thing I am missing here? My end goal is to make a function that processes a video file and emits progress events until it completes, then emits a URL for the completed file. </p>
","11017643","","","","","2020-06-01 21:34:52","Swift Combine Future with multiple values?","<swift><rx-swift><combine>","1","1","","","","CC BY-SA 4.0"
"62139342","1","62139427","","2020-06-01 19:12:43","","4","1842","<p>I'm trying to perform side effect on <code>Publisher</code>, and I can't find any operator which will allow me to do something like this. To be precise, I'm looking for a concept similar to RxSwift's <code>do(on:)</code>.</p>

<p>Here's what I'm trying to do.
I'm writing a reactive wrapper for a delegate provided by a 3rd party SDK. It's and SDK for interacting with BLE devices. I have methods like <code>startScanning</code> and <code>stopScanning</code> and what I want to achieve is to react to signals and call <code>stopScanning</code> as a side effect of any error or complete events. So far, I have something like this:</p>

<pre class=""lang-swift prettyprint-override""><code>newDeviceFoundPublisher
            .timeout(.seconds(timeout), scheduler: DispatchQueue.global())
            .eraseToAnyPublisher()
</code></pre>

<p>and what I want to achieve is something like:</p>

<pre class=""lang-swift prettyprint-override""><code>newDeviceFoundPublisher
            .timeout(.seconds(timeout), scheduler: DispatchQueue.global())
            .doOnError {
                manager.stopScanning()
            }
            .doOnComplete {
                manager.stopScanning()
            }
            .eraseToAnyPublisher()
</code></pre>

<p>Is there already something like this or maybe I'm missing something, and there's something in Combine I can use and get the result?</p>
","1911042","","","","","2020-06-01 19:18:14","Performing side effects on Publisher","<ios><swift><combine><frp>","1","0","1","","","CC BY-SA 4.0"
"62158279","1","62160035","","2020-06-02 17:53:11","","2","406","<p>I have a function that returns a publisher. This publisher gives the results of a background process. I only want to trigger the background process when the publisher would be subscribed, so that no results are lost. The background process can update its results many times, so the variant with <code>Future</code> is not suitable.</p>

<pre><code>private let passthroughSubject = PassthroughSubject&lt;Data, Error&gt;()

// This function will be used outside.
func fetchResults() -&gt; AnyPublisher&lt;Data, Error&gt; {
     return passthroughSubject
     .eraseToAnyPublisher()
     .somehowTriggerTheBackgroundProcess()
}

extension MyModule: MyDelegate {
     func didUpdateResult(newResult: Data) {
          self.passthroughSubject.send(newResult)
     }
}
</code></pre>

<p>What have I tried?</p>

<p>Future:</p>

<pre><code>Future&lt;Data, Error&gt; { [weak self] promise in
     self?.passthroughSubject
          .sink(receiveCompletion: { completion in
               // My logic
          }, receiveValue: { value in
               // My logic    
          })
          .store(in: &amp;self.cancellableSet)
      self?.triggerBackgroundProcess()
}.eraseToAnyPublisher()
</code></pre>

<p>Works the way I want but the subscriber is called only once (logical).</p>

<p>Deffered:</p>

<pre><code>Deferred&lt;AnyPublisher&lt;Data, Error&gt;&gt;(createPublisher: { [weak self] in
   defer {
      self?.triggerBackgroundProcess()
   }
   return passthroughSubject.eraseToAnyPublisher()
}
</code></pre>

<p>Debugger shows that everything is correct: first <code>return</code> then <code>trigger</code> but the subscriber is not called for the first time.</p>

<p><code>receiveSubscription</code>:</p>

<pre><code>passthroughSubject
.handleEvents(receiveSubscription: { [weak self] subscription in 
   self?.triggerBackgroundProcess()
})
.eraseToAnyPublisher()
</code></pre>

<p>The same effect as with <code>Deffered</code>.</p>

<p>Is it even possible what I want to achieve? 
Or, it is better to create a public publisher subscribe it and receive results from background process. And the <code>fetchResults()</code> function doesn't return anything?</p>

<p>Thanks in advance for your help.</p>
","11837681","","","","","2020-06-02 19:40:56","How can I trigger a process after a returned publisher would be subscribed?","<swift><combine>","2","4","1","","","CC BY-SA 4.0"
"62164578","1","62164627","","2020-06-03 03:08:51","","0","181","<p>In my app, I want to store an object in Environment to perform network queries from various views. However, during development I'd like to use a mock instead, and retrieve the payload (in JSON format) from the app's bundle. These are the steps I've taken:</p>

<ol>
<li>Specify the protocol</li>
</ol>

<pre><code>    typealias Token = String

    protocol MyAPIConforming {
        func signIn(username: String, password: String, completion: @escaping (Token?, Error?) -&gt; Void)
    }
</code></pre>

<ol start=""2"">
<li>Implement the two classes I need</li>
</ol>

<pre><code>    class MockMyAPIManager: MyAPIConforming, ObservableObject {
        func signIn(username: String, password: String, completion: @escaping (Token?, Error?) -&gt; Void) {
            // Read the JSON document from the app's bundle
        }
    }

    class MyAPIManager: MyAPIConforming, ObservableObject {
        func signIn(username: String, password: String, completion: @escaping (Token?, Error?) -&gt; Void) {
            // Perform the network request
        }
    }
</code></pre>

<ol start=""3"">
<li>Inject the mock object in the Environment</li>
</ol>

<pre><code>    let myManager = MockMyAPIManager()

    // Create the SwiftUI view that provides the window contents.
    let contentView = LoginView().environmentObject(myManager)
</code></pre>

<ol start=""4"">
<li>Declare the @Environment object in the view</li>
</ol>

<pre><code>    struct LoginView: View {
    @EnvironmentObject var myManager: MyAPIConforming
    ...
</code></pre>

<p>I did declare <code>myManager</code> to be <code>MyAPIConforming</code> because I could be passing an object of type <code>MockMyAPIManager</code> or <code>MyAPIManager</code>.</p>

<p>However, in step #4 I get the following error:</p>

<blockquote>
  <p>Property type 'MyAPIConforming' does not match that of the 'wrappedValue' property of its wrapper type 'EnvironmentObject'</p>
</blockquote>

<p>I'm not sure if the error means that there is no guarantee that the object adopting to <code>MyAPIConforming</code> will be also adopting the <code>ObservableObject</code> protocol.</p>

<p>So what do I need to do to store either <code>MockMyAPIManager</code> or <code>MyAPIManager</code> in the environment? Is this even possible?</p>
","686765","","","","","2020-06-03 04:45:06","Store a mock object in the Environment","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"62179405","1","62180833","","2020-06-03 17:49:01","","0","1026","<p>I have this code in lrvViewModel.swift</p>

<pre><code>func getVerificationID (phoneNumber: String) -&gt; Future&lt;String?, Error&gt; {

        return Future&lt;String?, Error&gt; { promise in
            PhoneAuthProvider.provider().verifyPhoneNumber(phoneNumber, uiDelegate: nil) { (verificationID, error) in
                if let e = error {
                    promise(.failure(e))
                    return
                }
                print(""verification worked"")
                self.defaults.set(verificationID, forKey: ""authVerificationID"")
                return promise(.success(verificationID))
            }
        }
    }
</code></pre>

<p>and then i call and subscribe to the Publisher in another file like this</p>

<pre><code>let _ = lrvViewModel.getVerificationID(phoneNumber: (lrvViewController?.textField.text)!)
                .sink(receiveCompletion: {
                    print(""Error worked"")
                    // does a bunch of stuff
                }, receiveValue: {
                    print(""completion worked"")
                    // does a bunch of stuff
                })
</code></pre>

<p>I don't get any buildtime errors, but whenever I run the app the GetVerificationID function runs fine (prints ""Verification worked""), but the code within .sink doesn't run (I don't get any print statements). What's going on?</p>

<hr>

<p>Edit:</p>

<p>My solution was to give up on combine and go back to RXSwift where the code is simply:</p>

<pre><code> var validateObs = PublishSubject&lt;Any&gt;()

    func getVerificationID (phoneNumber: String) {

        PhoneAuthProvider.provider().verifyPhoneNumber(phoneNumber, uiDelegate: nil) { (verificationID, error) in
            if let e = error {
                print(""v error"")
                self.validateObs.onError(e)
                return
            }
            self.defaults.set(verificationID, forKey: ""authVerificationID"")
            self.validateObs.onCompleted()
            }
    }
</code></pre>

<p>and </p>

<pre><code>lrvViewModel.getVerificationID(phoneNumber: (lrvViewController?.textField.text)!)

            let _ = lrvViewModel.validateObs.subscribe(onError: {
                let e = $0
                print(e.localizedDescription)
                // do stuff
            }, onCompleted: {
                // do stuff

                })
</code></pre>

<p>Was hoping to not rely on a dependency but RxSwift implementation was much easier. </p>

<p>If someone knows the solution to the Combine Future problem please post! I would still like to know wtf is happening. It's very possible (and likely) I'm just using combine wrong. </p>

<hr>

<p>Edit 2:</p>

<p>Was using combine wrong. I can duplicate the code I had with RXSwift like this:</p>

<pre><code>let verifyPub = PassthroughSubject&lt;Any, Error&gt;()

func getVerificationID (phoneNumber: String) {

    PhoneAuthProvider.provider().verifyPhoneNumber(phoneNumber, uiDelegate: nil) { (verificationID, error) in
            if let e = error {
                self.verifyPub.send(completion: .failure(e))
                return
            }
            print(""verification worked"")
            self.defaults.set(verificationID, forKey: ""authVerificationID"")
        self.verifyPub.send(completion: .finished)
        }
    }
</code></pre>

<p>and </p>

<pre><code>let subs = Set&lt;AnyCancellable&gt;()
let pub = lrvViewModel.verifyPub
                .sink(receiveCompletion: { completion in
                    if case let .failure(error) = completion {
                        print(""Error worked"")
                       // do stuff
                    } else {
                        print(""completion worked"")
                        // do stuff
                    }
                    }, receiveValue: { _ in
                        print(""this will never happen"")
                    }).store(in: &amp;subs)
</code></pre>

<p>I didnt' understand that in combine there are only two results to a sink, a completion or a value, and that completion is split up into multiple cases. Whereas in RxSwift you have OnNext, OnComplete, and OnError. </p>

<p>Shoutout to the book on Combine from raywanderlich.com. Good stuff. </p>
","12728118","","12728118","","2020-06-04 16:13:30","2020-06-04 16:13:30",".sink is not returning the promise values from a Future Publisher","<swift><xcode><reactive-programming><ios13><combine>","1","3","","","","CC BY-SA 4.0"
"62183641","1","62185933","","2020-06-03 22:18:16","","1","287","<p>I'm new to swift and I cannot get the UserDefaults updated values in the same session. Only after the application restarts.</p>

<p>Here is what I mean in some code:</p>

<pre><code>//This is where I have the userdefaults
@ObservedObject var userSettingsController = UserSettingsController

//These are the auxiliar vars I created to help me achieve the conditional renders I need. I'm looking to get rid of these and use the usersettings updated values
@State private var showMap = false
@State private var showTutorial = true

//Partial code of my view, where I'm using the variables
if(!self.userSettingsController.showActionSheet &amp;&amp; self.showMap) {
   showMapView()
     .onTapGesture {
        if (self.userSettingsController.showNextDeparturesTutorial &amp;&amp; self.showTutorial {
          self.showTutorial = false
          self.userSettingsController.showNextDeparturesTutorial.toggle()
        } else {
        //code that has nothing to do with the question
</code></pre>

<p>No, here is my UserSettings and UserSettingsController classes:</p>

<p><strong>UserSettings</strong></p>

<pre><code>import Foundation

struct UserSettings {
    var settings: UserDefaults

    init() {
        self.settings = UserDefaults.standard
        self.settings.register(
            defaults: [
                ""userCity"": """",
                ""showUserCityActionSheet"": true,
                ""showNextDeparturesTutorial"": true,
        ])
    }
}
</code></pre>

<p><strong>UserSettingsController</strong></p>

<pre><code>import Foundation
import Combine
import SwiftUI

class UserSettingsController: ObservableObject {
    @Published var userSettings = UserSettings()

    var userCity : String {
        get {
            return self.userSettings.settings.string(forKey: ""userCity"") ?? """"
        }
        set {
            self.userSettings.settings.set(newValue, forKey: ""userCity"")
        }
    }

    var showUserCityActionSheet: Bool {
        get {
            return self.userSettings.settings.bool(forKey: ""showUserCityActionSheet"")
        }
        set {
            self.userSettings.settings.set(newValue, forKey: ""showUserCityActionSheet"")
        }
    }

    var showNextDeparturesTutorial: Bool {
        get {
            return self.userSettings.settings.bool(forKey: ""showNextDeparturesTutorial"")
        }
        set {
            self.userSettings.settings.set(newValue, forKey: ""showNextDeparturesTutorial"")
        }
    }
}
</code></pre>

<p>My question is, how can I get the updated values of the UserDefault values showNextDeparturesTutorial and showActionSheet in realtime? I've already tried to store them in other variables but to no avail.</p>

<p>Thanks.</p>

<p><strong>EDIT</strong></p>

<p>I accepted @Asperi answer because it was the most efficient one considering my project.
However, @pawello2222 answer would also solve my problem.</p>

<p>Thanks, all.</p>
","6380249","","6380249","","2020-06-04 14:55:48","2020-06-04 14:55:48","Cannot get UserDefautls updated values in realtime","<ios><swift><xcode><swiftui><userdefaults>","3","2","1","","","CC BY-SA 4.0"
"62191269","1","62193426","","2020-06-04 09:28:44","","0","2249","<p>I need to implement a handler for a timeout function in Combine. Let's consider the following code structure:</p>

<pre class=""lang-swift prettyprint-override""><code>SomeKindOfPublisher&lt;Bool, Never&gt;()
   .timeout(timeoutInterval, scheduler: backgroundQueue,
      customError: { [weak self] () -&gt; Never in
         ...
         while true {} // This block should not return because of Never
      }
</code></pre>

<p>My question is how to avoid a weird line <code>while true {}</code>? I would prefer not to change Never to Error type. </p>
","6305934","","","","","2020-06-04 11:23:58","Swift Combine. What is a correct way to return from a block of a timeout handler?","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"62194693","1","62195956","","2020-06-04 12:32:45","","1","90","<p>I'm trying to do an iOS app using Node with express and body-parser and Swift.</p>

<p>In my app I encode my object that has the username and the password like this:</p>

<pre><code>try? JSONEncoder().encode(requestParams)
</code></pre>

<p>The requestParams object is this one:</p>

<pre><code>import Foundation

struct UserRequestParams: Codable {
    var username: String
    var password: String
}
</code></pre>

<p>Here is how I create the request.</p>

<pre><code>let request = RequestBuilder.host(""localhost:3000"")
    .post()
    .headers([""Content-Type"": ""application/x-www-form-urlencoded""])
    .encoded(.body)
    .parameter(params)
    .path(""auth"")
</code></pre>

<p>And this is the request:</p>

<pre><code>func execute&lt;T: Decodable&gt;(request: HttpRequest, responseType: T.Type) -&gt; AnyPublisher&lt;T, Error&gt; {
    var urlComponents = URLComponents(string: request.stringURL)!

    if let data = request.parameter?.toJson(), request.encoded == .url {
        var queryItems = [URLQueryItem]()
        for (key,param) in data {
            queryItems.append(URLQueryItem(name: key, value: param as? String))
        }

        urlComponents.queryItems = queryItems
    }

    let url = urlComponents.url!

    var urlRequest = URLRequest(url: url)
    urlRequest.httpMethod = request.method.rawValue

    if request.encoded == .body {
        urlRequest.httpBody = try? JSONEncoder().encode(request.parameter)
    }

    for header in request.headers {
        urlRequest.setValue(header.value, forHTTPHeaderField: header.key)
    }

    return URLSession.shared.dataTaskPublisher(for: urlRequest)
    .tryMap { output in
        guard let response = output.response as? HTTPURLResponse, (200...299).contains(response.statusCode) else {
            throw RepositoryError.serverError
        }
        return output.data
    }
    .receive(on: RunLoop.main)
    .decode(type: responseType.self, decoder: JSONDecoder())
    .eraseToAnyPublisher()
}`
</code></pre>

<p>So I think that works correctly, the problem is in the server side I am getting this request body:</p>

<pre><code>body: { '{""username"":""****"",""password"":""****""}': '' }
</code></pre>

<p>It seems the server is already wrapping the app json into another json.</p>
","4895903","","4895903","","2020-06-04 13:03:21","2020-06-04 13:32:18","Request body JSON inside JSON","<node.js><swift><express><codable><body-parser>","1","5","","","","CC BY-SA 4.0"
"62202516","1","62202984","","2020-06-04 19:17:58","","0","88","<p>I'm trying to wrap my mind around how Combine works.  I believe I'm doing something wrong when I use the .assign operator to mutate the @Published property I'm operating on.  I've read the documentation on Publishers, Subscribers, and Operators.  But I'm a bit loose on where exactly to create the Publisher if I don't want it to be a function call.</p>
<pre><code>import SwiftUI
import Combine

struct PhoneNumberField: View {
    
    let title: String
    @ObservedObject var viewModel = ViewModel()
    
    var body: some View {
        TextField(title,text: $viewModel.text)
    }
    
    class ViewModel: ObservableObject {
        @Published var text: String = &quot;&quot;
        private var disposables = Set&lt;AnyCancellable&gt;()
        
        init() {
            $text.map { value -&gt; String in
                    self.formattedNumber(number: value)
            }
            //something wrong here
            .assign(to: \.text, on: self)
            .store(in: &amp;disposables)
            
        }
        
        func formattedNumber(number: String) -&gt; String {
                let cleanPhoneNumber = number.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()
                let mask = &quot;+X (XXX) XXX-XXXX&quot;

                var result = &quot;&quot;
                var index = cleanPhoneNumber.startIndex
                for ch in mask where index &lt; cleanPhoneNumber.endIndex {
                    if ch == &quot;X&quot; {
                        result.append(cleanPhoneNumber[index])
                        index = cleanPhoneNumber.index(after: index)
                    } else {
                        result.append(ch)
                    }
                }
                return result
            }
    }
}

struct PhoneNumberParser_Previews: PreviewProvider {
    static var previews: some View {
        PhoneNumberField(title: &quot;Phone Number&quot;)
    }
}
</code></pre>
","6768221","","8697793","","2020-07-14 15:01:05","2020-07-14 15:01:05","Using Combine to parse phone number String","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"62212563","1","62229053","","2020-06-05 09:51:08","","1","239","<p>I found a lot of SwiftUI-related topics about this which didn't help (eg <a href=""https://stackoverflow.com/questions/57459727/why-an-observedobject-array-is-not-updated-in-my-swiftui-application"">Why an ObservedObject array is not updated in my SwiftUI application?</a>)</p>

<p>This doesn't work with Combine in Swift (specifically <strong>not</strong> using Swift<strong>UI</strong>):</p>

<pre class=""lang-swift prettyprint-override""><code>class SomeTask {
  @Published var progress = Progress(totalUnitCount: 5) // Progress is a Class
  [...]
}
var task = SomeTask()
let cancellable = task.$progress.sink { print($0.fractionCompleted) }
task.progress.completedUnitCount = 2
</code></pre>

<p>This is not SwiftUI-related so no <code>ObservableObject</code> inheritance to get <code>objectWillChange</code>, but even if I try to use <code>ObservableObject</code> and <code>task.objectWillChange.send()</code> it doesn't do anything, also trying to add <code>extension Progress: ObservableObject {}</code> doesn't help.
Since the publisher emits values through the var's <code>willSet</code> and since <code>Progress</code> is itself class-type nothing happens.</p>

<p><strong>Looks like there is no real decent way to manually trigger it?</strong></p>

<p>Only <strong>solution</strong> I found is to just re-assign itself which is quite awkward:</p>

<p><code>let pr = progress
progress = pr</code></p>

<p>(writing <code>progress = progress</code> is a compile-time error).</p>

<p>Only other way which might be working is probably by using <strong>Key-value-observing/KVO</strong> and/or writing a new <code>@PublishedClassType</code> property wrapper?</p>
","3078330","","3078330","","2020-06-06 07:11:14","2020-06-08 12:37:23","`@Published var name: ClassType` doesn't work _outside_ of SwiftUI / manual trigger?","<swift><key-value-observing><combine><reference-type>","3","5","","","","CC BY-SA 4.0"
"62233246","1","62233543","","2020-06-06 14:37:35","","-1","120","<p>I have this class in LRVDetails.swift</p>

<pre><code>class LRVDetails {
    var heading = CurrentValueSubject&lt;String, Never&gt;(K.LRV.Register)
    // other publishers
}
</code></pre>

<p>I have this assign in LRVViewController.swift</p>

<pre><code>private var details = LRVDetails()
private var subs = Set&lt;AnyCancellable&gt;()

override func viewDidLoad() {
    super.viewDidLoad()

    details
        .heading
        .assign(to: \.text!, on: heading)
        .store(in: &amp;subs)
}
</code></pre>

<p>and in LRVCoordinator.swift I have</p>

<pre><code>private var details = LRVDetails()

func UserDidPressButton() { // this is a delegate method from the VC
    details.heading.send(""New Heading"")
}
</code></pre>

<p>I thought that because LRVDetails is a class, it only stores a reference. so if I simply instantiate it in each file and then call send() on it, the publisher should update, and then emit the value to the LRVViewController subscription and update the heading.</p>

<p>But it does nothing. The subscriber never receives a value ( I checked with a .print() operator ). When i call lrvController?.details.send() -- without the private tag -- in the coordinator, it works fine.</p>

<p>Is this because the subscriber is stored in the 'subs' variable in LRVCoordinator, and thus it has to be updated with the subscriber in LRVViewController? That's my best bet. </p>

<p>If not, why doesn't this work?.</p>

<p>Thanks!</p>

<p>Edit:</p>

<p>If they are different instances, why does this code print two?</p>

<pre><code>class myClass {
 var int = 1
}

let test1 = myClass()
let test2 = myClass()

test1.int = 2
print(test2.int)
// prints 2
</code></pre>
","12728118","","12728118","","2020-06-06 15:36:16","2020-06-06 15:36:16","Why can't I call .send on a publisher in a class from a second class and have it update the subscription in third class?","<ios><swift><xcode><reactive-programming><combine>","1","1","","","","CC BY-SA 4.0"
"62242073","1","62242125","","2020-06-07 07:17:26","","3","3019","<p>I have been playing around a timer publisher for a while in playground. below is my code</p>

<pre><code>let timer = Timer
    .publish(every: 1.0, on: .main, in: .common)
.autoconnect()

var counter = 0
let subscriber = timer
    .map({ (date) -&gt; Void in
        counter += 1
    })
    .sink { _ in

        print(""I am printing the counter \(counter)"")
}

if counter &gt; 5 {
    timer.upstream.connect().cancel() //1.nothing happened
    subscriber.cancel() //2. nothing happened too. :(
}
</code></pre>

<p>But i could not stop the timer by using both line 1 and line 2.
What am i actually missing?</p>
","3172726","","","","","2020-06-07 07:23:46","how to stop a timer publisher?","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"62252592","1","62252655","","2020-06-07 22:40:12","","1","736","<p>The logic that I want to apply is: </p>

<p>If we have already imported the users we just fetch them otherwise import first the users and then fetch them. Here is my attempt :</p>

<pre><code>import Combine

struct User {
    let name: String
}

var didAlreadyImportUsers = false

// Import the users and return true of false 
var importUsers: Future&lt;Bool, Never&gt; {
    Future { promise in
        promise(.success(true))
    }
}

var fetchUsers: Future&lt;[User], Error&gt; {
    Future { promise in
        promise(.success([User(name: ""John""), User(name: ""Jack"")]))
    }
}

var users: Future&lt;[User], Error&gt; {
    if didAlreadyImportUsers {
        return fetchUsers
    } else {
        return importUsers.setFailureType(to: Error.self)
            .combineLatest(fetchUsers)
            .map { $0.1 }
    }
}
</code></pre>

<p>I get an error:</p>

<pre><code>Cannot convert return expression of type
'Publishers.Map&lt;Publishers.CombineLatest&lt;Publishers.SetFailureType&lt;Future&lt;Bool, Never&gt;, Error&gt;, Future&lt;[User], Error&gt;&gt;, [User]&gt;' 
to return type 'Future&lt;[User], Error&gt;'
</code></pre>

<p>Any idea how to get the result of chaining as Future&lt;[User], Error> ?</p>
","2305342","","","","","2020-06-07 22:47:42","Simple Future chaining that have different value types using Combine","<ios><swift><future><combine>","1","0","1","","","CC BY-SA 4.0"
"62253436","1","62258970","","2020-06-08 00:42:52","","2","2683","<p>I have 2 publishers where I want to perform an action based on either response. I don't care about the values. I'm trying to do something like this:</p>

<pre><code>var hasChangedPublisher: AnyPublisher&lt;(Void, Void), Never&gt; {
    Publishers.CombineLatest(
        preferences.publisher,
        state.$permissionStatus
    ).eraseToAnyPublisher()
}
</code></pre>

<p>If <code>preferences.publisher</code> fires first but not the other, I want to fire. If <code>state.$permissionStatus</code> fires but not the other, I want to fire. I don't really want to <code>CombineLatest</code>, but not sure how to fire if either emit.</p>

<p>Is there a way to produce an even if either fire but more elegantly erase its values?</p>
","235334","","","","","2022-02-26 16:42:02","How to combine 2 publishers and erase values to Void?","<swift><combine>","3","0","","","","CC BY-SA 4.0"
"62264214","1","62264351","","2020-06-08 14:20:37","","3","1910","<p>When using a Future I'm not able to receive the cancel event. </p>

<pre><code>Future&lt;String, Never&gt; { promise in
    promise(.success(""Hello Stackoverflow""))
}
.eraseToAnyPublisher()
    .handleEvents(receiveCancel: {
        print(""Cancel event received here"")
    })
    .sink(receiveValue: { value in
        print(value)
    })
    .store(in: &amp;disposeBag)

disposeBag.map { $0.cancel() }
</code></pre>

<p>Interestingly using a subject it's working and I'm getting the event.</p>

<pre><code>let subject = PassthroughSubject&lt;String, Never&gt;()

subject.send(""Hello Stackoverflow"")

    subject.eraseToAnyPublisher()
    .handleEvents(receiveCancel: {
        print(""Cancel event received here"")
    })
    .sink(receiveValue: { value in
        print(value)
    })
    .store(in: &amp;disposeBag)

disposeBag.map { $0.cancel() }
</code></pre>

<p>So why is Combine behaving that way and how I can resolve this?</p>
","4142753","","","","","2020-06-08 14:27:54","Receiving cancel event using Future in Combine","<ios><swift><combine>","1","1","","","","CC BY-SA 4.0"
"62264708","1","62265368","","2020-06-08 14:46:23","","4","2070","<p>If you run this on a Playground:</p>

<pre><code>import Combine
import Foundation

struct User {
    let name: String
}

var didAlreadyImportUsers = false

var importUsers: Future&lt;Bool, Never&gt; {
    Future { promise in
        sleep(5)
        promise(.success(true))
    }
}

var fetchUsers: Future&lt;[User], Error&gt; {
    Future { promise in
        promise(.success([User(name: ""John""), User(name: ""Jack"")]))
    }
}

var users: AnyPublisher&lt;[User], Error&gt; {
    if didAlreadyImportUsers {
        return fetchUsers
            .receive(on: DispatchQueue.global(qos: .userInitiated))
            .eraseToAnyPublisher()
    } else {
        return importUsers
            .receive(on: DispatchQueue.global(qos: .userInitiated))
            .setFailureType(to: Error.self)
            .combineLatest(fetchUsers)
            .map { $0.1 }
        .eraseToAnyPublisher()

    }
}

users
    .receive(on: DispatchQueue.global(qos: .userInitiated))
    .sink(receiveCompletion: { completion in
    print(completion)
}, receiveValue: { value in
    print(value)
})

print(""run"")

</code></pre>

<p>the output will be: </p>

<pre><code>[User(name: ""John""), User(name: ""Jack"")]
run
finished
</code></pre>

<p>But I was expecting to get:</p>

<pre><code>run
[User(name: ""John""), User(name: ""Jack"")]
finished
</code></pre>

<p>Because the sink should run the code in background thread. What I'm missing here. 
Do I need to rin the code:</p>

<pre><code> sleep(5)
 promise(.success(true))
</code></pre>

<p>in a background thread ? then what's the purpose of </p>

<pre><code>.receive(on: DispatchQueue.global(qos: .userInitiated))
</code></pre>
","2305342","","","","","2021-08-28 08:57:26","Execute Combine Future in background thread is not working","<ios><grand-central-dispatch><future><combine>","2","0","1","","","CC BY-SA 4.0"
"62268309","1","62268560","","2020-06-08 17:55:20","","3","3151","<p>I'd like to have a worker task update a SwiftUI view. </p>

<p>The worker task is busy doing the procedural work of the application - playing sounds, and firing timer-based events. I'd like to to flash several icons in a SwiftUI view during those timer events. So I want to trigger a view refresh in those icon views.</p>

<p>So, I created an environmentObject called Settings. It's instantiated in the App Delegate, and attached to the root view in the SceneDelegate.</p>

<p>The Settings object works just fine inside the SwiftUI View hierarchy. </p>

<p>The problem is the dreaded:</p>

<pre><code>Fatal error: No ObservableObject of type Settings found. A View.environmentObject(_:) for Settings may be missing as an ancestor of this view.
</code></pre>

<p>I think that the problem is that the worker class is instantiated in the AppDelegate, and Settings is not yet an ObservableObject yet when it's instantiated. But I'm confused.</p>

<p>The environment object is straightforward:</p>

<pre><code>import SwiftUI
import Combine

final class Settings: ObservableObject {
   @Published var showMenu: Bool = true
   @Published var lessonNum: Int = 0

   @Published var arrowsOn: Bool = false {
       willSet {
           willChange.send(self)
       }
   }
}

let willChange = PassthroughSubject&lt;Settings, Never&gt;()

</code></pre>

<p>It's instantiated, along with the worker class, in the AppDelegate:</p>

<pre><code>let settings = Settings()
...
var workerClass  = WorkerClass()
var leftArrow = LeftArrowView()

</code></pre>

<p>And it's passed to the SceneDelegate:</p>

<pre><code>            window.rootViewController = UIHostingController(rootView: contentView
                .environmentObject(settings)
</code></pre>

<p>The sub view that uses settings looks at the environment object to draw the icon in either the on or off state:</p>

<pre><code>import SwiftUI

struct LeftArrowView: View {
@EnvironmentObject var settings: Settings

    let leftArrowOnImage = Image(""Arrow Left On"").renderingMode(.original)
    let leftArrowOffImage = Image(""Arrow Left Off"").renderingMode(.original)

    var body: some View {
        ZStack {
            if settings.arrowsOn {
                leftArrowOnImage
            } else {
                leftArrowOffImage
            }
        }
    }
}

</code></pre>

<p>The worker class is called as a Button action from higher up in the SwiftUI view hierarchy.</p>

<p>Inside the worker class I attempt to attach to the settings environment object:</p>

<pre><code>import Combine

public class WorkerClass : NSObject, ObservableObject {

    @EnvironmentObject var settings: Settings
</code></pre>

<p>and inside a method that's invoked via a timer, I attempt to update a variable in the environment object:</p>

<pre><code>       settings.arrowsOn = !settings.arrowsOn
        print(""Arrows are \(settings.arrowsOn)"")
</code></pre>

<p>... which is when I discover that I failed to actually attach properly to the environment object.</p>

<p>What did I miss?</p>

<p>Thanks in advance for any insights...</p>
","4277085","","","","","2020-06-08 18:10:14","Setting a SwiftUI @EnvironmentObject from outside a view","<ios><swiftui><observable><combine>","1","0","2","","","CC BY-SA 4.0"
"62288568","1","62290125","","2020-06-09 17:34:20","","1","403","<p>If you try this code in Playgroud:</p>

<pre><code>import Combine
import Foundation

struct User {
    let name: String
}

private var subscriptions = Set&lt;AnyCancellable&gt;()
var didAlreadyImportUsers = false
var users = [User]()

func importUsers() -&gt; Future&lt;Bool, Never&gt; {
    Future { promise in
        DispatchQueue.global(qos: .userInitiated).async {
            sleep(5)
            users = [User(name: ""John""), User(name: ""Jack"")]
            promise(.success(true))
        }
    }
}

func getUsers(age: Int? = nil) -&gt;Future&lt;[User], Error&gt; {
    Future { promise in
        promise(.success(users))
    }
}

var usersPublisher: AnyPublisher&lt;[User], Error&gt; {
    if didAlreadyImportUsers {
        return getUsers().eraseToAnyPublisher()
    } else {
        return importUsers()
            .setFailureType(to: Error.self)
            .combineLatest(getUsers())
            .map { $0.1 }
            .eraseToAnyPublisher()
    }
}

usersPublisher
    .sink(receiveCompletion: { completion in
    print(completion)
}, receiveValue: { value in
    print(value)
}).store(in: &amp;subscriptions)
</code></pre>

<p>It will print: </p>

<pre><code>[]
finished
</code></pre>

<p>but I expect: </p>

<pre><code>[User(name: ""John""), User(name: ""Jack"")]
finished

</code></pre>

<p>If I remove the line with <code>sleep(5)</code> then it prints the result correctly. It seems like an issue with asynchronicity. It seems like <code>.combineLatest(getUsers())</code> is not waiting for <code>importUsers()</code> I thought that <code>combineLatest</code> is taking care of that ? what I'm missing here ? </p>

<p>(in my real code there is a long running Core Data operations instead of <code>sleep</code>)</p>
","2305342","","","","","2020-06-09 19:08:33","Combine combineLatest is not waiting for the previous operation to fire","<ios><swift><combine><combinelatest>","1","0","","","","CC BY-SA 4.0"
"62291498","1","62304494","","2020-06-09 20:42:04","","0","316","<p>I have this code in an <code>MVVM</code> code in SwiftUI. My Objective is when the app loads for the first time to return the result without the filter. When I press the button on the view to trigger <code>CatLotViewModel</code> to reload the filtered data but can't seem to figure out I can trigger it.</p>

<pre><code>class CatLotViewModel: ObservableObject {
    //MARK: - Properties
    @Published var catViewModel = [CatViewModel]()

    private var cancellabels = Set&lt;AnyCancellable&gt;()

    init() {
        MyAPIManager().$cat.map{ kitten in
            // Filter
            let filtered = kitten.filter{ ($0.meals.contains(where: {$0.feed == false}))}
            return filtered.map { park in
                MyCatViewModel(parking: park)
            }
//            return kitten.map { park in
//                CatViewModel(parking: park)
//            }
        }
        .assign(to: \.catViewModel, on: self)
        .store(in: &amp;cancellabels)
    }
}
</code></pre>
","5525626","","5525626","","2020-06-10 19:23:12","2020-06-11 17:51:31","Reload data in SwiftUI using MVVM using filters","<swift><swiftui><swiftui-environment>","1","0","","","","CC BY-SA 4.0"
"62307192","1","62307707","","2020-06-10 15:22:29","","0","692","<p>I am requesting a single value from a publisher and would like to terminate after I get the response. Below I'm just deallocating the cancel token after the first time, is there a better way to do this?</p>

<pre><code>extension MyInteractor {
    private static var locationPermissionToken: Cancellable?

    func requestLocationPermission(completion: @escaping (Result&lt;Void, LocationError&gt;) -&gt; Void) {
        Self.locationPermissionToken = locationProxy.authorizationPublisher
            .sink { status in
                Self.locationPermissionToken = nil
                status ? completion(.success(())) : completion(.failure(.deniedLocationServices))
            }

        locationProxy.requestAuthorization()
    }
}
</code></pre>
","235334","","","","","2020-06-10 15:47:55","How to terminate Swift Combine response after first emit?","<swift><reactive-programming><combine>","1","2","","","","CC BY-SA 4.0"
"62307501","1","62319762","","2020-06-10 15:37:15","","1","420","<p>I'm trying to create a <code>LocationManager</code> wrapper for Combine. I have a publisher and some functions that trigger the publisher. However, I'd like to combine them in one with a custom command.</p>

<p>Here's what I got so far:</p>

<pre><code>@available(OSX 10.15, iOS 13, tvOS 13, watchOS 6, *)
public class LocationProxy: NSObject {
    private lazy var manager = CLLocationManager()

    private static let authorizationSubject = PassthroughSubject&lt;Bool, Never&gt;()
    public private(set) lazy var authorizationPublisher: AnyPublisher&lt;Bool, Never&gt; = Self.authorizationSubject.eraseToAnyPublisher()

    var isAuthorized: Bool { CLLocationManager.isAuthorized }

    func isAuthorized(for type: LocationAPI.AuthorizationType) -&gt; Bool {
        guard CLLocationManager.locationServicesEnabled() else { return false }

        #if os(macOS)
        return type == .always &amp;&amp; CLLocationManager.authorizationStatus() == .authorizedAlways
        #else
        return (type == .whenInUse &amp;&amp; CLLocationManager.authorizationStatus() == .authorizedWhenInUse)
            || (type == .always &amp;&amp; CLLocationManager.authorizationStatus() == .authorizedAlways)
        #endif
    }

    func requestAuthorization(for type: LocationAPI.AuthorizationType = .whenInUse) {
        // Handle authorized and exit
        guard !isAuthorized(for: type) else {
            Self.authorizationSubject.send(true)
            return
        }

        // Request appropiate authorization before exit
        defer {
            #if os(macOS)
            if #available(OSX 10.15, *) {
                manager.requestAlwaysAuthorization()
            }
            #elseif os(tvOS)
            manager.requestWhenInUseAuthorization()
            #else
            switch type {
            case .whenInUse:
                manager.requestWhenInUseAuthorization()
            case .always:
                manager.requestAlwaysAuthorization()
            }
            #endif
        }

        // Handle mismatched allowed and exit
        guard !isAuthorized else {
            // Process callback in case authorization dialog not launched by OS
            // since user will be notified first time only and ignored subsequently
            Self.authorizationSubject.send(false)
            return
        }

        // Handle denied and exit
        guard CLLocationManager.authorizationStatus() == .notDetermined else {
            Self.authorizationSubject.send(false)
            return
        }
    }

    public func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        guard status != .notDetermined else { return }
        Self.authorizationSubject.send(isAuthorized)
    }
}
</code></pre>

<p>To use it, I have to subscribe first, then call the request authorization function:</p>

<pre><code>cancellable = locationProxy.authorizationPublisher
    .sink { status in
        print(status)
    }

locationProxy.requestAuthorization()
</code></pre>

<p>Is there a way to structure the code to subscribe and request authorization in one call, something like this:</p>

<pre><code>cancellable = locationProxy.authorizationPublisher
    .sink { status in
        print(status)
    }
    .requestAuthorization()
</code></pre>
","235334","","235334","","2020-06-10 15:59:03","2020-06-11 08:05:27","How to create a custom chain in Swift Combine?","<swift><location><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"62316440","1","62319791","","2020-06-11 03:14:41","","0","261","<p>I have an <code>AnyPublisher</code> property that emits values. When someone subscribes to it, is there a way to emit the last value immediately and let it listen for future values from there?</p>
","235334","","","","","2020-06-11 08:07:04","Fire last value when subscribing to publisher?","<swift><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"62372478","1","62372581","","2020-06-14 12:25:40","","2","1185","<p>I have a publisher that my view's <code>onReceive</code> is subscribed to. Instead of duplicating logic in <code>onAppear</code> as well, I'd like the publisher in the <code>onReceive</code> to fire on first subscribe.</p>

<p>Is there a way to convert a publisher to a <code>CurrentValueSubject</code>? Here's what I'm trying to do:</p>

<pre><code>var myPublisher: CurrentValueSubject&lt;Void, Never&gt; {
    Just(()) // Error: Cannot convert return expression of type 'Just&lt;()&gt;' to return type 'CurrentValueSubject&lt;Void, Never&gt;'
}
</code></pre>

<p>Is this possible or a better way to do this?</p>
","235334","","","","","2021-10-27 04:05:12","How to convert a publisher to a CurrentValueSubject?","<swift><reactive-programming><combine>","2","0","","","","CC BY-SA 4.0"
"62372908","1","62374081","","2020-06-14 13:03:53","","2","1956","<p>I'm trying to pass in an optional publisher to my view's <code>.onReceive</code>. I don't want to force wrap it like this:</p>

<pre><code>let refreshPublisher: AnyPublisher&lt;Void, Never&gt;?

var body: some View {
    Group {
        ...
    }
    .onReceive(refreshPublisher!) {...}
}
</code></pre>

<p>So I'm passing an empty default value like this:</p>

<pre><code>var body: some View {
    Group {
        ...
    }
    .onReceive(refreshPublisher ?? Empty&lt;Void, Never&gt;().eraseToAnyPublisher()) {...}
}
</code></pre>

<p>This is really verbose and want to add an extension on <code>Optional</code> publishers something like this:</p>

<pre><code>extension Optional where Wrapped == Publisher { // Incorrect syntax, doesn't compile
    func orEmpty() -&gt; AnyPublisher&lt;Void, Never&gt; { ... }
}
</code></pre>

<p>This way, I can end or doing something like this: </p>

<pre><code>var body: some View {
    Group {
        ...
    }
    .onReceive(refreshPublisher.orEmpty()) {...}
}
</code></pre>

<p>Is something like this possible or a better way to handle optional publishers in non-optional chains?</p>
","235334","","","","","2020-06-14 15:09:27","Extension for default empty value for optional publisher?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62406372","1","62415523","","2020-06-16 10:28:35","","1","504","<p>Is there any way to get the subscriptions by accessing the publisher?</p>

<p>In the below example, I created a publisher, and had it subscribed by two subscribers and had the publisher send a value.</p>

<p>Here in this simple scenario, all works are thrown together in a couple of lines of code. It is easy to notice who subscribed the publisher. In real world application, however, each work is compartmentalized and hard to notice the subscribers from the publisher's standpoint.</p>

<p>So, does a publisher has properties to get access to the subscribers or subscriptions?
Or, do you suggest a design pattern to make publisher-subscriber data flow more obvious?</p>

<pre><code>final class IntSubscriber: Subscriber {

  typealias Input = Int
  typealias Failure = Never

  func receive(subscription: Subscription) {
      print(""receive subscription"")
    subscription.request(.max(3))
  }

  func receive(_ input: Int) -&gt; Subscribers.Demand {
    print(""Received value"", input)
    return .none
  }

  func receive(completion: Subscribers.Completion&lt;Never&gt;) {
    print(""Received completion"", completion)
  }
}

let subject = PassthroughSubject&lt;Int, Never&gt;()
let subscriber1 = IntSubscriber()
let subscriber2 = IntSubscriber()
subject.subscribe(subscriber1)
subject.subscribe(subscriber2)

// send a value without knowing who might get the value?
subject.send(3)
</code></pre>
","5007422","","","","","2020-06-16 18:45:37","How to access the subscriptions from the given publisher? (combine kit)","<ios><swift><combine><publisher><subscriber>","1","0","","","","CC BY-SA 4.0"
"62408526","1","62433711","","2020-06-16 12:29:16","","0","2207","<p>I want to display multiple text fields, representing scores of each part of a match.</p>

<p>Example : For a volleyball match, we have 25/20, 25/22, 25/23. The global score is 3/0.</p>

<p>The global components architecture :</p>

<pre><code>&gt;&gt; ParentComponent
    &gt;&gt; MainComponent
        &gt;&gt; X TextFieldsComponent (2 text fields, home/visitor score)
</code></pre>

<p>The lowest component, TextFieldsComponent, contains basic bindings :</p>

<pre><code>struct TextFieldsComponent: View {
    @ObservedObject var model: Model

    class Model: ObservableObject, Identifiable, CustomStringConvertible {
        let id: String
        @Published var firstScore: String
        @Published var secondScore: String

        var description: String {
            ""\(firstScore) \(secondScore)""
        }

        init(id: String, firstScore: String = .empty, secondScore: String = .empty) {
            self.id = id
            self.firstScore = firstScore
            self.secondScore = secondScore
        }
    }

    var body: some View {
        HStack {
            TextField(""Dom."", text: $model.firstScore)
                .keyboardType(.numberPad)
            TextField(""Ext."", text: $model.secondScore)
                .keyboardType(.numberPad)
        }
    }
}
</code></pre>

<p><strong>The parent component needs to show the total score of all parts of the match. And I wanted to try a Combine binding/stream to get the total score.</strong></p>

<p>I tried multiple solutions and I ended up with this non-working code (the reduce seems to not be take all the elements of the array but internally stores a previous result) :</p>

<pre><code>struct MainComponent: View {
    @ObservedObject var model: Model
    @ObservedObject private var totalScoreModel: TotalScoreModel

    class Model: ObservableObject {
        @Published var scores: [TextFieldsComponent.Model]

        init(scores: [TextFieldsComponent.Model] = [TextFieldsComponent.Model(id: ""main"")]) {
            self.scores = scores
        }
    }

    private final class TotalScoreModel: ObservableObject {
        @Published var totalScore: String = """"
        private var cancellable: AnyCancellable?

        init(publisher: AnyPublisher&lt;String, Never&gt;) {
            cancellable = publisher.print().sink {
                self.totalScore = $0
            }
        }
    }

    init(model: Model) {
        self.model = model
        totalScoreModel = TotalScoreModel(
            publisher: Publishers.MergeMany(
                model.scores.map {
                    Publishers.CombineLatest($0.$firstScore, $0.$secondScore)
                        .map { ($0.0, $0.1) }
                        .eraseToAnyPublisher()
                }
            )
            .reduce((0, 0), { previous, next in
                guard let first = Int(next.0), let second = Int(next.1) else { return previous }
                return (
                    previous.0 + (first == second ? 0 : (first &gt; second ? 1 : 0)),
                    previous.1 + (first == second ? 0 : (first &gt; second ? 0 : 1))
                )
            })
            .map { ""[\($0.0)] - [\($0.1)]"" }
            .eraseToAnyPublisher()
        )
   }

    var body: some View {
        VStack {
            Text(totalScoreModel.totalScore)
            ForEach(model.scores) { score in
                TextFieldsComponent(model: score)
            }
        }
    }
}
</code></pre>

<p>I'm searching for a solution to get an event on each binding change, and merge it in a single stream, to display it in MainComponent.</p>

<p>N/B: The TextFieldsComponent needs to be usable in standalone too.</p>
","10785142","","","","","2020-09-04 00:49:56","SwiftUI / Combine : Listening array items value change","<swift><swiftui><reactive><combine>","1","0","","","","CC BY-SA 4.0"
"62417129","1","62417793","","2020-06-16 20:33:59","","0","667","<p>I have a class: </p>

<pre><code>final class LocationManager: NSObject, ObservableObject, CLLocationManagerDelegate {
  let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()
  private let locationManager = CLLocationManager()

  @Published var status: String? {
    willSet { objectWillChange.send() }
  }
  @Published var location: CLLocation? {
    willSet { objectWillChange.send() }
  }

// ...other code
  }
</code></pre>

<p>And then I have a view that observes this class:</p>

<pre><code>struct MapView: UIViewRepresentable {
  @ObservedObject var lm = LocationManager()

  // ...other view code
}
</code></pre>

<p>Everything works fine and the view updates when the published property changes. However, if I remove the <code>willSet { objectWillChange.send() }</code> then the view that observes an instance of <code>LocationManager</code> does not update when the published location changes. Which brings me to my question: I thought that by putting <code>@Published</code> next to a <code>var</code> that any <code>@ObservedObject</code> will invalidate the current view when the published property changes, essentially a default <code>objectWillChange.send()</code> implementation but this doesn't seem to be happening. Instead I have to manually call the update. Why is that?</p>
","2217750","","2217750","","2020-06-16 20:41:47","2020-06-17 17:40:55","@Published requires willSet to fire","<swift><swiftui>","2","3","","","","CC BY-SA 4.0"
"62452048","1","62461722","","2020-06-18 14:15:11","","2","1593","<p>I have 3 observables namely source, source1 and source2. What I want is whenever source emits distinct event get the value of source1 and source2. This is the code I've come up with, obviously it won't compile since withLatestFrom expects only one observable.</p>

<pre><code>source.distinctUntilChanged()
        .withLatestFrom(source1, source2) { ($0, $1.0, $1.1) }
        .subscribe(onNext: { (A, B, C) in
            print(""OnNext called"")
        })
        .disposed(by: bag)
</code></pre>
","3490203","","","","","2020-06-19 01:02:19","RxSwift Use withLatestFrom operator with multiple sources","<ios><swift><rx-swift><reactive><combine>","2","0","","","","CC BY-SA 4.0"
"62467663","1","62467664","","2020-06-19 09:50:57","","0","3979","<p>When adding a cocoapods dependency, we started getting build errors like these:</p>
<pre class=""lang-none prettyprint-override""><code>Undefined symbols for architecture x86_64:
  &quot;type metadata accessor for (extension in Foundation):__C.NSURLSession.DataTaskPublisher&quot;, referenced from:
      (extension in TinyNetworkingObjcIO):__C.NSURLSession.load&lt;A&gt;(TinyNetworkingObjcIO.Endpoint&lt;A&gt;) -&gt; Combine.AnyPublisher&lt;A, Swift.Error&gt; in libTinyNetworkingObjcIO.a(Endpoint.o)
      lazy protocol witness table accessor for type (extension in Foundation):__C.NSURLSession.DataTaskPublisher and conformance (extension in Foundation):__C.NSURLSession.DataTaskPublisher : Combine.Publisher in Foundation in libTinyNetworkingObjcIO.a(Endpoint.o)
  &quot;protocol conformance descriptor for (extension in Foundation):__C.NSURLSession.DataTaskPublisher : Combine.Publisher in Foundation&quot;, referenced from:
      lazy protocol witness table accessor for type (extension in Foundation):__C.NSURLSession.DataTaskPublisher and conformance (extension in Foundation):__C.NSURLSession.DataTaskPublisher : Combine.Publisher in Foundation in libTinyNetworkingObjcIO.a(Endpoint.o)
  &quot;(extension in Foundation):__C.NSURLSession.dataTaskPublisher(for: Foundation.URLRequest) -&gt; (extension in Foundation):__C.NSURLSession.DataTaskPublisher&quot;, referenced from:
      (extension in TinyNetworkingObjcIO):__C.NSURLSession.load&lt;A&gt;(TinyNetworkingObjcIO.Endpoint&lt;A&gt;) -&gt; Combine.AnyPublisher&lt;A, Swift.Error&gt; in libTinyNetworkingObjcIO.a(Endpoint.o)
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>
<p>These errors just appear kind of &quot;out of the blue&quot; after we added a new dependency to our Podfile, with no info about what caused them and what part of the code it originates from, they're just printed after the build and during the linking stage, which now fails.</p>
<p>What does this error mean? What can be done to try and resolve it?</p>
<p>This happens to be a react-native generated XCode project, not sure if that's relevant.</p>
","26051","","26051","","2021-06-08 11:08:31","2021-06-08 11:08:31","How to fix iOS/Xcode build error, undefined symbol `__C.NSURLSession.DataTaskPublisher`?","<ios><swift><xcode><react-native>","1","0","","","","CC BY-SA 4.0"
"62469222","1","62469820","","2020-06-19 11:24:25","","0","2266","<p>I've been successfully using <a href=""https://github.com/Thomvis/BrightFutures"" rel=""nofollow noreferrer"">BrightFutures</a> in my apps mainly for async network requests. I decided it was time to see if I could migrate to <a href=""https://developer.apple.com/documentation/combine"" rel=""nofollow noreferrer"">Combine</a>. However what I find is that when I combine two <a href=""https://developer.apple.com/documentation/combine/future"" rel=""nofollow noreferrer"">Futures</a> using <a href=""https://developer.apple.com/documentation/combine/future/3333364-flatmap"" rel=""nofollow noreferrer"">flatMap</a> with two subscribers my second <a href=""https://developer.apple.com/documentation/combine/future"" rel=""nofollow noreferrer"">Future</a> code block is executed twice. Here's some example code which will run directly in a playground:</p>

<pre class=""lang-swift prettyprint-override""><code>import Combine
import Foundation

extension Publisher {
    func showActivityIndicatorWhileWaiting(message: String) -&gt; AnyCancellable {
        let cancellable = sink(receiveCompletion: { _ in Swift.print(""Hide activity indicator"") }, receiveValue: { (_) in })
        Swift.print(""Busy: \(message)"")
        return cancellable
    }
}

enum ServerErrors: Error {
    case authenticationFailed
    case noConnection
    case timeout
}

func authenticate(username: String, password: String) -&gt; Future&lt;Bool, ServerErrors&gt; {
    Future { promise in
        print(""Calling server to authenticate"")
        DispatchQueue.main.async {
            promise(.success(true))
        }
    }
}

func downloadUserInfo(username: String) -&gt; Future&lt;String, ServerErrors&gt; {
    Future { promise in
        print(""Downloading user info"")
        DispatchQueue.main.async {
            promise(.success(""decoded user data""))
        }
    }
}

func authenticateAndDownloadUserInfo(username: String, password: String) -&gt; some Publisher {
    return authenticate(username: username, password: password).flatMap { (isAuthenticated) -&gt; Future&lt;String, ServerErrors&gt; in
        guard isAuthenticated else {
            return Future {$0(.failure(.authenticationFailed)) }
        }
        return downloadUserInfo(username: username)
    }
}

let future = authenticateAndDownloadUserInfo(username: ""stack"", password: ""overflow"")
let cancellable2 = future.showActivityIndicatorWhileWaiting(message: ""Please wait downloading"")
let cancellable1 = future.sink(receiveCompletion: { (completion) in
    switch completion {
    case .finished:
        print(""Completed without errors."")
    case .failure(let error):
        print(""received error: '\(error)'"")
    }
}) { (output) in
    print(""received userInfo: '\(output)'"")
}
</code></pre>

<p>The code simulates making two network calls and <code>flatmap</code>s them together as a unit which either succeeds or fails.
The resulting output is:</p>

<blockquote>
  <p><code>Calling server to authenticate</code><br>
  <code>Busy: Please wait downloading</code><br>
  <code>Downloading user info</code><br>
  <code>Downloading user info</code> &nbsp;&nbsp;&nbsp;&nbsp;&lt;---- unexpected second network call <br>
  <code>Hide activity indicator</code><br>
  <code>received userInfo: 'decoded user data'</code><br>
  <code>Completed without errors.</code></p>
</blockquote>

<p>The problem is <code>downloadUserInfo((username:)</code> appears to be called twice. If I only have one subscriber then <code>downloadUserInfo((username:)</code> is only called once. I have an ugly solution that wraps the <code>flatMap</code> in another <code>Future</code> but feel I missing something simple. Any thoughts?</p>
","848808","","848808","","2020-06-19 11:36:50","2020-06-19 13:52:37","Combine Future block called multiple times when using Flatmap and multiple subscribers","<ios><combine>","1","6","","","","CC BY-SA 4.0"
"62474871","1","62476194","","2020-06-19 16:41:54","","11","2148","<p>I am having some trouble with memory management in SwiftUI and Combine.</p>

<p>For example, if I have a NavigationView and then navigate to a detail view with a TextField, and enter a value in the TextField and tap on the back button, next time I go to that view the TextField has the previously entered value.</p>

<p>I noticed that the view-model is still in memory after the detail view is dismissed, and that's probably why the TextField still holds a value.</p>

<p>In UIKit, when dismissing a ViewController, the view-model will be deallocated and then created again when the ViewController is presented. This seems to not be the case here.</p>

<p>I attach some minimum reproductible code for this issue.</p>

<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    var body: some View {
        NavigationView {
            NavigationLink(destination: OtherView()) {
                Text(""Press Here"")
            }
        }
    }
}

struct OtherView: View {

    @ObservedObject var viewModel = ViewModel()

    var body: some View {
        VStack {
            TextField(""Something"", text: $viewModel.enteredText)
                .textFieldStyle(RoundedBorderTextFieldStyle())

            Button(action: {
                print(""Tap"")
            }) {
                Text(""Tapping"")
            }.disabled(!viewModel.isValid)
        }
    }
}

class ViewModel: ObservableObject {

    @Published var enteredText = """"
    var isValid = false

    var cancellable: AnyCancellable?

    init() {
        cancellable = textValidatedPublisher.receive(on: RunLoop.main)
            .assign(to: \.isValid, on: self)
    }

    deinit {
        cancellable?.cancel()
    }

    var textValidatedPublisher: AnyPublisher&lt;Bool, Never&gt; {
        $enteredText.map {
            $0.count &gt; 1
        }.eraseToAnyPublisher()
    }


}
</code></pre>

<p>I also noticed that, if for example, I add another view, let's say SomeOtherView after OtherView, then each time I type in the TextField from OtherView, then the deinit from SomeOtherView's view-model is called. Can anyone please also explain why this happens?</p>
","11974137","","11974137","","2020-06-19 16:56:01","2022-05-27 12:25:20","ObservedObject view-model is still in memory after the view is dismissed","<ios><swift><swiftui><combine>","2","4","2","","","CC BY-SA 4.0"
"62488565","1","62489054","","2020-06-20 16:27:50","","1","1248","<p>I'm playing around with generics in SwiftUI, and ran into a data persistence issue when attempting to leverage a ViewBuilder closure to pass data into a generic View. My goal is to have a shell view that manages receiving data from an API and passing it to a generic view, as defined in a ViewBuilder block. All of the data seems to be passed to the inits successfully, including to my generic <code>BasicListView</code>, however when the <code>body</code> gets called none of the list data is persisted.</p>
<p>I think it will be easier to explain the issue through code. Apologies for the long code dump here:</p>
<pre><code>import SwiftUI
import Combine

// This is the blank &quot;shell&quot; View that manages passing the data into the viewBuilder through the @ViewBuilder block

struct BlankView&lt;ListItem, Content:View&gt;: View where ListItem: Listable {
    
    let api = GlobalAPI.shared
    
    @State var list: [ListItem] = []
    
    @State var viewBuilder: ([ListItem]) -&gt; Content // Passing in generic [ListItem] here
    
    init(@ViewBuilder builder: @escaping ([ListItem]) -&gt; Content) {
        self._viewBuilder = State&lt;([ListItem]) -&gt; Content&gt;(initialValue: builder)
    }
    
    var body: some View {
        
        viewBuilder(list) // List contained in Blank View passed into viewBuilder Block here
            .multilineTextAlignment(.center)
            .onReceive(GlobalAPI.shared.listDidChange) { item in
                if let newItem = item as? ListItem {
                    self.list.append(newItem) // Handle API updates here
                }
            }
    }
}

// And Here is the implementation of the Blank View
struct TestView: View {

    public var body: some View {
        BlankView&lt;MockListItem, VStack&gt;() { items in // A list of items will get passed into the block
            VStack {
                Text(&quot;Add a row&quot;) // Button to add row via API singleton
                    .onTapGesture {
                        GlobalAPI.shared.addListItem()
                    }
                
                BasicListView(items: items) { // List view init'd with items
                    Text(&quot;Hold on to your butts&quot;) // Destination
                }
            }
        }
    }
}


// Supporting code

// The generic list view/cell

struct BasicListView&lt;Content: View, ListItem:Listable&gt;: View {
    
    @State var items: [ListItem]
    
    var destination: () -&gt; Content
    
    init(items: [ListItem], @ViewBuilder builder: @escaping () -&gt; Content) {
        self._items = State&lt;[ListItem]&gt;(initialValue: items) // Items successfully init'd here
        self.destination = builder
    }
    
    var body: some View {
        List(items) { item in // Items that were passed into init no longer present here, this runs on a blank [ListItem] array
            BasicListCell(item: item, destination: self.destination)
        }
    }
}

struct BasicListCell&lt;Content: View, ListItem:Listable&gt;: View {
    
    @State var item: ListItem
    
    var destination: () -&gt; Content
    
    var body: some View {
        
        NavigationLink(destination: destination()) {
            HStack {
                item.photo
                    .resizable()
                    .frame(width: 50.0, height: 50.0)
                    .font(.largeTitle)
                    .cornerRadius(25.0)
                VStack (alignment: .leading) {
                    Text(item.title)
                        .font(.headline)
                    Text(item.description)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
        }
    }
}

// The protocol and mock data struct
protocol Listable: Identifiable {
        
    var id: UUID { get set }
    var title: String { get set }
    var description: String { get set }
    var photo: Image { get set }
}

public struct MockListItem: Listable {
    
    public var photo: Image = Image(systemName:&quot;photo&quot;)
    public var id = UUID()
    public var title: String = &quot;Title&quot;
    public var description: String = &quot;This is the description&quot;

    static let all = [MockListItem(), MockListItem(), MockListItem(), MockListItem()]
}

// A global API singleton for testing data updates
class GlobalAPI {
    
    static let shared = GlobalAPI()
    
    var listDidChange = PassthroughSubject&lt;MockListItem, Never&gt;()
    
    var newListItem:MockListItem? = nil {
        didSet {
            if let item = newListItem {
                listDidChange.send(item)
            }
        }
    }
    
    func addListItem() {
        newListItem = MockListItem()
    }
}

</code></pre>
<p>Is this a proper implementation of the ViewBuilder block, or is it not encouraged to try to pass data through a View builder block?</p>
<p><strong>NOTE: WHAT DOES WORK</strong></p>
<p>The view will properly draw itself if I directly pass in static Mock data as shown below:</p>
<pre><code>struct TestView: View {

    public var body: some View {
        BlankView&lt;MockListItem, VStack&gt;() { items in // A list of items will get passed into the block
            VStack {
                Text(&quot;Add a row&quot;) // Button to add row via API singleton
                    .onTapGesture {
                        GlobalAPI.shared.addListItem()
                    }
                
                BasicListView(items: MockListItem.all) { // List view init'd with items
                    Text(&quot;Hold on to your butts&quot;) // Destination
                }
            }
        }
    }
}
</code></pre>
<p>Any ideas? Thanks for the help and feedback everyone.</p>
","4785359","","","","","2020-06-20 17:06:45","What is the correct method for passing data into a ViewBuilder closure in SwiftUI?","<swift><list><generics><swiftui><viewbuilder>","2","0","1","","","CC BY-SA 4.0"
"62526745","1","62526823","","2020-06-23 03:17:40","","4","3223","<p>I want to return the publisher for a function if there is error in input params for it but its giving some compilation error.</p>
<p>Below is the function for the same.</p>
<pre><code>func fetchList(input: String) -&gt; AnyPublisher&lt;List, Error&gt; {
    guard let url = URL(string: input)  else {            
        return AnyPublisher(URLError(.cannotParseResponse))
    }
    //some call for to get the List which returns publisher
}
</code></pre>
<p><strong>Error</strong></p>
<p><code>Cannot invoke initializer for type 'AnyPublisher&lt;_, _&gt;' with an argument list of type '(URLError)'</code></p>
<p><strong>Summary</strong></p>
<p>How to create our publisher to return the error?</p>
<p>Thanks for any hint in the right direction.</p>
","248014","","3641812","","2021-06-24 16:13:13","2021-06-24 16:13:13","Swift Combine return Publisher from func","<swift><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"62532680","1","62548756","","2020-06-23 10:30:39","","2","268","<p>When you create an Augmented Reality Project using the standard Xcode template, Xcode adds this <code>swift</code> file to your project:</p>
<pre><code>//
// Experience.swift
// GENERATED CONTENT. DO NOT EDIT.
//

import Foundation
import RealityKit
import simd
import Combine

public enum Experience {

    public enum LoadRealityFileError: Error {
        case fileNotFound(String)
    }

    private static var streams = [Combine.AnyCancellable]()

    public static func loadBox() throws -&gt; Experience.Box {
        guard let realityFileURL = Foundation.Bundle(for: Experience.Box.self).url(forResource: &quot;Experience&quot;, withExtension: &quot;reality&quot;) else {
            throw Experience.LoadRealityFileError.fileNotFound(&quot;Experience.reality&quot;)
        }

        let realityFileSceneURL = realityFileURL.appendingPathComponent(&quot;Box&quot;, isDirectory: false)
        let anchorEntity = try Experience.Box.loadAnchor(contentsOf: realityFileSceneURL)
        return createBox(from: anchorEntity)
    }

    public static func loadBoxAsync(completion: @escaping (Swift.Result&lt;Experience.Box, Swift.Error&gt;) -&gt; Void) {
        guard let realityFileURL = Foundation.Bundle(for: Experience.Box.self).url(forResource: &quot;Experience&quot;, withExtension: &quot;reality&quot;) else {
            completion(.failure(Experience.LoadRealityFileError.fileNotFound(&quot;Experience.reality&quot;)))
            return
        }

        var cancellable: Combine.AnyCancellable?
        let realityFileSceneURL = realityFileURL.appendingPathComponent(&quot;Box&quot;, isDirectory: false)
        let loadRequest = Experience.Box.loadAnchorAsync(contentsOf: realityFileSceneURL)
        cancellable = loadRequest.sink(receiveCompletion: { loadCompletion in
            if case let .failure(error) = loadCompletion {
                completion(.failure(error))
            }
            streams.removeAll { $0 === cancellable }
        }, receiveValue: { entity in
            completion(.success(Experience.createBox(from: entity)))
        })
        cancellable?.store(in: &amp;streams)
    }

    private static func createBox(from anchorEntity: RealityKit.AnchorEntity) -&gt; Experience.Box {
        let box = Experience.Box()
        box.anchoring = anchorEntity.anchoring
        box.addChild(anchorEntity)
        return box
    }

    public class Box: RealityKit.Entity, RealityKit.HasAnchoring {

        public var steelBox: RealityKit.Entity? {
            return self.findEntity(named: &quot;Steel Box&quot;)
        }

    }

}
</code></pre>
<p>let's focus on the last part of the code</p>
<pre><code>public class Box: RealityKit.Entity, RealityKit.HasAnchoring {
    public var steelBox: RealityKit.Entity? {
        return self.findEntity(named: &quot;Steel Box&quot;)
    }
}
</code></pre>
<p>this part is apparently loading the cube, named &quot;Steel Box&quot; from the standard <code>Experience.rcproject</code>. But If I rename this string to any random name that is not on the scene, the cube still loads fine and so does the project... and this method is called during initialization!</p>
<p>Why is that? What is this really loading, or not?</p>
","316469","","6599590","","2020-06-24 09:56:32","2022-02-16 10:26:33","RealityKit – What is `steelBox` instance loading?","<swift><augmented-reality><arkit><realitykit><reality-composer>","1","0","3","","","CC BY-SA 4.0"
"62585953","1","62586157","","2020-06-25 23:48:10","","3","336","<p>I've got an @EnvironmentObject that's updated in a worker thread, and several SwiftUI views subscribe to changes to the published values.</p>
<p>This all works quite nicely.</p>
<p>But I'm struggling to get a UIView to subscribe to changes in the @EnvironmentObject.</p>
<p>Given</p>
<pre><code>@EnvironmentObject var settings: Settings 

where Settings is:

final class Settings {
    @Published var bar: Int = 0
    @Published var beat: Int = 1
    etc.
}

</code></pre>
<p>SwiftUI views update based on published value changes rather nicely.</p>
<p>But now, I want to declare a sink that receives the published values inside a UIView that conforms to UIViewRepresentable.</p>
<p>I've been working through the Combine book, and thought that I could declare a .sink closure with something like:</p>
<pre><code>   func subscribeToBeatChanges() {
        settings.$bar
            .sink(receiveValue: {
                bar in
                self.bar = bar
                print(&quot;Bar = \(bar)&quot;)
            } )
        settings.$beat
            .sink(receiveValue: {
                beat in
                self.beat = beat
                print(&quot;Beat = \(beat)&quot;)
                self.setNeedsDisplay()
            } )
    }
 
</code></pre>
<p>Unfortunately, the closure is only called once, when subscribeToBeatChanges() is called. What I want is for the closure to be called every time a @Published property in the @EnvironmentObject value changes.</p>
<p>I've also tried to subscribe inside the UIViewRepresentable wrapper, with something inside the makeUIView method, but was unsuccessful.</p>
<p>I'm obviously doing some rather simple and fundamental wrong, and would sure appreciate a push in the right direction, because I'm getting cross-eyed trying to puzzle this out!</p>
<p>Thanks!</p>
","4277085","","","","","2020-06-26 19:02:18","UIView as a subscriber to @EnvironmentObject","<ios><swift><swiftui><publish-subscribe><combine>","1","0","","","","CC BY-SA 4.0"
"62600312","1","62600640","","2020-06-26 17:53:02","","0","134","<p>I've built this small demo view where I have two <code>NoteRow</code>s and my goal is to be able to press the return key to create a new row and for it to become the first responder. <strong>This works, however, the first time around, the new row is created but it doesn't become the first responder.</strong> Subsequent taps of the return key both create the row and become first responder.</p>
<p>Any ideas what's going wrong here? Thanks!</p>
<pre><code>import SwiftUI
import Combine

struct FirstResponderDemo: View {
    
    @State private var rows: [NoteRow] = [
        .init(parentNoteId: &quot;1&quot;, text: &quot;foo&quot;),
        .init(parentNoteId: &quot;1&quot;, text: &quot;bar&quot;),
    ]
    
    @State private var activeRowId: String?
    
    var body: some View {
        ScrollViewReader { proxy in
            ScrollView {
                VStack {
                    ForEach(rows, id: \.id) { row in
                        ResponderTextView(
                            row: row,
                            text: $login,
                            activeRowId: $activeRowId,
                            returnPressed: returnPressed
                        )
                        .frame(width: 300, height: 44)
                    }
                }.padding(.horizontal, 12)
            }
        }
        .onAppear {
            self.activeRowId = rows[0].id
        }
    }
    
    private func returnPressed() {
        guard let id = activeRowId else { return }
        
        let newRow = NoteRow(parentNoteId: &quot;1&quot;, text: &quot;&quot;)
        print(&quot;new row id&quot;, newRow.id)
        
        if let index = rows.firstIndex(where: { $0.id == id }) {
            rows.insert(newRow, at: index + 1)
            activeRowId = newRow.id
        }
    }
}

struct FirstResponderDemo_Previews: PreviewProvider {
    static var previews: some View {
        FirstResponderDemo()
    }
}


struct ResponderView&lt;View: UIView&gt;: UIViewRepresentable {
    
    let row: NoteRow
    
    @Binding var activeRowId: String?
    
    var configuration = { (view: View) in }

    func makeUIView(context: Context) -&gt; View { View() }

    func makeCoordinator() -&gt; Coordinator {
        Coordinator(row: row, activeRowId: $activeRowId)
    }

    func updateUIView(_ uiView: View, context: Context) {
        context.coordinator.view = uiView
        
//        print(activeRowId)
        _ = activeRowId == row.id ? uiView.becomeFirstResponder() : uiView.resignFirstResponder()
        
        configuration(uiView)
    }
}

// MARK: - Coordinator

extension ResponderView {
    
    final class Coordinator {
    
        @Binding private var activeRowId: String?
        
        private var anyCancellable: AnyCancellable?
        
        fileprivate weak var view: UIView?

        init(row: NoteRow, activeRowId: Binding&lt;String?&gt;) {
            _activeRowId = activeRowId
            
            self.anyCancellable = Publishers.keyboardHeight.sink(receiveValue: { [weak self] keyboardHeight in
                guard let view = self?.view, let self = self else { return }
                
                DispatchQueue.main.async {
                    if view.isFirstResponder {
                        self.activeRowId = row.id
                        print(&quot;active row id is:&quot;, self.activeRowId)
                    }
                }
            })
        }
    }
    
}

// MARK: - keyboardHeight

extension Publishers {
    
    static var keyboardHeight: AnyPublisher&lt;CGFloat, Never&gt; {
        let willShow = NotificationCenter.default.publisher(for: UIApplication.keyboardWillShowNotification)
            .map { ($0.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect)?.height ?? 0 }

        let willHide = NotificationCenter.default.publisher(for: UIApplication.keyboardWillHideNotification)
            .map { _ in CGFloat(0) }

        return MergeMany(willShow, willHide)
            .eraseToAnyPublisher()
    }
    
}

struct ResponderView_Previews: PreviewProvider {
    static var previews: some View {
        ResponderView&lt;UITextView&gt;.init(row: .init(parentNoteId: &quot;1&quot;, text: &quot;Hello world&quot;), activeRowId: .constant(nil)) { _ in
        }.previewLayout(.fixed(width: 300, height: 40))
    }
}

struct ResponderTextView: View {
    
    let row: NoteRow
    
    @State var text: String
    
    @Binding var activeRowId: String?
    
    private var textViewDelegate: TextViewDelegate

    init(row: NoteRow, text: Binding&lt;String&gt;, activeRowId: Binding&lt;String?&gt;, returnPressed: @escaping () -&gt; Void) {
        self.row = row
        self._text = State(initialValue: row.text)
        self._activeRowId = activeRowId
        self.textViewDelegate = TextViewDelegate(text: text, returnPressed: returnPressed)
    }

    var body: some View {
        ResponderView&lt;UITextView&gt;(row: row, activeRowId: $activeRowId) {
            $0.text = self.text
            $0.delegate = self.textViewDelegate
        }
    }
}

// MARK: - TextFieldDelegate

private extension ResponderTextView {
    
    final class TextViewDelegate: NSObject, UITextViewDelegate {
        
        @Binding private(set) var text: String
        
        let returnPressed: () -&gt; Void

        init(text: Binding&lt;String&gt;, returnPressed: @escaping () -&gt; Void) {
            _text = text
            self.returnPressed = returnPressed
        }
        
        func textViewDidChange(_ textView: UITextView) {
            DispatchQueue.main.async {
               self.text = textView.text
            }
        }
        
        func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -&gt; Bool {
            if (text == &quot;\n&quot;) {
                returnPressed()
                return false
            }
            
            return true
        }
    }

}
</code></pre>
<p>And the definition of <code>NoteRow</code>:</p>
<pre><code>final class NoteRow: ObservableObject, Identifiable {
    
    let id: String = UUID().uuidString
    
    let parentNoteId: String

    let text: String
   
    init(parentNoteId: String, text: String) {
        self.parentNoteId = parentNoteId
        self.text = text
    }
 
}

extension NoteRow: Equatable {
    
    static func == (lhs: NoteRow, rhs: NoteRow) -&gt; Bool {
        lhs.id == rhs.id &amp;&amp;
        lhs.parentNoteId  == rhs.parentNoteId
    }
    
}
</code></pre>
<p><strong>Edit:</strong> Debugging this more</p>
<p>active row id is: Optional(&quot;71D8839A-D046-4DC5-8E02-F124779309E6&quot;) // first default row
active row id is: Optional(&quot;5937B1D0-CBB0-4BE4-A235-4D57835D7B0F&quot;) // second default row</p>
<p>// I hit return key:
new row id F640D1F9-0708-4099-BDA4-2682AF82E3BD
active row id is: Optional(&quot;5937B1D0-CBB0-4BE4-A235-4D57835D7B0F&quot;) <strong>// ID for 2nd row is set as active for some reason</strong></p>
<p>// After that, new row id and active row ID follow the expected path:</p>
<p>new row id 9FDEB548-E19F-4572-BAD3-00E6CBB951D1
active row id is: Optional(&quot;9FDEB548-E19F-4572-BAD3-00E6CBB951D1&quot;)</p>
<p>new row id 4B5C1AA3-15A1-4449-B1A2-9D834013496A
active row id is: Optional(&quot;4B5C1AA3-15A1-4449-B1A2-9D834013496A&quot;)</p>
<p>new row id 22A61BE8-1BAD-4209-B46B-15666FF82D9B
active row id is: Optional(&quot;22A61BE8-1BAD-4209-B46B-15666FF82D9B&quot;)</p>
<p>new row id 95DD6B33-4421-4A32-8478-DCCBCBB1824E
active row id is: Optional(&quot;95DD6B33-4421-4A32-8478-DCCBCBB1824E&quot;)</p>
","602210","","602210","","2020-06-26 18:15:35","2020-06-26 18:15:38","SwiftUI: Custom UITextView UIViewRepresentable requires double tap on the first action to work, works fine with single taps thereafter","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"62627660","1","62627882","","2020-06-28 20:04:43","","1","590","<p>It is possible to receive progress updates about a <code>URLSessionTask</code> by implementing the <code>URLSessionDataDelegate.urlSession(_:dataTask:didReceive:)</code> delegate method, and using the delegate-style &quot;task, task.resume()&quot; style of invocation.</p>
<p>With the Combine flavor of the API, this does not appear to be possible. Using <code>URLSession.dataTaskPublisher(for:)</code> returns a publisher that publishes the <code>(Data, URLResponse)</code> tuple upon completion, but never invokes the delegate method. In that way, it is very similar to the <code>URLSession.dataTask(with:completionHandler:)</code> method, which invokes <code>completionHandler</code> with the final result, and not in-process <code>Progress</code> reports.</p>
<p>Am I missing any API or pattern to allow progress reporting, or does the Combine flavor of URLSession task handling not offer a way to retrieve progress?</p>
","603369","","","","","2020-06-28 20:29:19","Receive task progress from `URLSession.dataTaskPublisher`","<ios><nsurlsession><combine>","1","0","1","","","CC BY-SA 4.0"
"62630362","1","62631145","","2020-06-29 02:30:32","","0","628","<p>hello i'm try to implement Core Data and swiftUI for my project.</p>
<p>I created an Entity called Aeroporti, which contain 2 attributes iataAPT : String and icaoAPT: string.</p>
<p>I want to save simple data on that.</p>
<p>I setup the app delegate like this:</p>
<pre><code>  // MARK: - Core Data stack

    lazy var persistentContainer: NSPersistentContainer = {
        
        let container = NSPersistentContainer(name: &quot;testFirebaseCoreData&quot;)
        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
            if let error = error as NSError? {
                
                fatalError(&quot;Unresolved error \(error), \(error.userInfo)&quot;)
            }
        })
        return container
    }()

    // MARK: - Core Data Saving support

    func saveContext () {
        let context = persistentContainer.viewContext
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                
                let nserror = error as NSError
                fatalError(&quot;Unresolved error \(nserror), \(nserror.userInfo)&quot;)
            }
        }
    }
</code></pre>
<p>my content view list the field icaoAPT in the entity Aeroporti</p>
<pre><code>import SwiftUI
import CoreData

struct ContentView: View {
    @ObservedObject var dm : DataManager
    @Environment(\.managedObjectContext) var managedObjectContext
    @FetchRequest(entity: Aeroporti.entity(),
                  sortDescriptors: [NSSortDescriptor(keyPath: \Aeroporti.icaoAPT, ascending: true)]) var aeroport : FetchedResults&lt;Aeroporti&gt; // crea la variabile che contiene le ricette
   
    var body: some View {
        List{
            HStack{
                
               // NOT WORKING IF USING DataMANAGER
//                Button(action: {
//                    self.dm.provaSalva()
//                }) {
//                    Text(&quot;save from manager&quot;)
//                }
                
                saveFromView    // button save from view
            }
            ForEach(aeroport, id: \.self) { apt in
                Text(apt.icaoAPT ?? &quot;sconosciuto&quot;)
//                    .environment(\.managedObjectContext, self.managedObjectContext)
            }
        }
        
    }
    
    var saveFromView : some View {
        
        Button(action: {
            let apt = Aeroporti(context: self.managedObjectContext)
            apt.iataAPT = &quot;MFM&quot;
            apt.icaoAPT = &quot;VMMC&quot;
            
            do {
                try self.managedObjectContext.save()
                print(&quot;airport saved.&quot;)
                
            } catch {
                print(error.localizedDescription)
            }
        }) {
            
            Text(&quot;save fromview&quot;)
        }
        
    }
}

</code></pre>
<p>all working fine and the data is saved if I use the button (saveFromView) in the ContentView.</p>
<p>now, in order to better handle the data I have create a DataManager where I put the same code to save the data in the entity, and I try to lunch this code on the content view via a button (save from manager) but it doest work, i'm getting the error &quot;The operation couldn’t be completed. (Foundation._GenericObjCError error 0.)&quot; when it save.</p>
<pre><code>import Combine
import SwiftUI
import CoreData


class DataManager:  ObservableObject {
    
    let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()
    @Environment(\.managedObjectContext) var managedObjectContext
    
    
    func provaSalva() {
        let apt = Aeroporti(context: managedObjectContext)
        apt.iataAPT = &quot;MFM&quot;
        apt.icaoAPT = &quot;VMMC&quot;
        
        do {
            try self.managedObjectContext.save()
            print(&quot;airport saved.&quot;)
            
        } catch {
            print(error.localizedDescription)
        }
    }
    
    
}

</code></pre>
<p>the question is?? why.. is the same code... how can I solve this issue if I want to handle the save data not in the ContentView.</p>
<p>thanks for the help..</p>
","9962676","","","","","2020-06-30 08:38:45","CoreData and SwiftUI","<swift><xcode><core-data><save><swiftui>","2","0","","","","CC BY-SA 4.0"
"62633728","1","62633945","","2020-06-29 08:07:02","","26","12736","<p>I think this error message is new to SwiftUI in Xcode 12 since it gave 0 hits in Google while the message itself is fairly generic:</p>
<blockquote>
<p>Accessing State's value outside of being installed on a View. This will result in a constant Binding of the initial value and will not update.</p>
</blockquote>
<p>I have the following code (removed some fluff):</p>
<pre class=""lang-swift prettyprint-override""><code>public struct ContentView: View {
    @ObservedObject var model: RootViewModel

    public var body: some View {
        VStack(alignment: .center, content: {
            Picker(selection: model.$amount, label: Text(&quot;Amount&quot;)) {
                Text(&quot;€1&quot;).tag(1)
                Text(&quot;€2&quot;).tag(2)
                Text(&quot;€5&quot;).tag(5)
                Text(&quot;€10&quot;).tag(10)
            }.pickerStyle(SegmentedPickerStyle())
            Text(&quot;Donating: €\(model.amount)&quot;).font(.largeTitle)
        }).padding(.all, 20.0)
    }
}

public class RootViewModel: ObservableObject {
    @State public var amount: Int = 1
}
</code></pre>
<p>I used to have the <code>field</code> right in the <code>ContentView</code> and that worked alright. Now the UI does not update anymore and I got that run-time warning instead.</p>
","2804585","","1033581","","2020-06-30 06:23:40","2022-04-08 17:12:15","Accessing ViewModel field in SwiftUI using Xcode 12: ""Accessing State's value outside of being installed on a View""","<swift><swiftui><combine><xcode12>","2","1","5","","","CC BY-SA 4.0"
"62639120","1","65395653","","2020-06-29 13:24:01","","3","1431","<p>I am trying to build a prototype app to evaluate the usage of AWS-Amplify (DataStore) in our next App. I am facing an issue when trying to sync 2 Clients. I set up my AWS-DataStore as explained by the tutorial here: <a href=""https://docs.amplify.aws/lib/datastore/getting-started/q/platform/ios"" rel=""nofollow noreferrer"">https://docs.amplify.aws/lib/datastore/getting-started/q/platform/ios</a> by using Cocoapods. Regarding Cocoapods everything is working as expected. I tried some testing which can also be seen under the link above with &quot;manipulating data&quot;. I also did the &quot;syncing data to cloud&quot; section. I can see my data in dynamoDB in the AWS console. When I am adding an entry I can see it in the console everything is working as expected but i have a problem in two scenarios:</p>
<p>Let's say i have 2 clients A and B (both running iOS 13 - it doesn't matter here if it is a real device or on simulator) and I want to these clients to stay in sync. For this purpose I added a PostStore (I am using the example schema from the AWS-link above atm) which looks like this:</p>
<pre><code>import Foundation
import Combine
import SwiftUI
import Amplify

class PostStore: ObservableObject {
    
    @Published private(set) var posts: [Post] = []
    
    var postSubscription: AnyCancellable?
    
    init() {
        self.getAllPostsFromDataStore()
    }
    
    deinit {
        self.unsubscribeFromDataStore()
    }
    
    func getAllPostsFromDataStore() {
        
        Amplify.DataStore.query(Post.self) { (result) in
            switch result {
            case .success(let posts):
                DispatchQueue.main.async {
                    print(&quot;Got \(posts.count) Posts from DataStore initially&quot;)
                    self.posts = posts
                }
            case .failure(let error):
                print(&quot;Error getting Posts from DataStore: \(error.localizedDescription)&quot;)
            }
        }
    }
    
    func addRandomPostToDataStore() {
        
        let post = Post.getRandomPost()
        self.addPostToArray(post)
        
        print(&quot;Fire: \(post.id)&quot;)
        
        Amplify.DataStore.save(post) {
            
            switch $0 {
            case .success(let post):
                print(&quot;Added post with id: \(post.id)&quot;)
            case .failure(let error):
                print(&quot;Error adding post with title: \(post.title) Error: \(error.localizedDescription)&quot;)
            }
        }
    }
    
    func deletePostFromDataStore(for indexSet: IndexSet) {
        
        let postsToDelete = indexSet.map { self.posts[$0] }
        
        self.posts.remove(atOffsets: indexSet)
        
        for post in postsToDelete {
            
            Amplify.DataStore.delete(post) { (result) in
                switch result {
                case .success():
                    print(&quot;Deleted Post from DataStore&quot;)
                case .failure(let error):
                    print(&quot;Error deleting Post From DataStore: \(error)&quot;)
                }
            }
        }
    }
        
    func subscribeToDataStore() {
        
        postSubscription = Amplify.DataStore.publisher(for: Post.self)
            .sink(receiveCompletion: { (completion) in

                print(&quot;Completion!&quot;)

                if case .failure(let error) = completion {
                    print(&quot;Subscription received Error: \(error.localizedDescription)&quot;)
                }

            }, receiveValue: { (changes) in
                
                
                //print(&quot;Subscription received mutation: \(changes)&quot;)
                print(&quot;\n\n\n&quot;)
                print(&quot;\(try! changes.toJSON())&quot;)
                print(&quot;\n\n\n&quot;)
//                print(&quot;Changes!&quot;)
                let newPost = try! changes.decodeModel(as: Post.self)

                DispatchQueue.main.async {

                    switch changes.mutationType {
                    case &quot;create&quot;:
//                        print(&quot;Create Subscription&quot;)
                        self.addPostToArray(newPost)
                        break
                    case &quot;update&quot;:
                        print(&quot;Update Subscription&quot;)
                        self.updatePostInArray(newPost)
                        break
                    case &quot;delete&quot;:
                        print(&quot;Delete Subscription&quot;)
                        self.deletePostFromArray(newPost)
                        break
                    default:
                        print(&quot;AnotherType?&quot;)
                        print(changes.mutationType)
                        break
                    }
                }
                print(&quot;\n&quot;)
            })
    }
    
    func unsubscribeFromDataStore() {
        postSubscription?.cancel()
    }
    
    private func addPostToArray(_ post: Post) {
        
        if !self.posts.contains(post) {
            self.posts.append(post)
        }
    }
    
    private func deletePostFromArray(_ post: Post) {
        
        if let index = self.posts.firstIndex(of: post) {
            self.posts.remove(at: index)
        }
    }
    
    private func updatePostInArray(_ post: Post) {
        print(&quot;update?&quot;)
    }
}
</code></pre>
<p>The <code>subscribeToDataStore</code> method is triggered via the SwiftUI-View (in <code>onAppear</code>) and is the key thing in here. If I am adding some Posts with Client A (slowly) then Client B receives every change and is adding it to the store (I visualized this with a SwiftUI View but that doesn't matter in this example). No Problems here everything is working as expected.</p>
<p>But</p>
<ol>
<li>When I am adding new entries (Posts) very fast with Client A then some of the new entries are not getting fetched by B.</li>
<li>When I am adding more than 1 entry while Client B is offline (in Flight Mode) and I turn Flight Mode off only the latest entry is fetched per subscription.</li>
</ol>
<p>In both cases when I trigger <code>getAllPostsFromDataStore</code> every single entry is fetched and we are good to go again.</p>
<p>So my question is: Why is the subscription not fetching every single entry?</p>
<p>There is an interesting fact when doing scenario 1: A common log message when receiving an entry per subscription looks like this:</p>
<pre><code>WebsocketDidReceiveMessage - {MyObject}
</code></pre>
<p>Then I am logging the object in the sink 'receiveValue' completion again:</p>
<pre><code>{MyObject}
</code></pre>
<p>But when adding a few entries fast (in a short time) the log message from Amplify sometimes looks like that: (And this is where the first &quot;Object&quot; is missing in the subscription fetch):</p>
<pre><code>WebsocketDidReceiveMessage - {MyObject}
WebsocketDidReceiveMessage - {MyObject2}
</code></pre>
<p>Then I am logging the object in the sink 'receiveValue' completion again and there is only the last object getting logged:</p>
<pre><code>{MyObject2}
</code></pre>
<p>Seems like that <code>{MyObject}</code> got cancelled or something when adding more than one entries fast. Like mentioned above, when B is in Flight Mode or has no connection only the last added entry is fetched. (But I also receive only the last log message for <code>WebsocketDidReceiveMessage</code>).</p>
<p>Am I missing a thing here or is this a bug in the Amplify-DataStore SDK?</p>
<p>Excuse my bad english please. I am not a native speaker and sometimes it is hard to tell exactly what is the problem. If you have any questions regarding this problem or need more information just comment and I will edit my question providing everything you need.</p>
<p>Best Regards</p>
","5650076","","","","","2020-12-21 15:39:48","AWS Amplify - sync DataStore","<ios><swift><swiftui><aws-amplify><combine>","1","0","1","","","CC BY-SA 4.0"
"62647224","1","62647285","","2020-06-29 21:51:35","","1","694","<p>Hi I am using SwiftUI and trying to create an ObservableObject for one of my views.</p>
<pre><code>class ResponseModelObject: ObservableObject {
    @Published var response = SongLinkAPIResponse()
}
</code></pre>
<p>The SongLinkAPIResponse looks like:</p>
<pre><code>public struct SongLinkAPIResponse: Codable, Equatable {
    public var entityUniqueId: String
    public var userCountry: String
    public var pageUrl: URL
    public var entitiesByUniqueId: [EntityUniqueId:Entity]
    public var linksByPlatform: [Platform.RawValue:PlatformInfo]
}
</code></pre>
<p>However my problem is that I am getting an error <code>Missing argument for parameter 'from' in call</code> on the @Published property. The from property is a Decoder but I have not defined an init for SongLinkAPIResponse so I am not sure what to do?</p>
<p>I'm sure I am missing something simple.</p>
","9682666","","","","","2020-06-29 22:00:27","Swift Custom Struct missing argument ""from: Decoder""","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"62654278","1","62655093","","2020-06-30 09:25:35","","1","81","<p>I'm trying to understand Combine a little bit and have an issue and can't wrap my head around it:</p>
<p>I got this data-source</p>
<pre><code>class NoteManager: ObservableObject, Identifiable {
  @Published var notes: [Note] = []
  var cancellable: AnyCancellable?
  init() {
    cancellable = $notes.sink(receiveCompletion: { completion in
      print(&quot;receiveCompletion \(completion)&quot;)
    }, receiveValue: { notes in
      print(&quot;receiveValue \(notes)&quot;)
    })
  }
}
</code></pre>
<p>which is used here:</p>
<pre><code>struct ContentView: View {
  @State var noteManager: NoteManager
    
      var body: some View {
        
        VStack {
          NavigationView {
            VStack {
              List {
                ForEach(noteManager.notes) { note in
                  NoteCell(note: note)
                }
              }
...
</code></pre>
<p>And I can change the values here:</p>
<pre><code>    struct NoteCell: View {
      @State var note: Note
      
      var body: some View {
        NavigationLink(destination: TextField(&quot;title&quot;, text: $note.title)
...
</code></pre>
<p>Anyways - I'm not receiving the <code>receiveValue</code> event after changing the value (which is also correctly reflected in the ui). <code>receiveValue</code> is only called initially when setting it - is there some other way to receive an event for updated fields?</p>
<p>Add on:</p>
<pre><code>struct Note: Identifiable, Codable {
  var id = UUID()
  var title: String
  var information:  String
}
</code></pre>
","2906041","","2906041","","2020-06-30 09:36:50","2020-06-30 10:11:29","Not receiving event for updated @Published","<swift><swiftui><combine>","1","5","1","","","CC BY-SA 4.0"
"62663737","1","62664015","","2020-06-30 18:15:00","","0","84","<p>I've done my best to implement other peoples similar questions from around the internet but haven't been successful. I am working on a simple app that displays the top 50 cryptocurrencies. The information I will show will be the symbol(BTC, ETH...) and price. For now I am just trying to show the symbol.</p>
<p>I am able to get the symbol for each coin individually by using Text(self.fetcher.publishedCoins?.data.coins[0].symbol ?? &quot;&quot;) and changing the array index. Obviously I don't want to do that 50 times so I tried implementing ForEach but couldn't figure it out. Here's where I'm at...</p>
<p>ContentView.swift</p>
<pre><code>import SwiftUI
import Foundation
import Combine

struct ContentView: View {

@ObservedObject var fetcher = CoinFetcher()

var body: some View {
    NavigationView {
        List {
            //Text(self.fetcher.publishedCoins?.data.coins[0].symbol ?? &quot;Error Updating&quot;)

            //Attempting to iterate through Coin.symbol
            ForEach(self.fetcher.publishedCoins?.data.coins[Coin] ?? &quot;&quot;) { select in
                Text(select.symbol)
            }
        }
    }
}}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>
<p>LoadJSON.swift</p>
<pre><code>import Foundation

public class CoinFetcher: ObservableObject {
    
@Published var publishedCoins: Top?
    
init() {
    loadJSON()
}

func loadJSON() {
    let url = URL(string: &quot;https://api.coinranking.com/v1/public/coins&quot;)!
    URLSession.shared.dataTask(with: url) {(data,response,error) in
        do {
            if let retrievedData = data {
                let webData = try JSONDecoder().decode(Top.self, from: retrievedData)
                print(Top.self)
                DispatchQueue.main.async {
                    self.publishedCoins = webData
                }
            } else {
                print(&quot;No data loaded&quot;)
            }
        } catch {
            print (&quot;Error here&quot;)
        }
    }.resume()
}
}
</code></pre>
<p>Coins.swift</p>
<pre><code>import Foundation

// MARK: - Top
struct Top: Codable {
    let status: String
    let data: Data
}

// MARK: - Data
struct Data: Codable {
    let coins: [Coin]
}

// MARK: - Coin
struct Coin: Codable {
    let id: Int
    let uuid: String
    let slug: String
    let symbol: String
    let name: String
    let confirmedSupply: Bool
    let volume: Int
    let marketCap: Int
    let price: String
    let circulatingSupply: Double
    let totalSupply: Double
    let approvedSupply: Bool
    let change: Double
    let rank: Int
    let history: [String?]
    enum CodingKeys: String, CodingKey {
        case id, uuid, slug, symbol, name, confirmedSupply, volume, marketCap, price, circulatingSupply, totalSupply, approvedSupply, change, rank, history
    }
}
</code></pre>
<p>Thank you for your help!</p>
","13667839","","","","","2020-06-30 18:32:54","How can I iterate through a specific JSON item in Swift","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"62678977","1","62679430","","2020-07-01 14:21:20","","3","1835","<p>Normally, I would use an optional variable to hold my <code>Timer</code> reference, as it's nice to be able to <strong>invalidate</strong> and set it to <code>nil</code> before recreating.</p>
<p>I'm trying to use <code>SwiftUI</code> and want to make sure I'm correctly doing so...</p>
<p>I declare as:</p>
<pre><code>@State var timer:Publishers.Autoconnect&lt;Timer.TimerPublisher&gt;? = nil
</code></pre>
<p>Later I:</p>
<pre><code>self.timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
</code></pre>
<p>To drive a UI text control I use:</p>
<pre><code>.onReceive(timer) { time in
    print(&quot;The time is now \(time)&quot;)
}
</code></pre>
<p>What is the right way with this <code>Combine</code> typed <code>Timer</code> to invalidate and recreate?</p>
<p>I've read one should call:</p>
<p><code>self.timer.upstream.connect().cancel()</code></p>
<p>However, do I also need to <strong>invalidate</strong> or simply then <code>nil</code> out?</p>
","1784011","","4667835","","2020-07-01 14:44:25","2020-07-01 14:55:37","SwiftUI - Optional Timer, reset and recreate","<ios><swift><swiftui><nstimer><combine>","1","0","4","","","CC BY-SA 4.0"
"62679300","1","62683025","","2020-07-01 14:37:14","","0","1814","<p>I have a button that's connected to a <code>PassthroughSubject</code> that triggers a network load. The problem I'm having is that if the network request fails (or if pre-flight validation fails) the <code>PassthroughSubject</code> is completed:</p>
<pre class=""lang-swift prettyprint-override""><code>private let createListSubject = PassthroughSubject&lt;Void, Never&gt;()
</code></pre>
<p>When the button is tapped, I send a new event to this subject via <code>send(())</code>.</p>
<pre class=""lang-swift prettyprint-override""><code>// Later on, in some function I set up the subject
    private func setupCreateListSubject() {
        self.createListSubject
            .combineLatest(self.$listName, self.$selectedClients)
            .tryMap { [weak self] (_, listName, selectedClients) -&gt; (String, [String]) in
                let clients = Array(selectedClients)
                try self?.validate(listName: listName, selectedClients: clients)
                return (listName, clients)
            }
            .flatMap { [clientListCreator] (listName, selectedClients) -&gt; AnyPublisher&lt;Result&lt;ClientListMembersDisplayable, Error&gt;, Error&gt; in
                return clientListCreator.createClientList(listName: listName, listMemberIds: selectedClients)
            }
            .catch { error  in
                return Future&lt;Result&lt;ClientListMembersDisplayable, Error&gt;, Error&gt; { // &lt;-- One of the problems is that Future completes after 1 event
                    $0(.success(.failure(error)))
                }
            }
            .sink(receiveCompletion: { [weak self] completion in
                switch completion {
                case .failure(let error):
                    self?.errorAlertContext = AlertContext(title: error.localizedDescription)
                case .finished:
                    break
                }
            }, receiveValue: { [weak self] result in
                switch result {
                case .failure(let error):
                    self?.errorAlertContext = AlertContext(title: error.localizedDescription)
                case .success:
                    self?.errorAlertContext = nil
                }
            }).store(in: &amp;self.disposeBag)
    }
</code></pre>
<p>There are two problems:</p>
<ul>
<li>When validation fails in the <code>tryMap</code>, the <code>catch</code> is invoked</li>
<li>When the API call fails, the same as above happens.</li>
</ul>
<p>I can fix both of these problems with a <code>replaceError</code> but what I want is to transform the publisher's error into a success with a <code>Result</code> error <em>and</em> for the <code>createListSubject</code> to not receive any completion events (because the user will still want to tap that button in the future.</p>
<p>What's the Combine way to do this?
I think what I want is something similar to <code>replaceError()</code> but that received the old error and returns a successful result.</p>
","1027644","","","","","2020-07-01 20:33:01","Swift Combine completing button tap","<ios><swift><swiftui><reactive><combine>","2","0","","","","CC BY-SA 4.0"
"62684388","1","62685006","","2020-07-01 19:51:48","","1","342","<p>I'm new to working with Swift and JSON, I'll try to describe what I'm trying to accomplish as best as I can.</p>
<p>I'm trying to access the Yelp API service and return and decode the JSON results and display the results in a list.</p>
<p>I've successfully been able to hit the API and log the results to the console, but I haven't been able to map the results to UI elements to display within a view.</p>
<p>Below is the struct for the results and the view I'm attempting to display the results in. I'm returning the error from my load function after the view loads.</p>
<p>Data.swift</p>
<pre><code>import SwiftUI

struct BusinessesResponse: Codable {
    let restaurants: [RestaurantResponse]
}

struct RestaurantResponse: Codable, Identifiable {
    let id: String
    var name: String
    var coordinates: [longlat]
    var is_closed: Bool
    var category: String
    var imageURL: URL
    var url: URL
    var review_count: Int
   var rating: Double
   var display_phone: String
   var distance: Double
}
</code></pre>
<p>ContentView</p>
<pre><code>import SwiftUI
import YelpAPI
import Combine
import CoreLocation

struct ContentView: View {

    @ObservedObject private var locationManager = LocationManager()
    @ObservedObject var fetcher = RestaurantFetcher()
    
    var body: some View {
        VStack {
            List(fetcher.businesses) { restaurant in
                VStack (alignment: .leading) {
                    Text(restaurant.name)
                }
              }
           }
        }
    }

    struct ContentView_Previews: PreviewProvider {
        static var previews: some View {
            ContentView()
    }
}
</code></pre>
<pre><code>public class RestaurantFetcher: ObservableObject {
    @Published var businesses = [RestaurantResponse]()
    
    init() {
        load(latitude: 28.4293403, longitude: -81.6241764)
    }
    
    func load(latitude: Double, longitude: Double) {
         let apikey = &quot;API-KEY-HERE&quot;
        let url = URL(string: &quot;https://api.yelp.com/v3/businesses/search?latitude=\(latitude)&amp;longitude=\(longitude)&quot;)!
        var request = URLRequest(url: url)
        request.setValue(&quot;Bearer \(apikey)&quot;, forHTTPHeaderField: &quot;Authorization&quot;)
        request.httpMethod = &quot;GET&quot;
        
        URLSession.shared.dataTask(with: request) { (data, response, error) in
            do {
                if let d = data {
                    let decodedLists = try JSONDecoder().decode([RestaurantResponse].self, from: d)
                    DispatchQueue.main.async {
                        self.businesses = decodedLists
                    }
                } else {
                    print(&quot;No Data&quot;)
                }
            } catch {
                print (&quot;Caught&quot;)
            }
        }.resume()
    }
}
</code></pre>
<p>JSON response from Yelp's API</p>
<pre><code>{
    &quot;businesses&quot;: [
        {
            &quot;id&quot;: &quot;ZTgp2l3XbADwmOMM5rpWZg&quot;,
            &quot;alias&quot;: &quot;disneys-oak-trail-golf-course-lake-buena-vista&quot;,
            &quot;name&quot;: &quot;Disney's Oak Trail Golf Course&quot;,
            &quot;image_url&quot;: &quot;https://s3-media1.fl.yelpcdn.com/bphoto/G3oE_KJJ53H1iweD-j83yQ/o.jpg&quot;,
            &quot;is_closed&quot;: false,
            &quot;url&quot;: &quot;https://www.yelp.com/biz/disneys-oak-trail-golf-course-lake-buena-vista?adjust_creative=s-hyKAjsx6P4UW-uqMn7aQ&amp;utm_campaign=yelp_api_v3&amp;utm_medium=api_v3_business_search&amp;utm_source=s-hyKAjsx6P4UW-uqMn7aQ&quot;,
            &quot;review_count&quot;: 12,
            &quot;categories&quot;: [
                {
                    &quot;alias&quot;: &quot;golf&quot;,
                    &quot;title&quot;: &quot;Golf&quot;
                }
            ],
            &quot;rating&quot;: 3.5,
            &quot;coordinates&quot;: {
                &quot;latitude&quot;: 28.4055855,
                &quot;longitude&quot;: -81.5956011
            },
            &quot;transactions&quot;: [],
            &quot;location&quot;: {
                &quot;address1&quot;: &quot;1950 W Magnolia Palm Dr&quot;,
                &quot;address2&quot;: &quot;&quot;,
                &quot;address3&quot;: &quot;&quot;,
                &quot;city&quot;: &quot;Lake Buena Vista&quot;,
                &quot;zip_code&quot;: &quot;32836&quot;,
                &quot;country&quot;: &quot;US&quot;,
                &quot;state&quot;: &quot;FL&quot;,
                &quot;display_address&quot;: [
                    &quot;1950 W Magnolia Palm Dr&quot;,
                    &quot;Lake Buena Vista, FL 32836&quot;
                ]
            },
            &quot;phone&quot;: &quot;+14079394653&quot;,
            &quot;display_phone&quot;: &quot;(407) 939-4653&quot;,
            &quot;distance&quot;: 3845.3340908128034
        },
        {
            &quot;id&quot;: &quot;VVF9h1jhhOVXIvxe-MDK8g&quot;,
            &quot;alias&quot;: &quot;panther-lake-golf-course-winter-garden&quot;,
            &quot;name&quot;: &quot;Panther Lake Golf Course&quot;,
            &quot;image_url&quot;: &quot;https://s3-media1.fl.yelpcdn.com/bphoto/ff47f9jXs56s3Cf7obIapA/o.jpg&quot;,
            &quot;is_closed&quot;: false,
            &quot;url&quot;: &quot;https://www.yelp.com/biz/panther-lake-golf-course-winter-garden?adjust_creative=s-hyKAjsx6P4UW-uqMn7aQ&amp;utm_campaign=yelp_api_v3&amp;utm_medium=api_v3_business_search&amp;utm_source=s-hyKAjsx6P4UW-uqMn7aQ&quot;,
            &quot;review_count&quot;: 1,
            &quot;categories&quot;: [
                {
                    &quot;alias&quot;: &quot;hotels&quot;,
                    &quot;title&quot;: &quot;Hotels&quot;
                },
                {
                    &quot;alias&quot;: &quot;golf&quot;,
                    &quot;title&quot;: &quot;Golf&quot;
                }
            ],
            &quot;rating&quot;: 4.0,
            &quot;coordinates&quot;: {
                &quot;latitude&quot;: 28.4419223,
                &quot;longitude&quot;: -81.6303836
            },
            &quot;transactions&quot;: [],
            &quot;location&quot;: {
                &quot;address1&quot;: &quot;16301 Phil Ritson Way&quot;,
                &quot;address2&quot;: &quot;&quot;,
                &quot;address3&quot;: &quot;&quot;,
                &quot;city&quot;: &quot;Winter Garden&quot;,
                &quot;zip_code&quot;: &quot;34787&quot;,
                &quot;country&quot;: &quot;US&quot;,
                &quot;state&quot;: &quot;FL&quot;,
                &quot;display_address&quot;: [
                    &quot;16301 Phil Ritson Way&quot;,
                    &quot;Winter Garden, FL 34787&quot;
                ]
            },
            &quot;phone&quot;: &quot;+14076562626&quot;,
            &quot;display_phone&quot;: &quot;(407) 656-2626&quot;,
            &quot;distance&quot;: 1620.1533458028462
        },
        {
            &quot;id&quot;: &quot;UdqKnhBDg4b04e38qFcjEA&quot;,
            &quot;alias&quot;: &quot;orange-83-pub-and-grill-winter-garden&quot;,
            &quot;name&quot;: &quot;Orange 83 Pub And Grill&quot;,
            &quot;image_url&quot;: &quot;https://s3-media2.fl.yelpcdn.com/bphoto/KjWvn26iBv13GnIUCW7z9Q/o.jpg&quot;,
            &quot;is_closed&quot;: false,
            &quot;url&quot;: &quot;https://www.yelp.com/biz/orange-83-pub-and-grill-winter-garden?adjust_creative=s-hyKAjsx6P4UW-uqMn7aQ&amp;utm_campaign=yelp_api_v3&amp;utm_medium=api_v3_business_search&amp;utm_source=s-hyKAjsx6P4UW-uqMn7aQ&quot;,
            &quot;review_count&quot;: 1,
            &quot;categories&quot;: [
                {
                    &quot;alias&quot;: &quot;pubs&quot;,
                    &quot;title&quot;: &quot;Pubs&quot;
                }
            ],
            &quot;rating&quot;: 4.0,
            &quot;coordinates&quot;: {
                &quot;latitude&quot;: 28.4419223,
                &quot;longitude&quot;: -81.6303836
            },
            &quot;transactions&quot;: [],
            &quot;location&quot;: {
                &quot;address1&quot;: &quot;16301 Phil Ritson Way&quot;,
                &quot;address2&quot;: null,
                &quot;address3&quot;: &quot;Orange County National Golf Center &amp; Lodge&quot;,
                &quot;city&quot;: &quot;Winter Garden&quot;,
                &quot;zip_code&quot;: &quot;34787&quot;,
                &quot;country&quot;: &quot;US&quot;,
                &quot;state&quot;: &quot;FL&quot;,
                &quot;display_address&quot;: [
                    &quot;16301 Phil Ritson Way&quot;,
                    &quot;Orange County National Golf Center &amp; Lodge&quot;,
                    &quot;Winter Garden, FL 34787&quot;
                ]
            },
            &quot;phone&quot;: &quot;+14076562626&quot;,
            &quot;display_phone&quot;: &quot;(407) 656-2626&quot;,
            &quot;distance&quot;: 1620.1533458028462
        }
    ],
    &quot;total&quot;: 3,
    &quot;region&quot;: {
        &quot;center&quot;: {
            &quot;longitude&quot;: -81.6241764,
            &quot;latitude&quot;: 28.4293403
        }
    }
}
</code></pre>
","1336383","","8697793","","2020-07-01 20:59:02","2020-07-01 20:59:02","SwiftUI + Decoding Yelp API Response","<json><swift><swiftui><yelp-fusion-api>","1","0","","","","CC BY-SA 4.0"
"62738611","1","62739489","","2020-07-05 08:44:55","","0","1067","<p>iOS 13, Swift 5.x</p>
<p>I am trying to get the syntax right on a combine subscription/publisher. I got a working example and I have tried to copy it, but I missing something; and I cannot see the wood for the trees. Here is my code.</p>
<pre><code>import Foundation
import Combine

class SwiftUIViewCModel: ObservableObject {
  @Published var state : SwiftUIViewCModelState = .page1

  static let shared = SwiftUIViewCModel()

  private var stateUpdatingSubscriber: AnyCancellable?

  init() {
    self.stateUpdatingSubscriber = nil
    self.stateUpdatingSubscriber = SwiftUIViewCModel.shared.$state
      .map(modelCTomodelD(modelState:))
      .receive(on: RunLoop.main)
      .assign(to: \.state, on: self)
  

  }

 private func modelCTomodelD(modelState: SwiftUIViewCModelState) -&gt; SwiftUIViewEModelState {
    switch modelState {
      case .page1:
      return .page1
    case .page2:
      return .page2
    default:
      break
 }
}

}

enum SwiftUIViewEModelState {
 case page1
 case page2
}

enum SwiftUIViewCModelState {
 case page1
 case page2
}
</code></pre>
<p>I am getting a syntax error on the compile, but I don't understand what exactly I need to do to fix it.</p>
<p>Cannot convert value of type '(SwiftUIViewCModelState) -&gt; SwiftUIViewEModelState' to expected argument type 'KeyPath&lt;Published.Publisher.Output, SwiftUIViewCModelState&gt;' (aka 'KeyPath&lt;SwiftUIViewCModelState, SwiftUIViewCModelState&gt;')</p>
<p>How do I get the format it needs here into this code?</p>
<p>Thanks</p>
","3069232","","","","","2020-07-05 10:27:44","Setting up a combine publisher in swift using map","<swift><dictionary><subscription><assign><combine>","1","0","","","","CC BY-SA 4.0"
"62756051","1","62756153","","2020-07-06 12:25:04","","1","488","<p>Swift 5, iOS 13</p>
<p>I want to use passthroughSubject publisher; but I my gut tells me its a global variable and as such very poor practice. How can make this global variable less global, while still being usable. Here's some code to show what I talking about.</p>
<p>I know there are a dozen other ways to do this, but I wanted to create some simple code to illustrate the issue.</p>
<pre><code>import SwiftUI
import Combine

let switcher = PassthroughSubject&lt;Void,Never&gt;()

struct SwiftUIViewF: View {
@State var nextPage = false
var body: some View {

  VStack {
    Text(&quot;Switcher&quot;)
    .onReceive(switcher) { (_) in
      self.nextPage.toggle()
    }
    if nextPage {
      Page1ViewF()
    } else {
      Page2ViewF()
    }
  }

 }
}

struct Page1ViewF: View {
  var body: some View {
    Text(&quot;Page 1&quot;)
    .onTapGesture {
        switcher.send()
    }
  }
}

struct Page2ViewF: View {
  var body: some View {
    Text(&quot;Page 2&quot;)
    .onTapGesture {
      switcher.send()
    }
  }
}

struct SwiftUIViewF_Previews: PreviewProvider {
  static var previews: some View {
    SwiftUIViewF()
  }
}
</code></pre>
","3069232","","","","","2020-07-17 05:44:58","Making a combine passthrough publisher less global","<ios><swift><swiftui><combine>","2","2","","","","CC BY-SA 4.0"
"62757987","1","62758950","","2020-07-06 14:16:07","","1","544","<p>I want to initialize an onTap closure where a method from viewmodel should be called. This function will be passed to another class which will call it. I couldn't figure out how to initialized it because it does not let me to use self and if i try to use weak reference to the viewmodel it says:</p>
<blockquote>
<p>'self' used before all stored properties are initialized
here is the code:</p>
</blockquote>
<pre><code>typealias OnTabBarTap = (Tab) -&gt; Void
struct TabScreenView: View {
    @State var selectedTab: Tab = .BROWSE
    @ObservedObject var viewModel: TabScreenViewModel
    var onTabItemTap: OnTabBarTap

    init(currentSelectedTab: Tab) {
        viewModel = TabScreenViewModel(
                input: TabScreenInput(
                    onStart: PassthroughSubject(),
                    onTabClick: PassthroughSubject()
                )
        )
        onTabItemTap = {
            [viewModel](tab: Tab) -&gt; Void in
            viewModel.input.onTabClick.send(tab)
        }
    }

    
    var body: some View {
        NavigationView{
            VStack{
                CurrentView(currentView: $selectedTab)
                BottomTabBarView(tabs: $viewModel.tabs, onTap: onTabItemTap)
            }
        }
        .navigationViewStyle(StackNavigationViewStyle())
        .onAppear{
                self.viewModel.input.onStart.send(true)
        }
    }
}
</code></pre>
","13727846","","13727846","","2020-07-06 14:37:44","2020-07-06 15:06:50","SwiftUI view, initialize closure with struct member says >'self' used before all stored properties are initialized<","<swift><initialization><swiftui><closures>","1","1","","","","CC BY-SA 4.0"
"62763112","1","62763129","","2020-07-06 19:27:07","","0","737","<p>I have implemented <code>CLLocationManagerDelegate</code> in one of my ObservableObjects and I want to be notified whenever the location changes. Everything works but I get &quot;location changed&quot; printed once. My guess is that I should call <code>manager.startUpdatingLocation()</code> from outside but I do not know from where exactly.</p>
<pre><code>import CoreLocation
import Combine

class LocationManagerService: NSObject, ObservableObject, CLLocationManagerDelegate {
    var manager: CLLocationManager = CLLocationManager()
    @Published var location: CLLocation?
    @Published var enabled: Bool = false
    
    override init() {
        super.init()
        manager.delegate = self
        
        if CLLocationManager.locationServicesEnabled() {
            manager.requestWhenInUseAuthorization()
            // manager.requestAlwaysAuthorization()
            manager.startUpdatingLocation()
        }
    }
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        print(&quot;location changed&quot;) // prints only once
        location = locations.first
        manager.stopUpdatingLocation()
    }
    
    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        enabled = CLLocationManager.locationServicesEnabled()
    }
}
</code></pre>
","2738166","","","","","2020-07-06 19:28:16","SwiftUI Live location update","<ios><swift><swiftui><core-location>","1","0","1","","","CC BY-SA 4.0"
"62764954","1","62765016","","2020-07-06 21:41:00","","-1","508","<p>I have a list of objects.</p>
<pre><code>let arr = [[1, 2, 3, 4, 5]]
</code></pre>
<p>It lives in a repository.</p>
<pre><code>class ArrayRepository: ObservableObject { 
     @Published let arr = [1,2,3,4,5]
} 
</code></pre>
<p>I have a class with a property that needs it assigned at initialization.</p>
<pre><code>class MyClass: ObservableObject { 
    var id: String = &quot;&quot;
    var myProperty: Int? 
}
</code></pre>
<p>My class is created through an asynchronous process that is itself a repository.</p>
<pre><code>class myClassRepository { 
   
    func buildClass -&gt; MyClass { 
        myClassInstance = MyClass()
        self.arrayRepository.$arr.map { arr in 
            arr.filter{ $0 == someOther.Value }
        }.assign(to: \.myProperty, on: myClassInstance).store(in: &amp;subscriptions)
       return myClassInstance
    }
} 
</code></pre>
<p>The problem is my pattern returns an array of elements that I cant make conform to to the singular property on the class? Whats the best way to get it out?</p>
<p>The error I get is essentially</p>
<pre><code>Declared closure result '[Int]' is incompatible with contextual type 'Int??'
</code></pre>
","4397682","","4397682","","2020-07-06 21:55:27","2020-07-06 21:55:27","Swift/Combine- Assign a filtered object to a property on a class","<ios><swift><swiftui><ios11><combine>","1","0","","","","CC BY-SA 4.0"
"62769304","1","62771126","","2020-07-07 06:27:59","","1","962","<p><code>didSelectItemAt</code> causes UI to reflow/redraw every time value for <code>lastSelectedIndex</code> is changed, causing performance issue. I'm not sure if I have used <code>@State</code> properly to propagate value from child to parent.</p>
<p>P.S. I need to use UICollectionView for a reason instead of swiftui <code>List</code> or <code>ScrollView</code>.</p>
<pre><code>import Foundation
import SwiftUI

struct ContentView: View {
    @State var lastSelectedIndex : Int = -1
    var body: some View {
        ZStack {
            CustomCollectionView(lastSelectedIndex: $lastSelectedIndex)
            Text(&quot;Current Selected Index \(lastSelectedIndex)&quot;)
        }
    }
}

struct CustomCollectionView: UIViewRepresentable {
    @Binding var lastSelectedIndex : Int
    
    func makeUIView(context: Context) -&gt; UICollectionView {
        let flowLayout = UICollectionViewFlowLayout()
        flowLayout.itemSize = CGSize(width: 400, height: 300)
        let collectionView = UICollectionView(frame: .zero, collectionViewLayout: flowLayout)
        collectionView.register(CustomCollectionViewCell.self, forCellWithReuseIdentifier: CustomCollectionViewCell.reuseId)
        collectionView.delegate = context.coordinator
        collectionView.dataSource = context.coordinator
        collectionView.backgroundColor = .systemBackground
        collectionView.isDirectionalLockEnabled = true
        
        collectionView.backgroundColor = UIColor.black
        collectionView.showsVerticalScrollIndicator = false
        collectionView.showsHorizontalScrollIndicator = false
        collectionView.alwaysBounceVertical = false
        return collectionView
    }

    func updateUIView(_ uiView: UICollectionView, context: Context) {
        uiView.reloadData()
    }

    func makeCoordinator() -&gt; CustomCoordinator {
        CustomCoordinator(self)
    }
}

class CustomCoordinator: NSObject, UICollectionViewDataSource, UICollectionViewDelegate {
    let parent:CustomCollectionView
    
    init(_ parent:CustomCollectionView) {
        self.parent = parent
    }
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int {
        100
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {

        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CustomCollectionViewCell.reuseId, for: indexPath) as! CustomCollectionViewCell
        cell.backgroundColor = UIColor.red
        cell.label.text = &quot;Current Index is \(indexPath.row)&quot;
        NSLog(&quot;Called for Index \(indexPath.row)&quot;)
        return cell
    }
    
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        parent.lastSelectedIndex = indexPath.row
    }
}

class CustomCollectionViewCell: UICollectionViewCell {
    static let reuseId = &quot;customCell&quot;
    let label = UILabel()

    override init(frame: CGRect) {
        super.init(frame: frame)
        label.numberOfLines = 0
        contentView.addSubview(label)
        label.translatesAutoresizingMaskIntoConstraints = false
        label.topAnchor.constraint(equalTo: contentView.topAnchor).isActive = true
        label.leadingAnchor.constraint(equalTo: contentView.leadingAnchor).isActive = true
        label.trailingAnchor.constraint(equalTo: contentView.trailingAnchor).isActive = true
        label.bottomAnchor.constraint(equalTo: contentView.bottomAnchor).isActive = true
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

</code></pre>
","362510","","","","","2020-07-08 15:27:22","Prevent reflow/redraw every time @State is changed","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"62769689","1","62771131","","2020-07-07 06:59:14","","8","1630","<p>I created a <a href=""https://www.hackingwithswift.com/books/ios-swiftui/triggering-events-repeatedly-using-a-timer"" rel=""noreferrer"">timer via combine</a> which emits <code>Date</code> and ignores errors using this code:</p>
<pre><code>let timer: AnyPublisher&lt;Date, Never&gt; = Timer.publish(every: 5, on: .main, in: RunLoop.Mode.common)
  .autoconnect()
  .map { _ in Date() }
  .replaceError(with: Date())
  .eraseToAnyPublisher()
</code></pre>
<p>(I'm sure there are better ways than mapping and replacing the error, but for this example, I wanted to keep the type simple, <code>AnyPublisher&lt;Date, Never&gt;</code>.)</p>
<p>The timer fires correctly, but there is a delay between when the timer is created to when it fires the first time (i.e. it waits 5 seconds). With <a href=""https://stackoverflow.com/questions/10764168/how-to-trigger-nstimer-right-away"">NSTimer, we can invoke timer.fire()</a> to force it to fire immediately.</p>
<p>Is there an equivalent way to force a timer to post immediately when using <code>Timer.publish()</code>?</p>
<hr />
<p>Alternatively, is there a way to merge <code>Just(Date())</code> with the above <code>Timer.publish</code> so that it fires immediately and every 5 seconds, while still keeping the <code>AnyPublisher&lt;Date, Never&gt;</code> type?</p>
","35690","","","","","2022-05-31 09:12:38","How to trigger Timer.publish() right away?","<swift><combine>","3","0","1","","","CC BY-SA 4.0"
"62785020","1","62799868","","2020-07-07 22:48:21","","1","508","<p>Consider:</p>
<pre><code>let test = [(1,true), (2,false), (3,false), (4,true), (5,true), (6,true)]
test.publisher.removeDuplicates { $0.1 != $1.1 }
    .sink { print($0.0) }
</code></pre>
<p>This is a sequence of (Int,Bool) pairs. What I'm trying to say in my <code>removeDuplicates</code> filter is: &quot;Do not let through any pairs where the Bool changed from the previous Bool.&quot;</p>
<p>So what I expect is:</p>
<ul>
<li><p><code>2</code> won't get through, because its <code>false</code> is different from the previous <code>true</code></p>
</li>
<li><p><code>4</code> won't get through, because its <code>true</code> is different from the previous <code>false</code></p>
</li>
</ul>
<p>All the others should get through, so the result should be <code>1,3,5,6</code>.</p>
<p>But it isn't. It's <code>1,4,5,6</code>.</p>
<p>Can anyone explain why? What reasoning is <code>removeDuplicates</code> using here?</p>
<p>I <em>think</em> I know the answer; I think it is comparing the current value from upstream with the previous value <em>that was permitted to pass through the filter</em>. Thus, <code>1</code> gets through with its <code>true</code>, and then <code>2</code> and <code>3</code> are suppressed because their <code>false</code> is different from <em>that</em>.</p>
<p>But surely that's not right? Surely we should be comparing to the previous value <em>that came from upstream</em>?</p>
<p>[The docs are in fact oddly coy about this. They say &quot;Publishes only elements that don’t match the previous element&quot;. I assumed that this meant &quot;the previous element that arrived from upstream.&quot; But it seems instead that it means &quot;the previous element that we actually published to the downstream&quot;?]</p>
","341994","","","","","2020-07-08 17:00:24","curious behavior of Combine framework removeDuplicates","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"62794530","1","62794886","","2020-07-08 12:11:02","","0","1030","<p>I am adding a simple login system to my SwiftUI project. Only I can't quite figure it out.</p>
<p>What the problem is, when a user wants to login and it works. I get this response from the server:</p>
<pre><code>    &quot;user&quot;: {
        &quot;id&quot;: 6,
        &quot;name&quot;: &quot;test&quot;,
        &quot;email&quot;: &quot;test@test.com&quot;,
        &quot;email_verified_at&quot;: null,
        &quot;created_at&quot;: &quot;2020-07-02T09:37:54.000000Z&quot;,
        &quot;updated_at&quot;: &quot;2020-07-02T09:37:54.000000Z&quot;
    },
    &quot;assessToken&quot;: &quot;test-token&quot;
} 
</code></pre>
<p>But when something isn't right, the server displays an error message like this:</p>
<pre><code>    &quot;message&quot;: &quot;The given data was invalid.&quot;,
    &quot;errors&quot;: {
        &quot;email&quot;: [
            &quot;The email field is required.&quot;
        ],
        &quot;password&quot;: [
            &quot;The password field is required.&quot;
        ]
    }
}
</code></pre>
<p>How can I make sure I parse this information into a structure. At the moment it looks like this.</p>
<pre><code>// This file was generated from JSON Schema using quicktype, do not modify it directly.
// To parse the JSON, add this file to your project and do:
//
//   let welcome = try? newJSONDecoder().decode(Welcome.self, from: jsonData)

import Foundation

// MARK: - Welcome
struct Login: Codable {
    let user: User
    let assessToken: String
}

// MARK: - User
struct User: Codable {
    let id: Int
    let name, email: String
    let emailVerifiedAt: JSONNull?
    let createdAt, updatedAt: String
    
    enum CodingKeys: String, CodingKey {
        case id, name, email
        case emailVerifiedAt = &quot;email_verified_at&quot;
        case createdAt = &quot;created_at&quot;
        case updatedAt = &quot;updated_at&quot;
    }
}

// MARK: - Encode/decode helpers

class JSONNull: Codable, Hashable {
    
    public static func == (lhs: JSONNull, rhs: JSONNull) -&gt; Bool {
        return true
    }
    
    public var hashValue: Int {
        return 0
    }
    
    public init() {}
    
    public required init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if !container.decodeNil() {
            throw DecodingError.typeMismatch(JSONNull.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: &quot;Wrong type for JSONNull&quot;))
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encodeNil()
    }
}

</code></pre>
<p>This is how i do it now:</p>
<pre><code>class HttpAuth: ObservableObject{
    var didChange = PassthroughSubject&lt;HttpAuth, Never&gt;()
    
    var authenticated = false{
        didSet{
            didChange.send(self)
        }
    }
    
    func checkDetails(email: String, password: String){
        guard let url = URL(string: &quot;https://test.ngrok.io/api/login&quot;) else {
            return
        }
        
        let body : [String : String] = [&quot;email&quot; : email, &quot;password&quot;: password]
        
        let finalBody = try! JSONSerialization.data(withJSONObject: body)
        
        
        var request = URLRequest(url: url)
        request.httpMethod = &quot;POST&quot;
        request.httpBody = finalBody
        
        request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        
        URLSession.shared.dataTask(with: request) { (data, response, error) in
            
            
            guard let data = data else {return}
            let finalData = try! JSONDecoder().decode(Login.self, from: data)
                
            
            
            print(finalData)
        }.resume()
    }
}

</code></pre>
<p>Do I have to create a new struct named like <code>LoginError</code> for example, or do I need it inside the existing login struct?</p>
","12621025","","4995828","","2020-07-09 06:33:09","2020-07-09 11:52:27","Swift struct optional values","<ios><json><swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"62807753","1","62933216","","2020-07-09 05:04:07","","1","555","<p>im tried to use Janus to call in videoroom. the problem is the remote video success to display, but only publisher can not show in janus videoroom, after check log i see :</p>
<p><code>RTCIceConnectionState didChange state 1</code></p>
<p><code>RTCIceConnectionState didChange state 4</code></p>
<pre><code>/** Represents the ice connection state of the peer connection. */
typedef NS_ENUM(NSInteger, RTCIceConnectionState) {
  RTCIceConnectionStateNew,
  RTCIceConnectionStateChecking,
  RTCIceConnectionStateConnected,
  RTCIceConnectionStateCompleted,
  RTCIceConnectionStateFailed,
  RTCIceConnectionStateDisconnected,
  RTCIceConnectionStateClosed,
  RTCIceConnectionStateCount,
};
</code></pre>
<p>After read admin api, i see the document say about my error:</p>
<pre><code>Let’s see an example of a “broken” PeerConnection instead:

&quot;components&quot;: [
    {
        &quot;id&quot;: 0,
        &quot;state&quot;: &quot;disconnected&quot;,
        &quot;local-candidates&quot;: [
            &quot;1 1 udp 2013266431 172.17.0.3 46008 typ host\r\n&quot;,
            &quot;2 1 udp 2013266431 143.225.229.138 60710 typ host\r\n&quot;,
            &quot;3 1 udp 2013266431 2002:8fe1:1cc3:b:5c48:51ff:fee9:11ef 58925 typ host\r\n&quot;,
            &quot;4 1 udp 2013266431 fec0::b:5c48:51ff:fee9:11ef 52486 typ host\r\n&quot;
        ],
        &quot;dtls&quot;: {},
        &quot;in_stats&quot;: {},
        &quot;out_stats&quot;: {}
    }
]
</code></pre>
<p><code>In this example, ICE is “disconnected”, which means the ICE connectivity checks never started at all. As a result, the DTLS and data stats sections are obviously empty, as Janus never got to the point of involving them. What is the cause of the problem here? Looking at the data Janus provides, one thing immediately pops to the eye: there are just local candidates (the ones Janus gathered for itself), but no remote candidates at all: this means that the client failed to send them to Janus for some reason (e.g., your client is not sending trickle candidates) and so Janus can’t do anything to establish a media connection.</code></p>
<p>Can anyone explain me the problem, note that subscriber work normal!, <b>i mean i can get remote  video and display in my phone, but my phone can publish video to janus </b></p>
<p>When open rtc error log, i see too much line about:
<code>(stunport.cc:279): Jingle:Port[0x1248a2e00:audio:1:0:local:Net[en2:169.254.0.x/16:Wifi]]: UDP send of 100 bytes failed with error 65</code></p>
<p>RTC log updated below
<code>https://pastebin.com/EE7Jhz75</code></p>
","1308590","","1308590","","2020-07-09 07:43:03","2020-07-16 10:58:16","swift Janus can not publish video, but get remote video successful - can not know reason","<swift><publisher><janus-gateway>","1","0","","","","CC BY-SA 4.0"
"62807992","1","62808497","","2020-07-09 05:28:24","","2","724","<p>I have simple <code>viewModel</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>final class EmployeeListViewModel: ObservableObject {
 @Published var list = [Employee]()
 init() {
  // some request
  self.list = [Employee, Employee]
 }
}
</code></pre>
<p>And have a <code>view</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>struct EmployeeView: View {
 @ObservedObject var viewModel = EmployeeListViewModel()
 @State private var showContents: [Bool] = Array(repeating: false, count: viewModel.list.count)// &lt;- error throws here
 var body: some View {
        GeometryReader { fullView in
            ScrollView {
                VStack(spacing: 40) {
                  ForEach(self.viewModel.list) { employee in
                     Text(employee.firstName).foregroundColor(.black)
                  }
                }
            }
        }
 }
}
</code></pre>
<p>Error text:</p>
<blockquote>
<p>Cannot use instance member 'viewModel' within property initializer; property initializers run before 'self' is available</p>
</blockquote>
<p>I tried change it with <code>init</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>struct EmployeeView: View {
 @ObservedObject var viewModel = EmployeeListViewModel()
 @State private var showContents: [Bool]

 init() {
        _showContents = State(initialValue: Array(repeating: false, count: viewModel.list.count)) // &lt;- error
    }

 var body: some View {
        GeometryReader { fullView in
            ScrollView {
                VStack(spacing: 40) {
                  ForEach(self.viewModel.list) { employee in
                     Text(employee.firstName).foregroundColor(.black)
                  }
                }
            }
        }
 }
}
</code></pre>
<p>But it also throws error:</p>
<blockquote>
<p>'self' used before all stored properties are initialized</p>
</blockquote>
<p>this throws on I call <code>viewModel</code> on <code>init()</code></p>
<p>How to solve it? @State i use for card view. There I simplified views for easy understand.</p>
","12882723","","12882723","","2020-07-09 05:49:35","2020-07-09 06:13:25","swiftui @State value depends on @ObservedObject ViewModel init error","<swift><swiftui><combine>","2","4","","","","CC BY-SA 4.0"
"62812260","1","62813977","","2020-07-09 09:55:46","","1","201","<p>I need a view grid where each item resizes depending on the number of items in the grid and I need to expand each item of the grid when tapped.</p>
<p>I eventually managed to layout out the items as required (see Fig 1) and to expand them.</p>
<p><a href=""https://i.stack.imgur.com/SAd3c.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/SAd3c.png"" alt=""Fig 1"" /></a></p>
<p>Unfortunately I am not able to properly bring the expanded item in front of all other views (see Fig 2 and Fig 3) using zIndex.</p>
<p><a href=""https://i.stack.imgur.com/tszDA.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tszDA.png"" alt=""Fig 2"" /></a>
<a href=""https://i.stack.imgur.com/rINHw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/rINHw.png"" alt=""Fig 3"" /></a></p>
<p>I also tried to embed both VStack and HStack into a ZStack but nothing changes.</p>
<p>How can I bring the expanded item on top?</p>
<p>Below is my code.</p>
<pre><code>struct ContentViewNew: View {
    private let columns: Int = 6
    private let rows: Int = 4
    @ObservedObject var viewModel: ViewModel
    var cancellables = Set&lt;AnyCancellable&gt;()

    init() {
        viewModel = ViewModel(rows: rows, columns: columns)
        viewModel.objectWillChange.sink { _ in
            print(&quot;viewModel Changed&quot;)
        }.store(in: &amp;cancellables)
    }

    var body: some View {
        GeometryReader { geometryProxy in

            let hSpacing: CGFloat = 7
            let vSpacing: CGFloat = 7

            let hSize = (geometryProxy.size.width - hSpacing * CGFloat(columns + 1)) / CGFloat(columns)
            let vSize = (geometryProxy.size.height - vSpacing * CGFloat(rows + 1)) / CGFloat(rows)
            let size = min(hSize, vSize)

            VStack {
                ForEach(0 ..&lt; viewModel.rows, id: \.self) { row in
                    Spacer()
                    HStack {
                        Spacer()
                        ForEach(0 ..&lt; viewModel.columns, id: \.self) { column in

                            GeometryReader { widgetProxy in

                                ItemWiew(info: viewModel.getItem(row: row, column: column), size: size, zoomedSize: 0.80 * geometryProxy.size.width)
                                    .offset(x: viewModel.getItem(row: row, column: column).zoomed ? (geometryProxy.size.width / 2.0 - (widgetProxy.frame(in: .global).origin.x + widgetProxy.size.width / 2.0)) : 0,
                                            y: viewModel.getItem(row: row, column: column).zoomed ? geometryProxy.size.height / 2.0 - (widgetProxy.frame(in: .global).origin.y + widgetProxy.size.height / 2.0) : 0)
                                    .onTapGesture {
                                        viewModel.zoom(row: row, column: column)
                                    }
                                    .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .center)
                                    .zIndex(viewModel.getItem(row: row, column: column).zoomed ? 10000 : 0)
                                    .background(Color.gray)
                            }
                            Spacer()
                        }
                    }
                    .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .center)
                    .background(Color.blue)
                    Spacer()
                }
            }
            .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .center)
            .background(Color.yellow)
        }
        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .center)
        .background(Color.green)
    }
}
</code></pre>
<pre><code>struct ItemWiew: View {
    @ObservedObject var info: ItemInfo
    var size: CGFloat

    init(info: ItemInfo, size: CGFloat, zoomedSize: CGFloat) {
        self.info = info
        self.size = size
        if self.info.size == 0 {
            self.info.size = size
            self.info.zoomedSize = zoomedSize
        }
    }

    var body: some View {
        VStack {
            Print(&quot;Drawing Widget with size \(self.info.size)&quot;)
            Image(systemName: info.symbol)
                .font(.system(size: 30))
                .frame(width: info.size, height: info.size)
                .background(info.color)
                .cornerRadius(10)
        }
    }
}
</code></pre>
<pre><code>class ItemInfo: ObservableObject, Identifiable {
    var symbol: String
    var color: Color
    var zoomed = false
    @Published var size: CGFloat
    @Published var originalSize: CGFloat
    @Published var zoomedSize: CGFloat

    init(symbol: String, color: Color) {
        self.symbol = symbol
        self.color = color
        size = 0.0
        originalSize = 0.0
        zoomedSize = 0.0
    }

    func toggleZoom() {
        if zoomed {
            size = originalSize
            color = .red
        } else {
            size = zoomedSize
            color = .white
        }
        zoomed.toggle()
    }
} 
</code></pre>
<pre><code>class ViewModel: ObservableObject {
    private var symbols = [&quot;keyboard&quot;, &quot;hifispeaker.fill&quot;, &quot;printer.fill&quot;, &quot;tv.fill&quot;, &quot;desktopcomputer&quot;, &quot;headphones&quot;, &quot;tv.music.note&quot;, &quot;mic&quot;, &quot;plus.bubble&quot;, &quot;video&quot;]
    private var colors: [Color] = [.yellow, .purple, .green]
    @Published var listData = [ItemInfo]()
    var rows = 0
    var columns = 0

    init(rows: Int, columns: Int) {
        self.rows = rows
        self.columns = columns
        for _ in 0 ..&lt; rows {
            for j in 0 ..&lt; columns {
                listData.append(ItemInfo(symbol: symbols[j % symbols.count], color: colors[j % colors.count]))
            }
        }
    }

    func getItem(row: Int, column: Int) -&gt; ItemInfo {
        return listData[columns * row + column]
    }

    func zoom(row: Int, column: Int) {
        listData[columns * row + column].toggleZoom()
        objectWillChange.send()
    }
}
</code></pre>
","477372","","8697793","","2020-09-19 12:54:02","2020-09-19 12:54:02","How to bring a view on top of VStack containing ZStacks","<swift><swiftui>","1","0","1","","","CC BY-SA 4.0"
"62818767","1","62818856","","2020-07-09 15:49:34","","1","496","<p>I have a two tests for a username, I want two so I can have different messages for the length of the username and one for the validity of a username.</p>
<p>Fine so far,  but I want to combine them to make sure that I can enable my register UIButton</p>
<pre><code>@Published var username: String = &quot;&quot;

var validLengthUsername: AnyPublisher&lt;Bool, Never&gt; {
    return $username.debounce(for: 0.2, scheduler: RunLoop.main)
        .removeDuplicates()
        .map{$0.count &gt; 6 ? true : false}
        .eraseToAnyPublisher()
}

var formattedUserName: AnyPublisher&lt;Bool, Never&gt; {
    return $username
        .removeDuplicates()
        .map{$0.isValidEmail() ? true : false}
        .eraseToAnyPublisher()
}
</code></pre>
<p>I'm trying to map them -but this gives me an array of AnyPublisher. This isn't what I want - I want to combine validLengthUsername &amp;&amp; formattedUserName - I tried just that but I can't simply AND the two <code>AnyPublisher</code>.</p>
","11076699","","","","","2020-07-09 15:53:49","Combine two AnyPublisher in Combine","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"62856674","1","62862531","","2020-07-12 03:08:17","","7","4447","<p>I'm wrapping async requests in Combine publishers so they can easily be used across different pipelines.</p>
<p>A consumer might hold on to these publishers as follows:</p>
<pre><code>struct Dependencies {
  var loadImageRequest: AnyPublisher&lt;UIImage, Never&gt;
  var saveToDatabaseRequest: AnyPublisher&lt;Void, Never&gt;
  var saveToUserDefaultsRequest: AnyPublisher&lt;Never, Never&gt;
}
</code></pre>
<p>Two of the more common types of requests are:</p>
<ol>
<li><strong>Fire and forget (complete immediately)</strong>: For example, saving a value to User Defaults, could be modeled as a fire and forget. So far it seems like <code>AnyPublisher&lt;Never, Never&gt;</code> is a good way to express this type. This can easily be constructed via <code>Empty&lt;Never, Never&gt;(completeImmediately: true)</code>.</li>
<li><strong>Fire, wait, and ignore result</strong>: An example of this is saving a value to the database (and ignoring the result), but still wanting to wait until the save is complete before continuing the pipeline. I've been using <code>AnyPublisher&lt;Void, Never&gt;</code> to model these request types. An easy way to construct these is via a <code>Future&lt;Void, Never&gt;() { promise in promise(.success(()))}</code>.</li>
</ol>
<p>Both of these have the common theme of ignoring the result. Therefore, when handing these off to the consumers, it's sometimes useful to convert between these two data types: <code>AnyPublisher&lt;Never, Never&gt;</code> and <code>AnyPublisher&lt;Void, Never&gt;</code>.</p>
<p>There are three potential ways to convert between the two:</p>
<ol>
<li><p><code>Never -&gt; Void</code>, complete immediately</p>
<p>One way to convert this is with some forced casting:</p>
<pre><code>let neverPublisher: AnyPublisher&lt;Never, Never&gt; = ...
let voidPublisher: AnyPublisher&lt;Void, Never&gt; = neverPublisher
  .map { _ in () }
  .append(Just(()))
  .eraseToAnyPublisher()
</code></pre>
</li>
<li><p><code>Void -&gt; Never</code>, wait until Void completes</p>
<p>Since there is a bulit-in operator for this one, the conversion is easy:</p>
<pre><code>let voidPublisher: AnyPublisher&lt;Void, Never&gt; = ...
let neverPublisher: AnyPublisher&lt;Never, Never&gt; = voidPublisher
  .ignoreOutput()
  .eraseToAnyPublisher()
</code></pre>
</li>
<li><p><code>Void -&gt; Never</code>, complete immediately</p>
<p>I'm not sure the best way to do this conversion. The solution I came up with has two major downsides: using <code>handleEvents</code>, and needing <code>cancellables</code> defined somewhere:</p>
<pre><code>let cancellables: Set&lt;AnyCancellable&gt; = []
let voidPublisher: AnyPublisher&lt;Void, Never&gt; = ...
let neverPublisher: AnyPublisher&lt;Never, Never&gt; = Empty&lt;Never, Never&gt;(completeImmediately: true)
  .handleEvents(receiveCompletion: { _ in voidPublisher.sink(receiveValue: { _ in }).store(in: &amp;cancellables) })
  .eraseToAnyPublisher()
</code></pre>
</li>
</ol>
<p>Questions:</p>
<ol>
<li>Is there a better way to do conversion #1 (<code>Never -&gt; Void</code>, complete immediately) without needing to invoke both <code>map</code> and <code>append</code>? (E.g. similar to how <code>ignoreOutput</code> was used to solve the second conversion?)</li>
<li>Is there a better way to do the third conversion (<code>Void -&gt; Never</code>, complete immediately) which doesn't need <code>cancellables</code>?</li>
</ol>
","35690","","","","","2020-07-12 15:03:38","How to convert to/from AnyPublisher<Void, Never> and AnyPublisher<Never, Never>?","<swift><combine>","1","3","2","","","CC BY-SA 4.0"
"62868061","1","62954869","","2020-07-13 01:25:32","","0","269","<p>I have a UITableView inside of a UIScrollView. The UITableView has scrolling disabled and has all the required delgates within the ViewController (as can be seen in the code below). However, when I click an item in the table, didSelectRowAt is never called (didHighlightRowAt is also never called). Why is it not called? How do I fix it?</p>
<pre><code>class NewsViewController: UIViewController, UITableViewDelegate, UITableViewDataSource, UICollectionViewDataSource, UICollectionViewDelegate, UICollectionViewDelegateFlowLayout {

private static let headlineArticleReuseIdentifier = &quot;HeadlineArticleCell&quot;
private static let categoryCellReuseIdentifier = &quot;NewsCategoryCell&quot;

@IBOutlet weak var headlineArticlesPreviewList: UITableView!
private var bindings = Set&lt;AnyCancellable&gt;()
private var viewModel: NewsViewModel = NewsViewModel()
private var headlineArticles: [Article] = []

@IBOutlet weak var headlineTitle: UILabel!
override func viewDidLoad() {
    super.viewDidLoad()
    // Do any additional setup after loading the view.
    self.navigationController?.setNavigationBarHidden(true, animated: false)
    headlineArticlesPreviewList.delegate = self
    headlineArticlesPreviewList.dataSource = self
    
    let cancellable = viewModel.$viewState.sink(receiveValue: { state in
        switch state {
        case let .data(data):
            self.setData(data: data)
            print()
        case let .error(error):
            print(error)
        case .loading:
            print()
        }
    })
    bindings.insert(cancellable)
}

private func setData(data: NewsViewModel.ViewState.Data) {
    self.headlineArticles = data.headlineArticles
    self.headlineTitle.text = data.headlineCategory.displayName
    self.headlineArticlesPreviewList.reloadData()
}

func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
    return headlineArticles.count
}

func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
    guard let cell = headlineArticlesPreviewList.dequeueReusableCell(
        withIdentifier: NewsViewController.headlineArticleReuseIdentifier,
        for: indexPath)
        as? HeadlineArticleTableViewCell else {
            fatalError(&quot;could not cast to headline article&quot;)
    }
    let headlineArticle = headlineArticles[indexPath.item]
    cell.setArticle(article: headlineArticle)
    return cell
}

func tableView(_ tableView: UITableView, didHighlightRowAt indexPath: IndexPath) {
    print()
}

func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
    self.performSegue(withIdentifier: &quot;HeadlineArticleSegue&quot;, sender: self)
}

override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
   if segue.identifier == &quot;HeadlineArticleSegue&quot; {

       let detailViewController = segue.destination
            as! ArticleViewController

       let articleIndexPath = headlineArticlesPreviewList.indexPathForSelectedRow!
       let row = articleIndexPath.row
    detailViewController.article = headlineArticles[row]
    }
}
}
</code></pre>
<p>UITableView Settings</p>
<p><a href=""https://i.stack.imgur.com/xDISU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xDISU.png"" alt="""" /></a></p>
<p>UITableView Inside UIScrollView
<a href=""https://i.stack.imgur.com/2h3x5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2h3x5.png"" alt=""enter image description here"" /></a></p>
<p>UITableViewCell Settings</p>
<p><a href=""https://i.stack.imgur.com/tsAoT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tsAoT.png"" alt=""enter image description here"" /></a></p>
","1120154","","","","","2020-07-23 15:50:49","didSelectRowAt not called for UITableView inside UIScrollView","<ios><swift><uitableview>","3","2","","","","CC BY-SA 4.0"
"62870847","1","62871604","","2020-07-13 07:08:50","","1","55","<p>It is required to dynamically render messages list in a SwiftUI body block:</p>
<pre><code> var chatSpace: some View {
        List(self.viewModel.getMessages(), id: \.self) { message in
            message
        }
 }
</code></pre>
<p>where view model, is the instance of the following class:</p>
<pre><code>class MessagesListViewModel: ObservableObject {
    
    @ObservedObject var messageService: MessageService
    
    init(messageService: MessageService) {
        self.messageService = messageService
    }
    
    func getMessages() -&gt; [MessageView] {
        return self.messageService.messages.map {
            return MessageView(message: $0)
        }
    }
    
    
}
</code></pre>
<p>I want to reflect changes when I update MessageService <code>message</code> property, how can I achieve that? Can I somehow subscribe to the changes? Right now, I'm basically adding a message by updating <code>messages</code> published var, however, it does not trigger re-drawing</p>
<pre><code>class MessageService: ObservableObject
{
    @Published var messages: [Message] = [Message]()
    
    func addMessage(_ sender: String, _ text: String, _ time: String) {
        self.messages.append(Message(sender: sender, text: text, time: time))
    }
}
</code></pre>
","2095257","","2095257","","2020-07-13 07:14:24","2020-07-13 08:03:27","how to subscribe to a function, which observes @Published?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"62871391","1","62871726","","2020-07-13 07:48:56","","1","646","<p>I'm using an API (Firebase) that exposes an async interface for most of its method calls. For every request I make through my own API, I want to add a user's token as a header, if such a token exists. I'm trying to make the entire process part of the same pipeline in Combine.</p>
<p>I have the following code:</p>
<pre><code>struct Response&lt;T&gt; {
    let value: T
    let response: URLResponse
}

...

func makeRequest&lt;T: Decodable&gt;(_ req: URLRequest, _ decoder: JSONDecoder = JSONDecoder()) -&gt; AnyPublisher&lt;T, Error&gt; {
    var request = req
    return Future&lt;String?, Error&gt; { promise in
        if let currentUser = Auth.auth().currentUser {
            currentUser.getIDToken() { (idToken, error) in
                if error != nil {
                    promise(.failure(error!))
                } else {
                    promise(.success(idToken))
                }
            }
        } else {
            promise(.success(nil))
        }
    }
    .map { idToken -&gt; URLSession.DataTaskPublisher in
        if idToken != nil {
            request.addValue(&quot;Bearer \(idToken!)&quot;, forHTTPHeaderField: &quot;Authorization&quot;)
        }
        return URLSession.shared.dataTaskPublisher(for: request)
    }
    .tryMap { result -&gt; Response&lt;T&gt; in
        let value = try decoder.decode(T.self, from: result.data)
        return Response(value: value, response: result.response)
    }
    .receive(on: DispatchQueue.main)
    .map(\.value)
    .eraseToAnyPublisher()
}
</code></pre>
<p>I get an error inside tryMap operator when trying to JSON decode the response data:</p>
<blockquote>
<p>Value of type 'URLSession.DataTaskPublisher' has no member 'data'</p>
</blockquote>
<p>I'm still wrapping my head around Combine, but can't understand what I'm doing wrong here. Any help would be greatly appreciated!</p>
","13920975","","13920975","","2020-07-13 08:08:06","2020-07-13 08:11:59","Using Combine operators to transform Future into Publisher","<swift><generics><combine>","1","0","","","","CC BY-SA 4.0"
"62885416","1","62886150","","2020-07-13 22:43:48","","0","353","<p>Imagine I have an API for a class that uses a <code>PassthroughSubject</code> to receive its input:</p>
<pre><code>class Logger {
  let log: PassthroughSubject&lt;String, Never&gt;
}
</code></pre>
<p>Normally I can emit a value by invoking <code>logger.log.send(&quot;test&quot;)</code>.</p>
<p>Now say I want to have my own logger that sits between this generic logger and my code:</p>
<pre><code>class MyLogger {
  let log: PassthroughSubject&lt;String, Never&gt;
}
</code></pre>
<p>This should prefix the string, and then send any updates to Logger. Is there a way to chain the output from one PassthroughSubject (e.g. MyLogger) to another (e.g. Logger)?</p>
<p>I know I can do it this way:</p>
<pre><code>let cancellable = myLogger.log.sink { 
  logger.log.send(&quot;[MyApp] &quot; + $0)
}
</code></pre>
<p>However, that doesn't seem like the Combine-way of chaining things together. I was hoping there was an API I could use more similar to this one:</p>
<pre><code>logger.log.subscribe(myLogger.log.map { &quot;[MyApp] &quot; + $0 })
</code></pre>
<p>However, that doesn't compile since I think the map is causing it to turn into a publisher instead of a subject:</p>
<blockquote>
<p>Instance method 'subscribe' requires that 'Publishers.Map&lt;PassthroughSubject&lt;String, Never&gt;, String&gt;' conform to 'Subject'</p>
</blockquote>
<p>Is there a more declarative API for making one PassthroughSubject subscribe to updates from another (with support for mutations in between) besides relying on <code>sink</code>?</p>
","35690","","","","","2020-07-14 00:08:30","How to forward send calls from one PassthroughSubject to another (i.e. PassthroughSubject chaining)?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62895539","1","62896763","","2020-07-14 12:45:41","","3","1073","<p>I have majority of the functionality working and returning exactly what I want. However, I'm having bit of a brain fart when it comes to taking the <code>photos</code> array in the <code>response</code> and assigning them to appropriate <code>employees</code> to be able to render them. Here's what's going on:</p>
<ol>
<li>There are 4x Codable structs: <code>Response</code>, <code>Company</code>, <code>Employee</code>, and <code>ProfileImages</code>. <code>Response</code> is the main object returned by the API and then decoded into <code>Company</code> having an array of <code>[Employee]</code>, each have 3x <code>ProfileImages</code> (small, medium, and large in size)</li>
<li>There's a <code>companyPublisher</code> that fetches the <code>company</code> details along with an array of <code>employees</code></li>
<li>Then there's a <code>photosPublisher</code> which takes <code>employees</code> array from the previous step and sequences them to be able to retrieve their <code>profileImages.large</code> profile image</li>
<li>At last, I have a <code>Publishers.Zip(companyPublisher, photosPublisher)</code> that sets up the publisher's <code>.sink()</code> to respond with completion once everything requested has been fetched.</li>
</ol>
<p>Can someone advise what would be the appropriate steps I need to take to be able to assign the correct employee image to the actual employee? I was thinking about setting up an optional <code>UIImage</code> type <code>property</code> inside the <code>Employee</code> codable struct but am still unsure on how I would go about assigning the appropriate Future object to that employee.</p>
<p>Any help would be greatly appreciated. Thanks in advance!</p>
<p><code>Response.JSON</code>:</p>
<pre class=""lang-js prettyprint-override""><code>{
  &quot;success&quot;: true,
  &quot;company&quot;: {
    &quot;id&quot;: 64,
    &quot;name&quot;: &quot;XYZ (Birmingham, AL)&quot;,
    &quot;enabled&quot;: true
  },
  &quot;employees&quot;: [{
    &quot;id&quot;: 35,
    &quot;name&quot;: &quot;Chad Hughes&quot;,
    &quot;email&quot;: &quot;chad.hughes@company.com&quot;,
    &quot;profileImages&quot;: {
      &quot;small&quot;: &quot;https://via.placeholder.com/150/09f/fff.png&quot;,
      &quot;medium&quot;: &quot;https://via.placeholder.com/300/09f/fff.png&quot;,
      &quot;large&quot;: &quot;https://via.placeholder.com/600/09f/fff.png&quot;
    }
  }, {
    &quot;id&quot;: 36,
    &quot;name&quot;: &quot;Melissa Martin&quot;,
    &quot;email&quot;: &quot;melissa.martin@company.com&quot;,
    &quot;profileImages&quot;: {
      &quot;small&quot;: &quot;https://via.placeholder.com/150/F2A/fff.png&quot;,
      &quot;medium&quot;: &quot;https://via.placeholder.com/300/F2A/fff.png&quot;,
      &quot;large&quot;: &quot;https://via.placeholder.com/600/F2A/fff.png&quot;
    }
  }]
}
</code></pre>
<p><code>Models.swift</code> (Codable Structs):</p>
<pre class=""lang-swift prettyprint-override""><code>struct Response: Codable {
  let success: Bool
  let company: Company
  let employees: [Employee]
  let message: String?
}

struct Company: Codable, Identifiable {
  let id: Int
  let name: String
  let enabled: Bool
}

struct Employee: Codable, Identifiable {
  let id: Int
  let name: String
  let email: String
  let profileImages: ProfileImage
  let profileImageToShow: SomeImage?
}

struct SomeImage: Codable {
  let photo: Data
  init(photo: UIImage) {
    self.photo = photo.pngData()!
  }
}

struct ProfileImage: Codable {
  let small: String
  let medium: String
  let large: String
}
</code></pre>
<p><code>CompanyDetails.swift</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>class CompanyDetails: ObservableObject {
  private let baseURL = &quot;https://my.api.com/v1&quot;
  
  @Published var company: Company = Company()
  @Published var employees: [Employee] = []
  
  var subscriptions: Set&lt;AnyCancellable&gt; = []
  
  func getCompanyDetails(company_id: Int) {
    let url = URL(string: &quot;\(baseURL)/company/\(company_id)&quot;)
    
    // Company Publisher that retrieves the company details and its employees
    let companyPublisher = URLSession.shared.dataTaskPublisher(for url: url)
      .map(\.data)
      .decode(type: Response.self, decoder: JSONDecoder())
      .eraseToAnyPublisher()
    
    // Photo Publisher that retrieves the employee's profile image in large size
    let photosPublisher = companyPublisher
      .flatMap { response -&gt; AnyPublisher&lt;Employee, Error&gt; in
        Publishers.Sequence(sequence: response.employees)
          .eraseToAnyPublisher()
      }
      .flatMap { employee -&gt; AnyPublisher&lt;UIImage, Error&gt; in
        URLSession.shared.dataTaskPublisher(for url: URL(string: employee.profileImages.large)!)
          .compactMap { UIImage(data: $0.data) }
          .mapError { $0 as Error }
          .eraseToAnyPublisher()
      }
      .collect()
      .eraseToAnyPublisher()
    
    // Zip both Publishers so that all the retrieved data can be .sink()'d at once
    Publishers.Zip(companyPublisher, photosPublisher)
      .receive(on: DispatchQueue.main)
      .sink(
        receiveCompletion: { completion in
          print(completion)
        },
        receiveValue: { company, photos in
          print(company)
          print(photos)
        }
      )
      .store(in: &amp;subscriptions)
  }
}
</code></pre>
","230578","","230578","","2020-07-14 15:26:18","2020-07-14 19:18:21","Swift Combine URLSession retrieving Dataset/Photos using 2x Publishers","<ios><swift><combine><urlsession>","1","2","1","","","CC BY-SA 4.0"
"62902028","1","62902237","","2020-07-14 18:47:43","","2","149","<p>If the user clicks the button while editing the TextField (cursor flashing) in DataPtView, the app crashes.</p>
<p>In a list cell, I have the button, which impacts the view that is also shown in the cell.
Here's a snippet, iPad specific.</p>
<p>CellView:</p>
<pre><code>VStack{
  Button(&quot;TagOut&quot;){
    self.tagOut.toggle()
  }
  
  if self.tagOut {
    TagOutView(question: question)
  }
  
  if !self.tagOut{
    if question.type == &quot;Y/N&quot;{
      YesOrNoView(question: question)
    } else if question.type == &quot;DataPt&quot;{
      DataPtView(question: question)
    } else {
      RecordEntryView()
  }
  ...
</code></pre>
<p>DataPtView:</p>
<pre><code>...
TextField(&quot;Data: &quot;, text: $collectedData)
       .onReceive(Just(collectedData)) {value in
         let filtered = value.filter {&quot;01234567890-&quot;.contains($0)}
         if filtered != value{
           self.invalidCollectedData = true
         } else {
           self.invalidCollectedData = false
         }
 }
 ...
</code></pre>
<p>I'm also using an AdaptsToKeyboard ViewModifier for when CellView is covered by the keyboard.
<a href=""https://stackoverflow.com/questions/56491881/move-textfield-up-when-the-keyboard-has-appeared-in-swiftu"">move-textfield-up-when-the-keyboard-has-appeared-in-swiftu</a></p>
<p>How do I prevent this from happening?  If user hides the keyboard before clicking the button, everything is fine, but that isn't intuitive.</p>
","12282938","","","","","2020-07-14 19:03:15","SwiftUI Prevent user from tapping button while entering data","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"62902789","1","62903191","","2020-07-14 19:37:29","","2","689","<p>I'm looking to create a Combine publisher/subscriber/subscription that behaves like this:</p>
<pre class=""lang-swift prettyprint-override""><code>struct Change&lt;Value&gt; {
  let new: Value
  let previous: Value?
}

let pub = PassthroughSubject&lt;Int, Never&gt;()

let cancellable = pub
  .change()
  .sink { (change: Change&lt;Int&gt;) -&gt; Void in
    print(change)
  }

pub.send(1) // prints Change(new: 1, previous: nil)
pub.send(2) // prints Change(new: 2, previous: 1)
pub.send(3) // prints Change(new: 3, previous: 2)
</code></pre>
<p>Having trouble coming up with the right implementation. I've made my own Publisher/Subscription to wrap external API calls and the sort, but can't come up with the right combination when some state needs to be retained, like the previous value in this example (I think this means you need a custom Subscriber?)</p>
<p>An alternate syntax with the same semantics would also be acceptable, if for some reason the <code>.change()</code> syntax is unworkable.</p>
","652141","","","","","2020-07-14 20:04:49","Custom change operator using Combine","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62942222","1","62996649","","2020-07-16 19:31:06","","1","199","<p>usually I organize my code (in a simplified way) like that :</p>
<p>Presenter Subscribe to my Model (via Managers)</p>
<pre><code>myManager.getItems(...).subscribe { .... }.disposed()
</code></pre>
<p>The Manager call getItems from a Provider and transform DTO -&gt; BO :</p>
<pre><code>func getItems(...) -&gt; Single&lt;myObectBO&gt; {
    myProvider.getItems(...).map { myDTO in
        return MyObjectBO(withDTO: myDTO)
    }
}
</code></pre>
<p>The Provider return a Single of DTO:</p>
<pre><code>func getItems(...) -&gt; Single&lt;myObectDTO&gt; {
    ...
    return Single.just(myObectDTO)
}
</code></pre>
<p>I tried different thing but for the moment I've found nothing to implement that in Combine, is there a simple way to do this?
Thank you for your help.</p>
<hr />
<p>To be more clear I want to do something like that :</p>
<pre><code>func getSomething() {
    getManagerFuture()
        .sink { result in
            print(result)
        }
}

func getManagerFuture() -&gt; Future&lt;[MyBO], ManagerError&gt; {
    
    Future { promise in
    getProviderFuture()
        .flatMap { dtoList -&gt; ([MyBO], ManagerError) in
            
            let boList = dtoList.map { dto in
                return MyBO(id: dto.id, name: dto.name)
            }
            
            return promise(.success(boList))
        }
    }
}

func getProviderFuture() -&gt; Future&lt;[MyDTO], ProviderError&gt; {

    // should be a webservice call
    
    let dto1 = MyDTO(id: 1, name: &quot;one&quot;)
    let dto2 = MyDTO(id: 2, name: &quot;two&quot;)
    
    return Future { promise in promise(.success([dto1, dto2])) }
}
</code></pre>
<p>I have this errors on getManagerProvider :</p>
<blockquote>
<p>Instance method 'flatMap(maxPublishers:_:)' requires the types
'([MyBO], ManagerError).Failure' and 'Never' be equivalent</p>
<p>Type '([MyBO], ManagerError)' cannot conform to 'Publisher'; only
struct/enum/class types can conform to protocols</p>
</blockquote>
","8247388","","8247388","","2020-07-17 08:58:26","2020-07-20 13:39:02","How to implement my MVP / Rxswift with Combine","<swift><rx-swift><combine>","1","1","","","","CC BY-SA 4.0"
"62972404","1","62972445","","2020-07-18 18:39:57","","16","4094","<pre><code>let myPassthrough = PassthroughSubject&lt;String, Error&gt;()
</code></pre>
<p>I know I can send a value to a passthrough subject using <code>send</code>:</p>
<pre><code>myPassthrough.send(&quot;abc&quot;)
</code></pre>
<p>How do I send a failure?</p>
<hr />
<p>I tried:</p>
<pre><code>myPassthrough.send(Fail(error: error))
myPassthrough.send(completion: Fail(error: error))
myPassthrough.send(completion: Just(error))
myPassthrough.send(completion: error)
</code></pre>
<p>None of them compile</p>
","35690","","","","","2020-07-18 18:43:28","How do I send an error to a PassthroughSubject?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62979426","1","62985159","","2020-07-19 11:06:16","","1","76","<p>I have a Auth store (an ObservableObject) which stores whether a user has authenticated into the application. I manage the auth store when the user logs in, essentially changing the authentication state from notAuthenticated to authenticated. I use the same state variable in a ViewModel another ObservableObject, which refers to the Auth store singleton object. I think there might be a simpler way to do this than sinking the variable and updating it on the ViewModel (like directly embedding the Auth variable in the ViewModel).</p>
<p>This is a simplified code for the auth store model</p>
<pre><code>class Auth: ObservableObject {
    
    static let shared = Auth()

    @Published var currentState: AuthState = .notAuthenticated

    enum AuthState {
        case notAuthenticated
        case authenticated
    }
}
</code></pre>
<p>This is the simplified view model</p>
<pre><code>class SampleViewModel: ObservableObject {

    @Published var authState = Auth.shared.currentState

    init() {
    
        Auth.shared.$currentState.sink { newAuthState in
             self.authState = newAuthState
        } // Is there any simple way in which I can skip sinking the publishr
    }
}
</code></pre>
","3970488","","","","","2020-07-19 20:10:44","Is there a way to embed a Published var in one ObservableObject into another ObservableObject?","<swift><observer-pattern><combine>","1","1","","","","CC BY-SA 4.0"
"62986929","1","62988407","","2020-07-19 23:57:23","","8","3269","<p>Suppose I have a data model in my SwiftUI app that looks like the following:</p>
<pre><code>class Tallies: Identifiable, ObservableObject {
  let id = UUID()
  @Published var count = 0
}

class GroupOfTallies: Identifiable, ObservableObject {
  let id = UUID()
  @Published var elements: [Tallies] = []
}
</code></pre>
<p>I want to add a computed property to <code>GroupOfTallies</code> that resembles the following:</p>
<pre><code>// Returns the sum of counts of all elements in the group
var cumulativeCount: Int {
  return elements.reduce(0) { $0 + $1.count }
}
</code></pre>
<p>However, I want SwiftUI to update views when the <code>cumulativeCount</code> changes. This would occur either when <code>elements</code> changes (the array gains or loses elements) or when the <code>count</code> field of any contained <code>Tallies</code> object changes.</p>
<p>I have looked into representing this as an <code>AnyPublisher</code>, but I don't think I have a good enough grasp on Combine to make it work properly. This was mentioned in <a href=""https://stackoverflow.com/questions/58203531/an-equivalent-to-computed-properties-using-published-in-swift-combine"">this answer</a>, but the AnyPublisher created from it is based on a published <code>Double</code> rather than a published <code>Array</code>. If I try to use the same approach without modification, <code>cumulativeCount</code> only updates when the elements array changes, but not when the <code>count</code> property of one of the elements changes.</p>
","2035473","","","","","2020-07-21 12:14:58","Published computed properties in SwiftUI model objects","<swift><swiftui><combine>","3","0","2","","","CC BY-SA 4.0"
"62989199","1","62989372","","2020-07-20 05:34:34","","1","79","<p>This is an oversimplification of what I'm trying to achieve using combine.<br>
I need to inject a value into a shared publisher if something happen.
Here you see that if the number 2 is received by map I use the send command on the original publisher to inject the number 3.<br>
I would expect to receive a sequence of number but instead I receive the number 3 before the event that triggered it.<br></p>
<pre><code>let pub = PassthroughSubject&lt;Int, Never&gt;()

let pubSharered = pub.share().eraseToAnyPublisher()

let anyCanc = pubSharered
.map { value -&gt; Int in
        switch value {
        case 2:
            pub.send(3)
            return value
        default:
            return value
        }
}.sink { (value) in
    print(&quot;Sink: \(value)&quot;)
}

pub.send(0)
pub.send(1)
pub.send(2)
pub.send(4)
</code></pre>
<p>The output is: <code>0,1,3,2,4</code> what I was expecting is <code>0,1,2,3,4</code>.<br>
Can someone explain it?</p>
","395897","","","","","2020-07-20 05:53:10","Trying to inject values into a publisher, but receiving unordered values","<ios><swift><macos><reactive-programming><combine>","1","2","","","","CC BY-SA 4.0"
"62996575","1","63000127","","2020-07-20 13:34:20","","3","690","<p>So I have a value of type <code>AnyPublisher&lt;Foo, Error&gt;</code> and I need to transform it to <code>Published&lt;Foo&gt;.Publisher</code> so that I can use it as @Published</p>
<p>so the idea is that I have a MVVM architecture</p>
<pre><code>struct SwiftUIView: View {
  @ObservedObject var viewModel: MyViewModel
  var body: some View {
    Text(/*Foo has a title, how do I access it? */)
  }
  
}
class MyViewModel: ObservableObject {
  var cellModels: AnyPublisher&lt;Foo, Error&gt;
  // so the idea is to have and then access it in swiftUI view via viewModel.cellModels2.title
  @Published cellModels2 = convert_somehow_to_publisher(cellModels)
}
</code></pre>
<p>Apparently I cannot use viewModel.cellModels</p>
<p>Is that possible?</p>
","919348","","919348","","2020-07-20 14:44:43","2020-08-13 16:40:55","Can I transform AnyPublisher to Published.Publisher?","<combine>","1","3","","","","CC BY-SA 4.0"
"62998695","1","62998845","","2020-07-20 15:23:24","","1","686","<p>I'm trying to observe a value in macOS AppDelegate but I got an Error</p>
<blockquote>
<p>ContentView.swift:14:6: Generic struct 'ObservedObject' requires that 'NSApplicationDelegate?' conform to 'ObservableObject'</p>
</blockquote>
<p>when I try to cast the object into <code>ObservedObject</code> with <code>as! ObservedObject</code> I have another Error</p>
<blockquote>
<p>ContentView.swift:14:6: Generic struct 'ObservedObject' requires that 'ObservedObject' conform to 'ObservableObject'</p>
</blockquote>
<p>Inside <code>AppDelegate.swift</code> file</p>
<pre><code>import Cocoa
import SwiftUI
import Combine

@NSApplicationMain
class AppDelegate: NSObject, ObservableObject, NSApplicationDelegate  {
    var isFocused = true
    
    // Other code app life-cycle functions
}
</code></pre>
<p>Inside the <code>ContentView.swift</code> file</p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    @ObservedObject var appDelegate = NSApplication.shared.delegate
    
    // Other UI code
}
</code></pre>
","2226315","","","","","2022-05-19 07:24:58","How to confirm ObservableObject for an AppDelegate?","<macos><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63018646","1","63018988","","2020-07-21 16:13:34","","1","293","<p>the following is the code I am trying to get to work, all I want to do is display the current price and the currency it is in.</p>
<p>the link returns a format of :
<code>{&quot;currency&quot;:&quot;USD&quot;,&quot;rate&quot;:&quot;178.0466666666667&quot;}</code></p>
<pre><code>import SwiftUI
import Combine

struct BitcoinPrice: Decodable, Identifiable {
    var id = UUID()
    let currency: String
    let rate: String
}


struct BSVPrice: View {
    @State private var requests = Set&lt;AnyCancellable&gt;()
    @State private var exchangeRate = [BitcoinPrice]()
    
    var body: some View {
        NavigationView {
            List(exchangeRate) { rate in
                VStack(alignment: .leading) {
                    Text(rate.currency)
                    Text(rate.rate)
                }
            }
            .navigationTitle(&quot;Bitcoin Price&quot;)
        }
        
        .onAppear {
            let bitcoinPriceURL = URL(string: &quot;https://api.whatsonchain.com/v1/bsv/main/exchangerate&quot;)!
            //let bitcoinPriceTask = fetch(bitcoinPriceURL, defaultValue: [BitcoinPrice]() )
            fetch(bitcoinPriceURL, defaultValue: [BitcoinPrice]() ) {
                exchangeRate = $0
            }
        }
    }
    
    func fetch&lt;T: Decodable&gt;(_ url: URL, defaultValue: T, completion: @escaping (T) -&gt; Void) {
        let decoder = JSONDecoder()
        
        URLSession.shared.dataTaskPublisher(for: url)
            .retry(1)
            .map(\.data)
            .decode(type: T.self, decoder: decoder)
            .replaceError(with: defaultValue)
            .receive(on: DispatchQueue.main)
            .sink(receiveValue: completion)
            .store(in: &amp;requests)
    }
    
    func fetch&lt;T: Decodable&gt;(_ url: URL, defaultValue: T) -&gt; AnyPublisher&lt;T, Never&gt; {
        let decoder = JSONDecoder()
        
        return URLSession.shared.dataTaskPublisher(for: url)
            .retry(1)
            .map(\.data)
            .decode(type: T.self, decoder: decoder)
            .replaceError(with: defaultValue)
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}


struct BSVPrice_Previews: PreviewProvider {
    static var previews: some View {
        BSVPrice()
    }
}
</code></pre>
<p>Does anyone know why the JSON is not loading into the application? Any help would be great, I have got the code to work with a different API so a bit confused.</p>
","13128993","","968155","","2020-07-21 16:18:14","2020-07-21 16:39:36","Fetching JSON from URL in SwiftUI","<json><swift><swiftui>","1","1","1","","","CC BY-SA 4.0"
"63020426","1","63020580","","2020-07-21 18:01:05","","2","274","<p>I've always used delegation in UIKit and WatchKit to communicate between objects as far as passing around data from e.g. a WorkoutManager ViewModel that receives delegate callbacks from HealthKit during an HKworkout for calories, heart rates, to an InterfaceController.</p>
<p>I'm now trying to use Combine and SwiftUI to pass around the same data and am a little lost. I'm using a WorkoutManager class as an environment object that I initialize in my ContentView:</p>
<pre><code>class WorkoutManager: NSObject, HKWorkoutSessionDelegate, HKLiveWorkoutBuilderDelegate, ObservableObject  {

    @Published var totalEnergyBurned: Double = 0

    //How to subscribe to the changes? 

//Omitted HealthKit code that queries and pushes data into totalEnergyBurned here

}



struct ContentView: View {
    
    let healthStore = HKHealthStore()
    @StateObject var workoutManager = WorkoutManager()
    
    var sessionTypes = [SessionType.Game, SessionType.Practice, SessionType.Pickup]
    
    var body: some View {
        
        List {
            ForEach(sessionTypes) { sessionType  in
                NavigationLink(destination: LiveWorkoutView(sessionType: sessionType)) {
                    SessionTypeRow(name: sessionType.stringValue)
                }
            }
        }
        .navigationTitle(&quot;Let's Go!&quot;)
        .onAppear {
            let authorizationStatus = healthStore.authorizationStatus(for: HKSampleType.workoutType())
            switch authorizationStatus {
            case .sharingAuthorized:
                print(&quot;sharing authorized&quot;)
            case .notDetermined:
                print(&quot;not determined&quot;)
                HealthKitAuthManager.authorizeHealthKit()
            case .sharingDenied:
                print(&quot;sharing denied&quot;)
                HealthKitAuthManager.authorizeHealthKit()
            default:
                print(&quot;default in healthStore.authorizationStatus in ContentView&quot;)
                HealthKitAuthManager.authorizeHealthKit()
            }
        }
    }
}
</code></pre>
<p>My goal is to Publish the changes to all of the children of ContentView but I'm not sure how to subscribe to the changes?</p>
<pre><code>import SwiftUI

struct LiveWorkoutView: View {

@State var sessionType: SessionType
    
    @StateObject var workoutManager = WorkoutManager()
    
    var body: some View {
        VStack {
            Text(&quot;\(workoutManager.totalEnergyBurned)&quot;)
            Button(action: {
                workoutManager.stopWorkout()
            }) {
                Text(&quot;End Workout&quot;)
            }
        }
        .onAppear {
            workoutManager.startWorkout()
            workoutManager.sessionType = sessionType
        }
        .navigationTitle(sessionType.stringValue)
    }
}
</code></pre>
","4625622","","","","","2020-07-21 18:09:37","Using Combine's Publishers and Subscribers to publish real time HealthKit data?","<swift><swiftui><healthkit><combine><watchos>","1","0","","","","CC BY-SA 4.0"
"63020783","1","63021040","","2020-07-21 18:22:15","","3","1262","<p>I recently came across an issue where I didn't find a way to work around it.
If I place an observable object inside an environment object, my views don't update when a variable is changing.
This is my setup:</p>
<p>inside SceneDelegate I decalre the parent view with environmentObject:</p>
<pre><code> let parent = ParentView().environmentObject(Data())
</code></pre>
<p>This is the environment Object:</p>
<pre><code>class Data: ObservableObject {
    enum Page {
        case pageOne
    }
    var page: Page = .pageOne
    var person = Person()
}
</code></pre>
<p>now all my views are linked to the parent view:</p>
<pre><code>struct ParentView: View {

     @EnvironmentObject var data: Data

     var body: some View {
         VStack {
            if self.data.page == .pageOne {
                PageOne()
            } else {
                Text(&quot;No pages&quot;)
            }
        }
    }
}
</code></pre>
<p>I have a class (I called it &quot;Person&quot;):</p>
<pre><code> import Foundation
 import SwiftUI
 import Combine

 class Person: ObservableObject {

     let objectWillChange = PassthroughSubject&lt;Person,Never&gt;()

     @Published var age = 30 { didSet { objectWillChange.send(self)} }

     func birthday() {
         self.age += 1
         print(age)
     }

 }
</code></pre>
<p><strong>And this is where my problem occurs:</strong></p>
<pre><code> struct PageOne: View {

     @EnvironmentObject var data: Data

     var body: some View {
         Text(&quot;\(data.person.age)&quot;).onTapGesture {
             self.data.person.birthday()
         }
     }
 }
</code></pre>
<p>When I tap the text, the age of the person is increasing but the view does not update.
I think I don't even understand why this is happening.
I thought I knew how it works but apparently I don't.</p>
","9607072","","9607072","","2020-07-21 21:42:13","2020-07-21 22:02:13","SwiftUI Observable Object inside Environment Object does not update view","<ios><swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"63034377","1","63034708","","2020-07-22 12:38:15","","1","2002","<p>My understanding is a CurrentValueSubject publisher in Combine is good for accessing on demand, as opposed to a regular Publisher that emits a value once. So I'm trying to use one here in an Environment Object to store the total energy burned in an HKWorkout so that I can access it after the workout is finished in a SwiftUI View.  With the code below I get the compiler error <code>Cannot convert return expression of type 'AnyCancellable' to return type 'Double'</code> so I think I need to do some type of casting but can't figure it out?</p>
<pre><code>class WorkoutManager: NSObject, HKWorkoutSessionDelegate, HKLiveWorkoutBuilderDelegate, ObservableObject  {
    
    var finishedWorkoutTotalEnergyBurned = CurrentValueSubject&lt;Double, Never&gt;(0.0)
    
    func stopWorkout() {
        self.finishedWorkoutTotalEnergyBurned.value = unwrappedWorkout.totalEnergyBurned!.doubleValue(for: .kilocalorie())
    }
}

struct SummaryView: View {

    @StateObject var workoutManager = WorkoutManager()
    
    var body: some View {
        Text(&quot;\(getFinishedWorkoutTotalEnergyBurned())&quot;)
            .navigationBarHidden(true)
        //.navigationTitle(&quot;Workout Complete&quot;)
    }
    
    func getFinishedWorkoutTotalEnergyBurned() -&gt; Double {
        workoutManager.finishedWorkoutTotalEnergyBurned.sink(receiveValue: { $0 })
    }
}
</code></pre>
","4625622","","968155","","2020-07-22 12:42:53","2020-10-15 11:39:02","How to use Combine's CurrentValueSubject and access it in a SwiftUI View?","<ios><swift><swiftui><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"63039749","1","63040386","","2020-07-22 17:16:31","","3","582","<p>I was playing around with Combine and I realised that instead of calling <code>.cancel()</code> on an <code>AnyCancellable</code>,  making the <code>AnyCancellable</code> an <code>Optional</code> and setting it to <code>nil</code> also stops the stream of values.</p>
<p>Is setting an <code>AnyCancellable?</code> to <code>nil</code> instead of calling <code>.cancel()</code> on an <code>AnyCancellable</code> a bad thing? Does it have any negative consequences such as leaking memory or something?</p>
<p>For reference, this is the code:</p>
<pre><code>class Test: ObservableObject {
    var canceller: AnyCancellable?
    
    func start() {
        let timerPublisher = Timer
            .publish(every: 1, on: .main, in: .common)
            .autoconnect()
        
        self.canceller = timerPublisher.sink { date in
            print(&quot;the date is \(date)&quot;)
        }
    }
    func stop1() {
        canceller?.cancel()
    }
    func stop2() {
        canceller = nil
    }
}
</code></pre>
<pre><code>struct ContentView: View {
    @ObservedObject var test = Test()
    
    var body: some View {
        VStack(spacing: 20) {
            Button(&quot;Start&quot;) {
                self.test.start()
            }
            
            Button(&quot;Stop1&quot;) {
                self.test.stop1()  // Both buttons stop the stream of values
            }

            Button(&quot;Stop2&quot;) {
                self.test.stop2()  // Is there any difference between using this and stop1?
            }
        }
    }
}
</code></pre>
","13299183","","","","","2020-07-22 17:54:12","Is there a difference between calling .cancel() on an AnyCancellable vs. making an AnyCancellable? = nil in SwiftUI?","<ios><swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"63049647","1","63053648","","2020-07-23 08:05:35","","0","97","<p>I have the following code running in a playground that supposed to print an array of 4 clues based on a random category ID. The category ID and the Correct URL used to get the clues are always printed correctly However, the clue results are printed intermittently sometimes its successful other times. Can anyone help me figure out why it sometimes does not print the array of clues yet the URL is correct?</p>
<pre><code>import Foundation
import Combine

// MARK: - ClueElement
struct ClueElement: Codable {
  let id: Int
  let answer, question: String
  let value: Int
  let categoryID: Int
  let category: Category

  enum CodingKeys: String, CodingKey {
    case id, answer, question, value
    case categoryID = “category_id”
    case category
  }
}


// MARK: - Category
struct Category: Codable {
  let id: Int
  let title: String
  let cluesCount: Int

  enum CodingKeys: String, CodingKey {
    case id, title
    case cluesCount = “clues_count”
  }
}


enum HTTPError: LocalizedError {
  case statusCode
  case post
}



typealias Clue = [ClueElement]

var cancellable: AnyCancellable?

func loadData() {
  let url1 = URL(string: “http://www.jservice.io/api/random”)!
  cancellable = URLSession.shared.dataTaskPublisher(for: url1)
    .map { $0.data }
    .decode(type: Clue.self, decoder: JSONDecoder())
    .tryMap { category in
      guard let categoryID = category.first?.categoryID else { throw HTTPError.post}
      guard let cluesCount = category.first?.category.cluesCount else { throw HTTPError.post}
      print(“\(categoryID)“)
      return (categoryID,cluesCount)
  }
  .flatMap { (categoryID,cluesCount) in
    return getClues(for: categoryID, cluesCount: cluesCount)
  }
  .receive(on: DispatchQueue.main)
  .sink(receiveCompletion: { completion in

  }) { clues in
    print(clues)
  }
}

func getClues(for id: Int, cluesCount: Int) -&gt; AnyPublisher&lt;Clue, Error&gt; {
  let url = URL(string: “http://www.jservice.io/api/clues?category=\(id)&amp;offset=\(cluesCount - 4)“)!
  print(url)
  return URLSession.shared.dataTaskPublisher(for: url)
    .map { $0.data }
    .decode(type: Clue.self, decoder: JSONDecoder())
    .receive(on: DispatchQueue.main)
    .eraseToAnyPublisher()
}

loadData()
</code></pre>
","3369207","","","","","2020-07-23 11:53:56","intermittent results using URLSession with Combine","<swift><nsurlsession><combine>","1","0","","","","CC BY-SA 4.0"
"63082722","1","63082907","","2020-07-24 23:31:22","","0","1552","<p>Ok, so I am using the last version of Swift with Combine.
My goal is to combine 3 <code>CurrentValueSubject</code> or <code>PassthroughSubject</code> into one Sequence by waiting for all of them to emit once.</p>
<p>Let's take the following example:</p>
<pre><code>var var1 = CurrentValueSubject&lt;[String], Never&gt;)([])
var var2 = CurrentValueSubject&lt;Int, Never&gt;(0)
var var3 = CurrentValueSubject&lt;Date?, Never&gt;(nil)
</code></pre>
<p>I want to have all value in one when they each emit a new sequence.</p>
<p>So I could do something like that:</p>
<pre><code>Publishers
    .CombineLatest3(var1, var2, var3)
    .sink(receivedValue: { var1, var2, var3 in
        print(&quot;Printed!&quot;)
    })
    .store(in: &amp;subscriptions)
</code></pre>
<p>Alright, so that kind of works, but it will print <code>Printed!</code> 3 times on the second pass.
Let's say, if I do the following code, it will do it only once.</p>
<pre><code>var1.send([&quot;test&quot;,&quot;test1&quot;])
var2.send(0)
var3.send(Date())
</code></pre>
<p>but I add this</p>
<pre><code>var1.send([&quot;test&quot;,&quot;test1&quot;])
var2.send(0)
var3.send(Date())
var1.send([&quot;test&quot;,&quot;test1&quot;])
</code></pre>
<p>It will trigger again my Combined Publishers. And I want to trigger it again only if I have the following scenario:</p>
<pre><code>var1.send([&quot;test&quot;,&quot;test1&quot;])
var2.send(0)
var3.send(Date())
var1.send([&quot;test2&quot;,&quot;test3&quot;])
var2.send(2)
var3.send(Date())
</code></pre>
<p>I hope this makes sense, let me know if you have an idea of how to tackle this issue!</p>
","5899647","","77567","","2020-07-25 01:25:04","2020-07-25 01:25:04","Swift Combine - Multiple Observable (CurrentValueSubject or PassthroughSubject) into one but wait for update from all","<swift><reactive-programming><combine>","1","3","","","","CC BY-SA 4.0"
"63123878","1","63123988","","2020-07-27 21:32:19","","0","118","<p>I am trying to decode this json array and I got the following code to work, initially but it is a bit buggy.</p>
<p>the json is structured as following:</p>
<pre><code>{
&quot;prices&quot;: [
  [
    1595642361269,
    180.62508267006177
  ],
  [
    1596642361269,
    190.1
  ]
],
&quot;market_caps&quot;: [
  [
    1595642361269,
    3322122955.6677375
  ],
  [
    1596642361269,
    3332122955.6677375
  ]
],
&quot;total_volumes&quot;: [
  [
    1595642361269,
    590499490.5115521
  ],
  [
    1595642361269,
    590499490.5115521
  ]
]
}
</code></pre>
<p>my swift object is structured as:</p>
<pre><code>struct MarketChart: Decodable {
    let prices: [[Double]]
    let market_caps: [[Double]]
    let total_volumes: [[Double]]
    
}
</code></pre>
<p>I dont think it is optimal but as the json doesn't have keys for the timestamps and values I was a bit confused on how to structure it.</p>
<p>the following is my playground code:</p>
<pre><code>func getJSON&lt;T: Decodable&gt;(urlString: String, completion: @escaping (T?) -&gt; Void) {
    guard let url = URL(string: urlString) else {
        return
    }
    let request = URLRequest(url: url)
    URLSession.shared.dataTask(with: request) { (data, response, error) in
        if let error = error {
            print(error.localizedDescription)
            completion(nil)
            return
        }
        guard let data = data else {
            completion(nil)
            return
        }
        
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        guard let decodedData = try? decoder.decode(T.self, from: data) else {
            completion(nil)
            return
        }
        completion(decodedData)
    }.resume()
}


struct MarketChart: Decodable {
    let prices: [[Double]]
    let market_caps: [[Double]]
    let total_volumes: [[Double]]
    
}

var priceArray: [Double] = []

print(priceArray)

getJSON(urlString: &quot;https://api.coingecko.com/api/v3/coins/bitcoin-cash-sv/market_chart?vs_currency=usd&amp;days=1&quot;) { (data: MarketChart?) in
    if let data = data {
        for item in data.prices {
            priceArray.append(item.first!)
        }
    }    
}
print(priceArray)
</code></pre>
<p>I am trying to get all the values into an array and it did work initially but now just keeps printing an empty array. my end goal is to crate a graph of the values over time in a project and I did it successfully the first time but now I keep getting an error saying it can't get the value from an empty array.</p>
<p>my Xcode project file is as follows:</p>
<pre><code>import SwiftUI
import SwiftUICharts
import Combine

struct CoinGeckoBSVMarketChart: View {
    @State var jsonData = [MarketChart]()
    @State var priceArray = [Double]()
    @State var volumeArray: [Double] = []
    
    private let last24hpricesURL: String = &quot;https://api.coingecko.com/api/v3/coins/bitcoin-cash-sv/market_chart?vs_currency=usd&amp;days=1&quot;
    
    var body: some View {
        ZStack {
            VStack {
                LineView(data: priceArray)
                    .padding()
                
                Text(&quot;Reset&quot;)
                    .onTapGesture {
                        
                    }

            }
        }
        .onAppear {
            getJSON(urlString: last24hpricesURL) { (data: MarketChart?) in
                if let data = data {
                    for item in data.prices {
                        priceArray.append(item.last!)
                    }
                }
            }
        }
    }
}

struct MarketChart: Decodable {
    let prices: [[Double]]
    let market_caps: [[Double]]
    let total_volumes: [[Double]]
}

struct CoinGeckoBSVMarketChart_Previews: PreviewProvider {
    static var previews: some View {
        CoinGeckoBSVMarketChart()
            .preferredColorScheme(.dark)
    }
}
</code></pre>
<p>any help with either improving the json object model or getting all the items in an array would be great</p>
","13128993","","13128993","","2020-07-27 22:01:27","2020-07-27 22:01:27","Array JSON decoding in swift","<json><swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"63143578","1","63144806","","2020-07-28 22:16:11","","1","1383","<p>I have the following model:</p>
<pre><code>struct Response: Decodable {
    let message: String
}

struct ErrorResponse: Decodable {
    let errorMessage: String
}

enum APIError: Error {
    case network(code: Int, description: String)
    case decoding(description: String)
    case api(description: String)
}
</code></pre>
<p>I'm trying to fetch an url and parse the JSON response using this flow:</p>
<pre><code>func fetch(url: URL) -&gt; AnyPublisher&lt;Response, APIError&gt; {
    URLSession.shared.dataTaskPublisher(for: URLRequest(url: url))

        // #1 URLRequest fails, throw APIError.network
        .mapError { .network(code: $0.code.rawValue, description: $0.localizedDescription) }

        // #2 try to decode data as a `Response`
        .tryMap { JSONDecoder().decode(Response.self, from: $0.data) }

        // #3 if decoding fails, decode as an `ErrorResponse`
        //    and throw `APIError.api(description: errorResponse.errorMessage)`

        // #4 if both fail, throw APIError.decoding
        
        // #5 return
        .eraseToAnyPublisher()
}
</code></pre>
<p>I have a problem with <code>#3</code>: how can I decode the original data after the <code>tryMap</code> part?</p>
<p>It seems like the only value I can access there is the error coming from <code>tryMap</code> but I need the original data to decode an <code>ErrorRepsonse</code>.</p>
<p>Note: unfortunately the error response comes with the 200 status and the only way to differentiate them is to decode them.</p>
","8697793","","","","","2020-07-29 14:20:54","Decode another response if first decoding failed using Combine and Swift","<json><swift><combine><decodable>","1","0","","","","CC BY-SA 4.0"
"63149864","1","63158713","","2020-07-29 08:52:52","","0","190","<p>I am trying to use the <code>URLSession.dataTaskPublisher</code> to create a retrying Publisher, which connects to a MJPEG stream.</p>
<p>Unfortunately my Subscriber never really receives any data, although I can see that data is transferred and the RAM consumption slowly increases. So the stream is open and data is received but not on the Subscriber. I had a version which received data once, but then closed the stream immediately.</p>
<p>I have tried many different configurations but the following seems to be closest to the goal:</p>
<p>What am I missing? Has someone encountered this kind of memory leak before?</p>
<p>I am mostly interested in a <code>timeout</code> error but also want to retry when something else is not working properly.</p>
<pre class=""lang-swift prettyprint-override""><code>var cancellables: Set&lt;AnyCancellable&gt; = []
let url = URL(string: &quot;http://mjpeg.stream&quot;)!
let configuration = URLSessionConfiguration.ephemeral
configuration.timeoutIntervalForRequest = 1
configuration.requestCachePolicy = .reloadIgnoringLocalAndRemoteCacheData
let datataskpublisher = URLSession(configuration: configuration)
    .dataTaskPublisher(for: url)

let catcher = datataskpublisher
    .tryCatch { (error) -&gt; AnyPublisher&lt;(data: Data, response: URLResponse), URLError&gt; in
        print(&quot;ERROR: \(error.code)&quot;)
        throw error
    }.eraseToAnyPublisher()

let retryer = catcher
    .catch { (error) -&gt; AnyPublisher&lt;(data: Data, response: URLResponse), Error&gt; in
        print(&quot;RETRYING&quot;)
        return catcher.delay(for: 0.5, scheduler: DispatchQueue.global()).eraseToAnyPublisher()
    }
    .eraseToAnyPublisher()


retryer
    .sink(receiveCompletion: { result in
          print(&quot;COMPLETED&quot;)
          switch result {
          case .failure(let fail):
               print(&quot;FAIL \(fail)&quot;)
          case .finished:
               print(&quot;FINISHED&quot;)
          }
     }, receiveValue: { value, response in
          print(&quot;DATA&quot;)
          let data = value
                    // parsing data
    })
    .store(in: &amp;self.cancellables)
</code></pre>
","5981293","","","","","2020-07-29 16:57:23","URLSession dataTaskPublisher with retry as MJPEG stream","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"63150648","1","63157768","","2020-07-29 09:35:36","","0","444","<p>Given I have an SDK which provides the functionality below</p>
<pre><code>class SDK {
    static func upload(completion: @escaping (Result&lt;String, Error&gt;) -&gt; Void) {
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            completion(.success(&quot;my_value&quot;))
        }
    }
}
</code></pre>
<p>I am able to a create a wrapper around to make its usage more functional</p>
<pre><code>class CombineSDK {
    func upload() -&gt; AnyPublisher&lt;String, Error&gt; {
        Future { promise in
            SDK.upload { result in
                switch result {
                case .success(let key):
                    promise(.success(key))
                case .failure(let error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
}
</code></pre>
<p>Now I'm trying to understand how my CombineSDK.upload method should look like if the SDK upload method also provides a progress block like below:</p>
<pre><code>class SDK {
    static func upload(progress: @escaping (Double) -&gt; Void, completion: @escaping (Result&lt;String, Error&gt;) -&gt; Void) {
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            progress(0.5)
        }

        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            progress(1)
        }

        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            completion(.success(&quot;s3Key&quot;))
        }
    }
}
</code></pre>
","1044591","","","","","2020-07-30 02:01:04","Publisher emitting progress of operation and final value","<swift><combine>","3","0","","","","CC BY-SA 4.0"
"63197832","1","63198186","","2020-07-31 19:12:54","","1","136","<p>I'm trying to observe change of an NSMutableOrderedSet in my ViewModel with combine.
I want to know when some element is added or removed of NSMutableOrderedSet</p>
<p>Some code of my ViewModel :</p>
<pre><code>    class TrainingAddExerciceViewModel: ObservableObject {
        
        @Published var exercice: Exercice?
        @Published var serieHistories = NSMutableOrderedSet()
    
    ...
      init(...) {
        ...
        
//Where i'm trying to observe 
        $serieHistories
            .sink { (value) in
                print(value)
        }
        .store(in: &amp;self.cancellables)
    }
    
    }
</code></pre>
<p>This is the function I use in my ViewModel to add element to NSMutableOrderedSet :</p>
<pre><code>func add(managedObjectContext: NSManagedObjectContext) {
        let newSerieHistory = ExerciceSerieHistory(context: managedObjectContext)
        self.serieHistories.add(newSerieHistory)
        self.updateView()
    }
</code></pre>
<p>I have some other publisher working well with an other type (custom class).</p>
<p>Did I miss something ?</p>
","3596283","","","","","2020-07-31 19:42:13","Detect change in NSMutableOrderedSet with Swift Combine","<swift><xcode><swiftui><combine><nsmutableset>","1","2","","","","CC BY-SA 4.0"
"63202303","1","63202346","","2020-08-01 06:02:32","","0","664","<p>Given an existing <code>CurrentValueSubject</code> instance, the goal is to create a new <code>Publisher</code> that will take the subject's stream of Strings, and in turn will output Ints.</p>
<p>My approach is to map the subject to <code>AnyPublisher</code>:</p>
<pre><code>let subject: CurrentValueSubject&lt;String, Never&gt; = ...

func intPublisher() -&gt; AnyPublisher&lt;Int, Never&gt;
{
    return subject.map { string in
        let value = Int(string) ?? 0
        return AnyPublisher&lt;Int, Never&gt;(value) // Error: Generic parameter P could not be inferred.
    }
}
</code></pre>
<p>However, I cannot create a new <code>AnyPublisher</code> this way. Clearly, my understanding of Publishers is flawed. Could someone please enlighten me?</p>
","1452758","","466862","","2020-08-01 06:13:08","2020-08-01 06:13:08","Convert Subject/Publisher to another Publisher","<swift><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"63202555","1","63202608","","2020-08-01 06:46:19","","1","3622","<p>I have the following code and Im getting the message error:</p>
<blockquote>
<p>'wrappedValue' is unavailable: @Published is only available on
properties of classes</p>
</blockquote>
<pre><code>//*
/**
Chat
Created on 29/07/2020
*/

import SwiftUI

let lightGreyColor = Color(red: 239.0/255.0, green: 243.0/255.0, blue: 244.0/255.0, opacity: 1.0)

struct ConnectionView: View {
    @ObservedObject var keyboardResponder = KeyboardResponder()
    @ObservedObject var viewModel = ConnectionVM()
//    @State var uuid1: String = &quot;&quot;
//    @State var uuid2: String = &quot;&quot;
    @State var authenticationDidFail: Bool = false
    
    var body: some View {
        return VStack {
            WelcomeText()
            LogoImage()
            UUIDTextField(uuid: viewModel.uuid1)
            UUIDTextField(uuid: viewModel.uuid2)
            if authenticationDidFail {
                Text(&quot;Information not correct. Try again.&quot;)
                .offset(y: -10)
                .foregroundColor(.red)
            }
            Button(action: {
                print(&quot;Button tapped&quot;)
            }) {
               LoginButtonContent()
            }
        }
        .padding()
        .offset(y: -keyboardResponder.currentHeight*0.5)
    }
    struct WelcomeText : View {
        var body: some View {
            return Text(&quot;Welcome!&quot;)
                .font(.largeTitle)
                .fontWeight(.semibold)
                .padding(.bottom, 20)
        }
    }
    struct LogoImage : View {
        var body: some View {
            return Image(&quot;logo&quot;)
                .resizable()
                .aspectRatio(contentMode: .fill)
                .frame(width: 150, height: 150)
                .clipped()
                .cornerRadius(150)
                .padding(.bottom, 75)
        }
    }
    struct UUIDTextField : View {
        @Published var uuid: String
        var body: some View {
        return TextField(&quot;UUID&quot;, text: $uuid)
                    .padding()
                    .background(lightGreyColor)
                    .cornerRadius(5.0)
                    .padding(.bottom, 20)
            }
    }
    struct LoginButtonContent : View {
        var body: some View {
            return Text(&quot;LOGIN&quot;)
                .font(.headline)
                .foregroundColor(.white)
                .padding()
                .frame(width: 220, height: 60)
                .background(Color.green)
                .cornerRadius(15.0)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ConnectionView()
    }
}
</code></pre>
<h1>My question is</h1>
<p>how can I pass @Published var by parameter to a subview .</p>
<p><a href=""https://i.stack.imgur.com/OKTBR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/OKTBR.png"" alt=""enter image description here"" /></a></p>
<h1>Update Question</h1>
<p>If i use Binding instead of published I get this error:</p>
<blockquote>
<p>Cannot convert value of type 'String' to expected argument type 'Binding'</p>
</blockquote>
<p><a href=""https://i.stack.imgur.com/F0HBl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/F0HBl.png"" alt=""enter image description here"" /></a></p>
","2139691","","2139691","","2020-08-01 06:59:05","2020-08-01 06:59:05","SwiftUI Combine: @Published is only available on properties of classes","<ios><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63237595","1","63254603","","2020-08-03 22:08:17","","1","1163","<p>I have an API that may return a JSON array of JSON objects or a single JSON object.</p>
<p>How do I write a combine publisher pipeline that handles this case?</p>
<p>I normally hard-code the type of the JSON-response when I add my combine decode operator to my pipeline:</p>
<pre><code>.decode(type: [MyArrayType].self, decoder: JSONDecoder())
.decode(type: MyObjectType.self, decoder: JSONDecoder())
</code></pre>
","3572929","","","","","2020-08-05 14:14:30","Combine JSON decoding pipeline, when response can be an array or an object at runtime","<json><swift><combine>","1","4","","","","CC BY-SA 4.0"
"63239813","1","63239902","","2020-08-04 03:27:19","","2","333","<p>I want to try <code>Combine</code> framework, very simple usage, press a <code>UIButton</code>, and update <code>UILabel</code>.</p>
<p>My idea is:</p>
<ol>
<li>Add a publisher</li>
</ol>
<p><code>@Published var cacheText: String?</code></p>
<ol start=""2"">
<li>Subscribe</li>
</ol>
<p><code>$cacheText.assign(to: \.text, on: cacheLabel)</code></p>
<ol start=""3"">
<li>assign a value when button pressed.</li>
</ol>
<p><code>cacheText = &quot;testString&quot;</code></p>
<p>Then the label's text should be updated.</p>
<p>The problem is when the button pressed, the <code>@Published</code> value is updated, but the <code>UILabel</code> value doesn't change.
e.g the <code>cacheLabel1</code> was assigned <code>123</code> initially but not <code>789</code> when button pressed.</p>
<p>Here's the full code:</p>
<p><strong>ViewModel.swift</strong></p>
<pre><code>import Foundation
import Combine

class ViewModel {
    @Published var cacheText: String?

    func setup(_ text: String) {
        cacheText = text
    }

    init() {
        setup(&quot;123&quot;)
    }
}
</code></pre>
<p><strong>ViewController.swift</strong></p>
<pre><code>  class ViewController: UIViewController {
    @IBOutlet weak var cacheLabel: UILabel!

    var viewModel = ViewModel()

    @IBAction func buttonPressed(_ sender: Any) {
        viewModel.setup(&quot;789&quot;)
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        viewModel.$cacheText.assign(to: \.text, on: cacheLabel)
    }
}
</code></pre>
<p>Not sure if I missed something, thanks for the help.</p>
","291240","","","","","2020-08-04 03:37:38","Combine Framework Update UI doesn't work properly","<ios><swift><combine>","1","0","1","","","CC BY-SA 4.0"
"63246040","1","63247810","","2020-08-04 11:35:04","","1","354","<p>I am trying to make a UITextView that edits a value <code>currentDisplayedAddress</code>. The value is also changed by other views, and I want the UITextView to update its text when that occurs.</p>
<p>The view initializes correctly, and I can edit <code>currentDisplayedAddress</code> from <code>AddressTextField</code> with no problem and trigger relevant view updates. However, when the value is changed by other views, the textField's text does not change, even though <code>textField.text</code> prints the correct updated value inside <code>updateUIView</code> and other views update accordingly.</p>
<p>I have no idea what may have caused this. Any help is extremely appreciated.</p>
<pre><code>struct AddressTextField: UIViewRepresentable {
    private let textField = UITextField(frame: .zero)
    var commit: () -&gt; Void
    @EnvironmentObject var userData: UserDataModel

    func makeUIView(context: UIViewRepresentableContext&lt;AddressTextField&gt;) -&gt; UITextField {
        textField.text = self.userData.currentDisplayedAddress
        textField.delegate = context.coordinator
        return textField
    }

    func updateUIView(_ uiView: UITextField, context: UIViewRepresentableContext&lt;AddressTextField&gt;) {
        if self.textField.text != self.userData.currentDisplayedAddress {
        DispatchQueue.main.async {
            self.textField.text = self.userData.currentDisplayedAddress
            }
        }
    }

   (...)

    func makeCoordinator() -&gt; Coordinator { Coordinator(self) }

    class Coordinator: NSObject, UITextFieldDelegate {
        var addressTextField: AddressTextField

        func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool {   //delegate method
            textField.resignFirstResponder()
            addressTextField.userData.currentDisplayedAddress = textField.text ?? String()
            addressTextField.commit()
            return true
        }
    }
}
</code></pre>
","7857053","","","","","2020-08-04 13:20:50","UITextField not updating to change in ObservableObject (SwiftUI)","<swiftui><combine><observableobject>","1","0","","","","CC BY-SA 4.0"
"63251715","1","63251882","","2020-08-04 17:01:12","","3","1092","<p>I have a following scenario.</p>
<p>I have AppState which consists of an object of type Foo. Foo has a counter variable and I want to call objectWillChange when counter value updates so I can update the UI.</p>
<p>At present nothing happens. The increment function gets called but the UI never gets updated.</p>
<pre><code>


import Foundation
import Combine

class Foo: ObservableObject {
    @Published var counter: Int = 999
    
    func increment() {
        counter += 1 // how to get notified when counter value changes
    }
}

class AppState: ObservableObject {
    
    @Published var foo: Foo = Foo()
}

// usage in Scene Delegate as Environment Object
let appState = AppState()

// Use a UIHostingController as window root view controller.
if let windowScene = scene as? UIWindowScene {
    let window = UIWindow(windowScene: windowScene)
    window.rootViewController = UIHostingController(rootView: accountSummaryScreen.environmentObject(appState))

</code></pre>
<p><strong>UPDATE</strong></p>
<pre><code>class Foo: ObservableObject {
    @Published var counter: Int = 999 {
        didSet {
            objectWillChange.send() 
        }
    }
    
    func increment() {
        counter += 1 // how to get notified when counter value changes
    }
}

</code></pre>
","810815","","810815","","2020-08-04 17:11:09","2022-03-01 15:37:31","Change Notification from Observable Object as a Nested Object in SwiftUI","<swift><swiftui>","2","4","1","","","CC BY-SA 4.0"
"63256563","1","63257257","","2020-08-04 23:51:41","","0","214","<p>My testbed looks like this:</p>
<pre><code>var storage = Set&lt;AnyCancellable&gt;()
override func viewDidLoad() {
    let pub = Timer.publish(every: 0.2, on: .main, in: .common).autoconnect()
        .scan(0) {i,_ in i+1}
        .buffer(size: 4, prefetch: .keepFull, whenFull: .dropNewest)
        .flatMap(maxPublishers:.max(1)) {
            Just($0).delay(for: 2, scheduler: DispatchQueue.main)
        }
    pub.sink{print($0)}.store(in:&amp;storage)
}
</code></pre>
<p>The result is just a slow steady stream of numbers in succession: 1 2 3 4 5 6 ...</p>
<p>But that is the same result you would get if you just deleted the <code>.buffer</code> line entirely. So what purpose does the buffer serve? To put it another way: can someone make me an example where a buffer with a <code>.keepFull</code> prefetch policy makes a difference?</p>
","341994","","","","","2021-05-11 03:16:28","Combine framework buffer operator with keepFull strategy: what does it do?","<ios><combine>","1","2","","","","CC BY-SA 4.0"
"63263824","1","63263859","","2020-08-05 11:04:31","","0","24","<p>from this link <a href=""https://developer.apple.com/documentation/combine/publishers/merge/share()"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/combine/publishers/merge/share()</a></p>
<pre><code>let pub = (1...3).publisher
.delay(for: 1, scheduler: DispatchQueue.main)
.map( { _ in return Int.random(in: 0...100) } )
.print(&quot;Random&quot;)
.share()

cancellable1 = pub
.sink { print (&quot;Stream 1 received: \($0)&quot;)}
cancellable2 = pub
.sink { print (&quot;Stream 2 received: \($0)&quot;)}

// Prints:
// Random: receive value: (20)
// Stream 1 received: 20
// Stream 2 received: 20
// Random: receive value: (85)
// Stream 1 received: 85
// Stream 2 received: 85
// Random: receive value: (98)
// Stream 1 received: 98
// Stream 2 received: 98
</code></pre>
<p>but if I do like this below, share doesn't work as I expected</p>
<pre><code>var pub: Publishers.Share&lt;AnyPublisher&lt;Int, Never&gt;&gt; {
    (1...3).publisher
        .delay(for: 1, scheduler: DispatchQueue.main)
        .map( { _ in return Int.random(in: 0...100) } )
        .print(&quot;Random&quot;)
        .eraseToAnyPublisher()
        .share()
}
cancellable1 = pub
.sink { print (&quot;Stream 1 received: \($0)&quot;)}
cancellable2 = pub
.sink { print (&quot;Stream 2 received: \($0)&quot;)}

// Prints:    
// Random: receive value: (99)
// Stream 1 received: 99
// Random: receive value: (56)
// Stream 1 received: 56
// Random: receive value: (38)
// Stream 1 received: 38
// Random: receive finished
// Random: receive value: (98)
// Stream 2 received: 98
// Random: receive value: (11)
// Stream 2 received: 11
// Random: receive value: (32)
// Stream 2 received: 32
</code></pre>
<p>Why share doesn't work with the second case?</p>
","12208004","","4667835","","2020-08-05 11:07:38","2020-08-05 11:07:38","Is this a normal behavior about Publisher.Share","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"63269415","1","63286820","","2020-08-05 16:22:01","","0","149","<p>To show my the content from my root view after successful login, I tried with <code>ObservedObject</code>, and with <code>EnvironmentObject</code>, to no avail.</p>
<p>E.g. as follows:</p>
<pre class=""lang-swift prettyprint-override""><code>struct RootView: View {

    @EnvironmentObject var loginManager: LoginManager

    var body: some View {
        Group {
            if loginManager.isLoggedIn {
                SegmentedView()
            }
            else {
                WelcomeView()
            }
        }
    }
}

class LoginManager: ObservableObject {
    
    static let shared = LoginManager()
    var cancellable = Set&lt;AnyCancellable&gt;()
    @Published var isLoggedIn = false

    ...
    
    func login(...) {
        ...
        // on success
        self.isLoggedIn = true
    }
</code></pre>
<p>The <code>LoginManager</code> is retained in the <code>SceneDelegate</code> and put into the environment:</p>
<pre><code>class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?
    var loginManager = LoginManager.shared
    ...

    // the view passed to window.rootUiewController via UIHostingController
    let contentView = RootView().environmentObject(loginManager)
</code></pre>
<p>After logging in, it goes right back to my <code>WelcomeView</code>. What am I missing?</p>
<p><strong>EDIT</strong></p>
<p>Here is a new aspect. I have a view model for the <code>LoginView</code> to manage the data in date fields. When the login button is pressed, I call a <code>login()</code> method in this view model.</p>
<p>I need to two <code>.sink</code> callbacks in the view model, because I have to dismiss the loading indicator by setting a <code>loading</code> flag to false.</p>
<p>So I cannot call <code>self.isLoggedIn = true</code> directly because I am in the view model, not the <code>LoginManager</code>. Instead I call</p>
<pre><code>self.loginManager.isLoggedIn = true 
</code></pre>
<p>and I suspect that this line is not working.</p>
<p>The connection between view model and login manager is done like this</p>
<pre><code>@ObservedObject var loginManager = LoginManager.shared
</code></pre>
<p>However, after shifting this to the <code>LoginManager</code>, I am indeed calling <code>self.isLoggedIn</code> from there. It is still not working.</p>
<p>I have two theses:</p>
<ol>
<li><p>It could be that the view is not set up correctly with <code>Group</code> etc. I also tried to use <code>@ViewBuilder</code> etc, no difference.</p>
</li>
<li><p>It could be that somehow there are two instances of <code>LoginManager</code>, or the <code>RootView</code> somehow get's reinitialised with a new instance where <code>isLoggedIn</code> is false. But I have been creating Swift singletons like this for ages:</p>
<p>static let shared = LoginManager()</p>
</li>
</ol>
<p>and never had any problems.</p>
<p>As mentioned in the comments, there is another error I encountered when switching all to <code>@EnvironmentObject</code>:</p>
<blockquote>
<p><code>Fatal error: No ObservableObject of type LoginManager found. A View.environmentObject(_:) for LoginManager may be missing as an ancestor of this view.: file SwiftUI, line 0</code></p>
</blockquote>
","427083","","427083","","2020-08-06 13:58:15","2020-08-06 15:24:58","SwiftUI ObservedObject not updating view after successful login","<swift><swiftui><combine><observedobject>","1","11","","","","CC BY-SA 4.0"
"63282377","1","63289139","","2020-08-06 11:14:32","","33","21877","<p>When trying to compile the following code:</p>
<pre><code>class LoginViewModel: ObservableObject, Identifiable {
    @Published var mailAdress: String = &quot;&quot;
    @Published var password: String = &quot;&quot;
    @Published var showRegister = false
    @Published var showPasswordReset = false

    private let applicationStore: ApplicationStore

    init(applicationStore: ApplicationStore) {
        self.applicationStore = applicationStore
    }

    var passwordResetView: some View {
        PasswordResetView(isPresented: $showPasswordReset) // This is where the error happens
    }
}
</code></pre>
<p>Where PasswordResetView looks like this:</p>
<pre><code>struct PasswordResetView: View {
    @Binding var isPresented: Bool
    @State var mailAddress: String = &quot;&quot;
    
    var body: some View {
            EmptyView()
        }
    }
}
</code></pre>
<p>I get the error compile error</p>
<pre><code>Cannot convert value of type 'Published&lt;Bool&gt;.Publisher' to expected argument type 'Binding&lt;Bool&gt;'
</code></pre>
<p>If I use the published variable from outside the LoginViewModel class it just works fine:</p>
<pre><code>struct LoginView: View {
    @ObservedObject var viewModel: LoginViewModel

    init(viewModel: LoginViewModel) {
      self.viewModel = viewModel
    }
    
    var body: some View {
            PasswordResetView(isPresented: self.$viewModel.showPasswordReset)
    }
}
</code></pre>
<p>Any suggestions what I am doing wrong here? Any chance I can pass a published variable as a binding from inside the owning class?</p>
<p>Thanks!</p>
","14059662","","","","","2022-02-12 11:51:30","Cannot convert value of type 'Published<Bool>.Publisher' to expected argument type 'Binding<Bool>'","<ios><swift><swiftui><combine>","5","3","","","","CC BY-SA 4.0"
"63304029","1","63305210","","2020-08-07 14:40:26","","2","402","<p>I'm using the <a href=""https://github.com/edw/swiftui-numberfield/blob/master/DecimalField.swift"" rel=""nofollow noreferrer"">DecimalField</a> struct to place text fields in my app. However, if I use it alongside an environment object, the app freezes with a memory leak.</p>
<p>This is my model:</p>
<pre><code>class PaymentPlan: ObservableObject {
    @Published var amountBorrowed: Decimal?
}
</code></pre>
<p>This is my content view:</p>
<pre><code>var currencyFormatter: NumberFormatter {
    let nf = NumberFormatter()
    nf.numberStyle = .currency
    nf.isLenient = true
    return nf
}

struct ContentView: View {
    
    @EnvironmentObject var paymentPlan: PaymentPlan
        
    static var currencyFormatter: NumberFormatter {
        let nf = NumberFormatter()
        nf.numberStyle = .currency
        nf.isLenient = true
        return nf
    }
    
    var body: some View {
        DecimalField(&quot;Placeholder&quot;, value: $paymentPlan.amountBorrowed, formatter: Self.currencyFormatter)
    }
}
</code></pre>
<p>This is the custom text field I am using (source):</p>
<pre><code>import SwiftUI
import Combine

struct DecimalField : View {
    let label: LocalizedStringKey
    @Binding var value: Decimal?
    let formatter: NumberFormatter
    let onEditingChanged: (Bool) -&gt; Void
    let onCommit: () -&gt; Void

    // The text shown by the wrapped TextField. This is also the &quot;source of
    // truth&quot; for the `value`.
    @State private var textValue: String = &quot;&quot;

    // When the view loads, `textValue` is not synced with `value`.
    // This flag ensures we don't try to get a `value` out of `textValue`
    // before the view is fully initialized.
    @State private var hasInitialTextValue = false

    init(
        _ label: LocalizedStringKey,
        value: Binding&lt;Decimal?&gt;,
        formatter: NumberFormatter,
        onEditingChanged: @escaping (Bool) -&gt; Void = { _ in },
        onCommit: @escaping () -&gt; Void = {}
    ) {
        self.label = label
        _value = value
        self.formatter = formatter
        self.onEditingChanged = onEditingChanged
        self.onCommit = onCommit
    }

    var body: some View {
        TextField(label, text: $textValue, onEditingChanged: { isInFocus in
            // When the field is in focus we replace the field's contents
            // with a plain unformatted number. When not in focus, the field
            // is treated as a label and shows the formatted value.
            if isInFocus {
                self.textValue = self.value?.description ?? &quot;&quot;
            } else {
                let f = self.formatter
                let newValue = f.number(from: self.textValue)?.decimalValue
                self.textValue = f.string(for: newValue) ?? &quot;&quot;
            }
            self.onEditingChanged(isInFocus)
        }, onCommit: {
            self.onCommit()
        })
            .onReceive(Just(textValue)) {
                guard self.hasInitialTextValue else {
                    // We don't have a usable `textValue` yet -- bail out.
                    return
                }
                // This is the only place we update `value`.
                self.value = self.formatter.number(from: $0)?.decimalValue
        }
        .onAppear(){ // Otherwise textfield is empty when view appears
            self.hasInitialTextValue = true
            // Any `textValue` from this point on is considered valid and
            // should be synced with `value`.
            if let value = self.value {
                // Synchronize `textValue` with `value`; can't be done earlier
                self.textValue = self.formatter.string(from: NSDecimalNumber(decimal: value)) ?? &quot;&quot;
            }
        }
        .keyboardType(.decimalPad)
    }
}
</code></pre>
<p>Any suggestions on what may not be working well? The text field works perfectly with @State.</p>
","1135714","","1135714","","2020-08-07 15:36:20","2020-08-07 15:50:31","Memory leak when using custom text field in SwiftUI","<swift><swiftui>","1","4","","","","CC BY-SA 4.0"
"63309233","1","63309384","","2020-08-07 21:15:44","","2","71","<p>I'm trying to load an image but the image is not loading.</p>
<p>I setup my image loader</p>
<pre><code>class ImageLoader: ObservableObject {
@Published var image: UIImage?
private let url: URL
private var cancellable: AnyCancellable?

init(url: URL) {
    self.url = url
}

 deinit {
       cancellable?.cancel()
   }

   func load() {
       cancellable = URLSession.shared.dataTaskPublisher(for: url)
           .map { UIImage(data: $0.data) }
           .replaceError(with: nil)
           .receive(on: DispatchQueue.main)
           .assign(to: \.image, on: self)
   }
   
   func cancel() {
       cancellable?.cancel()
   }
 }
</code></pre>
<p>and then AsyncImage struct</p>
<pre><code>struct AsyncImage&lt;Placeholder: View&gt;: View {
@ObservedObject private var loader: ImageLoader
private let placeholder: Placeholder?

init(url: URL, placeholder: Placeholder? = nil) {
    loader = ImageLoader(url: url)
    self.placeholder = placeholder
}

var body: some View {
    image
        .onAppear(perform: loader.load)
        .onDisappear(perform: loader.cancel)
}

private var image: some View {
    placeholder
}
}





struct ProductSearhView: View {
 @ObservedObject var model: SearchResultViewModel
var body: some View{
    NavigationView {
         List {
                ForEach(0 ..&lt; Global.productArry.count) { value in
                     CollectionView(model: self.model, data: Global.productArry[value])
                }
                
         }.navigationBarTitle(&quot;CollectionView&quot;)
    }


 }

}



struct CollectionView: View {
 @ObservedObject var model: SearchResultViewModel

let data: Product
    var body: some View {
        VStack {
            HStack {
                 
                Spacer()
                    AsyncImage(url: URL(string: self.data.productImageUrl)!, placeholder: Text(&quot;Loading ...&quot;)
                    ).aspectRatio(contentMode: .fit)
                Spacer()
               
            }
            HStack {
                Spacer()
                Text(self.data.name)
                Spacer()
                
                 }
        }.onAppear(perform:thisVal)
     }

func thisVal (){
    
    print(self.data.productImageUrl)
    // https://i5.walmartimages.com/asr/113d660f-8b57-4ab8-8cfa-a94f11b121aa_1.f6bad4b281983e164dcf0a160571e886.jpeg?odnHeight=180&amp;odnWidth=180&amp;odnBg=ffffff
    
}
}
</code></pre>
<p>Everything else works fine except the image loading. The image only shows the placeholder and not the image.
Sample image url to load is this</p>
<p><a href=""https://i5.walmartimages.com/asr/113d660f-8b57-4ab8-8cfa-a94f11b121aa_1.f6bad4b281983e164dcf0a160571e886.jpeg?odnHeight=180&amp;odnWidth=180&amp;odnBg=ffffff"" rel=""nofollow noreferrer"">https://i5.walmartimages.com/asr/113d660f-8b57-4ab8-8cfa-a94f11b121aa_1.f6bad4b281983e164dcf0a160571e886.jpeg?odnHeight=180&amp;odnWidth=180&amp;odnBg=ffffff</a></p>
<p>What am I doing wrong?</p>
","6283073","","1513086","","2020-08-09 16:03:33","2020-08-09 16:03:33","image is not loading on swiftui collectionview","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"63312902","1","63317429","","2020-08-08 07:35:12","","0","702","<p>If I have a Subject and subscribe it from many places like below, should I use .share()? Or .share() does nothing in this case?</p>
<pre><code>let sampleSubject = CurrentValueSubject&lt;String, Never&gt;(&quot;&quot;)
sampleSubject.sink { print($0) }
sampleSubject.sink { print($0) }
sampleSubject.sink { print($0) }
sampleSubject.sink { print($0) }
  
</code></pre>
<pre><code>let sharedSampleSubject = sampleSubject.share()
sharedSampleSubject.sink { print($0) }
sharedSampleSubject.sink { print($0) }
sharedSampleSubject.sink { print($0) }
sharedSampleSubject.sink { print($0) }
</code></pre>
","12208004","","","","","2021-05-11 17:14:56","How to use .share() with Subject [Swift Combine]","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"63321923","1","63322147","","2020-08-09 02:22:10","","2","975","<p>I have the following SwiftUI view which contains a subview that fades away after five seconds. The fade is triggered by receiving the result of a Combine TimePublisher, but changing the value of <code>showRedView</code> in the <code>sink</code> publisher's sink block is causing a memory leak.</p>
<pre><code>import Combine
import SwiftUI

struct ContentView: View {
    @State var showRedView = true

    @State var subscriptions: Set&lt;AnyCancellable&gt; = []
    
    var body: some View {
        ZStack {
            if showRedView {
                Color.red
                    .transition(.opacity)
            }
            Text(&quot;Hello, world!&quot;)
                .padding()
        }
        .onAppear {
            fadeRedView()
        }
    }
    
    func fadeRedView() {
        Timer.publish(every: 5.0, on: .main, in: .default)
            .autoconnect()
            .prefix(1)
            .sink { _ in
                withAnimation {
                    showRedView = false
                }
            }
            .store(in: &amp;subscriptions)
    }
}
</code></pre>
<p>I thought this was somehow managed behind the scenes with the <code>AnyCancellable</code> collection. I'm relatively new to SwiftUI and Combine, so sure I'm either messing something up here or not thinking about it correctly. What's the best way to avoid this leak?</p>
<p>Edit: Adding some pictures showing the leak.</p>
<p><a href=""https://i.stack.imgur.com/2izeq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2izeq.png"" alt=""Memory leak pic 1"" /></a></p>
<p><a href=""https://i.stack.imgur.com/nWYZB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nWYZB.png"" alt=""Memory leak pic 2"" /></a></p>
","1306952","","1306952","","2020-08-11 04:20:03","2020-08-12 14:50:19","How can I avoid this SwiftUI + Combine Timer Publisher reference cycle / memory leak?","<ios><swiftui><combine><xcode12>","2","3","","","","CC BY-SA 4.0"
"63330229","1","63331266","","2020-08-09 19:03:17","","1","259","<p>I am using a class to store a @Published variable but when I try to pass the value chosen on my custom DatePicker to the @ObservedObject in the class I receive the following error:</p>
<pre><code>TimePicker(time: self.$time.**timeSelected**)
</code></pre>
<blockquote>
<p>Cannot convert value of type 'Binding' (aka
'Binding') to expected argument type 'TimeModel'</p>
</blockquote>
<p>How do I update the @ObservedObject with the picker value?</p>
<p>Full code:</p>
<pre><code>struct ContentView: View {
    
    @ObservedObject var time = TimeModel()

    var body: some View {

        ZStack{
            VStack{
                TimePicker(time: self.$time.timeSelected)
                
                Text(&quot;You chose \(time.timeSelected/60) minutes&quot;)
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

class TimeModel: ObservableObject{
     @Published var timeSelected: TimeInterval = 1.0
}
    

struct TimePicker: UIViewRepresentable {
    
    @ObservedObject var time = TimeModel()
    
    func makeUIView(context: Context) -&gt; UIDatePicker {
        let datePicker = UIDatePicker()
        datePicker.datePickerMode = .countDownTimer
        datePicker.addTarget(context.coordinator,
                             action: #selector(Coordinator.updateTime),
                             for: .valueChanged)
        return datePicker
    }
    
    func updateUIView(_ datePicker: UIDatePicker, context: Context) {
        datePicker.minuteInterval = 5
        datePicker.countDownDuration = time.timeSelected
    }
    
    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject {
        let parent: TimePicker
        
        init(_ parent: TimePicker) {
            self.parent = parent
        }
        
        @objc func updateTime(datePicker: UIDatePicker) {
            parent.time.timeSelected = datePicker.countDownDuration
        }
    }
}
</code></pre>
","12349248","","8697793","","2020-09-19 18:26:58","2020-09-19 18:26:58","Swift UI DatePicker won't update @ObservedObject value","<swift><datepicker><swiftui><combine><observedobject>","1","0","","","","CC BY-SA 4.0"
"63343693","1","63351794","","2020-08-10 15:57:55","","0","316","<p>I'm building a UI where in the view I want to either show an &quot;Enable&quot; button or a green check mark based on whether HealthKit has been authorized or not.  I also want the view to be reactive so that as soon as you authorize HealthKit the view dynamically changes from the button to the check mark, but I can't figure out how to get this two way communication right and which property wrapper to use:</p>
<pre><code>struct SetUpWatchView: View {

    let healthKitAuthManager = HealthKitAuthManager()
@ViewBuilder
    var body: some View {
            VStack(alignment: .leading) {
                HStack {
                     Image(systemName: &quot;heart.circle.fill&quot;)
                     .foregroundColor(.red)
                      .font(.system(size: 56.0, weight: .bold))
                      .frame(width: 65, height: 65)
                    VStack(alignment: .leading) {
                        Text(&quot;Health Integration&quot;)
                            .fontWeight(.bold)
                        Text(&quot;Enable in Order to Track your Speed, Distance, and Heart Rate.&quot;)
                    }
                    Spacer()
                    if healthKitAuthManager.healthKitIsAuthorized {
                        Image(systemName: &quot;checkmark.circle.fill&quot;)
                            .foregroundColor(.green)
                            .font(.system(size: 30.0, weight: .bold))
                             .padding(.horizontal)
                    } else {
                        Button(action: {
                            healthKitAuthManager.authorizeHealthKit()
                        }) {
                            Text(&quot;ENABLE&quot;)
                                .fontWeight(.bold)
                                .foregroundColor(Color.black)
                        }
                        .padding(.horizontal)
                    }
                }
                .padding([.leading, .bottom])
            }.onAppear {
                healthKitAuthManager.checkWhetherHealthKitDatAvailableAndIfAuthorized()
            }
        }
    }
}



class HealthKitAuthManager: ObservableObject {
    
    let healthStore = HKHealthStore()
    
    @Published var healthKitIsAuthorized = false
    
     public func checkWhetherHealthKitDatAvailableAndIfAuthorized()  {
        
        if HKHealthStore.isHealthDataAvailable() {
            
            let authorizationStatus = healthStore.authorizationStatus(for: HKSampleType.workoutType())
            switch authorizationStatus {
            case .sharingAuthorized:
                
                healthKitIsAuthorized = true
                
            case .sharingDenied: ()
             healthKitIsAuthorized = false
            default:()
              healthKitIsAuthorized = false
            }
            
        }
        else {
            healthKitIsAuthorized = false 
        }
    }

    public func authorizeHealthKit() {

        let healthKitTypesToWrite: Set&lt;HKSampleType&gt; = [
            HKObjectType.workoutType(),
            HKSeriesType.workoutRoute(),
            HKObjectType.quantityType(forIdentifier: .activeEnergyBurned)!,
            HKObjectType.quantityType(forIdentifier: .heartRate)!,
            HKObjectType.quantityType(forIdentifier: .restingHeartRate)!,
            HKObjectType.quantityType(forIdentifier: .bodyMass)!,
            HKObjectType.quantityType(forIdentifier: .vo2Max)!,
            HKObjectType.quantityType(forIdentifier: .stepCount)!,
            HKObjectType.quantityType(forIdentifier: .distanceWalkingRunning)!]

        let healthKitTypesToRead: Set&lt;HKObjectType&gt; = [
            HKObjectType.workoutType(),
            HKSeriesType.workoutRoute(),
            HKObjectType.quantityType(forIdentifier: .activeEnergyBurned)!,
            HKObjectType.quantityType(forIdentifier: .heartRate)!,
            HKObjectType.quantityType(forIdentifier: .restingHeartRate)!,
            HKObjectType.characteristicType(forIdentifier: .dateOfBirth)!,
            HKObjectType.quantityType(forIdentifier: .bodyMass)!,
            HKObjectType.quantityType(forIdentifier: .vo2Max)!,
            HKObjectType.quantityType(forIdentifier: .stepCount)!,
            HKObjectType.quantityType(forIdentifier: .distanceWalkingRunning)!]

        let authorizationStatus = HKHealthStore().authorizationStatus(for: HKSampleType.workoutType())

        switch authorizationStatus {

        case .sharingAuthorized:

            print(&quot;Sharing Authorized&quot;)
            healthKitIsAuthorized = true

        case .sharingDenied: print(&quot;sharing denied&quot;)

        //Success does NOT necessarily mean we are authorized, only that the request was successfully delivered.  Also if a user chooses not to authorize, if you call .requestAuthorization again you won't get the action sheet
        HKHealthStore().requestAuthorization(toShare: healthKitTypesToWrite, read: healthKitTypesToRead) { (success, error) in
            if !success {
                print(&quot;failed HealthKit Authorization from iPhone SetUpWatchVC \(String(describing: error?.localizedDescription))&quot;)
            }

            print(&quot;Successful HealthKit Authorization from iPhone&quot;)
            }

        default: print(&quot;not determined&quot;)

        HKHealthStore().requestAuthorization(toShare: healthKitTypesToWrite, read: healthKitTypesToRead) { (success, error) in
            if !success {
                print(&quot;failed HealthKit Authorization from iPhone SetUpWatchVC \(String(describing: error?.localizedDescription))&quot;)
            }

            print(&quot;Successful HealthKit Authorization from iPhone SetUpWatchVC&quot;)

            }

        }



    }

}
</code></pre>
","4625622","","","","","2020-08-11 05:03:58","Using SwiftUI and Combine to conditionally display a view based on authorization status?","<ios><swift><swiftui><healthkit><combine>","1","0","1","","","CC BY-SA 4.0"
"63350301","1","63350405","","2020-08-11 01:41:03","","1","67","<blockquote>
<p>I'm using this API <a href=""http://shibe.online/api/shibes?"" rel=""nofollow noreferrer"">http://shibe.online/api/shibes?</a> although when i load it, all i see is a single link which is what i want to use but there is no variable identifier associated with it.</p>
</blockquote>
<pre><code>[&quot;https://cdn.shibe.online/shibes/be12be31e2c880b4ac6992b3bb02751211b6ee68.jpg&quot;]
</code></pre>
<pre><code>import Foundation
import SwiftUI
import Combine
import SDWebImageSwiftUI

struct ShibeView: View {
    @ObservedObject var fetcher = ShibeFetcher()

    var body: some View {
            AnimatedImage(url: URL(string: self.fetcher.shibe?.url ?? &quot;&quot;)).resizable().scaledToFit()
    }
}

public class ShibeFetcher: ObservableObject {
    @Published var shibe: ShibeRecievers?

    init(){
        load()
    }

    func load() {
        let url = URL(string: &quot;http://shibe.online/api/shibes?&quot;)!

        URLSession.shared.dataTask(with: url) {(data,response,error) in
            do {
                if let d = data {
                    let webData = try JSONDecoder().decode(ShibeRecievers.self, from: d)
                    DispatchQueue.main.async {
                        self.shibe = webData
                    }
                }else {
                    print(&quot;No Data&quot;)
                }
            } catch {
                print (&quot;Error here&quot;)
            }

        }.resume()
    }
}


struct ShibeRecievers: Codable {
    var url: String //Not sure how to store the link from the api
}
</code></pre>
<blockquote>
<p>The problem i have is storing the link from the api into my app and I can't find any json parsing documentation without variable names.</p>
</blockquote>
","12743107","","","","","2020-08-11 03:18:26","Reading single string of json in swift ui","<json><swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"63368098","1","63368236","","2020-08-12 00:24:01","","0","263","<p>When using @EnvironmentObject, can you have an @EnvironmentObject inside of another class?</p>
<p>I have a setup (MeetingStats) class and then a processing class(Meeting).  The processing class and the setup classes are both displayed via different tabs in my app.  So if you can change the settings in setup, you should see in real time the changes to the processing class (that is mostly timer driven).</p>
<p>I have tried to switch from using the AppDelegate to passing things between views, to using @EnvironmentObject.  I have changed my ScceneDelegate to create the initial objects, and am passing them .envrionmentObjects to the ContentView.  However, when I run the app, the first time I try to access the setup class in the processing class, I crash with the message No ObservableObject of type MeetingStats found. A View.environmentObject(_:) for MeetingStats may be missing as an ancestor of this view.</p>
<p>SceneDelegate</p>
<pre><code>class SceneDelegate: UIResponder, UIWindowSceneDelegate {
    var meetingStats = MeetingStats()
    var meeting = Meeting()
    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)
    {
        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            // passing EnvironmentObjects 
            window.rootViewController = UIHostingController(rootView:
                                                                ContentView()
                                                                .environmentObject(meeting)
                                                                .environmentObject(meetingStats)
                                                             )
            self.window = window
            window.makeKeyAndVisible()
        }
    }
}
</code></pre>
<p>Content View is a set of tabs, one for meeting, one for setup and one for statistics</p>
<p>meeting.swift - grossly simplified to show the problem area</p>
<pre><code>//
//  meeting.swift
import Foundation
import SwiftUI
import Combine
import Intents
import os
class Meeting: ObservableObject {
    @EnvironmentObject var meetingStats: MeetingStats
    @objc func calcQuorumEvents() {
   // LOTS of calcualtions     
        self.meetingStats.totalWasteAmount = totalWasteAmount. // HERE's the Crash
        self.meetingStats.totalWasteAmountPersonal = totalWasteAmountPersonal
        self.meetingStats.totalLifetimeWasteAmount = totalLifetimeWasteAmount
    }
  }
</code></pre>
<p>Is the issue I am not passing explicitly passing the values to the tabs from the contentView? I have tried explicitly passing the Environment object to the meetingView but still receive the same error:</p>
<pre><code>iOSMeetingView()
                .environmentObject(meeting)
                .environmentObject(meetingStats)
                .tabItem {
                    Image(&quot;presentation&quot;)
                    Text(&quot;Meeting&quot;)
            }.tag(1)
</code></pre>
<p>I didn't think that was required as Swift was to look in the object hierarchy to find the object.</p>
","373749","","","","","2020-08-13 00:19:08","How to correctly handle @EnvironmentObject within secondary Class","<swift><environment><ios14>","1","0","1","","","CC BY-SA 4.0"
"63406177","1","63406303","","2020-08-14 03:41:09","","1","1167","<p>I want to make a picker use SwiftUI, when I change the value in ChildView, it will not change and called ChildView init.</p>
<pre><code>class ViewModel: ObservableObject {
    @Published var value: Int
    
    init(v: Int) {
        self.value = v
    }
}

struct ChildView: View {
    @Binding var value: Int
    @ObservedObject var vm = ViewModel(v: 0)
    
    init(value: Binding&lt;Int&gt;) {
        self._value = value
        print(&quot;ChildView init&quot;)
    }
    
    var body: some View {
        VStack {
            Text(&quot;param value: \(value)&quot;)
            Text(&quot;@ObservedObject bar: \(vm.value)&quot;)
            Button(&quot;(child) bar.value++&quot;) {
                self.vm.value += 1
            }
        }
        .onReceive(vm.$value) { value = $0 }
    }
}

struct ContentView: View {
    @State var value = 0
    
    var body: some View {
        VStack {
            Text(&quot;(parent) \(self.value)&quot;)
            ChildView(value: $value)
        }
    }
}
</code></pre>
<p>But when I remove <code>Text(&quot;(parent) \(self.value)&quot;)</code> in ContentView, it seems to be normal.</p>
","12666655","","","","","2020-08-14 03:56:59","SwiftUI @Binding value can not change and called init","<swift><swiftui><combine><publisher>","2","0","","","","CC BY-SA 4.0"
"63412373","1","63414811","","2020-08-14 11:59:54","","1","272","<p>My API returns this format, where <code>data</code> can contain all kinds of responses.</p>
<pre><code>{
    status: // http status
    error?: // error handle
    data?:  // your response data
    meta?:  // meta data, eg. pagination
    debug?: // debuging infos
}
</code></pre>
<p>I have made a <code>Codable</code> Response type with a generic for the optional data, of which we do not know the type.</p>
<pre><code>struct MyResponse&lt;T: Codable&gt;: Codable {
    let status: Int
    let error: String?
    let data:  T?
    let meta: Paging?
    let debug: String?
}
</code></pre>
<p>I am now trying to write API convenience methods <strong>as concisely as possible</strong>. So I have a function to return a generic publisher that I can use for all these responses, i.e. one that pre-parses the response and catches any errors upfront.</p>
<p>First, I get a <code>dataTaskPublisher</code> that processes the parameter inputs, if any. <code>Endpoint</code> is just a convenience <code>String</code> <code>enum</code> for my endpoints, <code>Method</code> is similar. <code>MyRequest</code> returns a <code>URLRequest</code> with some necessary headers etc.</p>
<p>Notice the way I define the parameters: <code>params: [String:T]</code>. This is standard JSON so it could be strings, numbers etc.<br />
<strong>It seems this <code>T</code> is the problem somehow.</strong>.</p>
<pre><code>static fileprivate func publisher&lt;T: Encodable&gt;(
        _ path: Endpoint,
        method: Method,
        params: [String:T] = [:]) throws
        -&gt; URLSession.DataTaskPublisher
    {
        let url = API.baseURL.appendingPathComponent(path.rawValue)
        var request = API.MyRequest(url: url)
        if method == .POST &amp;&amp; params.count &gt; 0 {
            request.httpMethod = method.rawValue
            do {
                let data = try JSONEncoder().encode(params)
                request.httpBody = data
                return URLSession.shared.dataTaskPublisher(for: request)
            }
            catch let err {
                throw MyError.encoding(description: String(describing: err))
            }
        }
        return URLSession.shared.dataTaskPublisher(for: request)
    }
</code></pre>
<p>Next, I am parsing the response.</p>
<pre><code>static func myPublisher&lt;T: Encodable, R: Decodable&gt;(
        _ path: Endpoint,
        method: Method = .GET,
        params: [String:T] = [:])
        -&gt; AnyPublisher&lt;MyResponse&lt;R&gt;, MyError&gt;
    {
        do {
                
            return try publisher(path, method: method, params: params)
            .map(\.data)
            .mapError { MyError.network(description: &quot;\($0)&quot;)}
            .decode(type: MyResponse&lt;R&gt;.self, decoder: self.agent.decoder)
            .mapError { MyError.encoding(description: &quot;\($0)&quot;)}             //(2)
            .tryMap {
                if $0.status &gt; 204 {
                    throw MyError.network(description: &quot;\($0.status): \($0.error!)&quot;)
                }
                else {
                    return $0 // returns a MyResponse
                }
            }
            .mapError { $0 as! MyError }
                                                                            //(1)
            .eraseToAnyPublisher()
        }
        catch let err {
            return Fail&lt;MyResponse&lt;R&gt;,MyError&gt;(error: err as? MyError ??
                MyError.undefined(description: &quot;\(err)&quot;))
            .eraseToAnyPublisher()
        }
    }
</code></pre>
<p>Now I can write an endpoint method easily. Here are two examples.</p>
<pre><code>static func documents() -&gt; AnyPublisher&lt;[Document], MyError&gt; {
    return myPublisher(.documents)
        .map(\.data!)
        .mapError { MyError.network(description: $0.errorDescription) }
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher() as AnyPublisher&lt;[Document], MyError&gt;
}
</code></pre>
<p>and</p>
<pre><code>static func user() -&gt; AnyPublisher&lt;User, MyError&gt; {
    return myPublisher(.user)
        .map(\.data!)
        .mapError { MyError.network(description: $0.errorDescription) }
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher() as AnyPublisher&lt;User, MyError&gt;
}
</code></pre>
<p>All this is working well. Please note that each time, I have to specify my exact return type twice. I think I can live with that.</p>
<p>I should be able to simplify this so that I do not have to repeat the same three operators (map, mapError, receive) in exactly the same way each time.</p>
<p>But when I insert <code>.map(\.data!)</code> at the location <code>//(1)</code> above I get the error <code>Generic parameter T could not be inferred.</code> at the location <code>//(2)</code>.</p>
<p>This is really confusing. Why does the generic type in the <strong>input</strong> parameters play any role here? This must be related to the call to the <code>.decode</code> operator just above, where the generic in question is called <code>R</code>, not <code>T</code>.</p>
<p>Can you explain this? How can I refactor these operators upstream?</p>
","427083","","427083","","2020-08-14 12:10:18","2020-08-14 14:54:37","Swift Combine: Cannot refactor repetitive code","<swift><dictionary><generics><combine>","1","9","","","","CC BY-SA 4.0"
"63426017","1","63426179","","2020-08-15 12:26:14","","3","299","<p>I have a Game-object that may hold an image. Whenever an image URL is found for a game a new instance of GameImage-object should be created. It will then fetch the image and populate the UIImage property. When this happens the UI should be updated presenting the image.</p>
<pre><code>class Game: ObservableObject {
    @Published var image: GameImage?
} 

class GameImage: ObservableObject {
    let url: URL
    @Published var image: UIImage?
    
    private var cancellable: AnyCancellable?
    
    init(url: URL) {
        self.url = url
    }
    
    func fetch() {
        self.cancellable = URLSession.shared.dataTaskPublisher(for: self.url)
            .map { UIImage(data: $0.data) }
            .replaceError(with: nil)
            .receive(on: DispatchQueue.main)
            .sink(receiveValue: { [weak self] (image) in
                guard let self = self else { return }
                self.image = image
                print(self.url)
                print(self.image)
            })
    }
    
    func cancel() {
        cancellable?.cancel()
    }
    
    deinit {
        cancel()
    }
}

struct ContentView: View {
    
    @StateObject var game = Game()

    var body: some View {
        VStack {
            if let image = game.image?.image {
                Image(uiImage: image)
            } else {
                Text(&quot;No image.&quot;)
            }
        }
        .onAppear(perform: {
            guard let gameImageURL = URL(string: &quot;https://cf.geekdo-images.com/itemrep/img/oVEpcbtyWkJjIjk1peTJo6hI1yk=/fit-in/246x300/pic4884996.jpg&quot;) else { return }
            game.image = GameImage(url: gameImageURL)
            game.image!.fetch()
        })
    }
}
</code></pre>
<p>The problem is. After fetch is done the debug console will show that image contains an UIImage. However the UI does not update to show the image. What am I missing here?</p>
","174655","","174655","","2020-08-15 12:34:58","2020-08-15 12:43:57","How to chain ObservableObject?","<asynchronous><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"63434788","1","63434829","","2020-08-16 08:32:23","","3","99","<p>i have made an app in SwiftUI where you can create different classes. The app saves this in an array. I have a textfield and a button in the same view as the scrollview that displays the array. This works perfectly fine and I can easily add new classes. Now I made a new view with a text field and a button. This view can be viewed by pressing a button in the nav bar. It uses the exact same function as the other view, but in the other view adding a item to the array works, in this view it doesn't work. I hope you understand my problem and can help me.
Thank You.</p>
<p>This is the file where I store the array:</p>
<pre><code>import Foundation
import SwiftUI
import Combine

struct Class: Identifiable {
    var name: String
    var id = UUID()
}

class ClassStore: ObservableObject {
    @Published var classes = [Class]()
}
</code></pre>
<p>This is the view with the button + textfield that works and the scrollview that displays the array:</p>
<pre><code>import SwiftUI

struct ContentView: View {
    @State var showNewClass = false
    @ObservedObject var classStore = ClassStore()
    @State var newClass: String = &quot;&quot;
    @State var toDoColor: Color = Color.pink
    
    func addNewClass() {
        classStore.classes.append(
            Class(name: newClass)
        )
        newClass = &quot;&quot;
    }
    
    
    var body: some View {
        NavigationView {
            VStack {
                HStack {
                    TextField(&quot;New Todo&quot;, text: $newClass)
                    Image(systemName: &quot;app.fill&quot;)
                        .foregroundColor(Color.pink)
                        .padding(.horizontal, 3)
                    Image(systemName: &quot;books.vertical&quot;)
                        .padding(.horizontal, 3)
                    if newClass == &quot;&quot; {
                        Text(&quot;Add!&quot;)
                            .foregroundColor(Color.gray)
                    } else {
                        Button(action: {
                            addNewClass()
                        }) {
                            Text(&quot;Add!&quot;)
                        }
                    }
                }.padding()
                ScrollView {
                    ForEach(self.classStore.classes) { name in
                        Text(name.name)
                    }
                }
                .navigationBarTitle(Text(&quot;Schulnoten&quot;))
                .navigationBarItems(trailing:
                Button(action: {
                    self.showNewClass.toggle()
                }) {
                    Text(&quot;New Class&quot;)
                }
                .sheet(isPresented: $showNewClass) {
                    NewClass(isPresented: $showNewClass)
                })
            }
        }
    }
}
</code></pre>
<p>And this is the new view I created, the button and the textfield have the exact same code, but somehow this doesn't work:</p>
<pre><code>import SwiftUI

struct NewClass: View {
    @Binding var isPresented: Bool
    @State var className: String = &quot;&quot;
    @ObservedObject var classStore = ClassStore()
    
    func addNewClass() {
        classStore.classes.append(
            Class(name: className)
        )
    }
    
    var body: some View {
        VStack {
            HStack {
                Text(&quot;New Class&quot;)
                    .font(.title)
                    .fontWeight(.semibold)
                Spacer()
            }
            TextField(&quot;Name of the class&quot;, text: $className)
                .padding()
                .background(Color.gray)
                .cornerRadius(5)
                .padding(.vertical)
            Button(action: {
                addNewClass()
                self.isPresented.toggle()
            }) {
                HStack {
                    Text(&quot;Safe&quot;)
                        .foregroundColor(Color.white)
                        .fontWeight(.bold)
                        .font(.system(size: 20))
                }
                .padding()
                .frame(width: 380, height: 60)
                .background(Color.blue)
                .cornerRadius(5)
            }
            Spacer()
        }.padding()
    }
}
</code></pre>
<p>Sorry if my English is not that good. I'm not a native speaker.</p>
","13696452","","","","","2020-08-16 08:38:20","Cannot add something to an Array","<ios><swift><xcode><swiftui>","1","0","","","","CC BY-SA 4.0"
"63448377","1","63492773","","2020-08-17 09:46:30","","4","2125","<p>I have a following class:</p>
<pre><code>struct PriceFormatter {
    @AppStorage(UserDefaultsKey.savedCurrency)
    var savedCurrency: String?

    let price: Float
    
    init(price: Float) {
        self.price = price
    }
    
    var formatted: String {
        return &quot;\(savedCurrency) \(price)&quot;
    }
}
</code></pre>
<p>And the following view:</p>
<pre><code>struct PriceText: View {
    let price: Float
    
    var body: some View {
        Text(PriceFormatter(price: self.price).formatted)
    }
}
</code></pre>
<p>I want the view to get rerendered after <code>savedCurrency</code> from <code>UserDefaults</code> changes.</p>
<p>I made it work easily, when <code>@AppStorage</code> was  a part of the view, but I'm not sure what to do in this case. I tried to use <code>@ObservableObject</code> with <code>@Published</code> or tried to make a Combine <code>Publisher</code> and subscribe to it but also had no success.</p>
","6898849","","","","","2022-05-26 21:52:42","How to update SwiftUI view after @AppStorage in a separate struct gets updated","<swift><swiftui><combine>","1","11","1","","","CC BY-SA 4.0"
"63449209","1","63449516","","2020-08-17 10:40:40","","0","648","<p>Given this publisher where i handle response with body. Than I can decode to a User struct. It works well.</p>
<pre><code>// Wrapped Request, return with an URLRequest object with POST method
let request = RequestWithModel(networkMethod: .post, path: PathBuilder().user().build(), model: User(userId: 1, title: &quot;fokora&quot;, body: &quot;baroka&quot;)).urlRequest()

let addUser : AnyPublisher&lt;User, Error&gt; = URLSession.shared.dataTaskPublisher(for: request)
.map{ $0.data }
.decode(type: User.self, decoder: JSONDecoder())
.receive(on: DispatchQueue.main)
.eraseToAnyPublisher()
</code></pre>
<p>How can I handle response when it comes empty json body, but I want to know about its success (status code is 200)? What kind of publisher do I need to use?</p>
<pre><code>// Wrapped Request, return with an URLRequest object with DELETE method
let request = RequestWithoutModel(networkMethod: .delete, path: PathBuilder().user().id(id: &quot;1&quot;).build()).urlRequest()
let deleteUser : AnyPublisher&lt;... no need this ..., Error&gt; = URLSession.shared.dataTaskPublisher(for: request)
.map{ $0.data }
.decode(type: ... no need this ..., decoder: JSONDecoder()) // no need to decode anything at all
.receive(on: DispatchQueue.main)
.eraseToAnyPublisher()
</code></pre>
<p>Thank you in advance for any help you can provide.</p>
","2645599","","","","","2020-08-17 10:59:33","How could I handle empty json body with Combine (AnyPublisher)?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"63454753","1","63465939","","2020-08-17 16:17:34","","0","1248","<p>My API usually returns a certain format in JSON (simplified notation):</p>
<pre><code>{
   status: // http status
   error?: // error handle
   data?:  // the response data
   ...
}
</code></pre>
<p>In my Combine operators, I take the <code>data</code> from a URLSession <code>dataTaskPublisher</code> and parse the response into a <code>Decodable</code> object that reflects the above schema. That works great.</p>
<p>However, I have an endpoint that returns the HTTP status code <code>201</code> (operation successful), and has <strong>no data</strong> at all. How would I chain this with my operators <strong>without throwing an error</strong>?</p>
<p>This is what I have:</p>
<pre><code>publisher
.map { (data, response) in
    guard data.count &gt; 0 else {
       let status = (response as! HTTPURLResponse).statusCode
       return Data(&quot;{\&quot;status\&quot;: \(status), \&quot;data\&quot;: \&quot;\&quot;}&quot;.utf8)
    }
    return data
}
.mapError { CustomError.network(description: &quot;\($0)&quot;)}
.decode(type: MyResponse&lt;R&gt;.self, decoder: self.agent.decoder)
.mapError { err -&gt; CustomError in CustomError.decoding(description: &quot;\(err)&quot;) }
...
</code></pre>
<p>As you can see, I simply construct an appropriate response, where the response's &quot;data&quot; is an empty string. However, this is ugly and a bit hacky, and I do not see the reason, why the pipeline should continue with parsing, etc, when I already have all I need. How can I interrupt it and finish the pipeline successfully for its final subscriber?</p>
","427083","","427083","","2020-08-18 11:02:33","2020-08-18 11:02:33","Swift Combine: handle no data before decode without an error","<swift><operator-keyword><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"63456569","1","63466274","","2020-08-17 18:22:27","","0","734","<p>I have a publisher wrapper struct where I can handle response status code. If the status code is not range in 200..300 it return with an object, otherwise it throws an Error. It works well.</p>
<pre><code>public func anyPublisher&lt;T:Decodable&gt;(type: T.Type) -&gt; AnyPublisher&lt;T, Error&gt; {
    return URLSession.shared.dataTaskPublisher(for: urlRequest)
        .tryMap { output in
            guard let httpResponse = output.response as? HTTPURLResponse, 200..&lt;300 ~= httpResponse.statusCode else {
                throw APIError.unknown
            }
            return output.data
    }
    .decode(type: T.self, decoder: JSONDecoder())
    .receive(on: DispatchQueue.main)
    .eraseToAnyPublisher()
}
</code></pre>
<p>Using:</p>
<pre><code>let sendNewUserPublisher = NetworkPublisher(urlRequest: request).anyPublisher(type: User.self)

cancellationToken = sendNewUserPublisher.sink(receiveCompletion: { completion in
    if case let .failure(error) = completion {
        NSLog(&quot;error: \(error.localizedDescription)&quot;)
    }
}, receiveValue: { post in
    self.post = post
})
</code></pre>
<p>As above, I would like to handle the error even if the response data does not contain an object to be decoded.</p>
<pre><code>public func anyPublisher() -&gt; AnyPublisher&lt;URLSession.DataTaskPublisher.Output, URLSession.DataTaskPublisher.Failure&gt; {
    return URLSession.shared.dataTaskPublisher(for: urlRequest)
        // I'd like to handle status code here, and throw an error, if needed
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
}
</code></pre>
<p>Thank you in advance for any help you can provide.</p>
","2645599","","968155","","2020-08-17 19:01:59","2020-08-18 10:00:27","How could I throw an Error when response data does not contain an object to decode with Combine?","<swift><combine><throw>","1","4","","","","CC BY-SA 4.0"
"63457868","1","63458602","","2020-08-17 20:03:19","","0","440","<p>I'm trying to implement MVVM in my SwiftUI app in a way that decouples the view from the view model itself. In my research I came across this article outlining one strategy: <a href=""https://quickbirdstudios.com/blog/swiftui-architecture-redux-mvvm/"" rel=""nofollow noreferrer"">https://quickbirdstudios.com/blog/swiftui-architecture-redux-mvvm/</a></p>
<p>Here's a summary of how it works:</p>
<pre><code>// ViewModel.swift

protocol ViewModel: ObservableObject where ObjectWillChangePublisher.Output == Void {
    associatedtype State
    associatedtype Event

    var state: State { get }
    func trigger(_ event: Event)
}
</code></pre>
<pre><code>// AnyViewModel.swift

final class AnyViewModel&lt;State, Event&gt;: ObservableObject {
    private let wrappedObjectWillChange: () -&gt; AnyPublisher&lt;Void, Never&gt;
    private let wrappedState: () -&gt; State
    private let wrappedTrigger: (Event) -&gt; Void

    var objectWillChange: some Publisher {
        wrappedObjectWillChange()
    }

    var state: State {
        wrappedState()
    }

    func trigger(_ input: Event) {
        wrappedTrigger(input)
    }

    init&lt;V: ViewModel&gt;(_ viewModel: V) where V.State == State, V.Event == Event {
        self.wrappedObjectWillChange = { viewModel.objectWillChange.eraseToAnyPublisher() }
        self.wrappedState = { viewModel.state }
        self.wrappedTrigger = viewModel.trigger
    }
}
</code></pre>
<pre><code>// MyView.swift

extension MyView {
    enum Event {
        case onAppear
    }

    enum ViewState {
        case loading
        case details(Details)
    }

    struct Details {
        let title: String
        let detail: String
    }
}

struct MyView: View {
    @ObservedObject var viewModel: AnyViewModel&lt;ViewState, Event&gt;

    var body: some View { ... }
}
</code></pre>
<pre><code>// ConcreteViewModel.swift

class ConcreteViewModel: ViewModel {
    @Published var state: MyView.ViewState = .loading

    func trigger(_ event: MyView.Event) {
        ...
        state = .details(...) // This gets called by my app and the state is updated.
        ...
    }
}
</code></pre>
<pre><code>// Constructing MyView

let view = MyView(viewModel: AnyViewModel(ConcreteViewModel))
</code></pre>
<p>This succeeds in separating the view from the view model (using AnyViewModel as a wrapper), but the issue is updates to the <code>state</code> property in <code>ConcreteViewModel</code> are not reflected in <code>MyView</code>.</p>
<p>My suspicion is that the problem lies in <code>AnyViewModel</code> and the <code>wrappedObjectWillChange</code> closure, but I am having difficulty debugging it. Do I need to do something with the <code>objectWillChange</code> publisher explicitly, or should <code>@Published</code> handle it automatically?</p>
<p>Any help is much appreciated.</p>
","797767","","","","","2020-08-17 21:01:54","SwiftUI MVVM AnyViewModel not propagating state changes","<ios><swift><mvvm><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63460286","1","63460456","","2020-08-18 00:32:56","","0","250","<p>I've created a property wrapper that I want to insert some logic into and the &quot;set&quot; value is doing the right thing, but the textfield isn't updating with all uppercase text. Shouldn't the text field be showing all uppercase text or am I misunderstanding how this is working?</p>
<p>Also this is a contrived example, my end goal is to insert a lot more logic into a property wrapper, I'm just using the uppercase example to get it working. I've searched all over the internet and haven't found a working solution.</p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    @StateObject var vm = FormDataViewModel()

    var body: some View {
        Form {
            TextField(&quot;Name&quot;, text: $vm.name)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

class FormDataViewModel: ObservableObject {
    @Capitalized var name: String = &quot;&quot;
}

@propertyWrapper
public class Capitalized {
    @Published var value: String

    public var wrappedValue: String {
        get { value }
        set { value = newValue.uppercased() } //Printing this shows all caps
    }

    public var projectedValue: AnyPublisher&lt;String, Never&gt; {
        return $value
            .eraseToAnyPublisher()
    }

    public init(wrappedValue: String) {
        value = wrappedValue
    }
}
</code></pre>
","4984384","","","","","2020-08-18 03:55:36","Custom property wrapper not accurately reflecting the state of my TextField in SwiftUI, any idea why?","<ios><swiftui><combine><property-wrapper>","2","0","","","","CC BY-SA 4.0"
"63470324","1","63473375","","2020-08-18 14:01:58","","2","4154","<p>In the example below, I’m making a network request to load different movie genres, then using that to load all the movies. The sink only returns the movie results. How could I receive both the genres and movies?</p>
<pre><code>struct Genre: Codable, Identifiable{
    let id: Int
    let name: String
    var movies: [Movie]?
}

struct Movie: Codable, Hashable, Identifiable {
    let title: String
    let id: Int
    let posterPath: String?
    let backdropPath : String?
    var tagline: String?
}

loadGenres() is AnyPublisher&lt;[Genre], Error&gt; 
fetchMoviesIn() is AnyPublisher&lt;[Movie], Error&gt;

class GenresViewModel: ObservableObject{
    @Published var genres = [Genre]()
    @Published var movies = [Movie]()
    var requests = Set&lt;AnyCancellable&gt;()
    
    init(){
        NetworkManager.shared.loadGenres()
            .flatMap{ genres in
                genres.publisher.flatMap{ genre in
                    NetworkManager.shared.fetchMoviesIn(genre)
                }
            }
            .collect()
            .retry(1)
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { completion in
                switch completion{
                case .finished:
                    print(&quot;Finished loading all movies in every genre&quot;)
                case .failure(let error):
                    print(&quot;Error: \(error)&quot;)
                }
            }, receiveValue: { [self] values in
                let allMovies = values.joined()
                self.movies = allMovies.map{$0}
            })
            .store(in: &amp;self.requests)
    }
}
</code></pre>
","10830089","","10830089","","2020-08-18 19:07:10","2020-08-19 09:49:36","Chaining swift combine publishers and receiving each result","<swift><combine>","1","4","3","","","CC BY-SA 4.0"
"63479425","1","63479523","","2020-08-19 03:05:55","","3","1494","<p>I am trying to get one object to listen to changes in the property of another object. I have it working as shown below, but I would prefer the observing object knew nothing of the Model, just the property.</p>
<pre><code>class Model : ObservableObject{
    @Published var items: [Int] = []
}

class ObjectUsingItems{
    var itemObserver: AnyCancellable?
    var items: [Int] = []
    
    func observeItems(model: Model){
        itemObserver = model.$items
            .sink{ newItems in
                self.items = newItems
                print(&quot;New Items&quot;)
        }
    }
}
</code></pre>
<p>At the moment I begin observing the model.items as follows - which works:</p>
<pre><code>let model = Model()
let itemUser = ObjectUsingItems()
        
itemUser.observeItems(model: model)
model.items.append(1) // itemUser sees changes
</code></pre>
<p>Unfortunately I can’t seem to figure out just what is required as the parameter to the observeItems method so that it works without knowing anything about the Model - like this:</p>
<pre><code>class ObjectUsingItems{
    var itemObserver: AnyCancellable?
    var items: [Int] = []
    
    func observeItems(propertyToObserve: WhatGoesHere?){
        itemObserver = propertyToObserve
            .sink{ newItems in
                // etc.
        }
    }
}
</code></pre>
<p>And then call it like so:</p>
<pre><code>itemUser.observeItems(XXX: model.$items)
</code></pre>
<p>Can anyone explain what I need to do? Thanks!</p>
","2234184","","","","","2020-08-19 03:21:48","Observing a @Published var from another Object","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"63502794","1","63502951","","2020-08-20 10:06:55","","2","956","<p>I have a UIViewController that is presenting a via a function in my <code>viewDidLoad</code>:</p>
<pre><code>let imageView: UIImageView = {
    let iv = UIImageView()
    iv.contentMode = .scaleAspectFit
    return iv
    }()

func configureViewComponents() {
    
    view.addSubview(imageView)
</code></pre>
<p>Call it as such:</p>
<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    configureViewComponents()
}
</code></pre>
<p>I have a form in a separate file form.swift:</p>
<pre><code>import Combine
import SwiftUI

struct myForm: View {

@ObservedObject var submission = Submission()

@State var confirmationMessage = &quot;&quot;
@State var showingConfirmation = false


var body: some View {
    NavigationView {
        Form {
            Toggle(isOn: $submission.fieldOne ) {
                Text(&quot;Field One&quot;)
            }
</code></pre>
<p>I am trying to add it to my UIViewController in the same fashion I add my imageView with <code>view.addSubview(myForm)</code> but I am getting the message <code>cannot convert value of type form to expected argument type UIView.</code></p>
<p>How can I present my form in this UIViewController?</p>
","10913684","","","","","2020-08-20 10:16:49","How to add SwiftUI form to UIView Controller","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"63511459","1","63527650","","2020-08-20 18:48:59","","2","5996","<p>I have an HTTP request publisher that when a 401 error is returned, I want to stop execution and display my sign in screen.</p>
<p>Here's part of my code:</p>
<pre><code>cancellable = fetcher.hello(helloRequest: HelloRequest(name: self.name))
            .print(&quot;fetcher.hello&quot;)
            .catch { _ in
                // TODO: how to handle errors with request?
                Just(HelloResponse.placeHolder)
            }
            .flatMap { response -&gt; AnyPublisher&lt;HelloResponse, Never&gt; in
                if response.imageUrl == nil || response.imageUrl == &quot;&quot; {
                    // If there's no image to download just return the response
                    return Just(response).eraseToAnyPublisher()
                }
                else {
                    // Chain together request and download image
                    return fetcher.downloadImage(url: response.imageUrl!)
                        .print(&quot;fetcher.hello.downloadImage&quot;)
                        .catch { _ in
                            // If there was an error downloading the image, replace it with a placeholder
                            Just(UIImage(named: &quot;placeholder_square&quot;)!)
                        }
                        .map {
                            // Add image to response
                            HelloResponse(message: response.message, visitCount: response.visitCount, imageUrl: response.imageUrl, image: $0)
                        }
                        .eraseToAnyPublisher()
                }
            }
            .sink(receiveCompletion: { _ in }, receiveValue: { self.response = $0.self })
</code></pre>
<p>So part of the problem is the following flatMap that will download an image if necessary. The output type is AnyPublisher&lt;HelloResponse, Never&gt; (I couldn't think of another way to do that). Right now the catch returns a placeholder model and worked fine. But now I've swallowed the error. I thought maybe Empty() publisher would work but it didn't seem right. I tried Fail() but apparently catch is a Never (makes sense). Thanks!</p>
","510199","","510199","","2020-08-21 17:42:36","2020-08-21 17:42:36","Swift Combine - How to throw an error and stop execution","<swift><combine>","1","7","","","","CC BY-SA 4.0"
"63530803","1","63532359","","2020-08-21 22:28:50","","1","879","<p>For my app, I have a welcome screen that intro's what the app does and allows the user to create their first item. When the user clicks the button I'd like to dismiss the 'welcomeScreen' sheet and and then launch the 'newRemindr' sheet.</p>
<p>I tried to achieve this by creating an observable object with an 'addNewTrigger' boolean set to false. When I click the Add New Reminder button on the welcomeScreen, the button's action causes the welcomeScreen to dismiss and toggles the 'addNewTrigger' boolean to True. (I've verified this is working with Print Statements). However content view is listening to that same observed object to launch the 'newRemindr' sheet but that action doesn't seem to be working.</p>
<p>Can somebody please take a look at the code and see where I am going wrong? Or suggest an alternative that can provide the type of functionality.</p>
<p>I really appreciate all the help. Thanks!</p>
<p>Code Below...</p>
<p><strong>welcomeScreen:</strong></p>
<pre><code>import SwiftUI
import Combine

struct welcomeScreen: View {
@Environment(\.presentationMode) var mode: Binding&lt;PresentationMode&gt;

@ObservedObject var addNewReminder = showAddScreen()

var body: some View {
    NavigationView {
        ZStack (alignment: .center) {

            LinearGradient(gradient: Gradient(colors: [Color.white, Color.white, Color.gray]), startPoint: .top, endPoint: .bottom)
                .edgesIgnoringSafeArea(.all)

            Image(&quot;Ellipse2&quot;)
                .offset(y: -475)

            VStack {
                Spacer()
                Text(&quot;Welcome to&quot;)
                    .foregroundColor(.white)
                    .fontWeight(.bold)
                Image(&quot;RemindrLogoWhite&quot;)
                Spacer()
                Text(&quot;What is remindr?&quot;)
                    .font(.title)
                    .fontWeight(.bold)
                    .padding(.bottom, 25)
                Text(&quot;Remindr is a simple app designed to help you schedule random reminders with the goal of clearing your mind.\n\nRemind yourself to check in with your body, set up positive affirmations, set your intentions; Whatever it is, the power is up to you.&quot;)
                    .padding(.horizontal, 25)
                    .padding(.bottom, 25)
                Text(&quot;Click below to get started:&quot;)
                    .fontWeight(.bold)

                // Add New Reminder Button
                Button(action: {
                    self.mode.wrappedValue.dismiss()
                    print(&quot;Add Reminder Button from Welcome Screen is Tapped&quot;)
                    self.addNewReminder.addNewTrigger.toggle()
                    print(&quot;var addNewTrigger has been changed to \(self.addNewReminder.addNewTrigger)&quot;)
                }) {
                    Image(&quot;addButton&quot;)
                        .renderingMode(.original)
                }.padding(.bottom, 25)

                Spacer()

            } .frame(maxWidth: UIScreen.main.bounds.width,
                     maxHeight: UIScreen.main.bounds.height)
        }
        .navigationBarTitle(Text(&quot;&quot;), displayMode: .automatic)
        .navigationBarItems(trailing: Button(action: {
            self.mode.wrappedValue.dismiss()

        }, label: {
            Image(systemName: &quot;xmark&quot;)
                .foregroundColor(.white)
        }))
    }
  }
}
</code></pre>
<p><strong>ContentView:</strong></p>
<pre><code>import SwiftUI
import CoreData

class showAddScreen: ObservableObject {
@Published var addNewTrigger = false
}

struct ContentView: View {


@Environment(\.managedObjectContext) var moc
@FetchRequest(entity: ReminderEntity.entity(), sortDescriptors: [NSSortDescriptor(keyPath: \ReminderEntity.dateCreated, ascending: false)])
var reminder: FetchedResults&lt;ReminderEntity&gt;

// Sheet Control
@ObservedObject var addNewReminder = showAddScreen()
//@State private var showingAddScreen = false
@State var showWelcomeScreen = false
    
let emojiList = EmojiList()

//Toggle Control
@State var notifyOn = true

// Save Items Function
func saveItems() {
    do {
        try moc.save()
    } catch {
        print(error)
    }
}

// Delete Item Function
func deleteItem(indexSet: IndexSet) {
    let source = indexSet.first!
    let listItem = reminder[source]
    moc.delete(listItem)
}

// View Controller
var body: some View {
    VStack {
        NavigationView {
            ZStack (alignment: .top) {
                
                // List View
                List {
                    ForEach(reminder, id: \.self) { notification in
                        NavigationLink(destination: editRemindr(reminder: notification,
                                                                notifyOn: notification.notifyOn,
                                                                emojiChoice: Int(notification.emojiChoice),
                                                                notification: notification.notification ?? &quot;unknown&quot;,
                                                                notes: notification.notes ?? &quot;unknown&quot;)) {
                            // Text within List View
                            HStack {
                                // MARK: TODO
                                //Toggle(&quot;NotifyOn&quot;, isOn: self.$notifyOn)
                                //    .labelsHidden() // Hides the label/title
                                Text(&quot;\(self.emojiList.emojis[Int(notification.emojiChoice)]) \(notification.notification!)&quot;)
                            } 
                        }
                    } 
                    .onDelete(perform: deleteItem)
                    }.lineLimit(1)
                    
                    // Navigation Items
                    .navigationBarTitle(&quot;&quot;, displayMode: .inline)
                    .navigationBarItems(
                        leading:
                        HStack {
                            
                            Button(action: {
                                self.showWelcomeScreen.toggle()
                            }) {
                                Image(systemName: &quot;info.circle.fill&quot;)
                                    .font(.system(size: 24, weight: .regular))
                            }.foregroundColor(.gray)
                            
                            // Positioning Remindr Logo on Navigation
                            Image(&quot;remindrLogoSmall&quot;)
                                .resizable()
                                .aspectRatio(contentMode: .fit)
                                //.frame(width: 60, height: 60, alignment: .center)
                                .padding(.leading, 83)
                                .padding(.top, -10)
                        },
                        
                        // Global Settings Navigation Item
                        trailing: NavigationLink(destination: globalSettings()){
                            Image(&quot;settings&quot;)
                                .font(Font.title.weight(.ultraLight))
                        }.foregroundColor(.gray)
                )
                
                // Add New Reminder Button
                VStack {
                    Spacer()
                    Button(action: { self.addNewReminder.addNewTrigger.toggle()
                    }) {
                        Image(&quot;addButton&quot;)
                            .renderingMode(.original)
                    }
                    .sheet(isPresented: $addNewReminder.addNewTrigger) {
                        
                        newRemindr().environment(\.managedObjectContext, self.moc)
                        
                    }
                }
            }
        }  .sheet(isPresented: $showWelcomeScreen) {
            welcomeScreen()
        }
    }
}
}
</code></pre>
","14122428","","14122428","","2020-08-21 22:40:56","2020-08-22 03:42:56","SwiftUI: How do you dismiss a sheet and launch a different sheet from ContentView?","<ios><swift><xcode><swiftui>","1","2","","","","CC BY-SA 4.0"
"63542092","1","63542512","","2020-08-22 23:39:13","","1","953","<h2>Problem</h2>
<p>When my model housed inside a store class is updated on the main thread asynchronously, a SwiftUI view does not automatically render the slice of the model provisioned by the ViewModel.</p>
<h2>Assumed Solution</h2>
<p>A custom publisher / promise is needed to link the View/ViewModel/Factory/Store together, as a reference doesn't fire updates on asynchronous updates.</p>
<h2>Block</h2>
<p>How do I write that? I've tried adding a promise to the Store class, but Xcode warns the Result of call to sink(receiveValue:) is unused. I clearly don't understand promises / publishers and most tutorials use URLSession and its dataTaskPublisher (not my case).</p>
<p>I tried the example <a href=""https://developer.apple.com/forums/thread/133907"" rel=""nofollow noreferrer"">in this Apple Dev Forums thread</a> on the factory and store classes, but no dice. I clearly don't understand it. <a href=""https://stackoverflow.com/questions/59452113/publisher-inside-a-publisher-does-not-trigger-swiftui-re-render"">In this answer, @Asperi suggested the View listen to a publisher</a> and update an @State variable, but since my model is private I lack a target for that approach.</p>
<h2>Abbreviated Code</h2>
<ul>
<li>A factory instantiates a ContactStore class with dependencies; a reference is passed to ViewModels.</li>
<li>The VMs gate access to the private store with computed variables. The view calls functions in the ViewModel that modify state, which works well if synchronous.</li>
</ul>
<p><strong>Factory.swift</strong></p>
<pre class=""lang-swift prettyprint-override""><code>
import SwiftUI
import Combine

class MainFactory {

    init() {
        ...
        self.contactStore = ContactStore()
    }

    private var preferences: Preferences
    private var contactStore: ContactStore

 ...

    func makeOnboardingVM() -&gt; OnboardingVM {
        OnboardingVM(preferences: preferences, contactStore: contactStore)
    }

}

</code></pre>
<p><strong>ContactStore.swift</strong></p>
<pre class=""lang-swift prettyprint-override""><code>final class ContactStore {

    private(set) var authorizationStatus: CNAuthorizationStatus = .notDetermined
    private(set) var contacts: [Contact] = [Contact]()
    private(set) var errors: [Error] = [Error]()

    private lazy var initialImporter = CNContactImporterForiOS14(converter: CNContactConverterForiOS14(),
                                                                 predictor: UnidentifiedSelfContactFavoritesPredictor())
}

// MARK: - IMPORT

extension ContactStore {
    /// Full import during app onboarding. Work conducted on background thread.
    func requestAccessAndImportPhoneContacts(completion: @escaping (Bool) -&gt; Void) {
        CNContactStore().requestAccess(for: .contacts) { [weak self] (didAllow, possibleError) in
            guard didAllow else {
                DispatchQueue.main.async { completion(didAllow) }
                return
            }
            DispatchQueue.main.async { completion(didAllow) }
            self?.importContacts()
        }
    }

    private func importContacts() {
        initialImporter.importAllContactsOnUserInitiatedThread { [weak self] importResult in
            DispatchQueue.main.async {
               switch importResult {
               case .success(let importedContacts):
                
                   self?.contacts = importedContacts
               case .failure(let error):
                   self?.errors.append(error)
               }
            }
        }
    }
}
</code></pre>
<p><strong>OnboardingViewModel.swift</strong></p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Contacts

class OnboardingVM: ObservableObject {

    init(preferences: Preferences, contactStore: ContactStore) {
        self.preferences = preferences
        self.contactStore = contactStore
    }

    @Published private var preferences: Preferences
    @Published private var contactStore: ContactStore

    var contactsAllImported: [Contact] { contactStore.contacts }

    func processAddressBookAndGoToNextScreen() {
        contactStore.requestAccessAndImportContacts() { didAllow in
            DispatchQueue.main.async {
                if didAllow {
                    self.go(to: .relevantNewScreen)
                else { self.go(to: .relevantOtherScreen) }
            }
        }
    }

    ...
}
       
</code></pre>
<p><strong>View.swift</strong></p>
<pre class=""lang-swift prettyprint-override""><code>struct SelectEasiestToCall: View {
    @EnvironmentObject var onboarding: OnboardingVM

    var body: some View {
        VStack {
            ForEach(onboarding.allContactsImported) { contact in 
                SomeView(for: contact)
            }
        }

</code></pre>
","11420986","","","","","2020-08-23 01:14:05","How to fire a publisher after async update in SwiftUI?","<ios><swift><asynchronous><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"63543450","1","63549194","","2020-08-23 04:39:25","","2","725","<p>Combine subscription sample code snippet all store the resulting subscription into the <code>subscriptions</code> set</p>
<pre><code>private var subscriptions = Set&lt;AnyCancellable&gt;()
</code></pre>
<p>Why do we need to do it?</p>
<pre><code>future
  .sink(receiveCompletion: { print($0) }, receiveValue: { print($0) }) 
  .store(in: &amp;subscriptions)
</code></pre>
","2226315","","","","","2020-08-23 16:09:04","What is the reason to store subscription into a subscriptions set?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"63546298","1","63549014","","2020-08-23 11:17:23","","1","345","<p>I'm getting to know Swift + Swift's Combine framework and wanted to check that my attempt at implementing a <code>retryIf(retries:, shouldRetry:)</code> operator makes sense. In particular, I'm curious if all the <code>.eraseToAnyPublisher</code>s are expected/idiomatic.</p>
<pre class=""lang-swift prettyprint-override""><code>extension Publisher {
    func retryIf(retries: Int, shouldRetry: @escaping (Self.Failure) -&gt; Bool) -&gt; AnyPublisher&lt;Self.Output, Self.Failure&gt; {
        self.catch { error -&gt; AnyPublisher&lt;Self.Output, Self.Failure&gt; in
            guard shouldRetry(error) &amp;&amp; retries &gt; 0 else {
                return Fail(error: error).eraseToAnyPublisher() 
            }
            return self.retryIf(retries: retries - 1, shouldRetry: shouldRetry).eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
</code></pre>
<p>Assuming that all the <code>AnyPublisher</code>s are ok, when do you want to make your own <code>Publisher</code> struct? For example, the regular Combine operator <code>retry</code> returns a <code>Retry&lt;Upstream&gt;</code> struct rather than an <code>AnyPublisher</code>, but I imagine you could implement it along the same lines as the code above, something like:</p>
<pre class=""lang-swift prettyprint-override""><code>extension Publisher {
    func doOver(tries: Int) -&gt; AnyPublisher&lt;Self.Output, Self.Failure&gt; {
        self.catch { error -&gt; AnyPublisher&lt;Self.Output, Self.Failure&gt; in
            guard tries &gt; 0 else { return Fail(error: error).eraseToAnyPublisher() }
            return self.doOver(tries: tries - 1).eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
</code></pre>
","238624","","","","","2020-08-23 15:53:20","Writing a retryIf operator with Swift's Combine framework","<swift><generics><combine>","1","3","","","","CC BY-SA 4.0"
"63552394","1","63569290","","2020-08-23 21:57:39","","1","121","<pre><code>self.imagesViewModel.allImages[post.imageContentURL]?
    .resizable()
    .scaledToFill()
    .frame(width: 343, height: 171, alignment: .center)
    .clipShape(Rectangle())
    .shadow(radius: 1)
</code></pre>
<p>What this code is supposed to do is nothing when the image value returned is <code>nil</code>. But for whatever reason, the <code>.frame</code> modifier still affects other elements inside of a scroll view. It ends up obstructing navigation links physically, but not visually.</p>
<p>I've confirmed that when <code>.frame</code> is removed, everything works as I intend it to. But I need to set limits on the images, so I can't do without something of the sort.</p>
<p>I've tried placing the code inside of an if statement to check for <code>nil</code> and only display upon an image being returned, but that didn't work. Other variations of this code also don't work.</p>
<pre><code>if self.imagesViewModel.allImages[post.imageContentURL] != nil {
    self.imagesViewModel.allImages[post.imageContentURL]?
        .resizable()
        .scaledToFill()
        .frame(width: 343, height: 171)
        .clipShape(Rectangle())
        .shadow(radius: 1)
}
</code></pre>
<p>I've also tried setting min values to zero with no luck.</p>
<p>I'm wondering if it has anything to do with me being on Xcode 12 beta 5, or with using the new SwiftUI app lifecycle. When I run the code on my iPhone (iOS 14), I get the same physical obstructions, but addition visual spacing added between scrollview elements.</p>
<p>Here is a simplified version of my code that replicates my problem:</p>
<pre><code>import SwiftUI
import Combine

struct Post: Codable, Identifiable {
    var id: Int
    var text: String
    var imageContentURL: String?
}

class PostsViewModel: ObservableObject {
    @Published var posts: [Post] = []
}

class ImagesViewModel: ObservableObject {
    @Published var allImages: [String?: Image] = [:]
}

/// The View of the content displayed in Home
struct PostLayout: View {
    @EnvironmentObject var imagesViewModel: ImagesViewModel
    var post: Post
    
    init(post: Post) {
        self.post = post
    }
    
    var body: some View {
        VStack {
            // This is the navigation link that gets obstructed
            NavigationLink(destination: SomeOtherView()) {
                Image(systemName: &quot;circle.fill&quot;)
                    .resizable()
                    .frame(width: 48, height: 48)
                    .clipShape(Circle())
            }
            
            Text(self.post.text)
            
            // MARK: This is the problem code, border added for clarity
            self.imagesViewModel.allImages[self.post.imageContentURL]?
                .resizable()
                .scaledToFill()
                .frame(width: 343, height: 171)
                .clipShape(Rectangle())
                .shadow(radius: 1)
                .border(Color.black, width: 1)
        }
        .border(Color.black, width: 1)
    }
}

/// View that is navigated to from Home
struct SomeOtherView: View {
    var body: some View {
        Text(&quot;SomeOtherView&quot;)
    }
}

/// Main displayed view
struct Home: View {
    @EnvironmentObject var postsViewModel: PostsViewModel
    @EnvironmentObject var imagesViewModel: ImagesViewModel

    var body: some View {
        NavigationView {
            ScrollView {
                ForEach(self.postsViewModel.posts) { post in
                    PostLayout(post: post)
                }
            }
            .onAppear() {
                // All displayed content created here
                var post1 = Post(id: 0, text: &quot;Content&quot;)
                let post2 = Post(id: 1, text: &quot;Content&quot;)
                var post3 = Post(id: 2, text: &quot;Content&quot;)
                let post4 = Post(id: 3, text: &quot;Content&quot;)
                let imageURL = &quot;someImageURL&quot;
                
                self.imagesViewModel.allImages[imageURL] = Image(systemName: &quot;circle&quot;)
                
                // Only two posts are supposed to have an imageURL
                post1.imageContentURL = imageURL
                post3.imageContentURL = imageURL
                self.postsViewModel.posts.append(contentsOf: [post1, post2, post3, post4])
            }
            .navigationTitle(&quot;Home&quot;)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        Home()
            .environmentObject(PostsViewModel())
            .environmentObject(ImagesViewModel())
    }
}

</code></pre>
","13621853","","13621853","","2020-08-24 20:27:24","2020-08-24 22:03:51","Why does the frame modifier still affect other views when attached to nil image?","<ios><swift><swiftui><ios14>","4","0","","","","CC BY-SA 4.0"
"63554713","1","63557912","","2020-08-24 04:25:40","","2","1596","<p>I need to use .publishDecodable together with Result, I followed the <a href=""https://github.com/Alamofire/Alamofire/blob/master/Documentation/AdvancedUsage.md#using-alamofire-with-combine"" rel=""nofollow noreferrer"">instructions</a>, but I ran into this error: &quot;generic parameter 't' could not be inferred closure&quot;</p>
<p><a href=""https://i.stack.imgur.com/hn4Eo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hn4Eo.png"" alt=""enter image description here"" /></a></p>
<pre><code>@Published var loginModel: [LoginModel] = [LoginModel]()

var cancellation: AnyCancellable?

func request&lt;T: Codable&gt;(_ url: String, method: HTTPMethod = .get, headers: HTTPHeaders? = nil, parameters: Codable? = nil) -&gt; AnyPublisher&lt;Result&lt;T, AFError&gt;, Never&gt; {
    let publisher = AF.request(url, method: method, headers: headers)
        .validate()
        .publishDecodable(type: T.self)
    return publisher.result()
}

 func login(email: String, password: String) {
    let parameters = LoginParameters(
        email: email,
        password: password
    )

    cancellation = request(serverURL + &quot;login&quot;, method: .post, parameters: parameters)
        .sink { [self] response in
            switch response {
            case .success:
                loginModel = response.value()
            case .failure(error):
                print(error)
            }
        }
}
</code></pre>
","12245359","","","","","2020-08-24 09:18:52","Using Alamofire with .publishDecodable","<swift><alamofire><combine>","1","0","","","","CC BY-SA 4.0"
"63556828","1","63558156","","2020-08-24 07:52:40","","-1","284","<p>I have 2 type date from api. I need to decode together. But I didn't find any solution. I need to add <code>&quot;yyyy-MM-dd'T'HH:mm:ssZ&quot;</code> format in this code. How can I do this?</p>
<pre><code>    func run&lt;T: Decodable&gt;(_ request: URLRequest, _ decoder: JSONDecoder = JSONDecoder()) -&gt; AnyPublisher&lt;Response&lt;T&gt;, Error&gt; {
    return URLSession.shared
        .dataTaskPublisher(for: request)
        .receive(on: DispatchQueue.main)
        .tryMap { result -&gt; Response&lt;T&gt; in
            self.dateFormatter.dateFormat = &quot;yyyy-MM-dd'T'HH:mm:ss&quot;
            decoder.dateDecodingStrategy = .formatted(self.dateFormatter)
            let value = try decoder.decode(T.self, from: result.data)
            return Response(value: value, response: result.response)
        }
        .eraseToAnyPublisher()
}
</code></pre>
","14139338","","2229783","","2020-08-24 11:27:49","2020-08-24 11:27:49","JSONDecoder with multiple date formats?","<swift><request><combine><dateformatter>","2","6","","","","CC BY-SA 4.0"
"63571106","1","63698245","","2020-08-25 02:11:38","","0","117","<p>I created a custom UITableViewCell to use in a TableView. The cell appears correctly in the storyboard but when I display it in the TableView it appears completely jumbled. I have looked at similar questions however their problems seem to have been naming of outlets and Xcode bugs. What am I missing?</p>
<p>UITableViewCell</p>
<pre><code>class ArticleLargeTableViewCell: UITableViewCell {

public static let Identifier = &quot;ArticleLargeTableViewCell&quot;

@IBOutlet weak var shareButton: UIButton!
@IBOutlet weak var favoriteButton: UIButton!
@IBOutlet weak var articleImage: UIImageView!
@IBOutlet weak var articleType: UIImageView!
@IBOutlet weak var articleTitle: UILabel!
@IBOutlet weak var articleDate: UILabel!
@IBOutlet weak var articleSource: UILabel!
@IBOutlet weak var articleFavicon: UIImageView!
private var shareClickListener: (Article) -&gt; Void = { _ in }
private var favoriteClickListener: (Article) -&gt; Void = { _ in }
private var article: Article!

override class func awakeFromNib() {
    super.awakeFromNib()
}

func setData(article: Article, shareClickListener: @escaping (Article) -&gt; Void, favoriteClickListener: @escaping (Article) -&gt; Void, shouldShowMoreButton: Bool = true) {
    self.article = article
    articleImage.sd_setImage(with: article.getImageUrl())
    articleImage.contentMode = UIView.ContentMode.scaleAspectFill
    articleImage.clipsToBounds = true
    articleTitle.text = article.title
    let textColor = UIColor(named: &quot;text&quot;)
    articleTitle.textColor = textColor
    articleSource.text = article.source.title
    articleSource.textColor = textColor
    articleDate.textColor = UIColor(named: &quot;caption&quot;)
    articleDate.text = article.date.timeAgo()
    self.shareClickListener = shareClickListener
    self.favoriteClickListener = favoriteClickListener
    articleType.image = article.articleType().getTypeImage()
    articleFavicon.sd_setImage(with: URL(string: article.faviconUrl)!)
    favoriteButton.addTarget(self, action: #selector(self.onFavoriteButtonClick), for: .touchUpInside)
    shareButton.addTarget(self, action: #selector(self.onShareButtonClick), for: .touchUpInside)
}

@objc func onShareButtonClick() {
    shareClickListener(article)
}

@objc func onFavoriteButtonClick() {
    favoriteClickListener(article)
}
}
</code></pre>
<p>ViewController</p>
<pre><code>import Foundation
import UIKit
import Combine
import MaterialComponents.MaterialActionSheet

class ArticlesViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {
    
    @IBOutlet weak var articlesList: UITableView!
    private var articles: [Article] = []
    var viewModel: ArticlesViewModel!
    private var useCompactView: Bool = true
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        articlesList.dataSource = self
        articlesList.delegate = self
        viewModel.$viewState.sink(receiveCompletion: { _ in}, receiveValue: { viewState in
            switch viewState {
            case .loading:
                print()
            case .error:
                print()
            case let .data(data):
                self.setData(data: data)
            }
        })
    }
    
    private func setData(data: ArticlesViewModel.ViewState.Data) {
        self.articles = data.articles
        self.title = data.title
        self.useCompactView = data.useCompactView
        if self.useCompactView {
            articlesList.register(UINib(nibName: ArticleUiTableViewCell.Identifier, bundle: Bundle.main), forCellReuseIdentifier: ArticleUiTableViewCell.Identifier)
        } else {
            articlesList.register(UINib(nibName: ArticleLargeTableViewCell.Identifier, bundle: Bundle.main), forCellReuseIdentifier: ArticleLargeTableViewCell.Identifier)
        }
        articlesList.reloadData()
        articlesList.refreshControl?.endRefreshing()
    }
    
    func numberOfSections(in tableView: UITableView) -&gt; Int {
        1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        return articles.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
        if useCompactView {
            guard let cell = articlesList.dequeueReusableCell(withIdentifier: ArticleUiTableViewCell.Identifier, for: indexPath) as? ArticleUiTableViewCell else {
                fatalError(&quot;could not cast to articles cell&quot;)
            }
            // display other cell
        } else {
            guard let cell = articlesList.dequeueReusableCell(withIdentifier: ArticleLargeTableViewCell.Identifier, for: indexPath) as? ArticleLargeTableViewCell else {
                fatalError(&quot;could not cast to articles cell&quot;)
            }
            let article = articles[indexPath.item]
            cell.setData(article: article, shareClickListener: { article in
                self.shareLink(description: article.title, url: article.originalUrl)
            }, favoriteClickListener: { article in
                self.viewModel.favoriteArticle(article: article, delegate: UIApplication.shared.delegate)
            })
            return cell
        }
    }
 
}
</code></pre>
<p>AutoLayout
<a href=""https://i.stack.imgur.com/1lr4T.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/1lr4T.png"" alt="""" /></a></p>
<p>Output
<a href=""https://i.stack.imgur.com/L43OK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/L43OK.png"" alt=""enter image description here"" /></a></p>
<p>I have tried returning an explicit height as you can see below, but I get a similar error.</p>
<pre><code>func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {
    return 467
}
</code></pre>
","1120154","","1120154","","2020-08-31 22:17:07","2020-09-03 16:33:34","Custom UITableViewCell does not display correctly","<ios><swift><uitableview>","3","6","","","","CC BY-SA 4.0"
"63586299","1","63586783","","2020-08-25 20:02:41","","3","1315","<p>I'm having troubles with passing class information from one struct instance to another, so I've been messing trying things out.</p>
<p>This works because I'm passing through Views</p>
<pre class=""lang-swift prettyprint-override""><code>// phone_testingApp.swift
import SwiftUI

@main
struct phone_testingApp: App {
    
    @ObservedObject var myObservedObject = MyObservedObject()
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(myObservedObject)
        }
    }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>// ContentView.swift

import SwiftUI
import Combine

struct ContentView: View {
    
    var subtract = MinusToObject()
    @EnvironmentObject var myNumber: MyObservedObject
    
    var body: some View {
        VStack{

            Text(&quot;The number is \(myNumber.theObservedObjectToPass)&quot;)
            
            MinusToObject()
                .environmentObject(myNumber)
        }
    }
}

class MyObservedObject: ObservableObject {
    @Published var theObservedObjectToPass = 5
}

struct MinusToObject: View {
    
    @EnvironmentObject var theObservedObject: MyObservedObject
    
    var body: some View {
        Text(&quot;Minus&quot;)
            .onTapGesture {
                theObservedObject.theObservedObjectToPass -= 1
            }
    }
}
</code></pre>
<p>but if I try something similar with just a plain struct that doesn't conform to View like this</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

struct ContentView: View {
    
    var subtract = MinusToObject()
    @EnvironmentObject var myNumber: MyObservedObject
    
    var body: some View {
        VStack{

            Text(&quot;The number is \(myNumber.theObservedObjectToPass)&quot;)
            
            Text(&quot;Minus&quot;)
                .onTapGesture {
                    subtract.subtractIt()
                }
        }
    }
}

class MyObservedObject: ObservableObject {
    @Published var theObservedObjectToPass = 5
}

struct MinusToObject {
    
    @EnvironmentObject var theObservedObject: MyObservedObject
    
        
            func subtractIt() {
                theObservedObject.theObservedObjectToPass -= 1 //Thread 1: Fatal error: No ObservableObject of type MyObservedObject found. A View.environmentObject(_:) for MyObservedObject may be missing as an ancestor of this view.
            }
}
</code></pre>
<p>I get a runtime error thats I've put commented in at the calling of the function.</p>
<p>I'm quite confused as to how to pass around an instance of a reference type, so I'm sure I'm doing many things wrong, and any help would be appreciated.</p>
","12051065","","","","","2020-08-25 20:58:19","Can @EnvironmentObject be used with a plain struct that isn't a View?","<ios><swift><swiftui>","2","0","","","","CC BY-SA 4.0"
"63605073","1","64896955","","2020-08-26 20:09:50","","2","566","<p>This problem has been haunting me for months and I believe it comes down to my using the wrong structure and procedure.</p>
<p>I'm trying to do an API call to Yelp's API and passing in the variables for the user's lat/long. I'm able to grab the lat/long based on my current LocationManager, however when it seems as though the lat/long only becomes available AFTER the API call has been made, so the API is getting default 0.0 values for both lat/long.</p>
<p>I'm very much a beginner when it comes to this, but is there a way that I could set up a loading screen that grabs the lat/long in the background and by the time my ExploreView shows, the real location information has been established?</p>
<p>Below is my LocationManager and ExploreView</p>
<p>LocationManager</p>
<pre><code>import Foundation
import CoreLocation

class LocationManager: NSObject, ObservableObject {

private let locationManager = CLLocationManager()
let geoCoder = CLGeocoder()

@Published var location: CLLocation? = nil
@Published var placemark: CLPlacemark? = nil

override init() {
    super.init()
    self.locationManager.delegate = self
    self.locationManager.desiredAccuracy = kCLLocationAccuracyBest
    self.locationManager.distanceFilter = kCLDistanceFilterNone
    self.locationManager.requestWhenInUseAuthorization()
    self.locationManager.startUpdatingLocation()
    
}

func geoCode(with location: CLLocation) {
    geoCoder.reverseGeocodeLocation(location) { (placemark, error) in
        if error != nil {
            print(error!.localizedDescription)
        } else {
            self.placemark = placemark?.first
        }
    }
}

func startUpdating() {
    self.locationManager.delegate = self
    self.locationManager.requestWhenInUseAuthorization()
    self.locationManager.startUpdatingLocation()
    }
}

extension LocationManager: CLLocationManagerDelegate {

func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    guard let location = locations.first else {
        return
    }
    self.location = location
    self.geoCode(with: location)
    }
}
</code></pre>
<p>ExploreView (The first view that shows upon launch)</p>
<pre><code>import SwiftUI
import CoreLocation
import Foundation


struct ExploreView: View {
    @ObservedObject  var location = LocationManager()
    @ObservedObject var fetcher: RestaurantFetcher


init() {
    let location = LocationManager()
    self.location = location
    self.fetcher = RestaurantFetcher(locationManager: location)
    self.location.startUpdating()
}

var body: some View {
        ScrollView (.vertical) {
            VStack {
                HStack {
                    Text(&quot;Discover &quot;)
                        .font(.system(size: 28))
                        .fontWeight(.bold)
                  +  Text(&quot; \(location.placemark?.locality ?? &quot;&quot;)&quot;)
                        .font(.system(size: 28))
                        .fontWeight(.bold)
                    Spacer()                       
                }
                HStack {
                    SearchBar(text: .constant(&quot;&quot;))
                }.padding(.top, 16)                
                HStack {
                    Text(&quot;Featured Restaurants&quot;)
                        .font(.system(size: 24))
                        .fontWeight(.bold)
                    Spacer()                       
                    NavigationLink(
                        destination: FeaturedView(),
                        label: {
                            Text(&quot;View All&quot;)
                        })                        
                }.padding(.vertical, 30)                 
                HStack {
                    Text(&quot;All Cuisines&quot;)
                        .font(.system(size: 24))
                        .fontWeight(.bold)
                    Spacer()
                }                
                Spacer()
            }.padding()
        }      
    }
}

public class RestaurantFetcher: ObservableObject {
    @Published var businesses = [RestaurantResponse]()
    @ObservedObject var locationManager: LocationManager
    let location = LocationManager()

var lat: String {
    return &quot;\(location.location?.coordinate.latitude ?? 0.0)&quot;
}

var long: String {
    return &quot;\(location.location?.coordinate.longitude ?? 0.0)&quot;
}

init(locationManager: LocationManager) {
    let location = LocationManager()
    self.locationManager = location
    self.location.startUpdating()
    
    load()
}

func load() {
    print(&quot;\(location.location?.coordinate.latitude ?? 0.0)&quot;)
    print(&quot;user latitude top of function&quot;)
    //Returns default values of 0.0
    let apikey = &quot;APIKEY Here&quot;
    let url = URL(string: &quot;https://api.yelp.com/v3/businesses/search?latitude=\(lat)&amp;longitude=\(long)&amp;radius=40000&quot;)!
    var request = URLRequest(url: url)
    request.setValue(&quot;Bearer \(apikey)&quot;, forHTTPHeaderField: &quot;Authorization&quot;)
    request.httpMethod = &quot;GET&quot;
    
    URLSession.shared.dataTask(with: request) { (data, response, error) in
        do {
            if let d = data {
                print(&quot;\(self.location.location?.coordinate.longitude ?? 0.0)&quot;)
                let decodedLists = try JSONDecoder().decode(BusinessesResponse.self, from: d)
               
                // Returns actual location coordinates
                DispatchQueue.main.async {
                    self.businesses = decodedLists.restaurants
                }
            } else {
                print(&quot;No Data&quot;)
            }
        } catch {
            print (&quot;Caught&quot;)
        }
    }.resume()
    }
}
</code></pre>
","1336383","","12299030","","2020-11-18 16:16:21","2020-11-18 16:16:21","SwiftUI - Get User's coordinates to pass in API call","<swift><swiftui><core-location><combine><clplacemark>","1","1","2","","","CC BY-SA 4.0"
"63611009","1","63611282","","2020-08-27 07:18:22","","1","149","<p>Given an AuthenticationView swiftui struct contains a UserLoginView. The UserLoginView has a UserLoginViewModel class for handle the login button actions.</p>
<p>In the AuthenticationView I would like to know when the value of the variable changes in the inner UserLoginView (if the tutorialScreenIsShowable is true in AuthenticationView, the NavigationLink navigate to next slide).</p>
<pre><code>struct AuthenticationView: View {
    @State private var tutorialScreenIsShowable = false
    var body: some View {
        NavigationView {
            ZStack {
                NavigationLink(destination: TutorialView(), isActive: $tutorialScreenIsShowable) {
                    EmptyView()
                }
                UserLoginView(tutorialScreenIsShowable: self.$tutorialScreenIsShowable)
            }
        }
    }
}
</code></pre>
<p>,</p>
<pre><code>struct UserLoginView: View {
    @Binding var tutorialScreenIsShowable: Bool
    @ObservedObject var userLoginViewModel = UserLoginViewModel()
    var body: some View {
        Button(action: {
            self.userLoginViewModel.loginButtonAction() // it not works but I need this way
//            self.tutorialScreenIsShowable = self.userLoginViewModel.loginButtonActionWithReturn() // it works, but its not good in this case
        }) {
            Text(&quot;Log in&quot;)
        }
    }
}
</code></pre>
<p>,</p>
<pre><code>class UserLoginViewModel: NSObject, ObservableObject {
    @Published var tutorialScreenIsShowable = false
    
    func loginButtonAction() {
        self.tutorialScreenIsShowable = true
    }
    
    func loginButtonActionWithReturn() -&gt; Bool {
        return true
    }
}
</code></pre>
<p>As I know if the function would have a return value that could be work, but in this case there is a delegate method running where I can handle the variable.</p>
<p>I'd like to avoid @EnvironmentObject as it possible, I hope there is another solution.</p>
<p>Could you help me with this?</p>
<p>Edit: I simplified the example. And uploaded a example project here: <a href=""https://www.dropbox.com/s/paosp6iom9oks9p/InnerViewPropBind.zip"" rel=""nofollow noreferrer"">https://www.dropbox.com/s/paosp6iom9oks9p/InnerViewPropBind.zip</a></p>
","2645599","","2645599","","2020-08-27 09:15:14","2020-08-27 10:36:31","In parent swiftui view how could I know when a state changes in an inner views viewmodel void method?","<swift><binding><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63633284","1","63634213","","2020-08-28 11:53:12","","0","445","<p>This code crashes (&quot;Unexpectedly found nil while unwrapping an Optional value&quot;)</p>
<pre><code>import Combine

class Receiver {
    var value: Int!
    var cancellables = Set&lt;AnyCancellable&gt;([])
    
    init(_ p: AnyPublisher&lt;Int,Never&gt;) {
        p.assign(to: \.value, on: self).store(in: &amp;cancellables)
    }
}

let receiver = Receiver(Just(5).eraseToAnyPublisher())
</code></pre>
<p>It does not crash if I use <code>p.sink { self.value = $0 }.store(in: &amp;cancellables)</code> instead of the assign, and it does not crash if I do not use an optional for the <code>value</code>-property.</p>
<p>To me this looks like a bug in Swift's constructor code, but maybe I am overlooking something?</p>
","15745","","","","","2021-10-31 14:36:19","Why does Combine assign crash when writing to an optional property?","<swift><combine>","2","2","","","","CC BY-SA 4.0"
"63669884","1","63670000","","2020-08-31 11:25:02","","7","6453","<p>I have a view with a view model, and actions in this view can change the view model. To be able to break out logic into reusable pieces, I have part of the view as its own view, with a @Binding to the values it needs to have. Now, I want to be able to perform some logic based on the value changes, not necessarily only view changes. How can I do that? If it was a regular property, I'd implement a didSet, but that gets me nowhere. I wanted to use Combine to and treat the @Binding as a publisher, but I couldn't find a way to do that either. Suggestions?</p>
<p>Here's the code:</p>
<pre class=""lang-swift prettyprint-override""><code>class ViewModel: ObservableObject {
    @Published var counter: Int = 0
}

struct Greeter: View {
    @Binding var counter: Int {
        didSet {
            // this isn't printed....
            print(&quot;Did set -&gt; \(counter)&quot;)
        }
    }
    
    init(counter: Binding&lt;Int&gt;) {
        self._counter = counter
        
        // ...so how about setting up a subscription to the @Binding counter above here?
    }
    
    var body: some View {
        Text(&quot;Hello, world #\(counter)!&quot;)
            .padding()
    }
}

struct ContentView: View {
    
    @ObservedObject var viewModel: ViewModel
    
    var body: some View {
        VStack {
            Greeter(counter: $viewModel.counter)
            Button(&quot;Go!&quot;) {
                viewModel.counter += 1
            }
        }
    }
}
</code></pre>
<p>So I want to retain the structure where the data is in a ViewModel, and that only parts of it is being passed down to the subview. And it is in the subview (Greeter) I want to be able to do something (let's say print the value like in the didSet)</p>
","80246","","","","","2022-04-19 06:02:33","SwiftUI/Combine: subscribe to value change of @Binding","<swift><xcode><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63678438","1","63682272","","2020-08-31 21:30:52","","3","1624","<p>I'm trying to update the main view with high frequency data coming from separate background thread.
I've created two tabviews and in case of slow update rate I can change the view. But in another case the UI doesn't react. I've observed this behavior only on real device, in the simulator works everything fine.</p>
<p>The while loop is still representing an imu, just to keep it simple.</p>
<p>Did someone any idea how to fix this issue?</p>
<p>Many thanks!</p>
<pre><code>import SwiftUI

struct ContentView: View {
    
    @EnvironmentObject var loop : Loop
    
    var body: some View {
        
        TabView{
        
            VStack {
                Text(&quot;Content View&quot;)
                LoopView()
            }.tabItem{
                  VStack{
                      Text(&quot;tab1&quot;)
                      Image(systemName: &quot;car&quot;)
                }
                
            }
            
            Text(&quot;second view&quot;).tabItem{
                                    VStack{
                                        Text(&quot;tab2&quot;)
                                        Image(systemName: &quot;star&quot;)
                }
            }
        }
    }
}


class Loop : ObservableObject {
    
    @Published var i : Int
    
    func startLoop() {
        while true {
            print(&quot;i = \(self.i)&quot;)
            DispatchQueue.main.async {
                self.i += 1
            }

            //sleep(1) // comment out to simulate worst case
        }
    }
    
    init() {
        DispatchQueue.global(qos: .background).async {
            self.startLoop()
        }
    }
}


struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>
","6108653","","12299030","","2020-09-01 06:10:00","2020-09-01 10:30:50","SwiftUI updating UI with high frequency data","<mvvm><swiftui><observable><grand-central-dispatch><combine>","2","3","4","","","CC BY-SA 4.0"
"63680919","1","63684496","","2020-09-01 03:25:10","","1","119","<p>I believe that I have set up my view and view model correctly. I have also confirmed that the network request returns data (via the console). I am confused on why my published property isn't updating my view with the fetched data.</p>
<p>Here is my view model:</p>
<pre><code> class ProductViewModel: ObservableObject {
    var didChange = PassthroughSubject&lt;ProductViewModel, Never&gt;()
    @Published var mensProducts = [StripeProduct]()
    
    init() {
    }
    
    func getMenItems() {
        // hit the URL and
        guard let url = URL(string: &quot;http://127.0.0.1:3000/bags&quot;) else {
            return
        }
        
        URLSession.shared.dataTask(with: url) { (data, response, err) in
            // return the data asynchronously so that the call doesn't have to complete before loading the UI
            DispatchQueue.main.async {
                print(&quot;Decode data&quot;)
                self.mensProducts = try! JSONDecoder().decode([StripeProduct].self, from: data!)
            }
        }
        .resume()
    }
}
</code></pre>
<p>Here is my view:</p>
<pre><code>struct MenProducts: View {
    @ObservedObject var productVM = ProductViewModel()
    var body: some View {
        GeometryReader { geometry in
            ScrollView {
                VStack {
                    ForEach(self.productVM.mensProducts) { item in
                        ProductView(productID: item.productID, photo: &quot;menMerch&quot;, price: item.price, name: item.productName, height: geometry.size.height/2, width: geometry.size.width)
                    }
                }
            }
        }
        .onAppear(perform: self.productVM.getMenItems)
    }
}
</code></pre>
","10667652","","","","","2020-09-01 09:00:58","@Published variable doesn't reload my view after API call?","<swift><swiftui>","1","3","","","","CC BY-SA 4.0"
"63696446","1","63696674","","2020-09-01 22:50:01","","3","867","<pre><code>class ObservableFormViewModel: ObservableObject {
  @Published var isSubmitAllowed: Bool = true
  @Published var username: String = &quot;&quot;
  @Published var password: String = &quot;&quot;
  var somethingElse: Int = 10
}

var form = ObservableFormViewModel()

let formSubscription = form.$isSubmitAllowed.sink { _ in
    print(&quot;Form changed: \(form.isSubmitAllowed) \&quot;\(form.username)\&quot; \&quot;\(form.password)\&quot;&quot;)
}


form.isSubmitAllowed = false
form.isSubmitAllowed = false
form.isSubmitAllowed = false
</code></pre>
<p>The output is:</p>
<pre class=""lang-swift prettyprint-override""><code>Form changed: true &quot;&quot; &quot;&quot;
Form changed: true &quot;&quot; &quot;&quot;
Form changed: false &quot;&quot; &quot;&quot;
Form changed: false &quot;&quot; &quot;&quot;
</code></pre>
<p>My question is:</p>
<ul>
<li>why <code>true</code> output comes 2 while <code>false</code> only 2?</li>
<li>any better way to remove duplicate?</li>
</ul>
","1861935","","8697793","","2020-09-02 08:10:43","2020-09-02 08:10:43","Swift Combine Publish Twice","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63701195","1","63701338","","2020-09-02 08:02:39","","0","608","<p>Lets say I want to create an asynchronous function that calls some random API and returns a random Int. I want wrap it using a future</p>
<pre><code>func createFuture() -&gt; Future&lt;Int, Never&gt; {
  return Future { promise in
    promise(.success(Int.random(1...10))
  }
}
</code></pre>
<p>This would return me the same output everytime. Instead i want to return AnyPublisher.</p>
<pre><code>func createAnyPublisher() -&gt; AnyPublisher&lt;Int, Never&gt; {  //This is invalid
    return AnyPublisher&lt;Int, Never&gt; { seed in
        seed.success(Int.random(in: 1...10))
    }
}
</code></pre>
<p>A better example:</p>
<pre><code>func guessNumber(num: Int) -&gt; AnyPublisher&lt;Bool, Never&gt; {
    asyncRandomNumber { winner in
        if num == winner {
            // return true
        } else {
            // return false
        }
    }
}

private func asyncRandomNumber(completion: (Int) -&gt; Void) {
    completion(Int.random(in: 1...10))
}
</code></pre>
<p>How do you wrap that asyncRandomNumber ?</p>
","588125","","4667835","","2020-09-02 08:31:05","2020-09-02 08:41:40","How to wrap an async function inside AnyPublisher?","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"63723976","1","63724127","","2020-09-03 12:44:51","","2","34","<p>I try do achieve something simple. In AppDelegate I need <code>var vertices: [SCNVector3] = []</code>. In <code>@IBAction func getVertices(_ sender: Any)</code> I can read file and assign new value to <code>vertices</code>. Simple and works. But when I try to pass value to SwiftUI View I have problems.
If I define</p>
<pre><code>@State var vertices: [SCNVector3] = []

func applicationDidFinishLaunching(_ aNotification: Notification) {
    ....
    let contentView = CloudView(data: $vertices)
    ....
    window.contentView = NSHostingView(rootView: contentView)
    ...
}

@IBAction func getVertices(_ sender: Any) {
    ...
    do {
        let readVertices: [SCNVector3] = try... // read file and convert to [SCNVector3]
        vertcices = readVertices // assign or not to assign, this is a question
        print (readVertices.count, vertices.count)
    }
    ...
}
</code></pre>
<p>and it prints:</p>
<pre><code>3500 0
</code></pre>
<p>so, it never updates <code>CloudView</code>, <code>vertices</code> is always an empty array.</p>
<p>Could somebody explain me how I should do it in proper way?</p>
","1238267","","","","","2020-09-03 12:54:13","Swift Combine and SwiftUI understanding needs corrections","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63748555","1","63750322","","2020-09-04 22:11:18","","1","492","<p>I can get a variable in my environment but I cannot set/update the variable.</p>
<p>My environment object looks like this:</p>
<pre><code>import SwiftUI
import Combine

class UserData: ObservableObject{
    @Published var examples = exampleData
}
</code></pre>
<p>I have a load function that reads in a JSON:</p>
<p><code>let exampleData: [Example] = load(&quot;exampleData.json&quot;)</code></p>
<p>Here is whaat Example is formatted as:</p>
<pre><code>import SwiftUI
import CoreLocation

struct Example: Hashable, Codable, Identifiable {
    var id: Int
    var name: String
    var exampleCondition: [SubCondition]
}

struct SubCondition: Hashable, Codable, Identifiable {
    var id: Int
    var comparand: String
    var firstElement: ExampleElement
    var secondElement: ExampleElement
    
    var stringFormat: String {
        firstElement.stringFormat + &quot; &quot; + comparand + secondElement.stringFormat     
    }
}

struct ExampleElement: Hashable, Codable {
    var timeFrame: String
    var element: String
    
    var stringFormat: String {
        element + &quot; (&quot; + timeFrame + &quot;)&quot;
    }
}
</code></pre>
<p>Using <code>@EnvironmentObject var userData: UserData</code> in my views, I can show something like: <code>Text(userData.examples[examplesIndex].exampleCondition[0].stringFormat)</code></p>
<p>However, I am getting a <code>Cannot assign to property: 'stringFormat' is a get-only property</code>. When I do:</p>
<pre><code>var tempString: String = &quot;abc&quot;

Rectangle().onTapGesture {
   userData.examples[examplesIndex].exampleCondition[0].stringFormat = tempString
}
</code></pre>
<p>How do I set something within my <code>@EnvironmentObject var userData</code>?</p>
<p>Is it because I am computing stringFormat and the best way to set stringFormat is to edit the variables in ExampleElement that it uses to compute stringFormat? If so, is there a way to set up a custom get and set?</p>
","10669653","","","","","2020-09-05 03:59:54","String variable in Environment is a get only. Swift","<swift><swiftui><environmentobject>","2","4","","","","CC BY-SA 4.0"
"63770032","1","63771209","","2020-09-07 00:24:03","","0","185","<p>Had various success with using dataTaskPublisher and pulling data from APIs.
Issue I'm having is with nested JSON. I can fetch simple JSON but something like the Pokemon API where it has nested JSON is getting me.</p>
<p>Any advise would be great.
The onappear: // fetch completion is the part I'm hung up on.</p>
<pre><code>import SwiftUI
import Combine

struct Pokemon: Codable {
    var cards: Card
}

struct Card: Codable {
    var id: String
    var name: String
}


struct ContentView: View {
    @State private var requests = Set&lt;AnyCancellable&gt;()
    @State var pokemon: Pokemon
    
    var body: some View {
        VStack {
            Text(&quot;card name here&quot;)
        }
        .onAppear {
            let url = URL(string: &quot;https://api.pokemontcg.io/v1/cards&quot;)!
            
            self.fetch(url, defaultValue: [Pokemon]()) {
                self.pokemon = $0
            }
        }
    }
    
    func fetch&lt;T: Decodable&gt;(_ url: URL, defaultValue: T, completion: @escaping (T) -&gt; Void) {
        
        let decoder = JSONDecoder()
        
        URLSession.shared.dataTaskPublisher(for: url)
            .retry(1)
            .map(\.data)
            .decode(type: T.self, decoder: decoder)
            .replaceError(with: defaultValue)
            .receive(on: DispatchQueue.main)
            .sink(receiveValue: completion)
            .store(in: &amp;requests)
    }
}
</code></pre>
","14232340","","","","","2020-09-07 04:08:04","Swift API Call using dataTaskPublisher","<json><swift><api><parsing><networking>","1","0","","","","CC BY-SA 4.0"
"63776624","1","64015142","","2020-09-07 11:21:55","","5","663","<p>I've heard with the Xcode 12 (now in Beta 6), Swift package manager is now able to include resources. But I am not able to open a reality (.rcproject) file.</p>
<h2>Here is what I have tried; (&amp; you can reproduce)</h2>
<ol>
<li>I created a new <code>Augmented Reality App</code> project. (RealityKit + SwiftUI + Swift)</li>
<li>Now if you try to run the project, everything works, you see a default metallic box.</li>
<li>Now I created a new <code>SPM</code> (Swift package manager)</li>
<li>Now I dragged locally created <code>SPM</code> to the project and added it to frameworks in General &gt; Targets tab. (To inform the project about locally added spm)</li>
<li>I dragged <code>Experience.rcproject</code> &amp; <code>ContentView</code> (also copied the autogenerated <code>Experience</code> enum, you can reach it via Cmd+Click) to <code>SPM</code></li>
<li>Fixed some access initializer issue for <code>ContentView</code> &amp; added platform support <code>platforms: [.iOS(.v13)],</code> in the <code>SPM</code></li>
<li>Added <code>resources</code> in the <code>SPM</code> for the path <code>Experience.rcproject</code> exist</li>
</ol>
<p>After those steps finished I'd except to have an AR included swift package manager. <br>
But auto generated <code>Experience</code> enum throws <code>.fileNotFound(&quot;Experience.reality&quot;)</code> error. <br>
Seems still not able to find reality file in Bundle?</p>
<p>Have you tried something similar. Waiting any helps. Thanks..</p>
<br>
<p><a href=""https://i.stack.imgur.com/aytGa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aytGa.png"" alt=""Folder Structure"" /></a></p>
<p><em><code>Package.swift</code></em></p>
<pre class=""lang-swift prettyprint-override""><code>// swift-tools-version:5.3
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: &quot;ARSPM&quot;,
    platforms: [.iOS(.v13)],
    products: [
        .library(
            name: &quot;ARSPM&quot;,
            targets: [&quot;ARSPM&quot;]),
    ],
    dependencies: [],
    targets: [
        .target(
            name: &quot;ARSPM&quot;,
            dependencies: [], resources: [
                .copy(&quot;Resources&quot;)
            ]),
        .testTarget(
            name: &quot;ARSPMTests&quot;,
            dependencies: [&quot;ARSPM&quot;]),
    ]
)

</code></pre>
<p><em><code>ARView.swift</code></em></p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import RealityKit

public struct EKARView : View {
    public init() { }
    public var body: some View {
        return ARViewContainer().edgesIgnoringSafeArea(.all)
    }
}

public struct ARViewContainer: UIViewRepresentable {
    
    public func makeUIView(context: Context) -&gt; ARView {
        
        let arView = ARView(frame: .zero)
        
        // Load the &quot;Box&quot; scene from the &quot;Experience&quot; Reality File
        let boxAnchor = try! Experience.loadBox()
        
        // Add the box anchor to the scene
        arView.scene.anchors.append(boxAnchor)
        
        return arView
        
    }
    
    public func updateUIView(_ uiView: ARView, context: Context) {}
    
}

</code></pre>
<p><em><code>GeneratedExperienceFile.swift</code></em></p>
<pre class=""lang-swift prettyprint-override""><code>//
// Experience.swift
// GENERATED CONTENT. DO NOT EDIT.
//

import Foundation
import RealityKit
import simd
import Combine

internal enum Experience {

    public enum LoadRealityFileError: Error {
        case fileNotFound(String)
    }

    private static var streams = [Combine.AnyCancellable]()

    public static func loadBox() throws -&gt; Experience.Box {
        guard let realityFileURL =
//                Also tried &gt;&gt; Foundation.Bundle.module
                Foundation.Bundle(for: Experience.Box.self)
                    .url(forResource: &quot;Experience&quot;, withExtension: &quot;reality&quot;) else {
            throw Experience.LoadRealityFileError.fileNotFound(&quot;Experience.reality&quot;)
        }

        let realityFileSceneURL = realityFileURL.appendingPathComponent(&quot;Box&quot;, isDirectory: false)
        let anchorEntity = try Experience.Box.loadAnchor(contentsOf: realityFileSceneURL)
        return createBox(from: anchorEntity)
    }

    public static func loadBoxAsync(completion: @escaping (Swift.Result&lt;Experience.Box, Swift.Error&gt;) -&gt; Void) {
        guard let realityFileURL = Foundation.Bundle(for: Experience.Box.self).url(forResource: &quot;Experience&quot;, withExtension: &quot;reality&quot;) else {
            completion(.failure(Experience.LoadRealityFileError.fileNotFound(&quot;Experience.reality&quot;)))
            return
        }

        var cancellable: Combine.AnyCancellable?
        let realityFileSceneURL = realityFileURL.appendingPathComponent(&quot;Box&quot;, isDirectory: false)
        let loadRequest = Experience.Box.loadAnchorAsync(contentsOf: realityFileSceneURL)
        cancellable = loadRequest.sink(receiveCompletion: { loadCompletion in
            if case let .failure(error) = loadCompletion {
                completion(.failure(error))
            }
            streams.removeAll { $0 === cancellable }
        }, receiveValue: { entity in
            completion(.success(Experience.createBox(from: entity)))
        })
        cancellable?.store(in: &amp;streams)
    }

    private static func createBox(from anchorEntity: RealityKit.AnchorEntity) -&gt; Experience.Box {
        let box = Experience.Box()
        box.anchoring = anchorEntity.anchoring
        box.addChild(anchorEntity)
        return box
    }

    public class Box: RealityKit.Entity, RealityKit.HasAnchoring {

        public var steelBox: RealityKit.Entity? {
            return self.findEntity(named: &quot;Steel Box&quot;)
        }

    }

}

</code></pre>
<p>And in <code>ContentView</code> file, I simple show <code>EKARView</code>.</p>
","5645821","","5645821","","2020-09-16 17:19:38","2020-09-22 17:48:06","How to add Reality file in a Swift Package Manager?","<ios><swift><swiftui><arkit><swift-package-manager>","1","6","1","","","CC BY-SA 4.0"
"63784923","1","63786860","","2020-09-07 22:19:48","","1","2662","<p>Using Combine and UIKit, I am trying to update my tableview when the array contained in the viewModel changes. My tableview's datasource is separate because I would like to reuse the file (Different objects all have a name var, so the tableviews will display a list of names).</p>
<p>The viewModel:</p>
<pre><code>class ViewModel {
  @Published var items = [ItemViewModel]()
  let service = NetworkService()

  init() {
    fetchItems()
  }
    
  func fetchItems() {
    service.fetchItems { items in {
    self.items = items.map { ItemViewModel($0) }
  }
}
</code></pre>
<p>The datasource:</p>
<pre><code>class GenericDataSource: UITableViewDataSource {
   var list = [String]()

   func setList(_ list: [String]) {
       self.list = list
   }

  // then the usual tableView datasource boilerplate
}
</code></pre>
<p>The viewController:</p>
<pre><code>class ViewController: UIViewController {
  let viewModel = ViewModel()
  let tableDataSouce = GenericDataSource()
  var subscriptions = Set&lt;AnyCancellable&gt;()

  func setupBinding() {
    // I want to: 1) map over viewModel.$items to get [item.name]
    //            2) assign the list of names to tableDataSource.list
    //            3) reload the tableview so the new values are displayed
  }
</code></pre>
<p>I'm not sure what Combine functions to use. My current (working) code is as follows:</p>
<pre><code>func setupBinding() {
     viewModel.$items.handleEvents(receiveOutput: { [weak self] items in
         self?.dataSource.setList(items.map { $0.name })
         
            // dispatch called because I get yelled at for not being on main thread
            DispatchQueue.main.async { 
                 self?.itemsTableView.reloadData()
            }
        })
           .sink { _ in }
           .store(in: &amp;subscriptions)
 }
</code></pre>
<p>It works, but I feel like I'm brute forcing it. Is there a cleaner way to perform the binding with the current setup?</p>
<p>Is there a cleaner way to setup the code so the binding will be easier?</p>
","8767479","","","","","2020-09-08 03:52:01","Swift UIKit Combine - How to reload tableview when handling publisher events?","<swift><mvvm><uikit><tableview><combine>","1","0","1","","","CC BY-SA 4.0"
"63788210","1","63788656","","2020-09-08 06:28:04","","1","8025","<p>I started using combine and it's really cool but currently I have no idea how to fix it. I want to make a POST Request using combine so I have to decode Data, create my request, send it and after that return an</p>
<pre><code>AnyPublisher&lt;Void, Error&gt;
</code></pre>
<p>Currently my code looks like this:</p>
<pre><code>func postData&lt;T&gt;(withURL urlRequest: URLRequest, object: T) -&gt; AnyPublisher&lt;Void, Error&gt; where T: Encodable {

        return Just(object)
        .encode(encoder: JSONEncoder())
        .mapError {
            let error = self.classifyError($0)
            return error
        }
        .map { data -&gt; URLRequest in
            var request = urlRequest
            //BUILD REQUEST
            return request
        }
        .flatMap { request in
            let dataTaskPublisher: AnyPublisher&lt;URLSession.DataTaskPublisher.Output, URLSession.DataTaskPublisher.Failure&gt; = URLSession.DataTaskPublisher(request: request, session: .shared)

            return dataTaskPublisher
            .tryMap { try self.throwErrorOrContinue(data: $0, basedOnResponse: $1) }
            .decode(type: T.self, decoder: JSONDecoder())
            .mapError { return self.handle(error: $0, from: urlRequest, object: T.self) }
        }
        .eraseToAnyPublisher()
    }
</code></pre>
<p>And he tells me:</p>
<pre><code>Cannot convert return expression of type 'AnyPublisher&lt;Publishers.FlatMap&lt;_, Publishers.Map&lt;Publishers.MapError&lt;Publishers.Encode&lt;Just&lt;T&gt;, JSONEncoder&gt;, _&gt;, URLRequest&gt;&gt;.Output, Publishers.FlatMap&lt;_, Publishers.Map&lt;Publishers.MapError&lt;Publishers.Encode&lt;Just&lt;T&gt;, JSONEncoder&gt;, _&gt;, URLRequest&gt;&gt;.Failure&gt;' (aka 'AnyPublisher&lt;_.Output, _&gt;') 
to return type 'AnyPublisher&lt;Void, Error&gt;'
</code></pre>
<p>I tried some mapping but it didn't work and I have no idea what he wants from me. Maybe one of you knows the problem? Thanks :)</p>
","4906484","","","","","2020-09-08 07:00:50","Swift Combine return AnyPublisher<Void, Error> with FlatMap (POST Request)","<ios><swift><post><swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"63793261","1","64212326","","2020-09-08 11:47:35","","6","3078","<p>My data model property is declared in my table view controller, and the SwiftUI view is modally presented. I'd like the presented <code>Form</code> input to manipulate the data model. The resources I've found on data flow are just between SwiftUI views, and the resources I've found on UIKit integration are on embedding UIKit in SwiftUI rather than the other way around.</p>
<p>Furthermore, is there a good approach for a value type (in my case struct) data model, or would it be worth remodeling it as a class so that it's a reference type?</p>
","1294854","","1294854","","2020-10-03 21:48:24","2022-05-09 17:35:02","How do you share a data model between a UIKit view controller and a SwiftUI view that it presents?","<swift><swiftui><uikit><combine>","2","6","","","","CC BY-SA 4.0"
"63794722","1","63794873","","2020-09-08 13:14:14","","0","727","<p>Here is a pseudo code of what I need to achieve:</p>
<pre><code>func apiRequest1() -&gt; Future&lt;ResultType1, Error&gt; { ... }
func apiRequest2() -&gt; Future&lt;ResultType2, Error&gt; { ... }
func transform(res1: ResultType1, res2: ResultType2) -&gt; ResultType3 { ... }

func combinedApiRequests() -&gt; Future&lt;ResultType3, Error&gt; {
    (resultType1, resultType2) = execute apiRequest1() and apiRequest2() asynchronously
    resultType3 = transform(resultType1, resultType2)
    return a Future publisher with resultType3
}
</code></pre>
<p>How would <code>combinedApiRequests()</code> look?</p>
","945711","","","","","2020-09-08 13:23:00","Swift Combine framework multiple async request responses into one","<swift><zip><combine>","1","0","","","","CC BY-SA 4.0"
"63797060","1","63797546","","2020-09-08 15:28:08","","0","541","<p>I am trying to save Checkin time preferences of a user (to send them notification reminders). So far I've been able to save a Bool and string to UserDefaults but I'm unable to figure out how to save the <strong>time</strong> preference. Here's my UserSettings class to store the preferences.</p>
<pre><code>public class UserSettings: ObservableObject {
    
    
    @Published var eveningCheckin: Bool {
        didSet{
            UserDefaults.standard.set(eveningCheckin, forKey: &quot;eveningCheckin&quot;)
            print(&quot;Evening checkin toggle value in didSET to \(self.eveningCheckin)&quot;)
            
        }
    }
    
    @Published var eveningCheckinTime: Date {
        didSet{
            UserDefaults.standard.set(eveningCheckinTime, forKey: &quot;eveningCheckinTime&quot;)
            print(&quot;Evening checkin didSet to \(self.eveningCheckinTime)&quot;)
        }
    }
    
    
    init() {

        self.eveningCheckin = UserDefaults.standard.object(forKey: &quot;eveningCheckin&quot;) as? Bool ?? false
        self.eveningCheckinTime = UserDefaults.standard.object(forKey: &quot;eveningCheckinTime&quot;) as? Date ?? Date(timeIntervalSince1970: 64800)
        print(&quot;Evening checkin time init to \(self.eveningCheckinTime)&quot;)// --&gt; To debug
        print(&quot;Evening checkin toggle value in init to \(self.eveningCheckin)&quot;)
    }
}
</code></pre>
<p>I want to set this Evening checkin time up with a Time picker that SwiftUI provides like this. Here are my Settings and Timepicker views.</p>
<pre><code>import SwiftUI

struct SettingsMain: View {
    @ObservedObject var userSettings = UserSettings()
    @State private var showTimepickerEvening = false

    var body: some View {
        NavigationView{
            ScrollView {
                VStack {
                    //Evening checkins
                    Button(action: {
                        //Show 🌙 Evening time picker sheet
                        self.showTimepickerEvening.toggle()
                    }) {
                        HStack {
                            Text(&quot;\(userSettings.eveningCheckinTime.hour12):\(userSettings.eveningCheckinTime.minute0x) \(userSettings.eveningCheckinTime.amPM.lowercased()) &quot;)
                            Text(&quot;Change &gt;&quot;)
                        }
                    }
                    .sheet(isPresented: $showTimepickerEvening) {
                        //Sheet view with the Timepicker
                        TimePickerView(pickedTime: self.$userSettings.eveningCheckinTime)
                    }
                }
                .buttonStyle(PlainButtonStyle())
            }
            .navigationBarTitle(&quot;Preferences&quot;, displayMode: .inline)
        }
    }
}

struct TimePickerView: View {
    @Environment(\.presentationMode) var presentationMode: Binding&lt;PresentationMode&gt;
    @Binding var pickedTime: Date
    
    var body: some View {
        VStack {
            DatePicker(&quot;Checkin time&quot;, selection: $pickedTime, displayedComponents: .hourAndMinute)
            .labelsHidden()
            
            Button(action: {
                    //Dimiss. Should I actually update my UserDefaults here as well?
                self.presentationMode.wrappedValue.dismiss()
                }) {
                    ZStack {
                        ColorManager.buttonGrey
                        Text(&quot;Save time&quot;)
                            .font(.system(size: 20))
                            .fontWeight(.semibold)
                    }
                    .frame(height: 64)
                }
            .padding(.all)
            .buttonStyle(PlainButtonStyle())
        }
        .background(Color.white)
    }
}
</code></pre>
<p><strong>My problem is that the Time picker does setup the time into the @Published var BUT it get's reset with the init statement. It does not happen with the Bool value. Why??</strong></p>
<p>Here's the output from the print() statements above: Basically means that every time I'm trying to use the Datepicker to set the time -&gt; didSet does choose the new time but init() resets it back to default.</p>
<blockquote>
<p>Evening checkin didSet to 1970-01-01 12:12:00 +0000</p>
<p>Evening checkin time init to 1970-01-01 18:00:00 +0000</p>
<p>Evening checkin toggle value in init to true</p>
<p>Evening checkin didSet to 1970-01-01 12:13:00 +0000</p>
<p>Evening checkin time init to 1970-01-01 18:00:00 +0000</p>
<p>Evening checkin toggle value in init to true</p>
</blockquote>
","1441582","","4667835","","2020-09-08 15:57:47","2020-09-08 16:08:02","Saving Date/Time to UserDefaults through didSet on @Published var (from TimePicker component of SwiftUI)","<swift><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"63809164","1","63809412","","2020-09-09 09:54:54","","0","1577","<p>I have a StateController class:</p>
<pre><code>import Foundation
import Combine

class StateController: ObservableObject {
    
    // Array of subjects loaded in init() with StorageController
    @Published var subjects: [Subject]
    
    private let storageController = StorageController()
    
    init() {
        self.subjects = storageController.fetchData()
    }
    
    // MARK: - Computed properties
    
    // Array with all tasks from subjects, computed property
    var allTasks: [Task] {
        var all: [Task] = []
        
        for subject in subjects {
            all += subject.tasks
        }
        print(&quot;Computed property updated!&quot;)
        return all
    }

    var numberofCompletedTasks: Int {
        return subjects.map({$0.tasks.map({$0.isCompleted == true})}).count
    }
    
    var numberOfHighPriorityTasks: Int {
        return subjects.map({$0.tasks.map({$0.priority == 1})}).count
    }
    var numberOfMediumPriorityTasks: Int {
        return subjects.map({$0.tasks.map({$0.priority == 2})}).count
    }
    var numberOfLowPriorityTasks: Int {
        return subjects.map({$0.tasks.map({$0.priority == 3})}).count
    }
}
</code></pre>
<p>And a SwiftUI view:</p>
<pre><code>import SwiftUI

struct SmartList: View {
    
    // MARK: - Properties
    let title: String
    
    @EnvironmentObject private var stateController: StateController
    
    // MARK: - View body
    
    var body: some View {
        
        List(stateController.allTasks, id: \.taskID) { task in
            
            TaskView(task: task)
                .environmentObject(self.stateController)
            
        }.listStyle(InsetGroupedListStyle())
        .navigationTitle(LocalizedStringKey(title))
    }
}
</code></pre>
<p>When I update &quot;Task&quot; objects inside &quot;subjects&quot; @Published array, for example checking them as complete, SwiftUI should automatically update the view because computed properties are derived from @Published property of an ObservableObject (declared as @EnvironmentObject inside view) but it doesn't work.</p>
<p>How can I bind my SwiftUI view to computed properties derived from a @Published property??</p>
","8705504","","","","","2020-09-09 10:10:07","Computed property from @Published array of objects not updating SwiftUI view","<swift><swiftui><computed-properties>","1","0","","","","CC BY-SA 4.0"
"63821754","1","63821841","","2020-09-10 01:56:16","","2","291","<p>I don't understand why this doesn't compile. It does if I remove the <code>where</code> restriction from the <code>P</code> type.</p>
<pre><code>import Combine

protocol Foo {
    associatedtype P: Publisher where P.Output == Int
    var publisher: P { get }
}

struct Bar: Foo {
    var publisher: some Publisher {
        Just(1)
    }
}
</code></pre>
<p>The error says that <code>Type 'Bar' does not conform to protocol 'Foo'</code>. I guess it's because <code>publisher</code> return type is not just any <code>some Publisher</code>. But in SwiftUI, the <code>View</code> uses a similar approach, just that it doesn't have restrictions over the <code>View</code> type.</p>
<p>Is there any way I can make this code to compile?</p>
","737419","","5133585","","2020-09-10 02:27:05","2020-09-10 02:27:05","""some Protocol"" causes type to not conform to protocol","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"63848132","1","63849694","","2020-09-11 13:32:50","","1","435","<p>I'm struggling implementing the following navigation behavior:
From a list the user can select an item which triggers a detail view for this item. On this detail view there is an &quot;Add&quot; button in the navigation bar which opens a modal sheet for adding an other item.</p>
<p>Up to this point, everything works as expected.</p>
<p>But after adding the item, I want the detail view to show the new item. I tried to set the list selection to the id of the new item. This triggers the detail view to disappear, the list selects the new item and show the details for a very short time, then the detail view disappears again and the list is shown.</p>
<p>I've tried adding a bridged binding and let the list view not set the selection to nil, this solves the issue at first, but then the &quot;Back&quot; button isn't working anymore.</p>
<p>Please note: I want the &quot;Add&quot; button on the detail view and not on the list view as you would expect it.</p>
<p>Here's the full code to test:</p>
<pre><code>import Combine
import SwiftUI

struct ContentView: View {
    @ObservedObject private var state = AppState.shared
    
    var body: some View {
        NavigationView {
            List(state.items) {item in
                NavigationLink(destination: DetailView(item: item), tag: item.id, selection: self.$state.selectedId) {
                    Text(item.title)
                }
            }
            .navigationBarTitle(&quot;Items&quot;)
        }
    }
}

struct DetailView: View {
    var item: Item
    @State private var showForm = false

    var body: some View {
        Text(item.title)
            .navigationBarItems(trailing: Button(&quot;Add&quot;) {
                self.showForm = true
            })
            .sheet(isPresented: $showForm, content: { FormView() })
    }
}

struct FormView: View {
    @Environment(\.presentationMode) private var presentationMode
    private var state = AppState.shared

    var body: some View {
        Button(&quot;Add&quot;) {
            let id = self.state.items.count + 1
            self.state.items.append(Item(id: id, title: &quot;Item \(id)&quot;))
            self.presentationMode.wrappedValue.dismiss()
            
            self.state.selectedId = id
        }
    }
}

class AppState: ObservableObject {
    static var shared = AppState()

    @Published var items: [Item] = [Item(id: 1, title: &quot;Item 1&quot;)]
    @Published var selectedId: Int?

}

struct Item: Identifiable {
    var id: Int
    var title: String
}
</code></pre>
","10826194","","","","","2020-09-11 15:06:07","SwiftUI Navigation: How to switch detail view to a different item?","<swift><swiftui>","1","0","2","","","CC BY-SA 4.0"
"63851104","1","63904663","","2020-09-11 16:41:15","","0","444","<p>I am successful in saving the additional <code>firstName</code>, <code>lastName</code>, <code>email</code> and <code>gender</code> into a collection on Cloud Firestore.</p>
<p>I now want to be able to use and change this data in the settings screen of my app. Eg: if the user wants to change email. The issue is that the email is saved in Firebase Auth but is also saved in the <code>profiles</code> collection in Cloud Firestore. Can you change both at the same time?</p>
<p>Here is my SessionStore:</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine
import Firebase

class SessionStore: ObservableObject {
    
  @Published var profile: UserProfile?
  var didChange = PassthroughSubject&lt;SessionStore, Never&gt;()
  @Published var session: User? {didSet{self.didChange.send(self) }}
  var handle: AuthStateDidChangeListenerHandle?
    
  func listen() {
    handle = Auth.auth().addStateDidChangeListener({ (auth, user) in
      if let user = user {
        self.session = User(uid: user.uid, email: user.email)
      }
      else {
        self.session = nil
      }
    })    
  }
    
  private var profileRepository = UserProfileRepository()
   
  func signUp(email: String, password: String, firstName: String, lastName: String, gender: 
    String, completion: @escaping (_ profile: UserProfile?, _ error: Error?) -&gt; Void) {
    Auth.auth().createUser(withEmail: email, password: password) { (result, error) in
      if let error = error {
        print(&quot;Error signing up: \(error)&quot;)
        completion(nil, error)
        return
      }
            
      guard let user = result?.user else { return }
      print(&quot;User \(user.uid) signed up.&quot;)
            
      let userProfile = UserProfile(uid: user.uid, 
                                    email: user.email ?? &quot;&quot;, 
                                    firstName: firstName, 
                                    lastName: lastName, 
                                    gender: gender)
      self.profileRepository.createProfile(profile: userProfile) { (profile, error) in
        if let error = error {
          print(&quot;Error while fetching the user profile: \(error)&quot;)
          completion(nil, error)
          return
        }
        self.profile = profile
        completion(profile, nil)
      }
    }
  }
    
  func signIn(email: String, password: String, completion: @escaping (_ profile: UserProfile?, 
    _ error: Error?) -&gt; Void) {
    Auth.auth().signIn(withEmail: email, password: password) { (result, error) in
      if let error = error {
        print(&quot;Error signing in: \(error)&quot;)
        completion(nil, error)
        return
      }
            
      guard let user = result?.user else { return }
      print(&quot;User \(user.uid) signed in.&quot;)
            
      self.profileRepository.fetchProfile(userId: user.uid) { (profile, error) in
        if let error = error {
          print(&quot;Error while fetching the user profile: \(error)&quot;)
          completion(nil, error)
          return
        }
                
        self.profile = profile
        completion(profile, nil)
      }
    }
  }
    
  func signOut() {
    do {
      try Auth.auth().signOut()
      self.session = nil
      self.profile = nil
    }
    catch let signOutError as NSError {
      print(&quot;Error signing out: \(signOutError)&quot;)
    }
  }
    
  func unbind() {
    if let handle = handle {
      Auth.auth().removeStateDidChangeListener(handle)
    }
  }
    
  deinit {
    unbind()
  }
    
  struct User {
    var uid: String
    var email: String?
        
    init(uid: String, email: String?) {
      self.uid = uid
      self.email = email
    }
  }
}
</code></pre>
<p>My profile repository:</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine
import Firebase
import FirebaseFirestoreSwift

struct UserProfile: Codable {
  var uid: String
  var email: String
  var firstName: String
  var lastName: String
  var gender: String
}

class UserProfileRepository: ObservableObject {
  private var db = Firestore.firestore()
    
  func createProfile(profile: UserProfile, completion: @escaping (_ profile: UserProfile?, _ 
    error: Error?) -&gt; Void) {
    do {
      let _ = try db.collection(&quot;profiles&quot;).document(profile.uid).setData(from: profile)
      completion(profile, nil)
    }
    catch let error {
      print(&quot;Error writing to Firestore: \(error)&quot;)
      completion(nil, error)
    }
  }
    
  func fetchProfile(userId: String, completion: @escaping (_ profile: UserProfile?, _ error: 
    Error?) -&gt; Void) {
    db.collection(&quot;profiles&quot;).document(userId).getDocument { (snapshot, error) in
      let profile = try? snapshot?.data(as: UserProfile.self)
      completion(profile, error)
    }
  }
}
</code></pre>
<p>and Settings View:</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import FirebaseAuth
import Firebase

struct SettingsView: View {    
  @State var showEdit = false
  var genderOptions = [&quot;Male&quot;, &quot;Female&quot;, &quot;Other&quot;]
  @StateObject var viewModel = UserProfileRepository()
  @State var firstName: String = &quot;&quot;
  @State var lastNameName: String = &quot;&quot;
  @State var email: String = &quot;&quot;
  @State var gender: String = &quot;&quot;
    
  var body: some View {
    ScrollView {
      VStack {
        HStack {
          Text(&quot;Settings&quot;)
        }
        .padding()
                
        VStack {
          Spacer()
          HStack {
            Image(systemName: &quot;person.fill&quot;)
            if showEdit == true {
              TextField(&quot;First Name&quot;, text: $firstName)
                .autocapitalization(.words)
                .keyboardType(.default)
                .font(.subheadline)
            } 
            else {
              Text(&quot;&quot;)
                .font(.subheadline)
                .padding()
                .onTapGesture {
                  showEdit = true
                }
              }
            }
            HStack {
              Image(systemName: &quot;envelope.fill&quot;)
              if showEdit == true {
                TextField(&quot;Email&quot;, text: $email)
                  .autocapitalization(.none)
                  .keyboardType(.emailAddress)
                  .font(.subheadline)
              } 
              else {
                Text(&quot;&quot;)
                  .font(.subheadline)
                  .padding()
                  .onTapGesture {
                    showEdit = true
                  }
              }
              HStack {
                Image(systemName: &quot;figure.wave&quot;)
                if showEdit == true {
                  Picker(selection: $gender, label: Text(&quot;&quot;)) {
                    ForEach(genderOptions, id: \.self) {
                      Text($0)
                        .font(.footnote)
                    }
                  }
                  .pickerStyle(SegmentedPickerStyle())
                  .frame(maxWidth: .infinity)
                  .padding()
                }
                else {
                  Text(&quot;&quot;)
                    .font(.subheadline)
                    .padding()
                    .onTapGesture {
                      showEdit = true
                    }
                }
                Spacer()
              }
            }
            if showEdit == true {
              Image(systemName: &quot;checkmark&quot;)
                .onTapGesture{
                  showEdit.toggle()
                }
            }  
          }
          .onAppear {
          }
    }
  }
}

struct SettingsView_Previews: PreviewProvider {
  static var previews: some View {
    SettingsView()
  }
}
</code></pre>
","14159615","","281221","","2020-09-15 14:46:49","2020-09-15 15:09:59","How to save additional user data to Cloud Firestore?","<swift><firebase><google-cloud-firestore><firebase-authentication><swiftui>","1","1","","","","CC BY-SA 4.0"
"63857853","1","63858028","","2020-09-12 07:13:00","","1","369","<p>I'm trying to share the output of a sequence. Why I don't have any values in the second subscription after I add the <code>share</code> operator?</p>
<pre><code>import Combine

var cancellables = Set&lt;AnyCancellable&gt;()

let test = [1,2,3].publisher.print().share()

test.sink { value in
    print(&quot;Go&quot;)
}.store(in: &amp;cancellables)

test.sink { value in
    print(&quot;no go ?&quot;)
}.store(in: &amp;cancellables)
</code></pre>
<p>The output is:</p>
<pre><code>receive subscription: ([1, 2, 3])
request unlimited
receive value: (1)
Go
receive value: (2)
Go
receive value: (3)
Go
receive finished
</code></pre>
","588125","","","","","2020-09-12 07:33:42","Swift Combine share operator not working?","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"63863645","1","63864562","","2020-09-12 18:31:17","","1","1123","<p>With a Combine <code>Publisher</code>, I can use the following to call a closure whenever a value changes:</p>
<pre><code>let cancellable = x.sink { value in … }
</code></pre>
<p>How can I achieve the same behaviour with a variable marked <code>@State</code> or <code>@Binding</code>?</p>
","11636607","","","","","2022-04-13 21:05:36","How to attach subscriber to State or Binding in SwiftUI/Combine?","<swift><binding><state><combine><publisher>","1","3","","","","CC BY-SA 4.0"
"63905441","1","63907976","","2020-09-15 15:46:30","","2","752","<p>I have the following SwiftUI View:</p>
<pre><code>struct ProductView: View {
@ObservedObject var productViewModel: ProductViewModel


var body: some View {
    VStack {
        ZStack(alignment: .top) {
            if(self.productViewModel.product != nil) {
                URLImage(url: self.productViewModel.product!.imageurl, itemColor: self.productViewModel.selectedColor)
            }
            else {
                Image(&quot;loading&quot;)
            } 
        }
    }
}
</code></pre>
<p>that observes a ProductViewModel</p>
<pre><code>class ProductViewModel: ObservableObject {

@Published var selectedColor: UIColor = .white

@Published var product: Product?


private var cancellable: AnyCancellable!

init(productFuture: Future&lt;Product, Never&gt;) {

    self.cancellable = productFuture.sink(receiveCompletion: { comp in
            print(comp)
        }, receiveValue: { product in
            
            self.product = product
            print(self.product)  // this prints the expected product. The network call works just fine


        })


}
</code></pre>
<p>The Product is a Swift struct that contains several string properties:</p>
<pre><code>struct Product {
    let id: String
    let imageurl: String
    let price: String

}
</code></pre>
<p>It is fetched from a remote API. The service that does the fetching returns a Combine future and passes it to the view model like so:</p>
<pre><code>let productFuture = retrieveProduct(productID: &quot;1&quot;)
let productVM = ProductViewModel(productFuture: productFuture)
let productView = ProductView(productViewModel: productViewModel)


func retrieveProduct(productID: String) -&gt; Future&lt;Product, Never&gt;{
    
    let future = Future&lt;Product, Never&gt; { promise in

    //  networking logic that fetches the remote product,  once it finishes the success callback is invoked


        promise(.success(product))
    }

    return future
}
</code></pre>
<p>For the sake of brevity, I've excluded the networking and error handling logic since it is irrelevant for the case at hand. To reproduce this as quickly as possible, just initialize a mock product with some dummy values and pass it to the success callback with a delay like this:</p>
<pre><code>let mockproduct = Product(id: &quot;1&quot;, imageurl: &quot;https://exampleurl.com&quot;, price: &quot;$10&quot;)

DispatchQueue.main.asyncAfter(deadline: .now() + 2.0, execute: {
    promise(.success(mockproduct))
})
</code></pre>
<p>Once the product arrives over the network, it is assigned to the published product property.
The fetching works and the correct value is assigned to the published property. Obviously this happens after the view has been created since the network call takes some time. However, the View never updates even though the published object is changed.</p>
<p>When I pass the product directly through the View Model initializer rather than the future, it works as expected and the view displays the correct product.</p>
<p>Any suggestions on why the view does not react to changes in the state of the view model when it is updated asynchronously through the combine future?</p>
<p>EDIT: When I asked this question I had the ProductViewModel + ProductView nested inside another view. So basically the productview was only a part of a larger CategoryView. The CategoryViewmodel initialized both the ProductViewModel and the ProductView in a dedicated method:</p>
<pre><code>func createProductView() -&gt; AnyView {
    let productVM = productViewModels[productIndex]
    return AnyView(ProductView(productViewModel: productVM))
}
</code></pre>
<p>which was then called by the CategoryView on every update. I guess this got the Published variables in the nested ProductViewModel to not update correctly because the view hierarchy from CategoryView downwards got rebuilt on every update. Accordingly, the method createProductView got invoked on every new update, resulting in a completely new initialization of the ProductView + ProductViewModel.</p>
<p>Maybe someone with more experience with SwiftUI can comment on this.</p>
<p>Is it generally a bad idea to have nested observable objects in nested views or is there a way to make this work that is not an antipattern?</p>
<p>If not, how do you usually solve this problem when you have nested views that each have their own states?</p>
","4572811","","4572811","","2020-09-21 08:11:00","2020-09-21 08:11:00","SwiftUI View not updating on async change to published properties of Observed Object","<swiftui><combine><observedobject>","1","4","","","","CC BY-SA 4.0"
"63909394","1","63912928","","2020-09-15 20:27:34","","1","257","<p>I'm trying to bind properties together in the view and couldn't find anything better specifically for it. This is what I'm doing:</p>
<pre><code>struct ContentView: View {
    @ObservedObject var model: MyModel
    @State var selectedID: Int

    var body: some View {
        Picker(&quot;Choose&quot;, selection: $selectedID) {
              Text(&quot;Abc&quot;).tag(0)
              Text(&quot;Def&quot;).tag(1)
              Text(&quot;Ghi&quot;).tag(2)
        }
        .onChange(of: model.item?.selectedID) {
            selectedID = $0
        }
    }
}
</code></pre>
<p>Is there a better way to bind properties together?</p>
","235334","","","","","2020-09-16 04:01:36","Assign property values together in SwiftUI view?","<swift><swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"63911224","1","63913419","","2020-09-15 23:43:14","","1","797","<p>Do I need to dump using List and just load content into a Scrollview/HStack or is there a horizontal equivalent to stack? I would like to avoid having to set it up differently, but am willing todo so if there is no alternative... it just means recoding multiple other views.</p>
<p>current code for perspective:</p>
<pre><code>import SwiftUI
import Combine

struct VideoList: View {
@Environment(\.presentationMode) private var presentationMode
@ObservedObject private(set) var viewModel: ViewModel
@State private var isRefreshing = false

var btnBack : some View { Button(action: {
    self.presentationMode.wrappedValue.dismiss()
    }) {
        HStack {
        Image(&quot;Home&quot;) // set image here
            .aspectRatio(contentMode: .fit)
            .foregroundColor(.white)
        }
    }
}

var body: some View {
    NavigationView {
        List(viewModel.videos.sorted { $0.id &gt; $1.id}, id: \.id) { video in
            NavigationLink(
            destination: VideoDetails(viewModel: VideoDetails.ViewModel(video: video))) {
                VideoRow(video: video)
                
            }
        }
        .onPullToRefresh(isRefreshing: $isRefreshing, perform: {
            self.viewModel.fetchVideos()
        })
        .onReceive(viewModel.$videos, perform: { _ in
            self.isRefreshing = false
        })
    }
    .onAppear(perform: viewModel.fetchVideos)
    .navigationViewStyle(StackNavigationViewStyle())
    .navigationBarBackButtonHidden(true)
            .navigationBarItems(leading: btnBack)

}
}
</code></pre>
","14063013","","","","","2020-09-16 04:59:21","is it possible get List array to load horizontally in swiftUI?","<swift><swiftui>","1","2","","","","CC BY-SA 4.0"
"63926305","1","63927445","","2020-09-16 18:52:44","","9","4469","<p>How can I rewrite <code>ReactiveSwift/ReactiveCocoa</code> code using <code>Combine</code> framework? I attached screenshot what <code>combinePrevious</code> mean from docs.</p>
<pre><code>let producer = SignalProducer&lt;Int, Never&gt;([1, 2, 3]).combinePrevious(0)
producer.startWithValues { value in
    print(value) // print: (0, 1), (1, 2), (2, 3)
}
</code></pre>
<p><a href=""https://i.stack.imgur.com/EvfdN.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/EvfdN.png"" alt=""enter image description here"" /></a></p>
","11079607","","11079607","","2020-09-17 13:02:27","2021-04-17 00:22:32","Combine previous value using Combine","<swift><reactive-cocoa><combine><reactive-swift>","2","0","1","","","CC BY-SA 4.0"
"63939436","1","63950917","","2020-09-17 13:44:07","","7","3340","<p>Let’s say you are using the built-in <code>.store(in:)</code> method on AnyCancellable like so:</p>
<pre><code>private var subscriptions = Set&lt;AnyCancellable&gt;()

let newPhotos = photos.selectedPhotos
newPhotos
  .map { [unowned self] newImage in
    return self.images.value + [newImage]
  }
  .assign(to: \.value, on: images)
  .store(in: &amp;subscriptions)
</code></pre>
<p>If you have an app that does this a lot - are these removed when the publishers complete?</p>
<p>Also, If i decide to go with this approach instead:</p>
<pre><code>private var newPhotosSubscription: AnyCancellable?

self.newPhotosSubscription = newPhotos
  .map { [unowned self] newImage in
    self.images.value + [newImage]
  }
  .assign(to: \.value, on: images)
</code></pre>
<p>Everytime I call the method again, it override the AnyCancellable, what happens to the previous one? Does it still complete before being deallocated?</p>
","3457218","","3457218","","2020-09-17 14:01:39","2020-09-18 17:57:16","AnyCancellable.store(in:) with Combine","<swift><combine>","3","1","1","","","CC BY-SA 4.0"
"63964251","1","63965191","","2020-09-19 00:43:00","","1","433","<p>I am learning to develop apps for iOS from scratch. And I chose SwiftUI to make an app that gets the location of the user, get with geocode the city where he is and with that information obtained, show a list of items that belong to that city from a API.</p>
<p>So, I learned on one hand how to get the location and on the other hand how to display a list. My problem now is that w<strong>hen you run .onAppear(perform: loadData) to display my list, the &quot;city&quot; result is still empty</strong>. Evidently the value of city is obtained after I try to display the list of the city.</p>
<p>Both the algorithm I have to get the location and the one I have to show the list work separately.</p>
<p>So my code is:</p>
<pre><code>import SwiftUI

struct Response: Codable {
    var cinemas: [Cinema]
}

struct Cinema: Codable {
    var _id: String
    var cinemaName: String
    var cinemaCategory: String
}

struct HomeScreenView: View {
    
    @State var results = [Cinema]()
    
    @ObservedObject var lm = LocationManager()

    var latitude: String  {
        return(&quot;\(lm.location?.latitude ?? 0)&quot;) }
    var longitude: String { return(&quot;\(lm.location?.longitude ?? 0)&quot;) }
    var placemark: String { return(&quot;\(lm.placemark?.description ?? &quot;XXX&quot;)&quot;) }
    var status: String    { return(&quot;\(lm.status)&quot;) }
    
    var city: String {
        return(&quot;\(lm.placemark?.locality ?? &quot;empty&quot;)&quot;)
    }
    
    var body: some View {
        VStack {
            List(results, id: \._id) { item in
                VStack(alignment: .leading) {
                    Text(item.cinemaName)
                        .font(.headline)
                    Text(item.cinemaCategory)
                }
            }.onAppear(perform: loadData)
        }
        
    }
    
    func loadData() {
        guard let url = URL(string: &quot;https://mycinemasapi.com/cinemasbycity/\(self.city)&quot;) else {
            print(&quot;Invalid URL&quot;)
            return
        }
        
        let request = URLRequest(url: url)
        
        URLSession.shared.dataTask(with: request) { data, response, error in
            
            if let data = data {
                if let decodedResponse = try? JSONDecoder().decode(Response.self, from: data) {
                    // we have good data – go back to the main thread
                    DispatchQueue.main.async {
                        // update our UI
                        self.results = decodedResponse.cinemas
                    }
                    
                    // everything is good, so we can exit
                    return
                }
            }
            
            // if we're still here it means there was a problem
            print(&quot;Fetch failed: \(error?.localizedDescription ?? &quot;Unknown error&quot;)&quot;)
            
        }.resume()
    }
}
</code></pre>
<p><strong>UPDATE</strong>:
LocationManager class</p>
<pre><code>import Foundation
import CoreLocation
import Combine

class LocationManager: NSObject, ObservableObject {
  private let locationManager = CLLocationManager()
  private let geocoder = CLGeocoder()
  let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()

  @Published var status: CLAuthorizationStatus? {
    willSet { objectWillChange.send() }
  }

  @Published var location: CLLocation? {
    willSet { objectWillChange.send() }
  }

  override init() {
    super.init()

    self.locationManager.delegate = self
    self.locationManager.desiredAccuracy = kCLLocationAccuracyBest
    self.locationManager.requestWhenInUseAuthorization()
    self.locationManager.startUpdatingLocation()
  }

    
  @Published var placemark: CLPlacemark? {
    willSet { objectWillChange.send() }
  }

  private func geocode() {
    guard let location = self.location else { return }
    geocoder.reverseGeocodeLocation(location, completionHandler: { (places, error) in
      if error == nil {
        self.placemark = places?[0]
      } else {
        self.placemark = nil
      }
    })
  }
}

extension LocationManager: CLLocationManagerDelegate {
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        self.status = status
    }

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        self.location = location
        self.geocode()
    }
}
</code></pre>
","5770609","","5770609","","2020-09-19 01:58:24","2020-09-19 04:21:30","How to wait for another value to be assigned to run .onAppear?","<ios><swift><swiftui><cllocationmanager>","1","2","","","","CC BY-SA 4.0"
"63964776","1","64397436","","2020-09-19 02:39:55","","1","2310","<p>For a Store/Factory/ViewModel pattern using Combine and SwiftUI, I'd like a Store protocol-conforming class to expose a publisher for when specified model object(s) change internal properties. Any subscribed ViewModels can then trigger objectWillChange to display the changes.</p>
<p>(This is necessary because changes are ignored inside a model object <strong>that is passed by reference</strong>, so @Published/ObservableObject won't auto-fire for Factory-passed Store-owned models. It works to call objectWillChange in the Store and the VM, but that leaves out any passively listening VMs.)</p>
<p>That's a delegate pattern, right, extending @Published/ObservableObject to passed-by-reference objects? Combing through combine blogs, books, and docs hasn't triggered an idea to what's probably a pretty standard thing.</p>
<h2>Crudely Working Attempt</h2>
<p>I thought PassthroughSubject&lt;Any,Never&gt; would be useful if I exposed a VM's objectWillChange externally, but PassthroughSubject.send() will fire for every object within the model object. Wasteful maybe (although the ViewModel only fires its objectWillChange once).</p>
<p>Attaching a limiter (e.g., throttle, removeDuplicates) on <code>Ext+VM republishChanges(of myStore: Store)</code> didn't seem to limit the .sink calls, nor do I see an obvious way to reset the demand between the PassthroughSubject and the VM's sink... or understand how to attach a Subscriber to a PassthroughSubject that complies with the Protcols. Any suggestions?</p>
<p><strong>Store-Side</strong></p>
<pre class=""lang-swift prettyprint-override""><code>struct Library {
   var books: // some dictionary
}

class LocalLibraryStore: LibraryStore {
    private(set) var library: Library {
         didSet { publish() }
    }

    var changed = PassthroughSubject&lt;Any,Never&gt;()
    func removeBook() {}
}

protocol LibraryStore: Store { 
    var changed: PassthroughSubject&lt;Any,Never&gt; { get }
    var library: Library { get }
}


protocol Store {
    var changed: PassthroughSubject&lt;Any,Never&gt; { get }
}

extension Store {
    func publish() {
        changed.send(1)
        print(&quot;This will fire once.&quot;)
    }
}

</code></pre>
<p><strong>VM-Side</strong></p>
<pre class=""lang-swift prettyprint-override""><code>class BadgeVM: VM {
    init(store: LibraryStore) {
        self.specificStore = store
        republishChanges(of: jokesStore)
    }

    var objectWillChange = ObservableObjectPublisher() // Exposed {set} for external call
    internal var subscriptions = Set&lt;AnyCancellable&gt;()

    @Published private var specificStore: LibraryStore
    var totalBooks: Int { specificStore.library.books.keys.count }
}

protocol VM: ObservableObject {
    var subscriptions: Set&lt;AnyCancellable&gt; { get set }
    var objectWillChange: ObservableObjectPublisher { get set }
}

extension VM {
    internal func republishChanges(of myStore: Store) {
        myStore.changed
            // .throttle() doesn't silence as hoped
            .sink { [unowned self] _ in
                print(&quot;Executed for each object inside the Store's published object.&quot;)
                self.objectWillChange.send()
            }
            .store(in: &amp;subscriptions)
    }
}

class OtherVM: VM {
    init(store: LibraryStore) {
        self.specificStore = store
        republishChanges(of: store)
    }

    var objectWillChange = ObservableObjectPublisher() // Exposed {set} for external call
    internal var subscriptions = Set&lt;AnyCancellable&gt;()

    @Published private var specificStore: LibraryStore
    var isBookVeryExpensive: Bool { ... }
    func bookMysteriouslyDisappears() { 
         specificStore.removeBook() 
    }
}

</code></pre>
","11420986","","11420986","","2020-09-19 05:27:17","2020-10-17 00:18:55","When a Store's object is updated, auto-trigger objectWillChange.send() in ViewModel ObservableObjects","<swift><swiftui><delegates><reactive-programming><combine>","2","2","1","","","CC BY-SA 4.0"
"63974677","1","63975650","","2020-09-20 01:02:08","","3","2189","<p>I'm experiencing this really weird issue/bug with SwiftUI. In the <code>setupSubscription</code> method, I'm creating a subscription to <code>subject</code> and inserting it into the <code>cancellables</code> Set. And yet, when I print the count of <code>cancellables</code>, I get zero. How can the set be empty if I just inserted an element into it?
This is presumably why the <code>handleValue</code> method is not called when I tap on the button. Here's the full output from the console:</p>
<pre><code>init
begin setupSubscription
setupSubscription subject sink: receive subscription: (CurrentValueSubject)
setupSubscription subject sink: request unlimited
setupSubscription subject sink: receive value: (initial value)
handleValue: 'initial value'
setupSubscription: cancellables.count: 0
setupSubscription subject sink: receive cancel
sent value: 'value 38'
cancellables.count: 0
sent value: 'value 73'
cancellables.count: 0
sent value: 'value 30'
cancellables.count: 0
</code></pre>
<p>What am I doing wrong? why Is my subscription to <code>subject</code> getting cancelled? Why is <code>handleValue</code> not getting called when I tap the button?</p>
<pre><code>import SwiftUI
import Combine

struct Test: View {
    
    @State private var cancellables: Set&lt;AnyCancellable&gt; = []
    
    let subject = CurrentValueSubject&lt;String, Never&gt;(&quot;initial value&quot;)
    
    init() {
        print(&quot;init&quot;)
        self.setupSubscription()
    }
    
    var body: some View {
        VStack {
            Button(action: {
                let newValue = &quot;value \(Int.random(in: 0...100))&quot;
                self.subject.send(newValue)
                print(&quot;sent value: '\(newValue)'&quot;)
                print(&quot;cancellables.count:&quot;, cancellables.count)
            }, label: {
                Text(&quot;Tap Me&quot;)
            })
        }
    }
    
    func setupSubscription() {
        print(&quot;begin setupSubscription&quot;)
        
        let cancellable = self.subject
            .print(&quot;setupSubscription subject sink&quot;)
            .sink(receiveValue: handleValue(_:))
        
        self.cancellables.insert(cancellable)
        
        print(&quot;setupSubscription: cancellables.count:&quot;, cancellables.count) 
        // prints &quot;setupSubscription: cancellables.count: 0&quot;
    
    }
    
    
    func handleValue(_ value: String) {
        print(&quot;handleValue: '\(value)'&quot;)
    }
    
    
}
</code></pre>
","12394554","","12394554","","2020-09-20 01:22:33","2021-01-13 05:46:55","SwiftUI - @State property not updating","<swift><swiftui><combine>","2","0","1","","","CC BY-SA 4.0"
"63993196","1","63997654","","2020-09-21 13:23:25","","1","435","<p>I'm trying to mimic the Combine @Published property wrapper. My end goal is to create a new custom property wrapper (e.g. @PublishedAppStorage) of @Published with a nested @AppStorage.
So I've started just by trying to mimic the @Published.</p>
<p>My problem that it crashes when accessing the original value from within the sink block with the error:
<code>Thread 1: Simultaneous accesses to 0x600000103328, but modification requires exclusive access</code></p>
<p>I've spent days trying to find a way.</p>
<p>Here is my custom @DMPublished:</p>
<pre><code>@propertyWrapper
struct DMPublished&lt;Value&gt; {
    private let subject:CurrentValueSubject&lt;Value, Never&gt;
    
    init(wrappedValue: Value) {
        self.wrappedValue = wrappedValue
        self.subject = CurrentValueSubject(wrappedValue)
    }
    
    var wrappedValue: Value {
        willSet {
            subject.send(newValue)
        }
    }

    var projectedValue: AnyPublisher&lt;Value, Never&gt; {
        subject.eraseToAnyPublisher()
    }
}
</code></pre>
<p>The ObservableObject defining my properties:</p>
<pre><code>import Combine

public class DMDefaults: ObservableObject {
    
    static public let shared = DMDefaults()
    private init(){}
    
    @Published public var corePublishedString = &quot;dd&quot;
    @DMPublished public var customPublishedString = &quot;DD&quot;

}
</code></pre>
<p>And here is my test function:</p>
<pre><code>public func testSink()
{
    let gdmDefaults = DMDefaults.shared
    gdmDefaults.corePublishedString = &quot;ee&quot;; gdmDefaults.customPublishedString = &quot;EE&quot;
    
    gdmDefaults.corePublishedString = &quot;ff&quot;; gdmDefaults.customPublishedString = &quot;FF&quot;

    let coreSub = gdmDefaults.$corePublishedString.sink { (newVal) in
        print(&quot;coreSub: oldVal=\(gdmDefaults.corePublishedString) ; newVal=\(newVal)&quot;)
    }
    let custSub = gdmDefaults.$customPublishedString.sink { (newVal) in
        print(&quot;custSub: oldVal=\(gdmDefaults.customPublishedString) ; newVal=\(newVal)&quot;) // **Crashing here**
    }
    
    gdmDefaults.corePublishedString = &quot;gg&quot;; gdmDefaults.customPublishedString = &quot;GG&quot;

}
</code></pre>
<p>Will appreciate any help here... thanks...</p>
","14314783","","14314783","","2020-09-21 18:01:36","2022-07-19 17:30:46","Mimic Swift Combine @Published to create @PublishedAppStorage","<swift><combine>","1","2","1","","","CC BY-SA 4.0"
"64008010","1","64010838","","2020-09-22 10:39:21","","7","836","<p>I have tried out different ways by which @State can be updated in a SwiftUI view. There are approaches where a state change updates the related view whereas in some it does not.</p>
<h2><strong>@State change updates view</strong></h2>
<pre><code>@State var bodyText: String = &quot;Hello swift&quot;

var body: some View {
    Text(bodyText)
        .onAppear(perform: triggerTextUpdate)
}

private func triggerTextUpdate() {
    DispatchQueue.main.asyncAfter(deadline: .now()+3) {
        bodyText = &quot;Hello I am future swift&quot;
    }
}
</code></pre>
<h2><strong>@State changes not updating the view</strong></h2>
<p><strong>1. @State changed from initializer</strong></p>
<pre><code>@State var bodyText: String = &quot;Hello swift&quot;
init() {
    triggerTextUpdate()
}

var body: some View {
    Text(bodyText)
}

private func triggerTextUpdate() {
    DispatchQueue.main.asyncAfter(deadline: .now()+3) {
        bodyText = &quot;Hello I am future swift&quot;
    }
}
</code></pre>
<p><strong>2. @State changed from mutating function</strong></p>
<pre><code>@State var bodyText: String = &quot;Hello swift&quot;
private let somePublishSubject = PublishSubject&lt;String, Never&gt;()
private var subscriptions = Set&lt;AnyCancellable&gt;()

init() {
    setUpBinding()
}

var body: some View {
    Text(bodyText)
}

mutating func setUpBinding() {
    somePublishSubject.sink { [self] text in
        self.bodyText = text
    }.store(in: &amp;subscriptions)
}
</code></pre>
<p>When the <code>somePublishSubject</code> gets invoked and alters the <code>bodyText</code> state, the view does not update.</p>
<p>There is not much documentation on SwiftUI which makes understanding why the view updation and <code>@State</code> changes become more confusing. Any explanation for this behaviour will be really helpful.</p>
","5395919","","","","","2020-09-22 13:31:37","@State not updating SwiftUI view when changed in mutating function and initialiser","<ios><swift><swiftui>","1","2","","","","CC BY-SA 4.0"
"64012314","1","64012568","","2020-09-22 14:51:42","","0","444","<p>How can I move data to other screens with ObservableObject keyword?
I save the data on the first page to the variable I created with the keyword Published, but I cannot access this data on the second page.</p>
<p><strong>User Model</strong></p>
<pre><code>import Combine
struct User: Codable, Identifiable {
    
    var id = UUID()
    var name: String
    var surName: String
    
}
</code></pre>
<p><strong>UserDataStore</strong></p>
<pre><code>import Combine
class UserDataStore: ObservableObject {

    @Published var users: [User] = []
    
}
</code></pre>
<p><strong>ContentView</strong></p>
<p>I get information from the user with TextField objects on the contentView screen. After pressing the button, I add it to the array in the UserDataStore. I redirect to the detail page.</p>
<pre><code>struct ContentView: View {
    @State var name: String = &quot;&quot;
    @State var surName: String = &quot;&quot;
    @State var user = User(name: &quot;&quot;, surName: &quot;&quot;)
    @State var show: Bool = false
    
    @ObservedObject var userStore = UserDataStore()
    
    var body: some View {
        
        NavigationView {
            VStack(spacing: 50) {
                TextField(&quot;isim&quot;, text: $name)
                TextField(&quot;soyİsim&quot;, text: $surName)
                
                NavigationLink(
                    destination: DetailView(),
                    isActive: $show,
                    label: {
                        Button(action: {
                            self.user.name = name
                            self.user.surName = surName
                            self.userStore.users.append(user)
                            self.show = true
                            
                        }) {
                            Text(&quot;Kaydet&quot;)
                        }
                    })
            }
        }
    }
}
</code></pre>
<p><strong>DetailView</strong></p>
<p>On the detail page, I try to view the recorded information, but I cannot.</p>
<pre><code>struct DetailView: View {
    @ObservedObject var user = UserDataStore()
    
    var body: some View {
        ForEach(user.users) { item in
            Text(&quot;\(item.name)&quot;)
        }
    }
}
</code></pre>
","13125522","","","","","2020-09-22 15:09:11","Passing data with ObservableObject keyword","<swift><swiftui><observable><observedobject>","1","1","","","","CC BY-SA 4.0"
"64037789","1","64039597","","2020-09-24 00:00:30","","1","1244","<p>Below is my code for a countdown timer and circular progress bar.</p>
<p>I coded a function <code>makeProgressIncrement()</code> that determines
the progress per second from the timer total of <code>timeSelected</code>.</p>
<p>What is the best way to to update the <code>ProgressBar</code> so it increases with the countdown timer publisher?</p>
<p>Should I use an <code>onReceive</code> method?</p>
<p>Any help is greatly appreciated.</p>
<p><strong>ContentView</strong></p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {

@StateObject var timer = TimerManager()
@State var progressValue : CGFloat = 0

var body: some View {
    
    ZStack{
        VStack {
            ZStack{
                
                ProgressBar(progress: self.$progressValue)
                    .frame(width: 300.0, height: 300)
                    .padding(40.0)
              
                VStack{
                    
                    Image(systemName: timer.isRunning ? &quot;pause.fill&quot; : &quot;play.fill&quot;)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: 80, height: 80)
                        .foregroundColor(.blue)
                        .onTapGesture{
                            timer.isRunning ? timer.pause() : timer.start()
                        }
                }
            }

            Text(timer.timerString)
                .onAppear {
                    if timer.isRunning {
                        timer.stop()
                    }
                }
                .padding(.bottom, 100)
            
            
            Image(systemName: &quot;stop.fill&quot;)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(width: 35, height: 35)
                .foregroundColor(.blue)
                .onTapGesture{
                    timer.stop()


                }
            }
        }
    }
 }
</code></pre>
<p><strong>ProgressBar</strong></p>
<pre><code>struct ProgressBar: View {
    @Binding var progress: CGFloat
    
    var body: some View {
        ZStack {
            Circle()
                .stroke(lineWidth: 20.0)
                .opacity(0.3)
                .foregroundColor(Color.blue)
            
            Circle()
                .trim(from: 0.0, to: CGFloat(min(self.progress, 1.0)))
                .stroke(style: StrokeStyle(lineWidth: 20.0, lineCap: .round, lineJoin: .round))
                .foregroundColor(Color.blue)
                .rotationEffect(Angle(degrees: 270.0))
                .animation(.linear)
            
        }
    }
}
</code></pre>
<p><strong>TimerManager</strong></p>
<pre><code>class TimerManager: ObservableObject {
    
    /// Is the timer running?
    @Published private(set) var isRunning = false
    
    /// String to show in UI
    @Published private(set) var timerString = &quot;&quot;
    
    /// Timer subscription to receive publisher
    private var timer: AnyCancellable?
    
    /// Time that we're counting from &amp; store it when app is in background
    private var startTime: Date? { didSet { saveStartTime() } }
    
    var timeSelected: Double = 30
    var timeRemaining: Double = 0
    var timePaused: Date = Date()
    var progressIncrement: Double = 0
    
    init() {
        startTime = fetchStartTime()
        
        if startTime != nil {
            start()
        }
    }
}

// MARK: - Public Interface

extension TimerManager {

    func start() {
     
        timer?.cancel()               
        
        if startTime == nil {
            startTime = Date()
        }
        
        timerString = &quot;&quot;
        
        timer = Timer
            .publish(every: 0, on: .main, in: .common)
            .autoconnect()
            .sink { [weak self] _ in
                guard
                    let self = self,
                    let startTime = self.startTime
                else { return }
                
                let now = Date()
                let elapsedTime = now.timeIntervalSince(startTime)
                      
                self.timeRemaining = self.timeSelected - elapsedTime
                                    
                guard self.timeRemaining &gt; 0 else {
                    self.stop()
                    return
                }
                self.timerString = String(format: &quot;%0.1f&quot;, self.timeRemaining)
            }
        isRunning = true
    }
    
    func stop() {
        timer?.cancel()
        timeSelected = 300
        timer = nil
        startTime = nil
        isRunning = false
        timerString = &quot; &quot;
    }
    
    func pause() {
        timeSelected = timeRemaining
        timer?.cancel()
        startTime = nil
        timer = nil
        isRunning = false
    }
    
    func makeProgressIncrement() -&gt; CGFloat{
        
        progressIncrement = 1 / timeSelected
        
        return CGFloat(progressIncrement)
        
    }        
}

private extension TimerManager {

    func saveStartTime() {
        if let startTime = startTime {
            UserDefaults.standard.set(startTime, forKey: &quot;startTime&quot;)
        } else {
            UserDefaults.standard.removeObject(forKey: &quot;startTime&quot;)
        }
    }
    
    func fetchStartTime() -&gt; Date? {
        UserDefaults.standard.object(forKey: &quot;startTime&quot;) as? Date
    }
}
</code></pre>
","12349248","","","","","2020-09-25 00:03:06","Circular progress bar for a countdown timer publisher SwiftUI","<timer><swiftui><progress-bar><combine>","1","2","","","","CC BY-SA 4.0"
"64038413","1","64039228","","2020-09-24 01:45:23","","0","28","<p>The following call stack is copied from code console. <code>s4Link22getPersistentContainerSo012NSPersistentD0CyF</code> contains some unreadable character like <code>s4</code>, <code>22</code>. Does it can be replaced with original path?</p>
<blockquote>
<p>Main Thread Checker: UI API called on a background thread:
-[UIApplication delegate] PID: 5202, TID: 471753, Thread name: (none), Queue name: NSOperationQueue 0x7fd76fc0f2d0 (QOS: UNSPECIFIED), QoS: 0
Backtrace: 4   Link                                0x000000010d0d4f13
$s4Link22getPersistentContainerSo012NSPersistentD0CyF + 67 5   Link<br />
0x000000010d0370dd $s4Link10DataSourceCACycfc + 29 6   Link<br />
0x000000010d036fd1 $s4Link10DataSourceCACycfC + 33 7   Link<br />
0x000000010d0ca419
$s4Link10DomainDataCACycfc7Combine12AnyPublisherVyytAA13ResponseErrorVGycfU1_</p>
<ul>
<li>105 8   Link                                0x000000010d0ca560 $s7Combine12AnyPublisherVyyt4Link13ResponseErrorVGIego_ytAGIegnr_TR +
16 9   Link                                0x000000010d0ca5b1
$s7Combine12AnyPublisherVyyt4Link13ResponseErrorVGIego_ytAGIegnr_TRTA</li>
<li>17 10  Combine                             0x00007fff235ad683 $s7Combine10PublishersO7FlatMapV5Outer33_E91C3F00A6DFAAFEA2009FAF507AE039LLC7receiveyAA11SubscribersO6DemandV6OutputQy_F</li>
<li>131 11  Combine                             0x00007fff235af170 $s7Combine10PublishersO7FlatMapV5Outer33_E91C3F00A6DFAAFEA2009FAF507AE039LLCy_xq__qd__GAA10SubscriberA2aJP7receiveyAA11SubscribersO6DemandV5InputQzFTW + 16 12  Combine                             0x00007fff235ac641 $s7Combine10PublishersO7FlatMapV5Outer33_E91C3F00A6DFAAFEA2009FAF507AE039LLC12receiveInneryAA11SubscribersO6DemandV6OutputQz_SitF</li>
<li>241 13  Combine                             0x00007fff235ac544 $s7Combine10PublishersO7FlatMapV5Outer33_E91C3F00A6DFAAFEA2009FAF507AE039LLC4SideV7receiveyAA11SubscribersO6DemandV6OutputQzF</li>
<li>20 14  Combine                             0x00007fff23590b60 $s7Combine10PublishersO3MapV5Inner33_5A6CD15A64659A6248DAF677D4BB6188LLV7receiveyAA11SubscribersO6DemandV6OutputQzF</li>
<li>144 15  Combine                             0x00007fff235913b1 $s7Combine10PublishersO6TryMapV5Inner33_5A6CD15A64659A6248DAF677D4BB6188LLC7receiveyAA11SubscribersO6DemandV6OutputQzF</li>
<li>305 16  Combine                             0x00007fff23591940 $s7Combine10PublishersO6TryMapV5Inner33_5A6CD15A64659A6248DAF677D4BB6188LLCy_xq__qd__GAA10SubscriberA2aJP7receiveyAA11SubscribersO6DemandV5InputQzFTW + 16 17  Combine                             0x00007fff23585da3 $s7Combine10PublishersO12HandleEventsV5Inner33_9464E9048FC4C9C669F954B681B5AD45LLC7receiveyAA11SubscribersO6DemandV6OutputQzF</li>
<li>243 18  Combine                             0x00007fff23586060 $s7Combine10PublishersO12HandleEventsV5Inner33_9464E9048FC4C9C669F954B681B5AD45LLCy_x_qd__GAA10SubscriberA2aJP7receiveyAA11SubscribersO6DemandV5InputQzFTW</li>
<li>16 19  libswiftFoundation.dylib            0x00007fff5158d9b4 $sSo12NSURLSessionC10FoundationE17DataTaskPublisherV5Inner33_1AA038E5228015E36E90CFE2C93D33C4LLC14handleResponse4data8response5erroryAC0C0VSg_So13NSURLResponseCSgs5Error_pSgtF</li>
<li>580 20  libswiftFoundation.dylib            0x00007fff5158df22 $s10Foundation4DataVSgSo13NSURLResponseCSgs5Error_pSgIegggg_So6NSDataCSgAGSo7NSErrorCSgIeyByyy_TR</li>
<li>162 21  CFNetwork                           0x00007fff22f5a4d0 CFNetwork + 38096 22  CFNetwork<br />
0x00007fff22f6d740 _CFHTTPMessageSetResponseProxyURL + 17217 23
Foundation                          0x00007fff2592128c
<strong>NSBLOCKOPERATION_IS_CALLING_OUT_TO_A_BLOCK</strong> + 7 24  Foundation                          0x00007fff259211ad -[NSBlockOperation main] + 80 25  Foundation<br />
0x00007fff259240dc <strong>NSOPERATION_IS_INVOKING_MAIN</strong> + 17 26
Foundation                          0x00007fff259203ee -[NSOperation
start] + 731</li>
</ul>
</blockquote>
","674199","","","","","2020-09-24 03:45:11","The call stack in console contains unreadable character","<ios><swift><xcode>","1","0","","","","CC BY-SA 4.0"
"64046770","1","64048437","","2020-09-24 12:47:08","","0","686","<p>I don't quite understand the pattern of waiting to retrieve data from any async call (any: network, timer, any call that executes asynchronously and I have to wait to perform another one) and use it in synchronously in a different place (how to chain to operations. I saw examples using flatmap by they referred to 2 web calls. In this case I have to retrieve data from the web (a session Id), and save it to further use (it lasts an hour). I read about Operations, DispatchGroups, and don't quite get them to work in here.
I have a simple class that gets data from a web service, I have to wait till its downloaded, and save it.</p>
<pre><code>import Foundation
import Combine
import CoreData

struct SessionId:Codable {
    
    let key:String?
    let dateTime:Date?
    
}

class ColppyModel {
    
    var session:SessionId?
        
    var key:String?
    var cancellable:AnyCancellable?
    
    init() {
        print(&quot;saving&quot;)
        let sess = SessionId(key: &quot;1&quot;, dateTime: DateComponents(calendar:Calendar(identifier: .gregorian), year:2020, month:1, day:1).date)
        guard let data = try? JSONEncoder().encode(sess) else {return}
        let defaults = UserDefaults.standard
        defaults.set(data, forKey: &quot;sessionIdKey&quot;)
        print(&quot;Saved \(sess)&quot;)
    }
    
     func getSessionKey(){
        
        let requestData = ColppyAPIRequests.createSessionIdRequestData()
        cancellable = ColppyAPI.sessionKeyRequest(sessionKeyJsonData: requestData)
            .replaceError(with: nil)
            .map{$0?.response?.data?.claveSesion}
            .receive(on: DispatchQueue.global(qos: .userInteractive))
            .sink(receiveValue: { (clave) in
                let data = try! JSONEncoder().encode(SessionId(key: clave!, dateTime: Date()))
                UserDefaults.standard.set(data, forKey: &quot;sessionIdKey&quot;)
            })
    }
    
    
     func getSessionIDFromUserDefaults() -&gt; SessionId? {
        let defaults = UserDefaults.standard
        let data = defaults.data(forKey: &quot;sessionIdKey&quot;)
        guard let safeData = data else { return nil }
        guard let sessionId = try? JSONDecoder().decode(SessionId.self, from: safeData) else {return nil}
        return sessionId
    }
    
}
</code></pre>
<p>And I use it in and SwiftUI View in this way</p>
<pre><code>import SwiftUI

struct ContentView: View {
    
    let ss = ColppyModel()
    
    var body: some View {
        Text(&quot;Press&quot;)
            .onTapGesture {
                self.getInvoices()
        }
        
    }
    
    private  func getInvoices() {
        let id = ss.getSessionIDFromUserDefaults()
        print(id)

        ss.getSessionKey()
        print(ss.getSessionIDFromUserDefaults())
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        return ContentView()
    }
}
</code></pre>
<p>The first time I click I get</p>
<p><a href=""https://i.stack.imgur.com/81JBB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/81JBB.png"" alt=""enter image description here"" /></a></p>
<p>The second time I click I get</p>
<p><a href=""https://i.stack.imgur.com/JM7sL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JM7sL.png"" alt=""enter image description here"" /></a></p>
<p>The correct item saved.</p>
<p>How can I do to wait till the data (string in this case) is retrieved from the server and saved to fetch it from the store correctly?</p>
<p>Really I don't quite get the pattern in combine.</p>
<p>Thanks a lot</p>
","2660129","","","","","2020-09-24 14:17:00","Swift: Chaining to async functions and waiting to perform another one","<ios><swift><xcode>","1","2","","","","CC BY-SA 4.0"
"64054468","1","64056031","","2020-09-24 21:11:21","","1","75","<p>I have a class called SocialMealplan that looks like the following:</p>
<pre><code>public class SocialMealplan : Identifiable, ObservableObject {
    public var id : String {
        return owner.id
    }
    @Published public var owner : YKUser
    @Published public var mealplan : Mealplan
    
    init(owner : YKUser, mealplan : Mealplan) {
        self.owner = owner
        self.mealplan = mealplan
    }
}
</code></pre>
<p>I then have the following code:</p>
<pre><code>
struct MealPlanView: View {

    @ObservedObject var currentMealplan: SocialMealplan = SocialMealplan(owner: YKUser.none, mealplan: Mealplan.none)

    var body: some View {
    /* ... */

        ForEach(self.currentMealplan.mealplan.meals, id: \.self) { (meal) in
            VStack {
                NavigationLink(destination: SelectRecipeView(completion: self.updatedMealplan, date: meal.date)) {
                    MealplanRow(meal: .constant(meal))
                }
            }
        }.onAppear {
            self.refreshMealplan()
        }

    /* ... */
    }

    func refreshMealplan() {
        // Get the mealplan from the server
        self.currentMealplan.mealplan = newMealplan
    }
}
</code></pre>
<p>The problem is that when I run this code it gets the mealplan, but when it tries to assign the variable nothing happens. refreshMealplan is called and the variable is assigned, but nothing changes on the UI and the view doesn't refresh to reflect the new data.</p>
<p>(Neither does anything happen when I reassign the owner variable)</p>
","4464283","","","","","2020-09-25 00:15:51","SwiftUI - ObservableObject doesn't cause update","<swift><xcode><swiftui><state><combine>","1","0","","","","CC BY-SA 4.0"
"64056134","1","64056767","","2020-09-25 00:26:54","","0","461","<p>I tried to use <a href=""https://blckbirds.com/post/how-to-navigate-between-views-in-swiftui-by-using-an-environmentobject/"" rel=""nofollow noreferrer"">this</a> method (see link attached) in a new Xcode 12 project as a way to create a login page for a SwiftUI app, but I had the Problem not knowing what to add to the main App struct. I'm still a beginner and tried adding <code>ContentView().environmentObject(ViewRouter())</code> to the WindowGroup in the main app struct. Am I totally wrong or why doesn't Xcode build the view? Can somebody help?
Below the working code snippet:</p>
<pre><code>import SwiftUI
import Foundation
import Combine

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?


    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(rootView: MotherView().environmentObject(ViewRouter()))
            self.window = window
            window.makeKeyAndVisible()
        }
    }
. . .
}

class ViewRouter: ObservableObject {
    let objectWillChange = PassthroughSubject&lt;ViewRouter,Never&gt;()
    var currentPage: String = &quot;page1&quot; {
        didSet {
            withAnimation() {
                objectWillChange.send(self)
            }
        }
    }
}

struct MotherView : View {
    @EnvironmentObject var viewRouter: ViewRouter
    var body: some View {
        VStack {
            if viewRouter.currentPage == &quot;page1&quot; {
                ContentViewA()
            } else if viewRouter.currentPage == &quot;page2&quot; {
                ContentViewB()
                    .transition(.scale)
            }
        }
    }
}

struct ContentViewA : View {
    @EnvironmentObject var viewRouter: ViewRouter
    var body: some View {
        Button(action: {self.viewRouter.currentPage = &quot;page2&quot;}) {
            Text(&quot;Login&quot;)
        }
    }
}

struct ContentViewB : View {
    
    @EnvironmentObject var viewRouter: ViewRouter
    
    var body: some View {
        Button(action: {self.viewRouter.currentPage = &quot;page1&quot;}) {
            Text(&quot;Logout&quot;)
        }
    }
}
</code></pre>
<p>Now I want to substitute the SceneDelegate in the Xcode 12 style, but the following doesn't work. Any idea why?</p>
<pre><code>@main
struct TestApp: App {
    var body: some Scene {
        WindowGroup {
            MotherView().environmentObject(ViewRouter())
        }
    }
}
</code></pre>
","13104338","","13104338","","2020-09-25 01:33:34","2020-09-25 02:37:59","Use ViewRouter in SwiftUI Project in Xcode 12","<swift><swiftui><xcode12><environmentobject>","1","2","","","","CC BY-SA 4.0"
"64092557","1","64092607","","2020-09-27 19:38:09","","2","3189","<p>I have a problem when I want to show an Image from a URL. I created a class for downloading data and publishing the data forward - <code>ImageLoader</code>:</p>
<pre><code>class ImageLoader: ObservableObject {
    var didChange = PassthroughSubject&lt;Data, Never&gt;()
    var data = Data() {
        didSet {
            didChange.send(data)
        }
    }
    
    func loadData(from urlString: String?) {
        if let urlString = urlString {
            guard let url = URL(string: urlString) else { return }
            let task = URLSession.shared.dataTask(with: url) { data, response, error in
                guard let data = data else { return }
                DispatchQueue.main.async {
                    self.data = data
                }
            }
            task.resume()
        }
    }
}
</code></pre>
<p>Therefore, I use it inside a <code>ImageView</code> struct which I use inside my screen.</p>
<pre><code>struct ImageView: View {
    var urlString: String
    @ObservedObject var imageLoader: ImageLoader = ImageLoader()
    @State var image: UIImage = UIImage(named: &quot;homelessDogsCats&quot;)!

    var body: some View {
        ZStack() {
            Image(uiImage: image)
                .resizable()
                .onReceive(imageLoader.didChange) { data in
                    self.image = UIImage(data: data) ?? UIImage()
            }
        }.onAppear {
            self.imageLoader.loadData(from: urlString)
        }
    }
}
</code></pre>
<p>My problem is that if I just run my project, the image doesn't change and by default appears only <code>image UIImage(named: &quot;homelessDogsCats&quot;)</code>.</p>
<p>If I add a breakpoint inside</p>
<pre><code>onAppear { 
    self.imageLoader.loadData(from: urlString) 
}
</code></pre>
<p>and  just step forward, the image is showing.</p>
<p>I have the same problem in another view which usually doesn't display the <code>Image</code> from URL, but sometimes it does.</p>
","13637073","","8697793","","2020-09-27 21:34:38","2021-08-30 18:51:57","SwiftUI Image from URL not showing","<swift><swiftui>","2","0","","","","CC BY-SA 4.0"
"64093825","1","64094607","","2020-09-27 22:18:17","","0","355","<p>I am trying to implement Networking with Combine Framework and I am able to fetch data from server using following code but I am facing an issue when there is no data returned from the server but the request was successful.</p>
<pre><code>   return URLSession.shared.dataTaskPublisher(for: request)
      .tryMap { response in
         print(response)
        guard let httpURLResponse = response.response as? HTTPURLResponse, 200..&lt;299 ~= httpURLResponse.statusCode  else {
           throw CustomError.serverError
         }
         if response.data.isEmpty &amp;&amp; 200..&lt;299 ~= httpURLResponse.statusCode {
            //HOW TO HANDLE IF if there is no Data from server but request has been processed successfully
         }
         return response.data
        }
        .decode(type: R.self, decoder: decoder)
        .mapError{CustomError.map(error: $0)}
        .receive(on: RunLoop.main)
        .eraseToAnyPublisher()
}
</code></pre>
<p>Can you please guide me on how to handle success response when there is no Data returned by the server.</p>
<p>Let me know if I have to elaborate on my question.</p>
","3173478","","","","","2020-09-28 00:48:10","Handle success response when there is no Data returned by the server with Combine","<ios><swift><combine>","1","6","","","","CC BY-SA 4.0"
"64127314","1","64127729","","2020-09-29 20:39:16","","0","45","<p>I´m new in SwiftUI and I would know how can I get the variable &quot;Selection&quot; from ContentView into SettingView in my &quot;special&quot; case with <strong>UserDefaults.standard.integer</strong>. I think with @Binding is it not possible, right?</p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    
    @State var Selection = UserDefaults.standard.integer(forKey: &quot;Picker&quot;)
    @State var Detail = false
    
    var body: some View {
        VStack {
        Button(action: {
            self.Detail.toggle()
        }) {
            Text(&quot;click&quot;)
        }.sheet(isPresented: $Detail) {
            SettingView(showSheetView: self.$Detail)
        }
        
        Picker(&quot;&quot;, selection: $Selection) {
            Text(&quot;Selection1&quot;).tag(0)
            Text(&quot;Selection2&quot;).tag(1)
            } .pickerStyle(SegmentedPickerStyle()).padding(.horizontal, 89)
            .onReceive(Just(Selection)) {
                UserDefaults.standard.set($0, forKey: &quot;Picker&quot;)
            }
        }
    }
}

struct SettingView: View {
   
    @Binding var showSheetView: Bool
    
    var body: some View {
        NavigationView {
                Text(&quot;Test&quot;)
                .navigationBarTitle(Text(&quot;Select something&quot;))
                .navigationBarItems(trailing: Button(action: {
                    self.showSheetView = false
                }) {
                    Text(&quot;Ok&quot;)
                        .bold()
                        
            })
        }
    }
}
</code></pre>
","14270161","","14270161","","2020-09-29 21:00:25","2020-09-29 21:13:21","How do I get a variable from a ""higher view"" into a ""ower view"" in SwiftUI?","<swift><swiftui>","1","4","","","","CC BY-SA 4.0"
"64127685","1","64166263","","2020-09-29 21:08:58","","2","164","<p>I have an app with Swift/SwiftUI. I use the <code>ObservableObject</code> and <code>JSONDecoder</code> to get values from my Node.JS Express API to show within my app:</p>
<pre><code>struct DevicesList: Decodable {
    var data: [PhilipsHueDevicesListEntry]
}

struct DevicesListEntry: Decodable {
    var ID: String
    var Name: String
    var State: Bool
    var Reachable: Bool
}
</code></pre>
<p>Class that gets the values from the API and puts into the above object:</p>
<pre><code>class GetDevices: ObservableObject {

var didChange = PassthroughSubject&lt;GetDevices, Never&gt;()

var DevicesList = DevicesList(data: []){
    didSet {
        didChange.send(self)
    }
}

init(){
    let keychain = KeychainSwift()
    let authToken = keychain.get(&quot;authToken&quot;)!
    let bridgeID = keychain.get(&quot;hubID&quot;)!
    var request = URLRequest(url: URL(string: GlobalVariables.HUEGetDevices)!)
    request.httpMethod = HTTPMethod.get.rawValue
    let headers = [
        &quot;auth-token&quot;: authToken,
        &quot;bridgeID&quot;: bridgeID,
        &quot;Content-Type&quot;: &quot;application/json&quot;]
    request.allHTTPHeaderFields = headers
    URLSession.shared.dataTask(with: request) { (data, _, _) in
        guard let data = data else {return}
        let devices = try! JSONDecoder().decode(DevicesList.self, from: data)
        DispatchQueue.main.async {
            self.DevicesList = devices
        }
    }.resume()
}
</code></pre>
<p>Then to show within my Main screen of my app:</p>
<pre><code>@State var devices = GetDevices()

ForEach(devices.DevicesList.data, id: \.ID) { device in
                        ZStack{
                            Rectangle()
                                .cornerRadius(5)
                                .frame(width: 100, height: 100)
                                .foregroundColor(Color.orange)
                            VStack(alignment: .leading){
                                Text(device.Name)
                                    .multilineTextAlignment(.center)
                                    .frame(width: 100, height: 100)
                            }
                        }
....
</code></pre>
<p>Everything works perfectly well, until I swipe up to send the app to the background (which I assume runs the <code>init()</code> function again to update the observableObject). I get this error:</p>
<pre><code>_http_outgoing.js:503
throw new errors.Error('ERR_HTTP_HEADERS_SENT', 'set');
^

Error [ERR_HTTP_HEADERS_SENT]: Cannot set headers after they are sent to the client
    at validateHeader (_http_outgoing.js:503:11)
    at ServerResponse.setHeader (_http_outgoing.js:510:3)
    at ServerResponse.header (/app-c/node_modules/express/lib/response.js:771:10)
    at ServerResponse.send (/app-c/node_modules/express/lib/response.js:170:12)
    at ServerResponse.json (/app-c/node_modules/express/lib/response.js:267:15)
    at ServerResponse.send (/app-c/node_modules/express/lib/response.js:158:21)
    at lightDataCallbackFunction (/app-c/app.js:185:32). // &lt;----- This is where the error occurs in my js file
    at Socket.socket.on (/app-c/app.js:121:7)
    at Socket.emit (events.js:180:13)
    at /app-c/node_modules/socket.io/lib/socket.js:528:12
    at process._tickCallback (internal/process/next_tick.js:176:11) 
</code></pre>
<p>My JS file to which the error occurs:</p>
<pre><code>lightDataCallbackFunction = function(data){
    if(data['socketID'] == socketID){
      if(data['code'] == '208'){
        return res.status(200).send(data) // &lt;--- OCCURS HERE
      }else{
        return res.status(400).send({&quot;data&quot;: &quot;&quot;, &quot;code&quot;: &quot;209&quot;, &quot;message&quot;: data['message']})
      }
    }
  }
</code></pre>
<p>I genuinely have no idea why this is the case and what is happening. My best guess would be that when I send the app to the background, the observable object instance is ran again and somehow the same server-side code tries to send another (same) response to my app? I even return the response to exit the function, so I do not see why this is happening?</p>
<p>EDIT:</p>
<p>I have tried MwcsMac comment from below, he mentioned that he usually just doesn't use the <code>init()</code> function at all, instead he moves the code that would go inside the <code>init()</code> function and puts it inside a new function, then calls that function when the view in question loads via <code>.onAppear()</code>.</p>
<p>I have tried that, however it either doesn't run the function at all for whatever reason - or it just doesn't update my view (populating my <code>ForEach</code> loop within my SwiftUI code.</p>
","12647189","","12647189","","2020-10-01 17:53:53","2020-10-02 04:44:43","'Can't set headers after they are sent to the client' NodeJS error when iOS Swift app is sent to the background","<javascript><ios><node.js><swift><swiftui>","1","5","","","","CC BY-SA 4.0"
"64130063","1","64130833","","2020-09-30 02:32:25","","1","78","<p>I just converted my app to the SwiftUI framework. The front end works great, but I am having a huge issue - I can't figure out how to fetch my data from a user UITextField entry and update my view. This project has a lot of code, but I've condensed it into a few files and will share only a portion since the other portions of the app are structured in a similar manner. I would really appreciate help anyone can offer. I intend to replace many of the strings in the <code>METARView</code> Text labels with variables based on the decoded API call data.</p>
<p>Front End: ContentView()</p>
<pre><code>//
//  ContentView.swift
//  Aviate
//
//  Created by Grayson Bertaina on 9/27/20.
//
import Combine
import SwiftUI
import Foundation

class Query: ObservableObject {
    var didChange = PassthroughSubject&lt;Void, Never&gt;()
}

struct ContentView: View {
    
    
    init() {
        UITableView.appearance().backgroundColor = .clear
    }
    
    
    @State var stationQuery: String = &quot;&quot;

    
    
    var body: some View {

            NavigationView{
           
                VStack {
                    Text(&quot;The App for GA Pilots&quot;)
                    Spacer()
                    
                    VStack(alignment: .leading){
                        Text(&quot;News&quot;)
                            .background(Color.blue)
                            .font(.title)
                            .padding()
                            
                        Text(&quot;Aviate now supports chart lookup functionality!&quot;)
                            .padding()
                            
                            
                        
                    }
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .padding()
                    
                    
                    
                        
                    VStack(alignment: .leading) {
                        
                        Text(&quot;Favorite Airports&quot;)
                            .font(.title)
                            .padding()
                        
                        
                        List {
                            
                            
                            Section(header: Text(&quot;Favorite Airports&quot;)) {
                            NavigationLink(destination: METARView(search: stationQuery)) {
                                Text(&quot;Airport 1&quot;)
                            }
                            }
                            
                            Section(header: Text(&quot;Nearby Stations&quot;)) {
                            NavigationLink(destination: METARView(search: stationQuery)) {
                                Text(&quot;Airport 1&quot;)
                                }
                            }
                        }
                    
                        }
                    

                    Spacer()
                    
                    
                    HStack{
                        TextField(&quot;Enter ICAO&quot;, text: $stationQuery)
                            .padding()
                            .border(Color.black)
                            
                        NavigationLink(destination: METARView(search: stationQuery)) {
                            Text(&quot;Search&quot;)
                            

                        }
                        .padding()
                        .background(Color.blue)
                        .foregroundColor(.white)
                    }
                    .padding()
                    
                    
                    
                }
                .navigationBarTitle(&quot;Aviate Home&quot;)
                
           
    }
        
    }
    
    
    
}





struct METARView: View {

    
    @State var weatherManager = WeatherManager()
       
       init(search: String) {
           self.weatherManager.fetchWeather(stationICAO: search)
       }

    var body: some View {
        
        
        
        ScrollView{
            
            METARReport(model: weatherManager.weather)
            MapView()
                .frame(height: 200)
                .edgesIgnoringSafeArea(/*@START_MENU_TOKEN@*/.all/*@END_MENU_TOKEN@*/)
            
            METARTitleView()
                .frame(height: 250)
               
            METARReport()
                
            Spacer()
        }
        .edgesIgnoringSafeArea(/*@START_MENU_TOKEN@*/.all/*@END_MENU_TOKEN@*/)
    }
    
    
}

struct TAFView: View {

    var search: String

    var body: some View {

        ScrollView{
            MapView()
                .frame(height: 200)
                .edgesIgnoringSafeArea(/*@START_MENU_TOKEN@*/.all/*@END_MENU_TOKEN@*/)
            METARTitleView()
                .frame(height: 250)
               
            TAFReport()
                
           
        }
        .edgesIgnoringSafeArea(/*@START_MENU_TOKEN@*/.all/*@END_MENU_TOKEN@*/)
    }
}


struct AirportView: View {

    var search: String

    var body: some View {

        ScrollView{
            MapView()
                .frame(height: 200)
                .edgesIgnoringSafeArea(/*@START_MENU_TOKEN@*/.all/*@END_MENU_TOKEN@*/)
            
               
            AirportReport()
                
           
        }
        .edgesIgnoringSafeArea(/*@START_MENU_TOKEN@*/.all/*@END_MENU_TOKEN@*/)
    }
}


struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
            .previewDevice(&quot;iPhone 11&quot;)
        
    }
}



final class DataModel: ObservableObject {
  static let shared = DataModel()
  @Published var observedString = &quot;&quot; {
    didSet {
      //RUNS SUCCESSFULLY
      print(&quot;Observed string changed to \(observedString)&quot;)
    }
  }
}

</code></pre>
<p>Here is the part of METARView() that is needed to understand where the data is going - it will present the pulled data.</p>
<p>METARReport()</p>
<pre><code>//
//  METARReport.swift
//  Aviate
//
//  Created by Grayson Bertaina on 9/29/20.
//

import SwiftUI
import Foundation


var weatherManager = WeatherManager()



struct METARReport: View {
    

    
    var body: some View {
        ScrollView {
            VStack{
            HStack{
                Text(&quot;METAR Report&quot;)
                    .font(.title)
                    
                Spacer()
                Text(&quot;Time: &quot; + &quot;&quot;)
                    .font(.headline)
            }
            
            .padding()
            
            HStack{
                Text(&quot;Flight Rules&quot;)
                  
                Spacer()
                Text(&quot;VFR&quot;)
                    .padding()
                    .background(Color.green)
                 
            }
            .padding()
            .font(.headline)
            
                HStack(spacing: 20){
                    VStack(alignment: .leading){
                        Text(&quot;Visibility&quot;)
                          
                        Spacer()
                        Text(&quot;10&quot; + &quot; SM&quot;)
                            
                           
                    }
                    
                    
                    VStack(alignment: .leading){
                        Text(&quot;Temperature&quot;)
                          
                        Spacer()
                        Text(&quot;25&quot; + &quot; °C&quot;)
                         
                           
                    }
                    
                    VStack(alignment: .leading){
                        Text(&quot;Dew Point&quot;)
                          
                        Spacer()
                        Text(&quot;25&quot; + &quot; °C&quot;)
                           
                           
                    }
                 
            }
            .padding()
            .font(.headline)
                
                VStack(alignment: .center){
                    Text(&quot;Clouds&quot;)
                        .font(.headline)
                        .padding()
                        
                    HStack() {
                        Text(&quot;Few&quot;)
                        Spacer()
                    
                        Text(&quot;1200&quot;)
                    }
                    .padding()
                    HStack() {
                        Text(&quot;Few&quot;)
                        Spacer()
                    
                        Text(&quot;1200&quot;)
                    }
                    .padding()
                    HStack() {
                        Text(&quot;Few&quot;)
                        Spacer()
                    
                        Text(&quot;1200&quot;)
                    }
                    .padding()
                }
                .font(.headline)
            
                HStack{
                    Text(&quot;Altimeter&quot;)
                      
                    Spacer()
                    Text(&quot;29.92&quot;)
                     
                }
                .font(.headline)
                .padding()
                
                VStack{
                    Text(&quot;Wind&quot;)
                    HStack{
                        Text(&quot;5&quot; + &quot;kt&quot;)
                        Text(&quot;G&quot;)
                        Text(&quot;12&quot; + &quot;kt&quot;)
                        Text(&quot;From&quot;)
                        Text(&quot;310&quot; + &quot;°&quot;)
                        
                    }
                    .padding()
                    
                }
                .font(.headline)
            
                HStack {
                    Text(&quot;Special Wx&quot;)
                    Spacer()
                    Text(&quot;+RA&quot;)
                }
                .padding()
                .font(.headline)
                
                VStack {
                    Text(&quot;Remarks&quot;)
                    Spacer()
                    Text(&quot;No Remarks&quot;)
                }
                .padding()
                .font(.headline)
        }
    }
    }
}

struct METARReport_Previews: PreviewProvider {
    static var previews: some View {
        METARReport()
    }
}
</code></pre>
<p>Back End: WeatherStorage (Contains WeatherData, WeatherModel, and WeatherManager with API Call)</p>
<pre><code>struct WeatherData: Codable {
   
    let flight_rules: String?
    let remarks: String?
    let wind_speed: WindSpeed?
    let wind_gust: WindGust?
    let wind_direction: WindDirection?
    let visibility: Visibility?
    let time: Time?
    let station: String?
    let temperature: Temperature?
    let raw: String?
    let clouds: [Clouds?]
    let wx_codes: [Wxcodes?]
}

struct Clouds: Codable {
    let type: String
    let altitude: Int
}

struct Time: Codable {
    let repr: String
}

struct WindSpeed: Codable {
    let value: Int
}

struct WindGust: Codable {
    let value: Int
}

struct WindDirection: Codable {
    let repr: String
}

struct Visibility: Codable {
    let repr: String
}

struct Remarks: Codable {
    let remarks: String
}

struct Altimeter: Codable {
    let repr: String?
    let spoken: String?
}

struct Temperature: Codable {
    let repr: String
}

struct Dewpoint: Codable {
    let repr: String
}

struct Wxcodes: Codable {
    let value: String
}

// WeatherModel

//
//  WeatherModel.swift
//  AvWx Pro
//
//  Created by Grayson Bertaina on 9/22/20.
//

import Foundation

struct WeatherModel {
    let reportingStation: String
    let windGust: Int
    let windSpeed: Int
    let windDirection: String
    let visibility: String
    let flightRules: String
    let time: String
    let remarks: String
    let temperature: String
    let dewpoint: String
    let rawMETAR: String
    let lowestCloudsType: String
    let lowestCloudsAlt: Int
    let middleCloudsType: String
    let middleCloudsAlt: Int
    let highestCloudsType: String
    let highestCloudsAlt: Int
    let firstWxCode: String
    
    var windGustString: String {
        return String(format: &quot;%u&quot; + &quot;kt&quot;, windGust)
    }
    
    
    var windSpeedString: String {
        return String(format: &quot;%u&quot; + &quot;kt&quot;, windSpeed)
    }
    
    
    var visUnits: String {
        return visibility + &quot; SM&quot;
    }
    
    var degUnits: String {
        return windDirection + &quot;°&quot;
    }
    
    var tempUnits: String {
        return temperature + &quot;°C&quot;
    }
    
    var dewUnits: String {
        return dewpoint + &quot;°C&quot;
    }
    
    var altToString1: String {
        return String(format: &quot;%u&quot; + &quot;00 ft&quot;, lowestCloudsAlt)
    }
    
    var altToString2: String {
        return String(format: &quot;%u&quot; + &quot;00 ft&quot;, middleCloudsAlt)
    }
    
    var altToString3: String {
        return String(format: &quot;%u&quot; + &quot;00 ft&quot;, highestCloudsAlt)
    }
    

    
    var flightConditions: String {
        switch flightRules {
        case &quot;VFR&quot;:
            return &quot;green&quot;
        case &quot;MVFR&quot;:
            return &quot;blue&quot;
        case &quot;IFR&quot;:
            return &quot;red&quot;
        case &quot;LIFR&quot;:
            return &quot;purple&quot;
        default:
            return &quot;gray&quot;
        
        }
    }
}

    private func parseJSON(_ weatherData: Data) -&gt; WeatherModel? {
        do {
            let decoder = JSONDecoder()
            let decodedData = try decoder.decode(WeatherData.self, from: weatherData)

            
            let clouds = decodedData.clouds
            let wxcodes = decodedData.wx_codes
            let reportingStationVar = decodedData.station ?? &quot;N/A&quot;
            let windGustValue = decodedData.wind_gust?.value ?? 0
            let windSpeedValue = decodedData.wind_speed?.value ?? 0
            let windDirectionValue = decodedData.wind_direction?.repr ?? &quot;N/A&quot;
            let visibilityValue = decodedData.visibility?.repr ?? &quot;N/A&quot;
            let flightRulesValue = decodedData.flight_rules ?? &quot;N/A&quot;
            let timeReportedMETAR = decodedData.time?.repr ?? &quot;N/A&quot;
            let remarksReportedMETAR = decodedData.remarks ?? &quot;N/A&quot;
            let tempMETAR = decodedData.temperature?.repr ?? &quot;No Data&quot;
            let rawMETARData = decodedData.raw ?? &quot;N/A&quot;
            let lowCloudsType = (clouds.count &gt; 0 ? clouds[0]?.type : nil) ?? &quot;N/A&quot;
            let midCloudsType = (clouds.count &gt; 1 ? clouds[1]?.type : nil) ?? &quot;N/A&quot;
            let highCloudsType = (clouds.count &gt; 2 ? clouds[2]?.type : nil) ?? &quot;N/A&quot;
            let lowCloudsAlt = (clouds.count &gt; 0 ? clouds[0]?.altitude : nil) ?? 0
            let midCloudsAlt = (clouds.count &gt; 1 ? clouds[1]?.altitude : nil) ?? 0
            let highCloudsAlt = (clouds.count &gt; 2 ? clouds[2]?.altitude : nil) ?? 0
            let firstWxCode1 = (wxcodes.count &gt; 0 ? wxcodes[0]?.value : &quot;N/A&quot;) ?? &quot;N/A&quot;
            
            let weather = WeatherModel(reportingStation: reportingStationVar, windGust: windGustValue, windSpeed: windSpeedValue, windDirection: windDirectionValue, visibility: visibilityValue, flightRules: flightRulesValue, time: timeReportedMETAR, remarks: remarksReportedMETAR, temperature: tempMETAR, dewpoint: rawMETARData, rawMETAR: rawMETARData, lowestCloudsType: lowCloudsType, lowestCloudsAlt: lowCloudsAlt, middleCloudsType: midCloudsType, middleCloudsAlt: midCloudsAlt, highestCloudsType: highCloudsType, highestCloudsAlt: highCloudsAlt, firstWxCode: firstWxCode1)
            
            return weather
            
        } catch {
            print(error)
            return nil
        }
    }

</code></pre>
<p>You will notice that there are some useless functions, like trying fetchWeather at the top of my ContentView. I am trying various things to get data to be pulled but don't know where to put the required:</p>
<ul>
<li>the fetchWeather function, and what to initialize</li>
<li>How to update the views and initialize the WeatherModel or WeatherManager to get that data.</li>
</ul>
<p>I am new to Swift so I apologize if any part of my question is vague. I am definitely in a bit over my head! Thanks for the help and have a great day.</p>
<p>Add on:</p>
<pre><code>//
//  WeatherData.swift
//  SwitUIAppExample
//
//  Created by mac on 30/09/2020.
//  Copyright © 2020 Kamran. All rights reserved.
//

//
//  WeatherData.swift
//  AvWx Pro
//
//  Created by Grayson Bertaina on 9/21/20.
//

import Foundation

struct WeatherData: Codable {
   
    
    let clouds: [Clouds?]
    let flight_rules: String?
    let remarks: String?
    let wind_speed: WindSpeed?
    let wind_gust: WindGust?
    let wind_direction: WindDirection?
    let visibility: Visibility?
    let time: Time?
    let station: String?
    let altimeter: Altimeter?
    let temperature: Temperature?
    let dewpoint: Dewpoint?
    let wx_codes: [Wxcodes?]
    let raw: String?
}



struct Clouds: Codable {
    let type: String
    let altitude: Int
}

struct Time: Codable {
    let repr: String
}

struct WindSpeed: Codable {
    let value: Int
}

struct WindGust: Codable {
    let value: Int
}

struct WindDirection: Codable {
    let repr: String
}

struct Visibility: Codable {
    let repr: String
}

struct Remarks: Codable {
    let remarks: String
}

struct Altimeter: Codable {
    let value: Double
}

struct Temperature: Codable {
    let repr: String
}

struct Dewpoint: Codable {
    let repr: String
}

struct Wxcodes: Codable {
    let value: String
}


// WeatherModel

//
//  WeatherModel.swift
//  AvWx Pro
//
//  Created by Grayson Bertaina on 9/22/20.
//

import Foundation

struct WeatherModel {
    
    
    let lowestCloudsType: String
    let lowestCloudsAlt: Int
    let middleCloudsType: String
    let middleCloudsAlt: Int
    let highestCloudsType: String
    let highestCloudsAlt: Int
    let reportingStation: String
    let windGust: Int
    let windSpeed: Int
    let windDirection: String
    let visibility: String
    let flightRules: String
    let time: String
    let remarks: String
    let altimeter: Double
    let temperature: String
    let dewpoint: String
    let firstWxCode: String
    let rawMETAR: String
    
    var altToString1: String {
        return String(format: &quot;%u&quot; + &quot;00 ft&quot;, lowestCloudsAlt)
    }
    
    var altToString2: String {
        return String(format: &quot;%u&quot; + &quot;00 ft&quot;, middleCloudsAlt)
    }
    
    var altToString3: String {
        return String(format: &quot;%u&quot; + &quot;00 ft&quot;, highestCloudsAlt)
    }
    
    var windGustString: String {
        return String(format: &quot;%u&quot; + &quot;kt&quot;, windGust)
    }
    
    
    var windSpeedString: String {
        return String(format: &quot;%u&quot; + &quot;kt&quot;, windSpeed)
    }
    
    var altimeterString: String {
        return String(format: &quot;%.2f&quot; + &quot; inHg&quot;, altimeter as CVarArg)
    }
    
    var visUnits: String {
        return visibility + &quot; SM&quot;
    }
    
    var degUnits: String {
        return windDirection + &quot;°&quot;
    }
    
    var tempUnits: String {
        return temperature + &quot;°C&quot;
    }
    
    var dewUnits: String {
        return dewpoint + &quot;°C&quot;
    }

    
    var flightConditions: String {
        switch flightRules {
        case &quot;VFR&quot;:
            return &quot;green&quot;
        case &quot;MVFR&quot;:
            return &quot;blue&quot;
        case &quot;IFR&quot;:
            return &quot;red&quot;
        case &quot;LIFR&quot;:
            return &quot;purple&quot;
        default:
            return &quot;gray&quot;
        
        }
    }
}



// WeatherManager

//
//  WeatherManager.swift
//  AvWx Pro
//
//  Created by Grayson Bertaina on 9/21/20.
//

import Foundation

class WeatherManager: ObservableObject {
    
    @Published var weater: WeatherModel?
    
    let weatherURL = &quot;https://avwx.rest/api/metar/&quot;
    

    func fetchWeather (stationICAO: String) {
        let urlString = &quot;\(weatherURL)\(stationICAO)?token=OVi45FiTDo1LmyodShfOfoizNe5m9wyuO6Mkc95AN-c&quot;
        performRequest(with: urlString)
    }
    
    func performRequest (with urlString: String) {
        if let url = URL(string: urlString) {
            let session = URLSession(configuration: .default)
                
            
            let task = session.dataTask(with: url) { (data, response, error) in
                if error != nil {
                    print(error)
                    return
                }
                
                if let safeData = data {
                    self.weater = self.parseJSON(safeData)
                }
            }
            
            task.resume()
            print(urlString)
            
            
            }
        }
    
   
    private func parseJSON(_ weatherData: Data) -&gt; WeatherModel? {
        do {
            let decoder = JSONDecoder()
            let decodedData = try decoder.decode(WeatherData.self, from: weatherData)

            let clouds = decodedData.clouds
            let wxcodes = decodedData.wx_codes
            let lowCloudsType = (clouds.count &gt; 0 ? clouds[0]?.type : nil) ?? &quot;N/A&quot;
            let midCloudsType = (clouds.count &gt; 1 ? clouds[1]?.type : nil) ?? &quot;N/A&quot;
            let highCloudsType = (clouds.count &gt; 2 ? clouds[2]?.type : nil) ?? &quot;N/A&quot;
            let lowCloudsAlt = (clouds.count &gt; 0 ? clouds[0]?.altitude : nil) ?? 0
            let midCloudsAlt = (clouds.count &gt; 1 ? clouds[1]?.altitude : nil) ?? 0
            let highCloudsAlt = (clouds.count &gt; 2 ? clouds[2]?.altitude : nil) ?? 0
            let reportingStationVar = decodedData.station ?? &quot;N/A&quot;
            let windGustValue = decodedData.wind_gust?.value ?? 0
            let windSpeedValue = decodedData.wind_speed?.value ?? 0
            let windDirectionValue = decodedData.wind_direction?.repr ?? &quot;N/A&quot;
            let visibilityValue = decodedData.visibility?.repr ?? &quot;N/A&quot;
            let flightRulesValue = decodedData.flight_rules ?? &quot;N/A&quot;
            let timeReportedMETAR = decodedData.time?.repr ?? &quot;N/A&quot;
            let remarksReportedMETAR = decodedData.remarks ?? &quot;N/A&quot;
            let altimeterMETAR = decodedData.altimeter?.value ?? 0
            let tempMETAR = decodedData.temperature?.repr ?? &quot;No Data&quot;
            let dewMETAR = decodedData.dewpoint?.repr ?? &quot;No Data&quot;
            let firstWxCode1 = (wxcodes.count &gt; 0 ? wxcodes[0]?.value : &quot;N/A&quot;) ?? &quot;N/A&quot;
            let rawMETARData = decodedData.raw ?? &quot;N/A&quot;
            
            let weather = WeatherModel(lowestCloudsType: lowCloudsType , lowestCloudsAlt: lowCloudsAlt, middleCloudsType: midCloudsType , middleCloudsAlt: midCloudsAlt, highestCloudsType: highCloudsType , highestCloudsAlt: highCloudsAlt, reportingStation: reportingStationVar, windGust: windGustValue, windSpeed: windSpeedValue, windDirection: windDirectionValue, visibility: visibilityValue, flightRules: flightRulesValue, time: timeReportedMETAR, remarks: remarksReportedMETAR, altimeter: altimeterMETAR, temperature: tempMETAR, dewpoint: dewMETAR, firstWxCode: firstWxCode1, rawMETAR: rawMETARData)
            return weather
            
        } catch {
            print(error)
            return nil
        }
    }
    
    

}
</code></pre>
","13503837","","13503837","","2020-09-30 05:55:18","2020-09-30 05:55:18","Issues Switching From UIKit to SwiftUI and Passing API Data to the View","<ios><swift><xcode><api><swiftui>","1","3","1","","","CC BY-SA 4.0"
"64142686","1","64142927","","2020-09-30 17:20:24","","1","108","<p>Here's a very simple view:</p>
<pre><code>import SwiftUI

struct ContentView: View
{
    @ObservedObject var doctestModel : DoctestModel
    
    var body: some View
    {
        ScrollView
        {
            Text(doctestModel.output)
        }
    }
}
</code></pre>
<p>I inject the model into the view in the SceneDelegate like this:</p>
<pre><code>let contentView = ContentView(doctestModel: self.doctestModel)
</code></pre>
<p>And here is my doctestModel:</p>
<pre><code>import Foundation
import SwiftUI
import Combine

class DoctestModel : ObservableObject
{
    @Published var output : String
    var queue : DispatchQueue
    

    init()
    {
        output = &quot;&quot;
        let fd = rdi_hos_init()
        queue = DispatchQueue(label: &quot;doctest_thread&quot;, qos: .utility)
        
        queue.async
        {
            // Some c code that will write to fd
            rdi_hos_run_tests()
        }
        
        queue.async
        {
            let buf_len = 4096
            let buf = UnsafeMutableRawPointer.allocate(byteCount: buf_len, alignment: 1)
            var bytes_read = 0
            
            while true
            {
                bytes_read = Darwin.read(fd, buf, buf_len)
                
                assert(bytes_read != -1)
                
                if bytes_read == 0
                {
                    break
                }
                                
                DispatchQueue.main.sync {
                    self.output += String(bytesNoCopy: buf, length: bytes_read,
                    encoding: .utf8, freeWhenDone: false)!
                }
            }
            
            buf.deallocate()
            rdi_hos_run_close()
        }
    }
}
</code></pre>
<p>The code reads from a pipe that is being written to by some C code. I'm doing the reading asynchronously but then I update the @Published variable in the main thread.</p>
<p>Issue is the screen is going to be blank until I minimize the app, then when I open it again the view will start updating.</p>
<p>Debugging I found that I'm receiving the data correctly and the output variable is being updated perfectly, but for some reason the View will not update until I minimize and open again.</p>
<p>I saw people suggesting StateObject but I'd like to target slightly older versions of iOS.</p>
<p>Halp!</p>
","3659011","","","","","2020-09-30 17:55:13","swiftui view is not updated until I minimize the app and open it again even though I inject the model","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"64151269","1","64152012","","2020-10-01 08:01:45","","0","847","<p>I'm very new to Swift and I am currently trying to learn by building a rent splitting app with SwiftUI + Combine. I want to follow the MVVM pattern and am trying to implement this. At the moment I have the following Model, ViewModel and View files:</p>
<p>Model:</p>
<pre><code>import Foundation
import Combine

struct InputAmounts {
    var myMonthlyIncome : Double
    var housemateMonthlyIncome : Double
    var totalRent : Double
}
</code></pre>
<p>ViewModel (where I have attempted to use the data from the Model to conform to the MVVM pattern, but I am not sure I have done this in the cleanest way/correct way so please correct me if wrong)</p>
<pre><code>import Foundation
import Combine

class FairRentViewModel : ObservableObject {
    
    private var inputAmounts: InputAmounts

    init(inputAmounts: InputAmounts) {
        self.inputAmounts = inputAmounts
    }
   
    var yourShare: Double {
        inputAmounts.totalRent = Double(inputAmounts.totalRent)
        inputAmounts.myMonthlyIncome = Double(inputAmounts.myMonthlyIncome)
        inputAmounts.housemateMonthlyIncome = Double(inputAmounts.housemateMonthlyIncome)
        let totalIncome = Double(inputAmounts.myMonthlyIncome + inputAmounts.housemateMonthlyIncome)
        let percentage = Double(inputAmounts.myMonthlyIncome / totalIncome)
        let value = Double(inputAmounts.totalRent * percentage)

        return Double(round(100*value)/100)
    }
}
</code></pre>
<p>And then am trying to pass this all to the View:</p>
<pre><code>import SwiftUI
import Combine

struct FairRentView: View {
    
    @ObservedObject private var viewModel: FairRentViewModel
    
    init(viewModel: FairRentViewModel){
        self.viewModel = viewModel
    }
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text(&quot;Enter the total monthly rent:&quot;)) {
                    TextField(&quot;Total rent&quot;, text: $viewModel.totalRent)
                        .keyboardType(.decimalPad)
                }
                
                Section(header: Text(&quot;Enter your monthly income:&quot;)) {
                    TextField(&quot;Your monthly wage&quot;, text: $viewModel.myMonthlyIncome)
                        .keyboardType(.decimalPad)
                }
                
                Section(header: Text(&quot;Enter your housemate's monthly income:&quot;)) {
                    TextField(&quot;Housemate's monthly income&quot;, text: $viewModel.housemateMonthlyIncome)
                        .keyboardType(.decimalPad)
                }
                Section {
                    Text(&quot;Your share: £\(viewModel.yourShare, specifier: &quot;%.2f&quot;)&quot;)
                }
            }
            .navigationBarTitle(&quot;FairRent&quot;)
        }
    }
}

struct FairRentView_Previews: PreviewProvider {
    static var previews: some View {
        let viewModel = FairRentViewModel(inputAmounts: &lt;#InputAmounts#&gt;)
        FairRentView(viewModel: viewModel)
    }
}

</code></pre>
<p>I am getting the build errors with the View:
&quot;Value of type 'ObservedObject.Wrapper' has no dynamic member 'totalRent' using key path from root type 'FairRentViewModel'&quot;</p>
<p>&quot;Value of type 'ObservedObject.Wrapper' has no dynamic member 'myMonthlyIncome' using key path from root type 'FairRentViewModel'&quot;</p>
<p>&quot;Value of type 'ObservedObject.Wrapper' has no dynamic member 'housemateMonthlyIncome' using key path from root type 'FairRentViewModel'&quot;</p>
<p>My questions are:</p>
<ul>
<li>What does this error mean and please point me in the right direction to solve?</li>
<li>Have I gone completely the wrong way at trying to implement the MVVM pattern here?</li>
</ul>
<p>As I said I am a Swift beginner just trying to learn so any advice would be appreciated.</p>
<p><strong>UPDATE IN RESPONSE TO ANSWER</strong></p>
<pre><code>  var yourShare: String {
        inputAmounts.totalRent = (inputAmounts.totalRent)
        inputAmounts.myMonthlyIncome = (inputAmounts.myMonthlyIncome)
        inputAmounts.housemateMonthlyIncome = (inputAmounts.housemateMonthlyIncome)
        var totalIncome = Double(inputAmounts.myMonthlyIncome) 0.00 + Double(inputAmounts.housemateMonthlyIncome) ?? 0.00
        var percentage = Double(myMonthlyIncome) ?? 0.0 / Double(totalIncome) ?? 0.0
        var value = (totalRent * percentage)
        
        return FairRentViewModel.formatter.string(for: value) ?? &quot;&quot;
    }
</code></pre>
<p>I am getting errors here that &quot;Value of optional type 'Double?' must be unwrapped to a value of type 'Double'&quot; which I thought I was achieving with the ?? operands?</p>
","12145038","","12145038","","2020-10-01 09:38:49","2020-10-01 09:57:13","SwiftUI + Combine, using Models and ViewModels together","<swift><mvvm><swiftui><combine>","1","2","1","","","CC BY-SA 4.0"
"64155578","1","64157877","","2020-10-01 12:37:48","","0","567","<p>I am learning SwiftUI and Combine to make a simple rent-splitting app. I am trying to follow the MVVM pattern and therefore have a Model, ViewModel and View as follows:</p>
<p>Model:</p>
<pre><code>import Foundation
import Combine

struct Amounts {
    var myMonthlyIncome : String = &quot;&quot;
    var housemateMonthlyIncome : String = &quot;&quot;
    var totalRent : String = &quot;&quot;
}

</code></pre>
<p>ViewModel:</p>
<pre><code>import Foundation
import Combine

class FairRentViewModel : ObservableObject {
    
    var amount: Amounts
    
    init(_ amount: Amounts){
        self.amount = amount
    }
    
    var myMonthlyIncome : String { return amount.myMonthlyIncome }
    var housemateMonthlyIncome : String { return amount.housemateMonthlyIncome }
    var totalRent : String { return amount.totalRent }
    
    var yourShare: Double {
        guard let totalRent = Double(totalRent) else { return 0 }
        guard let myMonthlyIncome = Double(myMonthlyIncome) else { return 0 }
        guard let housemateMonthlyIncome = Double(housemateMonthlyIncome) else { return 0 }
        let totalIncome = Double(myMonthlyIncome + housemateMonthlyIncome)
        let percentage = myMonthlyIncome / totalIncome
        let value = Double(totalRent * percentage)

        return Double(round(100*value)/100)
    }
}

</code></pre>
<p>View:</p>
<pre><code>
import SwiftUI
import Combine

struct FairRentView: View {
    
    @ObservedObject private var viewModel: FairRentViewModel
    
    init(viewModel: FairRentViewModel){
        self.viewModel = viewModel
    }
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text(&quot;Enter the total monthly rent:&quot;)) {
                    TextField(&quot;Total rent&quot;, text: $viewModel.amount.totalRent)
                        .keyboardType(.decimalPad)
                }
                
                Section(header: Text(&quot;Enter your monthly income:&quot;)) {
                    TextField(&quot;Your monthly wage&quot;, text: $viewModel.amount.myMonthlyIncome)
                        .keyboardType(.decimalPad)
                }
                
                Section(header: Text(&quot;Enter your housemate's monhtly income:&quot;)) {
                    TextField(&quot;Housemate's monthly income&quot;, text: $viewModel.amount.housemateMonthlyIncome)
                        .keyboardType(.decimalPad)
                }
                Section {
                    Text(&quot;Your share: £\(viewModel.yourShare, specifier: &quot;%.2f&quot;)&quot;)
                }
            }
            .navigationBarTitle(&quot;FairRent&quot;)
        }
    }
}

struct FairRentView_Previews: PreviewProvider {
    static var previews: some View {
        FairRentView(viewModel: FairRentViewModel(Amounts()))
    }
}

</code></pre>
<p>The entry point:</p>
<pre><code>@main
struct FairRentCalculatorApp: App {
    var body: some Scene {
        WindowGroup {
            FairRentView(viewModel: FairRentViewModel(Amounts(myMonthlyIncome: &quot;&quot;, housemateMonthlyIncome: &quot;&quot;, totalRent: &quot;&quot;)))
        }
    }
}

</code></pre>
<p>I want the <code>yourShare</code> value to update as the other properties are entered by the user in the form. This is what I have been trying to achieve with the above code. Can anyone please help point me in the right direction? I'm very new to SwiftUI + Combine and am trying my best to code cleanly so any other pointers are also welcome.</p>
<p>Thanks</p>
","12145038","","","","","2020-10-01 14:51:03","Using Combine + SwiftUI to update values when form values are updated","<swift><mvvm><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"64155823","1","64156129","","2020-10-01 12:53:03","","0","136","<p>I'm new in SwiftUI. I would like on the top left in the corner a Button next to the Picker. But when I place the Button, the Picker moves to the right and the Button is to nearly on the edge. How can I place the Button flush over the Headline and the Picker perfectly in the middle from iPhone Nodge?</p>
<p>Before:
<a href=""https://i.stack.imgur.com/HQdis.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/HQdis.png"" alt=""enter image description here"" /></a></p>
<p>After:
<a href=""https://i.stack.imgur.com/mkwCs.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mkwCs.png"" alt=""enter image description here"" /></a></p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    
    @State var Selection = UserDefaults.standard.integer(forKey: &quot;Picker&quot;)
    @State var Detail = false
    
    var body: some View {
        VStack {
            HStack {
                Button(action: {
                    self.Detail.toggle()
                }) {
                    Text(&quot;click&quot;)
                }.sheet(isPresented: $Detail) {
                    SettingView(showSheetView: self.$Detail, selection: $Selection)
                }
        
        Picker(&quot;&quot;, selection: $Selection) {
            Text(&quot;Selection1&quot;).tag(0)
            Text(&quot;Selection2&quot;).tag(1)
            }
            .pickerStyle(SegmentedPickerStyle()).padding(.horizontal, 89)
            .onReceive(Just(Selection)) {
                UserDefaults.standard.set($0, forKey: &quot;Picker&quot;)
            }
            }
            PageOne()
        }
    }
}

struct PageOne: View {
    
    var body: some View {
        NavigationView {
            VStack {
                Text(&quot;some Text&quot;)
            }.navigationTitle(&quot;Headline&quot;)
        }
    }
}

struct SettingView: View {
   
    @Binding var showSheetView: Bool
    @Binding var selection: Int
    
    var body: some View {
        NavigationView {
                Text(&quot;Test&quot;)
                .navigationBarTitle(Text(&quot;Select something&quot;))
                .navigationBarItems(trailing: Button(action: {
                    self.showSheetView = false
                }) {
                    Text(&quot;Ok&quot;)
                        .bold()
                        
            })
        }
    }
}
</code></pre>
","14270161","","1015258","","2020-10-01 13:00:30","2020-10-01 13:11:25","SwiftUI: How can I move texts or something else with VStack, HStack?","<swift><swiftui>","1","0","0","","","CC BY-SA 4.0"
"64211593","1","64212437","","2020-10-05 15:25:15","","0","110","<p>I am creating a basic Rent Splitting app to learn about Swift UI and Combine. I want to have a home screen where the user selects the number of housemates they share with first, and then based on that selection, they are shown a form which has fields that correspond with this number. So far I have the HomeView:</p>
<pre><code>import SwiftUI
import Combine

struct HomeScreenView: View {
    
    @ObservedObject private var viewModel: HomeScreenViewModel
    
    init(viewModel: HomeScreenViewModel){
        self.viewModel = viewModel
    }
    
    var body: some View {
        NavigationView {
            VStack {
                Text(&quot;Welcome to Fair Rent!&quot;)
                Text(&quot;Please select how many housemates you live with:&quot;)
                    .lineLimit(nil)
                    .padding(5.0)
                    
                NavigationLink(destination: FairRentView(viewModel: FairRentViewModel(Amounts())))
                {
                   Text(&quot;1&quot;)
                }
                NavigationLink(destination: FairRentView(viewModel: FairRentViewModel(Amounts())))
                {
                   Text(&quot;2&quot;)
                }
                NavigationLink(destination: FairRentView(viewModel: FairRentViewModel(Amounts())))
                {
                   Text(&quot;3&quot;)
                }
                NavigationLink(destination: FairRentView(viewModel: FairRentViewModel(Amounts())))
                {
                   Text(&quot;4&quot;)
                }
                NavigationLink(destination: FairRentView(viewModel: FairRentViewModel(Amounts())))
                {
                   Text(&quot;5&quot;)
                }
                NavigationLink(destination: FairRentView(viewModel: FairRentViewModel(Amounts())))
                {
                   Text(&quot;6&quot;)
                }
                NavigationLink(destination: FairRentView(viewModel: FairRentViewModel(Amounts())))
                {
                   Text(&quot;7&quot;)
                }
            }
        }
    }
}

struct HomeScreenView_Previews: PreviewProvider {
    static var previews: some View {
        HomeScreenView(viewModel: HomeScreenViewModel(Variables()))
    }
}
</code></pre>
<p>Based on which number they click, they'll be taken to the FairRentView:</p>
<pre><code>import SwiftUI
import Combine

struct FairRentView: View {
    
    @ObservedObject private var viewModel: FairRentViewModel
    
    init(viewModel: FairRentViewModel){
        self.viewModel = viewModel
    }
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text(&quot;Enter the total monthly rent:&quot;)) {
                    TextField(&quot;Total rent&quot;, text: $viewModel.amount.totalRent)
                        .keyboardType(.decimalPad)
                }
                Section(header: Text(&quot;Enter your monthly income:&quot;)) {
                    TextField(&quot;Your monthly wage&quot;, text: $viewModel.amount.myMonthlyIncome)
                        .keyboardType(.decimalPad)
                }
                Section(header: Text(&quot;Enter your housemate's monthly income:&quot;)) {
                    TextField(&quot;Housemate's monthly income&quot;, text: $viewModel.amount.housemateMonthlyIncome)
                        .keyboardType(.decimalPad)
                }
                Section {
                    Text(&quot;Your share: £\(viewModel.yourShare, specifier: &quot;%.2f&quot;)&quot;)
                }
            }
            .navigationBarTitle(&quot;FairRent&quot;)
        }
    }
}

struct FairRentView_Previews: PreviewProvider {
    static var previews: some View {
        FairRentView(viewModel: FairRentViewModel(Amounts()))
    }
}
</code></pre>
<p>I want the rent to be based on salary. At the moment as you can see there's only one form field for a housemate's wage to be entered, not taking into account if there are several housemates. I want the number of those fields to correspond with the number that the user has selected on the HomeScreen. I am very new to SwiftUI and am not sure of the best way to do this. Can anyone point me in the right direction please? I am trying my best to use Combine and confirm to an MVVM pattern.</p>
<p>Thanks</p>
","12145038","","","","","2020-10-06 18:46:02","SwiftUI and Combine - how to create a form that has the number of fields corresponding with user selection","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"64230593","1","64230704","","2020-10-06 17:04:54","","0","161","<p>What is the correct syntax of calling the following fetchURL function?</p>
<pre><code>func fetchURL&lt;T: Decodable&gt;(_ url: URL) -&gt; AnyPublisher&lt;T, Error&gt; {
     URLSession.shared.dataTaskPublisher(for: url)
    .map(\.data)
    .decode(type: T.self, decoder: JSONDecoder())
    .eraseToAnyPublisher()
}
</code></pre>
<p>
I'm confused here. <br/>
<pre><code>let url = URL(string:&quot;http://apple.com&quot;)
let publisher = fetchURL&lt;[String].self&gt;(url)????
</code></pre>
","715747","","968155","","2020-10-06 17:13:05","2020-10-06 20:01:31","What is the correct syntax for calling a generic function that generates a publisher?","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"64256851","1","64263595","","2020-10-08 06:22:20","","-1","177","<p>I have implemented the .OnReceive method in a SwiftUI view to be able to keep track of some variebles.</p>
<p><a href=""https://i.stack.imgur.com/qXqBG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qXqBG.png"" alt=""onCreate"" /></a></p>
<p><a href=""https://i.stack.imgur.com/RsfWN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RsfWN.png"" alt=""states"" /></a></p>
<p>But as you can see I have all the .onReceive's code is commented and the reason is that if I don't I get the following error on the canvas:</p>
<p><a href=""https://i.stack.imgur.com/2m50Q.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2m50Q.png"" alt=""canvas error"" /></a></p>
<p>This is my ContentView_Previews Struct:
<a href=""https://i.stack.imgur.com/wLSoF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wLSoF.png"" alt=""enter image description here"" /></a></p>
<p>Could anyone help me to understand the error? I suspect that the ContentView_Previews Struct need some extra value to be able to interpret the view on the canvas.</p>
<p>Thanks for the help!</p>
","2327791","","","","","2020-10-08 13:30:27","Failed to update SwiftUI preview when using .OnReceive Method","<ios><swift><canvas><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"64270761","1","64271270","","2020-10-08 21:19:23","","-1","119","<p>I am trying to make a GET from a REST API in swift. When I use the print statement (print(clubs)) I see the expected response in the proper format. But in the VC is gives me an empty array.</p>
<p>Here is the code to talk to the API</p>
<pre><code>extension ClubAPI {

    public enum ClubError: Error {
        case unknown(message: String)
    }

    func getClubs(completion: @escaping ((Result&lt;[Club], ClubError&gt;) -&gt; Void)) {
        let baseURL = self.configuration.baseURL
        let endPoint = baseURL.appendingPathComponent(&quot;/club&quot;)
        print(endPoint)
        API.shared.httpClient.get(endPoint) { (result) in
            switch result {
            case .success(let response):
                let clubs = (try? JSONDecoder().decode([Club].self, from: response.data)) ?? []
                print(clubs)
                completion(.success(clubs))
            case .failure(let error):
                completion(.failure(.unknown(message: error.localizedDescription)))
            }
        }
    }

}
</code></pre>
<p>and here is the code in the VC</p>
<pre><code>private class ClubViewModel {
    @Published private(set) var clubs = [Club]()
    @Published private(set) var error: String?

    func refresh() {
        ClubAPI.shared.getClubs { (result) in
            switch result {
            case .success(let club):
                print(&quot;We have \(club.count)&quot;)
                self.clubs = club
                print(&quot;we have \(club.count)&quot;)
            case .failure(let error):
                self.error = error.localizedDescription
            }
        }
    }
}
</code></pre>
<p>and here is the view controller code (Before the extension)</p>
<pre><code>class ClubViewController: UIViewController {
    private var clubs = [Club]()
    private var subscriptions = Set&lt;AnyCancellable&gt;()
    private lazy var dataSource = makeDataSource()

    enum Section {
        case main
    }
    private var errorMessage: String? {
        didSet {

        }
    }
    private let viewModel = ClubViewModel()
    @IBOutlet private weak var tableView: UITableView!

    override func viewDidLoad() {
        super.viewDidLoad()

        self.subscriptions = [
            self.viewModel.$clubs.assign(to: \.clubs, on: self),
            self.viewModel.$error.assign(to: \.errorMessage, on: self)
        ]

        applySnapshot(animatingDifferences: false)
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        self.viewModel.refresh()
    }



}




extension ClubViewController {
    typealias DataSource = UITableViewDiffableDataSource&lt;Section, Club&gt;
    typealias Snapshot = NSDiffableDataSourceSnapshot&lt;Section, Club&gt;
    func applySnapshot(animatingDifferences: Bool = true) {
        // Create a snapshot object.
        var snapshot = Snapshot()
        // Add the section
        snapshot.appendSections([.main])
        // Add the player array
        snapshot.appendItems(clubs)
        print(clubs.count)

        // Tell the dataSource about the latest snapshot so it can update and animate.
        dataSource.apply(snapshot, animatingDifferences: animatingDifferences)
    }

    func makeDataSource() -&gt; DataSource {
        let dataSource = DataSource(tableView: tableView) { (tableView, indexPath, club) -&gt; UITableViewCell? in
            let cell = tableView.dequeueReusableCell(withIdentifier: &quot;ClubCell&quot;, for: indexPath)
            let club = self.clubs[indexPath.row]
            print(&quot;The name is \(club.name)&quot;)
            cell.textLabel?.text = club.name
            return cell
        }
        return dataSource
    }
}
</code></pre>
","9525218","","9525218","","2020-10-08 21:54:04","2020-10-08 22:04:49","Swift - How do I decode json from a REST API","<ios><swift><networking><combine><urlsession>","1","6","","","","CC BY-SA 4.0"
"64278780","1","64281609","","2020-10-09 11:04:33","","0","107","<p>I've got the publisher</p>
<pre class=""lang-swift prettyprint-override""><code>@Published var feedData = Feed()
</code></pre>
<p>And this piece of code, which listens to it</p>
<pre class=""lang-swift prettyprint-override""><code>// some View 
.onReceive(feed.$feedData) { feedData in
            if feedData.personalTasks.count &gt; 0 {
                withAnimation(.easeOut(duration: 0.3)) {
                    showCards = true
                }
            }
        }
</code></pre>
<p>The question is when .onRecieve will be executed? Every time feedData is accessed? Or every time any property of feedData is changed? How does this property wrapper know when <em>something</em> changes in feedData?</p>
","14346210","","4042366","","2020-10-09 11:11:05","2020-10-09 14:02:06","When the @Published publishes the value it wraps?","<swift><swiftui><publish-subscribe><combine><property-wrapper>","1","0","","","","CC BY-SA 4.0"
"64285386","1","64285634","","2020-10-09 18:22:16","","1","422","<p>I have a <code>CurrentValueSubject</code> in an object and I want another <code>CurrentValueSubject</code> to copy the changes of the first one.</p>
<p>I can't find a way of easily doing that without having to do something like this:</p>
<pre><code>subjectA.assign(to: \.value, on: subjectB).store(in: &amp;cancelables)
</code></pre>
<p>It would be nice to be able to initialize the <code>subjectB</code> using <code>subjectA</code>. Is there a way of doing something like that?</p>
<p>Edit:
For example I was thinking it would be great to be able to do something like:</p>
<pre><code>let subjectB = CurrentValueSubject(from: subjectA)
</code></pre>
","973242","","973242","","2020-10-09 18:25:48","2020-10-09 18:41:37","Create a CurrentValueSubject from another CurrentValueSubject","<ios><swift><combine>","1","10","","","","CC BY-SA 4.0"
"64286306","1","64287364","","2020-10-09 19:39:58","","4","4442","<p>I have a sink that needs to be canceled as soon as I receive the first value. I don't care about future values, just the first one published. Because without storing the <code>AnyCancelable</code> created by the sink, the garbage collector will delete the sink, I must store it. At the same time, I must also clean it up after the sink has completed, otherwise, I will have a memory leak.</p>
<p>I built one using a UUID → AnyCancelable map, but I am worried that this is more complex than it should be; is there another way of doing this? What's recommended by Combine?</p>
<pre><code>@Published var locationState: (location: CLLocation?, error: Error?)?
var requestLocationSinks: [String: AnyCancellable] = [:]

// 1. Generate ID to uniquely identify the current sink.
let sinkID = UUID().uuidString

// 2. Start the sink and store it in our ID → AnyCancellable dictionary.
requestLocationSinks[sinkID] = $locationState.sink { locationState in
    if let locationState = locationState {
        invokeCallbackWithLocationState(locationState)
    }
    // 3. Remove the stored AnyCancellable as soon as we received our first value!
    self.requestLocationSinks.removeValue(forKey: sinkID)
}
</code></pre>
","577878","","","","","2020-10-10 14:39:08","How to stop storing AnyCancellable after Swift Combine Sink has received at least one value?","<ios><swift><combine>","2","2","1","","","CC BY-SA 4.0"
"64311732","1","64311873","","2020-10-12 04:33:44","","0","49","<p>The following code produces the output that I expect:</p>
<p>
<pre><code>import UIKit
import Combine


    let myURL = URL(string: &quot;https://disease.sh/v3/covid-19/apple/countries/Canada&quot;)

    // MARK: - Region
    struct Region: Codable {
        let country: String
        let subregions: [String]
    }


    let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: myURL!)
        .map { $0.data }
        .print(&quot;Hello Data&quot;)
        .decode(type: Region.self, decoder: JSONDecoder())

    let cancellableSink = remoteDataPublisher
        .sink(receiveCompletion: { completion in
                print(&quot;.sink() received the completion&quot;, String(describing: completion))
                switch completion {
                    case .finished:
                        break
                    case .failure(let anError):
                        print(&quot;received error: &quot;, anError)
                }
        }, receiveValue: { someValue in
            print(&quot;.sink() received \(someValue)&quot;)
        })


// =====================================================================================================
 
print(&quot;The End.&quot;)
</code></pre>
<p>
Here's the output as shown in the console. <br/>
As you can see, there is no 'cancel':
<p><a href=""https://i.stack.imgur.com/F8qbl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/F8qbl.png"" alt=""enter image description here"" /></a></p>
<p>
<hr/>
However when I wrap the code into a function(), 'combine' CANCELS the output. <br/>
The following code within <b>getRegionList()</b> doesn't produce an output.

Instead it receives a 'cancel' as shown in the console following the code below:
<p>
<pre><code>import UIKit
import Combine

var regionList = [String]()
let simplePublisher = PassthroughSubject&lt;String, Never&gt;()


func getRegionList() {
let myURL = URL(string: &quot;https://disease.sh/v3/covid-19/apple/countries/Canada&quot;)

// MARK: - Region
struct Region: Codable {
    let country: String
    let subregions: [String]
}


let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: myURL!)
    .map { $0.data }
    .print(&quot;Hello Data&quot;)
    .decode(type: Region.self, decoder: JSONDecoder())

    let cancellableSink = remoteDataPublisher
    .sink(receiveCompletion: { completion in
            print(&quot;.sink() received the completion&quot;, String(describing: completion))
            switch completion {
                case .finished:
                    break
                case .failure(let anError):
                    print(&quot;received error: &quot;, anError)
            }
    }, receiveValue: { someValue in
        print(&quot;.sink() received \(someValue)&quot;)
    })
}
getRegionList()
print(&quot;The End.&quot;)
</code></pre>
<p>
<p>The function cancels as shown in the console:</p>
<p><a href=""https://i.stack.imgur.com/TKJF7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TKJF7.png"" alt=""enter image description here"" /></a></p>
<p>
Why?
<br/>
The only code difference is one <em>is wrapped in a simple function</em>.
<br/>
I suspect some 'lifespan' must have expired.
<p>
<b>Solution:</b> should I make <b>concellableSink</b> global?
<br> What is the correct solution/syntax? 
","715747","","715747","","2020-10-12 04:52:01","2020-10-12 17:26:01","Combine access to server retrieves data within a playground but not within a function. Why?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"64316975","1","64322996","","2020-10-12 11:27:32","","1","635","<p>I'm determined to fully understand why this isn't causing a reference cycle. And in general what is happening at each stage of memory management here.</p>
<p>I have the following setup:</p>
<pre><code>struct PresenterView: View {
    @State private var isPresented = false
    var body: some View {
        Text(&quot;Show&quot;)
            .sheet(isPresented: $isPresented) {
                DataList()
            }
            .onTapGesture {
                isPresented = true
            }
    }
}

struct DataList: View {

    @StateObject private var viewModel = DataListViewModel()
    
    var body: some View {
        NavigationView {
            List(viewModel.itemViewModels, id: \.self) { itemViewModel in
                Text(itemViewModel.displayText)
            }.onAppear {
                viewModel.fetchData()
            }.navigationBarTitle(&quot;Items&quot;)
        }
    }
}

class DataListViewModel: ObservableObject {
    
    private let webService = WebService()

    @Published var itemViewModels = [ItemViewModel]()
    
    private var cancellable: AnyCancellable?
    
    func fetchData() {
        cancellable = webService.fetchData().sink(receiveCompletion: { _ in
            //...
        }, receiveValue: { dataContainer in
            self.itemViewModels = dataContainer.data.items.map { ItemViewModel($0) }
        })
    }
    
    deinit {
        print(&quot;deinit&quot;)
    }
    
}

final class WebService {
    
    var components: URLComponents {
        //...
        return components
    }

    func fetchData() -&gt; AnyPublisher&lt;DataContainer, Error&gt; {
        return URLSession.shared.dataTaskPublisher(for: components.url!)
            .map { $0.data }
            .decode(type: DataContainer.self, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>So when I create a PresenterView and then dismiss it I get a successful deinit print.</p>
<p>However I don't understand why they is no reference cycle here. <code>DataListViewModel</code> has <code>cancellables</code> which has a subscription that captures self. So <code>DataListViewModel</code> -&gt; subscription and subscription -&gt; <code>DataListViewModel</code>. How can <code>deinit</code> be triggered? In general is there a good approach to understanding whether there is a retain cycle in these kinds of situation?</p>
","2105498","","","","","2020-10-12 17:56:31","Why Is There No Retain Cycle In ReceiveValue Block Combine Subscription","<swiftui><combine><retain-cycle>","1","3","","","","CC BY-SA 4.0"
"64335093","1","64338062","","2020-10-13 12:16:05","","5","578","<p>I have a very strange crash that occurs <strong>on Release builds (App Store + TestFlight) and on Apple Watch Series 3 only.</strong> If I run it on debug on my Series 3 it works fine. On newer watches (Series 4+) the App Store and debug versions work fine.</p>
<p>My watch app uses SwiftUI. Does anybody know what is going on here? Is this a SwiftUI bug or am I doing something wrong?</p>
<p>This is the crash log that I'm getting from the Series 3 (symbolicated):</p>
<pre><code>Incident Identifier: B1210338-BE7E-4296-816B-5C07B3B2796A
Beta Identifier:     030172D5-8766-4A2C-B988-12A27F1DB754
Hardware Model:      Watch3,2
Process:             Thirstic [279]
Path:                /private/var/containers/Bundle/Application/8A4A4A35-2570-44BE-9767-E6B8EFE31369/ThirsticWatch.app/PlugIns/Thirstic.appex/Thirstic
Identifier:          co.tapcode.thirstic.watchkitapp.watchkitextension
Version:             24 (2020.2)
AppVariant:          1:Watch3,2:7
Beta:                YES
Code Type:           ARM (Native)
Role:                Foreground
Parent Process:      launchd [1]
Coalition:           co.tapcode.thirstic.watchkitapp [343]


Date/Time:           2020-10-13 11:12:41.5505 +0200
Launch Time:         2020-10-13 11:12:40.0000 +0200
OS Version:          Watch OS 7.0.2 (18R402)
Release Type:        User
Baseband Version:    5.02.01
Report Version:      104

Exception Type:  EXC_CRASH (SIGABRT)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Exception Note:  EXC_CORPSE_NOTIFY
Triggered by Thread:  0

Application Specific Information:
abort() called

Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libsystem_kernel.dylib          0x416e8358 __pthread_kill + 8
1   libsystem_pthread.dylib         0x417638e2 pthread_kill + 170
2   libsystem_c.dylib               0x4166650e abort + 86
3   libswiftCore.dylib              0x6768dee6 swift_vasprintf+ 2506470 (char**, char const*, char*) + 0
4   libswiftCore.dylib              0x67697852 swift_initClassMetadata + 0
5   libswiftCore.dylib              0x6769789c _swift_initClassMetadataImpl+ 2545820 (swift::TargetClassMetadata&lt;swift::InProcess&gt;*, swift::ClassLayoutFlags, unsigned long, swift::TypeLayout const* const*, unsigned long*, bool) + 44
6   libswiftCore.dylib              0x67698416 swift_initClassMetadata2 + 22
7   Thirstic                        0x000e9950 _hidden#4114_ + 366928 (__hidden#304_:0)
8   libswiftCore.dylib              0x67696438 swift_getSingletonMetadata + 720
9   Thirstic                        0x000e9786 type metadata accessor for WaterNeedsTimeline + 366470 (__hidden#304_:0)
10  libswiftCore.dylib              0x676a4bf8 swift::Demangle::TypeDecoder&lt;(anonymous namespace)::DecodedMetadataBuilder&gt;::decodeMangledType+ 2599928 (swift::Demangle::Node*) + 2624
11  libswiftCore.dylib              0x676a4492 swift::Demangle::TypeDecoder&lt;(anonymous namespace)::DecodedMetadataBuilder&gt;::decodeMangledType+ 2598034 (swift::Demangle::Node*) + 730
12  libswiftCore.dylib              0x676a3c14 swift_getTypeByMangledNodeImpl(swift::MetadataRequest, swift::Demangle::Demangler&amp;, swift::Demangle::Node*, void const* const*, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* + 2595860 (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 250
13  libswiftCore.dylib              0x676a3ae6 swift::swift_getTypeByMangledNode(swift::MetadataRequest, swift::Demangle::Demangler&amp;, swift::Demangle::Node*, void const* const*, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* + 2595558 (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 310
14  libswiftCore.dylib              0x676a3e90 swift_getTypeByMangledNameImpl(swift::MetadataRequest, llvm::StringRef, void const* const*, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* + 2596496 (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 556
15  libswiftCore.dylib              0x676a24b4 swift::swift_getTypeByMangledName(swift::MetadataRequest, llvm::StringRef, void const* const*, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* + 2589876 (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 310
16  libswiftCore.dylib              0x676c7870 (anonymous namespace)::getFieldAt+ 2742384 (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int) + 378
17  libswiftCore.dylib              0x676c7d50 (anonymous namespace)::ClassImpl::childMetadata(long, char const**, void (**)+ 2743632 (char const*)) + 16
18  libswiftCore.dylib              0x676c7eae (anonymous namespace)::ClassImpl::recursiveChildMetadata(long, char const**, void (**)+ 2743982 (char const*)) + 56
19  libswiftCore.dylib              0x676c6b40 swift_reflectionMirror_recursiveChildMetadata + 360
20  libswiftCore.dylib              0x675399e4 _forEachField+ 1112548 (of:options:body:) + 112
21  Combine                         0x5de66dfa ObservableObject&lt;&gt;.objectWillChange.getter + 228
22  Thirstic                        0x0009a172 protocol witness for ObservableObject.objectWillChange.getter in conformance TodayViewModel + 41330 (&lt;compiler-generated&gt;:0)
23  Combine                         0x5de6894e dispatch thunk of ObservableObject.objectWillChange.getter + 10
24  SwiftUI                         0x44d7099a ObservedObjectPropertyBox.update+ 5437850 (property:phase:) + 118
25  SwiftUI                         0x44aa0448 static BoxVTable.update+ 2487368 (ptr:property:phase:) + 164
26  SwiftUI                         0x44aa015c _DynamicPropertyBuffer.update+ 2486620 (container:phase:) + 48
27  SwiftUI                         0x44c493d2 StateObject.Box.update+ 4228050 (property:phase:) + 110
28  SwiftUI                         0x44aa0448 static BoxVTable.update+ 2487368 (ptr:property:phase:) + 164
29  SwiftUI                         0x44aa015c _DynamicPropertyBuffer.update+ 2486620 (container:phase:) + 48
30  SwiftUI                         0x44e8c21e DynamicBody.updateValue+ 6599198 () + 402
31  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
32  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
33  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
34  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
35  AttributeGraph                  0x45106984 AGGraphGetValue + 170
36  SwiftUI                         0x44a878b4 SubscriptionView.ChildAttribute.view.getter + 50
37  SwiftUI                         0x44a879ea SubscriptionView.ChildAttribute.updateValue+ 2386410 () + 286
38  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
39  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
40  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
41  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
42  AttributeGraph                  0x45106984 AGGraphGetValue + 170
43  SwiftUI                         0x44e8b522 StaticBody.container.getter + 50
44  SwiftUI                         0x44e8be8c closure #1 in StaticBody.value.getter + 84
45  SwiftUI                         0x44e8bbd4 StaticBody.value.getter + 476
46  SwiftUI                         0x44e8c070 protocol witness for Rule.value.getter in conformance StaticBody&lt;A&gt; + 8
47  AttributeGraph                  0x45108cb8 dispatch thunk of Rule.value.getter + 10
48  SwiftUI                         0x4490609a implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 807066 (_:) + 42
49  SwiftUI                         0x44922270 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 922224 (_:) + 22
50  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
51  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
52  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
53  AttributeGraph                  0x45106984 AGGraphGetValue + 170
54  SwiftUI                         0x44e8c1cc DynamicBody.updateValue+ 6599116 () + 320
55  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
56  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
57  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
58  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
59  AttributeGraph                  0x45106984 AGGraphGetValue + 170
60  SwiftUI                         0x44cf133c GeometryReader.Child.view.getter + 26
61  SwiftUI                         0x44cf143c GeometryReader.Child.updateValue+ 4916284 () + 240
62  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
63  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
64  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
65  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
66  AttributeGraph                  0x45106984 AGGraphGetValue + 170
67  SwiftUI                         0x44e8c1cc DynamicBody.updateValue+ 6599116 () + 320
68  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
69  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
70  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
71  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
72  AttributeGraph                  0x45106984 AGGraphGetValue + 170
73  SwiftUI                         0x44c2fda2 EnvironmentReadingChild.updateValue+ 4124066 () + 214
74  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
75  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
76  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
77  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
78  AttributeGraph                  0x45106984 AGGraphGetValue + 170
79  SwiftUI                         0x44e7d20c IsAnimated.updateValue+ 6537740 () + 44
80  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
81  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
82  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
83  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
84  AttributeGraph                  0x45106984 AGGraphGetValue + 170
85  SwiftUI                         0x44a838e8 HostPreferencesTransform.updateValue+ 2369768 () + 252
86  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
87  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
88  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
89  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
90  AttributeGraph                  0x45106984 AGGraphGetValue + 170
91  SwiftUI                         0x44cf217c PairPreferenceCombiner.value.getter + 56
92  SwiftUI                         0x44cf2220 protocol witness for Rule.value.getter in conformance PairPreferenceCombiner&lt;A&gt; + 20
93  AttributeGraph                  0x45108cb8 dispatch thunk of Rule.value.getter + 10
94  SwiftUI                         0x4490609a implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 807066 (_:) + 42
95  SwiftUI                         0x44922270 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 922224 (_:) + 22
96  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
97  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
98  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
99  AttributeGraph                  0x45106984 AGGraphGetValue + 170
100 SwiftUI                         0x44a8382e HostPreferencesTransform.updateValue+ 2369582 () + 66
101 SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
102 AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
103 AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
104 AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
105 AttributeGraph                  0x45106984 AGGraphGetValue + 170
106 SwiftUI                         0x44a8382e HostPreferencesTransform.updateValue+ 2369582 () + 66
107 SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
108 AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
109 AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
110 AttributeGraph                  0x450f9cc0 AG::Graph::value_ref+ 36032 (AG::AttributeID, AGSwiftMetadata const*, bool*) + 102
111 AttributeGraph                  0x451069c2 AGGraphGetValue + 232
112 SwiftUI                         0x44e24296 GraphHost.updatePreferences+ 6173334 () + 38
113 SwiftUI                         0x44c5f2a4 ViewGraph.updateOutputs+ 4317860 (at:) + 64
114 SwiftUI                         0x44e6a488 closure #1 in ViewRendererHost.render+ 6460552 (interval:updateDisplayList:) + 1176
115 SwiftUI                         0x44e6367c ViewRendererHost.render+ 6432380 (interval:updateDisplayList:) + 252
116 SwiftUI                         0x44f3ada4 _UIHostingView.layoutSubviews+ 7314852 () + 128
117 SwiftUI                         0x44f3adce @objc _UIHostingView.layoutSubviews+ 7314894 () + 18
118 UIKitCore                       0x5d082ce8 -[UIView+ 13118696 (CALayerDelegate) layoutSublayersOfLayer:] + 2002
119 QuartzCore                      0x46d0121e -[CALayer layoutSublayers] + 232
120 QuartzCore                      0x46d0644c CA::Layer::layout_if_needed+ 1213516 (CA::Transaction*) + 402
121 QuartzCore                      0x46d10af4 CA::Layer::layout_and_display_if_needed+ 1256180 (CA::Transaction*) + 62
122 QuartzCore                      0x46c7c120 CA::Context::commit_transaction+ 647456 (CA::Transaction*, double, double*) + 368
123 QuartzCore                      0x46c9d7e0 CA::Transaction::commit+ 784352 () + 712
124 UIKitCore                       0x5cca6768 __34-[UIApplication _firstCommitBlock]_block_invoke_2 + 72
125 CoreFoundation                  0x41a11cbe __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12
126 CoreFoundation                  0x41a11164 __CFRunLoopDoBlocks + 362
127 CoreFoundation                  0x41a0c91c __CFRunLoopRun + 692
128 CoreFoundation                  0x41a0c18a CFRunLoopRunSpecific + 474
129 GraphicsServices                0x451f2eb6 GSEventRunModal + 134
130 UIKitCore                       0x5cc8df7e -[UIApplication _run] + 1044
131 UIKitCore                       0x5cc92afa UIApplicationMain + 114
132 WatchKit                        0x5333143c WKExtensionMain + 680
133 libdyld.dylib                   0x415b7c52 start + 2
</code></pre>
","1983667","","1983667","","2020-10-13 13:42:09","2020-10-16 12:14:32","SwiftUI Apple Watch app crash on release build (Series 3 only)","<swift><swiftui><watchkit><apple-watch><combine>","2","0","","","","CC BY-SA 4.0"
"64353091","1","64459866","","2020-10-14 12:17:47","","0","308","<p>I am trying to make an audio player in SwiftUI, Audio player should have these functionality.</p>
<ol>
<li>Play/Stop Audio</li>
<li>Play in loop</li>
<li>Change volume through slider</li>
<li>Change audio pitch through slider.</li>
</ol>
<p>There are two problem currently I am facing</p>
<ol>
<li>audio player is not using volume and pitch slider value</li>
<li>While I stop and play and change volume/pitch slider app crashes with following message.</li>
</ol>
<blockquote>
<p>2020-10-14 17:34:08.957709+0530 SwiftUIAudioPlayer[1369:24886] [avae]
AVAEInternal.h:109   [AVAudioFile.mm:484:-[AVAudioFile
readIntoBuffer:frameCount:error:]:
(ExtAudioFileRead(_imp-&gt;_extAudioFile, &amp;ioFrames,
buffer.mutableAudioBufferList)): error -50</p>
</blockquote>
<p>Here is the link to project. <a href=""https://github.com/varun-naharia/SwiftUIAudioPlayer"" rel=""nofollow noreferrer"">https://github.com/varun-naharia/SwiftUIAudioPlayer</a></p>
<p><strong>ContentView.swift</strong></p>
<pre><code>import Foundation
import SwiftUI

struct ContentView: View {
    @State var volume:Double = 0.00
    @State var pitch:Double = 0.0
    @State var musicFiles:[SoundModel] = [SoundModel(file: &quot;metro35&quot;, name: &quot;Metronome&quot;, fileExtension: &quot;wav&quot;), SoundModel(file: &quot;johnson_tone_down_5min&quot;, name: &quot;Johnson&quot;, fileExtension: &quot;wav&quot;), SoundModel(file: &quot;sine_140_6s_fade_ogg&quot;, name: &quot;Sine wave&quot;, fileExtension: &quot;wav&quot;)]
    @State var selectedMusicFile:SoundModel = SoundModel(file: &quot;sine_140_6s_fade_ogg&quot;, name: &quot;Sine wave&quot;, fileExtension: &quot;wav&quot;)
    @State var showSoundPicker = false
    @State var selectedGraph = &quot;skin_conductance&quot;
    @State var iconSize:CGFloat = 0.124
    @State var iconSpace:CGFloat = 0.015
    @State var heart = false
    
    init() {
        Player.setPitch(pitch: Float(self.pitch))
        Player.setVolume(volume: Float(self.volume))
    }
    
    var body: some View {
        GeometryReader { geometry in
            ZStack{
                VStack(alignment: .leading) {
                    Button(action: {
                        self.heart = !self.heart
                        self.selectedGraph = &quot;heart&quot;
                        if(self.heart)
                        {
                            Player.playMusic(musicfile: self.selectedMusicFile.file, fileExtension: self.selectedMusicFile.fileExtension)
                        }
                        else
                        {
                            Player.stopMusic()
                            self.selectedGraph = &quot;&quot;
                        }
                    })
                    {
                        
                        Image(self.selectedGraph == &quot;heart&quot; ? &quot;heart&quot; : &quot;heart_disabled&quot;)
                            .resizable()
                            .frame(width: geometry.size.height*self.iconSize, height: geometry.size.height*self.iconSize)
                        
                    }
                    .frame(width: geometry.size.height*self.iconSize, height: geometry.size.height*self.iconSize)
                    .padding(.bottom, geometry.size.height*(self.iconSpace/2))
                    
                    Button(action: {
                        self.showSoundPicker = !self.showSoundPicker
                    })
                    {
                        
                        Image(&quot;tone&quot;)
                            .resizable()
                            .frame(width: geometry.size.height*self.iconSize, height: geometry.size.height*self.iconSize)
                        
                    }
                    .frame(width: geometry.size.height*self.iconSize, height: geometry.size.height*self.iconSize)
                    .padding(.bottom, geometry.size.height*(self.iconSpace/2))
                    
                    HStack{
                        SwiftUISlider(
                            thumbColor: .green,
                            thumbImage: &quot;musicNote 2&quot;,
                            value: self.$volume
                        ).padding(.horizontal)
                        Button(action: {
                            
                        })
                        {
                            
                            Image(&quot;centerGraph&quot;)
                                .resizable()
                                .frame(width: geometry.size.width*0.05, height: geometry.size.width*0.05)
                            
                            
                        }
                        .frame(width: geometry.size.width*0.03, height: geometry.size.width*0.03)
                        SwiftUISlider(
                            thumbColor: .green,
                            
                            thumbImage: &quot;timerSlider 2&quot;,
                            minValue: 0,
                            maxValue: 20,
                            value: self.$pitch
                            
                        )
                            .padding(.horizontal)
                            .frame(width: (geometry.size.width/2)-geometry.size.width*0.05, height: geometry.size.width*0.05)
                    }
                    .background(Color(UIColor.lightGray))
                    .frame(width: geometry.size.width, height: geometry.size.height*0.10)
                    if(self.showSoundPicker)
                    {
                        ChooseSoundView(
                            musicFiles: self.musicFiles,
                            selectedMusicFile: self.$selectedMusicFile ,
                            showSoundPicker: self.$showSoundPicker,
                            isPlaying: self.selectedGraph != &quot;&quot;
                        )
                            .frame(width: geometry.size.width*0.6, height: geometry.size.height*0.7, alignment: .center)
                            .background(Color.white)
                    }
                        
                }
                .frame(maxWidth: geometry.size.width,
                       maxHeight: geometry.size.height)
                .background(Color(UIColor.lightGray))
                
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    
    static var previews: some View {
        ContentView()
    }
}



struct ChooseSoundView: View {
    @State var musicFiles:[SoundModel]
    @Binding var selectedMusicFile:SoundModel
    @Binding var showSoundPicker:Bool
    @State var isPlaying:Bool
    var body: some View {
        GeometryReader { geometry in
            VStack(alignment: .leading)
            {
                List(self.musicFiles, id: \.name)
                { item in
                    Image(self.selectedMusicFile.file == item.file ? &quot;radio-button_on&quot; : &quot;radio-button_off&quot;)
                        .resizable()
                        .frame(width: 15, height: 15)
                    Button(action: {
                        print(item.name)
                        self.selectedMusicFile = item
                        self.showSoundPicker = false
                        if(self.isPlaying)
                        {
                            //                            Player.stopMusic()
                            //                            Player.playMusic(musicfile: self.selectedMusicFile.file, fileExtension: self.selectedMusicFile.fileExtension)
                        }
                    }){
                        Text(item.name)
                            .frame(width: geometry.size.width*90,
                                   height: 50.0,
                                   alignment: .leading)
                    }
                    .frame(width: geometry.size.width*90, height: 50.0)
                }
                HStack{
                    Button(action: {
                        self.showSoundPicker = false
                    }){
                        Text(&quot;Done&quot;)
                            .frame(width: geometry.size.width*0.45,
                                   height: 50.0,
                                   alignment: .center)
                    }
                    .frame(width: geometry.size.width*0.45, height: 50.0)
                    Button(action: {
                        self.showSoundPicker = false
                    }){
                        Text(&quot;Cancel&quot;)
                            .frame(width: geometry.size.width*0.45,
                                   height: 50.0,
                                   alignment: .center)
                    }
                    .frame(width: geometry.size.width*0.45, height: 50.0)
                }
                .background(Color.white)
            }
        }
    }
}
</code></pre>
<p><strong>Player.swift</strong></p>
<pre><code>import Foundation
import AVFoundation

class Player {
    
    private static var breathAudioPlayer:AVAudioPlayer?
    private static var audioPlayerEngine = AVAudioEngine()
    private static let speedControl = AVAudioUnitVarispeed()
    private static var pitchControl = AVAudioUnitTimePitch()
    private static var audioPlayerNode = AVAudioPlayerNode()
    private static var volume:Float = 1.0
    private static func playSounds(soundfile: String) {
    
    
        if let path = Bundle.main.path(forResource: soundfile, ofType: &quot;m4a&quot;){
            
            do{
                
                breathAudioPlayer = try AVAudioPlayer(contentsOf: URL(fileURLWithPath: path))
                breathAudioPlayer?.volume = self.volume
                breathAudioPlayer?.prepareToPlay()
                breathAudioPlayer?.play()
                
            }catch {
                print(&quot;Error&quot;)
            }
        }
    }
    
    static func playMusic(musicfile: String, fileExtension:String) {
        if let path = Bundle.main.path(forResource: musicfile, ofType: fileExtension){
            
            do{
                // 1: load the file
                let audioPlayFile = try AVAudioFile(forReading: URL(fileURLWithPath: path))
                let audioFileBuffer = AVAudioPCMBuffer(pcmFormat: audioPlayFile.fileFormat, frameCapacity: AVAudioFrameCount(audioPlayFile.length))
                try? audioPlayFile.read(into: audioFileBuffer!)
                
                // 2: create the audio player
                
                audioPlayerNode = AVAudioPlayerNode()
                
                audioPlayerEngine = AVAudioEngine()
                
                // you can replace mp3 with anything else you like, just make sure you load it from our project
                
                // making sure to clean up the audio hardware to avoid any damage and bugs
                
                audioPlayerNode.stop()
                
                audioPlayerEngine.stop()
                
                audioPlayerEngine.reset()
                
                audioPlayerEngine.attach(audioPlayerNode)
                
                let pitchControl = AVAudioUnitTimePitch()
                
                // assign the speed and pitch
                
                audioPlayerEngine.attach(pitchControl)
                
                audioPlayerEngine.connect(audioPlayerNode, to: pitchControl, format: nil)
                
                audioPlayerEngine.connect(pitchControl, to: audioPlayerEngine.outputNode, format: nil)
                
                audioPlayerNode.scheduleFile(audioPlayFile, at: nil, completionHandler: nil)
                
                // try to start playing the audio
                audioPlayerNode.scheduleBuffer(audioFileBuffer!, at: nil, options: .loops, completionHandler: nil)
                do {
                    try audioPlayerEngine.start()
                } catch {
                    print(error)
                }
                
                // play the audio
                
                
                
                audioPlayerNode.play()
            }catch {
                print(&quot;Error&quot;)
            }
        }
    }
    static func breathIn() {
//            Player.playSounds(soundfile: &quot;breathin&quot;)
    }
    
    static func breathOut() {
//            Player.playSounds(soundfile: &quot;breathout&quot;)
    }
    
    static func play(musicFile:String, fileExtension:String)
    {
        
        Player.playMusic(musicfile: musicFile,fileExtension: fileExtension)
        
    }
    
    static func stopMusic() {
        audioPlayerNode.pause()
        audioPlayerNode.stop()
    }
    
    static func setPitch(pitch:Float) {
        pitchControl.pitch = pitch
    }
    
    static func setVolume(volume:Float) {
        audioPlayerNode.volume = volume
    }
}
</code></pre>
<p><strong>SwiftUISlider.swift</strong></p>
<pre><code>import Foundation
import SwiftUI

struct SwiftUISlider: UIViewRepresentable {
    var onChangeNotification:String = &quot;&quot;
    
    final class Coordinator: NSObject {
        // The class property value is a binding: It’s a reference to the SwiftUISlider
        // value, which receives a reference to a @State variable value in ContentView.
        var value: Binding&lt;Double&gt;
        
        // Create the binding when you initialize the Coordinator
        init(value: Binding&lt;Double&gt;) {
            self.value = value
        }
        
        // Create a valueChanged(_:) action
        @objc func valueChanged(_ sender: UISlider) {
            self.value.wrappedValue = Double(sender.value)
            
        }
    }
    
    var thumbColor: UIColor = .white
    var minTrackColor: UIColor?
    var maxTrackColor: UIColor?
    var thumbImage:String?
    var minValue:Float?
    var maxValue:Float?
    
    @Binding var value: Double
    
    func makeUIView(context: Context) -&gt; UISlider {
        let slider = UISlider(frame: .zero)
        slider.thumbTintColor = thumbColor
        slider.minimumTrackTintColor = minTrackColor
        slider.maximumTrackTintColor = maxTrackColor
        slider.value = Float(value)
        if(self.minValue != nil)
        {
            slider.minimumValue = self.minValue!
        }
        if(self.maxValue != nil)
        {
            slider.maximumValue = self.maxValue!
        }
        slider.setThumbImage(UIImage(named: self.thumbImage ?? &quot;&quot;), for: .normal)
        slider.setThumbImage(UIImage(named: self.thumbImage ?? &quot;&quot;), for: .focused)
        slider.setThumbImage(UIImage(named: self.thumbImage ?? &quot;&quot;), for: .highlighted)
        
        slider.addTarget(
            context.coordinator,
            action: #selector(Coordinator.valueChanged(_:)),
            for: .valueChanged
        )
        
        return slider
    }
    
    func onValueChange(_ sender: UISlider) {
        
    }
    
    func updateUIView(_ uiView: UISlider, context: Context) {
        // Coordinating data between UIView and SwiftUI view
        uiView.value = Float(self.value)
    }
    
    func makeCoordinator() -&gt; SwiftUISlider.Coordinator {
        Coordinator(value: $value)
    }
}
</code></pre>
<p><strong>SoundModel.swift</strong></p>
<pre><code>import Foundation
import Combine

class SoundModel:ObservableObject, Identifiable
{
    @Published var file:String
    @Published var name:String
    @Published var fileExtension:String
    
    init(file:String, name:String, fileExtension:String) {
        self.file = file
        self.name = name
        self.fileExtension = fileExtension
    }
}
</code></pre>
","3851580","","","","","2020-10-22 17:06:50","Audio Player in swift is not getting value of volume and pitch","<ios><swift><audio><swiftui><avfoundation>","2","0","1","","","CC BY-SA 4.0"
"64360711","1","64364775","","2020-10-14 20:01:37","","1","30","<p>On MacOS, I have a very simple <code>ContentView</code>:</p>
<pre><code>struct ContentView: View {
    
    @ObservedObject var environment: Environment
    
    var body: some View {
        
        if let glyph = environment.glyph {
            print (&quot;Content View \(glyph)&quot;)
            return AnyView {
                GlyphView(glyph: glyph)
            }
        } else {
            return AnyView {
                Text(&quot;no glyph&quot;)
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var environment = Environment()
    static var previews: some View {
        ContentView(environment: environment)
    }
}
</code></pre>
<p>When I run application, console gives:</p>
<pre><code>2020-10-14 21:50:42.065365+0200 ShapeSearch[94679:5992139] Metal API Validation Enabled
2020-10-14 21:50:42.093298+0200 ShapeSearch[94679:5992191] flock failed to lock maps file: errno = 35
2020-10-14 21:50:42.093688+0200 ShapeSearch[94679:5992191] flock failed to lock maps file: errno = 35
Content View Glyph &quot;k&quot; - 6 contours
</code></pre>
<p>and <code>ContentView</code> stays empty, no <code>GlyphView</code>, no <code>Text</code>.</p>
<p>But when I debug <code>GlyphView</code>, I can see very nice rendered glyph on canvas:</p>
<pre><code>struct GlyphView_Previews: PreviewProvider {
    
    static var glyph = Environment().glyph!
    static var previews: some View {
        GlyphView(glyph: glyph)
    }
}
</code></pre>
<p><code>environment.glyph</code> is taken from the same source in both cases. I'm sure.</p>
<p><strong>Edit:</strong></p>
<p>This way it works:</p>
<pre><code>struct ContentView: View {
    
    @ObservedObject var environment: Environment
    
    var body: some View {
        GlyphView(glyph: environment.glyph!)
    }
}
</code></pre>
<p>Where a mistake could be ?</p>
","1238267","","1238267","","2020-10-14 20:13:33","2020-10-15 04:15:00","Canvas renders View, Console gives right output, but View in app stays empty","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"64379083","1","68518591","","2020-10-15 20:17:57","","3","577","<p>I've been working with RxSwift for a few years now, and am starting to explore Combine with SwiftUI and am having some trouble trying to replicate some functionality from RxSwift in Combine.</p>
<p>On the RxSwift <a href=""https://github.com/ReactiveX/RxSwift/blob/main/RxExample/RxExample/Services/ActivityIndicator.swift"" rel=""nofollow noreferrer"">GitHub</a> there is an example in a file called <code>ActivityIndicator.swift</code>.</p>
<p>Basic usage is as follows:</p>
<pre><code>class Foo {
  let activityIndicator = ActivityIndicator()

  lazy var activity = activityIndicator.asDriver()

  var disposeBag = DisposeBag()

  func doSomething() {
    Observable
      .just(&quot;this is something&quot;)
      .trackActivity(activityIndicator)
      .subscribe()
      .disposed(by: disposeBag)
  }
}
</code></pre>
<p>What this does is allow you to then drive off of the <code>activity</code> driver and it will emit boolean values every time something subscribes or a subscription completes.</p>
<p>You can then directly drive something like a UIActivityIndicatorView's isAnimating property using RxCocoa.</p>
<p>I've been trying to figure out how to create something similar to this in Combine but am not having any luck.</p>
<p>Say I have a viewModel that looks like this:</p>
<pre class=""lang-swift prettyprint-override""><code>class ViewModel: ObservableObject {
  @Published var isActive = false

  func doSomething() -&gt; AnyPublisher&lt;Void, Never&gt; {
    Just(())
      .delay(for: 2.0, scheduler: RunLoop.main)
      .eraseToAnyPublisher()
  }
}
</code></pre>
<p>What I would like to do is create an operator for a <code>Publisher</code> that will function similarly to how the Rx operator worked where I can forward the events from the subscription through the chain, but change the <code>isActive</code> value every time something subscribes/completes/cancels.</p>
<p>In the SwiftUI View I would initiate the <code>doSomething</code> function and sink to it, while also being able to use the published <code>isActive</code> property to show/hide a <code>ProgressView</code></p>
<p>Something similar to this:</p>
<pre class=""lang-swift prettyprint-override""><code>struct SomeView: View {
  let viewModel = ViewModel()

  var body: some View {
    var cancelBag = Set&lt;AnyCancellable&gt;()

    VStack {
      Text(&quot;This is text&quot;)

      if viewModel.isActive {
        ProgressView()
      }
    }
    .onAppear(perform: {
      viewModel
        .doSomething()
        .sink()
        .store(in: &amp;cancelBag)
    })
  }
}
</code></pre>
<p>Is there something that works like this already that I am just completely missing?</p>
<p>If not, how can I go about replicating the RxSwift functionality in Combine?</p>
<p>Thank you in advance for the help.</p>
","4408483","","","","","2021-07-25 12:45:50","RxSwift `ActivityIndicator` Functionality in Combine","<swift><swiftui><observable><rx-swift><combine>","2","0","1","","","CC BY-SA 4.0"
"64391848","1","64392074","","2020-10-16 15:11:45","","0","457","<p>I'm pretty sure this should be possible and I'm just searching for the wrong thing, but what I'm going to do is perform a 2 network requests in the same publisher chain.</p>
<p>Basically I'm trying to fetch a JSON Web token (from the web or locally) then perform the requested fetch using that JWT.</p>
<p>I've created a custom Subscription and Publisher for getting my JWT, and it stores the token locally and checks if it's valid so it can be reused, renewed or requested for the first time. However I'm having trouble working out how to then use this with the fetch.</p>
<p>This is where I am (please ignore the force unwrap for now):</p>
<pre class=""lang-swift prettyprint-override""><code>JWTState.publisher(JWTState.urlRequest!)
    .tryMap { (jwtState) -&gt; String in
        guard jwtState.isValid == true else {
            throw JWTError.invalidJWT
        }
        return jwtState.jwt
    }
    .map { (jwt) -&gt; URLRequest in
        URLRequest.jsonRequest(url: url, jwt: jwt)
    }
</code></pre>
<p>At that point I have a valid <code>URLRequst</code> for the fetch using a valid JWT, but I just can't work out how I call the next <code>URLSession.shared.dataTaskPublisher</code> or <code>URLSession.shared.dataTask</code> in the chain.</p>
<p>I'm hoping I've missed some publisher or function, or someone can steer me in the right direction. I'm also guessing I might have to create another custom Subscription and Publisher pair, but at the moment I can't see how doing that would help.</p>
<p>Thanks in advance. 😄</p>
","511495","","","","","2020-10-16 21:10:01","Perform multiple URLSessionDataTask in a single publisher chain","<ios><swift><swiftui><combine>","1","2","","2020-10-16 17:22:41","","CC BY-SA 4.0"
"64392029","1","64392848","","2020-10-16 15:23:08","","6","4179","<p>I'm observe a property on a view using the <code>onChange</code> modifier. However, I'd also like the same piece of code to run on the initial value as well because sometimes the data is injected in the initializer or asynchronously loaded later.</p>
<p>For example, I have a view that gets a model injected. Sometimes this model has data in it to begin with (like previews), or is asynchronously retrieved from the network.</p>
<pre><code>class MyModel: ObservableObject {
    @Published var counter = 0
}

struct ContentView: View {
    @ObservedObject var model: MyModel
    
    var body: some View {
        VStack {
            Text(&quot;Counter: \(model.counter)&quot;)
            Button(&quot;Increment&quot;) { model.counter += 1 }
        }
        .onChange(of: model.counter, perform: someLogic)
        .onAppear { someLogic(counter: model.counter) }
    }
    
    private func someLogic(counter: Int) {
        print(&quot;onAppear: \(counter)&quot;)
    }
}
</code></pre>
<p>In both <code>onAppear</code> and <code>onChange</code> cases, I'd like to run <code>someLogic(counter:)</code>. Is there a better way to get this behaviour or combine them?</p>
","235334","","","","","2022-06-10 09:23:23","Combine onChange and onAppear events in SwiftUI view?","<ios><swift><swiftui><combine>","3","1","","","","CC BY-SA 4.0"
"64421297","1","64421357","","2020-10-19 04:46:10","","1","311","<p>Is there way we can cancel dataTaskPublisher while app is going in background in Combine framework?</p>
","2883875","","","","","2020-10-19 14:05:01","Canceling subscription Combine framework","<swiftui><combine>","2","0","1","","","CC BY-SA 4.0"
"64442725","1","64446387","","2020-10-20 09:55:54","","2","777","<p>I need a publisher that publish values from 1 to 360 continuously with a certain time interval between values.</p>
<p>I have this publisher that publish one value from 1 to 360 at every second, but once it reaches 360 it stops, basically <code>(1...360).publisher</code> stops providing values, but I need the publisher to keep publishing values starting again from 1</p>
<p>Probably it will work to add a condition if value == 360 then reset the publisher, but this would be inefficient since the condition will be put for every single value, any idea for a better solution?</p>
<pre><code>struct ContentView: View {

let delayedValuesPublisher = Publishers.Zip((1...360).publisher,
                                            Timer.publish(every: 1, on: .main, in: .default)
                                                .autoconnect())



  var body: some View {

        Text(&quot;&quot;)
            .onReceive(delayedValuesPublisher) { (output) in
                print(output.0)
            }

    }

}
</code></pre>
","10208552","","10208552","","2020-10-20 11:11:43","2020-10-20 13:39:41","How to make a Combine publisher that publish values continuously?","<swift><swiftui><combine><publisher>","1","1","1","","","CC BY-SA 4.0"
"64452434","1","64478832","","2020-10-20 19:54:23","","3","418","<p>I'm building a view controller with a collection view, using the (kinda) new diffable datasource and composable collectionview layout. I made my own Section and Row enums, can react to changes in my model (an array of photos), which triggers the <code>applySnapshot</code> and everything works.</p>
<p>But.. in my <code>createLayout</code> function I only have a section index to work with?? This seems very weird to me, why don't these two technologies work better together? One works with <code>SectionIdentifierType</code> and <code>ItemIdentifierType</code> (great!) and the other is still index based? Ugh.</p>
<p>What I want to be able to do is something like this: all cells within the <code>Section.header</code> section need to be full screen width, with an automatic height. Every cell in the <code>Section.photos</code> section will get a fixed size. And there can be other sections with different cell sizes too, and some sections can be optional. So an index-based system is really crap to work with, can't hardcode that section 0 is the header and section 1 is photos: the order can change, things might be optional, etc.</p>
<p>What is a better wat to deal with this? I can of course store an array <code>[Section]</code> on the view controller, use the section index to get the <code>Section</code> case that way, but is there no built-in way to get the section identifier for the index? 🤔 It seems like such a logical thing since these 2 technologies were released at the same time.</p>
<pre class=""lang-swift prettyprint-override""><code>class PhotosViewController: UIViewController {
  enum Section: Equatable, Hashable {
    case header
    case photos
  }

  enum Row: Equatable, Hashable {
    case header
    case photo(Photo)
  }

  private lazy var dataSource = makeDataSource()
  var photos: AnyPublisher&lt;[Photo], Never&gt;!

  override func viewDidLoad() {
    super.viewDidLoad()

    collectionView.collectionViewLayout = createLayout()

    photos
      .sink(receiveValue: applySnapshot)
      .store(in: &amp;subscriptions)
  }

  private func makeDataSource() -&gt; UICollectionViewDiffableDataSource&lt;Section, Row&gt; {
    return UICollectionViewDiffableDataSource(collectionView: collectionView) { (collectionView, indexPath, item) -&gt; UICollectionViewCell? in
      switch item {
        case .header:
          let cell = collectionView.dequeueReusableCell(for: indexPath, cellType: ProfileHeaderCollectionViewCell.self)
          return cell

        case .photo(let photo):
          let cell = collectionView.dequeueReusableCell(for: indexPath, cellType: PhotoCollectionViewCell.self)
          cell.configure(photo: photo)
          return cell
      }
    }
  }

  private func applySnapshot(photos: [Photo]) {
    var snapshot = NSDiffableDataSourceSnapshot&lt;Section, Row&gt;()

    let headerSection = Section.header
    snapshot.appendSections([headerSection])
    snapshot.appendItems([.header], toSection: headerSection)

    let items = photos.map { Row.photo($0) }
    let photosSection = Section.photos
    snapshot.appendSections([photosSection])
    snapshot.appendItems(items, toSection: photosSection)

    dataSource.apply(snapshot, animatingDifferences: false)
  }

  private func createLayout() -&gt; UICollectionViewLayout {
    let layout = UICollectionViewCompositionalLayout { [unowned self] sectionIndex, _ in
      // I have to work with a sectionIndex instead of a Section case?
    }

    return layout
  }
}
</code></pre>
","403425","","","","","2020-10-22 09:01:36","UICollectionViewCompositionalLayout can't use the same sections as UICollectionViewDiffableDataSource?","<ios><swift><uicollectionview><uicollectionviewdiffabledatasource>","1","0","2","","","CC BY-SA 4.0"
"64489959","1","64492986","","2020-10-22 20:19:56","","0","649","<p>Here is my thought, I want to present the data when the user searching via <code>$artistName</code> then combine framework could help me to request the data from the server.</p>
<p>I don't know which step I'm wrong. When I try to fetch the data via the simulator. It will show the unknown error and the rest of these.</p>
<pre><code>2020-10-23 03:56:38.220523+0800 PodcastSearchV2[42967:667554] [] nw_protocol_get_quic_image_block_invoke dlopen libquic failed
Fetch failed: Unknown error
2020-10-23 03:56:40.114906+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_protocol_metadata [C2] Client called nw_connection_copy_protocol_metadata on unconnected nw_connection
2020-10-23 03:56:40.115071+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_protocol_metadata [C2] Client called nw_connection_copy_protocol_metadata on unconnected nw_connection
2020-10-23 03:56:40.115255+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_protocol_metadata [C2] Client called nw_connection_copy_protocol_metadata on unconnected nw_connection
2020-10-23 03:56:40.115360+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_protocol_metadata [C2] Client called nw_connection_copy_protocol_metadata on unconnected nw_connection
2020-10-23 03:56:40.115516+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_connected_local_endpoint [C2] Client called nw_connection_copy_connected_local_endpoint on unconnected nw_connection
2020-10-23 03:56:40.115613+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_connected_remote_endpoint [C2] Client called nw_connection_copy_connected_remote_endpoint on unconnected nw_connection
2020-10-23 03:56:40.115723+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_connected_path [C2] Client called nw_connection_copy_connected_path on unconnected nw_connection
2020-10-23 03:56:40.115924+0800 PodcastSearchV2[42967:667546] Connection 2: unable to determine interface type without an established connection
2020-10-23 03:56:40.116069+0800 PodcastSearchV2[42967:667546] Connection 2: unable to determine interface classification without an established connection
2020-10-23 03:56:40.116381+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_protocol_metadata [C2] Client called nw_connection_copy_protocol_metadata on unconnected nw_connection
2020-10-23 03:56:40.120441+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_metadata [C2] Client called nw_connection_copy_metadata on unconnected nw_connection
2020-10-23 03:56:40.120579+0800 PodcastSearchV2[42967:667546] Connection 2: unable to determine interface type without an established connection
2020-10-23 03:56:40.121823+0800 PodcastSearchV2[42967:667546] Connection 2: unable to determine interface type without an established connection
</code></pre>
<p>This is my response.</p>
<pre><code>struct DataResponseSpotify: Codable {
    var episodes: PodcastItemSpotify
}

struct PodcastItemSpotify: Codable {
    var items: [PodcastItemsDetailsSpotify]
}

struct PodcastItemsDetailsSpotify: Codable, Identifiable {
    let id: String
    let description: String
    let images: [Images]
    let name: String
    let external: String
    
    var externalURL: URL? {
        return URL(string: external)
    }
    
    enum CodingKeys: String, CodingKey {
        case id
        case description
        case images
        case name
        case external = &quot;external_urls&quot;
    }
}

struct Images: Codable {
    let url: String
    
    var imageURL: URL? {
        return URL(string: url)
    }
    
    enum CodingKeys: String, CodingKey {
        case url
    }
}

struct Token: Codable {
    let accessToken: String
    
    enum CodingKeys: String, CodingKey {
        case accessToken = &quot;access_token&quot;
    }
}
</code></pre>
<p>This is how I write in the model.</p>
<pre><code>class DataObserverSpotify: ObservableObject {
    
    @Published var artistName = &quot;&quot;
    @Published var token = &quot;&quot;
    @Published var fetchResult = [PodcastItemsDetailsSpotify]()
    var subscriptions: Set&lt;AnyCancellable&gt; = []
    let podsURLComponents = PodsFetcher()
    
    init() {
        getToken()
        $artistName
            .debounce(for: .seconds(2), scheduler: RunLoop.main)
            .removeDuplicates()
            .compactMap { query in
                let url = self.podsURLComponents.makeURLComponentsForSpotify(withName: query, tokenAccess: self.token)
                return URL(string: url.string ?? &quot;&quot;)
            }
            .flatMap(fetchDatatesting)
            .receive(on: DispatchQueue.main)
            .assign(to: \.fetchResult, on: self)
            .store(in: &amp;subscriptions)
    }
    
     
    func fetchDatatesting(url: URL) -&gt; AnyPublisher&lt;[PodcastItemsDetailsSpotify], Never&gt; {
        URLSession.shared.dataTaskPublisher(for: url)
            .map(\.data)
            .decode(type: DataResponseSpotify.self, decoder: JSONDecoder())
            .map(\.episodes.items)
            .replaceError(with: [])
            .eraseToAnyPublisher()
    }
    
    
    func getToken() {
        let parameters = &quot;grant_type=refresh_token&amp;refresh_token=[example-refresh-token]&quot;
        let postData =  parameters.data(using: .utf8)
        var request = URLRequest(url: URL(string: &quot;https://accounts.spotify.com/api/token&quot;)!,timeoutInterval: Double.infinity)
        request.addValue(&quot;Basic exampleBasicAuth=&quot;, forHTTPHeaderField: &quot;Authorization&quot;)
        request.addValue(&quot;application/x-www-form-urlencoded&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        request.addValue(&quot;inapptestgroup=; __Host-device_id=example_id; __Secure-example=; csrf_token=example&quot;, forHTTPHeaderField: &quot;Cookie&quot;)

        request.httpMethod = &quot;POST&quot;
        request.httpBody = postData

        URLSession.shared.dataTask(with: request) { data, response, error in
            if let data = data {
                let decoder = JSONDecoder()
                decoder.dateDecodingStrategy = .iso8601
                if let token = try? decoder.decode(Token.self, from: data) {
                    DispatchQueue.main.async {
                        self.token = token.accessToken
                    }
                    return
                }
            }
            print(&quot;Fetch failed: \(error?.localizedDescription ?? &quot;Unknown error&quot;)&quot;)
        }.resume()
    }
    

}
</code></pre>
","9318133","","","","","2020-10-23 02:24:43","Couldn't not fetching the data from Spotify API with Combine framework in SwiftUI","<api><swiftui><spotify><combine>","1","0","1","","","CC BY-SA 4.0"
"64494369","1","64494500","","2020-10-23 05:29:43","","3","1247","<p>I recently encounter two data fetching (download) API that performs seemingly the same thing to me. I cannot see when should I use one over the other.</p>
<p>I can use <code>URLSession.shared.dataTask</code></p>
<pre><code>    var tasks: [URLSessionDataTask] = []

    func loadItems(tuple : (name : String, imageURL : URL)) {
        let task = URLSession.shared.dataTask(with: tuple.imageURL, completionHandler :
        { data, response, error in
            guard let data = data, error == nil else { return }
            DispatchQueue.main.async() { [weak self] in
                self?.displayFlag(data: data, title: tuple.name)
            }
        })
        tasks.append(task)
        task.resume()
    }

    deinit {
        tasks.forEach {
            $0.cancel()
        }
    }
</code></pre>
<p>Or I can use <code>URLSession.shared.dataTaskPublisher</code></p>
<pre><code>    var cancellables: [AnyCancellable] = []

    func loadItems(tuple : (name : String, imageURL : URL)) {
        URLSession.shared.dataTaskPublisher(for: tuple.imageURL)
            .sink(
                receiveCompletion: {
                    completion in
                    switch completion {
                    case .finished:
                        break
                    case .failure( _):
                        return
                    }},
                receiveValue: { data, _ in DispatchQueue.main.async { [weak self] in self?.displayFlag(data: data, title: tuple.name) } })
            .store(in: &amp;cancellables)
    }

    deinit {
        cancellables.forEach {
            $0.cancel()
        }
    }
</code></pre>
<p>I don't see their distinct differences, as both also can fetch, and both also provide us the ability to cancel the tasks easily. Can someone shed some light on their differences in terms of when to use which?</p>
","3286489","","3286489","","2020-10-23 05:53:01","2020-12-03 11:40:59","URLSession.shared.dataTask vs dataTaskPublisher, when to use which?","<ios><swift><urlsession>","1","8","1","","","CC BY-SA 4.0"
"64508345","1","64509924","","2020-10-23 23:11:08","","2","1002","<p>On the track to learn more and more about SwiftUI. I come accross some weird behaviors.</p>
<p>I have a simple view called <code>Modal</code>. I am using a <code>Picker</code> in it and set a title in the navigation bar to go in the detail view.</p>
<p>That works fine. The problem starts when I add a button in the nav bar.
It end up looking like this</p>
<p>Without the + button
<a href=""https://i.stack.imgur.com/I4Uwy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/I4Uwy.png"" alt=""enter image description here"" /></a></p>
<p>With the + button
<a href=""https://i.stack.imgur.com/PVqEx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/PVqEx.png"" alt=""enter image description here"" /></a></p>
<p>And the code is the following:</p>
<p><code>ContentView.swift</code></p>
<pre><code>import SwiftUI

struct ContentView: View {
    @State var isShowing = false
    
    var body: some View {
        VStack(content: {
            Button(&quot;Modal&quot;) {
                isShowing = true
            }
        })
        .sheet(isPresented: $isShowing, content: content)
    }
    
    @ViewBuilder
    func content() -&gt; some View {
        Modal()
    }
}
</code></pre>
<p><code>Modal.swift</code></p>
<pre><code>import SwiftUI
import Combine

struct Modal: View {
    @State var selection: String = &quot;&quot;
    @State var list: [String] = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;]
    
    var body: some View {
        NavigationView(content: {
            Form(content: {
                self.type()
            })
            .navigationBarTitle(&quot;Modal&quot;, displayMode: .inline)
        })
    }
}

private extension Modal {
    func type() -&gt; some View {
        Section(content: {
            Picker(selection: $selection, label: Text(&quot;Type&quot;).bold()) {
                ForEach(list, id: \.self) { item in
                    Text(item)
                        .tag(UUID())
                }
                .navigationBarTitle(&quot;Select&quot;)
                .navigationBarItems(trailing: button())
            }
        })
    }
    
    func button() -&gt; some View {
        HStack(alignment: .center, content: {
            Button(action: {
                // Action
            }) {
                Image(systemName: &quot;plus&quot;)
            }
        })
    }
}
</code></pre>
","5899647","","","","","2020-10-24 04:18:39","SwiftUI picker with a button in the navbar","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"64509935","1","64510089","","2020-10-24 04:20:46","","1","1277","<p>I have a view(<code>MainView</code>) with another view(<code>FooGroupView</code>) inside. Each time I click the item in <code>FooGroupView</code> then pass the value changes to <code>MainView</code>.</p>
<p>Like below:</p>
<p>The white view is <code>MainView</code>, the red is <code>FooGroupView</code>. If click <code>foo1</code> then the text should <code>Current:foo1</code>, then if click <code>foo2</code> then <code>Current:foo2</code>.</p>
<p><a href=""https://i.stack.imgur.com/UMUjA.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UMUjA.png"" alt=""enter image description here"" /></a></p>
<p>My code is here:</p>
<p><strong>Test.Playground</strong></p>
<pre><code>import SwiftUI
import PlaygroundSupport

struct FooRowView: View {

    var foo: Foo

    var body: some View {
        VStack {
            Color(.red)
            Text(foo.name)
        }
    }
}

class Foo: Identifiable, ObservableObject {
    var name: String
    var id: String

    init(name: String, id: String) {
        self.name = name
        self.id = id
    }
}

final class FooGroupViewModel: ObservableObject {

    var foos: [Foo] {
        didSet {
            self.selectedFoo = foos.first
        }
    }

    @Published var selectedFoo: Foo? {
        didSet {
            print(&quot;You selected: \(selectedFoo?.name)&quot;)
        }
    }

    init(foos: [Foo] = []) {
        self.foos = foos
        self.selectedFoo = foos.first
    }
}

struct FooGroupView: View {

    var viewModel: FooGroupViewModel

    var body: some View {
        ScrollView(.horizontal) {
            HStack(alignment: .center, spacing: 32, content: {

                // Error: error: Execution was interrupted, reason: signal SIGABRT.
                //The process has been left at the point where it was interrupted, use &quot;thread return -x&quot; to return to the state before expression evaluation.

                /*ForEach(viewModel.foos) { foo in
                    Text(foo.name)
                }*/


                Text(viewModel.foos[0].name).onTapGesture {
                    viewModel.selectedFoo = viewModel.foos[0]
                }
                Text(viewModel.foos[1].name).onTapGesture {
                    viewModel.selectedFoo = viewModel.foos[1]
                }
            })
        }
    }
}

final class MainViewModel: ObservableObject {
    @ObservedObject var fooGroupViewModel: FooGroupViewModel

    @Published var currentFoo: Foo?

    init() {
        fooGroupViewModel = FooGroupViewModel(foos: [Foo(name: &quot;foo1&quot;, id: &quot;1&quot;), Foo(name: &quot;foo2&quot;, id: &quot;2&quot;)])
        currentFoo = self.fooGroupViewModel.selectedFoo

    }
}

struct MainView: View {

    @ObservedObject var viewModel = MainViewModel()

    var body: some View {
        VStack {
            FooGroupView(viewModel: viewModel.fooGroupViewModel)
                .background(Color.red)
            Spacer()
            Text(&quot;Current:\(viewModel.currentFoo!.name)&quot;)
        }.frame(width: 200, height: 200)

    }
}


PlaygroundPage.current.liveView = UIHostingController(rootView: MainView())
</code></pre>
<p>In <code>MainViewModel</code> if <code>currentFoo</code> has changes, then the UI should be updated.</p>
<p>When click <code>foo1</code> or <code>foo2</code>, the <code>selectedFoo</code> in <code>FooGroupViewModel</code> was updated, then in <code>MainViewModel</code> should get the changes (as <code>@ObservedObject var fooGroupViewModel: FooGroupViewModel</code>)</p>
<p>My question is how to let <code>currentFoo</code> knows about the changes of <code>selectedFoo</code> in <code>fooGroupViewModel</code>? I was thought this line could observe the changes of the <code>selectedFoo</code> and if any update then trigger the <code>currentFoo</code> changes and update the UI.</p>
<pre><code>currentFoo = self.fooGroupViewModel.selectedFoo
</code></pre>
<p>But actually it doesn't work.</p>
<p>Any help? thanks!</p>
<p>I also have another question, its the comment in above code(Line 56 if paste my code into Playground)</p>
<pre><code>ForEach(viewModel.foos) { foo in
                    Text(foo.name)
                }
</code></pre>
<p>this code make the playground error:</p>
<pre><code>// Error: error: Execution was interrupted, reason: signal SIGABRT.
                //The process has been left at the point where it was interrupted, use &quot;thread return -x&quot; to return to the state before expression evaluation.
</code></pre>
<p>without any other information in console. Not sure why. Thanks for any help.</p>
","291240","","","","","2020-10-24 05:05:16","SwiftUI How to assign @Published to another @Published","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"64512868","1","64517234","","2020-10-24 11:30:25","","2","221","<p>I am trying to generate a Combine publisher off <code>didReceiveRemoteNotification </code></p>
<p>Similar to this code below:</p>
<pre><code>NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)
</code></pre>
<p>I want to use SwiftUI Lifecycle and don't want to use AppDelegate methods using <code>@UIApplicationDelegateAdaptor</code></p>
","7680493","","","","","2020-10-24 19:28:11","How to generate a Combine Publisher for didReceiveRemoteNotification?","<ios><swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"64528054","1","64555264","","2020-10-25 19:46:52","","-1","238","<p>I thought it was the case that @Published properties inside a class designated as an environment object would automatically update to all the subviews I pass the environment object to, but the below code isn't updating, what am I doing wrong?</p>
<pre><code>class trackerDataStore: ObservableObject {
    
    let healthStore = HKHealthStore()
    
    @Published var isLoadingWorkouts = false
    @Published var subscriptionIsActive = false
    @Published var trackerWorkoutObject: trackerWorkoutObject?
    
}
    

struct detailHeaderCard: View {
    
    @EnvironmentObject var trackerDataStore: TrackerDataStore
    
    var body: some View {
        //omitted
    }
    .sheet(isPresented: $isShowingPlayerAddStatsFormAsModal) {
        PlayerAddStatsForm(isShowingPlayerAddStatsFormAsModal: $isShowingPlayerAddStatsFormAsModal)
            .environmentObject(trackerDataStore)
    }
    
}
   
 
struct PlayerAddStatsForm: View {
    
    @EnvironmentObject var trackerDataStore: TrackerDataStore
    //not getting reactively updated here

}
</code></pre>
","4625622","","6738247","","2020-10-26 17:15:02","2020-10-27 13:15:25","SwiftUI Environment Object Not Getting Updated","<ios><swift><swiftui><publisher><environmentobject>","1","1","","","","CC BY-SA 4.0"
"64532998","1","64546061","","2020-10-26 07:31:56","","1","75","<p><strong>Scenario:</strong> I want to use a common function to access various endpoints.  So I'm trying to create boilerplate code to process various data models (struct.self) with their associated URLs.</p>
<p>Here are a couple of models that <em>share a common</em> URLSession + decode code:</p>
<pre><code>// MARK: - Region
struct Region: Codable {
    let country: String
    let subregions: [String]
}


// MARK: - SubRegion
struct SubRegion: Codable {
    let country: String
    let subregion: Sub
    let data: [Datum]
}
</code></pre>
<p>Here's one data vector (<code>Region</code>) that contains a URL with its associated data model:</p>
<pre><code>struct URLDataModel {
    var url = URL(string: &quot;https://disease.sh/v3/covid-19/apple/countries/Canada&quot;)
    var dataModel: Any = Region.self
}
</code></pre>
<p>The following is the entire class that contains the shared <code>getRegionList()</code> using the <code>URLDataModel</code> struct:</p>
<pre><code>class CountryRegionListModelView: ObservableObject {
    @Published var countryRegionList = [String]()

    // Data Persistence:
    var cancellables: Set&lt;AnyCancellable&gt; = []

    // TODO: --- Get Region tag ---
    func getRegionList(urlDataModel: URLDataModel) {
        // MARK: - Region

        struct Country: Codable {
            let countries: [String]
        }
        struct Region: Codable {
            let country: String
            let subregions: [String]
        }
        print(&quot;url: &quot;, urlDataModel.url)

        let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: urlDataModel.url!)
            // the dataTaskPublisher output combination is (data: Data, response: URLResponse)
            .map(\.data)
            .receive(on: DispatchQueue.main)
            .print(&quot;Hello Data&quot;)
            .decode(type: urlDataModel.dataModel, decoder: JSONDecoder())

        remoteDataPublisher
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    break
                case let .failure(anError):
                    Swift.print(&quot;received error: &quot;, anError)
                }
            }, receiveValue: { someValue in
                self.countryRegionList = someValue.subregions
                print(self.countryRegionList)

            }).store(in: &amp;cancellables)
    }
}
</code></pre>
<p>
<b>Problem:</b> I don't know how to make the JSON decoder work with a <em>variable</em> model type <b>'model'.self</b>.
<p>Should I use generics?  <br/>
How would that work?
","715747","","8697793","","2020-10-30 23:47:32","2020-10-31 00:15:58","Using a generic value for the model (vs a static model.self) to be parsed with JSONDecoder","<json><swift><swiftui><publish-subscribe><combine>","2","0","","","","CC BY-SA 4.0"
"64533899","1","64539537","","2020-10-26 08:48:06","","3","743","<p>in order to customise a <code>UISlider</code>, I use it in a <code>UIViewRepresentable</code>. It exposes a <code>@Binding var value: Double</code> so that my  view model (<code>ObservableObject</code>) view can observe the changes and update a <code>View</code> accordingly.</p>
<p>The issue is that the view is not updated when the <code>@Binding</code> value is changed. In the following example, I have two sliders. One native <code>Slider</code> and one custom <code>SwiftUISlider</code>.</p>
<p>Both pass a binding value to the view model that should update the view. The native <code>Slider</code> does update the view but not the custom one. In the logs, I can see that the <code>$sliderValue.sink { ... </code> is correctly called but the view is not updated.</p>
<p>I noticed this is happening when the presenting view has the <code>@Environment(\.presentationMode) var presentationMode: Binding&lt;PresentationMode&gt;</code> property. If I comment it out, it works as expected.</p>
<p><a href=""https://i.stack.imgur.com/fj65K.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fj65K.gif"" alt=""enter image description here"" /></a></p>
<p>A complete sample code to reproduce this is</p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    @State var isPresentingModal = false

    // comment this out
    @Environment(\.presentationMode) var presentationMode: Binding&lt;PresentationMode&gt;

    var body: some View {
        VStack {
            Button(&quot;Show modal&quot;) {
                isPresentingModal = true
            }
            .padding()
        }
        .sheet(isPresented: $isPresentingModal) {
            MyModalView(viewModel: TempViewModel())
        }
    }
}

class TempViewModel: ObservableObject {
    @Published var sliderText = &quot;&quot;
    @Published var sliderValue: Double = 0
    private var cancellable = Set&lt;AnyCancellable&gt;()

        init() {
            $sliderValue
                .print(&quot;view model&quot;)
                .sink { [weak self] value in
                    guard let self = self else { return }
                    print(&quot;updating view  \(value)&quot;)
                    self.sliderText = &quot;\(value) C = \(String(format: &quot;%.2f&quot; ,value * 9 / 5 + 32)) F&quot;
                }
                .store(in: &amp;cancellable)
        }
}

struct MyModalView: View {
    @ObservedObject var viewModel: TempViewModel

    var body: some View {
        VStack(alignment: .leading) {
            Text(&quot;SwiftUI Slider&quot;)
            Slider(value: $viewModel.sliderValue, in: -100...100, step: 0.5)
                .padding(.bottom)

            Text(&quot;UIViewRepresentable Slider&quot;)
            SwiftUISlider(minValue: -100, maxValue: 100, value: $viewModel.sliderValue)
            Text(viewModel.sliderText)
        }
        .padding()
    }
}

struct SwiftUISlider: UIViewRepresentable {
    final class Coordinator: NSObject {
        var value: Binding&lt;Double&gt;
        init(value: Binding&lt;Double&gt;) {
            self.value = value
        }

        @objc func valueChanged(_ sender: UISlider) {
            let index = Int(sender.value + 0.5)
            sender.value = Float(index)
            print(&quot;value changed \(sender.value)&quot;)
            self.value.wrappedValue = Double(sender.value)
        }
    }

    var minValue: Int = 0
    var maxValue: Int = 0

    @Binding var value: Double

    func makeUIView(context: Context) -&gt; UISlider {
        let slider = UISlider(frame: .zero)
        slider.minimumTrackTintColor = .systemRed
        slider.maximumTrackTintColor = .systemRed
        slider.maximumValue = Float(maxValue)
        slider.minimumValue = Float(minValue)

        slider.addTarget(
            context.coordinator,
            action: #selector(Coordinator.valueChanged(_:)),
            for: .valueChanged
        )

        adapt(slider, context: context)
        return slider
    }

    func updateUIView(_ uiView: UISlider, context: Context) {
        adapt(uiView, context: context)
    }

    func makeCoordinator() -&gt; SwiftUISlider.Coordinator {
        Coordinator(value: $value)
    }

    private func adapt(_ slider: UISlider, context: Context) {
        slider.value = Float(value)
    }
}

struct PresentationMode_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>
","677987","","677987","","2020-10-26 14:47:20","2020-10-26 19:43:08","UIViewRepresentable not working in a modally presented SwiftUI View","<swiftui><combine><observableobject>","2","0","2","","","CC BY-SA 4.0"
"64551792","1","64552734","","2020-10-27 09:46:51","","2","883","<p>I created a Model like this:</p>
<pre><code>class TestModel: ObservableObject {
    @Published var num: Int = 0
}
</code></pre>
<p>Model is be used in &quot;Home&quot; view and &quot;Home&quot;s child view &quot;HomeSub&quot;</p>
<pre><code>struct Home: View {
    
    @StateObject var model = TestModel()
    
    var body: some View {
        NavigationView(content: {
            NavigationLink(destination: HomeSub(model: model)) { Text(&quot;\(model.num)&quot;) }
        })
    }
}
</code></pre>
<pre><code>struct HomeSub: View {
   //1
    @StateObject var model = TestModel()
   //2
    @ObservedObject var model = TestModel()

    var body: some View {
        VStack {
            Text(&quot;\(model.num)&quot;)
                .padding()
                .background(Color.red)
            Button(&quot;Add&quot;) {
                model.num += 1
            }
        }
        .onChange(of: model.num, perform: { value in
            print(&quot;homeSub: \(value)&quot;)
        })
        
    }
}
</code></pre>
<p>In HomeSub view, what is the difference between 1 and 2?
When I run the project, they have exactly the same behavior.</p>
","14527688","","1630618","","2020-10-27 11:23:05","2020-10-27 11:28:11","What is the difference between @StateObject and @ObservedObject in child views in swiftUI","<swift><swiftui><combine><observedobject>","3","0","1","","","CC BY-SA 4.0"
"64607968","1","64608071","","2020-10-30 11:59:33","","0","153","<p>I'd like to provide <code>Combine</code> counterparts to completion closures which is becoming very cumbersome. Is there a shorter way or extension that can convert the following:</p>
<pre><code>extension MyType {
    
    func send(with request: URLRequest, completion: @escaping (Result&lt;MyResponse, MyError&gt;) -&gt; Void) {
        // Logic
    }
    
    func send(with request: URLRequest) -&gt; Future&lt;MyResponse, MyError&gt; {
        Future&lt;MyResponse, MyError&gt; { promise in
            send(with: request) { result in
                switch result {
                case let .success(response):
                    promise(.success(response))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
    }
}
</code></pre>
<p>The <code>Future</code> method is just a wrapper to the completion closure method. I was hoping to do at least something like this:</p>
<pre><code>Future&lt;MyResponse, MyError&gt; { send(with:request, completion: $0) }
</code></pre>
<p>Is there a more elegant way to do this since this will be applied in a lot of places in my library.</p>
","235334","","","","","2020-10-30 12:09:36","Shorthand conversion from Result to Future in Swift?","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"64614122","1","64617001","","2020-10-30 18:46:02","","0","1842","<p>I'm trying to create a refresh event using CurrentValueSubject while making a network call. So whenever network request fails I can press the button to make the request again, but can't make it work as failure event will terminate publisher and it won't work again.</p>
<pre><code>import Combine
import SwiftUI

struct ContentView: View {

    @ObservedObject var viewModel: TestViewModel = TestViewModel()

    var body: some View {
        Button(&quot;Test&quot;, action: viewModel.test)
        Button(&quot;Refresh&quot;, action: viewModel.refresh)
    }
}

class TestViewModel: ObservableObject {

    var bag = Set&lt;AnyCancellable&gt;()
    private let changeSubject = CurrentValueSubject&lt;Void, Never&gt;(())

    func test() {
        changeSubject
            .flatMap { self.networkPublisher }
            .sink(
                receiveCompletion: {
                    switch $0 {
                        case .failure:
                            print(&quot;Failure&quot;)
                        case .finished:
                            print(&quot;Finished&quot;)
                    }
                },
                receiveValue: {
                    print(&quot;Value: \($0)&quot;)
                }
            )
            .store(in: &amp;bag)
    }

    func refresh() {
        changeSubject.send(())
    }

    var networkPublisher: AnyPublisher&lt;String, Error&gt; {
        var url = URLRequest(url: URLComponents(string: &quot;www.google.com&quot;)!.url!)
        url.httpMethod = &quot;GET&quot;
        return URLSession.shared
            .dataTaskPublisher(for: url)
            .tryMap { _ -&gt; String in &quot;Result&quot; }
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>To fix this I could use <code>.tryCatch { _ -&gt; Just&lt;String&gt; in Just(&quot;Error&quot;) }</code> to catch the error and that would prevent the publisher from terminating. But why it wouldn't work when publisher terminates? And how can I make work after finish event?</p>
","2543013","","2543013","","2020-10-30 21:12:30","2020-10-30 23:35:39","Swift Combine publisher won't trigger in flatMap after finished event","<swift><combine>","2","1","","2020-11-01 15:42:15","","CC BY-SA 4.0"
"64628120","1","64628292","","2020-11-01 02:16:38","","3","3456","<p>I'm trying to compose a nested publisher chain in combine with Swift and I'm stumped. My current code starts throwing errors at the .flatMap line, and I don't know why. I've been trying to get it functional but am having no luck.</p>
<p>What I'm trying to accomplish is to download a TrailerVideoResult and decode it, grab the array of TrailerVideo objects, transform that into an array of YouTube urls, and then for each YouTube URL get the LPLinkMetadata. The final publisher should return an array of LPLinkMetadata objects. Everything works correctly up until the LPLinkMetadata part.</p>
<p>EDIT: I have updated the loadTrailerLinks function. I originally forgot to remove some apart of it that was not relevant to this example.</p>
<p>You will need to import &quot;LinkPresentation&quot;. This is an Apple framework for to fetch, provide, and present rich links in your app.</p>
<p>The error &quot;Type of expression is ambiguous without more context&quot; occurs at the very last line (eraseToAnyPublisher).</p>
<pre><code>func loadTrailerLinks() -&gt; AnyPublisher&lt;[LPLinkMetadata], Error&gt;{    
    return URLSession.shared.dataTaskPublisher(for: URL(string: &quot;Doesn't matter&quot;)!)
        .tryMap() { element -&gt; Data in
            guard let httpResponse = element.response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                throw URLError(.badServerResponse)
            }
            return element.data
        }
        .decode(type: TrailerVideoResult.self, decoder: JSONDecoder(.convertFromSnakeCase))
        .compactMap{ $0.results }
        .map{ trailerVideoArray -&gt; [TrailerVideo] in
            let youTubeTrailer = trailerVideoArray.filter({$0.site == &quot;YouTube&quot;})
            return youTubeTrailer
        }
        .map({ youTubeTrailer -&gt; [URL] in
            return youTubeTrailer.compactMap{
                let urlString = &quot;https://www.youtube.com/watch?v=\($0.key)&quot;
                let url = URL(string: urlString)!
                return url
            }
        })
        .flatMap{ urls -&gt; [AnyPublisher&lt;LPLinkMetadata, Never&gt;] in
            return urls.map{ url -&gt; AnyPublisher &lt;LPLinkMetadata, Never&gt; in
                return self.getMetaData(url: url)
                    .map{ metadata -&gt; LPLinkMetadata in
                        return metadata
                    }
                    .eraseToAnyPublisher()
            }
        }
        .eraseToAnyPublisher()
}
</code></pre>
<pre><code>func fetchMetaData(url: URL) -&gt; AnyPublisher &lt;LPLinkMetadata, Never&gt; {
    return Deferred {
        Future { promise in
            LPMetadataProvider().startFetchingMetadata(for: url) { (metadata, error) in
                promise(Result.success(metadata!))
            }
        }
    }.eraseToAnyPublisher()
}
</code></pre>
<pre><code>struct TrailerVideoResult: Codable {
    let results : [TrailerVideo]
}
</code></pre>
<pre><code>struct TrailerVideo: Codable {
    let key: String
    let site: String
}
</code></pre>
","10830089","","10830089","","2020-11-01 02:33:01","2020-11-01 03:10:21","Swift Combine Nested Publishers","<swift><combine>","2","9","1","","","CC BY-SA 4.0"
"64628393","1","64638634","","2020-11-01 03:22:58","","0","730","<p>I am starting on combine with swift, but having some hard time (had experience working in swiftui before).
So the question is how to perform certain operation:</p>
<ol>
<li>lets say i have vc1. and I go to vc2 from there
2.then i start asynchronos network closure and come back to vc1 (by popping out vc2).</li>
<li>Now say i want to ge just a string from vc2's asycnrhoss clousre to vc1 when i am back to vc1.
how can i achieve this?</li>
</ol>
<p>I want to use publisher of lets say &lt;String, Never&gt;
how can I subscribe in my vc1 and publish or send it from vc2 ?</p>
<p><strong>I am using this approach but its not working, it never comes to code under sink.....</strong></p>
<pre><code>public class Parent {
   public  static let shared = Parent()
   public var publisher = PassthroughSibject&lt;String,Never&gt;()
}

class vc1: ViewController {
   func viewdidLoad() {
     let subscription = Parent.shared.oublisehr.sink { (result) in
     print(result)
     }
  }
  func navigatetoVC1() {
  ///// some code to navigate to vc1
  }

  func button() {
    self.navigatetoVC1
  }

}


class vc2: ViewController {

   func viewDidload() {
   ///
   }
  func performsomeOperation() {
     someasyncoperation(completion: { result in
       switch result {
       case .success:
         //send some data to vc1
         Parent.shared.publisher.send(&quot;testdata&quot;)
       case .failure:
       //send some data to vc1
    })
  self.dismisVC2() //some method to pop out vc2
  } 
</code></pre>
<p>}</p>
","14556604","","","","","2020-11-02 01:14:52","Passing data between controllers using combine not working","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"64638418","1","64638555","","2020-11-02 00:37:01","","1","136","<p>I'm new to combine, and trying to figure out how to chain Publishers. I have one publisher that returns a string value that I would like to use to build a URLRequest, which is in turn being passed to a DataTaskPublisher. Any help with the correct syntax would be appreciated!</p>
<p>sample code:</p>
<pre><code>struct ResultObject: Decodable {}

func getValueKey() -&gt; AnyPublisher&lt;String, Error&gt; {
    return Just(&quot;Test&quot;)
        .setFailureType(to: Error.self)
        .eraseToAnyPublisher()
}

func performSearch(_ searchTerm: String) -&gt; AnyPublisher&lt;[ResultObject], Error&gt; {
    return getValueKey().flatMap { valueKey in
        let request: URLRequest = URLRequest(url: URL(string: &quot;http://www.test.com/\(valueKey)&quot;)!)
        return URLSession.shared.dataTaskPublisher(for: request)
            .map { $0.data }
            .decode(type: [ResultObject].self, decoder: JSONDecoder())
    }
    .eraseToAnyPublisher() /* Error: Type of expression is ambiguous without more context */
}
</code></pre>
<p>note: I'm very unsure about the position of the last <code>eraseToAnyPublisher</code></p>
","1561702","","1561702","","2020-11-02 01:06:01","2020-11-02 01:06:01","How do I use the value from one publisher in a request for a dataTaskPublisher in the same chain?","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"64653506","1","64653706","","2020-11-02 21:20:37","","0","42","<p><strong>Scenario:</strong> I want to look at a parameter of the <strong>CountryRegionListModel()</strong> in the debugger.
<br/>
The following are the view and it's dependent model snippets:</p>
<p>
<p><a href=""https://i.stack.imgur.com/82lWn.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/82lWn.png"" alt=""enter image description here"" /></a></p>
<p>
<pre><code>import Combine
import UIKit

protocol URLResource {
    associatedtype DataModel: Decodable
    var url: URL? { get }
}

struct CovidResource&lt;T: Decodable&gt;: URLResource {
    typealias DataModel = T
    var url = URL(string: &quot;https://disease.sh/v3/covid-19/apple/countries/Canada&quot;)
}

// =====================================================================================================

class CountryRegionListModel: ObservableObject {
    @Published var countryRegionList: [String] = []

    // Data Persistence:
    var cancellables: Set&lt;AnyCancellable&gt; = []

    // ---------------------------------------------------------------------------

    func getList&lt;Resource&gt;(urlDataModel: Resource) where Resource: URLResource {
        let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: urlDataModel.url!)
            .map(\.data)
            .receive(on: DispatchQueue.main)
            .decode(type: Resource.DataModel.self, decoder: JSONDecoder())

        remoteDataPublisher
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    print(&quot;Publisher Finished&quot;)
                case let .failure(anError):
                    Swift.print(&quot;received error: &quot;, anError)
                }
            }, receiveValue: { [self] someValue in
                self.countryRegionList = someValue as! [String]
            }).store(in: &amp;cancellables)
    }
}
</code></pre>
<p>
Here I'm calling a child picker view to display the data that is injected into it. <br/>
I want to check this data: <b>countryListViewModel.countryRegionList</b> via the debugger:
<p>
<pre><code>CountryRegionPickerView(countryRegionList: $countryListViewModel.countryRegionList)
                            
</code></pre>
<p><a href=""https://i.stack.imgur.com/tNPFm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tNPFm.png"" alt=""enter image description here"" /></a></p>
<p>
I don't understand why this is occurring. <br/>
How can I check to see if I got data passing into the child view?
  
","715747","","77567","","2020-11-02 21:40:05","2020-11-02 21:40:05","Unable to view a passing SwiftUI parameter value via debugger","<swift><swiftui><lldb>","1","0","","","","CC BY-SA 4.0"
"64661782","1","64662075","","2020-11-03 11:15:20","","1","251","<p>I am really new to Combine and I'm stuck with this issue. I have basic registration form, that returns empty response with 200 code if everything is ok and 442 if form has some registration failures.</p>
<p>That's the code that can handle empty response and works fine</p>
<pre><code>extension Route where ResultType: EmptyResult {
    func emptyResult() -&gt; AnyPublisher&lt;Void, APIError&gt; {
        return URLSession.shared.dataTaskPublisher(for: urlRequest)
            .print(&quot;EMPTY RESULT&quot;)
            .tryMap { data, response in
                guard let httpResponse = response as? HTTPURLResponse else { throw APIError.nonHttpResponse(description: &quot;Not http resp&quot;) }
                let statusCode = httpResponse.statusCode
                
                guard (200..&lt;300).contains(statusCode) else { throw APIError.nonHttpResponse(description: &quot;bad response&quot;)
                }
                    return Void()
            }.mapError { error in
                print(&quot;Error \(error)&quot;)
                return .network(description: error.localizedDescription)
            }
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>However, how I could return publisher with other type? For example</p>
<pre><code>struct CustomError: Decodable {
    let usernameError: String
    let emailError: String
}
</code></pre>
<p>My network call:</p>
<pre><code>    API.registration(name: name, email: email, password: password, schoolID: selectedSchool?.id ?? 0)
        .print(&quot;Registration&quot;)
        .receive(on: DispatchQueue.main)
        .sink(receiveCompletion: { (completion) in
            switch completion {
            case let .failure(error):
                print(&quot;ERROR \(error)&quot;)
            case .finished: break
            }
        }, receiveValue: { value in
            print(value)
        })
        .store(in: &amp;disposables)
</code></pre>
","10064816","","10064816","","2020-11-03 12:47:26","2020-11-03 13:08:02","Combine handle different type of publishers","<swift><networking><combine>","1","2","","","","CC BY-SA 4.0"
"64674464","1","64674679","","2020-11-04 04:58:57","","2","75","<p>I'm studying Combine Scheduler and I have this example code from Raywenderlich book</p>
<pre><code>let queue = OperationQueue()

let subscription = (1...10).publisher
  .receive(on: queue)
  .sink { value in
    print(&quot;Received \(value) on thread \(Thread.current.number)&quot;)
  }

</code></pre>
<p>The book is explaining that OperationQueue uses all available threads so the print order and thread could be random. I understand that part but when I run this code in my playground, I see only 5 numbers out of 10.</p>
<pre><code>Received 1 on thread 7
Received 2 on thread 6
Received 3 on thread 5
Received 7 on thread 9
Received 6 on thread 4
</code></pre>
<p>Why that code doesn't show all 10 numbers??</p>
","10611907","","","","","2020-11-04 11:09:25","print 1 to 10 in OperationQueue don't print whole number","<swift><multithreading><combine><operationqueue>","1","0","","","","CC BY-SA 4.0"
"64675594","1","64682962","","2020-11-04 07:15:11","","1","391","<p>I need to create a generic struct that will hold any decodable type which is returned from the network, so I created something like this:</p>
<pre><code>struct NetworkResponse&lt;Wrapped: Decodable&gt;: Decodable {
    var result: Wrapped
}
</code></pre>
<p>so I can use the decoding method like this:</p>
<pre><code>struct MyModel: Decodable {
  var id: Int
  var name: String
  var details: String
}

func getData&lt;R: Decodable&gt;(url: URL) -&gt; AnyPublisher&lt;R, Error&gt;
    URLSession.shared
   .dataTaskPublisher(for: url)
   .map(\.data)
   .decode(type: NetworkResponse&lt;R&gt;.self, decoder: decoder)
   .map(\.result)
   .eraseToAnyPublisher()

//call site
let url = URL(string: &quot;https://my/Api/Url&quot;)!
let models: [MyModel] = getData(url: url)
  .sink {
   //handle value here
}
</code></pre>
<p>But, I noticed that some responses from the network contains the <code>result</code> key, and some others do not:</p>
<p>with result:</p>
<pre><code>{
&quot;result&quot;: { [ &quot;id&quot;: 2, &quot;name&quot;: &quot;some name&quot;, &quot;details&quot;: &quot;some details&quot;] }
}
</code></pre>
<p>without result:</p>
<pre><code>[ &quot;id&quot;: 2, &quot;name&quot;: &quot;some name&quot;, &quot;details&quot;: &quot;some details&quot; ]
</code></pre>
<p>this results in the following error from the <code>.map(\.result)</code> publisher because it can't find the <code>result</code> key in the returned json:</p>
<p><code>(typeMismatch(Swift.Dictionary&lt;Swift.String, Any&gt;, Swift.DecodingError.Context(codingPath: [], debugDescription: &quot;Expected to decode Dictionary&lt;String, Any&gt; but found an array instead.&quot;, underlyingError: nil)))</code></p>
<p>How can I handle either case in the <code>NetworkResponse</code> struct in order to avoid such error?</p>
","1056118","","1056118","","2020-11-04 10:09:09","2020-11-04 15:56:10","Decoding a generic decodable type","<swift><codable><combine><decodable>","1","2","1","","","CC BY-SA 4.0"
"64685876","1","64687284","","2020-11-04 18:39:26","","1","504","<p>I have a <code>UIViewController</code> which using <code>UITableViewDiffableDataSource</code>. I have a view-model for this controller which looks something like:</p>
<pre><code>class ListViewModel {
    @Published private(set) var items: [Item] = []
    
    func load(params: [String: Any] = [:]) {
        WebRepo().index(params: params, completion: { [weak self] (items, error) in
            self?.items = items
        })
    }
    
    func deleteFirst() {
        self.items.remove(object: self.items.first)
    }
}
</code></pre>
<p>In my VC, I have a binding like:</p>
<pre><code>self.viewModel.$items.sink { [weak self] (scenes) in
    self?.update(items: items, animated: false)
}.store(in: &amp;self.subscriptions)
</code></pre>
<p>So, when I'm calling my view-model's <code>load</code> method - I want to do <code>self?.update(items: items, animated: false)</code>, but when I'm calling <code>deleteFirst</code> - I want <code>self?.update(items: items, animated: true)</code>.</p>
<p>I'm quite new to reactive and Combine, so not sure what is the proper way to handle this.
I can add <code>isReset</code> property to my view-model and change <code>load</code> method to something like:</p>
<pre><code>    func load(params: [String: Any] = [:]) {
        WebRepo().index(params: params, completion: { [weak self] (items, error) in
            self?.isReset = true
            self?.items = items
            self?.isReset = false
        })
    }
</code></pre>
<p>And inside <code>sink</code> just check this property, but it does not look as a proper way for me.</p>
","1246675","","","","","2020-11-04 20:42:22","Swift Combine two handlers for one property","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"64690518","1","64690738","","2020-11-05 02:48:23","","2","729","<p>I'm writing a Mock service to test login in a SwiftUI MVVM project. In my ViewModel:</p>
<pre><code>  func login() {
    self.cancellable = service.login(email: email, password: password)
      .sink(receiveCompletion: { [weak self] completion in
        switch completion {
          case .finished:
            break
          case .failure(let error):
            if let session = self?.session {
              session.currentUser = nil
            }
            print(error.localizedDescription)
        }
      }, receiveValue: { user in
        if let session = self.session {
          session.currentUser = user
        } 
      })
  }
</code></pre>
<p>My mock service code:</p>
<pre><code>func login(email: String, password: String) -&gt; AnyPublisher&lt;User, Error&gt; {
    
    let user = User(name: &quot;test&quot;, email: email, password: password)
    if email.lowercased() == &quot;test@mail.com&quot; &amp;&amp; password == &quot;Password!23&quot; {
      return Just(user)
        .setFailureType(to: Error.self)
        .eraseToAnyPublisher()
    } else {
      // ??? How to generate a failure here
    }
  }
</code></pre>
<p>My question is how to generate an error (failure) in my code? I only found some code sample regarding with error handling. But can't find how to generate an error in publisher.</p>
","118562","","","","","2020-11-05 03:19:45","Method to generate error (failure) for a SwiftUI Combine publisher","<ios><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"64691746","1","64691942","","2020-11-05 05:37:15","","1","133","<p>How do I peer into the data portion of this publisher? <br/>
I want to decipher the data (via <strong>String(bytes: data, encoding: .utf8)</strong>) during debug.</p>
<pre><code>func getList&lt;Resource&gt;(urlDataModel: Resource) where Resource: URLResource {
        let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: urlDataModel.url!)
            .map(\.data)
            .receive(on: DispatchQueue.main)
            .decode(type: Resource.DataModel.self, decoder: JSONDecoder())
            .print(&quot;getList: &quot;)
</code></pre>
","715747","","715747","","2020-11-05 06:47:52","2020-11-05 06:47:52","Debugging: How do I observe a publisher's data?","<ios><debugging><combine>","1","2","","","","CC BY-SA 4.0"
"64697969","1","64699777","","2020-11-05 13:13:50","","1","2999","<p>in my view controller I have a property <code>items</code> to which I have a subscription and rendering my view.</p>
<p>For this view controller I have a view model where I have load method like:</p>
<pre><code>    @Published private(set) var items: [Item] = []

    func load(params: [String: Any] = [:]) {
        self.isLoading = true
        
        self.subscription = WebRepo().index(params: params).sink(receiveCompletion: { [weak self] (completion) in
            switch completion {
            case .failure(let error):
                print(&quot;Error is: \(error.localizedDescription)&quot;)
            default: break
            }
            self?.isLoading = false
        }, receiveValue: { [weak self] (response) in
            self?.items = response.data
        })
    }
</code></pre>
<p>and my <code>WebRepo</code> looks like:</p>
<pre><code>final class WebRepo {
    func index(params: [String: Any]) -&gt; AnyPublisher&lt;MyResponse&lt;[Item]&gt;, Error&gt; {
        let url = URL(...)
        return AF.request(url, method: .get, parameters: params)
        .publishDecodable(type: MyResponse&lt;[Item]&gt;.self)
        .tryCompactMap { (response) -&gt; MyResponse&lt;[Item]&gt;? in
            if let error = response.error { throw error }
            return response.value
        }
        .eraseToAnyPublisher()
    }
}
</code></pre>
<p>My user can load multiple times and as you can see It will subscribe each time when <code>load</code> method is called, which I think should not be like this.</p>
<p>I tried to introduce property for my view model:</p>
<pre><code>private var indexResponse: AnyPublisher&lt;MyResponse&lt;[Item]&gt;, Error&gt;?

//And my load becomes

func load(params: [String: Any] = [:]) {
   self.isLoading = true
   self.indexResponse = WebRepo().index(params: params)
}
</code></pre>
<p>But in this case I can't make initial binding since initial value is <code>nil</code> hence it won't subscribe.</p>
<p>Another question is about handling error from load, do I need to have property for <code>error</code> inside view model or is there way I can rethrow an error for <code>$items</code>?</p>
","1246675","","","","","2020-11-08 13:46:36","Alamofire + Combine + MVVM request example","<ios><swift><alamofire><combine>","1","0","","","","CC BY-SA 4.0"
"64721407","1","64721861","","2020-11-06 20:49:14","","0","607","<p>having a bit of trouble with the following.</p>
<p>I have a List in a VStack as follows:</p>
<pre><code>List{
ForEach(fetchRequest.wrappedValue, id: \.self) { city in
                    
                 NavigationLink(destination: CityView(city: city, moc: self.moc)) {
                            
                            cityRow(city: city)
                 }
                    
         }
}
</code></pre>
<p>This list is populated from a coreData fetchrequest. Each NavigationLinks navigates to CityView and passes a city Object with it.</p>
<p>CityView had a observable object 'notificationHandler' defined as follows:</p>
<pre><code>struct CityView: View {

    @ObservedObject var notificationHandler = NotificationHandler()
    @ObservedObject var city: City
    
    var body: some View {

    }
}
</code></pre>
<p>NotificationHandler() sets up an instance of NotificationHandler and sets up a few notification observers from within init as follows:</p>
<pre><code>import Foundation
import Combine

class NotificationHandler: ObservableObject {
    
    let nc = NotificationHandler.default
    
    @Published var networkActive: Bool = false
    
    init() {
        nc.addObserver(self, selector: #selector(networkStart), name: Notification.Name(&quot;networkingStart&quot;), object: nil)
        nc.addObserver(self, selector: #selector(networkStop), name: Notification.Name(&quot;networkingStop&quot;), object: nil)
    }

}
</code></pre>
<p><strong>My issues is this - when the app boots onto its first view which contins the list above - I'm getting a number of instance of NotificationHandler starting - one for every row of the list.</strong> - This has led me to the belief that the NavigationLinks in the list are preemtivly loading the CityView's they hold. However I believe this is no longer the case and lazy load is the defualt behaviour. To add to that adding an onAppear() within CityView shows the they are not being completly loaded.</p>
<p>Any help would be greatly appretiated, I can't work out how this is happening.</p>
<p>Thanks</p>
","14223047","","14223047","","2020-11-06 21:15:42","2021-03-07 18:57:59","ObservedObject being loaded multiple times prior to navigation to its view","<swift><swiftui><swiftui-navigationlink><observableobject><observedobject>","2","5","","","","CC BY-SA 4.0"
"64746660","1","64746778","","2020-11-09 06:15:07","","0","123","<p>So I have a class that records the state of a toggle and a selection of a picker into UserDefaults</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

class UserSettings: ObservableObject {
    @Published var shouldSort: Bool {
        didSet {
            UserDefaults.standard.set(shouldSort, forKey: &quot;shouldSort&quot;)
        }
    }
    
    @Published var sortKey: String {
        didSet {
            UserDefaults.standard.set(sortKey, forKey: &quot;sortKey&quot;)
        }
    }
    
    public var sortKeys = [&quot;alphabetical&quot;, &quot;length&quot;, &quot;newest&quot;, &quot;oldest&quot;]
    
    init() {
        self.shouldSort = UserDefaults.standard.object(forKey: &quot;shouldSort&quot;) as? Bool ?? true
        self.sortKey = UserDefaults.standard.object(forKey: &quot;sortKey&quot;) as? String ?? &quot;Name&quot;
    }
}
</code></pre>
<p>On my settings page I use the following code</p>
<pre class=""lang-swift prettyprint-override""><code>@ObservedObject var userSettings = UserSettings()

...

Toggle(isOn: $userSettings.shouldSort, label: {Text(&quot;Sort Books&quot;)})

Picker(selection: $userSettings.sortKey, label: Text(&quot;Sort By&quot;), content: {
                            ForEach(userSettings.sortKeys, id: \.self){ key in
                                Text(key)
                            }
                        })
</code></pre>
<p>This code changes the value just fine because if I close and open the app, the views update based on the data. I am reading the data with</p>
<pre class=""lang-swift prettyprint-override""><code>@State var sorted =  UserDefaults.standard.bool(forKey: &quot;shouldSort&quot;)
@State var sort =  UserDefaults.standard.string(forKey: &quot;sortKey&quot;)
</code></pre>
<p>in my content view. (shouldSort calls a function to sort if true and sortKey determines how the data is sorted)</p>
<p>Am I reading the data wrong with the @State variable (can @State even detect changes in state of UserDefaults)?</p>
","12939143","","","","","2020-11-09 06:29:40","Views dependant on UserDefaults not updating on change","<ios><swift><swiftui>","1","1","","","","CC BY-SA 4.0"
"64758962","1","64759038","","2020-11-09 20:40:01","","1","181","<p>I want to tap a button in one view and change the text on another view.
The button that changes the bool is on LessonOne and the text I want to show in on my ContentView.</p>
<p>The code in my Lesson One is:</p>
<pre><code>import SwiftUI
import Combine

class LessonTwoButton: ObservableObject {
    let didChange = PassthroughSubject &lt;Void, Never &gt;()
    var ButtonIsTapped = false {didSet {didChange.send()}}
}

struct LessonOne: View {
    
    @ObservedObject var ActivateNextLesson = LessonTwoButton ()
    
    var body: some View {
        
        VStack{
            Button (action: {
                self.ActivateNextLesson.ButtonIsTapped.toggle()
            }
            , label: {
                Text(&quot;Activate the next lesson&quot;)
            })
            
        }
        
    }
    
}
</code></pre>
<p>The code in my ContentView is:</p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    
    @ObservedObject var lessontwobutton = LessonTwoButton()
    
    var body: some View {
        NavigationView{
            
            VStack{
                Text(&quot;Hello, world!&quot;)
                    .padding()
                
                if lessontwobutton.ButtonIsTapped{
                    Text (&quot;The button has been pressed. Your lesson is unlocked&quot;)}
                else{
                    Text(&quot;This lesson is locked&quot;)
                }
                
                NavigationLink (
                    destination: LessonOne(),
                    label: {
                        Text(&quot;Next view&quot;)
                    })
                
            }
            
        }
        
    }
}
</code></pre>
<p>The code runs, but it just doesn’t bind… I go on LessonOne, tap the button, get back to ContentView and nothing is changed. Can you please tell me what to do?</p>
","14608483","","8697793","","2020-11-09 20:50:07","2020-11-10 09:01:35","How to change a boolean instance of a class in another view?","<swift><swiftui><observedobject>","1","1","0","","","CC BY-SA 4.0"
"64770553","1","64824011","","2020-11-10 14:12:22","","0","113","<p>I'm new to SwiftUI and manual camera functionality, and I really need help.</p>
<p>So I trying to build a SwiftUI camera view that has a UIKit camera as a wrapper to control the focus lens position via SwiftUI picker view, display below a fucus value, and want to try have a correlation between AVcaptureDevice.lensPosition from 0 to 1.0 and feats that are displayed in the focus picker view. But for now, I only want to display that fucus number on screen.</p>
<p>And the problem is when I try to update focus via coordinator focus observation and set it to the camera view model then nothing happened. Please help 🙌</p>
<p>Here's the code:</p>
<pre><code>import SwiftUI
import AVFoundation
import Combine

struct ContentView: View {
    
    @State private var didTapCapture = false
    @State private var focusLensPosition: Float = 0
    @ObservedObject var cameraViewModel = CameraViewModel(focusLensPosition: 0)
    
    var body: some View {
        
        VStack {
            ZStack {
                CameraPreviewRepresentable(didTapCapture: $didTapCapture, cameraViewModel: cameraViewModel)
                    .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .center)
                
                VStack {
                    FocusPicker(selectedFocus: $focusLensPosition)
                    
                    Text(String(cameraViewModel.focusLensPosition))
                        .foregroundColor(.red)
                        .font(.largeTitle)
                }
                .frame(maxWidth: .infinity, alignment: .leading)
            }
            .edgesIgnoringSafeArea(.all)
            
            Spacer()
            
            CaptureButton(didTapCapture: $didTapCapture)
                .frame(width: 100, height: 100, alignment: .center)
                .padding(.bottom, 20)
        }
        
        
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

struct CaptureButton: View {
    @Binding var didTapCapture : Bool
    
    var body: some View {
        Button {
            didTapCapture.toggle()
            
        } label: {
            Image(systemName: &quot;photo&quot;)
                .font(.largeTitle)
                .padding(30)
                .background(Color.red)
                .foregroundColor(.white)
                .clipShape(Circle())
                .overlay(
                    Circle()
                        .stroke(Color.red)
                )
        }
    }
}

struct CameraPreviewRepresentable: UIViewControllerRepresentable {
    
    @Environment(\.presentationMode) var presentationMode
    @Binding var didTapCapture: Bool
    @ObservedObject var cameraViewModel: CameraViewModel
    
    let cameraController: CustomCameraController = CustomCameraController()
    
    func makeUIViewController(context: Context) -&gt; CustomCameraController {
        cameraController.delegate = context.coordinator
        
        return cameraController
    }
    
    func updateUIViewController(_ cameraViewController: CustomCameraController, context: Context) {
        
        if (self.didTapCapture) {
            cameraViewController.didTapRecord()
        }
    }
    
    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self, cameraViewModel: cameraViewModel)
    }
    
    class Coordinator: NSObject, UINavigationControllerDelegate, AVCapturePhotoCaptureDelegate {
        let parent: CameraPreviewRepresentable
        var cameraViewModel: CameraViewModel
        
        var focusLensPositionObserver: NSKeyValueObservation?
        
        init(_ parent: CameraPreviewRepresentable, cameraViewModel: CameraViewModel) {
            self.parent = parent
            self.cameraViewModel = cameraViewModel
            super.init()
            
            focusLensPositionObserver = self.parent.cameraController.currentCamera?.observe(\.lensPosition, options: [.new]) { [weak self] camera, _ in

                print(Float(camera.lensPosition))
                
                //announcing changes via Publisher
                self?.cameraViewModel.focusLensPosition = camera.lensPosition
            }
        }
        
        deinit {
            focusLensPositionObserver = nil
        }
        
        func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {
            
            parent.didTapCapture = false
            
            if let imageData = photo.fileDataRepresentation(), let image = UIImage(data: imageData) {
                UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil)
            }
            
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
}

class CameraViewModel: ObservableObject {
    @Published var focusLensPosition: Float = 0

    init(focusLensPosition: Float) {
        self.focusLensPosition = focusLensPosition
    }
}

class CustomCameraController: UIViewController {
    
    var image: UIImage?
    
    var captureSession = AVCaptureSession()
    var backCamera: AVCaptureDevice?
    var frontCamera: AVCaptureDevice?
    var currentCamera: AVCaptureDevice?
    var photoOutput: AVCapturePhotoOutput?
    var cameraPreviewLayer: AVCaptureVideoPreviewLayer?
    
    //DELEGATE
    var delegate: AVCapturePhotoCaptureDelegate?
    
    func showFocusLensPosition() -&gt; Float {
//        guard let camera = currentCamera else { return 0 }
        
//        try! currentCamera!.lockForConfiguration()
//        currentCamera!.focusMode = .autoFocus
////        currentCamera!.setFocusModeLocked(lensPosition: currentCamera!.lensPosition, completionHandler: nil)
//        currentCamera!.unlockForConfiguration()
        
        return currentCamera!.lensPosition
    }
    
    func didTapRecord() {
        
        let settings = AVCapturePhotoSettings()
        photoOutput?.capturePhoto(with: settings, delegate: delegate!)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setup()
    }
    
    func setup() {
        
        setupCaptureSession()
        setupDevice()
        setupInputOutput()
        setupPreviewLayer()
        startRunningCaptureSession()
    }
    
    func setupCaptureSession() {
        captureSession.sessionPreset = .photo
    }
    
    func setupDevice() {
        let deviceDiscoverySession =
            AVCaptureDevice.DiscoverySession(deviceTypes: [.builtInWideAngleCamera],
                                                                      mediaType: .video,
                                                                      position: .unspecified)
        for device in deviceDiscoverySession.devices {
            
            switch device.position {
            case .front:
                self.frontCamera = device
            case .back:
                self.backCamera = device
            default:
                break
            }
        }
        
        self.currentCamera = self.backCamera
    }
    
    func setupInputOutput() {
        do {
            
            let captureDeviceInput = try AVCaptureDeviceInput(device: currentCamera!)
            captureSession.addInput(captureDeviceInput)
            photoOutput = AVCapturePhotoOutput()
            captureSession.addOutput(photoOutput!)
            
        } catch {
            print(error)
        }
        
    }
    
    func setupPreviewLayer() {
        
        self.cameraPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession)
        self.cameraPreviewLayer?.videoGravity = AVLayerVideoGravity.resizeAspectFill
        
        let deviceOrientation = UIDevice.current.orientation
        cameraPreviewLayer?.connection?.videoOrientation = AVCaptureVideoOrientation(rawValue: deviceOrientation.rawValue)!
        
        self.cameraPreviewLayer?.frame = self.view.frame
//        view.transform = CGAffineTransform(scaleX: 0.5, y: 0.5)
        self.view.layer.insertSublayer(cameraPreviewLayer!, at: 0)
    }
    
    func startRunningCaptureSession() {
        captureSession.startRunning()
    }
}


struct FocusPicker: View {
    
    var feets = [&quot;∞ ft&quot;, &quot;30&quot;, &quot;15&quot;, &quot;10&quot;, &quot;7&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3.5&quot;, &quot;3&quot;, &quot;2.5&quot;, &quot;2&quot;, &quot;1.5&quot;, &quot;1&quot;, &quot;0.5&quot;, &quot;Auto&quot;]
    
    @Binding var selectedFocus: Float
    
    var body: some View {
        
        Picker(selection: $selectedFocus, label: Text(&quot;&quot;)) {
            ForEach(0 ..&lt; feets.count) {
                Text(feets[$0])
                    .foregroundColor(.white)
                    .font(.subheadline)
                    .fontWeight(.medium)
                
            }
            .animation(.none)
            .background(Color.clear)
            .pickerStyle(WheelPickerStyle())
        }
        .frame(width: 60, height: 200)
        .border(Color.gray, width: 5)
        .clipped()
    }
}
</code></pre>
","14553245","","14553245","","2020-11-11 12:46:29","2020-11-13 15:56:38","SwiftUI doesn't update state to @ObservedObject cameraViewModel object","<swiftui><uikit><combine><foundation>","1","0","","","","CC BY-SA 4.0"
"64774869","1","64776573","","2020-11-10 18:43:24","","1","94","<p>I am new to combine and struggling to understand how I can return the result of my fetch pins.</p>
<p>I can set the result as <code>@Published</code> but I want to just be able to call the fetch method and await the result or error.</p>
<pre><code>class PinService: NSObject, ObservableObject {
    private var session: Session
    private var subscriptions = Set&lt;AnyCancellable&gt;()
    
    init(session: Session) {
        self.session = session
        super.init()
    }
    
    func fetchPins (categories: Set&lt;CategoryModel&gt;, coordinates: CLLocationCoordinate2D)  {
        _fetchPins(categories: categories, coordinates: coordinates)
            .sink(receiveCompletion: { completion in
                switch completion {
                case .failure:
                    print(&quot;fetchPins() error&quot;)
                case .finished:
                    print(&quot;fetchPins() complete&quot;)
                }
            }, receiveValue: { pins in
                /*
                    What to do here?
                 
                    I can add a @Published var pins: [Pin], and do
                    self.pins = pins
                 
                    But if I want to be able to return the value or the error, how can I do that?
                 */
            })
            .store(in: &amp;self.subscriptions)
    }
    

    private func _fetchPins(categories: Set&lt;CategoryModel&gt;, coordinates: CLLocationCoordinate2D) -&gt; Future&lt;[Pin], Error&gt; {
        return Future&lt;[Pin], Error&gt; { promise in
            let categoryIds = categories.map { return $0.id }.joined(separator: &quot;,&quot;)
            
            let radius = 15 //miles
            
            self.session.request(baseUrl + &quot;/api/v1/pinsRadius?latitude=\(coordinates.latitude)&amp;longitude=\(coordinates.longitude)&amp;radius=\(radius)&amp;categories=\(categoryIds)&quot;)
                .responseDecodable(of: [Pin].self) { (response: DataResponse) in
                    switch response.result {
                    case .success(let pins):
                        promise(.success((pins)))
                    case .failure(let error):
                        promise(.failure(error))
                    }
            }
        }
    }
}
</code></pre>
<p>Sorry if its a dumb question, thanks.</p>
","1354934","","100297","","2020-11-11 11:53:08","2020-11-11 11:53:08","How do I return the result of my fetch call using combine?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"64779992","1","64780495","","2020-11-11 03:17:36","","-2","856","<p>I just want to do some test like this ↓</p>
<ol>
<li>Create one publisher from first view</li>
<li>Pass it to second view</li>
<li>Bind the publisher with some property in second view and try to show it on screen</li>
</ol>
<p>The code is ↓ (First View)</p>
<pre><code>struct ContentView: View {
    
    let publisher = URLSession(configuration: URLSessionConfiguration.default)
        .dataTaskPublisher(for: URLRequest(url: URL(string: &quot;https://v.juhe.cn/joke/content/list.php?sort=asc&amp;page=&amp;pagesize=&amp;time=1418816972&amp;key=aa73ebdd8672a2b9adc9dbb2923184c8&quot;)!))
        .map(\.data.description)
        .replaceError(with: &quot;Error!&quot;)
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
        
    
    var body: some View {
        NavigationView {
            List {
                NavigationLink(destination: ResponseView(publisher: publisher)) {
                    Text(&quot;Hello, World!&quot;)
                }
            }.navigationBarTitle(&quot;Title&quot;, displayMode: .inline)
        }
    }
}
</code></pre>
<p>(Second View)</p>
<pre><code>struct ResponseView: View {
    
    let publisher: AnyPublisher&lt;String, Never&gt;
    @State var content: String = &quot;&quot;
    
    var body: some View {
        HStack {
            VStack {
                Text(content)
                    .font(.system(size: 12))
                    .onAppear { _ = self.publisher.assign(to: \.content, on: self) }
                Spacer()
            }
            Spacer()
        }
        
    }
}
</code></pre>
<p>But the code is not working. The request failed with message blow ↓</p>
<pre><code>2020-11-11 11:08:04.657375+0800 PandaServiceDemo[83721:1275181] Task &lt;6B53516E-5127-4C5E-AD5F-893F1AEE77E8&gt;.&lt;1&gt; finished with error [-999] Error Domain=NSURLErrorDomain Code=-999 &quot;cancelled&quot; UserInfo={NSErrorFailingURLStringKey=https://v.juhe.cn/joke/content/list.php?sort=asc&amp;page=&amp;pagesize=&amp;time=1418816972&amp;key=aa73ebdd8672a2b9adc9dbb2923184c8, NSLocalizedDescription=cancelled, NSErrorFailingURLKey=https://v.juhe.cn/joke/content/list.php?sort=asc&amp;page=&amp;pagesize=&amp;time=1418816972&amp;key=aa73ebdd8672a2b9adc9dbb2923184c8}
</code></pre>
<p>Can someone tell me what happened and what is the right approach to do this?</p>
","8287098","","341994","","2020-11-12 11:55:54","2020-11-12 11:55:54","SwiftUI Why Can't pass a publisher between Views?","<swift><swiftui><combine>","4","1","0","","","CC BY-SA 4.0"
"64793177","1","64798905","","2020-11-11 19:46:42","","0","152","<p>I am using Firebase as my backend, when a user signs up I create a new document in my Firestore DB and then start a listener on that document. When a user signs out I want to be able to stop listening for security reasons.
I currently have a standard Session listener class that handles Firebase authentication and detects when a user has logged in / logged out:</p>
<p><strong>SessionListener</strong></p>
<pre><code>class SessionListener : ObservableObject {
@Published var session: User? { didSet { self.didChange.send(self) }}

var carRepo: CarRepository = CarRepository()
var didChange = PassthroughSubject&lt;SessionListener, Never&gt;()
var handle: AuthStateDidChangeListenerHandle?
    
func listen () {
    // monitor authentication changes using firebase
    handle = Auth.auth().addStateDidChangeListener { (auth, user) in
        if let user = user {
            // if we have a user, create a new user model
            self.session = User(uid: user.uid,name,email: user.email)
            self.carRepo.initialiseUser()
        } else {
            // if we don't have a user, set our session to nil
            self.session = nil
        }
    }
}
...
//Sign in / Sign up methods below
</code></pre>
<p>I also have a repository class to communicate with my Firestore DB (set up listeners etc.)</p>
<p><strong>CarRepository</strong></p>
<pre><code>class CarRepository: ObservableObject {

let db = Firestore.firestore()
@Published var cars = [Car]()
@Published var listener: ListenerRegistration?

init(){
    loadData()
}

func detatchListener(){
    if(self.listener != nil) {
        self.listener!.remove()
    }
}
    
func loadData() {        
    if(Auth.auth().currentUser?.uid != nil){
        self.listener = db.collection(&quot;users&quot;).document(Auth.auth().currentUser!.uid).collection(&quot;cars&quot;).addSnapshotListener { (querySnapshot, error) in
        if let querySnapshot = querySnapshot {
            querySnapshot.documents.compactMap { document in  
                try? self.cars.append(document.data(as: Car.self)!)
            }
        }
        }
    }
}
...
//Add user to DB below
</code></pre>
<p>My problem is that I need to access this CarRepository from both the SessionListener (detect when a user logs out so that I can call <strong>detachListener()</strong>, and I also need to access <strong>CarRepository</strong> in a viewModel to parse the cars array.<br />
The problem is that this is creating two separate instances of <strong>CarRepository</strong> (multiple listeners are being set up for the same document, and only the instance was created by <strong>SessionListener</strong> will have <strong>detachListener()</strong> called. Instead, I want there to be a single object that all classes/structs have access to.</p>
","10142976","","","","","2020-11-12 06:22:44","Referencing a single instance of a class for entire application (Firebase)","<ios><swift><google-cloud-firestore><swiftui>","1","0","","","","CC BY-SA 4.0"
"64814296","1","64814742","","2020-11-13 01:41:41","","0","246","<p>I'm following a tutorial to make a reminders app in swiftui. I'm pretty new to more complex apps in swiftui and there were these errors in the debugger. What do they mean and how I can solve them. If it helps, the tutorial that I'm watching is this: <a href=""https://www.youtube.com/watch?v=4RUeW5rUcww"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=4RUeW5rUcww</a></p>
<p>Thank you in advance.</p>
<pre><code>1)TaskListView.swift:15:25: error: failed to produce diagnostic for expression; please file a bug report
    var body: some View {

2) TaskListView.swift:20:45: error: cannot find 'taskCellVM' in scope
                    in TaskCell(taskCellVM: taskCellVM)
                                            ^~~~~~~~~~
</code></pre>
<p>TaskListView.swift</p>
<pre><code>import SwiftUI

struct TaskListView: View {
    @ObservedObject var taskListVM = TaskListViewModel()
    
    let tasks = testDataTasks
    
    var body: some View {
        NavigationView {
            VStack(alignment: .leading) {
                List(taskListVM.taskCellViewModels){
                    TaskCellVM
                    in TaskCell(taskCellVM: taskCellVM)
                    
                }
                Button(action: {}) {
                    HStack {
                        Image(systemName: &quot;plus.circle.fill&quot;).resizable().frame(width: 20, height: 20)
                        Text(&quot;Add New Task&quot;)
                    }
                }
            }
            .padding()
        }
        .navigationBarTitle(&quot;Tasks&quot;)
    }
}

struct TaskListView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            TaskListView()
                .previewDevice(&quot;iPhone 12 Pro Max&quot;)
        }
    }
}

struct TaskCell: View {
    @ObservedObject var taskCellVM: TaskCellViewModel
    
    var body: some View {
        HStack {
            Image(systemName: taskCellVM.task.completed ? &quot;checkmark.circle.fill&quot; :  &quot;circle&quot;).resizable().frame(width: 20, height: 20)
            Text(taskCellVM.task.title)
        }
    }
}
</code></pre>
<p>TaskCellViewModel.swift</p>
<pre><code>import Foundation
import Combine

class TaskCellViewModel: ObservableObject, Identifiable {
    @Published var task: Task
    
    var id = &quot;&quot;
    @Published var completionStateIconName = &quot;&quot;
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(task: Task) {
        self.task = task
        
        $task
            .map{
            task in task.completed ? &quot;checkmark.circle.fill&quot; : &quot;circle&quot;
        }
        .assign(to: \.completionStateIconName, on: self)
        .store(in: &amp;cancellables)
        
        $task
            .map { task
                in task.id
            }
            .assign(to: \.id, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>TaskListViewModel.swift</p>
<pre><code>import Foundation
import Combine

class TaskListViewModel: ObservableObject {
    @Published var taskCellViewModels = [TaskCellViewModel]()
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        self.taskCellViewModels = testDataTasks.map{
            task in TaskCellViewModel(task: task)
        }
    }
}
</code></pre>
","","user14518353","","","","2020-11-13 02:44:56","Cannot find 'taskCellVM' in scope","<swift><swiftui>","1","1","0","","","CC BY-SA 4.0"
"64817953","1","64818443","","2020-11-13 08:56:15","","0","1836","<p>I want to achieve this: A class <code>A</code>, which has a property <code>var c1: C</code> and <code>var b1: B</code>, if the property of <code>C</code> changes, then the property of <code>b1</code> should be updated.</p>
<p>Here is my code:</p>
<pre><code>import UIKit
import Combine

struct B {
    var b = &quot;b&quot;
}

class C: ObservableObject {
    @Published var c: String = &quot;c1&quot;
}

class A: ObservableObject {
    var b1 = B()
    var cancellables = Set&lt;AnyCancellable&gt;()
    @Published var c1 = C()

    init() {

        $c1.sink {
            print(&quot;new value is \($0.c)&quot;) //Only print once
            self.b1.b = $0.c
        }.store(in: &amp;cancellables)
    }

    func printMe() {
        print(&quot;b1.b: \(b1.b)&quot;)
        print(&quot;c1.c: \(c1.c)&quot;)
    }
}



let a = A()
a.c1.c = &quot;c2&quot;
a.printMe()


a.c1.c = &quot;c3&quot;
a.printMe()
</code></pre>
<p>The output is:</p>
<pre><code>new value is c1
b1.b: c1
c1.c: c2
b1.b: c1
c1.c: c3
</code></pre>
<p>Every time the <code>a.c1.c</code> was updated I expected <code>a.b1.b</code> should be updated automatically by <code>sink</code>, not sure if anything I missed, the <code>sink</code> closure body just was called once.</p>
<p>Any suggestion? thanks!</p>
","291240","","291240","","2020-11-13 09:20:45","2020-11-13 09:28:27","Swift Combine doesn't update value by sink","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"64848598","1","64848699","","2020-11-15 19:02:52","","1","87","<p>The application schema is simple: if the session variable is nil, the login screen appears. If the password and login are successfully entered, we create a new user model and the session variable ceases to be nil. However, this does not happen, as a result, a login screen always appears in front of us, regardless of whether the login was successful or not.</p>
<p>(I get a debug message while opening the application &quot;Got user: &lt;FIRUser: 0x600003c29b80&gt;&quot; which indicates that there are no problems with authentication)</p>
<p><strong>ContentView.swift:</strong></p>
<pre><code>import SwiftUI

struct ContentView: View {
    @EnvironmentObject var session: SessionStore
    
    func getUser () {
          session.listen()
      }

    var body: some View {
        Group {
            if (session.session != nil) {
                Text(&quot;Hello user!&quot;)
              } else {
                SignInView()
              }
        }.onAppear(perform: getUser)
    }
}
</code></pre>
<p><strong>SessionStore.swift:</strong></p>
<pre><code>import SwiftUI
import Firebase
import Combine

class SessionStore : ObservableObject {
    var didChange = PassthroughSubject&lt;SessionStore, Never&gt;()
    var session: User? { didSet { self.didChange.send(self) }}
    var handle: AuthStateDidChangeListenerHandle?

    func listen () {
        // monitor authentication changes using firebase
        handle = Auth.auth().addStateDidChangeListener { (auth, user) in
            if let user = user {
                // if we have a user, create a new user model
                print(&quot;Got user: \(user)&quot;)
                self.session = User(
                    uid: user.uid,
                    displayName: user.displayName,
                    email: user.email
                    
                )
            } else {
                // if we don't have a user, set our session to nil
                self.session = nil
            }
        }
    }

    func signUp(
            email: String,
            password: String,
            handler: @escaping AuthDataResultCallback
            ) {
            Auth.auth().createUser(withEmail: email, password: password, completion: handler)
        }

    func signIn(
        email: String,
        password: String,
        handler: @escaping AuthDataResultCallback
        ) {
        Auth.auth().signIn(withEmail: email, password: password, completion: handler)
    }

    func signOut () -&gt; Bool {
        do {
            try Auth.auth().signOut()
            self.session = nil
            return true
        } catch {
            return false
        }
    }
}
</code></pre>
<p><strong>SignInView.swift:</strong></p>
<pre><code>import SwiftUI

struct SignInView : View {

    @State var email: String = &quot;&quot;
    @State var password: String = &quot;&quot;
    @State var loading = false
    @State var error = false

    @EnvironmentObject var session: SessionStore

    func signIn () {
        loading = true
        error = false
        session.signIn(email: email, password: password) { (result, error) in
            self.loading = false
            if error != nil {
                self.error = true
            } else {
                self.email = &quot;&quot;
                self.password = &quot;&quot;
            }
        }
    }

    var body: some View {
        VStack {
            TextField(&quot;email address&quot;, text: $email)
            SecureField(&quot;password&quot;, text: $password)
            if (error) {
                Text(&quot;ahhh crap&quot;)
            }
            Button(action: signIn) {
                Text(&quot;Sign In&quot;)
            }
        }
    }
}
</code></pre>
","13696467","","","","","2020-11-15 19:11:12","Firebase session variable is always nil","<ios><swift><firebase><firebase-authentication><swiftui>","1","0","","","","CC BY-SA 4.0"
"64849556","1","64851228","","2020-11-15 20:41:50","","0","1798","<p>I'm currently using Moya alpha 15 with Combine Framework for my SwiftUI project. With Moya, I have a provider that's responsible for creating requests.</p>
<p>What I want:</p>
<ol>
<li>Use getInstance(page: Int) to get my initial instanceResponseList object.</li>
<li>From that instanceResponseList object, check each instance if hasChildren == true</li>
<li>If hasChildren == true, call getInstanceChildren(id: String) using the instance's id</li>
<li>response from getInstanceChildren(id: String) will be mapped and assigned to the children: [Instance] property(response.data.instances)</li>
</ol>
<p>Is this possible? If not, is there a better way to do this?</p>
<p>What I'm trying to do:</p>
<p>I need to show a profile image using the profileURL from Instance in a tableView. The height of each cell will be dynamic and based on the aspect ratio of each image. Each cell could have 1 + children profile images arranged differently.</p>
<p>Some sample code of my service call and data models:</p>
<pre><code>    public struct InstanceResponseList: Codable {
        public var success: Bool
        public var data: InstanceResponse
    }

    public struct InstanceResponse: Codable {
        public var instances: [Instance]
        public var hasMore: Bool //for pagination
    }

    public struct Instance: Codable {
        public var id: String
        public var profileURL: String?
        public var hasChildren: Bool


        public var children: [Instance] // I want to make a request and append the children for each of my instances.

        enum CodingKeys: String, CodingKey {
            case id = &quot;instance_id&quot;
            case profileURL = &quot;profile_url&quot;
            case hasChildren = &quot;has_children&quot;
        }
    }

    public func getInstance(page: Int) -&gt; AnyPublisher&lt;InstanceResponseList, MoyaError&gt; {
        return instanceProvider
            .requestPublisher(.allInstances(page: page, show: 10)) // page &amp; show are parameters used for pagination, not relevant here
            .map(InstanceResponseList.self)
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }

    public func getInstanceChildren(id: String) -&gt; AnyPublisher&lt;InstanceResponseList, MoyaError&gt; {
        return haptagramProvider
            .requestPublisher(.children(id: id))
            .map(InstanceResponseList.self)
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }

</code></pre>
<p>My attempt:</p>
<pre><code>    public func getInstanceWithChildren(page: Int) -&gt; AnyPublisher&lt;[Instance], MoyaError&gt; {
        
        return getInstance(page: Int)
            .flatMap { instanceResponseList -&gt; AnyPublisher&lt;Instance, MoyaError&gt; in
                Publishers.Sequence(sequence: instanceResponseList.data.instances).eraseToAnyPublisher()
            }
            .flatMap { instance -&gt; AnyPublisher&lt;Instance, MoyaError&gt; in
                return getInstanceChildren(id: instance.id).map {
                    let instance = instance
                    instance.children = $0
                    return instance
                }
                .eraseToAnyPublisher()
                
            }
            .collect()
            .eraseToAnyPublisher()
    }

</code></pre>
<p>which returns <code>AnyPublisher&lt;[Instance], MoyaError&gt;</code>, but I'm looking to return <code>AnyPublisher&lt;InstanceResponseList, MoyaError&gt;</code>.</p>
","1221857","","1221857","","2020-11-15 23:46:36","2020-11-16 02:31:21","How to have multiple requests using Combine Framework","<ios><swift><reactive-programming><combine><moya>","1","4","","","","CC BY-SA 4.0"
"64854765","1","64855339","","2020-11-16 08:33:27","","2","3123","<p>I was looking for good solutions for loading images asynchronously from a remote server image URL. There were many solutions online. It's a shame Apple doesn't provide one natively for something that is so common. Anyways, I found <a href=""https://www.swiftbysundell.com/tips/constant-combine-publishers/"" rel=""nofollow noreferrer"">Sundell's blog</a> really interesting and took the good bits from it to create my own ImageLoader, as shown below:</p>
<pre><code>import Combine

class ImageLoader {

    private let urlSession: URLSession
    private let cache: NSCache&lt;NSURL, UIImage&gt;

    init(urlSession: URLSession = .shared,
         cache: NSCache&lt;NSURL, UIImage&gt; = .init()) {
        self.urlSession = urlSession
        self.cache = cache
    }

    func publisher(for url: URL) -&gt; AnyPublisher&lt;UIImage, Error&gt; {
        if let image = cache.object(forKey: url as NSURL) {
            return Just(image)
                .setFailureType(to: Error.self)
                .receive(on: DispatchQueue.main)
                .eraseToAnyPublisher()
        } else {
            return urlSession
                .dataTaskPublisher(for: url)
                .map(\.data)
                .tryMap { data in
                    guard let image = UIImage(data: data) else {
                        throw URLError(.badServerResponse, userInfo: [
                            NSURLErrorFailingURLErrorKey: url
                        ])
                    }
                    return image
                }
                .receive(on: DispatchQueue.main)
                .handleEvents(receiveOutput: { [cache] image in
                    cache.setObject(image, forKey: url as NSURL)
                })
                .eraseToAnyPublisher()
        }
    }
}
</code></pre>
<p>As you can see the publisher provides an instance of <code>AnyPublisher&lt;UIImage, Error&gt;</code>. I'm not entirely sure on how to use this <code>ImageLoader</code> in my <code>MyImageView</code> shown below:</p>
<pre><code>struct MyImageView: View {

    var url: URL
    var imageLoader = ImageLoader()

    @State private var image = #imageLiteral(resourceName: &quot;placeholder&quot;)

    var body: some View {
        Image(uiImage: image)
            .onAppear {
                let cancellable = imageLoader.publisher(for: url).sink(receiveCompletion: { failure in
                    print(failure) // doesn't print
                }, receiveValue: { image in
                    self.image = image // not getting executed
                })
                cancellable.cancel() // tried with and without this line.
            }
    }
}
</code></pre>
<p>How do I extract the <code>UIImage</code> from the <code>ImageLoader</code> publisher that returns an instance of <code>AnyPublisher&lt;UIImage, Error&gt;</code>?</p>
","7098650","","","","","2021-06-14 02:11:24","Loading image from remote URL asynchronously in SwiftUI Image using combine's Publisher","<swift><image><swiftui><combine><publisher>","3","4","0","","","CC BY-SA 4.0"
"64889594","1","64898688","","2020-11-18 08:35:59","","1","343","<p>I want to verify the user еmail, for this I send the verification link, follow it, and expect the isEmailVerified property to change its value to true, but this does not happen (even if I reopen the application). The property changes its value to true only if I log out and log in again.</p>
<p>What is the explanation for this behavior? How to check a user email for verification without leaving account?</p>
<p><em>ContentView.swift:</em></p>
<pre><code>struct ContentView: View {
    @EnvironmentObject var session: SessionStore
    
    var body: some View {
        Group {
            if (self.session.session != nil) {
                VStack{
                    Text(&quot;Logged In As \(Auth.auth().currentUser?.email ?? &quot;&quot;)&quot;)
                    Text(&quot;\(String(self.session.session!.isEmailVerified!))&quot;)
//This also print false:
//Text(&quot;\(String((Auth.auth().currentUser?.isEmailVerified)!))&quot;)

                    Button(action: {Auth.auth().currentUser?.sendEmailVerification { (error) in
                        // ...
                    }}){
                        Text(&quot;Verify email&quot;)
                    }
                    Button(action: {session.signOut()}){
                        Text(&quot;Sign Out&quot;)
                    }
                }
            } else {
                SignInView()
            }
            
        }.onAppear(perform: {
            session.listen()
        })
    }
}
</code></pre>
<p><em>SessionStore.swift:</em></p>
<pre><code>class SessionStore : ObservableObject {
    var didChange = PassthroughSubject&lt;SessionStore, Never&gt;()
    @Published var session: User? { didSet { self.didChange.send(self) }}
    var handle: AuthStateDidChangeListenerHandle?
    
    func listen () {
        // monitor authentication changes using firebase
        handle = Auth.auth().addStateDidChangeListener { (auth, user) in
            if let user = user {
                // if we have a user, create a new user model
                print(&quot;Got user: \(user)&quot;)
                DispatchQueue.main.async {
                    self.session = User(
                        uid: user.uid,
                        displayName: user.displayName,
                        email: user.email,
                        isEmailVerified: user.isEmailVerified
                    )
                }
            } else {
                // if we don't have a user, set our session to nil
                self.session = nil
            }
        }
    }
    
    func signUp(
        email: String,
        password: String,
        handler: @escaping AuthDataResultCallback
    ) {
        Auth.auth().createUser(withEmail: email, password: password, completion: handler)
    }
    func signIn(
        email: String,
        password: String,
        handler: @escaping AuthDataResultCallback) {
        Auth.auth().signIn(withEmail: email, password: password, completion: handler)
    }
    
    func signOut () -&gt; Bool {
        do {
            try Auth.auth().signOut()
            self.session = nil
            return true
        } catch {
            return false
        }
    }
}
</code></pre>
","13696467","","13696467","","2020-11-18 09:09:05","2020-11-18 17:58:27","How to check if user email verified?","<ios><swift><firebase><firebase-authentication><swiftui>","1","2","0","","","CC BY-SA 4.0"
"64902399","1","64904404","","2020-11-18 22:27:05","","0","646","<p>I'm trying to have a combine pipeline that fetches five random photo urls using the Unsplash API, then downloads a photo from each url. The issue I’m running into is that the images are mostly the same. Sometimes (and I don't know why) one of the images will be different than the other four.</p>
<p>Any help would be appreciated. I've included all the necessary code besides the UnSplash Api key.</p>
<pre><code>static func fetchRandomPhotos() -&gt; AnyPublisher&lt;UIImage, Error&gt;{
        let string = createURL(path: &quot;/photos/random&quot;)

        return [1,2,3,4,5]
            .publisher
            .flatMap{ i -&gt; AnyPublisher&lt;UnsplashImageResults, Error&gt; in
                return self.downloadAndDecode(string, type: UnsplashImageResults.self)
            }
            .flatMap{ result -&gt; AnyPublisher&lt;UIImage, Error&gt; in
                print(result.urls.thumb)
                let url = URL(string: result.urls.thumb)!
                return URLSession.shared.dataTaskPublisher(for: url)
                    .map { UIImage(data: $0.data)! }
                    .mapError{_ in NetworkError.invalidURL}
                    .eraseToAnyPublisher()
            }
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }

</code></pre>
<pre><code>struct UnsplashURLs: Decodable{
    let full: String
    let regular: String
    let small: String
    let thumb: String
}

struct UnsplashImageResults: Decodable{
    let urls: UnsplashURLs
}
</code></pre>
<pre><code>enum NetworkError: LocalizedError{
    case invalidURL

    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return &quot;The url is invalid&quot;
        }
    }
}
</code></pre>
<pre><code>static private func createURL(path: String)-&gt; String{
        var components = URLComponents()
        components.scheme     = &quot;https&quot;
        components.host       = &quot;api.unsplash.com&quot;
        components.path       = path
        components.queryItems = [
            URLQueryItem(name: &quot;client_id&quot;, value: &quot;YOUR API KEY HERE&quot;)
        ]
        
        return components.string!
    }
    
    static private func downloadAndDecode&lt;T:Decodable&gt;(_ urlString: String, type: T.Type) -&gt; AnyPublisher&lt;T, Error&gt;{
        guard let url = URL(string: urlString) else{
            return Fail(error: NetworkError.invalidURL).eraseToAnyPublisher()
        }
        return URLSession.shared.dataTaskPublisher(for: url)
            .tryMap() { element -&gt; Data in
                guard let httpResponse = element.response as? HTTPURLResponse,
                      httpResponse.statusCode == 200 else {
                    throw URLError(.badServerResponse)
                }
                return element.data
            }
            .decode(type: T.self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }
</code></pre>
<pre><code>class UnsplashImagesViewModel: ObservableObject{
    var subscriptions = Set&lt;AnyCancellable&gt;()
    @Published var images = [UIImage]()
    
    init(){
        UnsplashAPI.fetchRandomPhotos()
            .sink { (_) in
                
            } receiveValue: { image in
                self.images.append(image)
            }.store(in: &amp;subscriptions)

    }
}

struct UnsplashImagesGrid: View {
    @StateObject private var model = UnsplashImagesViewModel()
    
    var body: some View {
        List(model.images, id: \.self){ image in
            Image(uiImage: image)
        }
    }
}
</code></pre>
","10830089","","","","","2020-11-19 02:14:26","Repeat Network Request Multiple Times With Swift Combine","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"64909143","1","65507827","","2020-11-19 09:48:49","","1","104","<p>I'm new to SwiftUI and Combine. What I trying to build is a manual camera app, and there's only 4 UI component:</p>
<ul>
<li><code>CaptureButton</code> for making a shot from the camera</li>
<li><code>FocusPicker</code> for controlling manually camera focus exposure</li>
<li><code>OffsetView</code> for displaying a level of exposure</li>
<li><code>CameraPreviewRepresentable</code> for integrating UIKit camera into SwiftUI view</li>
</ul>
<p>Also added Privacy requests into.Info.plist file from a user to allow camera feature and saving to Apple Photo App</p>
<p><a href=""https://i.stack.imgur.com/QYYkl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QYYkl.png"" alt=""enter image description here"" /></a></p>
<p>For updating data and passing it to the UI, I'm using <code>CameraViewModel</code>, <code>currentCameraSubject</code> and <code>currentCamera</code> Publisher to showing new values from <code>AVCaptureDevice</code> and setting it to <code>CameraViewModel</code>.</p>
<p>And I'm noticing a really interesting behavior/bug of <code>FocusPicker</code> when I start interacting with it and piking a new focus it constantly get back to started position and when <code>OffsetView</code> is getting a new value each time.</p>
<p>But interesting enough for example when <code>OffsetView</code> has the same value then <code>FocusPicker</code> is doing normal. And I do not know why this is happening. Please help, it's really frustrating to fix for me.</p>
<p>By the way, it will only work on a real device only.</p>
<p>Here's all the code:</p>
<pre><code>import SwiftUI

//@main
//struct StackOverflowCamApp: App {
//    var cameraViewModel = CameraViewModel(focusLensPosition: 0)
//    let cameraController: CustomCameraController = CustomCameraController()
//
//    var body: some Scene {
//        WindowGroup {
//            ContentView(cameraViewModel: cameraViewModel, cameraController: cameraController)
//        }
//    }
//}

struct ContentView: View {
    
    @State private var didTapCapture = false
    @ObservedObject var cameraViewModel: CameraViewModel
    let cameraController: CustomCameraController
    
    var body: some View {
        
        VStack {
            ZStack {
                CameraPreviewRepresentable(didTapCapture: $didTapCapture, cameraViewModel: cameraViewModel, cameraController: cameraController)
                    .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .center)
                
                VStack {
                    FocusPicker(selectedFocus: $cameraViewModel.focusChoice)
                    
                    Text(String(format: &quot;%.2f&quot;, cameraViewModel.focusLensPosition))
                        .foregroundColor(.red)
                        .font(.largeTitle)
                }
                .frame(maxWidth: .infinity, alignment: .leading)
            }
            .edgesIgnoringSafeArea(.all)
            
            Spacer()
            
            OffsetView(levelValue: cameraViewModel.exposureTargetOffset, height: 100)
                .frame(maxWidth: .infinity, alignment: .leading)
            
            CaptureButton(didTapCapture: $didTapCapture)
                .frame(width: 100, height: 100, alignment: .center)
                .padding(.bottom, 20)
        }
    }
}

struct CaptureButton: View {
    @Binding var didTapCapture : Bool
    
    var body: some View {
        Button {
            didTapCapture.toggle()
            
        } label: {
            Image(systemName: &quot;photo&quot;)
                .font(.largeTitle)
                .padding(30)
                .background(Color.red)
                .foregroundColor(.white)
                .clipShape(Circle())
                .overlay(
                    Circle()
                        .stroke(Color.red)
                )
        }
    }
}

struct OffsetView: View {
    
    var levelValue: Float
    let height: CGFloat
    
    var body: some View {

        ZStack {
            Rectangle()
                .foregroundColor(.red)
                .frame(maxWidth: height / 2, maxHeight: height, alignment: .trailing)

            Rectangle()
                .foregroundColor(.orange)
                .frame(maxWidth: height / 2, maxHeight: height / 20, alignment: .trailing)
                .offset(x: 0, y: min(CGFloat(-levelValue) * height / 2, height / 2))
        }
    }
}

struct FocusPicker: View {
    
    @Binding var selectedFocus: FocusChoice
    
    var body: some View {
        
        Picker(selection: $selectedFocus, label: Text(&quot;&quot;)) {
            ForEach(0..&lt;FocusChoice.allCases.count) {
                Text(&quot;\(FocusChoice.allCases[$0].caption)&quot;)
                    .foregroundColor(.white)
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .tag(FocusChoice.allCases[$0])
            }
            .animation(.none)
            .background(Color.clear)
            .pickerStyle(WheelPickerStyle())
        }
        .frame(width: 60, height: 200)
        .border(Color.gray, width: 5)
        .clipped()
    }
}

import SwiftUI
import Combine
import AVFoundation

struct CameraPreviewRepresentable: UIViewControllerRepresentable {
    
    @Environment(\.presentationMode) var presentationMode
    @Binding var didTapCapture: Bool
    @ObservedObject var cameraViewModel: CameraViewModel
    
    let cameraController: CustomCameraController
    
    func makeUIViewController(context: Context) -&gt; CustomCameraController {
        cameraController.delegate = context.coordinator
        
        return cameraController
    }
    
    func updateUIViewController(_ cameraViewController: CustomCameraController, context: Context) {
        
        if didTapCapture {
            cameraViewController.didTapRecord()
        }
        
        // checking if new value is differnt from the previous value
        if cameraViewModel.focusChoice.rawValue != cameraViewController.manualFocusValue {
            cameraViewController.manualFocusValue = cameraViewModel.focusChoice.rawValue
        }
    }
    
    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self, cameraViewModel: cameraViewModel)
    }
    
    class Coordinator: NSObject, UINavigationControllerDelegate, AVCapturePhotoCaptureDelegate {
        let parent: CameraPreviewRepresentable
        var cameraViewModel: CameraViewModel
        
        var tokens = Set&lt;AnyCancellable&gt;()
        
        init(_ parent: CameraPreviewRepresentable, cameraViewModel: CameraViewModel) {
            self.parent = parent
            self.cameraViewModel = cameraViewModel
            super.init()
            
            // for showing focus lens position
            self.parent.cameraController.currentCamera
                    .filter { $0 != nil }
                    .flatMap { $0!.publisher(for: \.lensPosition) }
                    .assign(to: \.focusLensPosition, on: cameraViewModel)
                    .store(in: &amp;tokens)
            
            // for showing exposure offset
            self.parent.cameraController.currentCamera
                .filter { $0 != nil }
                .flatMap { $0!.publisher(for: \.exposureTargetOffset) }
                .assign(to: \.exposureTargetOffset, on: cameraViewModel)
                .store(in: &amp;tokens)
        }
        
        func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {
            
            parent.didTapCapture = false
            
            if let imageData = photo.fileDataRepresentation(), let image = UIImage(data: imageData) {
                UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil)
            }
            
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
}

import Combine
import AVFoundation

class CameraViewModel: ObservableObject {
    @Published var focusLensPosition: Float = 0
    @Published var exposureTargetOffset: Float = 0
    
    @Published var focusChoice: FocusChoice = .infinity
    
    private var tokens = Set&lt;AnyCancellable&gt;()

    init(focusLensPosition: Float) {
        self.focusLensPosition = focusLensPosition
    }
}

enum FocusChoice: Float, CaseIterable {
    case infinity = 1
    case ft_30 = 0.95
    case ft_15 = 0.9
    case ft_10 = 0.85
    case ft_7 = 0.8
    case ft_5 = 0.5
    case ft_4 = 0.7
    case ft_3_5 = 0.65
    case ft_3 = 0.6
    case auto = 0
}

extension FocusChoice {
    var caption: String {
        switch self {
        case .infinity: return &quot;∞ft&quot;
        case .ft_30: return &quot;30&quot;
        case .ft_15: return &quot;15&quot;
        case .ft_10: return &quot;10&quot;
        case .ft_7: return &quot;7&quot;
        case .ft_5: return &quot;5&quot;
        case .ft_4: return &quot;4&quot;
        case .ft_3_5: return &quot;3.5&quot;
        case .ft_3: return &quot;3&quot;
        case .auto: return &quot;Auto&quot;
        }
    }
}

import UIKit
import Combine
import AVFoundation

class CustomCameraController: UIViewController {
    
    var image: UIImage?
    
    var captureSession = AVCaptureSession()
    var backCamera: AVCaptureDevice?
    var frontCamera: AVCaptureDevice?
    lazy var currentCamera: AnyPublisher&lt;AVCaptureDevice?, Never&gt; = currentCameraSubject.eraseToAnyPublisher()
    var photoOutput: AVCapturePhotoOutput?
    var cameraPreviewLayer: AVCaptureVideoPreviewLayer?
    private var currentCameraSubject = CurrentValueSubject&lt;AVCaptureDevice?, Never&gt;(nil)
    
    var manualFocusValue: Float = 1 {
        didSet {
            guard manualFocusValue != 0 else {
                setAutoLensPosition()
                return
            }
            setFocusLensPosition(manualValue: manualFocusValue)
        }
    }
    
    //DELEGATE
    var delegate: AVCapturePhotoCaptureDelegate?
    
    func setFocusLensPosition(manualValue: Float) {
        do {
            try currentCameraSubject.value!.lockForConfiguration()
            currentCameraSubject.value!.focusMode = .locked
            currentCameraSubject.value!.setFocusModeLocked(lensPosition: manualValue, completionHandler: nil)
            currentCameraSubject.value!.unlockForConfiguration()
        } catch let error {
            print(error.localizedDescription)
        }
    }
    
    func setAutoLensPosition() {
        do {
            try currentCameraSubject.value!.lockForConfiguration()
            currentCameraSubject.value!.focusMode = .continuousAutoFocus
            currentCameraSubject.value!.unlockForConfiguration()
        } catch let error {
            print(error.localizedDescription)
        }
    }
    
    func didTapRecord() {
        
        let settings = AVCapturePhotoSettings()
        photoOutput?.capturePhoto(with: settings, delegate: delegate!)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setup()
    }
    
    func setup() {
        
        setupCaptureSession()
        setupDevice()
        setupInputOutput()
        setupPreviewLayer()
        startRunningCaptureSession()
    }
    
    func setupCaptureSession() {
        captureSession.sessionPreset = .photo
    }
    
    func setupDevice() {
        let deviceDiscoverySession =
            AVCaptureDevice.DiscoverySession(deviceTypes: [.builtInWideAngleCamera],
                                                                      mediaType: .video,
                                                                      position: .unspecified)
        for device in deviceDiscoverySession.devices {
            
            switch device.position {
            case .front:
                self.frontCamera = device
            case .back:
                self.backCamera = device
            default:
                break
            }
        }
        
        self.currentCameraSubject.send(self.backCamera)
    }
    
    func setupInputOutput() {
        do {
          let captureDeviceInput = try AVCaptureDeviceInput(device: currentCameraSubject.value!)
          captureSession.addInput(captureDeviceInput)
          photoOutput = AVCapturePhotoOutput()
          captureSession.addOutput(photoOutput!)
        } catch {
          print(error)
        }
         
      }
    
    func setupPreviewLayer() {
        
        self.cameraPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession)
        self.cameraPreviewLayer?.videoGravity = AVLayerVideoGravity.resizeAspectFill
        
        let deviceOrientation = UIDevice.current.orientation
        cameraPreviewLayer?.connection?.videoOrientation = AVCaptureVideoOrientation(rawValue: deviceOrientation.rawValue)!
        
        self.cameraPreviewLayer?.frame = self.view.frame
        self.view.layer.insertSublayer(cameraPreviewLayer!, at: 0)
    }
    
    func startRunningCaptureSession() {
        captureSession.startRunning()
    }
}
</code></pre>
","14553245","","14553245","","2020-12-29 14:52:17","2020-12-30 13:34:44","Weird behaviour of SwiftUI Picker View when the other view getting new value from AVCaptureDevice API","<swiftui><avfoundation><combine>","1","0","","","","CC BY-SA 4.0"
"64932846","1","64935533","","2020-11-20 16:06:43","","0","1349","<p>I'm currently developing an application using SwiftUI.</p>
<p>I want to show a progress status when a flag is true.</p>
<p>In my code, the flag has true status during a <code>while</code> loop with a method wrapped in the <code>DispatchQueue.main.sync</code> method works.
But I get an error below:</p>
<p><a href=""https://i.stack.imgur.com/PvcJs.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/PvcJs.png"" alt=""enter image description here"" /></a></p>
<blockquote>
<p>Publishing changes from background threads is not allowed; make sure to publish values from the main thread (via operators like receive(on:)) on model updates.</p>
</blockquote>
<p>How cloud I solve this problem?</p>
<hr />
<p>Here are the codes:</p>
<p>AppState.swift</p>
<pre><code>@Published var isLoading:Bool = false
@Published var weatherInfos:[WeatherInfos]?


func getTemperatureAsync(date: String) {

    DispatchQueue.global().async {

        var counter:Int = 0
        var totalTemp:Float = 0.0

        while counter &lt; 100
        {
            self.isLoading = true // I get error here

            counter += 1
            totalTemp += self.getTemperature(date: date)

            self.isLoading = false // I get error here
        }
    }
}


func getTemperature(date: String) -&gt; Float{

    var temperature: Float = 0.0
    let semaphore = DispatchSemaphore(value: 0)

    let endpoint: String = &quot;https://sample.com/api/weather/?&amp;date=\(date)&quot;
    let url = URL(string: endpoint)
    var urlRequest = URLRequest(url: url!)
    urlRequest.addValue(&quot;token xxxxxxxxxxxx&quot;, forHTTPHeaderField: &quot;authorization&quot;)
    // set up the session
    let config = URLSessionConfiguration.default
    let session = URLSession(configuration: config)

    let task = session.dataTask(with: urlRequest) {(data, response, error) in
        guard error == nil else {
            print(&quot;error calling GET&quot;)
            return
        }
        // make sure we got data
        guard let responseData = data else {
            print(&quot;Error: did not receive data&quot;)
            return
        }
        DispatchQueue.main.sync {
            do{
                self.weatherInfos = try JSONDecoder().decode([WeatherInfos].self, from: responseData)

                for info in self.weatherAveInfos!{
                    temperature += info.ave_temp
                }
            }catch{
                print(&quot;Error: did not decode&quot;)
                return
            }
        }
        semaphore.signal()
    }
    task.resume()
    semaphore.wait()

    return temperature
}
</code></pre>
<p>JsonModel.swift</p>
<pre><code>struct WeatherInfos:Codable,Identifiable {
    var id: Int
    var ave_temp: Float
}
</code></pre>
<p>Progress.swift</p>
<pre><code>struct Progress: View {
    var body: some View {
        ProgressView(&quot;Loading...&quot;)
    }
}
</code></pre>
<p>MainView.swift</p>
<pre><code>import SwiftUI

struct InformationView: View {

@EnvironmentObject var appState: AppState

    var body: some View {
       if appState.isLoding {
           Progress()
       }
       Button(action:{
            appState.getTemperatureAsync(date: &quot;2020-11-01&quot;)
       }){
            Text(&quot;show progress&quot;)
         }
    }
}
</code></pre>
<hr />
<p>Xcode: Version 12.0.1</p>
<p>iOS: 14.0</p>
","12611330","","1271826","","2020-11-20 22:04:09","2020-11-20 22:04:09","How to publish values from the main thread using DispatchQueue.global().async?","<swiftui><combine><ios14>","2","3","","","","CC BY-SA 4.0"
"64938442","1","64942348","","2020-11-20 23:57:29","","5","2881","<p>I have a custom pipeline where I want to have 3 retry attempt for some error codes which are recoverable plus I want to add some short delay for the recoverable error. Anyone has an idea how I can do it?</p>
<pre><code>func createRequest(for message: Message) -&gt; AnyPublisher&lt;ResponseMessage, Error&gt; {
    Future&lt;ResponseMessage, Error&gt; { promise in
        .....   
    }
    .tryCatch({ error -&gt; AnyPublisher&lt;ResponseMessage, Error&gt; in
        // If error is a recoverable error retry, otherwise fail directly
        if case let MessageBusError.messageError(responseError) = error {
            if responseError.isRecoverable {
                // Make a next attempt only for recoverable error
                throw error
            }
        }
            //Should fail directly if the error code is not recoverable
        return Fail&lt;ResponseMessage, Error&gt;(error: error)
               .eraseToAnyPublisher()

    })
    .retry(3)
    .eraseToAnyPublisher()
}
</code></pre>
","4142753","","","","","2022-03-29 06:40:59","Swift combine retry only for some error types","<ios><swift><combine>","2","0","5","","","CC BY-SA 4.0"
"64948720","1","64949874","","2020-11-21 22:26:29","","1","932","<p>I am not able to bind the bookName from my Core Data object to a TextField inside a ForEach loop. How can I get this binding to work? I want the bookName value to be saved to Core Data when it changes.</p>
<p>I am receiving an error that says: Cannot find $book in scope.</p>
<pre><code>extension Book: Identifiable {
                @nonobjc public class func fetchRequest() -&gt; NSFetchRequest&lt;Book&gt; {
                    return NSFetchRequest&lt;Book&gt;(entityName: &quot;Book&quot;)
                }
                
                @NSManaged public var id: UUID?
                @NSManaged public var bookName: String?
                
                var wrappedBookName: String {
                    bookName ?? &quot;&quot;
                }
           }    
            
    struct BookListView: View {
            @FetchRequest(entity: Book.entity(), sortDescriptors: [NSSortDescriptor(keyPath: \Book.rankNumber, ascending: false)]) var books: FetchedResults&lt;Book&gt;
                
                 var body: some View {
                    ForEach(books) { book in
                       TextField(&quot;Book Name&quot;, text: $book.bookName)  //Error: cannot find $book in scope
                    }
                 }
    }
</code></pre>
","618916","","","","","2020-11-22 01:40:35","SwiftUI Bind to core data object inside foreach","<core-data><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"64957228","1","64957540","","2020-11-22 17:23:04","","4","4072","<p>I have following RxSwift view model code:</p>
<pre><code>private(set) var num = BehaviorRelay&lt;Int&gt;(value: 1)
private let indexTrigger = PublishRelay&lt;Int&gt;()
private let disposeBag = DisposeBag()

private func setupBindings() {
   //...
   self.num.distinctUntilChanged().bind(to: self.indexTrigger).disposed(by: self.disposeBag)
}

func numSelected(num: Int) {
   self.num.accept(num)
}

</code></pre>
<p>This code is working fine and does what I want. I'm trying to do same, but with swift Combine framework with following code:</p>
<pre><code>@Published private(set) var num: Int = 1
private let indexTrigger = PassthroughSubject&lt;Int, Never&gt;()
private var subscriptions = Set&lt;AnyCancellable&gt;()

private func setupBindings() {
   //...
   self.$num.removeDuplicates().sink(receiveValue: { [weak self] num in
      self.indexTrigger.send(num)
   }).store(in: &amp;self.subscriptions)
}

func numSelected(num: Int) {
   self.num = num
}
</code></pre>
<p>So RxSwift binding looks much clean and simple and without need of weak. I tried to check <code>assign(on:)</code> method in combine, but seems it is not the one. Is there way to do same thing?</p>
","1246675","","","","","2020-11-22 17:52:17","Combine assign publisher to PassthroughSubject","<ios><swift><rx-swift><combine>","1","5","","","","CC BY-SA 4.0"
"64975317","1","64976195","","2020-11-23 19:45:57","","0","488","<p>I want to perform an API call whenever a user types 3 or more letters into a search field.</p>
<p>I finally got it to work, but unfortunately when I turned off and on the server it turned out that the <code>Publisher</code> terminates upon the first error and when user types text into the search field again no API call is made.</p>
<p>I watched the WWDC 2019 videos on <code>Combine</code> and read a few blog posts, but it seems that <code>Combine API</code> changes quite often, every source does everything differently, and when I tinker around it the compiler often throws useless errors like <code>Fix: Replace type X with type X</code> (see screenshot)</p>
<p><a href=""https://i.stack.imgur.com/AOM3c.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/AOM3c.png"" alt=""enter image description here"" /></a></p>
<p>PS: I know I can use <code>filter</code> to filter out queries shorter than 3 letters, but I somehow couldn't get the publishers and types to work.. I feel like I am missing something fundamental on <code>Combine</code>...</p>
<p>Here is the code:</p>
<p>DictionaryService.swift</p>
<pre><code>class DictionaryService {

    func searchMatchesPublisher(_ query: String,
                                inLangSymbol: String,
                                outLangSymbol: String,
                                offset: Int = 0,
                                limit: Int = 20) -&gt; AnyPublisher&lt;[TranslationMatch], Error&gt; {
        
    ...
}
</code></pre>
<p>DictionarySearchViewModel.swift</p>
<pre><code>class DictionarySearchViewModel: ObservableObject {
    @Published var inLang = &quot;de&quot;
    @Published var outLang = &quot;en&quot;
    
    @Published var translationMatches = [TranslationMatch]()
    @Published var text: String = &quot;&quot;
    
    private var cancellable: AnyCancellable? = nil
    
    init() {
        cancellable = $text
            .debounce(for: .seconds(0.2), scheduler: DispatchQueue.main)
            .removeDuplicates()
            .map { [self] queryText -&gt; AnyPublisher&lt;[TranslationMatch], Error&gt; in
                if queryText.count &lt; 3 {
                    return Future&lt;[TranslationMatch], Error&gt; { promise in
                        promise(.success([TranslationMatch]()))
                    }
                    .eraseToAnyPublisher()
                } else {
                    return DictionaryService.sharedInstance()
                        .searchMatchesPublisher(queryText, inLangSymbol: self.inLang, outLangSymbol: self.outLang)
                }
            }
            .switchToLatest()
            .eraseToAnyPublisher()
            .replaceError(with: [])
            .receive(on: DispatchQueue.main)
            .assign(to: \.translationMatches, on: self)
    }
}
</code></pre>
","659389","","659389","","2020-11-24 10:00:41","2020-11-24 10:00:41","SwiftUI + Combine - Publisher terminates upon first error","<ios><swift><swiftui><reactive-programming><combine>","2","5","","","","CC BY-SA 4.0"
"64976084","1","65010017","","2020-11-23 20:40:10","","1","3589","<p>How can you have different return types for a flatMap when using Swift Combine? I have my first publisher, which emits a value and then I flatMap that to transform it into a new publisher. However, based on the original value, I might need to have a different publisher that returns a different type.</p>
<p>I've added a basic example below.</p>
<pre><code>import Combine


class Testing{
    var subscriptions = Set&lt;AnyCancellable&gt;()
    
    
    func getTestScore()-&gt;AnyPublisher&lt;Int, Never&gt;{
        return Just(80).eraseToAnyPublisher()
    }
    
    func congratulate()-&gt;AnyPublisher&lt;String, Never&gt;{
        return Just(&quot;Good Job!&quot;).eraseToAnyPublisher()
    }
    
    func getGPA()-&gt;AnyPublisher&lt;Double, Never&gt;{
        return Just(2.2).eraseToAnyPublisher()
    }
    
    init() {
        getTestScore()
            .flatMap{ score in
                if score &lt; 70{
                    return self.getGPA()
                } else{
                    return self.congratulate()
                }
            }
            .sink { _ in } receiveValue: { value in
                print(value)
            }.store(in: &amp;subscriptions)
    }
}

let testing = Testing()

</code></pre>
","10830089","","","","","2022-06-05 15:10:26","Swift Combine Conditional FlatMap Results","<swift><conditional-statements><combine><flatmap>","2","5","1","","","CC BY-SA 4.0"
"64981458","1","64981955","","2020-11-24 06:46:31","","3","151","<p>I got this sample code about ObservableObject from <a href=""https://developer.apple.com/documentation/combine/observableobject"" rel=""nofollow noreferrer"">Apple official website</a></p>
<pre><code>import Foundation

class Contact: ObservableObject {
    @Published var name: String
    @Published var age: Int
    
    
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
    
    func changeAge() -&gt; Int {
        self.age += 1
        return self.age
    }
}



class Test {
    init() {
        let john = Contact(name: &quot;John Appleseed&quot;, age: 24)
        _ = john.objectWillChange
            .sink { _ in
                print(&quot;\(john.age) will change&quot;)
        }
        print(john.changeAge())
    }
}

let test = Test()
</code></pre>
<p>When running on terminal by <code>swift Contact.swift</code>, the result is only <code>25</code>, but official website shows the result should be</p>
<pre><code>// Prints &quot;24 will change&quot;
// Prints &quot;25&quot;
</code></pre>
<p>Why the first line <code>Prints &quot;24 will change&quot;</code> is not shown?</p>
<p>Thank you.</p>
","9355534","","","","","2020-11-24 07:28:29","Why objectWillChange has no effect","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"65015283","1","65016177","","2020-11-26 02:20:38","","3","106","<p>I have defined a few (up to many) different SwiftUI Views:</p>
<p>ViewA(), ViewB(), ViewC() .. ViewN()</p>
<p>Each View contains a specific information that I want to present depending on the choice made by the user..</p>
<p>I created a Hashable, Identifiable list of items and I want to link each item to one specific view. But I can not seem to overcome the errors..</p>
<p>Here is a specific example of exactly what I am trying to do:</p>
<pre><code>//Country Definitions:

import Foundation
import Combine
import SwiftUI

let Countries = [
    CountryModel(countryID: &quot;US&quot;, countryName: &quot;United States&quot;, countryView: USAView() )
    CountryModel(countryID: &quot;UK&quot;, countryName: &quot;United Kingdom&quot;, countryView: UKView() )
]

struct CountryModel: Identifiable, Hashable {
    
    let id:UUID
    let countryID:String
    let countryName:String
    let countryView:View   //I have tried AnyView here, different issues, still no go...
    
    init(countryID:String, countryName:String, countryView:View) {
        self.id = UUID();
        self.countryID = countryID
        self.countryName = countryName
        self.countryView = countryView
    }
}

</code></pre>
<p>How it is planned to be used in theory is in a NavigationView / NavigationLink as such:</p>
<pre><code>
struct ContentView: View {
    
    var body: some View {
        
        NavigationView {
            
            ForEach(Countries) { thisCoutry in
                
                NavigationLink(destination: thisCoutry.countryView) { //Also tried forcing as! View, no good
                    MyItemCell(itemName: thisCoutry.countryName, itemDesc: thisCoutry.countryID)
                    
                }
            }
        }
    }
}
</code></pre>
<p>(MyItemCell is just a View to format the name and ID of the item)..</p>
<p>Thus far, trying to use &quot;View&quot;, I get the errors:</p>
<blockquote>
<p>Protocol 'View' can only be used as a generic constraint because it
has Self or associated type requirements</p>
</blockquote>
<p>and something about not conforming to Equatable. When I add Equatable and have it add the stub with return true, no help...</p>
<pre><code>struct CountryModel: Hashable, Identifiable, Equatable {
    static func == (lhs: CountryModel, rhs: CountryModel) -&gt; Bool {
        return true
    }
</code></pre>
<p>I also get an error proclaiming that this does not conform to Hashable, so I tried taking that out and still no go..</p>
<p>Any ideas greatly appreciated. Trying to avoid a long list of Nav Links as SwiftUI seems to get funky at/around/after 10 or so and I have to start Grouping, or being otherwise more creative...</p>
<pre><code>struct ContentView: View {
    
    var body: some View {
        
        VStack{
            NavigationView {
                
                NavigationLink(destination: ViewA()) {
                    MyItemCell(itemName: &quot;United States&quot;, itemDesc: &quot;USA&quot;)
                    
                }
                
                NavigationLink(destination: ViewB()) {
                    MyItemCell(itemName: &quot;United Kingdom&quot;, itemDesc: &quot;UK&quot;)
                    
                }
            }
        }
    }
}
</code></pre>
","1174318","","","","","2020-11-26 04:36:33","How to pass a View() as part of a list in SwiftUI?","<ios><swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"65018191","1","65020855","","2020-11-26 08:10:45","","1","510","<p>my goal is to decode a deeply nested json response from an api and render it in a list, below is the raw response data and my attempt.</p>
<p>The problem is that when I attempt to initialize my data to then further populated when I make my API call it gives me an error</p>
<p>“ Listing(data: []) { <em>ERROR: No exact matches in call to initializer</em>”</p>
<p>Is this the correct way to declare my structs to decode a deeply nested JSON Object?</p>
<p>Api response data -&gt;
<a href=""https://pastebin.com/7pgswZqk"" rel=""nofollow noreferrer"">https://pastebin.com/7pgswZqk</a></p>
<pre><code>import Foundation
import SwiftUI
import Combine


struct Listing: Decodable {
    var kind: String
    struct data: Decodable {
        var modhash: String
        var dist: Int
        struct children: Decodable {
            var kind: String
            struct data: Decodable {    &lt;--- this level is where my iterable children are
                var title: String
                ... &lt;---- there is more properties here but I just put title for now
            }
        }
    }
}

class NetworkingManager : ObservableObject {
    var didChange = PassthroughSubject&lt;NetworkingManager, Never&gt;()
    
    var ListingList = Listing(data: []) { *ERROR: No exact matches in call to initializer*
        didSet {
            didChange.send(self)
        }
    }
    
    init() {
        guard let url = URL(string: &quot;https://www.reddit.com/best.json?limit=25&quot;) else { return }

        URLSession.shared.dataTask(with: url) { (data, _, _) in
            guard let data = data else { return }
            
            let List = try! JSONDecoder().decode(Listing.self, from: data)
            
            DispatchQueue.main.async {
                self.ListingList = List
            }
        }.resume()
    }
}
</code></pre>
<p>Then to iterate over the list, would it be like this?</p>
<pre><code>List(ListingList.data.children.data.identified(by ./title) {listItem in
    Text(listItem.title)
}
</code></pre>
","2228391","","9223839","","2020-11-26 08:52:30","2020-11-26 11:08:14","Decoding deeply nested object in Swift using nested structs","<ios><swift>","1","4","","","","CC BY-SA 4.0"
"65018677","1","65018945","","2020-11-26 08:48:17","","2","290","<p>I am new in swift ui, I try to go back to previous screen after getting response from API call.</p>
<p>In my scenario, I have a button to call an API. This is my button,</p>
<pre><code>import SwiftUI

struct RegisterCashierView: View {
    @ObservedObject var registerCashierController = RegisterCashierController()
    @Environment(\.presentationMode) var presentationMode: Binding&lt;PresentationMode&gt;
    
    var body: some View {
      Button(action: {
        if(self.registerCashierController.isActive){
          self.presentationMode.wrappedValue.dismiss()
        }
        self.registerCashierController.submitRegisterCashier(email: self.email, full_name: self.full_name, username: self.username, password: self.password)
      }) {
      HStack {
        Text(&quot;Submit&quot;)
            .fontWeight(.semibold)
            .font(.title)
        Image(systemName: &quot;arrow.right.circle&quot;)
            .font(.title)
      }
      .frame(minWidth: 0, maxWidth: .infinity)
      .padding()
    }
}
</code></pre>
<p>As we can see I have an isActive, when isActive is true, it will execute this</p>
<pre><code>self.presentationMode.wrappedValue.dismiss()
</code></pre>
<p>I set my isActive to true variable after getting an response from API. But it is not work. Any one knows how to fix this?</p>
<pre><code>class RegisterCashierController: ObservableObject {
    @Published var isActive = false
    @Published var isLoading = false
    @State private var adminToken = UserDefaults.standard.string(forKey: &quot;adminToken&quot;)
    let url = BaseUrl().setUrl(subUrl: &quot;auth/user/register&quot;)
    var didChange = PassthroughSubject&lt;RegisterCashierController, Never&gt;()
    
    func submitRegisterCashier(email: String, full_name: String, username: String, password: String){
        let body : [String : String] = [&quot;email&quot;: email, &quot;full_name&quot;: full_name, &quot;username&quot;: username, &quot;password&quot;: password]
        guard let finalBody = try? JSONEncoder().encode(body) else {
            return
        }
        print(&quot;URL \(self.url)&quot;)
        var request = URLRequest(url: self.url)
        request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        request.setValue(&quot;Bearer \(adminToken ?? &quot;&quot;)&quot;, forHTTPHeaderField: &quot;Authorization&quot;)
        request.httpMethod = &quot;POST&quot;
        request.httpBody = finalBody
        URLSession.shared.dataTask(with: request) { (data, response, error) in
            guard let data = data, error == nil else {
                print(&quot;No data response&quot;)
                return
            }
            do {
                let decoder = JSONDecoder()
                let dateFormatter = DateFormatter()
                dateFormatter.dateFormat = &quot;yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ&quot;
                decoder.dateDecodingStrategy = .formatted(dateFormatter)
                let response = try decoder.decode(RegisterCashierResponse.self, from: data)
                DispatchQueue.main.async {
                    self.isActive = true
                    self.isLoading = false
                }
                print(&quot;Response from register cashier \(response)&quot;)
            } catch let error {
                print(&quot;Error from register cashier \(error)&quot;)
            }
        }.resume()
    }
}

</code></pre>
","11513854","","","","","2020-11-26 10:23:40","How to go back to previous screen after getting response from API call in swiftui?","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"65024144","1","65024734","","2020-11-26 14:38:50","","0","58","<p>I have a game written with SwiftUI with two classes, a Game class to manage the game, and a ScoreStore class that manages an array of high scores. Currently the score of a game is stored (via a function on ScoreStore) when the user presses a button (displayed in the ContentView struct) to start a new game. I want to have the score saved when a game reaches a certain state (considered here to be a certain score).</p>
<p>Both Game and ScoreStore are ObservableObjects and have @Published properties available to ContentView as @EnvironmentObjects. Within Game, score is not @Published because it is a computed property.</p>
<pre><code>class Game: ObservableObject, Codable {
    
    var deck: [Card] = []
    
    @Published var piles: [[Card]] = [[],[],[],[]] 

    var score: Int {
        let fullDeckCount = 52
        var cardsOnThePiles = 0
        for pile in piles {
            cardsOnThePiles += pile.count
        }
        return fullDeckCount - deck.count - cardsOnThePiles
    }

</code></pre>
<pre><code>class ScoresStore: Codable, ObservableObject, Identifiable {
    
    @Published var highScores: [Score] = []
    
    func addScore(newScore: Int, date: Date = Date()) {
        // Do things to add the score to the array
}
        
</code></pre>
<pre><code>struct ContentView: View {
    @EnvironmentObject var game: Game
    @EnvironmentObject var scores: ScoresStore

func saveScore() {
        scores.addScore(newScore: game.score)
    }
    
var body: some View {
    Button(action: { saveScore }) {
        Text(&quot;New Game?&quot;)
    }
}
</code></pre>
<p>I've looked at questions whose answers reference binding via a @State property but in this case the property I'm &quot;observing&quot; is in Game (not ContentView).</p>
<p>Thanks in advance!</p>
","13648289","","4667835","","2020-11-26 14:43:06","2020-11-26 15:14:53","How do I execute a function on ClassB when something changes in ClassA?","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"65066793","1","65067190","","2020-11-30 00:47:36","","6","1012","<p>I know, this is one of those &quot;Not working in iOS XX&quot; questions, but I'm completely stuck...</p>
<p>So I have an <code>ObservableObject</code> class that inherits from <code>NSObject</code>, because I need to listen to the delegate methods of <code>UISearchResultsUpdating</code>.</p>
<pre><code>class SearchBarListener: NSObject, UISearchResultsUpdating, ObservableObject {
    
    @Published var searchText: String = &quot;&quot;
    let searchController: UISearchController = UISearchController(searchResultsController: nil)
    
    override init() {
        super.init()
        self.searchController.searchResultsUpdater = self
    }
    
    func updateSearchResults(for searchController: UISearchController) {
        
        /// Publish search bar text changes
        if let searchBarText = searchController.searchBar.text {
            print(&quot;text: \(searchBarText)&quot;)
            self.searchText = searchBarText
        }
    }
}

struct ContentView: View {
    @ObservedObject var searchBar = SearchBarListener()
    
    var body: some View {
        Text(&quot;Search text: \(searchBar.searchText)&quot;)
        .padding()

        /// more code that's not related 
    }
}
</code></pre>
<p>The problem is that even though <code>print(&quot;text: \(searchBarText)&quot;)</code> prints fine, the <code>Text(&quot;Search text: \(searchBar.searchText)&quot;)</code> <strong>is never updated</strong> (in iOS 13). It works fine in iOS 14.</p>
<hr />
<p>Here's a minimal reproducible example:</p>
<pre><code>class SearchBarTester: NSObject, ObservableObject {

    @Published var searchText: String = &quot;&quot;

    override init() {
        super.init()
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
            print(&quot;updated&quot;)
            self.searchText = &quot;Updated&quot;
        }
    }
}

struct ContentView: View {
    @ObservedObject var searchBar = SearchBarTester()
    
    var body: some View {
        NavigationView {
            Text(&quot;Search text: \(searchBar.searchText)&quot;)
            .padding()
        }
    }
}
</code></pre>
<p>After 5 seconds, &quot;updated&quot; is printed in the console, but the <code>Text</code> doesn't change. In iOS 14, the <code>Text</code> changes to <strong>&quot;Search text: Updated&quot;</strong> as expected.</p>
<p><kbd><a href=""https://i.stack.imgur.com/wUjEg.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/wUjEg.png"" alt=""&quot;Updated&quot; printed in console but simulator does not change"" /></a></kbd></p>
<p>However, if I don't inherit from <code>NSObject</code>, <strong>both</strong> iOS 13 and iOS 14 work!</p>
<pre><code>class SearchBarTester: ObservableObject {

    @Published var searchText: String = &quot;&quot;

    init() {
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
            print(&quot;updated&quot;)
            self.searchText = &quot;Updated&quot;
        }
    }
}    
</code></pre>
<p><kbd><a href=""https://i.stack.imgur.com/oCYx3.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/oCYx3.png"" alt=""&quot;Updated&quot; printed in console and simulator also changes"" /></a></kbd></p>
<p>I think the problem has something to do with inheriting from a class. Maybe it's something that was fixed in iOS 14. But does anyone know what is going on?</p>
<hr />
<h3>Edit</h3>
<p>Thanks <a href=""https://stackoverflow.com/users/2739567/"">@Cuneyt</a> for the answer! Here's the code that finally worked:</p>
<pre><code>import SwiftUI
import Combine /// make sure to import this

class SearchBarTester: NSObject, ObservableObject {

    let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()
    @Published var searchText: String = &quot;&quot; {
        willSet {
            self.objectWillChange.send()
        }
    }

    override init() {
        super.init()

        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
            print(&quot;updated&quot;)
            self.searchText = &quot;Updated&quot;
        }
    }
}
</code></pre>
","14351818","","14351818","","2020-11-30 02:41:09","2020-11-30 02:41:09","SwiftUI - ObservableObject that inherits from NSObject does not update in iOS 13","<ios><swift><swiftui><observableobject>","1","4","","","","CC BY-SA 4.0"
"65072163","1","65072289","","2020-11-30 10:51:23","","3","946","<p>I am trying to use 2 publishers and have them stream to 1 publisher that is mapped from both values.</p>
<p>My code is:</p>
<pre><code>class ViewModel {

    let email = CurrentValueSubject&lt;String, Never&gt;(&quot;&quot;)

    lazy var isEmailValid = email.map { self.validateEmail(email: $0) }

    let password = CurrentValueSubject&lt;String, Never&gt;(&quot;&quot;)

    lazy var isPasswordCorrect = password.map {
        self.validatePassword(password: $0)
    }

    let canLogin: CurrentValueSubject&lt;Bool, Never&gt;

    private func validateEmail(email: String) -&gt; Bool {
        return email == &quot;1234@gmail.com&quot;
    }

    private func validatePassword(password: String) -&gt; Bool {
        return password == &quot;1234&quot;
    }


    init() {
    
        canLogin = Publishers
            .CombineLatest(isEmailValid, isPasswordCorrect)
            .map { $0 &amp;&amp; $1 } 

    }
}
</code></pre>
<p>Then in the init I get this error:</p>
<pre><code>    //error: Cannot assign value of type 
'Publishers.Map&lt;Publishers.CombineLatest&lt;Publishers.Map&lt;CurrentValueSubject&lt;String, Never&gt;, 
Bool&gt;, Publishers.Map&lt;CurrentValueSubject&lt;String, Never&gt;, Bool&gt;&gt;, Bool&gt;' to type 'CurrentValueSubject&lt;Bool, Never&gt;'
</code></pre>
<p>I am new to combine so I find it a little confusing.
How should I achieve, from the code above, the combination of 2 publishers isEmailValid and isPasswordCorrect, into 1 publisher that is a CurrentValueSubject&lt;Bool, Never&gt;?</p>
","5784052","","","","","2020-11-30 11:02:03","how to use Publishers.CombineLatest to get 1 publisher","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"65082713","1","65084641","","2020-11-30 23:38:46","","2","112","<p>Whenever the value of the <code>@State</code> variable <code>myData</code> changes I would like to be notified and store that data in an <code>@AppStorage</code> variable <code>myStoredData</code>.  However, I don't want to have to write explicitly this storing code everywhere the state var is changed, I would like to associate a block of code with it that gets notified whenever the state var changes and performs storage.  The reason for this is, for example, I want to pass the state var as a binding to another view, and when that view would change the variable, the storage block would automatically be executed.  How can I do this/can I do this in SwiftUI?</p>
<pre><code>struct MyView : View {
  @AppStorage(&quot;my-data&quot;) var myStoredData : Data!
  @State var myData : [String] = [&quot;hello&quot;,&quot;world&quot;]
  var body : some View {
    Button(action: {
      myData = [&quot;something&quot;,&quot;else&quot;]
      myStoredData = try? JSONEncoder().encode(myData)
    }) {
      Text(&quot;Store data when button pressed&quot;)
    }
    .onAppear {
        myData = (try? JSONDecoder().decode([String].self, from: myStoredData)) ?? []
    }
  }
}
</code></pre>
<p>I'm looking for something like this, but this does not work:</p>
<pre><code>@State var myData : [String] = [&quot;hello&quot;,&quot;world&quot;] {
  didSet {
    myStoredData = try? JSONEncoder().encode(myData)
  }
}
</code></pre>
<pre><code></code></pre>
","213563","","213563","","2020-12-01 00:35:43","2020-12-01 04:15:14","How to associate a block of code with a @State var when it changes","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"65124793","1","65124886","","2020-12-03 11:07:22","","0","1024","<p>I have this code:</p>
<pre><code>class ViewModel {

    let email = CurrentValueSubject&lt;String, Never&gt;(&quot;&quot;)

    private var isEmailValid: AnyPublisher&lt;Bool, Never&gt;?

    var emailColor: AnyPublisher&lt;UIColor, Never&gt;?


    private func validateEmail(email: String) -&gt; Bool { return email == &quot;1234@gmail.com&quot; }
    private func emailColor(isValid: Bool) -&gt; UIColor { return isValid ? UIColor.black : 
UIColor.red }

    public func setupPublishers() {
        isEmailValid = email
        .map { self.validateEmail(email: $0) }
        .eraseToAnyPublisher()

        emailColor = email
        .map { self.emailColor(isValid: self.validateEmail(email: $0)) }
        .eraseToAnyPublisher()
    }
}
</code></pre>
<p>In the function setupPublishers, I create isEmailValid as a map from the CurrentValueSubject 'email'.
I wish to map it directly from 'isEmailValid', but if I do this:</p>
<pre><code>        emailColor = isEmailValid
        .map { self.emailColor(isValid: $0) }
        .eraseToAnyPublisher()
</code></pre>
<p>I get this error:</p>
<pre><code>Cannot convert value of type 'AnyPublisher&lt;Bool, Never&gt;' to expected argument type 'Bool'
Value of type 'UIColor?' has no member 'eraseToAnyPublisher'
</code></pre>
<p>Which obviously indicates that mapping from the publisher gives me the actual value instead of another publisher.
So how could I achieve this task?</p>
","5784052","","","","","2020-12-03 11:13:33","Map an AnyPublisher to another AnyPublisher","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"65126447","1","65181122","","2020-12-03 12:57:06","","0","288","<pre><code>enum FailureReason : Error {
  case sessionFailed(error: URLError)
  case decodingFailed
  case other(Error)
}
</code></pre>
<p>the custom error enum</p>
<pre><code> private func performOperation&lt;T: Decodable&gt;(requestUrl: URLRequest, responseType: T.Type)-&gt;AnyPublisher&lt;T, FailureReason&gt;
   {
return URLSession.shared.dataTaskPublisher(for: requestUrl)
          .map(\.data)
          .decode(type: T.self, decoder: JSONDecoder())
          .mapError({ error -&gt; FailureReason in
            switch error {
            case is Swift.DecodingError:
              return .decodingFailed
            case let urlError as URLError:
              return .sessionFailed(error: urlError)
            default:
              return .other(error)
            }
          })
          .eraseToAnyPublisher()
   
}
</code></pre>
<p>this is how my urlsession publisher looks like</p>
<pre><code>func validateLogin(username : String , password :String) {
    
    let url = &quot;\(Constants.baseUrl)api/v1/auth/login/&quot;
    let htppbodyRequest = EmailLogin(username: username, password: password)
    let httpBody = try! JSONEncoder().encode(htppbodyRequest)
    
   cancellable = webservice.apiRequest(url: URL(string: url)!, resultType: User.self, httpMethodType: .post, requestBody: httpBody)
             .map{ $0 }
             .receive(on: RunLoop.main)
             .sink(receiveCompletion: {
                print(&quot;Received completion: \($0).&quot;)
             }, receiveValue: { (user) in
                  print(&quot;user name is :\(user)&quot;)
                  self.subject.send(user)
            })
</code></pre>
<p>User is the decodable struct. Even if i enter invalid username and password the Received completion of sink prints finished error is never thrown.
Subject is a passthroughSubject.</p>
","12478078","","4667835","","2020-12-07 11:18:59","2020-12-07 11:43:35","Error is not triggering on url session using combine","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"65132939","1","65137146","","2020-12-03 19:38:12","","2","804","<p>I am currently using Alamofire which contains Combine support and using it following way:</p>
<pre class=""lang-swift prettyprint-override""><code>    let request = AF.request(endpoint)

    ...
    request
            .publishDecodable(type: T.self, decoder: decoder)
            .value()
            .eraseToAnyPublisher()
</code></pre>
<p>This will publish result and <code>AFError</code> but from subscriber's <code>.sink</code>, I can't find anywhere to get the HTTP status code. What's the best way to get the status code in subscriber?</p>
","2970107","","","","","2022-01-22 22:32:29","Alamofire + Combine: Get the HTTP response status code","<ios><swift><alamofire><combine>","3","0","","","","CC BY-SA 4.0"
"65134392","1","65148363","","2020-12-03 21:25:21","","0","3234","<p>Trying to figure out how to make quick http requests using combine. I've mostly been looking at this <a href=""https://developer.apple.com/documentation/foundation/urlsession/processing_url_session_data_task_results_with_combine"" rel=""nofollow noreferrer"">doc</a> by Apple. I haven't made any progress though and it seems simple enough so I don't know what I'm doing wrong.</p>
<p>I'm use to JavaScript and using the <a href=""https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"" rel=""nofollow noreferrer"">Fetch API</a><br />
Also use to <a href=""https://golang.org/pkg/net/http/"" rel=""nofollow noreferrer"">http pkg</a> in Golang<br />
But for some reason doing it in Swift is really confusing to me like it's not very streamlined like the two I mentioned</p>
<p>I'm using SwiftUI with the MVVM architecture so my goal is to implement a way of communicating to my Golang server in my view model.</p>
<p>This requires mostly <code>POST</code> requests with <code>Accept</code> and <code>Authorization</code> headers and a <code>JSON</code> body</p>
<p>I tried this code:</p>
<pre class=""lang-swift prettyprint-override""><code>let url = URL(string: &quot;https://api.example.com/user/login&quot;)!
var request = URLRequest(url: url)
request.httpMethod = &quot;POST&quot;
request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Accept&quot;)
request.setValue(String(format: &quot;Bearer %s&quot;, idToken!), forHTTPHeaderField: &quot;Authorization&quot;)
        
_ = URLSession.shared.dataTaskPublisher(for: request)
    .tryMap() { element -&gt; Data in
        // not worried about the status code just trying to get any response.
        guard let httpResponse = element.response as? HTTPURLResponse, httpResponse.statusCode &gt;= 200
        else {
            throw URLError(.badServerResponse)
        }
        return element.data
    }
    // .decode(type: LoginResponseData.self, decoder: JSONDecoder()) commenting this out because I just want to see any data.
    .sink(
        receiveCompletion: { print (&quot;Received completion: \($0).&quot;) },
        receiveValue: { data in print (&quot;Received user: \(data).&quot;)}
    )
</code></pre>
<p>And get this console message: <code>nw_protocol_get_quic_image_block_invoke dlopen libquic failed</code><br />
Which I read <a href=""https://forums.swift.org/t/swift-firebase-connection/41632/2"" rel=""nofollow noreferrer"">here</a> may have nothing to do with my issue however they were talking about firebase I think.</p>
<p>I would like to know if there is anything wrong with my code?<br />
Or a working example with some <code>JSON</code> API or even a http <code>GET</code> request of some website would be fine.</p>
<p>Thanks!</p>
","9745881","","","","","2022-05-11 17:00:09","Swift Combine HTTP request","<ios><swift><http><combine>","2","2","","","","CC BY-SA 4.0"
"65148657","1","65148737","","2020-12-04 18:12:09","","2","669","<p>I am pretty nw to SwiftUI, and to make my code more readable, I usually break my views into smaller views.</p>
<p>Let's say I have a viewModel, what is the best way to call a method of my viewModel from a nested view? Right now I am passing around my ViewModel as a parameter of every nested view, but I don't find it very optimal and clean...</p>
<p>Is there a way to notify MyMainView that the button of HeaderSubview was tapped ? Can I use Combine for example?</p>
<p><strong>ViewModel</strong></p>
<pre><code>class MyViewModel {
    func fetchSomeData() {
        print(&quot;Fetching Some Data&quot;)
    }
}
</code></pre>
<p><strong>MainView</strong></p>
<pre><code>struct MyMainView: View {

    var myViewModel = MyViewModel()
    var body: some View {
        HeaderView(viewModel: myViewModel)
    }
}

struct HeaderView: View {
    var viewModel: MyViewModel

    var body: some View {
        HeaderSubview(viewModel: viewModel)
    }
}

struct HeaderSubview: View {
    var viewModel: MyViewModel
    var body: some View {
        Button(&quot;Search&quot;) {
            // I want to call my View Model method here
            viewModel.fetchSomeData()
        }
    }
}
</code></pre>
","6248848","","","","","2022-05-26 14:16:56","SwiftUI: calling a method from nested view","<ios><mvvm><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"65164651","1","65202129","","2020-12-06 04:23:42","","2","710","<p>I am trying to replace delegation pattern with Combine.</p>
<p>The architecture of my app is a VIPER, so I need to pass the sink subscriber from one module to another. The use case is i have data from module A (list) that needs to be show to module B (detail view), and module B can also update the data so I need to get it back to module A also.</p>
<p>With delegates it works okay but when I use a sink subscriber I am facing an issue.</p>
<p>The first time I go from module A to module B, I pass the subscriber and then subscribe it to the publisher (from moduleB) it works well and the subscriber in module A receives all the events from module B.</p>
<p>But then when dismissing the module B and routing again from A to B, then the subscriber receives immediately a cancel event when trying to subscribe again: <strong>receive subscription: (PublishedSubject) ... receive cancel ...</strong></p>
<p>I made a very simplified example to show what is happening:</p>
<p><strong>Module A:</strong></p>
<pre><code>class ViewController_A: UIViewController {
    
    var subscriber: AnySubscriber&lt;String, Never&gt;!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        createSubscriber()
    }
    
    func createSubscriber() {
        let subscriber = Subscribers.Sink&lt;String, Never&gt;(
            receiveCompletion: { completion in
                print(completion)
            }, receiveValue: { value in
                print(value)
            })
        self.subscriber = AnySubscriber(subscriber)
    }
    
    func showViewControllerB() {
        let viewControllerB = ViewControllerB()
        viewControllerB.passSubscriber(AnySubscriber(subscriber))
    }
}
</code></pre>
<p><strong>Module B:</strong></p>
<pre><code>protocol MyProtocol {
    var publisher: Published&lt;String&gt;.Publisher { get }
    func passSubscriber(_ subscriber: AnySubscriber&lt;String, Never&gt;)
}

class ViewController_B: UIViewController, MyProtocol {
    
    @Published var word: String = &quot;House&quot;
    var publisher: Published&lt;String&gt;.Publisher { $word }
    
    func passSubscriber(_ subscriber: AnySubscriber&lt;String, Never&gt;) {
        publisher
            .print()
            .subscribe(subscriber)
    }
    
    func dismiss() {
        dismiss(animated: true)
    }
}
</code></pre>
<p><strong>When routing..</strong></p>
<pre><code>let viewControllerA = ViewController_A()
viewControllerA.showViewController_B() // When presenting B for the first time, receiving events here
// Dismiss B here...
viewControllerA.showViewControllerB() // When presenting B again (hence subscribing again), the subscription gets cancelled here without receiving any events/values
</code></pre>
<p>I noticed something interesting.. When I create the subscriber again every time I route to module B instead of creating it only one time in <code>viewDidLoad</code>, it seems to work okay, but I am not sure why.</p>
<p>Does this mean that a subscriber cannot subscribe to another publisher once it subscribed to one, even when the previous publisher doesn't exist anymore?</p>
<p>How I can make it work in my delegation case?</p>
","","user13611542","3585796","","2021-11-02 02:19:54","2021-11-02 02:19:54","Combine - Subscriber gets cancelled silently when subscribing a second time","<swift><combine><delegation><viper-architecture>","1","6","0","","","CC BY-SA 4.0"
"65176436","1","65176792","","2020-12-07 05:12:22","","2","1057","<p>I have a particular situation where the returning function provides something like <code>AnyPublisher&lt;Response, Error&gt;</code>. But from the calling function, I want to return <code>AnyPublisher&lt;Response, Never&gt;</code>.</p>
<pre><code>//just an example
func getList(_ request: QueryRequest) -&gt; AnyPublisher&lt;Response, Never&gt; {
   return executeQuery(request).eraseToAnyPublisher()
}

func executeQuery(_ request: QueryRequest) -&gt; AnyPublisher&lt;Response, Error&gt; {
   return someData().eraseToAnyPublisher()
}
</code></pre>
<p>When I do this, I am getting <code>Cannot convert return expression of type 'AnyPublisher&lt;Response, Error&gt;' to return type 'AnyPublisher&lt;Response, Never&gt;'</code></p>
<p>How do I do convert to <code>AnyPublisher&lt;Response, Never&gt;</code> without modifying the called function?</p>
<p>Note: <em>I cannot modify the called function's return type as it's used by other methods which make use of Error</em></p>
","849486","","","","","2020-12-07 06:06:09","Combine: AnyPublisher<Response, Error> to AnyPublisher<Response, Never>","<swift><combine>","1","8","","","","CC BY-SA 4.0"
"65194585","1","65195474","","2020-12-08 07:13:39","","2","487","<p>I'm trying to manage user state via a series of nested classes.</p>
<p>The basic view of the app uses a <code>globalState</code> environment object. This object allows other views to the user in and out.</p>
<pre class=""lang-swift prettyprint-override""><code>@EnvironmentObject var globalState: GlobalState

// View Code
Text(&quot;Logged In&quot;).opacity(globalState.user.isLoggedIn ? 1 : 0)
Text(&quot;Please Sign In&quot;).opacity(globalState.user.isLoggedIn ? 0 : 1)
</code></pre>
<p>Then the <code>GlobalState</code> class merely houses the <code>User</code> class. The <code>user</code> field is init'ed elsewhere (and no, I'm not referencing different <code>user</code> objects).</p>
<pre class=""lang-swift prettyprint-override""><code>class GlobalState: ObservableObject {
    @Published public var user: User // Inited somewhere else
}
class User {
    @Published var isLoggedIn: Bool = false
}
</code></pre>
<p>The <code>User</code> class automatically pulls data about the user when it is <code>init</code>ed. On app launch, user information is pulled from the Keychain (if present). If the user can be created from existing data, that user's <code>isLoggedIn</code> is set to <code>true</code>.</p>
<p>I know I do not have duplicate objects, as the memory addresses of the <code>globalState.user</code> in <code>GlobalState</code>'s View Code is the same as when <code>isLoggedIn</code> is updated for a user.</p>
<p>I feel a disturbance in the Force by using two levels of <code>@Published</code> variables, but everything should work out?</p>
<p>The view code in <code>GlobalState</code> does not update though. Any one know why? Some Combine jiu jitsu I'm missing?</p>
","6637709","","","","","2020-12-08 08:25:44","SwiftUI Published updates not refreshing","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"65202102","1","65205031","","2020-12-08 15:43:37","","0","616","<p>I'm pretty new to SwiftUI, so I'd love any help!</p>
<p>I'm looking to build a <code>TextField</code> that shows an error state based on the validation of the <code>text</code>.</p>
<p>For example, if the <code>TextField</code> is meant to collect an email, show an error if the <code>text</code> doesn't contain <code>@</code>. Let's say the error state would change the border color of the <code>TextField</code> to <code>Color.green</code>.</p>
<p>I was thinking of approaching this with a validating closure, but I'm still unsure of how to change the actual visual state of the <code>TextField</code>.</p>
<p>I see that we can <a href=""https://stackoverflow.com/questions/60379010/how-to-change-swiftui-textfield-style-after-tapping-on-it"">can change border color based on editing state</a> - should I just declare something like a <code>@State var isError</code>?</p>
<p>I've also tried holding <code>TextFieldStyle</code> as a <code>@State</code>, but that seems to be a protocol with an associated type, which I haven't been able to get around:</p>
<p>Something like:</p>
<pre><code>TextField(&quot;&quot;,
              text: $text,
              onEditingChanged: { _ in
                self.style = CustomErrorStyle()
</code></pre>
<p>Please let me know if I can clarify at all, thanks!</p>
","6383587","","6383587","","2020-12-08 15:59:11","2020-12-08 18:49:34","How can you change TextField state based on input in SwiftUI?","<ios><swift><swiftui><textfield><combine>","1","4","","","","CC BY-SA 4.0"
"65268884","1","65269387","","2020-12-12 19:19:11","","1","49","<p>I am trying to create a <code>Fetchable</code> protocol that contains the location of where to get the objects from as part of its type, and instead of writing the <code>fetch</code> function with an explicit type parameter, like this:</p>
<pre><code>func fetch&lt;Model: Fetchable&gt;(_ type: Model.Type, path: Model.Path) -&gt; AnyPublisher&lt;[Model], Error&gt; {
   print(path.value)
   // ...
}
</code></pre>
<p>I would like <code>Model</code> to be inferred from the <code>Model.Path</code> parameter:</p>
<pre><code>func fetch&lt;Model: Fetchable&gt;(path: Model.Path) -&gt; AnyPublisher&lt;[Model], Error&gt; {
   print(path.value)
   // ...
}
</code></pre>
<p>This is inspired by @RobNapier's approach <a href=""https://robnapier.net/thats-not-a-number"" rel=""nofollow noreferrer"">here</a>. It's not exactly the same, and so I might be missing salient details to make it work.</p>
<p>Here's what I have:</p>
<pre><code>protocol Locatable {
   associatedtype Model
   var value: String { get }
}
</code></pre>
<hr />
<pre><code>protocol Fetchable: Codable {
   associatedtype Path: Locatable where Path.Model == Self
}
</code></pre>
<hr />
<pre><code>struct Message {
   let content: String
}
</code></pre>
<hr />
<pre><code>extension Message: Fetchable, Codable {
   enum Path: Locatable {
      typealias Model = Message
      case forUser(_ userId: String)
      var value: String {
         switch self {
         case .forUser(let userId): return &quot;/user/\(userId)/messages&quot;
         }
      }
   }
}
</code></pre>
<p>When I call <code>fetch</code>, I get an error <strong><code>&quot;Generic parameter 'Model' could not be inferred&quot;</code></strong></p>
<pre><code>let pub = fetch(path: Message.Path.forUser(&quot;123&quot;))
</code></pre>
<p>But this works with a <code>fetch</code> that accepts the type parameter explicitly (even infers its own Message.Path type):</p>
<pre><code>let pub = fetch(Message.self, .forUser(&quot;123&quot;))
</code></pre>
<p>Any idea how (if possible) to solve this?</p>
","968155","","2303865","","2020-12-12 23:12:55","2020-12-12 23:12:55","Inferring a generic type from its nested type","<swift>","1","0","","","","CC BY-SA 4.0"
"65297150","1","65297766","","2020-12-14 22:05:30","","0","831","<p>I am new to SwiftUI and I am having difficulty with something that I presume is rather simple.
I have created an app that shows the user's current location. If the user puts the app into the background, and the user's physical location changes, the app does not show the new location when it enters the foreground. If I kill the app, then restart, it shows the new location.</p>
<p>I also want to call a function to get an updated dataset from Firebase when the location change is detected. Here is a simplified version of the code that I am using. Please let me know what I am missing. I think I am supposed to use more Combine functionality to achieve this outcome, but I am not sure how?</p>
<p><em><strong>My key question is: &quot;How do I detect a location change in my view and call a function as a result of that location change?&quot;</strong></em></p>
<p>MyView.swift</p>
<pre><code>import SwiftUI

struct MyView: View {

    @ObservedObject var locationManager = LocationManager()

    var userLatitude: String {
        return &quot;\(locationManager.lastLocation?.coordinate.latitude ?? 0)&quot;
    }

    var userLongitude: String {
        return &quot;\(locationManager.lastLocation?.coordinate.longitude ?? 0)&quot;
    }

    var body: some View {
        VStack {
            Text(&quot;location status: \(locationManager.statusString)&quot;)
            HStack {
                Text(&quot;latitude: \(userLatitude)&quot;)
                Text(&quot;longitude: \(userLongitude)&quot;)
            }
            Text(&quot;place: \(locationManager.placemark?.thoroughfare ?? &quot;&quot;)&quot;) 
        }
     
    }
    
    func refreshData() {
        // call firebase listener with new location data
    }

}
</code></pre>
<p>LocationManager.swift</p>
<pre><code>import Foundation
import CoreLocation
import Combine

class LocationManager: NSObject, ObservableObject {
    
    let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()
    
    private let locationManager = CLLocationManager()
    
    override init() {
        super.init()
        self.locationManager.delegate = self
        self.locationManager.desiredAccuracy = kCLLocationAccuracyThreeKilometers
        self.locationManager.requestWhenInUseAuthorization()
        self.locationManager.startUpdatingLocation()
    }
    
    @Published var locationStatus: CLAuthorizationStatus? {
        willSet {
            objectWillChange.send()
        }
    }
    
    @Published var lastLocation: CLLocation? {
        willSet {
            objectWillChange.send()
        }
    }
    
    @Published var placemark: CLPlacemark? {
        willSet {
            objectWillChange.send()
        }
    }
    
    var statusString: String {
        guard let status = locationStatus else {
            return &quot;unknown&quot;
        }
        
        switch status {
        case .notDetermined: return &quot;notDetermined&quot;
        case .authorizedWhenInUse: return &quot;authorizedWhenInUse&quot;
        case .authorizedAlways: return &quot;authorizedAlways&quot;
        case .restricted: return &quot;restricted&quot;
        case .denied: return &quot;denied&quot;
        default: return &quot;unknown&quot;
        }
        
    }
    
}

extension LocationManager: CLLocationManagerDelegate {
    
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        self.locationStatus = status
        print(#function, statusString)
    }
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        self.lastLocation = location
        print(#function, location)
        
        let geocoder = CLGeocoder()
        geocoder.reverseGeocodeLocation(location) { (placemarks, error) in
            if (error != nil){
                print(&quot;Error in reverseGeocode: \(error)&quot;)
                return
            }
            
            let placemark = placemarks! as [CLPlacemark]
            
            if placemark.count &gt; 0 {
                let placemark = placemarks![0]
                self.placemark = placemark
            }
        }
        locationManager.stopUpdatingLocation()
    }
    
    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        if let error = error as? CLError, error.code == .denied {
            // Location updates are not authorized.
            locationManager.stopUpdatingLocation()
            return
        }
        // Notify the user of any errors.
    }
    
}
</code></pre>
","7993358","","","","","2020-12-14 23:02:04","SwiftUI - Get Location and Call Function when App enters Foreground","<swiftui><core-location><combine>","1","2","","","","CC BY-SA 4.0"
"65297268","1","65304528","","2020-12-14 22:15:51","","1","393","<p>I like to test if the variable is nil because it is set when a connection to the server is established.
But when I do I receive an EXC_BREAKPOINT code=1. I can't figure out why. Here's the code:</p>
<pre><code>struct CategoryView: View {
@ObservedObject var viewRouter: ViewRouter
@Environment(\.presentationMode) var presentationMode: Binding&lt;PresentationMode&gt;

var body: some View {
    NavigationView {
        if (viewRouter.menuStructure != nil) {
            CategoryPage(viewRouter: viewRouter, settingsShown: true, pageTitle: &quot;Räume&quot;, items: viewRouter.menuStructure?.items ?? [])
        }
    }
    .edgesIgnoringSafeArea(.top)
}
</code></pre>
<p>bt in debugger shows the following:</p>
<pre>
* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BREAKPOINT (code=1, subcode=0x1a1d79bd4)
  * frame #0: 0x00000001a1d79bd4 SwiftUI`SwiftUI.ColumnNavigationView.BodyContent.body.getter : some + 944
    frame #1: 0x00000001a1ba22f4 SwiftUI`generic specialization  of SwiftUI.ViewBodyAccessor.updateBody(of: A, changed: Swift.Bool) -> () + 1276
    frame #2: 0x00000001a1cac218 SwiftUI`generic specialization >.0, SwiftUI.StaticBody>> of implicit closure #2 (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in implicit closure #1 (A1.Type) -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 () -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 (Swift.UnsafePointer) -> AttributeGraph.Attribute in AttributeGraph.Attribute.init(A1) -> AttributeGraph.Attribute + 40
    frame #3: 0x00000001c39aabc0 AttributeGraph`AG::Graph::UpdateStack::update() + 492
    frame #4: 0x00000001c39aaff4 AttributeGraph`AG::Graph::update_attribute(AG::data::ptr, bool) + 332
    frame #5: 0x00000001c39b06f8 AttributeGraph`AG::Graph::input_value_ref_slow(AG::data::ptr, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 384
    frame #6: 0x00000001c39c272c AttributeGraph`AGGraphGetValue + 232
    frame #7: 0x00000001a1a5923c SwiftUI`generic specialization >, SwiftUI.MulticolumnSplitView>, SwiftUI.MulticolumnSplitView, Swift.AnyHashable, SwiftUI._VariadicView_Children.Element>>>> of (extension in SwiftUI):SwiftUI._ConditionalContent.(ChildView in _1A625ACC143FD8524C590782FD8F4F8C).content.getter : SwiftUI._ConditionalContent + 48
    frame #8: 0x00000001a1a59d78 SwiftUI`generic specialization >, SwiftUI.MulticolumnSplitView>, SwiftUI.MulticolumnSplitView, Swift.AnyHashable, SwiftUI._VariadicView_Children.Element>>>> of (extension in SwiftUI):SwiftUI._ConditionalContent.(ChildView in _1A625ACC143FD8524C590782FD8F4F8C).value.getter : SwiftUI.AnyView + 40
    frame #9: 0x00000001a1a7c230 SwiftUI`merged generic specialization , SwiftUI._EnvironmentKeyWritingModifier>>, SwiftUI._EnvironmentKeyWritingModifier>>, SwiftUI._EnvironmentKeyWritingModifier>, SwiftUI._AlignmentLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.SizeLimitLayout>, SwiftUI._BackgroundModifier, SwiftUI.ModifiedContent, SwiftUI._FrameLayout>, SwiftUI._PushPopTransactionModifier>, SwiftUI._OffsetEffect>)>>>>, SwiftUI._BackgroundModifier, SwiftUI.ModifiedContent, SwiftUI._FrameLayout>, SwiftUI._PushPopTransactionModifier>, SwiftUI._OffsetEffect>)>>>>, SwiftUI._EnvironmentKeyWritingModifier>>, SwiftUI.ModifiedContent, SwiftUI._EnvironmentKeyWritingModifier>>, SwiftUI._EnvironmentKeyWritingModifier>>, SwiftUI._EnvironmentKeyWritingModifier>, SwiftUI._AlignmentLayout>, SwiftUI._PaddingLayout>, SwiftUI._PaddingLayout>, SwiftUI.SizeLimitLayout>, SwiftUI._BackgroundModifier, SwiftUI.ModifiedContent, SwiftUI._FrameLayout>, SwiftUI._PushPopTransactionModifier>, SwiftUI._OffsetEffect>)>>>>, SwiftUI._BackgroundModifier, SwiftUI.ModifiedContent, SwiftUI._FrameLayout>, SwiftUI._PushPopTransactionModifier>, SwiftUI._OffsetEffect>)>>>>, SwiftUI._EnvironmentKeyWritingModifier>>, SwiftUI._EnvironmentKeyWritingModifier>>, SwiftUI._EnvironmentKeyWritingModifier>>>.(ChildView in _1A625ACC143FD8524C590782FD8F4F8C)> of implicit closure #2 (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in implicit closure #1 (A1.Type) -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 () -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 (Swift.UnsafePointer) -> AttributeGraph.Attribute in AttributeGraph.Attribute.init(A1) -> AttributeGraph.Attribute + 32
    frame #10: 0x00000001a1a9fcd8 SwiftUI`partial apply forwarder for generic specialization >, SwiftUI.MulticolumnSplitView>, SwiftUI.MulticolumnSplitView, Swift.AnyHashable, SwiftUI._VariadicView_Children.Element>>>>.(ChildView in _1A625ACC143FD8524C590782FD8F4F8C)> of implicit closure #2 (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in implicit closure #1 (A1.Type) -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 () -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 (Swift.UnsafePointer) -> AttributeGraph.Attribute in AttributeGraph.Attribute.init(A1) -> AttributeGraph.Attribute + 28
    frame #11: 0x00000001c39aabc0 AttributeGraph`AG::Graph::UpdateStack::update() + 492
    frame #12: 0x00000001c39aaff4 AttributeGraph`AG::Graph::update_attribute(AG::data::ptr, bool) + 332
    frame #13: 0x00000001c39b06f8 AttributeGraph`AG::Graph::input_value_ref_slow(AG::data::ptr, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 384
    frame #14: 0x00000001c39c272c AttributeGraph`AGGraphGetValue + 232
    frame #15: 0x00000001a2069728 SwiftUI`SwiftUI.(AnyViewList in _A96961F3546506F21D8995C6092F15B5).updateValue() -> () + 60
    frame #16: 0x00000001a1cd0434 SwiftUI`partial apply forwarder for generic specialization  of implicit closure #2 (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in implicit closure #1 (A1.Type) -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 () -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 (Swift.UnsafePointer) -> AttributeGraph.Attribute in AttributeGraph.Attribute.init(A1) -> AttributeGraph.Attribute + 24
    frame #17: 0x00000001c39aabc0 AttributeGraph`AG::Graph::UpdateStack::update() + 492
    frame #18: 0x00000001c39aaff4 AttributeGraph`AG::Graph::update_attribute(AG::data::ptr, bool) + 332
    frame #19: 0x00000001c39b06f8 AttributeGraph`AG::Graph::input_value_ref_slow(AG::data::ptr, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 384
    frame #20: 0x00000001c39c272c AttributeGraph`AGGraphGetValue + 232
    frame #21: 0x00000001a1e85f74 SwiftUI`SwiftUI.(DynamicLayoutViewAdaptor in _8B9C7F39264416187A895085215951BC).updatedItems() -> Swift.Optional + 64
    frame #22: 0x00000001a1bc1fe0 SwiftUI`generic specialization  of SwiftUI.DynamicContainerInfo.(updateItems in _023AA827B8A8D39774F7A0C281455FEE)(disableTransitions: Swift.Bool) -> (changed: Swift.Bool, hasDepth: Swift.Bool) + 68
    frame #23: 0x00000001a1bc106c SwiftUI`generic specialization  of SwiftUI.DynamicContainerInfo.updateValue() -> () + 340
    frame #24: 0x00000001a1cb1514 SwiftUI`partial apply forwarder for generic specialization > of implicit closure #2 (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in implicit closure #1 (A1.Type) -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 () -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 (Swift.UnsafePointer) -> AttributeGraph.Attribute in AttributeGraph.Attribute.init(A1) -> AttributeGraph.Attribute + 24
    frame #25: 0x00000001c39aabc0 AttributeGraph`AG::Graph::UpdateStack::update() + 492
    frame #26: 0x00000001c39aaff4 AttributeGraph`AG::Graph::update_attribute(AG::data::ptr, bool) + 332
    frame #27: 0x00000001c39b06f8 AttributeGraph`AG::Graph::input_value_ref_slow(AG::data::ptr, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 384
    frame #28: 0x00000001c39c272c AttributeGraph`AGGraphGetValue + 232
    frame #29: 0x00000001a1d37768 SwiftUI`SwiftUI.(DynamicPreferenceCombiner in _023AA827B8A8D39774F7A0C281455FEE).info.getter : Swift.Optional + 96
    frame #30: 0x00000001a1d37960 SwiftUI`SwiftUI.(DynamicPreferenceCombiner in _023AA827B8A8D39774F7A0C281455FEE).value.getter : A.Value + 204
    frame #31: 0x00000001a1ae2f9c SwiftUI`implicit closure #2 (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in implicit closure #1 (A1.Type) -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 () -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 (Swift.UnsafePointer) -> AttributeGraph.Attribute in AttributeGraph.Attribute.init(A1) -> AttributeGraph.Attribute + 124
    frame #32: 0x00000001c39aabc0 AttributeGraph`AG::Graph::UpdateStack::update() + 492
    frame #33: 0x00000001c39aaff4 AttributeGraph`AG::Graph::update_attribute(AG::data::ptr, bool) + 332
    frame #34: 0x00000001c39b06f8 AttributeGraph`AG::Graph::input_value_ref_slow(AG::data::ptr, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 384
    frame #35: 0x00000001c39c272c AttributeGraph`AGGraphGetValue + 232
    frame #36: 0x00000001a1d37c14 SwiftUI`SwiftUI.(DynamicPreferenceCombiner in _023AA827B8A8D39774F7A0C281455FEE).value.getter : A.Value + 896
    frame #37: 0x00000001a1ae2f9c SwiftUI`implicit closure #2 (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in implicit closure #1 (A1.Type) -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 () -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 (Swift.UnsafePointer) -> AttributeGraph.Attribute in AttributeGraph.Attribute.init(A1) -> AttributeGraph.Attribute + 124
    frame #38: 0x00000001c39aabc0 AttributeGraph`AG::Graph::UpdateStack::update() + 492
    frame #39: 0x00000001c39aaff4 AttributeGraph`AG::Graph::update_attribute(AG::data::ptr, bool) + 332
    frame #40: 0x00000001c39b06f8 AttributeGraph`AG::Graph::input_value_ref_slow(AG::data::ptr, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 384
    frame #41: 0x00000001c39c272c AttributeGraph`AGGraphGetValue + 232
    frame #42: 0x00000001a2009d90 SwiftUI`SwiftUI.(HostPreferencesTransform in _5EC2B8E51282B711F818D51701767C64).updateValue() -> () + 88
    frame #43: 0x00000001a1d3ec10 SwiftUI`partial apply forwarder for implicit closure #2 (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in implicit closure #1 (A1.Type) -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 () -> (Swift.UnsafeMutableRawPointer, __C.AGAttribute) -> () in closure #1 (Swift.UnsafePointer) -> AttributeGraph.Attribute in AttributeGraph.Attribute.init(A1) -> AttributeGraph.Attribute + 32
    frame #44: 0x00000001c39aabc0 AttributeGraph`AG::Graph::UpdateStack::update() + 492
    frame #45: 0x00000001c39aaff4 AttributeGraph`AG::Graph::update_attribute(AG::data::ptr, bool) + 332
    frame #46: 0x00000001c39b0154 AttributeGraph`AG::Graph::value_ref(AG::AttributeID, AGSwiftMetadata const*, bool*) + 156
    frame #47: 0x00000001c39c2774 AttributeGraph`AGGraphGetValue + 304
    frame #48: 0x00000001a236d5b8 SwiftUI`SwiftUI.GraphHost.updatePreferences() -> Swift.Bool + 56
    frame #49: 0x00000001a1e5b9d4 SwiftUI`SwiftUI.ViewGraph.updateOutputs(at: SwiftUI.Time) -> () + 112
    frame #50: 0x00000001a22c2eac SwiftUI`closure #1 () -> () in (extension in SwiftUI):SwiftUI.ViewRendererHost.render(interval: Swift.Double, updateDisplayList: Swift.Bool) -> () + 1444
    frame #51: 0x00000001a22ba090 SwiftUI`(extension in SwiftUI):SwiftUI.ViewRendererHost.render(interval: Swift.Double, updateDisplayList: Swift.Bool) -> () + 340
    frame #52: 0x00000001a243ee00 SwiftUI`SwiftUI._UIHostingView.layoutSubviews() -> () + 176
    frame #53: 0x00000001a243ee34 SwiftUI`@objc SwiftUI._UIHostingView.layoutSubviews() -> () + 28
    frame #54: 0x000000019e383d90 UIKitCore`-[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 2504
    frame #55: 0x000000019e899384 QuartzCore`-[CALayer layoutSublayers] + 308
    frame #56: 0x000000019e899858 QuartzCore`CA::Layer::layout_if_needed(CA::Transaction*) + 524
    frame #57: 0x000000019e8adff8 QuartzCore`CA::Layer::layout_and_display_if_needed(CA::Transaction*) + 144
    frame #58: 0x000000019e7f3ee0 QuartzCore`CA::Context::commit_transaction(CA::Transaction*, double, double*) + 416
    frame #59: 0x000000019e81f36c QuartzCore`CA::Transaction::commit() + 732
    frame #60: 0x000000019de55240 UIKitCore`__34-[UIApplication _firstCommitBlock]_block_invoke_2 + 84
    frame #61: 0x000000019b40449c CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 28
    frame #62: 0x000000019b4036e4 CoreFoundation`__CFRunLoopDoBlocks + 408
    frame #63: 0x000000019b3fdaa0 CoreFoundation`__CFRunLoopRun + 844
    frame #64: 0x000000019b3fd21c CoreFoundation`CFRunLoopRunSpecific + 600
    frame #65: 0x00000001b247c784 GraphicsServices`GSEventRunModal + 164
    frame #66: 0x000000019de36200 UIKitCore`-[UIApplication _run] + 1072
    frame #67: 0x000000019de3ba74 UIKitCore`UIApplicationMain + 168
    frame #68: 0x00000001a22fcb20 SwiftUI`closure #1 (Swift.UnsafeMutablePointer>>) -> Swift.Never in SwiftUI.(KitRendererCommon in _ACC2C5639A7D76F611E170E831FCA491)(Swift.AnyObject.Type) -> Swift.Never + 112
    frame #69: 0x00000001a22fcaac SwiftUI`SwiftUI.runApp(A) -> Swift.Never + 220
    frame #70: 0x00000001a1e54e5c SwiftUI`static (extension in SwiftUI):SwiftUI.App.main() -> () + 140
    frame #71: 0x0000000102377478 JarvisHome`static JarvisHomeApp.$main(self=JarvisHome.JarvisHomeApp) at :0
    frame #72: 0x0000000102379cf8 JarvisHome`main at JarvisHomeApp.swift:0
    frame #73: 0x000000019b0bd6c0 libdyld.dylib`start + 4
</pre>
<p>Any suggestions why? If i comment out the if line code isn't crashing.</p>
<p><strong>EDIT</strong>: ViewRouter.swift</p>
<pre><code>import Foundation
import Combine
import SwiftUI

class ViewRouter: ObservableObject {
    let objectWillChange = PassthroughSubject&lt;ViewRouter, Never&gt;()
    
    var currentPage: String = &quot;myhome&quot; {
        didSet {
            objectWillChange.send(self)
        }
    }
    
    var symcSocketStatus: String = &quot;connecting&quot; {
        didSet {
            objectWillChange.send(self)
        }
    }
    
    var syncSocketStatusShown: Bool = true {
        didSet {
            objectWillChange.send(self)
        }
    }
    
    var settingsShown: Bool = false {
        didSet {
            objectWillChange.send(self)
        }
    }
    
    var menuStructure: MenuItem? = nil {
        didSet {
            objectWillChange.send(self)
        }
    }
}
</code></pre>
<p><strong>EDIT</strong>: MenuItem.swift</p>
<pre><code>import Foundation

struct MenuItem: Codable {
    //var data: [String: Any]
    var disabled: Bool
    var hidden: Bool
    var icon: String?
    var id: Int
    var ident: String
    var info: String
    var items: [MenuItem]?
    var name: String
    var parentId: Int?
    var position: Int
    var readOnly: Bool
    var summary: String
    var type: Int
    
    init() {
//        self.data = [&quot;&quot;: &quot;&quot;]
        self.disabled =  true
        self.hidden = false
        self.icon = &quot;&quot;
        self.id = -1
        self.ident = &quot;&quot;
        self.info = &quot;&quot;
        self.items = []
        self.name = &quot;Unknown&quot;
        self.parentId = 0
        self.position = 0
        self.readOnly = true
        self.summary = &quot;&quot;
        self.type = -1
    }
}
</code></pre>
","13134373","","13134373","","2020-12-15 10:10:43","2020-12-15 10:58:56","Swift: EXC_BREAKPOINT when trying to test if ObservedObject variable is nil","<swift><exception><view><swiftui>","1","3","","","","CC BY-SA 4.0"
"65297505","1","65297709","","2020-12-14 22:36:03","","1","81","<p>I have created an Atimeter as ObservableObject, so that I can access it from several points in my App. Unfortunately the view is not updating, when the @Published variable pressure changes. Can somebody explain why?</p>
<p>I already tried {willSet {objectWillChange.send()} }, which will trigger but also not update the View!</p>
<p>The Altimeter:</p>
<pre><code>//
//  Altimeter.swift
//  iAlti_v2
//
//  Created by Lukas Wheldon on 14.12.20.
//

import Foundation
import CoreMotion
import Combine

class Altimeter: CMAltimeter, ObservableObject {
    static let shared = Altimeter()
    
    @Published var pressure: Double = 0
    
    func start() {
        if Altimeter.isRelativeAltitudeAvailable() {
            switch Altimeter.authorizationStatus() {
            case .notDetermined: // Handle state before user prompt
                debugPrint(&quot;CM: Awaiting user prompt...&quot;)
            //fatalError(&quot;Awaiting CM user prompt...&quot;)
            case .restricted: // Handle system-wide restriction
                fatalError(&quot;CM Authorization restricted!&quot;)
            case .denied: // Handle user denied state
                fatalError(&quot;CM Authorization denied!&quot;)
            case .authorized: // Ready to go!
                debugPrint(&quot;CM Authorized!&quot;)
            @unknown default:
                fatalError(&quot;Unknown CM Authorization Status!&quot;)
            }
            Altimeter.shared.startRelativeAltitudeUpdates(to: OperationQueue.main) { data, error in
                if let trueData = data {
                    //debugPrint(#function, trueData)
                    Altimeter.shared.pressure = trueData.pressure.doubleValue * 10
                } else {
                    debugPrint(&quot;Error starting relative Altitude Updates: \(error?.localizedDescription ?? &quot;Unknown Error&quot;)&quot;)
                }
            }
        }
    }
}
</code></pre>
<p>The View:</p>
<pre><code>import SwiftUI

struct SwiftUIView: View {
    var body: some View {
        Text(&quot;\(Altimeter.shared.pressure)&quot;)
    }
}

</code></pre>
","7678035","","7678035","","2020-12-14 22:56:29","2020-12-15 10:55:26","ObservableObject not updating View","<ios><xcode><swiftui><combine><observableobject>","2","0","","","","CC BY-SA 4.0"
"65309270","1","65309481","","2020-12-15 15:52:51","","0","212","<p>I'm trying to make an easy application in SwiftUI for iOS. I'm following the instructions of a YouTube video which shows how to make an API call from PokeAPI in order to show a List of Pokemon in the view. I made every single step equal to those of the video but the compiler returns me errors like these in the code below.</p>
<p>PokemonAPIList.swift</p>
<pre><code>import Foundation

struct PokemonAPIList: Decodable {
    var results: [PokemonListEntry]
}

struct PokemonListEntry: Decodable {
    var name: String
    var url: String
}
</code></pre>
<p>PokemonNetworkManager.swift</p>
<pre><code>import Foundation
import SwiftUI
import Combine

class PokemonNetworkManager: ObservableObject {
    var didChange = PassthroughSubject&lt;PokemonNetworkManager, Never&gt; ()
    
    var pokemonList = PokemonAPIList(results: []) {
        didSet {
            didChange.send(self)
        }
    }
    
    init() {
        guard let url = URL(string: &quot;https://pokeapi.co/api/v2/pokemon?limit=151&quot;) else { return }
        
        URLSession.shared.dataTask(with: url) { (data, _, _) in
            guard let data = data else { return }
            
            let pokemonList = try! JSONDecoder().decode(PokemonAPIList.self, from: data)
            
            DispatchQueue.main.async {
                self.pokemonList = pokemonList
            }
        }.resume()
    }
}
</code></pre>
<p>ContentView.swift</p>
<pre><code>import SwiftUI
    
struct ContentView: View {
    @State var networkingManager = PokemonNetworkManager()
    
    var body: some View {
        List(networkingManager.pokemonList.results.identified(by: \.url)) {pokemon in //HERE THE ERRORS
            Text(pokemon.name)
                .font(.largeTitle)
        }
    }
}

#if DEBUG
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
#endif
</code></pre>
<p><strong>Following Errors occur:</strong></p>
<blockquote>
<p>Cannot infer key path type from context; consider explicitly specifying a root type</p>
</blockquote>
<blockquote>
<p>Insert '&lt;#Root#&gt;'</p>
</blockquote>
<blockquote>
<p>Value of type '[PokemonListEntry]' has no member 'identified'</p>
</blockquote>
<p>The only thing I changed is @BindableObject to @ObservableObject because I read online it is no longer supported.</p>
","13535799","","13087977","","2020-12-15 16:45:31","2020-12-26 09:20:22","API calls for SwiftUI application","<ios><swift><api><swiftui>","1","0","","","","CC BY-SA 4.0"
"65311424","1","65311519","","2020-12-15 18:12:52","","-2","526","<p>I am following a tutorial to make API Calls using Swift but I need to take only the first item of the array retrieved. So, my question is: &quot;What is the best way to pick the first element of an Array/Dictionary of JSON Objects?&quot;.</p>
<p>I am trying several ways but they show me no light at the end of the tunnel.</p>
<p>Here's the example code.</p>
<p>PokemonAPIList.swift</p>
<pre><code>import Foundation

struct PokemonAPIList: Decodable {
    var results: [PokemonListEntry]
}

struct PokemonListEntry: Decodable {
    var name: String
    var url: String
}
</code></pre>
<p>PokemonNetworkManager.swift</p>
<pre><code>import Foundation
import SwiftUI
import Combine

class PokemonNetworkManager: ObservableObject {
  
   @Published var results = [PokemonListEntry]()
     
   init() {
        guard let url = URL(string: &quot;https://pokeapi.co/api/v2/pokemon?limit=151&quot;) else { return }

        URLSession.shared.dataTask(with: url) { (data, _, _) in
            guard let data = data else { return }

            let pokemonList = try! JSONDecoder().decode(PokemonAPIList.self, from: data)

            DispatchQueue.main.async {
                self.results = pokemonList.results
            }
        }.resume()
   }
}
</code></pre>
<p>ContentView.swift</p>
<pre><code>import SwiftUI
    
struct ContentView: View {
   @ObservedObject var networkingManager = PokemonNetworkManager()

var body: some View {
    let bulbasaur = networkingManager.results.first
    
    Text(bulbasaur!.name) //Thread 1: Fatal error: Unexpectedly found nil while unwrapping an Optional value
        .bold()
}

/*THIS CODE BELOW WORKS
List(networkingManager.results, id:\.name) { pokemon in
            Text(pokemon.name)
        }
*/

#if DEBUG
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
#endif
</code></pre>
","13535799","","13535799","","2021-05-14 10:04:36","2021-05-14 10:04:36","Take the first item of a list in Swift","<swift><swiftui>","1","1","","2020-12-16 16:39:54","","CC BY-SA 4.0"
"65327281","1","65328672","","2020-12-16 16:28:50","","1","347","<p>I'm new to the <code>Combine</code> game and am trying to figure out how to generalize a HTTP <code>POST</code> request.</p>
<p>I created the following <code>APIService</code> class to extend individual resource services from:</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

class APIService {
  let decoder: JSONDecoder
  let session: URLSession
  
  init(session: URLSession = URLSession.shared, decoder: JSONDecoder = JSONDecoder()) {
    self.decoder = decoder
    self.session = session
  }
}

// MARK: JSON API
extension APIService {
  struct Response&lt;T&gt; {
    let response: HTTPURLResponse
    let value: T
  }
  
  func post&lt;T: Codable&gt;(
    payload: T,
    url: URL
  ) -&gt; AnyPublisher&lt;Response&lt;T&gt;, APIError&gt; {
    return Just(payload)
      .setFailureType(to: APIError.self) // &lt;&lt;&lt; THIS WAS MISSING!
      .encode(encoder: JSONEncoder())
      .flatMap({ [weak self] payload -&gt; AnyPublisher&lt;Data, Error&gt; in
        guard let self = self else {
          return Fail(error: .default(&quot;Failing to establish self.&quot;)).eraseToAnyPublisher()
        }
        var request = URLRequest(url: url)
        request.httpMethod = Methods.post
        request.setValue(
          Mimetypes.json,
          forHTTPHeaderField: Headers.contentType
        )
        request.httpBody = payload
        return self.session
          .dataTaskPublisher(
            for: request
          )
          .tryMap { response -&gt; Response&lt;T&gt; in
            let value = try self.decoder.decode(T.self, from: response.data)
            return Response(
              value: value,
              response: response.response
            )
          }
          .mapError { error in
            return APIError.default(error.localizedDescription)
          }
          .receive(on: DispatchQueue.main)
          .eraseToAnyPublisher()
      })
      .eraseToAnyPublisher()
  }
}
</code></pre>
<p>However, this class won't compile with the following error at the <code>post</code> function.</p>
<pre><code>Type of expression is ambiguous without more context
</code></pre>
<p>Being new to Swift in general and Combine in particular, I am unfortunately out of ideas on how to proceed.</p>
<p><strong>Any help is greatly appreciated!</strong></p>
<h2>Figured it out myself: Solution</h2>
<p>Add a <code>Failure</code> type to the <code>Just</code>, so input and output <code>Failure</code> types to <code>flatMap</code> are equal. Or put differently: <code>flatMap</code> cannot convert the <code>Never</code> failing <code>Just</code> to a <code>Publisher</code> with <code>Failure</code>.</p>
<p>The missing line in my case:</p>
<pre class=""lang-swift prettyprint-override""><code>Just(payload)
  .setFailureType(to: APIError.self)
</code></pre>
","5061949","","5061949","","2020-12-16 17:58:16","2020-12-18 14:12:53","Trouble posting API request with Combine","<ios><swift><combine>","2","0","1","","","CC BY-SA 4.0"
"65353749","1","65353916","","2020-12-18 08:23:16","","0","2347","<p>I have a publisher which emits an optional output type. I need to <code>flatMap</code> to a new publisher if the output isn't <code>nil</code>, or fallback to an empty publisher if it is <code>nil</code>.</p>
<p>For example, something like:</p>
<pre class=""lang-swift prettyprint-override""><code>[1, nil, 5].publisher // Generic parameter 'T' could not be inferred
    .flatMap {
        $0?.someNewPublisher ?? Empty(completeImmediately: false)
    }
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>[1, nil, 5].publisher
    .map {
        $0?.someNewPublisher
    }
    .replaceNil(with: Empty(completeImmediately: false)) // Generic parameter 'Failure' could not be inferred
    .flatMap { $0 }

</code></pre>
<p>I'm wondering if maybe I'm trying to solve this in the wrong way. Just to be clear, filtering <code>nil</code> before mapping would not solve my issue, as that would not replace a current publisher with an empty publisher (I would continue to receive elements which I should no longer be receiving).</p>
","343299","","","","","2021-01-04 01:23:32","With Combine, how can you flatMap with nil-coalescing","<ios><swift><reactive-programming><combine>","2","3","","","","CC BY-SA 4.0"
"65362213","1","65362488","","2020-12-18 18:32:11","","0","278","<p>I have a view model that is parent to other children view models. That is:</p>
<pre><code>public class ViewModel: ObservableObject {
    
    @Published var nav = NavigationViewModel()
    @Published var screen = ScreenViewModel()
</code></pre>
<p>The other children view model, such as nav and screen, all serve a specific purpose. For example, nav’s responsibility is to keep track of the current screen:</p>
<pre><code>class NavigationViewModel: ObservableObject {
    
    // MARK: Publishers
    @Published var currentScreen: Screen = .Timeline
    
}
</code></pre>
<p>The ViewModel is instantiated in the App struct:</p>
<pre><code>    @main
struct Appy_WeatherApp: App {
    
    // MARK: Global
    var viewModel = ViewModel()
    
    // MARK: -
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(viewModel)
        }
    }
}
</code></pre>
<p>And I declare an @EnvironmentObject for it on any view that needs access to it:</p>
<pre><code>@EnvironmentObject var viewModel: ViewModel 
</code></pre>
<p>Any view referencing a non-object property of ViewModel that is being <code>@Published</code> whose value changes will result in the view to be re-rendered as expected. However, if the currentScreen <code>@Published</code> property of the <code>NavigationViewModel</code> changes, for example, then the view is not being re-rendered.</p>
<p>I know I can make it work if I separate <code>NavigationViewModel</code> from ViewModel, instantiate it at the app level and use it as its own environment object in any views that access any of its published properties.</p>
<p>My question is whether the above workaround is actually the correct way to handle this, and/or is there any way for views to be subscribed to value changes of properties inside child objects of environment objects? Or is there another way that I’ve not considered that’s the recommended approach for what I’m trying to achieve through fragmentation of view model responsibilities?</p>
","698971","","14437411","","2020-12-19 06:06:40","2020-12-19 06:06:40","Subscribing to value changes inside child objects of environment view models (view not being re-rendered when this happens)","<ios><swift><swiftui><viewmodel><combine>","1","0","1","","","CC BY-SA 4.0"
"65368391","1","65376768","","2020-12-19 09:32:26","","1","1376","<p>I'm working on caching for my network module. My module will return an <code>AnyCancallable</code> back to the caller for each request. If cached data is not available, I use <code>URLSession.dataTaskPublisher</code>, it works fine with 2 events: data received and completion. If cached data is available, I will use a  <code>CurrentValueSubject</code> to create the AnyCancallable to return. I send both of the 2 events on this subject, but on the caller side, it only gets notified on the completion, no data.</p>
<pre><code>cacheSubject.send(cachedData.data)
cacheSubject.send(completion: Subscribers.Completion&lt;Error&gt;.finished)
</code></pre>
<p>Removing the completion send and now it can receive data, but no completion notification.</p>
<p>Could someone please let me know what I'm doing wrong here?</p>
<p>Here is the full file in case you guys need it:</p>
<pre><code>public class SSNetworkManager {
    public static let shared = SSNetworkManager()
    
    private var cache: [String: CachedData] = [:]
    private let cacheSubject = CurrentValueSubject&lt;Data, Error&gt;(Data())
    
    @discardableResult public func makeServiceCall&lt;D: Decodable&gt;(forRequest request: SSNetworkRequest&lt;D&gt;, onMainThread: Bool = true) -&gt; AnyPublisher&lt;D, Error&gt;? {
        guard let urlRequest = request.urlRequest else {
            return nil
        }
        
        var cancelable: AnyPublisher&lt;Data, Error&gt;
        
        if let url = urlRequest.url?.absoluteString,
           let cachedData = cache[url],
           cachedData.isValid {
            cancelable = cacheSubject.eraseToAnyPublisher()
            cacheSubject.send(cachedData.data)
            cacheSubject.send(completion: Subscribers.Completion&lt;Error&gt;.finished)
        } else {
            cancelable = URLSession.shared.dataTaskPublisher(for: urlRequest).tryMap {[weak self] (data, response) -&gt; Data in
                guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                    throw SSNetworkError(httpCode: (response as? HTTPURLResponse)?.statusCode ?? 0, data: data)
                }
                if request.shouldCacheNow,
                   let url = urlRequest.url?.absoluteString {
                    self?.cache[url] = CachedData(data: data, expirationTime: request.cacheExpirationTime)
                }
                return data
            }.eraseToAnyPublisher()
        }
        
        if onMainThread {
            return cancelable
                .receive(on: RunLoop.main)
                .decode(type: D.self, decoder: JSONDecoder())
                .eraseToAnyPublisher()
        } else {
            return cancelable
                .decode(type: D.self, decoder: JSONDecoder())
                .eraseToAnyPublisher()
        }
    }
}

fileprivate struct CachedData {
    let data: Data
    let expirationTime: Date
    
    var isValid: Bool {
        return Date().compare(expirationTime) != .orderedDescending
    }
}
</code></pre>
","8355412","","","","","2020-12-20 03:52:45","Swift Combine: send completion after send value","<ios><swift><combine>","1","6","","","","CC BY-SA 4.0"
"65386645","1","65387024","","2020-12-21 01:54:40","","1","1549","<p>I'm trying to compose a publisher, that, when a subsequent subscriber connects to it, emits the last emitted value immediately to that subscriber, and then continues to emit future values to all connected subscribers.</p>
<p><strong>Q:</strong> Is there a way to do this <strong>without writing a publisher from scratch</strong>, and only by composing built-in publishers? I might be missing something here.</p>
<p>So, if we had a publisher counting every second:</p>
<pre><code>let counter = Timer.publish(every: 1, on: .main, in: .common)
                   .autoconnect()
                   .scan(0, { v, _ in v + 1 })


let sharedPublisher = // ??? something with counter publisher above

sharedPublisher.sink { print(&quot;A: &quot;, $0 }.store(in: &amp;bag)

// after 2.5 seconds
sharedPublisher.sink { print(&quot;B: &quot;, $0 }.store(in: &amp;bag)
</code></pre>
<p>The output would be:</p>
<pre><code>A: 1 // at t=1 sec
A: 2 // at t=2
B: 2 // at t=2.5
A: 3 // at t=3
B: 3 // at t=3
</code></pre>
<hr />
<p>Initially, naively, I thought I could just use a <code>.share</code> and a <code>.buffer</code>:</p>
<pre><code>let sharedPublisher = counter
                  .share()
                  .buffer(size: 1, prefetch: .byRequest, whenFull: .dropOldest)
</code></pre>
<p>but of course, that doesn't work since <code>buffer</code> only buffers if the downstream isn't ready to accept values, which isn't the case here.
Maybe something with <code>Record</code>/<code>Record.Recording</code>?</p>
","968155","","","","","2020-12-21 04:31:22","How to compose a combine publisher that emits the last-emitted value to its 2nd subscriber","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"65391477","1","65391657","","2020-12-21 10:55:34","","3","632","<p>I'm trying to figure out how to link the <code>@Binding</code> passed into a custom View to an <code>@Published</code> from that view's model.  Essentially I'm trying to create a reusable integer only TextField.  I'm using the below code, which works to set the integer value into the text field, but what I can't figure out is how to update the binding when the text changes.</p>
<pre class=""lang-swift prettyprint-override""><code>private class IntegerTextFieldValue: ObservableObject {
    @Published var value = &quot;&quot; {
        didSet {
            let numbersOnly = value.filter { $0.isNumber }
            if value != numbersOnly {
                value = numbersOnly
            }
        }
    }
}

struct IntegerTextField: View {
    @Binding var value: Int?
    @StateObject private var fieldValue = IntegerTextFieldValue()

    var placeholder = &quot;&quot;

    var body: some View {
        TextField(placeholder, text: $fieldValue.value)
            .keyboardType(.numberPad)
            .onAppear {
                if let value = value {
                    fieldValue.value = &quot;\(value)&quot;
                }
            }
    }
}
</code></pre>
","1455351","","","","","2021-01-04 02:05:28","Link @Binding to @Published with SwiftUI","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"65397556","1","65402086","","2020-12-21 17:45:39","","2","5295","<p>I have found ways of combining publishers using <code>MergeMany</code> or <code>CombineLatest</code>, but I don't seem to find a solution in my particular case.</p>
<p>Example:</p>
<pre><code>class Test {
    @Published var firstNameValid: Bool = false
    @Published var lastNameValid: Bool = false
    @Published var emailValid: Bool = false

    @Published var allValid: Bool = false
}
</code></pre>
<p>I want <code>allValid</code> to become <code>false</code> when any of the previous publishers are set to <code>false</code>, and <code>true</code> if all of them are <code>true</code>.
I also don't want to hardcode the list of publishers I am observing since I want a flexible solution, so I want to be able to pass an array of <code>Bool</code> publishers to whatever code I use to do this.</p>
<p>I tried this</p>
<pre><code>        let fieldPublishers = [$firstNameValid, $lastNameValid, $emailValid]
        Publishers
            .MergeMany(fieldPublishers)
            .sink { [weak self] values in
                self?.allValid = values.allSatisfy { $0 }
            }
            .store(in: &amp;subscribers)
</code></pre>
<p>But this of course doesn't work because I get an array of publishers and not an array of values. I tried some other ways (forgot which ones) but they only seemed to call <code>sink</code> if I assigned a value during execution to all 3 publishers.</p>
<p>In the case of only using 2 publishers I managed to get it working using <code>CombineLatest</code>.</p>
<p>So the question is: Can I have <code>sink</code> triggered when only one of the publishers in an array changes value after instantiation of <code>Test</code>, and then iterate over the values of all the publishers I am observing?</p>
","251824","","","","","2020-12-22 01:28:04","Swift Combine, how to combine publishers and sink when only one publisher's value changes?","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"65433180","1","65433349","","2020-12-24 02:13:52","","1","407","<p>I'm trying to take advantage of Combine's ability to <code>subscribe</code> to an upstream Publisher on a different queue but I'm finding that when I do, the upstream Publisher does not correctly get cancelled.</p>
<p>The documentation for <a href=""https://developer.apple.com/documentation/combine/publisher/subscribe(on:options:)"" rel=""nofollow noreferrer"">subscribe(on:options:)</a> makes the following reference:</p>
<blockquote>
<p>Using subscribe(on:options:) also causes the upstream publisher to
perform cancel() using the specified scheduler.</p>
</blockquote>
<p>It's not entirely clear to me what this statement implies. In the example code below, I have a basic type <code>NameIterator</code> that conforms to <code>Sequence</code> and <code>IteratorProtocol</code>. It's just simulating a custom iterator that might take a long time to fetch elements.</p>
<p>Combine adds a <code>.publisher</code> property to <code>Sequence</code>. If you subscribe to that publisher in a single thread, then any cancellation events are correctly propagated up to the root publisher and iteration stops.</p>
<p>However, if you call <code>subscribe(on:)</code>, then the cancellation event does not reach the root publisher until it has exhausted calls to the iterator. Note that <code>sink</code> is correctly called in both cases, but the iterator continues to get called even though no values are being pushed down the pipeline.</p>
<p>This causes a problem if the iterator is expensive and contains a large number of items, like traversing a filesystem. Is there a way to correctly cancel the upstream publisher? Or perhaps I'm incorrectly configuring the chain of Publishers.</p>
<p><strong>Sample Iterator:</strong></p>
<pre><code>struct NameIterator: Sequence, IteratorProtocol {

  private let names = [&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Charlie&quot;, &quot;Delta&quot;]
  private var index = 0

  mutating func next() -&gt; String? {
    guard index &lt; names.endIndex else {
      return nil
    }

    // Simulate an expensive iterator.
    sleep(1)
    
    defer { index = names.index(after: index) }
    print(&quot;NameIterator.next() called with \(names[index])&quot;)
    return names[index]
  }
}
</code></pre>
<p><strong>Correctly Cancelled:</strong></p>
<pre><code>let cancellable = NameIterator().publisher
  .first()
  .sink { print(&quot;Sink: \($0)&quot;) }

// Outputs:

NameIterator.next() called with Alpha
NameIterator.next() called with Beta
Sink: Alpha
</code></pre>
<p><strong>Incorrectly Cancelled:</strong></p>
<pre><code>let cancellable = NameIterator().publisher
  .subscribe(on: DispatchQueue(label: &quot;BackgroundQueue&quot;))
  .first()
  .sink { print(&quot;Sink: \($0)&quot;) }

// Outputs: 

NameIterator.next() called with Alpha
NameIterator.next() called with Beta
Sink: Alpha
NameIterator.next() called with Charlie  // This call was unexpected.
NameIterator.next() called with Delta    // This call was unexpected.   
</code></pre>
","48321","","48321","","2020-12-24 09:35:35","2020-12-24 09:35:35","Combine Publisher does not cancel when subscribed to on a background queue","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"65443391","1","65443413","","2020-12-24 21:31:57","","1","592","<p>I'm following along with the WWDC 2019 'Combine in Practice' video and I get the following error</p>
<pre><code>Cannot find 'CombineLatest' in scope
</code></pre>
<p>I did it in a playground made in Xcode 12</p>
<pre><code>import SwiftUI
import Combine

class Stuff {
    @Published var password: String = &quot;&quot;
    @Published var passwordAgain: String = &quot;&quot;

    var validatedPassword: AnyPublisher&lt;String?, Never&gt; {
        // wtf? &quot;Cannot find 'CombineLatest' in scope&quot;
        return CombineLatest($password, $passwordAgain) { password, passwordAgain in
            guard password == passwordAgain, password.count &gt; 8 else { return nil }
            return password
        }
        .map { $0 == &quot;password1&quot; ? nil : $0 }
        .eraseToAnyPublisher()
    }
}
</code></pre>
<p>Has the API changed since 2019? Because it seems that</p>
<pre><code>CombineLatest($password, $passwordAgain) -&gt; $password.combineLatest($passwordAgain) 
</code></pre>
<p>Is this true? Can anyone find any formal documentation on if it's true and why?</p>
","465446","","","","","2020-12-24 21:35:12","Cannot find 'CombineLatest' in scope","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"65456295","1","65456352","","2020-12-26 12:17:59","","1","35","<p>I want to establish a binding for an object in a collection so that I can pass it on downstream like a reference pointer. I want this to be a convenience function but I am having some trouble.</p>
<p>What constraint, if any, can I put on the following protocol 'Diskable' to eliminate the error I'm getting below?</p>
<pre><code>final class PropertiesData: ObservableObject, Diskable {
    
    @Published var fetchedItems: [Property] = []
        
    var location: URL {
        let file = try! LocalStorage.rootFolder.createFileIfNeeded(withName: &quot;properties.data&quot;)
        return file.url
    }
}

extension Diskable where T: Identifiable {
    
    func binding(for object: T) -&gt; Binding&lt;T&gt; {
        let index = fetchedItems.firstIndex(where: { $0.id == object.id } )!
        return $fetchedItems[index] // cannot find 'fetchedItems' in scope
    }
}

protocol Diskable: AnyObject {
    associatedtype T: Codable
    var location: URL { get }
    var fetchedItems: [T] { get set }
}
</code></pre>
","9400730","","","","","2020-12-26 12:25:37","Which is an appropriate protocol constraint to identify a property as being '@Published'","<swiftui><combine><protocol-extension>","1","0","","","","CC BY-SA 4.0"
"65466576","1","65466803","","2020-12-27 14:04:14","","0","382","<p>I have a function that takes a publisher parameterlike this</p>
<pre><code>func runPublisher(publisher: AnyPublisher&lt;Void, Error&gt;, shouldLoad: Bool = true) {

}
</code></pre>
<p>When I try to convert to publisher, I get this error</p>
<pre><code>let publisher = provider.check(credentials: cred)
            .eraseToAnyPublisher()
            .tryMap({ (data) in
            })
            .mapError({ (error) -&gt; Error in
                return error
            })
            .map { _ in

                return ()
            }

runPublisher(publisher: publisher)
</code></pre>
<p>I get the error</p>
<pre><code>Cannot convert value of type 'Publishers.Map&lt;Publishers.MapError&lt;Publishers.TryMap&lt;AnyPublisher&lt;BaseResponseData&lt;AuthResponse&gt;, MoyaError&gt;, ()&gt;, Error&gt;, ()&gt;' to expected argument type 'AnyPublisher&lt;Void, Error&gt;'
</code></pre>
","8310287","","","","","2020-12-27 15:53:06","map to AnyPublisher Void","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"65469679","1","65469932","","2020-12-27 19:33:17","","1","213","<p>trying to post a notification when ever the observable object changes.</p>
<p>this seems wrong. looking for a better way.</p>
<pre><code>class MyClass: ObservableObject {
    
    @Published var date: Date {
        didSet {
            NotificationCenter.default.post(name: .modified, object: self) // want to also post notifications for changes, not just publish to owners of the object
        }
    }
    @Published var a: Int {
        didSet {
            NotificationCenter.default.post(name: .modified, object: self)
        }
    }
    @Published var b: Int {
        didSet {
            NotificationCenter.default.post(name: .modified, object: self)
        }
    }
}
</code></pre>
","1532045","","","","","2020-12-27 20:02:36","How to post a notification when an observable object has changed","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"65503215","1","65503279","","2020-12-30 06:57:41","","1","630","<p>I have two functions which return <strong>AnyPublisher</strong> with different failure type: <strong>Never</strong> and <strong>Error</strong>. When using these functions in the <strong>CombineLates</strong>, then compilation fails with an error: <strong>Generic struct 'CombineLatest' requires the types 'Error' and 'Never' be equivalent</strong></p>
<h3>Function which never fails:</h3>
<pre><code>func foo() -&gt; AnyPublisher&lt;Int, Never&gt; {
    Result&lt;Int, Never&gt;
        .success(1).publisher
        .eraseToAnyPublisher()
}
</code></pre>
<h3>Function which sometimes fails:</h3>
<pre><code>func boo() -&gt; AnyPublisher&lt;Int, Error&gt; {
    Result&lt;Int, Error&gt;
        .failure(NSError(domain: &quot;d&quot;, code: -1))
        .publisher.eraseToAnyPublisher()
}
</code></pre>
<h3>foo &amp; boo functions usage:</h3>
<pre><code>Publishers.CombineLatest(foo(), boo())
</code></pre>
<h3>Error generated:</h3>
<pre><code>Generic struct 'CombineLatest' requires the types 'Error' and 'Never' be equivalent
</code></pre>
<p><strong>How to use CombineLates when publisher's failure types are not equivalent?</strong></p>
","1151916","","5133585","","2020-12-30 09:45:16","2020-12-30 13:59:47","How to use CombineLates when when publishers failure types is not equivalent?","<swift><combine>","2","2","2","","","CC BY-SA 4.0"
"65521039","1","65521484","","2020-12-31 12:39:02","","2","62","<p>I want to send empty text inside the <code>searchText</code> to <code>AuthorService()</code> if button value <code>.isCancel</code> is true. So that my author search result will be cleaned.</p>
<pre><code>import SwiftUI
import Combine

struct AuthorSearchBar: View {
        @StateObject var service = AuthorService()
        @Binding var isCancel: Bool
        @State var emptyText = &quot;&quot;
        var body: some View {
            VStack(spacing: 0) {
               HStack {
                Image(systemName: &quot;magnifyingglass&quot;)
                if isCancel == false{
                TextField(&quot;Search&quot;, text: $service.searchText)
                } else if isCancel {
                    TextField(&quot;Search&quot;, text: $service.searchText = &quot;&quot;) 
            //Cannot assign to property: '$service' is immutable
            //Cannot assign value of type 'String' to type 'Binding&lt;String&gt;'
            //Cannot convert value of type '()' to expected argument type 'Binding&lt;String&gt;'
                }
                .padding()
                .onReceive(Just( self.isCancel ? emptyText : service.searchText), perform: { _ in
                    service.fetchData()
                })
            }
        }
}
</code></pre>
<p>My service <code>fetchData()</code> gets searchText parameter as below.</p>
<p>so I want to send &quot;&quot; to fetchData if .isCancel is true.</p>
<pre><code>class AuthorService: ObservableObject {
@Published var searchText : String = &quot;&quot;
func fetchData() {
    let parameters = [&quot;index&quot;: &quot;authors&quot;, &quot;query&quot;: &quot;\(searchText)&quot; ]
</code></pre>
","8418174","","8418174","","2020-12-31 13:32:11","2020-12-31 13:39:59","Send emptyText to Service SwiftUI","<swiftui><uitextfield><combine>","1","1","","","","CC BY-SA 4.0"
"65533884","1","65536404","","2021-01-01 21:32:37","","1","120","<p>I'm new to SwiftUI and have been following along with @<a href=""https://stackoverflow.com/users/281221/peter-friese"">peter-friese</a>'s <a href=""https://youtu.be/4RUeW5rUcww"" rel=""nofollow noreferrer"">example SwiftUI/Firebase app</a>.</p>
<p>My example app works perfectly, but am now trying to modify slightly but am <strong>unable to get the correct keypath syntax of in the <code>assign/map</code> in order to set a property.</strong></p>
<p>Relevantly (and slightly simplified), there is a struct for the data model:</p>
<pre><code>struct Task: Codable, Identifiable {
  var title: String
  var status: Bool
  var flag: Bool
}
</code></pre>
<p>and a class for a view model:</p>
<pre><code>class TaskCellViewModel {
  @Published var task: Task
  var iconName:String = &quot;&quot; 
}
</code></pre>
<p>In this tutorial a <code>map/assign</code> is used within the <code>TaskCellViewModel</code> to set the value of the <code>iconName</code> property in the instance of the <code>TaskCellViewModel</code> as follows:</p>
<pre><code>private var cancellables = Set&lt;AnyCancellable&gt;()

init(task: Task) {
    self.task = task
$task
   .map { task in
            task.status ? &quot;checkmark.circle.fill&quot; : &quot;circle&quot;
        }
   .assign(to: \.iconName, on: self)
   .store(in: &amp;cancellables)
}
</code></pre>
<p>This works for setting the <code>iconName</code>. <strong>What is the correct syntax to set the <code>flag</code> property on the <code>Task</code> itself?</strong></p>
<p>I have tried various combinations but none work, including:</p>
<pre><code>.assign(to .\Task.task.flag, on: self)
.assign(to .\task.flag, on: self)
.assign(to .\Task.task.flag, on: TaskCellViewModel)
</code></pre>
<p>Using <code>Task.task.flag</code> it fails at runtime with <code>EXC_BAD_ACCESS</code> error or a type conversion compile error:</p>
<blockquote>
<p>Cannot convert value of type <code>AnswerRowViewModel.Type</code> to expected argument type <code>AnswerRowViewModel</code>.</p>
</blockquote>
<p>PS given I'm learning and trying to follow along with the tutorials, I'm hoping for a answer to the assign/map question - as opposed to a workaround/alternative.</p>
","7371966","","3585796","","2021-11-24 00:06:49","2021-11-24 00:06:49","Need keypath syntax for use in assign(to:_) in SwiftUI","<swift><swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"65541603","1","65544683","","2021-01-02 16:45:49","","0","531","<p>Below is my code to call api and it returns Swift.Error when the api call has error.</p>
<pre><code>AccountAPI.postAccount(withSignUpCommand: signUpCommand)
            .sink(receiveCompletion: { [weak self] result in
                guard let self = self else { return }

                switch result {
                    case .finished:
                        self.logger.debug(&quot;signUp completed.&quot;)
                    case .failure(let error):
                        self.isAuthenticating = false
                        self.logger.error(&quot;signUp error : \(error)&quot;)
                }
            }, receiveValue: { [weak self] (statusCode, userId) in
                guard let self = self else { return }

                self.logger.debug(&quot;signUp status code : \(statusCode)&quot;)

                guard (200...299).contains(statusCode) else {
                    return
                }

                self.logger.debug(&quot;UserId: \(userId)&quot;)
            })
            .store(in: &amp;disposables)
</code></pre>
<p>And my publisher here</p>
<pre><code>static func postAccount(
        withSignUpCommand signUpCommand: SignUpCommand,
        apiResponseQueue: DispatchQueue = CloudHospitalClientAPI.apiResponseQueue
    ) -&gt; AnyPublisher&lt;(Int, String), Error&gt; {
        let url = &quot;\(CloudHospitalClientAPI.identityBasePath)/api/v1/accounts&quot;

        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: signUpCommand)

        return Future&lt;(Int, String), Error&gt;.init { promise in
            postAccountWithRequestBuilder(withURLString: url, withParameters: parameters, isBody: true).execute(apiResponseQueue) { result -&gt; Void in
                switch result {
                    case let .success(response):
                        promise(.success((response.statusCode, response.body!)))
                    case let .failure(error):
                        promise(.failure(error))
                }
            }
        }
        .eraseToAnyPublisher()

    }

    static func postAccountWithRequestBuilder(
        withURLString URLString: String,
        withParameters parameters: [String: Any]?,
        isBody: Bool
    ) -&gt; RequestBuilder&lt;String&gt; {

        let url = URLComponents(string: URLString)
        let requestBuilder: RequestBuilder&lt;String&gt;.Type = CloudHospitalClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: &quot;POST&quot;, URLString: (url?.string ?? URLString), parameters: parameters, isBody: isBody)
    }
</code></pre>
<p>When debugging this, I get below result.
<a href=""https://i.stack.imgur.com/Er933.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Er933.png"" alt=""Debugging"" /></a></p>
<p>The api error response below format and I'd like to parse this Data but can't access to this value at all.
<a href=""https://i.stack.imgur.com/oV7IC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/oV7IC.png"" alt=""Error response from api(swagger)"" /></a></p>
<p>Tried to change the Return type to custom error response but had no luck.</p>
<p>Please share some advice where I can insert decoding error response code and return to caller function.</p>
<p>Thanks in advance.</p>
<p>Thanks to Bruno, below is my edited code.</p>
<pre><code>        AccountAPI.postAccount(withSignUpCommand: signUpCommand)
            .sink(receiveCompletion: { [weak self] result in
                guard let self = self else { return }

                switch result {
                    case .finished:
                        self.logger.debug(&quot;signUp completed.&quot;)
                    case .failure(let error):
                        self.isAuthenticating = false
                        self.logger.error(&quot;signUp error : \(error)&quot;)
                        if case let ErrorResponse.error(_, data, _) = error {
                            let decoder = JSONDecoder()
                            let identityErrors = try! decoder.decode([IdentityError].self, from: data!)

                            // TODO: Decode `data` here...
                            self.logger.debug(&quot;data: \(String(describing: identityErrors))&quot;)

                            self.errors = identityErrors
                        }
                }
            }, receiveValue: { [weak self] (statusCode, userId) in
                guard let self = self else { return }

                self.logger.debug(&quot;signUp status code : \(statusCode)&quot;)

                guard (200...299).contains(statusCode) else {
                    return
                }

                self.logger.debug(&quot;UserId: \(userId)&quot;)
            })
            .store(in: &amp;disposables)
</code></pre>
","4596095","","4596095","","2021-01-03 03:14:41","2021-01-03 03:14:41","How do I get Data value from Combine + Alamofire Error response?","<swift5><decoding><combine><openapi-generator>","1","0","","","","CC BY-SA 4.0"
"65554158","1","65554638","","2021-01-03 19:41:37","","0","1002","<p>Here's a simplified example of an approach I want to take, but I can't get the simple example to work.</p>
<p>I have a Combine publisher who's subject is a view model State:</p>
<pre><code>struct State {
    let a: Bool
    let b: Bool
    let transition: Transition?
}
</code></pre>
<p>The State includes a <code>transition</code> property. This describes the <code>Transition</code> that the <code>State</code> made in order to become the current state.</p>
<pre><code>enum Transition {
    case onAChange, onBChange
}
</code></pre>
<p>I want to use <code>transition</code> property to drive animations in a <code>View</code> subscribed to the publisher so that different transitions animate in specific ways.</p>
<h1>View code</h1>
<p>Here's the code for the view. You can see how it tries to use the <code>transition</code> to choose an animation to update with.</p>
<pre><code>struct TestView: View {
    
    let model: TestViewModel

    @State private var state: TestViewModel.State
    private var cancel: AnyCancellable?

    init(model: TestViewModel) {
        self.model = model
        self._state = State(initialValue: model.state.value)
        self.cancel = model.state.sink(receiveValue: updateState(state:))
    }
    
    var body: some View {
        VStack(spacing: 20) {
            Text(&quot;AAAAAAA&quot;).scaleEffect(state.a ? 2 : 1)
            Text(&quot;BBBBBBB&quot;).scaleEffect(state.b ? 2 : 1)
        }
        .onTapGesture {
            model.invert()
        }
    }
    
    private func updateState(state: TestViewModel.State) {
        withAnimation(animation(for: state.transition)) {
            self.state = state
        }
    }

    private func animation(for transition: TestViewModel.Transition?) -&gt; Animation? {
        guard let transition = transition else { return nil }

        switch transition {
        case .onAChange: return .easeInOut(duration: 1)
        case .onBChange: return .easeInOut(duration: 2)
        }
    }
}

struct TestView_Previews: PreviewProvider {
    static var previews: some View {
        TestView(model: TestViewModel())
    }
}
</code></pre>
<h1>Model code</h1>
<pre><code>final class TestViewModel: ObservableObject {
    
    var state = CurrentValueSubject&lt;State, Never&gt;(State(a: false, b: false, transition: nil))
    
    struct State {
        let a: Bool
        let b: Bool
        let transition: Transition?
    }
    
    enum Transition {
        case onAChange, onBChange
    }

    func invert() {
        let oldState = state.value
        setState(newState: .init(a: !oldState.a, b: oldState.b, transition: .onAChange))
        setState(newState: .init(a: !oldState.a, b: !oldState.b, transition: .onBChange))
    }
    
    private func setState(newState: State) {
        state.value = newState
    }
}
</code></pre>
<p>You can see in the model code that when <code>invert()</code> is called, <em>two</em> state changes occur. The model first toggles <code>a</code> using the <code>.onAChange</code> transition, and then toggles <code>b</code> using the <code>.onBChange</code> transition.</p>
<h1>What should happen</h1>
<p>What should happen when this is run is that each time the view is clicked, the text &quot;AAAAAAA&quot; and &quot;BBBBBBB&quot; should toggle size. However, the &quot;AAAAAAA&quot; text should change quickly (1 second) and the &quot;BBBBBBB&quot; text should change slowly (2 seconds).</p>
<h1>What actually happens</h1>
<p>However, when I run this and click on the view, the view doesn't update at all.</p>
<p>I can see from the debugger that <code>onTapGesture { … }</code> is called and <code>invert()</code> is being called on the model. Also <code>updateState(state:)</code> is also being called. However, <code>TestView</code> is not changing on screen, and <code>body</code> is not invoked again.</p>
<h1>Other things I tried</h1>
<h2>Using a callback</h2>
<p>Instead of using a publisher to send the event to the view, I've tried a callback function in the model set to the view's <code>updateState(state:)</code> function. I assigned to this in the <code>init</code> of the view with <code>model.handleUpdate = self.update(state:)</code>. Again, this did not work. The function <code>invert()</code> and <code>update(state:)</code> were called, as expected, but the view didn't actually change.</p>
<h2>Using <code>@ObservedObject</code></h2>
<p>I change the model to be <code>ObservableObject</code> with its <code>state</code> being <code>@Published</code>. I set up the view to have an <code>@ObservedOject</code> for the model. With this, the view <em>does</em> update, but it updates both pieces of text using the same animation, which I don't want. It seems that the two state updates are squashed and it only sees the last one, and uses the <code>transition</code> from that.</p>
<h1>Something that did work – sort of</h1>
<p>Finally, I tried to directly copy the model's <code>invert()</code> function in to the view's <code>onTapGesture</code> handler, so that the view updates its own state directly. This did work! Which is  something, but I don't want to put all by model update logic in my view.</p>
<h1>Question</h1>
<p>How can I have a SwiftUI view subscribe to <em>all</em> states that a model sends through its publisher so that it can use a <code>transition</code> property in the state to control the animation used for that state change?</p>
","2547229","","2547229","","2021-01-04 03:39:59","2021-01-04 03:39:59","Subscribe SwiftUI View to every update of a combine publisher","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"65558967","1","65559015","","2021-01-04 07:17:03","","1","258","<p>I'm new to SwiftUI, and was wondering if someone could help me make my app work. Also I'm trying to get my head around MVVM, and was wondering if I was doing it correctly.</p>
<p>The app makes a call to <a href=""https://jsonplaceholder.typicode.com/users"" rel=""nofollow noreferrer"">https://jsonplaceholder.typicode.com/users</a> and I'm trying to generate user cards based on the json response.</p>
<p><strong>Model:</strong></p>
<pre><code>import Foundation

// MARK: - User
class User: Codable {
    
    
    let id: Int
    let name, username, email: String
    let address: Address
    let phone, website: String
    let company: Company

    init(id: Int, name: String, username: String, email: String, address: Address, phone: String, website: String, company: Company) {
        self.id = id
        self.name = name
        self.username = username
        self.email = email
        self.address = address
        self.phone = phone
        self.website = website
        self.company = company
    }
}

// MARK: - Address
class Address: Codable {
    let street, suite, city, zipcode: String
    let geo: Geo

    init(street: String, suite: String, city: String, zipcode: String, geo: Geo) {
        self.street = street
        self.suite = suite
        self.city = city
        self.zipcode = zipcode
        self.geo = geo
    }
}

// MARK: - Geo
class Geo: Codable {
    let lat, lng: String

    init(lat: String, lng: String) {
        self.lat = lat
        self.lng = lng
    }
}

// MARK: - Company
class Company: Codable {
    let name, catchPhrase, bs: String

    init(name: String, catchPhrase: String, bs: String) {
        self.name = name
        self.catchPhrase = catchPhrase
        self.bs = bs
    }
}

typealias Users = [User]
</code></pre>
<p><strong>View:</strong></p>
<pre><code>import SwiftUI

struct UserView: View {
    let user: User
    
    var body: some View {
        VStack {
            Text(user.name)
                .font(.title)
                .fontWeight(.bold)
            Text(user.email)
                .font(.callout)
                .foregroundColor(.gray)
                .textCase(.uppercase)
        }
        .frame(width: 300, height: 200, alignment: .center)
        .background(Color.yellow)
        .cornerRadius(10.0)
    }
}
</code></pre>
<p><strong>ViewModel:</strong></p>
<pre><code>
import SwiftUI

class UserViewModel: ObservableObject {
    @Published var users: Users = []
    
    init() {
        fetchUsers()
    }
    
    func fetchUsers() {
        guard let url = URL(string: &quot;https://jsonplaceholder.typicode.com/users&quot;) else { print(&quot;Invalid url&quot;)
            return
        }
        
        let task = URLSession.shared.dataTask(with: url) { data, response, error in
            guard let data = data else {
                print(&quot;There was an error: \(String(describing: error?.localizedDescription))&quot;)
                return
            }
            
            do {
                let userData = try JSONDecoder().decode(Users.self, from: data)
                print(&quot;success: \(userData.capacity)&quot;)
            } catch let parsingError {
                print(&quot;There was an error: \(parsingError.localizedDescription)&quot;)
            }
        }
        
        task.resume()
        
    }
}
</code></pre>
<p>And I want to display it in a <strong>UserContainerView:</strong></p>
<pre><code>struct UserContainer: View {
    let uservm = UserViewModel()
    
    var body: some View {
        VStack {
            Button(action: uservm.fetchUsers, label: {
                Text(&quot;Fetch some users boy&quot;)
            })
            
            ForEach(uservm.users, id: \.id, content: { user in
                UserView(user: user)
            })
            
            Spacer()
        }
        
        
    }
}
</code></pre>
<p><strong>My problem is</strong> not a single UserView is displayed, because the array of Users passed to UserView is empty. Can someone tell me what am I doing wrong? I don't have a solid grasp on this. Thanks.</p>
","11914725","","","","","2021-01-04 11:23:56","Generating views from API call - SwiftUI","<swift><swiftui><combine><swiftui-state>","2","0","","","","CC BY-SA 4.0"
"65592624","1","65592730","","2021-01-06 08:41:48","","0","214","<p>Below there are three functions. The first one is the function that I need to refactor. Basically what I'm hoping for is something similar what can be achieved using Promise Kit but in this case using Swifts combine framework.</p>
<p>The second function <code>loginWithFacebook()</code> returns a <code>AuthCredential</code>.
This <code>AuthCredential</code> needs to be passed on to the last functions which returns a type <code>Future&lt;UserProfileCompact, Error&gt;</code> which is a similar return type to the main function (1st function).</p>
<p>My question is is there a way to achieve this in a Swifty way, similar to Promise Kit doing this operation:<code> return loginWithFacebook().then {loginWithFirebase(:_)}</code></p>
<pre><code>    // Call site is a View Model 
    // Main Function that needs to be refactored
    func loginwithFacebook() -&gt; Future&lt;UserProfileCompact, Error&gt; {
        //This returs a Future Firebase Credential
        loginWithFacebook()
        //The above credential needs to be passed to this method and this returns a type Future&lt;UserProfileCompact, Error&gt; 
        loginWithFirebase(&lt;#T##credentials: AuthCredential##AuthCredential#&gt;)
    }
    
    private func loginWithFacebook() -&gt; Future&lt;AuthCredential,Error&gt; {
        return Future { [weak self] promise in
            self?.loginManager.logIn(permissions: [&quot;public_profile&quot;,&quot;email&quot;], from: UIViewController()) { (loginResult, error) in
                if let error = error {
                    promise(.failure(error))
                } else if loginResult?.isCancelled ?? false {
                    //fatalError()
                }
                else if let authToken = loginResult?.token?.tokenString {
                    let credentials = FacebookAuthProvider.credential(withAccessToken: authToken)
                    
                    promise(.success(credentials))
                }
                else{
                    fatalError()
                }
            }
        }
    }
    
    private func loginWithFirebase(_ credentials: AuthCredential) -&gt; Future&lt;UserProfileCompact, Error&gt; {
        return Future { promise in
            Auth.auth().signIn(with: credentials) { (result, error) in
                if let error = error {
                    //Crashlytics.crashlytics().record(error: error)
                    promise(.failure(error))
                }
                else if let user = result?.user {
                    //Crashlytics.crashlytics().setUserID(user.uid)
                    let profile = UserProfileCompactMapper.map(firebaseUser: user)
                    promise(.success(profile))
                }
                else {
                    fatalError()
                }
            }
        }
    }
</code></pre>
","5201157","","","","","2021-01-06 08:51:01","Chaining calls when using Future in Swift similar to PromiseKit","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"65604302","1","65608413","","2021-01-06 22:44:57","","2","629","<p>I'm using the timeout operator in Combine, and my understanding was that it would timeout only if a publisher does not publish an event, but it seems to timeout even if a value is published.</p>
<p>From the <a href=""https://developer.apple.com/documentation/combine/fail/timeout(_:scheduler:options:customerror:)"" rel=""nofollow noreferrer"">docs</a></p>
<blockquote>
<p>A publisher that terminates if the specified interval elapses with no events received from the upstream publisher.</p>
</blockquote>
<pre class=""lang-swift prettyprint-override""><code>import PlaygroundSupport
import Combine
import Foundation

PlaygroundPage.current.needsIndefiniteExecution = true

let subject = PassthroughSubject&lt;String, Never&gt;()
let cancellable = subject
    .timeout(.seconds(5), scheduler: DispatchQueue.main)
    .sink(
          receiveCompletion: { print (&quot;completion: \($0) at \(Date())&quot;) },
          receiveValue: { print (&quot;value: \($0) at \(Date())&quot;) }
     )

subject.send(&quot;Sending data&quot;)

/*
Prints
value: Sending data at 2021-01-06 22:41:12 +0000
completion: finished at 2021-01-06 22:41:17 +0000
*/
</code></pre>
<p>Is my understanding wrong with the operator?.</p>
","723056","","","","","2021-01-07 07:47:53","timeout operator in Combine times out even after an event is published","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"65626760","1","65682054","","2021-01-08 09:52:15","","1","198","<p>I am trying to merge two publishers but one of the completions are never run.<br/>
The following is how I create my two publishers and try to use <code>.sink</code> to observe when they complete. The <code>featureFlagPublisher</code> will finish as expected and print &quot;featureFlagPublisher done&quot;, but the <code>migratePublisher</code> and the merged publishers will never complete.<code>publisher.send(completion: .finished)</code> is run but nothing happens.</p>
<pre><code>private var cancellables = Set&lt;AnyCancellable&gt;()

func start() {
    let featureFlagPublisher = self.startFeatureFlagging()
    let migratePublisher = self.migrate()
    
    migratePublisher.sink { _ in
        print(&quot;migratePublisher done&quot;)
    } receiveValue: { _ in }.store(in: &amp;cancellables)

    featureFlagPublisher.sink { _ in
        print(&quot;featureFlagPublisher done&quot;)
    } receiveValue: { _ in }.store(in: &amp;cancellables)
    
    migratePublisher.merge(with: featureFlagPublisher)
        .sink { completion in
            print(&quot;All Done&quot;)
        } receiveValue: { _ in }
        .store(in: &amp;cancellables)
}

private func startFeatureFlagging() -&gt; AnyPublisher&lt;Bool, Never&gt; {
    let future = Future&lt;Bool, Never&gt; { promise in
        FeatureFlaggingService.shared.start {
            promise(.success(true))
        }
    }
    return future.eraseToAnyPublisher()
}


private func migrate() -&gt; AnyPublisher&lt;Bool, Never&gt;  {
    let future = Future&lt;Bool, Never&gt; { promise in 
        FavoriteMigrationsAPI.shared.get { result in
            switch result {
                case .success(let favoriteIDs):
                    promise(.success(true))
            ...
        }
    }

    return future.eraseToAnyPublisher()
}
</code></pre>
","2501509","","2501509","","2021-01-08 10:41:30","2021-01-18 07:41:00","Publisher sink never runs completion","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"65636907","1","65741413","","2021-01-08 21:52:49","","0","481","<p>I am working on a project that is using Combine to get updates from Firebase Firestore. I have a StockListView, a StockListCellView, and a StockDetailView that I want updates to be registered in.</p>
<p>The StockListView holds StockListCellViews which push StockDetailsViews onto the stack.  Each view also has a corresponding ViewModel where I am working with Combine.</p>
<p>My trouble is my StockDetailView is not receiving the updates from Combine and I can't see why. Below is a simplified version of the code for each view and viewModel. I think this has something to do with how I am assigning in the StockDetailViewModel but I can't figure it out. Any help would be appreciated.</p>
<p><strong>StockListViewModel - Works Great</strong></p>
<pre><code>class StockListViewModel: ObservableObject {
    @Published var stockRepository = StockRepository()
    @Published var stockListCellViewModels = [StockListCellViewModel]()

    private var cancellables = Set&lt;AnyCancellable&gt;()

    init() {
        stockRepository.$stocks.map { stocks in
            stocks.map { stock in
                StockListCellViewModel(stockDetailViewModel: StockDetailViewModel(stock: stock))
            }
        }
        .assign(to: \.stockListCellViewModels, on: self)
        .store(in: &amp;cancellables)
    }
}
</code></pre>
<p><strong>StockListView - Works Great</strong></p>
<pre><code>struct StockListView: View {
    @ObservedObject var stockRepository = StockRepository()
    @ObservedObject var stockListVM = StockListViewModel()
        
    var body: some View {
       NavigationView {
                List {
                    ForEach(stockListVM.stockListCellViewModels) { stockListCellVM in
                            NavigationLink(destination: StockDetailView(stockDetailVM: stockListCellVM.stockDetailViewModel)) {
                                StockListCell(stockListVM: stockListVM, stockListCellVM: stockListCellVM)
                            }
                    }
                } // List
                .listStyle(PlainListStyle())
            .navigationBarTitle(&quot;stock&quot;)
        } // NavigationView
    } // View
}
</code></pre>
<p><strong>StockListCellViewModel - Works Great</strong></p>
<pre><code>class StockListCellViewModel: ObservableObject, Identifiable {
    var id: String = &quot;&quot;
    @Published var stockDetailViewModel: StockDetailViewModel
    @Published var stock: Stock

    private var cancellables = Set&lt;AnyCancellable&gt;()

    init(stockDetailViewModel: StockDetailViewModel) {
        self.stockDetailViewModel = stockDetailViewModel
        self.stock = stockDetailViewModel.stock

        stockDetailViewModel.$stock.compactMap { stock in
            stock.id
        }
        .assign(to: \.id, on: self)
        .store(in: &amp;cancellables)

        stockDetailViewModel.$stock.map { stock in
            StockDetailViewModel(stock: stock)
        }
        .assign(to: \.stockDetailViewModel, on: self)
        .store(in: &amp;cancellables)
    }
}
</code></pre>
<p><strong>StockListCellView - Works Great</strong></p>
<pre><code>struct StockListCell: View {
    @ObservedObject var stockListVM: StockListViewModel
    @ObservedObject var stockListCellVM: StockListCellViewModel

    var body: some View {
                Text(stockListCellVM.stock.ticker)
    }
}
</code></pre>
<p><strong>StockDetailViewModel - Not Updating</strong></p>
<pre><code>class StockDetailViewModel: ObservableObject, Identifiable {
    var id: String = &quot;&quot;
    @Published var stock: Stock
    
    private var cancellables = Set&lt;AnyCancellable&gt;()

    init(stock: Stock) {
        self.stock = stock
        self.chartColor = UIColor()

        $stock.compactMap { stock in
            stock.id
        }
        .assign(to: \.id, on: self)
        .store(in: &amp;cancellables)
}
</code></pre>
<p><strong>StockDetailView - Not Updating</strong></p>
<pre><code>struct StockDetailView: View {
    @ObservedObject var stockDetailVM: StockDetailViewModel

    var body: some View {
                    Text(stockDetailVM.stock.ticker)
    }
}
</code></pre>
","4441627","","988260","","2021-01-09 05:55:16","2021-01-15 18:09:01","Swift Combine Not Receiving Published Values","<swift><swiftui><combine>","1","9","","","","CC BY-SA 4.0"
"65649090","1","65696363","","2021-01-10 00:38:27","","0","806","<p>this question is straight forward :</p>
<p>My code :</p>
<pre><code>        return urlSession.dataTaskPublisher(for: urlRequest)
        .tryMap { (data: Data, response: URLResponse) -&gt; Data in
            //TODO: hide loader
            GRP.hideLoader()
            if let httpURLResponse = response as? HTTPURLResponse {
                if !(200...299 ~= httpURLResponse.statusCode) {
                    var error = NetworkingError(errorCode: httpURLResponse.statusCode)
                    if let json = try? JSONSerialization.jsonObject(with: data, options: []) {
                        error.jsonPayload = json
                    }
                    throw error
                }
            }
            
            if withErrorMessage, let errorCheckModel = try? JSONDecoder().decode(ErrorModel.self, from: data)
            {
                if let statusIsSuccess = errorCheckModel.success, let errorMessage = errorCheckModel.message, !errorMessage.isEmpty
                {
                    if(!statusIsSuccess)
                    {
                        print(urlString)
                        GRP.showToast(failure: true, message: errorMessage)
                    }
                }
            }

            
            return data
        }.mapError { error -&gt; NetworkingError in
            return NetworkingError(error: error)
        }
        .decode(type: T.self, decoder: decoder)
        .receive(on: RunLoop.main)
        .eraseToAnyPublisher()
}
</code></pre>
<p>i made this task buikder but i am stuck, i want to know how can i implement refresh token i. Thank you.</p>
","11650653","","","","","2021-01-13 05:53:28","refresh token using combine networking ios","<ios><swift><swiftui><combine><refresh-token>","1","0","2","","","CC BY-SA 4.0"
"65683739","1","65684078","","2021-01-12 12:13:03","","1","591","<p>My project is creating an ordering app, and in this screen about the menu detail, there are menu variants which users can choose / add-on, I need to iterate an array of [MenuDetailVariantGroup] and I need to get the index of the array, how do I do this? While in the for loop I also need to append a variable into a @Published var variantChosen, however if I do self.viewModel.variantChosen.append(1), it always returns an error. Below is my codes:</p>
<p>MenuDetailData.swift</p>
<pre><code>struct MenuDetailData: Codable, Identifiable {
    let id = UUID()
    let idMenu: String
    let menuName: String
    let variantGroup: [MenuDetailVariantGroup]
}
</code></pre>
<p>MenuDetailVariantGroup.swift</p>
<pre><code>struct MenuDetailVariantGroup: Codable, Identifiable, Hashable {
    let id = UUID()
    let variantGroupName: String
    let variant: [MenuDetailVariant]
    let limit: Int
}
</code></pre>
<p>MenuDetailVariant.swift</p>
<pre><code>struct MenuDetailVariant: Codable, Identifiable, Hashable {
    let id = UUID()
    let variantName: String
}
</code></pre>
<p>MenuDetailViewModel.swift</p>
<pre><code>class MenuDetailViewModel: ObservableObject, MenuDetailService {
    var apiSession: APIService
    @Published var detaildata: MenuDetailData?
    @Published var variantGroup = [MenuDetailVariantGroup]()
    @Published var variantChosen: Array&lt;Int&gt; = []
    
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(apiSession: APIService = APISession()) {
        self.apiSession = apiSession
    }
    
    func getMenuDetail() {
        let cancellable = self.getMenuDetail()
            .sink(receiveCompletion: { result in
                switch result {
                case .failure(let error):
                    print(&quot;Handle error: \(error)&quot;)
                case .finished:
                    break
                }
                
            }) { (detail) in
                self.detaildata = detail.data
                self.variantGroup = detail.data.variantGroup
        }
        cancellables.insert(cancellable)
    }
    
}
</code></pre>
<p>MenuDetailView</p>
<pre><code>struct MenuDetailView: View {
    @ObservedObject var viewModel = MenuDetailViewModel()
    
    var body: some View {
        ForEach(self.viewModel.variantGroup, id: \.self) { vg in
                /*** I Need to get the index of each iteration here, how? ***/
                VStack {
                    HStack {
                        Text(vg.variantGroupName)
                        Text(String(self.viewModel.arrVariantChoosen[0]))
                    }
                    VStack {
                        ForEach(vg.variant, id: \.self) { v in
                            Text(v.variantName)
                        }
                    }
                }
                // I also need to append Int to @Published var variantChosen
                self.viewModel.variantChosen.append(1)
                // This always return error:
                // Type '()' cannot conform to 'View'; only struct/enum/class types can conform to protocols
            }
        }
    }
}
</code></pre>
<p>This is the codes that I have tried so far but failed and return empty</p>
<pre><code>// This returns blank
ForEach(0..&lt;self.viewModel.variantGroup.count) { i in
    Text(&quot;\(self.viewModel.variantGroup[i].variantGroupName)&quot;)
}

// This too returns blank
ForEach(self.viewModel.variantGroup.indices) { i in
    Text(&quot;\(self.viewModel.variantGroup[i].variantGroupName)&quot;)
}
</code></pre>
<p>Thank you all in advance</p>
","4608714","","8697793","","2021-01-12 18:10:58","2021-01-12 18:10:58","SwiftUI MVVM how to iterate and get index of array","<arrays><swift><swiftui><swiftui-list>","1","3","2","","","CC BY-SA 4.0"
"65691867","1","65722102","","2021-01-12 20:51:47","","2","366","<p>I am new to Combine and Sink, however the prints that I put in them do not seem to log however the result of the action completes as the user is created within AWS Amplify.</p>
<pre><code>@objc private func createAccountButtonAction(sender: UIButton) {
    print(&quot;Create Account Button Action&quot;)
    signUp(password: self.password, email: self.email)
  }
  
  func signUp(password: String, email: String) -&gt; AnyCancellable {
      let userAttributes = [AuthUserAttribute(.email, value: email)]
      let options = AuthSignUpRequest.Options(userAttributes: userAttributes)
      let sink = Amplify.Auth.signUp(username: email, password: password, options: options)
        .resultPublisher.sink(receiveCompletion: { (authError) in
          print(&quot;Failed with error: \(authError)&quot;)
        }, receiveValue: { (signUpResult) in
          print(&quot;Signed Up&quot;)
        })
    return sink
  }
</code></pre>
","5034263","","8387516","","2021-01-13 20:51:12","2021-01-14 15:40:58","Combine .sink print doesn't print","<swift><aws-amplify><combine>","1","4","","","","CC BY-SA 4.0"
"65719548","1","65719977","","2021-01-14 13:06:31","","0","219","<p>I am at the beginning phases of understanding Combine and to my surprise I actually got this simple model to work. In the model I simply pass data the .receive publisher in the init using .receive. What I'm wondering is:</p>
<ol>
<li>Is there a better way to implement this functionality</li>
<li>None of it worked until I added .store() and passed in a Set = []. which to my understanding is a way to cancel the stream of data. But although it is just to cancel to stream, the stream also will not work without it. Wondering if my understanding of that is correct and if there is a better to way to implement the cancellable.</li>
</ol>
<p><img src=""https://atenivel.sirv.com/Screen%2BRecording%2B2021-01-14%2Bat%2B07.52.40%2BAM.mp4"" alt=""Text"" /></p>
<pre><code>    import SwiftUI
import Combine

struct ContentView: View {
    @ObservedObject var viewModel = SimpleViewModel()
    @State private var changer = &quot;&quot;
    
    var body: some View {
        VStack {
            TextField(&quot;ENTER TEXT TO PASS&quot;, text: $changer)
                .padding()
                .textFieldStyle(RoundedBorderTextFieldStyle())
            HStack(alignment: .top) {
                Button(action: {
                    viewModel.changer = self.changer
                }){
                    Text(&quot;Change&quot;)
                        .fontWeight(.bold)
                        .padding()
                        .foregroundColor(.white)
                        .background(Color.blue)
                        .cornerRadius(10)
                }
                VStack {
                    Button(action: {}){
                        Text(&quot;Receive&quot;)
                            .fontWeight(.bold)
                            .padding()
                            .foregroundColor(.white)
                            .background(Color.green)
                            .cornerRadius(10)
                    }
                    Group {
                        Text(viewModel.firstValue).bold()
                        Text(viewModel.secondValue).bold()
                        Text(viewModel.thirdValue).bold()
                    }.padding(.vertical)
                }

            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

    final class SimpleViewModel: ObservableObject {
    @Published var changer = &quot;&quot;
    @Published var firstValue = &quot;Value #1&quot;
    @Published var secondValue = &quot;Value #2&quot;
    @Published var thirdValue = &quot;Value #3&quot;
    
    private var cancellableSet: Set&lt;AnyCancellable&gt; = []
    
    init() {
       $changer
        .receive(on: RunLoop.main)
        .assign(to: \.firstValue, on: self)
        .store(in: &amp;cancellableSet)
    }

}
                             
</code></pre>
","14346703","","752890","","2021-01-14 20:21:20","2021-01-14 20:21:20","Is there a better way to assign data using Combine","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"65723991","1","65725108","","2021-01-14 17:31:59","","0","120","<p>My App calculate for divers some important Values like max. depth etc in meter or in feet. When the User change the Slider in Metric and switch the picker to Imperial the Slider should automatically display the correctly converted result in feet.
For example: The picker is set to metric. The user changes the value to 60m MOD. Now the user changes to Imperial and the slider should automatically be on 197 (rounded up) (60 * 3.281 = 196.85). The same should happen from imperial to metric.</p>
<p>I wrote the following simple function:</p>
<pre><code>    import Foundation

func autoUpdateMeterToFeet(meter: Double) -&gt; Float {
    return ceil(Float(meter * 3.281))
}
</code></pre>
<p>The Code from the Slider:</p>
<pre><code>    import SwiftUI
    import Combine


struct ContentView: View {
    @State var unitSelection = UserDefaults.standard.integer(forKey: &quot;Picker&quot;)
   
    @State var value_meter_initialized = 40.0
    
    @State var value_feet_initialized = 100.0

    var body: some View {
        VStack {
            HStack (alignment: .top) {
                Spacer()
                Picker(&quot;&quot;, selection: $unitSelection) {
                    Text(&quot;Metric&quot;).tag(0)
                    Text(&quot;Imperial&quot;).tag(1)
                }
                .pickerStyle(SegmentedPickerStyle()).padding(.horizontal, 89)
                .onReceive(Just(unitSelection)) {
                UserDefaults.standard.set($0, forKey: &quot;Picker&quot;)
                }
                Spacer()
            }
            HStack {
                if unitSelection == 0 {
                    ValueMOD2(value_meter: $value_meter_initialized)
                } else {
                    ValueMODft2(value_feet: $value_feet_initialized, value_meter: $value_meter_initialized)
                }
            }
        }
    }
}

struct ValueMOD2: View {
    @Binding var value_meter: Double
    
    var body: some View {
        VStack {
            HStack {
                Text(&quot; &quot;)
                Slider(value: $value_meter, in: 3...60, step: 1)
                Text(&quot; &quot;)
            }
            HStack {
                Text(&quot;\(value_meter, specifier: &quot;%.0f&quot;)m&quot;)
                Text(&quot;MOD&quot;)
            }
        }
    }
}

struct ValueMODft2: View {
    @Binding var value_feet: Double
    @Binding var value_meter: Double
    
    var body: some View {
        VStack {
            HStack {
                Text(&quot; &quot;)
                Slider(value: $value_feet, in: 0...180, step: 10)
                Text(&quot; &quot;)
            }
            HStack {
                Text(&quot;\(value_feet, specifier: &quot;%.0f&quot;)ft.&quot;)
                Text(&quot;MOD&quot;)
                
                Text(&quot;\(autoUpdateMeterToFeet(meter: value_meter), specifier: &quot;%.0f&quot;)&quot;)

            }
        }
    }
}
</code></pre>
<p>But When I replace <strong>$value_feet</strong> in <em>ValueMODft</em> to <strong>autoUpdateMeterToFeet(meter: value_meter)</strong> comes the following error: &quot;Cannot convert value of type 'Float' to expected argument type 'Binding'&quot; What do I have to change?</p>
","14270161","","14270161","","2021-01-14 17:49:59","2021-01-14 18:45:21","SwiftUI: How can I insert a function in a slider","<swift><swiftui>","1","2","","","","CC BY-SA 4.0"
"65744503","1","65744543","","2021-01-15 22:43:53","","1","86","<p>I have two blocks of code, both similar.</p>
<p>One works in playground and performs as expected.</p>
<p>The other, when I make it part of a function (in an Xcode proj) does not work, and a very telltale warning from Xcode is that the 'immutable value of cancellableSink was never used'</p>
<p>I do not get that warning from Xcode when I execute this code in playgrounds. What is going on?</p>
<p>I have a feeling that my problem is not with Combine but something more fundamental</p>
<pre><code>import Foundation
import Combine


let url = URL(string: &quot;https://xkcd.com/614/info.0.json&quot;)



let publisher = URLSession.shared.dataTaskPublisher(for: url!)
    .map{ $0.data }
    .decode(type: Joke.self, decoder: JSONDecoder())
    .map { $0.img}

let cancellableSink = publisher
    .sink(receiveCompletion: { completion in
        print(String(describing: completion))
    }, receiveValue: { value in
        print(&quot;Returned value: \(value)&quot;)
    })
</code></pre>
<p><strong>The code snippet above will work in playground</strong> .. but why wouldn't this work in a Xcode proj inside of a function.</p>
<p>Below is a warning that I will get in a Xcode proj that I cannot repeat in playgrounds</p>
<p><img src=""https://atenivel.sirv.com/Screen%20Shot%202021-01-15%20at%205.16.01%20PM.png"" alt=""Text"" /></p>
","14346703","","8697793","","2021-01-15 22:49:27","2021-01-15 22:49:27","Combine snippet not working in function, how do I get this to work","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"65747222","1","65747301","","2021-01-16 07:00:22","","0","372","<p>In my Combine pipeline, I'm trying to prevent the upstream from terminating by using <code>flatMap</code> to catch the error outside of the original publisher:</p>
<pre><code>PlaygroundPage.current.needsIndefiniteExecution = true

let cancellable = Timer.publish(every: 1, on: .main, in: .default)
    .autoconnect()
    .flatMap { _ in
        Timer.publish(every: 1, on: .main, in: .default)
            .autoconnect()
            .tryMap { value throws -&gt; String? in
                return &quot;\(Date())&quot;
            }
            .catch { _ in
                Just(nil)
            }
            .filter { $0 != nil }
    }
    .sink { _ in
        print(&quot;complete&quot;)
        PlaygroundPage.current.finishExecution()
    } receiveValue: {
        print(&quot;sink: \(String(describing: $0))&quot;)
    }
</code></pre>
<p>Although this never terminates the upstream publisher when an error is replaced with a <code>nil</code>, it's duplicating every upstream event for some reason. The above code will result as:</p>
<pre><code>sink: Optional(&quot;2021-01-16 06:49:58 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:49:59 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:49:59 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:00 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:00 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:00 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:01 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:01 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:01 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:01 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:02 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:02 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:02 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:02 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:02 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
</code></pre>
<p>On the first event, output is just once. Second upstream event, it's twice. Third upstream result in three outputs and so on.</p>
<p>It seems like <code>flatMap</code> creates a new publisher every upstream event and stays alive. How do I cancel the previous flatMaps and always get one value, or is there a better way to do this? I don't want past upstream events to stay alive, I only care of the one value not old ones. I'd want to end up with something like:</p>
<pre><code>sink: Optional(&quot;2021-01-16 06:49:58 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:49:59 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:00 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:01 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:02 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
</code></pre>
","235334","","","","","2021-01-16 07:14:23","Combine FlatMap duplicates for every new successful upstream","<swift><combine>","1","4","","","","CC BY-SA 4.0"
"65779662","1","65780031","","2021-01-18 17:53:05","","2","916","<p>I've tried creating my own <code>ProgressView</code> to support iOS 13, but for some reason it appears to not work. I've tried <code>@State</code>, <code>@Binding</code> and the plain <code>var progress: Progress</code>, but it doesn't update at all.</p>
<pre class=""lang-swift prettyprint-override""><code>struct ProgressBar: View {
    @Binding var progress: Progress

    var body: some View {
        VStack(alignment: .leading) {
            Text(&quot;\(Int(progress.fractionCompleted))% completed&quot;)
            ZStack {
                RoundedRectangle(cornerRadius: 2)
                    .foregroundColor(Color(UIColor.systemGray5))
                    .frame(height: 4)
                GeometryReader { metrics in
                    RoundedRectangle(cornerRadius: 2)
                        .foregroundColor(.blue)
                        .frame(width: metrics.size.width * CGFloat(progress.fractionCompleted))
                }
            }.frame(height: 4)
            Text(&quot;\(progress.completedUnitCount) of \(progress.totalUnitCount)&quot;)
                .font(.footnote)
                .foregroundColor(.gray)
        }
    }
}
</code></pre>
<p>In my content view I added both the iOS 14 variant and the iOS 13 supporting one. They look the same, but the iOS 13 variant does not change anything.</p>
<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
    @State private var progress = Progress(totalUnitCount: 10)
    let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()

    var body: some View {
        VStack {
            ProgressBar(progress: $progress)
                .padding()
                .onReceive(timer) { timer in
                    progress.completedUnitCount += 1
                    if progress.isFinished {
                        self.timer.upstream.connect().cancel()
                        progress.totalUnitCount = 500
                    }
                }
            if #available(iOS 14, *) {
                ProgressView(progress)
                    .padding()
                    .onReceive(timer) { timer in
                        progress.completedUnitCount += 1
                        if progress.isFinished {
                            self.timer.upstream.connect().cancel()
                            progress.totalUnitCount = 500
                        }
                    }
            }
        }
    }
}
</code></pre>
<p>The iOS 14 variant works, but my iOS 13 implementation fails. Can somebody help me?</p>
","5530076","","","","","2022-06-04 06:44:35","ProgressBar iOS 13","<swift><swiftui><progress-bar><combine>","1","0","2","","","CC BY-SA 4.0"
"65788191","1","65788253","","2021-01-19 08:57:25","","0","440","<p>I am using MVVM in my SwiftUI project and after I request to fetch data from the API, I want to loop through the data and store some of them inside an array, however it returns error, what is the correct method to do this?</p>
<p>Here is my code and data struct</p>
<p>MenuDetailView</p>
<pre><code>struct MenuDetailView: View {
    @ObservedObject var viewModel = MenuDetailViewModel()
    
    var body: some View {
        ForEach(self.viewModel.variantGroup, id: \.self) { vg in
                /*** I Need to loop and store vg.variantGroupName into array viewModel.variantChosen, how? ***/

                self.viewModel.variantChosen.append(vg.VariantGroupName)
                // This always return error:
                // Type '()' cannot conform to 'View'; only struct/enum/class types can conform to protocols

                VStack {
                    HStack {
                        Text(vg.variantGroupName)
                        Text(String(self.viewModel.arrVariantChoosen[0]))
                    }
                    VStack {
                        ForEach(vg.variant, id: \.self) { v in
                            Text(v.variantName)
                        }
                    }
                }
                
            }
        }
    }
}
</code></pre>
<p>MenuDetailViewModel.swift</p>
<pre><code>class MenuDetailViewModel: ObservableObject, MenuDetailService {
    var apiSession: APIService
    @Published var detaildata: MenuDetailData?
    @Published var variantGroup = [MenuDetailVariantGroup]()
    @Published var variantChosen: Array&lt;String&gt; = []
    
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(apiSession: APIService = APISession()) {
        self.apiSession = apiSession
    }
    
    func getMenuDetail() {
        let cancellable = self.getMenuDetail()
            .sink(receiveCompletion: { result in
                switch result {
                case .failure(let error):
                    print(&quot;Handle error: \(error)&quot;)
                case .finished:
                    break
                }
                
            }) { (detail) in
                self.detaildata = detail.data
                self.variantGroup = detail.data.variantGroup
        }
        cancellables.insert(cancellable)
    }
    
}
</code></pre>
<p>MenuDetailData.swift</p>
<pre><code>struct MenuDetailData: Codable, Identifiable {
    let id = UUID()
    let idMenu: String
    let menuName: String
    let variantGroup: [MenuDetailVariantGroup]
}
</code></pre>
<p>MenuDetailVariantGroup.swift</p>
<pre><code>struct MenuDetailVariantGroup: Codable, Identifiable, Hashable {
    let id = UUID()
    let variantGroupName: String
    let variant: [MenuDetailVariant]
    let limit: Int
}
</code></pre>
<p>MenuDetailVariant.swift</p>
<pre><code>struct MenuDetailVariant: Codable, Identifiable, Hashable {
    let id = UUID()
    let variantName: String
}
</code></pre>
<p>Thank you all in advance</p>
","4608714","","","","","2021-01-19 09:08:56","SwiftUI MVVM how to loop through data and store them inside array","<arrays><swift><swiftui><swift5>","1","0","","","","CC BY-SA 4.0"
"65797398","1","65800729","","2021-01-19 18:30:24","","1","964","<p>As example I have a basic published value like</p>
<pre class=""lang-swift prettyprint-override""><code>@Published var value: String
</code></pre>
<p>I have want to validates this value of my form to give my user an output. For that I will use Combine in my MVVM project.</p>
<p>Now this type of value needs to be validated against my REST API. For my REST API I already have a method to get my results of my like <code>getFirstMailboxRedirectFromAPI</code> which returns <code>AnyPublisher&lt;MailboxAPIResponse, APIError&gt;</code>. MailboxAPIResponse is a decodable object for the api response. So if I just want to display the result, I create a subscriber with <code>.sink</code> add the result to a variable which will be shown in a view. So good so far. Now my problem:</p>
<p>As described in the first section my value is already a Publisher (because of @Published), where I can do some <code>.map</code> stuff for validation with it and returning true or false if everything is fine or not.</p>
<p>So to validate my published value I need to call my other Publisher which uses the API to check if the value already exists. But I don't know how this should work.</p>
<p>This is my code so far but this doesn't work. But this shows you my idea how it should work.</p>
<pre class=""lang-swift prettyprint-override""><code>private var isMailboxRedirectNameAvailablePublisher: AnyPublisher&lt;Bool, Never&gt; {
    $mailboxRedirectName
        .debounce(for: 0.5, scheduler: RunLoop.main)
        .setFailureType(to: Error.self)
        .flatMap { name in
            self.getFirstMailboxRedirectFromAPI(from: name, and: self.domainName)
                .map { apiResponse in
                    return apiResponse.response.data.count == 0
                }
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>So in result the publisher should use the redirectName to call the API and the API gives me the result if the mailbox already exists, then returns a boolean, if it's existing or not.</p>
<p>How can I nest multiple publishers and use the result of the API publisher in my published value publisher?</p>
","9618687","","8080648","","2021-01-19 22:51:44","2021-01-19 22:55:30","Use result of publisher in map of another publisher","<swift><mvvm><combine><flatmap><publisher>","1","0","","","","CC BY-SA 4.0"
"65802716","1","65802900","","2021-01-20 03:35:54","","1","321","<p>I want my code to be as reusable as it can be. <code>Writer</code> and <code>JsonProperties</code> are Protocols that define plenty of the functionality the related objects require. <code>JsonProperties</code> conforms to <code>Codable</code> protocol, but I want to implement a custom method for Core Data implementation, through a <code>Writer</code>, the question is:</p>
<p>Can I initialize an object that implements a <code>Writer</code> protocol through the typealias of <code>JsonProperties</code>?</p>
<p>Right now I'm getting this error:</p>
<blockquote>
<p>Cannot convert value of type '[Model]' to expected argument type '[Model.WriterType.Model]'</p>
</blockquote>
<p>Here's the code:</p>
<pre><code>protocol Writer {
    associatedtype Model: JsonProperties
    ...
    init(in dataStack: DataStack)
}

struct GenericWriter&lt;Model: JsonProperties&gt;: Writer { ... }

protocol JsonProperties: Codable {
    associatedtype WriterType: Writer
    ...
}

struct ConversationProperties: JsonProperties {
    typealias WriterType = GenericWriter&lt;Self&gt;
    ...

}
</code></pre>
<p>The implementation I was looking for, but got the error was:</p>
<pre><code>func networkFetch&lt;Model: JsonProperties&gt;(type: Model.Type) -&gt; AnyPublisher&lt;Bool, Error&gt; {
    let writer = Model.WriterType(in: dataStack)
    ...
    var objects = [Model]()
    ...
    writer.insert(objects) &lt;- Error here!
</code></pre>
<p>My guess this is not the correct implementation of the <code>init()</code> of a <code>typealias</code> struct.</p>
","13084493","","5318223","","2021-01-20 03:55:00","2021-01-20 05:48:20","Swift Initialize struct based on typealias","<swift><generics>","2","2","","","","CC BY-SA 4.0"
"65804818","1","65813322","","2021-01-20 07:22:40","","2","630","<p>A SwiftUI TabView contains to two tabs. Each displays data from the same model. If the data is missing, a ProgressView is displayed, if the data is present, the current value is displayed.
In the example model the data is set asynchronously after 2 seconds to cause the problem. (In my real app, the data is set as a result of an async call.)</p>
<p>After running the app, the first tab is displayed containing the ProgressView and the data is displayed after 2 seconds. So far everything seems to work.
When switching from the first Tab to the second the app crashes somewhere 75 levels deep in SwiftUI display code:</p>
<blockquote>
<p>(AG::Graph::add_indirect_attribute:) with EXC_BAD_ACCESS.</p>
</blockquote>
<p>What am I doing wrong and how can I circumvent the problem, if it is an SwiftUI Bug?</p>
<p>The following code causes the crash:</p>
<pre><code>import SwiftUI
import Combine

class Model: ObservableObject{
    @Published var value:Double?
    
    init(){
        DispatchQueue.main.asyncAfter(deadline: .now() + 3){
            self.value = 2.0
            print(&quot;value set&quot;)
        }
    }
}

@main
struct TabViewUpdatingTestApp: App {
    @StateObject var model = Model()
    
    var body: some Scene {
        WindowGroup {
            ContentView(model: model)
        }
    }
}

struct Tab: View {
    let name:String
    @ObservedObject var model:Model
    
    var body: some View {
        if let mvalue = model.value{
            Text(&quot;name: \(name), value: \(mvalue)&quot;)
        }else{
            ProgressView().font(.largeTitle)
        }
    }
}

struct ContentView: View {
    @ObservedObject var model:Model
    
    var body: some View {
        TabView {
            Tab(name: &quot;Tab 1&quot;, model: model)
                .tabItem {
                    Label(&quot;Tab 1&quot;, systemImage: &quot;1.circle&quot;)
                }
            Tab(name: &quot;Tab 2&quot;, model: model)
                .tabItem {
                    Label(&quot;Tab 2&quot;, systemImage: &quot;2.circle&quot;)
                }
        }
    }
}
</code></pre>
","15042552","","8697793","","2021-01-20 16:14:32","2021-01-20 16:14:32","SwiftUI TabView crashes when displaying tab containing data that changed when said tab was invisible","<ios><swift><swiftui><tabview>","1","0","","","","CC BY-SA 4.0"
"65831741","1","65832036","","2021-01-21 16:33:12","","1","112","<p>Kotlin’s coroutines provide the ability to write very flat code. I am trying to work on converting some of the async iOS code to utilize Combine to flatten it out on my end as well.</p>
<p><strong>Kotlin looks like:</strong></p>
<pre><code>private suspend fun getData(
        networkCall: Boolean = true,
        networkRequest: suspend () -&gt; Either&lt;FieldError, List&lt;JobModel&gt;&gt;,
        localRequest: suspend () -&gt; Either&lt;FieldError, List&lt;JobModel&gt;&gt;,
        cache: suspend (data: List&lt;JobModel&gt;) -&gt; Unit
): Either&lt;FieldError, List&lt;JobModel&gt;&gt; {
    // getting of Jobs and passing in pair if result was from network
    var resultNetwork = false
    var result: Either&lt;FieldError, List&lt;JobModel&gt;&gt; = Left(GenericError)
    if (!networkCall) {
        result = localRequest()
    }
    // if it was not a network call and failed we will force network call
    if (networkCall || result.isLeft()) {
        resultNetwork = true
        result = networkRequest()
    }

    if (result is Either.Right &amp;&amp; resultNetwork) {
        cache(result.b)
    }

    return result

}
</code></pre>
<p><strong>Swift WIP looks like:</strong></p>
<pre><code>public func getData(isNetworkCall: AnyPublisher&lt;Bool, Error&gt;,
                    networkRequest: AnyPublisher&lt;[Job], Error&gt;,
                    localRequest: AnyPublisher&lt;[Job], Error&gt;,
                    cache: ([Job]) -&gt; AnyPublisher&lt;Void, Error&gt;) -&gt; AnyPublisher&lt;[Job], Error&gt;? {
    
    let getJobsRequest =  isNetworkCall.flatMap { (isCall) in
        return isCall
            ? networkRequest
            //.also { jobs in cache(jobs) }
            .catch{ _ in return localRequest }
            .eraseToAnyPublisher()
            : localRequest
    }.eraseToAnyPublisher()
    
    return getJobsRequest
}
</code></pre>
<p>How do I add this logic of caching data as part of this AnyPublisher? I would like to have it cache in the midst of this logic transformation. Ideally there could be an <em>also</em> function that appends logic when the transaction is being completed by the subscriber.</p>
<p><strong>Solution:</strong></p>
<pre><code>private func getData(isNetworkCall: AnyPublisher&lt;Bool, Error&gt;,
                         networkRequest: AnyPublisher&lt;[Job], Error&gt;,
                         localRequest: AnyPublisher&lt;[Job], Error&gt;,
                         cache: @escaping ([Job]) -&gt; AnyPublisher&lt;Void, Error&gt;) -&gt; AnyPublisher&lt;[Job], Error&gt; {
    
    // Sequence of steps for when we should do a network call
    let networkCallFlow = networkRequest
        .flatMap { jobs in // cache jobs from network
            cache(jobs)
                .replaceError(with: ()) // fire and forget cache, replace error with Void to continue
                .map { _ in jobs } // need to give back jobs to flatMap
                .setFailureType(to: Error.self) // match failure type
        }
        .catch { _ in localRequest } // return local if network fails
        .eraseToAnyPublisher()
    
    // Sequence of steps for when we should get from local
    let localCallFlow = localRequest
        .catch { _ in networkCallFlow } // do network flow if local call fails
        .eraseToAnyPublisher()

    return isNetworkCall
        .flatMap { $0 ? networkCallFlow : localCallFlow }
        .eraseToAnyPublisher()
}
</code></pre>
","15053529","","15053529","","2021-01-21 23:24:05","2021-01-21 23:24:05","Add additional logic to chain of publisher transformation without affecting Publisher type","<ios><swift><kotlin><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"65839021","1","65839912","","2021-01-22 03:46:39","","2","1010","<p>I need to work with attributed strings (<code>NSMutableAttributedString</code>) in <code>SwiftUI</code> to make a simple rich-text editor, and as you might already know, attributed strings are not natively supported in SwiftUI. So I had to work with the old <code>UITextView</code> using a <code>UIViewRepresentable</code> wrapper.</p>
<p>Now, my app is a document-based app, and whenever I try to save the files, some strange problems happens:</p>
<p><strong>First Problem:</strong> When I run the app and open a file, and start typing, the initial contents of the file are erased.</p>
<p><strong>Second Problem:</strong> Whenever I write text and hit the back arrow to save file, it's never updated. All documents still have the same initial content.</p>
<img src=""https://i.stack.imgur.com/Z73h0.gif"" width=""300"" height=""650"">
<p>The code for document processing is the default code that came when you create a new SwiftUI document-based app, but, I changed the encoding from plain text to <code>NSMutableAttributedString</code>. (I also created a document extension called .mxt instead of .txt)</p>
<p><em><strong>Document processing file <code>MyextDocument.swift</code>:</strong></em></p>
<pre><code>import SwiftUI
import UniformTypeIdentifiers

extension UTType {
    static var MyextDocument = UTType(exportedAs: &quot;com.example.Myext.mxt&quot;)
}

struct MyextDocument: FileDocument {
    var text: NSMutableAttributedString

    init(text: NSMutableAttributedString = NSMutableAttributedString()) {
        self.text = text
    }

    static var readableContentTypes: [UTType] { [.MyextDocument] }
    
    init(configuration: ReadConfiguration) throws {
        guard let data = configuration.file.regularFileContents,
              let string = try? NSMutableAttributedString(data: data, options: [NSMutableAttributedString.DocumentReadingOptionKey.documentType : NSMutableAttributedString.DocumentType.rtf], documentAttributes: nil)
        else {
            throw CocoaError(.fileReadCorruptFile)
        }
        text = string
    }
    
    func fileWrapper(configuration: WriteConfiguration) throws -&gt; FileWrapper {
        let data = (try? text.data(from: NSMakeRange(0, text.length), documentAttributes: [.documentType: NSMutableAttributedString.DocumentType.rtf]))!
        return .init(regularFileWithContents: data)
    }
}
</code></pre>
<p><em><strong>UIViewRepresentable wrapper file <code>iOSEditorTextView.swift</code>:</strong></em></p>
<pre><code>import Combine
import SwiftUI
import UIKit

struct iOSEditorTextView: UIViewRepresentable {
    //@Binding var text: String
    @Binding var document: NSMutableAttributedString
    var isEditable: Bool = true
    var font: UIFont?    = .systemFont(ofSize: 14, weight: .regular)
    
    var onEditingChanged: () -&gt; Void       = {}
    var onCommit        : () -&gt; Void       = {}
    var onTextChange    : (String) -&gt; Void = { _ in }
    
    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self)
    }
    
    func makeUIView(context: Context) -&gt; CustomTextView {
        let textView = CustomTextView(
            text: document,
            isEditable: isEditable,
            font: font
        )
        textView.delegate = context.coordinator
        
        return textView
    }
    
    func updateUIView(_ uiView: CustomTextView, context: Context) {
        uiView.text = document
        uiView.selectedRanges = context.coordinator.selectedRanges
    }
}

// MARK: - Preview

#if DEBUG

struct iOSEditorTextView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            iOSEditorTextView(
                document: .constant(NSMutableAttributedString()),
                isEditable: true,
                font: .systemFont(ofSize: 14, weight: .regular)
            )
            .environment(\.colorScheme, .dark)
            .previewDisplayName(&quot;Dark Mode&quot;)
            
            iOSEditorTextView(
                document: .constant(NSMutableAttributedString()),
                isEditable: false
            )
            .environment(\.colorScheme, .light)
            .previewDisplayName(&quot;Light Mode&quot;)
        }
    }
}

#endif

// MARK: - Coordinator

extension iOSEditorTextView {
    
    class Coordinator: NSObject, UITextViewDelegate {
        var parent: iOSEditorTextView
        var selectedRanges: [NSValue] = []
        
        init(_ parent: iOSEditorTextView) {
            self.parent = parent
        }
        
        func textViewDidBeginEditing(_ textView: UITextView) {
            self.parent.document = textView.attributedText as! NSMutableAttributedString
            self.parent.onEditingChanged()
        }
        
        func textViewDidChange(_ textView: UITextView) {
            self.parent.document = textView.attributedText as! NSMutableAttributedString
            //self.selectedRanges = textView.selectedRange
        }

        func textViewDidEndEditing(_ textView: UITextView) {
            self.parent.document = textView.attributedText as! NSMutableAttributedString
            self.parent.onCommit()
        }
    }
}

// MARK: - CustomTextView

final class CustomTextView: UIView, UIGestureRecognizerDelegate, UITextViewDelegate {
    private var isEditable: Bool
    private var font: UIFont?
    
    weak var delegate: UITextViewDelegate?
    
    var text: NSMutableAttributedString {
        didSet {
            textView.attributedText = text
        }
    }
    
    var selectedRanges: [NSValue] = [] {
        didSet {
            guard selectedRanges.count &gt; 0 else {
                return
            }
            
            //textView.selectedRanges = selectedRanges
        }
    }
        
    private lazy var textView: UITextView = {
        let textView                     = UITextView(frame: .zero)
        textView.delegate                = self.delegate
        textView.font                    = self.font
        textView.isEditable              = self.isEditable
        textView.textColor               = UIColor.label
        textView.textContainerInset      = UIEdgeInsets(top: 40, left: 0, bottom: 0, right: 0)
        textView.translatesAutoresizingMaskIntoConstraints = false
        
        return textView
    }()

    // Create paragraph styles
    let paragraphStyle = NSMutableParagraphStyle() // create paragraph style

    var attributes: [NSMutableAttributedString.Key: Any] = [
        .foregroundColor: UIColor.red,
        .font: UIFont(name: &quot;Courier&quot;, size: 12)!
    ]
    
    // MARK: - Init
    init(text: NSMutableAttributedString, isEditable: Bool, font: UIFont?) {
        self.font       = font
        self.isEditable = isEditable
        self.text       = text
        
        super.init(frame: .zero)
    }
    
    required init?(coder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    // MARK: - Life cycle
    
    override func draw(_ rect: CGRect) {
        super.draw(rect)
        
        setupTextView()
        
        // Set tap gesture
        let tap = UITapGestureRecognizer(target: self, action: #selector(didTapTextView(_:)))
        tap.delegate = self
        textView.addGestureRecognizer(tap)

        // create paragraph style
        self.paragraphStyle.headIndent = 108
        
        // create attributed string
        let string = &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&quot;
        
        // create attributes
        self.attributes = [
            .foregroundColor: UIColor.red,
            .font: UIFont(name: &quot;Courier&quot;, size: 12)!,
            .paragraphStyle: paragraphStyle,
        ]

        // Create the Attributed String
        let myAttrString = NSMutableAttributedString(string: string, attributes: attributes)
        
        // Write it to the Text View
        textView.attributedText = myAttrString
    }
    
    // Show cursor and set it to position on tapping + Detect line
    @objc func didTapTextView(_ recognizer: UITapGestureRecognizer) {
        // Show cursor and set it to position on tapping
        if recognizer.state == .ended {
            textView.isEditable = true
            textView.becomeFirstResponder()
                        
            let location = recognizer.location(in: textView)
            if let position = textView.closestPosition(to: location) {
                let uiTextRange = textView.textRange(from: position, to: position)
                
                if let start = uiTextRange?.start, let end = uiTextRange?.end {
                    let loc = textView.offset(from: textView.beginningOfDocument, to: position)
                    let length = textView.offset(from: start, to: end)
                    
                    textView.selectedRange = NSMakeRange(loc, length)
                }
            }
            
        }
        
    }
        
    func setupTextView() {
        // Setup Text View delegate
        textView.delegate = self
        
        // Place the Text View on the view
        addSubview(textView)
        
        NSLayoutConstraint.activate([
            textView.topAnchor.constraint(equalTo: topAnchor),
            textView.trailingAnchor.constraint(equalTo: trailingAnchor),
            textView.leadingAnchor.constraint(equalTo: leadingAnchor),
            textView.bottomAnchor.constraint(equalTo: bottomAnchor)
        ])

    }
}
</code></pre>
<p><em><strong>And to call the UIViewRepresentable wrapper, I wrote the following code in the <code>ContentView</code>:</strong></em></p>
<pre><code>iOSEditorTextView(
    document: $document.text,
    isEditable: true,
    font: .systemFont(ofSize: 14, weight: .regular)
)
</code></pre>
<p>Any help will be appreciated.</p>
","14910585","","752890","","2021-01-22 22:10:36","2021-01-22 22:10:36","Save a UITextView attributed string to file in SwiftUI","<ios><swift><swiftui><uikit><nsmutableattributedstring>","2","4","1","","","CC BY-SA 4.0"
"65851027","1","65851523","","2021-01-22 18:46:18","","7","1231","<p>I have a question about the <a href=""https://developer.apple.com/documentation/combine/fail/subscribe(on:options:)"" rel=""noreferrer"">subscribe(on:options:)</a> operator. I would appreciate if anyone can help me to figure it out.</p>
<p>So what we have from the documentation:</p>
<blockquote>
<p>Specifies the scheduler on which to perform subscribe, cancel, and request operations.
In contrast with receive(on:options:), which affects downstream messages, subscribe(on:options:) changes the execution context of upstream messages.</p>
</blockquote>
<p>Also, what I got from different articles is that unless we explicitly specify the <code>Scheduler</code> to receive our downstream messages on (using <code>receive(on:options:)</code>), messages will be send on the <code>Scheduler</code> used for receiving a subscription.</p>
<p>This information is not aligned with what I am actually getting during the execution.</p>
<p>I have the next code:</p>
<pre><code>Just(&quot;Some text&quot;)
    .map { _ in
        print(&quot;Map: \(Thread.isMainThread)&quot;)
    }
    .subscribe(on: DispatchQueue.global())
    .sink { _ in
        print(&quot;Sink: \(Thread.isMainThread)&quot;)
    }
    .store(in: &amp;subscriptions)
</code></pre>
<p>I would expect next output:</p>
<pre><code>Map: false
Sink: false
</code></pre>
<p>But instead I am getting:</p>
<pre><code>Map: true
Sink: false
</code></pre>
<p>The same thing happens when I use <code>Sequence</code> publisher.</p>
<p>If I swap the position of <code>map</code> operator and <code>subscribe</code> operator, I receive what I want:</p>
<pre><code>Just(&quot;Some text&quot;)
    .subscribe(on: DispatchQueue.global())
    .map { _ in
        print(&quot;Map: \(Thread.isMainThread)&quot;)
    }
    .sink { _ in
        print(&quot;Sink: \(Thread.isMainThread)&quot;)
    }
    .store(in: &amp;subscriptions)
</code></pre>
<p>Output:</p>
<pre><code>Map: false
Sink: false
</code></pre>
<p>Interesting fact is that when I use the same order of operators from my first listing with my custom publisher, I receive the behaviour I want:</p>
<pre><code>struct TestJust&lt;Output&gt;: Publisher {
    typealias Failure = Never
    
    private let value: Output
    
    init(_ output: Output) {
        self.value = output
    }
    
    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {
        subscriber.receive(subscription: Subscriptions.empty)
        _ = subscriber.receive(value)
        subscriber.receive(completion: .finished)
    }
}

TestJust(&quot;Some text&quot;)
    .map { _ in
        print(&quot;Map: \(Thread.isMainThread)&quot;)
    }
    .subscribe(on: DispatchQueue.global())
    .sink { _ in
        print(&quot;Sink: \(Thread.isMainThread)&quot;)
    }
    .store(in: &amp;subscriptions)
</code></pre>
<p>Output:</p>
<pre><code>Map: false
Sink: false
</code></pre>
<p>So I think there is either my total misunderstanding of all these mechanisms, or some publishers intentionally choose the thread to publish values (<code>Just</code>, <code>Sequence</code> -&gt; <code>Main</code>, <code>URLSession.DataTaskPublisher</code> -&gt; <code>Some of Background</code>), which does not make sense for me, cause in this case why would we need this <code>subscribe(on:options:)</code> for.</p>
<p>Could you please help me to understand what am I missing? Thank you in advance.</p>
","12178141","","","","","2021-01-22 22:14:03","Combine`s subscribe(on:options:) operator","<swift><combine><frp>","1","0","1","","","CC BY-SA 4.0"
"65866463","1","65881095","","2021-01-24 01:56:24","","0","546","<p>I have an AuthService with the following functions:</p>
<pre><code>func signInAnon() -&gt; AnyPublisher&lt;User, AuthError&gt; {
    return Future&lt;User, AuthError&gt; { promise in
        Auth.auth().signInAnonymously { result, error in
            if let error = error {
                return promise(.failure(.signInAnon(description: error.localizedDescription)))
            } else if let user = result?.user {
                return promise(.success(user))
            }
        }
    }.eraseToAnyPublisher()
}

func linkAccount(email: String, password: String) -&gt; AnyPublisher&lt;User, AuthError&gt; {
    
    let emailCredential = EmailAuthProvider.credential(withEmail: email, password: password)
    
    return Future&lt;User, AuthError&gt; { promise in
        Auth.auth().currentUser?.link(with: emailCredential) { result, error in
            if let error = error {
                return promise(.failure(.linkAccount(description: error.localizedDescription)))
            } else if let user = result?.user {
                Auth.auth().updateCurrentUser(user) { error in
                    if let error = error {
                        return promise(.failure(.updateCurrentUser(description: error.localizedDescription)))
                    } else {
                        return promise(.success((user)))
                    }
                }
            }
        }
    } .eraseToAnyPublisher()
}
</code></pre>
<p>In my ViewModel, I want to link the user's anonymous account with an email/password credential. However, at the point of sign in, anonymous sign in has not happened.</p>
<p>Here is the code in my ViewModel:</p>
<pre class=""lang-swift prettyprint-override""><code>case .signUp:

isLoading = true

authService.signInAnon()
    .timeout(.seconds(5), scheduler: DispatchQueue.main, options: nil, customError: { () -&gt; AuthError in
        return .signInAnon(description: self.error?.localizedDescription)})
    .sink { completion in
        switch completion {
        case let .failure(error):
            self.error = error
        case .finished:
            print(&quot;User signed in anonymously&quot;)
            self.error = nil
            }
    } receiveValue: { user in
        self.user = user
    }
    .store(in: &amp;cancellables)

authService.linkAccount(email: email, password: password)
    .timeout(.seconds(5), scheduler: DispatchQueue.main, options: nil, customError: { () -&gt; AuthError in
        return .linkAccount(description: self.error?.localizedDescription)})
    .sink { completion in
    self.isLoading = false
    switch completion {
    case let .failure(error):
        self.error = error
        self.alertIsPresented = true
        print(error.localizedDescription)
    case .finished:
        print(&quot;Sign up successful&quot;)
    }
} receiveValue: { user in
    self.user = user
}
.store(in: &amp;cancellables)
</code></pre>
<p>I am running into problems because sometimes the function linking the accounts finishes before the anonymous sign in function, presenting an error.</p>
<p>How can I write this conditionally so that there is a check to see if the user is signed in anonymously? If they are, link their account. If they are not, sign them in anonymously, and then link their account.</p>
","15068510","","209103","","2021-01-24 02:41:43","2021-01-25 08:16:44","Using SwiftUI, Combine, and Firebase, how do I verify that a user is signed in anonymously before linking their account to an email/password?","<swift><firebase><firebase-authentication><swiftui>","1","0","1","","","CC BY-SA 4.0"
"65868890","1","65869343","","2021-01-24 09:21:06","","0","653","<p>I am very new to Swift &amp; XCode, after following several tutorials, I have made an MVVM architecture with an API service, however I could not pass my variable from ViewModel to my API service. I want to pass var user &amp; pass from LoginViewModel to APIEndpoint</p>
<p>LoginViewModel</p>
<pre><code>class LoginViewModel: ObservableObject, LoginService {
    // I want to send this 2 variables to APIEndpoint
    @Published var user = &quot;&quot;
    @Published var pass = &quot;&quot;
    
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(apiSession: APIService = APISession()) {
        self.apiSession = apiSession
    }
    
    func login() {
        let cancellable = self.login()
            .sink(receiveCompletion: { result in
                switch result {
                case .failure(let error):
                    print(&quot;Handle error: \(error)&quot;)
                case .finished:
                    break
                }
                
            }) { (detail) in
                print(detail)
        }
        cancellables.insert(cancellable)
    }
}
</code></pre>
<p>APIEndpoint</p>
<pre><code>enum APIEndpoint {
    case userLogin
    case menuList
}

extension APIEndpoint: RequestBuilder {
    var urlRequest: URLRequest {
        switch self {
        case .userLogin:
             guard let url = URL(string: &quot;https://jcouserapidev.oxxo.co.id/home/app&quot;)
                else {preconditionFailure(&quot;Invalid URL format&quot;)}
            var request = URLRequest(url: url)
            request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
            request.setValue(Constants.API_TOKEN, forHTTPHeaderField: &quot;Authorization&quot;)
            request.httpMethod = &quot;POST&quot;
            
            // I want to pass the variables here, how??
            let body: [String: Any] = [&quot;user&quot;: $user, &quot;pass&quot;: $pass]

            let rb = try! JSONSerialization.data(withJSONObject: body)
            request.httpBody = rb
            
            return request
        case .menuList:
            guard let url = URL(string: &quot;https://jcouserapidev.oxxo.co.id/home/app&quot;)
                else {preconditionFailure(&quot;Invalid URL format&quot;)}
            var request = URLRequest(url: url)
            request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
            request.setValue(Constants.API_TOKEN, forHTTPHeaderField: &quot;Authorization&quot;)
            request.httpMethod = &quot;POST&quot;
            return request
        }
        
    }
}
</code></pre>
<p>RequestBuilder</p>
<pre><code>protocol RequestBuilder {
    var urlRequest: URLRequest {get}
}
</code></pre>
<p>LoginService</p>
<pre><code>protocol LoginService {
    var apiSession: APIService {get}
    
    func login() -&gt; AnyPublisher&lt;LoginAPIResponse, APIError&gt;
}

extension LoginService {
    
    func login() -&gt; AnyPublisher&lt;LoginAPIResponse, APIError&gt; {
        return apiSession.request(with: APIEndpoint.userLogin)
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>APIService</p>
<pre><code>protocol APIService {
    func request&lt;T: Decodable&gt;(with builder: RequestBuilder, test: String) -&gt; AnyPublisher&lt;T, APIError&gt;
}
</code></pre>
<p>APISession</p>
<pre><code>struct APISession: APIService {
    func request&lt;T&gt;(with builder: RequestBuilder) -&gt; AnyPublisher&lt;T, APIError&gt; where T: Decodable {
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        
        return URLSession.shared
            .dataTaskPublisher(for: builder.urlRequest)
            .receive(on: DispatchQueue.main)
            .mapError { _ in .unknown }
            .flatMap { data, response -&gt; AnyPublisher&lt;T, APIError&gt; in
                if let response = response as? HTTPURLResponse {
               
                    if (200...299).contains(response.statusCode) {
                        print(String(data: data, encoding: .utf8) ?? &quot;&quot;)
                        return Just(data)
                            .decode(type: T.self, decoder: decoder)
                            .mapError {_ in .decodingError}
                            .eraseToAnyPublisher()
                    } else {
                        return Fail(error: APIError.httpError(response.statusCode))
                            .eraseToAnyPublisher()
                    }
                }
                return Fail(error: APIError.unknown)
                        .eraseToAnyPublisher()
            }
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>Thank you all in advance.</p>
","4608714","","14733292","","2021-01-24 18:20:33","2021-01-24 18:20:33","SwiftUI MVVM pass variable from ViewModel to API Service","<ios><swift><mvvm><swiftui>","1","0","","","","CC BY-SA 4.0"
"65879229","1","65879330","","2021-01-25 04:59:27","","0","1152","<p>I am setting up a login page logic with MVVM and I could not figure out how to modify the user login state after calling the function from ViewModel.</p>
<p>LoginView</p>
<pre><code>struct LoginView: View {
    @ObservedObject var user: User
    @ObservedObject var viewModel = LoginViewModel()
    @State var inputUser: String = &quot;&quot;
    @State var inputPass: String = &quot;&quot;
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading) {
                Group {
                    Text(&quot;Login&quot;)
                    CustomTextField(placeHolder: &quot;Username&quot;, value: $viewModel.user, secure: false)
                    CustomTextField(placeHolder: &quot;Password&quot;, value: $viewModel.pass, secure: true)
                    Button(action: {
                        self.viewModel.login()
                        // After this login function completes and if return result success
                        // How do I pass data / callback after login?
                        // How to check if login success then set token or login failed
                        self.user.tokenIsActive = true
                    }) {
                        Text(&quot;Sign In&quot;)
                    }
                }
            }
        }
    }
}
</code></pre>
<p>LoginViewModel</p>
<pre><code>class LoginViewModel: ObservableObject, LoginService {
    var apiSession: APIService
    
    @Published var user = &quot;&quot;
    @Published var pass = &quot;&quot;
    
    @Published var accessToken: String?
    
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(apiSession: APIService = APISession()) {
        self.apiSession = apiSession
    }
    
    func login() {
        let cancellable = self.loginUser(user: user, pass: pass)
            .sink(receiveCompletion: { result in
                switch result {
                case .failure(let error):
                    print(&quot;Handle error: \(error)&quot;)
                case .finished:
                    break
                }
                
            }) { (result) in
                self.accessToken = result.accessToken
                UserDefaults.standard.set(self.accessToken, forKey: &quot;accessToken&quot;)
        }
        cancellables.insert(cancellable)
    }
}
</code></pre>
<p>User</p>
<p>So I store the user session in User class</p>
<pre><code>class User: ObservableObject {
    @Published var tokenIsActive = false;
}
</code></pre>
<p>How do I pass data from the login function in viewmodel and check if login is success and set user token? Thank you in advance.</p>
","4608714","","8697793","","2021-01-26 11:24:10","2021-01-26 15:37:19","SwiftUI MVVM how to set callback from ViewModel function to View","<swift><mvvm><swiftui>","1","1","","","","CC BY-SA 4.0"
"65880240","1","65880337","","2021-01-25 06:59:53","","0","280","<p>I have a view performing expensive updates so I'd like to throttle them:</p>
<p>currently my view is like this:</p>
<pre><code>struct CodeGenerationView: View {
    @StateObject var root: RootState
    var body: some View {
        Text(CodeGenerator.generate(root: root))
    }
}
</code></pre>
<p>so it is called on each update.</p>
<p>I'd like to throttle the changes to update only once a second</p>
<p>is this possible?</p>
","1532045","","","","","2021-01-25 07:08:57","how can i throttle changes to stateobject in swiftui","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"65890208","1","65892366","","2021-01-25 18:15:22","","0","85","<p>So I finally have the isoCountrycode from the user's current location and need to concatenate it on the end of an API url in order that the URL will respond with the relevant information.</p>
<p>The location's isoCountrycode is found in model/LocationViewModel.swift</p>
<p>Code:</p>
<pre><code>import Foundation
import Combine
import CoreLocation

class LocationViewModel: NSObject, ObservableObject{
  
  @Published var userLatitude: Double = 0
  @Published var userLongitude: Double = 0
  
  private let locationManager = CLLocationManager()
  
  override init() {
    super.init()
    self.locationManager.delegate = self
    self.locationManager.desiredAccuracy = kCLLocationAccuracyBest
    self.locationManager.requestWhenInUseAuthorization()
    self.locationManager.startUpdatingLocation()
  }
}

extension LocationViewModel: CLLocationManagerDelegate {
  
  func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    guard let location = locations.last else { return }
    userLatitude = location.coordinate.latitude
    userLongitude = location.coordinate.longitude
    print(location)
    
    CLGeocoder().reverseGeocodeLocation(location) { (placemark, error) in
        if error != nil
        {
            print(&quot;there is an error&quot;)
        }
        else
        {
            if let place = placemark?[0]
            {
                let countrycode = place.isoCountryCode
            }
        }
    }
    
  }
}
</code></pre>
<p>And the view where I need to use it is here (located in views/HomeAPIContentView.swift), where I would add it to the end of the API URL .e.g  &quot;https://emergency-phone-numbers.herokuapp.com/country/&quot; + countrycode</p>
<p>Code for view file is here:</p>
<pre><code>
import SwiftUI

struct Response: Decodable {
    var content: [Result]
}

struct Result : Decodable {
    var code: String
    var fire: String
    var name: String
    var police: String
    var medical: String
}

struct HomeAPIContentView: View {
    @State private var content = [Result]()
    @ObservedObject var locationViewModel = LocationViewModel()

    var body: some View {
        List(content, id: \.code) { item in
            VStack(alignment: .center) {
                Text(&quot;Latitude: \(locationViewModel.userLatitude)&quot;)
                Text(&quot;Longitude: \(locationViewModel.userLongitude)&quot;)
                Text(item.name)
                    .font(.headline)
                HStack {
                    Text(&quot;Medical:&quot;)
                    Text(item.medical)
                        .foregroundColor(Color.red)
                    Text(&quot;Police:&quot;)
                    Text(item.police)
                        .foregroundColor(Color.red)
                    Text(&quot;Fire:&quot;)
                    Text(item.fire)
                        .foregroundColor(Color.red)
                }
            }
        }
        .onAppear(perform: loadData)
    }
    func loadData() {
        
        let url = URL(string: &quot;https://emergency-phone-numbers.herokuapp.com/country/us&quot;)!

        URLSession.shared.dataTask(with: url) { data, response, error in
            if let error = error { print(error); return }
            do {
                let decodedResponse = try JSONDecoder().decode(Result.self, from: data!)
                // we have good data – go back to the main thread
                DispatchQueue.main.async {
                    // update our UI
                    self.content = [decodedResponse]
                }
                
            } catch {
                print(error)
            }
        }.resume()
        
    }
}
</code></pre>
<p>If I could access the cc variable from the view, it sounds like an easy enough thing to do but I have no idea how to do that. Please advise.</p>
<p>Thanks in advance.</p>
","14668403","","8441876","","2021-01-25 18:43:18","2021-01-25 21:01:24","How to access variable in model from view in Swift","<ios><swift><swiftui>","1","5","","","","CC BY-SA 4.0"
"65913214","1","65913307","","2021-01-27 05:11:21","","2","741","<p>I am creating a user login page using MVVM architecture and I want to show an alert page if text field is empty or if wrong username / wrong password. So after login click and API call, if login failed, I want to show an alert, however I tried changing the state but still the alert does not show.</p>
<p>LoginView</p>
<pre><code>struct LoginView: View {
    @ObservedObject var user: User
    @ObservedObject var viewModel = LoginViewModel()
    @State var inputUser: String = &quot;&quot;
    @State var inputPass: String = &quot;&quot;
    @State private var showingAlert = true
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading) {
                Group {
                    Text(&quot;Login&quot;)
                    CustomTextField(placeHolder: &quot;Username&quot;, value: $viewModel.user)
                    CustomTextField(placeHolder: &quot;Password&quot;, value: $viewModel.pass)
                    Button(action: {
                        self.viewModel.login { (isSuccess) in
                            if isSuccess {
                                self.user.tokenIsActive = true
                            } else {
                                // if login failed, show alert, but alert not showing
                                self.showingAlert = true
                            }
                        }
                    }) {
                        Text(&quot;Sign In&quot;)
                    }.buttonStyle(PrimaryButtonStyle())
                    .alert(isPresented: $showingAlert) {
                        Alert(title: Text(&quot;Error&quot;), message: Text(&quot;Invalid username / password&quot;), dismissButton: .default(Text(&quot;Got it!&quot;)))
                    }
                }
            }
        }
    }
}
</code></pre>
<p>LoginViewModel</p>
<pre><code>class LoginViewModel: ObservableObject, LoginService {
    var apiSession: APIService
    
    @Published var user = &quot;&quot;
    @Published var pass = &quot;&quot;
    
    @Published var accessToken: String?
    @Published var refreshToken: String?
    @Published var showingAlert = true
    
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(apiSession: APIService = APISession()) {
        self.apiSession = apiSession
    }
    
    func login(_ completion: @escaping ((Bool)-&gt;Void)) {
        let cancellable = self.loginUser(user: user, pass: pass)
            .sink(receiveCompletion: { result in
                switch result {
                case .failure(let error):
                    print(&quot;Handle error: \(error)&quot;)
                case .finished:
                    break
                }
                
            }) { (result) in
                completion(true)
                self.accessToken = result.accessToken
                self.refreshToken = result.refreshToken
                UserDefaults.standard.set(self.accessToken, forKey: &quot;AccessToken&quot;)
                UserDefaults.standard.set(self.refreshToken, forKey: &quot;RefreshToken&quot;)
        }
        cancellables.insert(cancellable)
    }
}

</code></pre>
<p>How do I show the alert? Thank you all in advance.</p>
","4608714","","","","","2021-01-27 05:22:20","SwiftUI MVVM how to show alert after a function","<swift><xcode><mvvm><swiftui>","1","0","","","","CC BY-SA 4.0"
"65922671","1","65922746","","2021-01-27 15:53:14","","-1","1114","<p>I have the following situation:</p>
<p>2 futures, one returns a value I am interested in, the other does some operations and returns void. The 2 are not related to each other (so the code should not be mixed), but both need to be executed in the right order in the application logic.</p>
<p>What I want to do is subscribe to a publisher that does the following:</p>
<ul>
<li>future one executes and gives a value</li>
<li>future two executes and returns nothing</li>
<li>the subscriber receives the value of future one after the execution of future two.</li>
</ul>
<p>Here is a small code example that does not compile, that shows what I would like to achieve:</p>
<pre><code>import Combine


func voidFuture() -&gt; Future&lt;Void, Error&gt; {
    return Future&lt;Void, Error&gt; { promise in
        promise(.success(()))
    }
}

func intFuture() -&gt; Future&lt;Int, Error&gt; {
    return Future&lt;Int, Error&gt; { promise in
        promise(.success(1))
    }
}

  

func combinedFuture() -&gt; AnyPublisher&lt;Int, Error&gt; {
    var intValue: Int!

    return intFuture().flatMap { result in
        intValue = result
        return voidFuture()
    }.flatMap{ _ in
        return CurrentValueSubject(intValue).eraseToAnyPublisher()
    }.eraseToAnyPublisher()
}

var subscriptions = Set&lt;AnyCancellable&gt;()

combinedFuture()
    .sink(receiveCompletion: { _ in }, receiveValue: { val in print(val)})
    .store(in: &amp;subscriptions)


</code></pre>
","251824","","","","","2021-01-27 15:57:11","Swift Combine return result of first future after evaluation of second","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"65925048","1","65925377","","2021-01-27 18:19:48","","1","295","<p>I use combine to connect to a REST API which pulls some data into an ObservableObject. The whole setup is really just MVVM. The ObservableObject is then being Observed in a view. Now, I'm stuck with a bug I can't seem to get resolved. What seems to happen is that the View is drawn twice. The first time it updates with the values from the ObservedObject. Then it immediately re-draws, but now the pulled data is suddenly gone. I have confirmed that the code that pulls the data is not executed a second time. Also, the View Hierarchy Viewer seems to suggest that the Text Views which are supposed to be render the data in the view are somehow deleted on the second render run.</p>
<p>This is what the model looks like (the authentication related code is from Firebase):</p>
<pre><code>class ItemViewModel: ObservableObject {
    
    @Published var items = [ScheduleItem]()
    
    private var publisher: AnyCancellable?
    
    func fetchData() {
        
        let currentUser = Auth.auth().currentUser
        currentUser?.getIDTokenForcingRefresh(false, completion: { idToken, error in
        
            let url = URL(string: &quot;abc&quot;)!
            var request = URLRequest(url: url)
            request.httpMethod = &quot;GET&quot;
            request.setValue(&quot;Bearer &quot;+String(idToken!), forHTTPHeaderField: &quot;Authorization&quot;)
     
            self.publisher = URLSession.shared
                .dataTaskPublisher(for: url)
                .map(\.data)
                .decode(
                    type: [ScheduleItem].self,
                    decoder: JSONDecoder()
                )
                .receive(on: DispatchQueue.main)
                .sink(
                    receiveCompletion: { completion in
                        switch completion {
                        case .failure(let error):
                            print(&quot;SINKERROR&quot;)
                            print(error)
                        case .finished:
                            print(&quot;SINKSUCCESS&quot;)
                        }
                    },
                    receiveValue: { repo in
                        print(&quot;DONE&quot;)
                        self.items.append(contentsOf: repo)
                    }
                )
        })
    }
}
</code></pre>
<p>The output from the print statements is
DONE
SINKSUCCESS
Both can only be found once in the debug output.</p>
<p>This is the view:</p>
<pre><code>struct TreatmentCardView: View {
    
    let startDate: String
    let uid: Int
    
    @ObservedObject var data = ItemViewModel()
    
    @State private var lastTime: String = &quot;2&quot;
    
    var body: some View {
        ZStack {
            GeometryReader { geometry in
                VStack{
                    
                    Text(&quot;Headline&quot;)
                        .font(.title)
                        .foregroundColor(Color.white)
                        .padding([.top, .leading, .bottom])
                    
                    Print(&quot;ISARRAYEMPTY&quot;)
                    Print(String(data.items.isEmpty))
                    
                    Text(String(data.items.isEmpty))
                                .font(.headline)
                                .fontWeight(.light)
                                .foregroundColor(Color.white)
                                .frame(width: 300, height: 25, alignment: .leading)
                                .multilineTextAlignment(.leading)
                                .padding(.top)
                      
                     
                }
            }
        }
        .background(Color(&quot;ColorPrimary&quot;))
        .cornerRadius(15)
        .onAppear{
            self.data.fetchData()
        }
    }
}
</code></pre>
<p>Print(String(data.items.isEmpty)) is first false, then true, indicating the view was re-rendered.</p>
<p>What is a bit weird to me is that I would have expected the view to render at least once before the data is pulled, but I don't see any indication of this happening.</p>
<p>I've been trying to make this word for two days now. Any help and advise is greatly appreciated!</p>
","1763259","","","","","2021-01-27 18:54:15","Data from ObservedObject not rendered in SwiftUI view","<swiftui><combine><observableobject><observedobject>","2","0","1","","","CC BY-SA 4.0"
"65942698","1","65943062","","2021-01-28 17:57:19","","0","67","<p>I'm having trouble getting a function call using a generic type to work using a <code>URLSession</code> <code>DataTaskPublisher</code>...</p>
<p>The API I'm calling always responds with an HTTP 200, and indicates whether it was successful or not in the JSON via a <code>code</code> string with an indicator.</p>
<p>I created a <code>protocol</code> that all response objects conform to, e.g.:</p>
<pre><code>protocol APIResponse: Decodable {
    var code: String { get }
}
</code></pre>
<p>My actual response will be something like:</p>
<pre><code>struct LoginResponse :  APIResponse {
    let code: String
    let name: String
    enum CodingKeys: String, CodingKey {
        case code = &quot;code&quot;
        case name = &quot;name&quot;
    }
    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        code = try values.decode(String.self, forKey: .code)
        name = try values.decode(String.self, forKey: .name)
    }
}
</code></pre>
<p>Now I want a function like this that I can use:</p>
<pre><code>    private func call&lt;T: APIResponse&gt;(_ endpoint: String, using data: Encodable, providing response: T)
                    -&gt; AnyPublisher&lt;T, Error&gt; {
        let request = createRequest(for: endpoint, using: data)
        return session
                .dataTaskPublisher(for: request)
                .map {
                    $0.data
                }
                .decode(type: T.self, decoder: decoder)
                .tryMap {
                    response in
                    if response.code.suffix(1) != &quot;I&quot; {
                        throw MyError(message: &quot;Error \(code)&quot;)
                    }
                    return response
                }
                .eraseToAnyPublisher()
    }
</code></pre>
<p>So far, so good!</p>
<p>But here's the problem... I want to use it like this:</p>
<pre><code>    func login() -&gt; AnyPublisher&lt;String, Error&gt; {
        call(&quot;login&quot;, using: LoginRequest(), providing: LoginResponse)
                .map {
                    $0.name
                }
                .eraseToAnyPublisher()
    }

</code></pre>
<p>The compiler complains with <code>Type 'LoginResponse.Type' cannot conform to 'APIResponse'; only struct/enum/class types can conform to protocols</code></p>
<p>My fix (which works, but is kludgy), it to provide a no-arg <code>init()</code> for <code>LoginResponse</code> and call it like this: <code>call(&quot;login&quot;, using: LoginRequest(), providing: LoginResponse())</code></p>
<p>Any way to get the Generic to work without the no-arg <code>init()</code>?</p>
<p>Should I be taking a totally different approach?</p>
","7833553","","","","","2021-02-14 14:55:19","Calling a function with a Generic parameter requires a no-arg init for the type","<swift><combine>","3","2","","","","CC BY-SA 4.0"
"65965666","1","65968034","","2021-01-30 07:30:53","","2","719","<p>I'm subscribing the the built-in User Defaults extension, but it seems to be firing multiple times unnecessarily.</p>
<p>This is the code I'm using:</p>
<pre><code>import Combine
import Foundation
import PlaygroundSupport

extension UserDefaults {
    
    @objc var someProperty: Bool {
        get { bool(forKey: &quot;someProperty&quot;) }
        set { set(newValue, forKey: &quot;someProperty&quot;) }
    }
}

let defaults = UserDefaults.standard

defaults.dictionaryRepresentation().keys
    .forEach(defaults.removeObject)

print(&quot;Before: \(defaults.someProperty)&quot;)

var cancellable = Set&lt;AnyCancellable&gt;()

defaults
    .publisher(for: \.someProperty)
    .sink { print(&quot;Sink: \($0)&quot;) }
    .store(in: &amp;cancellable)

defaults.someProperty = true
cancellable.removeAll()

PlaygroundPage.current.needsIndefiniteExecution = true
</code></pre>
<p>This prints:</p>
<pre><code>Before: false
Sink: false
Sink: true
Sink: true
</code></pre>
<p>Why is it firing the sink 3 times instead of only once?</p>
<p>I can maybe understand it firing on subscribe, which is confusing because it doesn't seem to be a <code>PassthroughSubject</code> or any documentation of this. However, what really confuses me is the third time it fires.</p>
<p><strong>UPDATE:</strong></p>
<p>It's strange but it seems the initial value gets factored into the new/old comparison:</p>
<pre><code>defaults.someProperty = false
defaults.someProperty = true
defaults.someProperty = false
defaults.someProperty = true

print(&quot;Initial: \(defaults.someProperty)&quot;)

defaults
    .publisher(for: \.someProperty, options: [.new])
    .sink { print(&quot;Sink: \($0)&quot;) }
    .store(in: &amp;cancellable)

defaults.someProperty = true
</code></pre>
<p>The above will print which looks good:</p>
<pre><code>Initial: true
Sink: true
</code></pre>
<p>But when the initial value is different than what you set it to:</p>
<pre><code>defaults.someProperty = false
defaults.someProperty = true
defaults.someProperty = false
defaults.someProperty = true
defaults.someProperty = false

print(&quot;Initial: \(defaults.someProperty)&quot;)

defaults
    .publisher(for: \.someProperty, options: [.new])
    .sink { print(&quot;Sink: \($0)&quot;) }
    .store(in: &amp;cancellable)

defaults.someProperty = true
</code></pre>
<p>The above will strangely print:</p>
<pre><code>Initial: false
Sink: true
Sink: true
</code></pre>
<p>This is untiutive because it's treating the initial value as a trigger of <code>[.new]</code>, then compares again for what was set.</p>
","235334","","235334","","2021-01-30 18:00:49","2021-01-30 18:16:52","Why does User Defaults publisher trigger multiple times","<swift><combine>","1","4","1","","","CC BY-SA 4.0"
"65968753","1","68891475","","2021-01-30 13:53:05","","0","1716","<h1>Situation</h1>
<p>Hi there,
I am developing an iOS app and while building my project I run into the following error message:
Error: Trace/BPT trap: 5</p>
<p>I didn't find anything online to fix this problem, so I wanted to know, if anyone here might be able to help.
I also had issues with Cocoapods and my Silicon Mac, so I want to list my steps I've tried fixing:</p>
<h1>Setup</h1>
<ul>
<li>M1 MacBook Pro, macOS 11.1</li>
<li>XCode Version 12.4</li>
<li>Cocoapods with Pods for Firebase Swift, Auth, Firestore and Storage</li>
</ul>
<h1>Steps I tried fixing</h1>
<ul>
<li>cmd + shift + k for cleaning the build folder</li>
<li>closing XCode and opening Terminal using Rosetta</li>
<li>delete ~/Library/Developer/Xcode/Derived Data - Folder</li>
<li>pod deintegrate in project directory</li>
<li>delete Podfile.lock, app.xcworkspace, Pods directory</li>
<li>pod install</li>
<li>in app and pods projects build settings setting Excluded Architectures for any iOS Simulator SDK to arm64</li>
<li>setting Build Active Architecture Only to yes</li>
<li>convert Pods Project to Swift 5</li>
<li>build Pods Project</li>
<li>build app project</li>
</ul>
<p>And then the following error occurs:</p>
<h1>Log</h1>
<p>Log enty from Merge swiftmodule (x86_64):
<a href=""https://pastebin.com/MiSKGxB7"" rel=""nofollow noreferrer"">https://pastebin.com/MiSKGxB7</a>
(Log way to long, exceeds character limit).</p>
<h1>Code</h1>
<p>As the error somewhere tells, it occured while trying to serialize the class BaseViewModel, here's the code from the Base.swift file I wrote containing that class:</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Firebase
import FirebaseFirestore
import Combine

protocol BaseModel: Identifiable, Codable {
    var id: String? { get set }
    var collection: String { get }
    init()
}

class BaseViewModel&lt;T: BaseModel&gt;: ObservableObject, Identifiable, Equatable {

    @Published var model: T
    var id: String {
        didSet {
            self.model.id = id
        }
    }
    
    var cancellables = [AnyCancellable]()
    private var db = Firestore.firestore()
    
    required init(){
        let model = T.init()
        self.model = model
        self.id = model.id ?? UUID().uuidString
    }
    
    required init(id: String) {
        var model = T.init()
        model.id = id
        self.model = model
        self.id = id
    }
    
    init(model: T) {
        self.model = model
        self.id = model.id ?? UUID().uuidString
    }

    static func ==(lhs: BaseViewModel&lt;T&gt;, rhs: BaseViewModel&lt;T&gt;) -&gt; Bool {
        lhs.model.id == rhs.model.id
    }
    
    func load(completion: @escaping (Bool) -&gt; Void = {finished in}){
        if let id = model.id {
            self.id = id
            db.collection(model.collection).document(id).getDocument { docSnapshot, error in
                guard let doc = docSnapshot else {
                    print(&quot;Error fetching document: \(error!)&quot;)
                    return
                }
                
                do {
                    guard let data = try doc.data(as: T.self) else {
                        print(&quot;Document empty \(type(of: self.model)) with id \(id)&quot;)
                        return
                    }
                    self.model = data
                    self.loadSubData {finished in
                        if finished{
                            completion(true)
                        }
                    }
                } catch {
                    print(error.localizedDescription)
                }
            }
        }
    }
    
    func loadSubData(completion: @escaping(Bool) -&gt; Void = {finished in}) {
        fatalError(&quot;Must be overridden!&quot;)
    }
    
    func loadDataByIDs&lt;T, S&gt;(from list: [String], appender: @escaping (T) -&gt; Void) where T: BaseViewModel&lt;S&gt;, S: BaseModel {
        for id in list {
            let viewModel = T.init(id: id)
            viewModel.load{finished in
                if finished {
                    appender(viewModel)
                }
            }
        }
    }
    
    func save(){
        do {
            let _ = try db.collection(model.collection).addDocument(from: model)
        } catch {
            print(error)
        }
    }
    
    func update(){
        if let id = model.id {
            do {
                try db.collection(model.collection).document(id).setData(from: model)
            } catch {
                print(error.localizedDescription)
            }
        }
    }
    
    func delete(){
        if let id = model.id {
            db.collection(model.collection).document(id).delete() { error in
                if let error = error {
                    print(error.localizedDescription)
                }
            }
        }
    }
    
}
</code></pre>
","12531598","","14531220","","2021-01-30 15:58:58","2022-08-02 09:31:18","Xcode Trace/BPT trap: 5","<swift><xcode><swiftui><cocoapods><apple-silicon>","4","0","1","","","CC BY-SA 4.0"
"65983371","1","65983730","","2021-01-31 19:33:40","","-1","47","<p>I started to program with swift and I have problem with the call to a local service that returns for example:</p>
<p>{&quot;idMember&quot;:14,&quot;externalID&quot;:&quot;001996.dce&quot;,&quot;email&quot;:null,&quot;name&quot;:&quot;Manu&quot;,&quot;isActive&quot;:true,&quot;logDate&quot;:&quot;2020-12-12 12:12:12&quot;,&quot;logUser&quot;:&quot;asdasd&quot;}</p>
<p>I tried this:</p>
<pre><code>let url = URL(string: &quot;http://localhost:8080/member/findByExternalID/001996.dce&quot;)!
let token = URLSession.shared.dataTaskPublisher(for: url)
           .map { $0.data }
           .decode(type: Member.self, decoder: JSONDecoder())
           .sink(receiveCompletion: { completion in
              print(completion)
            }, receiveValue: { value in
               print(&quot;service has \(value) value&quot;)
           })
</code></pre>
<p>Member.swift:</p>
<pre><code>struct Member: Codable, Identifiable {
var id = UUID()
let idMember:Int
var name:String
    
var logDate:Date
var logUser:String

var externalID:String
var email:String
var isActive:Bool

enum CodingKeys: String, CodingKey {
    case idMember, name,  logDate,  logUser,  externalID, email, isActive }
}
</code></pre>
<p>but never print info, the service is never invoked (I check it in the server log). I suppose this is a trivial question. But I didn't find what's wrong.</p>
","15118472","","","","","2021-02-01 01:31:13","Swift and Combine. Problems when I recover one record from a local service","<swift><rest><combine>","1","2","","","","CC BY-SA 4.0"
"66010221","1","66010340","","2021-02-02 12:57:23","","1","228","<p>I'm trying to wrap a tryMap operator along the lines of <a href=""https://www.swiftbysundell.com/articles/extending-combine-with-convenience-apis/"" rel=""nofollow noreferrer"">this</a> article.</p>
<pre class=""lang-swift prettyprint-override""><code>extension Publisher where Output == Data {
    func decode&lt;T: Decodable&gt;(as type: T.Type = T.self, using decoder: JSONDecoder = .init()) -&gt; Publishers.Decode&lt;Self, T, JSONDecoder&gt; {
        decode(type: type, decoder: decoder)
    }
}

extension Publisher where Output == URLSession.DataTaskPublisher.Output {
    func processData(_: @escaping (Self.Output) throws -&gt; Data) -&gt; Publishers.TryMap&lt;Self, Data&gt; {
        tryMap { element -&gt; Data in
            guard let httpResponse = element.response as? HTTPURLResponse,
                  httpResponse.statusCode == 200
            else {
                throw URLError(.badServerResponse)
            }
            return element.data
        }
    }
}
</code></pre>
<p>While using it I'm getting a compiler error which I'm struggling with:</p>
<pre><code>return urlSession
    .dataTaskPublisher(for: request)
    .processData // &lt;- Value of type '(@escaping (URLSession.DataTaskPublisher.Output) throws -&gt; Data) -&gt; Publishers.TryMap&lt;URLSession.DataTaskPublisher, Data&gt;' (aka '(@escaping ((data: Data, response: URLResponse)) throws -&gt; Data) -&gt; Publishers.TryMap&lt;URLSession.DataTaskPublisher, Data&gt;') has no member 'decode'
    .decode(as: InstantResponse.self)
    .eraseToAnyPublisher()
</code></pre>
<p>What would be the correct way of doing it?
Thanks!</p>
","4473187","","4473187","","2021-02-02 13:01:29","2021-02-02 13:04:31","Swift: Extending Combine operators","<swift><generics><combine>","1","0","","","","CC BY-SA 4.0"
"66014783","1","66228737","","2021-02-02 17:35:48","","1","609","<p>I am trying to implement a list functionality similar to to <a href=""https://developer.apple.com/tutorials/swiftui/handling-user-input"" rel=""nofollow noreferrer"">Handling User Input</a> example, the interface shows a list the user can filter depending on boolean values. I want to add the following differences from the example:</p>
<ul>
<li>Can edit list elements from the row itself</li>
<li>Move the filter logic to a ViewModel class</li>
</ul>
<p>I've tried many approaches without success one of them:</p>
<ul>
<li>ViewModel:</li>
</ul>
<pre><code>    class TaskListViewModel : ObservableObject  {
    
        private var cancelables = Set&lt;AnyCancellable&gt;()
    
        private var allTasks: [Task] =
            [ Task(id: &quot;1&quot;,name: &quot;Task1&quot;, description: &quot;Description&quot;, done: false),
              Task(id: &quot;2&quot;,name: &quot;Task2&quot;, description: &quot;Description&quot;, done: false)]
    
        @Published var showNotDoneOnly = false
    
        @Published var filterdTasks: [Task] = []

        init() {
        
            filterdTasks = allTasks

            $showNotDoneOnly.map { notDoneOnly in
                if notDoneOnly {
                    return self.filterdTasks.filter { task in
                        !task.done
                    }
                }
                return self.filterdTasks
            }.assign(to: \.filterdTasks, on: self)
            .store(in: &amp;cancelables)
        }
    }
</code></pre>
<ul>
<li>View:</li>
</ul>
<pre><code>struct TaskListView: View {
    
    @ObservedObject private var taskListViewModel = TaskListViewModel()
        
    var body: some View {
        
        NavigationView {
            VStack {
                Toggle(isOn: $taskListViewModel.showNotDoneOnly) {
                    Text(&quot;Undone only&quot;)
                }.padding()
                List {
                    ForEach(taskListViewModel.filterdTasks.indices, id: \.self) { idx in
                        TaskRow(task: $taskListViewModel.filterdTasks[idx])
                    }
                }
            }.navigationBarTitle(Text(&quot;Tasks&quot;))
        }
    }
}
</code></pre>
<ul>
<li>TaskRow:</li>
</ul>
<pre><code>struct TaskRow: View {
    
    @Binding var task: Task

    var body: some View {
        HStack {
            Text(task.name)
            Spacer()
            Toggle(&quot;&quot;, isOn: $task.done )
        }
    }

}
</code></pre>
<p>With this approach the list is filtered when the user enable the filter but when it is disabled the list lose the previously filtered elements. If I change the code to restore the filter elements like this:</p>
<pre><code>    $showNotDoneOnly.map { notDoneOnly in
        if notDoneOnly {
            return self.filterdTasks.filter { task in
                !task.done
            }
        }
        return self.allTasks
    }.assign(to: \.filterdTasks, on: self)
</code></pre>
<p>The list lose the edited elements.</p>
<p>I've also tried making allTask property to a @Published dictionary by without success. Any idea on how to implement this? Is ther any better approach to do this in SwiftUi?</p>
<p>Thanks</p>
","1629864","","","","","2021-02-16 16:55:17","Filter @Published array in SwiftUI List removes elements in list","<ios><swift><swiftui><swiftui-list>","2","0","","","","CC BY-SA 4.0"
"66019350","1","66019521","","2021-02-03 00:00:45","","0","139","<p>I am using an isLoading Bool in an environment object named authState.</p>
<pre><code>import Foundation
import FirebaseAuth
import Combine

class AuthState: ObservableObject {
    
    enum AuthStateMode {
        case unregistered
        case signedInAnonymously
        case signedInWithEmail
    }
    
    @Published var user: User?
    @Published var authStateMode: AuthStateMode = .unregistered
    @Published var error: AuthError?
    @Published var isLoading: Bool = false
    
    private var cancellables = Set&lt;AnyCancellable&gt;()

    
    let authService = AuthService()
    
    init() {
        authService.authStateSubject.assign(to: &amp;$user)
        $user.map { user -&gt; AuthStateMode in
            if let user = user {
                if user.email != nil { return .signedInWithEmail }
                else if user.uid != &quot;&quot; { return .signedInAnonymously }
                else { return .unregistered }
            } else { return .unregistered }
        }.assign(to: &amp;$authStateMode)
    
    }
    
    func signIn(email: String, password: String) {
        self.isLoading = true
        authService.signIn(email: email, password: password)
            .sink { completion in
                self.isLoading = false
                switch completion {
                case let .failure(error):
                    return self.error = error
                case .finished: return print(&quot;authState.signIn finished&quot;)
                }
            } receiveValue: { _ in }
            .store(in: &amp;cancellables)
    }
    
    func signInAnonymously() {
        isLoading = true
        authService.signInAnonymously()
            .sink { completion in
                self.isLoading = false
                switch completion {
                case let .failure(error):
                    return self.error = error
                case .finished: return
                }
            } receiveValue: { user in
                self.user = user
            }.store(in: &amp;cancellables)
    }
    
    func linkAccount(email: String, password: String) {
        isLoading = true
        authService.linkAccount(email: email, password: password)
            .sink { completion in
                self.isLoading = false
                switch completion {
                case let .failure(error):
                    return self.error = error
                case .finished:
                    return print(&quot;linkAccount finished&quot;)
                }
            } receiveValue: { user in
                self.user = user
            }
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>I have a parent View that uses the authState.isLoading Bool.</p>
<pre><code>import SwiftUI
import Combine

struct SelectUserTypeView: View {
    
    @EnvironmentObject var authState: AuthState

    var body: some View {
        
        NavigationView {
            VStack {
                Spacer()
                if authState.isLoading == true {
                    ProgressView()
                } else if authState.authStateMode == .unregistered {
                    Button { authState.signInAnonymously() }
                        label:{ Text(&quot;Connect&quot;) }
                } else {
                    NavigationLink(
                        destination: GuestPreviewView(),
                        label: { Text(&quot;Join as Guest&quot;) })
                    Spacer()
                    NavigationLink(
                        destination: SignInUpView(viewModel: .init(mode: .signUp)),
                        label: { Text(&quot;Host a Session&quot;) })
                }
                Spacer()
                NavigationLink(destination: RecordingsView(),
                               label: { Text(&quot;Browse Recordings&quot;) })
                Spacer()
                    .navigationBarTitle(Text(&quot;Welcome to Fullres&quot;), displayMode: .inline)
                    .onAppear(perform: authState.signInAnonymously)
            }
        }
    }
}
</code></pre>
<p>I have a child view that also uses the authState.isLoading Bool.</p>
<pre><code>import SwiftUI
import Combine

struct SignInUpView: View {
    
    @EnvironmentObject var authState: AuthState
    @StateObject var viewModel: SignInUpViewModel
    
    var body: some View {
        ZStack {
            if authState.isLoading {
                ProgressView()
            } else if authState.authStateMode == .signedInWithEmail {
                HostPreviewView()
            } else {
                VStack {
                    Spacer()
                    Text(viewModel.heading)
                        .font(.title)
                        .bold()
                        .padding()
                    if let error = authState.error { Text(&quot;\(error.localizedDescription)&quot;) }
                    TextField(&quot;Email&quot;, text: $viewModel.email)
                        .autocapitalization(/*@START_MENU_TOKEN@*/.none/*@END_MENU_TOKEN@*/)
                        .disableAutocorrection(true)
                        .padding()
                    SecureField(&quot;Password&quot;, text: $viewModel.password)
                        .autocapitalization(/*@START_MENU_TOKEN@*/.none/*@END_MENU_TOKEN@*/)
                        .disableAutocorrection(true)
                        .padding()
                    Button(viewModel.signInUpBtnLbl) {signInUpBtnAction()}
                        .font(.title2)
                        .padding()
                    Spacer()
                    Button(viewModel.signInUpModeBtnLbl) {
                        viewModel.mode.toggle()
                    }
                    .padding()
                    Spacer()
                }
            }
        }
    }
    
    func signInUpBtnAction() {
        switch viewModel.mode {
        case .signIn: authState.signIn(email: viewModel.email, password: viewModel.password)
        case .signUp: authState.linkAccount(email: viewModel.email, password: viewModel.password)
        }
    }
}
</code></pre>
<p>It seems that whenever the isLoading Bool switches to true while on the child view, the UI presents the parent view.</p>
<p>Can someone shed some light on how best to go about solving this issue?</p>
","15068510","","15068510","","2021-02-03 00:10:40","2021-02-03 01:12:57","How to use isLoading with a viewModel and an Environment Object","<mvvm><swiftui><combine>","2","2","","","","CC BY-SA 4.0"
"66035450","1","66036283","","2021-02-03 20:49:53","","1","1031","<p>I'm exploring Combine, and this issue has come up and perplexed me no end. My understanding is that a PassthroughSubject will exist as long as the object it is scoped in if a reference to it is stored as <code>AnyCancellable</code>.</p>
<p>In this example of a <code>loginPublisher: PassthroughSubject&lt;User, Error&gt;</code> waiting for updates to the <code>User</code> object, the <code>Subject.Completion.finished</code> block is called immediately after the first value is received.</p>
<pre><code>import SwiftUI
import Combine

class AppDelegate: NSObject, UIApplicationDelegate {
    let appState = AppState()

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -&gt; Bool {
        return true
    }
}

@main
struct SPMDepsTestApp: SwiftUI.App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

    var body: some Scene {
        WindowGroup {
            ContentView().environmentObject(appDelegate.appState)
        }
    }
}

struct User {
    var id: Int
    var name: String
}

class App {
    var currentUser: User? = nil

    func login (user: User) -&gt; Future&lt;User, Error&gt; {
        Future { promise in
            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                self.currentUser = user
                promise(.success(user))
            }
        }
    }
}

class AppState: ObservableObject {
    var app = App()
    var loginPublisher = PassthroughSubject&lt;User, Error&gt;()

    var cancellables = Set&lt;AnyCancellable&gt;()

    init () {

        loginPublisher
                .receive(on: DispatchQueue.main)
                .sink(receiveCompletion: { completion in
                    switch completion {
                        case .failure(let err):
                            dump(err)
                        case .finished:
                            print(&quot;ISSUE: loginPublisher is finished&quot;) // &lt;&lt; Why should this happen immediately?
                    }
                }, receiveValue: { user in
                    dump(user)
                })
                .store(in: &amp;cancellables)

        if let user = app.currentUser {
            loginPublisher.send(user)
        } else {
            app.login(user: User(id: 0, name: &quot;AAA&quot;))
                    .receive(on: DispatchQueue.main)
                    .subscribe(loginPublisher)
                    .store(in: &amp;cancellables)
        }
    }
}
</code></pre>
<p>Differently, If I initialize the App object like so</p>
<pre><code>var App = App(user: user)
</code></pre>
<p>so that <code>app.currentUser != nil</code> then the line</p>
<pre><code> if let user = app.currentUser {
      loginPublisher.send(user) // &lt;&lt; loginPublisher completion (finished) block is never called
 }
 
</code></pre>
<p>Why is <code>PassthroughSubject</code> completing if (seemingly) loginPublisher.send() is not called synchronously?</p>
","4286164","","","","","2021-02-03 21:54:42","Why is PassthroughSubject completing with .finished?","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"66043573","1","66044955","","2021-02-04 10:16:54","","1","674","<p>Thats my model class</p>
<pre><code>struct LoginResponse: Codable {
    let main: LoginModel
}

struct LoginModel: Codable {
    
    let success: Bool?
    let token: String?
    let message: String?
    
    static var placeholder: LoginModel {
        return LoginModel(success: nil, token: nil, message: nil)
    }
    
}
</code></pre>
<p>Thats my service. I have one more issue i am using two map here but when try to remove map.data getting error in dataTaskPublisher. error mention below</p>
<blockquote>
<p>Instance method 'decode(type:decoder:)' requires the types 'URLSession.DataTaskPublisher.Output' (aka '(data: Data, response: URLResponse)') and 'JSONDecoder.Input' (aka 'Data') be equivalent</p>
</blockquote>
<pre><code>class LoginService {
    func doLoginTask(username: String, password: String) -&gt; AnyPublisher&lt;LoginModel, Error&gt; {
        
       
        
      let networkQueue = DispatchQueue(label: &quot;Networking&quot;,
                                           qos: .default,
                                           attributes: .concurrent)
        
        guard let url = URL(string: Constants.URLs.baseUrl(urlPath: Constants.URLs.loginPath)) else {
            fatalError(&quot;Invalid URL&quot;)
         }
        
        print(&quot;uri&quot;, url)
        
        let body: [String: String] = [&quot;username&quot;: username, &quot;password&quot;: password]

                let finalBody = try! JSONSerialization.data(withJSONObject: body)
                var request = URLRequest(url: url)
                request.httpMethod = &quot;POST&quot;
                request.httpBody = finalBody
                request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        
        return URLSession.shared.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: LoginResponse.self, decoder: JSONDecoder())
            .map { $0.main }
            .receive(on: networkQueue)
            .eraseToAnyPublisher()
        
    }
    
}
</code></pre>
<p>Thats my contentView</p>
<pre><code>Button(action: {
                    self.counter += 1
                    print(&quot;count from action&quot;, self.counter)
                    
                
                    
                    func loaginTask() {
                        _ = loginService.doLoginTask(username: &quot;1234567890&quot;, password: &quot;12345&quot;)
                        .sink(
                          receiveCompletion: {
                            print(&quot;Received Completion: \($0)&quot;) },
                          receiveValue: { doctor in
                            print(&quot;hhhhh&quot;)
                          //  print(&quot;yes &quot;, doctor.message as Any)
                            
                          }
                      )
                    }
                })
</code></pre>
<p>Thats my json response</p>
<pre><code>{
    &quot;success&quot;: true,
    &quot;token&quot;: &quot;ed48aa9b40c2d88079e6fd140c87ac61fc9ce78a&quot;,
    &quot;expert-token&quot;: &quot;6ec84e92ea93b793924d48aa9b40c2d88079e6fd140c87ac61fc9ce78ae4fa93&quot;,
    &quot;message&quot;: &quot;Logged in successfully&quot;
}
</code></pre>
","5532139","","","","","2021-02-04 12:15:44","Unable to get the response from URL using combine with SwiftUI","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"66050438","1","66053430","","2021-02-04 17:09:06","","-1","81","<p>I have an object named myObjectType, how do I convert myObjectType to AnyPublisher&lt;myObjectType, Never&gt; ?</p>
<pre><code>   func getDemoTest() -&gt; AnyPublisher&lt;myObjectType, Never&gt; {
        return ????????? ///How do I convert the myObjectType to the AnyPublisher&lt;myObjectType, Never&gt; ?
    }
</code></pre>
","5365534","","","","","2021-02-04 20:35:10","How to convert myObject to AnyPublisher<myObject, Never>?","<swift>","1","4","","","","CC BY-SA 4.0"
"66055354","1","66055648","","2021-02-04 23:23:39","","9","2971","<pre><code>func testData()-&gt;AnyPublisher&lt;DemoObject, APIError&gt; {

    var data = DummyData().decodeClaimDetails()!
    
    return (Just(data).eraseToAnyPublisher(),
            APIError.httpError(200))
    
}
</code></pre>
<p>I got this error.
Cannot convert return expression of type '(AnyPublisher&lt;DemoObject, Never&gt;, APIError)' to return type 'AnyPublisher&lt;DemoObject, APIError&gt;'</p>
<p>How can I return a type that is AnyPublisher&lt;DemoObject, APIError&gt;?</p>
","5365534","","","","","2021-12-22 11:15:05","Cannot convert return expression of type '(AnyPublisher<DemoObject, Never>, APIError)' to return type 'AnyPublisher<DemoObject, APIError>'","<swift>","1","0","","","","CC BY-SA 4.0"
"66071387","1","66072284","","2021-02-05 22:20:53","","0","329","<p>I have an object called <code>ProcessorStack</code> which contains zero or more child <code>Processor</code> items. The <code>ProcessorStack</code> and the individual <code>Processor</code> objects each have only a single method:</p>
<p><code>process(input: Value) -&gt; Future&lt;Value, Never&gt;</code></p>
<p>I would like the return value to be a <code>Future</code> rather than <code>AnyPublisher</code> to clearly indicate that the caller should only expect a single result to be emitted. Other objects only have access to the <code>ProcessorStack</code>, not its <code>Processor</code> children. Here's what I want to happen:</p>
<ol>
<li>An object calls the <code>ProcessorStack</code>:
<pre><code>stack.process(value: someValue).sink { result in
    // Do something with the result
}.store(in: &amp;subscriptions)
</code></pre>
</li>
<li>The <code>ProcessorStack</code> chains all of its child <code>Processor</code> objects together using a reduce operation and returns the final result via the <code>Future</code>:
<pre><code>func process(value: Value) -&gt; Future&lt;Value, Never&gt; {
    guard !childProcessors.isEmpty else {
        return Future { $0(.success(value)) }
    }
    let just = Just(value).eraseToAnyPublisher()
    childProcessors.reduce(just) { (publisher, processor) -&gt; AnyPublisher&lt;Value, Never&gt; in
        publisher.flatMap { processor.process(value: $0).eraseToAnyPublisher() }
    }
    // Here's where I'm lost.
}
</code></pre>
</li>
</ol>
<p>I cannot for the life of me figure out how to execute the asynchronous reduce chain and then return the result as a <code>Future</code>. If I wrap the whole reduce operation in a <code>Future</code> initializer, I'm left holding an <code>AnyPublisher&lt;Value, Never&gt;</code> which I somehow have to get to execute and then the result of that get passed to the <code>Future</code>'s completion closure. I can't <code>sink</code> it inside the <code>Future</code>'s closure, because I have to hold on to the cancellable returned from that or the whole process immediately halts. I can't FlatMap the result into a Future, because that has the type <code>FlatMap&lt;AnyPublisher&lt;Value, Never&gt;, Future&lt;Value, Never&gt;&gt;</code>. I can accomplish all of this if I just make the outer return type <code>AnyPublisher&lt;Value, Never&gt;</code>, but I was really hoping to have the <code>Future</code> semantics for subscribers.</p>
","630517","","","","","2021-02-06 00:18:05","Swift Combine: Do asynchronous work in a Future?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"66075000","1","66078973","","2021-02-06 08:39:33","","2","1397","<p>I have a publisher which would need re-evaluating on day change, but should continue to emit values at any other time.</p>
<p>As such, I thought I could use a <code>NotificationCenter</code> publisher for the <code>UIApplication.significantTimeChangeNotification</code> notification and combine it with my publisher such that the combine emission process would re-run on either on data change or day change and hence re-evaluate the map filter. See a rough outline of that code below.</p>
<p>The problem is that there is no published event by <code>NotificationCenter</code> at the point in time that this is setup and hence, none of the following <code>map</code> etc calls actually evaluate. <code>merge(with:)</code> won't work as the two publishers publish different types, but <code>combineLatest(_:)</code> and <code>zip(_:)</code> both won't emit events until both publishers have emitted a single event.</p>
<p>I can validate that my code operates as expected by adding <code>NotificationCenter.default.post(name: UIApplication.significantTimeChangeNotification, object: nil)</code> after this code, but that is undesirable due to it potentially signalling other areas of the app that an actual time change has occurred when it hasn't</p>
<pre class=""lang-swift prettyprint-override""><code>private func todaysDate() -&gt; String {
    let formatter = DateFormatter()
    formatter.dateFormat = &quot;YYYY-MM-dd&quot;
    return formatter.string(from: Date())
}

@Published var entities: [MyEntity]

let dayChangePublisher = NotificationCenter.default
    .publisher(for: UIApplication.significantTimeChangeNotification)

$entities.combineLatest(dayChangePublisher)
    .map(\.0) // Only pass on the entity for further operations
    .map { entities -&gt; MyEntity? in
        let today = todaysDate()
        return entities?.first(where: { $0.id == today })
    }
    ...remainder of combine code

</code></pre>
<p>Can this combination of publishers and evaluation of events occur with the current Swift combine framework? Like the behaviour I'd expect from <code>merge(with:)</code> but where the publishers emit two different types.</p>
<p>edit:
I found one solution where I map the notification publisher to a nil array</p>
<pre class=""lang-swift prettyprint-override""><code>let dayChangePublisher = NotificationCenter.default
    .publisher(for: UIApplication.significantTimeChangeNotification)
    .map { _ ➝ [MyEntity]? in
        return nil
    }
</code></pre>
<p>And then use <code>merge</code> and <code>compactMap</code> to avoid passing any nil values on</p>
<pre class=""lang-swift prettyprint-override""><code>let mergedPub = repo.$entities
        .merge(with: dayChangePublisher)
        .compactMap { entity -&gt; MyEntity? in
            let today = todaysDate()
            return entities?.first { $0.id == today }
        }
        .share()
</code></pre>
<p>It works, but maybe a bit cumbersome if anyone has a better solution?</p>
","1602729","","1602729","","2021-02-06 10:05:29","2021-03-17 13:33:35","Swift combine publishers where one hasn't sent a value yet","<swift><combine>","1","0","2","","","CC BY-SA 4.0"
"66081123","1","66092335","","2021-02-06 19:39:21","","2","363","<p>I'm trying to implement an MVVM architecture as described here:</p>
<p><a href=""https://medium.com/better-programming/swiftui-and-coredata-the-mvvm-way-ab9847cbff0f"" rel=""nofollow noreferrer"">https://medium.com/better-programming/swiftui-and-coredata-the-mvvm-way-ab9847cbff0f</a></p>
<p>But I'm getting a run-time error in this file and cannot figure out where to add the sort descriptor:</p>
<pre><code>import Foundation
import CoreData
import Combine
import UIKit

class ItemsStorage: NSObject, ObservableObject {
    var items = CurrentValueSubject&lt;[Item], Never&gt;([])
    private let itemFetchController: NSFetchedResultsController&lt;Item&gt;
    
    //SINGLETON INSTANCE
    static let shared: ItemsStorage = ItemsStorage()  ///Run time error: Thread 1: &quot;An instance of NSFetchedResultsController requires a fetch request with sort descriptors&quot;
    
    private override init() {
        
        /// This line doesn't solve the issue
        let sort = NSSortDescriptor(key: &quot;name_&quot;, ascending: true)
        
        itemFetchController = NSFetchedResultsController(
        
        fetchRequest: Item.fetchRequest(),
        managedObjectContext: PersistenceController.shared.container.viewContext,
        sectionNameKeyPath: nil, cacheName: nil
        )
        
        /// This line doesn't solve the issue
        itemFetchController.fetchRequest.sortDescriptors = [sort]
        
        super.init()
        
        itemFetchController.delegate = self
        
        do {
            try itemFetchController.performFetch()
            items.value = itemFetchController.fetchedObjects ?? []
        } catch {
            NSLog(&quot;Error: could not fetch objects&quot;)
        }
    }
    
    func add(){
        
    }
    
    func update(withID id: UUID) {
        
    }
    
    func delete(id: UUID) {
        
    }
}

extension ItemsStorage: NSFetchedResultsControllerDelegate  {
    public func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {
        guard let items = controller.fetchedObjects as? [Item] else { return }
        NSLog(&quot;Context has changed, reloading items ...&quot;)
        self.items.value = items
    }
}
</code></pre>
","3762119","","14351818","","2021-02-06 19:45:07","2021-02-08 08:34:12","How do I correctly insert a sort descriptor for this SwiftUI CoreData model?","<swift><core-data><mvvm><swiftui><nsfetchrequest>","1","0","","","","CC BY-SA 4.0"
"66085127","1","66089919","","2021-02-07 06:23:36","","1","586","<p>I have a function that needs to only be executed once at time. I'm trying to avoid a function to be called while it hasn't completed the last request. Here's what I'm trying to:</p>
<pre><code>import Combine
import Foundation
import PlaygroundSupport

var publisher1 = PassthroughSubject&lt;Bool, Never&gt;()
var publisher2 = PassthroughSubject&lt;Void, Never&gt;()
var cancellable = Set&lt;AnyCancellable&gt;()

func scheduleNotifications() -&gt; Future &lt;Void, Never&gt; {
    Future() { promise in
        print(&quot;Started scheduling... \(Date())&quot;)

        DispatchQueue.main.asyncAfter(deadline: .now() + 10) {
            promise(.success(()))
        }
    }
}

Publishers.Merge(
    publisher1
        .filter { $0 }
        .map { _ in },
    publisher2
)
.flatMap { scheduleNotifications() }
.sink { print(&quot;Complete: \(Date())&quot;) }
.store(in: &amp;cancellable)

PlaygroundPage.current.needsIndefiniteExecution = true
</code></pre>
<p>If <code>publisher1</code> and <code>publisher2</code> fire, then <code>scheduleNotifications()</code> is called. However, before the function finishes, <code>publisher1</code> could fire and call <code>scheduleNotifications()</code>:</p>
<pre><code>DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
    publisher1.send(true)
}

DispatchQueue.main.asyncAfter(deadline: .now() + 4) {
    publisher1.send(true)
}
</code></pre>
<p>This prints:</p>
<pre><code>Started scheduling... 2021-02-07 15:50:25 +0000
Started scheduling... 2021-02-07 15:50:27 +0000
Complete: 2021-02-07 15:50:35 +0000
Complete: 2021-02-07 15:50:38 +0000
</code></pre>
<p>This is a problem because the <code>scheduleNotifications</code> is erasing all notifications before adding them. So the second request that fired one second later is erasing all the notifications the first request is still busy building.</p>
<p>Is there a way to tell the 2nd fire to hold on until <code>scheduleNotifications()</code> has completed any currently on going work it has finished yet?</p>
","235334","","235334","","2021-02-07 15:51:39","2021-02-07 15:57:31","How to queue or wait until last Combine request done?","<swift><combine>","2","6","","","","CC BY-SA 4.0"
"66089669","1","66106239","","2021-02-07 15:33:39","","-2","229","<p>I have 2 independent <code>ObservableObject</code>s called <code>ViewModel1</code> and <code>ViewModel2</code>.</p>
<p><code>ViewModel2</code> has an array of strings:</p>
<p><code>@Published var strings: [String] = []</code>.</p>
<p>Whenever that array is modified i want <code>ViewModel1</code> to be informed.</p>
<p>What's the recommended approach to achieve this?</p>
","294661","","","","","2021-02-08 17:16:28","Data communication between 2 ObservableObjects","<swift><swiftui><combine><observableobject><data-communication>","2","8","","","","CC BY-SA 4.0"
"66101210","1","66107017","","2021-02-08 11:59:38","","0","575","<p>I would like to perform a recursive once retry with Swift Combine when the server responds with a certain message (in the example a 401 error). The data in that response alters a model, which allows for a single retry.</p>
<p>I wrote a small extension for the result type that was used pre iOS 13</p>
<pre class=""lang-swift prettyprint-override""><code>extension URLSession {
    typealias HTTPResponse = (response: HTTPURLResponse, data: Data)
    typealias DataTaskResult = ((Result&lt;HTTPResponse, Error&gt;) -&gt; Void)

    func dataTask(with request: URLRequest, completionHandler: @escaping DataTaskResult) -&gt; URLSessionDataTask {
        self.dataTask(with: request) { (data, response, error) in
            if let error = error {
                completionHandler(.failure(error))
            }
            completionHandler(.success((response as! HTTPURLResponse, data!)))
        }
    }
}
</code></pre>
<p>I used this extension to do the following</p>
<pre class=""lang-swift prettyprint-override""><code>class Account {
    enum CommunicationError: Swift.Error {
        case counterOutOfSync
    }

    var counter: Int = 0

    func send(isRetry: Bool = false, completionBlock: @escaping URLSession.DataTaskResult) {
        var request = URLRequest(url: URL(string: &quot;https://myserver.com/fetch/&quot;)!)
        request.setValue(&quot;\(counter)&quot;, forHTTPHeaderField: &quot;MESSAGE-COUNTER&quot;)
        request.httpMethod = &quot;POST&quot;

        URLSession.shared.dataTask(with: request) { [weak self] taskResult in
            do {
                let taskResponse = try taskResult.get()
                if taskResponse.response.statusCode == 401 {
                    if isRetry { throw CommunicationError.counterOutOfSync }

                    // Counter is resynced based on taskResponse.data
                    self?.send(isRetry: true, completionBlock: completionBlock)
                } else {
                    completionBlock(.success(taskResponse))
                }
            } catch {
                completionBlock(.failure(error))
            }
        }.resume()
    }
}
</code></pre>
<p>You can see the recursive call in the function. I would like to do the same with Combine, but I don't know how to. This is as far as I get</p>
<pre class=""lang-swift prettyprint-override""><code>func combine(isRetry: Bool = false) -&gt; AnyPublisher&lt;Data, Error&gt; {
    var request = URLRequest(url: URL(string: &quot;https://myserver.com/fetch/&quot;)!)
    request.setValue(&quot;\(counter)&quot;, forHTTPHeaderField: &quot;MESSAGE-COUNTER&quot;)
    request.httpMethod = &quot;POST&quot;

    return URLSession.shared.dataTaskPublisher(for: request).tryMap {
        let response = $0.response as! HTTPURLResponse
        if response.statusCode == 401 {
            if isRetry { throw CommunicationError.counterOutOfSync }

            // Counter is resynced based on $0.data
            return self.combine(isRetry: true)
        } else {
            return $0.data
        }
    }.eraseToAnyPublisher()
}
</code></pre>
<p>Any help is appreciated</p>
","5530076","","","","","2021-02-08 18:09:11","Swift combine recursive retry","<ios><swift><http><recursion><combine>","1","2","","","","CC BY-SA 4.0"
"66103041","1","66104576","","2021-02-08 13:55:58","","1","134","<p>I'm trying to implement a background session for my app, but when trying to start the session by a press of a button, I'm getting following error:</p>
<pre><code>WKExtendedRuntimeSession hit internal error. Error Domain=com.apple.CarouselServices.SessionErrorDomain Code=17 &quot;startSession cannot be called on a scheduled session&quot; UserInfo={NSLocalizedDescription=startSession cannot be called on a scheduled session}
</code></pre>
<p>Any idea why ? This is my code. I tried googling the error but I cab't find a solution anywhere. For background session I have used the background modes capability and I have selected the smart alarm session type (no other selections):</p>
<pre><code>import SwiftUI

final class ExtendedRunTimeService {
    
    private var session: WKExtendedRuntimeSession?
    
    func start() {
        guard session?.state != .running else { return }
        if nil == session || session?.state == .invalid {
            session = WKExtendedRuntimeSession()
        }
        print(&quot;session started&quot;)
        session?.start()
    }
    
    func stop() {
        session?.invalidate()
    }
    
}
</code></pre>
<p>And I'm starting it through:</p>
<pre><code>import Combine

final class ClockDataViewModel: ObservableObject {
    
    @Published var motionValues = MotionValues()
    @Published var healthValues = HealthValues()
    
    var motionService = MotionService()
    var healthService = HealthService()
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    var backGroundService = ExtendedRunTimeService()
    
    init() {
        motionService.$motionValues
            .combineLatest(healthService.$healthValues)
            .sink(receiveValue: {
                self.motionValues = $0
                self.healthValues = $1
            })
            .store(in: &amp;cancellables)
    }
    
    func startUpdates() {
        backGroundService.start()
        motionService.startMotionUpdates()
        healthService.fetchHeartRateData(quantityTypeIdentifier: .heartRate)
    }
    
    func stopUpdates() {
        backGroundService.stop()
        motionService.stopMotionUpdates()
        healthService.stopFetchingHeartRateData()
    }
    
</code></pre>
","4795917","","","","","2021-02-08 15:33:04","WKExtendedRuntimeSession hit internal error: 'startSession cannot be called on a scheduled session'","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"66129348","1","66129484","","2021-02-10 00:43:35","","1","320","<p>So I'm very new to swift so I might be getting this all wrong.</p>
<p>I'm learning to work with combine so I used the playground to log at an interval like so</p>
<pre><code>var cancellable:AnyCancellable? = Timer.publish(every: 1, on: .main, in: .default)
.autoconnect()
.sink {
    print($0)
}

PlaygroundPage.current.needsIndefiniteExecution = true
</code></pre>
<p>It's very simple and it works like I expect it to, printing a log every second.</p>
<p>Now when I create a new iOS project in Xcode it doesn't seem to work and I can't figure out why. From a blank project, I simply added this in the ContentView</p>
<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
    func test() {
        var cancellable: AnyCancellable?
        cancellable = Timer.publish(every: 1, on: .main, in: .default)
        .autoconnect()
        .sink {
            print($0)
        }
    }
    
    var body: some View {
        VStack {
            Text(&quot;Hello, world!&quot;)
                .padding()
        }
    }
    
    init() {
        test()
    }
}
</code></pre>
<p>All of a sudden, it doesn't work and the log won't print. I'm sure it's something dumb that I'm not understanding but I've been looking at this forever now. My real case is with a network call that is not running so I tried simplifying as much as I can and this is as simple as I could get.</p>
<p>Any help appreciated!</p>
<p>Thanks!</p>
","7759526","","","","","2021-02-10 01:02:05","Swift combine not running properly in iOS app","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"66141387","1","67892456","","2021-02-10 16:57:28","","6","420","<p>I am using <strong>List</strong> to show the models in the main view. When I update the model in detail view it is not updated in detail view.</p>
<p>When I don't use <code>List</code>, detail view is updated. What am I missing for <code>List</code>?</p>
<hr />
<pre><code>struct Person: Identifiable {
  var id: UUID
  var name: String
}

class PersonModel: ObservableObject {
  @Published var persons: [Person] = [Person(id: UUID(), name: &quot;Ege&quot;)]
}

struct PersonListView: View {
  
  @StateObject private var personModel = PersonModel()
  
  var body: some View {
    NavigationView {
      List {
        ForEach(personModel.persons) { person in
          NavigationLink(destination: PersonDetailView(person: person).environmentObject(personModel)) {
            Text(person.name)
          }
        }
      }
      .navigationTitle(&quot;Persons&quot;)
    }
  }
}

struct PersonDetailView: View {
  
  let person: Person
  @EnvironmentObject var personModel: PersonModel
  
  var body: some View {
    VStack {
      Text(person.name)
      
      Button(action: {
        let personIndex = personModel.persons.firstIndex(where: { $0.id == person.id })!
        personModel.persons[personIndex].name = &quot;Updated Name&quot;
      }) {
        Text(&quot;Update&quot;)
      }
    }
    .navigationTitle(&quot;Person Detail&quot;)
  }
}
</code></pre>
<p>Workarounds that I used for List:</p>
<ul>
<li>Using custom binding function for NavigationLink.</li>
</ul>
<p>Example code:</p>
<pre><code>//1
private func binding(for person: Person) -&gt; Binding&lt;Person&gt; {
  let personIndex = personModel.persons.firstIndex(where: { $0.id == person.id }) ?? 0
  return $personModel.persons[personIndex]
}
//2
NavigationLink(destination: PersonDetailView(person: binding(for: person)))
//3
@Binding var person: Person //DetailView
</code></pre>
<ul>
<li>Using another <code>@State</code> in detail view which is initialized with passed
model in onAppear method.</li>
</ul>
","13886048","","13886048","","2021-03-28 09:52:45","2021-06-08 18:09:49","Detail View is not updated when the model is updated (Using List) SwiftUI","<swift><swiftui><combine><swiftui-list>","3","2","2","","","CC BY-SA 4.0"
"66144518","1","66146569","","2021-02-10 20:27:31","","-1","248","<p>I want to synthesize text. I have an array of sentences and array of pauses, that I wish between these sentences.</p>
<p>What was the thought
<code>Synthesize -&gt; start the timer, timer fires after provided time -&gt; Synthesize -&gt; start the timer -&gt; Synt...</code></p>
<p>By chance, I've noticed that timer fires the lesser time first, instead of executing and setting up timers in sequence. The loop doesn't wait till synthesizer finished to pronounce, it continues to run.</p>
<p>How to work out that synthesizer pronounces sentences with provided pauses, and in order?</p>
<pre><code>import SwiftUI

struct KingsSpeechView: View {
    @ObservedObject var speaker = Speaker()
    @State private var subtitles = &quot;&quot;

    @State private var currentStepIndex = 0

    let kingsSpeech = [
        &quot;Hello. Let's start the Game! Let the hunger Games Begin...Whoa-Whoa. Here're are the rules on the screen.&quot;,
        &quot;Okey, now that you know the rules, chill out. Let's play another game.&quot;,
        &quot;You say Hi, I say Ho.&quot;,
        &quot;Hooo&quot;,
        &quot;Hooo&quot;
     ]
     var pauses = [0.0, 20.0, 90.0, 40.0, 40.0]
     // try to change into this
     // var pauses = [0.0, 20.0, 10.0, 5.0, 5.0]
     // the sequence of execution is completely different
     // the ones that has less value, will execute first
     // While I expected it to execute in order it is in array, instead it runs as it runs (wants)
     // (or maybe it's the case it's just one timer for all)
     // How to prevent loop from continuing to new iteration until the speech is not pronounced?

    var body: some View {
        VStack {
            Text(subtitles)
                .padding(.bottom, 50)
                .padding(.horizontal, 20)
        
        
            Button(&quot;Play&quot;) {
                playSound()
            }
        }
    }

    func playSound() {

        for step in 0..&lt;kingsSpeech.count {
            let timer = Timer.scheduledTimer(withTimeInterval: pauses[step], repeats: false) { timer in

                subtitles = kingsSpeech[step]
                speaker.speak(&quot;\(kingsSpeech[step])&quot;)
                print(&quot;I am out&quot;)
                currentStepIndex += 1


                // I've tried to stop a loop from moving on, before the speech had finished to pronounce 
                // with some sort of a condition maybe; by index or by identifying if the synthesizer is speaking
                // but it even turned out that timer executes completely different, look in time arrays above
                // while speaker.semaphoreIndex == step {
                //     print(&quot;still waiting&quot;)
                // }
                // while speaker.synth.isSpeaking {
                //
                // }

            }
        }
    }
}
</code></pre>
<p>...</p>
<pre><code>import AVFoundation
import Combine

class Speaker: NSObject, ObservableObject, AVSpeechSynthesizerDelegate {
    let synth = AVSpeechSynthesizer()
    // started to try something with simophore, but didn't understand how to implement it
    var semaphore = DispatchSemaphore(value: 0)
    var semaphoreIndex = 0
    

    override init() {
        super.init()
        synth.delegate = self
    }

    func speak(_ string: String) {
        let utterance = AVSpeechUtterance(string: string)
        utterance.voice = AVSpeechSynthesisVoice(language: &quot;en-GB&quot;)
        utterance.rate = 0.4
        synth.speak(utterance)
    }
    
}

extension Speaker {
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance) {
        print(&quot;all done&quot;)
        semaphore.signal()
        semaphoreIndex += 1
    }
}
</code></pre>
","11419259","","11419259","","2021-02-10 23:11:59","2021-02-11 05:21:37","Executing text-to-speech in order","<swift><timer><avfoundation><avspeechsynthesizer><avspeechutterance>","2","3","1","","","CC BY-SA 4.0"
"66152490","1","66157775","","2021-02-11 10:02:10","","0","172","<p>Swift 5.x iOS 14</p>
<p>Wrote this code, trying understand the sequence publisher in the Combine Framework.</p>
<pre><code>struct SwiftUIViewH: View {
  @State var textColor = Color.black
  var body: some View {
    Text(&quot;Hello, World!&quot;)
      .foregroundColor(textColor)
      .onAppear { 
        let initialSequence = [Color.red, Color.blue, Color.green, Color.orange]
        _ = initialSequence.publisher
              .delay(for: 1.0, scheduler: RunLoop.main)
              .sink {
                textColor = $0
                print($0)
              }
        }
  }
}
</code></pre>
<p>It works, in that I goes thru the list in milli-seconds and changes the colour of hello World if I don't try and slow the process down with a delay? But with delay in place as you see here, it does nothing it seems... <strong>the code above is broken</strong>?</p>
","3069232","","","","","2021-02-11 15:32:21","Why does .delay break this short piece of code using Combine framework in swift","<ios><swift><sequence><combine>","1","0","","","","CC BY-SA 4.0"
"66164898","1","66165075","","2021-02-12 00:24:52","","17","6842","<p>I have a SwiftUI app with SwiftUI App life cycle. I'm trying to setup a standard way to add
typing debounce to TextFields. Ideally, I'd like to create my own TextField modifier that
can easily be applied to views that have many textfields to edit. I've tried a bunch of
ways to do this but I must be missing something fundamental. Here's one example. This
does not work:</p>
<pre><code>struct ContentView: View {

    @State private var searchText = &quot;&quot;
    
    var body: some View {
    
        VStack {
            Text(&quot;You entered: \(searchText)&quot;)
                .padding()
            TextField(&quot;Enter Something&quot;, text: $searchText)
                .frame(height: 30)
                .padding(.leading, 5)
                .overlay(
                    RoundedRectangle(cornerRadius: 6)
                        .stroke(Color.blue, lineWidth: 1)
                )
                .padding(.horizontal, 20)
                .onChange(of: searchText, perform: { _ in
                    var subscriptions = Set&lt;AnyCancellable&gt;()
                
                    let pub = PassthroughSubject&lt;String, Never&gt;()
                    pub
                        .debounce(for: .seconds(1), scheduler: DispatchQueue.main)
                        .collect()
                        .sink(receiveValue: { t in
                            self.searchText = t.first ?? &quot;nothing&quot;
                        } )
                        .store(in: &amp;subscriptions)
                })
        }
    }
}
</code></pre>
<p>Any guidance would be appreciated. Xcode 12.4, iOS 14.4</p>
","2698617","","","","","2022-07-16 12:25:20","SwiftUI Combine Debounce TextField","<ios><xcode><swiftui><combine>","4","0","8","","","CC BY-SA 4.0"
"66176535","1","66176703","","2021-02-12 17:39:14","","1","701","<p>I have a generic function used to send requests to the server.
Now before I send a request I need to check if the session token is expired and update it if needed.</p>
<p>my function looks like this<br />
<code>func upload&lt;T: Decodable&gt;(some parameters here) -&gt; AnyPublisher&lt;T, Error&gt;</code></p>
<p>I wanted to check and update the token inside that function before calling the main request but in this case, I can not return <code> AnyPublisher&lt;T, Error&gt;</code></p>
<pre><code>func upload&lt;T: Decodable&gt;(some parameters here) -&gt; AnyPublisher&lt;T, Error&gt; {
    if shouldUpdateToken {
        let request = // prepare request
        let session = // prepare session
        return session.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: SomeTokenObject.self, decoder: JSONDecoder())
            // here I wanted to save token and continue with 
            // the previous request 
            // but using .map, .flatMap, .compactMap will not return needed publisher
            // the error message I'll post below
            .map {
                // update token with $0
                // and continue with the main request
            }
    } else {
        return upload() // this will return AnyPublisher&lt;T, Error&gt; so it's ok here
    }
}
</code></pre>
<p>This error I get when using .flatMap
<code>Cannot convert return expression of type 'Publishers.FlatMap&lt;AnyPublisher&lt;T, Error&gt;, Publishers.Decode&lt;Publishers.MapKeyPath&lt;URLSession.DataTaskPublisher, JSONDecoder.Input&gt;, SomeTokenObject, JSONDecoder&gt;&gt;' (aka 'Publishers.FlatMap&lt;AnyPublisher&lt;T, Error&gt;, Publishers.Decode&lt;Publishers.MapKeyPath&lt;URLSession.DataTaskPublisher, Data&gt;, SomeTokenObject, JSONDecoder&gt;&gt;') to return type 'AnyPublisher&lt;T, Error&gt;'</code><br />
And similar for .map.</p>
<p>I added another function that was returning AnyPublisher&lt;SomeTokenObject, Error&gt; and thought to use inside <code>shouldUpdateToken</code> like that</p>
<pre><code>func upload&lt;T: Decodable&gt;(some parameters here) -&gt; AnyPublisher&lt;T, Error&gt; {
    if shouldUpdateToken {
        return refreshToken() // returns AnyPublisher&lt;Void, Error&gt;
            // now I need to continue with original request
            // and I'd like to use something like
            .flatMap { result -&gt; AnyPublisher&lt;T, Error&gt;
                upload()
            }
            // but using .map, .flatMap, .compactMap will not return needed publisher
            // the error message I'll post below
            
    } else {
        return upload() // this will return AnyPublisher&lt;T, Error&gt; so it's ok here
    }
}
</code></pre>
<p>for flatMap:
<code>Cannot convert return expression of type 'Publishers.FlatMap&lt;AnyPublisher&lt;T, Error&gt;, AnyPublisher&lt;Void, Error&gt;&gt;' to return type 'AnyPublisher&lt;T, Error&gt;'</code><br />
for map: <code>Cannot convert return expression of type 'Publishers.Map&lt;AnyPublisher&lt;Void, Error&gt;, AnyPublisher&lt;T, Error&gt;&gt;' to return type 'AnyPublisher&lt;T, Error&gt;'</code></p>
<p>Maybe I need to change to another approach?
I have a lot of requests all around the app so updating the token in one place is a good idea, but how can it be done?</p>
<p>Here is the <code>refreshToken()</code> function</p>
<pre><code>func refreshToken() -&gt; AnyPublisher&lt;Void, Error&gt; {
        let request = ...
        let session = ...
        return session.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: SomeTokenObject.self, decoder: JSONDecoder())
            .map {
                // saved new token
            }
            .eraseToAnyPublisher()
    }
</code></pre>
","1507356","","1507356","","2021-02-12 18:00:39","2021-02-12 18:00:39","How to combine two requests but return generic publisher? Details below","<swift><generics><combine><publisher>","1","3","","","","CC BY-SA 4.0"
"66184006","1","66184274","","2021-02-13 10:19:51","","1","127","<p>I want to update button, from &quot;pause&quot; sign, back to &quot;play&quot; sign; when the class finishes to do the speech task. Current code doesn't do any change... What's wrong?</p>
<p>Can I do <code>.onChange</code> with condition? (only if change is specific)</p>
<pre><code>struct SwiftUIView: View {
    
    var speaker = Speaker()
    @State var isPlaying = false
        
    var body: some View {

        VStack {
            Button(action: {
                
                if isPlaying {
                    isPlaying.toggle()
                    speaker.synth.pauseSpeaking(at: .immediate)
                } else {
                    isPlaying.toggle()
                    // continue playing here if it was paused before, else ignite speech utterance
                    if speaker.synth.isPaused {
                        speaker.synth.continueSpeaking()
                    } else {
                        speaker.speak(&quot;Holly Molly bro&quot;)
                    }
                    
                }
            }, label: {
                Text(isPlaying ? &quot;pause&quot; : &quot;play&quot;)
            })
            
            
        }
        .onChange(of: speaker.hasStopped, perform: { value in
            isPlaying = false
            print(&quot;Who asked for change?&quot;)
        })
        
    }
}
</code></pre>
<p>...</p>
<pre><code>import AVFoundation
import Combine

class Speaker: ObservableObject, AVSpeechSynthesizerDelegate {
    let synth = AVSpeechSynthesizer()
    
    @Published var hasStopped: Bool = false

    func speak(_ string: String) {
            hasStopped = false
            
            let utterance = AVSpeechUtterance(string: string)
            utterance.voice = AVSpeechSynthesisVoice(language: &quot;en-GB&quot;)
            utterance.rate = 0.4
            synth.speak(utterance)
        }
    
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance) {
            print(&quot;all done&quot;)
            
            hasStopped = true
        }
}
</code></pre>
","11419259","","11419259","","2021-02-13 11:29:31","2021-02-22 03:04:57","How to update SwiftUI button after event in external class?","<swift><swiftui><combine>","2","2","","","","CC BY-SA 4.0"
"66186284","1","66186499","","2021-02-13 14:37:45","","2","307","<p>This is what I am trying to achieve:</p>
<pre><code>class MyVC: UIViewController {
    @State var myBoolState: Bool = false

    private var subscribers = Set&lt;AnyCancellable&gt;()

    override func viewDidLoad() {
        super.viewDidLoad()

        myBoolState.sink { value in .... }.store(in:&amp;subscribers)
    }

    func createTheView() {
        let vc = UIHostingController(rootView: MySwiftUIView(myBoolState: $myBoolState))
        self.navigationController!.pushViewController(vc, animated: true)
    }
}

struct MySwiftUIView: View {
    @Binding var myBoolState: Bool

    var body: some View {
          Button(action: {
              myBoolState = true
          }) {
              Text(&quot;Push Me&quot;)
          }

    }

}
</code></pre>
<p>But the above of course does not compile.</p>
<p>So the question is: can I somehow declare a published property inside a view controller, pass it to a SwiftUI View and get notified when the SwiftUI view changes its value?</p>
","251824","","","","","2021-02-13 15:00:23","Create a Publishable property in a view controller, pass it to a SwiftUI View and listen to changes inside view controller?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66188140","1","66188633","","2021-02-13 17:52:11","","2","1423","<p>I just want to ask you. Do I need <code>ObservableObject</code> as an inheritance in viewModel with UIKit and Combine (without SwiftUI)? I tried it without inheritance and it works. Should I use it or not?</p>
<p>Thanks for your responses.</p>
","11746995","","","","","2021-02-13 18:41:53","Do I need ObservableObject with UIKit?","<swift><uikit><observable><combine>","1","0","","","","CC BY-SA 4.0"
"66193060","1","66201291","","2021-02-14 06:43:09","","0","186","<p>I'm having trouble wrapping my head around how to use Combine in SwiftUI. I'm accustomed to using key-value observation in AppKit an UIKit because view controllers don't need to know about each other and can just react to some global objects that help determine state.</p>
<p>For example, in an AppKit/UIKit app, I would create a global state object like this:</p>
<pre><code>//Global State file
@objc class AppState: NSObject {
  @objc dynamic var project: Project?
}

//Create an instance I can access anywhere in my app
let app = AppState()
</code></pre>
<p>Then in a view controller, I can get notified of any changes to my app-wide project instance and react accordingly:</p>
<pre><code>//View Controller
class MyViewController: NSViewController{
  var observerProject: NSKeyValueObservation?

  override func viewDidLoad() {
    observerProject = app.observe(\.project) { object, change in
      self.refreshData()
    }
  }
  
  func refreshData(){
    //Query my persistent store and update my UI
  }
}
</code></pre>
<p>What is the Combine/SwiftUI analog to this?</p>
<p>Do I need to create a Publisher and then listen to my global object changes? If so, how do I make my Core Data <code>@FetchRequest</code> (whose predicate includes my global <code>Project</code> object) respond in real-time?</p>
<p>I've done things the old way for so long that this transition to SwiftUI/Combine is rather confusing to me. 🙂</p>
","1142348","","","","","2021-02-15 00:32:13","Converting Key-Value Observation in AppKit/UIKit to Combine and SwiftUI","<core-data><swiftui><key-value-observing><combine>","1","0","1","","","CC BY-SA 4.0"
"66201492","1","66202115","","2021-02-15 00:33:07","","2","451","<p>So I have this combine publisher that say emits integers -  <code>1,2,3,4,5,6,7,8,9,10,11 ....</code></p>
<p>These integers are though not always there. They are generated on the fly and sent to the publisher.</p>
<p>I am aware of the collect operator which when say called as .collect(5) gives me - <code>[1,2,3,4,5], [6,7,8,9,10], ...</code></p>
<p>What I am instead looking for is somewhat like buffer and collect combined - <code>[1,2,3,4,5], [2,3,4,5,6], [3,4,5,6,7] ...</code>.</p>
<p>Is there any way to do it without writing a custom operator? And if a custom operator is the way to go, can you provide some guidance towards that, I have not written a custom operator before. I hope what I am asking for is clear from the examples.</p>
<p>Thanks</p>
<h1>Edit</h1>
<p>This works, but I am not sure if this is the best solution -</p>
<pre class=""lang-swift prettyprint-override""><code>publisher.zip(
    publisher.dropFirst(),
    publisher.dropFirst(2))
</code></pre>
","10077646","","968155","","2021-02-15 02:39:34","2022-05-17 09:26:07","Swift Combine: Collect with Sliding window like functionality","<swift><combine>","3","0","","","","CC BY-SA 4.0"
"66206178","1","66213015","","2021-02-15 10:16:21","","1","308","<p>The API provider requires performing requests no more often than 1 second. How can this limitation be implemented using Combine in my <code>request</code> method?</p>
<pre><code>func request&lt;T: Codable&gt;(components: URLComponents) -&gt; AnyPublisher&lt;T, Error&gt; {
    return urlSession.dataTaskPublisher(for: components.url!)
        .map(\.data)
        .decode(type: T.self, decoder: JSONDecoder())
        .receive(on: RunLoop.main)
        .eraseToAnyPublisher()
}
</code></pre>
<p>So I would like to get from this:</p>
<pre><code>Request1 - 0.0 sec
Request2 - 0.3 sec
Request3 - 0.6 sec
Request4 - 0.9 sec
Request5 - 1.2 sec
</code></pre>
<p>... something like that:</p>
<pre><code>Request1 - 0.0 sec
Request2 - 1.0 sec
Request3 - 2.0 sec
Request4 - 3.0 sec
Request5 - 4.0 sec
</code></pre>
","6279226","","6279226","","2021-02-15 11:22:02","2021-02-15 17:53:59","Cooldown between api requests","<ios><swift><combine>","2","0","","","","CC BY-SA 4.0"
"66231216","1","66231375","","2021-02-16 19:49:58","","1","322","<p>When adding to or removing from an array, the view does not update unless the user interacts with the <code>ScrollView</code>.</p>
<p>The <code>Model</code> is a <code>ObservableObject</code> that is declared as a <code>StateObject</code> early in the app lifecycle and then passed as a <code>EnvironmentObject</code>.</p>
<p>The data is simply a custom <code>Profile</code> object with an array of objects, when adding to <code>store.profile!.tasks.append()</code> or removing from the view does not update unless the user scrolls the ScrollView; I mean literally by 1 pixel.</p>
<p>What I have tried</p>
<ul>
<li>Wrapping the ForEach in a LazyVStack or VStack</li>
<li>Wrapping the NavigationLink in a VStack</li>
<li>Making sure size is full height incase it needed to recalculate</li>
</ul>
<p><strong>Code</strong></p>
<pre><code>class Profile: Identifiable, Codable, Equatable
    var tasks: [Task]
}


struct Task: Identifiable, Codable, Equatable {
    var createdBy: String
    var title: String
    var date: Date
}

class Store : ObservableObject {
    @Published var profile: Profile?
}

struct ListView: View {

@EnvironmentObject var store: Store

  var body: some View {
     GeometryReader { geometry in
        ZStack(alignment: .bottomTrailing) {
          ScrollView(.vertical, showsIndicators: false){
              ForEach(store.profile!.tasks.filter({ return $0.createdBy == store.profile!.uid}).indices, id: \.self) { index in
                 NavigationLink(destination: DetailView().environmentObject(store)) {
                      TasksRow().id(UUID()) 
                 }
             }
          }
           .frame(maxWidth: geometry.size.width, alignment: .center)
           .frame(maxHeight: geometry.size.height)
           .background(Color.gray)
       }
    }
 }
</code></pre>
","4556409","","4556409","","2021-02-16 20:03:17","2021-02-16 20:03:17","ForEach in ScrollView not updating until interaction","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66241909","1","66242168","","2021-02-17 12:23:32","","0","136","<p>I am trying to make a try-catch block with combine so I can execute certain function and re-execute main block again. I am doing something like this -</p>
<pre><code>return urlSession.dataTaskPublisher(for: request)
    .tryMap(verifyAPIResponse)
    .tryCatch { (error) -&gt; AnyPublisher&lt;(data: Data, response: URLResponse), URLError&gt; in
        self.apiCallOne()
            .tryMap(\.apiResponse)
            .tryMap({ (response) in
            })
        return self.urlSession.dataTaskPublisher(for: request) //&lt;&lt;- DOES this execute after refreshToken or executes in parallel?
    }
    .tryMap(parseJson)
    .receive(on: RunLoop.main)
    .eraseToAnyPublisher()
</code></pre>
<p>So my main concern here is -</p>
<ol>
<li>Does the apiCallOne happen before it returns self.urlSession.dataTaskPublisher(for: request) or</li>
<li>Does the API call apiCallOne execute in background and self.urlSession.dataTaskPublisher(for: request) will be returned immediately? If so, I can I return after completion of apiCallOne?</li>
</ol>
<p>Any pointers/help would be great.</p>
","3307233","","3307233","","2021-02-17 12:30:51","2021-02-17 12:41:53","How does Combine work inside try-catch block?","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"66244396","1","66250725","","2021-02-17 14:52:26","","0","902","<p>I have an <code>ObservableObject</code> that publishes some values using <code>@Published</code> property wrappers. This object also holds a timer.</p>
<p>The question is, how can I fire an event as soon as the timer is executed and handle that event in a view in SwiftUI (I'd prefer using something like <code>onReceive</code>)?
Using the Combine framework for publishing changing values already, I'd like to implement this event triggering / handling properly. But all that I've read so far about Combine is always about handling value changes. But in my case it's rather a single simple event (without any values).</p>
<p>I know that I could simply use a closure and call that when the timer expires, and I will do that if there's no better, combine-like solution.</p>
<p>This is a conceptual question for a very simple problem so I think it's self explaining without me coming up with a code example?</p>
","1754221","","1015258","","2021-02-17 17:44:55","2021-02-18 15:43:11","SwiftUI receive custom Event","<swift><swiftui><event-handling><combine>","2","6","","","","CC BY-SA 4.0"
"66253532","1","66264100","","2021-02-18 04:17:42","","2","169","<p>I have a Core Data publisher that is working great so far. I have a <code>Workspace</code> entity and a <code>Project</code> entity. I use the following publisher to get all the projects for a given workspace:</p>
<pre><code>class ProjectModel: ObservableObject {
  @Published var projects = [Project]()
  private var cancellableSet: Set&lt;AnyCancellable&gt; = []

  init(){
    CoreDataPublisher(request: Project.getAllProjects(), context: PersistenceController.shared.container.viewContext)
      .sink(
        receiveCompletion: { print($0) },
        receiveValue: { [weak self] items in
          self?.projects = items
        })
      .store(in: &amp;cancellableSet)
  }
}
</code></pre>
<p>The fetch request <code>getAllProjects()</code> is in a Core Data entity extension here where the <code>NSPredicate</code> filters based on a <code>Workspace</code> object set in the UI.</p>
<pre><code>//Core Data Entity Extension
extension Project{
  @nonobjc public class func getAllProjects() -&gt; NSFetchRequest&lt;Project&gt; {
    let workspace = AppState.shared.workspace as Workspace //&lt;-- The user can change this workspace
  
    let request = NSFetchRequest&lt;Project&gt;(entityName: &quot;\(Self.self)&quot;)
    request.sortDescriptors = [NSSortDescriptor(keyPath: \Project.name, ascending: true)]
    request.predicate = NSPredicate(format: &quot;workspace = %@&quot;, workspace)
    return request
  }
}
</code></pre>
<p>This <code>Workspace</code> object is in a global state class:</p>
<pre><code>class AppState: ObservableObject{
  static let shared = AppState()
  @Published var workspace: Workspace!

  init(){
    //Setup the workspace for the first time
  }
}
</code></pre>
<p>I can successfully receive data from my publisher and I can successfully change the global <code>Workspace</code> in the UI. The problem is that after changing the <code>Workspace</code>, the publisher still points to the old <code>Workspace</code> originally set when the fetch request was created.</p>
<p>How do I prompt the <code>ProjectModel</code> to reinitialize in order to renew the publisher's state when the <code>AppState</code>'s <code>workspace</code> is changed?</p>
","1142348","","","","","2021-02-18 16:32:05","Reinitialize Combine Publishers When User Changes Global Object","<core-data><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"66257019","1","66260412","","2021-02-18 09:24:33","","1","75","<p>In order to update a view, I want to forward the view from my ViewController to the ViewModel by forwarding it.</p>
<p>Something like the following:</p>
<pre class=""lang-swift prettyprint-override""><code>viewModel.labelViewModel.subscribe(forward: labelView) { labelView, model in labelView.update(with: model) }
</code></pre>
<p>but using Combine.</p>
<p>So how can I return the observer with the observable?</p>
<p>In the ViewController I'm trying:</p>
<pre class=""lang-swift prettyprint-override""><code>viewModel.$labelModel.sink { lab in
    print(&quot;Value: \(lab?.1.text)&quot;)            
}.store(in: &amp;subscriptions)
</code></pre>
<p>with the label in the ViewModel:</p>
<pre class=""lang-swift prettyprint-override""><code>@Published private(set) var labelModel: (Label, Label.Model)?
</code></pre>
<p>but what I want to do is actually return the same label in the sink as is subscribing from the ViewController.</p>
<p>Is this possible?</p>
","1800285","","","","","2021-02-18 12:55:02","Forward object using Combine","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"66258759","1","66260701","","2021-02-18 11:09:17","","0","373","<p>I'm trying to communicate with CoreBluetooth using Combine, but my completion handler of a <code>PassthroughSubject</code> is not called. Below you can see a rough layout of the code. The <code>DetailViewModel</code> contains the bluetooth peripheral and the data to send.</p>
<pre class=""lang-swift prettyprint-override""><code>final class DetailViewModel: NSObject, ObservableObject, CBPeripheralDelegate {
    // Called when the correct write characteristic is found
    private var writeCharacteristicReceived = PassthroughSubject&lt;CBCharacteristic, Never&gt;()
    // Used to send and listen for peripheral data
    private var bluetoothDidChange = PassthroughSubject&lt;Data, Error&gt;()

    func open() -&gt; AnyPublisher&lt;Data, Error&gt; {
        writeCharacteristicReceived.tryMap { characteristic -&gt; AnyPublisher&lt;Data, Error&gt; in
            print(&quot;Write char&quot;, characteristic)

            let data: Data = try constructPayload()

            self.peripheral?.writeValue(data, for: characteristic, type: .withoutResponse)

            return self.bluetoothDidChange.eraseToAnyPublisher()
        }
        .switchToLatest()
        .eraseToAnyPublisher()
    }

    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
        print(&quot;Did update value&quot;, characteristic.value ?? Data())
        guard let value = characteristic.value, value.count &gt;= 84 else { return }

        defer {
            // Never called
            bluetoothDidChange.send(completion: .finished)
        }

        do {
            let message: Data = try parse(value)
            bluetoothDidChange.send(message)
            // Never called when placed here either
            // bluetoothDidChange.send(completion: .finished)
        } catch {
            bluetoothDidChange.send(completion: .failure(error))
        }
    }
}
</code></pre>
<p>I then listen for these changes in the view itself as follows</p>
<pre class=""lang-swift prettyprint-override""><code>viewModel.open().sink(receiveCompletion: { (completion) in
    print(&quot;Open completion: \(completion)&quot;)
}, receiveValue: { (payload) in
    print(&quot;Open payload \(payload)&quot;)
}).store(in: &amp;cancellable)
</code></pre>
<p>Now, this works fine for receiving values every now and then and the completion block is correctly called when an error occurs. But I never get the finished completion hander, not even when I specifically do <code>send(completion: .finished)</code>. Can anyone help me out?</p>
","5530076","","","","","2021-02-18 13:22:31","PassthroughSubject completion finished not called","<swift><swiftui><core-bluetooth><combine><publisher>","1","0","1","","","CC BY-SA 4.0"
"66263029","1","66752350","","2021-02-18 15:29:20","","3","391","<p>I have a SwiftUI app that fetches some information from the backend when the view appears and then attempts to update the State by setting <code>@Published</code> vars in an <code>ObservableObject</code>. The problem I have is it doesn't update at first fetch (it remains empty since it was initialized with an empty array) but if I click to another view and come back it's updated (since the information was already fetched).</p>
<p>Obviously, the intended thing I'm going for with using <code>@Published</code> is for the view to update once the information is fetched. This is part of a larger app but I have the reduced version of what I have below.</p>
<p>First, we have a parent view that contains the view I want to update.</p>
<pre><code>struct ParentView: View {
    
    var body: some View {
        NavigationView {
        ScrollView {
            VStack {
                SummaryView()
                // In real life I have various forms of summary
                // but to simplify here I will just use this one SummaryView.
                SummaryView()
                SummaryView()
            }
        }
        }
    }
}
</code></pre>
<p>Here is the summary view itself:</p>
<pre><code>struct SummaryView: View {
    
    @ObservedObject var model = AccountsSummaryViewModel()
    
    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Text(&quot;Accounts&quot;)
                    .font(.title)
                
                Spacer()
                
                NavigationLink(
                    destination: AccountView(),
                    label: {
                        Image(&quot;RightArrow&quot;)
                    })
                
            }
            
            if model.accounts.count &gt; 0 {
                Divider()
            }
            
            // And if I add the following line for debugging
            //Text(model.accounts.count)
            // It remains 0.

            ForEach(model.accounts, id: \.id) { account in
                Text(account.account.text)
            }
        }
        .padding()
        .onAppear() {
            model.onAppear()
        }
    }
}
</code></pre>
<p>Here is it's simple view model:</p>
<pre><code>class AccountsSummaryViewModel: ObservableObject, Identifiable {
    
    @Published var accounts: [AccountIdentifiable] = []
    
    func onAppear() {
        
        AccountsService.accounts { (success, error, response) in
            DispatchQueue.main.async {
                // This always succeeds
                if let response = response {
                    
                    // All AccountIdentifiable does is make a struct that is Identifiable (has an account and a var id = UUID())
                    self.accounts = Array(response.accounts.map { AccountIdentifiable(account: $0) }.prefix(3))
                }
            }
        }
        
    }
    
}
</code></pre>
<p>Here is the contents of the AccountsService also, I will note that the URL is a localhost but I'm not sure if that matters:</p>
<pre><code>public struct AccountsService {
    
    public static func accounts(completion: @escaping ((Bool, Error?, AccountsResponse?) -&gt; Void)) {
        guard let url = getAllAccountsURL() else {
            completion(false, nil, nil)
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = &quot;GET&quot;
        request.allHTTPHeaderFields = [&quot;Content-Type&quot;: &quot;application/json&quot;,
                                       BusinessConstants.SET_COOKIE : CredentialsObject.shared.jwt]

        let task = URLSession.shared.dataTask(with: request) { (data, urlResponse, error) in
            guard let data = data else {
                completion(false, error, nil)
                return
            }
            
            guard let response = try? JSONDecoder().decode(AccountsResponse.self, from: data) else {
                completion(false, error, nil)
                return
            }

            // This does successfully decode and return here. 
            completion(true, nil, response)
            
            return
        }

        task.resume()

    }
    
    private static func getAllAccountsURL() -&gt; URL? {
        let address = &quot;\(BusinessConstants.SERVER)/plaid/accounts&quot;

        return URL(string: address)
    }
    
}
</code></pre>
<p>I have read that there are issues with an empty <code>ScrollView</code>, however, my <code>ScrollView</code> is never empty as I have those static text elements. I also read that if you use a <code>ForEach</code> without the <em>id</em> it can fail - but you can see I am using the <em>id</em> so I'm kind of at a loss.</p>
<p>I have print statements in the <code>onAppear()</code> so I know it runs and successfully sets the <code>@Published accounts</code> but looking at the UI and putting breakpoints in the <code>ForEach</code> I can see the view does not update. However, if I navigate somewhere else in my app, and then come back to the <code>ParentView</code> then since the <code>@Published accounts</code> is non-empty (already fetched) it updates perfectly.</p>
","3853879","","3853879","","2021-02-18 15:59:07","2021-03-22 19:05:58","SwiftUI identifiable ForEach doesn't update when initially starting with empty","<swift><swiftui><combine>","2","4","","","","CC BY-SA 4.0"
"66266534","1","66268508","","2021-02-18 19:04:56","","2","558","<p>I have this general implementation for my api <code>.post</code> method:</p>
<pre><code>func post&lt;T: Decodable&gt;(endpoint: Endpoint, parameters: Parameters, responseType: T.Type) -&gt; AnyPublisher&lt;T, Error&gt; {
    sessionManager.request(self.baseUrl + endpoint.path, method: .post, parameters: parameters)
        .publishDecodable(type: responseType)
        .value()
        .mapError(ServiceError.init(error: ))
        .eraseToAnyPublisher()
}
</code></pre>
<p>It's working and I think it's how it supposed to be in SwiftUI/Combine. My problem is that I want to be able parse response when I get other status codes then 2xx. I fount <a href=""https://stackoverflow.com/a/64574546/367593"">this answer</a> and <a href=""https://charlesmuchene.com/custom-response-handler-in-alamofire-80267c3773a9"" rel=""nofollow noreferrer"">this article</a> about how to do it.</p>
<p>With that help I was able to change my code to this:</p>
<pre><code>func post&lt;T: Decodable&gt;(endpoint: Endpoint, parameters: Parameters, responseType: T.Type, completionHandler: @escaping (Result&lt;T, ErrorResponse&gt;) -&gt; Void) {
    sessionManager.upload(multipartFormData: multipartFormData, to: self.baseUrl + endpoint.path, method: .post, headers: headers)
        .validate(statusCode: 200..&lt;300)
        .responseTwoDecodable(of: responseType, completionHandler: completionHandler)
}
</code></pre>
<p>For more info here is my <code>TwoDecodableResponseSerializer</code> (created with help from that two links):</p>
<pre><code>final class TwoDecodableResponseSerializer&lt;T: Decodable&gt;: ResponseSerializer {
     
    lazy var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        return decoder
    }()
    
    private lazy var successSerializer = DecodableResponseSerializer&lt;T&gt;(decoder: decoder)
    private lazy var errorSerializer = DecodableResponseSerializer&lt;ErrorResponse&gt;(decoder: decoder)
    
    public func serialize(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) throws -&gt; Result&lt;T, ErrorResponse&gt; {
        
        guard let response = response else { return .failure(ErrorResponse()) }
        
        do {
            if response.statusCode &lt; 200 || response.statusCode &gt;= 300 {
                let result = try errorSerializer.serialize(request: request, response: response, data: data, error: nil)
                return .failure(result)
            } else {
                let result = try successSerializer.serialize(request: request, response: response, data: data, error: nil)
                return .success(result)
            }
        } catch(let err) {
            return .failure(ErrorResponse())
        }
        
    }
}

extension DataRequest {
    @discardableResult func responseTwoDecodable&lt;T: Decodable&gt;(queue: DispatchQueue = DispatchQueue.global(qos: .userInitiated), of t: T.Type, completionHandler: @escaping (Result&lt;T, ErrorResponse&gt;) -&gt; Void) -&gt; Self {
        return response(queue: .main, responseSerializer: TwoDecodableResponseSerializer&lt;T&gt;()) { response in
            switch response.result {
            case .success(let result):
                completionHandler(result)
            case .failure(let error):
                completionHandler(.failure(ErrorResponse()))
            }
        }
    }
}
</code></pre>
<p>and ErrorResponse:</p>
<pre><code>class ErrorResponse: Error, Decodable {
    
    var error: Int = 0
    
    enum CodingKeys: String, CodingKey {
        case error = &quot;error&quot;
    }
    
}
</code></pre>
<p>and it's working. That's great but I would like to have more reactive/Combine code. Not with closure. Is it possible? How would you do this?</p>
<p>Thanks for any help</p>
","367593","","","","","2021-02-18 21:36:54","SwiftUI - Combine and Alamofire parse error Response","<swift><swiftui><alamofire><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"66304103","1","66306256","","2021-02-21 15:48:26","","0","41","<p>I am trying to use a Picker to select a VideoFormat from Twilio's Video API via a ForEach loop. The loop is working– it lists all of the correctly formatted format strings.</p>
<p>Here's my view, <code>SettingsView</code>:</p>
<pre><code>import SwiftUI

struct SettingsView: View {
    
    @EnvironmentObject var twilioState: TwilioState
        
    var body: some View {
        Form {
            Section(header: Text(&quot;Stream&quot;)) {
                HStack {
                    Text(&quot;Device&quot;)
                    Spacer()
                    Text(&quot;\(twilioState.captureDevice?.localizedName ?? &quot;N/A&quot;)&quot;)
                }
</code></pre>
<p>This is where I run into trouble. I cannot seem to get the <code>Picker</code> to assign a value to my <code>selection</code>, <code>$twilioState.videoFormat</code>. I suspect it has something to do with <code>id</code> and <code>VideoFormat</code> not conforming to <code>Hashable</code>? I was considering changing the <code>selection</code> to an <code>Int</code> and using a range for <code>ForEach</code>, like <code>0..&lt;twilioState.videoFormats.count</code>.</p>
<pre><code>                Picker(&quot;Select a Format&quot;, selection: $twilioState.videoFormat) {
                    if let videoFormats = twilioState.videoFormats {
                        ForEach(videoFormats, id: \.self) {
                            Text(&quot;\(twilioState.getVideoFormatString(videoFormat: $0))&quot;)
                                .tag($0)
                        }
                    }
                }
                .disabled(twilioState.videoFormats == nil)
</code></pre>
<p>The rest is a listing of <code>twilioState.videoFormat</code> as I try to figure out how to successfully implement the <code>Picker</code>.</p>
<pre><code>                HStack {
                    Text(&quot;Format&quot;)
                    Spacer()
                    if let videoFormat = twilioState.videoFormat {
                        Text(&quot;\(twilioState.getVideoFormatString(videoFormat: videoFormat))&quot;)
                    } else {
                        Text(&quot;N/A&quot;)
                    }
                }
            }
        }
        .navigationBarTitle(&quot;Settings&quot;)
    }
}
</code></pre>
<p>And here's my state model, <code>TwilioState</code>:</p>
<pre><code>import Foundation
import TwilioVideo
import Combine


class TwilioState: ObservableObject {

    let twilioService = TwilioService()
    private var cancellables = Set&lt;AnyCancellable&gt;()
    var camera: CameraSource?
    
    @Published var videoFormat: VideoFormat?
    @Published var videoFormats: [VideoFormat]?
    @Published var captureDevice: AVCaptureDevice?
    @Published var twilioError: TwilioError?
        
    init() {
        
        twilioService.setCaptureDevice(captureDevice: self.captureDevice)
            .sink { completion in
                switch completion {
                case let .failure(twilioError):
                    return self.twilioError = twilioError
                case .finished:
                    return print(&quot;Capture device set&quot;)
                }
            } receiveValue: { captureDevice in
                self.captureDevice = captureDevice
            }
            .store(in: &amp;cancellables)

        twilioService.getVideoFormats(captureDevice: self.captureDevice!)
            .sink { completion in
                switch completion {
                case let .failure(twilioError):
                    return self.twilioError = twilioError
                case .finished: return print(&quot;Capture device formats set&quot;)
                }
            } receiveValue: { videoFormats in
                self.videoFormats = videoFormats
            }
            .store(in: &amp;cancellables)
    }
    
    func getVideoFormatString(videoFormat: VideoFormat) -&gt; String {
        return &quot;\(videoFormat.dimensions.width) x \(videoFormat.dimensions.height) @ \(videoFormat.frameRate)&quot;
    }
    
    deinit {
        // We are done with camera
        if let camera = self.camera {
            camera.stopCapture()
            self.camera = nil
        }
    }
}
</code></pre>
<p>In case it's helpful, this is the service function, <code>getVideoFormats()</code>, which is feeding values to <code>@Published videoFormats</code> in my model, <code>TwilioState</code>:</p>
<pre><code>    func getVideoFormats(captureDevice: AVCaptureDevice) -&gt; AnyPublisher&lt;[VideoFormat], TwilioError&gt; {
        return Just(captureDevice)
            .map { captureDevice -&gt; [VideoFormat] in
                return CameraSource.supportedFormats(captureDevice: captureDevice)
                    .compactMap { $0 as? VideoFormat }
            }
            .setFailureType(to: TwilioError.self)
            .eraseToAnyPublisher()
    }
</code></pre>
","15068510","","15068510","","2021-02-21 15:54:12","2021-02-21 19:30:01","How can I get Picker to return a VideoFormat var using a ForEach loop?","<foreach><swiftui><twilio><picker><combine>","1","0","","","","CC BY-SA 4.0"
"66306735","1","66310042","","2021-02-21 20:22:33","","1","393","<p>The point is that after successfully adding a record to the database (when I tap confirm button), the view should be closed. The problem is that it does not close after adding, <code>.onReceive</code> does not triggered, although the publisher <code>PassthroughSubject</code> sends a new value. There is one thing: the view will close if an alert was triggered before clicking the confirm button (for example, when not all fields are filled in, a warning is displayed)</p>
<p>Also properties <code>viewModel.name</code> and <code>viewModel.name</code> (for <code>TextField</code>'s) after adding a record become equal to empty strings, although I do not explicitly assign such a value to them anywhere in the code (as if a new instance of the view model is created where such default values are)</p>
<p><strong>View:</strong></p>
<pre><code>struct AddChallengeView: View {
    @Environment(\.presentationMode) var presentationMode
    @ObservedObject var viewModel = AddChallengeViewModel()
    
    
    var body: some View {
        Form{
            Section(header: Text(&quot;Name&quot;)){
                TextField(&quot;Type challenge name&quot;, text: $viewModel.name) //viewModel.name == &quot;&quot; after new record added
            }
            
            Section(header: Text(&quot;Description&quot;)){
                TextEditor(text: $viewModel.description) //viewModel.description == &quot;&quot; after new record added
            }
            //...
            
            Section{
                Button(action: { viewModel.addChallenge()}){
                    HStack{
                        Spacer()
                        Text(&quot;Submit&quot;).bold()
                        Spacer()
                    }
                }
            }
            
        }.alert(isPresented: $viewModel.showErrorAlert){
            Alert(title: Text(&quot;Please, set all values!&quot;))
        }
        .onReceive(viewModel.viewDismissalModePublisher) { shouldDismiss in
        print(&quot;new value received&quot;) //not printed 
        if shouldDismiss {
            self.presentationMode.wrappedValue.dismiss()
        }
    }
        
    }
}
</code></pre>
<p><strong>ViewModel:</strong></p>
<pre><code>class AddChallengeViewModel: ObservableObject{
    var viewDismissalModePublisher = PassthroughSubject&lt;Bool, Never&gt;()
    
    private var shouldDismissView = false {
        print(&quot;sending new value&quot;) //printed
        didSet {
            viewDismissalModePublisher.send(shouldDismissView)
        }
    }
    
    @Published var showErrorAlert = false

    @Published var name = &quot;&quot;
    @Published var description = &quot;&quot;

    //...
    
    func addChallenge () {
        //...
        
        if (name != &quot;&quot; &amp;&amp; description != &quot;&quot; &amp;&amp; grounds.count != 0){
            Firestore.firestore().collection(&quot;users&quot;).document(Auth.auth().currentUser!.uid).collection(&quot;challenges&quot;).addDocument(data: [
                &quot;name&quot;: &quot;\(name)&quot;,
                &quot;description&quot;: &quot;\(description)&quot;,
                &quot;grounds&quot;: grounds
            ]) { err in
                if let err = err {
                    print(&quot;Error adding document: \(err)&quot;)
                } else {
                    print(&quot;setting new value&quot;) //printed
                    self.shouldDismissView = true
                }
            }
        } else {
            showErrorAlert.toggle()
        }
    }
}
</code></pre>
<p><strong>UPDATE:</strong> I found a solution. We need to replace <code>@ObservedObject var viewModel = AddChallengeViewModel()</code> with <code>@StateObject var viewModel = AddChallengeViewModel()</code> in <code>AddChallengeView</code> but why does it work?</p>
","13696467","","13696467","","2021-02-21 21:30:40","2021-02-22 04:28:00","onReceive is not triggered after published value has changed","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66306859","1","66319796","","2021-02-21 20:34:04","","0","425","<p>I am trying to do some decoding of JSON I am receiving from a server. As this app is being written in SwiftUI I thought I may as well give Combine a go as well. I have been using .decode() as part of my combine chain which has been working well but now I need to decode json which won't work with this.</p>
<p>I am trying to decode JSON of a format into a <code>Team</code> struct. However the issue is that this is not guaranteed to exist on the server, in those cases, the server simply returns no JSON (it does however still have the correct HTTPS response code so I do know when this is the case). My question is how to decode the received data into an optional <code>Team?</code> (where it is either the decoded team data or nil if no JSON is received.</p>
<pre><code>struct Team: Codable, Identifiable, Hashable {
    var id: UUID
    var name: String
    var currentRating: Int

    enum CodingKeys: String, CodingKey {
        case id = &quot;id&quot;
        case name = &quot;name&quot;
        case currentRating = &quot;rating&quot;
    }
}
</code></pre>
<pre><code>func fetch&lt;T: Decodable&gt;(
        from endpoint: Endpoint,
        with decoder: JSONDecoder = JSONDecoder()
    ) -&gt; AnyPublisher&lt;T, DatabaseError&gt; {
        // Get the URL from the endpoint
        guard let url = endpoint.url else { ... }
        
        let request = URLRequest(url: url)
        
        // Get the publisher data from the server
        // retrieveData is a function with the return type AnyPublisher&lt;Data, DatabaseError&gt;
        return retrieveData(with: request)
            // Try to decode into a decodable object
            .decode(type: T.self, decoder: decoder)
            // If there is an error, map it to a DatabaseError
            .mapError { ... }
            // Main thread
            .receive(on: DispatchQueue.main)
            // Type erase
            .eraseToAnyPublisher()
    }
</code></pre>
","9682666","","","","","2021-02-22 16:43:02","Swift Combine version of decodeIfPresent?","<json><swift><codable><combine><decodable>","1","0","1","","","CC BY-SA 4.0"
"66315177","1","66358184","","2021-02-22 11:50:18","","0","376","<p>I'm trying to track an AVAudioPlayerNode's playback state via its Combine Publisher:</p>
<pre class=""lang-swift prettyprint-override""><code>import Cocoa
import AVFoundation
import Combine

@main
class AppDelegate: NSObject, NSApplicationDelegate {

    let engine = AVAudioEngine()
    let player = AVAudioPlayerNode()
    var cancellable: AnyCancellable?

    func applicationDidFinishLaunching(_ aNotification: Notification) {

        cancellable = player.publisher(for: \.isPlaying)
            .sink { newValue in
                print(&quot;is playing: \(newValue)&quot;)
            }

        let url = Bundle.main.url(forResource: &quot;blues&quot;, withExtension: &quot;aiff&quot;)!
        let file = try! AVAudioFile(forReading: url)

        let buffer = AVAudioPCMBuffer(pcmFormat: file.processingFormat, frameCapacity: UInt32(file.length))!
        try! file.read(into: buffer)

        engine.attach(player)
        engine.connect(player, to: engine.mainMixerNode, format: file.processingFormat)

        player.scheduleBuffer(buffer, at: nil, options: .loops, completionHandler: nil)

        try! engine.start()
        player.play()
    }
}
</code></pre>
<p>The sink gets called just once when it's initialised, and never again. I would expect it to get called when playback starts, but it doesn't... Any ideas why?</p>
","1072846","","","","","2021-02-24 20:11:01","Combine Publisher not firing for a KVO property","<ios><macos><combine><avaudioengine>","1","3","","","","CC BY-SA 4.0"
"66320320","1","66320913","","2021-02-22 17:15:56","","0","1790","<p>I would like to wait for data from all elements and combine them into one result:</p>
<pre><code>Item: AnyPublisher &lt;Int, Swift.Error&gt;
Array: AnyPublisher &lt;[Result&lt;Int, Swift.Error&gt;], Never&gt;
</code></pre>
<p>Can this be done somehow? I've tried using Zip and Merge - but I couldn't get the desired result.</p>
<p>Example:</p>
<pre><code>func createItem(num: Int) -&gt; AnyPublisher&lt;Int, Swift.Error&gt; {
    Just(num)
        .setFailureType(to: Swift.Error.self)
        .eraseToAnyPublisher()
}
func createItems(nums: [Int]) -&gt; AnyPublisher&lt;[Result&lt;Int, Swift.Error&gt;], Never&gt; {
    Publishers.MergeMany(nums.map { self.createItem(num: $0) } )
        .collect()
        .eraseToAnyPublisher()
}
</code></pre>
<p>Function but &quot;createItems&quot; does not work</p>
","10682199","","10682199","","2021-02-22 18:10:51","2021-02-22 19:20:03","Swift Combine Sink Array AnyPublisher","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"66325099","1","66325152","","2021-02-22 23:47:15","","1","486","<p>In this code I am expecting the <code>Empty()</code> publisher to send completion to the <code>.sink</code> subscriber, but no completion is sent.</p>
<pre><code>func testEmpty () {
    let x = XCTestExpectation()

    let subject = PassthroughSubject&lt;Int, Never&gt;()

    emptyOrSubjectPublisher(subject).sink(receiveCompletion: { completion in
        dump(completion)
    }, receiveValue: { value in
        dump(value)
    }).store(in: &amp;cancellables)

    subject.send(0)

    wait(for: [x], timeout: 10.0)
}

func emptyOrSubjectPublisher (_ subject: PassthroughSubject&lt;Int, Never&gt;) -&gt; AnyPublisher&lt;Int, Never&gt; {
    subject
        .flatMap { (i: Int) -&gt; AnyPublisher&lt;Int, Never&gt; in
            if i == 1 {
                return subject.eraseToAnyPublisher()
            } else {
                return Empty().eraseToAnyPublisher()
            }
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>Why does the <code>emptyOrSubjectPublisher</code> not receive the completion?</p>
","4286164","","","","","2021-02-23 03:31:22","Empty() publisher does not send completion","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"66331398","1","66334804","","2021-02-23 10:30:46","","2","2217","<p>I'm getting my way through Combine bit I don't seem to wrap my head around some trivial operations. I'm building a Combine based to do some HealthKit operations. Mainly I have two operations:</p>
<ol>
<li><code>func workouts(_ limit: Int) -&gt; AnyPublisher&lt;[HKWorkout], Error&gt;</code></li>
<li><code>func workoutDetails(_ workout: HKWorkout) -&gt; AnyPublisher&lt;WorkoutDetails, Error&gt;</code></li>
</ol>
<p>First off I will use the first one to query some workouts, that's easy.</p>
<pre class=""lang-swift prettyprint-override""><code>HKHealthStore().workouts(HKObjectQueryNoLimit)
    .sink(receiveCompletion: { subject in
        switch subject {
        
        case .finished:
            break
        case .failure(let error):
            dump(error)
        }
    }, receiveValue: { workouts in
        dump(workouts)
        // What now? 
    }).store(in: &amp;bag)  
</code></pre>
<p>Now I'd like to query the second function. It takes a workout as an argument and returns more information about the <code>HKWorkout</code>. How can I query the second function with the returned <code>[HKWorkout]</code> but don't know how to approach this.</p>
<ul>
<li>Should I do the query in a nested way in the sink part of the first method?</li>
<li>Is there a way to nest operations for each of the workout in the <code>[HKWorkout]</code> and call <code>workoutDetails(_ workout: HKWorkout)</code> for each one so I get as a result <code>[WorkoutDetails]</code>?</li>
</ul>
<p>What I have attempted so far it's not working.</p>
<pre class=""lang-swift prettyprint-override""><code>HKHealthStore().workouts(HKObjectQueryNoLimit)
    .map({ workouts -&gt; AnyPublisher&lt;[WorkoutDetails], Never&gt; in
        
        return workouts.publisher.flatMap({ workout in
            return Just(workout as! [WorkoutDetails]).eraseToAnyPublisher()
                .eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
        
    }).sink(receiveCompletion: { subs in
        switch subs {
        
        }
    }, receiveValue: { val in
        /// Cannot convert value of type 'AnyPublisher&lt;[WorkoutDetails], Never&gt;' to expected argument type 'Void'
        /// I am not able to get [WorkoutDetails] here as I'd like
        dump(val)
    })
    .store(in: &amp;bag)
</code></pre>
<hr />
<p>Edit: Solution I've finally used. There are two options that I've finally managed to make it work and understand it.</p>
<p>One is @New Dev's answer to finally receive in the <code>sink</code> the combined array and another one is to receive on the <code>sink</code> individual elements to save on an array.</p>
<pre class=""lang-swift prettyprint-override""><code>HKHealthStore().workouts(HKObjectQueryNoLimit)
    .flatMap({
        $0.publisher.eraseToAnyPublisher()
    }).flatMap({
        $0.workoutWithDetails
    }).sink(receiveCompletion: { comp in
        switch comp {

        case .finished:
            break
        case .failure(let er):
            dump(er)
        }
    }, receiveValue: { details in
        /// Add the individual `WorkoutDetails` elements to an array 
        results.append(details)
    }).store(in: &amp;SGHealthManager.bag)

</code></pre>
","4296481","","4296481","","2021-02-23 14:38:04","2021-02-23 14:45:55","Swift Combine transform an array of publishers","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"66332306","1","66333540","","2021-02-23 11:31:37","","1","149","<p>Let's say I have the following <code>PassthroughSubject</code>, somewhere in an <code>ObservableObject</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>@Published var errorOccured = PassthroughSubject&lt;(), Error&gt;()
</code></pre>
<p>I send an error to it with:</p>
<pre class=""lang-swift prettyprint-override""><code>self.errorOccured.send(completion: .failure(error))
</code></pre>
<p>How can I be notified in a <code>View</code> whenever an error occurs? I know that with <code>onReceive</code> I can be notified of values, but I am interested in errors.</p>
","6603599","","","","","2021-02-23 12:55:07","Observe errors in PassthroughSubject in SwiftUI","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66339422","1","66339700","","2021-02-23 18:59:59","","0","588","<p>I want to use the <code>@Published</code> property wrapper combined with <code>map</code>, but I get this compiler error:</p>
<blockquote>
<p>Cannot convert return expression of type 'Publishers.Map&lt;Published.Publisher, Bool&gt;' to return type 'Published.Publisher'</p>
</blockquote>
<pre><code>@Published private var aNumber: Int = 1

var theNumberIsZero2: Published&lt;Bool&gt;.Publisher {
   $aNumber.map { number -&gt; Bool in
      return number == 0
   }
}
</code></pre>
<p>I could just use a <code>CurrentValueSubject</code>, like below, but I lost some benefit because <code>theNumberIsZero</code> cannot be synchronously checked.</p>
<pre><code>private let currentValueNumber = CurrentValueSubject&lt;Int, Never&gt;(0)
    
var theNumberIsZero: AnyPublisher&lt;Bool, Never&gt; {
   currentValueNumber.map { number -&gt; Bool in
      return number == 0
    }
    .eraseToAnyPublisher()
}
    
</code></pre>
<p>How can I do this?</p>
","9718260","","9718260","","2021-02-23 19:08:35","2021-02-24 10:08:21","How do I use @Published and map?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"66349952","1","66355245","","2021-02-24 11:27:20","","1","840","<p>I'm trying to fetch some data with this helper file:
<a href=""https://gist.github.com/jbfbell/e011c5e4c3869584723d79927b7c4b68"" rel=""nofollow noreferrer"">https://gist.github.com/jbfbell/e011c5e4c3869584723d79927b7c4b68</a></p>
<p>Here's a snippet of the important code:</p>
<p><b>Class</b></p>
<pre><code>/// Base class for requests to the Alpha Vantage Stock Data API.  Intended to be subclasssed, but can
/// be used directly if library does not support a new api.
class AlphaVantageRequest : ApiRequest {

    private static let alphaApi = AlphaVantageRestApi()
    let method = &quot;GET&quot;
    let path = &quot;&quot;
    let queryStringParameters : Array&lt;URLQueryItem&gt;
    let api : RestApi = AlphaVantageRequest.alphaApi

    var responseJSON : [String : Any]? {
        didSet {
            if let results = responseJSON {
            print(results)
        }
    }
  }
}
</code></pre>
<p><b> Extension ApiRequest </b></p>
<pre><code>    /// Makes asynchronous call to fetch response from server, stores response on self
    ///
    /// - Returns: self to allow for chained method calls
    public func callApi() -&gt; ApiRequest {
        guard let apiRequest = createRequest() else {
            print(&quot;No Request to make&quot;)
            return self
        }
        let session = URLSession(configuration: URLSessionConfiguration.ephemeral)
        let dataTask = session.dataTask(with: apiRequest) {(data, response, error) in
            guard error == nil else {
            print(&quot;Error Reaching API, \(String(describing: apiRequest.url))&quot;)
            return
            }
            self.receiveResponse(data)
        }
        dataTask.resume()
        return self
    }
</code></pre>


My goal is to fetch the data from <b>responseJSON</b> after the data of the url request is loaded.
<p>My ViewModel currently looks like this:</p>
<pre><code>class CompanyViewModel: ObservableObject {
    
    var companyOverviewRequest: ApiRequest? {
        didSet {
            if let response = companyOverviewRequest?.responseJSON {
                print(response)
            }
        }
    }
    
    private var searchEndpoint: SearchEndpoint
    
    init(companyOverviewRequest: AlphaVantageRequest? = nil,
         searchEndpoint: SearchEndpoint) {
        
        self.companyOverviewRequest = CompanyOverviewRequest(symbol: searchEndpoint.symbol)
    }
    
    
    func fetchCompanyOverview() {
        
        guard let request = self.companyOverviewRequest?.callApi() else { return }
        self.companyOverviewRequest = request

    }
    
}
</code></pre>
<p>So in my ViewModel the didSet gets called once but not when it should store the data. The results of <strong>AlphaVantageRequest</strong> always prints out properly, but not in my ViewModel. How can I achieve to have the loaded data also in my ViewModel?</p>
","13618212","","13618212","","2021-02-25 07:40:19","2021-02-25 14:23:12","How does a view obtain data using a view model and Network API","<api><swiftui><protocols><viewmodel><combine>","1","2","","","","CC BY-SA 4.0"
"66370035","1","66372175","","2021-02-25 14:03:43","","0","89","<p>I have created an <code>AnyPublisher</code> for subscribing to Firestore documents and the Output type is a DocumentSnapshot.</p>
<p>I run it like this...</p>
<pre><code>firestoreSubscription.subscribe(MyHashable(), &quot;/user/1234567890&quot;)
    .compactMap { try? $0.data(as: UserDoc.self }
</code></pre>
<p>The return type of this is <code>&lt;UserDoc, Never&gt;</code> which I want to keep.</p>
<p>This worked but I thought it would be cool if I could use the <code>.decode</code> function on Publisher to make it a bit more Combiney.</p>
<p>So I created this...</p>
<pre><code>public struct FirestoreDecoder: TopLevelDecoder {
    public init() {}
    
    public typealias Input = DocumentSnapshot
    
    public func decode&lt;T&gt;(_ type: T.Type, from: DocumentSnapshot) throws -&gt; T where T : Decodable {
        try! from.data(as: type)!
    }
}
</code></pre>
<p>So now I try this...</p>
<pre><code>environment.firestoreSubscription.subscribe(userSubscriptionID, &quot;/user/\(state.userID)&quot;)
    .decode(type: UserDoc.self, decoder: FirestoreDecoder())
</code></pre>
<p>But... <code>TopLevelDecoder</code> throws rather than returning <code>nil</code>. I wonder, is it possible to throw away the throws and default back to my compact map solution that I had whilst using the <code>.decode</code> method?</p>
<p>Or... should I just keep using the <code>.compactMap</code>?</p>
<p>Also... will the <code>throw</code> on the <code>.decode</code> end the publisher?</p>
","421018","","","","","2021-02-25 16:09:23","Combine replace `.compactMap` with custom `.decode`","<swift><decode><combine><publisher>","2","0","","","","CC BY-SA 4.0"
"66374840","1","66383795","","2021-02-25 19:01:47","","1","81","<p>I have a VielModel in SwiftUI handling my person model. To be able to store draft persons in the editor in the View(s), I have two objects:</p>
<pre><code>@Published var person: Person
@Published var draftPerson: Person
</code></pre>
<p>In the UI, I am only changing the draftPersons until the user clicks on &quot;Save&quot;, which stores the draftPerson as the person. In the onAppear method of the editor, I reset the draftPerson to the person.</p>
<p>Now I want to disable the &quot;Save&quot; button of the Editor and therefor introduced a bool &quot;modified&quot; in the VM. Using a pipeline, I want to set the modified to true, if and as long as the draftPerson is not equal to person, by doing the following:</p>
<pre><code>    $draftPerson.map { draftPerson in
        return draftPerson != self.person
    }
    .assign(to: \.modified, on: self)
    .store(in: &amp;cancellables)
</code></pre>
<p>It looks like it is working on first glance, but if I change something in a textField, the value of modified is only set to true after the second change in the field. Vice versa, if I delete the typed values, it is only set back to false after I delete one more character as were originally there.</p>
<p>Question 1:
Is there another &quot;best practice&quot; to handle changes in draft objects and deactivating the &quot;Save&quot; button in SwiftUI?</p>
<p>Question 2:
Why is the pipeline &quot;one change behind&quot;?</p>
<p>Thanks a lot for your input.</p>
<p><strong>Edit</strong>: I created a separate part of the App focusing only on the pipeline and realized that it is indeed working as intended if I remove my other pipelines. I have to check now in detail. Nevertheless, I will stick with my first question:
Is there anything I can do better?</p>
<p>Please find the code <a href=""https://gist.github.com/brenner-tobias/0dcf340342e9142d8538458c5d945e9f"" rel=""nofollow noreferrer"">here on Github</a></p>
","14596897","","14596897","","2021-02-26 10:04:19","2021-02-26 10:08:36","Swift Combine Pipeline to compare draft model","<swift><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"66375767","1","66376399","","2021-02-25 20:08:24","","0","729","<p>I'd like not to use <code>saveButton.addTarget(:selector:event)</code> that's why
I try to use tap publisher from <em><strong><a href=""https://github.com/CombineCommunity/CombineCocoa"" rel=""nofollow noreferrer"">CombineCocoa</a></strong></em> framework like this</p>
<pre><code> saveButton.tapPublisher.sink {  _ in
        print(&quot;tap&quot;) // tap twice
    }
    .store(in: &amp;subscriptions)
</code></pre>
<p>and when I tap <code>saveButton</code> then 'tap' printed twice.</p>
<p>Also I try to use from <em><strong>Combine</strong></em> framework</p>
<pre><code>saveButton.publisher(for: .touchUpInside) 
</code></pre>
<p>but have the same result.</p>
<p>My code here</p>
<pre><code>class ArticleVC: UIViewController {
    let saveButton: UIButton = {
        let btn = UIButton()
        btn.setTitle(&quot;Save&quot;, for: .normal)
        return btn
    }()
    
    var subscriptions: Set&lt;AnyCancellable&gt; = []
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // add to view
        view.addSubview(saveButton)
        didTapSave()
        saveButton.snp.makeConstraints {
            $0.centerX.centerY.equalToSuperview()
        }
        
        didTapSave()
    }
    
    func didTapSave() {
//        saveButton.tapPublisher.sink(receiveValue: { _ in
//            print(&quot;tap&quot;)  // twice printed 'tap'
//        })
//        .store(in: &amp;subscriptions)
        /// OR
        saveButton.publisher(for: .touchUpInside).sink { _ in
            print(&quot;tap&quot;) // twice printed 'tap'
        }
        .store(in: &amp;subscriptions)
    }
}

</code></pre>
<p>What the reason for it?</p>
","11079607","","11079607","","2021-02-25 21:11:31","2021-02-25 21:17:28","Tap publisher execute twice in Combine","<swift><combine>","1","8","","","","CC BY-SA 4.0"
"66402638","1","66404043","","2021-02-27 19:22:25","","0","146","<p>I've included stubbed code samples. I'm not sure how to get this presentation to work. My expectation is that when the sheet presentation closure is evaluated, <code>aDependency</code> should be non-nil. However, what is happening is that <code>aDependency</code> is being treated as nil, and <code>TheNextView</code> never gets put on screen.</p>
<p>How can I model this such that <code>TheNextView</code> is shown? What am I missing here?</p>
<pre><code>struct ADependency {}

struct AModel {
    func buildDependencyForNextExperience() -&gt; ADependency? {
        return ADependency()
    }
}

struct ATestView_PresentationOccursButNextViewNotShown: View {
    @State private var aDependency: ADependency?
    @State private var isPresenting = false
    @State private var wantsPresent = false {
        didSet {
            aDependency = model.buildDependencyForNextExperience()
            isPresenting = true
        }
    }
    private let model = AModel()
    
    var body: some View {
        Text(&quot;Tap to present&quot;)
            .onTapGesture {
                wantsPresent = true
            }
            .sheet(isPresented: $isPresenting, content: {
                if let dependency = aDependency {
                    // Never executed
                    TheNextView(aDependency: dependency)
                }
            })
    }
}

struct TheNextView: View {
    let aDependency: ADependency
    
    init(aDependency: ADependency) {
        self.aDependency = aDependency
    }
    
    var body: some View {
        Text(&quot;Next Screen&quot;)
    }
}
</code></pre>
","9718260","","","","","2021-02-27 22:29:08","How can I dynamically build a View for SwiftUI and present it?","<ios><swift><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"66415728","1","66416084","","2021-03-01 02:00:10","","0","776","<p>I'm trying to call several publishers in sequence and call the <code>completionBlock</code> when the last one is finished. All the return type of the publishers is <code>AnyPublisher&lt;Void, Error&gt;</code>. Compared to the solution below, can I do it with <code>.flatMap</code> or some other functions provided in <code>Publishers</code>?</p>
<pre><code>private var firstObserver: AnyCancellable?
private var secondObserver: AnyCancellable?

public func setup() {
    firstObserver = Manager.firstPublisher()
        .sink(receiveCompletion: {_ in}, receiveValue: {[weak self] _ in
            self?.secondObserver = Manager.secondPublisher()
                .sink(receiveCompletion: {_ in}, receiveValue: {[weak self] _ in
                    self?.completionBlock()
                }
        })
}
</code></pre>
","1682474","","","","","2021-03-01 03:07:37","Chaining Combine.Publisher and calling completion when finished","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"66416553","1","66416746","","2021-03-01 04:14:07","","-1","266","<p>I am aware this has been asked numerous times but I am struggling to see which properties is not being intialized. Each of these fields are from a CoreData model and I am populating its respective model. Can anyone help with which parameter this would be. All fields in the CoreData Entity and not optional.</p>
<pre><code>init() {
    self.flightListVM = FlightListViewModel()   -- Error Line
}
</code></pre>
<hr />
<pre><code>import Foundation
import SwiftUI
import CoreData
import Combine

class FlightListViewModel: ObservableObject {

@Published
var flights = [FlightViewModel]()

init() {
    fetchAllFlights()
}

func deleteFlight(_ flightVM: FlightViewModel) {
    CoreDataManager.shared.deleteFlight(id: flightVM.id)
    fetchAllFlights()
}

func fetchAllFlights() {
    self.flights = CoreDataManager.shared.getAllFlights().map(FlightViewModel.init)
    print(self.flights)
}
}

struct FlightViewModel {

var id: UUID
var date: Date
var origin: String
var destination: String
var altitude: Double
var duration: Double


init(flight: Flight) {
    
    self.id = flight.id!
    self.date = flight.date!
    self.origin = flight.origin!
    self.destination = flight.destination!
    self.altitude = flight.altitude
    self.duration = flight.duration

 
}

}
</code></pre>
<p>-Core Data Object</p>
<pre><code>import Foundation
import CoreData


extension Flight {

@nonobjc public class func fetchRequest() -&gt; NSFetchRequest&lt;Flight&gt; {
    return NSFetchRequest&lt;Flight&gt;(entityName: &quot;Flight&quot;)
}

@NSManaged public var id: UUID?    
@NSManaged public var date: Date?
@NSManaged public var origin: String?
@NSManaged public var destination: String?
@NSManaged public var altitude: Double
@NSManaged public var duration: Double

}
</code></pre>
<p>--------- First Init Code Block</p>
<pre><code>struct ContentView: View {

@ObservedObject var flightListVM: FlightListViewModel    
@State private var isPresented: Bool = false

init() {
    self.flightListVM = FlightListViewModel()  -- Error Line
}

private func delete(at offsets: IndexSet) {
    offsets.forEach { index in
        let flightVM = self.flightListVM.flights[index]
        self.flightListVM.deleteFlight(flightVM)
    }
}

var flights: FetchedResults&lt;Flight&gt;

var body: some View {
    
    NavigationView {
    
    List {
        
        ForEach(self.flightListVM.flights, id: \.id) { flight in
            HStack {
                
                Text(flight.origin)
                    .font(.largeTitle)
                    .padding([.leading], 10)
                
            }
        }.onDelete(perform: delete)
        
    }
    .sheet(isPresented: $isPresented, onDismiss: {
        print(&quot;Here&quot;)
        self.flightListVM.fetchAllFlights()
    }, content: {
        AddFlightView()
    })
    .navigationBarTitle(&quot;Flights&quot;)
    .navigationBarItems(trailing: Button(&quot;Add New Flight&quot;) {
        self.isPresented = true
    })
    }
    
}
</code></pre>
<p>}</p>
<pre><code>struct ContentView_Previews: PreviewProvider {
static var previews: some View {
    ContentView().environment(\.managedObjectContext, 
PersistenceController.preview.container.viewContext)
}
}
</code></pre>
","14141822","","14141822","","2021-03-01 04:33:13","2021-03-01 04:42:22","Swift Error Message - Return from initializer without initializing all stored properties","<swift><compiler-errors>","1","2","","","","CC BY-SA 4.0"
"66433501","1","66435139","","2021-03-02 04:48:30","","0","471","<ol>
<li>I have an upstream <code>Publisher</code> emitting values. For example, a stream of hex colors.</li>
<li>Separately I have an <code>Operator</code> backed by a <code>Publisher</code> that takes in those values and outputs some derived about them that is one-to-one in the long-term, but requires information about the value before or after. For example, returning the difference between each hex color and the color before it. <strong>I can't modify this.</strong></li>
<li>I would like a simple way to return the two values together. E.g. a tuple <code>(color, differenceToPreviousColor)</code></li>
<li>I am using OpenCombine for backwards compatibility and it might be missing some operators. For example, it doesn't have <code>zip</code> (if that's what I would even need)</li>
</ol>
<p>Pseudocode:</p>
<pre class=""lang-swift prettyprint-override""><code>// Can't mess with this. Basically just returns the consecutive differences
extension Publisher {
    func colorDiff&lt;E&gt;() -&gt; AnyPublisher&lt;Color, E&gt; where Color == Output, E == Failure {
        return self
          .map({ ($0, $0) })
          .scan((Color.black(), Color.black()), {
            let (_, prev) = $0
            let (curr, _) = $1
            return (prev, curr)
          })
          .map({
            let (prev, curr) = $0
            return curr - prev
          })
          .eraseToAnyPublisher()
    }
}

let colorPublisher = ... // emits #333333; #444444; ...
</code></pre>
<p>What's the simplest way to do something like the below with OpenCombine (without using zip)?</p>
<pre class=""lang-swift prettyprint-override""><code>let _ = zip(colorPublisher, colorPublisher.colorDiff()).sink { (e) in } receiveValue: { (tuple) in
      debugPrint(tuple.description) // (#333333, #333333); (#444444, #111111); ...
    }
</code></pre>
","37685","","","","","2021-03-03 07:12:34","How can I cleanly split and recombine Swift Publisher values? (using OpenCombine)","<swift><combine>","2","3","","","","CC BY-SA 4.0"
"66436139","1","66436581","","2021-03-02 08:53:27","","2","627","<p>I'm combining two publishers:</p>
<pre><code>let timer = Timer.publish(every: 10, on: .current, in: .common).autoconnect()
let anotherPub: AnyPublisher&lt;Int, Never&gt; = ...

Publishers.CombineLatest(timer, anotherPub)
    .sink(receiveValue: (timer, val) in { 
      print(&quot;Hello!&quot;)
} )
</code></pre>
<p><strong>Unfortunately, sink is not called until both publishers emit at least one element.</strong></p>
<p>Is there any way to make the sink being called without waiting for all publishers?
So that if any publisher emits a value, sink is called with other values set to nil.</p>
","380014","","","","","2021-03-02 09:22:49","Swift Combine - combining publishers without waiting for all publishers to emit first element","<ios><swift><combine>","1","0","1","","","CC BY-SA 4.0"
"66448542","1","66500771","","2021-03-02 23:24:59","","0","156","<p>I'm trying to find a viable way to handle navigation with data that has been returned from an asynchronous callback.</p>
<p>Consider the following example. The button in <code>NavigationExampleView</code> is triggering some async method on a separate object, <code>NavigationExampleViewModel</code> in this case. The returned data form the method, should then be <em>pushed on the navigation stack</em> in a <code>UserView</code>. A <code>NavigationLink</code> seems to be the way to archive this, but I can't find a way to get hold of a non-optional value of the data that I need to present.</p>
<pre><code>struct User: Identifiable {
    let id: String
    let name: String
}

protocol API {
    func getUser() -&gt; AnyPublisher&lt;User, Never&gt;
}

struct NavigationExampleView: View {
    
    @ObservedObject var vm: NavigationExampleViewModel
    
    var body: some View {
        HStack {
            Button(&quot;Get User&quot;) {
                vm.getUser()
            }
            NavigationLink.init(
                destination: UserView(user: ???),
                isActive: ???,
                label: EmptyView.init
            )
        }
    }
}

class NavigationExampleViewModel: ObservableObject {
    @Published var isLoading = false
    @Published var pushUser: User?
    
    var cancellable: AnyCancellable?
    
    let api: API
    init(api: API) { self.api = api }
    
    func getUser() {
        isLoading = true
        cancellable = api.getUser().sink { user in
            self.pushUser = user
            self.isLoading = false
        }
    }
}

struct UserView: View, Identifiable {
    let id: String
    let user: User
    
    var body: some View {
        Text(user.name)
    }
}
</code></pre>
<p><strong>Questions:</strong></p>
<ol>
<li>How do I get hold of the data to present as a non-optional value in the view?</li>
<li>What should I use as a binding to control presentation?</li>
</ol>
<p>A way I can almost archive this is with the view modifier <code>.sheet(item: Binding&lt;Identifiable?&gt;, content: Identifiable -&gt; View)</code>, like this:</p>
<pre><code>struct NavigationExampleView: View {
    
    @ObservedObject var vm: NavigationExampleViewModel
    
    var body: some View {
        HStack {
            Button(&quot;Get User&quot;) {
                vm.getUser()
            }
        }.sheet(item: $vm.pushUser, content: UserView.init)
    }
}
</code></pre>
<p>How can archive the same for pushing the view onto the navigation stack, instead of presenting it as a sheet?</p>
","2299801","","","","","2021-03-11 14:00:52","Push view with data from asynchronous callback","<swift><swiftui><navigation>","2","5","","","","CC BY-SA 4.0"
"66460273","1","66498238","","2021-03-03 15:41:09","","1","638","<p>I have a HTTP request to my server like this.</p>
<pre><code>func loginUser( username: String, password: String )-&gt;AnyPublisher&lt;UserModel, Error&gt;{

    let url = URL( string: &quot;\(Credentials.BASE_URL)auth/login&quot;)!
    let userSignInModel = SignInModel(username: username, password: password)
    
    return AF.request(url,
                      method: .post,
                      parameters: userSignInModel,
                      encoder: JSONParameterEncoder.default)
        .validate()
        .publishDecodable(type: UserModel.self)
        .value()
        .mapError{$0 as Error}
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
}
</code></pre>
<p>and get response like this</p>
<pre><code>    self.dataManager.loginUser(username: self.logInUsername, password: self.logInPassword)
        .sink { (response) in
            print( response )
            switch response {
                case .failure( let error ):
                    self.createAlert(with: error.localizedDescription,
                                     for: .loginAlert,
                                     responseCode: error.asAFError?.responseCode)
                case .finished:
                    break
            }
        } receiveValue: { (userModel) in                
            self.token = userModel.token
            self.userID = userModel.user.id
        }.store(in: &amp;cancellableSet)
</code></pre>
<p>but the problem is that I am not able to get error message from the server, how it can be done?</p>
","13772103","","6791677","","2021-03-03 20:23:33","2021-03-05 19:06:38","Alamofire publish decodable","<ios><swift><alamofire>","1","2","","","","CC BY-SA 4.0"
"66497244","1","66497366","","2021-03-05 17:47:20","","0","719","<p>I'm trying to make a list of products. In GetProducts class, I'm getting the data from Firebase Dtabase. Then I use @Published for use this products in another struct. But in my product list, view is not updating.</p>
<p>Here is the simplified GetProducts class;</p>
<pre><code>import Combine
import FirebaseDatabase

class GetProducts: ObservableObject {

private let database = Database.database().reference()

//Shared list
@Published var productList: [String] = []

//Reading the products from Firebase Database
func getProducts() {
    database.child(&quot;Products&quot;).child(&quot;Category1&quot;).child(&quot;name&quot;).observeSingleEvent(of: .value, with: { snapshot in
        guard let value = snapshot.value as? String else {
            return
        }
        print(&quot;Value: \(value)&quot;)
        self.productList.append(value)
    })
}

}
</code></pre>
<p>In print everything seems fine, I got the data. And the View;</p>
<pre><code>struct ProductsView: View {

@ObservedObject var products = GetProducts()

var body: some View {
    NavigationView {
        List {
            ForEach(0 ..&lt; products.productList.count, id: \.self) { product in
                NavigationLink(destination: ProductDetails()) {
                    Text(&quot;\(products.productList[product])&quot;)
                }
            }
        }
        .navigationBarTitle(Text(&quot;Product List&quot;))
    }
}
}
</code></pre>
<p>And I'm calling the getProducts function in the first view (ContentView);</p>
<pre><code>struct ContentView: View {

@ObservedObject var products = GetProducts()
@State var selected = 0

var body: some View {
    TabView(selection: $selected) {
        ProductsView()
            .tabItem {
                if self.selected == 0 {
                    Image(systemName: &quot;tray.and.arrow.down&quot;)
                    Text(&quot;Products&quot;)
                }else {
                    Image(systemName: &quot;tray.and.arrow.down.fill&quot;)
                    Text(&quot;Products&quot;)
                }
            }.tag(0)
        AddNewProductView()
            .tabItem {
                if self.selected == 1 {
                    Image(systemName: &quot;icloud.and.arrow.up&quot;)
                    Text(&quot;Add Product&quot;)
                }else {
                    Image(systemName: &quot;icloud.and.arrow.up.fill&quot;)
                    Text(&quot;Add Product&quot;)
                }
            }.tag(1)
    }.onAppear(perform: products.getProducts)
}
}
</code></pre>
","13742387","","8697793","","2021-03-05 23:44:52","2021-03-05 23:44:52","SwiftUI, @Published with ForEach not updating my View","<ios><swift><firebase><swiftui>","1","2","","","","CC BY-SA 4.0"
"66519416","1","66519511","","2021-03-07 17:34:15","","1","528","<p>I have a view model called <code>UserService</code>. Let's says that this stores all the user data and it's automatically updated when the data is changed in Firestore.</p>
<p>Then I have a View with a <code>TextField</code> called <code>phone</code>. This is used as an input to get the user phone number.</p>
<p>This view has a ViewModel also and this vm contains the <code>@Published var phone: String = &quot;&quot;</code> property which the TextField uses.</p>
<p><strong>The problem is that other than using this <code>TextField</code> to update the value I want it to also show the current value coming from <code>UserService</code>.</strong></p>
<p>I do not know how to pass this data from <code>UserService</code> to <code>TestViewModel</code>. If a put <code>UserService</code> inside <code>TestViewModel</code> the property wont be updated in real time since vm inside vm is not supported yet in SwiftUI. Right now i have ended up with two separate properties. the <code>phone</code> inside  <code>UserService</code> and the <code>phone</code> inside <code>TestViewModel</code>.</p>
<p>I thought of manually updating <code>phone</code> inside on init() (<code>TestViewModel</code>) but I'm not sure if thats the correct way to do it since I have a other properties other than <code>phone</code></p>
<p>How can I achieve smth like this?</p>
<pre><code>struct User: Identifiable, Codable {
    var phone: String
}


class UserService: ObservableObject {
    @Published var user: User?
}


struct TestView: View {
    @ObservedObject var testViewModel = TestViewModel()
    @EnvironmentObject var userService: UserService
    
    var body: some View {
        Form {
            Section(header: Text(&quot;PHONE NUMBER&quot;)) {
                TextField(&quot;Phone number&quot;, text: $testViewModel.phone)
            }
        }
    }
}


class TestViewModel: ObservableObject {
    @Published var phone: String = &quot;&quot;

    init() {
        prefillForm()
    }
    
    func prefillForm() {
      //
    }
    
}
</code></pre>
","2738166","","","","","2021-03-07 17:42:51","SwiftUI pre fill TextField from ViewModel","<ios><swift><xcode><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66522477","1","66537672","","2021-03-07 23:11:33","","0","763","<p>I previously asked <a href=""https://stackoverflow.com/questions/66448542/push-view-with-data-from-asynchronous-callback"">a question</a> about how to push a view with data received from an asynchronous callback. The method I ended up with has turned out to cause a Memory Leak.</p>
<p>I'm trying to structure my app with MVVM for SwiftUI, so a ViewModel should publish another ViewModel, that a View then knows how to present on screen. Once the presented view is dismissed from screen, I expect the corresponding ViewModel to be deinitialised. However, that's never the case with the proposed solution.</p>
<p>After <code>UserView</code> is dismissed, I end up having an instance of <code>UserViewModel</code> leaked in memory. <code>UserViewModel</code> never prints <em>&quot;Deinit UserViewModel&quot;</em>, at least not until next time a view is pushed on <code>pushUser</code>.</p>
<pre><code>struct ParentView: View {
    @ObservedObject var vm: ParentViewModel
    
    var presentationBinding: Binding&lt;Bool&gt; {
        .init(get: { vm.pushUser != nil },
              set: { isPresented in
                if !isPresented {
                    vm.pushUser = nil
                }
              }
        )
    }
    
    var body: some View {
        VStack {
            Button(&quot;Get user&quot;) {
                vm.getUser()
            }
            Button(&quot;Read user&quot;) {
                print(vm.pushUser ?? &quot;No userVm&quot;)
            }
            if let userVm = vm.pushUser {
                NavigationLink(
                    destination: UserView(vm: userVm),
                    isActive: presentationBinding,
                    label: EmptyView.init
                )
            }
        }
    }
}

class ParentViewModel: ObservableObject {
    @Published var pushUser: UserViewModel? = nil
    
    var cancellable: AnyCancellable?
    
    private func fetchUser() -&gt; AnyPublisher&lt;User, Never&gt; {
        Just(User.init(id: &quot;1&quot;, name: &quot;wiingaard&quot;))
            .delay(for: .seconds(1), scheduler: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
    
    func getUser() {
        cancellable = api.getUser().sink { [weak self] user in
            self?.pushUser = UserViewModel(user: user)
        }
    }
}

struct User: Identifiable {
    let id: String
    let name: String
}

class UserViewModel: ObservableObject, Identifiable {
    deinit { print(&quot;Deinit UserViewModel&quot;) }

    @Published var user: User
    init(user: User) { self.user = user }
}

struct UserView: View {
    @ObservedObject var vm: UserViewModel    
    var body: some View {
        Text(vm.user.name)
    }
}
</code></pre>
<p>After dismissing the <code>UserView</code> and I inspect the Debug Memory Graph, I see an instance of <code>UserViewModel</code> still allocated.</p>
<p><a href=""https://i.stack.imgur.com/wLxyj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wLxyj.png"" alt=""Leaked Object from Xcode's memory debugger"" /></a></p>
<p>The top reference (<code>view.content.vm</code>) has kind: <code>(AnyViewStorage in $7fff57ab1a78)&lt;ModifiedContent&lt;UserView, (RelationshipModifier in $7fff57ad2760)&lt;String&gt;&gt;&gt;</code> and hierarchy: <code>SwiftUI.(AnyViewStorage in $7fff57ab1a78)&lt;SwiftUI.ModifiedContent&lt;MyApp.UserView, SwiftUI.(RelationshipModifier in $7fff57ad2760)&lt;Swift.String&gt;&gt;&gt; AnyViewStorageBase _TtCs12_SwiftObject</code></p>
<p><strong>What's causing this memory leak, and how can I remove it?</strong></p>
","2299801","","2299801","","2021-03-07 23:39:30","2021-06-07 18:34:13","Published ViewModel causes memory leak when pushing a view with NavigationLink","<swift><memory-leaks><swiftui>","2","2","","","","CC BY-SA 4.0"
"66538341","1","66542235","","2021-03-08 22:47:39","","1","145","<p>I'm looking to wrap AVPlayer's play and pause methods so that I may use ReCombine effects to dispatch actions from SwiftUI which will ultimate play and pause some audio.</p>
<pre><code>public extension AVPlayer {
    func timeControlPub() -&gt; AnyPublisher&lt;TimeControlStatus, Never&gt; {
        publisher(for: \.timeControlStatus).eraseToAnyPublisher()
        
    }
    
    func playPub() -&gt; AnyPublisher&lt;() -&gt; Void, Never&gt; {
        publisher(for: \.play).eraseToAnyPublisher()
    }
}
</code></pre>
<p>The above snippet shows the general idea of the playback API and errors with:</p>
<p><strong>Key path cannot refer to instance method 'play()'</strong></p>
<p>Ive also tried</p>
<pre><code>protocol PlaybackAPIManager {
    func playStream() -&gt; AnyPublisher&lt;()-&gt; Void, Never&gt;
}

extension AVPlayer: PlaybackAPIManager {
    func playStream() -&gt; AnyPublisher&lt;()-&gt; Void, Never&gt;{
        return AVPlayer.play
    }
}
</code></pre>
<p>But receive the error:</p>
<p><strong>Cannot convert return expression of type '(AVPlayer) -&gt; () -&gt; Void' to return type 'AnyPublisher&lt;() -&gt; Void, Never&gt;'</strong></p>
<pre><code>static let togglePlayPause = Effect(dispatch: false)  { (actions: AnyPublisher&lt;Action, Never&gt;) in
            actions.ofTypes(TogglePlay.self)
                .flatMap(playStremAPI)
                .print(&quot;Stream Played&quot;)
                .eraseToAnyPublisher()
        }
</code></pre>
<p>I am have trouble wrapping AVPlayer methods with AnyPublisher to appease ReCombine.</p>
","10106418","","10106418","","2021-03-09 00:39:12","2021-03-09 07:03:31","Is it possible to wrap AVPlayer Play and Pause with AnyPublisher","<swift><avfoundation><avplayer><combine>","1","0","1","","","CC BY-SA 4.0"
"66558997","1","66559279","","2021-03-10 05:44:52","","0","182","<p>When I have a Binding in SwiftUI and I want to save whenever the binding changes I do (e.g. on a TextField)</p>
<pre><code>var myText: String { /* value is derived */ }
func save(_ text: String) { /* doing the save stuff */ }
TextFiel(text: .init(get: { myText }, set: { save($0) }) 
</code></pre>
<p>Doing this, <code>save()</code> gets called whenever the binding changes. In some cases this might not be ideal, e.g. when save() makes a server call or some expensive computations.  So what I'm looking for, is to get notified whenever the <strong>binding</strong> changes for the <em>last time</em>.
Maybe some kind of delayed observer that fires x seconds after the final change and get's invalidated if another change happens earlier than that threshold. Does Combine offer something like this?</p>
<p><strong>Disclaimer</strong>: This question is about bindings in general and not just about TextFields in particular. The Textfield is only a coding example , so <code>.onCommit</code> is not the solution I'm looking for ;)</p>
","1754221","","","","","2021-03-10 06:12:42","Capture the Very Last Change of a Binding in SwiftUI / Combine","<swift><swiftui><binding><onchange><combine>","1","0","1","","","CC BY-SA 4.0"
"66579482","1","66580926","","2021-03-11 09:14:02","","1","1903","<p>I have a Combine publisher like this:</p>
<pre><code>enum RemoteError: Error {
    case networkError(Error)
    case parseError(Error)
    case emptyResponse
}

func getPublisher(url: URL) -&gt; AnyPublisher&lt;Entiy, RemoteError&gt; {
    return URLSession.shared
        .dataTaskPublisher(for: url)
        .map(\.data)
        .decode(type: RemoteResponse.self, decoder: decoder)
        .mapError { error -&gt; RemoteError in
            switch error {
            case is URLError:
                return .networkError(error)
            default:
                return .parseError(error)
            }
        }
        .map { response -&gt; Entiy in
            response.enitities.last
        }
        .eraseToAnyPublisher()
}

struct RemoteResponse: Codable {
    let enitities: [Entity]
    let numberOfEntries: Int
}

struct Entity {

}
</code></pre>
<p>By the above setting, the compiler complains because <code>response.enitities.last</code> can be nil. The question is can I replace nil with Empty publisher and if not can I replace it with error <code>emptyResponse</code> in Combine chain? The first option is preferable.</p>
","3477974","","","","","2022-08-02 21:39:08","Replace nil with Empty or Error in Combine","<swift><reactive-programming><combine>","3","0","","","","CC BY-SA 4.0"
"66581811","1","66587914","","2021-03-11 11:39:01","","1","769","<p>Assume you have this WKWebView implementation:</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine
import SwiftUI
import WebKit

class WebViewData: ObservableObject {
    @Published var parsedText: NSAttributedString? = nil

    var isInit = false
    var shouldUpdateView = true
}

struct WebView: UIViewRepresentable {
    let text: String
    @ObservedObject var data: WebViewData

    func makeUIView(context: Context) -&gt; WKWebView {
        context.coordinator.view.navigationDelegate = context.coordinator
        return context.coordinator.view
    }

    func updateUIView(_ uiView: WKWebView, context: Context) {
        guard data.shouldUpdateView else {
            data.shouldUpdateView = false
            return
        }

        let html = &quot;&quot;&quot;
            &lt;html&gt;
                &lt;head&gt;
                    &lt;meta charset=&quot;UTF-8&quot; /&gt;
                    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;
                &lt;/head&gt;
                &lt;body&gt;
                    \(text)

                &lt;script&gt;
                    let isScrolling = false;
                    let timer;

                    function toggleScrolling() {
                        if(!isScrolling) {
                            timer = setInterval(function() {
                                window.scrollBy(0, 1);
                            }, \(80 / autoScrollVelocity));
                        } else {
                            clearInterval(timer)
                        }

                        isScrolling = !isScrolling;
                    }
                &lt;/script&gt;
                &lt;/body&gt;
            &lt;/html&gt;
        &quot;&quot;&quot;

        uiView.loadHTMLString(html, baseURL: nil)
    }

    func makeCoordinator() -&gt; WebViewCoordinator {
        return WebViewCoordinator(view: self)
    }
}

class WebViewCoordinator: NSObject, WKNavigationDelegate {
    let view: WebView

    init(view: WebView) {
        self.view = view

        super.init()
    }

    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        DispatchQueue.main.async {
            if !self.view.data.isInit {
                self.view.data.isInit = true
                // useless text parsing here...
            }
        }
    }
}
</code></pre>
<p>in this view</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI

struct ReadingView: View {
    @ObservedObject var webViewData = WebViewData()
    private let text: String

    init(text: String?) {
        self.text = text ?? &quot;Sorry, this reading is empty&quot;
    }

    var body: some View {
        VStack {
            Button(&quot;Auto scroll&quot;) {
                ??????
            }
            WebView(title: self.title, text: self.text, data: self.webViewData)
        }
        .onReceive(self.webViewData.$parsedText, perform: { parsedText in
            if let parsedText = parsedText {
               print(parsedText)
            }
        })
    }
}
</code></pre>
<p>Now, in the button with label <code>Auto scroll</code>, how is it possible to call the javascript inside the html <code>toggleScrolling()</code> (or moving this code in a WKUserScript if necessary)? I'm pretty lost here.</p>
<p>Thanks in advance for any suggestion</p>
","813728","","","","","2021-03-11 17:54:48","Call evaluateJavascript from a SwiftUI button","<javascript><swift><swiftui><wkwebview>","1","0","1","","","CC BY-SA 4.0"
"66588983","1","66594384","","2021-03-11 19:10:15","","0","243","<p>Is it possible to fire multiple requests which return a <code>Publisher</code> and be able to cancel them without <code>sink</code>?</p>
<p>I would like to combine the requests into a single cancellable reference or store each one if possible without <code>sink</code> (code below). Is this possible?</p>
<pre class=""lang-swift prettyprint-override""><code>func fetchDetails(for contract: String) -&gt; AnyPublisher&lt;String, Error&gt;
</code></pre>
<p>Fire Multiple requests and store</p>
<pre class=""lang-swift prettyprint-override""><code>  @State var cancellable: Set&lt;AnyCancellable&gt; = []

    let promises = items.map {
      self.fetchFeed.fetchDetails(for: $0.contract)
    }
    
    Publishers.MergeMany(promises)
      .sink(receiveCompletion: { _ in }, receiveValue: { _ in }) // ** is this required?
      .store(in: &amp;cancellable)
</code></pre>
","5222077","","5222077","","2021-03-12 02:33:59","2021-03-12 04:54:38","Swift Combine erase array of publishers into AnyCancellable","<swift><combine>","1","0","0","","","CC BY-SA 4.0"
"66592683","1","66592922","","2021-03-12 00:53:54","","2","191","<p>I am new to swift and I am having treouble making my SwiftUI and UIkit pices of code talk to each other.</p>
<p>I have a variable in my swiftUI that I want to transfer to the UIkit piece or vice versa.</p>
<p>This is my swfitUI code and I want to pass <code>someString</code> to the UIKit code</p>
<pre><code>struct ForceTestView: View {
//MARK: - PROPERTIES

//MARK: - BODY
var body: some View {
    
    VStack(spacing: 20){
        
        TouchesSwiftUI()
        .border(Color.gray, width: 5)
        .frame(maxWidth: 200, maxHeight: 200)
        
        Text(&quot;\(someString)&quot;)
            .onTapGesture {
                someString = &quot;New Value&quot;
            }

        
    }//:VSTACK

  
    
}//: BODY


struct TouchesSwiftUI: UIViewControllerRepresentable {
  
    func makeUIViewController(context: Context) -&gt; TouchesHelper {
        let touchControl = TouchesHelper()
        
         return touchControl
        
    }
    func updateUIViewController(_ uiViewController: TouchesHelper, context: Context) {
          
    }
    

}
</code></pre>
<p>This is the UIkit code that I have</p>
<pre><code>import Foundation
import UIKit
import SwiftUI
import Combine

class TouchesHelper: UIViewController{
    
    var forceLabel: UILabel!
    var forceText: String = &quot;frcTxt Empty&quot;
    
    var xPosLabel: UILabel!
    
    
    
    override func loadView() {
        view = UIView()
        view.backgroundColor = .white
        
        forceLabel = UILabel()
        forceLabel.translatesAutoresizingMaskIntoConstraints = false
        forceLabel.textAlignment = .left
        forceLabel.font = UIFont.systemFont(ofSize: 18)
        forceLabel.text = &quot;Force Readings&quot;
        forceLabel.numberOfLines = 0
        view.addSubview(forceLabel)
        
        xPosLabel = UILabel()
        xPosLabel.translatesAutoresizingMaskIntoConstraints = false
        xPosLabel.textAlignment = .left
        xPosLabel.font = UIFont.systemFont(ofSize: 18)
        xPosLabel.text = &quot;Finger X Position&quot;
        xPosLabel.numberOfLines = 0
        view.addSubview(xPosLabel)
        
        NSLayoutConstraint.activate([
            forceLabel.topAnchor.constraint(equalTo: view.layoutMarginsGuide.topAnchor),
            forceLabel.leadingAnchor.constraint(equalTo: view.layoutMarginsGuide.leadingAnchor),
            
            xPosLabel.topAnchor.constraint(equalTo: forceLabel.bottomAnchor),
            xPosLabel.leadingAnchor.constraint(equalTo: view.layoutMarginsGuide.leadingAnchor),

        ])
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
    }
    
    override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {
        if let touch = touches.first{
            let userForce = touch.force
            forceLabel.text = &quot;Force: \(userForce)&quot;
            forceText = &quot;\(userForce)&quot;
            print(&quot;UI \(testString)&quot;)
        }//:if touch
        
    }//: touchesMoved

}
</code></pre>
<p>I would want to pass the userForce to swiftUI, and then update something like the userxPosLabel with the text input from SwiftUI</p>
<p>I have tried to look at @Obverbable objects and coordinators, but they don't really make sense or work because they don't help in passing things that are connected to touching events within TOuchesMoved (I am coding this for a project that uses an iPhoneX, which had 3D touch)</p>
<p>Any help will be really appreciated!</p>
<p>Thank you!</p>
","15379339","","","","","2021-05-01 12:09:08","Working in Swift: How to transfer variables between UIKit (ViewRepresentabble) and SwiftUI","<swift><swiftui><uikit>","1","0","","","","CC BY-SA 4.0"
"66594921","1","66630766","","2021-03-12 05:57:11","","0","445","<p>i'm new in SwiftUI. So, I am doing my practice and create some kind of cashier app and here I been stuck for a while. In <code>ProductPageView</code> I can increase and decrease the number of item. Then, when I go to <code>DetailOrderView</code> (like a cart view), I can also increase and decrease the quantity number. The print shows the quantity number correctly.
But if I go back to <code>ProductPageView</code>, the label doesn't update it self.</p>
<p>Take a look at this screenshots:</p>
<p>First, I add 2 items.</p>
<p><a href=""https://i.stack.imgur.com/JybeAl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JybeAl.png"" alt=""enter image description here"" /></a></p>
<p>Then I go to <code>DetailOrderView</code>, the quantity number is the same.:</p>
<p><a href=""https://i.stack.imgur.com/P8BkGl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/P8BkGl.png"" alt=""enter image description here"" /></a></p>
<p>Then I add 2 items in <code>DetailOrderView</code> (so it's now 4 items) and going back to <code>ProductPageView</code>, notice how the total price has increased but the quantity doesn't change. I feel like I want to &quot;refresh&quot; or &quot;reload data&quot; on this page.</p>
<p><a href=""https://i.stack.imgur.com/MQTz5l.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/MQTz5l.png"" alt=""enter image description here"" /></a></p>
<p>How can I fix this and update the Text when I press the back button?</p>
<p>Here's my code:</p>
<p>Main</p>
<pre><code>import SwiftUI

@main
struct CashierApp: App {
    @StateObject var productOder = ProductPresenter()

var body: some Scene {
    WindowGroup {
        MainPageView()
            .environmentObject(productOder)
    }
}
</code></pre>
<p>}</p>
<p>Product Page View
import SwiftUI</p>
<pre><code>struct ProductPageView: View {
    @EnvironmentObject var productOrder: ProductPresenter


var body: some View {
    VStack {
        ScrollView {
            VStack {
                ForEach(productOrder.cartItems, id: \.item.idItem) { element in
                    ProductRow(cartItems: CartItems(item: element.item, quantity: element.quantity))
                }
            }
        }
        TotalPaymentRow()
    }
}
</code></pre>
<p>}</p>
<p>Detail Order View or Cart View
import SwiftUI</p>
<pre><code>struct DetailOrderView: View {
    @EnvironmentObject var productOrder: ProductPresenter
    var arrayOrdered: [CartItems] = []


var body: some View {
    
    ZStack {
        ScrollView {
            VStack {
                ForEach(arrayOrdered, id: \.item.idItem) { element in
                    ProductRow(cartItems: CartItems(item: element.item, quantity: element.quantity))
                }
            }
            .padding(.top, 10)
        }
        CustomModalGrandTotal()
    }
    .navigationTitle(&quot;Cart&quot;)
    .navigationBarTitleDisplayMode(.inline)
}
</code></pre>
<p>}</p>
<p>The Presenter</p>
<pre><code>import SwiftUI
import Combine

class ProductPresenter: ObservableObject {
     @Published var cartItems: [CartItems] = []
     var totalQuantity = 0

     // Increment product
     func increment(cartItem: inout CartItems) {
         let index: Int = cartItems.firstIndex(where: {$0.item == cartItem.item}) ?? -1
         cartItems[index].quantity += 1
         totalQuantity += 1
     }

     // Decrement product
     func decrement(cartItem: inout CartItems) {
         let index: Int = cartItems.firstIndex(where: {$0.item == cartItem.item}) ?? -1
         if cartItems[index].quantity &gt; 0 {
             cartItems[index].quantity -= 1
             totalQuantity -= 1
         }
     }
}
</code></pre>
<p>Product Row</p>
<pre><code>import SwiftUI

struct ProductRow: View {
    @State var cartItems: CartItems
    @EnvironmentObject var productOrder: ProductPresenter

var body: some View {
    
    HStack(alignment: .center) {
        Image(cartItems.item.image ?? &quot;&quot;)
        VStack(alignment: .leading, spacing: 8) {
            Text(cartItems.item.name ?? &quot;&quot;)
            Text(getPrice(value: cartItems.item.price ?? 0))
        }
        Spacer()
        VStack {
            Spacer()
            HStack{
                Button(action: {
                    if cartItems.quantity &gt; 0 {
                        cartItems.quantity -= 1
                        productOrder.decrement(cartItem: &amp;cartItems)
                        productOrder.calculateTotalPrice()
                    }
                }, label: {
                    imageMinusPlus(name: &quot;minus&quot;)
                })
                Text(&quot;\(cartItems.quantity)&quot;) // This Text should be updated.
                Button(action: {
                    cartItems.quantity += 1
                    productOrder.increment(cartItem: &amp;cartItems)
                    productOrder.calculateTotalPrice()
                }, label: {
                    imageMinusPlus(name: &quot;plus&quot;)
                })
            }
        }
    }
}
}
</code></pre>
<p>PS: I deleted the styling to make the code shorter.</p>
<p>Thankyou in advance</p>
","11195057","","11195057","","2021-03-12 07:20:28","2021-03-17 17:57:43","Can't Update Text on Previous View using @EnvironmentObject SwiftUI","<ios><swift><swiftui><state><environmentobject>","2","4","1","","","CC BY-SA 4.0"
"66602791","1","66607851","","2021-03-12 15:30:29","","0","119","<p>I have an observable object class that downloads an image from a url to display:</p>
<pre><code>class ImageLoader : ObservableObject {
var didChange = PassthroughSubject&lt;Data, Never&gt;()
var data = Data() {
    didSet {
        didChange.send(data)
    }
}
init(urlString:String){
    guard let url = URL(string: urlString) else {return}
    let task = URLSession.shared.dataTask(with: url) { data, response, error in
        guard let data = data else { return }
        DispatchQueue.main.async {
            self.data = data
            print(&quot;imageloader1&quot;)
        }
    }
    task.resume()
}
</code></pre>
<p>and I show it using:</p>
<pre><code>struct ShowImage1: View {
@ObservedObject var imageLoader:ImageLoader
@State var image:UIImage = UIImage()

init(withURL url:String) {
    imageLoader = ImageLoader(urlString:url)
}

var body: some View {
    Image(uiImage: image)
    .resizable()
    .aspectRatio(contentMode: .fit)
    .edgesIgnoringSafeArea(.top)
    .onReceive(imageLoader.didChange) {
            data in self.image = UIImage(data: data) ?? UIImage()
    }
}
</code></pre>
<p>The problem I'm having is this is only capable of running once, If i click off the <code>ShowImage1</code> view and then click back on to it, <code>ImageLoader</code> doesn't run again, and I'm left with a blank page.</p>
<p>How can I ensure that <code>ImageLoader</code> Runs every time the <code>ShowImage1</code> view is accessed?</p>
<p>EDIT:</p>
<p>I access ShowImage1 like this:</p>
<pre><code>struct PostCallForm: View {
  var body: some View {
    NavigationView {
        Form {
            Section {
                    Button(action: {
                        if true {
                            self.showImage1 = true
                        }
                    }){
                        Text(&quot;View Camera 1 Snapshot&quot;)
                    }.overlay(NavigationLink(destination: ShowImage1(withURL: &quot;example.com/1.jpg&quot;), isActive: self.$showImage1, label: {
                            EmptyView()
                        }))
                }

            }
            Section {
                Button(action: {
                }){
                    Text(&quot;Submit&quot;)
                    }
                }
            }.disabled(!submission.isValid)
        }
</code></pre>
<p>}
}</p>
","12109121","","12109121","","2021-03-12 15:45:15","2021-03-12 23:37:21","SWIFTUI Observable Object Data Task only runs once?","<swift><swiftui>","1","11","","","","CC BY-SA 4.0"
"66608682","1","66610389","","2021-03-12 23:49:46","","1","307","<p>I am currently running into an issue that is confusing me. I am trying to create a user using Firebase for my app, which is a SwiftUI app. I have a <code>UserDataController</code> that holds onto a <code>@Published var profile: Profile?</code> variable.</p>
<p>What I am noticing is that after creating a <code>Profile</code> in Firebase I get the callback with the data and decode it into my model. I then set that decoded model on my published property. However, when I do that the SwiftUI view does not change like I expect it to.</p>
<p>I have tested this functionality before introducing Firebase with test data. When I set the published property with the test data I do see the SwiftUI views update accordingly. I see that happen even when I update the published property in a <code>DispatchQueue.main.asyncAfter</code> block to simulate a network request.</p>
<p>Am I doing something wrong that is not allowing SwiftUI to update?</p>
<p>Also note that I am using <a href=""https://github.com/hmlongco/Resolver"" rel=""nofollow noreferrer"">Resolver</a> for my <code>UserDataController</code> injection. The <code>@InjectedObject</code> grabs an <code>@ObservedObject</code> for use in SwiftUI views.</p>
<p>Here is my code:</p>
<p><strong>App.swift</strong></p>
<pre><code>import Resolver
import SwiftUI

@main
struct MyApp: App {

    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

    @InjectedObject var userController: UserDataController

    init() {
          // This is the method that calls `DispatchQueue.main.asyncAfter` which causes the
          // view to update correctly.
//        userController.authenticate()
    }

    var body: some Scene {
        WindowGroup {
            // This is where SwiftUI should be updating to show the profile instead of 
            // the LandingView since we have been logged in.
            if let profile = userController.profile {
                ProfileView()
                    .environmentObject(ProfileViewModel(profile: profile))
            } else {
                // This is where the login form is
                LandingView()
            }
        }
    }
}
</code></pre>
<p><strong>UserDataController.swift</strong></p>
<pre><code>import Firebase
import FirebaseAuth
import FirebaseFirestoreSwift
import Foundation

// This AuthError also will not show as an alert when set from a completion block
enum AuthError: Error, Identifiable {

    var id: AuthError { self }

    case noUser
    case emailExists
    case couldNotSignOut
    case generic
}

final class UserDataController: ObservableObject {

    @Published var profile: Profile? {
        didSet {
            print(&quot;Profile: \(profile)&quot;)
        }
    }
    @Published var user: User?

    @Published var authError: AuthError?

    private lazy var db = Firestore.firestore()

    private var authStateListener: AuthStateDidChangeListenerHandle?
    private var profileListener: ListenerRegistration?

    // MARK: Auth

    func authenticate() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            self.profile = TestData.amyAlmond
        }
    }

    func login(email: String, password: String) {
        applyStateListener()

        Auth.auth().signIn(withEmail: email, password: password) { [weak self] result, error in
            if let error = error {
                self?.authError = .generic
            } else if let user = result?.user {
                self?.addSnapshotListener(for: user)
            } else {
                self?.authError = .noUser
            }
        }
    }

    func signUp(email: String, password: String, firstName: String, lastName: String) {
        applyStateListener()

        Auth.auth().createUser(withEmail: email, password: password) { [weak self] result, error in
            if let error = error {
                self?.authError = .generic
            } else if let user = result?.user {
                self?.addSnapshotListener(for: user)
                self?.createProfile(for: user, firstName: firstName, lastName: lastName)
            } else {
                self?.authError = .noUser
            }
        }
    }
}

// MARK: - Private

private extension UserDataController {

    func applyStateListener() {
        guard authStateListener == nil else { return }

        authStateListener = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
            guard let self = self else { return }

            if let user = auth.currentUser {
                self.user = user
            } else {
                self.user = nil
                self.profile = nil

                self.profileListener?.remove()
                self.profileListener = nil

                if let stateListener = self.authStateListener {
                    Auth.auth().removeStateDidChangeListener(stateListener)
                    self.authStateListener = nil
                }
            }
        }
    }

    func addSnapshotListener(for user: User) {
        guard profileListener == nil else { return }

        profileListener = db.collection(&quot;profiles&quot;).document(user.uid).addSnapshotListener { [weak self] snapshot, error in
            guard let self = self else { return }
            guard let snapshot = snapshot else { return }

            do {
                // Setting the profile here does not change the SwiftUI view
                // These blocks happen on the main thread as well, so wrapping this
                // in a `DispatchQueue.main.async` does nothing.
                self.profile = try snapshot.data(as: Profile.self)
            } catch {
                print(&quot;Error Decoding Profile: \(error)&quot;)
            }
        }
    }

    func createProfile(for user: User, firstName: String, lastName: String) {
        let profile = Profile(uid: user.uid, firstName: firstName, lastName: lastName, farms: [], preferredFarmId: nil)

        do {
            try db.collection(&quot;profiles&quot;).document(user.uid).setData(from: profile)
        } catch {
            print(error)
        }
    }
}
</code></pre>
<p><strong>LandingView.swift</strong></p>
<pre><code>import Resolver
import SwiftUI

struct LandingView: View {

    @InjectedObject private var userController: UserDataController

    var body: some View {
        VStack(spacing: 10) {
            LightText(&quot;Title&quot;)
                .font(.largeTitle)

            Spacer()

            AuthenticationView()

            Spacer()
        }
        .frame(maxWidth: .infinity)
        .padding()
        .alert(item: $userController.authError) { error -&gt; Alert in
            Alert(title: Text(&quot;Oh Boy&quot;), message: Text(&quot;Something went wrong&quot;), dismissButton: .cancel())
        }
    }
}
</code></pre>
<p><strong>AuthenticationView.swift</strong></p>
<pre><code>import SwiftUI

struct AuthenticationView: View {

    @StateObject private var viewModel = AuthenticationViewModel()

    var body: some View {
        VStack {
            VStack {
                Group {
                    switch viewModel.mode {
                    case .login:
                        loginForm
                    case .signUp:
                        signUpForm
                    }
                }
                .textFieldStyle(RoundedBorderTextFieldStyle())
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 20)
                    .foregroundColor(Color.gray)
            )

            Button(action: viewModel.switchMode) {
                Text(viewModel.switchModeTitle)
            }
            .padding(.bottom, 10)

            Button(action: viewModel.submitAction) {
                Text(viewModel.submitButtonTitle)
            }
            .disabled(!viewModel.isValid)
        }
        .padding()
    }
}

private extension AuthenticationView {

    @ViewBuilder
    var loginForm: some View {
        TextField(&quot;Email Address&quot;, text: $viewModel.emailAddress)
        TextField(&quot;Password&quot;, text: $viewModel.password)
    }

    @ViewBuilder
    var signUpForm: some View {
        TextField(&quot;First Name&quot;, text: $viewModel.firstName)
        TextField(&quot;Last Name&quot;, text: $viewModel.lastName)
        TextField(&quot;Email Address&quot;, text: $viewModel.emailAddress)
        TextField(&quot;Password&quot;, text: $viewModel.password)
        TextField(&quot;Confirm Password&quot;, text: $viewModel.confirmPassword)
    }
}
</code></pre>
<p><strong>AuthenticationViewModel.swift</strong></p>
<pre><code>import Foundation
import Resolver

final class AuthenticationViewModel: ObservableObject {

    @Injected private var userController: UserDataController

    enum Mode {
        case login, signUp
    }

    @Published var firstName: String = &quot;&quot;
    @Published var lastName: String = &quot;&quot;
    @Published var emailAddress: String = &quot;&quot;
    @Published var password: String = &quot;&quot;
    @Published var confirmPassword: String = &quot;&quot;

    @Published var mode: Mode = .login
}

extension AuthenticationViewModel {

    var isValid: Bool {
        switch mode {
        case .login:
            return !emailAddress.isEmpty &amp;&amp; isPasswordValid
        case .signUp:
            return !firstName.isEmpty
                &amp;&amp; !lastName.isEmpty
                &amp;&amp; !emailAddress.isEmpty
                &amp;&amp; isPasswordValid
                &amp;&amp; !confirmPassword.isEmpty
                &amp;&amp; password == confirmPassword
        }
    }

    var submitButtonTitle: String {
        switch mode {
        case .login:
            return &quot;Login&quot;
        case .signUp:
            return &quot;Create Account&quot;
        }
    }

    var switchModeTitle: String {
        switch mode {
        case .login:
            return &quot;Create a New Account&quot;
        case .signUp:
            return &quot;Login&quot;
        }
    }

    func switchMode() {
        if mode == .login {
            mode = .signUp
        } else {
            mode = .login
        }
    }

    func submitAction() {
        switch mode {
        case .login:
            loginUser()
        case .signUp:
            createUser()
        }
    }
}

private extension AuthenticationViewModel {

    var isPasswordValid: Bool {
        !password.isEmpty &amp;&amp; password.count &gt; 8
    }

    func loginUser() {
        userController.login(email: emailAddress, password: password)
    }

    func createUser() {
        userController.signUp(email: emailAddress, password: password, firstName: firstName, lastName: lastName)
    }
}
</code></pre>
","2317492","","2317492","","2021-03-13 00:12:17","2021-03-13 05:24:41","Setting @Published var in Firebase Completion Block Not Updating SwiftUI View","<ios><swift><firebase><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66612944","1","66613030","","2021-03-13 11:30:40","","2","1933","<p>I had a setup using <code>@State</code> in my SwiftUI view and going all my operations in the View (loading API etc) however when attempting to restructure this away from using <code>@ViewBuilder</code> and <code>@State</code> and using a <code>@ObservedObject</code> ViewModel, I lost the ability to dynamically change my view based on the <code>@State</code> variables</p>
<p>My code is now</p>
<pre><code>    
    @ObservedObject private var contentViewModel: ContentViewModel
    
    init(viewModel: ContentViewModel) {
        self.contentViewModel = viewModel
    }
    
    var body: some View {
        if contentViewModel.isLoading {
            loadingView
        }
        else if contentViewModel.fetchError != nil {
            errorView
        }
        else if contentViewModel.movies.isEmpty {
            emptyListView
        } else {
            moviesList
        }
    }
</code></pre>
<p>However whenever these viewmodel properties change, the view doesn't update like it did when i used them in the class as <code>@State</code> properties...</p>
<p>ViewModel is as follows:</p>
<pre><code>final class ContentViewModel: ObservableObject {

    var movies: [Movie] = []
    var isLoading: Bool = false
    var fetchError: String?
    
    private let dataLoader: DataLoaderProtocol
    
    init(dataLoader: DataLoaderProtocol = DataLoader()) {
        self.dataLoader = dataLoader

        fetch()
    }

    func fetch() {
        isLoading = true
        dataLoader.loadMovies { [weak self] result, error in
            guard let self = `self` else { return }
            self.isLoading = false
            guard let result = result else {
                return print(&quot;api error fetching&quot;)
            }
            guard let error = result.errorMessage, error != &quot;&quot; else {
                return self.movies = result.items
            }
            return self.fetchError = error
        }
    }
</code></pre>
<p>How can i bind these 3 state deciding properties to View outcomes now they are abstracted away to a viewmodel?</p>
<p>Thanks</p>
","7321892","","4145420","","2022-07-20 13:06:46","2022-07-20 13:06:46","Updating SwiftUI View Based on ViewModel States?","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"66616334","1","66625395","","2021-03-13 17:14:29","","1","418","<p>I'm wondering if there is a way to chain <strong>array of publishers</strong> similar to how we chain publishers with regular <code>flatMap</code></p>
<p>Let's say I have three publishers: <strong>publisher1, publisher2, publisher3</strong> all of them <strong>have the same Output, Failure types</strong>. For example, each of them is <code>AnyPublisher&lt;String, Never&gt;</code> and emits a single String value. The only role of each publisher is to fetch its own value and emits previous value joined with its own.</p>
<p>I'm looking for same effect as from the following pseudo code:</p>
<pre><code>let pipe = publisher1(value: &quot;&quot;)
      .flatMap { publisher2(value: $0) }
      .flatMap { publisher3(value: $0) }
</code></pre>
<p>Execution flow:</p>
<blockquote>
<p>publisher1 (fetches &quot;A&quot;) -&gt; publisher2 (fetches &quot;B&quot;) -&gt; publisher3 (fetches &quot;C&quot;) -&gt; &quot;ABC&quot;</p>
</blockquote>
<p>I would like to reproduce the same flow for the array with unknown count of publishers <strong>n</strong> <code>([AnyPublisher&lt;String, Never&gt;])</code></p>
<blockquote>
<p>1 -&gt; 2 -&gt; 3 -&gt; ... -&gt; n</p>
</blockquote>
<p>I'll appreciate any tips, thanks! :)</p>
","6857974","","6857974","","2021-03-14 11:14:38","2022-06-30 18:41:08","Chaining array of AnyPublishers","<swift><combine>","3","2","1","","","CC BY-SA 4.0"
"66619128","1","66620390","","2021-03-13 22:18:41","","0","145","<p>I have a property with a fixed type</p>
<pre><code>var statusPublisher: Published&lt;Status&gt;.Publisher
</code></pre>
<p>and some other statuses like <code>substatus1</code>, <code>substatus2</code></p>
<p>and I want it to combine values of other statuses like</p>
<pre><code>var statusPublisher: Published&lt;Status&gt;.Publisher {
    $substatus1.combineLatest($substatus2).map { s1, s2 -&gt; Status in ... }
}
</code></pre>
<p>but it says <code>Cannot convert return expression of type 'Publishers.CombineLatest&lt;Published&lt;Substatus1&gt;.Publisher, Published&lt;Substatus2&gt;.Publisher&gt;' to return type 'Published&lt;Status&gt;.Publisher'</code></p>
<p>I managed to workaround it with one extra</p>
<pre><code>var connectionStatusSubject = PassthroughSubject&lt;Status, Never&gt;()
</code></pre>
<p>that I put into</p>
<pre><code>var connectionStatusPublisher: AnyPublisher&lt;Status, Never&gt; {
    connectionStatusSubject.eraseToAnyPublisher()
}
</code></pre>
<p>with new <code>AnyPublisher</code> here, but it seems not so neat.</p>
<p>Is there any way to make it the right way?</p>
","1261347","","","","","2021-03-14 02:00:31","Deriving Publisher from different publishers in Combine","<ios><swift><xcode><combine>","1","1","","","","CC BY-SA 4.0"
"66621874","1","66627313","","2021-03-14 06:54:52","","0","767","<p>In the <code>init()</code> of my <code>ViewModel</code>, I have 2 subscribers.</p>
<ol>
<li>The first one subscribes to downloaded data within <code>DataProvider()</code> and updates <code>downloadedData</code> with the result. This makes an API call and usually takes a few seconds before publishing data.</li>
<li>The second one subscribes to <code>$savedData</code> and then updates the <code>filteredData</code> array only with data that is contained in the <code>savedData</code> <strong>AND</strong> the <code>downloadedData</code>.</li>
</ol>
<p>The problem is that the <code>downloadedData</code> takes time to download, while <code>savedData</code> is instant (it's actually in Core Data). After it downloads, I want to force an update to the second observer above (<code>$savedData</code>) to update the <code>filteredData</code> accordingly.</p>
<p><strong>Is there a way to manually force a publisher to publisher a value? On ObservedObjects, we can call <code>objectWillChange.send()</code> but is there something like that I can call on <code>$savedData</code>?</strong></p>
<p><em>Disclaimer: This is a super-simplified version of my app. Please do not include answers that change the hierarchy. I also realize that I can add another publisher on $allCoins to mimic the one on $savedData, but I'd rather just force an update to $savedData. Thanks!</em></p>
<pre class=""lang-swift prettyprint-override""><code>    import SwiftUI
    
    struct TestView: View {
        
        @StateObject var vm = ViewModel()
        
        
        var body: some View {
            VStack {
                ForEach(vm.filteredData, id: \.self) { user in
                    Text(user)
                }
            }
        }
    }
    
    struct TestView_Previews: PreviewProvider {
        static var previews: some View {
            TestView()
        }
    }
    
    import Combine
    
    class ViewModel: ObservableObject {
        
        @Published var downloadedData: [String] = []
        @Published var savedData: [String] = []
        @Published var filteredData: [String] = []
        var cancellables = Set&lt;AnyCancellable&gt;()
        @Published var provider = DataProvider()
    
        init() {
            // WHEN THIS GETS PUBLISHED...
            // CAN I FORCE A PUBLISH / UPDATE TO savedData?
            provider.$data
                .assign(to: \.downloadedData, on: self)
                // here?
                .store(in: &amp;cancellables)
            
            $savedData
                .map { (saved) -&gt; [String] in
                    return saved.map { (savedItem) -&gt; String in
                        return self.downloadedData.contains(savedItem) ? savedItem : &quot;NO&quot;
                    }
                }
                .assign(to: \.filteredData, on: self)
                .store(in: &amp;cancellables)
            
            getSavedData()
        }
        
        func getSavedData() {
            savedData = [&quot;ONE&quot;, &quot;TWO&quot;]
        }
        
    }
    
    class DataProvider: ObservableObject {
        
        @Published var data: [String] = []
        
        init() {
            getData()
        }
        
        func getData() {
            // simulating api call
            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                self.data.append(contentsOf: [&quot;ONE&quot;, &quot;TWO&quot;])
            }
        }
    }

</code></pre>
","11279971","","11279971","","2021-03-14 18:12:30","2021-03-14 18:12:30","Force publisher to publish an update?","<swift><swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"66627029","1","66627053","","2021-03-14 16:42:58","","0","44","<ul>
<li><p>I have an array of objects.</p>
</li>
<li><p>Every object has an ID.</p>
</li>
<li><p>I have a UIStackview.</p>
</li>
<li><p>Every object is dynamically added to the UIStackview as an arranged Subview (a Stackview as well).</p>
</li>
<li><p>Every Subview has a UITapGestureRecognizer.</p>
</li>
<li><p>The Recognizer's action is a selector.</p>
</li>
</ul>
<p><strong>How do I pass the object in that selector?</strong></p>
<p>The subview's tap gesture:</p>
<pre class=""lang-swift prettyprint-override""><code>subview.addGestureRecognizer(UITapGestureRecognizer(target: self, action: Selector))
</code></pre>
<p>The function being triggered on tap (modified for better understanding):</p>
<pre class=""lang-swift prettyprint-override""><code>@objc func addModelToScene(sender: AnyObject, myWantedObject: MyObject) {
        let anchor = AnchorEntity(plane: .horizontal)
        anchor.name = &quot;modelAnchor&quot;
        self.arView.scene.addAnchor(anchor)
        
        var cancellable: AnyCancellable? = nil
        cancellable = ModelEntity.loadModelAsync(named: myWantedObject.mesh)
            .sink(receiveCompletion: {error in
                print(&quot;Unexpected error: \(error)&quot;)
                cancellable?.cancel()
            }, receiveValue: {entity in
                anchor.addChild(entity)
                cancellable?.cancel()
            })
    }
</code></pre>
<p>In general, the question is:</p>
<p><strong>How do I pass a custom parameter into a selector?</strong></p>
","13353451","","","","","2021-03-14 19:09:58","How to pass custom parameter in selector","<ios><arrays><swift><uikit>","2","0","","","","CC BY-SA 4.0"
"66628712","1","66629431","","2021-03-14 19:30:31","","0","62","<p>I'm trying to use SwiftUI in a project but beyond the very basic version of using @States and @Bindings that can be found in every tutorial, so I need some help on what I'm doing wrong here.</p>
<p>Environment Setup:
I have following files involved with this problem:</p>
<ul>
<li><strong>CustomTextField</strong>: It's a SwiftUI View that contains an internal TextField along with bunch of other things (According to the design)</li>
<li><strong>CustomTextFieldConfiguration</strong>: Contains the things that I need to configure on my custom textfield view</li>
<li><strong>RootView</strong>: It's a SwiftUI View that is using CustomTextField as one of it's subviews</li>
<li><strong>RootPresenter</strong>: This is where the UI Logic &amp; Presentation Logic goes (Between the view and business logic)</li>
<li><strong>RootPresentationModel</strong>: It's the viewModel through which the Presenter can modify view's state</li>
<li><strong>RootBuilder</strong>: It contains the builder class that uses the builder pattern to wire components together</li>
</ul>
<p><em><strong>The Problem</strong></em>:</p>
<ul>
<li>The textField value does not update in the <strong>textValue</strong> property of <strong>rootPresentationModel</strong></li>
</ul>
<p>Here are the implementations (Partially) as I have done and have no idea where I have gone wrong:</p>
<p><strong>CustomTextField</strong>:</p>
<pre><code>struct CustomTextField: View {
@Binding var config: CustomTextFieldConfiguration

var body: some View {
    ZStack {
        VStack {
            VStack {
                ZStack {
                    HStack {
                        TextField($config.placeHolder,
                                  value: $config.textValue,
                                  formatter: NumberFormatter(),
                                  onEditingChanged: {_ in },
                                  onCommit: {})
                            .frame(height: 52.0)
                            .padding(EdgeInsets(top:    0, leading:  16 + ($config.detailActionImage != nil ? 44 : 0),
                                                bottom: 0, trailing: 16 + ($config.contentAlignment == .center &amp;&amp; $config.detailActionImage != nil ? 44 : 0)))
                            .background($config.backgroundColor)
                            .cornerRadius($config.cornerRedius)
                            .font($config.font)
            ...
            ...
            ...
            ...
</code></pre>
<p><strong>CustomTextFieldConfiguration</strong>:</p>
<pre><code>struct CustomTextFieldConfiguration {
    @Binding var textValue: String
    ...
    ...
    ...
    ...
</code></pre>
<p><strong>RootView</strong>:</p>
<pre><code>struct RootView: View {
    @State var configuration: CustomTextFieldConfiguration
    var interactor: RootInteractorProtocol!
    @Environment(\.colorScheme) private var colorScheme
    
    var body: some View {
        HStack {
            Spacer(minLength: 40)
            VStack(alignment: .trailing) {
                CustomTextField(config: $configuration)
                Text(&quot;\(configuration.textValue)&quot;)
            }
            Spacer(minLength: 40)
        }
    }
}
</code></pre>
<p><strong>RootPresenter</strong>:</p>
<pre><code>class RootPresenter: BasePresenter {

    @ObservedObject var rootPresentationModel: RootPresentationModel

    init(presentationModel: RootPresentationModel) {
        rootPresentationModel = presentationModel
    }
    ...
    ...
    ...
</code></pre>
<p><strong>RootPresentationModel</strong>:</p>
<pre><code>class RootPresentationModel: ObservableObject {
    var textValue: String = &quot;&quot;  {
        didSet {
            print(textValue)
        }
    }
}
</code></pre>
<p><strong>RootBuilder</strong>:</p>
<pre><code>class RootBuilder: BaseBuilder {
    class func build() -&gt; (RootView, RootInteractor) {
        let interactor = RootInteractor()
        
        let presenter = RootPresenter(presentationModel: RootPresentationModel())
        let view: RootView = RootView(configuration: CustomTextFieldConfiguration.Presets.priceInput(textValue: presenter.$rootPresentationModel.textValue, placeholder: &quot;&quot;, description: &quot;&quot;), interactor: interactor)
        let router = RootRouter()
        
        interactor.presenter = presenter
        interactor.router = router
        
        return (view, interactor)
    }
}
</code></pre>
<p>(That Presets method doesn't do anything important, but just to make sure it will not raise an irrelevant question, here's the implementation):</p>
<pre><code>static func priceInput(textValue: Binding&lt;String&gt;, placeholder: String, description: String) -&gt; CustomTextFieldConfiguration {
      return CustomTextFieldConfiguration(textValue: textValue,
                                         placeHolder: placeholder,
                                         description: description,
                                         defaultDescription: description,
                                         textAlignment: .center,
                                         descriptionAlignment: .center,
                                         contentAlignment: .center,
                                         font: CustomFont.headline1))
}
</code></pre>
","1665870","","","","","2021-03-14 21:24:04","Placing SwiftUI Data Sources Somewhere Else","<swift><swiftui><binding><state><combine>","1","6","","","","CC BY-SA 4.0"
"66652554","1","66653169","","2021-03-16 09:39:19","","0","538","<p>Whenever usecase call any method from repository, it should return data saved in Core data first and start fetching data from remote server. Once repository receives data from remote server it should update in local db and emit new event with latest data.</p>
<p>How to do it using Swift Combine?</p>
<pre><code>Class UsersRepository {

  func fetchUsers() -&gt; AnyPublisher&lt;[Users], Error&gt; {
     1. Emit Users from local DB
     2. Emit Users received from remote server
   }
}
</code></pre>
","1453349","","1453349","","2022-07-19 10:49:56","2022-07-19 10:49:56","Swift Combine: Return local data first and then remote data","<swift><combine>","1","2","0","2021-03-17 23:32:34","","CC BY-SA 4.0"
"66679183","1","66682230","","2021-03-17 18:31:53","","0","302","<p>I have two lists of URLs that return some links to images.
The lists are passed into a future like</p>
<pre><code>static func loadRecentEpisodeImagesFuture(request: [URL]) -&gt; AnyPublisher&lt;[RecentEpisodeImages], Never&gt; {
        return Future { promise in
            print(request)
             networkAPI.recentEpisodeImages(url: request)
                .sink(receiveCompletion: { _ in },
                        receiveValue: { recentEpisodeImages in
                            promise(.success(recentEpisodeImages))
                        })
                .store(in: &amp;recentImagesSubscription)
        }
        .eraseToAnyPublisher()
    }
</code></pre>
<p>Which calls:</p>
<pre><code>    /// Get a list of image sizes associated with a featured episode .
    func featuredEpisodeImages(featuredUrl: [URL]) -&gt; AnyPublisher&lt;[FeaturedEpisodeImages], Error&gt; {
        let featuredEpisodesImages = featuredUrl.map { (featuredUrl) -&gt; AnyPublisher&lt;FeaturedEpisodeImages, Error&gt; in
        return URLSession.shared
            .dataTaskPublisher(for: featuredUrl)
            .map(\.data)
            .decode(type: FeaturedEpisodeImages.self, decoder: decoder)
            .receive(on: networkApiQueue)
            .catch { _ in Empty&lt;FeaturedEpisodeImages, Error&gt;() }
            .print(&quot;###Featured###&quot;)
            .eraseToAnyPublisher()
        }
        return Publishers.MergeMany(featuredEpisodesImages).collect().eraseToAnyPublisher()
    }
    /// Get a list of image sizes associated with a recent episode .
    func recentEpisodeImages(recentUrl: [URL]) -&gt; AnyPublisher&lt;[RecentEpisodeImages], Error&gt; {
        let recentEpisodesImages = recentUrl.map { (recentUrl) -&gt; AnyPublisher&lt;RecentEpisodeImages, Error&gt; in
        return URLSession.shared
            .dataTaskPublisher(for: recentUrl)
            .map(\.data)
            .decode(type: RecentEpisodeImages.self, decoder: decoder)
            .receive(on: networkApiQueue)
            .catch { _ in Empty&lt;RecentEpisodeImages, Error&gt;() }
            .print(&quot;###Recent###&quot;)
            .eraseToAnyPublisher()
        }
        return Publishers.MergeMany(recentEpisodesImages).collect().eraseToAnyPublisher()
    }
</code></pre>
<p>and is attached to the app state:</p>
<pre><code>/// Takes an action and returns a future mapped to another action.
     static func recentEpisodeImages(action: RequestRecentEpisodeImages) -&gt; AnyPublisher&lt;Action, Never&gt; {
        return loadRecentEpisodeImagesFuture(request: action.request)
             .receive(on: networkApiQueue)
             .map({ images in ResponseRecentEpisodeImages(response: images) })
             .replaceError(with: RequestFailed())
             .eraseToAnyPublisher()
     }
</code></pre>
<p>It seems that:</p>
<pre><code>return Publishers.MergeMany(recentEpisodes).collect().eraseToAnyPublisher()
</code></pre>
<p>doesn't give me a reliable downstream value as whichever response finishes last overwrites the earlier response.</p>
<p>I am able to log the responses of both series of requests. Both are processing the correct arrays and returning the proper json.</p>
<p>I would like something like:</p>
<pre class=""lang-swift prettyprint-override""><code>return recentEpisodeImages
</code></pre>
<p>but currently this gives me the error</p>
<blockquote>
<p>Cannot convert return expression of type '[AnyPublisher&lt;RecentEpisodeImages, Error&gt;]' to return type 'AnyPublisher&lt;[RecentEpisodeImages], Error&gt;'</p>
</blockquote>
<p>How can I collect the values of the inner publisher and return them as</p>
<pre class=""lang-swift prettyprint-override""><code>AnyPublisher&lt;[RecentEpisodeImages], Error&gt;
</code></pre>
","10106418","","10106418","","2021-03-17 20:52:42","2022-05-09 20:55:42","Swift Combine - Accessing separate lists of publishers","<swift><asynchronous><combine><urlsession>","1","4","1","","","CC BY-SA 4.0"
"66694643","1","66696096","","2021-03-18 15:58:26","","2","545","<p>As mentioned in the headline, I try to load images to a custom object
I’ve got the custom object “User” that contains the property “imageLink” that stores the location within the Firebase Storage.</p>
<p>First I load the users frome the Firestore db and then I try to load the images for these users asynchronous from the Firebase Storage and show them on the View. As long as the image has not been loaded, a placeholder shall be shown.
I tried several implementations and I always can see in the debugger that I am able to download the images (I saw the actual image and I saw the size of some 100kb), but the loaded images don’t show on the view, I still see the placeholder, it seems that the view does not update after they loaded completely.</p>
<p>From my perspective, the most promising solution was:</p>
<p><strong>FirebaseImage</strong></p>
<pre><code>import Combine
import FirebaseStorage
import UIKit

let placeholder = UIImage(systemName: &quot;person&quot;)!

struct FirebaseImage : View {

    init(id: String) {
        self.imageLoader = Loader(id)
    }

    @ObservedObject private var imageLoader : Loader

    var image: UIImage? {
        imageLoader.data.flatMap(UIImage.init)
    }

    var body: some View {
        Image(uiImage: image ?? placeholder)
    }
}
</code></pre>
<p><strong>Loader</strong></p>
<pre><code>import SwiftUI
import Combine
import FirebaseStorage

final class Loader : ObservableObject {
    let didChange = PassthroughSubject&lt;Data?, Never&gt;()
    var data: Data? = nil {
        didSet { didChange.send(data) }
    }

    init(_ id: String){
        // the path to the image
        let url = &quot;profilepics/\(id)&quot;
        print(&quot;load image with id: \(id)&quot;)
        let storage = Storage.storage()
        let ref = storage.reference().child(url)
        ref.getData(maxSize: 1 * 1024 * 1024) { data, error in
            if let error = error {
                print(&quot;\(error)&quot;)
            }

            DispatchQueue.main.async {
                self.data = data
            }
        }
    }
}

</code></pre>
<p><strong>User</strong></p>
<pre><code>import Foundation
import Firebase
import CoreLocation
import SwiftUI

struct User: Codable, Identifiable, Hashable {
    
    var id: String?
    var name: String
    var imageLink: String
    var imagedata: Data = .init(count: 0)
    
    init(name: String, imageLink: String, lang: Double) {
        self.id = id
        self.name = name
        self.imageLink = imageLink
    }
    
    init?(document: QueryDocumentSnapshot) {
        let data = document.data()
        
        guard let name = data[&quot;name&quot;] as? String else {
            return nil
        }
        
        guard let imageLink = data[&quot;imageLink&quot;] as? String else {
            return nil
        }
        
        id = document.documentID
        self.name = name
        self.imageLink = imageLink
    }
}

extension User {

    var image: Image {
        Image(uiImage: UIImage())
        }
}

extension User: DatabaseRepresentation {
    
    var representation: [String : Any] {
        var rep = [&quot;name&quot;: name, &quot;imageLink&quot;: imageLink] as [String : Any]
        
        if let id = id {
            rep[&quot;id&quot;] = id
        }
        
        return rep
    }
    
}

extension User: Comparable {
    
    static func == (lhs: User, rhs: User) -&gt; Bool {
        return lhs.id == rhs.id
    }
    
    static func &lt; (lhs: User, rhs: User) -&gt; Bool {
        return lhs.name &lt; rhs.name
    }
}

</code></pre>
<p><strong>UserViewModel</strong></p>
<pre><code>import Foundation
import FirebaseFirestore
import Firebase

class UsersViewModel: ObservableObject {
    
    let db = Firestore.firestore()
    let storage = Storage.storage()

    @Published var users = [User]()
    
    
    @Published var showNewUserName: Bool = UserDefaults.standard.bool(forKey: &quot;showNewUserName&quot;){
        didSet {
            UserDefaults.standard.set(self.showNewUserName, forKey: &quot;showNewUserName&quot;)
            NotificationCenter.default.post(name: NSNotification.Name(&quot;showNewUserNameChange&quot;), object: nil)
        }
    }
    
    
    @Published var showLogin: Bool = UserDefaults.standard.bool(forKey: &quot;showLogin&quot;){
        didSet {
            UserDefaults.standard.set(self.showLogin, forKey: &quot;showLogin&quot;)
            NotificationCenter.default.post(name: NSNotification.Name(&quot;showLoginChange&quot;), object: nil)
        }
    }
    
    @Published var isLoggedIn: Bool = UserDefaults.standard.bool(forKey: &quot;isLoggedIn&quot;){
        didSet {
            UserDefaults.standard.set(self.isLoggedIn, forKey: &quot;isLoggedIn&quot;)
            NotificationCenter.default.post(name: NSNotification.Name(&quot;isLoggedInChange&quot;), object: nil)
        }
    }
    
    func addNewUserFromData(_ name: String, _ imageLing: String, _ id: String) {
        do {
            let uid = Auth.auth().currentUser?.uid
            let newUser = User(name: name, imageLink: imageLing, lang: 0, long: 0, id: uid)
            try db.collection(&quot;users&quot;).document(newUser.id!).setData(newUser.representation) { _ in
                self.showNewUserName = false
                self.showLogin = false
                self.isLoggedIn = true
            }
        } catch let error {
            print(&quot;Error writing city to Firestore: \(error)&quot;)
        }
    }
    
    func fetchData() {
        db.collection(&quot;users&quot;).addSnapshotListener { (querySnapshot, error) in
            guard let documents = querySnapshot?.documents else {
                print(&quot;No documents&quot;)
                return
            }
            
            self.users = documents.map { queryDocumentSnapshot -&gt; User in
                let data = queryDocumentSnapshot.data()
                let id = data[&quot;id&quot;] as? String ?? &quot;&quot;
                let name = data[&quot;name&quot;] as? String ?? &quot;&quot;
                let imageLink = data[&quot;imageLink&quot;] as? String ?? &quot;&quot;
                let location = data[&quot;location&quot;] as? GeoPoint
                let lang = location?.latitude ?? 0
                let long = location?.longitude ?? 0
                Return User(name: name, imageLink: imageLink, lang: lang, long: long, id: id)
            }
        }
    }
}
</code></pre>
<p>UsersCollectionView</p>
<pre><code>import SwiftUI

struct UsersCollectionView: View {
    @Environment(\.presentationMode) var presentationMode: Binding&lt;PresentationMode&gt;
    @EnvironmentObject var usersViewModel: UsersViewModel
    
    
    let itemWidth: CGFloat = (screenWidth-30)/4.2
    let itemHeight: CGFloat = (screenWidth-30)/4.2
    
    var fixedLayout: [GridItem] {
        [
            .init(.fixed((screenWidth-30)/4.2)),
            .init(.fixed((screenWidth-30)/4.2)),
            .init(.fixed((screenWidth-30)/4.2)),
            .init(.fixed((screenWidth-30)/4.2))
        ]
    }
    
    func debugUserValues() {
        for user in usersViewModel.users {
            print(&quot;ID: \(user.id), Name: \(user.name), ImageLink: \(user.imageLink)&quot;)
        }
    }
    
    var body: some View {
        VStack() {

            ScrollView(showsIndicators: false) {
                LazyVGrid(columns: fixedLayout, spacing: 15) {
                    ForEach(usersViewModel.users, id: \.self) { user in
                        VStack() {

                            FirebaseImage(id: user.imageLink)
                            
                            HStack(alignment: .center) {
                                Text(user.name)
                                    .font(.system(size: 16))
                                    .fontWeight(.bold)
                                    .foregroundColor(Color.black)
                                    .lineLimit(1)
                            }
                        }
                    }
                }
                .padding(.top, 20)
                
                Rectangle()
                    .fill(Color .clear)
                    .frame(height: 100)
            }
            
        }
        .navigationTitle(&quot;Find Others&quot;)
        .navigationBarBackButtonHidden(true)
        .navigationBarItems(leading:
                    Button(action: {
                        self.presentationMode.wrappedValue.dismiss()
                    }) {
                        HStack {
                            Image(systemName: &quot;xmark&quot;)
                                .foregroundColor(.black)
                                .padding()
                                .offset(x: -15)
                        }
                })
    }
}
</code></pre>
","11532731","","","","","2021-03-18 17:24:22","SwiftUI: View does not update after image changed asynchronous","<swift><firebase><swiftui><firebase-storage>","1","0","","","","CC BY-SA 4.0"
"66701058","1","66755580","","2021-03-19 00:36:49","","1","861","<p>I have a SwiftUI app where I show a map (using Mapkit made with UIViewRepresentable) with different annotations being displayed. On each annotation, I have implemented a callout button and I would like to completely change the main View when the button is pressed.</p>
<p>My idea was to use a State/Binding parameter of the main view and the mapView. The idea works but I have some difficulties to implement the State/Binding with the way I use the Map View. The difficulty is that I am using the map as a parameter for a second view containing the menu to interact with the map. I tried to change how I use the map view but I did not find any solution...</p>
<p>My idea was to create the map : <code>@State var map = MapView(displaySP: $displayStorePage)</code> before body but I can not do it (err : Cannot use instance member '$displayStorePage' within property initializer; property initializers run before 'self' is available)</p>
<p>Any help is very welcome :)</p>
<p>edit: Additional code display, I tried to do the lightest version.</p>
<p>So in the code, the goal is to toggle the <code>displayStorePage</code> in Mainview from the Mapview function activated for annotation click <code>func mapView(_ mapView: MKMapView, annotationView view: MKAnnotationView, calloutAccessoryControlTapped control: UIControl)</code></p>
<p><strong>Main View:</strong></p>
<pre><code>import SwiftUI
import MapKit

struct MainView: View {
    @State var researchStore: String = &quot;&quot;
    @State var displayStorePage: Bool = false
    @State var map = MapView()
    
    var body: some View {
        ZStack{
            if displayStorePage == false {
                VStack{
                  map.frame(height: 400)
                }
            TopMapMenu(map: $map)
            }
            
            if displayStorePage == true {
                Text(&quot;This is a win !&quot;)
                }
            
            }
        }
    }
</code></pre>
<p><strong>MapKit View:</strong></p>
<pre><code>import Combine

var storeLocation = [MKAnnotation]()
var newAnnotation = MKPointAnnotation()

let mapView = MKMapView()
var displayRedMarker: Bool = true
var displayStore: Bool = false


struct MapView: UIViewRepresentable {

    class Coordinator: NSObject, MKMapViewDelegate{
        var parent : MapView

        init(_ parent: MapView){
            self.parent = parent
        }
        
        
        func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -&gt; MKAnnotationView? {
            
            var annotationView = mapView.dequeueReusableAnnotationView(withIdentifier: &quot;AnnotationView&quot;)
            
                annotationView = MKPinAnnotationView(annotation: annotation, reuseIdentifier: &quot;AnnotationView&quot;)
            
            let annotationLabel = UILabel(frame: CGRect(x: -25, y: 12, width: 105, height: 30))
            if displayRedMarker {
            annotationLabel.text = annotation.title!!
            } else {
            annotationLabel.text = &quot;Annotation to be hidden&quot;
            }
            
            //Other markers done there ....

            annotationView?.canShowCallout = true
            let btn = UIButton(type: .detailDisclosure)
                        annotationView?.rightCalloutAccessoryView = btn
            return annotationView
        }
        
        // Gestion click Annotation button
        func mapView(_ mapView: MKMapView, annotationView view: MKAnnotationView, calloutAccessoryControlTapped control: UIControl) {
               // Here : Changing the Main View parameter : displayStorePage to true
        }
        
}
    
    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self)
    }
    
    
    func makeUIView(context: Context) -&gt; some UIView {
        
       
        let region = MKCoordinateRegion(
            center: CLLocationCoordinate2D(latitude: 47.510053, longitude: 6.798374),
            span: MKCoordinateSpan(latitudeDelta: 0.01, longitudeDelta: 0.01))
        
        mapView.delegate = context.coordinator
        mapView.showsUserLocation = true
        mapView.setRegion(region, animated: false)
        
        mapView.addAnnotation(AddAnnotations())
        
        return mapView
    }
    
    func updateUIView(_ uiView: UIViewType, context: Context) {
        
    }
 
    func AddAnnotations() -&gt; MKAnnotation {
        
        newAnnotation = MKPointAnnotation()
        newAnnotation.title = &quot;Title1&quot;
        newAnnotation.coordinate = CLLocationCoordinate2D(latitude: 47.510053, longitude: 6.798374)
        
        return newAnnotation
    }
    
}
</code></pre>
<p><strong>TopMenuMap:</strong></p>
<pre><code>struct TopMapMenu: View {
    
     @Binding var map : MapView
     @State var searching: Bool = false
     @State var redStore: Bool = true
     @State var storeFound : Bool = false
    
    var body: some View {
            
                HStack{
                    VStack(alignment: .leading, spacing: 10){
                        
                        Button(action: {
                            displayRedMarker.toggle()
                         //   map.DeleteMarkers()
                         //   map.AddMarkers()
                            redStore = displayRedMarker
                        }) {
                            HStack {
                            if redStore { Image(systemName: &quot;heart.fill&quot;) }
                            else { Image(systemName: &quot;heart&quot;) }
                                
                                Text(&quot;Restaurant&quot;)
                                }
                            Spacer()
                                .background(Color(.white))
                            }
                        // Other Buttons(Pins) are display here
                    }// End VStack Pin stores
                }
    }
}
</code></pre>
","14683297","","14683297","","2021-03-23 19:09:43","2021-03-23 23:42:17","SwiftUI - Mapkit - Binding mapkit and show view on annotation callout buttons","<swift><swiftui><mapkit>","2","1","","","","CC BY-SA 4.0"
"66706403","1","66708496","","2021-03-19 10:26:26","","-1","1411","<p><strike>I'm attempting to use combine to chain two requests together. The code is pretty rough, but I need to call two api requests. One to get the schedule data than one for live data. I'm able to get the live data <em>(second request)</em> but how do I get the schedule data <em>(first request)</em>? I'm having a hard time understanding how to use combine to chain two requests together, this is my first need to use combine for a widget I'm working on. I'm still fresh to Swift, so my terminology may be lacking.</strike></p>
<p>My last code example wasn't correct and my question was unclear. I have two <code>publishers</code> and the <em>second one</em> depends on the <em>first one</em>. My understanding is still unclear on how to handle the data from my first <code>publisher</code> as well as in <code>.flatMap</code> for the second data. Does it need to be <code>ObservableObject</code> class and have <code>@Published</code> variables for the data? Do I use <code>.assign</code> or <code>.sink</code> to get data from my codable data <code>Schedule</code> and <code>Live</code>? Articles seem a bit too advance for myself as they create custom <code>extensions</code> and changing the API data to <code>nested types</code>.</p>
<p>New example code</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

class DataGroup {
    // How to get data from Schedule and Live codable data, do I use a variable and .assign or .sink?
    // Where do I put the subscriber?
    
    func requestSchedule(_ teamID : Int) -&gt; AnyPublisher&lt;Schedule, Error&gt; {
        let url = URL(string: &quot;https://statsapi.web.nhl.com/api/v1/schedule?teamId=\(teamID)&quot;)!
        return URLSession
            .shared.dataTaskPublisher(for: url)
            .map(\.data)
            .decode(type: Schedule.self, decoder: JSONDecoder())
            .flatMap {self.fetchLiveFeed($0.dates.first?.games.first?.link ?? &quot;&quot;)}
            /*
            .flatMap {URLSession.shared.dataTaskPublisher(for: URL(string: $0.dates.first?.games.first?.link ?? &quot;&quot;)!)}
            */
            .eraseToAnyPublisher()
    }
    

    // Remove and put into flatMap URLSession.shared.dataTaskPublisher?
    func fetchLiveFeed(_ link: String) -&gt; AnyPublisher&lt;Live, Error&gt; {
        let url = URL(string: &quot;https://statsapi.web.nhl.com\(link)&quot;)!
        return URLSession.shared.dataTaskPublisher(for: url)
            .map(\.data)
            .decode(type: Live.self, decoder: JSONDecoder())
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>OLD
<strike></p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

class CombineData {
    var schedule: Schedule? // Get schedule data alongside live data
    var live: Live?
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    func fetchSchedule(_ teamID: Int, _ completion: @escaping (/* Schedule, */Live) -&gt; Void) {
        let url = URL(string: &quot;https://statsapi.web.nhl.com/api/v1/schedule?teamId=\(teamID)&quot;)!
        URLSession.shared.dataTaskPublisher(for: url)
            .map { $0.data }
            .decode(type: Schedule.self, decoder: JSONDecoder())
            .flatMap { self.fetchLiveFeed($0.dates.first?.games.first?.link ?? &quot;&quot;) }
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { _ in }) { data in
                // How to get both schedule data and live data here?
                //self.schedule = ?
                self.live = data
                print(data)
                completion(self.schedule!, self.live!)
            }.store(in: &amp;cancellables)
    }

    func fetchLiveFeed(_ link: String) -&gt; AnyPublisher&lt;Live, Error&gt; {
        let url = URL(string: &quot;https://statsapi.web.nhl.com\(link)&quot;)!
        return URLSession.shared.dataTaskPublisher(for: url)
            .map(\.data)
            .decode(type: Live.self, decoder: JSONDecoder())
            .eraseToAnyPublisher()
    }
}
</code></pre>
</strike>
","14601731","","14601731","","2021-03-21 09:48:19","2021-03-21 09:48:19","Swift combine chain requests","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"66707315","1","66707505","","2021-03-19 11:28:56","","3","1817","<p>I am using a function to get recipes from a database via an API endpoint. It takes in 3 parameters, fat, carbs, protein and I want these values to be equal to my environment object (or a calculation of two environment objects) fatGoal - fatProgress etc. However in my viewModel I get the following error when trying to use my environment object:</p>
<pre><code>Thread 1: Fatal error: No ObservableObject of type UserInfoModel found. A View.environmentObject(_:) for UserInfoModel may be missing as an ancestor of this view.
</code></pre>
<p>This is my ViewModel service file:</p>
<pre><code>import SwiftUI
import Combine
import Foundation

class MealViewModel: ObservableObject {
    
    @Published var nutrients: [RecipieAPI] = []
    
    @EnvironmentObject var person: UserInfoModel
    
    
    @State public var fat = 0
    @State public var carbs = 0
    @State public var protein = 0


    
    init() {
        
        fetchNutrients()


    }
    
    func fetchNutrients() {
        NetworkServices.fetchNutrients(maxProtein: self.person.recipeNutrientsSearch.protein , maxFat: self.person.recipeNutrientsSearch.fat,  maxCarbs: self.person.recipeNutrientsSearch.carb, number: 4) { (nutrients, error) in
            if let error = error {
                print(error)
            } else {
                if let nutrientList = nutrients as? [RecipieAPI] {
                    self.nutrients = nutrientList
                }
            }
        }
    }
}
</code></pre>
<p>The error is called in</p>
<pre><code>NetworkServices.fetchNutrients(maxProtein: self.person.recipeNutrientsSearch.protein , maxFat: self.person.recipeNutrientsSearch.fat,  maxCarbs: self.person.recipeNutrientsSearch.carb, number: 4) { (nutrients, error) in
</code></pre>
<p>Any help would be greatly appreciated</p>
<p><strong>Edit</strong>
Content View:</p>
<pre><code>import SwiftUI

struct ContentView: View {

    
    //Instantiating an object of UserInfo Model (referenced in App.swift too 
    @EnvironmentObject var person: UserInfoModel
    

    
    init() {
        //Setting appearance of UI colour
        UITabBar.appearance().backgroundColor = ColourManager.UIColour1
    }
    
    var body: some View {
        
        
        TabView {
            ProfileView().tabItem ({
                Text(&quot;Profile&quot;)
            }).tag(0)
            
            TrackerView().tabItem ({
                Text(&quot;Tracker&quot;)
            }
            ).tag(1)

            
            AddView().tabItem ({
                Text(&quot;Add&quot;)
            }).tag(2)
            
            MealView().tabItem ({
                Text(&quot;Meals&quot;)
            }).tag(3)
        }.accentColor(ColourManager.Colour3)
        .environmentObject(UserInfoModel())

        
        }

    }
</code></pre>
<p>Environment Object class: UserinfoModel:</p>
<pre><code>import Foundation

class UserInfoModel: ObservableObject {
    
    
    struct UserInfo: Identifiable {
        var id = UUID()
        var firstName: String
        var height: Double
        var weight: Double
        var gender: String
        var age: Double
        var activityLevel: String
        var BMR: Double
        
    }
    
    struct AddedFoods:Identifiable{
        var name: String = &quot;&quot;
        var totalCals: Double = 0
        var totalProtein: Double = 0
        var totalCarbs: Double = 0
        var totalFat: Double = 0
        var id = UUID().uuidString
       //Your other properties
    }
    
    struct DailyCalorieGoals: Identifiable{
        var id = UUID()
        var calorieGoal: Double
        var fatGoal: Double
        var proteinGoal: Double
        var carbGoal: Double

    }
    
    struct CurrentCalorieProgress: Identifiable{
        var id = UUID()
        var calorieProgress: Double
        var fatProgress: Double
        var carbProgress: Double
        var proteinProgress: Double

    }
    
    struct SearchRecipeCalories: Identifiable{
        var id = UUID()
        var fat: Int
        var carb: Int
        var protein: Int

    }
    
    @Published var personUserInfo = UserInfo.init(firstName: &quot;&quot;,  height: 0, weight: 0, gender: &quot;&quot;, age: 0, activityLevel: &quot;&quot;, BMR: 0)
    @Published var personDailyCalorieGoals = DailyCalorieGoals.init(calorieGoal: 2400, fatGoal: 40, proteinGoal: 40, carbGoal: 40)
    @Published var personCurrentCalorieProgress = CurrentCalorieProgress.init(calorieProgress: 1200, fatProgress:   12, carbProgress: 5, proteinProgress: 30)
    
    @Published var  recipeNutrientsSearch = SearchRecipeCalories.init(fat: 0, carb: 0, protein: 0)
    
    
}
</code></pre>
","13729458","","13729458","","2021-03-19 12:14:14","2021-03-19 12:21:09","How do I pass in an Environment Object to my ViewModel SwiftUI","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"66708005","1","66708229","","2021-03-19 12:15:50","","-1","421","<p>I have question regarding how to pass data between two models.</p>
<pre><code>struct SettingsCell: View {
    @State var isOn: Bool

    var body: some View {
        Toggle(name, isOn: $isOn)
    }
}

class SettingsModel: ObservableObject {
    @Published var someValue: Bool = false
}

struct SettingsView: View {
    @ObservedObject var model = SettingsModel()

    var body: some View {
        List {
            SettingsCell(isOn: model.someValue)
        }
    }
}
</code></pre>
<p>So i want to pass isOn state from cell, to main model, and react there. Send requests for example.</p>
","2185412","","","","","2021-03-19 12:37:47","SwiftUI / Combine Pass data between two models","<ios><swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"66708406","1","66708695","","2021-03-19 12:42:32","","0","138","<p>I try to reset a <code>TextField</code> value when a certain condition is met <code>(.count == 4)</code>, but it does not work, what am I missing?</p>
<pre><code>class ViewModel: ObservableObject {
    @Published var code = &quot;&quot;
    private var anyCancellable: AnyCancellable?
    init() {
        anyCancellable = $code.sink { (newVal) in
            if newVal.count == 4 {
                self.code = &quot;&quot;
            }
        }
    }
}
struct ContentView: View {
    
    @ObservedObject var viewModel = ViewModel()
    
    var body: some View {
        TextField(&quot;My code&quot;, text: $viewModel.code)
    }
}
</code></pre>
","10208552","","","","","2021-03-19 13:03:04","Reset TextField value using Combine and Swiftui","<ios><swiftui><combine>","2","0","0","","","CC BY-SA 4.0"
"66709950","1","66714610","","2021-03-19 14:23:17","","1","542","<p>Recently, I tried to use <a href=""https://github.com/freshOS/Networking"" rel=""nofollow noreferrer"">freshOS/Networking</a> swift package.</p>
<p>And I read the README file several times and I couldn't make it work with me. I'm trying to get a list of countries using public API services and here's what I did:</p>
<p><strong>Model</strong></p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Networking

struct CountryModel: Codable {
    let error: Bool
    let msg: String
    let data: [Country]
}

struct Country: Codable {
    let name: String
    let Iso3: String
}

extension Country: NetworkingJSONDecodable {}
extension CountryModel: NetworkingJSONDecodable {}

/* 
Output
{
     &quot;error&quot;:false,
     &quot;msg&quot;:&quot;countries and ISO codes retrieved&quot;,
     &quot;data&quot;:[
          {
               &quot;name&quot;:&quot;Afghanistan&quot;,
               &quot;Iso2&quot;:&quot;AF&quot;,
               &quot;Iso3&quot;:&quot;AFG&quot;
          }
     ]
}
*/
</code></pre>
<p><strong>View Controller</strong> + print(data) in <code>callAPI()</code> function does not print</p>
<pre class=""lang-swift prettyprint-override""><code>    override func viewDidLoad() {
        super.viewDidLoad()
        
        configureUI()
        callAPI()
        
    }

    fileprivate func configureUI() {
        title = &quot;Choose Country&quot;
        
        view.addSubview(tableView)
        tableView.delegate = self
        tableView.dataSource = self
        tableView.frame = view.bounds
    }

    fileprivate func callAPI() {
        let countriesService = CountriesApi()
        var cancellable = Set&lt;AnyCancellable&gt;()
        
        countriesService.countries().sink(receiveCompletion: { completion in
            switch completion {
            case .finished:
                print(&quot;finished&quot;) // not printing
                break
            case .failure(let error):
                print(error.localizedDescription)
            }
        }) { data in
            print(data) // not printing
            self.countriesData = data
        }.store(in: &amp;cancellable)
    }
</code></pre>
<p><strong>CountriesAPI()</strong></p>
<pre class=""lang-swift prettyprint-override""><code>struct CountriesApi: NetworkingService {
    
    let network = NetworkingClient(baseURL: &quot;https://countriesnow.space/api/v0.1&quot;)
    
    // Create
    func create(country c: Country) -&gt; AnyPublisher&lt;Country, Error&gt; {
        post(&quot;/countries/create&quot;, params: [&quot;name&quot; : c.name, &quot;Iso3&quot; : c.Iso3])
    }
    
    // Read
    func fetch(country c: Country) -&gt; AnyPublisher&lt;Country, Error&gt; {
        get(&quot;/countries/\(c.Iso3)&quot;)
    }
    
    // Update
    func update(country c: Country) -&gt; AnyPublisher&lt;Country, Error&gt; {
        put(&quot;/countries/\(c.Iso3)&quot;, params: [&quot;name&quot; : c.name, &quot;Iso3&quot; : c.Iso3])
    }
    
    // Delete
    func delete(country c: Country) -&gt; AnyPublisher&lt;Void, Error&gt; {
        delete(&quot;/countries/\(c.Iso3)&quot;)
    }
    
    func countries() -&gt; AnyPublisher&lt;[CountryModel], Error&gt; {
        get(&quot;/countries/iso&quot;)
    }
}
</code></pre>
<p>I hope someone can help with what I'm missing.</p>
","5564548","","5231607","","2021-04-03 17:34:12","2021-10-24 18:45:28","Swift - Combine subscription not being called","<swift><xcode><networking><combine><urlsession>","1","0","","","","CC BY-SA 4.0"
"66711221","1","66718772","","2021-03-19 15:37:37","","0","726","<p>I am trying to understand how I can inject dependencies into child views using SwiftUI.</p>
<p>For example, if I have a view -</p>
<pre><code>struct FeedListView: View {
    
    @ObservedObject private(set) var viewModel: FeedViewModel
    @State private var items: [Post] = []
    
    var body: some View {
        ScrollView(.vertical, showsIndicators: false) {
                ForEach(items, id: \.id) { item in
                    FeedListItemView(viewModel: .init(item: item))
                }
        }
        .onAppear(perform: onLoad)
        .padding()
    }
}

private extension FeedListView {
    
    func onLoad() {
        viewModel.onFeedLoad = { self.items = $0 }
        viewModel.loadFeed()
    }
}
</code></pre>
<p>with a view model -</p>
<pre><code>final class FeedViewModel: ObservableObject {
    
    typealias LoaderResult = Result&lt;[Post], Error&gt;
    typealias LoaderCompletion = (LoaderResult) -&gt; Void
    typealias Loader = ((@escaping LoaderCompletion) -&gt; Void)
    
    typealias Observer&lt;T&gt; = (T) -&gt; Void
     
    @Published var onFeedLoad: Observer&lt;[Post]&gt;?
    @Published var onLoadingStateChange: Observer&lt;Bool&gt;?

    private let loader: Loader
    
    init(loader: @escaping Loader) {
        self.loader = loader
    }
    
    func loadFeed() {
        onLoadingStateChange?(true)
        loader { [weak self] result in
            if let feed = try? result.get() {
                self?.onFeedLoad?(feed)
            }
            self?.onLoadingStateChange?(false)
        }
    }
}
</code></pre>
<p>As this is the top level view, I can inject FeedViewModel with it's dependencies at the point of composition.</p>
<p>However this view renders FeedListItemView - that view has it's own view model and will have it's own dependencies.</p>
<pre><code>final class FeedListItemViewModel: ObservableObject {
        
    private let item: Post
    
    init(item: Post) {
        self.item = item
    }
    
    func loadImage() {
        let imageURL = item.imageURL
        // do something here to load an image
    }
}

struct FeedListItemView: View {
    
    @ObservedObject private(set) var viewModel: FeedListItemViewModel

    init(viewModel: FeedListItemViewModel) {
        self.viewModel = viewModel
    }
    
    var body: some View {
        Text(&quot;My Awesome Post&quot;)
            .onAppear(perform: viewModel.loadImage)
    }
}
</code></pre>
<p>How can I make an image loader, such as <code>(_imageURL: URL) -&gt; AnyPublisher&lt;Data, Error&gt;</code> available in FeedListItemViewModel without passing this into FeedListView and then passing it directly to the child views view model?</p>
<p>Testability is very important so I'd like to avoid a singleton instance of dependencies and I'd also like to avoid passing a bunch of values to a view, only for that view to pass them to a child, which in turn passes them to another distant child.</p>
<p>I'd really appreciate any thoughts on how this can be achieved.</p>
","11709138","","","","","2021-03-20 06:17:05","SwiftUI & Distant Child View Dependency Injection","<swift><dependency-injection><swiftui>","1","0","","","","CC BY-SA 4.0"
"66713123","1","66715459","","2021-03-19 17:42:10","","3","1644","<p>I am studying and trying out a few stuff with Combine to apply on my own and came into the following situation with this contrived example..</p>
<pre><code>let sequencePublisher = [70, 5, 17].publisher
var cancellables = [AnyCancellable]()

sequencePublisher
//    .spellOut()
    .flatMap { query -&gt; URLSession.DataTaskPublisher in
        return URLSession.shared.dataTaskPublisher(for: URL(string: &quot;http://localhost:3000?q=\(query)&quot;)!)
    }
    .compactMap { String(data: $0.data, encoding: .utf8) }
    .sink(receiveCompletion: { completion in
        switch completion {
        case .failure(let error):
            print(error.localizedDescription)
        default: print(&quot;finish&quot;)
        }
    }) { value in
        print(value)
    }
    .store(in: &amp;cancellables)
</code></pre>
<p>I have a sequence publisher that emits 3 Integers and I pass it through <code>flatMap</code> and send a Get request request to my local API that simply returns back the same value it got embedded in a string.</p>
<p>It all works fine, I get all 3 API responses in sink, as long as I don't uncomment the <code>spellOut()</code> custom operator, this operator is supposed to fail if the number is smaller than 6, here is what it does:</p>
<pre><code>enum ConversionError: LocalizedError {
    case lessThanSix(Int)
    var errorDescription: String? {
        switch self {
        case .lessThanSix(let n):
            return &quot;could not convert number -&gt; \(n)&quot;
        }
    }
}

extension Publisher where Output == Int {
    func spellOut() -&gt; Publishers.TryMap&lt;Self, String&gt; {
        tryMap { n -&gt; String in
            let formatter = NumberFormatter()
            formatter.numberStyle = .spellOut
            guard n &gt; 6, let spelledOut = formatter.string(from: n as NSNumber) else { throw ConversionError.lessThanSix(n) }
            return spelledOut
        }
    }
}
</code></pre>
<p>The code doesn't even compile if I add another <code>map</code> operator before flatMap it works, but with a tryMap it just says</p>
<blockquote>
<p>No exact matches in call to instance method 'flatMap'</p>
</blockquote>
<p>Is there any way of achieving this or why is it not allowed?</p>
<p>Thank you in advance for the answers</p>
","9819649","","11559619","","2021-03-19 18:42:52","2021-03-20 09:29:27","Why can't I use .flatMap() after .tryMap() in Swift Combine?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"66716119","1","67853022","","2021-03-19 22:04:10","","3","311","<p>I have a Swift package which supports iOS 10, macOS 10.13, tvOS 10 and watchOS 2. I want this package to expose some SwiftUI functionality which could be used when the referencing module can import SwiftUI. For example, making my package type (<code>Persisted</code>) conform to the SwiftUI protocol <code>DynamicProperty</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>#if canImport(SwiftUI)
import SwiftUI

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Persisted: DynamicProperty { }

#endif
</code></pre>
<p>With the above in place, the project no longer builds when building for &quot;Any iOS Device (arm64)&quot; - I get the compiler error:</p>
<blockquote>
<p>Cannot find type 'DynamicProperty' in scope</p>
</blockquote>
<p>When I change the build target to any iPhone simulator, it builds OK. It also builds OK when building for &quot;Any Mac&quot;, &quot;Any tvOS Device&quot;, etc. What do I need to do to make the package build for Any iOS?</p>
","5513562","","5513562","","2021-03-20 18:45:33","2021-06-05 19:01:06","Cannot find SwiftUI or Combine types when building Swift package for ""Any iOS Device""","<ios><swift><swiftui><combine><swift-package-manager>","1","0","1","","","CC BY-SA 4.0"
"66718827","1","66722793","","2021-03-20 06:23:52","","0","141","<p>I’ve been chasing my own tail for days..  Maybe the architecture is all wrong.  I just can't get it all to work at the same time.  Any help would be greatly appreciated.</p>
<p>I have a <code>LoginView</code> which takes an email and password, and validates to the server.</p>
<pre><code>import SwiftUI
struct LoginView: View {

    @EnvironmentObject var userAuth: UserAuth
    @State private var email: String = &quot;&quot;
    @State private var password: String = &quot;&quot;

    var body: some View {
      TextField(&quot;Email Address&quot;, text: $email)
      SecureField(&quot;Password&quot;, text: $password)
      Button(action: {
        guard let url = URL(string: &quot;https://www.SomeLoginApi.com/login&quot;) else { return }
        let body: [String: String] = [&quot;emailAddress&quot;: email, &quot;password&quot;: password]
        let finalBody = try! JSONSerialization.data(withJSONObject: body)
        var request = URLRequest(url: url)
        request.httpMethod = &quot;POST&quot;
        request.httpBody = finalBody
        request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        URLSession.shared.dataTask(with: request) { (data, _, _) in
          guard let data = data else { return }
          let loginResponse = try! JSONDecoder().decode(ServerResponse.self, from: data)
          if loginResponse.message == &quot;authorized&quot; {
            DispatchQueue.main.async {
                self.userAuth.isLoggedIn = true
                self.userAuth.userId = loginResponse.userId
                AppData().getData(userId: userAuth.userId)
            }
          } else {
            var isLoggedin = false 
          }
        }
        .resume()
      }) {
        Text(&quot;LOGIN&quot;)
      }
      .disabled(email.isEmpty || password.isEmpty)
    }
</code></pre>
<p>If validated, the above code does the following:</p>
<ol>
<li>Sets <code>isLoggedIn</code> to <code>true</code> which changes the view to <code>MainView</code> via the following <code>StartingView</code>:</li>
</ol>
<pre><code>import SwiftUI
struct StartingView: View {

    @EnvironmentObject var userAuth: UserAuth

    var body: some View {
        if !userAuth.isLoggedIn {
            LoginView()
        } else {
            MainView()
        }
    }
}
</code></pre>
<ol start=""2"">
<li>Sends a 2nd API call <code>AppData().getData(userId: userAuth.userId)</code> to the server for data.</li>
</ol>
<p>Here is the <code>AppData</code> class that the above API is pointing to.</p>
<pre><code>import Foundation
import SwiftUI
import Combine
import CoreImage
import CoreImage.CIFilterBuiltins

class AppData : ObservableObject {
    @Published var userData: AppDataModel = AppDataModel(data1: &quot;&quot;, data2: &quot;&quot;, data3: &quot;&quot;, data4: &quot;&quot;, data5: &quot;&quot;, data6: &quot;&quot;, data7: &quot;&quot;, bool1: false, data8: &quot;&quot;, data9: &quot;&quot;, bool2: true, bool3: true, bool4: true, bool5: true, bool6: true, data10: &quot;&quot;, data11: &quot;&quot;, data12: &quot;&quot;, data13: &quot;&quot;, array1:[], array2: [], array3: [], array4: [], array5: [], array6: [])
    @Published var time = &quot;&quot;
    @Published var greet = &quot;&quot;
    @Published var bgImage = Image.init(&quot;&quot;)
    
    init() {
        var greetingTimer: Timer?
        greetingTimer = Timer.scheduledTimer(timeInterval: 60.0, target: self, selector: #selector(getData), userInfo: nil, repeats: true)
    }
    
    @objc func getData(userId: String) {
        let bgImgArr = [&quot;appBackAnimals1&quot;, &quot;appBackAnimals2&quot;, &quot;appBackAnimals3&quot;, &quot;appBackAnimals4&quot;, &quot;appBackAnimals5&quot;, &quot;appBackAnimals6&quot;, &quot;appBackAnimals7&quot;, &quot;appBackAnimals8&quot;, &quot;appBackAnimals9&quot;, &quot;appBackAnimals10&quot;, &quot;appBackAnimals11&quot;, &quot;appBackAnimals12&quot;, &quot;appBackAnimals13&quot;]
        let bgImg = bgImgArr.randomElement()!
        guard let inputImage = UIImage(named: bgImg) else { return }
        let beginImage = CIImage(image: inputImage)
        let context = CIContext()
        let currentFilter = CIFilter.vignette()
        currentFilter.inputImage = beginImage
        currentFilter.intensity = 6
        // get a CIImage from our filter or exit if that fails
        guard let outputImage = currentFilter.outputImage else { return }
        // attempt to get a CGImage from our CIImage
        if let cgimg = context.createCGImage(outputImage, from: outputImage.extent) {
            // convert that to a UIImage
            let uiImage = UIImage(cgImage: cgimg)
            // and convert that to a SwiftUI image
            self.bgImage = Image(uiImage: uiImage)
        }
        let today = Date()
        let formatter = DateFormatter()
        formatter.dateFormat = &quot;EEEE h:mma&quot;
        formatter.amSymbol = &quot;am&quot;
        formatter.pmSymbol = &quot;pm&quot;
        let calendar = Calendar.current
        let hour = calendar.component(.hour, from: today)
        time = formatter.string(from: today)

        if hour &gt;= 5 &amp;&amp; hour &lt;= 11 {
            greet = &quot;morning&quot;
        } else if hour &gt;= 12 &amp;&amp; hour &lt;= 17 {
            greet = &quot;afternoon&quot;
        } else if hour &gt;= 18 &amp;&amp; hour &lt;= 20 {
            greet = &quot;evening&quot;
        } else if hour &gt;= 21 &amp;&amp; hour &lt;= 24 {
            greet = &quot;night&quot;
        } else if hour &gt;= 0 &amp;&amp; hour &lt;= 4 {
            greet = &quot;night&quot;
        } 

        guard let url = URL(string: &quot;https://www.SomeDataApi.com/data&quot;) else { return }
        let body: [String: String] = [&quot;userId&quot;: userId]
        let finalBody = try! JSONSerialization.data(withJSONObject: body)
        var request = URLRequest(url: url)
        request.httpMethod = &quot;POST&quot;
        request.httpBody = finalBody
        request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        URLSession.shared.dataTask(with: request) { (data, _, _) in
            guard let data = data else { return }
            let apiData = try! JSONDecoder().decode(AppDataModel.self, from: data)
            if apiData.message == &quot;data&quot; {
                DispatchQueue.main.async {
                    self.userData = apiData
                }
            }
        }
        .resume()
        if userData.appTopLine == &quot;&quot; {
            userData.appTopLine = &quot;Good &quot; + greet + &quot; &quot; + userData.appName
        } else {
            userData.appTopLine = &quot;not working&quot;
        }
        if userData.appBottomLine == &quot;&quot; {
            userData.appBottomLine = &quot;It's &quot; + time
        }
    }
}
</code></pre>
<p>And here is <code>MainView</code> where I want to display the data</p>
<pre><code>import SwiftUI

struct MainView: View {

  @ObservedObject var profileData = AppData()
  @EnvironmentObject var userAuth: UserAuth
  
  var body: some View {
    ZStack {
      profileData.bgImage
      HStack {
        VStack(alignment: .leading) {
            Text(profileData.userData.appTopLine)
            Text(profileData.userData.appBottomLine)
        }
      }
    }
  }
}
</code></pre>
<p>Issues that I am experiencing:</p>
<ol>
<li><p>I am able to <code>print(apiData)</code> and see the data, however  <code>@Published var userData</code> and <code>self.userData = apiData</code> are not making the data available on <code>MainView</code> via <code>@ObservedObject var profileData = AppData()</code></p>
</li>
<li><p><code>getData()</code> is not getting triggered every 60 seconds with the <code>Timer</code> because I am not able to figure out how to pass the <code>(userId: userAuth.userId)</code> parameter in there.</p>
</li>
</ol>
<p>I appreciate any direction at all.  If this is not set-up in an ideal way, please tell me, I want to do this correctly.</p>
<p>Thank you!</p>
","15397274","","968155","","2021-03-20 09:01:04","2021-03-20 14:48:11","SwiftUI publishing API data every 60 seconds with a Timer","<swift><timer><swiftui>","2","2","","","","CC BY-SA 4.0"
"66737960","1","66738971","","2021-03-21 21:53:58","","0","142","<p>I'm building a wrapper for a textField that is used to introduce quantities. I'm trying to build everything with Combine. One of the use cases consists in that if the stringValue sent by the text field has a letter, I filter the letters and reassign the new value to the same var, so the text field filters these values. There's also a code to change this value to an int so other components can read the int value. Here's the code:</p>
<pre><code>class QuantityPickerViewModel: ObservableObject {
    private var subscriptions: Set&lt;AnyCancellable&gt; = Set&lt;AnyCancellable&gt;()
    @Published var stringValue: String = &quot;&quot;
    @Published var value : Int? = nil
    
    init(initialValue: Int?) {
        $stringValue
            .removeDuplicates()
            .print(&quot;pre-filter&quot;)
            .map {
                $0.filter {$0.isNumber}
            }
            .print(&quot;post-filter&quot;)
            .map {
                Int($0)
            }
            .assign(to: \.value, on: self)
            .store(in: &amp;subscriptions)

        $value.map {
            $0 != nil ? String($0!): &quot;&quot;
        }
        .print(&quot;Value&quot;)
        .assign(to: \.stringValue, on:self)
        .store(in: &amp;subscriptions)
    
        value = initialValue
    }
}
</code></pre>
<p>I verify the behavior using tests, I'll just the test that fails:</p>
<pre><code>class QuantityPickerViewModelTest: AppTestCase {
    var model: QuantityPickerViewModel!
    override func setUpWithError() throws {
        super.setUp()
        model = QuantityPickerViewModel(initialValue: 10)
    }
    
    func test_changeStringValueWithLetters_filtersLettersAndChangesValue() {
        model.stringValue = &quot;30a&quot;
        
        XCTAssertEqual(model.value, 30)
        XCTAssertEqual(model.stringValue, &quot;30&quot;) // fails saying stringValue is still &quot;30a&quot;
    }
}
</code></pre>
<p>The output of the test is:</p>
<pre><code>Test Case '-[SourdoughMasterTests.QuantityPickerViewModelTest test_changeStringValueWithLetters_filtersLettersAndChangesValue]' started.
pre-filter: receive subscription: (RemoveDuplicates)
post-filter: receive subscription: (Print)
post-filter: request unlimited
pre-filter: request unlimited
pre-filter: receive value: ()
post-filter: receive value: ()
Value: receive subscription: (PublishedSubject)
Value: request unlimited
Value: receive value: ()
Value: receive value: (10)
pre-filter: receive value: (10)
post-filter: receive value: (10)
Value: receive value: (10)
pre-filter: receive value: (30a)
post-filter: receive value: (30)
Value: receive value: (30)
pre-filter: receive value: (30)
post-filter: receive value: (30)
Value: receive value: (30)
/Users/jpellat/workspace/SourdoughMaster/SourdoughMasterTests/QuantityPickerViewModelTest.swift:54: error: -[SourdoughMasterTests.QuantityPickerViewModelTest test_changeStringValueWithLetters_filtersLettersAndChangesValue] : XCTAssertEqual failed: (&quot;30a&quot;) is not equal to (&quot;30&quot;)
</code></pre>
<p>Does anyone know why the value has not been assigned? Thanks</p>
","1068536","","1068536","","2021-03-21 22:07:10","2021-03-22 11:53:07","Use publishers to filter numbers in a string field","<ios><swift><combine>","2","6","","","","CC BY-SA 4.0"
"66741745","1","66830608","","2021-03-22 07:20:49","","0","834","<p>I have created  a class to perform a network request and parse the data using <code>Combine</code>. I'm <strong>not</strong> entirely certain the code is <strong>correct</strong>, <em>but it's working as of now</em> <strong>(still learning the basics of Swift and basic networking tasks)</strong>. My Widget has the correct data and is works until the data becomes nil. Unsure how to check if the data from my first <code>publisher</code> in my SwiftUI <code>View</code> is nil, the data seems to be valid even when there's no games showing.</p>
<p>My SwiftUI View</p>
<pre class=""lang-swift prettyprint-override""><code>struct SimpleEntry: TimelineEntry {
    let date: Date
    public var model: CombineData?
    let configuration: ConfigurationIntent
}

struct Some_WidgetEntryView : View {
    var entry: Provider.Entry
    @Environment(\.widgetFamily) var widgetFamily
    
    var body: some View {
        VStack (spacing: 0){
            if entry.model?.schedule?.dates.first?.games == nil {
                Text(&quot;No games Scheduled&quot;)
            } else {
                Text(&quot;Game is scheduled&quot;)
            }
        }
    }
}
</code></pre>
<p>Combine</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import WidgetKit
import Combine

// MARK: - Combine Attempt
class CombineData {
    var schedule: Schedule?
    var live: Live?
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    func fetchSchedule(_ teamID: Int, _ completion: @escaping (Live) -&gt; Void) {
        let url = URL(string: &quot;https://statsapi.web.nhl.com/api/v1/schedule?teamId=\(teamID)&quot;)!
        let publisher = URLSession.shared.dataTaskPublisher(for: url)
            .map(\.data)
            .decode(type: Schedule.self, decoder: JSONDecoder())
            //.catch { _ in Empty&lt;Schedule, Error&gt;() }
            //.replaceError(with: Schedule(dates: []))
        let publisher2 = publisher
            .flatMap {
                return self.fetchLiveFeed($0.dates.first?.games.first?.link ?? &quot;&quot;)
            }
        Publishers.Zip(publisher, publisher2)
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: {_ in
            }, receiveValue: { schedule, live in
                self.schedule = schedule
                self.live = live
                completion(self.live!)
                WidgetCenter.shared.reloadTimelines(ofKind: &quot;NHL_Widget&quot;)
            }).store(in: &amp;cancellables)
    }

    func fetchLiveFeed(_ link: String) -&gt; AnyPublisher&lt;Live, Error /*Never if .catch error */&gt; {
        let url = URL(string: &quot;https://statsapi.web.nhl.com\(link)&quot;)!
        return URLSession.shared.dataTaskPublisher(for: url)
            .map(\.data)
            .decode(type: Live.self, decoder: JSONDecoder())
            //.catch { _ in Empty&lt;Live, Never&gt;() }
            .eraseToAnyPublisher()
    }
}
</code></pre>
","14601731","","","","","2021-03-27 11:06:51","SwiftUI combine nil data","<swiftui><combine><widgetkit>","2","8","","","","CC BY-SA 4.0"
"66754330","1","66754778","","2021-03-22 21:51:31","","0","105","<p>I'm trying to merges two published object from query of two different collections to make a single published array using <code>combineLatest</code>.</p>
<pre><code>import Combine
import Firebase

class FirestoreViewModel: ObservableObject {
    let userId: String
    
    @Published var aList: [DocumentA]? = nil
    @Published var bList: [DocumentB]? = nil
    
    init(userId: String, listenForChanges: Bool = false)    {
        
        // Get the user
        if (listenForChanges)   {
            self.loadA()
            self.loadB()
        }
    }
    
    var cList: AnyPublisher&lt;[DocumentC]?, Never&gt; {
        return Publishers.CombineLatest(
            $aList.map { (aList) -&gt; [DocumentC]?  in
                guard let aList = aList else { return nil }
                return aList.map {a in
                    DocumentC(from: a)
                }
            },
            $bList.map { (bList) -&gt; [DocumentC]?  in
                guard let bList = bList else { return nil }
                return bList.map { n in
                    DocumentC(from: b)
                }
            })
            .map { (aList, bList) -&gt; [DocumentC]?  in
                
                if (aList == nil &amp;&amp; bList == nil) { return nil }
                
                var cList: [DocumentC] = []
                
                if let aList = aList {
                    cList.append(contentsOf: aList)
                }
                
                if let bList = bList {
                    cList.append(contentsOf: bList)
                }
                return cList
            }
            .eraseToAnyPublisher()
    }
    
    private func loadA() {
        
        // Start listening
        Firestore.firestore().collection(&quot;colA&quot;).addSnapshotListener { (snapshot, error) in
            if let error = error {
                print(&quot;DEBUG: Unable to get user data: \(error.localizedDescription)&quot;)
                return
            }
            
            // Invalid data return
            guard let snapshot = snapshot else {
                print(&quot;DEBUG: null data returned&quot;)
                self.aList = nil
                return
            }
            
            // Update the info
            var aList: [DocumentA] = []
            snapshot.documents.forEach { document in
                let aData = document.data()
                guard !aData.isEmpty else {
                    return
                }
                aList.append(DocumentA(from: aData)
                
            }
            self.aList = aList
        }
    }
    
    private func loadB() {
        
        // Start listening
        Firestore.firestore().collection(&quot;colB&quot;).addSnapshotListener { (snapshot, error) in
            if let error = error {
                print(&quot;DEBUG: Unable to get user data: \(error.localizedDescription)&quot;)
                return
            }
            
            // Invalid data return
            guard let snapshot = snapshot else {
                print(&quot;DEBUG: null data returned&quot;)
                self.bList = nil
                return
            }
            
            // Update the info
            var bList: [DocumentB] = []
            snapshot.documents.forEach { document in
                let bData = document.data()
                guard !bData.isEmpty else {
                    return
                }
                bList.append(DocumentB(from: bData))
                
            }
            self.userUnits = userUnits
        }
    }
}
</code></pre>
<p>When I debug, I can see that <code>aList</code> and <code>bList</code> are published once, however, the <code>cList</code> keeps been published eventually eating all the memory...</p>
<p>The <code>cList</code> is consumed via a onReceive statement in the view, which output each item.</p>
<p>Would anybody be able to tell me why the <code>combineLatest</code> keeps on publishing <code>cList</code>, though there are no fresh <code>aList</code> or <code>bList</code> published ?</p>
<p>Many thanks in advance.</p>
","2405639","","968155","","2021-03-22 22:06:24","2021-03-22 22:36:57","Swiftui + Firestore + CombineLatest keep publishing data","<swift><google-cloud-firestore><combine><combinelatest>","1","1","","","","CC BY-SA 4.0"
"66832641","1","66972872","","2021-03-27 14:51:22","","0","375","<p>I have a <code>Show</code> <code>CoreData</code> <code>NSManagedObject</code> with multiple <code>Seasons</code>. Both models can be marked as <code>watched</code>. When all seasons of a <code>Show</code> are marked as watched the <code>Show</code> should be marked watched as well. How do I achieve this? I tried using manual getter and setter for my <code>NSManagedObject</code> classes but I can't get my view to update when the state changes.</p>
<p>The GUI:
<a href=""https://i.stack.imgur.com/STKEJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/STKEJ.png"" alt=""enter image description here"" /></a></p>
<p>My code of the main View:</p>
<pre><code>// ShowDetailView.swift

@ObservedObject var show: Show

// ... in the body

Button(action: {
    show.isWatched.toggle()
}, label: {
    HStack {
        Image(systemName: show.isWatched ? &quot;checkmark.rectangle.fill&quot; : &quot;checkmark.rectangle&quot;)
    }
})

ScrollView(.horizontal) {
    LazyHStack {
        ForEach(seasons) { season in
            NavigationLink(destination: SeasonDetailView(season: season)) {
                SeasonListItemView(season: season)
                    .environment(\.managedObjectContext, viewContext)
            }
        }
    }
}
</code></pre>
<p>The class for the list item:</p>
<pre><code>// SeasonListItemView.swift

@ObservedObject var season: Season

Button(action: {
    season.isWatched.toggle()
}, label: {
    HStack {
        Image(systemName: season.isWatched ? &quot;checkmark.rectangle.fill&quot; : &quot;checkmark.rectangle&quot;)
    }
})
</code></pre>
<p>I mean it totally makes sense because the <code>Show</code> model does not know it should be marked as watched when all seasons are watched, but how can I implemented and let it update automatically and using <code>CoreData</code> at the same time?</p>
<p><strong>// Edit:</strong>
Added my last edit as answer because no other solution was found.</p>
","1195661","","1195661","","2021-04-06 16:40:47","2021-04-06 16:40:47","Update view after subview change SwiftUI","<swift><swiftui><combine>","1","2","1","","","CC BY-SA 4.0"
"66850468","1","67097502","","2021-03-29 07:51:05","","1","219","<p>I have a LazyVGrid, every item with is favorite button. and use combine to debounce user input($isFavoriteI), when isFavoriteO changed, then modify the items.</p>
<p>it works fine, but when i scroll the list, log will print: &quot;X, isFavorite changed as false/true)&quot;, what cause isFavoriteO changed and why? because of item reusing in list? how to avoid it?</p>
<pre><code>index 7, isFavorite changed as true
index 7, isFavorite changed as true
index 7, isFavorite changed as true
index 7, isFavorite changed as true
index 7, isFavorite changed as true
index 7, isFavorite changed as true
index 7, isFavorite changed as true
index 7, isFavorite changed as true
</code></pre>
<pre><code>import SwiftUI
import Combine

struct Item {
    var index: Int
    var favorite: Bool
}

var items = [
    Item(index: 0, favorite: true),
    Item(index: 1, favorite: false),
    Item(index: 2, favorite: true),
    Item(index: 3, favorite: false),
    Item(index: 4, favorite: true),
    Item(index: 5, favorite: false),
    Item(index: 6, favorite: true),
    Item(index: 7, favorite: false),
//    Item(index: 8, favorite: true),
//    Item(index: 9, favorite: false),
//    Item(index: 10, favorite: true),
//    Item(index: 11, favorite: false),
//    Item(index: 12, favorite: true),
//    Item(index: 13, favorite: false),
//    Item(index: 14, favorite: true),
//    Item(index: 15, favorite: false),
//    Item(index: 16, favorite: true),
//    Item(index: 17, favorite: false),
//    Item(index: 18, favorite: true),
//    Item(index: 19, favorite: false),
]

struct ViewModelInListTestView: View {
    var body: some View {
        ScrollView(showsIndicators: false) {
            LazyVGrid(columns: [GridItem(.adaptive(minimum: 200), spacing: 4, alignment: .center)], spacing: 4) {
                ForEach(items, id: \.index) { item in
                    ItemView(item: item)
                }
            }
        }.navigationTitle(&quot;ViewModel In List&quot;)
    }
}

struct ItemView: View {
    let item: Item
    @ObservedObject var viewModel: ViewModel
    
    init(item: Item) {
        print(&quot;ItemView.init, \(item.index)&quot;)
        self.item = item
        self.viewModel = ViewModel(item: item)
    }
    
    var body: some View {
        HStack {
            Text(&quot;index \(item.index)&quot;)
            Spacer()
            Image(systemName: viewModel.isFavoriteI ? &quot;heart.fill&quot; : &quot;heart&quot;)
                .foregroundColor(viewModel.isFavoriteI ? .red : .white)
                .padding()
                .onTapGesture { onFavoriteTapped() }
                .onChange(of: viewModel.isFavoriteO) { isFavorite in
                    setFavorite(isFavorite)
                }
        }
        .frame(width: 200, height: 150)
        .background(Color.gray)
    }
    
    func onFavoriteTapped() {
        viewModel.isFavoriteI.toggle()
    }
    
    func setFavorite(_ isFavorite: Bool) {
        print(&quot;index \(item.index), isFavorite changed as \(isFavorite)&quot;)
        items[item.index].favorite = isFavorite
    }
    
    class ViewModel: ObservableObject {
        @Published var isFavoriteI: Bool = false
        @Published var isFavoriteO: Bool = false
        private var subscriptions: Set&lt;AnyCancellable&gt; = []
        
        init(item: Item) {
            print(&quot;ViewModel.init, \(item.index)&quot;)
            let isFavorite = item.favorite
            isFavoriteI = isFavorite; isFavoriteO = isFavorite
            $isFavoriteI
                .print(&quot;index \(item.index) isFavoriteI:&quot;)
                .dropFirst()
                .debounce(for: .milliseconds(500), scheduler: DispatchQueue.main)
                .removeDuplicates()
                .eraseToAnyPublisher()
                .print(&quot;index \(item.index) isFavoriteO:&quot;)
                .receive(on: DispatchQueue.main)
                .assign(to: \.isFavoriteO, on: self)
                .store(in: &amp;subscriptions)
        }
    }
}

</code></pre>
<p>update @ 4.15
according to @Cenk Bilgen, i re-write the code, but strange thing happened. print(&quot;set favorite as (favorite)&quot;) will not present if adding removeDuplicates. why?</p>
<pre><code>
import SwiftUI
import Combine

struct Item: Identifiable {
    var index: Int
    var favorite: Bool
    var id: Int { index }
}

class Model: ObservableObject {
    @Published var items = [
        Item(index: 0, favorite: true),
        Item(index: 1, favorite: false),
        Item(index: 2, favorite: true),
        Item(index: 3, favorite: false),
        Item(index: 4, favorite: true),
        Item(index: 5, favorite: false),
        Item(index: 6, favorite: true),
        Item(index: 7, favorite: false),
    ]
}

struct ViewModelInListTestView: View {
    @StateObject var model = Model()
    var body: some View {
        print(&quot;ViewModelInListTestView refreshing&quot;); return
        ScrollView(showsIndicators: false) {
            LazyVGrid(columns: [GridItem(.adaptive(minimum: 200), spacing: 4, alignment: .center)], spacing: 4) {
                ForEach(model.items.indices) { index in
                    ItemView(item: model.items[index])
                        .environmentObject(model)
                }
            }
        }.navigationTitle(&quot;ViewModel In List&quot;)
    }
    
    
    struct ItemView: View {
        @EnvironmentObject var model: Model
        let item: Item
        @State private var updateFavourite = PassthroughSubject&lt;Bool, Never&gt;()
        @State private var favorite: Bool = false
        
        init(item: Item) {
            self.item = item
            self._favorite = State(initialValue: item.favorite)
        }
        
        var body: some View {
            print(&quot;ItemView \(item.index) refreshing&quot;); return
            HStack {
                Text(&quot;index \(item.index)&quot;)
                Spacer()
                Image(systemName: favorite ? &quot;heart.fill&quot; : &quot;heart&quot;)
                    .foregroundColor(favorite ? .red : .white)
                    .padding()
                    .onTapGesture {
                        favorite.toggle()
                        updateFavourite.send(favorite)
                    }
                    .onReceive(
                        updateFavourite
                            .debounce(for: .seconds(0.5), scheduler: DispatchQueue.main)
//                            .removeDuplicates()  &lt;------ HERE
//                            .eraseToAnyPublisher()
                    ) { favorite in
                        print(&quot;set favorite as \(favorite)&quot;)
                        model.items[item.index].favorite = favorite
                    }
            }
            .frame(width: 200, height: 150)
            .background(Color.gray)
        }
    }
    
}

</code></pre>
","12668737","","12668737","","2021-04-15 14:39:21","2021-04-15 14:39:21","swiftui+combine: why isFavoriteO changed when scroll the LazyVGrid?","<swiftui><combine>","3","7","","","","CC BY-SA 4.0"
"66854873","1","66855029","","2021-03-29 13:12:44","","0","644","<p>How to update view, when view models publish var's (user's) , name property is updated. I do know why its happening but what is the best way to update the view in this case.</p>
<pre><code>class User {
    var id  = &quot;123&quot;
    @Published  var name = &quot;jhon&quot;
}
</code></pre>
<hr />
<pre><code> class ViewModel : ObservableObject {
    @Published var user : User = User()
}
 
</code></pre>
<hr />
<pre><code>struct ContentView: View {
     @ObservedObject var viewModel = ViewModel() 
    
    var body: some View  {
        userNameView 
    }

    var userNameView: some View  {
        Text(viewModel.user.name)
            .background(Color.red)
            .onTapGesture {
                viewModel.user.name += &quot;update&quot;
                print( viewModel.user.name)
            }
    }
}
</code></pre>
<p>so one way i do it, is by using onReceive like this,</p>
<pre><code>var body: some View  {

         userNameView
             .onReceive(viewModel.user.$name){ output in

                    let tmp = viewModel.user
                           viewModel.user = tmp
                    print(&quot;onTapGesture&quot;,output)

          }
}
</code></pre>
<p>but it is not a good approach it will update all view using users properties.
should i make a @state var for the name?
or should i just make a ObservedObject for user as well?</p>
","12383844","","14998134","","2021-03-29 13:45:33","2021-03-29 14:07:47","update View when view model's, publish object's, property is updated","<swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"66884362","1","66884796","","2021-03-31 08:41:42","","0","569","<p>I have already decode my JSON API and successfully display the location on the map with <code>MapAnnotations</code> and put <code>NavigationLink</code> to see the detail on it. But somehow, when I zoomed out the map to see all marked locations, suddenly my view becomes very laggy with simulator and real iPhone 8 (maybe because I have 100+ annotations on the map?). And then I tried to use <code>MapMarker</code> and the view becomes more smoother, but the problem is now I can't put <code>NavigationLink</code> on <code>MapMarker</code> as well as <code>MapPin</code>. Is there a proper way to display marker/annotations on the map and <code>NavigationLink</code> without making the view lag??</p>
<p>Here is my LocationManager Code to track user's location</p>
<pre><code>import Foundation
import CoreLocation

class LocationManager: NSObject, ObservableObject {
    
    private let locationManager = CLLocationManager()
    @Published var location: CLLocation?
    
    override init() {
        super.init()
        
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.distanceFilter = kCLDistanceFilterNone
        locationManager.requestAlwaysAuthorization()
        locationManager.startUpdatingLocation()
        locationManager.delegate = self
    }
    
}

extension LocationManager: CLLocationManagerDelegate {
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        
        guard let location = locations.last else { return }
        locationManager.stopUpdatingLocation()
        
        DispatchQueue.main.async {
            self.location = location
        }
        
    }
    
}
</code></pre>
<p>My ContentView to display the Map and Show the annotations</p>
<pre><code>import SwiftUI
import MapKit
import Combine

struct ContentView: View {
    
    var body: some View {
        NavigationView{
            ServiceLocation()
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    
    static var previews: some View {
        ContentView()
    }
}

extension MKCoordinateRegion {
    
    static var defaultRegion: MKCoordinateRegion {
        MKCoordinateRegion(center: CLLocationCoordinate2D.init(latitude: -0.789275, longitude: 113.921327), latitudinalMeters: 5000, longitudinalMeters: 5000)
    }
    
}

//MARK: MAP VIEW
struct ServiceLocation: View{
    
    @State var serviceLocations: [ServiceLocationJSON] = []
    @ObservedObject private var locationManager = LocationManager()
    @State private var region = MKCoordinateRegion.defaultRegion
    @State private var cancellable: AnyCancellable?
    
    private func setCurrentLocation() {
        cancellable = locationManager.$location.sink { location in
            region = MKCoordinateRegion(center: location?.coordinate ?? CLLocationCoordinate2D(), latitudinalMeters: 20000, longitudinalMeters: 20000)
        }
    }
    
    var body: some View{
        GeometryReader{ geometry in
            VStack{
                if locationManager.location != nil {
                    Map(coordinateRegion: $region, interactionModes: .all, showsUserLocation: true, userTrackingMode: .none, annotationItems: serviceLocations) { location in
                        MapAnnotation(coordinate: CLLocationCoordinate2D(latitude: location.LATITUDE, longitude: location.LONGITUDE)){
                            NavigationLink(destination: serviceLocationDetail(serviceLocations: location)){
                                Image(systemName: &quot;mappin&quot;)
                                    .resizable()
                                    .scaledToFit()
                                    .frame(width: geometry.size.width / 15, height: geometry.size.height / 15)
                            }
                        }
                    }
                } else {
                    VStack{
                        Spacer()
                        ProgressView()
                        Spacer()
                    }
                }
            }.onAppear{
                setCurrentLocation()
                getServiceLocation(url: &quot;https://my.api.mockaroo.com/latlong.json?key=e57d0e40&quot;){ (serviceLocations) in
                    self.serviceLocations = serviceLocations
                }
            }
            .navigationTitle(&quot;Service&quot;)
            .navigationBarTitleDisplayMode(.inline)
            
        }
    }
}

//MARK: DETAIL VIEW
struct serviceLocationDetail: View{
    var serviceLocations: ServiceLocationJSON
    
    var body: some View{
        
        VStack{
            if serviceLocations.DEALER_NAME.isEmpty{
                VStack{
                    Spacer()
                    ProgressView()
                    Spacer()
                }
            }else{
                VStack(alignment: .leading, spacing: 10){
                    
                    Text(serviceLocations.DEALER_NAME)
                        .fontWeight(.medium)
                        .padding(.leading, 10)
                    Text(serviceLocations.DEALER_ADDRESS)
                        .padding(.leading, 10)
                    HStack(spacing: 5){
                        Image(systemName: &quot;phone.fill&quot;)
                        Text(serviceLocations.PHONE)
                    }.padding(.leading, 10)
                    
                    Spacer()
                    
                }.navigationBarTitle(serviceLocations.DEALER_NAME)
            }
        }
        Spacer()
    }
}

//MARK: JSON MODEL
struct ServiceLocationJSON: Identifiable, Decodable{
    var id: Int
    var LATITUDE: Double
    var LONGITUDE: Double
    var DEALER_NAME: String
    var DEALER_ADDRESS: String
    var DEALER_PICTURE: String
    var PHONE: String
}

//MARK: DECODE JSON MODEL
func getServiceLocation(url: String, completion: @escaping ([ServiceLocationJSON])-&gt;()){
    let session = URLSession(configuration: .default)
    session.dataTask(with: URL(string: url)!){ (data, _, err) in
        if err != nil{
            print(err!.localizedDescription)
            return
        }
        do{
            let serviceLocations = try
                JSONDecoder().decode([ServiceLocationJSON].self, from: data!)
            completion(serviceLocations)
        }
        catch{
            print(error)
        }
    }.resume()
}
</code></pre>
<p>Build with Xcode 12 and Swift 5</p>
","15520364","","15520364","","2021-03-31 08:53:39","2022-07-21 00:44:16","SwiftUI: How to put NavigationLink in MapPin or MapMarker","<swift><xcode><swiftui><mapkit><swift5>","1","0","","","","CC BY-SA 4.0"
"66884390","1","66885061","","2021-03-31 08:44:13","","4","896","<p>What is the best approach to have swiftUI still update based on nested observed objects?</p>
<p>The following example shows what I mean with nested observed objects. The balls array of the ball manager is a published property that contains an array of observable objects, each with a published property itself (the color string).</p>
<p>Unfortunately, when tapping one of the balls it dos not update the balls name, nor does it receive an update. So I might have messed up how combine was ment to work in that case?</p>
<pre><code>import SwiftUI

class Ball: Identifiable, ObservableObject {
    let id: UUID
    @Published var color: String
    init(ofColor color: String) {
        self.id = UUID()
       self.color = color
    }
}

class BallManager: ObservableObject {
    @Published var balls: [Ball]
    init() {
        self.balls = []
    }
}

struct Arena: View {
   @StateObject var bm = BallManager()

    var body: some View {
        VStack(spacing: 20) {
            ForEach(bm.balls) { ball in
                Text(ball.color)
                    .onTapGesture {
                        changeBall(ball)
                    }
            }
        }
        .onAppear(perform: createBalls)
        .onReceive(bm.$balls, perform: {
            print(&quot;ball update: \($0)&quot;)
        })
    }
    
    func createBalls() {
        for i in 1..&lt;4 {
            bm.balls.append(Ball(ofColor: &quot;c\(i)&quot;))
        }
    }
    
    func changeBall(_ ball: Ball) {
        ball.color = &quot;cx&quot;
    }
}
</code></pre>
","1754221","","","","","2021-03-31 14:50:15","SwiftUI Combine: Nested Observed-Objects","<swift><swiftui><combine><observableobject>","4","0","3","","","CC BY-SA 4.0"
"66908175","1","66910608","","2021-04-01 16:20:34","","4","3733","<p>Here is a simple &quot;Download&quot; class to illustrate what I want to do.</p>
<pre class=""lang-swift prettyprint-override""><code>class Download {
    
    public var progress: CurrentValueSubject&lt;Double, Never&gt; = CurrentValueSubject&lt;Double, Never&gt;(0)
    
    var subscriptions: Set&lt;AnyCancellable&gt; = []
    
    func start(task: URLSessionTask) {
        task.resume()
        task.progress.publisher(for: \.fractionCompleted).sink { [weak self] (newProgress) in
            self?.progress.send(newProgress)
        }.store(in: &amp;subscriptions)
    }
    
}
</code></pre>
<p>I would like to be able to &quot;re-publish&quot; the progress property observer publisher to my current value subject. As you can see I currently subscribe using the <code>.sink</code> function and then just call the <code>CurrentValueSubject</code> publisher directly.</p>
<p>I would like to be able to use something like the <code>.assign(to:, on:)</code> operator like this.</p>
<pre class=""lang-swift prettyprint-override""><code>task.progress.publisher(for: \.fractionCompleted).assign(to: \.progress, on: self)
</code></pre>
<p>However, that will not work nor will the <code>.assign(to:)</code> operator that seems to be reserved for &quot;re-publishing&quot; on a SwiftUI <code>@Published</code> property. Why is Combine not living up to it's name here?</p>
","4576323","","","","","2021-04-01 19:40:25","Combine assign(to: on:) another publisher","<ios><swift><combine>","2","1","2","","","CC BY-SA 4.0"
"66912429","1","66913662","","2021-04-01 22:42:46","","0","157","<p>I'm following a <a href=""https://www.youtube.com/watch?v=4RUeW5rUcww"" rel=""nofollow noreferrer"">video on the Firebase YouTube channel</a>. Starting around 27:45, the instructor is trying to set a variable based on a Boolean and ends up with the following code in <code>init(task: Task)</code>:</p>
<pre><code>$task
    .map { task in
        task.isCompleted ? &quot;checkmark.circle.fill&quot; : &quot;circle&quot;
    }
    .assign(to: \.completionStateIconName, on: self)
    .store(in: &amp;cancellables)
</code></pre>
<p>This seems overly convoluted to me. First, I can't find documentation on using <code>.map</code> on a struct object, only on arrays, etc. Second, what is with this <code>&amp;cancellables</code> thing? (It's defined as <code>private var cancellables = Set&lt;AnyCancellable&gt;()</code> before the <code>init{}</code>.) Third, why all this code, and not simply:</p>
<pre><code>task.completionStateIconName = task.isCompleted ? &quot;checkmark.circle.fill&quot; : &quot;circle&quot;
</code></pre>
<p>This seems to give the same result, but will there be something down the line that the first code fragment works, but the second doesn't?</p>
","1363998","","1015258","","2021-04-01 22:45:09","2021-04-02 02:12:38","SwiftUI and Combine","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66916090","1","66937105","","2021-04-02 07:50:24","","-1","321","<p>In my app, I've added the capabilities of background audio and background processing.</p>
<p>My code presently uses <code>AVAudioPlayer</code> to play audio. While playback is good when the app in the foreground, with a locked screen, the audio is has some static jitteriness to it.</p>
<p>My app is written using SwiftUI and Combine. Has anyone encountered this issue and what would you suggest as a workaround?</p>
<p>Here is the <code>play</code> method:</p>
<pre><code>    /// Play an `AudioFile`
    /// - Parameters:
    ///   - audioFile: an `AudioFile` struct
    ///   - completion: optional completion, default is `nil`
    func play(_ audioFile: AudioFile,
              completion: (() -&gt; Void)? = nil) {
        if audioFile != currentAudioFile {
            resetPublishedValues()
        }
        currentAudioFile = audioFile
        setupCurrentAudioFilePublisher()
        guard let path = Bundle.main.path(forResource: audioFile.filename, ofType: &quot;mp3&quot;) else {
            return
        }
        
        let url = URL(fileURLWithPath: path)
        
        // everybody STFU
        stop()
        
        do {
            // make sure the sound is one
            try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default)
            try AVAudioSession.sharedInstance().setActive(true)
            // instantiate instance of AVAudioPlayer
            audioPlayer = try AVAudioPlayer(contentsOf: url)
            audioPlayer.prepareToPlay()
            // play the sound
            let queue = DispatchQueue(label: &quot;audioPlayer&quot;, qos: .userInitiated, attributes: .concurrent, autoreleaseFrequency: .inherit, target: nil)
            
            queue.async {
                self.audioPlayer.play()
            }
            audioPlayer.delegate = self
        } catch {
            // Not much to go wrong, so leaving alone for now, but need to make `throws` if we handle errors
            print(String(format: &quot;play() error: %@&quot;, error.localizedDescription))
        }
    }
</code></pre>
<p>This is the class definition:</p>
<pre><code>import AVFoundation
import Combine
import Foundation

/// A `Combine`-friendly wrapper for `AVAudioPlayer` which utilizes `Combine` `Publishers` instead of `AVAudioPlayerDelegate`
class CombineAudioPlayer: NSObject, AVAudioPlayerDelegate, ObservableObject {
    static let sharedInstance = CombineAudioPlayer()
    private var audioPlayer = AVAudioPlayer()
    /*
     FIXME: For now, gonna leave this timer on all the time, but need to refine
     down the road because it's going to generate a fuckload of data on the
     current interval.
     */
    // MARK: - Publishers
    private var timer = Timer.publish(every: 0.1,
                                      on: RunLoop.main,
                                      in: RunLoop.Mode.default).autoconnect()
    @Published public var currentAudioFile: AudioFile?
    public var isPlaying = CurrentValueSubject&lt;Bool, Never&gt;(false)
    public var currentTime = PassthroughSubject&lt;TimeInterval, Never&gt;()
    public var didFinishPlayingCurrentAudioFile = PassthroughSubject&lt;AudioFile, Never&gt;()
    
    private var cancellables: Set&lt;AnyCancellable&gt; = []
    
    // MARK: - Initializer
    private override init() {
        super.init()
        // set it up with a blank audio file
        setupPublishers()
        audioPlayer.setVolume(1.0, fadeDuration: 0)
    }
    
    // MARK: - Publisher Methods
    private func setupPublishers() {
        timer.sink(receiveCompletion: { completion in
            // TODO: figure out if I need anything here
            // Don't think so, as this will always be initialized
        },
        receiveValue: { value in
            self.isPlaying.send(self.audioPlayer.isPlaying)
            self.currentTime.send(self.currentTimeValue)
        })
        .store(in: &amp;cancellables)
        
        didFinishPlayingCurrentAudioFile.sink(receiveCompletion: { _ in
            
        },
        receiveValue: { audioFile in
            self.resetPublishedValues()
        })
        .store(in: &amp;cancellables)
    }
    
    private func setupCurrentAudioFilePublisher() {
        self.isPlaying.send(false)
        self.currentTime.send(0.0)
    }
    
    // MARK: - Playback Methods
    
    /// Play an `AudioFile`
    /// - Parameters:
    ///   - audioFile: an `AudioFile` struct
    ///   - completion: optional completion, default is `nil`
    func play(_ audioFile: AudioFile,
              completion: (() -&gt; Void)? = nil) {
        if audioFile != currentAudioFile {
            resetPublishedValues()
        }
        currentAudioFile = audioFile
        setupCurrentAudioFilePublisher()
        guard let path = Bundle.main.path(forResource: audioFile.filename, ofType: &quot;mp3&quot;) else {
            return
        }
        
        let url = URL(fileURLWithPath: path)
        
        // everybody STFU
        stop()
        
        do {
            // make sure the sound is one
            try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default)
            try AVAudioSession.sharedInstance().setActive(true)
            // instantiate instance of AVAudioPlayer
            audioPlayer = try AVAudioPlayer(contentsOf: url)
            audioPlayer.prepareToPlay()
            // play the sound
            let queue = DispatchQueue(label: &quot;audioPlayer&quot;, qos: .userInitiated, attributes: .concurrent, autoreleaseFrequency: .inherit, target: nil)
            
            queue.async {
                self.audioPlayer.play()
            }
            audioPlayer.delegate = self
        } catch {
            // Need to make `throws` if we handle errors
            print(String(format: &quot;play error: %@&quot;, error.localizedDescription))
        }
    }
    
    func stop() {
        audioPlayer.stop()
        resetPublishedValues()
    }
    
    private func resetPublishedValues() {
        isPlaying.send(false)
        currentTime.send(0.0)
    }
    
    private var currentTimeValue: TimeInterval {
        audioPlayer.currentTime
    }
    
    /// Use the `Publisher` to determine when a sound is done playing.
    /// - Parameters:
    ///   - player: an `AVAudioPlayer` instance
    ///   - flag: a `Bool` indicating whether the sound was successfully played
    func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
        if let currentAudioFile = currentAudioFile {
            didFinishPlayingCurrentAudioFile.send(currentAudioFile)
        }
        resetPublishedValues()
    }
}
</code></pre>
","4475605","","4475605","","2021-04-02 08:21:28","2021-04-04 00:45:02","Using AVAudioPlayer in background","<audio><swiftui><avaudioplayer><combine>","1","0","1","","","CC BY-SA 4.0"
"66916773","1","66917632","","2021-04-02 08:49:00","","0","263","<p>My API return a JSON data with 2 possible data set formats and how do I decode it? Thank you so much in advance</p>
<p>result.json</p>
<pre><code>format 1:
{
    product_name: &quot;coffee&quot;
    product_code: &quot;100010&quot;
    variant: [
        flavour: [
            {
                flavour_name: &quot;chocolate&quot;,
                flavour_code: &quot;C001&quot;,
            },
            {
                flavour_name: &quot;vanilla&quot;,
                flavour_code: &quot;C002&quot;,
            }
        ],
        size: [ { ... }, { ... } ]
    ]
}

format 2:
{
    product_name: &quot;bread&quot;,
    product_code: &quot;B123&quot;,
    variant: [
        portion: [&quot;quarter&quot;, &quot;half&quot;, &quot;full&quot;],
        type: [&quot;plain&quot;, &quot;wheat&quot;, &quot;oat&quot;],
    ]
}
</code></pre>
<p>MenuViewModel.swift</p>
<pre><code>class MenuDetailViewModel: ObservableObject, MenuDetailService {
    var apiSession: APIService
    @Published var detaildata: MenuDetailData?
    
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(apiSession: APIService = APISession()) {
        self.apiSession = apiSession
    }
    
    func getMenuDetail() {
        let cancellable = self.getMenuDetail(menuCode: menuCode)
            .sink(receiveCompletion: { result in
                switch result {
                case .failure(let error):
                    print(&quot;Handle error: \(error)&quot;)
                case .finished:
                    break
                }
                
            }) { (detail) in
                self.detaildata = detail.data
        }
        cancellables.insert(cancellable)
    }
    
}
</code></pre>
<p>MenuDetailService.swift</p>
<pre><code>protocol MenuDetailService {
    var apiSession: APIService {get}
    
    func getMenuDetail(menuCode: String) -&gt; AnyPublisher&lt;MenuDetailAPIResponse, APIError&gt;
}

extension MenuDetailService {
    
    func getMenuDetail(menuCode: String) -&gt; AnyPublisher&lt;MenuDetailAPIResponse, APIError&gt; {
        return apiSession.request(with: APIEndpoint.menuDetail(menuCode: menuCode))
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>APIService.swift</p>
<pre><code>protocol APIService {
    func request&lt;T: Decodable&gt;(with builder: RequestBuilder) -&gt; AnyPublisher&lt;T, APIError&gt;
}
</code></pre>
<p>RequestBuilder.swift</p>
<pre><code>protocol RequestBuilder {
    var urlRequest: URLRequest {get}
}
</code></pre>
<p>APISession.swift</p>
<pre><code>struct APISession: APIService {
    func request&lt;T&gt;(with builder: RequestBuilder) -&gt; AnyPublisher&lt;T, APIError&gt; where T: Decodable {
        
        // 1
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        
        // 2
        return URLSession.shared
            .dataTaskPublisher(for: builder.urlRequest)
            // 3
            .receive(on: DispatchQueue.main)
            // 4
            .mapError { _ in .unknown }
            // 5
            .flatMap { data, response -&gt; AnyPublisher&lt;T, APIError&gt; in
                if let response = response as? HTTPURLResponse {
//                    let dataString = String(data: data, encoding: .utf8) {
//                        print(&quot;Response data string:\n \(dataString)&quot;)
//                    }
                    
                    if (200...299).contains(response.statusCode) {
                        print(String(data: data, encoding: .utf8) ?? &quot;&quot;)
                        // 6
                        return Just(data)
                            .decode(type: T.self, decoder: decoder)
                            .mapError {_ in .decodingError}
                            .eraseToAnyPublisher()
                    } else {
                    // 7
                        return Fail(error: APIError.httpError(response.statusCode))
                            .eraseToAnyPublisher()
                    }
                }
                return Fail(error: APIError.unknown)
                        .eraseToAnyPublisher()
            }
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>APIEndpoint.swift</p>
<pre><code>enum APIEndpoint {
    case menuDetail(menuCode: String)
}

extension APIEndpoint: RequestBuilder {
    var urlRequest: URLRequest {
        switch self {
        case .menuDetail(let menuCode):
            guard let url = URL(string: &quot;API_URL/product/detail&quot;)
                else {preconditionFailure(&quot;Invalid URL format&quot;)}
            var request = URLRequest(url: url)
            request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
            request.setValue(Constants.API_TOKEN, forHTTPHeaderField: &quot;Authorization&quot;)
            request.httpMethod = &quot;POST&quot;
            
            let body: [String: Any] = [&quot;brand&quot;: 1, &quot;city&quot;: &quot;&quot;, &quot;menu_code&quot;: menuCode, &quot;member_phone&quot;: &quot;&quot;]
            let rb = try! JSONSerialization.data(withJSONObject: body)
            request.httpBody = rb
            
            return request
        }
    }
}
</code></pre>
<p>MenuDetailAPIResponse.swift</p>
<pre><code>struct MenuDetailAPIResponse: Codable {
    let data: MenuDetailData
}
</code></pre>
<p>MenuDetailData.swift</p>
<pre><code>struct MenuDetailData: Codable, Identifiable {
    let id = UUID()
    let productName: String
    let productCode: String
    let variant: [MenuVariant]
}

struct MenuVariant: Codable, Identifiable, Hashable {
    let id = UUID()
    let flavour: [MenuFlavour]
    let size: [MenuSize]
}

struct MenuFlavour: Codable, Identifiable, Hashable {
    let id = UUID()
    let flavourName: String
    let flavourCode: String
}
</code></pre>
","4608714","","4608714","","2021-04-02 09:07:22","2021-04-02 10:00:13","SwiftUI MVVM data binding decode JSON with different formats","<ios><json><swift><xcode><swiftui>","1","3","","2021-04-02 10:06:38","","CC BY-SA 4.0"
"66930090","1","66930971","","2021-04-03 10:28:25","","0","251","<p>There are three publishers. First you need to try the first, if an error occurs, then use the second, if again an error, then use the third, if there is a failure, then return the last error. Important: you cannot call in parallel, it is necessary to follow the sequence. I have an assumption that the scan method should be used, but I do not understand how exactly.</p>
","10682199","","","","","2021-04-04 14:01:10","How to call the next swift combine publisher in turn if the previous one reported an error?","<combine>","1","0","","","","CC BY-SA 4.0"
"66938411","1","66938539","","2021-04-04 06:02:37","","0","116","<p>I kind of wrote everything correctly and the code itself is working but it gives me an error Result of call to 'fetchPokemon()' is unused, what could be the problem here?</p>
<p>Hear is my code: ModelView class</p>
<pre><code> import Foundation
 import Combine
 class NetworkManager: ObservableObject {

let baseuRL = &quot;https://pokeapi.co/api/v2/pokemon&quot;

@Published var pokemon: [Pokemon] = []
var error: Error?
var cancellables: Set&lt;AnyCancellable&gt; = []

func fetchPokemon() -&gt; Future&lt;[Pokemon], Error&gt; {
    return Future&lt;[Pokemon], Error&gt; { promice in
        guard let url = URL(string: &quot;\(self.baseuRL)&quot;) else {
            return promice(.failure(ApiError.unknowed))
        }
        URLSession.shared.dataTaskPublisher(for: url)
            .tryMap { (data, response) -&gt; Data in
                guard let http = response as? HTTPURLResponse,
                      http.statusCode == 200 else {
                    throw ApiError.responseError
                }
                return data
            }
            .decode(type: PokemonList.self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    break
                case .failure(let error):
                    print(error)
                }
            }, receiveValue: {
                promice(.success($0.results))
            })
            .store(in: &amp;self.cancellables)
    }
}


 struct ContentView: View {
@StateObject var net = NetworkManager()
var body: some View {
    List(net.pokemon, id: \.self) { pokemon in
        Text(pokemon.name)
    }.onAppear {
        net.fetchPokemon()
    }
}
</code></pre>
<p>}</p>
","13065117","","","","","2021-04-04 06:22:03","Result with combine can't get results","<swift><xcode><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66962267","1","66962642","","2021-04-06 03:16:20","","1","395","<p>I have two publishers, both of which can publish a value or complete without publishing any at all. I'm combining the two publishers and comparing their values and doing some post-processing on the values and saving them to my local CoreData. Simplified code looks like:</p>
<pre><code>let p1 = [&quot;1&quot;]
    .publisher
    .map { Int($0) }

let p2 = [&quot;2&quot;]
    .publisher
    .map { Int($0) }

let p1p2 = p1.combineLatest(p2)
    .map { $0 == $1 }
    .sink { print($0) }
</code></pre>
<p>But in case one of the publishers doesn't publish any value, I still need to save the remaining value to my local DB. The issue is that the combineLatest operator doesn't fire any event if one of the publisher finishes without ever firing a value. I tried prepend and append operators, but they cannot be combined with any conditions, say if one of the publishers finish without publishing any value.</p>
<p>For example, something like:</p>
<pre><code>let p1String: [String] = []
let p1 = p1String.publisher
    .map { Int($0) }
    .if(completionWithoutPublishing, perform: { prepend(nil) })
</code></pre>
<p>Any ideas would be appreciated.</p>
","3970488","","","","","2021-04-06 04:24:59","Append element to publisher only if it wants to finish without publishing any value","<swift><combine>","2","2","1","","","CC BY-SA 4.0"
"66972792","1","66972903","","2021-04-06 16:34:42","","0","33","<p>Unable to get <code>Data</code> using <code>Combine</code>, nothing is printed on the console.</p>
<pre><code>struct RepositoryElement: Codable {}

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        
        let url = URL(string: &quot;https://api.github.com/users/brunosilva808/repos&quot;)!

        let repos = URLSession.shared.dataTaskPublisher(for: url)
            .map { $0.data }
            .decode(type: [Repository].self, decoder: JSONDecoder())
            .sink(receiveCompletion: { completion in // 5
                print(completion)
            }, receiveValue: { repositories in
                print(&quot;brunosilva808 has \(repositories.count) repositories&quot;)
            })
    }
}
</code></pre>
","516765","","516765","","2021-04-06 16:39:19","2021-04-06 16:43:22","Unable to do a urlSession request with Combine","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"66982854","1","67011837","","2021-04-07 09:05:52","","2","570","<p>If I specify the <code>maxPublishers</code> parameter then source events after first maxPublishers events won't be flat mapped. While I want to limit only concurrency. That is to continue processing next events after some of the first maxPublishers flat map publishers have completed.</p>
<pre><code>Publishers.Merge(
    addImageRequestSubject
        .flatMap(maxPublishers: .max(3)) { self.compressImage($0) }
        .compactMap { $0 }
        .flatMap(maxPublishers: .max(3)) { self.addImage($0) },
    addVideoRequestSubject
        .flatMap(maxPublishers: .max(3)) { self.addVideo(url: $0) }
).sink(receiveCompletion: { _ in }, receiveValue: {})
.store(in: &amp;cancelBag)
</code></pre>
<p>I've also tried to limit concurrency with help of OperationQueue. But <code>maxConcurrentOperationCount</code> seems doesn't have an effect.</p>
<pre><code>Publishers.Merge(
    addImageRequestSubject
        .receive(on: imageCompressionQueue)
        .flatMap { self.compressImage($0) }
        .compactMap { $0 }
        .receive(on: mediaAddingQueue)
        .flatMap { self.addImage($0) },
    addVideoRequestSubject
        .receive(on: mediaAddingQueue)
        .flatMap { self.addVideo(url: $0) }
).sink(receiveCompletion: { _ in }, receiveValue: {})
.store(in: &amp;cancelBag)

private lazy var imageCompressionQueue: OperationQueue = {
    var queue = OperationQueue()
    queue.maxConcurrentOperationCount = 3

    return queue
}()

private lazy var mediaAddingQueue: OperationQueue = {
    var queue = OperationQueue()
    queue.maxConcurrentOperationCount = 3

    return queue
}()
</code></pre>
<p>Flat map publishers look this way:</p>
<pre><code>func compressImage(_ image: UIImage) -&gt; Future&lt;Data?, Never&gt; {
    Future { promise in
        DispatchQueue.global().async {
            let result = image.compressTo(15)?.jpegData(compressionQuality: 1)
            promise(Result.success(result))
        }
    }
}
</code></pre>
","1531671","","1531671","","2021-04-07 10:52:10","2021-04-08 21:01:35","How to limit flatMap concurrency in Combine still having all source events processed?","<swift><combine>","1","4","","","","CC BY-SA 4.0"
"66982859","1","66990247","","2021-04-07 09:06:05","","1","823","<p>I'm writing a ChartView using NSView with data obtained from a rest api using Combine. The struct PlotView is the SwiftUI View that displays the chart, ChartViewRepresentable is the bridge between the NSView with the chart and the SwiftUI world and ChartView is the view that I actually draw on.</p>
<p>RestRequest gets the data from the network correctly and PlotView has access to it with no issues. When the data is received a ChartViewRepresentable is created and it contains the data, and ChartViewRepresentable creates a ChartView with the data and the data is stored in its data property correctly.</p>
<p>There are two problems: 1) the view's draw method never gets called when the data is loaded, and 2) if the view is redrawn a new ChartViewRepresentable (with a new ChartView) is created by SwiftUI but with no data.</p>
<p>I have connected the RestRequest @StateObject in every possible way imaginable, using @Binding, using @State, with no luck so far, so I'm discounting it as the problem, but with SwiftUI who really knows. It doesn't matter how I load the data, even loading the data manually into ChartView, it never calls the draw method on its own when receiving the data, and then when I for example resize the window to force a draw call it does call the draw method but on a new ChartViewRepresentable struct with no data in it.</p>
<p>What am I doing wrong? This is all the code besides the RestRequest() struct which I know works because I have been using it reliably on other views until now. Any clue or even a hint would be greatly appreciated.</p>
<pre><code>struct PlotView: View {
    @StateObject var request = RestRequest()
    
    var body: some View {
        Group {
            ChartViewRepresentable(data: ChartData(array: ChartData.createArray(from: request.response.data)))
                .frame(minWidth: 300, maxWidth: .infinity, minHeight: 300, maxHeight: .infinity)
        }
        .onAppear{
            let params: [String: String] = [
                &quot;limit&quot;: &quot;10&quot;,
            ]
            request.perform(endPoint: &quot;http://localhost:4000/api/testdata&quot;, parameters: params)
        }
    }
}


struct ChartViewRepresentable: NSViewRepresentable {
    typealias NSViewType = ChartView
    
    var chart: ChartView
    
    init(data: ChartData) {
        chart = ChartView(data: data)
    }
    
    func makeNSView(context: Context) -&gt; ChartView {
        return chart
    }
    func updateNSView(_ nsView: ChartView, context: Context) {
    }
}

class ChartView: NSView {
    
    private var data: ChartData
    
    init(data: ChartData) {
        self.data = data
        print(&quot;\(data)&quot;)
        super.init(frame: .zero)
        wantsLayer = true
        layer?.backgroundColor = .white
    }
    
    required init?(coder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    override func draw(_ dirtyRect: NSRect) {
        print(&quot;draw call - Frame: \(self.frame), Data: \(data.array.count)&quot;)
        
        super.draw(dirtyRect)
        
        guard let context = NSGraphicsContext.current else { return }
        context.saveGraphicsState()
        
        if data.array.count &gt; 0 {
            //detect data present on ChartView
            let ctx = context.cgContext
            ctx.setFillColor(NSColor.green.cgColor)
            ctx.fillEllipse(in: CGRect(x: 10, y: 10, width: 10, height: 10))
        }
        
        context.restoreGraphicsState()
    }
}
</code></pre>
","572366","","","","","2021-04-07 16:30:09","SwiftUI NSViewRepresentable can't read data from @Publisher","<swift><swiftui><core-graphics><combine><uiviewrepresentable>","1","0","","","","CC BY-SA 4.0"
"66984760","1","66984986","","2021-04-07 11:03:30","","1","370","<p>I have the following functions:</p>
<pre><code>    func getUserProfile() -&gt; AnyPublisher&lt;UserProfileDTO?, Error&gt; {
    return Future { [unowned self] promise in
        do {
            if let data = KeychainWrapper.standard.data(forKey: profileKey) {
                let profileDTO = try PropertyListDecoder().decode(UserProfileDTO.self, from: data)
                setCurrentSession(profileDTO)
                promise(.success(profileDTO))
            }
            else {
                promise(.success(nil))
            }
        }
        catch {
            // Delete current UserProfile if cannot decode
            let _ = KeychainWrapper.standard.removeAllKeys()
            promise(.failure(error))
        }
    }.eraseToAnyPublisher()
}

    func connect(userProfile: UserProfileDTO) -&gt; AnyPublisher&lt;UserProfileDTO, Error&gt; {
    return Future { promise in
        SBDMain.connect(withUserId: userProfile.email) { (user, error) in
            if let error = error {
                promise(.failure(error))
            }
            else {
                promise(.success(userProfile))
            }
        }
    }.eraseToAnyPublisher()
}
</code></pre>
<p>What I want to do is to first call the getUserProfile() method and if the return value in not nil then call the connect() method. However, if the getUserProfile() has nil response it does not need to call the connect() and it should just return the nil response. Both these methods needs to be called from the autoLoginUser() method.
The problem I'm having right now is figuring out how to do this in a clean swift way without writing too much nested statements.</p>
<p>I tried to use flatMaps but it didn't workout the way I expected. Any help is much appreciated.</p>
<p>A solution I've been working on at the moment is this. But it doesn't quite work.</p>
<pre><code>    func autoLoginUser2() -&gt; AnyPublisher&lt;UserProfile?,Error&gt; {
    getUserProfile()
        .tryMap { [unowned self] in
            if let currentProfile = $0 {
                return connect(userProfile: currentProfile)
                    .tryMap {
                        //Map from UserProfileDTO --&gt; UserProfile
                        return UserProfileDTOMapper.map($0)
                        
                    }
            }
            return nil
        }.eraseToAnyPublisher()
}
</code></pre>
","5201157","","5201157","","2021-04-08 10:09:34","2021-04-08 10:09:34","Swift Combine - Async calls","<swift><async-await><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"66997336","1","66998365","","2021-04-08 04:25:17","","-1","256","<p>I'm attempting to implment a <code>Map</code> on a SwiftUI view from a view model. Every example I find online hard codes a coordinate. In my case, I'm initializing a view model with a <code>Codable</code> struct and I have no idea what the coordinate is going to be.</p>
<p>I do not encounter compiler issues when I build the project, but canvas crashes. I've tried closing Xcode, cleaning derived data, etc., but that doesn't seem to resolve it.</p>
<p>Any suggestions re: where my mistake is are greatly appreciated.</p>
<pre><code>class EarthquakeViewModel: ObservableObject {
    @Published private(set) var quakeData: Feature
    @State var region: MKCoordinateRegion
    
    
    init(quakeData: Feature) {
        self.quakeData = quakeData
        let center = CLLocationCoordinate2D(latitude: quakeData.geometry.coordinates[0],
                                        longitude: quakeData.geometry.coordinates[1])
        let span = MKCoordinateSpan(latitudeDelta: 1.0, longitudeDelta: 1.0)
        region = MKCoordinateRegion(center: center,
                                    span: span)
    }

        public lazy var title: String = {
        quakeData.properties.title
    }()
}
</code></pre>
<p>This is my <code>ContentView</code>:</p>
<pre><code>struct EarthquakeView: View {
    @ObservedObject var viewModel: EarthquakeViewModel
    
    var body: some View {
        VStack {
            Text(viewModel.title)
//            makeMapView()
            Map(coordinateRegion: $viewModel.region)
        }
    }
}
</code></pre>
<p>// I tried this, too, but it doesn't work.</p>
<pre><code>extension EarthquakeView {
    @ViewBuilder func makeMapView() -&gt; some View {
        Map(coordinateRegion: $viewModel.region)
    }
}

</code></pre>
<h2>Update</h2>
<p>This is the message from Diagnostics. Cleaning derived data with Xcode closed doesn't seem to resolve it, so I think my issue lies with one of my declarations:</p>
<pre><code>RemoteHumanReadableError: Failed to update preview.

The preview process appears to have crashed.

Error encountered when sending 'render' message to agent.

==================================

|  RemoteHumanReadableError: The operation couldn’t be completed. (BSServiceConnectionErrorDomain error 3.)
|  
|  BSServiceConnectionErrorDomain (3):
|  ==BSErrorCodeDescription: OperationFailed
</code></pre>
<h2>Update 2</h2>
<p>I tweaked my data model and added a computed region var off of it, so here's how I'm getting the region now:</p>
<pre><code>extension Feature /* Feature is a Codable struct */ {
    var region: MKCoordinateRegion {
        let center = CLLocationCoordinate2D(latitude: geometry.coordinates[0],
                                            longitude: geometry.coordinates[1])
        let span = MKCoordinateSpan(latitudeDelta: 1.0, longitudeDelta: 1.0)
        let region = MKCoordinateRegion(center: center,
                                        span: span)
        
        return region
    }
}
</code></pre>
<p>At <a href=""https://stackoverflow.com/users/560942/jnpdx"">jnpdx's</a> suggestion, I updated the region on my view model to<code> @Published</code>.</p>
<pre><code>class EarthquakeViewModel: ObservableObject {
    `@Published private(set) var quakeData: Feature
    `@Published var region: MKCoordinateRegion
    
    init(quakeData: Feature) {
        self.quakeData = quakeData
        region = quakeData.region
    }
    
    public lazy var title: String = {
        quakeData.properties.title
    }()
}
</code></pre>
<p>And lastly, my View, as follows:</p>
<pre><code>struct EarthquakeView: View {
    @ObservedObject var viewModel: EarthquakeViewModel
    
    @State var region: MKCoordinateRegion
    
    init(viewModel: EarthquakeViewModel) {
        self.viewModel = viewModel
        _region = State(initialValue: viewModel.region)
    }
    
    var body: some View {
        VStack {
            Text(viewModel.title)
            Map(coordinateRegion: $region)
        }
    }
}
</code></pre>
<p>The new error is this. Closing Xcode, rebooting, cleaning derived data, etc. doesn't seem to resolve it, so I am quickly concluding I'm missing something basic:</p>
<blockquote>
<p>PreviewUpdateTimedOutError: Updating took more than 5 seconds Updating
a preview from EarthquakeView_Previews in CombineQuake.app (16766)
took more than 5 seconds.</p>
</blockquote>
<h2>Update 3</h2>
<p>Preview initialization:</p>
<pre><code>struct EarthquakeView_Previews: PreviewProvider {
    static var previews: some View {
        
        let quakeData = EarthQuakeData(mag: 6.5,
                                       place: &quot;32km W of Sola, Vanuatu&quot;,
                                       time: 1388592209000,
                                       updated: 1594407529032,
                                       tz: 660,
                                       url: &quot;https://earthquake.usgs.gov/earthquakes/eventpage/usc000lvb5&quot;,
                                       detail: &quot;https://earthquake.usgs.gov/fdsnws/event/1/query?eventid=usc000lvb5&amp;format=geojson&quot;,
                                       felt: nil,
                                       cdi: nil,
                                       mmi: nil,
                                       alert: nil,
                                       status: &quot;reviewed&quot;,
                                       tsunami: 1,
                                       sig: 650,
                                       net: &quot;us&quot;,
                                       code: &quot;c0001vb5&quot;,
                                       ids: &quot;,pt14001000,at00myqcls,usc000lvb5,&quot;,
                                       sources: &quot;pt,at,us&quot;,
                                       types: &quot;cap,geoserve,impact-link,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary&quot;,
                                       nst: nil,
                                       dmin: 3.997,
                                       rms: 0.76,
                                       gap: 14.0,
                                       magType: &quot;mww&quot;,
                                       type: &quot;earthquake&quot;,
                                       title: &quot;M 6.5 - 32km W of Sola, Vanuatu&quot;)
        let geometry = Geometry(type: &quot;Point&quot;,
                                coordinates: [167.249, -13.8633, 187.0])
        let earthquake = Feature(type: &quot;Feature&quot;,
                                 properties: quakeData,
                                 geometry: geometry,
                                 id: &quot;usc000lvb5&quot;)
        
        let viewModel = EarthquakeViewModel(quakeData: earthquake)
        
        
        EarthquakeView(viewModel: viewModel)
    }
}
</code></pre>
","4475605","","4475605","","2021-04-08 06:05:28","2021-04-08 06:25:29","Initializing Map from an Observable view model in SwiftUI","<swiftui><mapkit><combine>","1","5","","","","CC BY-SA 4.0"
"67005269","1","67009115","","2021-04-08 13:41:40","","1","411","<p>Does anybody have a working copy/sample of using AWS Amplify with the Combine framework?</p>
<p>The samples provided
<a href=""https://docs.amplify.aws/lib/datastore/data-access/q/platform/ios"" rel=""nofollow noreferrer"">https://docs.amplify.aws/lib/datastore/data-access/q/platform/ios</a>
<a href=""https://docs.amplify.aws/lib/auth/getting-started/q/platform/ios#configure-auth-category"" rel=""nofollow noreferrer"">https://docs.amplify.aws/lib/auth/getting-started/q/platform/ios#configure-auth-category</a>
Seems really straight forward and I'm using it verbatim, but since I'm not well versed in Combine, it could be that I'm losing the sink, especially when these functions are placed in an Observable class.</p>
<p>And when going with URL session, my attempts deliver a load of the same error:</p>
<p>Error Domain=NSCocoaErrorDomain Code=4099 &quot;The connection to service on pid 0 named com.apple.commcenter.coretelephony.xpc was invalidated from this process.&quot; UserInfo={NSDebugDescription=The connection to service on pid 0 named com.apple.commcenter.coretelephony.xpc was invalidated from this process.}</p>
","5944973","","","","","2022-01-25 21:16:48","AWS Amplify for Swift / SwiftUI under Combine framework cause headache","<swift><sample><combine><amplify>","2","0","","","","CC BY-SA 4.0"
"67017829","1","67017950","","2021-04-09 08:40:17","","1","318","<p>I'm new to Combine and I don't understand the behaviour in these cases:</p>
<pre><code>func getPublisherWithFirst() -&gt; AnyPublisher&lt;Value, Error&gt; {
    // somePublisher: PassthroughSubject&lt;Bool, Never&gt;
    return somePublisher
        .compactMap { (someBool) -&gt; Value? in
            if someBool {
                return Value()
            }
            return nil
        }
        .setFailureType(to: Error.self)
        .first()
        .timeout(.seconds(5), scheduler: DispatchQueue.main)
        .eraseToAnyPublisher()
}
</code></pre>
<pre><code>func getPublisherWithFlatMap() -&gt; AnyPublisher&lt;Value, Error&gt; {
    // somePublisher: PassthroughSubject&lt;Bool, Never&gt;
    return somePublisher
        .flatMap { (someBool) -&gt; AnyPublisher&lt;Value, Never&gt; in
            if someBool {
                return Just(Value()).eraseToAnyPublisher()
            }
            return Empty(completeImmediately: false, outputType: Value.self, failureType: Never.self).eraseToAnyPublisher()
        }
        .setFailureType(to: Error.self)
        .timeout(.seconds(5), scheduler: DispatchQueue.main)
        .eraseToAnyPublisher()
}
</code></pre>
<p>When using <code>getPublisherWithFlatMap</code>, my stream does not finish (the timeout is triggered), even if a <code>Just</code> publisher is returned and it is supposed to finish. Why?</p>
","1220867","","4667835","","2021-04-09 08:45:45","2021-04-09 08:49:28","Combine: difference between Just and first() to finish a stream","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"67037463","1","67037735","","2021-04-10 17:43:52","","4","238","<p>I'm very new to Swift. For learning purposes I'm creating a little countdown app (days until date X).
Those countdowns are presented in a List. A single countdown in the list is represented by the following view.</p>
<pre><code>struct CountdownRow: View {
  @State private var remainingDays: Int = 0
  @State private var progress: Float = 0.0
  
  var countdown: Countdown
  
  var body: some View {
    VStack{
      HStack {
        Text(countdown.name)
          .font(.subheadline)
          .multilineTextAlignment(.leading)
          .padding(10)
        Spacer()
        Text(String(remainingDays))
          .font(.headline)
          .padding(10)
      }
      ProgressView(value: progress)
        .padding(10)
    }
    .onAppear {
      remainingDays = countdown.getRemainingDays()
      progress = countdown.getProgress()
    }
    .onReceive(NotificationCenter.default.publisher(for:
        UIApplication.significantTimeChangeNotification), 
        perform: { _ in
      remainingDays = countdown.getRemainingDays()
      progress = countdown.getProgress()
    })
  }
}
</code></pre>
<p>I want to update the remaining days for each countdown at midnight. But the .onReceive modifier doesn't trigger when the time changes from 23:59 to 0:00.
Receiving other notifications (e.g. UIApplication.willEnterForegroundNotification) instead works as expected.</p>
<p>Why is this specific notification not emitted (or received) at midnight?
According to the documentation at apple, it should be emitted at midnight.</p>
<p>Thank you!</p>
","9786743","","9786743","","2021-04-10 17:59:04","2021-04-10 18:11:39","Why is significantTimeChangeNotification not emitted (or not received?)","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"67045350","1","67053255","","2021-04-11 13:09:21","","0","271","<p>So I am writing a todo list app in SwiftUI in order to get the hang of it, but I am facing a problem.</p>
<p>In my first view (list of items) I have a toolbar with an &quot;add&quot; button which uses a NavigationLink to navigate to the detail view. In the detail view I also have a toolbar button acting as a save button which dismisses this view and also adds the item to a list of items kept in the view model used by both views.</p>
<p>The problem is that if I save the item when tapping the save button it will first navigate back to the first view and then auto navigate to the second view again. If I instead use the built in back button this issue doesn't happen, but obviously I would like to save the item and only when pressing save. This also only happens if I add the item to the item list in the view model before dismissing the view, if I only dismiss the view without saving the item when pressing done then this bug doesn't happen.</p>
<p>Is this not a standard way of saving and closing a view with SwiftUI, or is there some sort of other pattern that is better? In any case I need to resolve this issue.</p>
<p>First view:</p>
<pre><code>struct TodoListView: View {
    @EnvironmentObject var viewModel: TodoListViewModel

    var body: some View {
        NavigationView {
            List {
                ForEach(viewModel.listOfTodos) { todoItem in
                    ItemCellView(todoItem: todoItem)
                }
            }
            .navigationTitle(&quot;Things to do&quot;)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    NavigationLink(
                        destination: AddEditTodoView(todoItem: TodoListInfo.TodoItem())
                    ) {
                        Text(&quot;Add item&quot;) // The navigation bug happens when using this button
                    }
                }
            }
        }
        .navigationViewStyle(StackNavigationViewStyle())
    }
}

struct ItemCellView: View {
    var todoItem: TodoListInfo.TodoItem

    var body: some View {
        HStack {
            NavigationLink(destination: AddEditTodoView(todoItem: todoItem)) {
                Text(todoItem.title) // The navigation bug doesn't happen when editing an existing item
            }
        }
        .padding()
    }
}
</code></pre>
<p>Second view:</p>
<pre><code>struct AddEditTodoView: View {
    @Environment(\.presentationMode) var presentationMode: Binding&lt;PresentationMode&gt;
    @EnvironmentObject var viewModel: TodoListViewModel
    @State var todoItem: TodoListInfo.TodoItem

    var body: some View {
        Form {
            Section(header: Text(&quot;Title&quot;)) {
                TextField(&quot;Title&quot;, text: $todoItem.title)
            }
        }
        .navigationTitle(Text(&quot;Edit task&quot;))
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button(&quot;Done&quot;) {
                    viewModel.upsert(item: todoItem) // No bug if I comment out this line
                    presentationMode.wrappedValue.dismiss()
                }
                .disabled(todoItem.title == &quot;&quot;)
            }
        }
    }
}
</code></pre>
<p>View model:</p>
<pre><code>class TodoListViewModel: ObservableObject {
    @Published private var todoListInfo: TodoListInfo
    private var autoSaveCancellable: AnyCancellable? // even without the autoSaveCancellable part, the bug happens

    init(testData: Bool = false) {
        todoListInfo = TodoListInfo(testData: testData)
        autoSaveCancellable = $todoListInfo.sink {
            TodoListInfo.persistTodoList($0)
        }
    }

    var listOfTodos: [TodoListInfo.TodoItem] {
        todoListInfo.todos
    }

    func upsert(item: TodoListInfo.TodoItem) {
        if let itemIndex = todoListInfo.todos.firstIndex(where: { $0.id == item.id }) {
            todoListInfo.todos[itemIndex] = item
        } else {
            todoListInfo.todos.append(item) // This gets called when adding an item
        }
    }
}
</code></pre>
","8542471","","","","","2021-04-12 05:50:27","SwiftUI auto navigates to detail view after saving and dismissing the view","<ios><swift><swiftui>","1","1","","","","CC BY-SA 4.0"
"67072311","1","67073664","","2021-04-13 09:36:20","","1","1388","<p>I'm exploring Combine Swift with this project <a href=""https://github.com/sgl0v/TMDB"" rel=""nofollow noreferrer"">https://github.com/sgl0v/TMDB</a>
and I'm trying to replace its imageLoader with something that supports Combine: <a href=""https://github.com/JanGorman/MapleBacon"" rel=""nofollow noreferrer"">https://github.com/JanGorman/MapleBacon</a></p>
<p>The project has a function that returns the type <code>AnyPublisher&lt;UIImage?, Never&gt;</code>.
But the imageLoader MapleBacon library returns the type <code>AnyPublisher&lt;UIImage, Error&gt;</code>.</p>
<p>So I'm trying to convert types with this function:</p>
<pre><code>func convert(_ loader: AnyPublisher&lt;UIImage, Error&gt;) -&gt; AnyPublisher&lt;UIImage?, Never&gt; {
    // here.
}
</code></pre>
<p>I actually found a question that is kinda similar to mine, but the answers weren't helpful:
<a href=""https://stackoverflow.com/a/58234908/3231194"">https://stackoverflow.com/a/58234908/3231194</a></p>
<hr />
<p>What I've tried to so far (Matt's answer to the linked question).</p>
<p>The sample project has this function:</p>
<pre><code>func loadImage(for movie: Movie, size: ImageSize) -&gt; AnyPublisher&lt;UIImage?, Never&gt; {
        return Deferred { return Just(movie.poster) }
            .flatMap({ poster -&gt; AnyPublisher&lt;UIImage?, Never&gt; in
                guard let poster = movie.poster else { return .just(nil) }
                let url = size.url.appendingPathComponent(poster)
                let a = MapleBacon.shared.image(with: url)
                    .replaceError(with: UIImage(named: &quot;&quot;)!) // &lt;----
            })
            .subscribe(on: Scheduler.backgroundWorkScheduler)
            .receive(on: Scheduler.mainScheduler)
            .share()
            .eraseToAnyPublisher()
    }
</code></pre>
<p>if I do <code>replaceError</code>,</p>
<p>I get the type <code>Publishers.ReplaceError&lt;AnyPublisher&lt;UIImage, Error&gt;&gt;</code></p>
<hr />
<p>BUT, I was able to solve this one, by extending the library.</p>
<pre><code>extension MapleBacon {
    public func image(with url: URL, imageTransformer: ImageTransforming? = nil) -&gt; AnyPublisher&lt;UIImage?, Never&gt; {
      Future { resolve in
        self.image(with: url, imageTransformer: imageTransformer) { result in
          switch result {
          case .success(let image):
            resolve(.success(image))
          case .failure:
            resolve(.success(UIImage(named: &quot;&quot;)))
          }
        }
      }
      .eraseToAnyPublisher()
    }
}
</code></pre>
","3231194","","3231194","","2021-04-13 10:42:03","2021-04-13 11:05:06","Swift combine Convert Publisher type","<ios><swift><combine>","1","6","","","","CC BY-SA 4.0"
"67074601","1","67074936","","2021-04-13 12:11:16","","-2","228","<p>In an <a href=""https://www.cocoawithlove.com/blog/separated-services-layer.html"" rel=""nofollow noreferrer"">article</a>, I saw a code snippet like below:</p>
<pre><code>extension URLSessionDataTask: Cancellable {}

extension URLSession: NetworkService {
   public func fetchData(with request: URLRequest, handler: @escaping (Data?, URLResponse?, Error?) -&gt; Void) -&gt; AnyCancellable {
      let task = dataTask(with: request, completionHandler: handler)
      task.resume()
      return AnyCancellable(task)
   }
}
</code></pre>
<p>There are several things that I do not understand:</p>
<ol>
<li>What is the purpose of making URLSessionDataTask conform to 'Cancellable' protocol;</li>
<li>If URLSessionDataTask conforms to 'Cancellable' protocol, why does not it implement the methods that 'Cancellable' protocol requires;</li>
<li>When I check the initialiser of AnyCancellable, there is no initialiser which accepts an argument, so what does 'AnyCancellable(task)' do here and is it correct?</li>
</ol>
<p>Appreciate any help.</p>
","3690904","","","","","2021-04-13 12:31:40","A question about URLSessionDataTask and Combine in Swift","<ios><swift><combine><nsurlsessiondatatask>","1","2","1","","","CC BY-SA 4.0"
"67099143","1","67099668","","2021-04-14 21:09:55","","2","702","<p>I am using Swift Combine and would like to make a <code>Publisher</code> that was created from an array of <code>Publisher</code>. It should emit an array of elements every time one of the Publishers in the array emits a new element.</p>
<p>In <code>RxSwift</code> would be like the following:</p>
<pre class=""lang-swift prettyprint-override""><code> let obs1 = PublishSubject&lt;Int&gt;()
 let obs2 = PublishSubject&lt;Int&gt;()
 let arrayObs = [obs1, obs2)]

 Observable.combineLatest(arrayObs)
    .subscribe(onNext: { arrayOfLatest in
        print(arrayOfLatest) //prints an array of integers
    }).disposed(by: disposeBag)

obs1.onNext(5) 
obs2.onNext(10) // prints [5,10]
obs1.onNext(12) // prints [12,10]

</code></pre>
","7969193","","","","","2021-05-04 14:47:53","How to make a Publisher from array of Publishers?","<ios><swift><reactive-programming><combine>","2","0","1","","","CC BY-SA 4.0"
"67110487","1","67110788","","2021-04-15 14:34:24","","0","53","<p>I am trying with combine to manage my socket &amp; handle messages</p>
<pre><code>private var garbageBag = Set&lt;AnyCancellable&gt;()

func setupSocket() {
  
    
    SocketHelper.shared.startListene()
  
    garbageBag.forEach{$0.cancel()}
    
    SocketHelper.shared.publisher.sink {[unowned self] (sub) in
        print(sub)
        print(&quot;FINISH &quot;)

    } receiveValue: {[unowned self] (value) in
        print(&quot;SUBSCRBE GOT VALUE &quot;)
      
     }.store(in: &amp;garbageBag)

}
</code></pre>
<p>This method call several times, so sink is also called many times to prevent that I have written like and it solves problem</p>
<pre><code>    garbageBag.forEach{$0.cancel()}
</code></pre>
<p>But Now suppose 4 time this method will be called so in <code>garbageBag</code> there will be 4 Items</p>
<p>How can I remove canceled items</p>
<p>I know directly empty the Set is one solution but is there any way to check ?</p>
","4601900","","","","","2021-04-15 14:53:35","Find Canceled Publisher Combine","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"67128650","1","67131295","","2021-04-16 16:08:31","","0","576","<p>According to Apple, <a href=""https://developer.apple.com/documentation/combine/fail/receive(on:options:)"" rel=""nofollow noreferrer""><code>receive(on:options:)</code></a> runs callbacks on a given queue. We use a serial dispatch queue to prevent racing on <code>localOptionalCancellable</code> in the code below. But <code>receiveCancel</code> is not getting dispatched to that queue. Can someone tell me why?</p>
<p>From the documentation,</p>
<blockquote>
<p>You use the receive(on:options:) operator to receive results and completion on a specific scheduler, such as performing UI work on the main run loop.</p>
<p>...</p>
<p>Prefer receive(on:options:) over explicit use of dispatch queues when performing work in subscribers. For example, instead of the following pattern:</p>
</blockquote>
<h3>Issue Reproduction:</h3>
<pre><code>import Foundation
import Combine

class Example {
    private var localOptionalCancellable: AnyCancellable?
    private let dispatchQueue = DispatchQueue(label: &quot;LocalQueue-\(UUID())&quot;)
    
    func misbehavingFunction() {
        self.dispatchQueue.async {
            self.localOptionalCancellable = Just(())
                .setFailureType(to: Error.self)
                .receive(on: self.dispatchQueue)
                .handleEvents(
                    receiveCancel: {
                        // Simultaneous accesses to 0x600000364e10, but modification requires exclusive access.
                        // Can be fixed by wrapping in self.dispatchQueue.async {}
                        self.localOptionalCancellable = nil
                    }
                )
                .sink(
                    receiveCompletion: { _ in },
                    receiveValue: { _ in
                        self.localOptionalCancellable = nil
                    }
                )
        }
    }
}

Example().misbehavingFunction()
</code></pre>
<h3>Stack Trace:</h3>
<pre><code>Simultaneous accesses to 0x600000364e10, but modification requires exclusive access.
Previous access (a modification) started at  (0x10eeaf12a).
Current access (a modification) started at:
0    libswiftCore.dylib                 0x00007fff2ff7be50 swift_beginAccess + 568
3    Combine                            0x00007fff4ba73a40 Publishers.HandleEvents.Inner.cancel() + 71
4    Combine                            0x00007fff4ba74230 protocol witness for Cancellable.cancel() in conformance Publishers.HandleEvents&lt;A&gt;.Inner&lt;A1&gt; + 16
5    Combine                            0x00007fff4b9f10c0 Subscribers.Sink.cancel() + 652
6    Combine                            0x00007fff4b9f1500 protocol witness for Cancellable.cancel() in conformance Subscribers.Sink&lt;A, B&gt; + 16
7    Combine                            0x00007fff4b9dd2d0 AnyCancellable.cancel() + 339
8    Combine                            0x00007fff4b9dd5f0 AnyCancellable.__deallocating_deinit + 9
9    libswiftCore.dylib                 0x00007fff2ff7da20 _swift_release_dealloc + 16
13   Combine                            0x00007fff4b9f0da0 Subscribers.Sink.receive(_:) + 54
14   Combine                            0x00007fff4b9f14c0 protocol witness for Subscriber.receive(_:) in conformance Subscribers.Sink&lt;A, B&gt; + 16
15   Combine                            0x00007fff4ba73ed0 Publishers.HandleEvents.Inner.receive(_:) + 129
16   Combine                            0x00007fff4ba74170 protocol witness for Subscriber.receive(_:) in conformance Publishers.HandleEvents&lt;A&gt;.Inner&lt;A1&gt; + 16
17   Combine                            0x00007fff4ba26440 closure #1 in Publishers.ReceiveOn.Inner.receive(_:) + 167
18   libswiftDispatch.dylib             0x000000010e97cad0 thunk for @escaping @callee_guaranteed () -&gt; () + 14
19   libdispatch.dylib                  0x00007fff20105323 _dispatch_call_block_and_release + 12
20   libdispatch.dylib                  0x00007fff20106500 _dispatch_client_callout + 8
21   libdispatch.dylib                  0x00007fff2010c12e _dispatch_lane_serial_drain + 715
22   libdispatch.dylib                  0x00007fff2010cde1 _dispatch_lane_invoke + 403
23   libdispatch.dylib                  0x00007fff20117269 _dispatch_workloop_worker_thread + 782
24   libsystem_pthread.dylib            0x00007fff6116391b _pthread_wqthread + 290
25   libsystem_pthread.dylib            0x00007fff61162b68 start_wqthread + 15
Fatal access conflict detected.
</code></pre>
","7946143","","7946143","","2021-04-16 18:27:44","2021-04-16 19:41:33","Combine's receive(on:) not dispatching to serial queue, causing data race","<ios><swift><xcode><multithreading><combine>","1","9","","","","CC BY-SA 4.0"
"67133680","1","67218104","","2021-04-17 00:44:14","","5","340","<p>I have a Combine function that I use to search through a list of items and return matches. It keeps track of not only what items to show the user that match the search term, but also what items have been marked as &quot;chosen&quot; by the user.</p>
<p>The function works great, including animations, until I add either <code>.debounce(for: .seconds(0.2), scheduler: RunLoop.main)</code> <em>or</em> <code>.receive(on: RunLoop.main)</code> in the Combine publisher chain. At that point, the rendering of the results in the <code>View</code> get inexplicably strange -- item titles start showing up as header views, items are repeated, etc.</p>
<p>You can see the result in the accompanying GIF.</p>
<img src=""https://i.stack.imgur.com/q891n.gif"" width=""200""/>
<p>The GIF version is using <code>.receive(on: RunLoop.main)</code>. Note I don't even use the search term here, although it <em>also</em> leads to funny results. It also may be worth noting that everything works correctly <em>with</em> the problem lines if <code>withAnimation { }</code> is removed.</p>
<p>I'd like to be able to use <code>debounce</code> as the list may eventually be pretty large and I don't want to filter the whole list on every keystroke.</p>
<p><strong>How can I get the table view to render correctly under these circumstances?</strong></p>
<p>Example code (see inline comments for the pain points and explanation of the code. It should run well as written, but if either of the two relevant lines is uncommented) :</p>
<pre><code>
import SwiftUI
import Combine
import UIKit

class Completer : ObservableObject {
    @Published var items : [Item] = [] {
        didSet {
            setupPipeline()
        }
    }
    @Published var filteredItems : [Item] = []
    @Published var chosenItems: Set&lt;Item&gt; = []
    @Published var searchTerm = &quot;&quot;
    
    private var filterCancellable : AnyCancellable?
    
    private func setupPipeline() {
        filterCancellable =
            Publishers.CombineLatest($searchTerm,$chosenItems) //listen for changes of both the search term and chosen items
            .print()
            // ** Either of the following lines, if uncommented will cause chaotic rendering of the table **
            //.receive(on: RunLoop.main) //&lt;----- HERE --------------------
            //.debounce(for: .seconds(0.2), scheduler: RunLoop.main) //&lt;----- HERE --------------------
            .map { (term,chosen) -&gt; (filtered: [Item],chosen: Set&lt;Item&gt;) in
                if term.isEmpty { //if the term is empty, return everything
                    return (filtered: self.items, chosen: chosen)
                } else { //if the term is not empty, return only items that contain the search term
                    return (filtered: self.items.filter { $0.name.localizedStandardContains(term) }, chosen: chosen)
                }
            }
            .map { (filtered,chosen) in
                (filtered: filtered.filter { !chosen.contains($0) }, chosen: chosen) //don't include any items in the chosen items list
            }
            .sink { [weak self] (filtered, chosen) in
                self?.filteredItems = filtered
            }
    }
    
    func toggleItemChosen(item: Item) {
        withAnimation {
            if chosenItems.contains(item) {
                chosenItems.remove(item)
            } else {
                searchTerm = &quot;&quot;
                chosenItems.insert(item)
            }
        }
    }
}

struct ContentView: View {
    @StateObject var completer = Completer()
    
    var body: some View {
        Form {
            Section {
                TextField(&quot;Term&quot;, text: $completer.searchTerm)
            }
            Section {
                ForEach(completer.filteredItems) { item in
                    Button(action: {
                        completer.toggleItemChosen(item: item)
                    }) {
                        Text(item.name)
                    }.foregroundColor(completer.chosenItems.contains(item) ? .red : .primary)
                }
            }
            if completer.chosenItems.count != 0 {
                Section(header: HStack {
                    Text(&quot;Chosen items&quot;)
                    Spacer()
                    Button(action: {
                        completer.chosenItems = []
                    }) {
                        Text(&quot;Clear&quot;)
                    }
                }) {
                    ForEach(Array(completer.chosenItems)) { item in
                        Button(action: {
                            completer.toggleItemChosen(item: item)
                        }) {
                            Text(item.name)
                        }
                    }
                }
            }
        }.onAppear {
            completer.items = [&quot;Chris&quot;, &quot;Greg&quot;, &quot;Ross&quot;, &quot;Damian&quot;, &quot;George&quot;, &quot;Darrell&quot;, &quot;Michael&quot;]
                .map { Item(name: $0) }
        }
    }
}

struct Item : Identifiable, Hashable {
    var id = UUID()
    var name : String
}

</code></pre>
","560942","","560942","","2021-04-17 01:06:27","2022-03-18 18:15:52","Combine + SwiftUI Form + RunLoop causes table view to render unpredictably","<swiftui><combine>","2","14","","","","CC BY-SA 4.0"
"67139077","1","67146446","","2021-04-17 14:09:42","","0","94","<p>I'm trying to instantiate a user profile based on the logged in user from my AuthenticationState class (using Firebase Auth). This user profile is part of my UserProfileViewModel, which should power a view for editing the user's profile.</p>
<p>But it appears that the loggedInUser is still seen as nil when the UserProfileViewModel is instantiated, and I'm not sure if there's a way I can use a Combine subscription from another class like this to make sure I'm subscribed to the loggedInUser published variable of that specific instance of Authentication state.</p>
<p>Authentication state is called by my main app file, as an environment object - once the user logs in, the loggedInUser is set to that Firebase Auth user:</p>
<pre><code>class AuthenticationState: NSObject, ObservableObject {
    
    // The firebase logged in user, and the userProfile associated with the users collection
    @Published var loggedInUser: User?
    
    
    @Published var isAuthenticating = false
    @Published var error: NSError?
    
    static let shared = AuthenticationState()
    
    private let auth = Auth.auth()
    fileprivate var currentNonce: String?
</code></pre>
<p>I initialize AuthenticationState in my main app file:</p>
<pre><code>@main
struct GoalTogetherApp: App {

    let authState: AuthenticationState
    
    init() {
        FirebaseApp.configure()
        self.authState = AuthenticationState.shared
        
        setupFirebase()
    }
 
 
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(authState)
        }
    }
}
</code></pre>
<p>And I have this other class that I want to grab the loggedInUser, and then use that user's uid to create or find a userProfile from Cloud Firestore:</p>
<pre><code>class UserProfileViewModel: ObservableObject {
    
    @Published var loggedInUser: User?
    @Published var userProfile: UserProfile?
    
    private let auth = Auth.auth()
    private let db = Firestore.firestore()
    
    init() {
        self.loggedInUser = AuthenticationState.shared.loggedInUser
        
        if self.loggedInUser != nil {
            self.userProfile = self.loadUser()
        }
    }
</code></pre>
<p>And the Profile page is supposed to grab that and pull the email from the UserProfile, but it keeps coming up as blank:</p>
<pre><code>struct ProfilePage: View {
    @ObservedObject var userProfileVM = UserProfileViewModel()
    
    @State var email: String = &quot;&quot;
    
    init() {
        print(&quot;User Profile VM equals: \(String(describing: userProfileVM.userProfile))&quot;)
        if userProfileVM.userProfile?.email != nil {
            _email = State(initialValue: userProfileVM.userProfile!.email!)
        } else {
            _email = State(initialValue: &quot;&quot;)
        }
    }
</code></pre>
","13831483","","","","","2021-04-18 08:15:18","Subscribing to a user variable from my authentication class in an unrelated ViewModel - Swift/Combine","<swift><firebase-authentication><combine>","1","2","","","","CC BY-SA 4.0"
"67153619","1","67185880","","2021-04-18 21:39:28","","-1","949","<p>I want to transform a Publisher to another one but I'm having an error <code>Cannot convert return expression of type 'AnyPublisher&lt;LoginState, LoginRepositoryError&gt;' to return type 'AnyPublisher&lt;LoginState, Never&gt;'</code></p>
<p>Is my approach feasible?, I have the following code:</p>
<pre><code>public protocol LoginUseCase {
    func login(email: String, password: String) -&gt; AnyPublisher&lt;Bool, LoginRepositoryError&gt;
}
</code></pre>
<p>MyViewmodel.swift</p>
<pre><code>public func login(email: String?, password: String?) -&gt; AnyPublisher&lt;LoginState, Never&gt; {
    guard let email=email, !email.isEmpty else {
        return Just&lt;LoginState&gt;(.invalidEmail).eraseToAnyPublisher()
    }
    guard let password=password, !password.isEmpty else {
        return Just&lt;LoginState&gt;(.invalidPassword).eraseToAnyPublisher()
    }
    
    return loginUseCase.login(email: email, password: password)
        .map { result in
            let subject = PassthroughSubject&lt;LoginState, Never&gt;()
            switch result {
            case .success(_):
                subject.send(.success)
                break
            case .failure(let error):
                switch error {
                case .wrongPassword:
                    subject.send(.wrongPassword)
                case .userNotExist:
                    subject.send(.error)
                case .emailValidationPending:
                    subject.send(.emailValidationPending)
                }
            }
            return subject.eraseToAnyPublisher()
        }.eraseToAnyPublisher()
}
</code></pre>
","2139691","","","","","2021-04-20 20:26:04","Combine: Transform an AnyPublisher into a another AnyPublisher","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"67170209","1","67170586","","2021-04-19 22:41:07","","3","665","<p>When I create a swift package, and then I  use the simple line:</p>
<pre><code>import Combine
</code></pre>
<p>I get the following error:</p>
<pre><code>No such module 'Combine'
</code></pre>
<p>I've switched my scheme to <code>Any iOS Device</code></p>
<p><a href=""https://i.stack.imgur.com/5BQc9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5BQc9.png"" alt=""enter image description here"" /></a></p>
<p>I also set the platform in the <code>Package.swift</code> file</p>
<pre><code>import PackageDescription

let package = Package(
    name: &quot;AsyncImageView&quot;,
    platforms: [.iOS(.v8)],
    products: [
</code></pre>
<p>It still does not accept Combine.</p>
","3833666","","3833666","","2021-04-19 23:00:35","2021-04-20 00:14:56","No such module 'Combine' when used in my Swift Package","<swift><swift-package-manager>","1","6","0","","","CC BY-SA 4.0"
"67195862","1","67196018","","2021-04-21 12:21:50","","0","43","<p>Simple question, but struggling a while with it.</p>
<p>I have a web request, where I fetch an array of strings: <code>['a','b','c']</code></p>
<p>So to speak I have a <code>CurrentValueSubject</code> of <code>['a','b','c']</code>. I would like to create a downstream, where the elements then go one by one, how to achieve that?</p>
<p>Combine Framework stream transformation <code>['a','b','c']</code> -&gt; <code>'a'</code> then <code>'b'</code> then <code>'c'</code></p>
","1003641","","15407542","","2021-04-21 12:31:32","2021-04-21 12:32:42","Combine Framework stream transformation ['a','b','c'] -> 'a' then 'b' then 'c'","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"67216064","1","67217168","","2021-04-22 15:14:15","","0","125","<p>I have two types</p>
<pre><code>let left: Future&lt;[Int]&gt;
let right: Future&lt;[Int]&gt;
</code></pre>
<p>How can I combine these so I have one contiguous 1D array?</p>
<p>Using <code>append</code> and <code>merge</code> create 2D arrays and there's no clear information. Is really the best way to collect the 2D arrays and then use a flatMap inside of a flatMap like:</p>
<pre><code>.collect().flatMap { arrays in arrays.flatMap { $0 } }
</code></pre>
<p>there has to be a better way.</p>
","2611971","","","","","2021-04-22 18:26:04","Merge two Combine Arrays into a Single Array","<arrays><swift><combine><flatmap>","1","3","","","","CC BY-SA 4.0"
"67216664","1","67216901","","2021-04-22 15:50:05","","0","151","<p>I have problem with catching notifications from default <code>NotificationCenter</code>. Sometimes it does not receive it at all.</p>
<p>Code example below:</p>
<pre><code>NotificationCenter.default.publisher(for: Notifications.userNotification)
    .removeDuplicates()
    .receive(on: DispatchQueue.main)
    .sink { self.handle(notification: $0) }
    .store(in: &amp;subscriptions)
</code></pre>
<p>As soon as I remove <code>.removeDuplicates()</code> line it starts to receive all notifications.
The question is: do I really need this line? Is it really helpful/important?
I was searching for good example with <code>.removeDuplicates()</code> usage for <code>NotificationCenter</code>, but could not find anything.
Could someone explain me, why it is like that?</p>
<p><strong>Update</strong>:</p>
<p>In my case the <code>Notification</code>s used for navigation inside the app. It has <code>userInfo</code> dictionary with information like: <code>[&quot;navigateTo&quot; : &quot;viewControllerTypeShoppingCart&quot;]</code> or <code>[&quot;navigateTo&quot; : &quot;viewControllerTypeWishList&quot;]</code></p>
","5381903","","5381903","","2021-04-23 06:17:59","2021-04-23 06:17:59","Handle notifications with Combine in Swift with removeDuplicated() sometimes does not cache notifications","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"67223472","1","67223831","","2021-04-23 03:09:52","","-1","260","<p>I am new to combine and i am trying write the network layer for my App.</p>
<p>My network call is</p>
<pre><code>protocol NetworkRequest {
    associatedtype model
    func decode(_ data:Data) -&gt; AnyPublisher&lt;model,Error&gt;
}

extension NetworkRequest {

 fileprivate func load&lt;model&gt;(_ url:URL, session:NetworkSession = URLSession.shared) -&gt; AnyPublisher&lt;model,Error&gt; {
    
    return session.loadData(for: URLRequest(url: url))
        .mapError { error in
            .network(description: error.localizedDescription)
        }
        .flatMap(maxPublishers: .max(1)) { pair in
            self.decode(pair.data)
        }
        .eraseToAnyPublisher()
        
 }

}
</code></pre>
<p>my decode method is</p>
<pre><code>func decode(_ data:Data) -&gt; AnyPublisher&lt;model,Error&gt;
</code></pre>
<p>and my session.loadData is</p>
<pre><code>func loadData(for URLRequest: URLRequest) -&gt; AnyPublisher&lt;(data: Data, response: URLResponse), URLError&gt;
</code></pre>
<p>The problem is i am getting an error <code>Type of expression is ambiguous without more context</code></p>
<p>I am not exactly sure what i am doing wrong here. I simply want to use the decode method to get a publisher.</p>
","11975968","","11975968","","2021-04-23 07:31:51","2021-04-23 12:55:15","Converting one publisher into another publisher in Combine","<ios><swift><combine>","1","4","","","","CC BY-SA 4.0"
"67225254","1","67232083","","2021-04-23 06:51:33","","0","439","<p><em>Realm 10.7.3, Xcode 12.4, macOS 11.2.3</em></p>
<p>I am experimenting with Realm and Combine+SwiftUI. When I make changes to my data in Realm Studio, they immediately reflect in my app's UI as expected. But when I <strong>add</strong> or <strong>delete</strong> an object, my app UI does not change.</p>
<p>Here's my model definition:</p>
<pre><code>//--- Model ---
class Item: Object, ObjectKeyIdentifiable {
  @objc dynamic var _id = ObjectId.generate()
  @objc dynamic var text = &quot;&quot;
}
</code></pre>
<p>Here's my view model:</p>
<pre><code>//--- View Model ---
class ItemModel: ObservableObject {
  static let shared = ItemModel()
  var token: NotificationToken? = nil
  @Published var items = [Item]()
  
  init(){
    let realm = try! Realm()
    let results = realm.objects(Item.self)
    items = Array(results)
   
    token = results.observe { [weak self] _ in
      print(&quot;-- updated --&quot;)
      self?.objectWillChange.send()
    }
  }
  
  deinit{
    token?.invalidate()
  }
}
</code></pre>
<p>And last of all, here's my SwiftUI view:</p>
<pre><code>//--- View ---
struct ItemView: View {
  @StateObject private var model = ItemModel.shared

  var body: some View {
    ScrollView{
      VStack(spacing: 7){
        ForEach(model.items, id: \._id) { item in
          Text(item.text)
        }
      }
    }
  }
}
</code></pre>
<p>Any ideas why my app won't show new/deleted objects and only edits? If I rebuild my app, the new/deleted objects are shown.</p>
","1142348","","","","","2021-10-18 18:35:56","SwiftUI App Shows Realm Changes but Not New Objects","<swiftui><realm><combine>","1","0","1","","","CC BY-SA 4.0"
"67233418","1","67234018","","2021-04-23 16:08:53","","1","109","<p>I am working on a SwiftUI project, where I use the MVVM-architecture.</p>
<p>When changing a View-model object property from the SwiftUI view, it causes a memory conflict crash in the view-model object.</p>
<p>The error is of the type: <em>Simultaneous accesses to 0x600003591b48, but modification requires exclusive access.</em></p>
<p>In steps, here is what happens:</p>
<ol>
<li>View-model property is changed from view</li>
<li>View-model property changes model property</li>
<li>Model property notifies about changes</li>
<li>View-model receives change notification</li>
<li>View-model access model object</li>
<li>Crash occur due to memory conflict</li>
</ol>
<p>Relevant code snippets are seen below. Xcode project is a standard SwiftUI project.</p>
<p>The error will happen, after first clicking the add button, and then the modify button.</p>
<p>If the &quot;update&quot; code is moved into the &quot;receiveValue&quot; closure, the error will not occur. Likewise, the error will not occur, if the View-model class is made non-generic.</p>
<p>To my best knowledge, the code is all-right, so I suspect it is a compiler problem. But I am not sure.</p>
<pre><code>import Foundation
import SwiftUI
import Combine

struct ContentView: View {
    
    @ObservedObject var item: ViewModel&lt;Model&gt; = ViewModel&lt;Model&gt;()

    var body: some View {
        
        VStack {
            Button(&quot;Add&quot;, action: { item.add(model:Model()) })
            Button(&quot;Modify&quot;, action: { item.selected.toggle() })
        }
    }
}

protocol ModelType {
    
    var objectDidChange: ObservableObjectPublisher { get }
    
    var selected: Bool { get set }
}

class Model: ModelType {
    
    let objectDidChange = ObservableObjectPublisher()
    
    var selected = false {
        didSet {
            objectDidChange.send()
        }
    }
}

class ViewModel&lt;Model:ModelType&gt;: ObservableObject {
    
    var selected = false {
        didSet {
            model.selected = selected
        }
    }
    
    func add(model: Model) {
        self.model = model
        cancellable = model.objectDidChange.sink(receiveValue: { _ in
            self.update()
        })
    }
    
    private var model: Model! = nil
    private var cancellable: AnyCancellable? = nil
    
    func update() {
        
        // Crash log: Simultaneous accesses to 0x600003591b48, but modification requires exclusive access.
        
        print(&quot;update \(model.selected)&quot;)
    }
}

</code></pre>
","7391811","","7391811","","2021-04-23 16:15:41","2021-04-23 16:52:08","Swift memory conflict where it should not happen","<swift><swiftui>","1","3","","","","CC BY-SA 4.0"
"67238880","1","67238915","","2021-04-24 02:47:05","","0","100","<p><a href=""https://i.stack.imgur.com/LX3S0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LX3S0.png"" alt=""enter image description here"" /></a></p>
<p>How can I make the sign in view expand so that its left side is constrained to the left side and its right side is constrained to the right side as well?</p>
<pre><code>
import SwiftUI

struct Intro: View {
    var body: some View {
        ZStack {
            Image(&quot;IntroImage&quot;)
                .resizable()
                .aspectRatio(contentMode: .fill)
                .frame(alignment: .center)
            VStack {
                Spacer()
                Button(action: {}, label: {
                    Text(&quot;Sign in&quot;)
                        .foregroundColor(Color.black)
                        .padding()
                        .background(Color.green)
                })
            }
        }
        .ignoresSafeArea()
    }
}

struct Intro_Previews: PreviewProvider {
    static var previews: some View {
        Intro()
    }
}
</code></pre>
<p>I want it to look like this: <a href=""https://i.stack.imgur.com/IEfkY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/IEfkY.png"" alt=""enter image description here"" /></a></p>
<p>I am using a 640 × 1136 png for the image. I am testing it on all devices including iPhone 11.</p>
","3833666","","3833666","","2021-04-24 05:26:14","2021-04-24 05:26:14","How to make a button in front of an image but constrained to the left bottom and right of the view in SwiftUI?","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"67239037","1","67239106","","2021-04-24 03:20:29","","1","74","<p>I am new to Combine/now learning the operators,
I followed the example in the apple developer docs but the output was different in playground
<a href=""https://developer.apple.com/documentation/combine/publisher/max(by:)"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/combine/publisher/max(by:)</a>
<a href=""https://i.stack.imgur.com/Xdsb4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Xdsb4.png"" alt=""enter image description here"" /></a>
//the website shows</p>
<pre><code>enum Rank: Int {
    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king
}

let cards: [Rank] = [.five, .queen, .ace, .eight, .jack]
cancellable = cards.publisher
    .max {
        return  $0.rawValue &gt; $1.rawValue
    }
    .sink { print(&quot;\($0)&quot;) }

// Prints: &quot;queen&quot;

</code></pre>
<p>my playground shows:</p>
<pre><code>import Combine

enum Rank: Int {
    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king
}

let cards: [Rank] = [.five, .queen, .ace, .eight, .jack]
cards.publisher
    .max {
        return  $0.rawValue &gt; $1.rawValue
    }
    .sink { print(&quot;\($0)&quot;) }
//Prints: &quot;ace&quot;
</code></pre>
<p>I tried to solve the &quot;most common name in an array&quot; problem and it only works when I use &quot;&lt;&quot; not &quot;&gt;&quot; to find the max value/</p>
<pre><code>import Combine

var subscriptions = Set&lt;AnyCancellable&gt;()
let nameArray: [String] = [&quot;bob&quot;, &quot;james&quot;, &quot;bob&quot;, &quot;james&quot;, &quot;lee&quot;, &quot;bob&quot;, &quot;bob&quot;]

nameArray
    .filter{ !$0.isEmpty }
    .reduce(into: [String: Int]()){ $0[$1] = ($0[$1] ?? 0) + 1 }
    .publisher
    .max {$0.1 &lt; $1.1 }
    .sink{print($0)}
    .store(in: &amp;subscriptions)

//Prints: &quot;(key: &quot;bob&quot;, value: 4)&quot; 
</code></pre>
<p>Is it possible the apple document is wrong?
or am I doing something wrong?</p>
","15354305","","15354305","","2021-04-24 04:46:47","2021-04-24 04:46:47","example in apple documents for max(by:) operator does not work as described?","<swift><max><documentation><combine>","2","3","","","","CC BY-SA 4.0"
"67240884","1","67241817","","2021-04-24 08:45:34","","0","1691","<p>I have a list of combine publishers that each publish one optional value.
From this list, i want to create a publisher, that runs the upstream publishers <em>in the sequence they appear in the list, one after the other</em>, and then publish the first non-nil item i can find.</p>
<p>My first approach was</p>
<pre><code>publishers
    .publisher
    .flatMap(identity)
    .first(where: {$0 != nil})
</code></pre>
<p>but this causes all publishers to run, and the fastest to win.</p>
<p>I created a minimal example with a solution that comes close to what i want to achieve.</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine
import Foundation
import PlaygroundSupport
PlaygroundPage.current.needsIndefiniteExecution = true

func delayedPublisher&lt;Value&gt;(_ value: Value?, delay after: Double) -&gt; AnyPublisher&lt;Value?, Never&gt; {
    let p = PassthroughSubject&lt;Value?, Never&gt;()
    DispatchQueue.main.asyncAfter(deadline: .now() + after) {
        p.send(value)
        p.send(completion: .finished)
    }
    return p.eraseToAnyPublisher()
}

let delays = [1,2,3,4,5].map({ Bool.random() ? nil : $0 }).shuffled()
print(&quot;Creating publishers with values and delays (in seconds)&quot;, delays)
let myPublishers = delays
    .map{ delayedPublisher($0, delay: Double($0 ?? 1))
        .print(&quot;\(String(describing: $0))&quot;)
        .eraseToAnyPublisher() }

let cancel = myPublishers
    .publisher
    .flatMap { $0 }
    .collect()
    .map { resultList in
        resultList.first(where: { $0 != nil }) ?? nil
    }
    .sink { result in
        print(&quot;result:&quot;, result ?? &quot;nil&quot;)
    }

</code></pre>
<p>This creates a bunch of publishers with different delays, that may or may not produce a value.
I then collect all results, and pick the first non-nil value.
The problem is</p>
<ul>
<li>All effects are run. I just want to run effects until i ran one that produces a value.</li>
<li>The results arrive in the order the publishers complete. I need to restore the original order after, which is possible but awkward in my specific example.</li>
</ul>
<p>I did my research but found nothing like that, perhaps because combine is not really designed to do that sort of thing. So any pointers are appreciated.</p>
","3885491","","","","","2021-06-17 20:48:55","Swift Combine: Run a list of publishers one after the other, and publish the first non-nil element","<ios><swift><combine>","2","0","","","","CC BY-SA 4.0"
"67259880","1","67283408","","2021-04-26 01:45:07","","0","872","<p>I'm playing about with writing a custom Combine publisher in order to better understand how I can turn various classes into them. Admittedly this is not something I want to do a lot, I just want to understand how it could be done if I need to.</p>
<p>The scenario I'm working with is where I have a class that generates values over time and potentially has multiple subscribers listening. It's not a case of the publisher generating values when requested, but pushing values when it desires. This might occur (for example) when reading text, or with random input from a UI.</p>
<p>To test this out I've started with a simple integer generator that's something like this:</p>
<pre class=""lang-swift prettyprint-override""><code>class IntPublisher {
                
    func generate() {
        DispatchQueue.global(qos: .background).async { [weak self] in
            self?.send(0)
            self?.send(1)
            self?.send(2)
            self?.complete()
        }
    }
        
    private func send(_ value: Int) {
        queueOnMain()
    }
        
    func queueOnMain() {
        Thread.sleep(forTimeInterval: 0.5)
        DispatchQueue.main.async { /* ... */ }
    }
}

</code></pre>
<p>And here's the generator as a <code>Publisher</code> and <code>Subscription</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>class IntPublisher: Publisher {
    
    typealias Output = Int
    typealias Failure = Never
    
    class Subscription: Combine.Subscription, Equatable {
        
        private var subscriber: AnySubscriber&lt;Int, Never&gt;?
        private var didFinish: ((Subscription) -&gt; Void)?
        
        init&lt;S&gt;(subscriber: S, didFinish:@escaping (Subscription) -&gt; Void) where S: Subscriber, S.Input == Output, S.Failure == Failure {
            self.subscriber = AnySubscriber(subscriber)
            self.didFinish = didFinish
        }
        
        func request(_ demand: Subscribers.Demand) {
        }
        
        func cancel() {
            finish()
        }
        
        func complete() {
            self.subscriber?.receive(completion: .finished)
            finish()
        }
        
        func finish() {
            didFinish?(self)
            subscriber = nil
            didFinish = nil
        }
        
        func send(_ value: Int) {
            _ = subscriber?.receive(value)
        }
        
        static func == (lhs: PublisherTests.IntPublisher.Subscription, rhs: PublisherTests.IntPublisher.Subscription) -&gt; Bool {
            return lhs.subscriber?.combineIdentifier == rhs.subscriber?.combineIdentifier
        }
    }
    
    var subscriptions = [Subscription]()
    
    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, S.Failure == Failure, S.Input == Output {
        
        let subscription = Subscription(subscriber: subscriber) { [weak self] (subscription) in
            self?.subscriptions.remove(subscription)
        }
        
        subscriptions.append(subscription)
        subscriber.receive(subscription: subscription)
    }
    
    func generate() {
        DispatchQueue.global(qos: .background).async { [weak self] in
            self?.send(0)
            self?.send(1)
            self?.send(2)
            self?.complete()
        }
    }
    
    private func send(_ value: Int) {
        queueOnMain { $0.send(value) }
    }
    
    private func complete() {
        queueOnMain { $0.complete() }
    }
    
    func queueOnMain(_ block: @escaping (Subscription) -&gt; Void) {
        Thread.sleep(forTimeInterval: 0.5)
        DispatchQueue.main.async { self.subscriptions.forEach { block($0) } }
    }
}
</code></pre>
<p>My question revolves around the way I've had to track the subscriptions in the publisher. Because it's generating the values and needs to forward them to the subscriptions, I've had to setup an array and store the subscriptions within it. In turn I had to find a way for the subscriptions to remove themselves from the publisher's array when they're cancelled or completed because the array effective forms a circular reference between the publisher and subscription.</p>
<p>In all the blogs I've read on custom publishing, they all cover the scenario where a publisher is waiting around for subscribers to request values. The publisher doesn't need to store a reference to the subscriptions because it passes closures which they can call to get a value. My use case is different because the publisher controls the request, not the subscribers.</p>
<p>So my question is this - Is using an array a good way to handle this? or is there something in Combine I've missed?</p>
","247090","","","","","2022-01-19 04:40:47","Combine: Is this a good technique for a custom publisher?","<swift><combine>","2","2","","","","CC BY-SA 4.0"
"67285032","1","70788672","","2021-04-27 14:26:00","","0","141","<p>I've set up a nice little view model with an <code>@Published</code> state:</p>
<pre class=""lang-swift prettyprint-override""><code>class ViewModel {
    @Published private(set) var state = State.loading
    private var cancellable: Set&lt;AnyCancellable&gt; = []
    enum State {
        case data([Users.UserData])
        case failure(Error)
        case loading
    }
}
</code></pre>
<p>I've then linked to this in my <code>UIViewController</code>'s <code>viewDidLoad</code> function:</p>
<pre class=""lang-swift prettyprint-override""><code>private var cancellable: AnyCancellable?

override func viewDidLoad() {
    super.viewDidLoad()
    cancellable = viewModel.$state.sink{  [weak self] _ in
        DispatchQueue.main.async {
           self?.render()
        }
    }
}
</code></pre>
<p>however, when I link directly to the state it doesn't change when the state is changed from the view model (not shown in the code).</p>
<pre class=""lang-swift prettyprint-override""><code>    private func render() {
        switch viewModel.state {
        case .loading:
            // Show loading spinner
            print(&quot;loading render&quot;)
        case .failure(let error):
            // Show error view
            print(&quot;failing render&quot;)
        case .data(let userData):
            // Show user's profile
            self.applySnapshot(userData: userData)

            print(&quot;loaded \(userData) render&quot;)
        }
    }
</code></pre>
<p>Now I can pass the state from my viewDidLoad, but how can I link directly to the viewModel state using <code>Combine</code> and <code>UIKit</code>?</p>
","11076699","","","","","2022-01-20 15:11:38","Combine link UIViewController to @Published","<swift>","1","0","","","","CC BY-SA 4.0"
"67292214","1","67292278","","2021-04-28 00:24:45","","0","133","<p>I have two methods with identical signature <code>func getItems() -&gt; AnyPublisher&lt;[Item], AppError&gt;</code>.
First is getting items from a storage, and the second one from the internet.</p>
<p>How can I add such logic to the third method with the same return type, if the first method completes successfully I return <code>storage.getItems()</code>, if not I return <code>network.getItems()</code>?</p>
","","user13691063","","","","2021-04-28 00:36:28","How to resolve two method calls with AnyPublisher return type into one?","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"67299564","1","67300951","","2021-04-28 11:43:01","","0","154","<p>I'm struggling with handling errors in Combine and find it very counter-intuitive that <a href=""https://developer.apple.com/documentation/combine/fail/catch(_:)"" rel=""nofollow noreferrer"">catching</a> or <a href=""https://developer.apple.com/documentation/combine/fail/replaceerror(with:)"" rel=""nofollow noreferrer"">replacing</a> an error completes and ends the publisher. For example, this ends the publisher even though I handled the exception:</p>
<pre><code>Just([1, 2, 3, NaN, 5, 6])
   .tryMap { _ in throw DummyError() }
   .catch { _ in Just(4) } // or .replaceError(with: 4)
   .sink { print($0) } // &lt;-- ends at 4 and ignores 5, 6, and anything ever again
</code></pre>
<p>If the publisher was subscribed to some system change, the first error will make my app dead until the user restarts the app. I would like to create a <code>catch</code> counterpart that does NOT end the publisher. I know <code>flatMap</code> is used for that, but that creates a whole other dimension of complexity such as inverting inner/outer publishers, publishers getting duplicated infinitely, back pressure, etc.</p>
<p>Is there a way to do something like this:</p>
<pre><code>Just([1, 2, 3, NaN, 5, 6])
   .tryMap { _ in throw DummyError() }
   .ignoreError { error in
        log(&quot;Error occurred: \(error)&quot;)
   }
   .sink { print($0) } // 1, 2, 3, 5, 6
</code></pre>
<p>How can I encapsulate this intent in a simple custom chain command called <code>ignoreError</code> and make my publishers live on?</p>
","235334","","235334","","2021-04-28 12:11:44","2021-04-28 19:28:07","Create a catch/replace error counterpart that does not complete the publisher?","<swift><combine>","1","11","","","","CC BY-SA 4.0"
"67328738","1","67328842","","2021-04-30 05:40:53","","-1","331","<p>I am new to Swift programming. Trying to build a login page with username and password fields with non empty validation</p>
<p>This is the code for validation using Combine:</p>
<pre><code>private var isUsernameValid: AnyPublisher&lt;Bool, Never&gt; {
        $username
            .debounce(for: 0.2, scheduler: RunLoop.main)
            .removeDuplicates()
            .map {
                if $0.isEmpty {
                self.errorUsername = &quot;Invalid Username&quot;
                return false
            } else {
                self.errorUsername = &quot;&quot;
                return true
            } }
            .eraseToAnyPublisher()
    }
    
    private var isPasswordValid: AnyPublisher&lt;Bool, Never&gt; {
        $password
            .debounce(for: 0.2, scheduler: RunLoop.main)
            .removeDuplicates()
            .map {
                if $0.isEmpty {
                self.errorPassword = &quot;Invalid Password&quot;
                return false
            } else {
                self.errorPassword = &quot;&quot;
                return true
            } }
            .eraseToAnyPublisher()
    }
    
    private var isFormValid: AnyPublisher&lt;Bool, Never&gt; {
        Publishers.CombineLatest(isUsernameValid, isPasswordValid)
            .debounce(for: 0.2, scheduler: RunLoop.main)
            .map { $0 &amp;&amp; $1 }
            .eraseToAnyPublisher()
    }
</code></pre>
<p>As soon as I enter login page error message is showing. I only want validation error to show after user starts typing into text field. Please help</p>
","15618585","","","","","2021-04-30 05:52:22","Combine: How to validate textfields only after user input","<swift><validation><combine>","1","0","","2021-04-30 06:01:28","","CC BY-SA 4.0"
"67341566","1","67341772","","2021-04-30 23:34:23","","1","97","<p>I am wondering why I am not required to provide any parameters at the call site of the function on <code>line 19</code></p>
<p><a href=""https://i.stack.imgur.com/7JhHS.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7JhHS.png"" alt=""Code Snippet of a custom timer"" /></a></p>
<p>I have a strong feeling its because of the <code>static</code> keyword on the function but I still would like more clarity / insight. Thanks</p>
<p>Code in text form below (if it helps)</p>
<pre><code>  import SwiftUI
  import Combine


   final class CurrentTime: ObservableObject {
    @Published var seconds: TimeInterval = CurrentTime.currentSecond(date: Date())
    
    private let timer = Timer.publish(every: 0.2, on: .main, in: .default).autoconnect()
    private var store = Set&lt;AnyCancellable&gt;()
    
    init() {
        timer.map(Self.currentSecond).assign(to: \.seconds, on: self).store(in: &amp;store) // &lt;-- Why am I not asked for a parameter here
    }
    
    
    private static func currentSecond(date: Date) -&gt; TimeInterval {
        let components = Calendar.current.dateComponents([.year, .month, .day], from: date)
        let referenceDate = Calendar.current.date(from: DateComponents(year: components.year!, month: components.month!, day: components.day!))!
        return Date().timeIntervalSince(referenceDate)
    }
}
</code></pre>
","14346703","","","","","2021-05-01 02:29:07","A function with parameters that doesn't require its parameters at the call site?","<swift>","2","6","","","","CC BY-SA 4.0"
"67353167","1","67353428","","2021-05-02 05:08:53","","3","571","<p>I'm trying to listen to <code>@State</code> changes and followed <a href=""https://stackoverflow.com/a/64659265/14351818"">this answer</a>. Here's my code:</p>
<pre><code>import SwiftUI

struct ContentView: View {
    @State var isOn = false
    
    var body: some View {
        Toggle(&quot;Selection&quot;, isOn: $isOn)
            .onReceive(Just(isOn)) { isOn in
                print(&quot;Toggle is on? \(isOn)&quot;)
            }
    }
}
</code></pre>
<p>It doesn't compile: I get &quot;Cannot find 'Just' in scope&quot;</p>
<p><a href=""https://i.stack.imgur.com/qhFx1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qhFx1.png"" alt=""Cannot find 'Just' in scope with the line containing 'Just' highlighted"" /></a></p>
<p><a href=""https://developer.apple.com/documentation/combine/just"" rel=""nofollow noreferrer""><code>Just</code> is part of the Combine framework</a>. But, I thought SwiftUI already imported Combine? I <kbd>Command</kbd>-clicked <code>import SwiftUI</code>, then pressed <code>Jump to Definition</code>, and there it was at the top.</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th>Jump to Definition</th>
<th><code>import Combine</code> is at the top</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href=""https://i.stack.imgur.com/QNATz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QNATz.png"" alt=""Jump to Definition in popup menu"" /></a></td>
<td><a href=""https://i.stack.imgur.com/P0dSf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/P0dSf.png"" alt=""Line 1 of SwiftUI file is import Combine"" /></a></td>
</tr>
</tbody>
</table>
</div>
<p>Once I add <code>import Combine</code> to my code, it compiles. But shouldn't this be redundant and unnecessary?</p>
<p><a href=""https://i.stack.imgur.com/Ig4X4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Ig4X4.png"" alt=""Build succeeded"" /></a></p>
","14351818","","","","","2021-05-02 06:01:02","Why do I need to import Combine when SwiftUI already imports it?","<ios><swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"67366522","1","67366812","","2021-05-03 09:28:35","","1","1380","<p>I'm trying to fetch 'Post' objects from the API with AnyPublisher, but I'm unable to get the result. How can we achieve result from <code>AnyPublisher&lt;[Post], Error&gt;</code></p>
<p>Here is my code,</p>
<pre class=""lang-swift prettyprint-override""><code>
import UIKit
import Combine

struct Post: Decodable{
    var id: Int
    var userId: Int
    var body: String
    var title: String

}

protocol API {
    var baseUrl: String { get }
    var path: URL { get }
}

enum PostService: API {

    var baseUrl : String { &quot;https://jsonplaceholder.typicode.com&quot; }
    case all
    var path: URL {
        switch self {
        case .all:
            return URL(string: baseUrl + &quot;/posts&quot;)!
        }
    }

    func fetch(from url: URL) -&gt; AnyPublisher&lt;[Post], Error&gt; {
        return URLSession.shared
            .dataTaskPublisher(for: url)
            .mapError { $0 as Error }
            .map(\.data)
            .decode(type: [Post].self, decoder: JSONDecoder())
            .eraseToAnyPublisher()

    }
}

PostService.fetch(.all)  
// how to get all posts here

</code></pre>
","8329912","","","","","2021-05-03 09:50:01","Swift combine get custom objects from AnyPublisher","<ios><swift>","1","2","","","","CC BY-SA 4.0"
"67372556","1","67449130","","2021-05-03 16:35:04","","1","751","<p>I have started using Combine quite recently and I am trying to create a repository that returns the combination of several data sources. To do that, each data source loads its own data in a quite simple load method:</p>
<pre><code>func loadData() -&gt; AnyPublisher&lt;DataObject, Error&gt;
</code></pre>
<p>To combine the data sources I thought of using <code>combineLatest</code>, since it'll wait for the data sources to finish loading and then it'll publish either a combined set with the data or an error indicating that it failed:</p>
<pre><code>func loadData() -&gt; AnyPublisher&lt;[DataObject], Error&gt; {
   return dataSource1.loadData()
             .combineLatest(dataSource2.loadData())
             .map { $0.0 + $0.1 }
             .eraseToAnyPublisher()
}
</code></pre>
<p>Overall the behavior of it seems alright, I can call <code>repository.loadData()</code> and I'll get an array that includes the data for both items. However, that's not the case if any of the data sources fail. In that case, the load method will return an error regardless of whether the other data source succeeded.</p>
<p>Is there a standard or recommended way to collect all the errors when combining publishers? In my use context I'd like to be able to discard the error only if both publishers failed, but go through and succeed if only one of them does.</p>
","1523403","","1523403","","2021-05-04 08:11:47","2021-05-08 15:19:51","How are errors handled when combining publishers?","<ios><swift><swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"67379046","1","67390491","","2021-05-04 05:01:34","","3","449","<p><strong>XCode Version 12.5 (12E262) - Swift 5</strong></p>
<p>To simplify this example, I've created a <strong>testObj</strong> class and added a few items to an array.
Let's pretend that I want to render buttons on the screen (see preview below), once you click on the button, it should set <strong>testObj.isSelected = true</strong> which triggers the button to change the background color.</p>
<p>I know it's changing the value to <strong>true</strong>, however is not triggering the button to change its color.</p>
<p>Here's the example:</p>
<pre><code>//
//  TestView.swift
//
import Foundation
import SwiftUI
import Combine

struct TestView: View {
    
    @State var arrayOfTestObj:[testObj] = [
        testObj(label: &quot;test1&quot;),
        testObj(label: &quot;test2&quot;),
        testObj(label: &quot;test3&quot;)
    ]

    var body: some View {
        VStack {
            ForEach(arrayOfTestObj, id: \.id) { o in
                HStack {
                    Text(o.label)
                        .width(200)
                        .padding(20)
                        .background(Color.red.opacity(o.isSelected ? 0.4: 0.1))
                        .onTapGesture {
                            o.isSelected.toggle()
                        }
                }
            }
        }
    }
}
  
class testObj: ObservableObject {
    let didChange = PassthroughSubject&lt;testObj, Never&gt;()
    
    var id:String = UUID().uuidString   {didSet {didChange.send((self))}}
    var label:String = &quot;&quot;               {didSet {didChange.send((self))}}
    var value:String = &quot;&quot;               {didSet {didChange.send((self))}}
    var isSelected:Bool = false         {didSet {didChange.send((self))}}
    
    init (label:String? = &quot;&quot;) {
        self.label = label!
    }
}

struct TestView_Previews: PreviewProvider {
    static var previews: some View {
        TestView()
    }
}
</code></pre>
<p>If I update the ForEach as...</p>
<pre><code>ForEach($arrayOfTestObj, id: \.id) { o in
</code></pre>
<p>... then I get this error:</p>
<p><strong>Key path value type '_' cannot be converted to contextual type '_'</strong></p>
<p>How can I change <strong>testObj</strong> to make it bindable?</p>
<p>Any help is greatly appreciated.</p>
<p><a href=""https://i.stack.imgur.com/54BZu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/54BZu.png"" alt=""Test snippet to illustrate bindable custom object issue"" /></a></p>
","563401","","","","","2021-05-04 18:47:50","How to create bindable custom objects in SWIFT? (conform with ObservableObject)","<swift><swiftui><observableobject>","1","1","","","","CC BY-SA 4.0"
"67393767","1","67438117","","2021-05-05 00:29:14","","2","165","<p>My goal is to send async accelerometer readings to a server in periodic payloads.</p>
<p>Accelerometer data continues while offline and concurrently during the network requests, so I'll need to handle network failures as well as data that arrives during the duration of each network request.</p>
<p>My inelegant approach is to append each new update to an array:</p>
<pre><code>motionManager.startAccelerometerUpdates(to: .main) { data, error in
    dataArray.append(data)
}
</code></pre>
<p>And then periodically send a group of values to the server (<code>network</code> is my wrapper around <code>NWPathMonitor()</code>):</p>
<pre><code>let timer = Timer(fire: Date(), interval: 5, // Every 5 seconds
              repeats: true, block: { timer in
                if network.connected {
                    postAccelerometerData(payload: dataArray) { success
                        if success {
                            dataArray.removeAll()
                        }
                    }
                }
            })


RunLoop.current.add(timer, forMode: RunLoop.Mode.default)
</code></pre>
<p>The major issue with this approach is that the elements of the array added between when the network request fires and when it completes would be removed from the array without ever being sent to the server.</p>
<p>I've had some ideas about adding a queue and dequeuing X elements on for each network request (but then do I add them back to the queue if the request fails?).</p>
<p>I can't help but think there is a better way to approach this using <code>Combine</code> to &quot;stream&quot; these accelerometer updates to some sort of data structure to buffer them, and then send those on to a server.</p>
<p>The <code>postAccelerometerData()</code> function just encodes a JSON structure and makes the network request. Nothing particularly special there.</p>
","577237","","577237","","2021-05-07 14:18:53","2021-05-09 22:16:14","How to use Combine to send async accelerometer updates to server","<swift><networking><buffer><sensors><combine>","2","2","","","","CC BY-SA 4.0"
"67393881","1","67393936","","2021-05-05 00:51:59","","4","694","<p>We know Empty Publisher in Combine will trigger a completion event immediately：</p>
<pre><code>Empty&lt;Void,Never&gt;()
    .sink {
        print(&quot;completion: \($0)&quot;)  // will print!
    } receiveValue: {}
</code></pre>
<p>But Empty Publisher that flatMap returned will NOT trigger completion event:</p>
<pre><code>var subs = Set&lt;AnyCancellable&gt;()
let p0 = PassthroughSubject&lt;[Int],Error&gt;()
let p1 = p0
    .flatMap {_ in
        Empty&lt;Void,Never&gt;() // same Empty Publisher
    }.eraseToAnyPublisher()

p1
    .sink {
        print(&quot;completion: \($0)&quot;)  // but NOT print!
    } receiveValue: {}
    .store(in: &amp;subs)

p0.send([1,2,3])
</code></pre>
<p>Why is that??? Am I miss something??? Thanks! ;)</p>
","5487391","","","","","2021-05-05 03:14:36","Why Empty Publisher not trigger completion event in Combine?","<swift><combine><publisher>","1","2","1","","","CC BY-SA 4.0"
"67438411","1","67440677","","2021-05-07 16:12:28","","1","417","<p>I would like to subscribe to UIPasteboard changes in SwiftUI with onReceive.
<code>pHasStringsPublisher</code> will not be updated as soon as something in the clipboard changes and I don't understand why.</p>
<pre><code>import SwiftUI

struct ContentView: View {
    let pasteboard = UIPasteboard.general
    
    @State var pString: String = &quot;pString&quot;
    @State var pHasStrings: Bool = false
    @State var pHasStringsPublisher: Bool = false

    var body: some View {
        VStack{
            Spacer()
            Text(&quot;b: '\(self.pString)'&quot;)
                .font(.headline)
            Text(&quot;b: '\(self.pHasStrings.description)'&quot;)
                .font(.headline)
            Text(&quot;p: '\(self.pHasStringsPublisher.description)'&quot;)
                .font(.headline)
            Spacer()
            Button(action: {
                self.pString = self.pasteboard.string ?? &quot;nil&quot;
                self.pHasStrings = self.pasteboard.hasStrings
            }, label: {
                Text(&quot;read pb&quot;)
                    .font(.largeTitle)
            })
            Button(action: {
                self.pasteboard.items = []
            }, label: {
                Text(&quot;clear pb&quot;)
                    .font(.largeTitle)
            })
            Button(action: {
                self.pasteboard.string = Date().description
            }, label: {
                Text(&quot;set pb&quot;)
                    .font(.largeTitle)
            })
            
        }
        .onReceive(self.pasteboard
                    .publisher(for: \.hasStrings)
                    .print()
                    .receive(on: RunLoop.main)
                    .eraseToAnyPublisher()
                   , perform:
                    { hasStrings in
                        print(&quot;pasteboard publisher&quot;)
                        self.pHasStringsPublisher = hasStrings
                    })
    }

}
</code></pre>
","12523385","","","","","2021-05-07 19:30:06","SwiftUI onReceive don't work with UIPasteboard publisher","<swift><swiftui><combine><uipasteboard>","1","2","","","","CC BY-SA 4.0"
"67442948","1","67457749","","2021-05-08 00:15:20","","2","568","<p><em>Xcode 12.5, iOS 14.5, macOS 11.3</em></p>
<p>Let's say I have a simple Realm class like this in a SwiftUI app:</p>
<pre><code>class Item: Object, ObjectKeyIdentifiable{
  @objc dynamic var id = &quot;&quot;
  @objc dynamic var name = &quot;&quot;
  @objc dynamic var updated = Date()
}
</code></pre>
<p>I pass an object into a view using <code>@ObservedRealmObject</code> where I can edit its <code>name</code> property by binding it to a <code>TextField</code> view like this:</p>
<pre><code>struct DetailView: View {
  @ObservedRealmObject var item: Item

  var body: some View{
  
    TextField(&quot;Name...&quot;, $item.name)

  }
}
</code></pre>
<p>When I edit the field, the <code>name</code> property updates as I type and the realm is updated in real-time.</p>
<p>But I also want to update the <code>updated</code> property with a new <code>Date()</code> timestamp whenever the object is modified. Since the write transaction is managed automatically by <code>@ObservedRealmObject</code>, I'm unclear on how to pull this off.</p>
<p>How can I change <code>updated</code> every time the <code>name</code> (or any other additional property) is changed?</p>
","1142348","","","","","2021-05-09 12:35:20","Update Additional Field on Realm Object with ObservedRealmObject in SwiftUI","<swiftui><realm><combine>","1","5","1","","","CC BY-SA 4.0"
"67461067","1","67461230","","2021-05-09 18:26:01","","1","199","<p>I have this rather common situation where a <code>List</code> is displaying some items from an <code>@ObservedObject</code> data store as <code>NavigationLinks</code>.</p>
<p>On selecting a <code>NavigationLink</code> a <strong>DetailView</strong> is presented. This view has a simple <code>Toggle</code> conected to a <code>@Published</code> var on its <strong>ViewModel</strong> class.</p>
<p>When the <strong>DetailView</strong> appears (<code>onAppear:</code>) its View Model sets the published <code>var</code> that controls the <code>Toggle</code> to <code>true</code> and also triggers an async request that will update the <strong>main data store</strong>, causing the <code>List</code> in the previous screen to update too.</p>
<p>The problem is that when this happens (the <code>List</code> is reloaded from an action triggered in the Detail View) multiple instances of the DetailViewModel seem to retained and the DetailView starts receiving events from the wrong <strong>Publishers</strong>.</p>
<p>In the first time the Detail screen is reached the behaviour is correct (as shown in the code below), the toggle is set to <code>true</code> and the <strong>store</strong> is updated, however, on navigating back to the <code>List</code> and then again to another DetailView the toggle is set to <code>true</code> on appearing but this time when the code that reloads the <strong>store</strong> executes, the toggle is set back to <code>false</code>.</p>
<p>My understanding is that when the <code>List</code> is reloaded and a new DetailView and ViewModel are created (as the destination of the <code>NavigationLink</code>) the initial value from the <code>isOn</code>  variable that controls the <code>Toggle</code> (which is <code>false</code>) is somehow triggering an update to the <code>Toggle</code> of the currently displayed screen.</p>
<p>Am I missing something here?</p>
<pre><code>import SwiftUI
import Combine

class Store: ObservableObject {
    static var shared: Store = .init()
    @Published var items = [&quot;one&quot;, &quot;two&quot;]
    private init() { }
}

struct ContentView: View {
    @ObservedObject var store = Store.shared
    
    var body: some View {
        NavigationView {
            List(store.items, id: \.self) { item in
                NavigationLink(item, destination: ItemDetailView())
            }
        }
    }
}

struct ItemDetailView: View {
    @ObservedObject var viewModel = ItemDetailViewModel()
    
    var body: some View {
        VStack {
            Toggle(&quot;A toggle&quot;, isOn: $viewModel.isOn)
            Text(viewModel.title)
            Spacer()
        }   .onAppear(perform: viewModel.onAppear)
    }
}

class ItemDetailViewModel: ObservableObject {
    @ObservedObject var store: Store = .shared
    @Published var isOn = false

    var title: String {
        store.items[0]
    }
    
    func onAppear() {
        isOn = true
        asyncOperationThatUpdatesTheStoreData()
    }
    
    private func asyncOperationThatUpdatesTheStoreData() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) { [weak self] in
            self?.store.items = [&quot;three&quot;, &quot;four&quot;]
        }
    }
}
</code></pre>
<img src=""https://i.stack.imgur.com/ToFv9.gif"" width=""350"" />
","1222373","","1222373","","2021-05-09 21:05:01","2021-05-09 21:05:01","SwiftUI List data update from destination view causes unexpected behaviour","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"67472990","1","67473266","","2021-05-10 15:09:09","","1","188","<p>I have 3 classes:</p>
<pre><code>class ClassOne: ObservableObject {
    @Published var loading: Bool = false
}

class ClassTwo: ObservableObject {
    @Published var loading: Bool = false
}

class ClassThree: ObservableObject {
    @Published var loading: Bool = false
}
</code></pre>
<p>In a SwiftUI view I need to do something when all <code>loading</code> variables are <code>true</code></p>
<p>This is a simplified version of my files of course: loading var of every class is set true or false by a download method.
I just need something to check if all download are completed and remove the loading view.</p>
<pre><code>struct MainScreen3: View {
    @State private var cancellables = Set&lt;AnyCancellable&gt;()
    @EnvironmentObject var classOne: ClassOne
    @EnvironmentObject var classTwo: ClassTwo
    @EnvironmentObject var classThree: ClassThree
    
    @State private var loading: Bool = true
    
    var body: some View {
        VStack {
            if loading {
                Text(&quot;Please wait...&quot;)
            } else {
                Text(&quot;Done!&quot;)
            }
            
        }.onAppear {
            self.classOne.fetchFromServer()
            self.classTwo.fetchFromServer()
            self.classThree.fetchFromServer()
        }
    }
}
</code></pre>
<p>Any suggestion?</p>
","15887870","","","","","2021-05-10 23:51:32","Check multiple @Published values","<swift><combine><observableobject>","2","0","","","","CC BY-SA 4.0"
"67508127","1","67512477","","2021-05-12 17:08:29","","0","1152","<p>What's the best way, to delay a moment when a publisher sends some data in Swift Combine? Let's assume following situation:</p>
<pre><code>private var publisher: PassthroughSubject&lt;Progress, Error&gt;

// closure called every second:
startWithProgress() { [weak self] progress in
    self.publisher.send(.init(progress: progress))

    // How to call this 0.5 second after the above `send`:
    self.publisher.send(.init(progress: progress + 0.5))
}
</code></pre>
<p>I checked <code>Delay</code> API, but it seems I'd need to create another publisher to make use of it, which is suboptimal in my case. I also checked <code>throttle</code> and <code>debounce</code>, but those also don't allow me to send 2 updates one after another, with a given delay between them.</p>
","1828352","","","","","2021-05-13 00:43:36","Combine - Delay publisher's send","<ios><swift><swiftui><combine>","3","4","","","","CC BY-SA 4.0"
"67523248","1","67523619","","2021-05-13 17:02:33","","1","154","<p>I'm looking for an operator that does the opposite of the <a href=""https://heckj.github.io/swiftui-notes/#reference-collect"" rel=""nofollow noreferrer"">collect</a> operator:</p>
<ul>
<li>Allows you to map from one emission value to many emission values, emitting them on the stream. For example if I have the element <code>[1,2,3]</code> in the stream, I want to convert it into a stream that emits <code>1</code> then <code>2</code>, then <code>3</code>.</li>
<li>Does not change the stream's completion state. Admittedly this <code>uncollect</code> operator wouldn't be exactly the opposite of <code>collect</code> since <code>collect</code> waits until the stream is finished. With <code>uncollect</code> it should just process results while the stream is unfinished, and not attempt to finish/unfinish the stream.</li>
</ul>
<p>For example, I imagine this is how an <code>uncollect</code> operator would function:</p>
<pre><code>func fibonacci(_ number: Int) -&gt; AnyPublisher&lt;Int, Never&gt; {
  Future { ... }.eraseToAnyPublisher()
}

let serverEventStream: AnyPublisher&lt;[Int], Never&gt; = ...

serverEventStream              // AnyPublisher&lt;[Int], Never&gt;  // Ex. 2 values: `[12, 24]`, `[1, 10, 50]`
  .uncollect { $0 }            // AnyPublisher&lt;Int, Never&gt;    // Ex. 5 values: `12`, `24`, `1`, `10`, `50`
  .flatMap { fibonacci($0) }   // AnyPublisher&lt;Int, Never&gt;    // Ex. 5 values: `144`, `46368`, `1`, `55`, `12586269025`
  .sink { print($0) }
</code></pre>
<p>I was looking for names like <code>explode</code>, <code>splat</code>, or <code>uncollect</code>, to no avail. The closest operator that shares a promising name is <a href=""https://heckj.github.io/swiftui-notes/#reference-flatmap"" rel=""nofollow noreferrer""><code>flatMap</code></a> since <a href=""https://developer.apple.com/documentation/swift/sequence/2905332-flatmap"" rel=""nofollow noreferrer""><code>Sequence.flatMap</code></a> is the equivalent in the non-Combine world. However, <a href=""https://stackoverflow.com/questions/59428026/how-to-replicate-promisekit-style-chained-async-flow-using-combine-swift"">Combine's <code>flatMap</code> is the way to chain promises together</a>.</p>
<p>Is there a way to uncollect elements, or map a single emission into an arbitrary number of emissions?</p>
<hr />
<p>I was able to get it to work with my <a href=""https://stackoverflow.com/a/67523545/35690"">custom <code>JustSeveral</code> Publisher</a>, but this seems clunky:</p>
<pre><code>class Tests: XCTestCase {
  func testUncollect() {
    func fibonacci(_ number: Int) -&gt; AnyPublisher&lt;Int, Never&gt; {
      switch number {
      case 1: return Just(1).eraseToAnyPublisher()
      case 10: return Just(55).eraseToAnyPublisher()
      case 12: return Just(144).eraseToAnyPublisher()
      case 24: return Just(46368).eraseToAnyPublisher()
      case 50: return Just(12586269025).eraseToAnyPublisher()
      default: fatalError(&quot;Should actually build this function.&quot;)
      }
    }

    let serverEventStream: AnyPublisher&lt;[Int], Never&gt; = JustSeveral([[12, 24], [1, 10, 50]]).eraseToAnyPublisher()

    serverEventStream              // AnyPublisher&lt;[Int], Never&gt;  // Ex. 2 values: `[12, 24]`, `[1, 10, 50]`
      .uncollect { $0 }            // AnyPublisher&lt;Int, Never&gt;    // Ex. 5 values: `12`, `24`, `1`, `10`, `50`
      .flatMap { fibonacci($0) }   // AnyPublisher&lt;Int, Never&gt;    // Ex. 5 values: `144`, `46368`, `1`, `55`, `12586269025`
      .sink { print($0) }
  }
}

extension Publisher {
  func uncollect&lt;T&gt;(_ transform: @escaping (Output) -&gt; [T]) -&gt; AnyPublisher&lt;T, Failure&gt; {
    self
      .flatMap { output -&gt; AnyPublisher&lt;T, Failure&gt; in
        JustSeveral(transform(output))
          .setFailureType(to: Failure.self)
          .eraseToAnyPublisher()
      }
      .eraseToAnyPublisher()
  }
}
</code></pre>
","35690","","35690","","2021-05-13 17:41:36","2021-05-13 17:47:40","Combine uncollect operator?","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"67523504","1","67523663","","2021-05-13 17:21:05","","0","100","<p>I want a Publisher similar to <code>Just</code> except it should emit multiple values, and then complete the stream.</p>
<p>Let's call it <code>JustSeveral</code>:</p>
<pre><code>func fibonacci(_ number: Int) -&gt; AnyPublisher&lt;Int, Never&gt; {
  Future { ... }.eraseToAnyPublisher()
}

JustSeveral([293, 18, 104])
  .flatMap { fibonacci($0) }
  .sink { print($0) }
</code></pre>
<p>Is there a way to combine operators with <code>Just</code> to get the same thing, or do I need to build this Publisher myself?</p>
<p>Note: Any solution should be able to handle an arbitrary number of elements in the array, not just 3.</p>
<hr />
<p>For example, if we had an <a href=""https://stackoverflow.com/questions/67523248/combine-uncollect-operator""><code>uncollect</code> operator</a>, this would be trivial:</p>
<pre><code>Just([293, 18, 104])
  .uncollect { $0 }
  .flatMap { fibonacci($0) }
  .sink { print($0) }
</code></pre>
","35690","","","","","2021-05-24 02:02:55","Just with several values?","<ios><swift><combine>","2","0","","","","CC BY-SA 4.0"
"67525273","1","67526661","","2021-05-13 19:42:02","","1","495","<p>I have this minimal example:</p>
<pre><code>import UIKit
import Combine

var values = [1,2,3,4,5]

var cancel = values.publisher
    .delay(for: 0.1, scheduler: DispatchQueue.global())
    .print()
    .flatMap() { i in
        [i].publisher.first()
    }
    .sink { completion in
        print(&quot;Received Completion: \(completion)&quot;)
    } receiveValue: { v in
        print(&quot;Received Value: \(v)&quot;)
    }
</code></pre>
<p>My expectation is that the source publisher emits the values from 1 to 5 into the stream. Each number gets transformed into (just for the sake of it) a new publisher that emits exactly the first value and then completes. Since this is done with each number, I would expect that all values reach the sink. This is not the case, however. Output looks like this:</p>
<pre><code>request unlimited
receive value: (1)
Received Value: 1
receive value: (2)
Received Value: 2
receive value: (4)
Received Value: 4
receive finished
Received Completion: finished
receive value: (3)
receive value: (5)
</code></pre>
<p>In fact, only 3 values reach the sink before the completion event arrives. Why is this? The <a href=""https://developer.apple.com/documentation/combine/publisher/flatmap(maxpublishers:_:)-3k7z5"" rel=""nofollow noreferrer"">documentation</a> states:</p>
<blockquote>
<p>successful completion of the new Publisher does not complete the overall stream.</p>
</blockquote>
<p>Even more curious, when you replace <code>.flatMap()</code> for <code>.flatMap(maxPublishers: .max(1))</code> and add a <code>.share()</code> to the original source publisher only the first value makes it to the sink.</p>
<p>Any pointers are much appreciated!</p>
","1138434","","","","","2021-05-13 22:09:38","Premature completion of publisher in flatMap in Combine","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"67540011","1","67540430","","2021-05-14 19:31:28","","0","453","<p>I'm playing an Audio in my app.</p>
<p>I can play the audio in the background mode in the simulator but when I test the app in a real device, the audio Stops as soon as the App goes in the background.</p>
<p>I have this in the background mode:</p>
<p><a href=""https://i.stack.imgur.com/ygQyF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ygQyF.png"" alt=""enter image description here"" /></a></p>
<p>and this is how I play the audio:</p>
<pre><code>import Foundation
import SwiftUI
import Combine
import AVKit
import AVFoundation
import WebKit



//BG Video Player
class PlayerUIView: UIView {
    
    // MARK: Class Property
    
    let playerLayer = AVPlayerLayer()
    
    // MARK: Init
    
    required init?(coder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    init(player: AVPlayer) {
        super.init(frame: .zero)
        self.playerSetup(player: player)
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
    // MARK: Life-Cycle
    
    override func layoutSubviews() {
        super.layoutSubviews()
           
        playerLayer.frame = bounds
            
    }
   
    
    // MARK: Class Methods
    
    private func playerSetup(player: AVPlayer) {
        playerLayer.player = player
        player.actionAtItemEnd = .none
        
        playerLayer.player = player
        playerLayer.videoGravity = .resizeAspectFill
        layer.addSublayer(playerLayer)
    
        
        self.setObserver()
        

    }
    
    func setObserver() {
        NotificationCenter.default.removeObserver(self)
        NotificationCenter.default.addObserver(self, selector: #selector(playerItemDidReachEnd(notification:)),
                                               name: .AVPlayerItemDidPlayToEndTime,
                                               object: playerLayer.player?.currentItem)
    }
    
    @objc func playerItemDidReachEnd(notification: Notification) {
        if let playerItem = notification.object as? AVPlayerItem {
            playerItem.seek(to: .zero, completionHandler: nil)
            self.playerLayer.player?.play()
        }
    }
}



struct PlayerView: UIViewRepresentable {
    
    @Binding var player: AVPlayer
    
    func makeUIView(context: Context) -&gt; PlayerUIView {
        return PlayerUIView(player: player)
           
    }
    
    
    func updateUIView(_ uiView: PlayerUIView, context: UIViewRepresentableContext&lt;PlayerView&gt;) {
        uiView.playerLayer.player = player
        
        //Add player observer.
        uiView.setObserver()
    
    }
    

    
   
}
</code></pre>
<p>And this is how I use it:</p>
<pre><code> struct audioPaleyerView: View {
    
    let audioToPlay = &quot;https://some-UR-to-the-Audio-file&quot;
   


   
    @State private var player = AVPlayer()
     
     var body: some View {


         NavigationView {
            
        

         
                       ZStack{
                        
                        
                        
                        PlayerView(player: $player)
                            .edgesIgnoringSafeArea(.all)

}

}         .onAppear {


            
            let originalUrl = &quot;https://some-UR-to-the-Audio-file&quot;
            let urlString = originalUrl.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)
             
            player = AVPlayer(url: URL(string: urlString!)!)
             
         
             player.play()

         
             
     }.onDisappear{
      
        
         
                 }

}

}
</code></pre>
<p>The strangest part is that it works fine in the background in the simulator but it fails on a real device!</p>
<p>Is there something that I'm missing?</p>
<p>EDIT:</p>
<p>I found this but I'm not sure how to use that in my code!</p>
<p>Also not sure if this is the correct way?</p>
<p><a href=""https://developer.apple.com/documentation/avfoundation/media_playback_and_selection/creating_a_basic_video_player_ios_and_tvos/playing_audio_from_a_video_asset_in_the_background"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/avfoundation/media_playback_and_selection/creating_a_basic_video_player_ios_and_tvos/playing_audio_from_a_video_asset_in_the_background</a></p>
","1169039","","1169039","","2021-05-14 20:02:20","2021-05-14 20:13:43","SwiftUI background mode works in simulator but not on a real device?","<swift><xcode><swiftui>","1","0","","","","CC BY-SA 4.0"
"67556849","1","67558067","","2021-05-16 12:46:39","","-1","106","<p>When using AppStorage for a global variable, navigationlinks are exited with simple swipe/tap gestures if AppStorage is used 2 times.</p>
<p>When I press one of two buttons to go into one of the two navigationlinks, once inside the NavigationLink, any single tap/swipe immediately exits the NavigationLink.</p>
<p>All I am trying to do is make sure that I can access the global variable &quot;quarters&quot; everywhere in my app - the main screen, the first NavigationLink that gives me quarters, and the second NavigationLink where I use my quarters.</p>
<p>This issue only began when I started using the below two lines of code for the global variable &quot;quarters&quot;.</p>
<p>I am also open to any other ways to have a global variable &quot;quarters&quot;. This one was suggested in a different question I asked and seems to work really well and easily and simply ... except for this issue.</p>
<p>The code causing the behavior:</p>
<pre><code>@AppStorage(&quot;quarters&quot;)
var quarters: Int = .zero
</code></pre>
<p>Minimal reproducible code. In the below code, a single button press exits either NavigationLink, but swipes do not exit either NavigationLink.</p>
<pre><code>import SwiftUI

struct ContentView: View {
    @AppStorage(&quot;quarters&quot;)
    var quarters: Int = .zero
    var body: some View {
        NavigationView {
            Image(&quot;Clouds&quot;)
                .overlay(
                VStack(spacing: 30) {
                    Text(&quot;\(quarters)&quot;).bold()
                        .foregroundColor(.white)
                    NavigationLink(destination: Menu1(choice: &quot;Menu1&quot;)) {
                            Image(&quot;Menu&quot;)
                    }
                    NavigationLink(destination: Menu2(choice: &quot;Menu2&quot;)) {
                            Image(&quot;MenuGrey&quot;)
                    }
                })
        }
    }
    }

struct Menu1: View {
    @AppStorage(&quot;quarters&quot;)
    var quarters: Int = .zero
    var choice: String
    var body: some View {
        Text(&quot;\(quarters)&quot;)
        Button(action: {
            quarters += 1
        }) {
            Image(&quot;Menu&quot;)
                .scaleEffect(0.4)
                .frame(width: 305, height: 45)
        }
    }
}

struct Menu2: View {
    @AppStorage(&quot;quarters&quot;)
    var quarters: Int = .zero
    var choice: String
    var body: some View {
        Text(&quot;\(quarters)&quot;)
        Button(action: {
            quarters += 1
        }) {
            Image(&quot;MenuGrey&quot;)
                .scaleEffect(0.4)
                .frame(width: 305, height: 45)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>
<p>The main code I want to use it in. In the below code, a single swipe in any direction will exit the NavigationLink. Some button presses cause it to exit, while others don't.</p>
<p>The below code also contains part of <a href=""https://github.com/caiobzen/2048-swiftui"" rel=""nofollow noreferrer"">this game I found online</a> - the game has other .swift files as part of the game including swipe gestures, but nothing in those .swift files references any part of the two lines of code in question.</p>
<pre><code>import SwiftUI
import UIKit
import AVKit
import AVFoundation
import Foundation

struct ContentView: View {
    static let engine = GameEngine()
    static let storage = LocalStorage()
    static let stateTracker = GameStateTracker(initialState: (storage.board ?? engine.blankBoard, storage.score))
    @ObservedObject var viewModel =  GameViewModel(engine, storage: storage, stateTracker: stateTracker)
    @AppStorage(&quot;quarters&quot;)
    var quarters: Int = .zero
    var body: some View {
        NavigationView {
            Image(&quot;Clouds&quot;)
                .overlay(
                VStack(spacing: 30) {
                    HStack {
                        Image(&quot;quarters&quot;)
                            .frame(width: 15, height: 15)
                        Text(&quot;\(quarters)&quot;).bold()
                            .frame(width: 65, height: 15)
                            .foregroundColor(Color.white)
                    }
                    NavigationLink(destination: ResultView2(choice: &quot;MenuGrey&quot;)) {
                            Image(&quot;MenuGrey&quot;)
                    }
                    NavigationLink(destination: MyContentView(viewModel: viewModel)) {
                        Image(&quot;Menu&quot;)
                    }
                    //Gain
                    Button(action: {
                        quarters += 1
                    }) {
                        Image(&quot;QuarterMachine&quot;)
                            .scaleEffect(0.4)
                            .frame(width: 305, height: 45)
                    }
                })
        }
    }

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
}

struct MyContentView: View {
    @ObservedObject var viewModel: GameViewModel
    @State var showMenu = false
    var body: some View {
        VStack(alignment: .center, spacing: 16) {
            Header(score: viewModel.state.score, bestScore: viewModel.bestScore, menuAction: {
                self.showMenu.toggle()
            }, undoAction: {
                self.viewModel.undo()
            }, undoEnabled: self.viewModel.isUndoable)
            GoalText()
            Board(board: viewModel.state.board, addedTile: viewModel.addedTile)
            Moves(viewModel.numberOfMoves)
        }
        .frame(minWidth: .zero,
               maxWidth: .infinity,
               minHeight: .zero,
               maxHeight: .infinity,
               alignment: .center)
            .background(Color.gameBackground)
            .background(Menu())
            .background(GameOver())
            .edgesIgnoringSafeArea(.all)
    }
}
extension MyContentView {
private func Menu() -&gt; some View {
    EmptyView().sheet(isPresented: $showMenu) {
        MenuView(newGameAction: {
            self.viewModel.reset()
            self.showMenu.toggle()
        }, resetScoreAction: {
            self.viewModel.eraseBestScore()
            self.showMenu.toggle()
        })
    }
}

private func GameOver() -&gt; some View {
    EmptyView().sheet(isPresented: $viewModel.isGameOver) {
        GameOverView(score: self.viewModel.state.score, moves: self.viewModel.numberOfMoves) {
            self.viewModel.reset()
        }
    }
}
}

struct ResultView2: View {
    @AppStorage(&quot;quarters&quot;)
    var quarters: Int = .zero
    var choice: String
    var body: some View {
                //Gain
                Button(action: {
                    quarters += 1
                }) {
                    Image(&quot;GainQuarters&quot;)
                        .scaleEffect(0.4)
                        .frame(width: 305, height: 45)
                }
                //quarters counter
                HStack {
                    Image(&quot;quarters&quot;)
                        .frame(width: 15, height: 15)
                    Text(String(quarters)).bold()
                        .frame(width: 65, height: 15)
                        .foregroundColor(Color.white)
                }
            }
        }
</code></pre>
<p>Edit: Below is the GameViewModel code.</p>
<pre><code>import SwiftUI
import Combine
import UIKit

class GameViewModel: ObservableObject {
    
    @AppStorage(&quot;quarters&quot;)
      var quarters: Int = .zero

      @Published var result: Int = .zero

      init() {
        result = quarters // Fetch saved value at startup 
//&quot;'self' used in property access 'quarters' before all stored properties are initialized&quot;
      }
//&quot;Return from initializer without initializing all stored properties&quot;

      // User this method on you Menu view to share the same result.
      func increaseQuarters() {
        result += 1
        quarters = result // Save the new value when result increase
      }
    
//Three below &quot;private(set) var&quot; have a grey notice on the side that say &quot;self.[word] not initialized&quot;
    private(set) var engine: Engine
    private(set) var storage: Storage
    private(set) var stateTracker: StateTracker
  
    @Published var isGameOver = false
    private(set) var addedTile: (Int, Int)? = nil {
        didSet { UIImpactFeedbackGenerator().impactOccurred() }
    }
    private(set) var bestScore: Int = .zero {
        didSet { storage.save(bestScore: bestScore) }
    }
    
    var numberOfMoves: Int {
        return stateTracker.statesCount - 1
    }
    var isUndoable: Bool {
        return stateTracker.isUndoable
    }
//Line below has error &quot;'self.state.board' not initialized&quot; and also for self.state.score
    var state: GameState {
        didSet {
            bestScore = max(bestScore, state.score)
            storage.save(score: state.score)
            isGameOver = engine.isGameOver(state.board)
            storage.save(board: state.board)
        }
    }
    
    init(_ engine: Engine, storage: Storage, stateTracker: StateTracker) {
        self.engine = engine
        self.storage = storage
        self.stateTracker = stateTracker
        self.state = stateTracker.last
        self.bestScore = max(storage.bestScore, storage.score)
    }
    
    func start() {
        if state.board.isMatrixEmpty { reset() }
    }
    
    func addNumber() {
        let result = engine.addNumber(state.board)
        state = stateTracker.updateCurrent(with: result.newBoard)
        addedTile = result.addedTile
    }
    
    func push(_ direction: Direction) {
        let result = engine.push(state.board, to: direction)
        let boardHasChanged = !state.board.isEqual(result.newBoard)
        state = stateTracker.next(with: (result.newBoard, state.score + result.scoredPoints))
        if boardHasChanged {
            addNumber()
        }
    }
    
    func undo() {
        state = stateTracker.undo()
    }
    
    func reset() {
        state = stateTracker.reset(with: (engine.blankBoard, .zero))
        addNumber()
    }
    
    func eraseBestScore() {
        bestScore = .zero
    }
    
}
</code></pre>
","15878457","","15878457","","2021-05-16 17:46:50","2021-05-16 17:46:50","AppStorage 2 times makes navigationlinks exit upon single taps/swipes","<ios><swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"67614590","1","67693133","","2021-05-20 05:42:39","","0","117","<p>Anyone who understands please help me, I want to retrieve data from Firestore and it wants to be read in realtime whenever there is a change from the database, so I use addSnapshotListener to read it, it works every time there is a change from Firestore, but it's still in object form NewsResponse. Because the final result I want to change to a NewsDomainModel form, then I continue the results from NewsResponse to _mapper.transformerResponseToDomain to be converted into NewsDomainModel, but every latest data generated using addSnapshotListener is not updated to the _mapper.transformerResponseToDomain, _mapper only reads 1 time the data sent only.</p>
<p>GetNewsRepository</p>
<pre><code>import SwiftUI
import Core
import Combine

public class GetNewsRepository&lt;
  NewsLocaleDataSource: LocaleDataSource,
  RemoteDataSource: DataSource,
  Transformer: Mapper&gt;: ObservableObject, Repository
where
  NewsLocaleDataSource.Request == String,
  NewsLocaleDataSource.Response == NewsModuleEntity,
  RemoteDataSource.Request == String,
  RemoteDataSource.Response == [NewsResponse],
  Transformer.Request == String,
  Transformer.Response == [NewsResponse],
  Transformer.Entity == [NewsModuleEntity],
  Transformer.Domain == [NewsDomainModel] {
  
  public typealias Request = String
  @Published public var Response: [NewsDomainModel] = [NewsDomainModel]()
  
  private let _localeDataSource: NewsLocaleDataSource
  @Published public var _remoteDataSource: RemoteDataSource
  @Published public var _mapper: Transformer
  
  public init(
    localeDataSource: NewsLocaleDataSource,
    remoteDataSource: RemoteDataSource,
    mapper: Transformer) {
    _localeDataSource = localeDataSource
    _remoteDataSource = remoteDataSource
    _mapper = mapper
  }
  
  public func execute(request: String?) -&gt; AnyPublisher&lt;[NewsDomainModel], Error&gt; {
    return self._remoteDataSource.execute(request: request)
      .map { self._mapper.transformerResponseToDomain(response: $0) }
      .eraseToAnyPublisher()
  }
}
</code></pre>
<p>GetNewsRemoteDataSource</p>
<pre><code>import Core
import Combine
import FirebaseFirestore
import FirebaseFirestoreSwift
import Foundation

public class GetNewsRemoteDataSource: ObservableObject, DataSource {
  
  public typealias Request = String
  @Published public var Response: [NewsResponse] = [NewsResponse]()
  private let _endPoint: String
  
  public init(endPoint: String) {
    _endPoint = endPoint
  }
  
  public func execute(request: String?) -&gt; AnyPublisher&lt;[NewsResponse], Error&gt; {
    return Future&lt;[NewsResponse], Error&gt; { completion in
      let ref = Firestore.firestore()
      
      ref.collection(&quot;news&quot;).addSnapshotListener { (querySnapshot, error) in
        guard let documents = querySnapshot?.documents else {
          print(&quot;Document not found&quot;)
          return
        }
        
        let dataJson = documents.compactMap { queryDocumentSnapshot in
          try? queryDocumentSnapshot.data(as: NewsResponse.self)
        } // THIS DATA WILL BE AUTOMATIC UPDATE IF DATA FROM FIRESTORE UPDATED
        
        completion(.success(dataJson))
      }
    }.eraseToAnyPublisher()
  }
}
</code></pre>
<p>NewsTransformer</p>
<pre><code>import Core
import Combine

public class NewsTransformer&lt;NewsMapper: Mapper&gt;: ObservableObject, Mapper
where
  NewsMapper.Request == String,
  NewsMapper.Response == NewsResponse,
  NewsMapper.Entity == NewsModuleEntity,
  NewsMapper.Domain == NewsDomainModel {
  
  @Published public var Request = String()
  @Published public var Response = [NewsResponse]()
  @Published public var Entity = [NewsModuleEntity]()
  @Published public var Domain = [NewsDomainModel]()
  
  private let _newsMapper: NewsMapper
  
  public init(newsMapper: NewsMapper) {
    _newsMapper = newsMapper
  }
  
  public func transformerResponseToEntity(request: String?, response: [NewsResponse]) -&gt; [NewsModuleEntity] {
    return response.map { result in
      _newsMapper.transformerResponseToEntity(request: request, response: result)
    }
  }
  
  public func transformerResponseToDomain(response: [NewsResponse]) -&gt; [NewsDomainModel] {
    print(&quot;\(response) DATA RESPONSE&quot;) // NOT UPDATING
    return response.map { results in
      _newsMapper.transformerResponseToDomain(response: results)
    }
  }
  
  public func transformerEntityToDomain(entity: [NewsModuleEntity]) -&gt; [NewsDomainModel] {
    return entity.map { result in
      _newsMapper.transformerEntityToDomain(entity: result)
    }
  }
  
  public func transformerDomainToEntities(domain: [NewsDomainModel]) -&gt; [NewsModuleEntity] {
    return domain.map { result in
      _newsMapper.transformerDomainToEntities(domain: result)
    }
  }
}
</code></pre>
<p>The sequence of images above is GetNewsRepository (Repository), GetNewsRemoteDataSource (Get Data From Firebase), NewsTransformer (Transform from NewsResponse to NewsDomainModel)</p>
<p>Sorry if the title I ask is wrong.</p>
","9105991","","9105991","","2021-05-20 05:50:40","2021-05-25 17:48:19","Published Object Not Working - Combine Swift","<swift><google-cloud-firestore><combine>","1","2","","","","CC BY-SA 4.0"
"67616747","1","67626425","","2021-05-20 08:30:28","","-3","191","<p>Take this case of a type constrained class <code>Parameter</code>, wrapping a value of given type.</p>
<p>Parameter conforms to the <code>AnyParameter</code> so it can be passed anywhere in the app without knowing the type. Parameters can be displayed in value cells <code>AnyValueCell</code></p>
<ul>
<li>How would you do to observe the change without having to know the underlying value type? It would be nice to avoid the code repetition in the value cell <code>updateObserver</code> function</li>
<li>Could <code>AnyPublisher</code> can be used here and how?</li>
</ul>
<pre class=""lang-swift prettyprint-override""><code>import UIKit
import Combine

print(&quot;Hello Playground&quot;)

protocol AnyParameter {
    var anyValue: Any { get }
    func set(value: Any)
}

protocol ParameterProtocol: AnyParameter {
    associatedtype ValueType
    
    var value: ValueType { get }
    func set(value: ValueType)

}

public class Parameter&lt;T&gt;: ParameterProtocol {
    
    typealias ValueType = T
    
    @Published var value: T
    
    var anyValue: Any { value }
    
    init(value: T) {
        self.value = value
    }
    
    func set(value: Any) {
        guard let value = value as? T else { return }
        set(value: value)
    }
    
    func set(value: T) {
        self.value = value
    }
}


public class AnyValueCell {
    
    var parameter: AnyParameter {
        didSet {
            updateObserver()
        }
    }
    
    var observer: AnyCancellable?
    
    init(parameter: AnyParameter) {
        self.parameter = parameter
        updateObserver()
    }
    
    func updateObserver() {
        observer?.cancel()
        
        // This is the point of the question - How to make this generic?
        // ----&gt;
        if let p = parameter as? Parameter&lt;Int&gt; {
            observer = p.$value.sink() { value in
                print(&quot;Update Cell -&gt; \(value)&quot;)
            }
            return
        }

        if let p = parameter as? Parameter&lt;Double&gt; {
            observer = p.$value.sink() { value in
                print(&quot;Update Cell -&gt; \(value)&quot;)
            }
            return
        }

        if let p = parameter as? Parameter&lt;Bool&gt; {
            observer = p.$value.sink() { value in
                print(&quot;Update Cell -&gt; \(value)&quot;)
            }
            return
        }
        // &lt;----

        print(&quot;Wrong param type&quot;)
    }
}

let intParam = Parameter&lt;Int&gt;(value: 42)
let doubleParam = Parameter&lt;Double&gt;(value: 3.14)
let boolParam = Parameter&lt;Bool&gt;(value: false)

var params: [AnyParameter] = [intParam, doubleParam, boolParam]

print (&quot;--&gt; Init Cells&quot;)
let cells: [AnyValueCell] = params.map { AnyValueCell(parameter: $0) }

print (&quot;--&gt; Change values&quot;)
intParam.set(value: 21)
doubleParam.set(value: 1.618)
boolParam.set(value: true)
</code></pre>
<p>Result, as expected:</p>
<pre><code>Hello Playground
--&gt; Init Cells
Update Cell -&gt; 42
Update Cell -&gt; 3.14
Update Cell -&gt; false
--&gt; Change values
Update Cell -&gt; 21
Update Cell -&gt; 1.618
Update Cell -&gt; true
</code></pre>
","441197","","","","","2021-05-20 18:51:43","Observe generic values with Combine","<swift><combine><type-constraints>","1","4","","","","CC BY-SA 4.0"
"67634928","1","67635273","","2021-05-21 10:15:41","","0","49","<p>I'm trying to load an array of <code>SCEvent</code>s into an array of <code>EventModel</code>s using Combine. The variable <code>imagePath</code> is optional, which I'd like to translate it to an empty <code>Data()</code> in its corresponding <code>EventModel.imageData</code> variable.</p>
<pre class=""lang-swift prettyprint-override""><code>struct SCEvent {
    let name: String
    let imagePath: String?
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>struct EventModel {
    let name: String
    let imageData: Data
}

</code></pre>
<p>The following code seems to work, but I can't help but wonder if it is the most optimal way of doing it:</p>
<pre class=""lang-swift prettyprint-override""><code>func loadEvents(_ events: [SCEvent]) -&gt; AnyPublisher&lt;[EventModel], Error&gt; {
    events.publisher
        .flatMap(loadEvent(_:))
        .collect()
        .eraseToAnyPublisher()
}

func loadEvent(_ event: SCEvent) -&gt; AnyPublisher&lt;EventModel, Error&gt; {
    if let imagePath = event.imagePath {
        return DataDownloader.downloadData(fromPath: imagePath)
                   .map { EventModel(name: event.name, imageData: $0) }
                   .eraseToAnyPublisher()
    }

    return Just(EventModel(name: event.name, imageData: Data())
               .eraseToAnyPublisher()
}
</code></pre>
<p>Ideally, I'd like to use a single publisher in the <code>loadEvent</code> function. Maybe something like this (doesn't work, but serves as an example of what I expect):</p>
<pre class=""lang-swift prettyprint-override""><code>func loadEvent(_ event: SCEvent) -&gt; AnyPublisher&lt;[EventModel], Error&gt; {
    event.imagePath
        .flatMap(DataDownloader.downloadData(_:))
        .replaceNil(with: Data())
        .map {
            EventModel(name: event.name, imageData: $0)
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>Which doesn't work because <code>.replaceNil</code> should be used after <code>event.imagePath</code> to replace a <code>nil</code> string. Another possible approach would be:</p>
<pre class=""lang-swift prettyprint-override""><code>func loadEvent(_ event: SCEvent) -&gt; AnyPublisher&lt;[EventModel], Error&gt; {
    event.imagePath
        .replaceNil(with: &quot;&quot;)
        .flatMap(
            DataDownloader.downloadData(_:)
                .replaceError(with: Data())
        )
        .map {
            EventModel(name: event.name, imageData: $0)
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>But it seems forced. Is it even possible with Combine? Is my initial approach the only valid solution?</p>
","2148023","","","","","2021-05-21 10:38:53","Combine using optional struct variable","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"67727584","1","67728701","","2021-05-27 17:58:51","","0","202","<p>Please help me, I would like to test the <code>viewModel</code>, when I'm run unit test and then an error is raised <code>Asynchronous wait failed: Exceeded timeout of 1 second</code></p>
<pre><code>var usersSubject = PassthroughSubject&lt;[User],Error&gt;()

    func fetchUsers(){
        let url = URL(string: endpoint.urlString)!
        apiManager.fetchItems(url: url) { (result: Result&lt;[User],Error&gt;)  in
            switch result {
            case .success(let users):
                self.usersSubject.send(users)
            case .failure(let error):
                self.usersSubject.send(completion: .failure(error))
            }
        }
    }
</code></pre>
<pre><code>    func testsuccess(){
        viewModel.usersSubject.sink { completion in
            self.exectation.fulfill()
        } receiveValue: { users in
            XCTAssertEqual(1, users.count)
            XCTAssertEqual(&quot;Hello World&quot;, users[0].name)
            self.exectation.fulfill()
        }
        
        viewModel.fetchUsers()
        XCTAssertEqual(1, apiManager.numberOfCalled)
        
        wait(for: [exectation], timeout: 1.0)
    }

    class StubApiManager: APIManager {
        var numberOfCalled = 0
        override func fetchItems&lt;T&gt;(url: URL, completion: @escaping (Result&lt;[T], Error&gt;) -&gt; Void) where T : Decodable {
            let users = [
            User(id: 1, name: &quot;Hello World&quot;)
            ]
            numberOfCalled += 1
            completion(.success(users as! [T]))
        }
    }
</code></pre>
","11966001","","11966001","","2021-05-29 02:10:23","2021-05-29 02:10:23","On unit test, How does assert the PassthroughSubject value without an external library?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"67756026","1","67770912","","2021-05-29 21:59:07","","0","305","<p>Based on some code examples from stackoverflow I created a class for location service. The location service is started immediately when the app starts, indicated by the navigation symbol in the upper system bar. My app needs the location service in specific views only, so I would like to activate/deactivate the location service on specific events. This could reduce energy consumption and improve customers confidence, that location service is used only when needed.</p>
<p>First I defined a class LocationViewModel:</p>
<pre><code>import SwiftUI
import Foundation
import Combine
import CoreLocation
import CoreMotion

class LocationViewModel: NSObject, ObservableObject
{

    @Published var userLatitude: Double = 0
    @Published var userLongitude: Double = 0
        
    private let locationManager = CLLocationManager()

    override init()
    {
        super.init()
        
        self.locationManager.delegate = self
        
        self.locationManager.startUpdatingLocation()
    }
    
    // I tried this to access the startUpdatingLocation() method, but it did not work
    func startUpdatingLocation()
    {
        self.locationManager.startUpdatingLocation()
    }
        
}

extension LocationViewModel: CLLocationManagerDelegate
{
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation])
    {
        guard let location = locations.last else { return }
        
        userLatitude = location.coordinate.latitude
        userLongitude = location.coordinate.longitude
    }
}

</code></pre>
<p>Next, in a specific LocationView, which is part of a NavigationView, I create a instance of LocationViewModel class:</p>
<pre><code>import SwiftUI

struct LocationView : View
{
    // some say, that a @StateObject is preferred over @ObservedObject, see:
    // https://stackoverflow.com/questions/59620573/handle-swiftui-and-corelocation-with-mvvm-pattern
    @ObservedObject var locationViewModel = LocationViewModel()
    
    var body: some View
    {
        VStack
        {
            Text(&quot;Latitude: \(locationViewModel.userLatitude)&quot;)
            Text(&quot;Longitude: \(locationViewModel.userLongitude)&quot;)
        }
        .navigationTitle(&quot;Location&quot;)
        .navigationBarTitleDisplayMode(.inline)
    }
}

</code></pre>
<p>Questions:</p>
<ol>
<li><p>Why is the location service started when the app starts? The override init() method calls the startUpdatingLocation(), but the LocationView (defined as part of a NavigationView) is not shown on apps startup. Is this an effect of the NavigationView?</p>
</li>
<li><p>How can I access the self.locationManager's startUpdatingLocation() method from outside the instance? Is there any way to do that directly or is it necessary to create a specific wrapper method (as I already tried without success)? The LocationViewModel instance does not offer any methods (XCode says there are no completions).</p>
</li>
<li><p>How can I start/stop location updates (navigation symbol to disappear) when the specific view becomes visible/invisble? All code examples I found implemented permanent location updates.</p>
</li>
</ol>
","3183157","","","","","2021-05-31 09:12:00","Using startUpdatingLocation() and stopUpdatingLocation() to activate/deactivate location updates in specific Views","<ios><swift><swiftui><core-location><cllocationmanager>","1","4","","","","CC BY-SA 4.0"
"67775625","1","67781680","","2021-05-31 14:27:15","","5","1929","<p>I am making a post request, which has an empty response</p>
<pre><code>AF.request(URL(string: &quot;some url&quot;)!, method: .post, parameters: parameters, encoding: URLEncoding.default, headers: nil)
    .validate()
    .publishDecodable(type: T.self)
    .value()
    .eraseToAnyPublisher()
</code></pre>
<p>where T is</p>
<p><code>struct EmptyResponse: Codable {}</code></p>
<p>and I am having this error &quot;Response could not be serialized, input data was nil or zero length.&quot;
How do I handle a post request with an empty response using Alamofire and Combine?</p>
","","user13691063","","","","2022-01-31 22:54:40","How to handle empty response using Alamofire and Combine?","<ios><swift><alamofire><combine>","3","0","","","","CC BY-SA 4.0"
"67800730","1","67835574","","2021-06-02 07:30:52","","0","262","<p>I need to build a <code>Combine</code> pipeline using <code>Swift</code> where 2 publishers are involved, pubA (A PassThroughSubject) generates values frequently and once pubB (another PassThroughSubject) generates a value, I need to use the latest value from pubA to trigger an event. The only strict condition is - the trigger should happen only on a new value of pubB (the driving publisher) and the pipeline should take most newest published value from pubA (should skip old values). Let me try to demonstrate with example:</p>
<pre><code>pubA =&gt; 
1               
          2               
                 3               
                                   4
                                             5 
pubB =&gt;                  true                     false       true
Expected Output:         (true, 3)                (false, 5)  (true, 5)
</code></pre>
<p>This seemed to be good for <code>Zip</code> initially but zip pops old value not newest, i.e the output becomes (true, 1), (false, 2). And using <code>combineLatest</code> triggers event whenever there is a value from any of the publishers &amp; breaks the dependency to trigger only on pubB’s new value, so the output becomes (true, 3), (true, 4), (true, 5), (false, 5)</p>
<p>Appreciate any pointers.</p>
<p>Edit Notes:</p>
<ol>
<li>The expectation is to get pair of values.</li>
<li>pubB is driving publisher, for each value from pubB there will be an event by using newest value from pubA.</li>
<li>If pubA hasn't produced any value, it will wait until pubA produces a value... as we need a pair.</li>
<li>If pubB produces more values than pubA, the newest pubA value will be paired with newest pubB value.</li>
</ol>
","693081","","693081","","2021-06-03 04:48:28","2021-06-04 10:21:01","How to zip two publishers but to get newest values instead of default oldest behavior of zip?","<ios><swift><reactive-programming><combine><publisher>","1","7","","","","CC BY-SA 4.0"
"67813464","1","67856782","","2021-06-02 22:54:01","","1","486","<p>I have a situation where my code needs to make one network call to fetch a bunch of items, but while waiting for those to come down, another network call might fetch an update to those items. I'd love to be able to enqueue those secondary results until the first one has finished. Is there a way to accomplish that with Combine?</p>
<p>Importantly, I am not able to wait before making the second request. It’s actually a connection to a websocket that gets made at the same time as the first request, and the updates come over the websocket outside of my control.</p>
<h2>Update</h2>
<p>After examining Matt’s thorough <a href=""https://www.apeth.com/UnderstandingCombine/operators/operatorsJoiners/operatorsappend.html"" rel=""nofollow noreferrer"">book</a> on Combine, I settled on <code>.prepend()</code>. But as Matt warned me in the comments, <code>.prepend()</code> doesn’t even subscribe to the other publisher until after the first one completes. This means I miss any signals sent prior to that. What I need is a <code>Subject</code> that enqueues values, but perhaps that’s not so hard to make. Anyway, this is where I got:</p>
<p>Initially I was going to use <code>.append()</code>, but I realized with <code>.prepend()</code> I could avoid keeping a reference to one of the publishers. So here’s a simplified version of what I’ve got. There might be syntax errors in this, as I’ve whittled it down from my (employer’s) code.</p>
<p>There’s the <code>ItemFeed</code>, which handles fetching a list of items and simultaneously handling item update events. The latter can arrive before the initial list of items, and thus must be sequenced via Combine to arrive after it. I attempt to do this by prepending the initial items source to the update <code>PassthroughSubject</code>.</p>
<p>Below that is an <code>XCTestCase</code> that simulates a lengthy initial item load, and adds an update before that load can complete. It attempts to subscribe to changes to the list of items, and tries to test that the first update is the initial 63 items, and the subsequent update is for 64 items (in this case, “update” results in adding an item).</p>
<p>Unfortunately, while the initial list is published, the update never arrives. I also tried removing the <code>.output(at:)</code> operators, but the two sinks are only called once.</p>
<p>After the test case sets up the delayed “fetch,” and subscribes to changes in <code>feed.items</code>, it calls <code>feed.handleItemUpatedEvent</code>. This calls <code>ItemFeed.updateItems.send(_:)</code>, but unfortunately that is lost to oblivion.</p>
<pre class=""lang-swift prettyprint-override""><code>class
ItemFeed
{
    typealias   InitialItemsSource      =   Deferred&lt;Future&lt;[[String : Any]], Error&gt;&gt;
    
                let updateItems         =   PassthroughSubject&lt;[Item], Error&gt;()
                var funnel              :   AnyCancellable?
    
    @Published  var items               =   [Item]()
    
    
    
    init(initialItemSource inSource: InitialItemsSource)
    {
        //  Passthrough subject each time items are updated…
        
        var pub = self.updateItems.eraseToAnyPublisher()
        
        //  Prepend the initial items we need to fetch…
        
        let initialItems = source.tryMap { try $0.map { try Item(object: $0) } }
        pub = pub.prepend(initialItems).eraseToAnyPublisher()
        
        //  Sink on the funnel to add or update to self.items…
        
        self.funnel =
            pub.sink { inCompletion in
                //  Handle errors
            }
            receiveValue: {
                self.update(items: inItems)
            }
    }
    
    func handleItemUpdatedEvent(_ inItem: Item) {
        self.updateItems.send([inItem])
    }
    
    func update(items inItems: [Item]) {
        //  Update or add inItems to self.items
    }
}

class
ItemFeedTests : XCTestCase
{
    func
    testShouldUpdateItems()
        throws
    {
        //  Set up a mock source of items…
        
        let source = fetchItems(named: &quot;items&quot;, delay: 3.0)      //  63 items
        
        let expectation = XCTestExpectation(description: &quot;testShouldUpdateItems&quot;)
        expectation.expectedFulfillmentCount = 2
        
        let feed = ItemFeed(initialItemSource: source)
        
        let sub1 = feed.$items
                    .output(at: 0)
                    .receive(on: DispatchQueue.main)
                    .sink { inItems in
                        expectation.fulfill()
                        
                        debugLog(&quot;Got first items: \(inItems.count)&quot;)
                        XCTAssertEqual(inItems.count, 63)
                    }
        
        let sub2 = feed.$items
                    .output(at: 1)
                    .receive(on: DispatchQueue.main)
                    .sink { inItems in
                        expectation.fulfill()

                        debugLog(&quot;Got second items: \(inItems.count)&quot;)
                        XCTAssertEqual(inItems.count, 64)
                    }
        
        //  Send an update right away…
        
        let item = try loadItem(named: &quot;Item3&quot;)
        feed.handleItemUpdatedEvent(item)
        
        XCTAssertEqual(feed.items.count, 0)         //  Should be no items yet
        
        //  Wait for stuff to complete…
        
        wait(for: [expectation], timeout: 10.0)
        
        sub1.cancel()           //  Not necessary, but silence the compiler warning
        sub2.cancel()
    }
}   
</code></pre>
","251914","","251914","","2021-06-03 07:50:50","2021-07-30 19:34:07","Swift Combine: enqueue updates to one publisher behind another publisher","<swift><combine>","2","12","1","","","CC BY-SA 4.0"
"67821097","1","67857053","","2021-06-03 11:59:54","","1","212","<p>I am trying to use Combine to route SwiftUI views, and it sort of works, but has some unwanted behaviour that I hope someone can help me with. I made an <a href=""https://github.com/imyrvold/RouteTest/tree/main/RouteTest"" rel=""nofollow noreferrer"">example project</a> which only contains two files, <code>ViewRouter.swift</code> and <code>ViewController.swift</code> that just contains a <code>@IBSegueAction</code> to return a <code>UIHostingController</code>:</p>
<p>The class <code>ViewRouter</code> is a <code>ViewModel</code> for the SwiftUI Views that contains a <code>@ViewBuilder</code> property. When the <code>SwiftUI</code> views calls the <code>didFinish()</code> function, the <code>step</code> property is set to the next <code>View</code>.</p>
<pre class=""lang-swift prettyprint-override""><code>class ViewRouter: ObservableObject {
    enum Step { case test1, test2, test3, test4 }
    @Published var step: Step = .test1
    @ViewBuilder var nextStepView: some View {
        switch step {
        case .test1:
            Test1(router: self)
        case .test2:
            Test2(router: self)
        case .test3:
            Test3(router: self)
        case .test4:
            Test4(router: self)
        }
    }
    
    func didFinish() {
        switch step {
        case .test1:
            step = .test2
        case .test2:
            step = .test3
        case .test3:
            step = .test4
        case .test4:
            break
        }
    }
}
</code></pre>
<p>This works perfect for <code>Test1</code>, when tapping the <code>Next</code> link, the <code>Test1</code> view is animated to the left, to reveal <code>Test2</code>. When tapping <code>Next</code> in <code>Test2</code> however, the <code>Test2</code> is animated to the left to reveal <code>Test3</code>, but then immediately it animates back to the right to reveal the same <code>Test3</code> view. Exactly the same happens when tapping <code>Next</code> in <code>Test3</code>.</p>
<p>And tapping the back button always ends up in <code>Test1</code> view.</p>
<p>All four views are the same, apart from the text in <code>Text</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>struct Test1: View {
    @ObservedObject var router: ViewRouter
    @State var nextView = false

    var body: some View {
        VStack {
            NavigationLink(destination: router.nextStepView, isActive: $nextView) {
                EmptyView()
            }

            Text(&quot;Test1&quot;)
            
            Button(action: {
                nextView = true
                router.didFinish()
            }, label: {
                Text(&quot;Next&quot;)
            })
        }
    }
}
</code></pre>
","6394244","","","","","2021-06-06 08:16:05","Use Combine to route SwiftUI Views","<swift><swiftui><combine>","1","2","1","","","CC BY-SA 4.0"
"67840597","1","68041060","","2021-06-04 16:10:18","","0","177","<p>I have created <a href=""https://github.com/afarber/ios-questions/tree/master/Tops1"" rel=""nofollow noreferrer"">a simple Core Data project at Github</a> to demonstrate my problem:</p>
<p><a href=""https://i.stack.imgur.com/450Vb.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/450Vb.jpg"" alt=""Xcode screenshot"" /></a></p>
<p>My test app downloads a JSON list of objects, stores it in Core Data and displays in a SwiftUI List via <code>@FetchRequest</code>.</p>
<p>Because the list of objects has 1000+ elements in my <em>real</em> app, I would like to save the entities into the Core Data on a background thread and not on the main thread.</p>
<p>Preferably I would like to use the same default background thread, which is already used by the <a href=""https://developer.apple.com/documentation/foundation/urlsession/datataskpublisher"" rel=""nofollow noreferrer"">URLSession.shared.dataTaskPublisher</a>.</p>
<p>So in the standard <a href=""https://github.com/afarber/ios-questions/blob/master/Tops1/Tops1/Persistence.swift"" rel=""nofollow noreferrer"">Persistence.swift</a> generated by Xcode I have added only 2 lines:</p>
<pre><code>container.viewContext.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
container.viewContext.automaticallyMergesChangesFromParent = true
</code></pre>
<p>and in my <a href=""https://github.com/afarber/ios-questions/blob/master/Tops1/Tops1/Managers/DownloadManager.swift"" rel=""nofollow noreferrer"">DownloadManager.swift</a> singleton I call:</p>
<pre><code>static let instance = DownloadManager()

var cancellables = Set&lt;AnyCancellable&gt;()

// How to run this line on the background thread of URLSession.shared.dataTaskPublisher?
let backgroundContext = PersistenceController.shared.container.newBackgroundContext()

private init() {
    getTops()
}

func getTops() {
    guard let url = URL(string: &quot;https://slova.de/ws/top&quot;) else { return }
    
    URLSession.shared.dataTaskPublisher(for: url)
        .tryMap(handleOutput)
        .decode(type: TopResponse.self, decoder: JSONDecoder())
        .sink { completion in
            print(completion)
        } receiveValue: { [weak self] returnedTops in
            for top in returnedTops.data {
                // the next line fails with EXC_BAD_INSTRUCTION
                let topEntity = TopEntity(context: self!.backgroundContext)
                topEntity.uid = Int32(top.id)
                topEntity.elo = Int32(top.elo)
                topEntity.given = top.given
                topEntity.avg_score = top.avg_score ?? 0.0
            }
            self?.save()
        }
        .store(in: &amp;cancellables)
}
</code></pre>
<p>As you can see in the above screenshot, this fails with</p>
<blockquote>
<p>Thread 4: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)</p>
</blockquote>
<p>because I have added the following &quot;Arguments Passed on Launch&quot; in Xcode:</p>
<blockquote>
<p>-com.apple.CoreData.ConcurrencyDebug 1</p>
</blockquote>
<p>Could anyone please advise me, how to call the <code>newBackgroundContext()</code> on the proper thread?</p>
<p><strong>UPDATE:</strong></p>
<p>I have tried to workaround my problem as in below code, but the error is the same:</p>
<pre><code>URLSession.shared.dataTaskPublisher(for: url)
    .tryMap(handleOutput)
    .decode(type: TopResponse.self, decoder: JSONDecoder())
    .sink { completion in
        print(completion)
    } receiveValue: { returnedTops in
        let backgroundContext = PersistenceController.shared.container.newBackgroundContext()

        for top in returnedTops.data {
            // the next line fails with EXC_BAD_INSTRUCTION
            let topEntity = TopEntity(context: backgroundContext)
            topEntity.uid = Int32(top.id)
            topEntity.elo = Int32(top.elo)
            topEntity.given = top.given
            topEntity.avg_score = top.avg_score ?? 0.0
        }

        do {
            try backgroundContext.save()
        } catch {
            let nsError = error as NSError
            fatalError(&quot;Unresolved error \(nsError), \(nsError.userInfo)&quot;)
        }
</code></pre>
<p><strong>UPDATE 2:</strong></p>
<p>I was assuming that when <code>newBackgroundContext()</code> is called, it takes the current thread and then you can use that context from the same thread...</p>
<p>This seems not to be the case and I have to call <code>perform</code>, <code>performAndWait</code> or <code>performBackgroundTask</code> (I have updated <a href=""https://github.com/afarber/ios-questions/blob/master/Tops1/Tops1/Managers/DownloadManager.swift"" rel=""nofollow noreferrer"">my code at Github</a> to do just that).</p>
<p>Still I wonder, if the thread of <code>newBackgroundContext</code> can be the same as of the <code>URLSession.shared.dataTaskPublisher</code>...</p>
","165071","","165071","","2021-06-05 15:46:25","2021-06-18 20:22:40","How to use newBackgroundContext() with URLSession.shared.dataTaskPublisher?","<ios><swift><core-data><combine><ios-multithreading>","1","2","","","","CC BY-SA 4.0"
"67841828","1","67844744","","2021-06-04 17:47:58","","0","204","<p>Whenever I am typing something in TextField, I am getting the value through the 'sink' operator after making UITextField the publisher. However, now I want to validate that password and the below piece of code involves 'send()' that works only for the first time the validatePassword() method is called. After that 'send()' does not work. Any idea why is this happening? I have been exploring Combine for 4-5 days now and here is the gist:<br>1. Publishers, subscribers and operators.<br>2. publishers in ViewModel and subscribers in ViewController.<br>3. Send() is used for sending a value to subscriber.<br><br> Everything fits but it still doesn't get called after first time. Stuck on it for 3-4 hours now.</p>
<p>Here is the code for ViewController<br></p>
<pre><code>            viewModel.passwordValidationResult
                .print(&quot;Debugging&quot;)
                .sink { completion in
                    
                    switch completion {
    
                    case .finished:
                        print(&quot;c&quot;)
                        return
                    case .failure(_):
                        print(&quot;f&quot;)
                        return
                    }
                    
                } receiveValue: { _  in
                    print(&quot;v&quot;)
                }
                .store(in: &amp;bindings)
        }

</code></pre>
<p>Here is the code for ViewModel</p>
<pre><code>class ViewModel
{
    private var bindings = Set&lt;AnyCancellable&gt;()

    @Published var emailValueChanged: String = String()
    @Published var passwordValueChanged: String = String()
        
    let passwordValidationResult = PassthroughSubject&lt;Void, Error&gt;()
    
    //input
    
    func validatePassword(_ password: String) {
        
        if password.count &gt;= 6 {
            passwordValidationResult.send()
        }
        passwordValidationResult.send(completion: .failure(PasswordError.shortPassword))
    }
}
</code></pre>
","3972195","","","","","2021-06-05 02:28:25","send() gets called only for the first time in combine framework iOS","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"67854150","1","67854402","","2021-06-05 21:44:45","","0","45","<p>I'm working on a quiz app, and stacked with updating the UI with the next set of questions. The first set is loading just fine, but when I'm trying to get the next set of question by clicking on the &quot;Next&quot; button - nothing happened. When I tried debugging, I noticed that instead of updating the questions, the questions are added to the previous set of questions. Please help me figure out what am I doing wrong.</p>
<p>Here is my code:</p>
<pre><code>import Foundation
import Combine

final class QuizManager: ObservableObject {
    @Published var quizQuestions: [QuizModel] = Bundle.main.decode(&quot;file.json&quot;)
    
    var imageIndex = 0
    var possibleAnswers = [String]()
    var correctAnswers = 0
    var questionsAsked = 0
    
    init() {
        getRandomQuestion()
    }
    
    
    func getRandomQuestion() {
        
            imageIndex = Int.random(in: 0..&lt;quizQuestions.count)
            if quizQuestions[imageIndex].isCompleted {
                imageIndex = Int.random(in: 0..&lt;quizQuestions.count)
            }
        
        
        possibleAnswers.append(quizQuestions[imageIndex].description)
        
        
        var index1 = Int.random(in: 0..&lt;quizQuestions.count)
        var index2 = Int.random(in: 0..&lt;quizQuestions.count)

        if index1 == imageIndex &amp;&amp; index1 == index2 {
            index1 = Int.random(in: 0..&lt;quizQuestions.count)
        } else {
            possibleAnswers.append(quizQuestions[index1].description)
        }

        if index2 == imageIndex &amp;&amp; index1 == index2 {
            index2 = Int.random(in: 0..&lt;quizQuestions.count)
        } else {
            possibleAnswers.append(quizQuestions[index2].description)
        }

        possibleAnswers.shuffle()
    }

    func checkAnswer(answer: String) -&gt; Bool {
        questionsAsked += 1
        
        if quizQuestions[imageIndex].description == answer {
            correctAnswers += 1
        }
        quizQuestions[imageIndex].isCompleted = true
        return quizQuestions[imageIndex].description == answer
    }
    
    
} 



import SwiftUI

struct QuizQestionsView: View {
    
    @ObservedObject private var quizManager = QuizManager()
    
    @State private var isCorrect = false
    @State private var correctAnswer = 0
    @State private var answerSelected = &quot;&quot;
    @State private var isTapped = false
    
    var body: some View {
        
        ScrollView {
            VStack {
                ImageView(name: quizManager.quizQuestions[quizManager.imageIndex].image,
                                          contentMode: .scaleAspectFit,
                                          tintColor: .black)
                                    .frame(minWidth: 150, idealWidth: 200, maxWidth: 250, minHeight: 150, idealHeight: 200, maxHeight: 250)
                
                Spacer()
                
                
                VStack {
                    ForEach(quizManager.possibleAnswers, id: \.self) { answer in
                        QuestionsView(answer: answer) {
                            self.isCorrect = self.quizManager.checkAnswer(answer: answer)
                            self.answerSelected = answer
                            self.isTapped = true
                        }
                        .disabled(isTapped)
                        .overlay(
                            RoundedRectangle(cornerRadius: 16.0)
                                .stroke(getColor(answer), lineWidth: 1)
                        )
                    }
                }
                Spacer()

                Button(action: {
                    self.quizManager.getRandomQuestion()
                }) {
                    Text(&quot;NEXT&quot;)
                }
            }
        }
        
    }
    
    
    func getColor(_ tag: String) -&gt; Color {
        if answerSelected == tag {
            if isCorrect {
                return Color.green
            } else {
                return Color.red
            }
        } else {
            if isTapped &amp;&amp; !isCorrect {
                if tag == quizManager.quizQuestions[quizManager.imageIndex].description {

                    return Color.green
                }
            }
        }
        return Color.accentColor
    }
    
    
</code></pre>
<p>The QuestionsView looks like this:</p>
<pre><code>        var answer: String
        var onTap: () -&gt; Void

        var body: some View {
            Button(action: {
                self.onTap()
            }) {
                Text(answer)
            }
        }
    }
</code></pre>
","15302071","","62576","","2021-06-06 01:31:24","2021-06-06 01:31:24","Questions are not updated after ""Next"" button is pressed","<swift><foreach><swiftui>","1","0","","","","CC BY-SA 4.0"
"67860634","1","67861029","","2021-06-06 15:14:47","","-1","249","<p>I am trying to pass Int to the ViewModel, but it doesn't work. Value is still 0. There is no problem with Strings or Data objects, but Int, Double and others number values are still 0 value. I also tried this way:</p>
<blockquote>
<p>@Published var tankCapacity: Int?</p>
</blockquote>
<p>but still same. How to resolve that? Use a string and convert to a given type?</p>
<pre><code>AddVehicleView: 

import SwiftUI

struct AddVehicleView: View {

@ObservedObject var viewModel: AddVehicleViewModel
@State private var selected = 0
@State private var showingAlert = false

init(viewModel: AddVehicleViewModel) {
    self.viewModel = viewModel
    UITableView.appearance().backgroundColor = .clear
    UITableView.appearance()
}

var body: some View {
    
    VStack(alignment: .leading) {
        
        Text(&quot;Add new vehicle&quot;)
            .font(.system(size: 26, weight: .medium))
            .padding(.top, -30)
            .padding(.leading, 20)
        
        VStack {
            
            TextField(&quot;Brand/Model etc&quot;, text: $viewModel.name)
                .padding(.top, 10)
                .padding(.leading, 20)
                .padding(.trailing, 20)
                .font(.system(size: 20))
                .textFieldStyle(RoundedBorderTextFieldStyle())
            
            TextField(&quot;Capacity&quot;, value: $viewModel.tankCapacity, formatter: NumberFormatter()) // I am trying send int value from here
                .padding(.top, 30)
            .padding(.leading, 20)
            .padding(.trailing, 20)
            .font(.system(size: 20))
            .textFieldStyle(RoundedBorderTextFieldStyle())
            
            Form {
                Section {
                    Picker(&quot;Fuel type&quot;, selection: $viewModel.fuelType) {
                        ForEach(0 ..&lt; viewModel.fuels.count) {
                            Text(self.viewModel.fuels[$0]).tag($0)
                                .padding(.leading, 5)
                                .padding(.trailing, 5)
                        }
                    }
                }
            }
            .padding(.leading, 5)
            .padding(.trailing, 5)
            
            Button(&quot;Add&quot;) {
                if self.viewModel.name.isEmpty {
                    self.showingAlert = true
                }
                else {
                    self.viewModel.saveVehicle()
                    self.viewModel.name = &quot;&quot;
                }
                
            }
            .frame(width: 200, height: 50)
                .background(Color.blue)
                .font(.system(size: 20, design: .default))
                .foregroundColor(Color.white)
            .cornerRadius(10)
            .padding(.top, -350)
                .alert(isPresented: $showingAlert) {
                    Alert(title: Text(&quot;Warning!&quot;), message: Text(&quot;Fill the fields&quot;))
            }
        }
        Spacer()
        
    }
}
}
</code></pre>
<p>import Foundation</p>
<pre><code>class AddVehicleViewModel: ObservableObject {

@Published var name = &quot;&quot;
@Published var tankCapacity = 0 // and here I am trying to get value.
@Published var fuelType = 0
@Published var fuels = [&quot;Petrol&quot;, &quot;Diesel&quot;]

private let persistenceService: PersistenceServiceProtocol

init(persistenceService: PersistenceServiceProtocol) {
    self.persistenceService = persistenceService
}

func saveVehicle() {
    print(&quot;name: \(name)&quot;)
    print(&quot;tankCapacity: \(tankCapacity)&quot;)
    let vehicle = Vehicle(name: name,
                          tankCapacity: tankCapacity)
    
    do {
        try self.persistenceService.addVehicle(vehicle: vehicle)
    }
    catch {
        print(&quot;ADDVEHICLEMODEL saveVehicle Error&quot;)
    }
}
}
</code></pre>
","11056400","","11056400","","2021-06-06 15:36:02","2021-06-06 15:53:56","SwiftUI pass Int value to the ViewModel","<ios><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"67860892","1","67862470","","2021-06-06 15:38:20","","0","520","<p>I'm creating a swift UI radio streaming app that has a library of past episodes that can be downloaded. I would like users to be able to begin a download and then lock the screen. Currently this suspends the download(s) in progress. My download function :</p>
<pre class=""lang-swift prettyprint-override""><code>func downloadFile(withUrl url: URL, andFilePath filePath: URL) {
        URLSession.shared
            .downloadTaskPublisher(for: url)
            .retry(4)
            .map(\.0)
            .receive(on: RunLoop.main)
            .sink(receiveCompletion: { [self] _ in
                      downloading = false
                      downloaded = true
                  },
                  receiveValue: { data in
                      do {
                          self.downloading = true
                          try FileManager.default.moveItem(atPath: data.path,
                                                           toPath: filePath.path)
                      } catch {
                          self.downloaded = false
                          print(&quot;Error: \(error.localizedDescription)&quot;)
                          print(&quot;an error happened while downloading or saving the file&quot;)
                      }
                  })
            .store(in: &amp;networkSubscription)
    }
</code></pre>
<p>Where <code>.downloadTaskPublisher(for: url)</code> is :</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine
import Foundation

public extension URLSession {
    /// Returns a publisher that wraps a URL session download task for a given
    /// URL.
    ///
    /// - Parameter url: The URL for which to create a download task.
    /// - Returns: A publisher that wraps a download task for the URL.
    func downloadTaskPublisher(for url: URL) -&gt; DownloadTaskPublisher {
        DownloadTaskPublisher(session: self, request: URLRequest(url: url))
    }

    /// Returns a publisher that wraps a URL session download task for a given
    /// URL request.
    ///
    /// - Parameter request: The URL request for which to create a download task.
    /// - Returns: A publisher that wraps a download task for the URL request.
    func downloadTaskPublisher(for request: URLRequest) -&gt; DownloadTaskPublisher {
        DownloadTaskPublisher(session: self, request: request)
    }
}

public struct DownloadTaskPublisher {
    fileprivate let session: URLSession
    fileprivate let request: URLRequest
}

extension DownloadTaskPublisher: Publisher {
    public typealias Output = (URL, URLResponse)
    public typealias Failure = Error

    public func receive&lt;Subscriber&gt;(subscriber: Subscriber)
        where
        Subscriber: Combine.Subscriber,
        Subscriber.Failure == Failure,
        Subscriber.Input == Output
    {
        let subscription = Subscription(subscriber: subscriber, session: session, request: request)
        subscriber.receive(subscription: subscription)
    }
}

private extension DownloadTaskPublisher {
    final class Subscription {
        private let downloadTask: URLSessionDownloadTask

        init&lt;Subscriber&gt;(subscriber: Subscriber, session: URLSession, request: URLRequest)
            where
            Subscriber: Combine.Subscriber,
            Subscriber.Input == Output,
            Subscriber.Failure == Failure
        {
            downloadTask = session.downloadTask(with: request, completionHandler: { url, response, error in

                guard let url = url, let response = response else {
                    subscriber.receive(completion: .failure(error!))
                    return
                }

                _ = subscriber.receive((url, response))
                subscriber.receive(completion: .finished)
            })
        }
    }
}

extension DownloadTaskPublisher.Subscription: Subscription {
    fileprivate func request(_: Subscribers.Demand) {
        downloadTask.resume()
    }

    fileprivate func cancel() {
        downloadTask.cancel()
    }
}
</code></pre>
<p>This download function writes the episode to disk but is canceled when the app is suspended.</p>
<p>I would like to write something like</p>
<pre class=""lang-swift prettyprint-override""><code>func downloadFile(withUrl url: URL, andFilePath filePath: URL) {
        URLSession.init(configuration: URLSessionConfiguration.background(withIdentifier: &quot;background.download.session&quot;))
            .downloadTaskPublisher(for: url)
            .retry(4)
            .map(\.0)
            .receive(on: RunLoop.main)
            .sink(receiveCompletion: { [self] _ in
                      downloading = false
                      downloaded = true
                  },
                  receiveValue: { data in
                      do {
                          self.downloading = true
                          try FileManager.default.moveItem(atPath: data.path,
                                                           toPath: filePath.path)
                      } catch {
                          self.downloaded = false
                          print(&quot;Error: \(error.localizedDescription)&quot;)
                          print(&quot;an error happened while downloading or saving the file&quot;)
                      }
                  })
            .store(in: &amp;networkSubscription)
    }
</code></pre>
<p>However, this throws a runtime exception: <code>libc++abi.dylib: terminating with uncaught exception of type NSException *** Terminating app due to uncaught exception 'NSGenericException', reason: 'Completion handler blocks are not supported in background sessions. Use a delegate instead.' terminating with uncaught exception of type NSException</code></p>
<p>I would like to download files in the background using combine idioms and avoid have to attach an <code>AppDelegate</code> to my <code>@main struct: App</code>.</p>
","10106418","","10106418","","2021-06-06 22:21:03","2021-06-06 22:21:03","Background mp3 download on iOS 14 in a swift ui app","<ios><swift><swiftui><combine><urlsession>","1","0","1","","","CC BY-SA 4.0"
"67863183","1","67863493","","2021-06-06 19:56:10","","0","599","<p>I'm new to Combine and I'm trying to understand it by solving the &quot;old&quot; problems</p>
<p>My goal is to make the process cancelable, but even I called the <code>.cancel()</code> method right after (or with sort delay) the <code>printFizzbuzz()</code> method, the code still keeping running(around 3 secs) until finishing</p>
<p>I've tried the code below in the new Xcode project, still the same</p>
<pre><code>import Foundation
import Combine

enum PrinterError: Error {
    case indexError(String)
    case subscriptionError(String)
    
    var description: String {
        switch self {
        case .indexError(let descpription):
            return descpription
        case .subscriptionError(let description):
            return description
        }
    }
}

struct FizzbuzzPrinter {
    private var subscriptions = Set&lt;AnyCancellable&gt;()

    mutating func printFizzbuzz(fromIndex: Int, toIndex: Int, handler: @escaping (_ result: Result&lt;Int,PrinterError&gt;) -&gt; Void) {
        guard toIndex &gt; fromIndex else {
            handler(.failure(.indexError(&quot;toIndex must larger than fromIndex&quot;)))
            return
        }

        var currentIndex: Int = fromIndex
        
        Array&lt;Int&gt;(fromIndex ..&lt; toIndex).publisher
            .handleEvents(receiveOutput: { index in
                currentIndex = index
            }, receiveCancel: {
                handler(.failure(.subscriptionError(&quot;cancaled at \(currentIndex)&quot;)))
            })
            .map { number -&gt; String in
                switch (number.isMultiple(of: 3), number.isMultiple(of: 5) ) {
                case (true, true):
                    return &quot;fizzbuzz at \(number)&quot;
                case (true, false):
                    return &quot;fizz at \(number)&quot;
                case (false, true):
                    return &quot;buzz at \(number)&quot;
                case (false, false):
                    return String()
                }
            }
            .filter{ !$0.isEmpty }
            .sink { _ in
                handler(.success(currentIndex))
            } receiveValue: { print($0)}
            .store(in: &amp;subscriptions)
        
    }
    
    mutating func cancelAll() {
        subscriptions.forEach{ $0.cancel()}
    }
}

var fizzBuzzPrinter = FizzbuzzPrinter()

DispatchQueue.main.async {
    fizzBuzzPrinter.printFizzbuzz(fromIndex: 1, toIndex: 60001) { result in
        switch result {
        case .failure(let printerError):
            print(printerError.description)
        case .success(let finishedIndex):
            print(&quot;finished at \(finishedIndex)&quot;)
        }
    }
}
DispatchQueue.main.async {
    fizzBuzzPrinter.cancelAll()
}

DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
    fizzBuzzPrinter.cancelAll()
}
</code></pre>
<p>the code prints (last 10 lines):</p>
<pre><code>fizz at 59982
fizzbuzz at 59985
fizz at 59988
buzz at 59990
fizz at 59991
fizz at 59994
buzz at 59995
fizz at 59997
fizzbuzz at 60000
finished at 60000

</code></pre>
<p>I also tried to use the .switchToLatest() operator, still unable to cancel it</p>
<pre><code>struct FizzbuzzPrinter {
    private var subscriptions = Set&lt;AnyCancellable&gt;()
    
    private let publishers = PassthroughSubject&lt;AnyPublisher&lt;Int, Never&gt;, Never&gt;()
    private let finishPublisher = PassthroughSubject&lt;Int,Never&gt;()


    mutating func printFizzbuzz(fromIndex: Int, toIndex: Int, handler: @escaping (_ result: Result&lt;Int,PrinterError&gt;) -&gt; Void) {
        guard toIndex &gt; fromIndex else {
            handler(.failure(.indexError(&quot;toIndex must larger than fromIndex&quot;)))
            return
        }

        var currentIndex: Int = fromIndex
        
        publishers
            .switchToLatest()
            .handleEvents(receiveOutput: { index in
                currentIndex = index
            }, receiveCancel: {
                handler(.failure(.subscriptionError(&quot;cancaled at \(currentIndex)&quot;)))
            })
            .map { number -&gt; String in
                switch (number.isMultiple(of: 3), number.isMultiple(of: 5) ) {
                case (true, true):
                    return &quot;fizzbuzz at \(number)&quot;
                case (true, false):
                    return &quot;fizz at \(number)&quot;
                case (false, true):
                    return &quot;buzz at \(number)&quot;
                case (false, false):
                    return String()
                }
            }
            .filter{ !$0.isEmpty }
            .sink { _ in
                handler(.success(currentIndex))
            } receiveValue: { print($0)}
            .store(in: &amp;subscriptions)
        
        publishers.send(Array&lt;Int&gt;(fromIndex ..&lt; toIndex)
                            .publisher
                            .eraseToAnyPublisher())
        
    }
    
    mutating func cancel() {
        publishers.send(finishPublisher.eraseToAnyPublisher())
        finishPublisher.send(completion: .finished)
    }
}

var fizzBuzzPrinter = FizzbuzzPrinter()

DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
    fizzBuzzPrinter.cancel()
}
fizzBuzzPrinter.printFizzbuzz(fromIndex: 1, toIndex: 60001) { result in
    switch result {
    case .failure(let printerError):
        print(printerError.description)
    case .success(let finishedIndex):
        print(&quot;finished at \(finishedIndex)&quot;)
    }
}
</code></pre>
<p>I feel that I made a mistake somewhere but I couldn't figure it.</p>
<p>++++++++++++++++++Update: +++++++++++++++++++</p>
<p>Thanks @matt
I changed the publisher to a Timer based one and it works now</p>
<pre><code>        Timer.publish(every: 0.1, on: .main, in: .common)
            .autoconnect()
            .scan(fromIndex) { current, _ in
                current + 1
            }
            .prefix(toIndex - fromIndex)
</code></pre>
<p>++++++++++++++++++Update: 2 +++++++++++++++++++</p>
<p>based on @matt comment</p>
<pre><code>.subscribe(on: DispatchQueue(label: &quot;serial queue&quot;))
</code></pre>
<p>and @matt Link: <a href=""https://www.apeth.com/UnderstandingCombine/operators/operatorsTransformersBlockers/operatorsflatmap.html#SECexertingbackpressure"" rel=""nofollow noreferrer"">link</a> the last section &quot;Exerting Backpressure&quot;</p>
<pre><code>            .flatMap(maxPublishers: .max(1)){ num in
                Just(num).delay(for: .seconds(0.01), scheduler: DispatchQueue.main)
            }

</code></pre>
<p>both works</p>
<p>Thanks!!</p>
<p>++++++++++++++++++Update: 3 +++++++++++++++++++</p>
<p>I modified my previous codes to become a more generic one and found out using</p>
<pre><code>.subscribe(on: DispatchQueue.global(qos: .background))
</code></pre>
<p>and</p>
<pre><code>.receive(on: DispatchQueue.main)
</code></pre>
<p>works best for me, the speed will not limited by hard coded timeInterval limit, not blocking each other and individually cancelable</p>
<p>I called the below code (some unrelated logics not included)</p>
<pre><code>typealias CancelableIntTaskType = CancelableTask&lt;AnyPublisher&lt;Int, Never&gt;&gt;
var cancelableIntTasks = CancelableIntTaskType()
var taskIdArray = [UUID?]()

taskIdArray = [
    startFizzBuzzTask(50, -80, &amp;cancelableIntTasks),
    startFizzBuzzTask(100, 200, &amp;cancelableIntTasks),
    startFizzBuzzTask(600, 1000, &amp;cancelableIntTasks),
    startFizzBuzzTask(2000, 2600, &amp;cancelableIntTasks)
]

checkAllTasksStarted(taskIdArray)

DispatchQueue.main.asyncAfter(deadline: .now() + 0.0001) {
    if let id = taskIdArray.compactMap({$0}).first {
        cancelableIntTasks.cancelTaskWithID(id)
    }
}

DispatchQueue.main.asyncAfter(deadline: .now() + 0.0002) {
    cancelableIntTasks.cancelAll()
}
</code></pre>
<p>outputs</p>
<pre><code>*id 52F started
id:52F val: 100 progress 0.0%
id:52F val: 101 progress 1.0%
id:52F val: 102 progress 2.0%
id:52F val: 103 progress 3.0%
id:52F val: 104 progress 4.0%
id:52F val: 105 progress 5.0%
id:52F val: 106 progress 6.0%
id:52F val: 107 progress 8.0%
id:52F val: 108 progress 8.0%
id:52F val: 109 progress 9.0%
id:52F val: 110 progress 10.0%
id:52F val: 111 progress 11.0%
id:52F val: 112 progress 12.0%
*id 9EA started
id:52F val: 113 progress 13.0%
id:52F val: 114 progress 15.0%
id:52F val: 115 progress 15.0%
*id 97B started
id:52F val: 116 progress 16.0%
id:52F val: 117 progress 17.0%
id:52F val: 118 progress 18.0%
id:9EA val: 600 progress 0.0%
id:9EA val: 601 progress 1.0%
id:97B val: 2000 progress 0.0%
id:9EA val: 602 progress 1.0%
id:9EA val: 603 progress 1.0%
id:9EA val: 604 progress 1.0%
id:97B val: 2001 progress 1.0%
id:9EA val: 605 progress 2.0%
id:97B val: 2002 progress 1.0%
id:52F val: 119 progress 19.0%
id:9EA val: 606 progress 2.0%
4 tasks initiated 3 started
task at index 0 failed
id:97B val: 2003 progress 1.0%
id:52F val: 120 progress 20.0%
id:9EA val: 607 progress 2.0%
id:97B val: 2004 progress 1.0%
id:9EA val: 608 progress 2.0%
id:52F val: 121 progress 21.0%
id:97B val: 2005 progress 1.0%
id:9EA val: 609 progress 3.0%
id:97B val: 2006 progress 1.0%
id:9EA val: 610 progress 3.0%
id:97B val: 2007 progress 2.0%
id:9EA val: 611 progress 3.0%
id:97B val: 2008 progress 2.0%
id:9EA val: 612 progress 3.0%
id:97B val: 2009 progress 2.0%
id:9EA val: 613 progress 4.0%
id:97B val: 2010 progress 2.0%
id:9EA val: 614 progress 4.0%
id:97B val: 2011 progress 2.0%
id:52F val: 122 progress 22.0%
id:9EA val: 615 progress 4.0%
id:52F val: 123 progress 23.0%
id:9EA val: 616 progress 4.0%
id:52F val: 124 progress 24.0%
id:9EA val: 617 progress 5.0%
id:52F val: 125 progress 25.0%
id:97B val: 2012 progress 2.0%
id:9EA val: 618 progress 5.0%
**52F canceled at 125 progress: 25.0%
**97B canceled at 2012 progress: 2.0%
**9EA canceled at 619 progress: 5.0%
id:9EA val: 619 progress 5.0%
id:52F val: 126 progress 26.0%


</code></pre>
<p>+++++++++++++++++++update 4+++++++++++++++++++</p>
<p>Just made a project for learning ways to cancel / resume the tasks</p>
<p><a href=""https://github.com/hgtlzyc/PokemonDisplay"" rel=""nofollow noreferrer"">https://github.com/hgtlzyc/PokemonDisplay</a></p>
","15354305","","15354305","","2021-06-13 02:31:26","2021-06-13 02:31:26","Swift Combine, how to cancel the execution","<ios><swift><xcode><combine>","1","3","","","","CC BY-SA 4.0"
"67864691","1","67951416","","2021-06-07 00:20:31","","1","352","<p>I have a <code>SummaryView</code> with a <code>Report</code> as <code>@State</code>.</p>
<p>A <code>Report</code> is a protocol which includes some changes a user might want to make:</p>
<pre><code>protocol Report {
    var changeGroups: [ChangeGroup] { get set }
}
</code></pre>
<p>There are several kinds of reports; individual reports are implemented as a struct:</p>
<pre><code>struct RealEstateReport: Report {
    static let name = &quot;Real Estate Report&quot;
    
    var changeGroups = [ChangeGroup]()
}
</code></pre>
<p>A <code>ChangeGroup</code> is a struct with (among other stuff) a human-readable summary and a handful of proposed changes:</p>
<pre><code>struct ChangeGroup: Identifiable {
    var summary: String
    var proposedChanges = [ProposedChange]()
}
</code></pre>
<p>A <code>ProposedChange</code> is a <em>class</em> that represents one discrete change the app proposes to the user, which is <code>enabled</code> by default:</p>
<pre><code>class ProposedChange: ObservableObject, Identifiable {
    @Published var enabled = true
    let summary: String
</code></pre>
<p>(In a detail view, <code>enabled</code> is bound to a <code>Toggle</code> so a user can flip each proposed change on and off.)</p>
<p>So a <code>Report</code> has many <code>ChangeGroup</code>s which themselves have many <code>ProposedChange</code>s.</p>
<p>I'm trying to include some high level details on the <code>SummaryView</code>:</p>
<pre><code>struct SummaryView: View {
    @State var report: Report
    
    var body: some View {
        Text(&quot;Summary&quot;)
            .foregroundColor(…) // ???
    }
</code></pre>
<p>I want <code>foregroundColor</code> to be red, yellow, or green:</p>
<ul>
<li><strong>Red</strong> if <code>enabled</code> is <code>false</code> for <em>all</em> <code>ProposedChange</code>s in this <code>Report</code></li>
<li><strong>Green</strong> if <code>enabled</code> is <code>true</code> for <em>all</em> <code>ProposedChange</code>s in this <code>Report</code></li>
<li><strong>Yellow</strong> if <code>enabled</code> is mixed for different <code>ProposedChange</code>s in this <code>Report</code></li>
</ul>
<p>I've read a bit about Combine, and I think I need to create a new Combine subscription for each <code>ChangeGroup</code>, and map that to a new Combine subscription for each <code>ProposedChange</code>'s <code>enabled</code> property, flatten the values when one changes, and check if they're all the same.</p>
<p>I'm a little lost on the exact syntax I'd use. And also it seems like structs don't publish changes in the same way (I guess since the structs are value vs. reference types).</p>
<p><strong>How can I set the foregroundColor of the Text view based on the above logic?</strong></p>
","1445366","","1445366","","2021-06-07 02:23:45","2021-06-16 16:25:34","SwiftUI / Combine subscribe to updates in multiple nested collections","<swift><swiftui><combine>","2","12","","","","CC BY-SA 4.0"
"67895297","1","67895298","","2021-06-08 22:26:05","","1","201","<p>When using an <code>@ObservedObject</code> member inside a SubView that is used as the destination of a NavigationLink, that class is never deallocated.</p>
<p>Example:</p>
<pre><code>import Combine
import SwiftUI

struct ParentView: View {
    
    var body: some View {
        NavigationView {
            List {
                ForEach(0..&lt;10) { i in
                    ZStack {
                        Text(&quot;row \(i)&quot;)
                        NavigationLink(destination: SubView()) {
                            EmptyView()
                        }
                    }
                }
            }
        }
    }
}

struct SubView: View {
    @ObservedObject private var viewModel = ViewModel()
    
    var body: some View {
        Text(&quot;bar&quot;)
    }
}

final class ViewModel: ObservableObject {
    
    init() {
        print(&quot;init - \(String(describing: type(of: self)))&quot;)
    }
    
    deinit {
        print(&quot;deinit - \(String(describing: type(of: self)))&quot;)
    }
}
</code></pre>
<p>Going back and forth the navigation stack will produce as many instances of ViewModel in this case.</p>
<p>Memory Graph:
<a href=""https://i.stack.imgur.com/8rnRp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8rnRp.png"" alt=""enter image description here"" /></a></p>
","1097106","","","","","2021-06-08 22:26:05","Retain Cycle when annotating member with @ObservedObject in SubView used as destination in NavigationLink","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"67907327","1","67911586","","2021-06-09 15:33:01","","0","103","<p>I have a login button named proceed, and have 2 <code>@Published</code> properties that represent current typed text in <code>UITextField</code>.
What i want is, to assign result of <code>.filter { !$0.0.isEmpty &amp;&amp; !$0.1.isEmpty}</code> to <code>Bool</code> variable <code>isEnabled</code> of my <code>UIButton</code></p>
<p>Currently i ended up with this:</p>
<pre><code>passwordTxtf.textView.$text
  .combineLatest(loginTxtf.textView.$text)
  .filter { !$0.0.isEmpty &amp;&amp; !$0.1.isEmpty}
  .sink(receiveValue: { [weak self] in
          guard let weakSelf = self else { return }
          weakSelf.loginEntered = $0
          weakSelf.passEntered = $1
          weakSelf.setProceedEnableState()
  })
  .store(in: &amp;subscriptions)
</code></pre>
<p>Where <code>setProceedEnableState()</code> is a function that checks class variables and therefore determine button enabled state.</p>
<p>But i want somehow assign that during &quot;pipeline&quot;, or do more elegant way</p>
","1451247","","","","","2021-06-10 07:15:50","Make button enabled depending on strings using Combine","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"67920632","1","67921717","","2021-06-10 11:55:32","","0","157","<p>I'm fairly new to Combine declarative API. I'm trying to implement a generic network layer for a SwiftUI application. For all requests that receive data I understand how to structure the data flow.</p>
<p>My problem is that I have some HTTP POST requests that returns no data. Only a HTTP 200 on success. I can't figure out how to create a publisher that will handle a decoding that can fail since there could be not data in the body of the response. Here's what I tried:</p>
<pre><code>func postResource&lt;Resource: Codable&gt;(_ resource: Resource, to endpoint: Endpoint) -&gt; AnyPublisher&lt;Resource?, NetworkError&gt; {
        return Just(resource)
            .subscribe(on: queue)
            .encode(encoder: JSONEncoder())
            .mapError { error -&gt; NetworkError in
                return NetworkError.encoding(error)
            }
            .map { data -&gt; URLRequest in
                return endpoint.makeRequest(with: data)
            }
            .tryMap { request -&gt; Resource? in
                self.session.dataTaskPublisher(for: request)
                    .tryMap { data, response -&gt; Data in
                        guard let httpUrlResponse = response as? HTTPURLResponse else { throw NetworkError.unknown }
                        guard (200 ... 299).contains(httpUrlResponse.statusCode) else { throw NetworkError.error(for: httpUrlResponse.statusCode) }
                        return data
                    }
                    .tryMap { data -&gt; Resource? in
                        return try? JSONDecoder().decode(Resource.self, from: data)
                    }
            }
            .mapError({ error -&gt; NetworkError in
                switch error {
                case is Swift.DecodingError:
                    return NetworkError.decoding(error)
                case let urlError as URLError:
                    return .urlError(urlError)
                case let error as NetworkError:
                    return error
                default:
                    return .unknown
                }
            })
            .eraseToAnyPublisher()
    }
</code></pre>
<p>The compiler is complaining with the following error on tryMap row:
<code>Declared closure result 'Publishers.TryMap&lt;URLSession.DataTaskPublisher, Resource?&gt;' is incompatible with contextual type 'Resource?'</code></p>
<p>Anyone has an idea?
Thanks!</p>
","1919754","","","","","2021-06-10 13:03:05","HTTP POST request using Swift Combine","<swift><http-post><combine>","1","2","","","","CC BY-SA 4.0"
"67924925","1","67954464","","2021-06-10 16:14:59","","1","679","<p>I am trying to call a Swift 5.5 async throws method inside a method that should return an AnyPublisher but I am having trouble to achieve this. I tried using a <code>Future</code> (promise) which did not work and I only managed to find a Swift 5.5 API to convert closure based methods to async ones.</p>
<pre><code>class Loader {

    func loadSomeData() -&gt; async throws [String] {
        /// some code
    }
}

class Service {
   let loader: Loader
   init(loader: Loader) { 
      self.loader = loader
   }

   func someDataPublisher() -&gt; AnyPublisher&lt;[String], Error&gt; {
       // How can I convert this?
       try await loader.loadSomeData() 
   }
}
</code></pre>
","4945232","","","","","2021-06-13 03:01:52","Swift 5.5 async await method to AnyPublisher","<swift><async-await><combine>","1","0","","","","CC BY-SA 4.0"
"67949158","1","67950044","","2021-06-12 13:08:33","","0","158","<p>I decided to migrate a standard network call to one using combine and its operators.</p>
<p>Given the following code</p>
<pre><code>enum NetworkServiceError: Error{
   case badUrl
   case networkFail(String)
}

func getHtml(from url: String, completion: @escaping (Result&lt;String, NetworkServiceError&gt;) -&gt; ()) {
   guard let url = URL(string: url) else {
      completion(.failure(.badUrl))
      return
   }
   URLSession.shared.dataTask(with: url) { (data, _, error) in
      if let err = error{
         completion(.failure(.networkFail(err.localizedDescription)))
         return
      }
      guard let rawHtmlData = data else {
         completion(.failure(.networkFail(&quot;No data&quot;)))
         return
      }
      guard let html = String(data: rawHtmlData, encoding: .utf8) else {
         completion(.failure(.networkFail(&quot;String serialization failed&quot;)))
         return
      }
      completion(.success(html))
   }
   .resume()
}
</code></pre>
<p>I would like to have the same precise error handling in the combine counterpart.
Being honest, i can t figure out how to do so despite i watched tons of videos about combine.
Here is my attempt</p>
<pre><code>func combineHtml(url: String)-&gt; AnyPublisher&lt;String, NetworkServiceError&gt;{
   
   guard let safeUrl = URL(string: url) else {
      return Fail(error: NetworkServiceError.badUrl).eraseToAnyPublisher()
   }

   let publisher = URLSession.shared
      .dataTaskPublisher(for: safeUrl)
      .tryMap{ result-&gt; Data in
         guard !result.data.isEmpty else{throw NetworkServiceError.networkFail(&quot;No data&quot;)}
         return result.data
      }
      .tryMap{ data-&gt; String in
         guard let html = String(data: data, encoding: .utf8) else{
            throw NetworkServiceError.networkFail(&quot;String serialization failed&quot;)
         }
         return html
      }
//      .mapError{ error-&gt; NetworkServiceError in
//         return NetworkServiceError.networkFail(&quot;error&quot;)
//      }

 
      .receive(on: DispatchQueue.main)
      .eraseToAnyPublisher()
      
   return publisher
      
}
</code></pre>
<p>Im not sure how i should handle the different errors: the try operators should throw and the pipeline should cancel, which is what i want. However, if i dont map the error to NetworkServiceError, (commented code) i should change the return type which i d like to avoid.
There must be something which is not correct im my error handling.</p>
<p>What would be the best way to handle multiple errors in combine?
Im not really satisfied with this code.</p>
","4584610","","4584610","","2021-06-12 13:15:45","2021-06-12 14:59:17","Combine multiple errors handling","<swift><error-handling><combine>","1","2","","","","CC BY-SA 4.0"
"67956910","1","67956949","","2021-06-13 09:49:04","","0","266","<p>In <a href=""https://github.com/afarber/ios-questions/blob/master/Tops1/Tops1/Managers/DownloadManager.swift"" rel=""nofollow noreferrer"">a singleton class</a> I am trying the following code with 3 URLs stored in a dictionary:</p>
<pre><code>class DownloadManager {
    static let instance = DownloadManager()
    
    let urls = [
        &quot;en&quot; : URL(string: &quot;https://wordsbyfarber.com/ws/top&quot;),
        &quot;de&quot; : URL(string: &quot;https://wortefarbers.de/ws/top&quot;),
        &quot;ru&quot; : URL(string: &quot;https://slova.de/ws/top&quot;)
    ]
    
    var cancellables = Set&lt;AnyCancellable&gt;()

    private init() {
        getTops()
    }
    
    func getTops() {
        guard let url = urls[&quot;en&quot;] else { return }
        
        URLSession.shared.dataTaskPublisher(for: url) // COMPILE ERROR
            .tryMap(handleOutput)
            .decode(type: TopResponse.self, decoder: JSONDecoder())
            .sink { completion in
                print(completion)
            } receiveValue: { fetchedTops in
                // ... store entities in Core Data
            }
            .store(in: &amp;cancellables)
    }
</code></pre>
<p>But for some reason the line <code>guard let url = urls[&quot;en&quot;] else { return }</code> is not sufficient to unwrap the value:</p>
<p><a href=""https://i.stack.imgur.com/xdfuy.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xdfuy.jpg"" alt=""screenshot"" /></a></p>
<p>Is this happening because the <code>URL</code> constructor might return nil?</p>
<p>Or because of the dictionary might not have a value for a key?</p>
<p>And why is guard statement not enough here?</p>
","165071","","","","","2021-06-13 10:59:27","After guard let url the value still needs to be unwrapped","<swift><swift-guard>","3","0","1","","","CC BY-SA 4.0"
"67963577","1","67964495","","2021-06-14 00:17:32","","1","156","<p>I have a listener that is registered/deregistered whenever user logs in and out. I have something analogous to the following code,</p>
<pre><code>import Foundation
import Combine

class X : ObservableObject {
    @Published var data: String? = nil
    
    func setData() {
        data = &quot;DATA&quot;
    }
}

let x = X()
var store = Set&lt;AnyCancellable&gt;()
x.$data.sink { v1 in  // I need to add .receive(on:) here
    print(v1)
    if v1 != nil {
        x.$data.sink { v2 in
            print(v2) // Why is this nil
        }.store(in: &amp;store)
    }
}.store(in: &amp;store)

x.setData()
</code></pre>
<p>I thought that <code>v2</code> will be <code>&quot;DATA&quot;</code>, but it isn't. I need to do a <code>.receive(on: DispatchQueue.main)</code> in the outer subscription to get them both to receive the &quot;after&quot; state.</p>
<p>My working theory is that the value isn't written after all the handlers are called, by I don't know how to verify it let alone if it's correct.</p>
<p>Why is <code>receive(on:)</code> necessary here?</p>
<blockquote>
<p>I know I could've used <code>flatMap</code>, but I didn't use it because I my state is delivered way too late, and I need to unsubscribe to the inner mapped publisher before the sign out code runs to avoid permission issues.</p>
</blockquote>
","789253","","","","","2021-06-14 03:29:44","Cannot get latest value when subscribing to the emitting Publisher","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"68035492","1","68035814","","2021-06-18 12:51:58","","1","773","<p>I'm struggling to understand why no values are received to <code>sink</code> in the underlying code.</p>
<pre class=""lang-swift prettyprint-override""><code>func somePublisher() -&gt; AnyPublisher&lt;Bool, Never&gt; {
   let subject = PassthroughSubject&lt;Bool, Never&gt;()
   subject.send(true)
   subject.send(completion: .finished)
   return subject.eraseToAnyPublisher()
}

somePublisher()
   .first()
   .sink { _ in
      print(&quot;Completed&quot;)
   } receiveValue: {
      print(&quot;Received \($0)&quot;)
   }
   .store(in: &amp;sinks)
</code></pre>
<p>Output:</p>
<blockquote>
<p>Completed</p>
</blockquote>
<p>It looks like values are not received by the publishers down the stream if it was finished before it was connected. Is that right?
How could I fix that if my publisher can finish synchronously?</p>
","380014","","","","","2021-06-18 13:14:20","Sink does not receive values when connecting to finished a Publisher","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"68057033","1","68058524","","2021-06-20 14:51:00","","-1","104","<p>Hello guys I'm trying to make a Calendar List in swiftUI :</p>
<p>I want  to App get the current date info and show it in <code>index 0</code> of <code>allDays list</code> and based on the subscription , App Generate an N number of  <code>Day</code> object after current date automatically. ie :  365 for 1 year subscription.</p>
<p>The final result is look like this right now it's a hard code.</p>
<p><a href=""https://i.stack.imgur.com/hJobc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hJobc.png"" alt=""enter image description here"" /></a></p>
<p>Here is my code DataModel :</p>
<pre><code>import SwiftUI
import Foundation
import Combine

struct Day : Identifiable {

var id = UUID()
var name : String
var date : String
var title : String
var color : Color
var month : String
var List : [Name?]

}

struct Name : Identifiable {

var id = UUID()
var name: String
var color: Color

}

class AppState : ObservableObject {

@Published var allDays : [Day] = [
    Day(name: &quot;Sunday&quot;, date: &quot;20&quot;, title: &quot;&quot;, color: .pink, month: &quot;Jun&quot;, List: [
        Name(id: UUID(), name: &quot;John&quot;, color: .pink),
        Name(id: UUID(), name: &quot;Rose&quot;, color: .pink),
        Name(id: UUID(), name: &quot;Mike&quot;, color: .pink),
    ]),
    Day(name: &quot;Monday&quot;, date: &quot;21&quot;, title: &quot;&quot;, color: .yellow, month: &quot;Jun&quot;, List: [
        Name(id: UUID(), name: &quot;Sara&quot;, color: .yellow),
        Name(id: UUID(), name: &quot;Jack&quot;,color: .yellow),
    ]),
    Day(name: &quot;Tuesday&quot;, date: &quot;22&quot;, title: &quot;&quot;, color: .blue, month: &quot;Jun&quot;, List: [
        Name(id: UUID(), name: &quot;Rachel&quot;,color: .blue),
    ]),
    Day(name: &quot;Wednesday&quot;, date: &quot;23&quot;, title: &quot;&quot;, color: .green, month: &quot;Jun&quot;, List: []),
    Day(name: &quot;Thursday&quot;, date: &quot;24&quot;, title: &quot;&quot;, color: .orange, month: &quot;Jun&quot;, List: []),
    Day(name: &quot;Friday&quot;, date: &quot;25&quot;, title: &quot;&quot;, color: .purple, month: &quot;Jun&quot;, List: []),
    Day(name: &quot;Saturday&quot;, date: &quot;26&quot;, title: &quot;&quot;, color: .red, month: &quot;Jun&quot;, List: []),
]

}
</code></pre>
<p>and View :</p>
<pre><code>import SwiftUI

struct CalendarList: View {

@EnvironmentObject var appState : AppState

var body: some View {
    
        NavigationView {
            
            List {
                
                ForEach(appState.allDays.indices, id:\.self) { index in
                    NavigationLink(destination: Text(appState.allDays[index].name) ) {
                        HStack(alignment: .top) {
                            RoundedRectangle(cornerRadius: 23)
                                .frame(width: 74, height: 74)
                                .foregroundColor(Color.blue)
                                .overlay(
                                    VStack {
                                        Text(appState.allDays[index].date)
                                            .font(.system(size: 35, weight: .regular))
                                            .foregroundColor(.white)
                                        Text(appState.allDays[index].month)
                                            .foregroundColor(.white)
                                    }
                                )
                                .padding(.trailing ,4)
                            
                            VStack(alignment: .leading, spacing: 5) {
                                Text(appState.allDays[index].name)
                                    .font(.system(size: 20, weight: .semibold))
                                Text(appState.allDays[index].title)
                                    .font(.subheadline)
                                    .foregroundColor(Color(#colorLiteral(red: 0.501960814, green: 0.501960814, blue: 0.501960814, alpha: 1)))
    
                                
                            }
                        }
                        .padding(.vertical ,6)
                    }
                }
                
            }
            .navigationTitle(&quot;Calendar&quot;)
        }
        .navigationViewStyle(StackNavigationViewStyle())
            
}
}

struct CalendarList_Previews: PreviewProvider {
    static var previews: some View {
        CalendarList()
        }
}
</code></pre>
","14871052","","","","","2021-06-20 19:48:58","How to make a Calendar List in swiftUI?","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"68057329","1","68058316","","2021-06-20 15:23:40","","2","900","<p>I have an <code>ObservableObject</code> which inside has two more <code>ObservableObjects</code>. Each of these two <code>ObservableObject</code> has one or more <code>@Published</code> properties inside. My solution works but I'm 100% sure there must be another way. I have to copy/ paste everything in order to make it work. I tried two put those two publishers in the View but then I need to pass a lot of params to the child view. Any ideas how to simplify this?</p>
<pre><code>class PackageService: ObservableObject {
    @Published var package: Package
    @Published var error: Error?
    
    @Published var distance: Double?
    @Published var expectedTravelTime: String?
    
    @Published var amount: Int = 0
    @Published var cost: Double = 0
    
    @Published var annotations = [MKPointAnnotation]()

    @Published var isCalculating = true
    @Published var route: MKRoute?
    
    var amountService = AmountService()
    var routeService = RouteService()
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(package: Package) {
        self.package = package
        routeService.calcDirections(source: package.source.toCLLocationCoordinate2D, destination: package.destination.toCLLocationCoordinate2D)
        
        routeService.$route.sink { [self] route in
            self.route = route
            
            amountService.calc(distance: route?.distance)
            calc(route: route)
        }
        .store(in: &amp;cancellables)
        
        routeService.$isCalculating.sink { [self] isCalculating in
            self.isCalculating = isCalculating
        }
        .store(in: &amp;cancellables)
        
        
        routeService.$error.sink { [self] error in
            self.error = error
        }
        .store(in: &amp;cancellables)
        
        amountService.$amount.sink { [self] amount in
            self.amount = amount
        }
        .store(in: &amp;cancellables)
        
        amountService.$cost.sink { [self] cost in
            self.cost = cost
        }
        .store(in: &amp;cancellables)
        
        amountService.$error.sink { [self] error in
            self.error = error
        }
        .store(in: &amp;cancellables)
    }
</code></pre>
","2738166","","","","","2021-06-21 12:39:33","SwiftUI/ Combine Listen to multiple publishers inside an ObservableObject","<ios><swift><xcode><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68058135","1","68058323","","2021-06-20 16:55:44","","1","278","<p>I have the following code</p>
<pre><code> private var codeState : AnyPublisher&lt;((Bool,Bool,Bool,Bool),(Bool,Bool)), Never&gt; {
    let publ1 =  Publishers.CombineLatest4(firstCodeAnyPublisher,secondCodeAnyPublisher,thirdCodeAnyPublisher,fourthCodeAnyPublisher)
    let pub2 = Publishers.CombineLatest(fifthCodeAnyPublisher, sixthCodeAnyPublisher)
    return publ1.combineLatest(pub2)
        .eraseToAnyPublisher()
}
</code></pre>
<p>This operation produces any publisher with two boolean tuple
How can I convert them to a publisher with one tuple the following</p>
<pre><code>AnyPublisher&lt;(Bool,Bool,Bool,Bool,Bool,Bool), Never&gt;
</code></pre>
","7438106","","12299030","","2021-06-20 17:06:26","2021-06-20 17:17:09","How to FlatMap a Publisher of two Tuples into a Publisher with one Tuple","<ios><tuples><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"68070052","1","68070333","","2021-06-21 14:48:21","","0","142","<p>I have two pages in my app TodayPage and CalendarList page.
I use <code>EnvironmentObject</code> wrapper to pass data between these two pages.
When TodayPage appears on <code>onAppear modifier</code> I <code>call a function to generate days of calendar</code> for me till now everything works fine when I add text to the list of TodayPage then go to the calendarList page and come back again to TodayPage all of the text that I addd to list are gone.I find out I can avoid lost of data by adding simple if to onAppear but I'm not sure this solution is right.</p>
<p>I have to upload lots of code ,Thanks for your help
( DataModel ) :</p>
<pre><code>import SwiftUI
import Foundation
import Combine

struct Day : Identifiable {

var id = UUID()
var name : String
var date : String
var month : String
var List : [Text1?]

}

struct Text1 : Identifiable , Hashable{

var id = UUID()
var name: String
var color: Color

}

class AppState : ObservableObject {

@Published var dataLoaded = false

@Published var allDays : [Day] = [.init(name : &quot;&quot;,date: &quot;&quot;,month: &quot;&quot;,List : [])]
    
func getDays(number: Int) -&gt; [Day] {
    let today = Date()
    let formatter = DateFormatter()
    return (0..&lt;number).map { index -&gt; Day in
        let date = Calendar.current.date(byAdding: .day, value: index, to: today) ?? Date()
        return Day(name: date.dayOfWeek(withFormatter: formatter) ?? &quot;&quot;, date: &quot;\(Calendar.current.component(.day, from: date))&quot;, month: date.nameOfMonth(withFormatter: formatter) ?? &quot;&quot;, List: [])
    }
    
}


}

extension Date {
    func dayOfWeek(withFormatter dateFormatter: DateFormatter) -&gt; String? {
        dateFormatter.dateFormat = &quot;EEEE&quot;
        return dateFormatter.string(from: self).capitalized
    }

func nameOfMonth(withFormatter dateFormatter: DateFormatter) -&gt; String? {
    dateFormatter.dateFormat = &quot;LLLL&quot;
    return dateFormatter.string(from: self).capitalized
}
}

class AddListViewViewModel : ObservableObject {
    @Published var textItemsToAdd : [Text1] = [.init(name: &quot;&quot;, color: .clear)] //start with one empty item


func saveToAppState(appState: AppState) {
    
appState.allDays[0].List.append(contentsOf: textItemsToAdd.filter { 

!$0.name.isEmpty })
}



func bindingForId(id: UUID) -&gt; Binding&lt;String&gt; {
    .init { () -&gt; String in
        self.textItemsToAdd.first(where: { $0.id == id })?.name ?? &quot;&quot;
    } set: { (newValue) in
        self.textItemsToAdd = self.textItemsToAdd.map {
            guard $0.id == id else {
                return $0
            }
            return .init(id: id, name: newValue, color: .clear)
        }
    }
}
}
</code></pre>
<p>List view :</p>
<pre><code>struct ListView: View {


@State private var showAddListView = false
@EnvironmentObject var appState : AppState
@Binding var dayList : [Text1?]
var title : String

var body: some View {
    NavigationView {
        VStack {
            ZStack {
                List(dayList,  id : \.self){ text in
                    Text(text?.name ?? &quot;&quot;)
                    
                }
                if showAddListView {
                    AddListView(showAddListView: $showAddListView)
                        .offset(y:-100)
                }
            }
        }
        .navigationTitle(title)
        .navigationBarItems(trailing:
                                Button(action: {showAddListView = true}) {
                                    Image(systemName: &quot;plus&quot;)
                                        .font(.title2)
                                }
        )
    }
    
}
}
</code></pre>
<p>pop up menu View(for adding text into the list)</p>
<pre><code>struct AddListView: View {

@Binding var showAddListView : Bool
@EnvironmentObject var appState : AppState
@StateObject private var viewModel = AddListViewViewModel()

var body: some View {
    ZStack {
        Title(addItem: { viewModel.textItemsToAdd.append(.init(name: &quot;&quot;, color: .clear)) })
        VStack {
            ScrollView {
                ForEach(viewModel.textItemsToAdd, id: \.id) { item in //note this is id: \.id and not \.self
                    PreAddTextField(textInTextField: viewModel.bindingForId(id: item.id))
                }
            }
        }
        .padding()
        .offset(y: 40)
        
        Buttons(showAddListView: $showAddListView, save: {
            viewModel.saveToAppState(appState: appState)
        })
        
    }
    .frame(width: 300, height: 200)
    .background(Color.white)
    .shadow(color: Color.black.opacity(0.3), radius: 10, x: 0, y: 10)
}
}

struct PreAddTextField: View {
@Binding var textInTextField : String

var body: some View {
    VStack {
        TextField(&quot;Enter text&quot;, text: $textInTextField)
    }
}
}

struct Buttons: View {
@Binding var showAddListView : Bool
var save : () -&gt; Void
var body: some View {
    VStack {
        HStack(spacing:100) {
            Button(action: {
                    showAddListView = false}) {
                Text(&quot;Cancel&quot;)
            }
            Button(action: {
                showAddListView = false
                save()
            }) {
                Text(&quot;Add&quot;)
            }
        }
    }
    .offset(y: 70)
}
}

struct Title: View {

var addItem : () -&gt; Void 

var body: some View {
    VStack {
        HStack {
            Text(&quot;Add Text to list&quot;)
                .font(.title2)
            Spacer()
            Button(action: {
                addItem()
            }) {
                Image(systemName: &quot;plus&quot;)
                    .font(.title2)
            }
        }
        .padding()
        Spacer()
    }
}
}
</code></pre>
<p>TodayPage View :</p>
<pre><code>struct TodayPage: View {
@EnvironmentObject var appState : AppState

var body: some View {
    ListView(dayList: $appState.allDays[0].List, title: &quot;Today&quot;)
        .onAppear {
        // To avoid data lost , we can use simple if below but I'm not sure it's a right solution
        //    if appState.dataLoaded == false {
               appState.allDays = appState.getDays(number: 365)
        //       appState.dataLoaded = true
        //    }
            
        }
}
}
</code></pre>
<p>CalendarListPage :</p>
<pre><code>struct CalendarList: View {

@EnvironmentObject var appState : AppState

var body: some View {
    
        NavigationView {
            
            List {
                
                ForEach(appState.allDays.indices, id:\.self) { index in
                    NavigationLink(destination: ListView(appState: _appState, dayList: $appState.allDays[index].List, title: appState.allDays[index].name).navigationBarTitleDisplayMode(.inline) ) {
                        HStack(alignment: .top) {
                            RoundedRectangle(cornerRadius: 23)
                                .frame(width: 74, height: 74)
                                .foregroundColor(Color.blue)
                                .overlay(
                                    VStack {
                                        Text(appState.allDays[index].date)
                                            .font(.system(size: 35, weight: .regular))
                                            .foregroundColor(.white)
                                        Text(appState.allDays[index].month)
                                            .foregroundColor(.white)
                                    }
                                )
                                .padding(.trailing ,4)
                            
                            VStack(alignment: .leading, spacing: 5) {
                                Text(appState.allDays[index].name)
                                    .font(.system(size: 20, weight: .semibold))
                                
                            }
                        }
                        .padding(.vertical ,6)
                    }
                }
                
            }
            .navigationTitle(&quot;Calendar&quot;)
        }.onAppear {
          
        }
        .navigationViewStyle(StackNavigationViewStyle())
            
}
}
</code></pre>
<p>and finally TabBar :</p>
<pre><code>struct TabBar: View {
var body: some View {
    let appState = AppState()
    
    TabView {
        TodayPage().tabItem {
            Image(systemName: &quot;info.circle&quot;)
            Text(&quot;Today&quot;)
        }
        CalendarList().tabItem {
            Image(systemName: &quot;square.fill.text.grid.1x2&quot;)
            Text(&quot;Calendar&quot;)
        }
    }
    .environmentObject(appState)
}
}
</code></pre>
","14871052","","","","","2021-06-21 15:06:22","Why do I lose Data here?(SwiftUI)","<swift><swiftui>","1","5","","","","CC BY-SA 4.0"
"68082774","1","68083163","","2021-06-22 11:30:48","","1","236","<p>Hi first off I'm very new to swift and programing (coming from design field).
I'm trying to update doesNotificationsExist based on posts.count</p>
<p>I'm getting true inside the <code>Api().getPosts {}</code>
Where I print the following:</p>
<pre><code>print(&quot;Api().getPosts&quot;)
print(doesNotificationExist)
</code></pre>
<p>but outside (in the <code>loadData() {}</code>) I still get false and not the @Publihed var doesNotificationExist:Bool = false doesn't update.</p>
<p>Please help me out, I would really appreciate some guidance to what I'm doing wrong and what I need to do.</p>
<p>Here is my code:</p>
<pre><code>import SwiftUI
import Combine

public class DataStore: ObservableObject {
    @Published var posts: [Post] = []
    @Published var doesNotificationExist:Bool = false
    
    init() {
        loadData()
        startApiWatch()
    }
    
    func loadData() {
        
        Api().getPosts { [self] (posts) in
            self.posts = posts

            if posts.count &gt;= 1 {
                doesNotificationExist = true
            }
            else {
                doesNotificationExist = false
            }
            
            print(&quot;Api().getPosts&quot;)
            print(doesNotificationExist)
        }
        print(&quot;loadData&quot;)
        print(doesNotificationExist)
    }
    
    func startApiWatch() {
        Timer.scheduledTimer(withTimeInterval: 60, repeats: true) {_ in
            self.loadData()
            
        }
    }
</code></pre>
<p>View where I'm trying to set an image based on <code>store.doesNotificationsExist</code></p>
<p>StatusBarController:</p>
<pre><code>import AppKit
import SwiftUI

class StatusBarController {
    private var statusBar: NSStatusBar
    private var statusItem: NSStatusItem
    private var popover: NSPopover
    
    @ObservedObject var store = DataStore()
    
    init(_ popover: NSPopover)
    {
        self.popover = popover
        statusBar = NSStatusBar.init()
        statusItem = statusBar.statusItem(withLength: 28.0)
        
        statusItem.button?.action = #selector(togglePopover(sender:))
        statusItem.button?.target = self
    
        if let statusBarButton = statusItem.button {
            let itemImage = NSImage(named: store.doesNotificationExist ? &quot;StatusItemImageNotification&quot; : &quot;StatusItemImage&quot;)
            statusBarButton.image = itemImage
            statusBarButton.image?.size = NSSize(width: 18.0, height: 18.0)
            statusBarButton.image?.isTemplate = true
            statusBarButton.action = #selector(togglePopover(sender:))
            statusBarButton.target = self
        }
        
    }
`Other none relevant code for the question`

 }

</code></pre>
","8972143","","8972143","","2021-06-23 09:02:51","2021-06-23 09:02:51","Trying to set @published bool to true based on results from an API call","<swift><swiftui><observableobject>","1","0","","","","CC BY-SA 4.0"
"68086634","1","68087514","","2021-06-22 15:37:29","","1","90","<p>I have a subscriber to an @Published text field. I add the subscriber through the init() function of my class.</p>
<p>The map of this subscriber scans all users in Firebase and checks for the &quot;email&quot; field. If the email inputted by the user is in one of these fields, then I set valid to false (as the email is already in use).</p>
<p>However, when I run this code, the second print line is executed first, with the default value. Then, after some time, the print(&quot;This email is valid&quot;) line is run.</p>
<p>I believe this has to do with the fact that a Firebase call is an asynchronous task.</p>
<p>How can I solve this so that the return value returns the result of the Firebase call? I'm using Xcode Version 12.5.1.</p>
<p>Also, i'm not sure if this is the best way to check if an email is already in use, but it's the only solution I could find :)</p>
<p>Code:</p>
<pre><code>func addEmailSubscriber() {
        
        $email
            .debounce(for: .seconds(1.0), scheduler: DispatchQueue.main)
            .map { email -&gt; Bool in
                
                var valid: Bool = false
                
                Firestore.firestore()
                    .collection(&quot;users&quot;)
                    .whereField(&quot;email&quot;, isEqualTo: email)
                    .getDocuments { (snapshot, err) in
                        
                        guard let snapshot = snapshot else { print(&quot;Error getting snapshot&quot;); return }
                        
                        if err != nil {
                            print(&quot;Error occured&quot;)
                            return
                        }
                        
                        if snapshot.documents.count == 0 {
                            print(&quot;This email is valid&quot;) // This is successfully printed after some time
                            valid = true
                            return
                        }
                    }
                
                print(valid) // This gets printed first, with the value of &quot;false&quot;
                return valid
                
            }
            .sink { [weak self] isValid in
                self?.emailIsValid = isValid
                
            }
            .store(in: &amp;cancellabes)
        
    }
</code></pre>
<p>Log:
<a href=""https://i.stack.imgur.com/5d8P6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5d8P6.png"" alt=""enter image description here"" /></a></p>
","15847296","","209103","","2021-06-22 16:28:48","2021-06-23 01:39:25","Subscriber returning value before Firebase returns a value in SwiftUI","<swift><firebase><google-cloud-firestore><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68109898","1","68110210","","2021-06-24 05:04:24","","-3","155","<h2>Edited</h2>
<h3>Having multiple data sources for an app</h3>
<p>What is the best approach to <code>combine</code> all data sources together in one class and add it as one environment object, keeping in mind data might change, therefore objects update the views?</p>
<p>What are the appropriate Bindings to use for:</p>
<p><strong>Services</strong> (API fetches): @Published?</p>
<p><strong>Computed variables</strong>: Lazy var?</p>
<p>Please refer to the diagram as an example. Thanks.</p>
<p>These questions were good references:</p>
<p><a href=""https://stackoverflow.com/questions/58203531/an-equivalent-to-computed-properties-using-published-in-swift-combine"">An equivalent to computed properties using @Published in Swift Combine?</a></p>
<p><a href=""https://medium.com/genetec-tech/property-wrappers-in-swift-5-1-the-missing-published-implementation-1a466ebcf660"" rel=""nofollow noreferrer"">https://medium.com/genetec-tech/property-wrappers-in-swift-5-1-the-missing-published-implementation-1a466ebcf660</a></p>
<h3>diagram</h3>
<p><a href=""https://i.stack.imgur.com/5c6bk.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5c6bk.jpg"" alt=""enter image description here"" /></a></p>
","14395202","","14395202","","2021-06-24 13:46:34","2021-06-24 13:46:34","MVVM in SwiftUI and the appropriate Bindings","<swift><core-data><swiftui><combine>","1","1","","2021-06-24 05:45:27","","CC BY-SA 4.0"
"68129303","1","68133969","","2021-06-25 10:10:15","","0","450","<p>I have network request that triggers every last cell in switui appearas. Sometimes if user scrolls fast enough down -&gt; up -&gt; request will trigger before first one finishes. Without combine or reactive approach I have completion block and bool value to handle this:</p>
<pre><code>public func load() {
        guard !isLoadingPosts else { return }
        isLoadingPosts = true
        postsDataProvider.loadMorePosts { _ in
            self.isLoadingPosts = false
        }
    }
</code></pre>
<p>I was wondering if with combine this can be resolved more elegantly, without the need to use bool value. For example execute request only if previous has finished?</p>
","744270","","560942","","2021-06-25 15:36:30","2021-06-25 23:52:44","iOS Combine Start new request only if previous has finished","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"68145401","1","68146433","","2021-06-26 18:51:51","","0","1523","<p><strong>StepsEntity is a core data entity</strong></p>
<p>Receiving the following error when attempting to display a string value in a TextField: &quot;Cannot convert value of type 'Published&lt;[StepsEntity]&gt;.Publisher' to expected argument type 'Binding'&quot;</p>
<p>I know this is because StepsEntity in my core data model is @Published. @Published works great here as it allows all the data to be updated neatly. How can I display an @Published in a TextField?</p>
<p>Below is the piece where I am receiving the error:</p>
<pre><code>List {
            VStack(alignment: .center) {
                if let recipeSteps = (vm.recipes[vm.getRecordsCount() - 1].steps?.allObjects as? [StepsEntity])?.sorted { $0.stepNumber &lt; $1.stepNumber } {
                    
                    if (textFieldCount == 1) {
                        //do nothing
                    } else if (textFieldCount &gt; 1) {
                        ForEach(recipeSteps, id: \.stepNumber) { index in
                            HStack {
                               
                                Text(String(index.stepNumber) + &quot;.&quot;).bold()
                                TextField(&quot;&quot;, text: vm.$recipeSteps) //This is where the error is seen
                                
                            }
                        }.onDelete(perform: { index in
                            self.vm.deleteRecipeSteps(at: index, from: vm.recipes[vm.getRecordsCount() - 1])
                            })
                    }
                
                }
            }
</code></pre>
<p>vm.recipeSteps refers to my CoreDataRelationshipViewModel, which is where all core data functions are handled. this is declared in the view struct as:</p>
<pre><code>@StateObject var vm = CoreDataRelationshipViewModel()
</code></pre>
<p>Here is a snippet from the CoreDataRelationshipViewModel class:</p>
<pre><code>class CoreDataRelationshipViewModel: ObservableObject {

let manager = CoreDataManager.instance
@Published var recipes: [RecipeEntity] = []
@Published var recipeSteps: [StepsEntity] = []

init() {
    getRecipes()
}

func getRecipes() { ////more functions for retrieving, deleting, etc. in this section
</code></pre>
<p>I have tried converting the Published var to a binding but no luck:</p>
<pre><code>TextField(&quot;&quot;, text: Binding(vm.$recipeSteps)!)
</code></pre>
<p>I have also tried referencing the recipeSteps declared in the if let statement within the list, but that does not work either.</p>
<p>I have been at it for a few days, and I think I have exhausted all options. Open to all ideas here. Maybe I need to rebuild my model?</p>
<p>Thoughts?</p>
<p>--Edits--</p>
<p>Upper portion of struct, where variables are created:</p>
<pre><code>struct AddItemView: View {

@StateObject var viewModel = ViewModel()
@State var frameDimensions: CGFloat = 0
@State var imageButtonText: String = &quot;Click To Add Image&quot;
@State var imageToUpload: Data

@StateObject var vm = CoreDataRelationshipViewModel()
@Environment(\.presentationMode) var presentationMode
@State var stepInfo: String = &quot;&quot;
@State var textFieldCount: Int = 1
@State var stepNumber: [Int]
@State var recordsCount = 1
@State var errorText = &quot;&quot;
@State var stepErrorColor = Color.white.opacity(0)
@State var nameErrorColor = Color.white.opacity(0)

var body: some View {
    ZStack {
        HStack {
</code></pre>
","12053724","","12053724","","2021-06-26 19:22:51","2021-06-27 11:49:25","Cannot convert value of type 'Published<[StepsEntity]>.Publisher' to expected argument type 'Binding<String>'","<swift><swiftui><binding><combine>","2","3","1","","","CC BY-SA 4.0"
"68160383","1","68171854","","2021-06-28 08:54:32","","1","229","<p>I am developing an IOS app and as per the requirement I need to retry all failed api for 3 times with 3 seconds delay. In order to do that I have added an extension to a Publisher as follows, but there is one small problem with this code, after the last attempt if I get a failed response then it takes 3 seconds to execute the expected failure code. I need to show failure message as soon as last attempt fails, is there any way to handle this?</p>
<pre><code>public extension Publisher {
    func retryWithDelay&lt;S&gt;(
        retries: Int,
        delay: S.SchedulerTimeType.Stride,
        scheduler: S
    ) -&gt; AnyPublisher&lt;Output, Failure&gt; where S: Scheduler {
        
        self
            .delayIfFailure(for: delay, scheduler: scheduler)
            .retry(retries)
            .eraseToAnyPublisher()
    }

    private func delayIfFailure&lt;S&gt;(
        for delay: S.SchedulerTimeType.Stride,
        scheduler: S
    ) -&gt; AnyPublisher&lt;Output, Failure&gt; where S: Scheduler {
        self.catch { error in
            Future { completion in
                scheduler.schedule(after: scheduler.now.advanced(by: delay)) {
                    completion(.failure(error))
                }
            }
        }
        .eraseToAnyPublisher()
    }
}
</code></pre>
","5068344","","968155","","2021-06-28 13:09:21","2021-06-29 11:44:56","How to retry failed web service calls with time delay in ios app","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"68187173","1","68190530","","2021-06-30 00:39:20","","1","194","<p>I am having a username textField in swiftUI. I am trying to validate input with the help of publishers.</p>
<p>Here is my code:</p>
<pre><code>View

struct UserView: View {
    @StateObject private var userViewModel = UserViewModel()

    init(){
        UITextField.appearance().semanticContentAttribute = .forceRightToLeft
        UITextField.appearance().keyboardAppearance = .dark
    
    }

    var body: some View {
        SecureField(&quot;&quot;, text: $userViewModel.passwordText)
        Text(userViewModel.passwordError).foregroundColor(.red)
            .frame(width: 264, alignment: .trailing)
    }
}
</code></pre>
<p>The View Model</p>
<pre><code>ViewModel

final class UserViewModel: ObservableObject {

    private var cancellables = Set&lt;AnyCancellable&gt;()
    @Published var userText: String = &quot;&quot;
    @Published var userTextError = &quot;&quot;

    private var usernamevalidation: AnyPublisher&lt;(username:String, isValid: Bool), Never&gt; {
        return $userText
            .dropFirst()
            .map{(username:$0, isValid: !$0.isEmpty)}
            .eraseToAnyPublisher()
    }

    private var usernamevalidated: AnyPublisher&lt;Bool,Never&gt; {
        return usernamevalidation
            .filter{$0.isValid}
            .map{$0.username.isValidUserName()}
            .eraseToAnyPublisher()
    }


    init(){
        usernamevalidation.receive(on: RunLoop.main)
            .map{$0.isValid ? &quot;&quot;: &quot;Emptyusername &quot;}
            .assign(to: \.userTextError, on: self)
            .store(in: &amp;cancellables)
        usernamevalidated.receive(on: RunLoop.main)
            .map{$0 ? &quot;&quot; : &quot;wrong username &quot;}
            .assign(to: \.userTextError, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>Extension</p>
<pre><code> extension String {

     func isValidUserName() -&gt; Bool {
         let usernameRegex = &quot;^[a-zA-Z0-9_-]*$&quot;
         let usernamepred = NSPredicate(format:&quot;SELF MATCHES %@&quot;, usernameRegex)
         return usernamepred.evaluate(with: self)
   }
}
</code></pre>
<p>In the usernamevalidated in the init() block in the ViewModel I am assigning the error to userTextError property which should be reflected in the textview. This should happens if a special character such as @ or % .. etc are entered. What happens is that sometimes the error appears in red and other no even though I try to print value of string after map operator i can see the string in printing fine. It is just the error is sometimes reflected in the view and sometimes not. Am I missing something or doing something fundamentally wrong</p>
","7438106","","7948372","","2021-06-30 07:52:20","2021-06-30 07:52:20","Why my views are not Rendered in SwiftUI even though the Publisher emits a value","<swiftui><combine><publisher>","3","0","","","","CC BY-SA 4.0"
"68240150","1","68240945","","2021-07-03 21:41:24","","1","507","<p>Being a Swift newbie I am trying to download and parse a CSV file using the code:</p>
<pre><code>URLSession.shared.dataTaskPublisher(for: url)
    .tryMap(handleOutput)
    .sink { completion in
    } receiveValue: { csvWords in

        let lines = csvWords.split(separator: &quot;\n&quot;)
        for line in lines {
            let columns = line.split(separator: &quot;,&quot;)
            for column in columns {
                print(&quot;column: \(column)&quot;)
            }
        }
</code></pre>
<p>however I get the syntax error:</p>
<blockquote>
<p>Cannot convert value of type 'String' to expected argument type 'Data.Element' (aka 'UInt8')</p>
</blockquote>
<p><a href=""https://i.stack.imgur.com/mAZKB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mAZKB.png"" alt=""Xcode"" /></a></p>
<p>Please help me to understand, what is happening.</p>
<p>What value is returned by the <a href=""https://developer.apple.com/documentation/combine/fail/sink(receivevalue:)"" rel=""nofollow noreferrer"">receiveValue</a>, isn't it the remote file content as string?</p>
<p><strong>UPDATE:</strong></p>
<p>Here is the missing method</p>
<pre><code>func handleOutput(output: URLSession.DataTaskPublisher.Output) throws -&gt; Data {
    guard
        // as? means &quot;this might be nil&quot;
        let response = output.response as? HTTPURLResponse,
        response.statusCode &gt;= 200,
        response.statusCode &lt; 300
        else {
            throw URLError(.badServerResponse)
        }
    
    return output.data
}
</code></pre>
","165071","","165071","","2021-07-04 07:14:01","2021-07-04 16:21:58","URLSession.shared.dataTaskPublisher - how to convert received value to string?","<ios><swift><string><csv><combine>","1","7","","","","CC BY-SA 4.0"
"68242439","1","68334001","","2021-07-04 07:01:59","","4","795","<p><strong>Situation</strong></p>
<p>Implement a multi window application, where each window has its own state.</p>
<p><strong>Example</strong></p>
<p>Here is an example (<a href=""https://github.com/ondrej-kvasnovsky/swiftui-multi-window-menu"" rel=""nofollow noreferrer"">on github</a>) to showcase the question:</p>
<pre><code>import SwiftUI

@main
struct multi_window_menuApp: App {

  var body: some Scene {
    WindowGroup {
      ContentView()
    }.commands {
      MenuCommands()
    }
  }
}

struct ContentView: View {
  @StateObject var viewModel: ViewModel  = ViewModel()
  
  var body: some View {
    TextField(&quot;&quot;, text: $viewModel.inputText)
      .disabled(true)
      .padding()
  }
}

public class ViewModel: ObservableObject {
  
  @Published var inputText: String = &quot;&quot; {
    didSet {
      print(&quot;content was updated...&quot;)
    }
  }
}
</code></pre>
<p><strong>Question</strong></p>
<p>How should we programmatically figure out what is the currently selected view  so we can update the state when the menu command is about to finish and update the state in the view model?</p>
<pre><code>import Foundation
import SwiftUI
import Combine

struct MenuCommands: Commands {
  
  var body: some Commands {
    CommandGroup(after: CommandGroupPlacement.newItem, addition: {
      Divider()
      Button(action: {
        let dialog = NSOpenPanel();
        
        dialog.title = &quot;Choose a file&quot;;
        dialog.showsResizeIndicator = true;
        dialog.showsHiddenFiles = false;
        dialog.allowsMultipleSelection = false;
        dialog.canChooseDirectories = false;
        
        if (dialog.runModal() ==  NSApplication.ModalResponse.OK) {
          let result = dialog.url
          if (result != nil) {
            let path: String = result!.path
            do {
              let string = try String(contentsOf: URL(fileURLWithPath: path), encoding: .utf8)
              print(string)
              // how to get access to the currently active view model to update the inputText variable?
              // viewModel.inputText = string
            }
            catch {
              print(&quot;Error \(error)&quot;)
            }
          }
        } else {
          return
        }
      }, label: {
        Text(&quot;Open File&quot;)
      })
      .keyboardShortcut(&quot;O&quot;, modifiers: .command)
    })
  }
}
</code></pre>
<p>Links that might be useful to figure this out:</p>
<ul>
<li><a href=""http://www.gfrigerio.com/build-a-macos-app-with-swiftui/"" rel=""nofollow noreferrer"">http://www.gfrigerio.com/build-a-macos-app-with-swiftui/</a></li>
<li><a href=""https://troz.net/post/2021/swiftui_mac_menus/"" rel=""nofollow noreferrer"">https://troz.net/post/2021/swiftui_mac_menus/</a></li>
<li><a href=""https://onmyway133.com/posts/how-to-manage-windowgroup-in-swiftui-for-macos/"" rel=""nofollow noreferrer"">https://onmyway133.com/posts/how-to-manage-windowgroup-in-swiftui-for-macos/</a></li>
</ul>
","931428","","931428","","2021-07-05 05:15:57","2022-07-12 14:56:40","How to implement multi window with menu commands in SwiftUI for macOS?","<swift><macos><swiftui>","2","6","1","","","CC BY-SA 4.0"
"68277878","1","68277944","","2021-07-06 22:10:51","","0","51","<p>I wrote the following in swift and expected it to just work:</p>
<pre class=""lang-swift prettyprint-override""><code>extension Array where Element : AnyCancellable
{
    mutating func add( event : NSNotification.Name, handler: @escaping () -&gt; () )
    {
        let cancellation_token : AnyCancellable = event.sink( handler: handler)
        self.append(cancellation_token)        // error here
    }
}
</code></pre>
<p>And I don't understand why it doesn't - it says &quot;<strong>no exact matches in call to append</strong>&quot;.
And if I comment out the append line, it compiles.
With this code however,</p>
<pre class=""lang-swift prettyprint-override""><code>extension Array where Element : AnyCancellable
{
    mutating func add( event : NSNotification.Name, handler: @escaping () -&gt; () )
    {
        let cancellation_token : Element = event.sink( handler: handler)   // error here
        self.append(cancellation_token)
    }
}
</code></pre>
<p>the assignment fails with a &quot;<strong>cannot convert value of type 'AnyCancellable' to specified type 'Element'</strong>&quot;.</p>
<p>So it's like the where clause is doing nothing?<br />
What am I doing wrong?</p>
","2446374","","-1","","2021-07-07 17:28:34","2021-07-08 09:00:14","How do I append to array as an extension in swift","<swift>","1","1","","","","CC BY-SA 4.0"
"68282016","1","68316125","","2021-07-07 07:49:12","","2","150","<p>I want to play stereo sounds using Audiounit using AUGraph in ios but the problem that I am facing is &quot;<strong>My sound is playing fast when i want to play in stereo mode on 48000 samplings rate</strong>&quot;.But it works fine for mono sounds(Single channel).</p>
<p>Here is my code.</p>
<pre><code>import Combine
import AudioUnit
import Foundation
import AudioToolbox
import AVFoundation

@objc protocol AudioUnitDataChannelPlayoutDelegate
{
    func performInput(
        _ ioActionFlags: UnsafeMutablePointer&lt;AudioUnitRenderActionFlags&gt;,
        inTimeStamp: UnsafePointer&lt;AudioTimeStamp&gt;,
        inBufNumber: UInt32,
        inNumberFrames: UInt32,
        ioData: UnsafeMutablePointer&lt;AudioBufferList&gt; ) -&gt; OSStatus
}

private let AudioController_InputCallback: AURenderCallback =
{
    (
        inRefCon,
        ioActionFlags,
        inTimeStamp,
        inBufNumber,
        inNumberFrames,
        ioData
    )-&gt; OSStatus in
    
    let delegate = unsafeBitCast(inRefCon, to: AudioUnitDataChannelPlayoutDelegate.self)
    
    let result = delegate.performInput(ioActionFlags,
                                       inTimeStamp: inTimeStamp,
                                       inBufNumber: inBufNumber,
                                       inNumberFrames: inNumberFrames,
                                       ioData: ioData!)
    return noErr
}

class AudioUnitDataChannelPlayout
{
    
    private static var instance: AudioUnitDataChannelPlayout?
    
    public class var sharedInstance: AudioUnitDataChannelPlayout
    {
        if instance == nil
        {
            instance = AudioUnitDataChannelPlayout()
        }
        return instance!
    }
    
    static let audioBuffer = CircularBuffer(size: 25003904)
   
    let kInputBus: UInt32 = 1
    let kOutputBus: UInt32 = 0
    var status: OSStatus?
    var flag: UInt32 = 1
    
    var ioFormat = CAStreamBasicDescription(
        sampleRate: Double(48000.0),
        numChannels: 2,
        pcmf: .int16,
        isInterleaved: true )
    
    var timePitchFormat = CAStreamBasicDescription(
        sampleRate: Double(48000.0),
        numChannels: 1,  // if chnges to 2 nothing happens
        pcmf: .float32,
        isInterleaved: false ) // if change to true then error occurs
    
    var graph: AUGraph?
    var firstConverterNode: AUNode = 0
    var timePitchNode: AUNode = 0
    var secondConverterNode: AUNode = 0
    var outputNode: AUNode = 0
    var firstConverterUnit: AudioUnit?
    var timePitchUnit: AudioUnit?
    var secondConverterUnit: AudioUnit?
    var outputUnit: AudioUnit?
    
    
    init()
    {
        configureAudioSession()
        setupRecordingUnit()
        playAudio()
    }
    
    private func setupRecordingUnit()
    {
        check(error: NewAUGraph(&amp;graph), description: &quot;Failed to create AUGraph&quot;)
        
        var output_desc = AudioComponentDescription(
            componentType: OSType(kAudioUnitType_Output),
            componentSubType: OSType(kAudioUnitSubType_VoiceProcessingIO),
            componentManufacturer: OSType(kAudioUnitManufacturer_Apple),
            componentFlags: 0,
            componentFlagsMask: 0 )
        
        var converter_desc = AudioComponentDescription(
            componentType: OSType(kAudioUnitType_FormatConverter),
            componentSubType: OSType(kAudioUnitSubType_AUConverter),
            componentManufacturer: OSType(kAudioUnitManufacturer_Apple),
            componentFlags: 0,
            componentFlagsMask: 0 )
        
        var varispeed_desc = AudioComponentDescription(
            componentType: OSType(kAudioUnitType_FormatConverter),
            componentSubType: OSType(kAudioUnitSubType_NewTimePitch),
            componentManufacturer: OSType(kAudioUnitManufacturer_Apple),
            componentFlags: 0,
            componentFlagsMask: 0 )
        
        check(error: AUGraphAddNode(graph!, &amp;output_desc, &amp;outputNode), description: &quot;Failed to Add Node Audio Node&quot;)
        
        check(error: AUGraphAddNode(graph!, &amp;converter_desc, &amp;firstConverterNode), description: &quot;Failed to Add converter node&quot;)
        check(error: AUGraphAddNode(graph!, &amp;varispeed_desc, &amp;timePitchNode), description: &quot;Failed to Add Node varispeed Node&quot;)
        check(error: AUGraphAddNode(graph!, &amp;converter_desc, &amp;secondConverterNode), description: &quot;Failed to Add converter node&quot;)
        
        check(error: AUGraphOpen(graph!), description: &quot;Failed to open AUGraph&quot;)
        
        check(error: AUGraphNodeInfo(graph!, outputNode, nil, &amp;outputUnit), description: &quot;Failed to get Info of audioUnit&quot;)
        check(error: AUGraphNodeInfo(graph!, firstConverterNode, nil, &amp;firstConverterUnit), description: &quot;Failed to get Info of converterUnit&quot;)
        check(error: AUGraphNodeInfo(graph!, timePitchNode, nil, &amp;timePitchUnit), description: &quot;Failed to get Info of VarispeedUnit&quot;)
        check(error: AUGraphNodeInfo(graph!, secondConverterNode, nil, &amp;secondConverterUnit), description: &quot;Failed to get Info of converterUnit&quot;)
        
        check(error: AudioUnitSetProperty(outputUnit!,kAudioOutputUnitProperty_EnableIO,kAudioUnitScope_Output,kOutputBus,&amp;flag,MemoryLayoutStride.SizeOf32(flag)),
              description: &quot;Failed to set enable IO for Playing.&quot;)
        
        check(error: AudioUnitSetProperty(firstConverterUnit!, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, kOutputBus, &amp;ioFormat, MemoryLayoutStride.SizeOf32(ioFormat)), description: &quot;Failed to set property of firstConverter Unit&quot;)
        
        check(error: AudioUnitSetProperty(firstConverterUnit!, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, kOutputBus, &amp;timePitchFormat, MemoryLayoutStride.SizeOf32(timePitchFormat)), description: &quot;Failed to set property of firstConverter Unit 1&quot;)
        
        check(error: AudioUnitSetProperty(timePitchUnit!, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, kOutputBus, &amp;timePitchFormat, MemoryLayoutStride.SizeOf32(timePitchFormat)), description: &quot;Failed to set property of varispeed unit&quot;)
        
        check(error: AudioUnitSetProperty(timePitchUnit!, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, kOutputBus, &amp;timePitchFormat, MemoryLayoutStride.SizeOf32(timePitchFormat)), description: &quot;Failed to set property of Varispeed Unit 1&quot;)
        
        check(error: AudioUnitSetProperty(secondConverterUnit!, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, kOutputBus, &amp;timePitchFormat, MemoryLayoutStride.SizeOf32(timePitchFormat)), description: &quot;Failed to set property of firstConverter Unit&quot;)
        
        check(error: AudioUnitSetProperty(secondConverterUnit!, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, kOutputBus, &amp;ioFormat, MemoryLayoutStride.SizeOf32(ioFormat)), description: &quot;Failed to set property of firstConverter Unit 1&quot;)
        
        
        check(error: AudioUnitSetProperty(outputUnit!, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, kOutputBus, &amp;ioFormat, MemoryLayoutStride.SizeOf32(ioFormat)), description: &quot;Failed to set property of Output Unit&quot;)
        AUGraphConnectNodeInput(graph!, firstConverterNode, 0, timePitchNode, 0)
        AUGraphConnectNodeInput(graph!, timePitchNode, 0, secondConverterNode, 0)
        AUGraphConnectNodeInput(graph!, secondConverterNode, 0, outputNode, 0)
        
        
        var recordingCallback = AURenderCallbackStruct(
            inputProc: AudioController_InputCallback,
            inputProcRefCon: UnsafeMutableRawPointer(Unmanaged.passUnretained(self).toOpaque()) )
        
        check(error: AUGraphSetNodeInputCallback(graph!, firstConverterNode, 0, &amp;recordingCallback), description: &quot;Failed to set inPutCallback&quot;)
        
        AUGraphInitialize(graph!)
    }
    
    func check(error: OSStatus, description: String)
    {
        if error != noErr
        {
            fatalError(&quot;\(description) : \(error)&quot;)
        }
    }
    
    func startSpeakerUnit()
    {
        check(error: AUGraphStart(graph!), description: &quot;Error Failed to start AUGraph&quot;)
        print(&quot;initializing the speaker unit&quot;)
    }
    
    func stopSpeakerUnit()
    {
        check(error: AUGraphStop(graph!), description: &quot;Error Failed to stop AUGraph&quot;)
        AudioUnitDataChannelPlayout.instance = nil
    }

    private func playAudio()
    {
        AudioUnitSetParameter(self.timePitchUnit!, kNewTimePitchParam_Rate, kAudioUnitScope_Global,0, AudioUnitParameterValue(1.0), 0)
    }
    
}

extension AudioUnitDataChannelPlayout: AudioUnitDataChannelPlayoutDelegate
{
    func performInput(_ ioActionFlags: UnsafeMutablePointer&lt;AudioUnitRenderActionFlags&gt;, inTimeStamp: UnsafePointer&lt;AudioTimeStamp&gt;, inBufNumber: UInt32, inNumberFrames: UInt32, ioData: UnsafeMutablePointer&lt;AudioBufferList&gt;) -&gt; OSStatus
    {
        
        let playbackPointer = ioData[0].mBuffers
        
        print(&quot;SECOND POINTER: \(playbackPointer)&quot;)

        let bytesToCopy = ioData[0].mBuffers.mDataByteSize

        
        var bufferTail = AudioUnitDataChannelPlayout.audioBuffer.getTail()
        
        print(AudioUnitDataChannelPlayout.audioBuffer.getAvailableBytes())

        let bytesToWrite = min(bytesToCopy, AudioUnitDataChannelPlayout.audioBuffer.getAvailableBytes())
        
        memcpy(playbackPointer.mData, bufferTail, Int(bytesToWrite))
        
        print(&quot;playing...\(bytesToCopy)&quot;)
        AudioUnitDataChannelPlayout.audioBuffer.consume(samples: bytesToWrite)
        
        return noErr
    }
    
}
</code></pre>
<p>In this class, I am just playing wave files of stereo sounds. Any help in this regard will be highly appreciated.</p>
","16396755","","","","","2021-07-09 11:38:58","Play stereo sound in AudioUnit using AUGraph in IOS","<ios><swift><audiounit><playing><augraph>","1","6","","","","CC BY-SA 4.0"
"68335835","1","68337422","","2021-07-11 11:38:26","","0","222","<p>I set my WidgetView using value of UserDefaults.
To share data between widget and core app, I set appGroup already.</p>
<pre class=""lang-swift prettyprint-override""><code>let appGroupId = &quot;group.com.myAppGroupId&quot;
Text(UserDefaults(suiteName: appGroupId)!.object(forKey: &quot;githubId&quot;) as? String ?? &quot;??&quot;)
</code></pre>
<p>It shows well in preview, but when I add it to home screen, it cannot read property. And in same condition, when I rebuild app (cmd+r), widget in the home screen read value of UserDefaults well.</p>
<p>I cannot guess the reason.</p>
<p>+++++ Add more code</p>
<p>Actually, I defined my <code>githubId</code> as UserDefaults like this using property wrapper.</p>
<pre class=""lang-swift prettyprint-override""><code>extension UserDefaults {
    enum Key: String {
        case githubId
    }
  
    static let shared: UserDefaults = {
        let appGroupId = &quot;group.com.myAppGroupId&quot;
        return UserDefaults(suiteName: appGroupId)!
    }()

    @UserDefault(key: .githubId)
    static var githubId: String?
}
</code></pre>
<p>And my property wrapper is seems like this.</p>
<pre class=""lang-swift prettyprint-override""><code>@propertyWrapper
struct UserDefault&lt;Value&gt; {
    let key: String
    let defaultValue: Value
    var container: UserDefaults = .shared
    private let publisher = PassthroughSubject&lt;Value, Never&gt;()
    
    var wrappedValue: Value {
        get {
            return container.object(forKey: key) as? Value ?? defaultValue
        }
        set {
            if let optional = newValue as? AnyOptional, optional.isNil {
                container.removeObject(forKey: key)
            } else {
                container.set(newValue, forKey: key) //this is where I set my value
            }
            publisher.send(newValue)
        }
    }

    var projectedValue: AnyPublisher&lt;Value, Never&gt; {
        return publisher.eraseToAnyPublisher()
    }
}

extension UserDefault where Value: ExpressibleByNilLiteral {
    init(key: UserDefaults.Key, _ container: UserDefaults = .shared) {
        self.init(key: key.rawValue, defaultValue: nil, container: container)
    }
}
</code></pre>
<p>In <code>LoginViewModel</code> , I set githubId value.</p>
<pre class=""lang-swift prettyprint-override""><code>class LoginViewModel: ObservableObject {
    @Published var githubId = UserDefaults.githubId ?? &quot;&quot;
    private var subscriptions = Set&lt;AnyCancellable&gt;()
    
    init() {
        $githubId
            .sink { githubId in
                UserDefaults.githubId = githubId
            }
            .store(in: &amp;subscriptions)
    }
}
</code></pre>
<p>Finally I use this value in my app, and widget extension using <code>UserDefaults.githubId</code></p>
<p>The code I wrote above ( <code>UserDefaults(suiteName: appGroupId)!.object(forKey: &quot;githubId&quot;)</code> ) long version of  <code>UserDefaults.githubId</code> .</p>
","8311390","","8311390","","2021-07-11 13:11:45","2021-07-11 15:06:24","iOS Widget does not read UserDeafults value for the first time in the home screen","<ios><swift><swiftui><widget><userdefaults>","2","5","1","","","CC BY-SA 4.0"
"68337688","1","68338011","","2021-07-11 15:39:25","","0","68","<p>I want to keep track of the size of an array, I thought something like this would work:</p>
<pre><code>class CarListViewModel: ObservableObject {
    private var cancellables = Set&lt;AnyCancellable&gt;()   
    @Published var ownedCarLength = 0

    init(){     

        CarRepository.$ownedCars.sink { _ in
            self.ownedCarLength = CarRepository.ownedCars.count
        }
        .store(in: &amp;cancellables)
    }
</code></pre>
<p>as this is called each time the array <code>CarRepository.ownedCars</code> is modified, however the value returned from CarRepository.ownedCars.count evaluates to 0 for some reason. Is there a cleaner way of doing this?</p>
","10142976","","","","","2021-07-11 16:20:23","How can I subscribe to the size of an array in SwiftUI?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68351279","1","68351640","","2021-07-12 16:59:03","","-1","138","<p>In <a href=""https://github.com/afarber/ios-questions/blob/master/TopsBatchInsert/TopsBatchInsert/ViewModels/TopViewModel.swift"" rel=""nofollow noreferrer"">a simple test project at Github</a> I am downloading JSON file, parse it into <code>[[String:Any]]</code> and then would like to pass the data structure to Core Data's <code>NSBatchInsertRequest</code>:</p>
<pre><code>func fetchTopModels(language:String) {
    guard let url = urls[language] as? URL else { return }
    
    URLSession.shared.dataTaskPublisher(for: url)
        .tryMap(handleOutput)
        .tryMap { jsonData -&gt; [[String: Any]] in
            let json = try? JSONSerialization.jsonObject(with: jsonData, options: [])
            guard let jsonDict = json as? [String:Any],
                  let dataList = jsonDict[&quot;data&quot;] as? [[String:Any]]
                else { throw URLError(.badServerResponse) }
                return dataList
        }
        // TODO How to set language on each dataList member?
        //.map {
              //$0.language = language
        //}
        .sink { completion in
            print(&quot;fetchTopModels completion=\(completion)&quot;)
        } receiveValue: { fetchedTops in
            PersistenceController.shared.container.performBackgroundTask { backgroundContext in
                backgroundContext.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
                backgroundContext.automaticallyMergesChangesFromParent = true
                backgroundContext.perform {
                    
                    let batchInsert = NSBatchInsertRequest(entity: TopEntity.entity(), objects: fetchedTops)
</code></pre>
<p>However the <code>[[String:Any]]</code> data structure is missing the <code>language</code> String property on each of its members. It is mandatory on the Core Data entity.</p>
<p>My question is how to iterate through the array and set the <code>language</code> on each member (for example to the value of <code>&quot;en&quot;</code>)?</p>
<p>I have searched, but it is difficult to find a good pointer because the search keywords are too common :-)</p>
","165071","","","","","2021-07-12 20:05:02","With Combine how to iterate through an array of dictionaries and set 1 additional property?","<ios><swift><dictionary><combine>","1","0","1","","","CC BY-SA 4.0"
"68355656","1","68357779","","2021-07-13 02:08:04","","0","444","<p>I'm attempting to retrieve data for a user profile, and I'm not sure how to initialize the observable objects in my view model. I see a lot of examples of where an array of objects will be returned, but not one single object.</p>
<p>How can I initialize the <code>profile</code> variable in the view model with a null value before I attempt to fetch the profile data, or should I not use this method for retrieving this data?</p>
<p>Also on a side note, is it best practice to write a common class (like a RestManager class) to handle all API requests and have one method which invokes the URLSession dataTaskPublisher method?</p>
<p>Model:</p>
<pre class=""lang-swift prettyprint-override""><code>struct Profile: Codable, Hashable, Identifiable {
    var id: UUID
    var address: String
    var city: String
    var emailAddress: String
    var firstName: String
    var lastName: String
    var smsNumber: String
    var state: String
    var userBio: String
    var username: String
    var zipCode: Int
}
</code></pre>
<p>ViewModel:</p>
<pre class=""lang-swift prettyprint-override""><code>class ProfileViewModel: ObservableObject {
    // Cannot create Profile() as it needs data to be instantiated
    @Published var profile: Profile = Profile()

    init() {
        fetchProfile()
    }

    func fetchProfile() {
        guard let url = URL(string: &quot;https://path/to/api/v1/profiles&quot;) else {
            print(&quot;Failed to create URL&quot;)
            return
        }
        
        let requestData = [
            &quot;username&quot;: &quot;testuser&quot;
        ]
        var request = URLRequest(url: url)
        request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Accept&quot;)
        request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        request.httpMethod = &quot;GET&quot;
        request.httpBody = try? JSONEncoder().encode(requestData)
        
        URLSession.shared.dataTaskPublisher(for: request)
            .tryMap { output in
                guard let response = output.response as? HTTPURLResponse, response.statusCode == 200 else {
                    throw HTTPError.statusCode
                }

                return output.data
            }
            .decode(type: Profile.self, decoder: JSONDecoder())
            .retry(3)
            .replaceError(with: Profile()) // Same issue here - requires data to be instantiated
            .eraseToAnyPublisher()
            .receive(on: DispatchQueue.main)
            .assign(to: &amp;$profile)
    }
}

</code></pre>
<p>View:</p>
<pre class=""lang-swift prettyprint-override""><code>struct ProfileSummary: View {
    @ObservedObject var viewModel: ProfileViewModel

    var body: some View {
        NavigationView {
            VStack {
                Text(viewModel.profile.firstName)
                Text(viewModel.profile.lastName)
            }
            .navigationTitle(&quot;Profile&quot;)
            .onAppear {
                viewModel.fetchProfile()
            }
        }
    }
}
</code></pre>
","3976172","","3976172","","2021-07-13 03:14:40","2021-07-13 11:30:42","Retrieving data using URLSession and ViewModel","<ios><swift><xcode><mvvm><swiftui>","3","0","","","","CC BY-SA 4.0"
"68381565","1","68381799","","2021-07-14 16:09:18","","2","732","<p>I am writing a SwiftUI app using the MVVM pattern.  I'm running into a situation where I am presenting an app setup screen and prompting the user for a password.  To perform password validation, I have a series of Combine <code>Publisher</code>s in my <code>ViewModel</code> that validate against numerous criteria.  If the password validates successfully, a &quot;Complete Registration&quot; button is enabled in my <code>View</code>, and upon tapping it the account is established.  If an error occurs while creating the account, an <code>Alert</code> is supposed to be displayed.  However, I am finding in my testing that when the alert is displayed it immediately dismisses itself.  Here's what my <code>ViewModel</code> looks like:</p>
<pre><code>struct ApplicationSetupState {
    
}

enum ApplicationSetupInput {
    case completeSetup
}

class ApplicationSetupViewModel: ViewModel {
    
    typealias ViewModelState = ApplicationSetupState
    typealias ViewModelInput = ApplicationSetupInput
    
    enum PasswordValidation {
        case valid
        case empty
        case noMatch
    }
    
    @Published var password: String = &quot;&quot;
    @Published var confirmPassword: String = &quot;&quot;
    @Published var useBiometrics: Bool = false
    
    @Published var isValid: Bool = false
    
    @Published var state: ApplicationSetupState
    @Published var errorMessage: String? = nil
    @Published var error: Bool = false
    
    private var cancellables: [AnyCancellable] = []
    
    private var isPasswordEmptyPublisher: AnyPublisher&lt;Bool, Never&gt; {
        $password
            .debounce(for: 0.8, scheduler: RunLoop.main)
            .removeDuplicates()
            .map { password in
                DDLogVerbose(&quot;Mapping password=\(password)&quot;)
                return password == &quot;&quot;
            }
            .eraseToAnyPublisher()
    }
    
    private var arePasswordsEqualPublisher: AnyPublisher&lt;Bool, Never&gt; {
        Publishers.CombineLatest($password, $confirmPassword)
            .debounce(for: 0.1, scheduler: RunLoop.main)
            .map { password, confirmPassword in
                DDLogVerbose(&quot;Mapping password=\(password), confirmPassword=\(confirmPassword)&quot;)
                return password == confirmPassword
            }
            .eraseToAnyPublisher()
    }
    
    private var isPasswordValidPublisher: AnyPublisher&lt;PasswordValidation, Never&gt; {
        Publishers.CombineLatest(isPasswordEmptyPublisher, arePasswordsEqualPublisher)
            .map { isPasswordEmpty, arePasswordsEqual in
                DDLogVerbose(&quot;Mapping isPasswordEmpty=\(isPasswordEmpty), arePasswordsEqual=\(arePasswordsEqual)&quot;)
                if isPasswordEmpty {
                    return .empty
                } else if !arePasswordsEqual {
                    return .noMatch
                }
                
                return .valid
            }
            .eraseToAnyPublisher()
    }
    
    private var isSetupValidPublisher: AnyPublisher&lt;Bool, Never&gt; {
        isPasswordValidPublisher
            .map { isPasswordValid in
                return isPasswordValid == .valid
            }
            .eraseToAnyPublisher()
    }
    
    init() {
        self.state = ApplicationSetupState()
        
        self.isPasswordValidPublisher
            .receive(on: RunLoop.main)
            .map { passwordValidation in
                DDLogVerbose(&quot;Mapping passwordValidation=\(passwordValidation)&quot;)
                switch passwordValidation {
                case .empty:
                    return &quot;You must provide a master password&quot;
                case .noMatch:
                    return &quot;The passwords do not match.  Try again.&quot;
                default:
                    return &quot;&quot;
                }
            }
            .assign(to: \.errorMessage, on: self)
            .store(in: &amp;cancellables)
        
        self.isSetupValidPublisher
            .receive(on: RunLoop.main)
            .assign(to: \.isValid, on: self)
            .store(in: &amp;cancellables)
    }
    
    func trigger(_ input: ApplicationSetupInput) {
        switch input {
        case .completeSetup:
            self.completeApplicationSetup()
        }
    }
    
    // MARK: - Private methods
    
    private func completeApplicationSetup() {
        DDLogInfo(&quot;Completing application setup...&quot;)
        
        do {
            let status = try ApplicationSetupController.shared.completeApplicationSetup(withPassword: self.password,
                                                                                        useBiometrics: self.useBiometrics)
            DDLogVerbose(&quot;status=\(status)&quot;)
            if status == true {
                DDLogInfo(&quot;Application setup completed successfully.  Posting notification...&quot;)
                NotificationCenter.default.post(name: .didCompleteSetup, object: nil)
            } else {
                DDLogWarn(&quot;Application setup failed with no error message&quot;)
                self.error = true
                self.errorMessage = &quot;An unknown error occurred during setup.  Please try again.&quot;
            }
        } catch {
            DDLogError(&quot;ERROR while completing application setup - \(error)&quot;)
            self.error = true
            self.errorMessage = error.localizedDescription
        }
    }
    
}
</code></pre>
<p>As you can see, I have a <code>@State</code> variable called <code>error</code> that indicates whether or not there is an error situation.  My <code>View</code> looks something like this:</p>
<pre><code>struct MasterPasswordSetupView: View {
    
    @ObservedObject var viewModel: ApplicationSetupViewModel
    
    var body: some View {
        VStack(alignment: .center) {
            ...stuff...
        }
            .alert(isPresented: self.$viewModel.error) {
                Alert(title: Text(&quot;Error&quot;),
                      message: Text(self.viewModel.errorMessage ?? &quot;&quot;),
                      dismissButton: .default(Text(&quot;Ok&quot;)) {
                        DDLogVerbose(&quot;OK pressed!&quot;)
                      })
            }
    }
}
</code></pre>
<p>You'll notice that the <code>Alert</code> is displayed if error is true within my <code>ViewModel</code>.  However, I am seeing that as soon as the <code>Alert</code> is displayed it is immediately dismissed, even though I have not pressed the OK button to dismiss it.</p>
<p>I've added some logging, including a <code>didSet</code> method on <code>error</code>, and see that at some point error is, in fact, toggled back to false.  However, I am not explicitly doing this anywhere within my code, so I'm at a loss as to why it is happening.  Any thoughts?</p>
","331747","","","","","2021-07-14 16:24:28","SwiftUI: Alert dismissing itself automatically (when it shouldn't!)","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68382516","1","68383280","","2021-07-14 17:14:49","","0","180","<p>i am learning swiftui now and I am newbie for stackoverflow, I find a question,this is my code. I want to change the @State nopubName in sink ,but it's not work,the print is always &quot;Nimar&quot;, I don't know why</p>
<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
   
    @State var nopubName: String = &quot;Nimar&quot;
    private var cancellable: AnyCancellable?
    
    var stringSubject = PassthroughSubject&lt;String, Never&gt;()

    init() {
        cancellable = stringSubject.sink(receiveValue: handleValue(_:))
    }
    
    func handleValue(_ value: String) {
         print(&quot;handleValue: '\(value)'&quot;)
        self.nopubName = value
        print(&quot;in sink &quot;+nopubName)
     }
    
    var body: some View {
        VStack {
            Text(self.nopubName)
                .font(.title).bold()
                .foregroundColor(.red)
            Spacer()
 
            Button(&quot;sink&quot;){
                stringSubject.send(&quot;World&quot;)
                print(nopubName)

            }
        }
    }
}
</code></pre>
","16372603","","41116","","2021-07-14 18:24:08","2021-07-14 18:29:57","swiftui cannot change @State value in sink","<state><combine><sink>","2","0","","","","CC BY-SA 4.0"
"68395108","1","68396086","","2021-07-15 13:49:26","","0","78","<p>I have a longish list of API endpoints I need to call sequentially in a specific order to keep my app's state in sync with a server. I chose to use a Combine chain to implement this. Each operation calls a function that does some work (reads and writes some Core Data models) and returns the same type, something like: <code>-&gt; AnyPublisher&lt;SyncEvent?, Error&gt;</code></p>
<p>together it looks something like this:</p>
<pre class=""lang-swift prettyprint-override""><code>Timer.publish(every: interval, on: .current, in: .common)
  .receive(on: DispatchQueue.global(qos: .background))
  .flatMap(syncEndpointOne)
  .flatMap(syncEndpointTwo)
  .flatMap(syncEndpointThree)
  .flatMap(syncEndpointFour)
  ...
</code></pre>
<p>After adding more than a few of these functions the Swift compiler and language server just gives up and becomes unresponsive, it will hang forever. Commenting out individual lines verifies there are no issues with each line specifically - just that this is too complicated for the compiler to infer and reason about.</p>
<p>How can I rewrite this or give the compiler more information to fix this?</p>
<p>(xcode 12.5.1 and swift 5.4.2)</p>
","3003156","","","","","2021-07-15 14:51:57","Improving compile time of long combine chain","<swift><xcode><compilation><combine>","1","0","","","","CC BY-SA 4.0"
"68413564","1","68415375","","2021-07-16 18:12:09","","1","161","<p>I wrote code to display City Names when typing in a Text field. I can display the search results with a For Each loop. I need to click on one of the results and get the geo location of the cities name. Now I am struggling with getting geo location (latitude, longitude) from that city names. Is there a solution for that to implement it into my code?</p>
<pre><code>class LocationService: NSObject, ObservableObject {

enum LocationStatus: Equatable {
    case idle
    case noResults
    case isSearching
    case error(String)
    case result
}

@Published var queryFragment: String = &quot;&quot;
@Published private(set) var status: LocationStatus = .idle
@Published private(set) var searchResults: [MKLocalSearchCompletion] = []

private var queryCancellable: AnyCancellable?
private let searchCompleter: MKLocalSearchCompleter!

init(searchCompleter: MKLocalSearchCompleter = MKLocalSearchCompleter()) {
    self.searchCompleter = searchCompleter
    super.init()
    self.searchCompleter.delegate = self

    queryCancellable = $queryFragment
        .receive(on: DispatchQueue.main)
        // we're debouncing the search, because the search completer is rate limited.
        // feel free to play with the proper value here
        .debounce(for: .milliseconds(250), scheduler: RunLoop.main, options: nil)
        .sink(receiveValue: { fragment in
            self.status = .isSearching
            if !fragment.isEmpty {
                self.searchCompleter.queryFragment = fragment
            } else {
                self.status = .idle
                self.searchResults = []
            }
    })
}


extension LocationService: MKLocalSearchCompleterDelegate {
func completerDidUpdateResults(_ completer: MKLocalSearchCompleter) {

    // out a lot of places and only shows cities and countries.
    self.searchResults = completer.results.filter({ $0.subtitle == &quot;&quot; })
    self.status = completer.results.isEmpty ? .noResults : .result
}

func completer(_ completer: MKLocalSearchCompleter, didFailWithError error: Error) {
    self.status = .error(error.localizedDescription)
}
</code></pre>
<p>}</p>
","7385996","","","","","2021-07-16 21:22:24","Get geo location from city name","<ios><swift><xcode><swiftui>","1","0","1","","","CC BY-SA 4.0"
"68415286","1","68426109","","2021-07-16 21:11:44","","0","194","<p>I'm observing an unexpected behavior regarding CombineLatest, if the inner publishers has <code>subscribe(on:)</code>, the CombineLatest stream is not emitting any value.</p>
<p>Notes:</p>
<ul>
<li>With Zip operator is working</li>
<li>Moving the subscribe(on:) / receive(on:) to the combineLatest stream also work. But in this particular use case, the inner publishers is defining their subscribe/receive
because are (re)used in other places.</li>
<li>Adding subscribe(on:)/receive(on:) to only one of the inner publishers also work, so the problem is just when both have it.</li>
</ul>
<pre><code>    func makePublisher() -&gt; AnyPublisher&lt;Int, Never&gt; {
        Deferred {
            Future { promise in
                DispatchQueue.global(qos: .background).asyncAfter(deadline: .now() + 3) {
                    promise(.success(Int.random(in: 0...3)))
                }
            }
        }
        .subscribe(on: DispatchQueue.global())
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
    }
    
    var cancellables = Set&lt;AnyCancellable&gt;()
    Publishers.CombineLatest(
        makePublisher(),
        makePublisher()
    )
    .sink { completion in
        print(completion)
    } receiveValue: { (a, b) in
        print(a, b)
    }.store(in: &amp;cancellables)
</code></pre>
<p>Is this a combine bug or expected behavior? Do you have any idea of how can be setup this kind of stream where the inners can define its own subscribe scheduler?</p>
","6909275","","6909275","","2021-07-17 21:20:46","2021-07-18 04:50:43","CombineLatest operator is not emitting when inners publishers use subscribe(on:)","<ios><swift><combine><combinelatest>","1","2","","","","CC BY-SA 4.0"
"68427812","1","68427882","","2021-07-18 09:35:41","","2","1094","<p>In my app, I am using the Combine framework to make network requests and it works fine for GET requests. But I am running into this issue with POST requests.</p>
<p>The following code (without Combine) works fine:</p>
<pre><code>let data = [&quot;statusTime&quot;: DateFormatter.iso8601Full.string(from: Date())]
let requestBody = try? JSONSerialization.data(withJSONObject: data, options: [])
let baseURL = &quot;my-api.amazonaws.com&quot;
let endpoint = &quot;/my/endpoint&quot;

var urlComponents = URLComponents()
urlComponents.scheme = &quot;https&quot;
urlComponents.host = baseURL
urlComponents.path = endpoint
let url = urlComponents.url!
var request = URLRequest(url: url)

request.httpMethod = &quot;POST&quot;
request.httpBody = requestBody

request.addValue(authorizationToken, forHTTPHeaderField: &quot;Authorization&quot;)
request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Accept&quot;)

let task = URLSession.shared.dataTask(with: request) { (data, response, error) in
    if let error = error {
        print(&quot;error: \(error)&quot;)
        return
    }
    print(&quot;Response: \((response as! HTTPURLResponse).statusCode)&quot;)
}
task.resume()
</code></pre>
<p>I get a 200 response code from the above code.</p>
<p>The same code with Combine:</p>
<pre><code>let data = [&quot;statusTime&quot;: DateFormatter.iso8601Full.string(from: Date())]
let requestBody = try? JSONSerialization.data(withJSONObject: data, options: [])
let baseURL = &quot;my-api.amazonaws.com&quot;
let endpoint = &quot;/my/endpoint&quot;

var urlComponents = URLComponents()
urlComponents.scheme = &quot;https&quot;
urlComponents.host = baseURL
urlComponents.path = endpoint
let url = urlComponents.url!
var request = URLRequest(url: url)

request.httpMethod = &quot;POST&quot;
request.httpBody = requestBody

request.addValue(authorizationToken, forHTTPHeaderField: &quot;Authorization&quot;)
request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Accept&quot;)

let cancellable = URLSession.shared
    .dataTaskPublisher(for: request)
    .print()
    .sink(receiveCompletion: {
        if let error = $0.error {
            print(&quot;Failure: \(error)&quot;)
        }
    }, receiveValue: {
        print(&quot;\($0)&quot;)
    })
</code></pre>
<p>Here is the output I receive:</p>
<pre><code>receive subscription: (DataTaskPublisher)
request unlimited
receive cancel
</code></pre>
<p>Seems like the request with the Combine framework is somehow getting cancelled? I used a network tracing app and I can see the first request (without Combine), but not the second request.</p>
<p>I have looked at numerous posts and documentation, but can't see what's wrong with my code. What am I missing? Thanks in advance.</p>
","1121544","","","","","2021-07-18 09:45:09","Swift HTTP POST request with Combine","<swift><post><combine>","1","0","1","","","CC BY-SA 4.0"
"68439147","1","68439497","","2021-07-19 10:42:40","","0","449","<p>If I send to <code>PassthroughSubject&lt;Void, Error&gt;</code>, this process will run once, but if I send it more than once, the process in the flatMap will not run. Why is this?</p>
<pre><code>var testTappedSubject = PassthroughSubject&lt;Void, Error&gt;()

testTappedSubject
    .print(&quot;testTappedSubject&quot;)
    .flatMap({ () -&gt; AnyPublisher&lt;Int, Error&gt; in
        print(&quot;called test&quot;)
        return Fail(error: LoginError.someError(error: .unknown))
                .eraseToAnyPublisher()
    })            
    .sink { error in
        print(&quot;error&quot;, error)
    } receiveValue: { value in
        print(&quot;pressed&quot;, value)
    }
    .store(in: &amp;cancellables)
</code></pre>
","3688956","","1974224","","2021-10-26 05:44:38","2021-10-26 05:44:38","PassthroughSubject + flatMap cannot be called more than once?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"68471814","1","68474358","","2021-07-21 14:55:38","","0","301","<p>I have a child view that is given a binding from the parent view, which controls the app's sidebar menu. When I click the button to toggle showSidebar and open the menu, my vm is re-created because the view is re-rendered? Is there a way to do this without affecting the view model?</p>
<pre><code>struct OnboardingView: View {
    @Environment (\.presentationMode) var presentationMode
    @ObservedObject private var vm: OnboardingViewModel
    @State private var filtering = false
    @Binding var showSidebar: Bool

init(showSidebar: Binding&lt;Bool&gt;) {
    self._showSidebar = showSidebar
    self.vm = OnboardingViewModel()
}
</code></pre>
","2484049","","","","","2021-07-21 17:54:44","SwiftUI Binding to parent view re-renders child view","<mvvm><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68481386","1","68481695","","2021-07-22 08:13:35","","1","269","<p>We started using Combine for Networks calls in our Application. The user is supposed to input a code, and we want to validate that code via a network call, then perform actions based on the result of said network call.</p>
<p>To our understanding, if we had a published string variable and used that to lazily create another publisher in which we made the API call, we'd only make API calls every time the string changed.</p>
<p>However, the more SwiftUI views that listen to the publisher via <code>onReceive</code>, the more API calls get made. Here's a simplified example:</p>
<p><strong>View</strong></p>
<pre><code>struct ContentView: View {

    @ObservedObject var viewModel: ResultBenchmarkViewModel

    @State var one: String = &quot;ONE&quot;
    @State var two: String = &quot;TWO&quot;
    @State var three: String = &quot;THREE&quot;

    var body: some View {
        VStack {
        
            TextField(&quot;INPUT&quot;, text: $viewModel.inputString)
        
            Text(one)
                .onReceive(viewModel.inputStringPublisher, perform: { string in
                    one = string
                })
        
            Text(two)
                .onReceive(viewModel.inputStringPublisher, perform: { string in
                    two = string
                })
        
            Text(three)
                .onReceive(viewModel.inputStringPublisher, perform: { string in
                    three = string
                })
        }
    }
}
</code></pre>
<p><strong>ViewModel</strong></p>
<pre><code>class ResultBenchmarkViewModel: Identifiable, ObservableObject {

    @Published var inputString: String = &quot;&quot;

    lazy var inputStringPublisher: AnyPublisher&lt;String, Never&gt; = {
    
        return $inputString
            .map { string in
                print(&quot;API CALL&quot;)
                return string
            }
            .eraseToAnyPublisher()
    }()
}
</code></pre>
<p>Using <code>onReceive</code> three times also prints &quot;API CALL&quot; three times every time the user inputs a character. What we expected to happen was that &quot;API CALL&quot; would only be printed once, since <code>inputString</code> only changes once, and then the three views that use <code>onReceive</code> would only receive the final result published by the publisher.</p>
<p>A solution we're now implementing is listening to the inputString, making the api call and saving the result to a local published variable, which the views then update according to. However, that seems like boilerplate to me that could be obsolete if we properly implemented the original request.</p>
<p>Could we achieve our expected result with some minor changes to the implementation? Or is there a fundamental misunderstanding of combine/swiftui here?</p>
","4442731","","","","","2021-07-22 08:36:45","Multiple onReceive usages lead to duplicated API calls","<ios><swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"68483865","1","68484941","","2021-07-22 11:16:23","","3","1093","<p>I have a SwiftUI Form with a backing ViewModel. I wish to enable a Save button when the ViewModel changed. I have the following code:</p>
<pre class=""lang-swift prettyprint-override""><code>class ViewModel: ObservableObject {
    @Published var didUpdate = false
    @Published var name = &quot;Qui-Gon Jinn&quot;
    @Published var color = &quot;green&quot;
    private var cancellables: [AnyCancellable] = []

    init() {
        self.name.publisher.combineLatest(self.color.publisher)
            .sink { _ in
                NSLog(&quot;Here&quot;)
                self.didUpdate = true
            }
            .store(in: &amp;self.cancellables)
    }
}

struct ContentView: View {
    @ObservedObject var viewModel = ViewModel()

    var body: some View {
        NavigationView {
            Form {
                Toggle(isOn: self.$viewModel.didUpdate) {
                    Text(&quot;Did update:&quot;)
                }
                TextField(&quot;Enter name&quot;, text: self.$viewModel.name)
                TextField(&quot;Lightsaber color&quot;, text: self.$viewModel.color)
            }
            .textFieldStyle(RoundedBorderTextFieldStyle())
            .navigationBarItems(
                trailing:
                Button(&quot;Save&quot;) { NSLog(&quot;Saving!&quot;) }
                    .disabled(!self.viewModel.didUpdate)
            )
        }
    }
}
</code></pre>
<p>There are two problems with this code.</p>
<p>First problem is that upon instantiation of the ViewModel, the log will show &quot;Here&quot;, and thus set <code>didUpdate</code> to true. The second problem is that when the user changes the viewmodel via the textfields, it doesn't actually fire the publishers.</p>
<p>How should these problems be fixed?</p>
<p>(I've thought of adding <code>didSet{}</code> to each property in the ViewModel but that is very ugly when there are lots of properties. I've also thought of adding modifiers to the textfields, but I really prefer putting this code in the ViewModel, because a network update could also change the ViewModel).</p>
","1085556","","1085556","","2021-07-22 12:24:15","2021-12-15 17:57:36","SwiftUI Combine observing updates","<swiftui><combine>","2","0","0","","","CC BY-SA 4.0"
"68492353","1","68492504","","2021-07-22 23:05:32","","2","91","<p>I've been looking for the perfect UserDefaults wrapper that</p>
<ul>
<li>seamlessly encodes and decodes Data objects from storage</li>
<li>works with @Published</li>
</ul>
<p>My starting point was this <a href=""https://stackoverflow.com/a/57982560/1346618"">StackOverflow answer</a>, but it uses <code>object:forKey</code> which doesn't work with custom objects (encoding URLs is always non-trivial for me).</p>
<p>My idea is to be able to use it like so:</p>
<pre class=""lang-swift prettyprint-override""><code>struct Server: Identifiable, Codable, Equatable, Hashable { /* vars */ }

class ServerPickerViewModel: ObservableObject {

  @Published(wrappedValue: Server.defaultServers.first!,
             type: Server.self,
             key: &quot;currentServer&quot;)
  var currentServer: Server?

}
</code></pre>
<p>To achieve this, I modified the code from @VictorKushnerov's answer:</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine

private var cancellables = [String: AnyCancellable]()

extension Published {
  init&lt;T: Encodable &amp; Decodable&gt;(wrappedValue defaultValue: T, type: T.Type, key: String) {
      let decoder = JSONDecoder()
      var value: T
      if
        let data = UserDefaults.standard.data(forKey: key),
        let decodedVal = try? decoder.decode(T.self, from: data) {
        value = decodedVal
      } else {
        value = defaultValue
      }

        self.init(initialValue: value) // &lt;-- Error

        cancellables[key] = projectedValue.sink { val in
          let encoder = JSONEncoder()
          let encodedVal = encoder.encode(val) // &lt;-- Error
          UserDefaults.standard.set(encodedVal, forKey: key)
        }
    }
}
</code></pre>
<p>There are currently two errors I can't get through, which are the following:</p>
<ul>
<li><code>Cannot convert value of type 'T' to expected argument type 'Value'</code> it still relying on the underlying <code>@Published</code>'s <code>Value</code> generic type, I wish I could override that with my type T.</li>
<li><code>Instance method 'encode' requires that 'Published&lt;Value&gt;.Publisher.Output' (aka 'Value') conform to 'Encodable'</code></li>
</ul>
","1346618","","1346618","","2021-07-30 17:51:53","2021-07-30 17:51:53","How to seamlessly wrap @Published variables with a UserDefaults propertyWrapper","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"68506284","1","68506853","","2021-07-24 01:13:33","","0","134","<p>I'm currently trying to change a button from one view to another depending on what the user presses. They would get a list/scrollview of pending requests and if the user clicks on accept, it should change that button to an accepted button and if the user clicks on reject, it should change that button to a rejected button. I'm running into a problem where if a user clicks on accept, all the pending request buttons gets changed to an accepted button and similarly for the reject case.</p>
<pre><code>
import SwiftUI
import Firebase
import SDWebImageSwiftUI
import Foundation
import Combine


struct BottomSheet: View {
    
//    @ObservedObject var userData : UserViewModel
    
    var edges = UIApplication.shared.windows.first?.safeAreaInsets
    
 
    @StateObject var userData = UserViewModel()

    @State var declinedRequest: Bool = false

    @State var acceptedRequest: Bool = false
    
    
    
    var body: some View {
        
        VStack{
            
            Spacer()
            
            VStack(spacing: 12){
                
               
                Divider()
               
                
                
                   
                    // here are the buttons inside the scrollview 
                    ScrollView{
                        ForEach(userData.pendingFriendUsers){ person in
                            
                            HStack{
                                if person.pic != &quot;&quot;{
                                    WebImage(url: URL(string: person.pic)!)
                                        .resizable()
                                        .aspectRatio(contentMode: .fill)
                                        .frame(width: 60, height: 60)
                                        .clipShape(Circle())
                                        .padding(.leading, 30)
                                        .padding(.trailing, 10)


                                }else{
                                    Circle()
                                        .stroke(Color.black.opacity(0.8), lineWidth: 2)
                                        .frame(width: 60, height: 60)
                                        .padding(.leading, 20)
                                        .padding(.trailing, 10)

                                }
                                VStack(alignment: .leading){
                                    Text(&quot;\(person.name)&quot;)
                                        .font(.custom(&quot;Helvetica Neue&quot;, size: 16))
                                        .foregroundColor(Color.white).bold()
                                    Text(&quot;@\(person.username)&quot;)
                                        .font(.custom(&quot;Helvetica Neue&quot;, size: 16))
                                        .foregroundColor(Color.white)
                                        .opacity(0.8)
                                }
                                Spacer()
                                
                                if person.isFriends == 2 {
                                    RoundedRectangle(cornerRadius: 15, style: .continuous)
                                        .fill(Color(&quot;Dark-Grey&quot;))
                                        .frame(width: 150, height: 40)
                                        .padding(.trailing, 25)
                                        .overlay(
                                            Text(&quot;Request removed&quot;)
                                                .font(.custom(&quot;Helvetica Neue&quot;, size: 14))
                                                .foregroundColor(Color.white)
                                                .padding(.trailing, 25)
                                        )
                                }else if person.isFriends == 1 {
                                    RoundedRectangle(cornerRadius: 15, style: .continuous)
                                        .fill(Color.white)
                                        .frame(width: 150, height: 40)
                                        .padding(.trailing, 25)
                                        .overlay(
                                            Text(&quot;Request accepted&quot;)
                                                .font(.custom(&quot;Helvetica Neue&quot;, size: 14))
                                                .foregroundColor(Color.black)
                                                .padding(.trailing, 25)
                                        )
                                }else {
                                    Button(action: {
                                        print(&quot;declined friend request for \(person.uid)&quot;)
                                        withAnimation(){declinedRequest = true}
                                        userData.declineFriendRequest(otherUserUID: person.uid)

                                    }){
                                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                                            .fill(Color(&quot;Dark-Grey&quot;))
                                            .frame(width: 55, height: 26.5)
                                            .padding(.trailing, 13)
                                            .overlay(
                                                Image(&quot;x&quot;)
                                                    .renderingMode(.template)
                                                    .resizable()
                                                    .foregroundColor(Color.white)
                                                    .opacity(0.8)
                                                    .frame(width: 12, height: 12)
                                                    .padding(.trailing, 12)
                                            )
                                    }
                                   
                                    Button(action: {
                                        print(&quot;accepted friend request for \(person.uid)&quot;)
                                        withAnimation(){acceptedRequest = true}
                                        userData.acceptFriendRequest(otherUserUID: person.uid)

                                    }){
                                    RoundedRectangle(cornerRadius: 15, style: .continuous)
                                        .fill(Color.white)
                                        .frame(width: 50, height: 25)
                                        .padding(.trailing, 35)
                                        .overlay(
                                            Image(&quot;check&quot;)
                                                .resizable()
                                                .aspectRatio(contentMode: .fill)
                                                .frame(width: 20, height: 20)
                                                .padding(.trailing, 33)
                                        )
                                    }
                                }
                                
                                
                            }.padding(.top, 12.5)
                            
                        }
            
                    }
                       
            
                        
                    Spacer()
                    
                .contentShape(Rectangle())
            }
            .frame(width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height / 1.15)
            .padding(.top)
            .background(Color(&quot;gray&quot;)
                            .clipShape(CustomCorner(corners: [.topLeft,.topRight])))
            .offset(y: offset)
            // bottom sheet remove swipe gesture....
            .gesture(DragGesture().onChanged(onChanged(value:)).onEnded(onEnded(value:)))
            .offset(y: showSheet ? 0 : UIScreen.main.bounds.height)
        }
        .ignoresSafeArea()
        .background(
            Color.black.opacity(showSheet ? 0.3 : 0).ignoresSafeArea()
                .onTapGesture(perform: {
                    withAnimation{showSheet.toggle()}
                })
        )
    }
    
    
    
    
}


</code></pre>
<p>When declinedRequest or acceptedRequest get modified, its not mapped to the button so everything in the for view gets changed instead of the individual button. I've added my basic code below but some things I tried are making a published variable in my user data model class but it doesn't get updated in the for each as it moves on by then and I also tried making a published variable here. It looks like I have something to do with indices and mapping but I'm unsure what the best approach is. Thanks for your help</p>
<p>Edit:
Here's relevant sections from my user view model:</p>
<pre><code>import SwiftUI
import Firebase
import Combine
import Foundation



struct pendingFriendUser: Identifiable {
    var id: Int
    var uid: String
    var name: String
    var username: String
    var pic: String
    var isFriends: Int
    
    
    init(id: Int, uid: String, name: String, username: String, pic: String, isFriends: Int){
        self.id = id
        self.uid = uid
        self.name = name
        self.username = username
        self.pic = pic
        self.isFriends = isFriends
    }
}



class UserViewModel : ObservableObject{
    
    @Published var userInfo = UserModel(username: &quot;&quot;, pic: &quot;&quot;, name: &quot;&quot;, age: 1, uid: &quot;&quot;, phoneNumber: &quot;&quot;)
    
    let ref = Firestore.firestore()
    let uid = Auth.auth().currentUser!.uid
    
 
    @Published var pendingFriendUsers: [pendingFriendUser]

    //show add friends sheet
    @AppStorage(&quot;showSheet&quot;) var showSheet = false

    //check friendship variabe
    @Published var isFriend = 0
    
    

    init() {
        self.searchedUsers = []
        
        self.pendingFriendUsers = []
        
        fetchUser(uid: uid) { (user) in
                    self.userInfo = user
        }
    }
func getPendingRequests(){
        //check if friends has any false memberships
        var pendingFriendRequests: [String: Bool] = [:]
        self.ref.collection(&quot;Users&quot;).document(uid).getDocument(){
            (document, err) in
            
            if let err = err {
                print(&quot;Error getting documents \(err)&quot;)
            } else {
                
                if document!.data()![&quot;friends&quot;] != nil {
                    pendingFriendRequests = document!.data()![&quot;friends&quot;] as! [String : Bool]
                }
                
                //filter based on false pending friend requests
                self.pendingFriendUsers.removeAll()

                var friendUserID = 0 
                for key in pendingFriendRequests.keys {
                    if pendingFriendRequests[key] == false {
                        self.ref.collection(&quot;Users&quot;).document(key).getDocument(){
                            (friendDocument, err) in
                            
                            if let err = err {
                                print(&quot;Error getting documents \(err)&quot;)
                            } else {
                                let pendingFriendUsername = (friendDocument?.data()?[&quot;username&quot;]) as! String
                                let pendingFriendUID = (friendDocument?.data()?[&quot;uid&quot;]) as! String
                                let pendingFriendName = (friendDocument?.data()?[&quot;name&quot;]) as! String
                                let pendingFriendPic = (friendDocument?.data()?[&quot;imageurl&quot;]) as! String

                                self.pendingFriendUsers.append(pendingFriendUser(id: friendUserID, uid: pendingFriendUID , name: pendingFriendName , username: pendingFriendUsername, pic: pendingFriendPic, isFriends: 0))
                                
                                friendUserID += 1

                            }
                        }

                    }
                }
            }

        }
    }

   ...
    func acceptFriendRequest(otherUserUID: String){
        for var pendingFriend in pendingFriendUsers {
            if pendingFriend.uid == otherUserUID {
                pendingFriend.isFriends = 1
            }
        }
        self.ref.collection(&quot;Users&quot;).document(self.uid).setData(
            [ &quot;friends&quot;: [
                otherUserUID: true
            ] ]
            , merge: true)
        
        self.ref.collection(&quot;Users&quot;).document(otherUserUID).setData(
            [ &quot;friends&quot;: [
                self.uid: true
            ] ]
            , merge: true)
    }
    
    func declineFriendRequest(otherUserUID: String){
        for var pendingFriend in pendingFriendUsers {
            if pendingFriend.uid == otherUserUID {
                pendingFriend.isFriends = 2
            }
        }
        
        self.ref.collection(&quot;Users&quot;).document(self.uid).updateData([
            &quot;friends.\(otherUserUID)&quot;: FieldValue.delete(),
        ]) { err in
            if let err = err {
                print(&quot;Error updating document: \(err)&quot;)
            } else {
                print(&quot;Document successfully updated&quot;)
            }
        }
    }
    func checkFriendRequest(otherUserUID: String){
        
        //0 if not found in friend list or friend request
        //1 means theyre friends
        //2 means that user sent self/me a friend request
        var pendingFriendRequests: [String: Bool] = [:]
        self.ref.collection(&quot;Users&quot;).document(self.uid).getDocument(){
            (document, err) in
            
            if let err = err {
                print(&quot;Error getting documents \(err)&quot;)
            } else {
                pendingFriendRequests = document!.data()![&quot;friends&quot;] as! [String : Bool]
                

                for key in pendingFriendRequests.keys {
                    if key == otherUserUID{

                        if pendingFriendRequests[key] == true {
                            self.isFriend = 1
                        }else if pendingFriendRequests[key] == false {
                            self.isFriend = 2
                            
                        }
                    }
                }
            }
        }
    }
    
    
    
}
</code></pre>
<p>Edited with isFriends variable</p>
","13111023","","13111023","","2021-07-24 03:08:21","2021-07-24 03:54:46","Update each button item inside a list instead of all buttons at once in Swift / SwiftUI","<ios><swift><swiftui>","1","12","","","","CC BY-SA 4.0"
"68507900","1","68508084","","2021-07-24 07:27:23","","1","308","<p>I am trying to parse some JSON data with SwiftUI/Combine and I am a bit confused on the error I am getting. I am really new to Combine, so I could be completely overlooking something. I'm sure this has nothing to do with the real issue, as this would probably happen if I was parsing the normal way with urlsession/@escaping.</p>
<p>Here is the code:</p>
<pre><code>struct FilmModel: Identifiable, Codable {
let adult: Bool
let backdropPath: String
let budget: Int
let genres: [Genre]
let homepage: String
let id: Int
let imdbID, originalLanguage, originalTitle, overview: String
let popularity: Double
let posterPath: String
let productionCompanies: [ProductionCompany]
let productionCountries: [ProductionCountry]
let releaseDate: String
let revenue, runtime: Int
let spokenLanguages: [SpokenLanguage]
let status, tagline, title: String
let video: Bool
let voteAverage: Double
let voteCount: Int

enum CodingKeys: String, CodingKey {
    case adult
    case backdropPath = &quot;backdrop_path&quot;
    case budget
    case genres
    case homepage
    case id
    case imdbID = &quot;imbd_id&quot;
    case originalLanguage = &quot;original_language&quot;
    case originalTitle = &quot;original_title&quot;
    case overview
    case popularity
    case posterPath = &quot;poster_path&quot;
    case productionCompanies = &quot;production_companies&quot;
    case productionCountries = &quot;production_countries&quot;
    case releaseDate = &quot;release_date&quot;
    case revenue
    case runtime
    case spokenLanguages = &quot;spoken_languages&quot;
    case status, tagline, title
    case video
    case voteAverage = &quot;vote_average&quot;
    case voteCount = &quot;vote_count&quot;
}

struct Genre: Identifiable, Codable {
    let id: Int
    let name: String
}

struct ProductionCompany: Codable {
    let id: Int
    let logoPath: String?
    let name, originCountry: String
}

struct ProductionCountry: Codable {
    let iso3166_1, name: String
}

struct SpokenLanguage: Codable {
    let englishName, iso639_1, name: String
}
</code></pre>
<p>JSON response:</p>
<pre><code>{
&quot;adult&quot;: false,
&quot;backdrop_path&quot;: &quot;/rr7E0NoGKxvbkb89eR1GwfoYjpA.jpg&quot;,
&quot;belongs_to_collection&quot;: null,
&quot;budget&quot;: 63000000,
&quot;genres&quot;: [
    {
        &quot;id&quot;: 18,
        &quot;name&quot;: &quot;Drama&quot;
    }
],
&quot;homepage&quot;: &quot;http://www.foxmovies.com/movies/fight-club&quot;,
&quot;id&quot;: 550,
&quot;imdb_id&quot;: &quot;tt0137523&quot;,
&quot;original_language&quot;: &quot;en&quot;,
&quot;original_title&quot;: &quot;Fight Club&quot;,
&quot;overview&quot;: &quot;A ticking-time-bomb insomniac and a slippery soap salesman channel primal male aggression into a shocking new form of therapy. Their concept catches on, with underground \&quot;fight clubs\&quot; forming in every town, until an eccentric gets in the way and ignites an out-of-control spiral toward oblivion.&quot;,
&quot;popularity&quot;: 46.456,
&quot;poster_path&quot;: &quot;/pB8BM7pdSp6B6Ih7QZ4DrQ3PmJK.jpg&quot;,
&quot;production_companies&quot;: [
    {
        &quot;id&quot;: 508,
        &quot;logo_path&quot;: &quot;/7PzJdsLGlR7oW4J0J5Xcd0pHGRg.png&quot;,
        &quot;name&quot;: &quot;Regency Enterprises&quot;,
        &quot;origin_country&quot;: &quot;US&quot;
    },
    {
        &quot;id&quot;: 711,
        &quot;logo_path&quot;: &quot;/tEiIH5QesdheJmDAqQwvtN60727.png&quot;,
        &quot;name&quot;: &quot;Fox 2000 Pictures&quot;,
        &quot;origin_country&quot;: &quot;US&quot;
    },
    {
        &quot;id&quot;: 20555,
        &quot;logo_path&quot;: &quot;/hD8yEGUBlHOcfHYbujp71vD8gZp.png&quot;,
        &quot;name&quot;: &quot;Taurus Film&quot;,
        &quot;origin_country&quot;: &quot;DE&quot;
    },
    {
        &quot;id&quot;: 54051,
        &quot;logo_path&quot;: null,
        &quot;name&quot;: &quot;Atman Entertainment&quot;,
        &quot;origin_country&quot;: &quot;&quot;
    },
    {
        &quot;id&quot;: 54052,
        &quot;logo_path&quot;: null,
        &quot;name&quot;: &quot;Knickerbocker Films&quot;,
        &quot;origin_country&quot;: &quot;US&quot;
    },
    {
        &quot;id&quot;: 25,
        &quot;logo_path&quot;: &quot;/qZCc1lty5FzX30aOCVRBLzaVmcp.png&quot;,
        &quot;name&quot;: &quot;20th Century Fox&quot;,
        &quot;origin_country&quot;: &quot;US&quot;
    },
    {
        &quot;id&quot;: 4700,
        &quot;logo_path&quot;: &quot;/A32wmjrs9Psf4zw0uaixF0GXfxq.png&quot;,
        &quot;name&quot;: &quot;The Linson Company&quot;,
        &quot;origin_country&quot;: &quot;US&quot;
    }
],
&quot;production_countries&quot;: [
    {
        &quot;iso_3166_1&quot;: &quot;DE&quot;,
        &quot;name&quot;: &quot;Germany&quot;
    },
    {
        &quot;iso_3166_1&quot;: &quot;US&quot;,
        &quot;name&quot;: &quot;United States of America&quot;
    }
],
&quot;release_date&quot;: &quot;1999-10-15&quot;,
&quot;revenue&quot;: 100853753,
&quot;runtime&quot;: 139,
&quot;spoken_languages&quot;: [
    {
        &quot;english_name&quot;: &quot;English&quot;,
        &quot;iso_639_1&quot;: &quot;en&quot;,
        &quot;name&quot;: &quot;English&quot;
    }
],
&quot;status&quot;: &quot;Released&quot;,
&quot;tagline&quot;: &quot;Mischief. Mayhem. Soap.&quot;,
&quot;title&quot;: &quot;Fight Club&quot;,
&quot;video&quot;: false,
&quot;vote_average&quot;: 8.4,
&quot;vote_count&quot;: 22054
</code></pre>
<p>Data service:</p>
<pre><code>class FilmDataService {
@Published var films: [FilmModel] = []

var filmSubscription: AnyCancellable?

init() {
    getFilms()
}

private func getFilms() {
    guard let url = URL(string: &quot;https://api.themoviedb.org/3/movie/550?api_key=&lt;key&gt;&quot;) else { return }
    
    filmSubscription = URLSession.shared.dataTaskPublisher(for: url)
        .subscribe(on: DispatchQueue.global(qos: .default))
        .tryMap { (output) -&gt; Data in
            guard let response = output.response as? HTTPURLResponse,
                  response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300 else {
                throw URLError(.badServerResponse)
            }
            return output.data
        }
        .decode(type: [FilmModel].self, decoder: JSONDecoder())
        .receive(on: DispatchQueue.main)
        .sink { (completion) in
            switch completion {
            case .finished:
                break
            case .failure(let error):
                print(error)
            }
        } receiveValue: { [weak self] (returnedFilms) in
            self?.films = returnedFilms
            self?.filmSubscription?.cancel()
        }

}
</code></pre>
<p>View model:</p>
<pre><code>class FilmViewModel: ObservableObject {
@Published var tabBarImageNames = [&quot;house&quot;, &quot;rectangle.stack&quot;, &quot;clock.arrow.circlepath&quot;, &quot;square.and.arrow.down&quot;]
@Published var films: [FilmModel] = []

private let dataService = FilmDataService()
private var cancellables = Set&lt;AnyCancellable&gt;()

init() {
    addSubscribers()
}

func addSubscribers() {
    dataService.$films
        .sink { [weak self] (returnedFilms) in
            self?.films = returnedFilms
        }
        .store(in: &amp;cancellables)
}
</code></pre>
","14995438","","14995438","","2021-07-24 21:19:23","2021-07-24 21:19:23","Decoding JSON Error: ""Expected to decode Array<Any> but found a dictionary instead."", underlyingError: nil","<json><swift><decodable>","2","2","1","","","CC BY-SA 4.0"
"68517968","1","68525280","","2021-07-25 11:11:29","","3","170","<p>I am trying to display a <code>reality</code> file created using <code>Reality Composer</code>. The below code works for <code>usdz</code> but not for <code>reality</code>. Here is my code</p>
<pre><code>struct ARViewContainer: UIViewRepresentable {
    
    var modelConfirmedForPlacement: AnchorEntity?
    
    func makeUIView(context: Context) -&gt; ARView {
        
        let arView = ARView(frame: .zero,
                            cameraMode: .ar,automaticallyConfigureSession: true)
        
        let config = ARFaceTrackingConfiguration()
            
        arView.session.run(config)
        return arView            
    }
    
    func updateUIView(_ uiView: ARView, context: Context) {
        if let modelEntity = modelConfirmedForPlacement {
                      
           // Add the box anchor to the scene
            uiView.scene.anchors.append(modelEntity)   
        }
    }
}
</code></pre>
<p>//ViewModel</p>
<pre><code>final class ContentViewModel: ObservableObject {
    
    @Published var modelConfirmedForPlacement: AnchorEntity?
    
    private var cancellable: AnyCancellable? = nil
    
    func updateModelEntity(path: String){
        let url = URL(fileURLWithPath: path)
        self.cancellable = AnchorEntity.loadAnchorAsync(contentsOf: url)
            .sink(receiveCompletion: { loadCompletion in
                if case let .failure(error) = loadCompletion {
                    print(&quot;Unable to load a model due to error \(error)&quot;)
                }
                self.cancellable?.cancel()
            }, receiveValue: { modelEntity in
                debugPrint(&quot;hereeeeeeeee&quot;)
                self.modelConfirmedForPlacement = modelEntity
            })
    }

func loadFileSync(url: URL, completion: @escaping (String?, Error?) -&gt; Void)
    { 
//load from network and save locally }
</code></pre>
<p>The file does gets saved locally correctly but for reality files it is not displaying
Here are the Xcode logs</p>
<pre><code>File already exists [/var/mobile/Containers/Data/Application/880ED2EE-CCE7-4EE5-B854-0D1398650705/Documents/Experience.reality]
2021-07-25 16:29:09.060267+0530 RealityKitLoadModelFromNetwork[1352:474463] Metal GPU Frame Capture Enabled
2021-07-25 16:29:09.060478+0530 RealityKitLoadModelFromNetwork[1352:474463] Metal API Validation Enabled
</code></pre>
","9552485","","6599590","","2021-07-26 06:19:06","2021-07-26 06:44:03","Error in displaying reality file from network","<swift><augmented-reality><arkit><face-detection><realitykit>","1","0","0","","","CC BY-SA 4.0"
"68554581","1","68555014","","2021-07-28 04:54:18","","0","502","<p>I'm trying to implement an async call to a function loadUserFromFirebase and populate and return an array based on user attributes that I then use to write to a firebase collection.</p>
<p>I'm trying to use the Combine framework from Swift using future and promises but for some reason, the receiveCompletion and receiveValue don't get called and thus I get an empty array from my async function call.</p>
<p>Here is my code:</p>
<pre><code>var cancellable = Set&lt;AnyCancellable&gt;()
    func loadUserFromFirebase(groupUserIds: [String], handler: @escaping ([groupMate]) -&gt; Void) {
        
        var groupmateID = 0
        var groupMates : [groupMate] = []
        print(&quot;groupUserIds: \(groupUserIds)&quot; )
        
        for groupUserUID in groupUserIds {
            print(&quot;groupUserUID: \(groupUserUID)&quot; )
            
            let future = Future&lt;groupMate, Never&gt; { promise in
                self.ref.collection(&quot;Users&quot;).document(groupUserUID).getDocument(){
                    
                    (friendDocument, err) in
                
                    if let err = err {
                            print(&quot;Error getting documents \(err)&quot;)
                    } else {
                      //  print(&quot;friendDocument: \(String(describing: friendDocument?.data()))&quot; )

                        let groupUsername = (friendDocument?.data()?[&quot;username&quot;]) as! String
                        let groupUID = (friendDocument?.data()?[&quot;uid&quot;]) as! String
                        let groupName = (friendDocument?.data()?[&quot;name&quot;]) as! String
                        let groupPic = (friendDocument?.data()?[&quot;imageurl&quot;]) as! String

                        promise(.success(groupMate(id: groupmateID, uid: groupUID , name: groupName , username: groupUsername, pic: groupPic)))
                    }
                    
                    groupmateID += 1
                }
            }
            print(&quot;in receiveCompletion&quot;)

            future.sink(receiveCompletion: { completion in
                print(&quot;in receiveCompletion&quot;)
                print(1, completion)
                switch completion {
                    case .failure(let error):
                        print(3, error)
                        handler([])
                        return
                    case .finished:
                        break
                }
            },
            receiveValue: {
                print(&quot;in receiveValue&quot;)
                groupMates.append($0)
                print(groupMates)
                handler(groupMates)
            }).store(in: &amp;cancellable)
        }
    }
    
    
    func creategroup(groupName: String){
        addedTogroupUsers.append(self.uid)
        
        print(&quot;here111&quot;)
        loadUserFromFirebase(groupUserIds: addedTogroupUsers) { groupMates in
            print(&quot;here222&quot;)

            let groupData: [String: Any] = [
                &quot;groupName&quot;: &quot;\(groupName)&quot;,
                &quot;groupmates&quot;: groupMates
            ]
            print(&quot;here333 \(groupData)&quot;)

            print(&quot;groupMates are \(self.groupMates)&quot;)
            
            
            var groupref: DocumentReference? = nil
                groupref = self.ref.collection(&quot;groups&quot;).addDocument(data: groupData) { err in
                if let err = err {
                    print(&quot;Error adding document: \(err)&quot;)
                } else {
                    print(&quot;Document added with ID: \(groupref!.documentID)&quot;)
                    for addedgroupUser in self.addedTogroupUsers {
                        self.ref.collection(&quot;Users&quot;).document(addedgroupUser).updateData([
                                &quot;groups&quot;: FieldValue.arrayUnion([groupref!.documentID])
                            ])
                    }
                }
            }
                print(&quot;groupName is \(groupName) and addedTogroup are \(self.addedTogroupUsers)&quot;)
        }
    }
</code></pre>
<p>I'm trying to see if AnyCancellable is the way to go but since I'm using a chained array of future promises, I'm not sure how to implement it. Please let me know how you'd solve this problem so that the array does get populated since the documents do exist and the print inside the method call work but the groupMates array in the createGroup function prints an empty array afterwards. Thanks!</p>
<p>Edit: Added AnyCancallable to Code along with completion handler as suggested</p>
","13111023","","13111023","","2021-07-28 07:03:57","2021-07-28 08:31:40","Async Future Promise not working in Swift 5","<swift><firebase><asynchronous><combine>","1","0","","","","CC BY-SA 4.0"
"68565266","1","68566047","","2021-07-28 17:56:13","","2","788","<p>Is there a way to mock the viewmodels of an application that uses SwiftUI and Combine? I always find articles about mocking services used by the viewmodel but never mocking a viewmodel itself.</p>
<p>I tried to create protocols for each viewmodel. Problem: the @Published wrapper cannot be used in protocols. It seems like there are no solutions...</p>
<p>Thanks for your help</p>
","8144073","","","","","2021-07-28 19:01:17","Mocking view model in swiftui with combine","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"68567716","1","68567824","","2021-07-28 21:46:59","","0","63","<p>I created a custom view, NetworkImage, to load image asynchronously.</p>
<pre><code>import Combine
import SwiftUI

struct NetworkImage&lt;Placeholder: View&gt;: View {
    @StateObject private var viewModel = NetworkImageViewModel()
    let url: String?
    let placeholder: Placeholder
    let saveLocally:Bool
    
    init(_ url: String?, @ViewBuilder placeholder: () -&gt; Placeholder, saveLocally:Bool = false) {
        self.url = url
        self.placeholder = placeholder()
        self.saveLocally = saveLocally
    }
    
    func loadImage(_ url:String?)  {
        if let url = url {
            viewModel.loadImage(from: url, saveLocally: saveLocally)
        }
    }
    
    var body: some View {
        Group {
            if let uiImage = viewModel.image {
                Image(uiImage: uiImage)
                    .resizable()
            } else {
                placeholder
            }
        }
        .onAppear {
            if let url = url {
                viewModel.loadImage(from: url, saveLocally: saveLocally)
            }
        }
    }
}

</code></pre>
<p>I use this in my views and it works really well. But now I would like to be able to replace the image with a new one each time the url change.
How can I do that? How can I pass a @Published property of my view's viewmodel to this NetworkImage view and make it work?</p>
<p>Thanks</p>
","8144073","","","","","2021-07-28 22:02:31","Observe property change in custom view SwiftUI","<view><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68581162","1","68582733","","2021-07-29 18:22:22","","0","212","<p>I'm having difficulty trying to figure out how to loop <code>TMDb</code> results from my publisher 1 and use the value I'm getting from key <code>id</code> for my second publisher. It's not looping through each result, it does get the proper URL inside my <code>func fetchVideos(_ id: Int)</code> but it's not calling each URL from <code>TMDb</code>'s results array. I'm not sure if it's because I'm also getting an Array of results from <code>Videos</code> Codable data?</p>
<p>I attempted to use <code>Publishers.MergeMany</code> in my first publisher's <code>flatMap</code>. I'm still definitely at a novice level for combine, any tips would help. I'm trying to get a list of movies, then from the movies get the <code>id</code> key then use that to fetch the movie trailer data for each movie.</p>
<p>print output</p>
<pre><code>https://api.themoviedb.org/3/movie/602223/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/459151/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/385128/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/522478/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/637693/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/529203/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/578701/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/631843/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/645856/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/581644/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/436969/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/568620/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/522931/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/681260/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/630586/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/671/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/618416/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/646207/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/550988/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/482373/videos?api_key=API_KEY&amp;language=en-US


Videos(id: 459151, results: [themoviedb_demo.Video(id: 3F24D610-4261-4AEB-8906-A9D0E5FE8E4D, iso639_1: &quot;en&quot;, iso3166_1: &quot;US&quot;, key: &quot;CK6xdYIsaa0&quot;, name: &quot;DreamWorks\' The Boss Baby: Family Business | Official Trailer #3 | Peacock&quot;, site: &quot;YouTube&quot;, size: 1080, type: &quot;Trailer&quot;), themoviedb_demo.Video(id: 417EF49C-B983-4CC3-B435-7A902DECE917, iso639_1: &quot;en&quot;, iso3166_1: &quot;US&quot;, key: &quot;-rF2j6K5FoM&quot;, name: &quot;The Boss Baby 2: Family Business – Official Trailer 2 (Universal Pictures) HD&quot;, site: &quot;YouTube&quot;, size: 1080, type: &quot;Trailer&quot;), themoviedb_demo.Video(id: C34A3F5F-9429-4267-86F0-5506EF3E8281, iso639_1: &quot;en&quot;, iso3166_1: &quot;US&quot;, key: &quot;QPzy8Ckza08&quot;, name: &quot;THE BOSS BABY: FAMILY BUSINESS | Official Trailer&quot;, site: &quot;YouTube&quot;, size: 1080, type: &quot;Trailer&quot;)])
</code></pre>
<p>Codable data</p>
<pre class=""lang-swift prettyprint-override""><code>struct Videos: Codable {
    let id: Int
    let results: [Video]
}

struct Video: Codable {
    let id = Int
    let key: String
    let name: String

    enum CodingKeys: String, CodingKey {
        case id
        case key, name
    }
}


struct TMDb: Codable {
    let results: [Results]?
}

struct Results: Codable {
    let id: Int
    let releaseDate, title: String?
    let name: String?

    enum CodingKeys: String, CodingKey {
        case id
        case releaseDate = &quot;release_date&quot;
        case title
        case name
    }
}

</code></pre>
<pre class=""lang-swift prettyprint-override""><code>@Published var movies = TMDb(results: Array(repeating: Results(id: 1, releaseDate: &quot;&quot;, title: &quot;&quot;, name: &quot;&quot;) , count: 5))
@Published var videos = Videos(id: 1, results: Array(repeating: Video(id: 1, key: &quot;&quot;, name: &quot;&quot;) , count: 5))

func getUpcoming() {
    var request = URLRequest(url:URL(string:&quot;https://api.themoviedb.org/3/movie/upcoming?api_key=API_KEY&amp;language=en-US&amp;page=1&quot;)!)
    request.httpMethod = &quot;GET&quot;
    let publisher = URLSession.shared.dataTaskPublisher(for: request)
        .map{ $0.data }
        .decode(type: TMDb.self, decoder: JSONDecoder())
    let publisher2 = publisher
        .flatMap{
            // loop results from TMDb for id for publisher 2, only one is called
            Publishers.MergeMany($0.results!.map { item in
                return self.fetchVideos(item.id)
                    .map { $0 as Videos }
                    .replaceError(with: nil)
            })
        }
    // Publishers.CombineLatest
    Publishers.Zip(publisher, publisher2)
        .receive(on:  DispatchQueue.main)
        .sink(receiveCompletion: {_ in
        }, receiveValue: { movies, videos in
            self.movies = movies
            self.videos = videos
        }).store(in: &amp;cancellables)
}

func fetchVideos(_ id: Int) -&gt; AnyPublisher&lt;Videos, Error&gt; {
    let url = URL(string: &quot;https://api.themoviedb.org/3/movie/\(id)/videos?api_key=API_KEY&amp;language=en-US&quot;)!
    return URLSession.shared.dataTaskPublisher(for: url)
        .mapError { $0 as Error }
        .map{ $0.data }
        .decode(type: Videos.self, decoder: JSONDecoder())
        .eraseToAnyPublisher()
}
</code></pre>
","14601731","","","","","2021-07-29 21:00:36","Chaining with flatMap","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"68582367","1","68584044","","2021-07-29 20:20:11","","0","375","<p>Can I add a tap publisher to a UIView or UILabel? UIButton has tapPublisher built in. I tried making an extension, but extensions can't store properties.</p>
<p>Also, is it bad practices to try and use a tap publisher on anything that isn't a button?</p>
<pre><code>    func bindViewModel() {
        cancellables = [
            continueButton.tapPublisher.sink { [unowned self] in
                viewModel.action
                    .send(.question)
            },
            headlineLabel.tapPublisher.sink {
                // Error: &quot;Value of type 'UILabel' has no member 'tapPublisher'...&quot;
            })
        ]
    }
</code></pre>
","7431741","","3585796","","2021-08-11 08:51:03","2021-08-11 08:51:03","Apple Combine add TapPublisher to UIView","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"68605557","1","68610203","","2021-07-31 20:16:12","","0","46","<p>I would like to create a module, that will refresh token if needed and repeat latest request using <code>Combine</code> from Apple.</p>
<p>For now, every part is works well, but not this one:</p>
<pre><code>  public func executeRequest&lt;T: Decodable, E: ServerErrorType&gt;(
    _ request: HTTPRequest,
    mapper: ObjectMapper&lt;T, E&gt;
  ) -&gt; AnyPublisher&lt;(T, HTTPResponse), Error&gt; {
        return authentificator // &lt;- handle refresh token stuff
          .refreshToken(force: false)
          .subscribe(on: DispatchQueue.global())
          .flatMap { token in // &lt;- on obtain token - transform it into request

---&gt; (here)
            session.publisher(for: request, mapper: mapper, token: token) // &lt;- create request 
---&gt; (here)
              .tryCatch({ error -&gt; AnyPublisher&lt;(T, HTTPResponse), Error&gt; in
                if let error = error as? ServerErrorType,
                   error.isAuthError {
                  
                  return authentificator
                    .refreshToken(force: true)
                    .subscribe(on: DispatchQueue.global())
                    .flatMap { token -&gt; AnyPublisher&lt;(T, HTTPResponse), Error&gt; in
                      session.publisher(for: request, mapper: mapper, token: token) //&lt;- repeat if token refreshed
                    }
                    .eraseToAnyPublisher()
                } else {
                  throw error
                }
              })
              .print()
          }
          .receive(on: DispatchQueue.main)
          .print()
          .eraseToAnyPublisher()
   }

</code></pre>
<p>In place where  I mark <code>(here)</code> when I have expired token, tryCatch wont works, instead &quot;received canceled&quot; printed in console. I'm not sure what I did wrong. Can any on advice?</p>
","2012219","","","","","2021-08-01 12:05:26","""Receive canceled"" when transform Publisher","<ios><swift><combine><urlsession>","1","2","","","","CC BY-SA 4.0"
"68613998","1","68616506","","2021-08-01 20:08:09","","0","63","<p>The execution of this code is confusing me:</p>
<pre><code>class RecipeListViewModel: ObservableObject {
    
    @Published var recipeList = [RecipeViewModel]()
    
    init(){

        RecipeRepository.$allRecipeVMs.map { recipes in
            recipes.map { recipe in
            recipe
            }
        }
        .assign(to: &amp;$recipeList)
    }
}
</code></pre>
<p>My understanding was that SwiftUI publishers are uni-directional, meaning that when <code>RecipeRepository.allRecipeVMs</code> is modified <code>recipeList</code> is too. However, the behaviour I'm seeing is that When <code>recipeList</code> is updated, <code>RecipeRepository.allRecipeVMs</code> is also updated. I've tried to find documentation on this but can't seem to find anything.</p>
<p>Here is the <code>RecipeViewModel</code> class, not sure if it's useful:</p>
<pre><code>class RecipeViewModel : Identifiable, ObservableObject, Hashable{
    
    var id = UUID().uuidString
    @Published var recipe: Recipe

    init(recipe: Recipe){

        self.recipe = recipe
    }
}
</code></pre>
","10142976","","","","","2021-08-02 04:53:42","SwiftUI/Combine Are publishers bi-directional?","<swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"68623753","1","68625818","","2021-08-02 14:56:02","","-1","173","<p>In my project i hold a large dict of items that are updated via grpc stream. Inside the app there are several places i am rendering these items to UI and i would like to propagate the realtime updates.</p>
<p>Simplified code:</p>
<pre class=""lang-swift prettyprint-override""><code>struct Item: Identifiable {
    var id:String = UUID().uuidString
    var name:String
    var someKey:String
    
    init(name:String){
        self.name=name
    }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>class DataRepository {
    public var serverSymbols: [String: CurrentValueSubject&lt;Item, Never&gt;] = [:]
    
    // method that populates the dict
    func getServerSymbols(serverID:Int){
        someService.fetchServerSymbols(serverID: serverID){ response in
            response.data.forEach { (name,sym) in
                self.serverSymbols[name] = CurrentValueSubject(Item(sym))
            }
        }
    }

    // background stream that updates the values
    func serverStream(symbols:[String] = []){
        someService.initStream(){ update in
            DispatchQueue.main.async {
                self.serverSymbols[data.id]?.value.someKey = data.someKey
            }
        }
    }
     
}
</code></pre>
<p>ViewModel:</p>
<pre class=""lang-swift prettyprint-override""><code>class SampleViewModel: ObservableObject {
    @Injected var repo:DataRepository   // injection via Resolver

    // hardcoded value here for simplicity (otherwise dynamically added/removed by user)
    @Published private(set) var favorites:[String] = [&quot;item1&quot;,&quot;item2&quot;]

    func getItem(item:String) -&gt; Item {         
        guard let item = repo.serverSymbols[item] else { return Item(name:&quot;N/A&quot;)}
        return ItemPublisher(item: item).data
    }
}

class ItemPublisher: ObservableObject {
    @Published var data:Item = Item(name:&quot;&quot;)
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(item:CurrentValueSubject&lt;Item, Never&gt;){
        item
            .receive(on: DispatchQueue.main)
            .assignNoRetain(to: \.data, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>Main View with subviews:</p>
<pre class=""lang-swift prettyprint-override""><code>struct FavoritesView: View {
    @ObservedObject var viewModel: QuotesViewModel = Resolver.resolve()
    var body: some View {
        VStack {
            ForEach(viewModel.favorites, id: \.self) { item in
                    FavoriteCardView(item: viewModel.getItem(item: item))
            }
        }
    }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>struct FavoriteCardView: View {
    var item:Item
    var body: some View {
        VStack {
            Text(item.name)
            Text(item.someKey)   // dynamic value that should receive the updates
        }
    }
}
</code></pre>
<p>I must've clearly missed something or it's a completely wrong approach, however my Item cards do not receive any updates (i verified the backend stream is active and serverSymbols dict is getting updated). Any advice would be appreciated!</p>
","1389597","","1389597","","2021-08-03 11:43:21","2021-08-03 11:43:21","SwiftUI+Combine - Dynamicaly subscribing to a dict of publishers","<swift><swiftui><combine>","1","7","","","","CC BY-SA 4.0"
"68625105","1","68625490","","2021-08-02 16:35:04","","0","85","<p>So I have a <code>View</code> with <code>List</code> of subviews that take an object. These objects come from array that is in my data manager.</p>
<pre><code>struct ContentView: View {
@ObservedObject var manager = AppConnectivityManager.shared

var body: some View {
    
        List {
            ForEach(manager.goals, id: \.id) { goal in
                let _ = print(&quot;goal in foreach: \(goal.goal.completitionCount) + title: \(goal.goal.title)&quot;)
                GoalView(goalWrapper:goal)
            }.listRowBackground(Color.clear)
        }
    
    }
}
</code></pre>
<p>This part works well and update is triggered every time I update the manager object.</p>
<p>The problem is that my <code>GoalView(goalWrapper:goal)</code> gets only updated once when the code runs first time but then when its supposed to be refreshed it stays the same. This <code>print(&quot;progress:</code> statement in the goal view prints always the same values but the print statement in the list gets the updates. I might be missing the concept but I though I can pass the <code>ObservedObject</code> down the subview and it will get updated when <code>manager</code> gets also updated but that is not the case.</p>
<pre><code>struct GoalView: View {

@ObservedObject var goalWrapper: GoalWrapper

var body: some View {
    let _ = print(&quot;progress: \(self.goalWrapper.goal.completitionCount) + daily: \(self.goalWrapper.goal.dailyNotificationCount) + title: \(self.goalWrapper.goal.title)&quot;)
    ZStack(content: {
        GoalAnimationView(goalWrapper: self.goalWrapper).cornerRadius(10)
        VStack(alignment: .leading, spacing: nil, content: {
            Text(goalWrapper.goal.title).foregroundColor(.black).padding(.leading, 8)
                .padding(.trailing, 8)
                .padding(.top, 4)
            HStack(alignment: .center,content: {
                Text(&quot;\(goalWrapper.goal.completitionCount)/\(goalWrapper.goal.dailyNotificationCount)&quot;).padding(.top, 2).padding(.trailing, 85).padding(.bottom, 6)
                Text(&quot;\(goalWrapper.goal.completitionCount)&quot;).padding(.top, 2).padding(.trailing, 12).padding(.bottom, 12).font(.title)
            }).frame(minWidth: 0, maxWidth: .infinity, minHeight: 0,maxHeight: 35,alignment: .trailing).background(Color.clear)


        }).listRowPlatterColor(Color.blue).frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, alignment: .leading).cornerRadius(10)
        
    })
  }
}
</code></pre>
<p>Here is the <code>GoalWrapper</code> class</p>
<pre><code>public class GoalWrapper: ObservableObject, Hashable {

    public static func == (lhs: GoalWrapper, rhs: GoalWrapper) -&gt; Bool {
        return lhs.goal.id == rhs.goal.id
    }

    public func hash(into hasher: inout Hasher) {
         hasher.combine(goal.id)
    }

    @Published var goal: Goal!
    let id: String
    init(goal: Goal) {
        self.goal = goal
        self.id = goal.id
   }
}
</code></pre>
<p>Is there some way How I can pass the updates to the list subviews? I have found some other people having issues with lists and passing a binding to the views in list. Is that the only way ?</p>
","4107264","","","","","2021-08-02 17:04:23","List item is not being updated","<swiftui><combine><swiftui-list>","1","1","","","","CC BY-SA 4.0"
"68665260","1","68665913","","2021-08-05 10:55:16","","2","325","<p>I have some difficulty using Combine in SwiftUI with making an API request and then decoding the data and returning it. When calling the API Service, it states in the 'AnyPublisher&lt;UserLoginResponse, APIError&gt;' that the result will be of such type. However, I would want to reuse the API Service and decode the response to different model structures. How can I call the API Service while defining which data structure it has to decode the returned data to? For example, in another ViewModel I would want to decode the API data to a 'NewsUpdatesResponse' instead of 'UserLoginResponse'. The code I have now is as follows:</p>
<p>Most code comes from: <a href=""https://www.youtube.com/watch?v=M2psX-JwHdE&amp;t=1039s"" rel=""nofollow noreferrer"">tundsdev</a></p>
<p><strong>API Service</strong></p>
<pre><code>struct APIService {

func request(from endpoint: APIRequest, body: String) -&gt; AnyPublisher&lt;UserLoginResponse, APIError&gt; {
    
    var request = endpoint.urlRequest
    request.httpMethod = endpoint.method
    
    if endpoint.authenticated == true {
        request.setValue(&quot;testToken&quot;, forHTTPHeaderField: &quot;token&quot;)
    }
    if body != &quot;&quot; {
        let finalBody = body.data(using: .utf8)
        request.httpBody = finalBody
    }
    
    return URLSession
        .shared
        .dataTaskPublisher(for: request)
        .receive(on: DispatchQueue.main)
        .mapError { _ in APIError.unknown}
        .flatMap { data, response -&gt; AnyPublisher&lt;UserLoginResponse, APIError&gt; in
            
            guard let response = response as? HTTPURLResponse else {
                return Fail(error: APIError.unknown).eraseToAnyPublisher()
            }
            
            print(response.statusCode)
            
            if response.statusCode == 200 {
                let jsonDecoder = JSONDecoder()
                
                return Just(data)
                    .decode(type: UserLoginResponse.self, decoder: jsonDecoder)
                    .mapError { _ in APIError.decodingError }
                    .eraseToAnyPublisher()
            }
            else {
                return Fail(error: APIError.errorCode(response.statusCode)).eraseToAnyPublisher()
            }
        }
        .eraseToAnyPublisher()
    }
}
</code></pre>
<p><strong>Login ViewModel</strong></p>
<pre><code>class LoginViewModel: ObservableObject {

@Published var loginState: ResultState = .loading

private var cancellables = Set&lt;AnyCancellable&gt;()
private let service: APIService

init(service: APIService) {
    self.service = service
}

func login(username: String, password: String) {
    
    self.loginState = .loading
    
    let cancellable = service
        .request(from: .login, body: &quot;username=admin&amp;password=admin&quot;)
        .sink { res in
            print(res)
            switch res {
            case .finished:
                self.loginState = .success
            case .failure(let error):
                self.loginState = .failed(error: error)
            }
        } receiveValue: { response in
            print(response)
        }
    
    self.cancellables.insert(cancellable)
    }
}
</code></pre>
","14855422","","14855422","","2021-08-05 23:02:35","2021-08-05 23:02:35","SwiftUI Combine Publisher targetstruct for decoding data","<api><data-structures><swiftui><combine><publisher>","2","0","1","","","CC BY-SA 4.0"
"68670444","1","68675191","","2021-08-05 16:40:17","","5","712","<p>I have a UIKit project with UIViewControllers, and I'd like to present an action sheet built on SwiftUI from my ViewController. I need to bind the appearance and disappearance of the action sheet back to the view controller, enabling the view controller to be dismissed (and for the display animation to happen only on viewDidAppear, to avoid some weird animation behavior that happens when using <code>.onAppear</code>). Here is a code example of how I expect the binding to work and how it's not doing what I'm expecting:</p>
<pre><code>import UIKit
import SwiftUI

class ViewController: UIViewController {
    let button = UIButton(type: .system)
    var show = true
    lazy var isShowing: Binding&lt;Bool&gt; = .init {
        self.show
    } set: { show in
        // This code gets called
        self.show = show
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        
        view.backgroundColor = .white
        button.setTitle(&quot;TAP THIS BUTTON&quot;, for: .normal)
        view.addSubview(button)
        button.translatesAutoresizingMaskIntoConstraints = false
        button.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true
        button.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true
        button.addTarget(self, action: #selector(tapped), for: .touchUpInside)
    }
    
    @objc private func tapped() {
        let vc = UIHostingController(rootView: BindingProblemView(testBinding: isShowing))
        vc.modalPresentationStyle = .overCurrentContext
        present(vc, animated: false)
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) { [self] in
            isShowing.wrappedValue.toggle()
            isShowing.update()
        }
    }
}

struct BindingProblemView: View {
    @Binding var testBinding: Bool
    @State var state = &quot;ON&quot;
    
    var body: some View {
        ZStack {
            if testBinding {
                Color.red.ignoresSafeArea().padding(0)
            } else {
                Color.green.ignoresSafeArea().padding(0)
            }
            
            Button(&quot;Test Binding is \(state)&quot;) {
                testBinding.toggle()
            }.onChange(of: testBinding, perform: { value in
                // This code never gets called
                state = testBinding ? &quot;ON&quot; : &quot;OFF&quot;
            })
        }
    }
}
</code></pre>
<p>What happens is that <code>onChange</code> never gets called after <code>viewDidAppear</code> when I set the binding value <code>true</code>. Am I just completely misusing the new combine operators?</p>
","381474","","381474","","2021-08-05 19:31:06","2021-08-06 01:46:55","How to bind SwiftUI and UIViewController behavior","<ios><swift><swiftui><uikit><combine>","1","4","1","","","CC BY-SA 4.0"
"68712664","1","68713750","","2021-08-09 13:12:01","","4","1240","<p>I'm trying to understand a design pattern for accessing the isolated state held in an actor type from within a SwiftUI view.</p>
<p>Take this naive code:</p>
<pre class=""lang-swift prettyprint-override""><code>actor Model: ObservableObject {
    @Published var num: Int = 0
    
    func updateNumber(_ newNum: Int) {
        self.num = newNum
    }
}

struct ContentView: View {
    @StateObject var model = Model()
    
    var body: some View {
        Text(&quot;\(model.num)&quot;) // &lt;-- Compiler error: Actor-isolated property 'num' can not be referenced from the main actor
        Button(&quot;Update number&quot;) {
            Task.detached() {
                await model.updateNumber(1)
            }
        }
    }
}
</code></pre>
<p>Understandably I get the compiler error <code>Actor-isolated property 'num' can not be referenced from the main actor</code> when I try and access the isolated value. Yet I can't understand how to display this data in a view. I wonder if I need a ViewModel that observes the actor, and updates itself on the main thread, but get compile time error <code>Actor-isolated property '$num' can not be referenced from a non-isolated context</code>.</p>
<pre class=""lang-swift prettyprint-override""><code>class ViewModel: ObservableObject {
    
    let model: Model
    @Published var num: Int
    let cancellable: AnyCancellable
    
    init() {
        let model = Model()
        self.model = model
        self.num = 0
        self.cancellable = model.$num
            .receive(on: DispatchQueue.main)
            .sink { self.num = $0 }
    }
    
}
</code></pre>
<p>Secondly, imagine if this code did compile, then I would get another error when clicking the button that the interface is not being updated on the main thread...again I'm not sure how to effect this from within the actor?</p>
","7820216","","9607863","","2021-08-13 22:51:07","2021-08-13 22:51:07","Accessing an actor's isolated state from within a SwiftUI view","<swift><concurrency><swiftui>","1","0","","","","CC BY-SA 4.0"
"68734145","1","68734227","","2021-08-10 22:36:43","","0","218","<p>I'm not very familiar with Combine's <code>Timer.publish(every:, on: , in: )</code>. Essentially I'm looking to run a timer to call a func in my <code>ObservableObject</code> class. Is there a better way of doing this, not sure if I'm doing so correctly or if there's a cleaner way of doing the same.</p>
<pre class=""lang-swift prettyprint-override""><code>class Example : ObservableObject {
    private var cancellables = Set&lt;AnyCancellable&gt;()
    var cancellable: AnyCancellable? = nil
    
    @Published var somedate: Date = Date()
    
    init() {
        cancellable = Timer
            .publish(every: 1, on: .main, in: .common)
            .autoconnect()
            .sink(receiveValue: { _ in
                self.update()
            })
    }
    
    func update() {
        let publisher =  Date()
        Just(publisher)
            .sink(receiveCompletion: { completion in
            }, receiveValue: { date in
                self.somedate = date
                print(self.somedate)
            }).store(in: &amp;cancellables)
    }
}
</code></pre>
<p>The output seems correct.</p>
<pre><code>2021-08-10 22:25:24 +0000
2021-08-10 22:25:25 +0000
2021-08-10 22:25:26 +0000
2021-08-10 22:25:27 +0000
2021-08-10 22:25:28 +0000
2021-08-10 22:25:29 +0000
2021-08-10 22:25:30 +0000
2021-08-10 22:25:31 +0000
2021-08-10 22:25:32 +0000
2021-08-10 22:25:33 +0000
2021-08-10 22:25:34 +0000
2021-08-10 22:25:35 +0000
2021-08-10 22:25:36 +0000
</code></pre>
","14601731","","","","","2021-08-10 22:49:33","Combine Timer - setting timer","<swiftui><timer><combine>","1","0","","","","CC BY-SA 4.0"
"68742369","1","68743922","","2021-08-11 12:49:21","","1","323","<p>I wonder if it is possible to access values in a combine-operator-chain that are used further up in the chain.</p>
<p>For example, if you have an array of strings, and you download a resource with each string, is it possible to access the string itself?</p>
<p>Maybe a pseudo-code example will help understand better:</p>
<pre><code>let strings = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

strings.publisher
    .compactMap{ str in
        URL(string: &quot;https://someresource/\(str)&quot;)
    }
    .flatMap { url  in
        URLSession.shared.dataTaskPublisher(for: url)
    }
    .map { $0.data}
    .map { data in
        // here I would need the &quot;str&quot; string from above
    }

</code></pre>
<p>Help is much appreciated</p>
<p>Thx, Gregor</p>
","12188194","","12188194","","2021-08-11 14:15:59","2021-08-11 15:12:32","Access used values in a combine-operator-chain","<swift><combine>","1","0","2","","","CC BY-SA 4.0"
"68745323","1","68745585","","2021-08-11 15:55:46","","4","3542","<p>A <code>ViewModel</code> class has a <code>sourceProperty</code> that is being edited by the <code>TextField</code>. That property is <code>@Published</code>. I'd like to pass it to the <code>Logic</code> class which has an initializer with <code>Binding&lt;String&gt;</code>. That class will be listening to the <code>sourceProperty</code> changes, react on them and set it's output to the <code>@Published output</code> property.</p>
<p>How can I pass <code>@Published sourceProperty</code> as an initializer parameter to the <code>Logic</code> class?</p>
<p>Relevant code:</p>
<pre><code>final class ViewModel {
    @Published var sourceProperty: String = &quot;&quot;
    private var logic: Logic?

    init() {
        self.logic = Logic(data: $sourceProperty)
        $logic.output.sink({result in 
            print(&quot;got result: \(result)&quot;)
        })
    }

}

final class Logic: ObservableObject {
    private var bag = Set&lt;AnyCancellable&gt;()
    @Published var output: String = &quot;&quot;
    @Binding var data: String
    init(data: Binding&lt;String&gt;) {
        self._data = data

        $data.sink({ newValue in 
            output = newvalue + &quot;ABCDE&quot;
        }).store(in: &amp;bag)
    }
}
</code></pre>
<p>So far I'm getting the following error:</p>
<blockquote>
<p>Cannot convert value of type 'Published.Publisher' to expected
argument type 'Binding'</p>
</blockquote>
<p>The goal is to use a change in the object's own property to trigger a method invocation in another object and then bind that second object's output to some view.</p>
<p>View Layer:</p>
<pre><code>public struct ViewLayer: View {
    @Binding private var sourceProperty: String

    public init(_ placeholder: String,
                sourceProperty: Binding&lt;String&gt;,
    ) {
        self.placeholder = placeholder
        self._sourceProperty = sourceProperty
    }

    public var body: some View {
        TextField(placeholder, text: $sourceProperty)
    }

 }
</code></pre>
","3667264","","3667264","","2021-08-11 16:11:38","2021-08-11 16:25:11","Pass @Published where @Binding is required (SwiftUI, Combine)","<data-binding><swiftui><binding><combine><publisher>","1","7","3","","","CC BY-SA 4.0"
"68799895","1","68800184","","2021-08-16 08:51:07","","2","135","<p>So, I have few steps, last one contains <strong>EnvironmentObject</strong> and <strong>ObservedObject</strong>. The issue is, when I try to modify <strong>EnvironmentObject</strong> <strong>(lane 68)</strong>  it re-creates <strong>ObservedObject</strong>.
Can any one explain me why this happens? Any solution to keep my <strong>ObservedObject</strong> with original state?</p>
<p>As far as I know it possible to change ObservedObject to StateObject, but I am using iOS 13+ so... I need other solution.</p>
<p><a href=""https://i.stack.imgur.com/d73m1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/d73m1.png"" alt=""enter image description here"" /></a></p>
","9506836","","","","","2021-08-16 09:14:43","SwiftUI changing environment object re-created observed object in same view","<swiftui><environment><combine><observedobject><environmentobject>","1","0","","","","CC BY-SA 4.0"
"68808409","1","68820035","","2021-08-16 19:41:36","","4","534","<p>I have a simple timer publisher that fires every 10 seconds.</p>
<pre><code>Timer
    .publish(every: 10, on: .main, in: .common)
    .autoconnect()
    .map { _ in ... }
    .sink(receiveValue: { [weak self] in
        ...
    })
    .store(in: &amp;subscriptions)
</code></pre>
<p>However, the first time it fires is in 10 seconds from now. Can I set it to fire its first value <em>now</em>?</p>
","10525140","","1974224","","2021-08-17 15:25:25","2021-08-17 15:25:25","Timer publisher with initial fire now","<ios><combine>","2","0","","","","CC BY-SA 4.0"
"68874223","1","69198997","","2021-08-21 15:08:37","","1","137","<p>There are several methods within Combine like...</p>
<ul>
<li><code>breakpointOnError()</code></li>
<li><code>breakpoint(receiveSubscription:receiveOutput:receiveCompletion:)</code></li>
</ul>
<p>What happens if you forget to remove these and it goes into a release build? Does the compiler pass them over because there's a release flag on the build or do I risk an exception?</p>
","4475605","","","","","2021-11-18 05:37:52","Using breakpointOnError() in Combine","<ios><swift><debugging><combine>","2","3","","","","CC BY-SA 4.0"
"68897689","1","68898031","","2021-08-23 18:53:59","","1","112","<p>I am very new to programming in Swift. So I'm trying to come up with a time management program. I have posted some code that have been derived from my project that is a work in progress, and I'm trying to troubleshoot some issues that I'm having that come from my lack of knowledge regarding Swift and SwiftUI. I would like to ask two questions here, but if you only have the answer to just one of them, I would greatly appreciate it.</p>
<p>So in my ContentView, I'm trying to display the taskName of the object with ID 0 using a Text in a VStack -- however, it is not displaying, and I'm not sure of the reason why. I can display the taskLength by putting it inside the String method, but taskName is not coming up when I attempt to display it.</p>
<p>Also I'm attempting to change the taskName of Task(id: 0) that is being passed into display2 directly from the display2, but I'm not sure if the taskName of Task(id: 0) is actually being changed, or it's only the taskName of @State var task:Task in display2 that is being changed -- based on my intuitions, I would think the latter case is actually happening. In that case, is there a way to directly edit the taskName of Task(id: 0) from display2?</p>
<pre><code>import SwiftUI
import Foundation
import Combine

struct Task: Hashable, Codable, Identifiable {
    var id: Int
    var taskName: String = &quot;&quot;
    var taskLength: Int = 0
    var isBreak : Bool = false
}

class ModelData : ObservableObject{
    @Published var tasks: [Task] = [
        Task(id: 0,taskName: &quot;Test&quot;, taskLength: 34, isBreak: false),
        Task(id: 1,taskName: &quot;Math&quot;, taskLength: 30, isBreak: false),
        Task(id: 2,taskName: &quot;Science&quot;, taskLength: 40, isBreak: false)
    ]
}

struct ContentView: View {
    @EnvironmentObject var modelData: ModelData
    var body: some View {
        VStack{
            Text(Task(id: 0).taskName)
            display2(task:Task(id: 0))
        }
    }
}

struct display2: View{
    @State var task:Task
    var body: some View {
        TextField(&quot;New task&quot;,text: $task.taskName)
    }
}
</code></pre>
","16700377","","","","","2021-08-23 19:24:59","SwiftUI: String property of an object is not displaying in Text, and how would you edit a string in an object?","<arrays><swift><object><swiftui>","2","0","","","","CC BY-SA 4.0"
"68910423","1","68910499","","2021-08-24 15:51:49","","-1","746","<p>I am trying to fetch data by Restcountries API, but there is a problem. When I try to fetch data the error immediately shows up:</p>
<blockquote>
<p>2021-08-24 17:36:44.851463+0200 Countries[1498:19786] Task &lt;3FF6E673-52AD-47FE-9342-229E2CE99859&gt;.&lt;1&gt; finished with error [-999] Error Domain=NSURLErrorDomain Code=-999 &quot;cancelled&quot; UserInfo={NSErrorFailingURLStringKey=https://restcountries.eu/rest/v2/all, NSLocalizedDescription=cancelled, NSErrorFailingURLKey=https://restcountries.eu/rest/v2/all}</p>
</blockquote>
<p>It shows every single time. Any idea how to resolve that?</p>
<p>APIService:</p>
<pre><code>final class APIService: APIServiceProtocol {


func fetchAllCountries(url: URL) -&gt; AnyPublisher&lt;[Country], APIError&gt; {
    
    let request = URLRequest(url: url)
    
    return URLSession.DataTaskPublisher.init(request: request, session: .shared)
        .tryMap { data, response in
            guard let httpResponse = response as? HTTPURLResponse, 200..&lt;300 ~= httpResponse.statusCode else {
                throw APIError.unknown
            }
            
            return data
    }
    .decode(type: [Country].self, decoder: JSONDecoder())
    .mapError { error in
        if let error = error as? APIError {
            return error
        } else {
            return APIError.apiError(reason: error.localizedDescription)
        }
    }
    .eraseToAnyPublisher()
}

}
</code></pre>
<p>ListViewModel:</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

class ListViewModel: ObservableObject {
    
    private let apiService: APIServiceProtocol
    @Published var countries = [Country]()
    
    init(apiService: APIServiceProtocol = APIService()) {
        self.apiService = apiService
    }
    
    func fetchCountries() {
        
        guard let url = URL(string: &quot;https://restcountries.eu/rest/v2/all&quot;) else { return }
        
        let publisher = apiService.fetchAllCountries(url: url)
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    break
                case .failure(let error):
                    print(error.localizedDescription)
                }
            }, receiveValue: { data in
                self.countries = data
                print(data)
        })
        publisher.cancel()
    }
    
}
</code></pre>
","11056400","","366492","","2021-08-31 10:50:23","2021-08-31 10:50:23","Swift Combine: finished with error [-999] Error Domain=NSURLErrorDomain Code=-999 ""cancelled""","<ios><swift><nsurl><combine>","1","0","","","","CC BY-SA 4.0"
"68928354","1","68942288","","2021-08-25 18:47:11","","2","128","<p>I have a somewhat complicated architecture for a feature in my app.</p>
<p>Sample code is below. My original expectation was that this would only print once, because I call <code>cancellableSet.removeAll()</code>. But this actually ends up being called twice, which creates problems in my application.</p>
<p>How do I get this so it only fires what's in the <code>sink</code> after the subscription is stored in the cancellable set.</p>
<p>Note that I have a few restrictions here that I'll mention. My sample code is just simplifying this.</p>
<ul>
<li>Can't use a <code>take</code> or <code>drop</code> operation, as this may get called an undetermined amount of times.</li>
</ul>
<pre><code>import Combine

enum State {
    case loggedOut
    case doingSomething
}

let aState = CurrentValueSubject&lt;State, Never&gt;(.doingSomething)
private var cancellableSet: Set&lt;AnyCancellable&gt; = []

func logUserOut() {
    cancellableSet.removeAll()
    aState.send(.loggedOut)
}

func doSomethingElse() { }
aState.sink { newState in
    print(&quot;numberOfSubscriptions is: \(cancellableSet.count)&quot;)
    switch newState {
    case .loggedOut:
        doSomethingElse()
    case .doingSomething:
        logUserOut()
    }
    
}
.store(in: &amp;cancellableSet)
</code></pre>
","9718260","","9718260","","2021-08-25 20:15:23","2021-08-26 16:31:23","How do I cancel a combine subscription within a sink?","<swift><combine>","2","9","","","","CC BY-SA 4.0"
"68938792","1","68939264","","2021-08-26 12:46:58","","0","172","<p>I'm currently trying to modify an upcoming value from a textField which is using a <code>Binding&lt;Double&gt;</code>, but haven't found any working solution yet. It's only been infinite loops (Like the example below) and other solutions which didn't work in the end anyway. So, for example, if an user inputs an amount which is too low, I would want to change the upcoming value to the minimum and vice verse if the value is higher than the maximum value.</p>
<p>I also want to present the <code>modified</code> value (if needed) for the user, so I can't just store it in another variable.</p>
<p>Any ideas on how to solve this?</p>
<h3>Example</h3>
<pre><code>class ViewModel: ObservableObject {
    @Published var amount: Double

    private var subscriptions: Set&lt;AnyCancellable&gt; = []
    private let minimum: Double = 10_000
    private let maximum: Double = 100_000

    init() {
        $amount
            .sink {
                if $0 &lt; self.minimum {
                    // Set minimum value
                    self.amount = self.minimum
                } else if $0 &gt; self.maximum {
                    // Set maximum value
                    self.amount = self.maximum
                }

                // If `Else` is implemented it will just be an infinite loop...
                else {
                    self.amount = $0
                }
            }
            .store(in: &amp;subscriptions)
    }

    func prepareStuff() {
        // Start preparing
        let chosenAmount = amount
    }
}
</code></pre>
","7653367","","7653367","","2021-08-26 12:52:09","2021-08-26 13:49:12","Update upcoming values in sink if needed","<swift><swiftui><combine>","1","0","0","","","CC BY-SA 4.0"
"68951141","1","68951525","","2021-08-27 09:31:38","","0","349","<p>I'm writing an application to get time based on timezone's, I'm unsure what's the proper way to keep time text up-to-date. It seems to lag because I'm using a <code>Timer</code> for updating every second. The example is pretty bland version of my project but close enough.</p>
<p>Also, I noticed the <code>Timer</code> may be interfering with my UI. If I have <code>navigationBarItems</code> such as a button, I can't click it <em>(must be when the timer is updating).</em> In main project.</p>
<p>Is there a better solution, something a little more elegant than using a <code>Timer</code>? I'm still new to <code>Swift</code>, so I have limitations.</p>
<p><a href=""https://i.stack.imgur.com/VyvLh.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/VyvLh.png"" alt=""enter image description here"" /></a></p>
<pre class=""lang-swift prettyprint-override""><code>extension String {
    func timezone(_ date: Date) -&gt; String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = &quot;h:mm a&quot;
        dateFormatter.timeZone = TimeZone(identifier: self)
        return dateFormatter.string(from: Date())
    }
}

class TimerData: ObservableObject {
    @Published var date = Date()
    var cancellable: AnyCancellable? = nil
    
    init() {
        cancellable = Timer
            .publish(every: 1, on: .main, in: .common)
            .autoconnect()
            .sink(receiveValue: { [self] _ in
                self.date = Date()
            })
    }
}

struct ContentView: View {
    @StateObject var timers = TimerData()
    @State var timezones = [TimeZone.current.identifier, &quot;America/Halifax&quot;]
    var body: some View {
        List {
            ForEach(timezones, id: \.self) { city in
                Text(city.timezone(Date()))
            }
        }
    }
}
</code></pre>
","14601731","","9607863","","2021-08-27 09:52:35","2021-08-27 11:23:33","SwiftUI - Timer to update text","<swift><swiftui>","3","4","","","","CC BY-SA 4.0"
"68962673","1","69322063","","2021-08-28 08:36:17","","0","368","<p>I have some code like this</p>
<pre class=""lang-swift prettyprint-override""><code>func a() -&gt; AnyPublisher&lt;Void, Never&gt; {
    Future&lt;Void, Never&gt; { promise in
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            print(1)
            promise(.success(()))
        }
    }
    .eraseToAnyPublisher()
}

func b() -&gt; AnyPublisher&lt;Void, Never&gt; {
    Future&lt;Void, Never&gt; { promise in
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            print(2)
            promise(.success(()))
        }
    }
    .eraseToAnyPublisher()
}

var tempBag = Set&lt;AnyCancellable&gt;()

let subject = CurrentValueSubject&lt;Int, Never&gt;(1)

subject
    .flatMap({ _ in a() })
    .flatMap({ _ in b() })
    .print()
    .sink(receiveCompletion: { _ in
        tempBag.removeAll()
    }, receiveValue: {  })
    .store(in: &amp;tempBag)
</code></pre>
<p>So, I have some uncompletable subject in the root of the stream and some completable publishers in flatMap operator. I want the overall stream to complete when the last flatMap's publisher completes. So, I want the console to look like this:</p>
<pre><code>receive subscription: (FlatMap)
request unlimited
1
2
receive value: (())
receive finished
</code></pre>
<p>but actual result is</p>
<pre><code>receive subscription: (FlatMap)
request unlimited
1
2
receive value: (())
</code></pre>
<p>How can I achieve this?</p>
","9174707","","","","","2021-09-24 23:48:15","How make Combine's flatMap to complete overall stream?","<ios><swift><combine>","1","1","0","","","CC BY-SA 4.0"
"68967390","1","68968273","","2021-08-28 19:01:00","","-1","190","<p>is there a way i can identify one button from others when they seem to represent the same logic.</p>
<p>So i download files from coredata and can play them on &quot;play&quot; button click, but the problem is i am unable to &quot;stop&quot; the already  playing music when i click on another &quot;play&quot; button.</p>
<p>How can i stop this and make sure when one button click implements the logic at a time others toggle to a same opposite state , the button is inside a List which has a ForEach View, kindly guide , thanks..</p>
<pre><code>@State var playButton = false -&gt; this outside body
Button(action: {
        playButton.toggle()
     do {
       if playButton {
         self.audioPlayer = try AVAudioPlayer(data: songCellVM.song.songMp3!)
         self.audioPlayer?.prepareToPlay()
         self.audioPlayer?.play()       
       }
       else {
         self.audioPlayer?.stop() 
       }
     } catch let error {
         print(&quot;\(error.localizedDescription)&quot;)
   }
      }){   Image(systemName: playButton ? &quot;playpause&quot; : &quot;play&quot;)
        .resizable()
        .frame(width: 25, height: 25, alignment: 
        .padding()
      }
</code></pre>
<p>//-------- The View File which not only changes the play and pause button correctly but also creates a common audioPlayer that can be used to make sure only one song is playing at a time. Also i use the approach as suggest by @adrien to create a binding by making an instance in ViewModel and publishing it and then using a Binding in the View. This makes sure that the View uses the unique instance defined in ViewModel when it is accessed in Cells that get their source of truth from it.</p>
<pre><code>import Foundation
import SwiftUI
import Combine
import AVFoundation

struct ArtistViewMain: View {
    
    
    
    @ObservedObject var songsListVM = SongListVM()
    @ObservedObject var repo = SongRepository()
    
    var body: some View {
        VStack {
            NavigationView {
                List {
                    ForEach(songsListVM.songCellVMs) {
                        songCellVM in
                        SongCell(songCellVM: songCellVM, selectedSong: $songsListVM.selectedSong, audioPlayer: $songsListVM.audioPlayer)
                    }
                }
                .navigationTitle(&quot;Artists&quot;)
            }
        }
        
        
    }
}

struct SongCell: View {
    @ObservedObject var songCellVM: SongCellVM
    @State var playButton: Bool = false
  //  @State var audioPlayer:AVAudioPlayer?
    @Binding var selectedSong: Song?
    @Binding var audioPlayer: AVAudioPlayer?
    var isSelected: Bool { songCellVM.song.id == selectedSong?.id }
    var onCommit: () -&gt; () = {  }
    var body: some View {
        HStack {
            
            Text(songCellVM.song.artistname)
            Spacer()
            Image(uiImage: UIImage(data: songCellVM.song.artistImage ?? Data()) ?? UIImage())
                .resizable()
                .frame(width: 70, height: 70, alignment: .center)
                .scaledToFit()
                .cornerRadius(20)
            
            //----
            
            Button(action: {
                self.audioPlayer?.stop()
              
                if isSelected  {
                    
                    selectedSong = nil
                   
                    
                } else {
                  
                    selectedSong = songCellVM.song
                    
                    do {
                        self.audioPlayer = try AVAudioPlayer(data: songCellVM.song.songMp3!)
                        self.audioPlayer?.prepareToPlay()
                        self.audioPlayer?.play()
                       
                        
                        
                        
                    } catch let error {
                        print(&quot;\(error.localizedDescription)&quot;)
                    }
                    
                }
                
                
            }){     Image(systemName: isSelected ? &quot;playpause&quot; : &quot;play&quot;)
                .resizable()
                .frame(width: 25, height: 25, alignment: /*@START_MENU_TOKEN@*/.center/*@END_MENU_TOKEN@*/)
                .padding()
            }
            .buttonStyle(PlainButtonStyle())
            
            //            .onAppear {
            //                if playButton == true {
            //                    playButton.toggle()
            //                }
            //            }
                        .onDisappear{
                           // self.playButton.toggle()
                            self.audioPlayer?.stop()
                        }
            
            
            //--------
            
            //-----
            
        }
    }
}
</code></pre>
","3151281","","3151281","","2021-09-09 16:13:02","2021-09-09 16:13:02","How to manage button state in swiftUI","<swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"68988218","1","68988332","","2021-08-30 17:37:25","","0","149","<p>I have the following model:</p>
<pre><code>struct Book: Codable, Identifiable {
    var id: Int
    var title: String
    var author: String
}

struct BookWrapper: Codable {
    var books: [Book]

}
</code></pre>
<p>and JSON:</p>
<pre><code>{
  &quot;books&quot;: [
    {
        &quot;id&quot;:     1,
        &quot;title&quot;:  &quot;Nineteen Eighty-Four: A Novel&quot;,
        &quot;author&quot;: &quot;George Orwell&quot;
    }, {
        &quot;id&quot;:     2,
        &quot;title&quot;:  &quot;Animal Farm&quot;,
        &quot;author&quot;: &quot;George Orwell&quot;
    }
  ],
  &quot;errMsg&quot;: null
}
</code></pre>
<p>I'm trying to grab data using Combine, but cannot find a way how to go around that books array. In case of <em>flat</em> data I would use following:</p>
<pre><code>func fetchBooks() {
        URLSession.shared.dataTaskPublisher(for: url)
            .map{ $0.data }
            .decode(type: [Book].self, decoder: JSONDecoder())
            .replaceError(with: [])
            .eraseToAnyPublisher()
            .receive(on: DispatchQueue.main)
            .assign(to: &amp;$books)
    }   
</code></pre>
<p>I tried to use BookWrapper.self, but it doesn't make sense. Is there any elegant way how to solve it?</p>
","183112","","9607863","","2021-08-30 18:25:52","2021-08-30 18:25:52","Combine and nested JSON objects","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"68998373","1","69013828","","2021-08-31 12:05:06","","3","1143","<p>This is a general question about SwiftUI and the architecture, so I'll take a simple but problematic example.</p>
<h1>Initial project :</h1>
<p>I have a first <code>View</code> which displays a list of <code>Item</code>s. This list is managed by a class (which I called <code>ListViewModel</code> here). In a second view I can modify one of these <code>Item</code>s, and save these modifications with a &quot;save&quot; button. In a simplified version, I can do this easily using <code>@Binding</code>. Thanks SwiftUI:</p>
<pre><code>struct ListView: View {
    @StateObject var vm = ListViewModel()
    var body: some View {
        NavigationView {
            List(Array(vm.data.enumerated()), id: \.1.id) { index, item in
                NavigationLink(destination: DetailView(item: $vm.data[index])) {
                    Text(item.name)
                }
            }
        }
    }
}

struct DetailView: View {
    @Binding var initialItem: Item
    @State private var item: Item
    init(item: Binding&lt;Item&gt;) {
        _item = State(initialValue: item.wrappedValue)
        _initialItem = item
    }
    var body: some View {
        VStack {
            TextField(&quot;name&quot;, text: $item.name)
            TextField(&quot;description&quot;, text: $item.description)
            Button(&quot;save&quot;) {
                initialItem = item
            }
        }
    }
}

struct Item: Identifiable {
    let id = UUID()
    var name: String
    var description: String
    static var fakeItems: [Item] = [.init(name: &quot;My item&quot;, description: &quot;Very good&quot;), .init(name: &quot;An other item&quot;, description: &quot;not so bad&quot;)]
}

class ListViewModel: ObservableObject {
    @Published var data: [Item] = Item.fakeItems
    func fetch() {}
    func save() {}
    func sort() {}
}
</code></pre>
<h1>Problem :</h1>
<p>Things get more complicated when the detail / edit view gets more complex. Its number of properties increases, we must set up code that does not concern the <code>View</code> (networking, storage, etc.), possibly an FSM, so we have another <code>class</code> to manage the <code>DetailView</code> (in my example: <code>DetailViewModel</code>).</p>
<p>And now the communication between the two Views, which was so easy with the <code>@Binding</code> becomes complicated to set up. In our example, these two elements are not linked, so we have to set up a two-way-binding :</p>
<pre><code>class ListViewModel: ObservableObject {
    @Published var data: [Item]     &lt;-----------
    func fetch() {}                             |
    func save() {}                              |
    func sort() {}                              |
}                                               | /In Search Of Binding/
                                                |
class DetailViewModel: ObservableObject {       |
    @Published var initialItem: Item &lt;----------
    @Published var item: Item
                                                
    init(item: Item) {
        self.initialItem = item
        self.item = item
    }
    func fetch() {}
    func save() {
        self.initialItem = item
    }
}
</code></pre>
<h1>Attempts</h1>
<h2>1. An array of DetailViewModels in the ListViewModel + Combine</h2>
<p>Rather than storing an <code>Array</code> of <code>Item</code>, my <code>ListViewModel</code> could store a <code>[DetailViewModel]</code>. So during initialization it could subscribe to changes on <code>DetailViewModel</code>s :</p>
<pre><code>class ListViewModel: ObservableObject {
    @Published var data: [DetailViewModel]
    var bag: Set&lt;AnyCancellable&gt; = []

    init(items: [Item] = Item.fakeItems) {
        data = items.map(DetailViewModel.init(item:))
        subscribeToItemsChanges()
    }
    func subscribeToItemsChanges() {
        data.enumerated().publisher
            .flatMap { (index, detailVM) in
                detailVM.$initialItem
                    .map{ (index, $0 )}
            }
            .sink { [weak self] index, newValue in
                self?.data[index].item = newValue
                self?.objectWillChange.send()
            }
            .store(in: &amp;bag)
    }
}
</code></pre>
<p><strong>Results :</strong>
Ok, that works, although it's not really a two-way-binding.
But is it really relevant that a ViewModel contains an array of other ViewModels?
a) It smells weird. b) We have an array of references (and no data types). c) we end up with that in the View:</p>
<pre><code>List(Array(vm.data.enumerated()), id: \.1.item.id) { index, detailVM in
                NavigationLink(destination: DetailView(vm: detailVM)) {
                    Text(detailVM.item.name)
                }
            }
</code></pre>
<h2>2. Give to DetailViewModel the reference of ListViewModel (Delegate style)</h2>
<p>Since the <code>DetailViewModel</code> does not contain the array of <code>Item</code>s, and since the <code>Item</code> it handles no longer has a <code>@Binding</code>: we could pass the <code>ListViewModel</code> (which contains the array) to each <code>DetailViewModel</code>.</p>
<pre><code>protocol UpdateManager {
    func update(_ item: Item, at index: Int)
}

class ListViewModel: ObservableObject, UpdateManager {
    @Published var data: [Item]
    init(items: [Item] = Item.fakeItems) {
        data = items
    }
    func update(_ item: Item, at index: Int) {
        data[index] = item
    }
}

class DetailViewModel: ObservableObject {
    @Published var item: Item
    private var updateManager: UpdateManager
    private var index: Int
    init(item: Item, index: Int, updateManager: UpdateManager) {
        self.item = item
        self.updateManager = updateManager
        self.index = index
    }
    func fetch() {}
    func save() {
        updateManager.update(item, at: index)
    }
}
</code></pre>
<p><strong>Results :</strong>
It works but : 1) It seems like an old way which doesn't quite match the style of SwiftUI. 2) We must pass the index of the Item to the DetailViewModel.</p>
<h2>3. Use a closure</h2>
<p>Rather than passing a reference to the entire <code>ListViewModel</code>, we could pass a closure (<code>onSave</code>) to the <code>DetailViewModel</code>.</p>
<pre><code>class ListViewModel: ObservableObject {
    @Published var data: [Item]
    init(items: [Item] = Item.fakeItems) {
        data = items
    }
    func update(_ item: Item, at index: Int) {
        data[index] = item
    }
}

class DetailViewModel: ObservableObject {
    @Published var item: Item
    var update: (Item) -&gt; Void
    init(item: Item, onSave update: @escaping (Item) -&gt; Void) {
        self.item = item
        self.update = update
    }
    func fetch() {}
    func save() {
        update(item)
    }
}
</code></pre>
<p><strong>Results:</strong>
On one hand it still looks like an old approach, on the other hand it seems to match the &quot;one view - one ViewModel&quot; approach. If we use an FSM we could imagine sending an Event / Input.</p>
<p><em><strong>Variant:</strong></em>
We can use Combine and pass a <code>PassthroughSubject</code> rather than a closure :</p>
<pre><code>class ListViewModel: ObservableObject {
    @Published var data: [Item]
    var archivist = PassthroughSubject&lt;(Int, Item), Never&gt;()
    var cancellable: AnyCancellable?
    init(items: [Item] = Item.fakeItems) {
        data = items
        cancellable = archivist
            .sink {[weak self ]index, item in
                self?.update(item, at: index)
            }
    }
    func update(_ item: Item, at index: Int) {
        data[index] = item
    }
}

class DetailViewModel: ObservableObject {
    @Published var item: Item
    var index: Int
    var archivist: PassthroughSubject&lt;(Int, Item), Never&gt;
    init(item: Item, saveWith archivist: PassthroughSubject&lt;(Int, Item), Never&gt;, at index: Int) {
        self.item = item
        self.archivist = archivist
        self.index = index
    }
    func fetch() {}
    func save() {
        archivist.send((index, item))
    }
}
</code></pre>
<h1>Question :</h1>
<p>I could also have used an <code>@Binding</code> in my <code>ObservableObject</code>, or even wrapped my <code>Item</code> array in an other <code>ObservableObject</code> (and therefore have an OO in an OO). But it seems even less relevant to me.</p>
<p>In any case, everything seems very complicated as soon as we leave a simple Model-View architecture: where a simple <code>@Binding</code> is enough.</p>
<p>So I ask for your help :
What do you recommend for this kind of scenario?
What do you think is the most suitable for SwiftUI?
Can you think of a better way?</p>
","16125496","","","","","2021-09-01 13:04:49","Communication between ViewModels with SwiftUI and Combine (ObservableObject vs Binding)","<swift><swiftui><combine>","1","2","2","","","CC BY-SA 4.0"
"68999280","1","69001959","","2021-08-31 13:08:49","","0","183","<p>So I want to access this variable squatCount from another class called <code>PoseEstimator</code> and print it out in a UILabel in another viewController.But for some reason when I do that, the label prints out the value of <code>squatCount</code> as zero even though the variable clearly increased.</p>
<p>I've read online and googled for hours the forums that I read through talking about implementing some global variable or singleton or some enum thingy I don't really understand it quite new to swift. So I'm trying to find out why this happens and solve it. Help is greatly appreciated.</p>
<p>PoseEstimator Code:</p>
<pre><code>import AVFoundation
import Vision
import Combine
import SwiftUI

//declaring PoseEstimator as a class. We need to add AVCaptureVideoDataOutputSampleBufferDelegate and make it an obserable object to use PoseEsimation on our AVFoundation video output
class PoseEstimator: NSObject, AVCaptureVideoDataOutputSampleBufferDelegate, ObservableObject {
    let sequenceHandler = VNSequenceRequestHandler()
    @Published var bodyParts = [VNHumanBodyPoseObservation.JointName : VNRecognizedPoint]() //declare body parts as a published variable storing the coordinates of the body joints from Vision
    
    var seconds = 0 //This variable will hold a starting value of seconds. It could be any amount above 0.
    
    var timer = Timer()
    
    var isTimerRunning = false//This will be used to make sure only one timer is created at a time.
    
    
    var elaspedTime = Float()//we need it to declare it as a float because we would be storing numbers with decimals inside//This one is for Planks the one above is to fix a lunge bug
    var halfburpee = 0
    var halfLunge = 0
    var halfPU = 0
    var uprightLunge = false
    var wasInBottomPosition = false       //declare the position of the player as top or bottom
    var wasInBottomLunge = false
    var wasInTopJJ = false
    var wasInBottomPU = false
    var wasInDeadLift = false
    var wasInMidBurpee = false
    var wasInBottomBurpee = false
    var wasinupright = false
    var wasinalmostdoneBurpee = false
    var down = false
    var cooldown = true
    
    
    @Published var squatCount = 0          //declare variables for no of exercises done
    @Published var LungeCounter = 0
    @Published var JumpingJackCounter = 0
    @Published var PushupCounter = 0
    @Published var BurpeesCounter = 0
    @Published var SLDeadliftsCounter = 0
    @Published var caloriesBurntSquats = Float(0)
    @Published var caloriesBurntLunges = Float(0)
    @Published var caloriesBurntJJ = Float()
    @Published var caloriesBurntPushups = Float(0)
    @Published var caloriesBurntBurpees = Float(0)
    @Published var caloriesBurntSLD = Float(0)
    @Published var isGoodSquatPosture = true
    @Published var isGoodLungePosture = true
    @Published var isGoodJJPosture = true
    @Published var isGoodPUPosture = true
    @Published var isGoodSLDPosture = true
    
    var subscriptions = Set&lt;AnyCancellable&gt;()        //for combine to store the proessed coordinates of Vision
    
    func runTimer() {
         timer = Timer.scheduledTimer(timeInterval: 1, target: self,   selector: (#selector(PoseEstimator.updateTimer)), userInfo: nil, repeats: true)
    }
    
    @objc func updateTimer() {
        seconds += 1     //This will decrement(count down)the seconds.
        if seconds &gt;= 2{
            self.cooldown = false
        }else{
            self.cooldown = true
        }
    }
    
    override init() {
        super.init()
        $bodyParts
            .dropFirst()
            .sink(receiveValue: { bodyParts in self.Process(bodyParts: bodyParts)})
            .store(in: &amp;subscriptions)
    }
    
    func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {
        let humanBodyRequest = VNDetectHumanBodyPoseRequest(completionHandler: detectedBodyPose)
        do {
            try sequenceHandler.perform(            //sent request to detect human body joints from AVFoundation
              [humanBodyRequest],
              on: sampleBuffer,
                orientation: .right)
        } catch {
          print(error.localizedDescription)
        }
    }
    func detectedBodyPose(request: VNRequest, error: Error?) {
        guard let bodyPoseResults = request.results as? [VNHumanBodyPoseObservation]       //set bodyPoseResults as the the reuslts from Vision
          else { return }
        guard let bodyParts = try? bodyPoseResults.first?.recognizedPoints(.all) else { return }
        DispatchQueue.main.async {
            self.bodyParts = bodyParts            //set bodyparts as the recognised points from vision
        }
    }
    
    func Process(bodyParts: [VNHumanBodyPoseObservation.JointName : VNRecognizedPoint]) { // function for processing results from vision
        
        
        let rightKnee = bodyParts[.rightKnee]!.location  // declare variables that we need to determine if the player is doing exercise
        let leftKnee = bodyParts[.leftKnee]!.location
        let rightHip = bodyParts[.rightHip]!.location
        let rightAnkle = bodyParts[.rightAnkle]!.location
        let leftAnkle = bodyParts[.leftAnkle]!.location
        let leftHip = bodyParts[.leftHip]!.location
        let rightShoulder = bodyParts[.rightShoulder]!.location
        let leftShoulder = bodyParts[.leftShoulder]!.location
        let rightElbow = bodyParts[.rightElbow]!.location
        let rightWrist = bodyParts[.rightWrist]!.location
        let leftWrist = bodyParts[.leftWrist]!.location
        let root = bodyParts[.root]!.location
        let neck = bodyParts[.neck]!.location
        
        //squats angles decleration
        let firstAngle = atan2(rightHip.y - rightKnee.y, rightHip.x - rightKnee.x) // simple trigonometry to determine the angles required
        let secondAngle = atan2(rightAnkle.y - rightKnee.y, rightAnkle.x - rightKnee.x)
        var angleDiffRadians = firstAngle - secondAngle //calculate the difference between the angles
        
        //Jumping Jacks angles decleration
        let firstJJAngle = atan2(rightHip.y - rightShoulder.y, rightHip.x - rightShoulder.x)
        let secondJJAngle = atan2(rightElbow.y - rightShoulder.y, rightElbow.x - rightShoulder.x) //calculate angles of armpit
        var JJangleDiffRadians = firstJJAngle - secondJJAngle
        
        let firstrootAngle = atan2(rightKnee.y - root.y, rightKnee.x - root.x)
        let secondrootAngle = atan2(leftKnee.y - root.y, leftKnee.x - root.x)
        var rootangleDiffRadians = firstrootAngle + secondrootAngle
        
        //Pushups anlges decleration
        let firstPUAngle = atan2(rightShoulder.y - rightElbow.y, rightShoulder.x - rightElbow.x)
        let secondPUAngle = atan2(rightWrist.y - rightElbow.y, rightWrist.x - rightElbow.x)
        var PUAngleDiffRadians = firstPUAngle - secondPUAngle
        
        //SLDeadlifts angles decleration
        let firstDeadliftAngle = atan2(neck.y - root.y, neck.x - root.x)
        let secondDeadLiftAngle = atan2(rightKnee.y - root.y, rightKnee.x - root.x)
        var SLDangleDiffRadians = firstDeadliftAngle - secondDeadLiftAngle
        
        let firstLegAngle = atan2(leftAnkle.y - leftKnee.y, leftAnkle.x - leftKnee.x)
        let secondLegAngle = atan2(leftHip.y - leftKnee.y, leftHip.x - leftKnee.x)
        var legAngleDiffRadians = firstLegAngle - secondLegAngle
        
        //Burpees angles decleration
        let firstBurpeeAngle = atan2(rightElbow.y - rightShoulder.y, rightElbow.x - rightShoulder.x)
        let secondBurpeeAngle = atan2(neck.y - rightShoulder.y, neck.x - rightShoulder.x)
        var BurpeeAngleDiffRadians = firstBurpeeAngle - secondBurpeeAngle
        
        //conversion of angles in radians to degrees
        while angleDiffRadians &lt; 0 {
                    angleDiffRadians += CGFloat(2 * Double.pi)
                }
        while JJangleDiffRadians &lt; 0{
            JJangleDiffRadians += CGFloat(2 * Double.pi)
        }
        while rootangleDiffRadians &lt; 0{
            rootangleDiffRadians += CGFloat(2 * Double.pi)
        }
        while PUAngleDiffRadians &lt; 0{
            PUAngleDiffRadians += CGFloat(2 * Double.pi)
        }
        while SLDangleDiffRadians &lt; 0{
            SLDangleDiffRadians += CGFloat(2 * Double.pi)
        }
        while legAngleDiffRadians &lt; 0{
            legAngleDiffRadians += CGFloat(2 * Double.pi)
        }
        while BurpeeAngleDiffRadians &lt; 0{
            BurpeeAngleDiffRadians += CGFloat(2 * Double.pi)
        }
        
        
        let angleDiffDegrees = Int(angleDiffRadians * 180 / .pi)

        let rootangleDIffDegrees = Int(rootangleDiffRadians * 180 / .pi)
        let JJangleDIffDegrees = Int(JJangleDiffRadians * 180 / .pi)
        
        let PUAngleDiffDegrees = Int(PUAngleDiffRadians * 180 / .pi)
        let SLDAngleDiffDegrees = Int(SLDangleDiffRadians * 180 / .pi)
        let legAngleDiffDegrees = Int(legAngleDiffRadians * 180 / .pi)
        let BurpeeAngleDiffDegrees = Int(BurpeeAngleDiffRadians * 180 / .pi)
        
        
        //process whether the player is doing a squat
        if angleDiffDegrees &gt; 150 &amp;&amp; self.wasInBottomPosition == true{ // determine if the player is doing a squat
            self.wasInBottomPosition = false
            self.squatCount += 1
            self.caloriesBurntSquats = Float(self.squatCount) * 0.32
        }
        
        //process whether the player is doing a lunge
        if angleDiffDegrees &gt; 160 &amp;&amp; wasInBottomLunge == true{
            self.LungeCounter += 1
            self.wasInBottomLunge = false
            self.caloriesBurntLunges = Float(self.LungeCounter) * 0.3
        }
        
        //process whether the player is doing a Jumping Jack
        if rootangleDIffDegrees &lt; 180 &amp;&amp; JJangleDIffDegrees &lt;= 90 &amp;&amp; self.wasInTopJJ{
            self.JumpingJackCounter += 1
            self.wasInTopJJ = false
            self.caloriesBurntJJ = Float(self.JumpingJackCounter) * 0.2
        }
        //process whether the player is doing a pushup
        if PUAngleDiffDegrees &gt; 167 &amp;&amp; wasInBottomPU{
            halfPU += 1
            wasInBottomPU = false
            self.caloriesBurntPushups = Float(self.PushupCounter) * 0.6
        }
        
        if halfPU &gt;= 2{
            self.halfPU = 0
            self.PushupCounter += 1
        }
        //process whether the player is doing a SLDeadlift
        if SLDAngleDiffDegrees &gt;= 215 &amp;&amp; wasInDeadLift{
            SLDeadliftsCounter += 1
            wasInDeadLift = false
            self.caloriesBurntSLD = Float(self.SLDeadliftsCounter) * 0.2
        }
        //process whether the player is doing a burpee
        if self.wasinupright == true &amp;&amp; self.wasinalmostdoneBurpee == true{
            self.halfburpee += 1
            self.wasinupright = false
            self.wasInBottomBurpee = false
            self.wasInMidBurpee = false
            self.down = false
            self.wasinalmostdoneBurpee = false
            self.caloriesBurntBurpees = Float(self.BurpeesCounter) * 0.5
        }
        if self.halfburpee &gt;= 2{
            self.BurpeesCounter += 1
            self.halfburpee = 0
        }
        
        //proess whether the player is in the top/bottom position of the exercise
        let hipHeight = rightHip.y
        let lefthipHeight = leftHip.y
        let kneeHeight = rightKnee.y
        let leftkneeHeight = leftKnee.y
        let ankleheight = rightAnkle.y
        let shoulderheight = rightShoulder.y
        let elbowHeight = rightElbow.y
        let wristheight = leftWrist.y
        
        
        //squats
        if hipHeight &lt; kneeHeight { //determing if the user is in the bottom position of the squat
            self.wasInBottomPosition = true
        }
        //lunges
        if leftkneeHeight &lt;= ankleheight {
            self.wasInBottomLunge = true
        }
        if leftkneeHeight == kneeHeight {
            self.uprightLunge = true
        }else{
            self.uprightLunge = false
        }
        
        //Jumping jacks
        if elbowHeight &gt; shoulderheight &amp;&amp; JJangleDIffDegrees &gt;= 130 &amp;&amp; rootangleDIffDegrees &gt; 175{ // determining if the user's arms are above the shoulders
            self.wasInTopJJ = true
        }
        //Pushups
        if PUAngleDiffDegrees &lt;= 150 {
            self.wasInBottomPU = true
        }
        //SL deadlifts
        if hipHeight &gt; lefthipHeight{
            self.wasInDeadLift = true
        }
        //Burpees
        if BurpeeAngleDiffDegrees &gt;= 240{
            self.down = true
        }
        if kneeHeight &gt;= elbowHeight{
            self.wasInMidBurpee = true
        }
        if kneeHeight &lt; elbowHeight &amp;&amp; self.wasInMidBurpee == true &amp;&amp; self.down == true{
            self.wasInBottomBurpee = true
        }
        if kneeHeight &gt;= elbowHeight &amp;&amp; self.wasInBottomBurpee == true{
            self.wasinalmostdoneBurpee = true
        }
        if wristheight &gt; ankleheight{
            self.wasinupright = true
        }else{
            self.wasinupright = false
        }
        

        let kneeDistance = rightKnee.distance(to: leftKnee)
        let ankleDistance = rightAnkle.distance(to: leftAnkle)
        let wristDistance = rightWrist.distance(to: leftWrist)
        let shoulderDistance = rightShoulder.distance(to: leftShoulder)
        
        
        if ankleDistance &gt; kneeDistance { //checking if the posture of the player doing squats is good
            self.isGoodSquatPosture = false
        } else {
            self.isGoodSquatPosture = true
        }
        
        if rootangleDIffDegrees &gt;= 180 &amp;&amp; elbowHeight &lt;= shoulderheight{ //posture check for Jumping Jacks
            self.isGoodJJPosture = false
        } else{
            self.isGoodJJPosture = true
        }
        if (wristDistance - 1) != shoulderDistance { //posture check for PushUps
            self.isGoodPUPosture = false
        }else{
            self.isGoodPUPosture = true
        }
        if legAngleDiffDegrees &gt; 175{ //posture check for Single-Leg Deadlifts
            self.isGoodSLDPosture = false
        }else{
            self.isGoodSLDPosture = true
        }
        
    }
}
</code></pre>
<p>my viewController code:</p>
<pre><code>import SwiftUI

class DoneViewController: UIViewController {
    
    var exerciseLoaded = false
    var burntCalories = Float()
    
    let poseEstimator = PoseEstimator()
    
    @IBOutlet weak var repsDone: UILabel!
    
    @IBOutlet weak var caloriesBurnt: UILabel!
    
    @IBOutlet weak var exerciseMoreBtn: UIButton!
    
    @IBOutlet weak var HomeWhenDone:
        UIButton!
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
        exerciseMoreBtn.layer.cornerRadius = 10
        HomeWhenDone.layer.cornerRadius = 10
        repsDone.text = String(poseEstimator.squatCount)
    }
</code></pre>
","16605996","","","","","2021-08-31 16:02:52","Accessing variable from another class gives 0 swift","<swift>","1","2","","","","CC BY-SA 4.0"
"69003260","1","69003276","","2021-08-31 17:48:27","","-1","138","<p>I have a custom Publisher that takes in a String key and emits values when data for that key changes. Say it's called <code>MyCustomPublisher</code>.</p>
<p>I have a function that I want to take in an instance of <code>MyCustomPublisher</code>, transform the value into a different key, and then create a separate instance of <code>MyCustomPublisher</code>. This looks like this:</p>
<pre><code>    let myInfoProvider: MyCustomPublisher = ...
    myInfoProvider.tryMap { v -&gt; Database in
        guard let value = v else { throw &quot;No value provided&quot; }
        return value
    }
    .map { v in
        MyCustomPublisher(key: v)
    }
    .switchToLatest()
    .tryMap { v -&gt; String in
        guard let value = v else {
            throw &quot;No value found&quot;
        }
        
        return value
    }
</code></pre>
<p>Given that the data is a String, I would like the output type to be <code>AnyPublisher&lt;String, Error&gt;</code>, but the actual type reported by Swift is <code>Publishers.TryMap&lt;Publishers.SwitchToLatest&lt;MyCustomPublisher, Publishers.TryMap&lt;MyCustomPublisher, MyCustomPublisher&gt;&gt;, String&gt;</code>. How can I make this conform to AnyPublisher&lt;String, Error&gt;?</p>
","887128","","","","","2021-08-31 17:50:24","Is there a way to simplify Swift combine types?","<swift><combine>","1","0","","2021-08-31 17:55:38","","CC BY-SA 4.0"
"69003265","1","69003311","","2021-08-31 17:49:04","","2","349","<p>Oh hey! I've been stuck trying to figure out how to have my <code>AVAudioPlayerNode()</code> automatically stop playback when it reaches the end of the file in my SwiftUI project. As you can see below, my audio files that don't go through the <code>AVAudioEngine</code> but rather the <code>AVAudioPlayer</code> have an <code>audioPlayerDidFinishPlaying</code> function and that works great. However for the audio files that go through the engine using the <code>play</code> function don't have anything like this, and I can't figure out how to get it to behave similarly.</p>
<p>I've tried building something like</p>
<pre><code>    func audioPlayerDidFinishPlaying2(_ player: AVAudioPlayerNode, successfully flag: Bool) {
        if flag {
            isPlaying = false
            print(&quot;Playback Engine Stopped&quot;)
        }
    }
</code></pre>
<p>But this doesn't appear to do anything.</p>
<p>Stopping the engine's playback manually by calling <code>stopPlayback2()</code> works just fine.</p>
<p>I'm calling the engine player using</p>
<pre><code>do {
    try self.audioPlayer.play(self.audioURL)
  }
    catch let error as NSError {
      print(error.localizedDescription)
  }
</code></pre>
<p>I've looked at other SO posts [here][1] and [here][2] but neither solutions are working for me. I would really appreciate your input if you have any suggestions! Thanks!!</p>
<p><strong>AudioPlayer.swift</strong></p>
<pre><code>class AudioPlayer: NSObject, ObservableObject, AVAudioPlayerDelegate {
    
    let objectWillChange = PassthroughSubject&lt;AudioPlayer, Never&gt;()
    var isPlaying = false {
        didSet {
            objectWillChange.send(self)
        }
    }

    
    var audioPlayer: AVAudioPlayer!
    
    func startPlayback (audio: URL) {

        let playbackSession = AVAudioSession.sharedInstance()
        
        do {
            try playbackSession.overrideOutputAudioPort(AVAudioSession.PortOverride.speaker)
        } catch {
            print(&quot;Playing over the device's speakers failed&quot;)
        }
        do {
            audioPlayer = try AVAudioPlayer(contentsOf: audio)
            audioPlayer.delegate = self
            audioPlayer.play()
            isPlaying = true
        } catch {
            print(&quot;Playback failed.&quot;)
        }
    }
    
    func stopPlayback() {
        
        audioPlayer.stop()
        isPlaying = false
        
    }
    
    func stopPlayback2() {
        engine.stop()
        isPlaying = false
    }
    
    func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
        if flag {
            isPlaying = false
            print(&quot;Playback Stopped&quot;)
        }
    }

    let engine = AVAudioEngine()
    let speedControl = AVAudioUnitVarispeed()
    let pitchControl = AVAudioUnitTimePitch()
    
    func play(_ url: URL) throws {
        let file = try! AVAudioFile(forReading: url)

        let avPlayer = AVAudioPlayerNode()

        engine.attach(avPlayer)
        engine.attach(pitchControl)
        engine.attach(speedControl)

        engine.connect(avPlayer, to: speedControl, format: nil)
        engine.connect(speedControl, to: pitchControl, format: nil)
        engine.connect(pitchControl, to: engine.mainMixerNode, format: nil)

        avPlayer.scheduleFile(file, at: nil)

        isPlaying = true
        try engine.start()
        avPlayer.play()
    }
    ```


  [1]: https://stackoverflow.com/questions/34238432/avaudioengine-avaudioplayernode-didfinish-method-like-avaudioplayer
  [2]: https://stackoverflow.com/questions/59080708/calling-stop-on-avaudioplayernode-after-finished-playing-causes-crash
</code></pre>
","15119711","","12299030","","2021-08-31 18:01:59","2021-08-31 18:01:59","How to monitor for AVAudioPlayerNode finished playing","<ios><swift><xcode>","1","0","","","","CC BY-SA 4.0"
"69015207","1","69015951","","2021-09-01 13:57:45","","2","189","<p>I'm developing an existing Android Kotlin app for IOS Swift UI.</p>
<p>In Kotlin when using Gson, I had a Client model class:</p>
<pre><code>abstract class Client(
        @SerializedName(&quot;nombre&quot;)
        var name: String? = null,
        @SerializedName(value=&quot;cliente_id&quot;, alternate = [&quot;id&quot;])
        var client_id: Int = -1,
)
</code></pre>
<p>As you can see, I use <code>@SerializedName()</code> to give Client property <code>name</code> or <code>client_id</code> an alter name. I do this because when I get the data from the API, Client Json has &quot;nombre&quot; and not &quot;name&quot; as I want. So <code>@SerializedName()</code> makes possible to detect &quot;nombre&quot; in JSON as &quot;name&quot; or detect &quot;cliente_id&quot; as &quot;client_id&quot; in Kotlin model Classes. This way I can read data from API using my own property names.</p>
<p>Well, now I'm facing the same issue in Swift. I want to use my own property names and not the API JSON property names.</p>
<p>My swift Client model class looks like this:</p>
<pre><code>class Client: Identifiable, Decodable{
    
    init(id: Int, token: String) {
        self.cliente_id = id
        self.token = token
    }
    
    let cliente_id: Int
    let token: String
}
</code></pre>
<p>And I get client data from API like this:</p>
<pre><code>let request = AF.request(
    url, method: .post,
    parameters: parameters,
    encoder: JSONParameterEncoder.default
)

request.validate(statusCode: 200...299)
request.responseDecodable(of: Client.self) { response in
    if let loginResponse = response.value{//Success
        loginPublisher.send(loginResponse)
    }
    else{//Failure
        loginPublisher.send(completion: Subscribers.Completion&lt;NetworkError&gt;.failure(.thingsJustHappen))
    }
}
</code></pre>
<p>In order to be able to use <code>Client</code> a decodable, <code>Client</code> has to implement <code>Decodable</code>. Well, all I want is Client to has <code>id</code> and not <code>cliente_id</code> as a property name.</p>
<p>Something like</p>
<pre><code>class Client: Identifiable, Decodable{

    init(id: Int, token: String) {
        self.id = id
        self.token = token
    }

    @NameforDecode(&quot;cliente_id&quot;)
    let id: Int
    let token: String
}
</code></pre>
<p>Is this possible?</p>
","15860448","","","","","2021-09-01 17:54:31","Set an Alter name for property in Decodable class | Swift","<swift><kotlin><alamofire><combine><decodable>","1","1","","","","CC BY-SA 4.0"
"69057605","1","69061704","","2021-09-04 17:34:17","","1","786","<p>I have an API Service handler implemented which uses an authentication token in the header of the request. This token is fetched when the user logs in at the launch of the application. After 30 minutes, the token is expired. Thus, when a request is made after this timespan, the API returns an 403 statuscode. The API should then login again and restart the current API request.</p>
<p>The problem I am encountering is that the login function to fetch a new token, makes use of a completion handler to let the calling code know if the asynchronous login procedure has been successful or not. When the API gets a 403 statuscode, it calls the login procedure and and when that is complete, it should make the current request again. But this repeated API request should return some value again. However, returning a value is not possible in a completion block. Does anyone know a solution for the problem as a whole?</p>
<p>The login function is as follows:</p>
<pre><code>func login (completion: @escaping (Bool) -&gt; Void) {
    
    self.loginState = .loading
    
    let preparedBody = APIPrepper.prepBody(parametersDict: [&quot;username&quot;: self.credentials.username, &quot;password&quot;: self.credentials.password])

    let cancellable = service.request(ofType: UserLogin.self, from: .login, body: preparedBody).sink { res in
        switch res {
        case .finished:
            if self.loginResult.token != nil {
                self.loginState = .success
                self.token.token = self.loginResult.token!

                _ = KeychainStorage.saveCredentials(self.credentials)
                _ = KeychainStorage.saveAPIToken(self.token)

                completion(true)
            }
            else {
                (self.banner.message, self.banner.stateIdentifier, self.banner.type, self.banner.show) = (&quot;ERROR&quot;, &quot;TOKEN&quot;, &quot;error&quot;, true)
                self.loginState = .failed(stateIdentifier: &quot;TOKEN&quot;, errorMessage: &quot;ERROR&quot;)
                completion(false)
            }
        case .failure(let error):
            (self.banner.message, self.banner.stateIdentifier, self.banner.type, self.banner.show) = (error.errorMessage, error.statusCode, &quot;error&quot;, true)
            self.loginState = .failed(stateIdentifier: error.statusCode, errorMessage: error.errorMessage)
            completion(false)
        }
    } receiveValue: { response in
        self.loginResult = response
    }
    
    self.cancellables.insert(cancellable)
}
</code></pre>
<p>The API service is as follows:</p>
<pre><code>func request&lt;T: Decodable&gt;(ofType type: T.Type, from endpoint: APIRequest, body: String) -&gt; AnyPublisher&lt;T, Error&gt; {
    
    var request = endpoint.urlRequest
    request.httpMethod = endpoint.method
    
    if endpoint.authenticated == true {
        request.setValue(KeychainStorage.getAPIToken()?.token, forHTTPHeaderField: &quot;token&quot;)
    }
    
    if !body.isEmpty {
        let finalBody = body.data(using: .utf8)
        request.httpBody = finalBody
    }
    
    return URLSession
        .shared
        .dataTaskPublisher(for: request)
        .receive(on: DispatchQueue.main)
        .mapError { _ in Error.unknown}
        .flatMap { data, response -&gt; AnyPublisher&lt;T, Error&gt; in
            
            guard let response = response as? HTTPURLResponse else {
                return Fail(error: Error.unknown).eraseToAnyPublisher()
            }
            
            let jsonDecoder = JSONDecoder()
            
            if response.statusCode == 200 {
                return Just(data)
                    .decode(type: T.self, decoder: jsonDecoder)
                    .mapError { _ in Error.decodingError }
                    .eraseToAnyPublisher()
            }
            else if response.statusCode == 403 {
                
                let credentials = KeychainStorage.getCredentials()
                let signinModel: SigninViewModel = SigninViewModel()
                signinModel.credentials = credentials!
        
                signinModel.login() { success in
                    
                    if success == true {
-------------------&gt;    // MAKE THE API CALL AGAIN AND THUS RETURN SOME VALUE
                    }
                    else {
-------------------&gt;    // RETURN AN ERROR
                    }
        
                }
    
            }
            else if response.statusCode == 429 {
                return Fail(error: Error.errorCode(statusCode: response.statusCode, errorMessage: &quot;Oeps! Je hebt teveel verzoeken gedaan, wacht een minuutje&quot;)).eraseToAnyPublisher()
            }
            else {
                do {
                    let errorMessage = try jsonDecoder.decode(APIErrorMessage.self, from: data)
                    return Fail(error: Error.errorCode(statusCode: response.statusCode, errorMessage: errorMessage.error ?? &quot;Er is iets foutgegaan&quot;)).eraseToAnyPublisher()
                }
                catch {
                    return Fail(error: Error.decodingError).eraseToAnyPublisher()
                }
            }
        }
        .eraseToAnyPublisher()
}
</code></pre>
","14855422","","560942","","2021-09-04 18:24:58","2021-09-06 11:46:34","Swift Combine Completion Handler with return of values","<swift><asynchronous><combine><completionhandler>","1","0","0","","","CC BY-SA 4.0"
"69066375","1","69067346","","2021-09-05 18:59:53","","0","88","<p>I have a NavigationManager to handle changing SwiftUI tab bar selection.</p>
<p>It work if it is set as a <code>@EnvironmentObject</code> in my SwiftUI views, but not when the NavigationManager is called as a service in my view models. The thing is that I would like to use a simpler solution than passing around <code>@EnvironmentObject var navigationManager</code> around and pass them inside view model initializer as I have a lot of them and I am looking for a cleaner approach.</p>
<p>How can I use my NavigationManager to change tabs from inside my view models without passing it in init()?</p>
<pre><code>import SwiftUI

struct ContentView: View {

  @StateObject var navigationManager = NavigationManager()

  var body: some View {
    TabView(selection: $navigationManager.selection) {
      AccountView()
        .tabItem {
          Text(&quot;Account&quot;)
          Image(systemName: &quot;person.crop.circle&quot;) }
        .tag(NavigationItem.account)

      SettingsView()
          .tabItem {
            Text(&quot;Settings&quot;)
            Image(systemName: &quot;gear&quot;) }
          .tag(NavigationItem.settings)
          .environmentObject(navigationManager)
    }
  }
}
</code></pre>
<p>The navigation manager that I would like to use within view models.</p>
<pre><code>class NavigationManager: ObservableObject {

  @Published var selection: NavigationItem = .account
}

enum NavigationItem {
  case account
  case settings
}
</code></pre>
<p>My AccountViewModel and Settings View Model:</p>
<pre><code>class AccountViewModel: ObservableObject {

  let navigationManager = NavigationManager()
}

struct AccountView: View {

  @StateObject var viewModel = AccountViewModel()

  var body: some View {
    VStack(spacing: 16) {
    Text(&quot;AccountView&quot;)
        .font(.title3)

      Button(action: {
        viewModel.navigationManager.selection = .settings
      }) {
        Text(&quot;Go to Settings tab&quot;)
          .font(.headline)
      }
      .buttonStyle(.borderedProminent)
    }
  }
}


class SettingsViewModel: ObservableObject {

  let navigationManager = NavigationManager()
}

struct SettingsView: View {

  @EnvironmentObject var navigationManager: NavigationManager

  @StateObject var viewModel = SettingsViewModel()

  var body: some View {
    VStack(spacing: 16) {
    Text(&quot;SettingsView&quot;)
        .font(.title3)

      Button(action: {
        navigationManager.selection = .account
      }) {
        Text(&quot;Go to Account tab&quot;)
          .font(.headline)
      }
      .buttonStyle(.borderedProminent)
    }
  }
}
</code></pre>
","10408494","","10408494","","2021-09-06 12:00:41","2021-09-06 12:00:41","How to create a NavigationManager that would change tab within view models?","<mvvm><swiftui><combine>","1","1","1","","","CC BY-SA 4.0"
"69079152","1","69080024","","2021-09-06 18:53:36","","0","87","<p>I am fairly acquainted with memory management in swift, and I know that if in the capturing closure we use [unowned self] code will break, if self becomes nil and we call some method on self. Still I have been dabbling in combine and have found curios case, self becomes nil, but code never breaks. I tried to test it some more, to explain what is happening, but could not. Here is the example:</p>
<pre><code>class DetailsViewController: UIViewController {

var subject: PassthroughSubject&lt;Int, Never&gt;!
var localIntHolder: Int!
private var subscriptions = Set&lt;AnyCancellable&gt;()

override func viewDidLoad() {
    super.viewDidLoad()
    
    subject
        .flatMap { [unowned self] value in
            self.completionPublisher()
        }
        .map({ [unowned self] value in
            self.increaseValue(value)
        })
        .sink { [unowned self] value in
            print(&quot;\(value)&quot;)
            self.localIntHolder = value
        }
        .store(in: &amp;subscriptions)
    
    subject.send(22)
    
    DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
        self.dismiss(animated: true, completion: nil)
    }
}

private func increaseValue(_ value: Int) -&gt; Int {
    return value + 1
}

deinit {
    print(&quot;deinit&quot;)
}

private func completionPublisher() -&gt; AnyPublisher&lt;Int, Never&gt; {
    return Future&lt;Int, Never&gt; { promise in
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
            promise(.success(10))
        }
    }
    .eraseToAnyPublisher()
}
}
</code></pre>
<p>Here is setup from main view controller:</p>
<pre><code>let subjectInt = PassthroughSubject&lt;Int, Never&gt;()

override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        let controller = DetailsViewController()
        controller.subject = subjectInt
        present(controller, animated: true, completion: nil)
    }
</code></pre>
<p>Now this is simple example, sender will send value, future will delay it for 10 seconds. While this is happening I deallocate controller in the middle of it. I imagine that code will break, but nothing happens, controller is deallocated, rest of the pipeline never executed.</p>
<p>Is there some combine magic that I am missing?</p>
","744270","","9607863","","2021-09-06 19:11:53","2021-09-06 20:32:58","Unowned self does not cause runtime to break when self is deallocated?","<swift><memory-management><automatic-ref-counting><combine>","1","2","","","","CC BY-SA 4.0"
"69084289","1","69085801","","2021-09-07 07:49:39","","0","702","<p>I'm developing a MVVM structure with API calls.
I have this structure now:</p>
<pre><code>    //Get publisher
    loginPublisher = LoginService.generateLoginPublisher()
        
    //Create a subscriber
    loginSubscriber = loginPublisher!
        .sink { error in
            print(&quot;Something bad happened&quot;)
            self.isLoading = false
        } receiveValue: { value in               
            
            self.saveClient(value)
            self.client = value
            self.isLoading = false
        }
    
    //Asking service to start assync task and notify its result on publisher
    LoginService.login(email, password, loginPublisher!)
</code></pre>
<p>Basically what I do is obtain certain publisher from a <code>LoginService</code>, then I create a subscriber on <code>loginPublisher</code>, and then I tell <code>LoginService</code> to make some assync logic and send it result to <code>loginPublisher</code> this way I manage sent data with <code>loginSubscriber</code>.</p>
<p>I would like to execute LoginService.login() internally when I execute <code>LoginService.generateLoginPublisher()</code>, but if I do that, there is a chance that <code>LoginService.login()</code> logic finish before I create <code>loginSubscriber</code>, that's why I was forced to control when to call <code>LoginService.login()</code>.</p>
<p><strong>How could I detect from LoginService when its publisher has a new subscriber?</strong></p>
<p>This is my <code>LoginService</code> class:</p>
<pre><code>class LoginService{
static func generateLoginPublisher() -&gt; PassthroughSubject&lt;Client, NetworkError&gt;{
    return PassthroughSubject&lt;Client, NetworkError&gt;()
}

static func login(_ email: String,_ password: String,_ loginPublisher: PassthroughSubject&lt;Client, NetworkError&gt;){
    let url = NetworkBuilder.getApiUrlWith(extraPath: &quot;login&quot;)
    
    print(url)
    
    let parameters: [String: String] = [
        &quot;password&quot;: password,
        &quot;login&quot;: email
    ]
    
    print(parameters)
    
    let request = AF.request(
        url, method: .post,
        parameters: parameters,
        encoder: JSONParameterEncoder.default
    )
    
    request.validate(statusCode: 200...299)
    request.responseDecodable(of: Client.self) { response in
        if let loginResponse = response.value{//Success
            loginPublisher.send(loginResponse)
        }
        else{//Failure
            loginPublisher.send(completion: Subscribers.Completion&lt;NetworkError&gt;.failure(.thingsJustHappen))
        }
    }
}
</code></pre>
<p>}</p>
","15860448","","","","","2021-09-08 06:35:17","Is there a way to detect when a publisher has a new subscriber? | Swift, Combine","<swift><swiftui><combine>","3","1","","","","CC BY-SA 4.0"
"69095008","1","69110012","","2021-09-07 22:08:49","","0","108","<p>I'm having an Image holder that would load the thumdnail on init and allow for download later on. My issue is that the view is not updated with the images after I load them. After pressing the load button for the second time, my first images are then displayed.</p>
<p>I'm having trouble finding the reason behind this behaviour.</p>
<p><strong>The image holder :</strong></p>
<pre><code>class MyImage: ObservableObject {
        private static let sessionProcessingQueue = DispatchQueue(label: &quot;SessionProcessingQueue&quot;)

    @Published var thumbnail: UIImage?
    @Published var loaded: Bool

    var fullName: String {
        &quot;\(folderName)/\(fileName)&quot;
    }

    var onThumbnailSet: ((UIImage?) -&gt; Void)

    private var folderName: String
    private var fileName: String

    private var cancelableThumbnail: AnyCancellable?

    private var thumbnailUrl: URL? {
        return URL(string: &quot;\(BASE_URL)/thumbnail/\(fullName)&quot;)
    }

    private var downloadUrl: URL? {
        return URL(string: &quot;\(BASE_URL)/download/\(fullName)&quot;)
    }

    init(folderName: String, fileName: String) {
        self.folderName = folderName
        self.fileName = fileName
        self.loaded = false
        self.loadThumbnail()
    }

    private func loadThumbnail() {
        guard let requestUrl = thumbnailUrl else { fatalError() }
        self.cancelableThumbnail = URLSession.shared.dataTaskPublisher(for: requestUrl)
            .subscribe(on: Self.sessionProcessingQueue)
            .map { UIImage(data: $0.data) }
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { (suscriberCompletion) in
                switch suscriberCompletion {
                case .finished:
                    break
                case .failure(let error):
                    print(error.localizedDescription)
                }
            }, receiveValue: { [weak self] (value) in
                self?.objectWillChange.send()
                self?.loaded.toggle()
                self?.thumbnail = value
            })
    }
</code></pre>
<p><strong>The view :</strong></p>
<pre><code>struct MyView: View {
    @ObservedObject var imagesHolder: ImagesHolder = ImagesHolder()

    var body: some View {
        VStack {
            Button(action: {
                self.loadImages()

            }, label: {
                Text(&quot;Load images&quot;)
            })

            ForEach(imagesHolder.images, id: \.self) { image in
                if image.loaded {
                    Image(uiImage: image.thumbnail!)
                        .frame(width: 600, height: 600)
                } else {
                    Text(&quot;Not loaded&quot;)
                }
            }
        }
    }

    private func loadImages() -&gt; Void {
        loadMediaList(
            onLoadDone: { myImages in
                myImages.forEach { image in
                    imagesHolder.append(image)
                }
            }
        )
    }
}
</code></pre>
<p><strong>The observed object containing the array of loaded images :</strong></p>
<pre><code>class ImagesHolder: ObservableObject {
    @Published var images: [MyImage] = []

    func append(_ myImage: MyImage) {
        objectWillChange.send()
        images.append(myImage)
    }
}
</code></pre>
<p><strong>And finally my data loader :</strong></p>
<pre><code>func loadMediaList(onLoadDone: @escaping (([MyImage]) -&gt; Void)) -&gt; AnyCancellable {
  let url = URL(string: &quot;\(BASE_URL)/medias&quot;)

  guard let requestUrl = url else { fatalError() }
  
  return URLSession.shared.dataTaskPublisher(for: requestUrl)
      .subscribe(on: Self.sessionProcessingQueue)
      .map { parseJSON(data: $0.data) }
      .receive(on: DispatchQueue.main)
      .sink(receiveCompletion: { (suscriberCompletion) in
          switch suscriberCompletion {
          case .finished:
              break
          case .failure(let error):
              print(error.localizedDescription)
          }
      }, receiveValue: { images in
          onLoadDone(images);
      })
}
</code></pre>
","858345","","858345","","2021-09-08 08:16:27","2021-09-09 09:26:00","Update view with observed objects of observed array in swiftui","<swift><swiftui>","1","2","1","","","CC BY-SA 4.0"
"69095798","1","69096758","","2021-09-08 00:40:25","","0","413","<p>I have a Publisher</p>
<p><code>var subject = PassthroughSubject&lt;Int, Error&gt;()</code></p>
<p>I want to convert it to</p>
<p><code>PassthroughSubject&lt;Int, Never&gt;</code></p>
<p>Is there anyway to achieve this ?</p>
<p>Edit - More Details</p>
<p>I do not want the Publisher to complete and the linked answer did not work because catch still completes the publisher.</p>
","11975968","","11975968","","2021-09-08 00:59:32","2021-09-08 03:47:36","Converting Publisher's error type to Never in Combine","<ios><swift><combine>","1","9","","","","CC BY-SA 4.0"
"69112120","1","69112333","","2021-09-09 04:07:25","","0","354","<p>I am trying to return just a string from my node.js Express server. It's a basic server that returns &quot;hello, world!&quot; but not as a <code>JSON</code> object but as a regular string. Here is my code from my request.</p>
<pre><code>URLSession
    .shared
    .dataTaskPublisher(for: request)
    .map(\.data)
    .decode(type: String.self, decoder: decoder)
    .receive(on: DispatchQueue.main)
</code></pre>
<p>I think I'm doing it right but I get this but when I run it, I get this error: <code>The data couldn't be read because it isn't in the correct format.</code></p>
<p><strong>Update</strong></p>
<p>So, as per the comments, I am not returning <code>JSON</code> so I can't use the <code>JSONDecoder</code>. That said, I wanted to use this in a generic fashion and some APIs will return <code>JSON</code> some will return <code>String</code>s and some will return <code>Int</code>s and some will return <code>Array&lt;Codable&gt;</code>. Is there a way to use combine to try and get these values back from my various API endpoints?</p>
<p>I know that I can do something like this:</p>
<pre><code>URLSession
    .shared
    .dataTaskPublisher(for: request)
    .map(\.data)
    .compactMap { String(data: $0, encoding:. utf8) }
    .receive(on: DispatchQueue.main)
</code></pre>
<p>but I want to be able to call each of my endpoints with this function. Can anybody help?</p>
","5863650","","5863650","","2021-09-13 17:42:50","2022-01-15 21:34:01","Retrieve String from `.dataTaskPublisher`","<ios><json><swift><combine><urlsession>","2","7","","","","CC BY-SA 4.0"
"69125885","1","69125941","","2021-09-10 00:07:27","","1","62","<p>I'm not sure why I'm not getting any data returned back.   I know the API key and URL is working properly. Below is the Struct and my class I'm using. I also included what I'm doing in my SwiftUI file.</p>
<p>In the response I can see that I am getting back a 200.  I've tried a few different ways to mapping the data to my view, but so far no luck.</p>
<pre><code>// MARK: - Welcome
struct WeatherDataModel: Codable, Identifiable {
    let id = UUID()
    let lat, lon: Double
    let timezone: String
    let current: Current
    let daily: [Daily]

    enum CodingKeys: String, CodingKey {
        case lat, lon, timezone
        case current, daily
    }
}

// MARK: - Current
struct Current: Codable {
    let dt, sunrise, sunset: Int
    let temp, feelsLike: Double
    let pressure, humidity: Int
    let dewPoint: Double
    let uvi, clouds, visibility: Int
    let windSpeed: Double
    let windDeg: Int
    let weather: [Weather]

    enum CodingKeys: String, CodingKey {
        case dt, sunrise, sunset, temp
        case feelsLike = &quot;feels_like&quot;
        case pressure, humidity
        case dewPoint = &quot;dew_point&quot;
        case uvi, clouds, visibility
        case windSpeed = &quot;wind_speed&quot;
        case windDeg = &quot;wind_deg&quot;
        case weather
    }
}

// MARK: - Weather
struct Weather: Codable {
    let id: Int
    let main, weatherDescription, icon: String

    enum CodingKeys: String, CodingKey {
        case id, main
        case weatherDescription = &quot;description&quot;
        case icon
    }
}

// MARK: - Daily
struct Daily: Codable {
    let dt, sunrise, sunset, moonrise: Int
    let moonset: Int
    let moonPhase: Double
    let temp: Temp
    let feelsLike: FeelsLike
    let pressure, humidity: Int
    let dewPoint, windSpeed: Double
    let windDeg: Int
    let windGust: Double
    let weather: [Weather]
    let clouds: Int
    let pop: Double
    let rain: Double?
    let uvi: Double

    enum CodingKeys: String, CodingKey {
        case dt, sunrise, sunset, moonrise, moonset
        case moonPhase = &quot;moon_phase&quot;
        case temp
        case feelsLike = &quot;feels_like&quot;
        case pressure, humidity
        case dewPoint = &quot;dew_point&quot;
        case windSpeed = &quot;wind_speed&quot;
        case windDeg = &quot;wind_deg&quot;
        case windGust = &quot;wind_gust&quot;
        case weather, clouds, pop, rain, uvi
    }
}

// MARK: - FeelsLike
struct FeelsLike: Codable {
    let day, night, eve, morn: Double
}

// MARK: - Temp
struct Temp: Codable {
    let day, min, max, night: Double
    let eve, morn: Double
}

typealias weatherData = [WeatherDataModel]

class DownloadWeatherData: ObservableObject {

    @Published var weatherdata: [WeatherDataModel] = []
    var weatherCancellabes = Set&lt;AnyCancellable&gt;()

    init() {
        print(&quot;loading weather init&quot;)

        getWeather(weatherUrl: &quot;&lt;my url&gt;&quot;)
    }

    func getWeather(weatherUrl: String) {

        guard let weatherUrl = URL(string: weatherUrl) else { return }

        URLSession.shared.dataTaskPublisher(for: weatherUrl)
            .subscribe(on: DispatchQueue.global(qos: .background))
            .receive(on: DispatchQueue.main)
            .tryMap { (data, response) -&gt; Data in
                print(response)
                guard
                    let response = response as? HTTPURLResponse,
                      response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300 else {
                    throw URLError(.badServerResponse)
                }
                print(&quot;data \(data)&quot;)
                return data
            }
            .decode(type: [WeatherDataModel].self, decoder: JSONDecoder())
            .sink { (completion) in
            } receiveValue: { [weak self] (returnedWeatherData) in
                self?.weatherdata = returnedWeatherData
                print(&quot;returnedWeatherData \(returnedWeatherData)&quot;)
            }
            .store(in: &amp;weatherCancellabes)
    }
}


struct WeatherView: View {

    @StateObject var weatherData = DownloadWeatherData()

    var body: some View {
        VStack {
            ForEach(weatherData.weatherdata) { day in
                Text(day.timezone)
            }
        }
    }
}
</code></pre>
<p>The error I'm getting here is <code>No exact matches in call to initializer </code></p>
","1165268","","","","","2021-09-10 01:49:27","OpenWeather data not returning using SwiftUI and Combine","<swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"69164401","1","69168294","","2021-09-13 14:25:30","","1","138","<p>I am new to Combine, please help. I need to combine 2 URL requests to receive complete data. First one with ids, and second request should use these ids in their request. I need it in one publisher.
So I perform first:</p>
<pre><code>func getDataFromServer(request: Request) -&gt; AnyPublisher&lt;MyData, NetworkError&gt; {
    return networking.xml(request)
        .mapError { NetworkError.invalidData) }
        .flatMap { response -&gt; AnyPublisher&lt; MyData, NetworkError&gt; in
            return Future&lt; MyData, NetworkError&gt;.init { promise in
                guard let data = MyData.from(response: response) else {
                    return promise(.failure(NetworkError.parseError))
                }
                if data.myID.count &gt; 0 {
                    **// Perform second request with data.myID as parameter
                    // receive and fill additional fields data in 'data' object**
                }
                promise(.success(MyData))
            }.eraseToAnyPublisher()
        }
        .eraseToAnyPublisher()
}
</code></pre>
","377760","","","","","2021-09-13 20:17:57","Combine perform nested requests","<ios><swift><networking><combine>","1","0","","","","CC BY-SA 4.0"
"69170111","1","69170254","","2021-09-13 23:27:14","","0","453","<p>I'm just getting started with Combine. I have these questions for this situation:</p>
<ol>
<li>Is it accepted to have a tuple as a PassthroughSubject output?</li>
<li>Is it accepted to have a completion handler as part of the PassthroughSubject output?</li>
</ol>
<p>Example situation:</p>
<p>A SwiftUI log in view where I hand off logging in to another class and expect a result back:</p>
<pre><code>struct LogInView: View {
    var loginSubject = PassthroughSubject&lt;(username: String, password: String, completion: (Error?) -&gt; Void), Never&gt;()         

    var body: some View {
        Button {
            loginSubject.send((username: &quot;Jim&quot;, password: &quot;qwerty123&quot;, completion: { error in
                if let error = error {
                    // handle error
                } else {
                    // navigate to app
                }
            }))
        } label: {
            Text(&quot;Log in&quot;)
        }
    }
}
</code></pre>
<p>I would like to know other possible solutions to this scenario (I'm not able to use the 'login helper' class directly in the SwiftUI view due to 'LogInView' being in a package and the 'log in helper' being in the main app) and/or if this would be generally accepted as a solution.</p>
","2237587","","","","","2021-09-13 23:53:01","PassthroughSubject with completion handler output?","<ios><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"69210973","1","69212888","","2021-09-16 15:10:53","","-1","256","<p>I recently started to study the Combine and ran into a certain problem.
First, I will describe what I am doing.
I trying to use Clean Architecture
Here you can see my Repository</p>
<pre><code>protocol Repository {
    func test()
}

class MockRepository: Repository {
    func test() {
        sleep(3)
    }
}
</code></pre>
<p>Then I created UseCase</p>
<pre><code>class UseCaseBase&lt;TInput, TOutput&gt; {
    var task: TOutput? { return nil }

    var repository: Repository

    init(_ repository: Repository) {
        self.repository = repository
    }

    func execute(with payload: TInput) -&gt; AnyPublisher&lt;TOutput, Never&gt; {
        return AnyPublisher(Future&lt;TOutput, Never&gt; { promise in
            promise(.success(self.task!))
        })
            .eraseToAnyPublisher()
    }
}

class MockUseCase: UseCaseBase&lt;String, Int&gt; {
    override var task: Int? {
        repository.test()
        return 1
    }
}
</code></pre>
<p>And then in a init block ContentView I did something like that</p>
<pre><code>init() {
        let useCase = MockUseCase(MockRepository())
        var cancellables = Set&lt;AnyCancellable&gt;()
        
        useCase.execute(with: &quot;String&quot;)
            .sink(receiveValue: { value in
                print(value)
            })
            .store(in: &amp;cancellables)
        
        print(&quot;Started&quot;)
        
    }
</code></pre>
<p>At first, I want to get
&quot;Started&quot;
and then after <code>sleep(3)</code>
value &quot;1&quot;</p>
<p><em>Now I get
&quot;1&quot; and then &quot;Started&quot;</em></p>
","10662610","","","","","2021-09-16 17:36:55","Executing a task asynchronously using Combine with Swift","<swift><asynchronous><swiftui><combine>","2","5","","","","CC BY-SA 4.0"
"69218080","1","69245315","","2021-09-17 05:17:33","","0","313","<p>I've found great content, But nothing too specific to my needs being swiftui is still new.
I need to support menu cycling with switch case in the latest swift and monterey for macos, no ios development. i need strings, variables, and custom graphics to make a menu title and current in need of up to 9 menus to cycle randomly from one to a random other without an if statement looping through all of the others first:
more info here: <a href=""https://pastebin.com/VCnEmdBa"" rel=""nofollow noreferrer"">https://pastebin.com/VCnEmdBa</a></p>
<p>Additional information on needs:</p>
<p>I want to have the switch case cycle my nine menus, where i can be on any given one and the menu jump to the next random selection, right now it currently rotates in order no matter where i click.</p>
<pre><code>import Foundation
import SwiftUI
import CoreData
import Combine
import PDFKit
import SceneKit
import WebKit
 
 
struct Cotharticren: App {
  var body: some Scene {
        WindowGroup {
            ContentView()
        }
  }
}
 
     struct Option: Hashable {
        
         let title: String
       
         let imageName: String
     }
 
struct ContentView: View {
 
    @State var currentOption = 0
    
    let options: [Option] = [
        .init(title: &quot;DART Meadow&quot;, imageName: &quot;sun.max.fill&quot;),
        .init(title: &quot;Research&quot;, imageName: &quot;flame&quot;),
        .init(title: &quot;Navigation&quot;, imageName: &quot;moon.stars.fill&quot;),
        .init(title: &quot;Shelf&quot;, imageName: &quot;archivebox&quot;),
        .init(title: &quot;Chest&quot; ,imageName: &quot;shippingbox&quot;),
        .init(title: &quot;Crate&quot; ,imageName: &quot;bonjour&quot;),
        .init(title: &quot;Manufactoring&quot;, imageName: &quot;gear&quot;),
        .init(title: &quot;Warehouse&quot;, imageName: &quot;archivebox.fill&quot;),
        .init(title: &quot;Journal&quot;, imageName: &quot;note.text&quot;),
       
    ]
    
    var body: some View {
        VStack(alignment: .leading) {
        HStack(alignment: .top) {
        ScrollView( .vertical) {
        NavigationView{
            /*
            List(1..&lt;9)
            {
                     Text(&quot;\($0)&quot;)
                }
            .listStyle(SidebarListStyle())
            }
 */
            ListView(options: options, currentSelection: $currentOption)
         
            //Text(systemName: myItem.selectedImageName) + Text(myItem.whateverText)
           
            switch (currentOption) {
            case 1:
                OrbitNodeView()
            case 2:
                ATM26NodeView()
            case 3:
                NozzleNodeView()
            case 4:
                EmptyView()
                VStack(alignment: .center) {
                Text(&quot;Chest&quot;)
                    .font(.largeTitle)
                    .bold()
                    .colorInvert()
                }
            case 5:
                EmptyView()
                VStack(alignment: .center) {
                Text(&quot;Crate&quot;)
               
                    .font(.largeTitle)
                    .bold()
                    .colorInvert()
                }
            case 6:
                EmptyView()
                    VStack(alignment: .center) {
                    Text(&quot;Manufactoring&quot;)
                    .font(.largeTitle)
                    .bold()
                    .colorInvert()
                    }
            case 7:
                EmptyView()
                        VStack(alignment: .center) {
                        Text(&quot;Warehouse&quot;)
                    .font(.largeTitle)
                    .bold()
                    .colorInvert()
                        }
            case 8:
                   VStack(alignment: .center) {
                    Text(&quot;Journal&quot;)
                    .font(.largeTitle)
                    .bold()
                    .colorInvert()
                    .padding(.top, 60)
                       
                       Image(&quot;articrenmeadowopacity&quot;)
                           .shadow(radius: 3)
                    WebView()
                   
            }
            default:
                MainView()
           
            }
            
       }.background(Color.white)
       
        }
        
    }
        
        
        }
        Spacer()
    }
}
 
 
struct MainView: View {
 
    var body: some View{
        VStack(alignment: .leading) {
        HStack(alignment: .bottom) {
          
              
                Image(&quot;CotharticrenMainView&quot;)
                    .shadow(radius: 3)
   
        }
            }
        
        .frame(width: 900, height: 800, alignment: .center)
 
        Spacer()
        }
       
    }
  
 
 
 
struct ListView: View {
    let options: [Option]
    @Binding var currentSelection: Int
    var body: some View{
        
        
        VStack(alignment: .leading) {
        HStack(alignment: .top) {
            HStack(alignment: .top) {
                VStack(alignment: .trailing) {
            Circle()
                .stroke(Color.init(red: 0.9, green: 0.95, blue: 0.2, opacity: 1), lineWidth: 2)
                .alignmentGuide(HorizontalAlignment.myAlignment)
                                   { d in d[.leading] }
                .alignmentGuide(VerticalAlignment.myAlignment)
                                   { d in d[.bottom] }
                .frame(width: 50, height: 50)
                
                        Circle()
                            .stroke(Color.init(red: 0.25, green: 0.9, blue: 0.2, opacity: 1), lineWidth: 2)
                            .alignmentGuide(HorizontalAlignment.myAlignment)
                                               { d in d[.leading] }
                            .alignmentGuide(VerticalAlignment.myAlignment)
                                               { d in d[.bottom] }
                            .frame(width: 25, height: 25)
                            VStack(alignment: .leading) {
            Circle()
                .stroke(Color.init(red: 0.1, green: 0.1, blue: 1, opacity: 1), lineWidth: 2)
                .alignmentGuide(HorizontalAlignment.myAlignment)
                                   { d in d[.leading] }
                .alignmentGuide(VerticalAlignment.myAlignment)
                                   { d in d[.bottom] }
                .frame(width: 75, height: 75)
                }
                }
            }
            
            HStack(alignment: .top) {
        Image(&quot;DARTMeadowCSMwidthArtemis2by1&quot;)
               
            .shadow(radius: 3)
            .padding(.top, 10)
            }
                
            
            .padding(.top, 20)
 
        
        .padding(.trailing, 10)
        }.padding(.top, 20).padding(.leading, 10)
          
            HStack(alignment: .center) {
            VStack(alignment: .center) {
            
            Image(&quot;arrow300&quot;)
                HStack(alignment: .center) {
                Text(&quot;You've never plotted an Edge?&quot;)
                }
            }
            }.shadow(radius: 3)
 
        VStack(alignment: .leading) {
            let current = options[currentSelection]
            ForEach(options, id: \.self) {option in
                HStack {
                    
                    Image(systemName: option.imageName)
                        //.resizable()
                        //.aspectRatio(contentMode: .fit)
                        .frame(width: 20)
                    
                    Text(option.title)
                        .foregroundColor(current == option ? Color.blue : Color.white)
                   
                }
                .padding(8)
                
 
                .onTapGesture {
                    
                    currentSelection += 1
                    
                    if currentSelection == 9 {
                    currentSelection = 0
                    }
              }
            }
            Spacer()
        }.frame(width: 300, height: 800, alignment: .leading)
            
    }
        Spacer()
    }
        
}
 
 
 
 
struct WebView: View {
 
    var body: some View{
        VStack(alignment: .leading) {
        HStack(alignment: .bottom) {
          
              
                
   
                   
            }
        }
        .frame(width: 900, height: 800, alignment: .center)
 
        Spacer()
        }
       
    }
</code></pre>
","16933914","","16933914","","2021-09-18 19:33:25","2021-09-19 16:58:26","I've searched and search SwiftUI Switch Case Menu Cycle?","<swift><macos><swiftui>","1","6","","","","CC BY-SA 4.0"
"69241272","1","69291680","","2021-09-19 07:39:09","","0","605","<p>I'd like to display some Realm objects in a read-only view (SwiftUI), and as far as I've understood, Realm objects should be frozen for such views.</p>
<p>But where should I call <code>.freeze()</code>? On the <code>Results</code>-object or the publisher?</p>
<pre class=""lang-swift prettyprint-override""><code>Realm().objects(Contact.self)
    .freeze()
    .publisher
    .[...]
</code></pre>
<p>vs.</p>
<pre class=""lang-swift prettyprint-override""><code>Realm().objects(Contact.self)
    .publisher
    .freeze()
    .[...]
</code></pre>
<p>Or does it make no difference?</p>
","15978784","","15978784","","2021-09-21 20:41:46","2021-09-22 21:50:47","Where to call freeze() when working with Realm collections and Combine?","<swift><realm><combine>","1","6","","","","CC BY-SA 4.0"
"69262534","1","69262812","","2021-09-21 01:50:07","","0","192","<p>I have an <code>enum</code> case which is a <code>@Published</code> var in an <code>ObservableObject</code> class. What I'm trying to do is observe changes to the <code>term</code> var defined below and update an <code>annualRate</code> publisher.</p>
<p>Below is the <code>@Published</code> var</p>
<pre><code>@Published var term: MortgageTerm = .thirtyYear
</code></pre>
<p>The <code>MortgageTerm</code> enum is defined as follows:</p>
<pre><code>public enum MortgageType: Int, CaseIterable {
    case tenYear     = 10
    case fifteenYear = 15
    case twentyYear  = 20
    case thirtyYear  = 30
}
</code></pre>
<p>I'm trying to get this <code>annualRate</code> defined so it observes changes to the <code>term</code> var above:</p>
<pre><code>public lazy var annualRate: AnyPublisher&lt;Double, Never&gt; = {
    var output: Double
    $term
        .map { switchCase -&gt; Double in
            switch switchCase {
            case .tenYear:
                output = self.rates.tenYearFix
            case .fifteenYear:
                output = self.rates.fifteenYearFix
            case .twentyYear:
                output = self.rates.twentyYearFix
            case .thirtyYear:
                output = self.rates.thirtyYearFix
            }
            
            return output * 0.01
        }
        // FIXME: Result of call to `eraseToAnyPublisher()` is unused
        .eraseToAnyPublisher()
}()
</code></pre>
<p>I'm getting this warning at the line for <code>.eraseToAnyPublisher()</code>. What am I mucking up and how do I fix it?</p>
<p>This is where the <code>rates</code> are coming from:</p>
<pre><code>private lazy var rates: AverageRate = {
    let rateMock = AverageRate(thirtyYearFha: 2.873,
                                thirtyYearVa: 2.858,
                                tenYearFix: 2.068,
                                fifteenYearFix: 2.358,
                                thirtyYearFix: 3.054,
                                fiveOneArm: 2.898,
                                sevenOneArm: 2.972,
                                twentyYearFix: 2.756)
    
    return rateMock
}()
</code></pre>
","4475605","","","","","2021-09-21 02:42:51","Using a Published var to observe a switch case in a Publisher with Combine","<swift><enums><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"69277972","1","69310575","","2021-09-22 03:50:40","","5","277","<p>I'm building a mortgage calculator as an exercise to learn <code>Combine</code>. Everything has been going swimmingly until I encountered a situation where I'm not getting deterministic published output from one of my <code>Publishers</code> when I unit test it. I'm not making any asynchronous calls. This is the problematic <code>AnyPublisher</code>:</p>
<pre><code>public lazy var monthlyPayment: AnyPublisher&lt;Double, Never&gt; = {
    Publishers.CombineLatest3(financedAmount, monthlyRate, numberOfPayments)
        .print(&quot;montlyPayment&quot;, to: nil)
        .map { financedAmount, monthlyRate, numberOfPayments in
            let numerator = monthlyRate * pow((1 + monthlyRate), Double(numberOfPayments))
            let denominator = pow((1 + monthlyRate), Double(numberOfPayments)) - 1
            
            return financedAmount * (numerator / denominator)
        }
        .eraseToAnyPublisher()
}()
</code></pre>
<p>Let's say I change the mortgage type from a 30 year to a 15 year, a few things happen:</p>
<ol>
<li>the <code>numberOfPayments</code> changes due to the change in the mortgage term (length)</li>
<li>the <code>monthlyRate</code> due to a change in the mortgage term (length)</li>
</ol>
<h2>End Goal</h2>
<p>My end goal is to wait for <code>financedAmount</code>, <code>monthlyRate</code>, and <code>numberOfPayments</code> publishers to finish doing their thing and when they're ALL done, THEN compute the monthly payment. Merge 3 seems to pick up changes in each of the publishers and for each change, it computes and spits out output I don't want.</p>
<p><a href=""https://github.com/AdrianBinDC/MortgageCalcIssue"" rel=""nofollow noreferrer"">Repo with problematic class and associated unit tests</a></p>
<h2>What I've Tried</h2>
<p>I've tried mucking around with <code>MergeMany</code>, <code>Merge3</code>, <code>.collect()</code>, but I can't get the syntax right. I've Googled the snot out of this and looked for examples in public GitHub repos, but I'm coming up with nothing that's germane to my situation. I'm trying to figure out what I'm mucking up and how to fix it.</p>
<h2>Supporting Declarations</h2>
<p>These are my declarations for the other publishers upon which <code>monthlyPayment</code> relies:</p>
<pre><code>@Published var principalAmount: Double
@Published var mortgageTerm: MortgageTerm = .thirtyYear
@Published var downPaymentAmount: Double = 0.0

// monthlyRate replies upon annualRate, so I'm including annualRate above
internal lazy var monthlyRate: AnyPublisher&lt;Double, Never&gt; = {
  annualRate
      .print(&quot;monthlyRate&quot;, to: nil)
      .map { rate in
          rate / 12
      }
      .eraseToAnyPublisher()
}()

public lazy var annualRate: AnyPublisher&lt;Double, Never&gt; = {
  $mortgageTerm
      .print(&quot;annualRate&quot;, to: nil)
      .map { value -&gt; Double in
          switch value {
          case .tenYear:
              return self.rates.tenYearFix
          case .fifteenYear:
              return self.rates.fifteenYearFix
          case .twentyYear:
              return self.rates.twentyYearFix
          case .thirtyYear:
              return self.rates.thirtyYearFix
          }
      }
      .map { $0 * 0.01 }
      .eraseToAnyPublisher()
}()

public lazy var financedAmount: AnyPublisher&lt;Double, Never&gt; = {
  Publishers.CombineLatest($principalAmount, $downPaymentAmount)
      .map { principal, downPayment in
          principal - downPayment
      }
      .eraseToAnyPublisher()
}()

public lazy var numberOfPayments: AnyPublisher&lt;Double, Never&gt; = {
  $mortgageTerm
      .print(&quot;numberOfPayments: &quot;, to: nil)
      .map {
          Double($0.rawValue * 12)
      }
      .eraseToAnyPublisher()
}()
</code></pre>
<h2>Update</h2>
<p>I attempted to use <code>Merge3</code> with <code>.collect()</code>, but my unit test is timing out on it. Here's the updated <code>monthlyPayment</code> declaration:</p>
<pre><code> public lazy var monthlyPayment: AnyPublisher&lt;Double, Never&gt; = {
     Publishers.Merge3(financedAmount, monthlyRate, numberOfPayments)
         .collect()
         .map { mergedArgs in
             let numerator = mergedArgs[1] * pow((1 + mergedArgs[1]), mergedArgs[2])
             let denominator = pow((1 + mergedArgs[1]), mergedArgs[2]) - 1
             
             return mergedArgs[0] * (numerator / denominator)
         }
         .eraseToAnyPublisher()
 }()
</code></pre>
<p>The test now fails with a timeout and the <code>.sink</code> code is never called:</p>
<pre><code> func testMonthlyPayment() {
     // sut is initialized w/ principalAmount of $100,000 &amp; downPaymentAmount of $20,000
     let sut = calculator
     
     let expectation = expectation(description: #function)
     
     let expectedPayments = [339.62, 433.97, 542.46]
     
     sut.monthlyPayment
         .collect(3)
         .sink { actualMonthlyPayment in
             XCTAssertEqual(actualMonthlyPayment.map { $0.roundTo(places: 2) }, expectedPayments)
             expectation.fulfill()
         }
         .store(in: &amp;subscriptions)
     
     // Initialized with 30 year fix with 20% down
     // Change term to 20 years
     sut.mortgageType = .twentyYear
     
     // Change the financedAmount
     sut.downPaymentAmount.value = 0.0
     
     waitForExpectations(timeout: 5, handler: nil)     
}
</code></pre>
","4475605","","4475605","","2021-09-24 04:57:57","2021-09-26 09:41:38","Unexpected Combine Publisher Behavior","<swift><combine><publisher>","1","7","","","","CC BY-SA 4.0"
"69291373","1","69292659","","2021-09-22 21:16:54","","0","64","<p>I have two api calls using <code>Combine</code> and <code>Result</code> that I need to merge so that i can create a new objects from the two.</p>
<pre><code>  public func getPosts() -&gt; AnyPublisher&lt;Result&lt;[Post], Error&gt;, Never&gt; {
    let client = ForumClient()
    return client.execute(.posts)
  }

  public func getUsers() -&gt; AnyPublisher&lt;Result&lt;[User], Error&gt;, Never&gt; {
    let client = ForumClient()
    return client.execute(.users)
  }
</code></pre>
<p>I have working code, but I feel like I'm missing some syntactic sugar that can avoid the two switches.</p>
<pre><code>    Publishers.Zip(getPosts(), getUsers())
      .sink(
        receiveValue: { [weak self] postsResult, usersReult in
          guard let self = self else {
            return
          }

          // Get Posts
          var posts: [Post] = []
          switch postsResult {
          case .failure(let error):
            print(&quot;Error: \(error.localizedDescription)&quot;)
          case .success(let postsArray):
            posts = postsArray
          }

          // Get Users
          var users: [User] = []
          switch usersReult {
          case .failure(let error):
            print(&quot;Error: \(error.localizedDescription)&quot;)
          case .success(let usersArray):
            users = usersArray
          }


          //Combine posts and users
          var forumPosts: [ForumPost] = []

          posts.forEach { post in
            users.forEach { user in
              if user.id == post.userId {
                let forumPost = ForumPost(username: user.username, title: post.title)
                forumPosts.append(forumPost)
              }
            }
          }

          print(forumPosts)

        })
      .store(in: &amp;publishers)
</code></pre>
<p>Is there a better way to do this that avoids using two switches etc?</p>
","6734301","","","","","2021-09-23 03:50:08","Using Combines zip with two api calls that return Result<T, Error>","<swift>","2","0","","","","CC BY-SA 4.0"
"69311371","1","69312040","","2021-09-24 07:46:58","","5","1919","<p>Consider the following code:</p>
<pre><code>        CurrentValueSubject&lt;Void, Error&gt;(())
            .eraseToAnyPublisher()
            .sink { completion in

                switch completion {
                case .failure(let error):
                    print(error)
                    print(&quot;FAILURE&quot;)
                case .finished:
                    print(&quot;SUCCESS&quot;)
                }
            } receiveValue: { value in
                // this should be ignored
            }
</code></pre>
<p>Just by looking at the <code>CurrentValueSubject</code> initializer, it's clear that the value is not needed / doesn't matter.</p>
<p>I'm using this particular publisher to make an asynchronous network request which can either pass or fail.</p>
<p>Since I'm not interested in the value returned from this publisher (there are none), how can I get rid of the <code>receiveValue</code> closure?</p>
<p>Ideally, the call site code should look like this:</p>
<pre><code>        CurrentValueSubject&lt;Void, Error&gt;(())
            .eraseToAnyPublisher()
            .sink { completion in

                switch completion {
                case .failure(let error):
                    print(error)
                    print(&quot;FAILURE&quot;)
                case .finished:
                    print(&quot;SUCCESS &quot;)
                }
            }
</code></pre>
<p>It also might be the case that I should use something different other than <code>AnyPublisher</code>, so feel free to propose / rewrite the API if it fits the purpose better.</p>
<p>The closest solution I was able to find is <a href=""https://developer.apple.com/documentation/combine/publisher/ignoreoutput()"" rel=""noreferrer"">ignoreOutput</a>, but it still returns a value.</p>
","3667264","","","","","2021-09-24 09:09:51","Combine sink: ignore receiveValue, only completion is needed","<swift><swiftui><reactive-programming><combine>","2","3","","","","CC BY-SA 4.0"
"69356976","1","69360140","","2021-09-28 06:48:08","","1","126","<p>I have two functions with the following signatures:</p>
<pre><code>import Combine

func firstCall() -&gt; Future&lt;Result&lt;Void, Error&gt;, Never&gt; {
    return Future { promise in
        promise(.success(.success(())))
    }
}



func secondCall() -&gt; Future&lt;Result&lt;Void, Error&gt;, Never&gt; {
    return Future { promise in
        promise(.success(.success(())))
    }
}


// Execute 1st call, then if it succeeds, execute the 2nd call
</code></pre>
<p>How can I execute the 2nd function only after the 1st one completes successfully?</p>
<p>Ideally, I'm looking to something like this:</p>
<pre><code>executeInSequence([firstCall(), secondCall()])
.onResult( { finalResult in
print(finalResult)
})
</code></pre>
<p>Feel free to slightly adjust API signatures if that helps the call site.</p>
<p>More information: one of the calls is actually a converted synchronous method call with a signature of:</p>
<pre><code>func secondSynchronousCall() throws {
}

    private func secondCall() -&gt; Future&lt;Result&lt;Void, Error&gt;, Never&gt; {
        return Future { [weak self] promise in
            do {
                try self?.secondSynchronousCall()
                promise(.success(.success(())))
            } catch {
                promise(.success(.failure(error)))
            }
        }
    }
</code></pre>
","3667264","","3667264","","2021-09-28 06:58:13","2021-09-28 10:33:56","Execute two promises in sequence in Swift / Combine","<swift><promise><functional-programming><combine>","1","4","","","","CC BY-SA 4.0"
"69371982","1","69372727","","2021-09-29 07:18:16","","0","254","<p>For scientific reasons I've created a <strong>Publisher</strong> and a <strong>Subscriber</strong> so I can dive into Combine.</p>
<p>The <strong>Publisher</strong> has been converted from a <strong>never failing</strong> to the <strong>failing</strong> one.</p>
<pre class=""lang-swift prettyprint-override""><code>enum IntegerError: String, Error {
    case miltupleOf2 = &quot;We are sorry but the number is a multiple of 2, therefore cannot be used in the process&quot;
}

let integerPublisher = [1,3,3,3,3,3,5,6,7,7].publisher
    .setFailureType(to: IntegerError.self)

let subscribtion = integerPublisher
    .tryMap { intValue in
        if intValue.isMultiple(of: 2) {
            throw IntegerError.miltupleOf2
        } else {
            return intValue
        }
    }
    .sink { completion in
        switch completion {
        case .finished:
            print(&quot;success&quot;)
        case .failure(let error):
            if let error = error as? IntegerError {
                print(error.rawValue)
            } else {
                print(error)
            }
        }
    } receiveValue: { value in
        print(value)
    }
</code></pre>
<p>My question is: when using <strong>sink</strong>, the error type is <strong>Error</strong>. Why is it not the custom <strong>IntegerError</strong> that I've used within the <strong>.setFailureType</strong> modifier?</p>
<p>The need of casting my error to the type that I specified earlier seems a little redundant.</p>
<p>Thank you.</p>
","14880022","","","","","2021-09-29 08:12:50","Swift Combine framework setFailureType error operator","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"69375932","1","69376725","","2021-09-29 11:57:44","","-1","260","<p>I just made a simple code of a timer, and am trying to figure out a way to NOT reset the timer when other observed object status is changed.
When I start the timer with init function, it resets whenever other observed objects' status is changed.
When I start the timer with onAppear, it gets changed once other observed objects' status is changed and never start again.
What I want to accomplish is, the timer starts once and doesn't reset when other observed objects have changed during other observed objects are passed out from other View and the tiemr itself has to be Subview.
Any suggestions?</p>
<pre><code>import SwiftUI
import Combine
import Foundation

struct ContentView: View {

    @ObservedObject var apptCardVM: ApptCardViewModel
    @ObservedObject var timerData = TimerDataViewModel()

    var body: some View {
        VStack {
            CurrentDateView(timerData: timerData)  // &lt;&lt; here !!

            Picker(&quot;Seizure Type&quot;, selection: $apptCardVM.typeIndex) {
            ForEach(0..&lt;apptCardVM.typeChoice.count) {
                Text(self.apptCardVM.typeChoice[$0])
            }
        }.pickerStyle(SegmentedPickerStyle())

        }

    }
}

struct CurrentDateView: View {
    @State private var currentDate = Date()
    let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
    @ObservedObject var timerData: TimerDataViewModel
    var body: some View {

        Text(&quot;\(Int(timerData.hoursElapsed), specifier: &quot;%02d&quot;):\(Int(timerData.minutesElapsed), specifier: &quot;%02d&quot;):\(Int(timerData.secondsElapsed), specifier: &quot;%02d&quot;)&quot;)
            .fontWeight(.bold)
            .textFieldStyle(RoundedBorderTextFieldStyle())
            .onAppear(){
                timerData.start()
            }
    }
}

class ApptCardViewModel: ObservableObject, Identifiable {
    @Published var typeChoice = [&quot;Quick&quot;, &quot;Long&quot;, &quot;FullService&quot;]
    @Published var typeIndex: Int = 0
    private var cancellables = Set&lt;AnyCancellable&gt;()


}

class TimerDataViewModel: ObservableObject{
    
    @Published var timer = Timer()
    @Published var startTime : Double = 0.0
    @Published var secondsOriginal = 0.0
    @Published var secondsElapsed = 0.0
    @Published var secondsElapsed_ = 0.0
    @Published var minutesElapsed = 0.0
    @Published var hoursElapsed = 0.0
    
    enum stopWatchMode {
        case running
        case stopped
        case paused
    }
    
    init(){
//        start()
        print(&quot;initialized&quot;)
    }

    
    func start(){
            self.secondsOriginal = self.startTime
            self.timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true){ timer in
                self.secondsOriginal += 1
                self.secondsElapsed_ = Double(Int(self.secondsOriginal))
                self.secondsElapsed = Double(Int(self.secondsOriginal)%60)
                self.minutesElapsed = Double(Int(self.secondsOriginal)/60 % 60)
                self.hoursElapsed = Double(Int(self.secondsOriginal)/3600 % 24)
            }
    }
}
</code></pre>
","951443","","","","","2021-09-29 12:49:22","SwiftUI Timer keep resetting when updating the ObservedObjects","<ios><swift><swiftui><timer><observedobject>","1","3","","","","CC BY-SA 4.0"
"69394812","1","69402636","","2021-09-30 15:18:54","","1","166","<p>My app consumes few API endpoints to fetch data, that is managed by respective ViewModels.</p>
<p>For example, this ViewModel fetch the languages</p>
<pre class=""lang-swift prettyprint-override""><code>class LanguageViewModel: ObservableObject {
    var subscriptions: Set&lt;AnyCancellable&gt; = []

    @Published private(set) var languages: [LanguageItem]?
    @Published private(set) var error: Error?

    func get() {
        APIService.fetchData()
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { [weak self] value in
                guard let self = self else { return }
                if case let .failure(error) = value {
                    self.error = error
                }

            }, receiveValue: { (data: [LanguageItem]) in
                self.languages = data

            })
            .store(in: &amp;self.subscriptions)
    }
}
</code></pre>
<p>and so on.</p>
<p>Now for the main UI</p>
<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
    @ObservedObject private var languageViewModel = LanguageViewModel()

    var body: some View {
        let hasError = Binding&lt;Bool&gt;(
            get: { self.languageViewModel.error != nil },
            set: { _ in }
        )

        Button(action: {
            self.languageViewModel.get()
        }) {
            Text(&quot;Hello, World&quot;)
        }
        .alert(isPresented: hasError) {
            let message = self.languageViewModel.error?.description

            return Alert(title: Text(&quot;Error&quot;), message: Text(message ?? &quot;&quot;), dismissButton: .default(Text(&quot;OK&quot;)))
        }
    }
}
</code></pre>
<p>If somehow the API call fails on clicking the button, the first and only first time the alert is shown, then on subsequent clicks does not appear.</p>
<p>Placing a breakpoint on <code>.alert</code> show that the code is running correctly, just not showing again.</p>
<p>Please send help!!</p>
","813728","","","","","2021-10-01 08:15:25","SwiftUI Alert shown once","<ios><swift><swiftui>","1","5","","","","CC BY-SA 4.0"
"69407291","1","69408187","","2021-10-01 14:08:51","","0","343","<p>I am trying to wrap all errors into one class, with Combine and URLSession. However, I can't map the &quot;No internet connection&quot; errors.</p>
<p>This is my code:</p>
<pre><code>func request&lt;T&gt;(type: T.Type, urlRequest: URLRequest) -&gt; AnyPublisher&lt;Resource&lt;Response&lt;T&gt;&gt;, Error&gt; where T : GenericDecodable {
    return URLSession.shared.dataTaskPublisher(for: urlRequest)
        .tryMap({ try NetworkController.handleURLResponse(output: $0, url: urlRequest) })
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
}

static func handleURLResponse&lt;T&gt;(output: URLSession.DataTaskPublisher.Output, url: URLRequest) throws -&gt; Resource&lt;Response&lt;T&gt;&gt; {
    guard let response = output.response as? HTTPURLResponse else { throw NetworkingError.badURLResponse(url: url) }
    
    var finalResponse: Response&lt;T&gt;
    do {
        finalResponse = try JSONDecoder().decode(Response&lt;T&gt;.self, from: output.data)
    } catch {
        return Resource.networkError(data: nil)
    }
    
    switch response.statusCode {
        case 200..&lt;300:
            return Resource.success(data: finalResponse)
        case 422, 400:
            return Resource.validationError(data: finalResponse)
        default:
            return Resource.networkError(data: nil)
    }
}
</code></pre>
<p>As you can see, if the server sends malformed JSON or something like that, my code works without any problem. But if I disable the internet connection on my phone, I mean if there is no response from the server, my tryMap method is not calling. I only see some text of logs. Like these:</p>
<pre><code>), NSLocalizedDescription=Could not connect to the server., NSErrorFailingURLStringKey=http://api-panel-gw.productplus.conf/api/customers/login?, NSErrorFailingURLKey=http://api-panel-gw.productplus.conf/api/customers/login?, _kCFStreamErrorDomainKey=1}
</code></pre>
<p>If this happens, I want to send <code>Resource.networkError(data: nil)</code> to the subscriber.</p>
<p>I tried to put .mapError above the .tryMap, but no luck. I am getting the following error:</p>
<p><a href=""https://i.stack.imgur.com/wxR5b.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wxR5b.png"" alt=""enter image description here"" /></a></p>
<p>How can I achieve that?</p>
","1270400","","","","","2021-10-01 15:27:52","Handle no internet connection errors with Combine and URLSession","<ios><swift>","1","5","","","","CC BY-SA 4.0"
"69416170","1","69419852","","2021-10-02 10:46:00","","1","84","<p>I'd like to combine two dataframes d1 and d2 in R. It should be grouped by &quot;ID&quot;, but at the end there should only exist one column &quot;date&quot; so that further analysis are possible (It is important to know if the &quot;number&quot;-entry (d2) is linked to the &quot;type&quot;-entry (d1) or how close it is to it)</p>
<p>Lets say d1 and d2 is</p>
<pre><code>d1 &lt;- data.frame(ID = c(1,1,2,2,2,3), 
                 sex = c(&quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;female&quot;),
                 date = c(&quot;2016-06-21 08:15:00&quot;, &quot;2016-06-21 23:00:00&quot;,
                          &quot;2017-04-19 07:15:00&quot;, &quot;2017-04-20 07:15:00&quot;, &quot;2017-04-20 08:15:00&quot;,
                          &quot;2017-08-20 23:15:00&quot; ),
                 type = c(&quot;horse&quot;, &quot;snake&quot;, &quot;horse&quot;, &quot;horse&quot;, &quot;monkey&quot;, &quot;fish&quot;))

d2 &lt;- data.frame(ID = c(1,1,1,2,2,3,3), 
                 date = c(&quot;2016-06-20 08:15:00&quot;, &quot;2016-06-21 22:15:00&quot;, &quot;2016-06-22 08:45:00&quot;,
                          &quot;2017-04-19 07:15:00&quot;, &quot;2017-04-19 09:30:00&quot;,
                          &quot;2017-08-19 08:15:00&quot;, &quot;2017-08-21 06:30:00&quot;),
                 number = c(65,234,64,234,6243,23,243))
</code></pre>
<p>My desired output would be</p>
<pre><code>d12 &lt;- data.frame(ID = c(1,1,1,1,1,2,2,2,2,3,3,3),
                  sex = c(NA, &quot;male&quot;, NA, &quot;male&quot;, NA, &quot;male&quot;, NA, &quot;male&quot;, &quot;male&quot; , NA, &quot;female&quot;, NA),
                  date = c(&quot;2016-06-20 08:15:00&quot;,&quot;2016-06-21 08:15:00&quot;, &quot;2016-06-21 22:15:00&quot;, &quot;2016-06-21 23:00:00&quot;, &quot;2016-06-22 08:45:00&quot;,
                          &quot;2017-04-19 07:15:00&quot;, &quot;2017-04-19 09:30:00&quot;, &quot;2017-04-20 07:15:00&quot;, &quot;2017-04-20 08:15:00&quot;,
                          &quot;2017-08-19 08:15:00&quot;, &quot;2017-08-20 23:15:00&quot;, &quot;2017-08-21 06:30:00&quot; ),
                  type = c(NA, &quot;horse&quot;, NA, &quot;snake&quot;, NA, &quot;horse&quot;, NA, &quot;horse&quot;, &quot;monkey&quot;, NA, &quot;fish&quot;, NA),
                  number= c(65, NA, 234, NA, 64, 234, 6243, NA, NA, 23, NA, 243))

</code></pre>
<p>I tried doing this</p>
<pre><code>d12 &lt;- full_join(
  d1 %&gt;% group_by(ID) %&gt;% mutate(time=row_number()),
  d2 %&gt;% group_by(ID) %&gt;% mutate(time=row_number()),
by = c(&quot;ID&quot;, &quot;time&quot;))
</code></pre>
<p>But more or less I just added some columns, I don't really come closer to my desired output. I am very looking forward to your help.</p>
","17057491","","17057491","","2021-10-02 20:31:40","2021-10-02 20:31:40","How to combine two data-frames by group and date","<r><dataframe><group-by><merge><combine>","1","6","","","","CC BY-SA 4.0"
"69417754","1","69419750","","2021-10-02 14:21:28","","2","274","<p>This code does not compile on iOS 13 because flatMap is available only in iOS 14. How to extend SubscribeOn to have flatMap operator?</p>
<pre><code>func f1(_ value: Int) -&gt; Future&lt;Int, Error&gt; {
    Future { promise in
        print(&quot;\(Thread.current): f1() value = \(value)&quot;)
        promise(.success(value + 1))
    }
}

func f2(_ value: Int) -&gt; Future&lt;Int, Error&gt; {
    Future { promise in
        print(&quot;\(Thread.current): f2() value = \(value)&quot;)
        promise(.success(value + 1))
    }
}

let a1 = Just(0)
    .subscribe(on: DispatchQueue.global())
    .flatMap(f1)
    .flatMap(f2)
    .receive(on: DispatchQueue.main)
    .sink { _ in
        print(&quot;\(Thread.current): completed&quot;)
    } receiveValue: { value in
        print(&quot;\(Thread.current): sink() value = \(value)&quot;)
    }
</code></pre>
<p>UPDATE
Here is how my solution looks like now:</p>
<pre><code>extension Publishers.SubscribeOn {
    func myFlatMap&lt;P&gt;(_ transform: @escaping (Self.Output) -&gt; P) -&gt; Publishers.FlatMap&lt;P, Publishers.SetFailureType&lt;Self, P.Failure&gt;&gt; where P: Publisher {
        Publishers.FlatMap&lt;P, Publishers.SetFailureType&lt;Self, P.Failure&gt;&gt;(
            upstream: Publishers.SetFailureType&lt;Self, P.Failure&gt;(upstream: self),
            maxPublishers: .unlimited,
            transform: transform
        )
    }
}
</code></pre>
","2464355","","2464355","","2021-10-02 16:48:47","2021-10-02 19:54:10","How to get SubscribeOn flatMap operator for iOS 13?","<swift><ios13><combine>","1","0","","","","CC BY-SA 4.0"
"69424516","1","69425705","","2021-10-03 11:41:05","","2","200","<p>I'm trying to use Combine to do several millions concurrent request through the network. Here is a mock up of the naive approach I'n using:</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

let cancellable = (0..&lt;1_000_000).publisher
  .map(some_preprocessing)
  .flatMap(maxPublishers: .max(32)) { request in
    URLSession.dataTaskPublisher(for: request)
      .map(\.data)
      .catch { _ in
        return Just(Data())
      }
  }
  .sink { completion in
    print(completion)
  } receiveValue: { value in
    print(value)
  }

// Required in a command line tool
sleep(100)
</code></pre>
<p>This pipeline first creates a request, the the request is done in <code>flatMap</code> to confine errors. Also, <code>flatMap</code> merges several requests to they are effectively done concurrently, which is great.</p>
<p>The issue is that it will literally make 1,000,000 requests concurrently, so I added the parameter <code>maxPublishers</code> which limits the number of publishers that are subscribed at the same time in <code>flatMap</code>. This kind of work, only 32 publishers are active at the same time, but unfortunately <code>some_preprocessing</code> will still be performed 1,000,000 times before <code>flatMap</code> will be executed.</p>
<p>I expected <code>flatMap(maxPublishers: .max(32))</code> to apply some back pressure, i.e. only requesting items from the upstream publisher <code>map</code> when <code>maxPublishers</code> &lt; 32. This does not seem to be the case, and it fills up the RAM rapidly and delays the processing.</p>
<p>I then tried to use the <code>buffer</code> operator that is used to introduce back pressure between a producer and a consumer, but Apple documentation is so poor I don't understand its functioning (more specifically the <code>prefechStrategy</code> argument).</p>
<p>So I tried different combinations such as:</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

let cancellable = (0..&lt;1_000_000).publisher
  .map(some_preprocessing)
  .buffer(size: 32, prefetch: .byRequest, whenFull: .dropNewest)
  .flatMap(maxPublishers: .max(32)) { request in
    URLSession.dataTaskPublisher(for: request)
      .map(\.data)
      .catch { _ in
        return Just(Data())
      }
  }
  .sink { completion in
    print(completion)
  } receiveValue: { value in
    print(value)
  }

// Required in a command line tool
sleep(100)
</code></pre>
<p>This does not seem to do anything useful though, <code>flatMap</code> still requests as much element as it can.</p>
<p><strong>How to properly apply back pressure in this case? I.e I need the upstream <code>map</code> publisher to &quot;wait&quot; for demand asked by the downstream publisher <code>flatMap</code>, which should only ask items when it as an empty slot.</strong></p>
","6324055","","","","","2021-10-05 15:18:21","How to apply back pressure with Combine buffer operator to avoid flatMap to ask an infinite demand upstream?","<swift><reactive-programming><combine>","1","5","","","","CC BY-SA 4.0"
"69441902","1","69444427","","2021-10-04 20:13:24","","1","890","<p>I have a strange infinite loop when using onAppear and I cannot identify the root of the problem. It only happens when the view is the detail view of a navigation view, but it works fine when it's the root view.
Another interesting thing is that if I wrap the detail view in a NavigationView (so, now we have a navigation view inside a navigation view), then the issue does not appear anymore. Is this a bug in SwiftUI? Is conceptually my design OK? I mean, using onAppear like viewDidLoad to trigger the initial sequence.
Thanks for suggestions.</p>
<p>Here is the source code.
ContentView.swift:</p>
<pre><code>import SwiftUI

struct ContentView: View {

    @StateObject var viewModel = ContentViewModel()

    var body: some View {
        NavigationView {
            VStack {
                Group {
                    switch viewModel.state {
                    case .loading:
                        Text(&quot;Loading...&quot;)
                    case .loaded:
                        HStack {
                            Text(&quot;Loaded&quot;)
                            Button(&quot;Retry&quot;) {
                                viewModel.fetchData()
                            }
                        }
                    }
                }
                .padding(.bottom, 20)
                NavigationLink(&quot;Go to detail screen&quot;, destination: DetailView())
            }
        }
        .onAppear() {
            viewModel.fetchData()
        }
    }
}

class ContentViewModel: ObservableObject  {

    enum State {
        case loading
        case loaded
    }

    @Published var state: State = .loading

    func fetchData() {
        state = .loading
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            self.state = .loaded
        }
    }
}
</code></pre>
<p>And here the code of the detail view:</p>
<pre><code>import SwiftUI

struct DetailView: View {

    @StateObject var viewModel = DetailViewModel()

    var body: some View {
        Group {
            switch viewModel.state {
            case .loading:
                Text(&quot;Loading...&quot;)
            case .loaded:
                HStack {
                    Text(&quot;Loaded&quot;)
                    Button(&quot;Retry&quot;) {
                        viewModel.fetchData()
                    }
                }
            }
        }
        .onAppear() {
            print(&quot;infinite loop here&quot;)
            viewModel.fetchData()
        }
    }
}

class DetailViewModel: ObservableObject  {

    enum State {
        case loading
        case loaded
    }

    @Published var state: State = .loading

    func fetchData() {
        state = .loading
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            self.state = .loaded
        }
    }
}
</code></pre>
<p>Here I attach the project:
<a href=""https://www.dropbox.com/s/5alokj3q81jbpj7/TestBug.zip?dl=0"" rel=""nofollow noreferrer"">https://www.dropbox.com/s/5alokj3q81jbpj7/TestBug.zip?dl=0</a></p>
<p>I'm using Xcode Version 12.5.1 (12E507) and iOS 14.5</p>
<p>Thanks a lot.</p>
","917338","","","","","2022-02-08 19:58:45","Infinite loop when using onAppear in SwiftUI","<swiftui><combine>","2","5","1","","","CC BY-SA 4.0"
"69469448","1","69469572","","2021-10-06 16:32:43","","3","271","<p>I have a <code>@Published</code> string in my view model. I want to receive updates on its value in my view controller so that I can update the UI.</p>
<p>I am able to successfully get the updates through use of the <code>sink</code> subscriber. This works fine:</p>
<pre><code>viewModel.$buttonText.sink { [weak self] buttonText in
      self?.buttonOutlet.setTitle(buttonText, for: .normal)
}.store(in: &amp;cancellables)
</code></pre>
<p>But I am looking for a one line approach. Something more like what you are able to do with UILabels using the <code>assign</code> subscriber:</p>
<pre><code>viewModel.$title.assign(to: \.text, on: titleLabel).store(in: &amp;cancellables)
</code></pre>
<p>I've tried accessing the <code>buttonOutlet.titleLabel</code> directly, but this of course doesn't work since we can't directly update the text (<code>UIButton.titleLabel</code> is read-only). And it also introduces the issue of unwrapping the <code>titleLabel</code> property:</p>
<pre><code>viewModel.$buttonText.assign(to: \.!.text, on: buttonOutlet.titleLabel).store(in: &amp;cancellables)
</code></pre>
<p>I don't know if I'm just struggling to find the correct syntax or if this is simply a limitation of Combine for the time being.</p>
","4959716","","4959716","","2021-10-06 16:39:29","2021-10-06 19:02:43","Is there a way to update UIButton's titleLabel text using Combine's .assign instead of .sink?","<swift><uikit><combine>","3","0","","","","CC BY-SA 4.0"
"69477691","1","69481117","","2021-10-07 08:17:57","","1","637","<p>How can I validate the email inside view model combining that two codes using combine?</p>
<p>This is inside my RegisterViewModel</p>
<pre><code>private var isEmailValidPublisher: ValidatePublisher {
        $email
            .removeDuplicates()
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines).count &gt;= 10}
            .handleEvents(receiveOutput: { [weak self] in $0 ? (self?.emailMessage = &quot;&quot;) : (self?.emailMessage = &quot;Invalid email&quot;)})
            .eraseToAnyPublisher()
    }
</code></pre>
<p>I want to add this validation inside isEmailValidPublisher.</p>
<pre><code>func isValidEmail() -&gt; Bool {
        let emailRegEx = &quot;(?:[\\p{L}0-9!#$%\\&amp;'*+/=?\\^_`{|}~-]+(?:\\.[\\p{L}0-9!#$%\\&amp;'*+/=?\\^_`{|}&quot; + &quot;~-]+)*|\&quot;(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\&quot; + &quot;x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\&quot;)@(?:(?:[\\p{L}0-9](?:[a-&quot; + &quot;z0-9-]*[\\p{L}0-9])?\\.)+[\\p{L}0-9](?:[\\p{L}0-9-]*[\\p{L}0-9])?|\\[(?:(?:25[0-5&quot; + &quot;]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-&quot; + &quot;9][0-9]?|[\\p{L}0-9-]*[\\p{L}0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21&quot; + &quot;-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])&quot;
        
        let emailValidation = NSPredicate(format:&quot;SELF MATCHES[c] %@&quot;, emailRegEx)
        return emailValidation.evaluate(with: self)
    }
</code></pre>
<p>how can I mix both of them inside isEmailValidPublisher so that I can use that info in my signupview like below</p>
<pre><code> Image(systemName: &quot;envelope&quot;)
                    .foregroundColor(registerVM.emailMessage != &quot;&quot; ? .red: .blue)
</code></pre>
","8418174","","","","","2021-10-07 12:25:20","SwiftUI Combine ViewModel Email Validation","<validation><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"69495351","1","69495505","","2021-10-08 11:47:22","","0","199","<p>I'm creating a login token validity timer, and I figured it needs to be a singleton that ticks and every second (or every minute or whatever), checks to see whether the login token is still valid.</p>
<p>But I can't even get the singleton to print a message every second. Why not?</p>
<pre><code>import SwiftUI
import Combine

class TokenObserver: ObservableObject {
    private let publisher = Timer.TimerPublisher(interval: 1.0, runLoop: .main, mode: .default)
    private let cancellable: AnyCancellable?
    static let instance = TokenObserver()
    let uuid = UUID()

    private init() {
        NSLog(&quot;TokenObserver.init()&quot;)
        self.cancellable = self.publisher.sink(receiveCompletion: { completion in
            NSLog(&quot;TokenObserver \(completion)&quot;)
        }, receiveValue: { date in
            NSLog(&quot;TokenObserver timestamp=&quot; + ISO8601DateFormatter().string(from: date))
        })
    }

    deinit {
        NSLog(&quot;TokenObserver.deinit()&quot;)
        self.cancellable?.cancel()
    }
}

struct ContentView: View {
    var body: some View {
        Text(&quot;Hello, world! Instance = &quot; + TokenObserver.instance.uuid.uuidString)
            .padding()
    }
}
</code></pre>
","12811732","","","","","2021-10-08 11:59:56","Combine Timer.TimerPublisher not starting","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"69506002","1","70416311","","2021-10-09 10:45:07","","6","3409","<p>I have a networking layer that currently uses completion handlers to deliver a result on the operation is complete.</p>
<p>As I support a number of iOS versions, I instead extend the network layer within the app to provide support for Combine. I'd like to extend this to now also a support Async/Await but I am struggling to understand how I can achieve this in a way that allows me to cancel requests.</p>
<p>The basic implementation looks like;</p>
<pre class=""lang-swift prettyprint-override""><code>
protocol HTTPClientTask {
    func cancel()
}

protocol HTTPClient {
    typealias Result = Swift.Result&lt;(data: Data, response: HTTPURLResponse), Error&gt;
    @discardableResult
    func dispatch(_ request: URLRequest, completion: @escaping (Result) -&gt; Void) -&gt; HTTPClientTask
}

final class URLSessionHTTPClient: HTTPClient {
    
    private let session: URLSession
    
    init(session: URLSession) {
        self.session = session
    }
    
    func dispatch(_ request: URLRequest, completion: @escaping (HTTPClient.Result) -&gt; Void) -&gt; HTTPClientTask {
        let task = session.dataTask(with: request) { data, response, error in
            completion(Result {
                if let error = error {
                    throw error
                } else if let data = data, let response = response as? HTTPURLResponse {
                    return (data, response)
                } else {
                    throw UnexpectedValuesRepresentation()
                }
            })
        }
        task.resume()
        return URLSessionTaskWrapper(wrapped: task)
    }
}

private extension URLSessionHTTPClient {
    struct UnexpectedValuesRepresentation: Error {}
    
    struct URLSessionTaskWrapper: HTTPClientTask {
        let wrapped: URLSessionTask
        
        func cancel() {
            wrapped.cancel()
        }
    }
}
</code></pre>
<p>It very simply provides an abstraction that allows me to inject a <code>URLSession</code> instance.</p>
<p>By returning <code>HTTPClientTask</code> I can call <code>cancel</code> from a client and end the request.</p>
<p>I extend this in a client app using <code>Combine</code> as follows;</p>
<pre class=""lang-swift prettyprint-override""><code>extension HTTPClient {
    typealias Publisher = AnyPublisher&lt;(data: Data, response: HTTPURLResponse), Error&gt;

    func dispatchPublisher(for request: URLRequest) -&gt; Publisher {
        var task: HTTPClientTask?

        return Deferred {
            Future { completion in
                task = self.dispatch(request, completion: completion)
            }
        }
        .handleEvents(receiveCancel: { task?.cancel() })
        .eraseToAnyPublisher()
    }
}
</code></pre>
<p>As you can see I now have an interface that supports canceling tasks.</p>
<p>Using <code>async/await</code> however, I am unsure what this should look like, how I can provide a mechanism for canceling requests.</p>
<p>My current attempt is;</p>
<pre class=""lang-swift prettyprint-override""><code>extension HTTPClient {
    func dispatch(_ request: URLRequest) async -&gt; HTTPClient.Result {

        let task = Task { () -&gt; (data: Data, response: HTTPURLResponse) in
            return try await withCheckedThrowingContinuation { continuation in
                self.dispatch(request) { result in
                    switch result {
                    case let .success(values): continuation.resume(returning: values)
                    case let .failure(error): continuation.resume(throwing: error)
                    }
                }
            }
        }

        do {
            let output = try await task.value
            return .success(output)
        } catch {
            return .failure(error)
        }
    }
}
</code></pre>
<p>However this simply provides the <code>async</code> implementation, I am unable to cancel this.</p>
<p>How should this be handled?</p>
","7579156","","1974224","","2021-10-10 14:49:38","2022-04-14 17:45:52","Cancelling an async/await Network Request","<ios><swift><async-await><urlsession>","3","2","1","","","CC BY-SA 4.0"
"69545349","1","69579673","","2021-10-12 18:26:35","","0","293","<p>I'm trying to query HealthKit for heart rate values and steps in the time interval defined by a <a href=""https://developer.apple.com/documentation/healthkit/hkworkoutevent#"" rel=""nofollow noreferrer""><code>HKWorkoutEvent</code></a> to fill a custom local model I have defined to store multiple variables, it's defined below.</p>
<pre class=""lang-swift prettyprint-override""><code>struct SGWorkoutEvent: Identifiable {
    let id = UUID()
    let type: HKWorkoutEventType
    let splitActiveDurationQuantity: HKQuantity?
    let splitDistanceQuantity: HKQuantity?
    let totalDistanceQuantity: HKQuantity?
    let splitMeasuringSystem: HKUnit

    let steps: HKQuantity?
    let heartRate: HKQuantity?
}
</code></pre>
<p>Al properties except <code>steps</code> and <code>heartRate</code> can be extracted from a <code>HKWorkoutEvent</code>. However, I am trying to build a Combine pipeline that would let me create an array of publishers to query in parallel for heart rate, steps and also pass the workout event so in the <code>sink</code> I receive a 3-element tuple with these values so I can populate the model above. What I  currently have is below,</p>
<pre class=""lang-swift prettyprint-override""><code>// Extract the workout's segments (defined automatically by an Apple Watch)
let workoutSegments = (workout.workoutEvents ?? []).filter({ $0.type == .segment })

// For each of the workout segments defined above create a HKStatisticQuery that starts on the interval's
// beginning and ends on the interval's end so the HealthKit query is properly defined to be
// executed between that interval.
let segmentsWorkoutPublisher = Publishers.MergeMany(workoutSegments.map({ $0.dateInterval }).map({
    healthStore.statistic(for: HKQuantityType.quantityType(forIdentifier: HKQuantityTypeIdentifier.heartRate)!, with: .discreteAverage, from: $0.start, to: $0.end)
}))
.assertNoFailure()

// Do the same logic as above in `segmentsWorkoutPublisher` but for steps
let stepsPublisher = Publishers.MergeMany(workoutSegments.map({ $0.dateInterval }).map({

    healthStore.statistic(for: HKObjectType.quantityType(forIdentifier: HKQuantityTypeIdentifier.stepCount)!, with: .cumulativeSum, from: $0.start, to: $0.end)
}))
.assertNoFailure()

Publishers.Zip3(workoutSegments.publisher, stepsPublisher, segmentsWorkoutPublisher)
    
    .receive(on: DispatchQueue.main)
    .sink(receiveValue: { pace, steps, hrs in
        
        let d = SGWorkoutEvent(type: pace.type,
                               splitActiveDurationQuantity: pace.splitDuration,
                               splitDistanceQuantity: pace.splitDistance,
                               totalDistanceQuantity: pace.totalDistanceQuantity,
                               splitMeasuringSystem: pace.splitMeasuringSystem,
                               steps: steps.sumQuantity(),
                               heartRate: hrs.averageQuantity())
        
        self.paces.append(d)
    })
    .store(in: &amp;bag)
</code></pre>
<p><code>HKHealthStore.statistic(for:...)</code> is nothing but a Combine wrapper for <code>HKStatisticsQuery</code> defined on a <code>HKHealthStore</code> extension, see below.</p>
<pre class=""lang-swift prettyprint-override""><code>public func statistic(for type: HKQuantityType, with options: HKStatisticsOptions, from startDate: Date, to endDate: Date, _ limit: Int = HKObjectQueryNoLimit) -&gt; AnyPublisher&lt;HKStatistics, Error&gt; {
    
    let subject = PassthroughSubject&lt;HKStatistics, Error&gt;()
    
    let predicate = HKStatisticsQuery.predicateForSamples(withStart: startDate, end: endDate, options: [.strictEndDate, .strictStartDate])
    
    let query = HKStatisticsQuery(quantityType: type, quantitySamplePredicate: predicate, options: options, completionHandler: { (query, statistics, error) in
        
        guard error == nil else {
            hkCombineLogger.error(&quot;Error fetching statistics \(error!.localizedDescription)&quot;)
            return
        }
        
        subject.send(statistics!)
        subject.send(completion: .finished)
    })
    
    self.execute(query)
    
    return subject.eraseToAnyPublisher()
}
</code></pre>
<p>What I am seeing here is some sort of race condition where both steps and heart rate retrieved is not returning ad the same time. As a result I see values that don't make sense like on one 1K split of 5' 200steps and another one of the same duration 700steps. The real case should be that those two intervals should show a value around 150 but it seems that I am probably not using the correct Combine operator.</p>
<p>The expected behavior I would hope to see is for every publisher on <code>Publishers.Zip</code> to have each 3-item tuple have finished its query in order (1st interval, 2nd interval...) rather than this non-replicable race condition.</p>
<p>To try and give more context I think this is akin to having a model with temperature, humidity and chance of rain for different timestamps and querying three different API endpoints to retrieve the three different values and merge them in the model.</p>
","4296481","","4296481","","2021-10-12 18:50:21","2021-10-15 03:36:06","Executing Combine Publishers in parallel creates race condition","<swift><combine><healthkit>","1","1","","","","CC BY-SA 4.0"
"69568041","1","69571321","","2021-10-14 09:10:41","","0","80","<p>If I have a combine pipeline, that prints changes to an array, is it then possible to update that array without having the pipeline run?</p>
<pre class=""lang-swift prettyprint-override""><code>class ObserveableTest: ObservableObject {
    private var cancellables: Set&lt;AnyCancellable&gt; = []
    @Published var items: [Int] = []
    init() {
        $items
            .debounce(for: 0.6, scheduler: RunLoop.main)
            .sink {
                print($0)
            }
            .store(in: &amp;cancellables)
    }
    
    func pleaseDoNotNotifyPipeline() {
        items.append(1)
    }
}
</code></pre>
<p><strong>Update:</strong>
The code provided is a simplified version of what I work on.
In short, I work on a basket manager, and whenever the user changes the quantity of a product (or in another way changes the basket) a request will need to be sent to the backend, why the debounce. In the code above, it is simply shown with changes to an array instead.</p>
<p>The case is, that the changes the user makes to the basket should run the the pipeline, however, it can also be that the system (from a web-response etc.) updates the local basket itself, and in that case the pipeline should not run.</p>
<p>I fear that cancelation and resubscribing to the pipeline in rare cases can mean that, changes from the user is lost.
But im also maybe realising the cancel/resub is the only solution, and I will need to take care of that rare situation. Or do you see other solutions now that I have elaborated a bit?</p>
","1838231","","1838231","","2021-10-14 09:38:47","2021-10-14 13:29:04","Update property without running combine pipeline","<swift><combine>","3","1","","","","CC BY-SA 4.0"
"69578970","1","69580805","","2021-10-15 01:21:56","","0","64","<p>My goal: Retrieve data from firestore and display said data once.</p>
<p>Problem: Same data is retrieving multiple times. If there is 5 rows of data, the array of my model retrieves 5 times. Why is this happening?</p>
<p>Here is my firestore model:</p>
<pre><code>&quot;Users - Investors&quot;
   &quot;currentUser.uid&quot;
      &quot;id&quot;: currentUser
      &quot;fullName&quot;: fullName,
      &quot;username&quot;: username,
      &quot;userLocation&quot;: userLocation,
      &quot;birthday&quot;: birthday
</code></pre>
<p>Here is my model:</p>
<pre><code>struct InvestorModel: Identifiable {
    let id: String
    let fullName: String
    let username: String
    let userLocation: String
    let birthday: Date
}
</code></pre>
<p>Here is my vm:</p>
<pre><code>class InvestorProfileViewModel: ObservableObject {
    @Published var investorProfile: [InvestorModel] = []
    
    private var auth = Auth.auth()
    private var store = Firestore.firestore()
    
    func getUserInfo() {
        let currentUser = auth.currentUser?.uid ?? &quot;&quot;
        store.collection(&quot;Users - Investors&quot;).document(currentUser).addSnapshotListener { snapshot, error in
            guard let data = snapshot?.data(), error == nil else {
                print(&quot;NO INVESTOR DATA, TRYING ARTIST DATA&quot;)
                return
            }

            DispatchQueue.main.async {
                self.investorProfile = data.map { (dataSnapshot) -&gt; InvestorModel in
                    return InvestorModel(
                        id: currentUser,
                        fullName: data[&quot;fullName&quot;] as? String ?? &quot;&quot;,
                        username: data[&quot;username&quot;] as? String ?? &quot;&quot;,
                        userLocation: data[&quot;userLocation&quot;] as? String ?? &quot;&quot;,
                        birthday: data[&quot;birthday&quot;] as? Date ?? Date()
                    )
                }
                print(self.investorProfile)
            }
        }
    }
}
</code></pre>
<p>Here is my view:</p>
<pre><code>struct HomeView: View {
    @EnvironmentObject var hvm: HomeViewModel
    @EnvironmentObject var ipvm: InvestorProfileViewModel
    @Environment(\.colorScheme) var colorScheme
    
    let devInvestor = DeveloperPreview.instance.investor
    
    var body: some View {
        ZStack {
            Color.theme.background.ignoresSafeArea(.all)
            VStack {
                ForEach(ipvm.investorProfile) { investor in
                    MenuContent(investor: investor, menuWidth: menuWidth)
                }
            }
            .padding(.vertical, 20)
            .padding(.horizontal, 30)
        }
        .onAppear {
            self.ipvm.getUserInfo()
        }
    }
}
</code></pre>
<p>The print call inside of getUserInfo() returns:</p>
<p>[musifi.InvestorModel(id: &quot;F65D7CB4-25B3-47C5-9A26-78C645916AAC&quot;, fullName: &quot;John Doe&quot;, username: &quot;johnn&quot;, userLocation: &quot;Lake Elsinore, CA, USA&quot;, birthday: 2021-10-15 00:59:47 +0000),</p>
<p>[musifi.InvestorModel(id: &quot;F65D7CB4-25B3-47C5-9A26-78C645916AAC&quot;, fullName: &quot;John Doe&quot;, username: &quot;johnn&quot;, userLocation: &quot;Lake Elsinore, CA, USA&quot;, birthday: 2021-10-15 00:59:47 +0000),</p>
<p>musifi.InvestorModel(id: &quot;2B4AE47A-4C55-4229-AB9F-1F2BA9983B44&quot;, fullName: &quot;John Doe&quot;, username: &quot;johnn&quot;, userLocation: &quot;Lake Elsinore, CA, USA&quot;, birthday: 2021-10-15 00:59:47 +0000),</p>
<p>musifi.InvestorModel(id: &quot;E8F87591-DC12-4068-958E-D2DA9025C316&quot;, fullName: &quot;John Doe&quot;, username: &quot;johnn&quot;, userLocation: &quot;Lake Elsinore, CA, USA&quot;, birthday: 2021-10-15 00:59:47 +0000),</p>
<p>musifi.InvestorModel(id: &quot;95C8B099-C753-410E-AF7D-72EDD8FB0E7D&quot;, fullName: &quot;John Doe&quot;, username: &quot;johnn&quot;, userLocation: &quot;Lake Elsinore, CA, USA&quot;, birthday: 2021-10-15 00:59:47 +0000)]</p>
<p>4 types of data: fullName, username, userLocation, birthday - and 4 times it was called. This number always correlates. I am only calling the function once.</p>
","16653398","","16653398","","2021-10-15 06:08:41","2021-10-15 06:41:11","iOS - Firestore same data retrieving multiple times","<ios><swift><firebase><google-cloud-firestore><combine>","1","7","","","","CC BY-SA 4.0"
"69592408","1","69592471","","2021-10-16 03:27:04","","2","176","<p>I have the following function:</p>
<pre><code>func generateIn() -&gt; Future&lt;Int,Never&gt; {
    return Future{ promise in
        promise(.success(Int.random(in: 1...10)))
    }
}
</code></pre>
<p>and I'm calling that function from this variable:</p>
<pre><code>let sub2 = generateIn()
    .map { value in
        print(value)
        return Int(value)
    }
</code></pre>
<p>But I'm getting this error:</p>
<pre><code>Unable to infer complex closure return type; add explicit type to disambiguate
</code></pre>
<p><a href=""https://i.stack.imgur.com/8UWO5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8UWO5.png"" alt=""enter image description here"" /></a></p>
<p>Any of you knows why I'm getting this error or how can fix it?</p>
<p>I'll really appreciate your help</p>
","2924482","","","","","2021-10-16 03:42:12","Swift Combine: Unable to infer complex closure return type error","<ios><swift><xcode><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"69618911","1","69635093","","2021-10-18 15:41:48","","0","375","<p>I have numerous pages where users may input information. They may input the fields with dates, numbers, or text.</p>
<p>I am trying to receive all changes in Combine and get their outputs as <code>Encodable</code> so I can easily upload the results to the network.</p>
<p>A <code>String</code> is <code>Encodable</code>, so I thought this would be easy but I cannot get this to work in Combine. I get a compiler error:</p>
<blockquote>
<p>Cannot convert return expression of type 'Publishers.Map&lt;Published.Publisher, Encodable&gt;' to return type 'Published.Publisher'</p>
</blockquote>
<p>There is a workaround where I add another property in <code>SampleTextHandler</code> that is <code>@Published var userTextEncodable: Encodable</code> but that's not what I want to do.</p>
<pre><code>import Combine

protocol FieldResponseModifying {
    var id: String { get }
    var output: Published&lt;Encodable&gt;.Publisher { get }
}


struct SampleTextWrapper {
    var output: Published&lt;Encodable&gt;.Publisher {
        // Cannot convert return expression of type 'Publishers.Map&lt;Published&lt;String&gt;.Publisher, Encodable&gt;' to return type 'Published&lt;Encodable&gt;.Publisher'
        handler.$userTextOutput.map { $0 as Encodable}
    }
    
    let id = UUID().uuidString
    let handler = SampleTextHandler()
}

class SampleTextHandler {
   @Published var userTextOutput = &quot;&quot;
    init () { }
}
</code></pre>
","9718260","","","","","2021-10-19 17:10:39","How can I map to a type in Combine?","<swift><combine>","1","5","","","","CC BY-SA 4.0"
"69628795","1","69663950","","2021-10-19 09:59:28","","-1","402","<p>Updating cartArray from ViewModel doesn't append to the current elements, but adds object everytime freshly. I need to maintain cartArray as global array so that it can be accessed from any view of the project. I'm adding elements to cartArray from ViewModel. I took a separate class DataStorage which has objects that can be accessible through out the project</p>
<pre><code>Example_AppApp.swift
import SwiftUI

@main
struct Example_AppApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView().environmentObject(DataStorage())
        }
    }
}
DataStorage.swift

import Foundation

class DataStorage: ObservableObject {
    @Published var cartArray = [Book]()
}
ContentView.swift
import SwiftUI

struct ContentView: View {
    @State var showSheetView = false

    var body: some View {
        NavigationView{
            
        ListViewDisplay()
           .navigationBarItems(trailing:
                    Button(action: {
                        self.showSheetView.toggle()
                    }) {
                        Image(systemName: &quot;cart.circle.fill&quot;)
                            .font(Font.system(.title))
                    }
                )
            
            
 
        }.sheet(isPresented: $showSheetView) {
            View3()
        }
        
    }
}



struct ListViewDisplay: View{
    
    
    var book = [
       Book(bookId: 1 ,bookName: &quot;Catch-22&quot;),
       Book(bookId: 2 ,bookName: &quot;Just-Shocking&quot; ),
       Book(bookId: 3 ,bookName: &quot;Stephen King&quot; ),
       Book(bookId: 4,bookName: &quot;A Gentleman in Moscow&quot;),
    ]
    
    var body: some View {
        List(book, id: \.id) { book in
            Text(book.bookName)

            NavigationLink(destination: View1(book: book)) {
            
        }
        }
        
}
}



View1Modal.swift

import Foundation

struct Book: Codable, Identifiable {
    var id:String{bookName}  
    var bookId : Int
    var bookName: String

}
 struct BookOption: Codable{
    var name: String
    var price: Int
}

View1ViewModel.swift
import Foundation
import Combine


class View1ViewModel : ObservableObject{
    
    var dataStorage = DataStorage()
   
    func addBook (bookId:Int ,bookName : String){
           dataStorage.cartArray.append(Book(bookId:bookId, bookName: bookName)) // Adding to global array
        print(dataStorage.cartArray)
    }
  
}

View1.swift
import SwiftUI

struct View1: View {
    
    @ObservedObject var vwModel = View1ViewModel()
    @EnvironmentObject var datastrg: DataStorage
   
    var book:Book
    
    var body: some View {
        
        Text(book.bookName).font(.title)
        Spacer()
        Button(action: {
            vwModel.addBook(bookId: book.bookId, bookName: book.bookName)
            
        }, label: {
            Text(&quot;Add Book to Cart&quot;)
            
                .frame(maxWidth: .infinity, minHeight: 60)
                .background(Color.red)
                .foregroundColor(Color.white)
                .font(.custom(&quot;OpenSans-Bold&quot;, size: 24))
            
        })
        
 
        
    }
}

View3.swift

import SwiftUI

struct View3: View {
    @EnvironmentObject var datastorage : DataStorage
    var body: some View {
        NavigationView {
            List(datastorage.cartArray,id:\.id){book in

   
                    VStack{
                    Text(book.bookName)
                        .font(.custom(&quot;OpenSans-Bold&quot;, size: 20))
                          
                        }
                    
            }
            
                    .navigationBarTitle(Text(&quot;Cart&quot;), displayMode: .inline)
                }
    }
}
</code></pre>
<p>When addBook func is called for the first time it prints as</p>
<pre><code>[Example_App.Book(bookId: 1, bookName: &quot;Catch-22&quot;)]
</code></pre>
<p>When I go back and come back to this View1 and add another book by calling <code>addBook</code> <code>func</code> it adds as new object to cartArray</p>
<pre><code>[Example_App.Book(bookId: 3, bookName: &quot;Stephen King&quot;)]
</code></pre>
<p>Printing number of elements in <code>cartArray</code> gives as <code>1 element</code> instead of <code>2 elements</code>. When I go to <code>View3</code> and display the Books in list, <code>cartArray</code> shows as <code>empty(0 elements)</code></p>
<p>I think there is something wrong with var dataStorage = DataStorage() in ViewModel class. Everytime this is being created freshly, so the prevoius values are not stored. But I couldn't understand how to preserve its state
How to display List in View3 ? Any ideas/ suggestions will be helpful</p>
","1719339","","1719339","","2021-10-21 12:52:58","2021-10-22 16:07:27","@EnvironmentObject property not working properly in swiftUI","<swift><iphone><xcode><swiftui>","2","7","","","","CC BY-SA 4.0"
"69634368","1","69641278","","2021-10-19 16:14:21","","0","118","<p>I have the following code:</p>
<pre><code>class Stuff {
    var str: String?
    var num = 0
}

class MyStuff:ObservableObject {
    @Published var stuff:Stuff?
    @Published var numer: Int?
}

class DoSomething {
    let observedObject = MyStuff()
    var cancellableBag = Set&lt;AnyCancellable&gt;()
    
    init() {
        observedObject.objectWillChange.sink { value in
            print(value)
            print(&quot;Object has changed&quot;)
        }.store(in: &amp;cancellableBag)
        observedObject.$stuff.sink { value in
            print(value?.str ?? &quot;&quot;)
        }.store(in: &amp;cancellableBag )
    }
}
</code></pre>
<p>But when I execute:</p>
<pre><code>let doSomething = DoSomething()
doSomething.observedObject.stuff?.str = &quot;Doing something&quot;
doSomething.observedObject.stuff?.num = 2
</code></pre>
<p>, the notifications never trigger:</p>
<p><a href=""https://i.stack.imgur.com/0g3tK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0g3tK.png"" alt=""enter image description here"" /></a></p>
<p>Any of you knows why the notifications never trigger? Or how can I make it happen?</p>
","2924482","","1974224","","2021-10-20 06:32:59","2021-10-20 06:32:59","Notifications not sent when changing an ObservedObject","<swift><swiftui><combine><observableobject>","2","3","","","","CC BY-SA 4.0"
"69638458","1","69640580","","2021-10-19 22:56:56","","2","1269","<p>I'm trying to observer any changes in object in the core data instance. Here is my code:</p>
<pre><code>class MyClass {
    @objc dynamic var str: String?
}

final class Article: NSObject {
    @objc dynamic var title: String?
    @objc dynamic var summary: String?
    var myVar: MyClass?
}
</code></pre>
<p>Here is were I'm implementing the observers:</p>
<pre><code>func update(article: Article) {
    titleSubscription = article.publisher(for: \.title).sink { value in
        print(value)
    } receiveValue: { _ in
        print(&quot;I got something&quot;)
    }
    summarySubscription = article.publisher(for: \.myVar?.str).sink{ _ in
        
    } receiveValue: { _ in
        
    }
}
</code></pre>
<p>But I'm getting this error:</p>
<pre><code>Thread 1: Fatal error: Could not extract a String from KeyPath Swift.KeyPath&lt;Examples.Article, Swift.Optional&lt;Swift.String&gt;&gt;
</code></pre>
<p><a href=""https://i.stack.imgur.com/Wn8ML.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Wn8ML.png"" alt=""enter image description here"" /></a></p>
<p>Any of you knows why I'm getting this error or if there is any work around ?</p>
<p>I'll really appreciate your help.</p>
","2924482","","9223839","","2021-10-20 07:49:52","2021-10-20 07:49:52","Swift Combine: Could not extract a String from KeyPath Swift.KeyPath","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"69645185","1","69645369","","2021-10-20 11:31:06","","1","218","<p>When some calculation happens in viewModel I want to present modal view. Normally I need to set some boolean binding for method:</p>
<pre><code>.fullScreenCover(isPresented: $isGalleryPresented) {
    GalleryPickerView())
}
</code></pre>
<p>where isGalleryPresented, is @State definied in view. However browsing SO, i have found out that I could have property in viewModel:</p>
<pre><code>@Published var isGalleryPresented = false
</code></pre>
<p>and then do something like this:</p>
<pre><code>.fullScreenCover(isPresented: $viewModel.isGalleryPresented) {
    GalleryPickerView()
}
</code></pre>
<p>And this works just fine, although I don't know how. <code>fullScreenCover</code> method argument of type <code>isPresented: Binding&lt;Bool&gt;</code>, and I pass as far as I can tell a publisher. How does this work?</p>
","744270","","1359088","","2022-07-12 13:42:33","2022-07-12 13:42:33","Passing @Published property where @Binding is expected?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"69678394","1","69682065","","2021-10-22 14:13:30","","0","92","<p>Goal to make retry with different input data.</p>
<pre><code>func generateRandomName() -&gt; Int { ... }

checkIfNameIsAvailable(generateRandomName())
   .retry(10) // &lt;- Makes 10 attempts with same link
   .sink(
       receiveCompletion: { completion in
            },
            receiveValue: { value in
                // Do things
            }
          )
          .store(in: &amp;cancellables)
</code></pre>
<p>How can I modify <code>retry</code> to retry with different upstream (request different query parameter) and 10 attempts?</p>
","4314758","","3141234","","2021-10-22 19:18:23","2021-10-22 19:18:23","How to retry a request with different input?","<ios><swift><combine>","2","1","","","","CC BY-SA 4.0"
"69681567","1","69681693","","2021-10-22 18:27:16","","0","623","<p>I have a parent state that <em>might</em> exist:</p>
<pre><code>class Model: ObservableObject {
    @Published var name: String? = nil
}
</code></pre>
<p><em>If</em> that state exists, I want to show a child view. In this example, showing <code>name</code>.</p>
<p>If <code>name</code> is visible, I'd like it to be shown and editable. I'd like this to be two-way editable, that means if <code>Model.name</code> changes, I'd like it to push to the ChildUI, if the ChildUI edits this, I'd like it to reflect back to <code>Model.name</code>.</p>
<p>However, if <code>Model.name</code> becomes <code>nil</code>, I'd like <code>ChildUI</code> to hide.</p>
<p>When I do this, via unwrapping of the <code>Model.name</code>, then only the first value is captured by the <code>Child</code> who is now in control of that state. Subsequent changes will not push upstream because it is not a <code>Binding</code>.</p>
<p><strong>Question</strong></p>
<p>Can I have a non-optional upstream bind to an optional when it exists? (are these the right words?)</p>
<p><strong>Complete Example</strong></p>
<pre><code>import SwiftUI

struct Child: View {
    // within Child, I'd like the value to be NonOptional
    @State var text: String
    
    var body: some View {
        TextField(&quot;OK: &quot;, text: $text).multilineTextAlignment(.center)
    }
}

class Model: ObservableObject {
    // within the parent, value is Optional
    @Published var name: String? = nil
}

struct Parent: View {
    @ObservedObject var model: Model = .init()
    
    var body: some View {
        VStack(spacing: 12) {
            Text(&quot;Demo..&quot;)

            // whatever Child loads the first time will retain
            // even on change of model.name
            if let text = model.name {
                Child(text: text)
            }
            
            // proof that model.name changes are in fact updating other state
            Text(&quot;\(model.name ?? &quot;&lt;waiting&gt;&quot;)&quot;)
        }
        .onAppear {
            model.name = &quot;first change of optionality works&quot;
            loop()
        }
    }
    
    @State var count = 0
    func loop() {
        async(after: 1) {
            count += 1
            model.name = &quot;updated: \(count)&quot;
            loop()
        }
    }
}

func async(_ queue: DispatchQueue = .main,
           after: TimeInterval,
           run work: @escaping () -&gt; Void) {
    queue.asyncAfter(deadline: .now() + after, execute: work)
}

struct OptionalEditingPreview: PreviewProvider {
    static var previews: some View {
        Parent()
    }
}
</code></pre>
","2611971","","","","","2021-10-22 21:06:12","Bridging Optional Binding to Non-Optional Child (SwiftUI)","<swift><swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"69684714","1","69690691","","2021-10-23 02:47:17","","2","659","<p>Overall use case is 4 network requests</p>
<ul>
<li>A. Request 1 and 2 need to be in parallel and wait for both to
complete</li>
<li>B. Request 3 happens after 1 and 2 complete</li>
<li>C. Request 4
happens after 3 completes</li>
</ul>
<p>After C the final output should be of a <code>AnyPublisher</code> type</p>
<p>I am trying to use Combine to achieve the above and so far I am able to do A using <code>Publishers.Zip</code> and C using <code>flatMap</code>. What I am struggling with is B. I can do that using nested completion handlers but not using <code>flatMap</code></p>
<p>This is the sample code with Strings (not actual code)</p>
<pre><code>func overallFunc(arg1: &quot;arg1&quot;, arg2: &quot;arg2&quot;, arg3: &quot;arg3&quot;, arg4: &quot;arg4&quot; ) -&gt; AnyPublisher&lt;String?, Error&gt; {
let pub1 = func1(arg1: arg1, arg2: arg2)
let pub2 = func2(arg1: arg3, arg2: arg4)

let combinedPub = Publishers.Zip(pub1, pub2)

combinedPub
   .flatMap {(response1, response2) in
     return func3(arg1: response1.attribute1, arg2: response2.attribute2)
   }
}
</code></pre>
<p>The <code>func1</code>, <code>func2</code> and <code>func3</code> all return <code>URLSession.shared.dataTaskPublisher</code> with return type say  <code>AnyPublisher&lt;String?, Error&gt;</code></p>
<p>Now I am struggling with completing the code for <code>overallFunc</code>. The complier gives the following error around <code>flatMap</code>.</p>
<p><code>Type of expression is ambiguous without more context</code></p>
<p>If I add an extra return in the last line of <code>overallFunc</code> then the error changes to
<code>No 'flatMap' candidates produce the expected contextual result type 'AnyPublisher&lt;String?, Error&gt;'</code></p>
<p>In short I want to use <code>flatMap</code> on the result of <code>Publishers.Zip</code> and return another publisher so that I can add another <code>flatMap</code> to do the 4th request but am not able to figure out the right syntax and order of things to do that.</p>
","5721193","","","","","2021-10-23 17:52:09","Chaining + zipping multiple network requests using Swift and Combine","<swift><combine>","2","5","","","","CC BY-SA 4.0"
"69725699","1","69728617","","2021-10-26 15:14:26","","4","461","<p>After switching our API Client to Combine we start to receive reports from our users about error &quot;The operation couldn’t be completed (NSURLErrorDomain -1.)&quot; which is the <code>error.localizedDescription</code> forwarded to UI from our API client.</p>
<p>Top level api call looks like this:</p>
<pre><code>class SomeViewModel {
  private let serviceCategories: ICategoriesService
  private var cancellables = [AnyCancellable]()

  init(service: ICategoriesService) {
    self.serviceCategories = service
  }

  // ...

  // Yes, the block is ugly. We are only on the half way of the migration to Combine
  func syncData(force: Bool = false, _ block: @escaping VoidBlock) {
    serviceCategories
      .fetch(force: force)
      .combineLatest(syncOrders(ignoreCache: force))
      .receive(on: DispatchQueue.main)
      .sink { [unowned self] completion in
        // bla-bla-bla
        // show alert on error
      }
      .store(in: &amp;cancellables)
  }
}
</code></pre>
<p>Low level API Client call looks like:</p>
<pre><code>func fetch&lt;R&gt;(_ type: R.Type, at endpoint: Endpoint, page: Int, force: Bool) -&gt; AnyPublisher&lt;R, TheError&gt; where R : Decodable {
  guard let request = request(for: endpoint, page: page, force: force) else {
    return Deferred { Future { $0(.failure(TheError.Network.cantEncodeParameters)) } }.eraseToAnyPublisher()
  }

  let decoder = JSONDecoder()
  decoder.keyDecodingStrategy = .convertFromSnakeCase

  return URLSession.shared
      .dataTaskPublisher(for: request)
      .subscribe(on: DispatchQueue.background)
      .tryMap { element in
        guard
          let httpResponse = element.response as? HTTPURLResponse,
          httpResponse.statusCode == 200 else
        { throw URLError(.badServerResponse) }
        
        return element.data
      }
      .decode(type: type, decoder: decoder)
      .mapError { error in
        // We map error to present in UI
        switch error {
        case is Swift.DecodingError:
          return TheError.Network.cantDecodeResponse
          
        default:
          return TheError(title: nil, description: error.localizedDescription, status: -2)
        }
      }
      .eraseToAnyPublisher()
}
</code></pre>
<p>In our analytics we can clearly see chain of events:</p>
<ul>
<li>application updated</li>
<li>application opened</li>
<li>main screen shown</li>
<li>alert shown (NSURLErrorDomain -1)</li>
<li>application backgrounded
then user fall into loop &quot;opened, alert, backgrounded&quot; trying to restart or reinstall the app without success.</li>
</ul>
<p>First sought was it may be some garbage sent from backend to the client, but our server logs have records for api calls correlated to analytics logs by date and time with <strong>http status code 499</strong>.<br />
So we can clearly determine this is not a server problem.
We also do not have reports or analytics records from users before this update.</p>
<p>All points to new API client switched to Combine.</p>
<p>It looks like session dropped by the client for some reason but at the same time it does not relates to a memory release cycle since if cancellable where released <code>sink</code> closure will never be executed and alert message will not be shown.</p>
<p><strong>Questions:</strong></p>
<ul>
<li>What can be wrong with this URLSession setup?</li>
<li>Did you faced similar behavior and managed to solve it?</li>
<li>Do you have ideas how to reproduce or at least simulate such error with URLSession?</li>
</ul>
<p>Notes:</p>
<ul>
<li>We do not use SwiftUI</li>
<li>iOS version vary from 14.8 to 15.0</li>
<li>From 5 to 10% of users affected</li>
<li>We never faced such error during development or testing</li>
</ul>
","1522697","","","","","2021-10-26 19:03:17","Swift Combine in UIKit. URLSession dataTaskPublisher NSURLErrorDomain -1 for some users","<ios><swift><combine><urlsession><nsurlsessiondatatask>","1","4","","","","CC BY-SA 4.0"
"69731160","1","69737763","","2021-10-26 23:52:38","","0","94","<p>Does anyone know how to recreate sampling behavior in Combine?</p>
<p>Here's a diagram of the sample's behavior in RXMarbles</p>
<p><a href=""https://i.stack.imgur.com/0S80B.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0S80B.png"" alt=""enter image description here"" /></a></p>
<p>The gist of sample() is that there are two streams, when one is triggered, the latest value of the other stream is sent if it already hasn't been sent.</p>
","465446","","","","","2021-10-27 18:07:24","Does Swift's Combine framework have a sample(on:) operator similar to those in RXSwift or Reactive Swift?","<rx-swift><reactive><sample><combine>","2","0","","","","CC BY-SA 4.0"
"69746741","1","69746865","","2021-10-27 23:54:56","","1","422","<p>After subscribing, I completed the subscription with the send method.<br />
I subscribed again, but it's finished.
How can I subscribe again?</p>
<pre><code>import Combine

let subject = PassthroughSubject&lt;String, Never&gt;()

subject
.sink(receiveCompletion: { completion in
    print(&quot;Received completion:&quot;, completion)
}, receiveValue: { value in
    print(&quot;Received value:&quot;, value)
})

subject.send(&quot;test1&quot;)
subject.send(completion: .finished)


subject
.sink(receiveCompletion: { completion in
    print(&quot;Received completion:&quot;, completion)
}, receiveValue: { value in
    print(&quot;Received value:&quot;, value)
})

subject.send(&quot;test2&quot;)
</code></pre>
<p>The output result is as follows.</p>
<blockquote>
<p>Received value: test1<br />
Received completion: finished<br />
Received completion: finished</p>
</blockquote>
<p>How can I get &quot;Received value: test2&quot;?</p>
","17149583","","","","","2021-10-28 00:15:49","How can I subscribe again after finishing with Combine?","<swift><combine><completion>","2","0","","","","CC BY-SA 4.0"
"69762275","1","69762412","","2021-10-29 00:16:05","","5","885","<p>I have a publisher when the sink, scans for a list of wifi.  I only want to scan for about 10 seconds and stop.</p>
<p>Is there a way to do this within the publisher chain of calls?</p>
","1454604","","","","","2021-11-04 21:38:09","How do you run a Swift Combine Publisher for a certain amount of time?","<swift><combine><publisher>","2","6","","","","CC BY-SA 4.0"
"69774495","1","69774881","","2021-10-29 20:32:40","","0","449","<p>I am trying to chain <code>n</code> requests with <code>Combine</code>.</p>
<p>Let's assume I have 50 users and for each of them I need to do a single request to get a users data. I know that with <code>flatMap</code> you can pass one <code>Publisher</code> result into the next. But does that work with loops as well?</p>
<p>That's my function to fetch a user:</p>
<pre><code>func fetchUser(for id: Int) -&gt; AnyPublisher&lt;User, Error&gt; {
    let url = &quot;https://user.com/api/user/\(id)&quot;
    return URLSession.shared.dataTaskPublisher(for: url)
        .mapError { $0 as Error }
        .map { $0.data }
        .decode(type: User.self, decoder: JSONDecoder())
        .eraseToAnyPublisher()
}
</code></pre>
<p>So basically I need another function, which loops this over this <code>fetchUser</code> and returns all users in one result array. The requests should not all run at the same time, but rather start one after the previous one has finished.</p>
","2128765","","","","","2021-10-29 21:19:45","Chaining n requests in Combine","<swift><combine><urlsession>","1","0","","2021-10-30 19:04:24","","CC BY-SA 4.0"
"69778621","1","69779157","","2021-10-30 10:11:01","","1","239","<p>I have a parent view and a child view, each with their own viewModels. The parent view injects the child view's viewModel.</p>
<p><strong>The parent view does not correctly react to the changes on the child's computed property <code>isFormInvalid</code> (the child view does).</strong></p>
<p>@Published cannot be added to a computed property, and other questions/answers I've seen around that area have not focused on having separate viewModels as this question does. I want separate viewModels to increase testability, since the child view could become quite a complex form.</p>
<p>Here is a file to minimally reproduce the issue:</p>
<pre><code>import SwiftUI

extension ParentView {
    final class ViewModel: ObservableObject {
        @ObservedObject var childViewViewModel: ChildView.ViewModel

        init(childViewViewModel: ChildView.ViewModel = ChildView.ViewModel()) {
            self.childViewViewModel = childViewViewModel
        }
    }
}

struct ParentView: View {
    @ObservedObject private var viewModel: ViewModel

    init(viewModel: ViewModel = ViewModel()) {
        self.viewModel = viewModel
    }

    var body: some View {
        ChildView(viewModel: viewModel.childViewViewModel)
        .navigationBarTitle(&quot;Form&quot;, displayMode: .inline)
        .toolbar {
            ToolbarItem(placement: .confirmationAction) {
                addButton
            }
        }
    }

    private var addButton: some View {
        Button {
            print(&quot;======&quot;)
            print(viewModel.childViewViewModel.$name)
        } label: {
            Text(&quot;ParentIsValid?&quot;)
        }
        .disabled(viewModel.childViewViewModel.isFormInvalid) // FIXME: doesn't work, but the actual fields work in terms of two way updating
    }
}

struct ParentView_Previews: PreviewProvider {
    static var previews: some View {
        let childVm = ChildView.ViewModel()
        let vm = ParentView.ViewModel(childViewViewModel: childVm)

        NavigationView {
            ParentView(viewModel: vm)
        }
    }
}

// MARK: child view

extension ChildView {
    final class ViewModel: ObservableObject {

        // MARK: - public properties

        @Published var name = &quot;&quot;
        
        var isFormInvalid: Bool {
            print(&quot;isFormInvalid&quot;)
            return name.isEmpty
        }
    }
}

struct ChildView: View {
    @ObservedObject private var viewModel: ViewModel
    
    init(viewModel: ViewModel = ViewModel()) {
        self.viewModel = viewModel
    }
    
    var body: some View {
        Form {
            Section(header: Text(&quot;Name&quot;)) {
                nameTextField
            }
            Button {} label: {
                Text(&quot;ChildIsValid?: \(String(!viewModel.isFormInvalid))&quot;)
            }
            .disabled(viewModel.isFormInvalid)
        }
    }
    
    private var nameTextField: some View {
        TextField(&quot;Add name&quot;, text: $viewModel.name)
            .autocapitalization(.words)
    }
}

struct ChildView_Previews: PreviewProvider {
    static var previews: some View {
        let vm = ChildView.ViewModel()
        ChildView(viewModel: vm).preferredColorScheme(.light)
    }
}
</code></pre>
<p>Thank you!</p>
","9946657","","9946657","","2021-10-31 06:10:09","2021-10-31 06:10:09","Computed Property from Child's ViewModel does not update @ObservedObject Parent's ViewModel","<ios><swift><mvvm><swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"69780705","1","69782757","","2021-10-30 17:47:44","","0","392","<p>I'm building a network API.
I'm new to Combine and I'm having some troubles with it, I'm trying to chain publish network requests, in this case I'm forming an URLRequest publisher and dispatching it on another publisher, the problem is that I cant make the flatMap work on the second publisher.</p>
<p>First I assemble the <code>URLRequest</code> with the Auth token:</p>
<pre><code>func asURLRequest(baseURL: String) -&gt; AnyPublisher&lt;URLRequest, NetworkRequestError&gt; {
        
        return Deferred {
            Future&lt;URLRequest, NetworkRequestError&gt; { promise in
                if var urlComponents = URLComponents(string: baseURL) {
                    urlComponents.path = &quot;\(urlComponents.path)\(path)&quot;
                    urlComponents.queryItems = queryItemsFrom(params: queryParams)
                    if let finalURL = urlComponents.url {
                        if let user = Auth.auth().currentUser {
                            print(&quot;##### final url -&gt; \(finalURL)&quot;)
                            // Retrieves the Firebase authentication token, possibly refreshing it if it has expired.
                            user.getIDToken(completion: { (token, error) in
                                if let fbToken = token {
                                    var request = URLRequest(url: finalURL)
                                    request.httpMethod = method.rawValue
                                    request.httpBody = requestBodyFrom(params: body)
                                    let defaultHeaders: HTTPHeaders = [
                                        HTTPHeaderField.contentType.rawValue: contentType.rawValue,
                                        HTTPHeaderField.acceptType.rawValue: contentType.rawValue,
                                        HTTPHeaderField.authentication.rawValue: fbToken
                                    ]
                                    request.allHTTPHeaderFields = defaultHeaders.merging(headers ?? [:], uniquingKeysWith: { (first, _) in first })
                                    print(&quot;##### API TOKEN() SUCCESS: \(defaultHeaders)&quot;)
                                    promise(.success(request))
                                }
                                
                                if let fbError = error {
                                    print(&quot;##### API TOKEN() ERROR: \(fbError)&quot;)
                                    promise(.failure(NetworkRequestError.decodingError))
                                }
                            })
                        }
                    } else {
                        promise(.failure(NetworkRequestError.decodingError))
                    }
                } else {
                    promise(.failure(NetworkRequestError.decodingError))
                }
            }
        }.eraseToAnyPublisher()
    }
</code></pre>
<p>Then I'm trying to dispatch a request (publisher) and return another publisher, the problem is that the .flatMap is not getting called:</p>
<pre><code>struct APIClient {
    var baseURL: String!
    var networkDispatcher: NetworkDispatcher!
    init(baseURL: String,
         networkDispatcher: NetworkDispatcher = NetworkDispatcher()) {
        self.baseURL = baseURL
        self.networkDispatcher = networkDispatcher
    }
    /// Dispatches a Request and returns a publisher
    /// - Parameter request: Request to Dispatch
    /// - Returns: A publisher containing decoded data or an error
    func dispatch&lt;R: Request&gt;(_ request: R) -&gt; AnyPublisher&lt;R.ReturnType, NetworkRequestError&gt; {
        print(&quot;##### --------&gt; \(request)&quot;)
        //typealias RequestPublisher = AnyPublisher&lt;R.ReturnType, NetworkRequestError&gt;
        return request.asURLRequest(baseURL: baseURL)
            .flatMap { request in
                //NOT GETTING CALLED
                self.networkDispatcher.dispatch(request: request)
            }.eraseToAnyPublisher()

}
</code></pre>
<p>The final publisher that is not being called is the following:</p>
<pre><code>struct NetworkDispatcher {
    let urlSession: URLSession!
    public init(urlSession: URLSession = .shared) {
        self.urlSession = urlSession
    }
    /// Dispatches an URLRequest and returns a publisher
    /// - Parameter request: URLRequest
    /// - Returns: A publisher with the provided decoded data or an error
    func dispatch&lt;ReturnType: Codable&gt;(request: URLRequest) -&gt; AnyPublisher&lt;ReturnType, NetworkRequestError&gt; {
        return urlSession
            .dataTaskPublisher(for: request)
        // Map on Request response
            .tryMap({ data, response in
                // If the response is invalid, throw an error
                if let response = response as? HTTPURLResponse,
                   !(200...299).contains(response.statusCode) {
                    throw httpError(response.statusCode)
                }
                // Return Response data
                return data
            })
        // Decode data using our ReturnType
            .decode(type: ReturnType.self, decoder: JSONDecoder())
        // Handle any decoding errors
            .mapError { error in
                handleError(error)
            }
        // And finally, expose our publisher
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>Running the code:</p>
<pre><code> struct ReadUser: Request {
        typealias ReturnType = UserData
        var path: String
        var method: HTTPMethod = .get
        init(_ id: String) {
            path = &quot;users/\(id)&quot;
        }
    }
    
    let apiClient = APIClient(baseURL: BASE_URL)
    var cancellables = [AnyCancellable]()
    
    apiClient.dispatch(ReadUser(Auth.auth().currentUser?.uid ?? &quot;&quot;))
        .receive(on: DispatchQueue.main)
        .sink(
            receiveCompletion: { result in
                switch result {
                case .failure(let error):
                    // Handle API response errors here (WKNetworkRequestError)
                    print(&quot;##### Error loading data: \(error)&quot;)
                default: break
                }
            },
            receiveValue: { value in
            })
        .store(in: &amp;cancellables)
</code></pre>
","1065307","","1065307","","2021-10-30 18:27:37","2021-10-31 12:10:14","FlatMap with Generic ReturnType using Combine","<ios><swift><xcode><combine><urlsession>","2","5","","","","CC BY-SA 4.0"
"69807263","1","69816371","","2021-11-02 08:23:27","","1","93","<p>I have a bottom view with a textField. This bottom view will show up on the action of a button. But the bottom view does not move up on taps of a text field. I have added the code for this.</p>
<p>This is ContentView where the button is displayed.</p>
<pre><code>struct ContentView: View {
    @State var cardShown = false
    @State var cardDismissal = false

    var body: some View {
        NavigationView {
            ZStack {
                Button(action: {
                    cardShown.toggle()
                    cardDismissal.toggle()
                }, label: {
                    Text(&quot;Show Card&quot;)
                        .bold()
                        .foregroundColor(Color.white)
                        .background(Color.blue)
                        .frame(width: 200, height: 50)
                })
                BottomCard(cardShown: $cardShown, cardDismissal: $cardDismissal, height: 300, content: {
                    CardContent()
                        .padding()
                })
            }
        }
    }
}
</code></pre>
<p>This is the bottom card content view. This needs to be up on tap on the text field. There is a TextField. I have added keyboardAdaptive modifier to recieve the keyboard height but not working.</p>
<pre><code>struct CardContent: View {
    
    @State private var text = &quot;&quot;
    
    var body: some View {
        
        VStack {
            
            Text(&quot;Photo Collage&quot;)
                .bold()
                .font(.system(size: 30))
                .padding()
            
            Text(&quot;You can create awesome photo grids and share them with all of your friends&quot;)
                .font(.system(size: 18))
                .multilineTextAlignment(.center)
            
            TextField(&quot;Enter something&quot;, text: $text)
                .textFieldStyle(RoundedBorderTextFieldStyle())
        }
        .padding()
        .keyboardAdaptive() // Apply the modifier
    }
}


struct BottomCard&lt;Content: View&gt;: View {
    let content: Content
    @Binding var cardShown: Bool
    @Binding var cardDismissal: Bool
    let height: CGFloat
    init(cardShown: Binding&lt;Bool&gt;, cardDismissal: Binding&lt;Bool&gt;, height: CGFloat, @ViewBuilder content: () -&gt; Content) {
        _cardShown = cardShown
        _cardDismissal = cardDismissal
        self.height = height
        self.content = content()
    }
    
    var body: some View {
        ZStack {
            // Dimmed
            GeometryReader { _ in
                EmptyView()
            }
            .background(Color.gray.opacity(0.5))
            .opacity(cardShown ? 1: 0)
            .animation(Animation.easeIn, value: 0.9)
            
            .onTapGesture {
                // Dismiss
                dismiss()
            }
            
            // Card
            
            VStack {
                Spacer()
                
                VStack {
                  content
                    
                    Button(action: {
                        // Dismiss
                        dismiss()
                    }, label: {
                        Text(&quot;Dismiss&quot;)
                            .foregroundColor(Color.white)
                            .frame(width: UIScreen.main.bounds.width/2, height: 50)
                            .background(Color.pink)
                            .cornerRadius(8)

                    })
                     .padding()
                }
                .background(Color(UIColor.secondarySystemBackground))
                .frame(height: height)
                .offset(y: (cardShown &amp;&amp; cardShown) ? 0 : 500)
                .animation(Animation.default.delay(0.2), value: 0.2)
            }
        }
        .edgesIgnoringSafeArea(.all)
    }
    
    func dismiss() {
        cardDismissal.toggle()
        DispatchQueue.main.asyncAfter(deadline: .now()+0.25) {
            cardShown.toggle()
        }

    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
extension Publishers {
    // 1.
    static var keyboardHeight: AnyPublisher&lt;CGFloat, Never&gt; {
        // 2.
        let willShow = NotificationCenter.default.publisher(for: UIApplication.keyboardWillShowNotification)
            .map { $0.keyboardHeight }
        
        let willHide = NotificationCenter.default.publisher(for: UIApplication.keyboardWillHideNotification)
            .map { _ in CGFloat(0) }
        
        // 3.
        return MergeMany(willShow, willHide)
            .eraseToAnyPublisher()
    }
}
extension Notification {
    var keyboardHeight: CGFloat {
        return (userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect)?.height ?? 0
    }
}

struct KeyboardAdaptive: ViewModifier {
    @State private var bottomPadding: CGFloat = 0
    
    func body(content: Content) -&gt; some View {
        // 1.
        GeometryReader { geometry in
            content
                .padding(.bottom, self.bottomPadding)
                // 2.
                .onReceive(Publishers.keyboardHeight) { keyboardHeight in
                    // 3.
                    let keyboardTop = geometry.frame(in: .global).height - keyboardHeight
                    // 4.
                    let focusedTextInputBottom = UIResponder.currentFirstResponder?.globalFrame?.maxY ?? 0
                    // 5.
                    self.bottomPadding = max(0, focusedTextInputBottom - keyboardTop - geometry.safeAreaInsets.bottom)
            }
            // 6.
                .animation(.easeOut, value: 0.16)
        }
    }
}
extension View {
    func keyboardAdaptive() -&gt; some View {
        ModifiedContent(content: self, modifier: KeyboardAdaptive())
    }
}
extension UIResponder {
    static var currentFirstResponder: UIResponder? {
        _currentFirstResponder = nil
        UIApplication.shared.sendAction(#selector(UIResponder.findFirstResponder(_:)), to: nil, from: nil, for: nil)
        return _currentFirstResponder
    }

    private static weak var _currentFirstResponder: UIResponder?

    @objc private func findFirstResponder(_ sender: Any) {
        UIResponder._currentFirstResponder = self
    }

    var globalFrame: CGRect? {
        guard let view = self as? UIView else { return nil }
        return view.superview?.convert(view.frame, to: nil)
    }
}
</code></pre>
","1960279","","","","","2021-11-03 11:56:45","unable to move bottom view up on tap of TextField in swiftui?","<swiftui><keyboard><combine><publisher><viewbuilder>","1","0","","","","CC BY-SA 4.0"
"69847772","1","69849312","","2021-11-05 01:38:59","","0","235","<p>I wrote a Combine Publisher wrapper class for some old code that used delegation.</p>
<p>TLDR; Can someone improve how I manage the lifetime of my custom publisher. Preferrable by making it behave like normal publishers, where you can just sink to it and not have to worry about retaining that instance.</p>
<p><strong>Details</strong>
I encountered a problem where I have to keep a reference to my Publisher wrapper for it to work. Every example of a custom publisher doesn't have this requirement, though their publishers were structs and were fairly different from mine.</p>
<p>Here's a simplified version of the problem that I'm having. Note the commented out section in doSomething()</p>
<pre><code>import Foundation
import Combine

// Old code that uses delegate
protocol ThingDelegate: AnyObject {
    func delegateCall(number: Int)
}

class Thing {
    weak var delegate: ThingDelegate?
    var name: String = &quot;Stuff&quot;

    init() {
        Swift.print(&quot;thing init&quot;)
    }

    deinit {
        Swift.print(&quot;☠️☠️☠️☠️☠️☠️ thing deinit&quot;)
    }

    func start() {
        Swift.print(&quot;Thing.start()&quot;)

        DispatchQueue.main.async {
            self.delegate?.delegateCall(number: 99)
        }
    }
}

// Combine Publisher Wrapper
class PublisherWrapper: Publisher {
    typealias Output = Int
    typealias Failure = Error

    private let subject = PassthroughSubject&lt;Int, Failure&gt;()

    var thing: Thing

    init(thing: Thing) {
        Swift.print(&quot;wrapper init&quot;)
        self.thing = thing
        self.thing.delegate = self
    }

    deinit {
        Swift.print(&quot;☠️☠️☠️☠️☠️☠️ wrapper deinit&quot;)
    }

    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Failure == S.Failure, Int == S.Input {
        self.subject.subscribe(subscriber)
        self.thing.start()
    }
}

extension PublisherWrapper: ThingDelegate {
    func delegateCall(number: Int) {
        Swift.print(&quot;publisher delegate call: \(number)&quot;)
        self.subject.send(number)
        self.subject.send(completion: .finished)
    }
}

class Test {
    var cancellables = Set&lt;AnyCancellable&gt;()

    var wrapper: PublisherWrapper?

    func doSomething() {
        Swift.print(&quot;doSomething()&quot;)
        let thing = Thing()
        let wrapper = PublisherWrapper(thing: thing)
        self.wrapper = wrapper

        // Take a look over here
        //
        // if you comment out the line above where I set self.wrapper = wrapper
        // it prints out the following
        //
        //start
        //doSomething()
        //thing init
        //wrapper init
        //Thing.start()
        //☠️☠️☠️☠️☠️☠️ wrapper deinit
        //☠️☠️☠️☠️☠️☠️ thing deinit
        //


        // But if you uncomment the line and retain it and you'll get the following
        //start
        //doSomething()
        //thing init
        //wrapper init
        //Thing.start()
        //publisher delegate call: 99
        //value: 99
        //finished
        //release wrapper: nil
        //☠️☠️☠️☠️☠️☠️ wrapper deinit
        //☠️☠️☠️☠️☠️☠️ thing deinit

        // we get the value and everything works as it should


        wrapper.sink { [weak self] completion in
            print(completion)
            self?.wrapper = nil
            print(&quot;release wrapper: \(self?.wrapper)&quot;)
        } receiveValue: {
            print(&quot;value: \($0)&quot;)
        }.store(in: &amp;self.cancellables)
    }
}

print(&quot;start&quot;)
let t = Test()
t.doSomething()

</code></pre>
<p>Is there an approach that avoids retaining the publisher like this? I ask because this can get pretty ugly when using flatMap.</p>
","465446","","465446","","2021-11-05 20:18:13","2021-11-06 04:08:04","Custom Combine Publisher wrapper class does not work unless retained","<swift><combine><publisher>","1","4","","","","CC BY-SA 4.0"
"69851185","1","69851238","","2021-11-05 09:39:36","","-1","49","<p>If I have an <code>ObservableObject</code> like...</p>
<pre><code>class Foo: ObservableObject {
  @Published var value: Int = 1

  func update() {
    value = 1
  }
}
</code></pre>
<p>And then a view like...</p>
<pre><code>struct BarView: View {
  @ObservedObject var foo: Foo

  var body: some View {
    Text(&quot;\(foo.value)&quot;)
      .onAppear { foo.update() }
  }
}
</code></pre>
<p>Does this cause the view to constantly refresh? Or does SwiftUI do something akin to <code>removeDuplicates</code> in the subscribers that it creates?</p>
<p>I imagine the latter but I've been struggling to find any documentation on this.</p>
","421018","","","","","2021-11-05 09:47:41","Does SwiftUI removeDuplicates from a subscriber to an @Published property?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"69859348","1","69859604","","2021-11-05 21:19:16","","2","338","<p>I currently have code like...</p>
<pre><code>var isFetching = false

func fetch() {
  guard !isFetching else { return }
  fetching = true

  apiPublisher
    .receive(on: .main)
    .handleEvents(receiveCompletion: { [weak self] _ in
      self?.fetching = false
    })
    .assign(to: \.foo, on: self)
    .store(in: &amp;cancellables)
}
</code></pre>
<p>But I'm not happy with the way I'm stopping multiple requests happening like this. It works but feels clunky.</p>
<p>I feel like there should be a more &quot;Combine-y&quot; way of doing this.</p>
<p>Is there a more elegant/Combine-y way of doing this?</p>
","421018","","","","","2021-11-05 21:49:19","Is there a Combine-y way to stop multiple requests being triggered?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"69872377","1","69878975","","2021-11-07 12:22:04","","0","238","<p>I want to use <code>@resultbuilder</code> and <code>Combine</code> to create my own reactive and declarative UICollectionView List in UIKit, similiar to what we get with <code>List {}</code> in SwiftUI.</p>
<p>For that, i am using a resultbuilder to create a Snapshot like this:</p>
<pre class=""lang-swift prettyprint-override""><code>@resultBuilder
struct SnapshotBuilder {
    
    static func buildBlock(_ components: ListItemGroup...) -&gt; [ListItem] {
        return components.flatMap { $0.items }
    }
    
    // Support `for-in` loop
    static func buildArray(_ components: [ListItemGroup]) -&gt; [ListItem] {
        return components.flatMap { $0.items }
    }
    
    static func buildFinalResult(_ component: [ListItem]) -&gt; NSDiffableDataSourceSectionSnapshot&lt;ListItem&gt; {
        var sectionSnapshot = NSDiffableDataSourceSectionSnapshot&lt;ListItem&gt;()
        sectionSnapshot.append(component)
        return sectionSnapshot
    }
}
</code></pre>
<p>I also need to use the following extensions to pass <code>ListItemGroup</code> to SnapshotBuilder and get <code>[ListItem]</code></p>
<pre class=""lang-swift prettyprint-override""><code>struct ListItem: Hashable {
    
    let title: String
    let image: UIImage?
    var children: [ListItem]
    
    init(_ title: String, children: [ListItem] = []) {
        self.title = title
        self.image = UIImage(systemName: title)
        self.children = children
    }
}

protocol ListItemGroup {
    var items: [ListItem] { get }
}

extension Array: ListItemGroup where Element == ListItem {
    var items: [ListItem] { self }
}

extension ListItem: ListItemGroup {
    var items: [ListItem] { [self] }
}
</code></pre>
<p>My <code>List</code> Class looks like this:</p>
<pre class=""lang-swift prettyprint-override""><code>final class List: UICollectionView {
    
    enum Section {
        case main
    }
    
    var data: UICollectionViewDiffableDataSource&lt;Section, ListItem&gt;!
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(_ items: Published&lt;[String]&gt;.Publisher, style: UICollectionLayoutListConfiguration.Appearance = .insetGrouped, @SnapshotBuilder snapshot: @escaping () -&gt; NSDiffableDataSourceSectionSnapshot&lt;ListItem&gt;) {
        super.init(frame: .zero, collectionViewLayout: List.createLayout(style))
    
        configureDataSource()
        data.apply(snapshot(), to: .main)
        
        items
            .sink { newValue in
                let newSnapshot = snapshot()
                self.data.apply(newSnapshot, to: .main, animatingDifferences: true)
            }
            .store(in: &amp;cancellables)
    }
    
    required init(coder: NSCoder) {
        super.init(coder: coder)!
    }
    
    private static func createLayout(_ appearance: UICollectionLayoutListConfiguration.Appearance) -&gt; UICollectionViewLayout {
        let layoutConfig = UICollectionLayoutListConfiguration(appearance: appearance)
        return UICollectionViewCompositionalLayout.list(using: layoutConfig)
    }
    
    private func configureDataSource() {
        let cellRegistration = UICollectionView.CellRegistration&lt;UICollectionViewListCell, ListItem&gt; {
            (cell, indexPath, item) in
            
            var content = cell.defaultContentConfiguration()
            content.image = item.image
            content.text = item.title
            cell.contentConfiguration = content
        }
        
        data = UICollectionViewDiffableDataSource&lt;Section, ListItem&gt;(collectionView: self) {
            (collectionView: UICollectionView, indexPath: IndexPath, identifier: ListItem) -&gt; UICollectionViewCell? in
            
            let cell = collectionView.dequeueConfiguredReusableCell(using: cellRegistration, for: indexPath, item: identifier)
            cell.accessories = [.disclosureIndicator()]
            return cell
        }
    }
}
</code></pre>
<p>And i am using it in my ViewControllers like this:</p>
<pre class=""lang-swift prettyprint-override""><code>class DeclarativeViewController: UIViewController {
    
    @Published var testItems: [String] = []
    
    var collectionView: List!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        navigationController?.navigationBar.sizeToFit()
        title = &quot;Settings&quot;

        navigationItem.rightBarButtonItem = UIBarButtonItem(image: UIImage(systemName: &quot;plus&quot;), style: .plain, target: self, action: #selector(addItem))
        
        view.backgroundColor = .systemBackground
        
        collectionView = List($testItems) {
            for item in self.testItems {
                ListItem(item)
            }
        }
        
        collectionView.frame = view.bounds
        collectionView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        view.addSubview(collectionView)
    }
    
    @objc func addItem() {
        testItems.append(&quot;Item \(testItems.count)&quot;)
    }
}
</code></pre>
<p>As you can see, i initialize my <code>List</code> with the <code>@Published var testItems</code> variable. In my <code>init()</code> func, i setup a subscriber and store them in <code>cancellables</code>, so i can react on changes.</p>
<p>If i add an item to <code>testItems</code> array, the <code>sink</code> callback is exectued to create a new snapshot and apply them to <code>data</code>. It works, but i need to tap the navigation button twice, to see an item on the list. Two questions:</p>
<ol>
<li>Why this is happen and how can i solve this? (so i only need to tap the button once to see changes in my list)</li>
<li>and how can i improve my code? (currently I always create a new snapshot instead of extending the already created one)</li>
</ol>
","10183816","","","","","2021-11-08 05:37:54","How can i use Combine with @resultbuilder to build a dynamic collectionview list?","<swift><uicollectionview><uikit><combine><swift5.4>","1","0","","","","CC BY-SA 4.0"
"69895122","1","69895565","","2021-11-09 08:45:26","","1","518","<p>If I have a Set of AnyCancellable:</p>
<pre><code>var observations: Set&lt;AnyCancellable&gt; = []
</code></pre>
<p>What's the difference between removing all the objects from the set:</p>
<pre><code>observations.removeAll()
</code></pre>
<p>or cancel each subscription:</p>
<pre><code>observations.forEach { $0.cancel() }
</code></pre>
<p>do they have the same effect? or in case that there is a strong reference in any of the subscription if <code>.removeAll()</code> is called the strong references will be not eliminated?
In case that they have the same effect I guess it will be a good practice to use the first approach as you don't need to traverse all the Set.</p>
","4102381","","","","","2021-11-09 09:21:15","Combine: Cancel a Set<AnyCancellable> or remove all its stored objects to stop the subscriptions","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"69910951","1","69921995","","2021-11-10 09:43:25","","1","62","<p>It's not clear to me how you would combine the output of the following computed property, to the UI.</p>
<pre><code>var isComplete: Bool {
    Set([.givenName, .familyName]).isSubset(of: elements)
}
</code></pre>
<p>I essentially want the user interface to update if the above changes. How would I do this using Combine?</p>
<p>Reactive programming demands that I now think backwards and I'm having trouble thinking about model &lt;&lt;&lt; UI rather than model &gt;&gt;&gt; UI.</p>
<p>Here is the code in context.</p>
<pre><code>struct EditPersonView: View {
    
    let model: ViewModel
            
    private var captionView: some View {
        HStack {
        /*
          stuff
        */
            if submitted &amp;&amp; model.name.isComplete {
                Spacer()
                Text(&quot;select&quot;.localizedCapitalized) + Text(&quot; &quot;) + Text(&quot;save&quot;) + Text(&quot; &quot;) + Text(&quot;👆&quot;)
            }
        }
    }

    var body: some View {
    /*
    stuff - including captionView
    */
    }
}

extension EditPersonView {
    
    final class ViewModel {
        
        let name: PersonName
        
        init(person: Person) {
            self.name = PersonName(for: person)
        }
    }
}

extension EditPersonView.ViewModel {
    
    final class PersonName {
        
        let person: Person
        
        private let formatter = PersonNameComponentsFormatter()
        
        init(for person: Person) {
            self.person = person
        }
        
        var text: String {
            get { person.name ?? &quot;&quot; }
            set { person.name = newValue }
        }
        
        private var components: PersonNameComponents? {
            formatter.personNameComponents(from: text)
        }
        
        var givenName: String? {
            components?.givenName
        }
        
        var familyName: String? {
            components?.familyName
        }
        
        private func isValid(component: String?) -&gt; Bool {
            if let name = component, name.count &gt; 1 {
                return true
            }
            return false
        }
        
        var elements: Set&lt;Elements&gt; {
            var collection = Set&lt;Elements&gt;()
            if isValid(component: givenName) { collection.insert(.givenName) }
            if isValid(component: familyName) { collection.insert(.familyName) }
            return collection
        }
        
        var isComplete: Bool {
            Set([.givenName, .familyName]).isSubset(of: elements)
        }
    }
}

extension EditPersonView.ViewModel.PersonName {
    
    enum Elements {
        case givenName, familyName
    }
}
</code></pre>
","9400730","","","","","2021-11-11 00:51:28","How to re-render UI in response to computed property buried in a nested class?","<swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"69921644","1","69922582","","2021-11-10 23:59:34","","0","422","<p>According to the swift combine documentation, the proper way to connect a subscriber to a publisher is with the publishers <code>subscribe&lt;S&gt;(S)</code> protocol extension method.  Then the publisher creates a subscription and passes that subscription on to the subscriber.  All's well and good so far.</p>
<p>What I can't seem to figure out is how to gain access to that subscription and retain it in the calling code.  How is <code>sink()</code> implemented such that it can return that subscription?  Unless I'm mistaken, the subscription is responsible for retaining its subscriber, which means I can't store a reference to the subscription in the subscriber.  And since Subscription isn't class bound, it can't be weak.</p>
","1022456","","","","","2021-11-11 02:39:34","Store subscription from custom Combine subscriber?","<swift><subscription><combine>","2","1","","","","CC BY-SA 4.0"
"69931486","1","69935963","","2021-11-11 16:10:21","","0","1370","<p><strong>Current (working) situation:</strong></p>
<p>In our app we have several publishers of type <code>PassthroughSubject&lt;Void, Never&gt;</code>.
The subscriber of this publisher send out the same type of publisher within the <code>.sink()</code> closure. In a simple playground it would look like that:</p>
<pre><code>//: A UIKit based Playground for presenting user interface

import UIKit
import PlaygroundSupport
import Combine

class MyViewController : UIViewController {

    // MARK: - Observables
    let initialPublisher: PassthroughSubject = PassthroughSubject&lt;Void, Never&gt;()
    let rePublisher = PassthroughSubject&lt;Void, Never&gt;()

    // MARK: - Observer
    private var cancellableSubscriber = Set&lt;AnyCancellable&gt;()

    override func loadView() {
        // MARK: - View Setup
        let view = UIView()
        let button = UIButton(type: .system)
        button.frame = CGRect(x: 100, y: 100, width: 200, height: 20)
        button.setTitle(&quot;Button&quot;, for: .normal)
        button.addTarget(self, action: #selector(buttonAction), for: .touchUpInside)
        view.addSubview(button)
        self.view = view

        // MARK: - Subscriptions

        // Event of initial publisher is received and re-published using another subject.
        initialPublisher
            .sink { [weak self] in
                self?.rePublisher.send()
            }
            .store(in: &amp;cancellableSubscriber)

        // The re-published event is received.
        rePublisher
            .sink {
                print(&quot;Received!&quot;)
            }
            .store(in: &amp;cancellableSubscriber)
    }

    @objc private func buttonAction() {
        self.initialPublisher.send()
    }
}
// Present the view controller in the Live View window
PlaygroundPage.current.liveView = MyViewController()
</code></pre>
<p><strong>Prefered (non-working) solution:</strong></p>
<p>Instead of subscribing and re publishing using the <code>.sink()</code> closure and another <code>PassthroughSubject</code> I wanted to re-publish the initial publisher using <code>.receive(subscriber: AnySubscriber)</code> However somehow it doesn't seem to work or maybe I'm understanding the <code>.receive</code> method wrong. I tried the following without luck.</p>
<p><strong>Question:</strong></p>
<p>How can I make the below code work, or is it even the correct way? If not, are there more elegant ways to re-publish than in our code above?</p>
<p><strong>Clarification:</strong></p>
<p>If something is unclear or of you need further examples please leave a comment below and I will try to update my question.</p>
<pre><code>class MyViewController : UIViewController {

    // MARK: - Observables
    let initialPublisher: PassthroughSubject = PassthroughSubject&lt;Void, Never&gt;()
    let rePublisher = PassthroughSubject&lt;Void, Never&gt;()
    var subscriber = AnySubscriber&lt;Void, Never&gt;()

    // MARK: - Observer
    private var cancellableSubscriber = Set&lt;AnyCancellable&gt;()

    override func loadView() {
        // MARK: - View Setup
        let view = UIView()
        let button = UIButton(type: .system)
        button.frame = CGRect(x: 100, y: 100, width: 200, height: 20)
        button.setTitle(&quot;Button&quot;, for: .normal)
        button.addTarget(self, action: #selector(buttonAction), for: .touchUpInside)
        view.addSubview(button)
        self.view = view

        // MARK: - Subscriptions

        //Republishing
        subscriber = AnySubscriber(initialPublisher)

        // Event of initial publisher is received and re-published.
        rePublisher.receive(subscriber: subscriber)

        // // The re-published event is received.
        rePublisher
            .sink {
                print(&quot;Received!&quot;) // &lt;-- does not work!
            }
            .store(in: &amp;cancellableSubscriber)
    }

    @objc private func buttonAction() {
        self.initialPublisher.send()
    }
}
</code></pre>
","12764795","","","","","2021-11-11 22:58:15","How to re-publish a PassthroughSubject using another publisher in Combine","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"69943029","1","69949223","","2021-11-12 12:33:40","","1","105","<p>I've been working with RxSwift for a while now, just switched to Combine and I am trying to wrap my head around this specific <code>.filter</code> behaviour. Here's a short playground example:</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine

let publisher = [1, 2, 3, 4, 5]
    .publisher
    .share()

let filter1 = publisher
    .filter { $0 == 1 }
    .print(&quot;filter1&quot;)

let filter2 = publisher
    .filter { $0 == 2 }
    .print(&quot;filter2&quot;)

Publishers
    .Merge(filter1, filter2)
    .sink {
        print(&quot;Result is: \($0)&quot;)
    }
</code></pre>
<p>the output is</p>
<pre><code>filter1: receive subscription: (Multicast)
filter1: request unlimited
filter1: receive value: (1)
Result is: 1
filter1: receive finished
filter2: receive subscription: (Multicast)
filter2: request unlimited
filter2: receive finished
</code></pre>
<p>What surprises me is that <code>Result is: 2</code> is never called because the stream finishes. I could remove <code>.share()</code> operator which would result in receiving both values as I'd expect</p>
<pre><code>filter1: receive subscription: ([1])
filter1: request unlimited
filter1: receive value: (1)
Result is: 1
filter1: receive finished
filter2: receive subscription: ([2])
filter2: request unlimited
filter2: receive value: (2)
Result is: 2
filter2: receive finished
</code></pre>
<p>But what if my publisher is an API call and I don't want to create a duplicate network request? Which is exactly the case I am trying to handle now and it's also why I need to use <code>.share()</code> operator.</p>
<p>Any better explanation why is this happening and how to handle a case where you want to filter a stream, do a separate logic in each stream and then merge the results back together?</p>
","1092167","","","","","2021-11-12 21:24:57","Combine - merging multiple shared filters","<ios><asynchronous><rx-swift><combine>","1","0","","","","CC BY-SA 4.0"
"69978018","1","69987492","","2021-11-15 16:51:15","","2","1069","<p>Let's say that we have a following code written in Swift that uses Combine:</p>
<pre><code>import UIKit
import Combine

class Test {
  @Published var array: [Int] = [] {
    willSet {
      print(&quot;willSet \(newValue.count)&quot;)
    }
    didSet {
      print(&quot;didSet \(array.count)&quot;)
    }
  }
}

var test = Test()
var subscriber = test.$array.sink { values in
  print(&quot;arrayCount: \(test.array.count) valuesCount: \(values.count)&quot;)
}

print(&quot;1 arrayCount \(test.array.count)&quot;)
test.array = [1, 2, 3]
print(&quot;2 arrayCount \(test.array.count)&quot;)
test.array = [1]
print(&quot;3 arrayCount \(test.array.count)&quot;)
</code></pre>
<p>This code prints following result on the console (it can be quickly tested in playground):</p>
<pre><code>arrayCount: 0 valuesCount: 0
1 arrayCount 0
willSet 3
arrayCount: 0 valuesCount: 3
didSet 3
2 arrayCount 3
willSet 1
arrayCount: 3 valuesCount: 1
didSet 1
3 arrayCount 1
</code></pre>
<p>As we can see the code given to sink method is executed after willSet and before didSet of given property. Now my question is: is there any way to create this publisher or subscribe to it in such way that the code given to sink is executed after didSet and not before it (so that arrayCount and valuesCount would be the same when print from sink is executed in above example)?</p>
","2102779","","","","","2021-12-21 14:10:35","Observe change on a @Published var in Swift Combine after didSet?","<ios><swift><combine>","2","1","","","","CC BY-SA 4.0"
"69982541","1","70090260","","2021-11-16 00:39:32","","0","1534","<p>I am getting an array from a Firestore table. Obviously is in real time so any newly added document or modifications to an existing document are reflected in the view. This works for simple properties like strings and numbers but I need to display and refresh other data too.</p>
<p>I'm storing the coordinates also and if the coordinates change I need to call <code>geocoder.reverseGeocodeLocation()</code> in order to get the Placemark out of this location and display the address as a string. For this I have created a service called <code>PlacemarkService (code provided below).</code></p>
<p>The issue is this. Whenever a model is modified the data comes through <code>PackagesViewModel</code> which has a <code>@Published var results = [Package]()</code> This is modified on the fly by Firestore (codable). Then, any changes caused to array this will cause the <code>List</code> inside <code>PackagesView</code> to be refreshed and this will cause a new instance of <code>PackageView(packageService: PackageService(package: package))</code> to be created and since the <code>PackageService</code> is passed as a param here a new instance of <code>PackageService</code> will be created. Finally this will trigger the init() inside this service to be called.</p>
<p><code>@Published var results = [Package]() -&gt; List -&gt; PackageView(packageService: PackageService(package: package)) -&gt; init()</code></p>
<p>So now if I follow this flow and I trigger <code>getPlacemarks()</code> inside init everything works (most of the time) and if the package model changes this function will be called on init and will reverseGeocodeLocation of the modified location. But there is a big problem here and here is why. I can not put this logic on init since I can not geocode hundreds of locations inside a for loop. I have multiple packages displayed on a list and MapKit won't allow this.</p>
<p>So obviously this logic needs to be triggered after the <code>PackageView</code> is shown, so when one of those packages is selected.</p>
<p>If I call <code>packageService.getPlacemarks()</code> when PackageView appears this works fine the first time but... onAppear won't be triggered when <code>@Published var results = [Package]()</code> is updated.</p>
<p>So finally the question is:</p>
<p><em><strong>Where to call <code>packageService.getPlacemarks()</code> so it gets called whenever a <code>Package</code> inside <code>@Published var results = [Package]</code> is updated</strong></em></p>
<p>but not on init of PlacemarkService for the reason I explained above.</p>
<p>Sorry for the long explanation, I am just trying to be clear.</p>
<pre><code>class PackageService: ObservableObject {
    var package: Package
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    @Published var sourcePlacemarkService = PlacemarkService()
    @Published var destinationPlacemarkService = PlacemarkService()
    
    var cancellable: AnyCancellable? = nil
    
    init(package: Package) {
        self.package = package
        startListening()
    }
    
    func startListening() {
        // Listen to placemark changes.
        cancellable = Publishers.CombineLatest(sourcePlacemarkService.$placemark, destinationPlacemarkService.$placemark).sink(receiveValue: {_ in
            
            // Publish changes manually to the view.
            self.objectWillChange.send()
        })
    }
    
    // Get placemarks from locations
    func getPlacemarks() {
        sourcePlacemarkService.reverseGeocodeLocation(location: package.source.toCLLocation)
        destinationPlacemarkService.reverseGeocodeLocation(location: package.destination.toCLLocation)
    }
}

class PackagesViewModel: ObservableObject {
    @Published var results = [Package]()
    
    func load() {
        query.addSnapshotListener { (querySnapshot, error) in 
            // updates results array when a document is modified.
        }
    }
}


struct PackagesView: View {
    @StateObject var packagessViewModel = PackagesViewModel()

    var body: some View {
        List(packagessViewModel.results, id: \.self) { package in
            NavigationLink(destination: PackageView(packageService: PackageService(package: package))) {
                Text(package.title)
            }
        }
    }
}

struct PackageView: View {
    @ObservedObject var packageService: PackageService

    func onAppear() {
        packageService.getPlacemarks()
    }
    
    var body: some View {
        // show the address from placemark after it is geocoded.
        VStack {
            Text(packageService.sourcePlacemarkService.placemark.title)
            Text(packageService.destinationPlacemarkService.placemark.title)
        }
        .onAppear(perform: onAppear)
    }
}

class PlacemarkService: ObservableObject {
    @Published var placemark: CLPlacemark?
    
    init(placemark: CLPlacemark? = nil) {
        self.placemark = placemark
    }
    
    func reverseGeocodeLocation(location: CLLocation?) {
        if let location = location {
            geocoder.reverseGeocodeLocation(location, completionHandler: { (placemark, error) in
                // some code here
                self.placemark = placemark
            })
        }
    }
}

struct Package: Identifiable, Codable {
    @DocumentID var id: String?
    var documentReference: DocumentReference
    
    var uid: String
    var title: String
    var description: String
    var source, destination: GeoPoint
    var amount: Double
    
    var createdAt: Timestamp = Timestamp()
    var paid: Bool = false
}
</code></pre>
","2738166","","2738166","","2021-11-16 00:51:07","2021-11-24 03:01:16","SwiftUI trigger function when model updates inside @Published property","<ios><swift><swiftui><swift5><combine>","2","1","","","","CC BY-SA 4.0"
"70018765","1","70019447","","2021-11-18 11:07:26","","1","137","<p>Consider the following code:</p>
<pre><code>class MyController: NSObject, ObservableObject {

    //...

    @Published var myRapidlyChangingVar: MyEnum? = nil

    //...

    func calledAtHighFrequencyByExternalEvents(value: MyEnum) {
        myRapidlyChangingVar = value
    }
}
</code></pre>
<p>The value of <code>myRapidlyChangingVar</code> needs to be set to <code>nil</code> if no calls to <code>calledAtHighFrequencyByExternalEvents()</code> have been made for 1 second.</p>
<p>What is the simplest and cleanest approach to adopt to achieve this?</p>
<p>Strikes me as the sort of thing which Reactive programming should make incredibly simple, but unsure where to start or what to search for.</p>
","233602","","","","","2021-11-20 16:40:44","Setting an @Published var to nil after no more events are received","<swift><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"70034331","1","70034718","","2021-11-19 11:44:36","","0","227","<p>I am following Stanford's CS193p Developing Apps for iOS online course.
I'm trying to do the <a href=""https://cs193p.sites.stanford.edu/sites/g/files/sbiybj16636/files/media/file/assignment_6.pdf"" rel=""nofollow noreferrer"">Assignment 6 (Memorize Themes.pdf)</a>.</p>
<p>When I run my app in simulator and in edit mode tap on a list row to bring up the sheet, I get the following fatal error:
Thread 1: Fatal error: Unexpectedly found nil while unwrapping an Optional value</p>
<p><strong>Question: Why the index matching</strong> <code>themeToEdit</code> <strong>inside themes array is nil?</strong></p>
<p>Please help me.</p>
<pre><code>import SwiftUI

// Required Task 3: Your Memorize application should now show a “theme chooser” UI when it launches.

struct ThemeChooserView: View {
    @EnvironmentObject var themeStore: ThemeStore
    
    @State private var editMode: EditMode = .inactive
        
    var body: some View {
        NavigationView {
            List {
                ForEach(themeStore.themes) { theme in
                    NavigationLink(destination: EmojiMemoryGameView(game: EmojiMemoryGame(theme: theme))) {
                        VStack(alignment: .leading) {
                            Text(theme.name)
                                .foregroundColor(theme.color)
                                .font(.title)
                            Text(themeCardsDescription(theme: theme))
                        }
                        .gesture(editMode == .active ? tapGesture(theme: theme) : nil)
                    }
                }
                .onDelete { indexSet in
                    themeStore.themes.remove(atOffsets: indexSet)
                }
                .onMove { indexSet, newOffset in
                    themeStore.themes.move(fromOffsets: indexSet, toOffset: newOffset)
                }
            }
            .sheet(isPresented: $isEditing) {
                let currentThemeIndex = themeStore.themes.firstIndex(where: {$0.id == themeToEdit?.id})
                ThemeEditor(theme: $themeStore.themes[currentThemeIndex!]) // ERROR: - 🛑 Thread 1: Fatal error: Unexpectedly found nil while unwrapping an Optional value
            }
            .navigationTitle(&quot;Memorize&quot;)
            .toolbar {
                ToolbarItemGroup(placement: .navigationBarLeading) {
                    plusButton
                }
                ToolbarItemGroup {
                    EditButton()
                }
            }
            .environment(\.editMode, $editMode)
        }
    }
    
    @State private var isEditing: Bool = false
    
    @State private var themeToEdit: Theme?

    private func tapGesture(theme: Theme) -&gt; some Gesture {
        TapGesture().onEnded { _ in
            themeToEdit = theme
            isEditing = true
        }
    }
    
    private func themeCardsDescription(theme: Theme) -&gt; String {
        let numberOrAll = theme.numberOfPairsOfCards == theme.emojis.count ? &quot;All&quot; : &quot;\(theme.numberOfPairsOfCards)&quot;
        return numberOrAll + &quot; pairs from \(theme.emojis.joined(separator: &quot;&quot;))&quot;
    }
    
    private var plusButton: some View {
        Button {
            let theme = Theme(name: &quot;New Theme&quot;, emojis: [&quot;🐵&quot;, &quot;🐿&quot;], numberOfPairsOfCards: 2, color: .black)
            themeStore.themes.append(theme)
        } label: {
            Image(systemName: &quot;plus&quot;)
        }
    }
}
</code></pre>
","14119170","","8160613","","2021-11-19 12:27:06","2021-11-19 12:30:12","SwiftUI: Unexpectedly found nil while unwrapping an Optional value","<swift><swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"70089737","1","70145857","","2021-11-24 01:22:48","","0","235","<p>I have the problem that I can't preview the View of my app with Canvas, because I always get the error:</p>
<blockquote>
<p>&quot;Terminating app due to uncaught exception
'NSInvalidArgumentException', reason: 'An NSManagedObject of class
'App.MPG_A' must have a valid NSEntityDescription.&quot;</p>
</blockquote>
<p>Now more detailed: In the view I want to preview I have a @Binding of the abstract class MultiplayerGame (MPG A or MPG B (subclasses) and the MultiplayerGame is a subclass of Game (picture below)</p>
<p><a href=""https://i.stack.imgur.com/dEMPC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dEMPC.png"" alt=""App Model"" /></a></p>
<p>Comment: MultiplayerGame is also an abstract entity (like Game) and &quot;Class&quot; -&gt; &quot;MPG B&quot;</p>
<p>And when I want to preview the class the following class by making a moc Object in the Preview my App crashes but I don't know why:</p>
<pre><code>    import SwiftUI
import CoreData
import Combine

struct StandingEditView: View {
    
    //multiplayer game with MPG A or MPG B class
    @Binding var game : MultiplayerGame
    
    @State private var invokeFunction : Bool = false
    
    var body: some View {
        
        VStack{
            
            List{
                
                ForEach(game.players!, id: \.self){ player in
                    
                    HStack{
                        Text(&quot;\(player.name)&quot;)
                    }
                    
                }
                
            }
            
            Button(action: {
                invokeFunction.toggle()
            }, label: {
                Text(&quot;Button&quot;)
            })
            
        }
        
    }
}

struct StandingEditView_Previews: PreviewProvider {
    
    static let moc = NSManagedObjectContext(concurrencyType: .mainQueueConcurrencyType)
    
    static var previews: some View {
        
        let game : MultiplayerGame = Standing(context: moc)
        
        let p1 : Player = Player(context: moc)
        let p2 : Player = Player(context: moc)
        let p3 : Player = Player(context: moc)
        
        p1.name =  &quot;Player One&quot;
        p2.name =  &quot;Player Two&quot;
        p3.name =  &quot;Player Three&quot;
        
        game.players = [p1,p2,p3]
        
        return StandingEditView(game: .constant(game))
    }
}
</code></pre>
<p>And the only (not default) attributes of <strong>Player</strong> is -&gt; <strong>var name : String</strong></p>
<p><strong>I also tried with AppDelegate but that didn't work either...</strong></p>
<p>The error must occur because of the Preview and moc-Object because the Code itself compiles and the other Views are visible without an error.</p>
<p>Thank you for your help!</p>
","","user12631628","","user12631628","2021-11-25 18:13:27","2021-11-29 07:01:36","SwiftUI Preview crashes with Core Data 'NSInvalidArgumentException'","<swift><core-data><swiftui><preview>","2","3","0","","","CC BY-SA 4.0"
"70106876","1","70107274","","2021-11-25 06:48:46","","1","313","<p>I have written a couple of view models for my SwiftUI project. It turns out that they share quite a lot of properties and code and I wanted to pull this code into a generic view model and then user class inheritance to specialize the real view models. Unfortunately this turns out quite difficult. Here's a simplified example:</p>
<pre><code>class viewModelA: ObservableObject {
    enum Animal {
        case cat
        case dog
    }

    @published var selected: Animal?

    func select(_ animal: Animal?) {
        self.selected = animal
    }
    ...
}

class viewModelB: ObservableObject {
    enum Animal {
        case lion
        case tiger
    }

    @published var selected: Animal?

    func select(_ animal: Animal?) {
        self.selected = animal
    }
    ...
}
</code></pre>
<p>The first thing I've tried is to create a protocol and use a protocol with an associatedtype for Animal, but then I struggled with the property that has @published. Swift doesn't allow to have property wrappers in protocols...</p>
<p>How could I generalize those 2 classes?</p>
","10826194","","10826194","","2021-11-25 07:41:08","2021-11-25 07:41:08","Generalizing multiple view models","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"70118808","1","70119000","","2021-11-26 01:42:01","","0","53","<p>I'm trying to parse stock data from the website alphavantage.com using the combine frame work. I keep getting this <code>error Swift.DecodingError.Context(codingPath: [], debugDescription: &quot;No value associated with key CodingKeys(stringValue: \&quot;bestMatches\&quot;, intValue: nil) (\&quot;bestMatches\&quot;).&quot;, underlyingError: nil))</code> despite my data model having the correct values to match during with the json. How do I fix this ?</p>
<pre><code>struct SearchResults: Decodable{
    let bestMatches : [SearchResult]
    
    enum CodingKeys: String, CodingKey{
        case bestMatches =  &quot;bestMatches&quot;
    }
}

struct SearchResult : Decodable{
    let symbol : String?
    let name : String?
    let type : String?
    let currency :String?
    
    enum CodingKeys:String, CodingKey{
       case symbol = &quot;1. symbol&quot;
       case  name = &quot;2. name&quot;
       case type = &quot;3. type&quot;
       case currency = &quot;8. currency&quot;
    }
}

struct APIservice{
    let apiKey = &quot;U893NJLDIREGERHB&quot;
    
    func fetchSymbols(keyword:String)-&gt; AnyPublisher&lt;SearchResults,Error&gt;{
        let urlSTring = &quot;https://www.alphavantage.co/query?function=\(keyword)H&amp;keywords=tesco&amp;apikey=U893NJLDIREGERHB&quot;
        let url = URL(string: urlSTring)!
        return URLSession.shared.dataTaskPublisher(for: url)
            .map({$0.data})
            .decode(type: SearchResults.self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }
}

   func performSearch(){
        apiSerivice.fetchSymbols(keyword: &quot;S&amp;P500&quot;).sink { (completion) in
            switch completion {
            case .failure(let error):
                print(error)
            case . finished:
                break
            }
        } receiveValue: { (SearchResults) in
            print(SearchResults.bestMatches)
        }.store(in: &amp;subcribers)
</code></pre>
","16693060","","","","","2021-11-26 21:54:25","How do I fix the error described during json parsing using combine?","<json><swift><combine>","1","3","","","","CC BY-SA 4.0"
"70122824","1","70123056","","2021-11-26 10:19:14","","0","88","<p>I'm playing with Combine to learn it and improve my reactive programming skills, and I'm trying to create some generic class that convert data to my <em>T</em> type</p>
<p>I have this error, and I don't understand why</p>
<blockquote>
<p><em>Key path value type '[T]' cannot be converted to contextual type 'T'</em></p>
</blockquote>
<pre><code>class Fetcher&lt;T: Codable&gt;: ObservableObject {
    private var task: AnyCancellable?
    @Published var result = [T]()

    init&lt;T: Codable&gt; (type: T.Type) {
    guard let url = URL(string: &quot;https://api.example.com&quot;) else { return }
    task = URLSession.shared.dataTaskPublisher(for: url)
        .map{$0.data}
        .decode(type: T.self, decoder: JSONDecoder())
        .receive(on: DispatchQueue.global(qos: .background))
        .replaceError(with: T.self as! T)
        .assign(to: \.result, on: self)
    }
}
</code></pre>
<p><a href=""https://i.stack.imgur.com/lKv1M.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/lKv1M.png"" alt=""enter image description here"" /></a></p>
","11734662","","12299030","","2021-11-26 10:44:55","2021-11-26 10:47:23","Generic Func: Key path value type '[T]' cannot be converted","<swift><combine>","1","7","","","","CC BY-SA 4.0"
"70128744","1","70129071","","2021-11-26 18:35:34","","2","662","<p>When hitting the button, a player is added to the game and I want to observe the changes in the game through the view model. When I hit the button, the counter doesn't change.</p>
<p>It's almost as if I need the game within the <code>ContentViewModel</code> to be both <code>@ObservedObject</code> and <code>@Published</code>.</p>
<p>Can someone help me understand the fundamentals of why this is setup wrong and how I can fix it?</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

class Game: ObservableObject {
    @Published var players: [String] = []

    func addPlayer(_ player: String) {
        players.append(player)
    }
}

class ContentViewModel: ObservableObject {
    @Published var game: Game {
        didSet {
            subscription = game.objectWillChange.sink { [weak self] _ in
                self?.objectWillChange.send()
            }
        }
    }
    var subscription: AnyCancellable?

    init(game: Game) {
        self.game = game
    }
}

struct ContentView: View {
    @ObservedObject var viewModel: ContentViewModel

    var body: some View {
        Text(&quot;Num players: \(viewModel.game.players.count)&quot;)
            .padding()

        Button(&quot;Add player&quot;) {
            viewModel.game.addPlayer(&quot;player&quot;)
        }
    }
}
</code></pre>
","174507","","","","","2021-11-26 19:11:38","SwiftUI observe published object of published object","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"70210706","1","70609561","","2021-12-03 07:14:05","","0","117","<p>Below is the SwiftUI view which owns a ViewModel and the logic is if the <code>viewModel.authenticationService.user</code> contains a user object then it will show the HomeView, else case will be asked for Login. So initially the <code>viewModel.authenticationService.user</code> is nil and user logins successful the user object in no more nil.</p>
<p><strong>View</strong></p>
<pre><code>struct WelcomeView: View {
    
    @ObservedObject private var viewModel: WelcomeView.Model
    @State private var signInActive: Bool = false
    
    init(viewModel: WelcomeView.Model) {
        self.viewModel = viewModel
    }
    
    var body: some View {
        if viewModel.authenticationService.user != nil {
            HomeView()
        } else { 
            LoginView()
        }
    } 
</code></pre>
<p><strong>ViewModel</strong></p>
<pre><code>extension WelcomeView {
    
    final class Model: ObservableObject {
        
        @ObservedObject var authenticationService: AuthenticationService
        
        init(authenticationService: AuthenticationService) {
            self.authenticationService = authenticationService
        }
    }
}
</code></pre>
<p><strong>AuthenticationService</strong></p>
<pre><code>final class AuthenticationService: ObservableObject {
    
    @Published var user: User?
    private var authenticationStateHandle: AuthStateDidChangeListenerHandle?
    
    init() {
        addListeners()
    }
    
    private func addListeners() {
        if let handle = authenticationStateHandle {
            Auth.auth().removeStateDidChangeListener(handle)
        }
        
        authenticationStateHandle = Auth.auth()
            .addStateDidChangeListener { _, user in
                self.user = user
            }
    }
    
    static func signIn(email: String, password: String, completion: @escaping AuthDataResultCallback) {
        if Auth.auth().currentUser != nil {
            Self.signOut()
        }
        Auth.auth().signIn(withEmail: email, password: password, completion: completion)
    }
}
</code></pre>
<p>However, when the user object is updated with some value it does not update the View. I am not sure as I am new to reactive way of programming. There is a chain of View -&gt; ViewModel -&gt; Service and the published user property is in the Service class which gets updated successfully once user login.</p>
<p>Do I need to add a listener in the ViewModel which reacts to Service published property? Or is there any direct way for this scenario to work and get the UI Updated?</p>
","4715546","","","","","2022-01-07 05:33:21","View not reacting to changes of Published property when its chained from another ObservedObject","<swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"70220286","1","70258563","","2021-12-03 20:26:04","","-1","89","<p>Server I work with accepts:</p>
<pre><code>  curl -X 'POST' \
  'https://some.url' \
  -H 'accept: application/json' \
  -H 'authorization: Bearer YOUR_TOKEN' \
  -H 'Content-Type: multipart/form-data' \
  -F 'data=@your-image.jpg;type=image/jpeg'
</code></pre>
<p>All I can find is examples with parameters. I have tried everything, alamofire and standard url sessions</p>
","6850173","","","","","2021-12-07 10:32:02","Swift upload UIImage with multipart form without parameters","<swift><swiftui><alamofire><combine>","1","1","","","","CC BY-SA 4.0"
"70281648","1","70297495","","2021-12-08 21:00:09","","0","218","<p>Like the title says I would like to make custom publisher that will basically function like deffered future. Normally when I want to encapsulate code in some Future, but want it to execute on subscription, I would need to write something like this:</p>
<pre><code>Deffered {
    Future { promise in
    }
}
</code></pre>
<p>Now I was thinking of making custom publisher, something along the lines DefferedFuture that will have exact same functionality as Future, but will execute promise only on subscription?</p>
","744270","","","","","2021-12-09 22:26:53","Making custom Deffered Future Publisher in Swift Combine?","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"70284965","1","70285679","","2021-12-09 05:06:03","","1","127","<p>I am working with TabView and would like to add more data when a user clicks for the 2nd time on the same tab item . I have been looking at other examples such as this <a href=""https://stackoverflow.com/questions/69813681/swiftui-tabview-on-click-action"">SwiftUI TabView On Click Action</a> however I have not been able to get it to work . I have a simple example below (full code) . Basically if the tag is already on MainView and the user clicks it again I want to hit the  <strong>print(&quot;Update get more data&quot;)</strong> code . I have used the OnReceive method however that does not work if clicked more than 1 time in the same tab . I have also tried to use onTapGesture outside of the TabView but do not seem to bind any suggestions would be great since I am learning SwiftUI and I am using version 3.0</p>
<pre><code>  *TabView(selection: $selectedTab) {
      ... 
    }.onTapGesture {
        print(selectedTab) // This always give MainView 
    }*
</code></pre>
<p>I have also tried the above and it is always giving MainView</p>
<pre><code>import SwiftUI
import Combine

struct TabViews: View {
    @State var selectedTab: Tab = .MainView
    @State private var firstPass = false
    
    var body: some View {
        
        TabView(selection: $selectedTab) {
            Text(&quot;Main View&quot;)
                .padding()
                .tabItem {
                    Image(systemName: &quot;1.circle&quot;)
                    
                    Text(&quot;First&quot;)
                    
                }
                .tag(Tab.MainView)
            
            Text(&quot;Menu View&quot;)
            
                .padding()
                .tabItem {
                    Image(systemName: &quot;2.circle&quot;)
                    
                    Text(&quot;Second&quot;)
                       
                }
                .tag(Tab.MenuView)
            
        }
        
        .onReceive(Just(selectedTab)) {
            print(&quot;Tapped!! \(selectedTab)&quot;)
            
 
            if $0 == .MainView  {
                
                if firstPass == true {
                    // update list
                    print(&quot;Update get more data&quot;)
                }
                firstPass = true
            }
            if $0 == .MenuView {
                print(&quot;2&quot;)
            }
        }
       
        
    }
}

extension TabViews {
    enum Tab: Hashable {
        case MainView
        case MenuView
        case RankingView
    }
}

struct TabView_Previews: PreviewProvider {
    static var previews: some View {
        TabViews()
    }
}
</code></pre>
","1591668","","","","","2021-12-09 06:40:37","SwiftUI TabView how can I load more data on 2nd tab click","<swift><swiftui><swiftui-tabview>","1","0","","","","CC BY-SA 4.0"
"70307882","1","70309753","","2021-12-10 16:50:30","","2","224","<p>I have a step function on AWS triggered by an HTTP Post request. The function can take a few seconds to complete. I'd like for execution to continue if the user puts the app into the background, and to correctly navigate to the next screen once the user puts the app back into the foreground (if execution has finished).</p>
<p>My API Client endpoint looks like this:</p>
<pre><code> func connect&lt;OutputType: Decodable&gt;(to request: URLRequestConvertible, decoder: JSONDecoder) -&gt; AnyPublisher&lt;Result&lt;OutputType, Error&gt;, Never&gt; {
    var request = request.asURLRequest()
    
    if let token: String = KeychainWrapper.standard.string(forKey: &quot;apiToken&quot;) {
        request.addValue(token, forHTTPHeaderField: &quot;Authorization&quot;)
    }
    
    let configuration = URLSessionConfiguration.default
    configuration.waitsForConnectivity = true
    let session = URLSession(configuration: configuration)
    
    return session.dataTaskPublisher(for: request)
        .tryMap({ (data, response) -&gt; Data in
            guard let response = response as? HTTPURLResponse else { throw NetworkError.invalidResponse }
            guard 200..&lt;300 ~= response.statusCode else {
                throw NetworkError.invalidStatusCode(statusCode: response.statusCode)
                
            }
            return data
        })
        .decode(type: OutputType.self, decoder: decoder)
        .map(Result.success)
        .catch { error -&gt; Just&lt;Result&lt;OutputType, Error&gt;&gt; in Just(.failure(error)) }
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
}
</code></pre>
<p>I'd like to know the best practice for implementing this call. I'm currently using beginBackgroundTask below.</p>
<pre><code>func makeRequest() {
    DispatchQueue.global(qos: .userInitiated).async {
        self.backgroundTaskID = UIApplication.shared.beginBackgroundTask (withName: &quot;Request Name&quot;) {
            UIApplication.shared.endBackgroundTask(self.backgroundTaskID!)
            self.backgroundTaskID = .invalid
        }
        &lt;implementation&gt;
    }
}
</code></pre>
<p>However, <code>implementation</code> only works if I have nested DispatchQueue.main.async blocks where I perform more logic after making the HTTP request (like determining which screen to navigate to next after we receive the response.</p>
<p>Is this the best way to do it? Is it ok to have a few different nested DispatchQueue.main.async blocks inside the DispatchQueue.global block? Should I post the <code>.receive(on: )</code> to DispatchQueue.global?</p>
","9307138","","5175709","","2022-02-18 20:20:48","2022-02-18 20:20:48","Swift Background Execution","<ios><swift><urlsession><uibackgroundtask><backgroundtaskidentifier>","1","0","","","","CC BY-SA 4.0"
"70314142","1","70315261","","2021-12-11 09:56:04","","0","312","<p>I've got this network call for fetching images.</p>
<pre class=""lang-swift prettyprint-override""><code>func load() {
        guard let url = URL(string: urlString)
        else { return }

        subscription = URLSession.shared.dataTaskPublisher(for: url)
            .map({ UIImage(data: $0.data) })
            .replaceError(with: nil)
            .receive(on: RunLoop.main)
            .sink(receiveValue: { [weak self] in self?.image = $0 })
    }
</code></pre>
<p>This is triggered by the text field being filled. After each letter is typed, I would like my publisher to wait with the execution for let's say 2 seconds, unless a user typed another letter. If that happens, I'd like the timer to reset to 2 seconds again.</p>
<p>Is there any on the fly <strong>cancel</strong> operator if the new request has been sent in the meanwhile?</p>
<p>Thanks for all the help.</p>
","14880022","","14880022","","2021-12-11 10:37:53","2021-12-11 13:36:14","Swift, Combine, cancel on the flight and replace with the new request operator","<ios><swift><combine>","1","7","","","","CC BY-SA 4.0"
"70354240","1","70356271","","2021-12-14 18:57:57","","0","96","<p>I'm currently trying to load JSON in Swift to use it in my UI. I think I've managed to get the JSON to load properly, but I can't test it due to the multiple errors I'm getting in my code.</p>
<p>JSONReader.swift:</p>
<pre><code>import Foundation

struct DatabaseObject: Decodable {
    let name: String
    let books: Books
    let memoryVerses: MemoryVerses
    
    struct Books: Codable {
        let Romans: Book
        let James: Book
        
        struct Book: Codable {
            let abbreviation: String
            let chapters: [Chapter]
            
            struct Chapter: Codable {
                let sections: [Section]
                let footnotes: Footnotes
                
                struct Section: Codable {
                    let title: String
                    let verses: [String]
                }
                
                struct Footnotes: Codable {
                    let a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z: String
                }
                
            }
            
        }
        
    }
    struct MemoryVerses: Codable {
        let singles: [String]
        let multiples: [String]
    }
}

public class JSONReaderSuperclass {
    @Published var contentData: (status: String, result: DatabaseObject?)
    init() {
        contentData = (status: &quot;loading&quot;, result: nil)
    }
}

public class JSONReader: JSONReaderSuperclass, ObservableObject {
    
    private func parse(jsonData: Data) -&gt; (status: String, result: DatabaseObject?) {
        do {
            let decodedData = try JSONDecoder().decode(DatabaseObject.self, from: jsonData)
            print(decodedData)
            return (status: &quot;success&quot;, result: decodedData)
        } catch {
            return (status: &quot;fail&quot;, result: nil)
        }
    }
    private func loadJson(fromURLString urlString: String,
                          completion: @escaping (Result&lt;Data, Error&gt;) -&gt; Void) {
        if let url = URL(string: urlString) {
            let urlSession = URLSession(configuration: .default).dataTask(with: url) { (data, response, error) in
                if let error = error {
                    completion(.failure(error))
                }
                
                if let data = data {
                    completion(.success(data))
                }
            }
            urlSession.resume()
        }
    }
    override init() {
        super.init()
        DispatchQueue.main.async {
            self.loadJson(fromURLString: &quot;redacted for anonymity&quot;) { result in
                switch result {
                    case .success(let data):
                        self.contentData = self.parse(jsonData: data)
                    case .failure:
                        self.contentData = (status: &quot;fail&quot;, result: nil)
                }
            }
        }
    }
}
</code></pre>
<p>ContentView.swift:</p>
<pre><code>import SwiftUI

struct ContentView: View {
    @StateObject var databaseObject = JSONReader()
    var body: some View {
        switch ($databaseObject.status) {
            case &quot;loading&quot;:
                Text(&quot;Loading...&quot;)
            case &quot;success&quot;:
                VersePicker(databaseObject: $databaseObject.result)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .navigationTitle(&quot;Content Judge&quot;)
                    .navigationBarTitleDisplayMode(.inline)
            case &quot;fail&quot;:
                Text(&quot;An unknown error occured. Check your internet connection and try again.&quot;)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>
<p>VersePicker.swift:</p>
<pre><code>import SwiftUI

enum Book: String, CaseIterable, Identifiable {
    case romans
    case james

    var id: String { self.rawValue }
}

struct VersePicker: View {
    var databaseObject: DatabaseObject
    @State private var selectedBook = Book.romans
    @State private var selectedChapter: Int = 1
    @State private var selectedVerse: Int = 1
    
    var body: some View {
        VStack {
            Picker(&quot;Book&quot;, selection: $selectedBook) {
                ForEach(Book.allCases) { book in
                    Text(book.rawValue.capitalized)
                        .tag(book)
                }
            }
            HStack {
                Picker(&quot;Chapter&quot;, selection: $selectedChapter) {
                    ForEach(1...100, id: \.self) { number in
                        Text(&quot;\(number)&quot;)
                    }
                }
                Picker(&quot;Verse&quot;, selection: $selectedVerse) {
                    ForEach(1...100, id: \.self) { number in
                        Text(&quot;\(number)&quot;)
                    }
                }
            }
            .frame(maxHeight: .infinity)
            Spacer()
            NavigationLink(destination: VerseDisplay()) {
                Label(&quot;Go&quot;, systemImage: &quot;arrow.right.circle&quot;)
            }
        }
        .padding()
    }
}

struct VersePicker_Previews: PreviewProvider {
    static var previews: some View {
        VersePicker(databaseObject: JSONReader().result)
    }
}
</code></pre>
<p>I'm getting the following errors:</p>
<ul>
<li><strong>ContentView.swift:13</strong> - &quot;Value of type 'ObservedObject.Wrapper' has no dynamic member 'status'
using key path from root type 'JSONReader'&quot;</li>
<li><strong>ContentView.swift:17</strong> - &quot;Cannot convert value of type 'Binding' to expected argument type 'DatabaseObject'&quot;</li>
<li><strong>ContentView.swift:17</strong> - &quot;Value of type 'ObservedObject.Wrapper' has no dynamic member 'result'
using key path from root type 'JSONReader'&quot;</li>
<li><strong>VersePicker.swift:55</strong> - &quot;Value of type 'JSONReader' has no member 'result'&quot;</li>
</ul>
<p>Any idea what I'm doing wrong? I'm completely new to Swift, so I'm at a loss.</p>
","14496190","","","","","2021-12-14 22:27:34","How to use StateObject and Combine with JSON loader?","<json><swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"70414035","1","70414171","","2021-12-19 18:02:44","","1","225","<p>I want to use a Combine in my project and face the problem.
Here is the code of the ViewController</p>
<pre><code>import Combine
import UIKit

class ProfileDetailsController: ViewController {
    //

    // MARK: - Views
    @IBOutlet private var tableView: UITableView!

    // MARK: - Properties
    private typealias DataSource = UITableViewDiffableDataSource&lt;ProfileDetailsSection, ProfileDetailsRow&gt;
    private typealias Snapshot = NSDiffableDataSourceSnapshot&lt;ProfileDetailsSection, ProfileDetailsRow&gt;

    @Published private var data: [ProfileDetailsSectionModel] = {
        return ProfileDetailsSection.allCases.map { ProfileDetailsSectionModel(section: $0, data: $0.rows) }
    }()
    
    private lazy var dataSource: DataSource = {
        let dataSource = DataSource(tableView: tableView) { tableView, _, model in
            let cell = tableView.dequeueReusableCell(withIdentifier: TextFieldTableCell.name) as! TextFieldTableCell
            cell.delegate = self
            cell.setData(model: model)
            return cell
        }
        dataSource.defaultRowAnimation = .fade
        return dataSource
    }()
}

// MARK: - Setup binding
extension ProfileDetailsController {
    override func setupBinding() {
        tableView.registerCellXib(cell: TextFieldTableCell.self)
        $data.receive(on: RunLoop.main).sink { [weak self] models in
            let sections = models.map { $0.section }
            var snapshot = Snapshot()
            snapshot.appendSections(sections)
            models.forEach { snapshot.appendItems($0.data, toSection: $0.section) }
            self?.dataSource.apply(snapshot, animatingDifferences: true)
        }.store(in: &amp;cancellable)
    }
}

// MARK: - Cell delegates
extension ProfileDetailsController: TextFieldTableCellDelegate {
    func switcherAction() { }
}
</code></pre>
<p>And here is the code of the cell.</p>
<pre><code>import UIKit

protocol TextFieldTableCellData {
    var placeholder: String? { get }
}

protocol TextFieldTableCellDelegate: NSObjectProtocol {
    func switcherAction()
}

class TextFieldTableCell: TableViewCell {
    //

    // MARK: - Views
    @IBOutlet private var textField: ZWTextField!

    // MARK: - Properties
    public weak var delegate: TextFieldTableCellDelegate?

    override class var height: CGFloat {
        return 72
    }
}

// MARK: - Public method
extension TextFieldTableCell {
    func setData(model: TextFieldTableCellData) {
        textField.placeholder = model.placeholder
    }
}
</code></pre>
<p>ViewController's <code>deinit</code> was not called.
But when I use this code for ViewController</p>
<pre><code>import UIKit

class ProfileDetailsController: ViewController {
    //

    // MARK: - Views
    @IBOutlet private var tableView: UITableView!

    // MARK: - Properties
    @Published private var data: [ProfileDetailsSectionModel] = {
        return ProfileDetailsSection.allCases.map { ProfileDetailsSectionModel(section: $0, data: $0.rows) }
    }()
}

// MARK: - Startup
extension ProfileDetailsController {
    override func startup() {
        tableView.dataSource = self
        tableView.registerCellXib(cell: TextFieldTableCell.self)
    }
}

// MARK: - Startup
extension ProfileDetailsController: UITableViewDataSource {
    func numberOfSections(in tableView: UITableView) -&gt; Int {
        return data.count
    }

    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        return data[section].data.count
    }

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
        let model = data[indexPath.section].data[indexPath.row]
        let cell = tableView.dequeueReusableCell(withIdentifier: TextFieldTableCell.name) as! TextFieldTableCell
        cell.delegate = self
        cell.setData(model: model)
        return cell
    }
}

// MARK: - Cell delegates
extension ProfileDetailsController: TextFieldTableCellDelegate {
    func switcherAction() {}
}
</code></pre>
<p>Everything is fine. <code>deinit</code> called. I tried to set dataSource optional and set it nil on <code>deinit</code>, the same result. With Combine deinit called only when I comment this line:</p>
<pre><code>cell.delegate = self
</code></pre>
<p>Does anyone know what's the matter?
Xcode 13.2 iOS 15.2</p>
","9315298","","","","","2021-12-19 18:30:33","UITableViewDiffableDataSource are not deinit","<swift><ios15><uitableviewdiffabledatasource>","1","2","","","","CC BY-SA 4.0"
"70415608","1","70415697","","2021-12-19 21:51:10","","-2","958","<p>Could someone explain why I get this warning: <strong>Publishing changes from background threads is not allowed; make sure to publish values from the main thread (via operators like receive(on:)) on model updates.</strong></p>
<p>I'm know that if I wrap the changes in <code>DispatchQueue.main.async</code> the problem goes away. Why does it happen with some view modals and not others? I thought that since the variable has <code>@Published</code> it's automatically a publisher on main thread?</p>
<pre class=""lang-swift prettyprint-override""><code>class VM: ObservableObject {
    
    private let contactsRepo = ContactsCollection()
    
    @Published var mutuals: [String]?
    
    func fetch() {
        contactsRepo.findMutuals(uid: uid, otherUid: other_uid, limit: 4) { [weak self] mutuals in
            guard let self = self else { return }
            if mutuals != nil {
                self.mutualsWithHost = mutuals // warning...
            } else {
                self.mutualsWithHost = []
            }
        }
    }
}
</code></pre>
","7451631","","","","","2021-12-19 22:06:01","SwiftUI @Published and main thread","<swift><swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"70442054","1","70538361","","2021-12-21 22:02:06","","0","80","<p>I've posted a minimal example to <a href=""https://github.com/SaganRitual/Vai"" rel=""nofollow noreferrer"">github</a>.</p>
<p><a href=""https://stackoverflow.com/questions/61025239/weird-behaviour-in-swiftuicombine-when-class-struct"">This question</a> seems like it might be related, but I couldn't make any progress.</p>
<p>I have an <code>@ObservableObject</code> class that contains a <code>@Published</code> struct. I have a <code>Slider</code> bound to a field in that struct, and two observers on the struct. One of the observers makes a change to a different field in the struct. When I read the updated struct during notification, everything looks right. After the notification, my struct has been overwritten. I can't find where it's happening in the debugger; it breaks on <code>@main</code>. I've put diagnostics all over the place in my real app, and can't figure out where it's being set to the wrong value.</p>
<p>It seems like what's happening is that SwiftUI is making copies of the struct. I could understand making copies if the struct weren't part of an object, but I don't get why it would do it here.</p>
<p>Changing my struct to a class causes the overwrite to stop. But my struct really shouldn't be a class; it's kind of like <code>CGRect</code> in my example. So I wonder:</p>
<ul>
<li>Why does it behave this way with a struct?</li>
<li>Is this a misuse of Combine or SwiftUI or Swift?</li>
<li>Is something I'm doing here generally a bad practice?</li>
<li>Is there a better way to do it?</li>
</ul>
<p>Here's the main app module:</p>
<pre><code>@ObservedObject var arena = Arena()

var body: some Scene {
    WindowGroup {
        ContentView(arena: arena).onAppear { arena.postInit() }
    }
}
</code></pre>
<p>Here's <code>ContentView</code>:</p>
<pre><code>@ObservedObject var arena: Arena

func bind() -&gt; Binding&lt;Double&gt; {
    // A sanity check of sorts, to verify that I'm really
    // reading and writing the slider values.
    Binding(
        get: { arena.frame.origin.x },
        set: {
            arena.frame.origin.x = $0
            print(&quot;Binding (x: \(arena.frame.origin.x), y: \(arena.frame.origin.y))&quot;)
        }
    )
}

var body: some View {
    // Slide this slider around; it will write to the X in the
    // frame struct.
    Slider(
        value: bind(), in: -1.0...1.0,
        label: { Text(&quot;Origin.x \(arena.frame.origin.x)&quot;) }
    )

    Button(&quot;Check values&quot;) {
        print(&quot;Button (x: \(arena.frame.origin.x), y: \(arena.frame.origin.y))&quot;)
    }
}
</code></pre>
<p>And here's <code>Arena</code>:</p>
<pre><code>@Published var frame: CGRect = .zero

var xObserver: AnyCancellable?

func postInit() {
    // Whenever the X is changed, update the Y
    xObserver = $frame
        .removeDuplicates {
            $0.origin.x == $1.origin.x
        }
        .sink { [weak self] in
            guard let myself = self else { return }
            myself.frame.origin.y = $0.origin.x
            print(&quot;Writing (x: \(myself.frame.origin.x), y: \(myself.frame.origin.y))&quot;)
        }
}
</code></pre>
<p>If you run the app and move the slider around, you can see in the console output that I'm writing to the x/y values in the rectangle, but when you click the button you can see that we're reading the rectangle values and getting zeros.</p>
<p>One clue is that if I add <code>RunLoop.main</code> or <code>DispatchQueue.main</code> to my observer as shown below, the correct values are read back when clicking the button, although they're not correct while the slider is being moved around.</p>
<pre><code>// In the Arena class
func postInit() {
    xObserver = $frame
        .removeDuplicates {
            $0.origin.x == $1.origin.x
        }

        // Adding this line changes the behavior; it
        // doesn't seem to clear up the whole issue, but it's a
        // clue. Note that this works the same using
        // DispatchQueue.main, but not using ImmediateScheduler.shared
        .receive(on: RunLoop.main)

        .sink { [weak self] in
            guard let myself = self else { return }
            myself.frame.origin.y = $0.origin.x
            print(&quot;Writing (x: \(myself.frame.origin.x), y: \(myself.frame.origin.y))&quot;)
        }
}
</code></pre>
","1610473","","1610473","","2021-12-22 09:15:55","2021-12-31 01:58:31","SwiftUI/Combine notification overwrites my struct with incorrect values","<swift><class><struct><swiftui><combine>","1","7","","","","CC BY-SA 4.0"
"70454265","1","70518109","","2021-12-22 19:34:39","","-2","121","<p>I have two publishers, one that gathers messages based on a state, and the second which is a Timer. I want these to fire in order - so first gather data, then start a timer. How can I do this? This is my current code:</p>
<pre><code>let messagesPublisher = OnboardingStateLogic.publisher(
  forState: state,
  nextState: nextState
)

messagesPublisher
  .sink { completion in 
    print(&quot;completed&quot;)
  } receiveValue: { [weak self] messages in
    messages.forEach { message in
      self?.queue.enqueue(message)
    }
  }

timer = Timer
  .publish(every: 2, on: .main, in: .default)
  .autoconnect()
  .sink { _ in
    self.dequeueMessages()
  }
</code></pre>
","362840","","","","","2021-12-29 10:25:53","How to fire one publisher after another?","<ios><swift><combine>","2","2","","","","CC BY-SA 4.0"
"70481696","1","70481978","","2021-12-25 17:32:22","","0","129","<p>I want to debounce a batch of events and process them after a delay of ~1.5 seconds. Here's what I've done.</p>
<pre><code>class ViewModel: ObservableObject {

    @Published var pending: [TaskInfo]
    private var cancellable: AnyCancellable? = nil

    init() {
        processPendingTasks()
    }

    func queueTask(task: TaskInfo) { 
        pending.append(task)
    }

    private func processPendingTasks() {
        cancellable = $pendingTasks
                .debounce(for: 1.5, scheduler: RunLoop.main)
                .sink(receiveValue: { batch in 
                    // Iterate though elements and process events.
                })           
    }
}
</code></pre>
<p><strong>Issue:</strong> This works fine, but the issue that I've is that it performs unnecessary view updates since the array is tagged <code>@Published</code>.</p>
<p><strong>What I'm looking for:</strong> The ideal approach would be a streaming setup where I get all events (in a batched fashion) but the <code>sink</code> should wait exactly for 1.5 seconds after the last event was added.</p>
<p>I tried <code>PassthroughSubject</code>, but it seems like it only gets me the last event that happened in the last 1.5 seconds.</p>
","3437352","","","","","2021-12-25 18:28:33","Creating a sequential publisher in Swift Combine","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"70533831","1","70533906","","2021-12-30 15:51:49","","-3","203","<p>I have the following function <code>loadData</code> and I want to use it within <code>refreshable</code> of a SwiftUI list. For this I need to make it an <code>async</code> function:</p>
<pre><code>func loadData() {
  // Publishers
  let followersPublisher = modelLoader.loadAllFollowers(withId: id)
  let followingPublisher = modelLoader.loadAllFollowing(withId: id)
  let friendshipsPublisher = Publishers.Zip(followersPublisher, followingPublisher)
    .share()
    .eraseToAnyPublisher()

  // Sinks
  getFollowers(from: followersPublisher)
  getFollowerChange(
    from: followersPublisher,
    cachedFollowers: followers
  )
  getFollowing(from: followingPublisher)
  getNotFollowingUserBack(from: friendshipsPublisher)
  getUserNotFollowing(from: friendshipsPublisher)

  followersPublisher
    .connect()
    .store(in: &amp;cancellables)
  followingPublisher
    .connect()
    .store(in: &amp;cancellables)
}
</code></pre>
<p>Within this function, all the separate functions use <code>Publisher</code> sinks. For example:</p>
<pre><code>private func getFollowing(from publisher: Publishers.MakeConnectable&lt;AnyPublisher&lt;Set&lt;User&gt;, Never&gt;&gt;) {
  publisher
    .sink(
      receiveCompletion: { _ in },
      receiveValue: { [weak self] following in
        self?.following = following
      }
    )
    .store(in: &amp;cancellables)
}
</code></pre>
<p>How can I turn it into an <code>async</code> function so I can use <code>await</code> with it?</p>
","362840","","362840","","2021-12-30 15:58:01","2021-12-30 23:19:06","Turning function that has a combination of publishers/sinks into an async function","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"70550104","1","70550166","","2022-01-01 16:11:53","","-2","262","<p>I want to learn Combine framework for Swift and I have found a tutorial video:
<a href=""https://www.youtube.com/watch?v=hbY1KTI0g70"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=hbY1KTI0g70</a></p>
<p>Unfortunately, I get:</p>
<pre><code>No exact matches in call to initializer 
</code></pre>
<p>error on the line which defines tableView and some other errors when I try to call the tableView, but I hope they will resolve after I fix the issue with initialising this element.</p>
<p>The code:</p>
<pre><code>import UIKit
import Combine

class MyCustomTableCell: UITableViewCell{ }

class ViewController: UIViewController, UITableViewDataSource {
    
    private let tableView = UITableView {
        let table = UITableView()
        table.register(MyCustomTableCell.self,
                       forceCellReuseIdentifier: &quot;cell&quot;)
        return table
    }()
</code></pre>
<p>(...)</p>
<pre><code>override func viewDidLoad() {
        super.viewDidLoad()
        view.addSubview(tableView)
        tableView.dataSource = self
        tableView.frame = view.bounds
</code></pre>
<p>(...)</p>
<pre><code> func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        return models.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
        guard let cell = tableView.dequeueReusableCell(withIdentifier: &quot;cell&quot;, for: indexPath) as? MyCustomTableCell else {
            fatalError()
        }
        cellTextLabel?.text = models(indexPath.row)
        return cell
    }
</code></pre>
<p>The whole code is long as hell. That is why I copied only the crucial parts of it (where the tableView occurs).
You can see the full code in the video:</p>
<p><a href=""https://www.youtube.com/watch?v=hbY1KTI0g70"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=hbY1KTI0g70</a></p>
","14224948","","","","","2022-01-01 16:24:18","No exact matches in call to initializer in tableView","<ios><swift><xcode><xcode-storyboard>","1","0","","","","CC BY-SA 4.0"
"70559235","1","70559539","","2022-01-02 19:50:04","","0","594","<p>I'm doing login using SwiftUI and Combine. Could you please give me some idea how can I decode and show json error when user types incorrect email or password? I can only get token.</p>
<p>When I'm doing the same login request with incorrect email or password, server returns me this error message:</p>
<pre><code>{
&quot;code&quot;: &quot;[jwt_auth] incorrect_password&quot;,
&quot;message&quot;: &quot;Incorrect password!&quot;,
&quot;data&quot;: {
    &quot;status&quot;: 403
}
</code></pre>
<p>}</p>
<p>The problem is that I can't understand how can I decode two different json responses when doing one request in Combine? I can only get token.</p>
<p>Here's model for login request:</p>
<pre><code>struct LoginResponse: Decodable {
let token: String }

struct ErrorResponse: Decodable {
    let message: String
}
struct Login: Codable {
    let username: String
    let password: String
}

static func login(email: String, password: String) -&gt; AnyPublisher&lt;LoginResponse, Error&gt; {
    let url = MarketplaceAPI.jwtAuth!
    var request = URLRequest(url: url)

    let encoder = JSONEncoder()
    let login = Login(username: email, password: password)
    let jsonData = try? encoder.encode(login)
    
    request.httpBody = jsonData
    request.httpMethod = HTTPMethod.POST.rawValue
    request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
    
    return URLSession.shared
        .dataTaskPublisher(for: request)
        .print()
        .receive(on: DispatchQueue.main)
        .map(\.data)
        .decode(
          type: LoginResponse.self,
          decoder: JSONDecoder())
        .eraseToAnyPublisher()
}
</code></pre>
<p>And in viewModel:</p>
<pre><code>MarketplaceAPI.login(email: email, password: password)
        .sink(
          receiveCompletion: { completion in
              switch completion {
              case .finished:
                  print(&quot;finished&quot;)
              case .failure(let error):
                  print(&quot;Failure error:&quot;, error.localizedDescription) // This's returning token error 
              }
          },
          receiveValue: { value in
              print(&quot;Token:&quot;, value.token)
             }
          })
        .store(in: &amp;subscriptions)
}
</code></pre>
","10949504","","12299030","","2022-01-02 19:57:35","2022-01-02 20:29:31","How to decode error response message in Combine?","<swift><combine>","2","4","","","","CC BY-SA 4.0"
"70564097","1","70564279","","2022-01-03 10:01:00","","0","117","<p>The example code here is very simple. Sliders update double values but not the other way around. Using Combine how to update two or more sliders on each other?</p>
<pre class=""lang-swift prettyprint-override""><code>struct Centimeters {
    var value: Double
    
    func updateInches() -&gt; Double {
        return value / 2.54
    }
}

struct Inches {
    var value: Double
    
    func updateCentimeters() -&gt; Double {
        return value * 2.54
    }
}

class SizeValueModel: ObservableObject {
    @Published var centimeters: Centimeters
    @Published var inches: Inches
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        self.centimeters = Centimeters(value: 1.0)
        self.inches = Inches(value: 0.393701)
        
        $centimeters.sink {
            self.inches.value = $0.updateInches()
        }.store(in: &amp;cancellables)
        
//        $inches.sink {
//            self.centimeters.value = $0.updateCentimeters()
//        }.store(in: &amp;cancellables)
    }
}

struct ContentView: View {
    @StateObject var model = SizeValueModel()
    var body: some View {
        Slider(value: $model.centimeters.value, in: 0...100, label: {
            Text(&quot;\(model.centimeters.value)&quot;)
        })
        Slider(value: $model.inches.value, in: 0...39.3701, label: {
            Text(&quot;\(model.inches.value)&quot;)
        })
    }
}
</code></pre>
","5941807","","","","","2022-01-03 11:07:43","Combine: update values each other","<swift><swiftui><combine>","2","2","","","","CC BY-SA 4.0"
"70567804","1","70568210","","2022-01-03 15:14:56","","0","136","<p>I have the following extension on a <code>Publisher</code> which allows me to paginate a URL request. I originally used this in a specific use case, where the <code>Output</code> of the publisher was of type <code>CustomType</code>.</p>
<pre><code>extension Publisher where Output == CustomType,
                          Failure == Error {
  func paginate(pageIdPublisher: CurrentValueSubject&lt;String?, Never&gt;) -&gt; AnyPublisher&lt;[User], Never&gt; {
    return self
      .handleEvents(receiveOutput: { response in
        if let maxId = response.pageId {
          pageIdPublisher.send(maxId)
        } else {
          pageIdPublisher.send(completion: .finished)
        }
      })
      .reduce([]) { allUsers, response in
        return response.users + allUsers
      }
      .catch { error in
        Just([])
      }
      .eraseToAnyPublisher()
  }
}

struct CustomType: Codable {
  let users: [User]
  let pageId: String?
}
</code></pre>
<p>This is called like this:</p>
<pre><code>func loadItem() async throws -&gt; [String] {
  let pageIdPublisher = CurrentValueSubject&lt;String?, Never&gt;(nil)

  return try await pageIdPublisher
    .flatMap { pageId in
      urlSession
        .publisher(
          for: .item(pageId: pageId),
          receiveOn: queue
        )
    }
    .paginate(pageIdPublisher: pageIdPublisher) // &lt;- This part
    .singleOutput()
}
</code></pre>
<p>However, I now want to make it generic so that it can be used on any <code>Output</code> type, so long as it has a <code>pageId</code> and some kind of array.</p>
<p>I tried using a protocol <code>Pageable</code> like this:</p>
<pre><code>protocol Pageable {
  associatedtype T

  var pageId: String? {get}
  var items: [T] {get}
}
</code></pre>
<p>But I can't use that with the extension because <code>Output</code> can't have be used with a protocol that contains an <code>associatedType</code>.</p>
<p>Is this possible?</p>
","362840","","362840","","2022-01-03 15:25:49","2022-01-03 16:02:39","How to make this publisher extension generic","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"70581043","1","70581155","","2022-01-04 15:17:17","","1","889","<p>I am rewriting my app that randomises the numbers from the set for SwiftUI with Combine.</p>
<pre><code>import SwiftUI
import Combine

private final class SomeViewState: ObservableObject {
        
        @Published var resultString = &quot;&quot;
        
    }
    
    struct SomeContent: View {
        
        @StateObject private var state = SomeViewState()
        
        func iterateAndRemove() -&gt; (Set&lt;Int&gt;, Set&lt;Int&gt;){
            var numbers = Set&lt;Int&gt;(1...50)
            var results = Set&lt;Int&gt;()
            for _ in 1...3{
                let randomNumbers = numbers.randomElement()!
                results.insert(randomNumbers)
                numbers.remove(randomNumbers)
            }
        return (numbers, results)
        }
        
        var body: some View {
            VStack{
                Text(&quot;Some Text&quot;)
                    (...)
                
                Text($state.resultString)
                    .multilineTextAlignment(.center)
                    .frame(width: 195, height: 70)
                    .background(Rectangle().fill(Color.white).shadow(radius: 3))
                    .padding()
                
                Button(&quot;Randomise&quot;) {
                
                    let runFunction = iterateAndRemove()
                    theResult = runFunction.1
                    state.resultString = theResult.map(String.init).joined(separator: &quot;, &quot;)
                    
                }.padding()
</code></pre>
<p>As stated in the title I get the</p>
<pre><code>Initializer 'init(_:)' requires that 'Binding&lt;String&gt;' conform to 'StringProtocol' SwiftUI Text
</code></pre>
<p>error. The only solutions I found in the Internet were for when the button throws such an error.
Please help!</p>
","14224948","","14224948","","2022-01-04 15:23:26","2022-01-04 15:25:00","Initializer 'init(_:)' requires that 'Binding<String>' conform to 'StringProtocol' SwiftUI Text","<swift><swiftui>","1","2","","","","CC BY-SA 4.0"
"70591138","1","70592267","","2022-01-05 10:14:19","","0","553","<p>Does anyone know how to chain together two publishers with Swift + Combine and keep the cancellable so that I can cancel the pipeline later?
I have a method that accepts input from a publisher and outputs to a publisher:</p>
<pre><code>static func connect(inputPublisher: Published&lt;String&gt;.Publisher, outputPublisher: inout Published&lt;String&gt;.Publisher) -&gt; AnyCancellable {
    inputPublisher.assign(to: &amp;outputPublisher)

    // Unfortunately assign consumes cancellable
}
</code></pre>
<p>Note that this method cannot access the wrapped properties directly. The publishers must be passed as arguments.</p>
","1040079","","","","","2022-01-05 11:41:58","How to chain together two Combine publishers in Swift and keep the cancellable object","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"70606132","1","70606343","","2022-01-06 11:03:49","","1","286","<p>I've created this publisher chain:</p>
<pre><code>enum ViewState {
  case loading, loaded([Person]), error(String)
}

var viewStatePublisher: AnyPublisher&lt;ViewState, Never&gt; {
  service.fetchPeople()
    .map { ViewState.loaded($0) }
    .eraseToAnyPublisher()
}
</code></pre>
<p><code>fetchPeople</code> can fail, and I'd like to propagate that down the publisher chain as a <code>ViewState.error(String)</code> value. Here's a rough idea of what I'm trying to do:</p>
<pre><code>service.fetchPeople()
  .mapError { error -&gt; AnyPublisher&lt;ViewState, Never&gt; in
    ViewState.error(error.localizedDescription)
  }
  .map { ViewState.loaded($0) }
  .eraseToAnyPublisher()
</code></pre>
<p>However, <code>mapError</code> doesn't work that way. I'm having trouble finding other alternatives to doing this.</p>
","6567226","","","","","2022-01-06 11:57:41","Combine - mapping errors to different types","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"70652026","1","70652184","","2022-01-10 11:57:13","","0","532","<p>Is there a way to pass a <code>@Published</code> variable as parameter to a function that needs access to both the current value of the variable and listen to any changes to the value?</p>
<p>Sample code:</p>
<pre><code>import Foundation
import Combine

class Player {
    @Published var progress = 0
}

class PlayerHandler {
    var cancellable: AnyCancellable?
    func send(progress: Int, progressPublisher: Published&lt;Int&gt;.Publisher) {
        print(&quot;Do something with current progress: \(progress)&quot;)

        cancellable = progressPublisher.sink {
            progr in
            print(&quot;Do something else with: \(progr)&quot;)
        }
    }
}

let handler = PlayerHandler()
let player = Player()
handler.send(progress: player.progress, progressPublisher: player.$progress)//Can I send this variable only once?
player.progress = 1
player.progress = 2
</code></pre>
<p>Here, I pass the <code>progress</code> variable as both an <code>Int</code> and as a <code>Published&lt;Int&gt;.Publisher</code>. Is there a way to pass the variable only once? How can I do that?</p>
<p>(I know, I could have used a <code>CurrentValueSubject</code> instead of a <code>@Published</code> variable, but I really like being able to access <code>progress</code> directly as allowed by @Published, instead of having to use <code>progress.value</code>)</p>
","653003","","","","","2022-01-10 12:11:00","Sending @Published variable as both value and Publisher","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"70664311","1","70748916","","2022-01-11 09:23:06","","0","192","<p>ObservableObject doesn't emit change events for nested observables by default. Here a nested settings object within a view model, which is then observed by a view.</p>
<p>In this small example, the <code>menu</code> doesn't see changes of <code>settings</code> (<code>enable</code> value). How to handle this behavior with Combine to propagate changes upwards in <code>ContentView</code>?</p>
<p>In other words, how to manually pipe changes from your nested models upwards to the dependent view: maybe introduce property wrappers in between to reduce the boiler plating involved?</p>
<pre class=""lang-swift prettyprint-override""><code>// Wrapper
@propertyWrapper struct UserDefault&lt;T: Codable&gt; {
    private let key: String
    private let defaultValue: T

    init(_ key: String, defaultValue: T) {
        self.key = key
        self.defaultValue = defaultValue
    }

    var wrappedValue: T {
        get {
            guard let data = UserDefaults.standard.object(forKey: key) as? Data else {
                return defaultValue
            }
            let value = try? JSONDecoder().decode(T.self, from: data)
            return value ?? defaultValue
        }
        set {
            let data = try? JSONEncoder().encode(newValue)
            UserDefaults.standard.set(data, forKey: key)
        }
    }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>// Values
final class UserSettings: ObservableObject {
    @UserDefault(&quot;itemA&quot;, defaultValue: true)
    var itemA: Bool { willSet { objectWillChange.send() } }

    @UserDefault(&quot;itemB&quot;, defaultValue: true)
    var itemB: Bool { willSet { objectWillChange.send() } }
    
    @UserDefault(&quot;itemC&quot;, defaultValue: true)
    var itemC: Bool { willSet { objectWillChange.send() } }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>// Model
struct Language: Identifiable, Hashable {
    var id: String
    var enable: Bool
}

enum Item: Identifiable, Hashable {
    var id: String {
        switch self {
        case .item(let language): return language.id
        }
    }
    case item(Language)
}

// ModelView
class ViewModel: ObservableObject {
    let settings = UserSettings()
    @Published var menu: [Item]
    var cancellables: [AnyCancellable] = []

    init() {
        menu = [.item(Language(id: &quot;a&quot;, enable: settings.itemA)),
                .item(Language(id: &quot;b&quot;, enable: settings.itemB)),
                .item(Language(id: &quot;c&quot;, enable: settings.itemC))]
    
        settings.objectWillChange.sink { [unowned self] in
            self.objectWillChange.send()
        }
        .store(in: &amp;cancellables)
    }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>// View
struct ContentView: View {
    @StateObject var model = ViewModel()

    var body: some View {
        HStack() {
            Button(&quot;toggle a \(model.settings.itemA.description)&quot;) { model.settings.itemA.toggle() }
            Button(&quot;toggle b \(model.settings.itemB.description)&quot;) { model.settings.itemB.toggle() }
            Button(&quot;toggle c \(model.settings.itemC.description)&quot;) { model.settings.itemC.toggle() }
        }
        Menu {
            ForEach(model.menu, id:\.self) { content in //// model.menu is not updated
                switch content {
                case let .item(language):
                    if language.enable { // the value doesn't update
                        Button(&quot;Item \(language.id)&quot;, action: {
                            print(language.id)
                        })
                    }
                }
            }
        } label: { Text(&quot;menu&quot;) }
    }
}
</code></pre>
","5941807","","5941807","","2022-01-13 20:44:02","2022-01-18 00:19:30","Updates changes for nested models","<swift><swiftui><combine>","1","6","","","","CC BY-SA 4.0"
"70673422","1","70674612","","2022-01-11 21:03:03","","1","48","<p>Apologies if the title is confusing. So, I'm implementing a chat app where there's a list of <code>ChatRow</code>s that would, upon clicking, entering into a <code>MessageView</code>. When a user sends a message, the list of <code>ChatRow</code>s may reorder because I order them in a way such that ones contain the latest messages are placed on the top.</p>
<p>The code looks roughly like this (let me know if more detail is needed):</p>
<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
    @EnvironmentObject var chatsManager: ChatsManager
    @EnvironmentObject var messagesManager: MessagesManager

     var body: some View {
         NavigationView{
             VStack{
                 // Some Views
                 VStack{
                     if chatsManager.chats.isEmpty{
                      Text(&quot;you have no chats for now&quot;).frame(maxHeight:.infinity, alignment: .top)
                     }
                     else {
                         List() {
                             ForEach($chatsManager.chats, id: \.id){ $chat in
                                 NavigationLink (destination:
                                           MessageView(chat: chat)
                                           .onAppear{messagesManager.fetchMessages(from: chat.id)}
                                 ){ ChatRow(chat: $chat) }
                             }
                     }.listStyle(.plain)
                 }
             }
         }.navigationBarTitle(&quot;&quot;).navigationBarHidden(true)
             
        }.navigationViewStyle(.stack)
            
     }
}
</code></pre>
<p>A very weird thing is that, if I click into chats that are within the viewport when <code>List</code> is scrolled to the top, everything would work perfectly (no auto popping-back, the <code>List</code> is updated properly when manually popped back).</p>
<p>But if I scroll down the list when the top few <code>ChatRow</code>s get scrolled away from the screen, I get popped back if I send any messages.</p>
<p>What I learned from searching the web was that <code>List</code> lazy loads elements, so that might be the cause of the problem. But I couldn't figure out a way to solve it.</p>
<h2>Code to reproduce the problem</h2>
<p>Just copy the following into one file and run.</p>
<p>Observe how things behave differently when you click into the first chat and click the button vs clicking into the last chat and click the button.</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

struct DebugView: View {
    
    @StateObject var chatsManager = ChatsManager()
    
     var body: some View {
         NavigationView{
             VStack{
                 HStack {
                 Text(&quot;Chats&quot;)
                 }.padding()
                 VStack{
                         List() {
                             ForEach($chatsManager.chats, id: \.id){ $chat in
                                         NavigationLink (destination:
                                                   ChatDetailView(chat: chat)
                                 ){ DemoChatRow(chat: $chat) }}

                     }.listStyle(.plain)
             }
         }.navigationBarTitle(&quot;&quot;).navigationBarHidden(true)
             
        }.navigationViewStyle(.stack)
             .environmentObject(chatsManager)
     }
}


struct DemoChatRow: View {
    @Binding var chat: Chat
    var body: some View {
        VStack{
            Text(chat.name)
            Text(chat.lastMessageTimeStamp, style: .time)
        }
        .frame(height: 50)
    }
}


struct ChatDetailView: View {
    var chat: Chat
    @EnvironmentObject var chatsManager: ChatsManager
    var body: some View {
        Button(action: {
            chatsManager.updateDate(for: chat.id)
        } ) {
            Text(&quot;Click to update the current chat to now&quot;)
        }
    }
}



class ChatsManager: ObservableObject {
    @Published var chats = [
        Chat(id: &quot;GroupChat 1&quot;, name: &quot;GroupChat 1&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat 2&quot;, name: &quot;GroupChat 2&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat 3&quot;, name: &quot;GroupChat 3&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat 4&quot;, name: &quot;GroupChat 4&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat 5&quot;, name: &quot;GroupChat 5&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat 6&quot;, name: &quot;GroupChat 6&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat 7&quot;, name: &quot;GroupChat 7&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat 8&quot;, name: &quot;GroupChat 8&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat 9&quot;, name: &quot;GroupChat 9&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat 10&quot;, name: &quot;GroupChat 10&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat2 5&quot;, name: &quot;GroupChat2 5&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat2 6&quot;, name: &quot;GroupChat2 6&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat2 7&quot;, name: &quot;GroupChat2 7&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat2 8&quot;, name: &quot;GroupChat2 8&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat2 9&quot;, name: &quot;GroupChat2 9&quot;, lastMessageTimeStamp: Date()),
        Chat(id: &quot;GroupChat2 10&quot;, name: &quot;GroupChat2 10&quot;, lastMessageTimeStamp: Date())].sorted(by: {$0.lastMessageTimeStamp.compare($1.lastMessageTimeStamp) == .orderedDescending})
    
    func updateDate(for chatID: String) {
        if let idx = chats.firstIndex(where: {$0.id == chatID}) {
            self.chats[idx] = Chat(id: chatID, name: self.chats[idx].name, lastMessageTimeStamp: Date())
         }
        self.chats.sort(by: {$0.lastMessageTimeStamp.compare($1.lastMessageTimeStamp) == .orderedDescending})
    }
    
        
}




struct Chat: Identifiable, Hashable {
    var id: String
    var name: String
    var lastMessageTimeStamp: Date
    
    static func == (lhs: Chat, rhs: Chat) -&gt; Bool {
        return lhs.id == rhs.id
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }

}


struct DebugView_Previews: PreviewProvider {
    static var previews: some View {
        DebugView().environmentObject(ChatsManager())
    }
}

</code></pre>
","4784433","","4784433","","2022-01-11 22:36:35","2022-01-11 23:26:34","NavigationLink pops out upon List update ONLY when List is not scrolled to the top","<swift><swiftui>","1","3","1","","","CC BY-SA 4.0"
"70687443","1","70687707","","2022-01-12 19:37:33","","4","548","<p>I am listening for changes of a publisher, then fetching some data asynchronously in my  pipeline and updating the view with the result. However, I am unsure how to make this testable. How can I best wait until the expectation has been met?</p>
<h2>View</h2>
<pre><code>struct ContentView: View {
    @StateObject var viewModel = ContentViewModel()

    var body: some View {
        NavigationView {
            List(viewModel.results, id: \.self) {
                Text($0)
            }
            .searchable(text: $viewModel.searchText)
        }
    }
}
</code></pre>
<h2>ViewModel</h2>
<pre><code>final class ContentViewModel: ObservableObject {
    @Published var searchText: String = &quot;&quot;
    @Published var results: [String] = []
    private var cancellables = Set&lt;AnyCancellable&gt;()

    init() {
        observeSearchText()
    }

    func observeSearchText() {
        $searchText
            .dropFirst()
            .debounce(for: 0.8, scheduler: DispatchQueue.main)
            .sink { _ in
                Task {
                    await self.fetchResults()
                }
            }.store(in: &amp;cancellables)
    }

    private func fetchResults() async {
        do {
            try await Task.sleep(nanoseconds: 1_000_000_000)
            self.results = [&quot;01&quot;, &quot;02&quot;, &quot;03&quot;]
        } catch {
            // 
        }
    }
}
</code></pre>
<h2>Tests</h2>
<pre><code>class ContentViewTests: XCTestCase {
    func testExample() {
        // Given
        let viewModel = ContentViewModel()

        // When
        viewModel.searchText = &quot;123&quot;

        // Then (FAILS - Not waiting properly for result/update)
        XCTAssertEqual(viewModel.results, [&quot;01&quot;, &quot;02&quot;, &quot;03&quot;])
    }
}
</code></pre>
<h2>Current Workaround</h2>
<p>If I make <code>fetchResults()</code> available I can async/await which works for my unit and snapshot tests, but I was worried that:</p>
<ol>
<li>It is bad practice to expose if it isn't to be called externally?</li>
<li>I'm not testing my publisher pipeline</li>
</ol>
<pre><code>func testExample_Workaround() async {
    // Given
    let viewModel = ContentViewModel()

    // When
    await viewModel.fetchResults()

    // Then
    XCTAssertEqual(viewModel.results, [&quot;01&quot;, &quot;02&quot;, &quot;03&quot;])
}
</code></pre>
","15477973","","","","","2022-07-27 17:46:21","SwiftUI Combine - How to test waiting for a publisher's async result","<swiftui><combine><swift-concurrency>","1","0","1","","","CC BY-SA 4.0"
"70715862","1","70716974","","2022-01-14 19:51:18","","0","116","<p>I'm trying to dynamically update a reference to an <code>@Published var</code>, but I'm not sure how to do it. Returning the value only is just a bool value and loses it's reference to the publisher and doesn't work. I tried returning the publisher itself (<code>$self.isBig</code>) but I can't seem to figure out how to update the value once I have the publisher instead of the @Published property.</p>
<p>I'm basically just trying to treat an <code>@Published</code> as a reference and update the reference on the class instead of copying the publisher's value.</p>
<p>This is a contrived example just trying to get the point across, what I want to do is:</p>
<pre><code>import UIKit
import Combine

class MyClass {
    
    struct MyData {
        enum MyDataType {
            case big
            case yellow
            case bird
        }
        var type: MyDataType
        var isEnabled: Bool
    }
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    @Published var isBig: Bool = false
    @Published var isYellow: Bool = false
    @Published var isBird: Bool = false
    
    var mySwitch = UISwitch()
    
    init() {
        // Add mySwitch and setupSubscribers...
    }

    func updatePublishers(from data: MyData) {
        let publisherForData = specificPublisherForData(data)
        // I want to access the underlying value for the @Published and set it here
//        publisherForData = data.isEnabled
    }

    func specificPublisherForData(_ data: MyData) -&gt; Published&lt;Bool&gt;.Publisher {
        switch data.type {
        case .big: return self.$isBig
        case .yellow: return self.$isYellow
        case .bird: return self.$isBird
        }
     }
    
    func setupSubscribers() {
        $isBig.sink { [weak self] isBig in
            guard let self = self else { return }
            
            self.mySwitch.isOn = isBig
        }.store(in: &amp;cancellables)
        
        // ... add subscribers for the other ones
    }
}
</code></pre>
","2338279","","560942","","2022-01-14 21:55:58","2022-01-14 21:58:47","Get reference for an @Published that can update the value","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"70718260","1","70718594","","2022-01-15 01:38:07","","-1","57","<p>I'm trying to use a generic modular function within Combine, but I'm getting the error that generic could not be inferred.</p>
<pre class=""lang-swift prettyprint-override""><code>func foo&lt;T&gt;(data: T) -&gt; AnyPublisher&lt;Bool, MyError&gt; {
    
}

func bar&lt;T&gt;(data: T) -&gt; AnyPublisher&lt;String, MyError&gt; {
    Deferred { [weak self] () -&gt; AnyPublisher&lt;Bool, MyError&gt; in
        guard let foo = self?.foo else { // error here
            return Fail(error: .someError)
                .eraseToAnyPublisher()
        }
        
        return foo(data)
    }
    .eraseToAnyPublisher()
    .flatMap { [weak self] (value) -&gt; AnyPublisher&lt;String, MyError&gt; in
        Future&lt;String, MyError&gt; { [weak self] promise in
            // do something with the returned value 
            promise(.success(&quot;Success&quot;))
        }
        .eraseToAnyPublisher()
    }
    .eraseToAnyPublisher()
}

enum MyError: Error {
    case someError
}

</code></pre>
<p>I'm getting the error when I'm trying to unwrap a function using a guard statement. <code>T</code> doesn't have constraints because it could be multiple disparate types like <code>Data</code> or <code>UIImage</code> which gets type checked within the <code>foo</code> function.</p>
","10116367","","","","","2022-01-15 03:13:56","Generic parameter 'T' could not be inferred when using a guard statement to unwrap a generic function","<ios><swift><generics>","1","2","","","","CC BY-SA 4.0"
"70736625","1","70740875","","2022-01-17 04:44:31","","0","120","<p>Could anyone please help me with configuring the Firebase signInAnonymously? In fact, I am able to login anonymously. However, whenever I start a new simulator I get the error &quot;There is no user logged in&quot;. The error disappears when restarting this new simulator, and then I am able to get the userId.</p>
<p>This is my initial code:</p>
<pre><code>import SwiftUI
import Firebase

@main
struct DyeNotesApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    var body: some Scene {
        WindowGroup {
            ContentView() 
        }
    }
}

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions laychOptions:
        [UIApplication.LaunchOptionsKey : Any]? = nil) -&gt; Bool {
        
        FirebaseApp.configure()
            if Auth.auth().currentUser == nil {
                Auth.auth().signInAnonymously()
            }
        
        return true
    }
}
</code></pre>
<p>This is the class talking to Firebase:</p>
<pre><code>class MainRepository: ObservableObject {
    private let path:String = &quot;MainCollection&quot;
    private let db = Firestore.firestore()
    @Published var model:[Model] = []
    
    init() {
        getData()
    }
    
    func getData() {
        if let userId = Auth.auth().currentUser?.uid {
            db.collection(path)
                .order(by: &quot;createdTime&quot;, descending: true)
                .whereField(&quot;userId&quot;, isEqualTo: userId)
                .addSnapshotListener { (snapshot, error) in
                    if let snapshot = snapshot {
                        self.model = snapshot.documents.compactMap{ document in
                            do {
                                let x = try document.data(as: Model.self)
                                return x
                            }
                            catch {
                                print(error)
                            }
                            return nil
                        }
                    }
                }
        } else {
            print(&quot;There is no user logged in&quot;)
        }
    }
</code></pre>
<p>I found a solution in a youtube video comment: &quot; ... capture the user id change via combine and trigger the snapshot monitoring when the user changes&quot;.
But I don't know how to implement it.</p>
<p>Could anyone help me with the code for this solution? How can I implement a snapshot to monitoring when user changes?</p>
","16471331","","209103","","2022-01-17 04:58:35","2022-01-18 12:12:11","Firebase signInAnonymously using SwiftUI","<google-cloud-firestore><swiftui><firebase-authentication><combine>","2","1","","","","CC BY-SA 4.0"
"70739978","1","70743653","","2022-01-17 10:38:57","","1","536","<p>Consider the following synthetic scenario:</p>
<pre><code>import Combine

let publisher1 = PassthroughSubject&lt;Int, Never&gt;().eraseToAnyPublisher()
let publisher2 = PassthroughSubject&lt;Int, Never&gt;()


publisher1.sink { value in
    publisher2.send(value)
}

</code></pre>
<p>We have 2 publishers, I'd like to propagate any value of the <code>publisher1</code> to the <code>publisher2</code>. The code I've shown does the job, but I'm interested whether there is a cleaner, declarative approach to this.</p>
<p>Note: both <code>publisher1</code> and <code>publisher2</code> are of the same type.</p>
<p><strong>Details on the problem</strong></p>
<p><code>publisher2</code> is a part of the API that is exposed by the &quot;core&quot; class. The &quot;core&quot; class has a &quot;has a&quot; relationship to a &quot;child&quot; class which in turn has a <code>publisher1</code> as it's API.</p>
<p>Over the lifetime of the &quot;core&quot; class, the &quot;child&quot; class can be allocated and deallocated multiple times. This should be transparent to the subscribers of the &quot;core&quot; class which won't need to subscribe to the <code>publisher2</code>.</p>
<p><strong>Code:</strong></p>
<pre><code>import UIKit
import Combine


class ChildClass {
    let publisher1 = PassthroughSubject&lt;Int, Never&gt;().eraseToAnyPublisher()
}

class CoreClass {
    let publisher2 = PassthroughSubject&lt;Int, Never&gt;()

    private var childClass: ChildClass?

    init() {
        allocateChildClass()
    }

    func allocateChildClass() {
        let child = ChildClass()
        childClass = child
        // Any way to simplify this?
        child.publisher1.sink { value in
            publisher2.send(value)
        }
    }

    func deallocateChildClass() {
        childClass = nil
    }
}


class Client {
    let core = CoreClass()

    init() {
        // Doesn't care about allocating or deallocating of the ChildClass
        core.publisher2.sink { value in
            print(value)
        }
    }
}

</code></pre>
<p>Trying to subscribe one publisher to another doesn't work:</p>
<pre><code>publisher2
    .subscribe(publisher1)

</code></pre>
<blockquote>
<p>No exact matches in call to instance method 'subscribe'</p>
</blockquote>
<p><a href=""https://i.stack.imgur.com/T8OIs.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/T8OIs.png"" alt=""enter image description here"" /></a></p>
","3667264","","3667264","","2022-01-17 14:29:02","2022-01-17 15:18:18","Swift Combine: direct output of one Publisher to the input of another","<ios><swift><combine><publisher>","1","14","","","","CC BY-SA 4.0"
"70763820","1","70764516","","2022-01-18 23:59:35","","0","68","<p>I am totally new at using the Combine framework.
The struct I am using:</p>
<pre><code>enum AuthenticateResponse: Decodable, Hashable {
    struct Success: Decodable, Hashable {
        let url, id, firstName, lastName: String
        let email, phone: String
    }

    struct Failure: Decodable, Hashable {
        struct Errors: Decodable, Hashable {
            let code: [String]?
            let username: [String]?
            let password: [String]?
        }
        let message: String
        let errors: Errors
    }

    case success(Success)
    case failure(Failure)
    init(from decoder: Decoder) throws {
        do {
            let success = try Success(from: decoder)
            self = .success(success)
        } catch {
            let failure = try Failure(from: decoder)
            self = .failure(failure)
        }
    }
}
</code></pre>
<p>I am getting this response from server:</p>
<pre><code>failure(demo.AuthenticateResponse.Failure(
    message: &quot;Invalid data..&quot;, 
    errors: demo.AuthenticateResponse.Failure.Errors(
        code: Optional([&quot;The code does not exist.&quot;]), 
        username: nil, 
        password: nil)
    )
)
</code></pre>
<p>I am trying to get this value <code>code: Optional([&quot;The code does not exist.&quot;]),</code> from above response using combine but I couldn’t</p>
<p>I am using below code to get that value:</p>
<pre><code>func syncOnlineData() {
    print(&quot;I am here&quot;)
    viewModel.authenticateResponse
        .sink { result in
            print(&quot;result: \(result)&quot;)
        } receiveValue: { res in
            print(&quot;value: \(String(describing: res))&quot;)
        }
} 
</code></pre>
<p>main response from server:</p>
<pre><code>[&quot;errors&quot;: {
    code =     (
        &quot;The code does not exist.&quot;
    );
}, &quot;message&quot;: Invalid data.]
</code></pre>
<p>How I will get the value from <code>code</code> ?</p>
","3231139","","465446","","2022-01-19 01:57:57","2022-01-20 01:03:40","How to get unwrap value using combine framework","<json><swift><combine>","2","2","","","","CC BY-SA 4.0"
"70782894","1","70787272","","2022-01-20 08:28:17","","1","205","<p>How to make a mechanism similar to binding in the view that refers to the Published in the ObservableObject class, but between 2 classes? That is, from class A, call the class B constructor, passing the prop1 from class A. And in class B prop2 exists, and these prop1 and prop2 should mirror each other.</p>
<p>PS: Attached code does not work, just visually show what I want ...</p>
<p>PPS: prop1 in ClassA and prop2 in ClassB, must be Published by condition. It's own views are also subscribed on it.</p>
<p>PPPS: Important to have any binding logic inside the ClassB, for easy reuse.</p>
<pre><code>class ClassA: ObservableObject {
    @Published var prop1: Bool = false //When prop1 changed, it must be reflected in prop2
    let classB: ClassB

    init() {
        classB = .init(prop2: _prop1) //Should stay that simple, no setup here, passing only property, ClassB doesn't know about ClassA.
    }
}

class ClassB: ObservableObject {
    @Published var prop2: Bool //When prop2 changed, it must be reflected in prop1

    init(prop2: Published&lt;Bool&gt;) {
        _prop2 = prop2
    }
}
</code></pre>
","7147231","","7147231","","2022-01-20 15:08:29","2022-01-21 15:21:18","How to bind properties between two classes with Combine?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"70793168","1","70804428","","2022-01-20 20:45:33","","0","133","<p>I have a view model, that has multiple child view models. I am fairly new to watchOS, SwiftUI and Combine - taking this opportunity to learn.</p>
<p>I have a watchUI where it has</p>
<ol>
<li>Play Button (View) - <code>SetTimerPlayPauseButton</code></li>
<li>Text to show Time (View) - <code>TimerText</code></li>
<li>View Model - that has 1 <code>WatchDayProgramViewModel</code> - N: <code>ExerciseTestClass</code> - N: <code>SetInformationTestClass</code>. For each ExerciseSets, there is a <code>watchTimer &amp; watchTimerSubscription</code> and I have managed to run the timer to update remaining rest time.</li>
<li>ContentView - that has been injected the ViewModel as <code>EnvironmentObject</code></li>
</ol>
<p>If I tap <code>SetTimerPlayPauseButton</code> to start the timer, timer is running, working and changing the remainingRestTime(property within the child view model <code>SetInformationTestClass</code>) correctly, <strong>but the updates/changes are not being &quot;published&quot; to the <code>TimerText</code> View</strong>.</p>
<p>I have done most, if not all, the recommendation in other SO answers, <strong>I even made all my <code>WatchDayProgramViewModel</code> and <code>ExerciseTestClass</code>,<code>SetInformationTestClass</code> properties <code>@Published</code>, but they are still not updating the View</strong>, when the view model properties are updated as shown in the Xcode debugger below.</p>
<p><a href=""https://i.stack.imgur.com/bNYuI.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bNYuI.png"" alt=""enter image description here"" /></a></p>
<p>Please review my code and give me some advice on how to improve it.</p>
<p><em><strong>ContentView</strong></em></p>
<pre><code>struct ContentView: View {
    @State var selectedTab = 0
    @StateObject var watchDayProgramVM = WatchDayProgramViewModel()
    
    var body: some View {
        
        TabView(selection: $selectedTab) {
            
            SetRestDetailView().id(2)
    
        }
        .environmentObject(watchDayProgramVM)
        .tabViewStyle(PageTabViewStyle())
        .indexViewStyle(.page(backgroundDisplayMode: .automatic))
        
    }
}

    
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            ContentView(watchDayProgramVM: WatchDayProgramViewModel())
        }
    }
}
</code></pre>
<p><em><strong>SetRestDetailView</strong></em></p>
<pre><code>import Foundation
import SwiftUI
import Combine

struct SetRestDetailView: View {
    
    @EnvironmentObject var watchDayProgramVM: WatchDayProgramViewModel
    
    var setCurrentHeartRate: Int = 120
    @State var showingLog = false
    
    
    var body: some View {


                    HStack {
         
                        let elapsedRestTime = watchDayProgramVM.exerciseVMList[0].sets[2].elapsedRestTime
                        let totalRestTime = watchDayProgramVM.exerciseVMList[0].sets[2].totalRestTime
                        
                        TimerText(elapsedRestTime: elapsedRestTime, totalRestTime: totalRestTime, rect: rect)
                            .border(Color.yellow)

                    }
                    
                    HStack {
                        
                        SetTimerPlayPauseButton(isSetTimerRunningFlag: false,
                                                playImage: &quot;play.fill&quot;,
                                                pauseImage: &quot;pause.fill&quot;,
                                                bgColor: Color.clear,
                                                fgColor: Color.white.opacity(0.5),
                                                rect: rect) {
                            
                            print(&quot;playtimer button tapped&quot;)
                            self.watchDayProgramVM.exerciseVMList[0].sets[2].startTimer()
                            
                            
                            let elapsedRestTime = watchDayProgramVM.exerciseVMList[0].sets[2].elapsedRestTime
                            let totalRestTime = watchDayProgramVM.exerciseVMList[0].sets[2].totalRestTime
                            print(&quot;printing elapsedRestTime from SetRestDetailView \(elapsedRestTime)&quot;)
                            print(&quot;printing elapsedRestTime from SetRestDetailView \(totalRestTime)&quot;)
                            
                        }
                            .border(Color.yellow)

                    }

 }

}
</code></pre>
<p><em><strong>TimerText</strong></em></p>
<pre><code>struct TimerText: View {
    var elapsedRestTime: Int
    var totalRestTime: Int
    var rect: CGRect
    
    var body: some View {
        VStack {
            Text(counterToMinutes())
                .font(.system(size: 100, weight: .semibold, design: .rounded))
                .kerning(0)
                .fontWeight(.semibold)
                .minimumScaleFactor(0.25)
                .padding(-1)
        }
    }
    
    func counterToMinutes() -&gt; String {
        let currentTime = totalRestTime - elapsedRestTime
        let seconds = currentTime % 60
        let minutes = Int(currentTime / 60)
        
        if currentTime &gt; 0 {
            return String(format: &quot;%02d:%02d&quot;, minutes, seconds)
        }
        
        else {
            return &quot;&quot;
        }
    }
}
</code></pre>
<p><em><strong>ViewModel</strong></em></p>
<pre><code>import Combine

final class WatchDayProgramViewModel: ObservableObject {
    
    @Published var exerciseVMList: [ExerciseTestClass] = [
 (static/hard-coded values for testing)
]

class ExerciseTestClass: ObservableObject {
    
    init(exercise: String, sets: [SetInformationTestClass]) {
        
        self.exercise = exercise
        self.sets = sets
        
    }
    
        var exercise: String
        @Published var sets: [SetInformationTestClass]
    
    }

class SetInformationTestClass: ObservableObject {
    
    init(totalRestTime: Int, elapsedRestTime: Int, remainingRestTime: Int, isTimerRunning: Bool) {
        
        self.totalRestTime = totalRestTime
        self.elapsedRestTime = elapsedRestTime
        self.remainingRestTime = remainingRestTime
        self.isTimerRunning = isTimerRunning
        
    }
    
    @Published var totalRestTime: Int
    @Published var elapsedRestTime: Int
    @Published var remainingRestTime: Int
    
    @Published var isTimerRunning = false
    @Published var watchTimer = Timer.publish(every: 1.0, on: .main, in: .default)
    @Published var watchTimerSubscription: AnyCancellable? = nil
    
    @Published private var startTime: Date? = nil
    
    
    func startTimer() {
        
        print(&quot;startTimer initiated&quot;)
        self.watchTimerSubscription?.cancel()
        
        if startTime == nil {
            startTime = Date()
        }
        
        self.isTimerRunning = true
        
        self.watchTimerSubscription = watchTimer
            .autoconnect()
            .sink(receiveValue: { [weak self] _ in
                
                guard let self = self, let startTime = self.startTime else { return }
                
                let now = Date()
                let elapsedTime = now.timeIntervalSince(startTime)
                
                self.remainingRestTime = self.totalRestTime - Int(elapsedTime)
                
                self.elapsedRestTime = self.totalRestTime - self.remainingRestTime
                                                    
                guard self.remainingRestTime &gt; 0 else {
                        self.pauseTimer()
                        return
                    }

self.objectWillChange.send()
                
                print(&quot;printing elapsedRest Time \(self.elapsedRestTime) sec&quot;)
                print(&quot;printing remaining Rest time\(self.remainingRestTime)sec &quot;)
                
            })
    }
    
    func pauseTimer() {
        //stop timer and retain elapsed rest time
        
        print(&quot;pauseTimer initiated&quot;)
        self.watchTimerSubscription?.cancel()
        self.watchTimerSubscription = nil
        self.isTimerRunning = false
        self.startTime = nil
        
    }
    
        
</code></pre>
","9104286","","9104286","","2022-01-21 16:07:05","2022-01-21 16:23:11","Timer within EnvironmentObject view model not updating the View","<mvvm><swiftui><combine><observableobject><environmentobject>","1","8","0","","","CC BY-SA 4.0"
"70806286","1","70806434","","2022-01-21 18:51:59","","0","1567","<p>I am making a Slider based on a view model, but I am facing this error message <code>Initializer 'init(value:in:step:label:minimumValueLabel:maximumValueLabel:onEditingChanged:)' requires that 'Int.Stride' (aka 'Int') conform to 'BinaryFloatingPoint'</code></p>
<p><a href=""https://i.stack.imgur.com/GsGLh.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GsGLh.png"" alt=""enter image description here"" /></a></p>
<p>It is strange because converting the integer from view model into Double doesn't quite do the trick.</p>
<p>I found very similar question and read the SO answer (<a href=""https://stackoverflow.com/questions/68315904/how-can-i-make-int-conform-to-binaryfloatingpoint-or-double-cgfloat-conform-to-b"">How can I make Int conform to BinaryFloatingPoint or Double/CGFloat conform to BinaryInteger?</a>), but it doesn't seem like I can implementation the solution for my case, probably because I am using <code>ObservedObject</code> for the  view model.</p>
<p>If I remove <code>$</code> in front of <code>setInformationVM.elapsedRestTime</code>, I would see another error message saying <code>Cannot convert value of type 'Int' to expected argument type 'Binding&lt;Int&gt;'</code></p>
<p>They said &quot;Binding are generally used when there is a need for 2-way communication&quot; - would that mean the Slider needs a way to communicate/update back to the View Model? <strong>Why is it that the Slider was accepting <code>@State private var xx: Double</code> for the value in general , but not a simple integer from my view model?</strong></p>
<pre><code>import Foundation
import SwiftUI
import Combine

struct SetRestDetailView: View {
    
    @EnvironmentObject var watchDayProgramVM: WatchDayProgramViewModel

    @State var showingLog = false

    var body: some View {

            GeometryReader { geometry in

             ZStack() {
                    (view content removed for readability)
              }

        .sheet(isPresented: $showingLog) {
            
            let setInformatationVM = self.watchDayProgramVM.exerciseVMList[0].sets[2]
            
            setLoggingView(setInformationVM: setInformatationVM, restfullness: 3, stepValue: 10)
        }
        
    }
}

</code></pre>
<p><em><strong>setLoggingView</strong></em></p>
<pre><code>struct setLoggingView: View {
    
    @Environment(\.dismiss) var dismiss
    
    @ObservedObject var setInformationVM: SetInformationTestClass
    @State var restfullness: Int
    var stepValue: Int
    
    var body: some View {
        
        GeometryReader { geometry in
            
            let rect = geometry.frame(in: .global)
            
            ScrollView {
                
                VStack(spacing: 5) {
                    
                    Text(&quot;Rested  \(Int(setInformationVM.elapsedRestTime)) sec&quot;)
                    
                    Slider(value: $setInformationVM.elapsedRestTime,
                           in: 0...setInformationVM.totalRestTime,
                           step: Int.Stride(stepValue),
                           label: {
                        Text(&quot;Slider&quot;)
                    }, minimumValueLabel: {
                        Text(&quot;-\(stepValue)&quot;)
                    }, maximumValueLabel: {
                        Text(&quot;+\(stepValue)&quot;)
                    })
                        .tint(Color.white)
                        .padding(.bottom)

                    Divider()

                    Spacer()
                    
                    Text(&quot;Restfullness&quot;)
                        .frame(minWidth: 0, maxWidth: .infinity)
                    
                    restfullnessStepper(rect: rect, maxRestFullness: 5, minRestFullness: 1, restfullnessIndex: restfullness)
                
                    Button(action: {
                        print(&quot;Update Button Pressed&quot;)
                        
                        //TODO
                        //perform further actions to update restfullness metric and elapsed rest time in the viewmodels before dismissing the view, and also update the iOS app by synching the view model.
                        
                        dismiss()
                        
                    }) {
                        HStack {
                            Text(&quot;Update&quot;)
                                .fontWeight(.medium)
                        }
                    }
                    .cornerRadius(40)
                    
                }
                .border(Color.yellow)
            }
        }
    }
</code></pre>
<p><em><strong>SetInformationTestClass view model</strong></em></p>
<pre><code>class SetInformationTestClass: ObservableObject {
    
    init(totalRestTime: Int, elapsedRestTime: Int, remainingRestTime: Int, isTimerRunning: Bool) {
        
        self.totalRestTime = totalRestTime
        self.elapsedRestTime = elapsedRestTime
        self.remainingRestTime = remainingRestTime
        
    }
    
    @Published var totalRestTime: Int
    @Published var elapsedRestTime: Int
    @Published var remainingRestTime: Int
    
    
</code></pre>
","9104286","","560942","","2022-01-21 19:25:19","2022-01-21 19:25:19","Initializer 'xxx' requires that 'Int' conform to 'BinaryFloatingPoint'","<swift><mvvm><swiftui><binding>","1","3","","","","CC BY-SA 4.0"
"70809030","1","70814658","","2022-01-22 00:29:25","","3","361","<p>I am trying to acquaint myself with unit testing some view models in SwiftUI. The view model currently has two <code>@Published</code> boolean values that publish changes when an underlying <code>UserDefaults</code> property changes. For my unit tests, I have followed <a href=""https://www.swiftbysundell.com/tips/avoiding-mocking-userdefaults/"" rel=""nofollow noreferrer"">this guide</a> on how to setup <code>UserDefaults</code> for testing so my production values are not modified. I am able to test the default value as such:</p>
<pre><code>func testDefaultValue() {
     XCTAssertFalse(viewModel.canDoThing)
}
</code></pre>
<p>How would I go about toggling the <code>@Published</code> value then ensuring my view model has received the changes? So for instance, I have a reference to my mock user defaults in my XCTestCase. I attempted to do the following with zero success:</p>
<pre><code>func testValueTogglesToTrue() {
     defaults.canDoThing = true
     XCTAssertTrue(viewModel.canDoThing)
</code></pre>
<p>}</p>
<p>The thought being that updating the underlying user defaults value that is publishing changes to the published value in the view model will notify our view model. The above does not do anything to the view model variable. Do I need to subscribe to the publisher and use sink to accomplish this?</p>
","1009085","","1009085","","2022-01-22 03:16:51","2022-01-23 00:46:13","Unit testing SwiftUI/Combine @Published boolean values","<unit-testing><swiftui><combine>","1","1","1","","","CC BY-SA 4.0"
"70857920","1","70863905","","2022-01-26 02:04:36","","0","238","<p>I am trying to figure out why the last .eraseToAnyPublisher() is giving the aforementioned error, to me it seems all the types are well specified, aren't they?</p>
<pre><code>static func searchUsers(query: String) -&gt; AnyPublisher&lt;[UserViewModel], Never&gt; {
            // prepare URL
            let urlString = &quot;\(baseURL)/search/users?q=\(query)&quot;
            guard let url = URL(string: urlString) else  {
                return Just([]).eraseToAnyPublisher()
            }
            // get handle of native data task publisher
            let publisher = URLSession.shared.dataTaskPublisher(for: url)
                .handleEvents(
                    receiveSubscription: { _ in
                        activityIndicatorPublisher.send(true)
                    }, receiveCompletion: { _ in
                        activityIndicatorPublisher.send(false)
                    }, receiveCancel: {
                        activityIndicatorPublisher.send(false)
                    })
                .tryMap { data, response -&gt; Data in
                    guard let httpResponse = response as? HTTPURLResponse,
                          httpResponse.statusCode == 200 else {
                              throw NetworkError.httpError
                          }
                    print(String(data: data, encoding: .utf8) ?? &quot;&quot;)
                    return data
                }
                .decode(type: SearchUserResponse.self, decoder: JSONDecoder())
                .map { $0.items }
                .flatMap({ users in
                    var userViewModels = [UserViewModel]()
                    users.forEach { user in
                        userViewModels.append(contentsOf: UserViewModel(with: user))
                    }
                    return userViewModels
                })
                .catch { err -&gt; Just&lt;[UserViewModel]&gt; in
                    print(err)
                    return Just([])
                }
                .eraseToAnyPublisher() // &lt;-- HERE IS THE ERROR
            return publisher
        }
</code></pre>
","720648","","","","","2022-01-26 13:08:12","Combine conversion from model to viewModel gives error ""Type of expression is ambiguous without more context when running .eraseToAnyPublisher()","<ios><swift><combine><publisher>","1","4","","","","CC BY-SA 4.0"
"70890755","1","70903682","","2022-01-28 08:28:29","","1","313","<p>I have successfully loaded an USDZ file to my scene. Now I want to add motion the ModelEntity. I have added PhysicsMotionComponent but it is not working. After Loading model it is static as usual. No movement. How to give an entity motion in RealityKit?</p>
<p>When I see the components I see that components are added. But The entity in not moving. What am I doing wrong?</p>
<p>My codes:</p>
<pre><code>import SwiftUI
import RealityKit
import ARKit
import Combine

struct ARViewContainer: UIViewRepresentable {
    
    
    func makeUIView(context: Context) -&gt; ARView {
        let arVIew = ARView(frame: .zero)
        context.coordinator.arVIew = arVIew
        arVIew.session.delegate = context.coordinator
        let config = ARWorldTrackingConfiguration()
        arVIew.session.run(config, options: [.resetTracking,.removeExistingAnchors])
        
        
        let anchorEntity = AnchorEntity()
 
        
        loadASingleModel(name:&quot;toy_biplane&quot;) { entity in
            if let entity = entity {

             let kinematics: PhysicsBodyComponent = .init(massProperties: .default,
                                                                           material: nil,
                                                                               mode: .kinematic)

                        let motion: PhysicsMotionComponent = .init(linearVelocity: [0.1 ,0, 0],
                                                                  angularVelocity: [3, 3, 3])

                        entity.components.set(kinematics)
                        entity.components.set(motion)
                anchorEntity.addChild(entity)
                //anchorEntity.transform.matrix.columns.3.z = -1.0
                arVIew.scene.anchors.append(anchorEntity)
                print(&quot;Model Added: &quot;,entity.name)

            }else{
                print(&quot;No entity avaible&quot;)
            }
        }

        return arVIew
    }
    

    // MARK: - AsychLoading working
    func loadASingleModel(name:String,completion:@escaping (_ model:ModelEntity?)-&gt;Void){
        
        var cancellable:AnyCancellable?
        cancellable = Entity.loadModelAsync(named:name)
                    .sink(receiveCompletion: { handler in
                        if case let .failure(error) = handler {
                            print(&quot;Unable to load a model due to error \(error)&quot;)
                        }
                        cancellable?.cancel()
                        completion(nil)

                    }, receiveValue: { [self] (model: ModelEntity?) in
                        if let model = model  {
                            cancellable?.cancel()
                            print(&quot;Congrats! Model is successfully loaded!&quot;)
                            completion(model)
                        }
                    })
    }
    
    func updateUIView(_ uiView: ARView, context: Context) {
        
    }
    
    func makeCoordinator() -&gt; Coordinator {
        Coordinator(arViewContainer: self)
    }
    
    class Coordinator:NSObject{
        var parent:ARViewContainer
        var arVIew:ARView?
        init(arViewContainer:ARViewContainer){
            parent = arViewContainer
        }
    }
}

extension ARViewContainer.Coordinator:ARSessionDelegate{
    
    func session(_ session: ARSession, didUpdate frame: ARFrame) {
        
    }
    
    
    
}
</code></pre>
","14733367","","6599590","","2022-01-29 08:54:50","2022-01-29 09:50:51","RealityKit – How to add motion to a loaded ModelEntity from USDZ file?","<swift><swiftui><augmented-reality><arkit><realitykit>","1","1","","","","CC BY-SA 4.0"
"70922400","1","70922870","","2022-01-31 07:21:35","","1","1130","<p>I'd like to be notified the moment all Combine publishers have done their work like <code>DispatchGroup</code> and <code>.notify</code> do.</p>
<p>For example, at the below codes, I want to show <code>ProgressView</code> while publishers(<code>pub1</code>, <code>pub2</code>) doing their job.</p>
<pre><code>import Combine
import Foundation
import SwiftUI

struct SwiftUIView: View {
    @State var isFinished = false
    let pub1 = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;].publisher
    let pub2 = [&quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;].publisher
    var subscriptions = Set&lt;AnyCancellable&gt;()

    var body: some View {
        if isFinished {
            Text(&quot;Hello, World!&quot;)
        } else {
            ProgressView()
        }
    }
    
    init() {
        pub1
            .sink { print($0) }
            .store(in: &amp;subscriptions)
        pub2
            .sink { print($0) }
            .store(in: &amp;subscriptions)
        
//         Where should I write this code?
//         isFinished = true
    }
}
</code></pre>
<p><strong>My question is</strong> that how can I wait until publishers finish and show &quot;Hello world&quot; at the right time?</p>
<p>Is there anything I should know? If so, please let me know. Thank you!</p>
","11768262","","","","","2022-01-31 08:37:28","How can I wait until all Combine publishers finished their jobs in Swift?","<ios><swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"70942952","1","70943016","","2022-02-01 15:14:48","","1","793","<p>Consider the following example:</p>
<pre><code>struct TestView: View {
    @Binding private var value: String
    init(value: Binding&lt;String&gt;) {
        self._value = value
    }
}
</code></pre>
<p>How can I initialize the <code>TestView</code> without any <code>Binding</code>, i.e. just bind it to an empty string (if the caller doesn't need to connect that property)?</p>
<p>Ideally I'd be able to use the <code>TestView</code> like this (sometimes):</p>
<pre><code>TestView()
</code></pre>
<p>I've tried setting a default value in the initializer, but obviously, it fails:</p>
<pre><code>init(value: Binding&lt;String&gt; = Binding&lt;Strings&gt;(&quot;&quot;)) {
</code></pre>
<p>Any approaches on how to tackle this API issue?</p>
","3667264","","","","","2022-02-01 15:19:17","SwiftUI: Binding in initializer: default value","<ios><swift><swiftui><binding><combine>","1","0","","2022-02-01 15:50:40","","CC BY-SA 4.0"
"70993274","1","70993353","","2022-02-04 21:57:20","","0","574","<p>I am subscribing to a @Published array in my view model so I can .map every object appended as an array of PostAnnotations...</p>
<p>I am not able to map the post array into an array of PostAnnotations and get the error:</p>
<p><strong>ERROR MESSAGE: Declared closure result '()' is incompatible</strong></p>
<p>What am I doing wrong??</p>
<pre><code>class UserViewModel: ObservableObject {
    var subscriptions = Set&lt;AnyCancellable&gt;()
    let newPostAnnotationPublisher = PassthroughSubject&lt;[PostAnnotation], Never&gt;()

    @Published var currentUsersPosts: [Posts] = []
  
    func addCurrentUsersPostsSubscriber() {
        $currentUsersPosts
             // convert each post into a PostAnnotation
            .map { posts -&gt; [PostAnnotation] in
                 // ^ERROR MESSAGE: Declared closure result '()' is incompatible 
                //with contextual type '[SpotAnnotation]'
                posts.forEach { post in
                    let postAnnotation = PostAnnotation(post: post)
                    return postAnnotation
                }
            }
            .sink { [weak self] postAnnotations in
                guard let self = self else { return }
                // send the array of posts to all subscribers to process
                self.newPostAnnotationsPublisher.send(postAnnotations)
            }
            .store(in: &amp;subscriptions)
    }

     func loadCurrentUsersPosts() {
         PostApi.loadCurrentUsersPosts { response in
             switch response {
             case .success(let posts):
                 self.currentUsersPosts.append(contentsOf: spots)
             case .failure(let error):
                 //////
             }
         }
     }

}
</code></pre>
","16636751","","","","","2022-02-04 22:06:27","Map array of objects into another array with Combine not working?","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"70994774","1","70994804","","2022-02-05 02:08:47","","1","249","<p>I'm trying to trigger an alert when is an error in the model but it never get updated to show the alert:</p>
<p>Here is my implementation in the view:</p>
<pre><code>struct ContentView: View {
    @ObservedObject var viewModel: ViewModel
    @State var showAlert = false
    init() {
        viewModel = ViewModel()
        showAlert = viewModel.showAlert
    }
    var body: some View {
        NavigationView {
            Text(&quot;Hello, world!&quot;)
                .padding()
        }
        .alert(isPresented: $showAlert) {
            Alert(title: Text(&quot;This works&quot;),
                  message: Text(&quot;Hello&quot;),
                  dismissButton: .default(Text(&quot;got it&quot;))
        )}
    }
}
</code></pre>
<p>Here is my models:</p>
<pre><code>class ViewModel: ObservableObject {
    @Published var showAlert = false
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        DoSomething.shared.showAlert.sink { _ in
            print(&quot;got new Value&quot;)
        } receiveValue: {[weak self] value in
            print(&quot;value&quot;)
            self?.showAlert = value
        }.store(in: &amp;cancellables)
    }
}
class DoSomething {
    let showAlert = PassthroughSubject&lt;Bool, Never&gt;()
    static let shared = DoSomething()
    private init() {
        checkToShowAlert()
    }
    func checkToShowAlert() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) { [weak self] in
            print(&quot;change value&quot;)
            self?.showAlert.send(true)
        }
    }
}
</code></pre>
<p>Any of you knows why the <code>showAlert</code> variable it never gets updated?</p>
<p>I'll really appreciate your help</p>
","2924482","","","","","2022-02-05 23:50:42","SwiftUI: @State variable never get updated from @Published","<ios><swift><swiftui><combine><xcode13.2>","2","0","","","","CC BY-SA 4.0"
"71050664","1","71050850","","2022-02-09 13:43:18","","0","26","<p>In RestManager class, using URLSession I want to return <em>AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt;</em>.</p>
<p>So I made this code</p>
<pre><code>class RestManager {

func fetchData&lt;T: Decodable&gt;(url: URL) -&gt; AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt; {
    
    return Future&lt;Result&lt;T, ErrorType&gt;, Never&gt; { promise in
        URLSession
            .shared
            .dataTask(with: url) { data, response, error in
                if let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 {
                    if let data = try? JSONDecoder().decode(T.self, from: data!){
                        promise(.success(.success(data)))
                    }else {
                        promise(.success(.failure(.empty)))
                    }
                }
                else if let error = error as? URLError {
                    switch error.code {
                    case .notConnectedToInternet, .networkConnectionLost, .timedOut:
                        promise(.success(.failure(.noInternetConnection)))
                    case .cannotDecodeRawData, .cannotDecodeContentData:
                        promise(.success(.failure(.empty)))
                    default:
                        break
                }
                }else {
                    promise(.success(.failure(.general)))
                }
            }
    }
    .eraseToAnyPublisher()
}
}
</code></pre>
<p>But when I call this function in viewModel it returns empty array, but there is not any error thrown.
I used breakpoints on <em>if</em> and <em>else</em> statements and program is actually not executing them.</p>
","16366914","","12299030","","2022-02-09 13:57:42","2022-02-09 13:57:42","dataTask in networking is not executing","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"71058511","1","71330621","","2022-02-10 00:40:48","","-1","150","<p>I have customized UITextfield which has clear textfield button on right accessory view.
clearbutton has textfield.text.removeAll() or textfield.text = &quot;&quot;</p>
<p>To monitor text changing on this textfield, I have added textPublisher like this.</p>
<pre><code>var textPublisher: AnyPublisher&lt;String, Never&gt; {
    NotificationCenter.default.publisher(
        for: UITextField.textDidChangeNotification,
        object: self
    )
    .compactMap { ($0.object as? UITextField)?.text }
    .eraseToAnyPublisher()
}
</code></pre>
<p>I would take UIButton enable assign with textfield text length.</p>
<pre><code>let button = UIButton()

textPublisher.sink { text in
     button.isEnabled = text.count &gt;= 2
}.store(in: &amp;cancellableSet)
</code></pre>
<p>This code is worked on UIKeyboardAction but not working on redeclare UITextfield.text programmatically. like clear button action what I added.
seems textDidChangeNotification event not fired when I put textfield.text = &quot;&quot;</p>
<p>where should I adapt combine publisher to monitor UITextfield text changed?</p>
","8051392","","","","","2022-03-03 00:00:58","where should I adapt combine publisher to monitor UITextfield text changed?","<swift><uitextfield><combine>","1","2","","","","CC BY-SA 4.0"
"71060365","1","71087788","","2022-02-10 05:49:49","","3","306","<p>Based on this answer: <a href=""https://stackoverflow.com/questions/62544115/what-is-the-difference-between-observedobject-and-stateobject-in-swiftui"">What is the difference between ObservedObject and StateObject in SwiftUI</a></p>
<p>And the Apple documentation code here: <a href=""https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app</a></p>
<p>In SwiftUI app, a <code>@StateObject</code> property wrapper should be used when a <code>View</code> instantiates the object itself, so that the object won't be recreated during a view update.</p>
<p>If the object is instantiated somewhere else, an <code>@ObservedObject</code> wrapper should be used instead.</p>
<p>However, there is a fine line which makes it a bit unclear: what if the object is instantiated somewhere else, but &quot;injected&quot; to the <code>View</code> and then the view is the sole owner / holder of that object? Should it be <code>@StateObject</code> or <code>@ObservedObject</code>?</p>
<p>Sample code to get the point illustrated:</p>
<pre><code>import SwiftUI
import Combine
import Foundation


struct ViewFactory {
    func makeView() -&gt; some View {
        let viewModel = ViewModel()
        return NameView(viewModel)
    }
}


final class ViewModel: ObservableObject {
    @Published var name = &quot;&quot;
    init() {}
}


struct NameView: View {

    // Should this be an `@ObservedObject` or `@StateObject`?
    @ObservedObject var viewModel: ViewModel

    init(_ viewModel: ViewModel) {
        self.viewModel = viewModel
    }

    var body: some View {
        Text(viewModel.name)
    }
}
</code></pre>
<p>Based on this article: <a href=""https://www.hackingwithswift.com/quick-start/swiftui/whats-the-difference-between-observedobject-state-and-environmentobject"" rel=""nofollow noreferrer"">https://www.hackingwithswift.com/quick-start/swiftui/whats-the-difference-between-observedobject-state-and-environmentobject</a></p>
<p>There is one important difference between @StateObject and @ObservedObject, which is ownership – which view created the object, and which view is just watching it.</p>
<p><em>The rule is this: whichever view is the first to create your object must use @StateObject, to tell SwiftUI it is the owner of the data and is responsible for keeping it alive. All other views must use @ObservedObject, to tell SwiftUI they want to watch the object for changes but don’t own it directly.</em></p>
<p>it appears that if the <code>View</code> to instantiate the <code>ViewModel</code>, it has to be declared with <code>@StateObject</code>. My code is very similar, the only difference is that the <code>ViewModel</code> is created elsewhere, but the <code>View</code> &quot;owns&quot; it after the initialization.</p>
","3667264","","","","","2022-02-11 23:53:08","@StateObject vs @ObservedObject when passed externally but owned by the view","<ios><swift><xcode><swiftui><combine>","1","10","","","","CC BY-SA 4.0"
"71064735","1","71069201","","2022-02-10 11:59:33","","0","510","<p>I need to apply some validations in my form like remove <em>special character</em>, accept only <em>number</em>, <em>alphabets</em>, <em>alphanumeric</em>, and only specific <em>length</em> of a string.</p>
<p>I have many text fields, in many places in my app. So that I'm creating extensions to Binding, and trying to apply conditions when editing.</p>
<p>These filters/conditions using for <code>@State</code>, <code>@Published</code>, and <code>@Binding</code> variables.</p>
<p>Here is my code:</p>
<pre class=""lang-swift prettyprint-override""><code>
struct ContentView: View {
    @State var name = &quot;&quot;
    var body: some View {
        InputField(text: $name)
    }
}

struct InputField: View {
    @Binding var text: String
    var body: some View {
        VStack {
            TextField(&quot;Name here...&quot;, text: $text.limit(6).alphaNumeric)
                .frame(maxWidth: .infinity, minHeight: 48,  alignment: .leading)
        }.padding()
    }
}

extension Binding where Value == String {
    
    var alphaNumeric: Binding&lt;String&gt; {
        Binding&lt;String&gt;(get: { self.wrappedValue },
                        set: {
            self.wrappedValue = $0.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)})
    }
    
    func limit(_ length: Int) -&gt; Binding&lt;String&gt; {
        Binding&lt;String&gt;(get: { self.wrappedValue },
                        set: {
            print($0.prefix(length))
            self.wrappedValue = String($0.prefix(length))
        })
    }
}
</code></pre>
<p>Here in the above code <code>$text.limit(6).alphaNumeric</code>, I'm trying to limit the <strong>length</strong> to <strong>6 characters</strong> and only allow the <strong>alphaNumeric</strong> string.</p>
","11997939","","11997939","","2022-02-10 16:30:00","2022-02-10 19:20:25","How to remove special characters from the `TextField` in SwiftUI","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"71076879","1","71078250","","2022-02-11 08:06:54","","1","80","<p>I am successfully loading USDZ file in my RealityKit scene asynchronously by using <a href=""https://developer.apple.com/documentation/realitykit/entity/3244093-loadmodelasync"" rel=""nofollow noreferrer"">LoadModelAsync</a>. I am using <strong>toy_biplane</strong> USDZ file provided by apple which has default animations. If I load model asynchronousely availableAnimations array is always empty!</p>
<p>My codes:</p>
<pre><code>func loadASingleModel(name: String, 
                completion: @escaping (_ model: ModelEntity?) -&gt; Void) {
        
    var cancellable: AnyCancellable?
    cancellable = Entity.loadModelAsync(named: name)
        .sink(receiveCompletion: { handler in
            if case let .failure(error) = handler {
                print(&quot;Unable to load a model due to error \(error)&quot;)
            }
            cancellable?.cancel()
            completion(nil)

        }, receiveValue: { [self] (model: ModelEntity?) in
            if let model = model  {
                cancellable?.cancel()
                print(&quot;Congrats! Model is successfully loaded!&quot;)
                print(model.availableAnimations, 
                      //Here availableAnimations is empty
                      &quot;Debug: Any Animation?&quot;)
                            completion(model)
            }
        })
    }
}
</code></pre>
<p>How to load USDZ file asynchronously with animations?</p>
","14733367","","6599590","","2022-02-11 10:10:15","2022-02-11 10:10:15","Available animations collection is empty, while using .loadModelAsync()","<swift><realitykit>","1","0","","","","CC BY-SA 4.0"
"71089458","1","71093346","","2022-02-12 06:19:04","","0","56","<p>I have a watchapp that receives parent view model (nested view model) data from iPhone via json/file transfer. I am using &quot;Communicator&quot; library by @KaneCheshire.</p>
<p>The data flow is</p>
<ol>
<li>Watch App launches - loading empty Parent View Model (<code>ReceivedDayProgViewModel</code>) into the app and showing activity indicator in <code>WatchLoadingView</code>.</li>
<li><code>WatchLoadingView</code> set-up observer to receive actual json data/file from iPhone</li>
<li><code>WatchLoadingView</code>'s observer receives actual json data, decodes them into ParentViewModel object (<code>ReceivedDayProgViewModel</code>)</li>
</ol>
<p>After step 3, I am having difficulty actually assigning the decoded object to the initially empty Parent View Model (<code>ReceivedDayProgViewModel</code>). There is a error message saying &quot;<code>**Cannot assign to property: 'receivedDayProgramVM' is a get-only property**</code>&quot;</p>
<p>So I did look up the error and have an idea that my parent View Model is actually a &quot;computed-property&quot; instead of stored property - <a href=""https://stackoverflow.com/questions/34071428/how-do-i-resolve-this-build-issue-cannot-assign-to-property-date-is-a-get-o"">How do I resolve this build issue - cannot assign to property: &#39;date&#39; is a get only property</a> <strong>But I am still struggling to add codes to ensure &quot;set/write&quot; function is embedded in the Parent View Model(<code>ReceivedDayProgViewModel</code>).</strong></p>
<p>Would appreciate any guidance/advice on how I can change my code to allow &quot;set/write&quot; operation in Parent View Model (<code>ReceivedDayProgViewModel</code>) so below step can be fulfilled.</p>
<ol start=""4"">
<li>Assign decoded object (<code>let ReceivedDayProgViewModel = try! decoder.decode(ReceivedDayProgViewModel.self, from: ReceivedDayProgVMData)</code>) (with values/data from iPhone) into the <code>@StateObject</code> in <code>ContentView</code>  (<code>receivedDayProgramVM</code>)</li>
</ol>
<p>Parent View Model</p>
<pre><code>import Foundation
import Combine

class ReceivedDayProgViewModel: ObservableObject, Codable {
    
    @Published var workoutModel = WorkoutModel()
    @Published var watchDayProgramSequence: Int = 0
    @Published var exerciseVM: [WatchExerciseViewModel] = []
    
    enum CodingKeys: String, CodingKey {
        
        case dayProgramSeq
        case exerciseVM
        
    }
    
    init() {
           //initiliazed empty view model via this function
    }
    
    required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        watchDayProgramSequence = try container.decode(Int.self, forKey: .dayProgramSeq)
        exerciseVM = try container.decode([WatchExerciseViewModel].self, forKey: .exerciseVM)
        
        do {
            watchDayProgramSequence = try container.decode(Int.self, forKey: .dayProgramSeq)
        } catch DecodingError.typeMismatch {
            do {
                watchDayProgramSequence = try Int(container.decode(String.self, forKey: .dayProgramSeq)) ?? 0
            }
        }
        
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(watchDayProgramSequence, forKey: .dayProgramSeq)
        try container.encode(exerciseVM, forKey: .exerciseVM)

    }//encode function ends
    
}
</code></pre>
<p>WatchApp</p>
<pre><code>import SwiftUI
import Communicator

@main
struct WatchApp: App {

    @SceneBuilder var body: some Scene {
        WindowGroup {
            NavigationView {
                ContentView(selectedTab: 0, receivedDayProgramVM: ReceivedDayProgViewModel())
            }
        }

        WKNotificationScene(controller: NotificationController.self, category: &quot;myCategory&quot;)
    }
}

</code></pre>
<p>ContentView</p>
<pre><code>import SwiftUI
import WatchKit
import Combine
import Communicator

struct ContentView: View {
    @State var selectedTab = 0
    
    @StateObject var receivedDayProgramVM = ReceivedDayProgViewModel()
    
    var body: some View {
        
        NavigationView {
            
            //Show WatchLoadingView, if dayprogramVM is being fetched
            if receivedDayProgramVM.exerciseVM.count == 0 {
                
                   WatchLoadingView()
                    .onAppear {
                        //Add Communicator functions if required
                         Blob.observe { Blob in

                             if Blob.identifier == &quot;dayProgramData&quot; {

                                 let ReceivedDayProgVMData = Blob.content
                                 print(&quot;WatchConnectivity blob setData printing \(ReceivedDayProgVMData)&quot;)

                                 let decoder = JSONDecoder()
                                 
                                 let ReceivedDayProgViewModel = try! decoder.decode(ReceivedDayProgViewModel.self, from: ReceivedDayProgVMData)
                                 
                                 //Assign decoded class(parent view model) to environment object in contentView
//This is the line that causes error showing receivedDayProgramVM is get-only property
                                 receivedDayProgramVM = ReceivedDayProgViewModel

                                 
                             } //Blob for &quot;dayProgramData&quot; code ends
                             
                             
                         } //Blob observation code ends
                    } else {
                
                TabView(selection: $selectedTab) {
                    
                    WatchControlView().id(0)
                    SetInformationView().id(1)
                    SetRestDetailView().id(2)
                    //Check if WatchControlView can be vertically scrollable
                    NowPlayingView().id(3)
                }
                .environmentObject(receivedDayProgramVM)
            }

        }
    }
}
            
</code></pre>
<p>WatchLoadingView</p>
<pre><code>import SwiftUI
import Communicator

struct WatchLoadingView: View {
    
    var body: some View {
        
        GeometryReader { geometry in
            
            let rect = geometry.frame(in: .global)
         
            VStack {
                ProgressView()
                Text(&quot;Fetching Data...&quot;)
                    .font(.body)
            }
        }
    }
}
</code></pre>
","9104286","","","","","2022-02-12 15:44:52","""xx"" is get-only property - How to Assign decoded Json Data to class (nested view model) Swift","<ios><json><swift><swiftui><computed-properties>","1","3","","","","CC BY-SA 4.0"
"71096170","1","71096196","","2022-02-12 21:52:55","","0","552","<p>Have the following situation.  I have a view model that is an observable object with a computed property of type Bool.  I want to be able to enable/disable a navigation link based on the computed property, but I need a binding to do so.  Here a simplified example:</p>
<pre><code>struct Project {
    var name: String
    var duration: Int
}

class MyViewModel: Observable Object {
    @Published var project: Project

    var isProjectValid: Bool {
        return project.name != &quot;&quot; &amp;&amp; project.duration &gt; 0
    }
}

struct MyView: View {
    @EnvironmentObject var myVM: MyViewModel

    var body: some View {
        ...
        NavigationLink(&quot;Click Link&quot;, isActive: ?????, destination: NextView())
        ...
    }
}
</code></pre>
<p>Since isActive expects a binding I am not able to access computed property such as myVM.isProjectValid.  Tried also with the computed property in project class, still same problem.</p>
<p>Also considered creating custom binding related to the computed property, but not quite sure if/how to go about it.</p>
<p>First question I have posted, so if I am missing some details please be kind :)</p>
","10303930","","10303930","","2022-02-12 22:09:18","2022-02-13 00:09:01","Swift binding to a computed property","<swift><swiftui><binding><combine><computed-properties>","2","0","1","","","CC BY-SA 4.0"
"71097477","1","71097572","","2022-02-13 02:38:08","","0","65","<p>I want to perform a background fetch and pass the result to closure. Currently I'm using <code>performBackgroundTask</code> method from <code>NSPersistentContainer</code> which is giving a <code>NSManagedObjectContext</code> as a closure. Then using that context I'm executing fetch request. When fetch is done I'm, passing the result to the completion handler.</p>
<pre><code>func getAllWorkspacesAsync(completion: @escaping ([Workspace]) -&gt; Void) {
    CoreDataStack.shared.databaseContainer.performBackgroundTask { childContext in
        let workspacesFetchRequest: NSFetchRequest&lt;Workspace&gt; = NSFetchRequest(entityName: &quot;Workspace&quot;)
        workspacesFetchRequest.predicate = NSPredicate(format: &quot;remoteId == %@&quot;, &quot;\(UserDefaults.lastSelectedWorkspaceId))&quot;)
        do {
            let workspaces: [Workspace] = try childContext.fetch(workspacesFetchRequest)
            completion(workspaces)
        } catch let error as NSError {
            // Handle error
        }
    }
}
</code></pre>
<p>I'm going to call this method from ViewModel and use Combine PassthroughSubject to notify the ViewController about the event.</p>
<pre><code>class WorkspaceViewModel {

    private var cancellables: Set&lt;AnyCancellable&gt; = []
    let resultPassthroughObject: PassthroughSubject&lt;[Workspace], Error&gt; = PassthroughSubject()

    private let cacheManager = WorkspaceCacheProvider.shared

    static public let shared: WorkspaceViewModel = {
        let instance = WorkspaceViewModel()
        return instance
    }()

    func fetchWorkspaces() {
        cacheManager.getAllWorkspacesAsync { [weak self] workspaces in
            guard let self = self else { return }
            self.resultPassthroughObject.send(workspaces)
        }
    }
}
</code></pre>
<p>And the ViewController code:</p>
<pre><code>class WorkspaceViewController: UIViewController {

    private var cancellables: Set&lt;AnyCancellable&gt; = []

    override func viewDidLoad() {
        super.viewDidLoad()
    
        WorkspaceViewModel.shared.resultPassthroughObject
            .receive(on: RunLoop.main)
            .sink { _ in } receiveValue: { workspaces in
            // update the UI
        }
        .store(in: &amp;cancellables)

    }
}
</code></pre>
<p>My question is: is it safe to pass NSManagedObject items?</p>
","11842636","","","","","2022-02-13 03:16:27","Passing ManagedObject collection from fetch result to closure up to ViewController","<ios><swift><core-data><nsmanagedobject><nsmanagedobjectcontext>","1","0","","","","CC BY-SA 4.0"
"71097740","1","71097813","","2022-02-13 03:44:50","","0","767","<p>If I have an array:</p>
<pre class=""lang-swift prettyprint-override""><code>var arr = [0,1,2]
</code></pre>
<p>And a Combine publisher for it:</p>
<pre class=""lang-swift prettyprint-override""><code>arr.publisher
    .sink { completion in print(&quot;Completed with \(completion)&quot;)
    } receiveValue: { val in
        print(&quot;Received value \(val)&quot;)
    }
arr.append(3)
</code></pre>
<p>Why does it finish right away with:</p>
<pre class=""lang-swift prettyprint-override""><code>Received value 0
Received value 1
Received value 2
Completed with finished
</code></pre>
<p>How can I make Combine execute the code every time I append values to the array?</p>
","17421862","","","","","2022-02-13 04:00:45","How to observe array's new values with combine?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"71105944","1","71106071","","2022-02-14 00:09:26","","2","939","<p>I'd like to trigger a &quot;change&quot; event on every change of either the <code>username</code> or <code>password</code> published properties and set a new <code>Credentials</code> published property derived of those two and emit an event.</p>
<p>What would be the simplest solution to achieve this result using SwiftUI &amp; Combine?</p>
<p>Some sample code with the idea I'm trying to achieve:</p>
<pre><code>import SwiftUI
import Combine
import Foundation

struct Credentials {
    let username: String
    let password: String

    init(username: String = &quot;&quot;,
         password: String = &quot;&quot;) {
        self.userName = username
        self.password = password
    }
}

final class ViewModel: ObservableObject {
    @Published var username = &quot;&quot;
    @Published var password = &quot;&quot;

    @Published var credentials = Credentials()


    init() {
        [$username, $password]// ..... What to do here? 
// How to &quot;subscribe&quot; each of those properties to emit an event
// so that I get notified each time one of them changes

        credentials = Credentials(username: $username, password: $password)
    }
}

</code></pre>
<p>Essentially, I'm looking to something similar to this answer:
<a href=""https://stackoverflow.com/questions/56782078/swift-combine-how-to-create-a-single-publisher-from-a-list-of-publishers"">Swift Combine: How to create a single publisher from a list of publishers?</a></p>
<p>But with the notification should be triggered each time any of the publishers produce a value, not all of them.</p>
","3667264","","3667264","","2022-02-14 00:14:53","2022-02-14 00:38:14","Combine publishers: notify when ANY of the publishers changes a value","<swift><swiftui><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"71121496","1","71164243","","2022-02-15 05:30:26","","0","132","<p>I want to observe changes on <strong>UISearchController</strong>'s text, here is my setup (and I'm pretty new to <code>Combine</code>):</p>
<pre><code>private var searchQuery: String? {
    didSet {
        print(searchQuery)
    }
}

private var disposable: AnyCancellable?


func bindSearchQuery() {
    disposable = searchController.searchBar.publisher(for: \.text)
        .debounce(for: .milliseconds(300), scheduler: DispatchQueue.main)
        .sink { value in
            if let _value = value {
                self.searchQuery = _value
            }
        }
}
</code></pre>
<p>And I see this once only in the console, on load:</p>
<blockquote>
<p>Optional(&quot;&quot;)</p>
</blockquote>
","689779","","11905533","","2022-02-15 15:54:12","2022-02-17 19:24:09","Combine: Publisher sends text change even once","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"71124914","1","71125012","","2022-02-15 10:33:50","","0","35","<p>I have an object that lives in my app (say a User object) that I want to be published (because some UI depends on it). I don't want to pass it as an EnvironmentObject because of the Liskov substitution principle so I decided to make a wrapper. Something like this:</p>
<pre><code>
protocol HasUser: ObservableObject {
    var user: String { get }
}

class HasUserWrapper: HasUser {
    var user: String { userGetter() }
    
    private let userGetter: () -&gt; String
    
    let objectWillChange: AnyPublisher&lt;Void, Never&gt;
    
    init&lt;UO: HasUser&gt;(wrapping userObject: UO) {
        self.objectWillChange = userObject
            .objectWillChange
            .map { _ in () }
            .eraseToAnyPublisher()
        self.userGetter = { userObject.user }
    }
}

extension HasUser {
    func eraseToHasUserWrapper() -&gt; HasUserWrapper {
        HasUserWrapper(wrapping: self)
    }
}

class ConcreteHasUser: HasUser {
    @Published var user: String = &quot;john&quot;
}

struct UserView {
    @ObservedObject var hasUser: HasUserWrapper = ConcreteHasUser().eraseToHasUserWrapper()
    var body: some View {
        Text(hasUser.user)
    }
}
</code></pre>
<p>Now, I would like to make this wrapper generic. So I started something like this:</p>
<pre><code>protocol HasThing: ObservableObject {
    associatedtype Thing
    var thing: Thing { get }
}

class HasThingWrapper&lt;Thing&gt;: HasThing {
    var thing: Thing { thingGetter() }
    private let thingGetter: () -&gt; Foo

    let objectWillChange: AnyPublisher&lt;Void, Never&gt;

    init&lt;HasThingType: HasThing&gt;(wrapping hasThing: HasThingType)  {
        self.objectWillChange = hasThing
            .objectWillChange
            .map { _ in () }
            .eraseToAnyPublisher()
        self.thingGetter = { hasThing.  }
    }
}

extension HasThing {
    func eraseToThingWrapper() -&gt; HasThingWrapper&lt;Thing&gt; {
        HasThingWrapper(wrapping: self)
    }
}

protocol HasString: HasThing {
    var thing: String { get }
}

class StringHolder: HasString {
    @Published var thing: String = &quot;hello&quot;
}

</code></pre>
<p>How do I tell the compiler that the generic type Thing inside the wrapper should match the associatedtype Thing in the HasThing protocol?</p>
","890407","","","","","2022-02-15 10:41:54","Swift generics: how to match associatedtype with generic parameter","<swift><generics><swiftui>","1","0","1","","","CC BY-SA 4.0"
"71149340","1","71200554","","2022-02-16 21:13:58","","-3","115","<p>Hi I'm fetching data from a local api in a <code>LocationsDataService</code> class and assigning this as a <code>@Published var</code> in the data service and then using this in my <code>LocationsViewModel</code>. If I wait for my api request to complete, for example;</p>
<pre><code> DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {
            let locations = dataService.locations
            self.locations = locations
        }
</code></pre>
<p>Then the locations are rendered on the screen.</p>
<p>This is my data service class;</p>
<pre><code>//
//  LocationsDataService.swift
//  MapTest
//
//

import Foundation
import MapKit
import Combine

class LocationsDataService: ObservableObject {
    
    let token = &quot;2|asOnUG27uCrcVuGxOO65kS25mX0nUSls5ApfemQy&quot;;
    @Published var locations: [Location] = []
    public var cancellable: AnyCancellable?
    enum HTTPError: LocalizedError {
        case statusCode
    }
    
    init() {
        fetch()
    }
    
    func fetch() {
        
        guard let url = URL(string: &quot;http://localhost:8080/api/locations&quot;) else {
            print(&quot;Invalid url...&quot;)
            return
        }
        var urlRequest = URLRequest(
            url: url
        )
        urlRequest.setValue(
            &quot;Bearer \(token)&quot;,
            forHTTPHeaderField: &quot;Authorization&quot;
        )
        
        self.cancellable = URLSession.shared.dataTaskPublisher(for: urlRequest)
                .tryMap { output in
                    guard let response = output.response as? HTTPURLResponse, response.statusCode == 200 else {
                        throw HTTPError.statusCode
                    }
                    return output.data
                }
                .decode(type: [Location].self, decoder: JSONDecoder())
                .receive(on: DispatchQueue.main)
                .eraseToAnyPublisher()
                .sink(receiveCompletion: { completion in
                    switch completion {
                    case .finished:
                        break
                    case .failure(let error):
                        fatalError(error.localizedDescription)
                    }
                }, receiveValue: { locations in
                    self.locations = locations
                })
        
    }
    
}
</code></pre>
<p>And this is my view model</p>
<pre><code>//
//  LocationsViewModel.swift
//  CoffeeShops
//
//

import Foundation
import MapKit
import SwiftUI

class LocationsViewModel: ObservableObject {
    
    // all loaded locations
    @Published var locations: [Location]
    
   
    init() {
        let dataService = LocationsDataService() // the init function will do the api call
        
        self.locations = [Location(
            name: &quot;Amsterdam&quot;,
            address: &quot;Amsterdam&quot;,
            latitude: 52.3721009,
            longitude:  4.8912196,
            description: &quot;Amsterdam&quot;,
            imageNames: [],
            link: &quot;https://en.wikipedia.org/wiki/Colosseum&quot;)]
        

        DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {
            let locations = dataService.locations
            self.locations = locations
            print(locations)
        }
        
    }
    

}
</code></pre>
<p>I'm not sure why I need to explicitly wait for the api before assigning it to the locations in the <code>LocationsViewModel</code> as the <code>LocationsDataService.locations</code> is <code>@Published var locations: [Location] = []</code>, therefore I thought it would be observed. Obviously it wouldn't be great to have to put in a time limit before I can update the screen as it could be done in 1 second or 5 seconds. Any ideas what I'm doing wrong?</p>
","1165028","","3585796","","2022-02-21 09:12:29","2022-02-21 09:12:29","Swift api observable not working without wait","<ios><swift><observable><combine>","1","2","","","","CC BY-SA 4.0"
"71184061","1","71184397","","2022-02-19 10:23:49","","-2","287","<p>How do I get the data returned from a combine publisher, to a view?</p>
<p><a href=""https://i.stack.imgur.com/GZdER.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GZdER.png"" alt=""enter image description here"" /></a></p>
<p>There are many examples of this that show sink -&gt; print. There is nothing that clearly shows how to do anything other than print.</p>
","9400730","","9400730","","2022-02-25 13:07:34","2022-02-25 13:07:34","Populating a SwiftUI view with output from a combine publisher","<ios><swift><combine>","2","2","","2022-02-21 14:14:03","","CC BY-SA 4.0"
"71235657","1","71235830","","2022-02-23 10:58:20","","-1","35","<p>i am new to the entity framework.
i want so find a spezific database item...</p>
<p>i used this code</p>
<pre><code>using (var db = new DatabaseX(_connectionVar))
            {
                try
                {
                    var data = from test in db.X where test.Y== Y &amp;&amp; test.z== z &amp;&amp; test.s== s select test;

                }
            }
</code></pre>
<p>but how can i combine this parameters? With the sign &quot;&amp;&amp;&quot; it doesn´t work...</p>
<p>I hope someone can help me.</p>
","11400394","","11400394","","2022-02-23 11:04:40","2022-02-23 11:10:54","Query many values into one request - entity framework","<sql><database><entity-framework-core><request><combine>","1","1","","2022-02-23 15:33:29","","CC BY-SA 4.0"
"71254656","1","71259063","","2022-02-24 15:46:39","","0","76","<p>I'm trying to wrap my head around this call in Combine.</p>
<p>I have two models and calls. One is an array of place data, the second an array for the OpenWeather response. What I need is to pass the latitude and longitude from my first call response into the second call. At the same time I need to keep the response for both calls.</p>
<p>Bear in mind that this is my first chained request.</p>
<pre><code>enum callAPI {
static let agent = Agent()
static let url1 = URL(string: &quot;**jsonURL**&quot;)!
static let url2 = URL(string: &quot;https://api.openweathermap.org/data/2.5/weather?lat=\(latitude)&amp;lon=\(longitude)&amp;APPID=**APIkey**&amp;unites=metric&quot;)! }

extension callAPI {
    
static func places() -&gt; AnyPublisher&lt;[Place], Error&gt; {
    return run(URLRequest(url: url1))
}

static func weather(latitude: Double, longitude: Double) -&gt; AnyPublisher&lt;[ResponseBody], Error&gt; {
    return run(URLRequest(url: url2))
}

static func run&lt;T: Decodable&gt;(_ request: URLRequest) -&gt; AnyPublisher&lt;T, Error&gt; {
    return agent.run(request)
        .map(\.value)
        .eraseToAnyPublisher()
}}

func chain() {
let places = callAPI.places()
let firstPlace = places.compactMap { $0.first }
let weather = firstPlace.flatMap { place in
    callAPI.weather(latitude: place.latitude, longitude: place.longitude)
}

let token = weather.sink(receiveCompletion: { _ in },
                        receiveValue: { print($0) })

RunLoop.main.run(until: Date(timeIntervalSinceNow: 10))

withExtendedLifetime(token, {})}
</code></pre>
<p>This is the model:</p>
<pre><code>struct Place: Decodable, Identifiable {
let id: Int
let name: String
let description: String
let latitude, longitude: Double
let imageURL: String }

struct ResponseBody: Decodable {
var coord: CoordinatesResponse
var weather: [WeatherResponse]
var main: MainResponse
var name: String
var wind: WindResponse

    struct CoordinatesResponse: Decodable {
    var lon: Double
    var lat: Double
}

    struct WeatherResponse: Decodable {
    var id: Double
    var main: String
    var description: String
    var icon: String
}

    struct MainResponse: Decodable {
    var temp: Double
    var feels_like: Double
    var temp_min: Double
    var temp_max: Double
    var pressure: Double
    var humidity: Double
}

    struct WindResponse: Decodable {
    var speed: Double
    var deg: Double
}}

extension ResponseBody.MainResponse {
var feelsLike: Double { return feels_like }
var tempMin: Double { return temp_min }
var tempMax: Double { return temp_max }}
</code></pre>
","18300482","","4667835","","2022-02-24 15:59:35","2022-02-26 16:56:15","Combine: Chain requests with dependency, keep both responses","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"71275145","1","71332106","","2022-02-26 08:29:21","","0","192","<p>EDIT:
I am trying my level best to make my question simpler,
here what I am trying to get a solution for is, I have an API and if my data is valid the API will give the correct response, for which I need to decode with the respective struct in swift.</p>
<p>also if my data is wrong the API will fail and it will produce an error response which is a different struct.</p>
<p>with the use of combine, I only could decode a single struct type.</p>
<p>SO how do I make my decode accept any type?
Generics is one way I hoped to solve but here the protocol that I need to implement is an issue I believe restricting me from using generics.</p>
<p>thanks for giving it a try.</p>
<p>// MARK: - ResponseStruct Model</p>
<pre><code>struct ResponseStruct: Codable {
   
}

</code></pre>
<p>//MARK: -Protocol</p>
<pre><code>public protocol RequestProtocol{
    associatedtype ResponseOutput 
    func fetchFunction() -&gt; AnyPublisher&lt;ResponseOutput, Error&gt;
}

</code></pre>
<p>//Mark: - Implementation</p>
<pre><code>struct RequestStruct: Codable, RequestProtocol {
    typealias ResponseOutput = ResponseStruct

    
    func fetchFunction() -&gt; AnyPublisher&lt;ResponseOutput, Error&gt;  {
        let networkManager = NetworkManager()
        do {
            return try networkManager.apiCall(url: url, method: .post, body: JSONEncoder().encode(self))
                .decode(type: ResponseStruct.self, decoder: JSONDecoder())
                .eraseToAnyPublisher()
        } catch {
            
        }
    }
}



</code></pre>
<p>Above this is the code, and this is fine if the API call works but if the call fails I will get an error response, so how to decode that struct in a combined way? I don't want to write another call for that and I am hoping to get something to do with Failure in the combine. or CAN I MAKE THE associated type (see protocol) generic?</p>
","16906745","","16906745","","2022-02-28 03:12:27","2022-03-03 04:19:42","How to Implement API for both Success and Failure Response with Combine Swift","<swift><generics><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"71316038","1","71316316","","2022-03-02 00:12:48","","0","1324","<p>I'm trying to implement Combine framework with Alamofire. But I have problems with generics, can you help me improving my code.
So, my APIRouter class:</p>
<pre><code>import Alamofire
import Foundation

public protocol APIConfiguration: URLRequestConvertible {
    var method: HTTPMethod { get }
    var baseURL: String { get }
    var path: String { get }
    var parameters: Parameters? { get }
    
    func asURLRequest() throws -&gt; URLRequest
}


public enum APIRouter: APIConfiguration {
    
    case getPopularRequests
    case getRegionAndCity
    case getCities
    case getComparableCities
    case getSuggests(_ parameters: [String: String])
    case getDrugs(_ parameters: [String: String])
    
    // MARK: - HTTPMethod
    public var method: HTTPMethod {
        switch self {
            
        case .getPopularRequests:
            return .get
        case .getRegionAndCity:
            return .get
        case .getCities:
            return .get
        case .getComparableCities:
            return .get
        case .getSuggests:
            return .get
        case .getDrugs:
            return .get
        }
    }
    
    // MARK: - BaseURL
    public var baseURL: String {
        return &quot;https://example.com/api&quot;
    }
    
    // MARK: - Path
    public var path: String {
        switch self {
            
        case .getPopularRequests:
            return &quot;/goods/search/popular&quot;
        case .getRegionAndCity:
            return &quot;/handbooks/cities?q=&amp;intersect_operation=&amp;need_data=true&amp;need_count=true&amp;take=1000&amp;skip=0&amp;sort_by=name&amp;sort_direction=asc&quot;
        case .getCities:
            return &quot;/handbooks/cities/&quot;
        case .getComparableCities:
            return &quot;/handbooks/cities?q=&amp;intersect_operation=&amp;need_data=true&amp;need_count=true&amp;take=1000&amp;skip=0&amp;sort_by=name&amp;sort_direction=asc&quot;
        case .getSuggests:
            return &quot;/goods/search/suggests&quot;
        case .getDrugs:
            return &quot;/goods/search/global&quot;
        }
    }
    
    // MARK: - Parameters
    public var parameters: Parameters? {
        switch self {
            
        case .getPopularRequests:
            return nil
        case .getRegionAndCity:
            return nil
        case .getCities:
            return nil
        case .getComparableCities:
            return nil
        case .getSuggests(let parameters):
            return parameters
        case .getDrugs(let parameters):
            return parameters
        }
    }
    
    // MARK: - URLRequestConvertible
    public func asURLRequest() throws -&gt; URLRequest {
        let urlWithPathValue = baseURL + path
        var url = try urlWithPathValue.asURL()
        var urlRequest = URLRequest(url: url)
        urlRequest.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        urlRequest.httpMethod = method.rawValue
        
        if let parameters = parameters {
            switch self {
                
            case .getPopularRequests, .getRegionAndCity, .getCities, .getComparableCities:
                return urlRequest
            case .getSuggests, .getDrugs:
                var urlComponents = URLComponents(string: urlWithPathValue)!
                urlComponents.queryItems = []
                
                _ = parameters.map { (key, value) in
                    let item = URLQueryItem(name: key, value: value as? String)
                    urlComponents.queryItems?.append(item)
                }
                
                url = urlComponents.url!
                urlRequest.url = url
            }
        }

        return urlRequest
    }
}
</code></pre>
<p>Than I have API Client class:</p>
<pre><code>public protocol APICitiesScreenClientProtocol: AnyObject {
    func getCities(completion: @escaping (Result&lt;CitiesScreenModel, AFError&gt;) -&gt; Void)
    func getCitiesWithCombine() -&gt; AnyPublisher&lt;Result&lt;CitiesScreenModel, AFError&gt;, Never&gt; 
}

public final class APIClient {
    
    @discardableResult
    private func performRequest&lt;T: Decodable&gt;(route: APIRouter, decoder: JSONDecoder = JSONDecoder(), completion: @escaping (Result&lt;T, AFError&gt;) -&gt; Void) -&gt; DataRequest {
        return AF.request(route).responseDecodable(of: T.self, decoder: decoder) { response in
            completion(response.result)
        }
    }
    
    private func performCombineRequest&lt;T: Decodable&gt;(route: APIRouter, decoder: JSONDecoder = JSONDecoder()) -&gt; AnyPublisher&lt;Result&lt;T, AFError&gt;, Never&gt; {
        return AF.request(route).publishDecodable(type: T.self, decoder: decoder).result()
    }
}

// MARK: - APICitiesScreenClientProtocol
extension APIClient: APICitiesScreenClientProtocol {
    
    public func getCities(completion: @escaping (Result&lt;CitiesScreenModel, AFError&gt;) -&gt; Void) {
        let jsonDecoder = JSONDecoder()
        jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase
        performRequest(route: .getCities, decoder: jsonDecoder, completion: completion)
    }
    
    public func getCitiesWithCombine() -&gt; AnyPublisher&lt;Result&lt;CitiesScreenModel, AFError&gt;, Never&gt; {
        let jsonDecoder = JSONDecoder()
        jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase
        performCombineRequest(route: .getCities, decoder: jsonDecoder)
//      return AF.request(APIRouter.getCities).publishDecodable(type: CitiesScreenModel.self, decoder: jsonDecoder).result()
    }
}
</code></pre>
<p>And I am planning it to use like this:</p>
<pre><code>APIClient().getCitiesWithCombine()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] result in
                switch result {
                    
                case .success(let data):
                    self?.prepareTableViewModel(for: data.data.elements)
                    self?.requestError = nil
                case .failure(let error):
                    self?.requestError = error
                }
            }
            .store(in: &amp;cancellables)
</code></pre>
<p>When I use this line of code</p>
<pre><code>return AF.request(APIRouter.getCities).publishDecodable(type: CitiesScreenModel.self, decoder: jsonDecoder).result()
</code></pre>
<p>, but if I try</p>
<pre><code>performCombineRequest(route: .getCities, decoder: jsonDecoder)
</code></pre>
<p>I got &quot;Generic parameter 'T' could not be inferred&quot;.
Thank you for help.</p>
","13781815","","13781815","","2022-03-02 02:14:15","2022-03-02 05:23:39","Alamofire with Swift Combine","<ios><swift><alamofire><combine>","1","2","","","","CC BY-SA 4.0"
"71319628","1","71319837","","2022-03-02 08:35:33","","-4","37","<p>So let's say I have a data type like this:</p>
<pre><code>struct Foo {
   var isOn: Bool
}
</code></pre>
<p>And I want to have a toggle which operates on the <code>isOn</code> member - something like this:</p>
<pre><code>struct MyView: View {

    @Binding var model: Foo

    var body: some View {
        Toggle(&quot;is on?&quot;, $model.isOn)
    }
}
</code></pre>
<p>Is there any way to achieve this, or would I have to make <code>Foo</code> an observable object with each member being published?</p>
","814570","","","","","2022-03-02 08:52:57","Is there any way for a toggle to operate on a member of a binding?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"71321715","1","71323471","","2022-03-02 11:14:15","","-1","138","<p>I need to test the code:</p>
<pre><code>func ourFunc() -&gt; AnyPublisher&lt;Void, Never&gt; {
       model: OurModel = OurModel()
       Just(model).eraseToAnyPublisher()
    }
</code></pre>
<p>An error occurs:
<code>Cannot convert value of type OurModel to expected type Void</code></p>
<p>How we can typecast <code>OurModel</code> type to <code>Void</code>?</p>
","14991757","","415303","","2022-03-03 04:30:11","2022-03-03 04:30:11","Combine: Casting AnyPublisher<Void, Error> to AnyPublisher<""OurType"", Error>","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"71325464","1","71325709","","2022-03-02 15:45:51","","0","42","<p>I am creating a feature where a user can remove a post from array after deleting it from our API, I am able to successfully remove the correct post from the array but my NewsFeed view always removes the wrong PostCell from the view, even when the correct object is being removed from the array???</p>
<p>The NewsFeed view seems to remove the last PostCell in it's list instead of the object that was successfully removed from the array??</p>
<p>I am performing a check that the correct object was removed from the view model after removing it by printing out all of the object id's and it is definitely gone. However the Newsfeed view removes a totally different view (the last one) and still shows the view that was supposed to be removed?</p>
<p>Any idea why this is happening?</p>
<p><strong>Newsfeed view showing all posts</strong></p>
<pre><code>struct NewsFeed: View {
    @StateObject var newsfeedVM = NewsFeedViewModel()

    var body: some View {
        NavigationView {
            List(0..&lt;newsfeedVM.posts.count, id: \.self) { index in
               PostCell(post: newsfeedVM.posts[index] )
            }
        }
    }
}
</code></pre>
<p><strong>View Model</strong></p>
<pre><code>class NewsFeedViewModel: ObservableObject {
    @Published var posts: [Post] = []
           
    var subscriptions = Set&lt;AnyCancellable&gt;()

    static let removePostFromArray = PassthroughSubject&lt;String, Never&gt;()
    
    init() {
        Self.removePostFromArray.sink { postId in
            print(postId)
            if let index = self.posts.firstIndex(where: { $0.id == postId }) {
                 // removes correct object
                self.posts.remove(at: index)
                 // confirms correct object was removed
                self.posts.forEach { post in
                    print(post.id)
                }
            }
        }.store(in: &amp;subscriptions)
    }
}
</code></pre>
<p><strong>Each post cell has an action-sheet to remove the post.</strong></p>
<pre><code>struct PostCell: View {
    @StateObject var postVM = PostViewModel()
    @State var post: Post
    @State var showActionSheet: Bool = false

    var body: some View {
        VStack(spacing: 5) {
            PostMedia(post: $post)
        }
        .actionSheet(isPresented: $showActionSheet) { &quot;REPORT POST&quot; }
    }

    // remove post with Combine
    func reportPost(post: Post) {
        NewsFeedViewModel.removePostFromArray.send(report.postId)
    }
}
</code></pre>
","16636751","","","","","2022-03-03 18:27:52","SwiftUI list view not reflecting removal of correct view model object?","<ios><swift><swiftui>","1","0","","","","CC BY-SA 4.0"
"71369916","1","71370379","","2022-03-06 11:39:43","","0","228","<p>So I am working on a view where I want to have editable text which is only made editable via a button press.  So basically, when pressing the &quot;edit&quot; button, a text field should be made editable, and the focus should be sent to the text field.</p>
<p>Here's how I have attempted to implement this:</p>
<pre><code>struct MyView: View {
    @Binding var text: String
    @FocusState var isEditing
    var body: some View {
        HStack {
            TextField(&quot;Text&quot;, text: $text)
                .disabled(!isEditing)
                .focused($isEditing)
            Spacer()
            
            Button(isEditing ? &quot;Done&quot; : &quot;Edit&quot;) {
                isEditing.toggle()
            }
        }
    }
}
</code></pre>
<p>So if I comment out the <code>.disabled</code> line, the focus behavior works as intended.  However when the disabled call is there, pressing the edit button does not enable or focus the text field.</p>
<p>My best guess is that maybe the field cannot be focused because it's initially disabled?</p>
<p>Is there any way to achieve this behavior?  I've also tried using a separate @State var for disabled and this has the same result.</p>
","814570","","","","","2022-03-06 15:34:41","Problem enabling and focusing a text field at the same time","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"71416836","1","71424330","","2022-03-09 22:43:09","","0","87","<p>I'm using Combine for networking and I want to have some of the combine operations executed only if a certain condition is present, for instance if a local boolean variable <code>needsDecoding</code> is true I want to add <code>.decode(type:,decoder:)</code>:</p>
<pre><code>if (needsDecoding) {
   return URLSession.shared.dataTaskPublisher(for: request)
                .map(\.data)
                .decode(type: T.self, decoder: JSONDecoder())
                .eraseToAnyPublisher()
} else {
    return URLSession.shared.dataTaskPublisher(for: request)
                .map(\.data)
                .eraseToAnyPublisher()
}
</code></pre>
<p>That code above works but is it possible to conditionally add <code>.decode()</code> to the chain?</p>
","689779","","","","","2022-03-10 12:40:56","Swift: execute an operation conditionally on Publisher","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"71422429","1","71422756","","2022-03-10 10:16:16","","0","36","<p>I am new to Combine, so I wanted to create class <em>RestManager</em> for networking with generic
<em>fetchData</em> function. Function is returning <em>AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt;</em> where <em>ErrorType</em> is enum with <em>.noInternetConnection, .empty and .general</em> cases.</p>
<p>I tried to use <em>URLSession</em> with <em>dataTaskPublisher</em> and <em>flatMap</em></p>
<pre><code>func fetchData&lt;T: Decodable&gt;(url: URL) -&gt; AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt; {
    URLSession
        .shared
        .dataTaskPublisher(for: url)
        .flatMap { (data, response) -&gt; AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt; in
            switch response.result {
            case .success(let data):
                if let data = try? JSONDecoder().decode(T.self, from: data){
                    return Just(data).eraseToAnyPublisher()
                }
            case .failure(let error):
                if let error = error as? URLError {
                    switch error.code {
                    case .notConnectedToInternet, .networkConnectionLost, .timedOut:
                        return Fail(ErrorType.noInternetConnection).eraseToAnyPublisher()
                    case .cannotDecodeRawData, .cannotDecodeContentData:
                        return Fail(ErrorType.empty).eraseToAnyPublisher()
                    default:
                        return Fail(ErrorType.general).eraseToAnyPublisher()
                    }
                }
            }
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>But I am getting</p>
<p><em>Cannot convert return expression of type 'AnyPublisher&lt;AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt;.Output, URLSession.DataTaskPublisher.Failure&gt;' (aka 'AnyPublisher&lt;AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt;.Output, URLError&gt;') to return type 'AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt;'</em> error.</p>
","16455916","","4667835","","2022-03-10 10:38:50","2022-03-10 10:40:43","Using flatMap in RestManager with generic function not working","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"71425444","1","71426490","","2022-03-10 14:04:00","","0","96","<p>I have two async calls to fetch data from the server, but I want them to handle them as a single response, also want to handle errors for each response.</p>
<p>for example, here I have two methods <code>m1()</code>, <code>m2()</code> each can throw the different types of errors.</p>
<p><strong>We should wait to get a response of both</strong> and show an error message based on its error type. If there is no error, continue with the flow.
Which operator do we have to use? I tried with <code>Publishers.Zip</code> &amp; <code>Publishers.Map</code> not able to handle errors.</p>
<pre class=""lang-swift prettyprint-override""><code>
enum Error1: Error {
    case e1
}

enum Error2: Error {
    case e2
}

func m1() -&gt; Future&lt;Bool, Error1&gt; {
    return Future { promise in
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            promise(.failure(.e1))
        }
    }
}

func m2() -&gt; Future&lt;String, Error2&gt; {
    return Future { promise in
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            promise(.success(&quot;1&quot;))
        }
    }
}

</code></pre>
<p>Help would be greatly appreciated.!! Thank you.</p>
","11997939","","415303","","2022-05-26 22:37:49","2022-05-26 22:37:49","How two handle errors in async calls in swift combine?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"71428825","1","71440994","","2022-03-10 18:07:04","","0","80","<p>I have a function which returns a list of Items using elastic search and falls back on realm cache. I'm wondering how can I use <code>Combine</code> to achieve the same.</p>
<p>I am trying to do something like this where I have a publisher for each store but I am getting stuck on the sorting them by score.</p>
<pre><code>    func search(for text: String) -&gt; AnyPublisher&lt;[Item], Error&gt; {
          
          return store.search(with: text)
            // Invalid syntax *
            .map { searchResults in
                let sorted = cacheStore.search(with: text)
                    .map { items in
                        items
                            .map { item in (item, searchResults.first { $0.id == item.id }?.score ?? 0) }
                            .sorted { $0.1 &gt; $1.1 } // by score
                            .map { $0.0 } // to item
                    }
                return sorted.eraseToAnyPublisher()
            }
            // *
            .catch { _ in cacheStore.search(with: text) }
            .eraseToAnyPublisher()
    }

</code></pre>
<p>This is the original function.</p>
<pre><code>func search(for text: String, completion: @escaping (Result&lt;[Item], Error&gt;) -&gt; Void) {
  
    store.search(with: text) {
        // Search network via elastic search or fall back to cache search
        // searchResults is of type [(id: Int, score: Double)] where id is item.id
        guard let searchResult = $0.value, $0.isSuccess else {
            return self.cacheStore.search(with: text, completion: completion)
        }
        
        self.cacheStore.fetch(ids: searchResult.map { $0.id }) {
            guard let items = $0.value, $0.isSuccess else {
                return self.cacheStore.search(with: text, completion: completion)
            }
            
            let scoredItems = items
                .map { item in (item, searchResult.first { $0.id == item.id }?.score ?? 0) }
                .sorted { $0.1 &gt; $1.1 } // by score
                .map { $0.0 } // to item
            
            completion(.success(scoredItems))
        }
    }
}
</code></pre>
","8213026","","8213026","","2022-03-11 16:53:39","2022-03-11 16:53:39","How to use Combine to show elastic search results using network while falling back on cache in Swift","<swift><caching><search><combine><publisher>","2","0","","","","CC BY-SA 4.0"
"71453206","1","71453320","","2022-03-12 22:30:14","","0","74","<p>can someone please help me with this. Whenever I am trying to declare gp as an Environment object, the list disappears. The list works fine when the gp is a @State variable. Could you please help me with creating gp as a global variable so that it works in another screen of Final. I want to call gp in the Final screen so that I can use the value of gp to calculate something else.</p>
<pre><code>import SwiftUI
    
    
    struct Calculation: View {
        
        @State var load1 = Float()
        @State var load2 = Float()
        //@State var gp : Float = 0
        @State var rate: Float = 0
        @ObservedObject var taskStore = TaskStore()
        @EnvironmentObject var userSettings: UserSettings
        func addNewToDo() {
            taskStore.tasks.append(Task(id: String(taskStore.tasks.count + 1), toDoItem: &quot; Earning: =  \(rate.description)&quot;, amount: rate))
        }
        
        var body: some View {
            NavigationView {
                VStack {
                    List {
                        
                        Section(header:Text(&quot;load 2&quot;))
                        {
                            TextField(&quot;Enter value of load 1&quot;, value: $load1, format: .number)
                            TextField(&quot;Enter value of load 1&quot;, value: $load2, format: .number)
                        }
                        
                        HStack {
                            Button(String(format: &quot;Add Load&quot;), action: {
                                print(&quot;pay for the shift is &quot;)
                                print(Rocky(mypay: rate))
                                userSettings.gp += rate
                            })
                            
                            Button(action: {
                                addNewToDo()
                                Rocky(mypay: rate)
                            },
                            label: {
                                Text(&quot; &quot;)
                            })
                        }
                        
                        ForEach(self.taskStore.tasks) { task in
                            Text(task.toDoItem)
                        }
                        .onMove(perform : self.move)
                        .onDelete(perform : self.delete) //For each
                        
                    }
                    .navigationBarTitle(&quot;SHIFTS&quot;)
                    .navigationBarItems(trailing: EditButton()) //List
                    
                    Text(&quot;Gross Pay = $\(userSettings.gp) &quot;)
                     NavigationLink(destination: Final(), label: {Text(&quot;Next&quot;)})
                }.onAppear()
                
            }
        }
        
        func Rocky(mypay: Float)
        {
            rate = load1 + load2
            print(&quot;Sus \(userSettings.gp)&quot;)
        }
        func move(from source : IndexSet, to destination : Int)
        {
            taskStore.tasks.move(fromOffsets: source, toOffset: destination)
        }
        func delete(at offsets : IndexSet) {
            if let index = offsets.first {  //&lt;-- Here
                let task = taskStore.tasks[index]
                userSettings.gp -= task.amount
            }
            taskStore.tasks.remove(atOffsets: offsets)
        }
    }
    
    struct Final: View {
        @EnvironmentObject var userSettings: UserSettings
        var body: some View {
            Text(&quot;Final result \(userSettings.gp)&quot;)
        }
    }
</code></pre>
<p>Another part of the file is as below:</p>
<pre><code>import Foundation
import SwiftUI
import Combine
class UserSettings: ObservableObject
{
@Published var gp : Float = 0
    
}

struct Task : Identifiable {
    var id = String()
    var toDoItem = String()
    var amount : Float = 0 //&lt;-- Here
}

class TaskStore : ObservableObject {
    @Published var tasks = [Task]()
}
</code></pre>
","18367715","","","","","2022-03-13 06:55:10","creating an Environment object","<swift><xcode><swiftui>","1","0","","","","CC BY-SA 4.0"
"71456618","1","71456919","","2022-03-13 12:08:43","","0","39","<p>After putting some operators on a publisher I am curious as to what the current return value and/or error is. Is there a quick way in Xcode that you can check that?</p>
<p>I would like to see something like <code>Map&lt;CombineLatest&lt;Published&lt;String&gt;, Published&lt;String&gt;, String?&gt;&gt;</code>.</p>
<p>I know I don't need to know if I erase it with <code>.eraseToAnyPublisher</code>, but I like to check.</p>
","174655","","","","","2022-03-13 12:51:21","How to check the current publisher type in Xcode?","<xcode><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"71459442","1","71466751","","2022-03-13 18:02:45","","1","199","<p>Basically what I am trying to do is cache the cell and have the video keep playing. When the user scroll back to the cell, the video should just show from where it was playing.</p>
<p>The problem is that the player gets removed and the cell ends up on a random cell instead of its designated area.</p>
<p>You will need to have two videos for this to work, I downloaded the videos off of here
<a href=""https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4"" rel=""nofollow noreferrer"">https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4</a>
I just saved the same video twice under two different names.</p>
<p>How to replicate the problem:
Tap the first cell, then scroll all the way down and then scroll back up, you will notice the video starts appearing all over the place. I just want the video to appear in its proper location and no where else.</p>
<p>Here is a link for the code: <a href=""https://github.com/Abstract45/QuestionTest"" rel=""nofollow noreferrer"">Code link</a></p>
<pre><code>class ViewController: UIViewController {
    
    private var collectionView: UICollectionView!
    
    private var videosURLs: [String] = [
        &quot;ElephantsDream2&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;,
        &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;,
        &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;,
        &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;, &quot;ElephantsDream&quot;
    ]
    
    var cacheItem = [String: (cell: CustomCell, player: AVPlayer)]()

    override func viewDidLoad() {
        super.viewDidLoad()
            
        setupCollectionView()
    }
    
    private func setupCollectionView() {
        collectionView = UICollectionView(frame: .zero, collectionViewLayout: ColumnFlowLayout())
        view.addSubview(collectionView)

        collectionView.register(CustomCell.self, forCellWithReuseIdentifier: &quot;cell&quot;)
        collectionView.dataSource = self
        collectionView.delegate = self
        collectionView.translatesAutoresizingMaskIntoConstraints = false
        
        NSLayoutConstraint.activate([
            collectionView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            collectionView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            collectionView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            collectionView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor),
        ])
    }

}

extension ViewController: UICollectionViewDelegate {
    
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        guard let cell = collectionView.cellForItem(at: indexPath) as? CustomCell else { return }
        let item = videosURLs[indexPath.row]
        let viewModel = PlayerViewModel(fileName: item)
        cell.setupPlayerView(viewModel.player)
        cacheItem[item] = (cell, viewModel.player)
    }
}

extension ViewController: UICollectionViewDataSource {
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int {
        videosURLs.count
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {
        let item = videosURLs[indexPath.row]
        if let cachedItem = cacheItem[item], indexPath.row == 0 {
            print(indexPath)
            print(item)
            cachedItem.cell.setUpFromCache(cachedItem.player)
            return cachedItem.cell
        } else {
            guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: &quot;cell&quot;, for: indexPath) as? CustomCell else { return UICollectionViewCell() }
            cell.contentView.backgroundColor = .orange
            let url = Bundle.main.url(forResource: item, withExtension: &quot;mp4&quot;)
            cell.playerItem = AVPlayerItem(url: url!)
            return cell
        }
    }
}


class CustomCell: UICollectionViewCell {
    private var cancelBag: Set&lt;AnyCancellable&gt; = []
    private(set) var playerView: PlayerView?
    var playerItem: AVPlayerItem?
    
    override var reuseIdentifier: String?{
        &quot;cell&quot;
    }
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        
        setupViews()
    }
    
    override func prepareForReuse() {
        super.prepareForReuse()
        
        playerView = nil
        playerView?.removeFromSuperview()
    }
    
    required init?(coder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }

    private func setupViews() {
        layer.cornerRadius = 8
        clipsToBounds = true
    }
    
    func setUpFromCache(_ player: AVPlayer) {
        playerView?.player = player
    }
    
    func setupPlayerView(_ player: AVPlayer) {
        if self.playerView == nil {
            self.playerView = PlayerView(player: player, gravity: .aspectFill)
            contentView.addSubview(playerView!)
            
            playerView?.translatesAutoresizingMaskIntoConstraints = false
            
            NSLayoutConstraint.activate([
                playerView!.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
                playerView!.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),
                playerView!.topAnchor.constraint(equalTo: contentView.topAnchor),
                playerView!.bottomAnchor.constraint(equalTo: contentView.bottomAnchor)
            ])
            
            playerView?.player?.play()
            
            NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime).sink { [weak self] notification in
                if let p = notification.object as? AVPlayerItem, p == player.currentItem {
                    self?.playerView?.removeFromSuperview()
                    guard let self = self else { return }
                    NotificationCenter.default.removeObserver(self, name: .AVPlayerItemDidPlayToEndTime, object: nil)
                }
            }.store(in: &amp;cancelBag)
        } else {
            playerView?.player?.pause()
            playerView?.removeFromSuperview()
            playerView = nil
        }
    }
}
</code></pre>
","5113674","","5113674","","2022-03-13 18:33:06","2022-03-14 11:05:20","How do I cache cells and also reuse cells in a collectionview that has avplayers embedded in each cell?","<swift><xcode><collectionview><avkit>","1","2","","","","CC BY-SA 4.0"
"71460557","1","71460723","","2022-03-13 20:24:34","","0","241","<p>I have an up-to-date json file hosted online and a local json file in my Xcode workspace. I would like to proceeed to decode a locally stored file if fetching failed: <code>MyError.fetchError</code> e.g. for no internet connection. This is the pipeline:</p>
<pre><code>func fetchAndDecode&lt;T: Decodable&gt;(url: URL) -&gt; AnyPublisher&lt;T, MyError&gt; {
    fetchURL(url: url)
        .decode(type: T.self, decoder: JSONDecoder())
        .mapError { error in
            if let error = error as? DecodingError {
                return MyError.parsingError
            }  else {
                return MyError.fetchError //here somehow proceed to parse local json file
            }
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>How to achieve this ?</p>
","18456673","","","","","2022-03-13 21:02:11","Combine - how to proceed to decode a local json file if online fetch failed?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"71472103","1","71472177","","2022-03-14 17:49:29","","0","77","<p>I'm trying implementing a data manager singleton class reading/write from a JSON file but I obtain this error:</p>
<pre><code>'self' used in method call 'LoadData' before all stored properties are initialized
</code></pre>
<p>this is the code:</p>
<pre><code>import SwiftUI
import Combine

class DataManager: ObservableObject {
        
    static let shared = DataManager()
    
    var TTDItemMainList: TTDItemList = TTDItemList(itemList: [TTDItem(id: UUID(), itemDesc: &quot;&quot;, itemCreaDate: Date(), itemUpdDate: Date(), itemTags: [], linkedItemsUID: [])])
    
    var urlFile: URL
    
    init() { LoadData() }
    
    func LoadData() {
        
        func getDocumentsDirectory() -&gt; URL {
            let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
            return paths[0]
        }

        let urlFile = getDocumentsDirectory().appendingPathComponent(&quot;/SMT.json&quot;)
        
        do {
            let data = try Data(contentsOf: urlFile)
            let decoder = JSONDecoder()
            TTDItemMainList = try decoder.decode(TTDItemList.self, from: data)
        } catch {
            debugPrint(error.localizedDescription)
        }
        
    }
    
    func saveData() {
        let encoder = JSONEncoder()
        do {
            let data = try encoder.encode(TTDItemMainList)
            try data.write(to: urlFile)
        } catch {
            debugPrint(error.localizedDescription)
        }
    }
    
}
</code></pre>
<p>I do not understand how restructure the code to avois this issue.</p>
","1937003","","","","","2022-03-14 17:54:46","How can I read and write from/to a JSON file in a specific file path in swift?","<json><swift><url>","1","0","","","","CC BY-SA 4.0"
"71475905","1","71724704","","2022-03-15 01:12:16","","2","70","<p>I'm using Apple's example of an Observable wrapper around <code>SFSpeechRecognizer</code> as follows:</p>
<pre><code>class SpeechRecognizer: ObservableObject {
    @Published var transcript: String
    func transcribe() {}
}
</code></pre>
<p>The goal is to use a ViewModel to both consume the transcript as it is generated, as well as passing on the value to a SwiftUI View for visual debugging:</p>
<pre><code>class ViewModel : ObservableObject {
    @Published var SpeechText: String = &quot;&quot;
    @ObservedObject var speech: SpeechRecognizer = SpeechRecognizer()

    public init() {
        speech.transcribe()
        speech.transcript.publisher
            .map { $0 as! String? ?? &quot;&quot; }
            .sink(receiveCompletion: {
                print ($0) },
                  receiveValue: {
                    self.SpeechText = $0
                    self.doStuff(transcript: $0)
                  })
    }

    private void doStuffWithText(transcript: String) {
        //Process the output as commands in the application
    }
}
</code></pre>
<p>I can confirm that if I observe <code>transcript</code> directly in a SwiftUI view, that the data is flowing through. My problem is receiving the values as they change, and then assigning that data to my own published variable.</p>
<p>How do I make this work?</p>
","786487","","","","","2022-06-16 07:53:50","Publishing and Consuming a transcript from SFSpeechRecognizer","<swift><combine><sfspeechrecognizer>","1","0","","","","CC BY-SA 4.0"
"71507374","1","71545454","","2022-03-17 05:12:14","","0","68","<p>can someone Help me with fixing this. I want this code to work such as when I click the Home button on the side menu, it should take me to the Main View(&quot;This is the Main View&quot;). I have tried using presenting sheets, however, presenting sheet doesn't look realistic. When the Home button is tapped, everything should disappear and only the Home Screen should come up with the side menu. I have tried writing up this code, however, I couldn't make the home button work. The codes are as below:</p>
<pre><code>import SwiftUI
import Foundation
import Combine


struct Home: View {
@State var showMenu = false
    @EnvironmentObject var userSettings: UserSettings
  
    var body: some View {
        
        let drag = DragGesture()
            .onEnded {
                if $0.translation.width &lt; -100 {
                    withAnimation {
                        self.showMenu = false
                    }
                }
            }
        return NavigationView {
            
            GeometryReader {
            geometry in
               
            ZStack(alignment: .leading) {
                MainView(showMenu: self.$showMenu)
                .frame(width: geometry.size.width, height: geometry.size.height)
                .offset(x: self.showMenu ? geometry.size.width/2 : 0)
                .disabled(self.showMenu ? true : false)
                if self.showMenu {
                    MenuView()
                        .frame(width: geometry.size.width/2)
                        .transition(.move(edge: .leading))
                }
    }
            .gesture(drag)
        }
            .navigationBarTitle(&quot;Pay Data&quot;, displayMode: .inline)
       
            .navigationBarItems(leading: (Button(action: {
                withAnimation {
                    self.showMenu.toggle()
                }
            }){
                Image(systemName: &quot;line.horizontal.3&quot;)
                    .imageScale(.large)
                
            }
                                         ))
    }
    }
}
struct MainView: View {
    @Binding var showMenu: Bool
        @EnvironmentObject var userSettings: UserSettings
    var body: some View {
        Text(&quot;This is Main View&quot;)
        
    }
}

struct Home_Previews: PreviewProvider {
    static var previews: some View {
        Home()
            .environmentObject(UserSettings())
       
    }
}
</code></pre>
<p>//This is the Menu View. The  Home Button is located in this view.</p>
<pre><code>import SwiftUI
import Combine
import Foundation


struct MenuView: View {
    @EnvironmentObject var userSettings: UserSettings
    @State var showMenu = false
    @State var Homevariable = false
    var body: some View {
        VStack(alignment: .leading) {
            
            Button(action: {
            
                UserDefaults.standard.set(false, forKey: &quot;status&quot;)
                
               
            }) {
                (Text(Image(systemName: &quot;rectangle.righthalf.inset.fill.arrow.right&quot;)) + (Text(&quot;Home&quot;)))
            }
              
           
        }
        .padding()
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(Color(red: 32/255, green: 32/255, blue: 32/255))
        .edgesIgnoringSafeArea(.all)
    }
 
}
struct MenuView_Previews: PreviewProvider {
    static var previews: some View {
        MenuView()
            .environmentObject(UserSettings())
       
    }
}
</code></pre>
<p>//This is the another view. I want the side Menu to appear on this as well, so when I press the Home button it takes me to the Main View(&quot;This is the Main View&quot;)</p>
<pre><code>import SwiftUI

struct Calculation: View {
    var body: some View {
        Text(&quot;Hello, World!&quot;)
    }
}

struct Calculation_Previews: PreviewProvider {
    static var previews: some View {
        Calculation()
    }
}
</code></pre>
","18367715","","18367715","","2022-03-20 00:29:31","2022-03-20 09:12:38","Implementing Button in side menu","<swift><xcode><swiftui>","1","3","","","","CC BY-SA 4.0"
"71509097","1","71510303","","2022-03-17 08:23:40","","0","272","<p>I'm trying to create an email input field in SwiftUI 2 that allows only certain characters to be entered. The code here is based on a piece of code from <a href=""https://stackoverflow.com/a/57829567/356105"">https://stackoverflow.com/a/57829567/356105</a>.</p>
<p>The code itself works but since this is a reusable view component I want to provide a text property from a parent view's view model to the <code>EmailTextField</code> which is updated when the text input changes ...</p>
<p><strong>EmailTextField view</strong>:</p>
<pre><code>import SwiftUI
import Combine

struct EmailTextField: View {
    private class EmailTextFieldViewModel: ObservableObject {
        @Published var text = String.Empty
        private var subCancellable: AnyCancellable!
        private var validCharSet = CharacterSet(charactersIn: &quot;1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ._-+$!~&amp;=#[]@&quot;)

        init() {
            subCancellable = $text.sink {
                value in

                /* Check if the new string contains any invalid characters. */
                if value.rangeOfCharacter(from: self.validCharSet.inverted) != nil {
                    /* Clean the string (do this on the main thread to avoid overlapping with the current ContentView update cycle). */
                    DispatchQueue.main.async {
                        self.text = String(self.text.unicodeScalars.filter {
                            self.validCharSet.contains($0)
                        })
                    }
                }
            }
        }

        deinit {
            subCancellable.cancel()
        }
    }

    @ObservedObject private var viewModel = EmailTextFieldViewModel()
    private let placeHolder: String

    var body: some View {
        TextField(placeHolder, text: $viewModel.text)
            .keyboardType(.emailAddress)
            .autocapitalization(.none)
            .disableAutocorrection(true)
    }

    init(_ placeHolder: String = .Empty, text: Binding&lt;String&gt;) {
        self.placeHolder = placeHolder
    }
}
</code></pre>
<p>In the parent view I'm trying this:</p>
<pre><code>var body: some View {
    VStack {
        EmailTextField(&quot;Email&quot;, text: $viewModel.email)
            .onChange(of: viewModel.email, perform: onEmailInputChanged)
    }
}

private func onEmailInputChanged(changedEmail: String) {
    // Nothing happens here!
    print(&quot;\(changedEmail)&quot;)
}
</code></pre>
<p>How do I need to change the <code>EmailTextField</code> code to be able to bind the <code>text</code> variable in its view model to the <code>text: Binding&lt;String&gt;</code> argument in its constructor?</p>
","356105","","","","","2022-03-17 09:57:04","Creating an Email Input Field in SwiftUI","<swift><swiftui><binding><combine>","1","0","","","","CC BY-SA 4.0"
"71513110","1","71513263","","2022-03-17 13:26:06","","1","100","<pre><code>    import SwiftUI


struct TimerView: View {
    
    @EnvironmentObject var tm : TimerModel
    
    @State var timerStyle : TimerStyle?
    @State var focusColors : [Color] = [Color.green, Color.mint, Color.green, Color.mint, Color.green]
    @State var breakColors : [Color] = [Color.blue, Color.mint, Color.blue, Color.mint, Color.blue]
    @State var longBreakColors : [Color] = [Color.gray, Color.white, Color.gray, Color.white, Color.gray]
    @State var isShowNewTimerView : Bool = false

    var body: some View {
        NavigationView {
            ZStack {
                Color(&quot;BackgroundColor&quot;).ignoresSafeArea(.all)
                if tm.timerStyle == nil {
                    NoTimerView()
                } else {
                    VStack(alignment : .center, spacing: 40){
                        Spacer()
                        if let timerStyle = tm.timerStyle {
                            switch timerStyle {
                                case .focus:
                                    Text(&quot;Focus Mode 🔥&quot;)
                                        .font(.system(size: 30, weight: .bold, design: .rounded))
                                        .fontWeight(.bold)
                       
                                case .short:
                                    Text(&quot;Break Mode ☕️&quot;)
                                        .font(.system(size: 30, weight: .bold, design: .rounded))
                                        .fontWeight(.bold)
                             
                                case .long:
                                    Text(&quot;Long Break Mode 🌕&quot;)
                                        .font(.system(size: 30, weight: .bold, design: .rounded))
                                        .fontWeight(.bold)//
                                    }
                                }
                        
                    if let timerStyle = tm.timerStyle {
                            switch timerStyle {
                            case .focus:
                                ProgressView(progress: tm.progress, gradientColors: focusColors, time: formatTime())
                                    .padding()
                                    .onReceive(tm.timer) { _ in
                                        if tm.timerMode == .start {
                                            if tm.elapsedFocusTime != 0 {
                                                tm.trackFocusProgress()
                                            } else {
                                                if tm.isAuto {
                                                    tm.timerStyle = .short
                                                    tm.progress = 0
                                                    tm.elapsedShortTime = tm.totalShortTime
                                                    
                                                    if tm.isOnSound {
                                                        playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                    }
                                                } else {
                                                    tm.timerMode = .normal
                                                    tm.timerStyle = .short
                                                    tm.isStarted = false
                                                    tm.progress = 0
                                                    tm.elapsedShortTime = tm.totalShortTime
                                                    audioPlayer1?.stop()
                                                    
                                                    if tm.isOnSound {
                                                        playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                    }
                                                }
                                            }
                                        }
                                    }
                            case .short:
                                ProgressView(progress: tm.progress, gradientColors: breakColors, time: formatTime())
                                    .padding()
                                    .onReceive(tm.timer) { _ in
                                        if tm.timerMode == .start {
                                            if tm.elapsedShortTime != 0 {
                                                tm.trackFocusProgress()
                                            } else {
                                                if tm.isAuto {
                                                    if tm.isSkipMode {
                                                        tm.timerStyle = .focus
                                                        tm.progress = 0
                                                        tm.elapsedFocusTime = tm.totalFocusTime
                                                        
                                                        if tm.isOnSound {
                                                            playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                        }
                                                        
                                                    } else {
                                                        tm.timerStyle = .long
                                                        tm.progress = 0
                                                        tm.elapsedLongBreakTime = tm.totalLongBreakTime
                                                        if tm.isOnSound {
                                                            playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                        }
                                                    }
                                                } else {
                                                    if tm.isSkipMode {
                                                        tm.timerStyle = .focus
                                                        tm.timerMode = .normal
                                                        tm.timerStyle = .focus
                                                        tm.isStarted = false
                                                        tm.progress = 0
                                                        tm.elapsedFocusTime = tm.totalFocusTime
                                                        audioPlayer1?.stop()
                                                        
                                                        if tm.isOnSound {
                                                            playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                        }
                                                        
                                                    } else {
                                                        tm.timerMode = .normal
                                                        tm.timerStyle = .long
                                                        tm.isStarted = false
                                                        tm.progress = 0
                                                        tm.elapsedLongBreakTime = tm.totalLongBreakTime
                                                        audioPlayer1?.stop()
                                                        
                                                        if tm.isOnSound {
                                                            playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                            case .long:
                                ProgressView(progress: tm.progress, gradientColors: longBreakColors, time: formatTime())
                                    .padding()
                                    .onReceive(tm.timer) { _ in
                                        if tm.timerMode == .start {
                                            if tm.elapsedLongBreakTime != 0 {
                                                tm.trackFocusProgress()
                                            } else {
                                                if tm.isAuto {
                                                    tm.timerStyle = .focus
                                                    tm.progress = 0
                                                    tm.elapsedFocusTime = tm.totalFocusTime
                                                    
                                                    if tm.isOnSound {
                                                        playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                    }
                                                    
                                                } else {
                                                    tm.timerMode = .normal
                                                    tm.timerStyle = .focus
                                                    tm.isStarted = false
                                                    tm.progress = 0
                                                    tm.elapsedFocusTime = tm.totalFocusTime
                                                    audioPlayer1?.stop()
                                                    
                                                    if tm.isOnSound {
                                                        playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                    }
                                                }
                                            }
                                        }
                                    }
                        }
                    }
                    
                    if let timerStyle = tm.timerStyle {
                        switch timerStyle {
                        case .focus:
                            Text(&quot;Let's concentrate on your task!&quot;)
                                .font(.headline)
                                .multilineTextAlignment(.center)
                        case .short:
                            Text(&quot;Well done, Have a short break!&quot;)
                                .font(.headline)
                                .multilineTextAlignment(.center)
                        case .long:
                            Text(&quot;It's so long journey, take care yourself.&quot;)
                                .font(.headline)
                                .multilineTextAlignment(.center)
                        }
                    }
                    
                    HStack {
                    
                    Button(action: {
                        switch tm.timerMode {
                            
                        case .normal:
                            tm.timerMode = .start
                            tm.isStarted.toggle()
                            tm.backBroundMusic()
                            
                        case .start:
                            audioPlayer1?.stop()
                            tm.timerMode = .normal
                            
                            if let timerStyle = tm.timerStyle {
                                switch timerStyle {
                                case .focus:
                                    tm.progress = 0
                                    tm.elapsedFocusTime = tm.totalFocusTime
                                    
                                case .short:
                                    tm.progress = 0
                                    tm.elapsedShortTime = tm.totalShortTime
                                   
                                case .long:
                                    tm.progress = 0
                                    tm.elapsedLongBreakTime = tm.totalLongBreakTime
                                }
                            }
                            
                            tm.isStarted.toggle()
                            
                        case .pause:
        
                            tm.isStarted.toggle()
                            tm.isPaused.toggle()
                            tm.timerMode = .normal
                            
                            if let timerStyle = tm.timerStyle {
                                switch timerStyle {
                                case .focus:
                                    tm.progress = 0
                                    tm.elapsedFocusTime = tm.totalFocusTime
                                    
                                case .short:
                                    tm.progress = 0
                                    tm.elapsedShortTime = tm.totalShortTime
                                   
                                case .long:
                                    tm.progress = 0
                                    tm.elapsedLongBreakTime = tm.totalLongBreakTime
                                }
                            }
                            
                        case .stop:
                            tm.timerMode = .normal
                        }
                    }, label: {
                        Image(systemName: tm.isStarted ? &quot;square.fill&quot;:&quot;play.fill&quot;)
                            .frame(width : 60, height : 60)
                            .background(tm.isStarted ? .red : .green)
                            .foregroundColor(.white)
                            .font(.title)
                            .cornerRadius(10)
                            .shadow(color: .gray.opacity(0.5), radius: 1, x: 1, y: 1)
                    })
                    .disabled(tm.timerStyle == nil)
                    .padding()
                        
                    Button(action:  {
                        switch tm.timerMode {
                        case .normal:
                            return
                        case .start:
                            audioPlayer1?.stop()
                            tm.timerMode = .pause
                            tm.isPaused.toggle()
                        case .pause:
                            tm.backBroundMusic()
                            tm.timerMode = .start
                            tm.isPaused.toggle()
                        case .stop:
                            return
                        }
                    }, label: {
                        Image(systemName: tm.timerMode == .pause
                              ? &quot;play.fill&quot; : &quot;pause.fill&quot;)
                            .frame(width : 60, height : 60)
                            .background(tm.timerMode == .normal ? .gray : .yellow)
                            .foregroundColor(.white)
                            .font(.title)
                            .cornerRadius(10)
                            .shadow(color: .gray.opacity(0.5), radius: 1, x: 1, y: 1)
                    })
                    .disabled(tm.timerStyle == nil)
                    .padding()
                        
                    Button(action:  {
                        
                        audioPlayer1?.stop()
                        
                        if let timerStyle = tm.timerStyle {
                            switch timerStyle {
                            case .focus:
                                tm.timerMode = .normal
                                tm.timerStyle = .short
                                tm.isStarted = false
                                tm.progress = 0
                                tm.elapsedShortTime = tm.totalShortTime
                            case .short:
                                if tm.isSkipMode {
                                    tm.timerMode = .normal
                                    tm.timerStyle = .focus
                                    tm.isStarted = false
                                    tm.progress = 0
                                    tm.elapsedFocusTime = tm.totalFocusTime
                                } else {
                                    tm.timerMode = .normal
                                    tm.timerStyle = .long
                                    tm.isStarted = false
                                    tm.progress = 0
                                    tm.elapsedLongBreakTime = tm.totalLongBreakTime
                                }
                            case .long:
                                tm.timerMode = .normal
                                tm.timerStyle = .focus
                                tm.isStarted = false
                                tm.progress = 0
                                tm.elapsedFocusTime = tm.totalFocusTime
                            }
                        }
                    }, label: {
                        Image(systemName: &quot;forward.end.fill&quot;)
                            .frame(width : 60, height : 60)
                            .background(.blue)
                            .foregroundColor(.white)
                            .font(.title)
                            .cornerRadius(10)
                            .shadow(color: .gray.opacity(0.5), radius: 1, x: 1, y: 1)
                    })
                    .disabled(tm.timerStyle == nil)
                    .padding()
                        
                    } // hst
                    Spacer()
                }//vst
            }
        }//Zstack
                    .navigationTitle(&quot;PPO.MO ⏱&quot;)
                    .navigationBarTitleDisplayMode(.inline)
                    .navigationBarItems(trailing:
                       HStack{
                        
                        if tm.isOnBackgroundSound {
                            Menu {
                                Button(action: {
                                    switch tm.timerMode {
                                    case .normal:
                                        tm.backgroundNoise = .forest
                                    case .start:
                                        tm.backgroundNoise = .forest
                                        tm.backBroundMusic()
                                    case .pause:
                                        audioPlayer1?.stop()
                                    case .stop:
                                        tm.backgroundNoise = .forest
                                    }
                                    
                                }, label: {
                                    Label(tm.backgroundNoise == .forest ? &quot;✅ Forest&quot; : &quot;Forest&quot;, systemImage: &quot;leaf&quot;)
                                })
                                
                                Button(action: {
                                    switch tm.timerMode {
                                    case .normal:
                                        tm.backgroundNoise = .river
                                    case .start:
                                        tm.backgroundNoise = .river
                                        tm.backBroundMusic()
                                    case .pause:
                                        audioPlayer1?.stop()
                                    case .stop:
                                        tm.backgroundNoise = .river
                                    }
                                }, label: {
                                    Label(tm.backgroundNoise == .river ? &quot;✅ River&quot; : &quot;River&quot;, systemImage: &quot;drop.circle&quot;)
                                })
                                
                                Button(action: {
                                    switch tm.timerMode {
                                    case .normal:
                                        tm.backgroundNoise = .rain
                                    case .start:
                                        tm.backgroundNoise = .rain
                                        tm.backBroundMusic()
                                    case .pause:
                                        audioPlayer1?.stop()
                                    case .stop:
                                        tm.backgroundNoise = .rain
                                    }
                                }, label: {
                                    Label(tm.backgroundNoise == .rain ? &quot;✅ Rain&quot; : &quot;Rain&quot;, systemImage: &quot;cloud.rain&quot;)
                                })
                                
                                Button(action: {
                                    switch tm.timerMode {
                                    case .normal:
                                        tm.backgroundNoise = .wave
                                    case .start:
                                        tm.backgroundNoise = .wave
                                        tm.backBroundMusic()
                                    case .pause:
                                        audioPlayer1?.stop()
                                    case .stop:
                                        tm.backgroundNoise = .wave
                                    }
                                }, label: {
                                    Label(tm.backgroundNoise == .wave ? &quot;✅ Wave&quot; : &quot;Wave&quot;, systemImage: &quot;cloud.rain&quot;)
                                })
                                
                                Button(action: {
                                    tm.backgroundNoise = .turnOff
                                    audioPlayer1?.stop()
                                }, label: {
                                    Label(tm.backgroundNoise == .turnOff ? &quot;✅ Turn off&quot; : &quot;Turn off&quot;, systemImage: &quot;speaker.slash&quot;)
                                })
                                
                            } label: {
                                Image(systemName: tm.backgroundNoise == .turnOff ? &quot;speaker.slash.circle&quot; : &quot;speaker.circle&quot;)
                            }
                        }
                        
                        NavigationLink(destination: {
                            AddTimerView()
                        }, label: {
                            Image(systemName: &quot;plus&quot;)
                        })
                        .simultaneousGesture(TapGesture().onEnded({
                            tm.timerMode = .pause
                            audioPlayer1?.stop()
                        }))
                    })
        }//nav
    }
}

extension TimerView {
    
    func formatTime() -&gt; String {
        
        if let timerStyle = tm.timerStyle {
            switch timerStyle {
            case .focus:
                let minute = Int(tm.elapsedFocusTime) / 60 % 60
                let second = Int(tm.elapsedFocusTime) % 60
                
                return String(format: &quot;%02i:%02i&quot;, minute, second)
            case .short:
                let minute = Int(tm.elapsedShortTime) / 60 % 60
                let second = Int(tm.elapsedShortTime) % 60
                
                return String(format: &quot;%02i:%02i&quot;, minute, second)
            case .long:
                let minute = Int(tm.elapsedLongBreakTime) / 60 % 60
                let second = Int(tm.elapsedLongBreakTime) % 60
                
                return String(format: &quot;%02i:%02i&quot;, minute, second)
            }
        }
            return &quot;00:00&quot;
    }
}
</code></pre>
<p>Hi, I am trying to make pomodoro timer myself.</p>
<p>But, when I checked bugs, I found that my onReceive modifier is turned off when the view is closed by swipe up.</p>
<p>When did that, timer is stopped and I think the onReceive is not working.</p>
<p>So, I want to know how I can maintain onreceive even if the view is swipe down.</p>
","16634995","","","","","2022-03-17 13:36:57","SwiftUI : How I can maintain onReceive when the View in closed","<swiftui><timer><combine>","1","0","","","","CC BY-SA 4.0"
"71520546","1","71532629","","2022-03-18 00:29:33","","0","181","<p>I would like to create a PassthroughSubject object that can send an output of any type. In code I currently have something like this:</p>
<pre><code>let cmd1Subj = PassthroughSubject&lt;String, Never&gt;()
let cmd2Subj = PassthroughSubject&lt;String, Never&gt;()
var desiredCmd: PassthroughSubject&lt;String, Never&gt;?
let executeDesiredCmdSubj = PassthroughSubject&lt;String, Never&gt;()
var arg: String?

func executeDesiredCmd(cmdArg: String) -&gt; AnyPublisher&lt;String, Never&gt; {
    guard (desiredCmd != nil) else {
        return Just(&quot;Nothing to execute\n&quot;).eraseToAnyPublisher()
    }
    desiredCmd?.send(cmdArg)
    return Just(&quot;Executed: \(String(describing: desiredCmd)) with argument: \(cmdArg)&quot;).eraseToAnyPublisher()
}

let cancellable = executeDesiredCmdSubj
    .flatMap(executeDesiredCmd)
    .receive(on: DispatchQueue.main)
    .sink(receiveValue: {
        print($0)
    })

desiredCmd = cmd1Subj
arg = &quot;This is the argument for command 1&quot;
desiredCmd?.send(arg!)
desiredCmd = cmd2Subj
arg = &quot;This is the argument for command 2&quot;
desiredCmd?.send(arg!)
</code></pre>
<p>How do I change <code>desiredCmd</code> and <code>executeDesiredCmdSubj</code> such that they can send an output of any type, as determined at runtime? I'd like to do something like this:</p>
<pre><code>let cmd1Subj = PassthroughSubject&lt;Int, Never&gt;()
let cmd2Subj = PassthroughSubject&lt;String, Never&gt;()
var desiredCmd: PassthroughSubject&lt;Some_Generic_Type, Never&gt;?
let executeDesiredCmdSubj = PassthroughSubject&lt;Some_Generic_Type, Never&gt;()
var arg: Some_Generic_Type?

func executeDesiredCmd(cmdArg: Some_Generic_Type) -&gt; AnyPublisher&lt;String, Never&gt; {
    guard (desiredCmd != nil) else {
        return Just(&quot;Nothing to execute\n&quot;).eraseToAnyPublisher()
    }
    desiredCmd?.send(cmdArg)
    return Just(&quot;Executed: \(String(describing: desiredCmd)) with argument: \(cmdArg)&quot;).eraseToAnyPublisher()
}

let cancellable = executeDesiredCmdSubj
    .flatMap(executeDesiredCmd)
    .receive(on: DispatchQueue.main)
    .sink(receiveValue: {
        print($0)
    })

desiredCmd = cmd1Subj
arg = 12345
desiredCmd?.send(arg!)
desiredCmd = cmd2Subj
arg = &quot;This is the argument for command 2&quot;
desiredCmd?.send(arg!)
</code></pre>
<p>where <strong>Some_Generic_Type</strong> is a placeholder that can be used to represent any type I attempt to pass through my PassthroughSubject. I tried using &quot;Any&quot; as the placeholder but it produces a couple of compilation errors:</p>
<ul>
<li>&quot;Cannot assign value of type 'PassthroughSubject&lt;Int, Never&gt;' to type 'PassthroughSubject&lt;Any, Never&gt;&quot;</li>
<li>&quot;Cannot assign value of type 'PassthroughSubject&lt;String, Never&gt;' to type 'PassthroughSubject&lt;Any, Never&gt;&quot;</li>
</ul>
","4347877","","4347877","","2022-03-18 15:40:57","2022-03-18 20:06:45","How do I create a PassthroughSubject that can have an output of any type?","<swift><casting><combine>","1","4","","","","CC BY-SA 4.0"
"71562973","1","71584586","","2022-03-21 19:17:05","","0","436","<p>I'm very new to the concept Publishers and I'm creating a networking service using <code>dataTaskPublisher</code> on <code>URLSession</code>. There is a case for refreshing token and I have a <code>refreshToken()</code> method which returns <code>AnyPublisher&lt;Bool, Never&gt;</code>:</p>
<pre><code>    func refreshToken() -&gt; AnyPublisher&lt;Bool, Never&gt; {
        var disposable = Set&lt;AnyCancellable&gt;()
        
        do {
            let request = URLRequest(url: URL(string: &quot;refresh_token_url&quot;)!)
            URLSession.shared.dataTaskPublisher(for: request).sink { finished in
                /// Compiler error: Cannot convert value of type 'AnyPublisher&lt;Bool, Never&gt;' to closure result type 'Void'
                return Just(false).eraseToAnyPublisher()
            } receiveValue: { _ in
                /// What should I return here?
                return Just(true).eraseToAnyPublisher()
            }.store(in: &amp;disposable)

        } catch {
            return Just(false).eraseToAnyPublisher()
        }
        
    }
</code></pre>
<p>Compiler complains for both of <code>Just().eraseToAnyPublisher()</code>.  I don't know how and where should return <code>Just(false).eraseToAnyPublisher()</code> based on success or failure of this refresh token call.</p>
","689779","","","","","2022-03-23 09:14:42","Swift: Return publisher after another publisher is done","<swift><combine>","1","5","","","","CC BY-SA 4.0"
"71564445","1","71564601","","2022-03-21 21:38:49","","-1","89","<p><em>NetworkManager</em> class has <em>fetchData</em> generic function for fetching data from Internet.</p>
<pre><code>class NetworkManager {
    
    func fetchData&lt;T: Decodable&gt;(url: URL) -&gt; AnyPublisher&lt;T, ErrorType&gt; {
        URLSession
            .shared
            .dataTaskPublisher(for: url)
            .tryMap { data, _ in
                return try JSONDecoder().decode(T.self, from: data)
            }
            .mapError { error -&gt; ErrorType in
                switch error {
                case let urlError as URLError:
                    switch urlError.code {
                    case .notConnectedToInternet, .networkConnectionLost, .timedOut:
                        return .noInternetConnection
                    case .cannotDecodeRawData, .cannotDecodeContentData:
                        return .empty
                    default:
                        return .general
                    }
                default:
                    return .general
                }
            }
            .eraseToAnyPublisher()
    }

}
</code></pre>
<p>In <em>HomeRepositoryImpl</em> class I am trying to get data from specific url with <em>AnyPublisher&lt;[CountryDayOneResponse], ErrorType&gt;</em> return value. I wanted to sort responed array, so I used <em>flatMap</em> on <em>NetworkManager</em> like this:</p>
<pre><code>func getCountryStats(for countryName: String) -&gt; AnyPublisher&lt;[CountryDayOneResponse], ErrorType&gt; {
    let url = RestEndpoints.countryStats(countryName: countryName).endpoint()

    return NetworkManager().fetchData(url: url)
        .flatMap { result -&gt; AnyPublisher&lt;[CountryDayOneResponse], ErrorType&gt; in
            switch result {
            case .success(var response):
                let filteredCountry = Array(response.sorted(by: {$0.date &gt; $1.date}))
                response = filteredCountry
                return response
            case .failure(let error):
                return error
            }
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>But I am getting <em>Unable to infer type of a closure parameter 'result' in the current context</em> error.</p>
","16455916","","421018","","2022-03-21 21:47:38","2022-03-21 22:45:49","unable to infer type in flatMap","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"71568376","1","71654429","","2022-03-22 07:38:53","","1","258","<p>I try to show progress of file downloading with combine and Alamofire. I have downloader class</p>
<pre><code>class DataManager: NSObject, DataManagerProtocol {
    private(set) var value = 0.0 {
        didSet { subject.send(value) }
    }

    private let subject = PassthroughSubject&lt;Double, Never&gt;()

    func increment(by value: Double) {
        self.value = value
    }
    
    func saveFile(urlString: String, fileName: String) -&gt; AnyPublisher&lt;Double, Never&gt; {
        download(urlString: urlString, fileName: fileName)
        return subject.eraseToAnyPublisher()
    }
    
    private func download(urlString: String, fileName: String) {
        AF.download(urlString)
            .downloadProgress { [self] progress in
                print(&quot;Download Progress: \(progress.fractionCompleted)&quot;)
                increment(by: progress.fractionCompleted)
            }
            .responseData { response in
                if let data = response.value {
                    print(&quot;data recieved&quot;)
                    self.writeToFile(data: data, fileName: fileName)
                }
            }
    }
    
    func writeToFile(data: Data, fileName: String) {
        // get path of directory
        
        guard let directory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).last else {
            return
        }
        // create file url
        let fileurl =  directory.appendingPathComponent(filename)
        if FileManager.default.fileExists(atPath: fileurl.path) {
            if let fileHandle = FileHandle(forWritingAtPath: fileurl.path) {
                print(&quot;FileExist&quot;)
            } else {
                print(&quot;Can't open file to write.&quot;)
            }
        } else {
            // if file does not exist write data for the first time
            do {
                try data.write(to: fileurl, options: .atomic)
            } catch {
                print(&quot;Unable to write in new file.&quot;)
            }
        }
    }
}
</code></pre>
<p>in console I see and file success downloaded</p>
<blockquote>
<p>Download Progress: 0.2707762694368025 Download Progress:
0.30361701168087313 Download Progress: 0.45961053734020857 Download Progress: 0.5088716507063145 Download Progress: 0.5827633207554733
Download Progress: 0.615604062999544 Download Progress:
0.6484448052436146 Download Progress: 0.7798077742198971 Download Progress: 0.8783300009521089 Download Progress: 1.0 data recieved</p>
</blockquote>
<p>but in my ViewModel i dont see publishing of progress changing</p>
<pre><code>import Combine

final class RecordsListViewModel: ObservableObject {
    private var cancellable: AnyCancellable?
    private(set) var progress = PassthroughSubject&lt;Double, Never&gt;()
    private let dataManager: DataManagerProtocol
    
    init(dataManager: DataManagerProtocol) {
        self.dataManager = dataManager
    }
    
    func downloadFile() {
        cancellable = dataManager.saveFile(urlString: &quot;https://i.artfile.ru/2880x1800_1455670_[www.ArtFile.ru].jpg&quot;, fileName: &quot;filename.jpg&quot;)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                print(completion, &quot;completion&quot;)
            } receiveValue: { progress in
                print(progress, &quot;progress&quot;)
            }
    }
}
</code></pre>
","8909145","","","","","2022-04-01 07:59:00","downloading progress with combine","<swift><alamofire><combine>","1","1","","","","CC BY-SA 4.0"
"71575484","1","71575717","","2022-03-22 16:20:26","","2","186","<p>In <em>HomeRepositoryImpl</em> is <em>getWorldWideData</em> function which returns <em>AnyPublisher&lt;WorldwideResponseItem, ErrorType&gt;</em></p>
<pre><code>func getWorldwideData() -&gt; AnyPublisher&lt;WorldwideResponseItem, ErrorType&gt; {
    let url = RestEndpoints.worldwideStats.endpoint()
    let publisher: AnyPublisher&lt;WorldwideResponseItem, ErrorType&gt; = RestManager().fetchData(url: url)
    
    return publisher
        .flatMap {
            let filteredCountries = Array($0.countries.sorted(by: {$0.totalConfirmed &gt; $1.totalConfirmed}).prefix(3))
            $0.countries = filteredCountries
            return Just($0)
        }
}
</code></pre>
<p>FlatMap takes <em>WorldResponseItem</em> from publisher and <em>WorldResponseItem</em> has <em>countries</em> array property which I wanted to sort, so I created new variable called <em>filteredCountries</em> and changed it value to array with 3 sorted countries, and I changed <em>WorldResponseItem</em> countries property to <em>filteredCountries</em> and flatMap is returning Just with <em>WorldResponseItem</em> from publisher.</p>
<p>But I am getting <em>No 'flatMap' candidates produce the expected contextual result type 'AnyPublisher&lt;WorldwideResponseItem, ErrorType&gt;'</em> error, and when I add <em>.eraseToAnyPublisher()</em> to pipeline, I am getting <em>Type of expression is ambiguous without more context</em></p>
","16455916","","4667835","","2022-03-22 16:23:27","2022-03-22 16:37:11","Combine flatMap returning no expected contextual result type","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"71606389","1","71609822","","2022-03-24 16:50:51","","0","70","<p>I have a <strong>CATiledLayer</strong> inside a <strong>NSView</strong> which is a <strong>documentView</strong> property of <strong>NSScrollView</strong>.
Storyboard setup is pretty straitforward: add <strong>NSScrollView</strong> to the default view controller and assign <strong>View</strong> class to the <strong>NSView</strong> of clipping view.</p>
<p>The following code draws a number of squares of random color. Scrolling works exactly as it should in <strong>CATiledLayer</strong> but zooming doesn't work very well:</p>
<p><a href=""https://i.stack.imgur.com/YXrs5.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YXrs5.gif"" alt=""enter image description here"" /></a></p>
<p>Found tons of <strong>CATiledLayer</strong> problems and all the proposed solutions don't work for me (like subclassing with 0 <strong>fadeDuration</strong> or disabling <strong>CATransaction</strong> actions). I guess that <strong>setNeedsDisplay()</strong> screws it all but can't figure out the proper way to do that. If I use <strong>CALayer</strong> then I don't see the flashing issues but then I can't deal with large layers of thousands of boxes inside.</p>
<p>The <strong>View</strong> class source:</p>
<pre><code>import Cocoa
import CoreGraphics
import Combine

let rows = 1000
let columns = 1000
let width = 50.0
let height = 50.0

class View: NSView {
    typealias Coordinate = (x: Int, y: Int)
    
    private let colors: [[CGColor]]
    private let rect = CGRect(origin: .zero, size: CGSize(width: width, height: height))
    private var store = Set&lt;AnyCancellable&gt;()
    private var scale: CGFloat {
        guard let scrollView = self.superview?.superview as? NSScrollView else { fatalError() }
        return NSScreen.main!.backingScaleFactor * scrollView.magnification
    }
    
    required init?(coder: NSCoder) {
        colors = (0..&lt;rows).map { _ in (0..&lt;columns).map { _ in .random } }
        super.init(coder: coder)
        
        setFrameSize(NSSize(width: width * CGFloat(columns), height: height * CGFloat(rows)))
        
        wantsLayer = true
        
        NotificationCenter.default.publisher(for: NSScrollView.didEndLiveMagnifyNotification).sink { [unowned self] _ in
            self.layer?.contentsScale = scale
            self.layer?.setNeedsDisplay()
        }.store(in: &amp;store)
    }
    
    override func makeBackingLayer() -&gt; CALayer {
        let layer = CATiledLayer()
        layer.tileSize = CGSize(width: 1000, height: 1000)
        return layer
    }
    
    override func draw(_ dirtyRect: NSRect) {
        guard let context = NSGraphicsContext.current?.cgContext else { return }
        
        let (min, max) = coordinates(in: dirtyRect)
        
        context.translateBy(x: CGFloat(min.x) * width, y: CGFloat(min.y) * height)
        
        (min.y...max.y).forEach { row in
            context.saveGState()
            
            (min.x...max.x).forEach { column in
                context.setFillColor(colors[row][column])
                context.addRect(rect)
                context.drawPath(using: .fillStroke)
                
                context.translateBy(x: width, y: 0)
            }
            
            context.restoreGState()
            context.translateBy(x: 0, y: height)
        }
    }
    
    private func coordinates(in rect: NSRect) -&gt; (Coordinate, Coordinate) {
        var minX = Int(rect.minX / width)
        var minY = Int(rect.minY / height)
        var maxX = Int(rect.maxX / width)
        var maxY = Int(rect.maxY / height)
        
        if minX &gt;= columns {
            minX = columns - 1
        }
        
        if maxX &gt;= columns {
            maxX = columns - 1
        }
        
        if minY &gt;= rows {
            minY = rows - 1
        }
        
        if maxY &gt;= rows {
            maxY = rows - 1
        }
        
        return ((minX, minY), (maxX, maxY))
    }
}


extension CGColor {
    class var random: CGColor {
        let random = { CGFloat(arc4random_uniform(255)) / 255.0 }
        return CGColor(red: random(), green: random(), blue: random(), alpha: random())
    }
}
</code></pre>
","1033865","","","","","2022-03-24 21:46:50","CATiledLayer in NSView flashes on changing contentsScale","<swift><macos><core-animation><catiledlayer>","1","1","","","","CC BY-SA 4.0"
"71624410","1","71624596","","2022-03-26 00:28:10","","0","91","<p>I have the following simple SwiftUI view which contains a component containing a list of marketing preference options with checkboxes and a button to update the preferences:</p>
<pre><code>@StateObject var marketingPreferencesViewModel: MarketingPreferencesViewModel

var body: some View {
    VStack {
        MarketingPreferencesView(viewModel: .init())
        Button {
            marketingPreferencesViewModel.marketingUpdateRequested()
        } label: {
            Text(&quot;Update prefs&quot;)
        }
    }
}
</code></pre>
<p>MarketingPreferencesView is as follows:</p>
<pre><code>struct MarketingPreferencesView: View {

@ObservedObject var viewModel: MarketingPreferencesViewModel

var body: some View {
    VStack(alignment: .leading) {
        marketingPreference(type: .email)
        marketingPreference(type: .directMail)
        marketingPreference(type: .notification)
        marketingPreference(type: .sms)
        marketingPreference(type: .telephone)
    }
}

func marketingPreference(type: MarketingOptions) -&gt; some View {
    HStack {
        if viewModel.preferencesAreLoading {
            ProgressView()
        } else {
            Button {
                switch type {
                case .email:
                    viewModel.emailMarketingEnabled.toggle()
                case .notification:
                    viewModel.notificationMarketingEnabled.toggle()
                case .sms:
                    viewModel.smsMarketingEnabled.toggle()
                case .telephone:
                    viewModel.telephoneMarketingEnabled.toggle()
                case .directMail:
                    viewModel.directMailMarketingEnabled.toggle()
                }
                
            } label: {
                switch type {
                case .email:
                    viewModel.emailMarketingEnabled ? Image.General.Checkbox.checked : Image.General.Checkbox.unChecked
                // ... remaining switch cases follow same pattern
                }
            }
        }
        Text(type.title())
    }
    .padding(.bottom, Constants.bottomPadding)
}
</code></pre>
<p>}</p>
<p>And the MarketingPreferencesViewModel:</p>
<pre><code> class MarketingPreferencesViewModel: ObservableObject {
    @Published var emailMarketingEnabled = false {
        didSet {
            print(emailMarketingEnabled)
        }
    }
    @Published var directMailMarketingEnabled = false
    @Published var notificationMarketingEnabled = false
    @Published var smsMarketingEnabled = false
    @Published var telephoneMarketingEnabled = false
    
    private func updateMarketingPreferences() {
        // For now, just printing emailMarketingEnabled value for debugging
        print(emailMarketingEnabled)
    }
    
    func marketingUpdateRequested() {
         self.updateMarketingPreferences()
       }  
    }
}
</code></pre>
<p>So the user taps on the marketing preference button, this toggles the corresponding value in the view model.</p>
<p>However, for some reason when I hit the marketingUpdateRequested() method, if I check the value of emailMarketingEnabled, it is always false even if I have toggled it already.</p>
<p>Steps to reproduce:</p>
<ul>
<li>Tap on the emailMarketingEnabled button</li>
<li>'true' is printed in the console</li>
<li>tap on the 'Update prefs' button</li>
<li>'false' is printed</li>
</ul>
<p>I have placed the didSet on the emailMarketingEnabled property to see if it changes elsewhere, and it does not. Why then, once I have set to true, is this then false when I tap the button?</p>
","7188537","","62576","","2022-03-26 00:33:24","2022-03-26 01:12:56","Published Bool variable resetting automatically","<swift><swiftui><publisher><observedobject>","1","0","","","","CC BY-SA 4.0"
"71652616","1","71655103","","2022-03-28 19:15:09","","0","75","<p>I try to implement a simple player app with a tracks list where each row has a play button, and if I press Play for one track, current playing track (if any) should stop playing (in this case Play button should change icon). Here I got some questions - how do I identify current playing track (where Play button is in playing mode), how can I reset it to initial state so that only one track plays at a time.</p>
<p>In this example multiple buttons can be switched to playing state, not exclusively one as desired</p>
<pre><code>import SwiftUI

class Audio: ObservableObject, Identifiable {
    let id = UUID()
    var title: String
    @Published var isPlaying = false {
        didSet {
            print(isPlaying)
        }
    }
    
    init(title: String) {
        self.title = title
    }
}

class AudiosFetcher: ObservableObject {
    
    @Published var audios = [Audio]()
    
    func fetchAudios() {
        audios = [
            Audio(title: &quot;track 1&quot;),
            Audio(title: &quot;track 2&quot;),
            Audio(title: &quot;track 3&quot;)
        ]
    }
    
}

struct ListRow: View {
    
    @ObservedObject var audio: Audio
    
    var body: some View {
        HStack {
            Button(action: {
                audio.isPlaying.toggle()
            }) {
                Image(systemName: audio.isPlaying ? &quot;pause.circle&quot; : &quot;play.circle&quot;)
            }
            .buttonStyle(BorderlessButtonStyle())
            .font(.largeTitle)
            
            Text(audio.title)
        }
    }
}

struct ContentView: View {
    
    @ObservedObject var audiosFetcher = AudiosFetcher()
    
    var body: some View {
        List(audiosFetcher.audios, id: \.id) { audio in
            ListRow(audio: audio)
        }.onAppear {
            audiosFetcher.fetchAudios()
        }
    }
}
</code></pre>
<p><strong>Update: solution</strong></p>
<p>Thanks to @Yrb's answer, we can do it like this. Maybe <code>AudiosFetcher</code> is not the best place to hold current playing audio, but it works and can be extracted to a separate entity if needed</p>
<pre><code>struct ContentView: View {
    // The intialization of the ObservableObject should be a @StateObject,
    // not an @ObservedObject.
    @StateObject var audiosFetcher = AudiosFetcher()
    
    var body: some View {
        List($audiosFetcher.audios) { audio in
            ListRow(audiosFetcher: audiosFetcher, audio: audio)
        }
        .onAppear {
            audiosFetcher.fetchAudios()
        }
    }
}

struct ListRow: View {
    
    @StateObject var audiosFetcher: AudiosFetcher
    @Binding var audio: Audio
    
    var body: some View {
        HStack {
            Button(action: {
                audiosFetcher.playingAudio = (audiosFetcher.playingAudio == audio ? nil : audio)
            }) {
                Image(systemName: audiosFetcher.playingAudio == audio ? &quot;pause.circle&quot; : &quot;play.circle&quot;)
            }
            .buttonStyle(BorderlessButtonStyle())
            .font(.largeTitle)
            
            Text(audio.title)
        }
    }
}

struct Audio: Identifiable, Equatable {
    let id = UUID()
    var title: String
    
    init(title: String) {
        self.title = title
    }
}

class AudiosFetcher: ObservableObject {
    
    @Published var audios = [Audio]()
    @Published var playingAudio: Audio?
    
    func fetchAudios() {
        audios = [
            Audio(title: &quot;track 1&quot;),
            Audio(title: &quot;track 2&quot;),
            Audio(title: &quot;track 3&quot;)
        ]
    }
}
</code></pre>
","3004003","","3004003","","2022-03-29 07:49:58","2022-03-29 07:49:58","SwiftUI: toggle buttons state inside List","<swiftui><binding><combine>","2","0","","","","CC BY-SA 4.0"
"71665010","1","71666059","","2022-03-29 15:39:54","","0","100","<p>I am using this code in a SwiftUI view model:</p>
<pre><code>    car.publisher(for: \.sold, options: [.new])
        .removeDuplicates()
        .receive(on: RunLoop.main)
        .sink { [weak self] sold in
            guard let self = self else { return }
            .... here is reference the car entity for some logic ....
        }
        .store(in: &amp;subscribers)
</code></pre>
<p>All works fine, until I actually delete that Car entity and the sink kicks in and then <code>.... here is reference the car entity for some logic ....</code> runs and it crashes trying to use a DELETED Core Data entity.</p>
<p>My pattern seems to be wrong here. Is there a way for that sink to cancel automatically when that car entity is deleted from context?</p>
","728246","","","","","2022-03-29 16:59:17","Swift Combine: sink() called after core data entity deletion","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"71667815","1","71667887","","2022-03-29 19:29:52","","1","403","<p>Today I refactored a ViewModel for a SwiftUI view to structured concurrency. It fires a network request and when the request comes back, updates a <code>@Published</code> property to update the UI. Since I use a <code>Task</code> to perform the network request, I have to get back to the <code>MainActor</code> to update my property, and I was exploring different ways to do that. One straightforward way was to use <code>MainActor.run</code> inside my <code>Task</code>, which works just fine. I then tried to use <code>@MainActor</code>, and don't quite understand the behaviour here.</p>
<p>A bit simplified, my ViewModel would look somewhat like this:</p>
<pre><code>class ContentViewModel: ObservableObject {
    
    @Published var showLoadingIndicator = false
    
    @MainActor func reload() {
        showLoadingIndicator = true
        
        Task {
            try await doNetworkRequest()
            showLoadingIndicator = false
        }
    }
    
    @MainActor func someOtherMethod() {
        // does UI work
    }
    
}
</code></pre>
<p>I would have expected this to not work properly.</p>
<p>First, I expected SwiftUI to complain that <code>showLoadingIndicator = false</code> happens off the main thread. It didn't. So I put in a breakpoint, and it seems even the <code>Task</code> within a <code>@MainActor</code> is run on the main thread. Why that is is maybe a question for another day, I think I haven't quite figured out <code>Task</code> yet. For now, let's accept this.</p>
<p>So then I would have expected the UI to be blocked during my networkRequest - after all, it is run on the main thread. But this is not the case either. The network request runs, and the UI stays responsive during that. Even a call to another method on the main actor (e.g. <code>someOtherMethod</code>) works completely fine.<br />
Even running something like <code>Task.sleep()</code> within <code>doNetworkRequest</code> will STILL work completely fine. This is great, but I would like to understand why.</p>
<p>My questions:<br />
a) Am I right in assuming a <code>Task</code> within a <code>MainActor</code> does not block the UI? Why?<br />
b) Is this a sensible approach, or can I run into trouble by using <code>@MainActor</code> for dispatching asynchronous work like this?</p>
","1421550","","1264804","","2022-03-29 19:32:00","2022-03-29 19:37:29","Why does a Task within a @MainActor not block the UI?","<swift><swiftui><actor><combine><structured-concurrency>","1","2","","","","CC BY-SA 4.0"
"71670739","1","71671698","","2022-03-30 02:10:02","","0","70","<p>I have RestManager class for fetching data from Internet.</p>
<p>I wanted to made special case when empty array is decoded function returns error.</p>
<p>So I made this</p>
<pre><code>class RestManager {

    func fetchData&lt;T: Decodable&gt;(url: URL) -&gt; AnyPublisher&lt;T, ErrorType&gt; {
        URLSession
        .shared
        .dataTaskPublisher(for: url)
        .tryMap { data, _ in
            let value = try JSONDecoder().decode(T.self, from: data)
            if let array = value as? [AnyObject], array.isEmpty {
                throw ErrorType.empty
            }
            return value
        }
        .mapError { error -&gt; ErrorType in
            switch error {

            case is Swift.DecodingError:
                return ErrorType.empty

            case let urlError as URLError:
                switch urlError.code {
                case .notConnectedToInternet, .networkConnectionLost, .timedOut:
                    return .noInternetConnection
                case .cannotDecodeRawData, .cannotDecodeContentData:
                    return .empty
                default:
                    return .general
                }
            default:
                return .general
            }
        }
        .eraseToAnyPublisher()
   }
}
</code></pre>
<p>But the problem is that returning ErrorType is <em>.general</em> instead of <em>.empty</em></p>
","16455916","","","","","2022-03-30 04:54:57","decoding empty array not throwing specified array","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"71695956","1","71727699","","2022-03-31 16:17:08","","0","174","<p>Working with <code>flagpedia.net/download/api</code></p>
<p>It has two endpoints:</p>
<p>1 - Returns [String:String] dictionary of code-country pairs, like [“us”:”United States”] as a json</p>
<p>2 - Returns an image data for a country code and specified image size, example url <code>flagcdn.com/16x12/us.png</code></p>
<p>I have create two functions using regular completion handler</p>
<ul>
<li><code>fetchCodes(completion: @escaping (Result&lt;[String],Error&gt;) -&gt; Void) { … }</code></li>
<li><code>fetchImage(forCode: String, completion: @escaping (Result&lt;UIImage,Error&gt;) -&gt; Void) { … }</code></li>
</ul>
<p>And also their Combine variations</p>
<ul>
<li><code>fetchCodes() -&gt; AnyPublisher&lt;[String],Error&gt; { … }</code></li>
<li><code>fetchImage(forCode: String) -&gt; AnyPublisher&lt;UIImage,Error&gt; { … }</code></li>
</ul>
<p>Both methods works fine, and returns expected result. How could we merge them?</p>
<p>fetchCodes() method decodes json into dictionary and create an array from the keys.</p>
<p>After getting codes: [String] from fetchCodes() want to do something like this:</p>
<ul>
<li><code>var results = [UIImage]()</code></li>
<li><code>for code in codes {</code></li>
<li><code>let image = fetchImage(forCode: code)</code></li>
<li><code>images.append(image)</code></li>
<li><code>}</code></li>
</ul>
<p>How to achieve this?</p>
<p>I tried Publishers.ManyMerge and flatMap but wasn’t successful. Ended up getting warning regarding mismatch in return types.</p>
<p><code>Sorry for the indentation, I’m posting this on mobile.</code></p>
","2916820","","2916820","","2022-03-31 16:24:26","2022-04-07 14:26:31","How to merge multiple network calls’ responses into an array? With or without Combine?","<ios><swift><combine>","1","0","1","","","CC BY-SA 4.0"
"71717828","1","71717875","","2022-04-02 13:10:26","","0","72","<p>I have a Circular ProgressBar View that takes a <code>@Binding var progress: Float</code> property as its progress value, what I would like to be able to do is pass the <code>var progress: Float</code> value from the <code>Task</code> objects respectably in the <code>List</code>. I tried assigning the <code>progress = task.progress</code> the value from the <code>Task</code> objects to a @State property within the ContentView but of course that cannot be done inside a View (see commented code line below).</p>
<p>How can I pass the progress values from each Task to the ProgressBar view respectably?</p>
<h2>Task Model:</h2>
<pre><code>class Task:Identifiable{
    var name = &quot;&quot;
    var progress: Float = 0.0
    
    init(name:String, progress:Float){
        self.name = name
        self.progress = progress
    }
}
</code></pre>
<h2>Content View</h2>
<pre><code>var tasks = [Task(name: &quot;Ketchen Floors&quot;, progress: 0.5),
            Task(name: &quot;Install Windows&quot;, progress: 0.75)]

struct ContentView: View {
    @State var progress:Float = 0.15
    
    var body: some View {
        List {
            ForEach(tasks) { task in
                // outputs error: Type '()' cannot conform to 'View'
                // progress = task.progress 
                HStack{
                    Text(task.name)
                    // here $progress value shoud come from task.progress
                    ProgressBar(progress: $progress)
                }
            }
        }
    }
}
</code></pre>
<h2>ProgressBar View</h2>
<pre><code>struct ProgressBar: View {
    @Binding var progress: Float
    
    var body: some View {
        ZStack {
            Circle()
                .stroke(lineWidth:5.0)
                .opacity(0.3)
                .foregroundColor(Color.orange)
            
            Circle()
                .trim(from: 0.0, to: CGFloat(min(self.progress, 1.0)))
                .stroke(style: StrokeStyle(lineWidth: 5.0, lineCap: .round, lineJoin: .round))
                .foregroundColor(Color.orange)
                .rotationEffect(Angle(degrees: 270.0))
                .animation(.linear, value: progress)

            VStack{
                Text(String(format: &quot;%.0f %%&quot;, min(self.progress, 1.0)*100.0))
                    .font(.caption2)
            }
        }
    }
}
</code></pre>
<h2>Screen</h2>
<p>As you can see, every item shows the initial 15% progress value, no surprise. Again, what I want is to be able to use the value from each Task respectably, Ketchen Floors at 50% and Install Windows at 75%.</p>
<p><a href=""https://i.stack.imgur.com/JNlvp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JNlvp.png"" alt=""enter image description here"" /></a></p>
","1577308","","","","","2022-04-02 13:17:27","How to bind a Float value from a model to a @Binding:Float property in a SwiftUI View","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"71731482","1","71733431","","2022-04-04 02:35:38","","0","239","<p>I have a SwiftUI <code>ProgressBar</code> View that displays the percentage progress based on a percentage-value you enter as a Bindable parameter. The progress percentage-value is calculated by a <code>ReminderHelper</code> class, which takes two Ints as its parameters, <code>totalDays</code> and <code>daysLeft</code>, the values input to the ReminderHelper class come from a <code>Reminder</code> object saved in Core Data.</p>
<p>I'm very confused as to how to structure my code to accomplish such of thing due to the poor understanding of how the SwiftUI/Combine, @Binding, @Published, @State, etc. work.</p>
<p>Based on the code below, what I'm expecting to see is two reminders, <code>Cut the Grass</code> at 20% and <code>Power Wash Siding</code> at 50%.  Again, the two <code>Ints</code> that determine the total percentage progress come from the <code>Reminder</code> object saved in Core Data and the actual total percentage result comes from the <code>RemindersHelper</code> class.</p>
<p>Any idea how to accomplish what I describe above?</p>
<h2>Model:</h2>
<p>This is saved in Core Data.</p>
<pre><code>class Reminder:Identifiable{
    var name = &quot;&quot;
    var totalDays = 0
    var daysLeft = 0
    
    init(name:String, totalDays:Int, daysLeft:Int){
        self.name = name
        self.totalDays = totalDays
        self.daysLeft = daysLeft
    }
}
</code></pre>
<h2>Helper class</h2>
<p>This needs to be in charge of calculating the total percentage that will be passed to the ProgressBar View with the values coming
from the Reminder object saved in Core Data.</p>
<pre><code>class ReminderHelper:ObservableObject{
    @Published var percentageLeft: Float = 0.80
    
    func calculatePerentageLeft(daysLeft: Int, totalDays:Int)-&gt;Float{
        percentageLeft  = Float(daysLeft / totalDays)
        return percentageLeft
    }
}
</code></pre>
<h2>Content View:</h2>
<p>Here I'm calling the <code>calculatePerentageLeft</code> method to prepare the <code>percentageLeft</code> property before presenting the ProgressBar. Which of course is not working.
I see an error:</p>
<blockquote>
<p>Static method 'buildBlock' requires that 'Float' conform to 'View'</p>
</blockquote>
<pre><code>struct ContentView: View {
    var reminders = [Reminder(name: &quot;Cut the Grass&quot;, totalDays: 50, daysLeft: 10),
                Reminder(name: &quot;Power Wash Siding&quot;, totalDays: 30, daysLeft: 15)]
    
    @StateObject var reminderModel = ReminderHelper()
    
    var body: some View {
        List {
            ForEach(reminders) { reminder in
                HStack{
                    Text(reminder.name)
                    reminderModel.calculatePerentageLeft(daysLeft: reminder.daysLeft, totalDays: reminder.totalDays)
                    ProgressBar(progress: reminderModel.percentageLeft)
                }
            }
        }
    }
}
</code></pre>
<h2>ProgressBar View</h2>
<p>This is the view in charge of drawing and displaying the percentage value.</p>
<pre><code>struct ProgressBar: View {
    @Binding var progress: Float
    
    var body: some View {
        ZStack {
            Circle()
                .stroke(lineWidth:5.0)
                .opacity(0.3)
                .foregroundColor(Color.orange)
            
            Circle()
                .trim(from: 0.0, to: CGFloat(min(self.progress, 1.0)))
                .stroke(style: StrokeStyle(lineWidth: 5.0, lineCap: .round, lineJoin: .round))
                .foregroundColor(Color.orange)
                .rotationEffect(Angle(degrees: 270.0))
                .animation(.linear, value: progress)

            VStack{
                Text(String(format: &quot;%.0f %%&quot;, min(self.progress, 1.0)*100.0))
                    .font(.caption2)
            }
        }
    }
}
</code></pre>
","1577308","","","","","2022-04-04 07:28:11","How to dynamically update a SwiftUI View with an @Bindable value","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"71739969","1","71740763","","2022-04-04 15:37:03","","0","73","<p>So I have this problem with a <code>@Published</code> realm result that is not updating in tests.</p>
<p>Basically what I am trying to do is, to test if a realm update is causing my ViewModel to update the ui. To do this I am subscribing to the published field.</p>
<p>This is the Test:</p>
<pre class=""lang-swift prettyprint-override""><code>   func testListUpdate() {
       // when
       let expectation = XCTestExpectation(description: &quot;Wasn't updated.&quot;)

       _ = sut.$stocks
           .dropFirst()
           .sink { value in
               expectation.fulfill()
           }

       try! realm.write {
           realm.add(Stock(value: [&quot;name&quot;: &quot;Test3&quot;]))
       }

       // then
       wait(for: [expectation], timeout: 1)
   }
</code></pre>
<p><code>sut</code> is the ViewModel which looks like this:</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import RealmSwift

class StockListViewModel: ViewModelBase, ObservableObject {
    let stockRepository: StockRepository

    @Published var stocks: Results&lt;Stock&gt;

    init(stockRepository: StockRepository) {
        self.stockRepository = stockRepository

        stocks = stockRepository.all
            .sorted(byKeyPath: &quot;createdAt&quot;, ascending: true)

        super.init(title: &quot;StockList_title&quot;.localize())

        self.notificationTokens.append(
            stocks
                .observe({ change in
                    switch change {
                    case .update(let updated, _, _, _):
                        self.stocks = updated
                    default: break
                    }
                })
        )
    }
}
</code></pre>
<p>As you can see, the viewmodel has as `@Published var stocks: Results.</p>
<p>In the initializer the stocks are set (this update is emitted by the <code>Publisher</code> successfully and tested in another case.</p>
<p>Then I assign a realm change listener to those stocks and when it updates, I set the stocks new (see in the <code>observe</code> closure). This update is really called, but the <code>sink</code> in the test never emits the update. Thus the test fails.</p>
<p>So my question is: Why is the <code>Publisher</code> emitting the initial value, but never the updated one?</p>
","1640012","","4667835","","2022-04-04 15:48:57","2022-04-04 16:37:57","@Published not emitting update in tests","<swift><realm><combine>","2","4","","","","CC BY-SA 4.0"
"71745549","1","71759403","","2022-04-05 01:56:48","","2","286","<p>As part of moving from RX to Combine. What exactly works like &quot;BehaviorRelay&quot; of RxRelay in Swift Combine?</p>
","1909513","","","","","2022-04-05 23:12:19","Alternative for BehaviorRelay in Swift Combine","<rx-swift><combine>","1","1","","","","CC BY-SA 4.0"
"71756471","1","71834974","","2022-04-05 18:06:03","","0","150","<p>I am new to the combine world and have written a query that returns the results I need correctly. It's multi-step, but basically makes an api call over the network, parses the returned json and creates an array of records I need.</p>
<pre class=""lang-swift prettyprint-override""><code>let results2: Publishers.Map&lt;Publishers.ReceiveOn&lt;Publishers.Decode&lt;Publishers.Map&lt;URLSession.DataTaskPublisher, JSONDecoder.Input&gt;, Wrapper&lt;Question&gt;, JSONDecoder&gt;, DispatchQueue&gt;, [Question]&gt;
</code></pre>
<p>I'm trying to rewrite a portion of my code and realize that I still don't quite grasp the ins and outs of parsing the results.
If you look at the datatype of results2 you will see the final portion contains an array of <code>Question</code>. How do I assign this array to a variable, as in:</p>
<pre class=""lang-swift prettyprint-override""><code>let finalAnswer: [Question] = turnThisIntoAnArray(results2)
</code></pre>
<p>If possible, I'd prefer a general answer to this general question, rather than providing all the code needed to recreate this specific string of publishers.</p>
<p>thanks</p>
","5156054","","","","","2022-04-11 22:23:37","How do i parse results from a combine publisher","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"71783587","1","71783622","","2022-04-07 13:59:26","","-1","87","<p>I am adding Combine to my iOS application. To do this, I have updated my create account ViewModel to use Combine rather than my previous implementation. Upon adding Combine to my ViewModel, I was met with an error prompting me to add <code>@available(iOS 13.0, *)</code> to my class. I also must add this attribute to every single VC that uses this ViewModel. My deployment target is iOS 13.0 so I am wondering if this is really necessary. Is there a way I can avoid adding this attribute in each class since I will have no users operating on an iOS version lower than iOS 13.0?</p>
","5568827","","","","","2022-04-07 14:01:24","Do I still need the @availible 13.0 attribute in my class if my minimum deployment target is iOS 13.0?","<ios><swift><combine><deployment-target>","1","1","","","","CC BY-SA 4.0"
"71795155","1","71795365","","2022-04-08 10:05:11","","0","154","<p>I have a variable with default value. And make a network call to get the value from server. If it returns some error, then I want to make the variable to <code>nil</code>. How can I do this with <code>Future</code>, <code>Promise</code>, <code>Combine</code>?</p>
<p><a href=""https://www.vadimbulavin.com/asynchronous-programming-with-future-and-promise-in-swift-with-combine-framework/"" rel=""nofollow noreferrer"">Asynchronous Programming with Futures and Promises in Swift with Combine Framework
</a></p>
","8014650","","8014650","","2022-04-08 10:44:18","2022-04-08 11:37:20","How to assign nil if network call returns error using Combine","<swift><promise><future><combine>","2","0","0","","","CC BY-SA 4.0"
"71825835","1","71837254","","2022-04-11 09:55:15","","1","155","<p>I have an app where I call API request. Some users are experiencing a bug, that application throws timeout error when they close the app while data are being fetched, and later they open it.</p>
<p>I'm using standard URLSession data task as in example bellow:</p>
<pre><code>var session = URLSession(configuration: .ephemeral, delegate: self, delegateQueue: queue)

private func loadModels -&gt; AnyPublisher&lt;[Model], LoadModelsUseCaseError&gt; {
    guard let keyID = keyAdapter.getKeyID() else {
        return Fail&lt;[Model], LoadModelsUseCaseError&gt;(error: .keyIDNotFound).eraseToAnyPublisher()
    }

    let url = Environment.loadModelsURL(for: keyID)

    return apiAdapter.session
        .dataTaskPublisher(for: url)
        .decode(type: [Model].self, decoder: decoder)
        .mapError(LoadModelsUseCaseError.init)
        .eraseToAnyPublisher()
}
</code></pre>
<p>One workaround is to call <code>.retry(1)</code> in view model from which I'm calling the method, but that solution has obvious flaws.</p>
<p>Another workaround is to catch timeout error and call the load method again. That is not perfect either as the request will never time out (even when its relevant case).</p>
<p>Any suggestions how to handle this situation? Many thanks</p>
","3834899","","3834899","","2022-04-13 03:45:18","2022-06-15 08:11:58","URL request times out when app is in the background","<ios><swift><urlsession><background-task>","1","0","1","","","CC BY-SA 4.0"
"71831820","1","71832336","","2022-04-11 17:15:16","","1","85","<p>I have the following code:</p>
<pre><code>    $myBoolean
        .debounce(for: 2, scheduler: RunLoop.main)
        .removeDuplicates()
        .sink { newValue in
            self.myBoolean = false
            ....... 
            ...... (closure called every 2 seconds if I don't use `removeDuplicates()`)
        }
        .store(in: &amp;subscribers)
</code></pre>
<p>I am using sink() on a @Published var in my observable object. Different parts of the app can set that boolean to <code>true</code>. When that happens, I want the code in <code>sink()</code> to run.</p>
<p>When that happens I want the code to reset <code>myBoolean</code> to false. So, only when I know the sink() code runs I want the boolean to be set back to false.</p>
<p>How can I set myBoolean back to false only when the sink() code runs without cause endless calls to the sink()?</p>
<p><code>myBoolean</code> is declared like so:</p>
<pre><code>@Published fileprivate var myBoolean:Bool = false
</code></pre>
","728246","","","","","2022-04-11 18:08:49","Combine: resetting observed boolean within sink() call?","<ios><swift><combine>","1","1","","","","CC BY-SA 4.0"
"71833216","1","71834482","","2022-04-11 19:20:08","","0","254","<p>I have the results from a publisher in an <code>Effect&lt;[Int], Error&gt;</code>
How do I assign that [Int] to a variable?</p>
<p>Although I am able to get the results using this:</p>
<pre><code>         case .reviewed:
               return environment.networkQuery.reviewed(pageCount: 1)
                  .catchToEffect()
                  .map(BespokeAction.processQueryResults)
         case let .processQuestionResult(.success(ids)):
             ...
  
         case let .processQuestionResult(.failure(error)):
            print(error)
           ...
</code></pre>
<p>I want to use the publisher outside of the reducer:</p>
<pre><code>let values: Effect&lt;[Question], Error&gt; = environment.networkQuery.reviewed(pageCount: 1)
</code></pre>
<p>what do I do to <code>values</code> to extract the array upon success?</p>
<p>note: this a more finely resolved take on a question I posted previously:</p>
<p><a href=""https://stackoverflow.com/questions/71756471/how-do-i-parse-results-from-a-combine-publisher"">previously asked</a></p>
","5156054","","","","","2022-04-11 22:29:08","In TCA: How to extract from Effect when not in the reducer?","<swift><combine><swift-composable-architecture>","1","0","","","","CC BY-SA 4.0"
"71835198","1","71835409","","2022-04-11 22:55:55","","1","76","<p>I am observing a peculiar behavior in my SwiftUI code and narrowed it down to the following minimal example.</p>
<p>Given this example storage holding an array of book model structs.</p>
<pre class=""lang-swift prettyprint-override""><code>struct Book: Identifiable {
    let id: UUID
    var likes: Int
    var unusedProperty: String = &quot;&quot;
}

extension Book: Equatable {
    static func == (lhs: Book, rhs: Book) -&gt; Bool {
        return lhs.id == rhs.id
    }
}

class MyStorage: ObservableObject {

    @Published var books: [Book] = [
        .init(id: .init(uuidString: &quot;B2A44450-BC03-47E6-85BE-E89EA69AF5AD&quot;)!, likes: 0),
        .init(id: .init(uuidString: &quot;F5AB9D18-DF73-433E-BB48-1C757CB6F8A7&quot;)!, likes: 0)
    ]

    func addLike(to book: Book) {
        for i in books.indices where books[i].id == book.id {
            books[i].likes += 1
        }
    }
}
</code></pre>
<p>And using it in this simple view hierarchy:</p>
<pre class=""lang-swift prettyprint-override""><code>struct ReducedContentView: View {
    @StateObject var storage: MyStorage = MyStorage()

    var body: some View {
        VStack(spacing: 8) {
            ForEach(storage.books) { book in
                HStack {
                    VStack(alignment: .leading) {
                        Text(&quot;Top-Level: \(book.likes)&quot;)
                        BookView(book: book)
                    }
                    Spacer()
                    Button(&quot;Add Like&quot;) {
                        storage.addLike(to: book)
                    }
                }.padding(.horizontal)
            }
        }
    }
}

struct BookView: View {
    let book: Book

    var body: some View {
        Text(&quot;Nested: \(book.likes)&quot;)
            .foregroundColor(.red)
    }
}
</code></pre>
<p>Any changes to the <code>likes</code> property don't propagate to the <code>BookView</code>, only to the &quot;top-level&quot; <code>Text</code>.</p>
<p><a href=""https://i.stack.imgur.com/a3si7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/a3si7.png"" alt=""enter image description here"" /></a></p>
<p>Now, <strong>if I change one of the following</strong>, it works:</p>
<ul>
<li>remove the <code>unusedProperty</code> (which is needed in production)</li>
<li>add <code>&amp;&amp; lhs.likes == rhs.likes</code> to the Equatable conformance (which is not intended)</li>
<li>modify <code>BookView</code> to accept <code>@Binding var book: Book</code> instead of a <code>let</code></li>
</ul>
<p>The last option is something I could adopt in my production code - nevertheless, I would really like to understand what's happening here, so any hints would be greatly appreciated.</p>
","5328140","","","","","2022-04-11 23:32:46","SwiftUI does not reliably propagate changes to child view","<ios><swift><swiftui><combine>","1","0","0","","","CC BY-SA 4.0"
"71914981","1","71917828","","2022-04-18 17:22:15","","2","169","<p>I am looking for a way to use <code>CoreData</code> Objects using <strong>MVVM</strong> (ditching <code>@FetchRequest</code>). After experimenting, I have arrived at the following implementation:</p>
<p>Package URL: <a href=""https://github.com/NoeOnJupiter/CoreDataStruct"" rel=""nofollow noreferrer"">https://github.com/NoeOnJupiter/CoreDataStruct</a></p>
<p>Datable.swift:</p>
<pre><code>protocol Datable {
    associatedtype Object: NSManagedObject
//MARK: - Mapping
    static func map(from object: Object) -&gt; Self
    func map(from object: Object) -&gt; Self
//MARK: - Entity
    var object: Object {get}
//MARK: - Fetching
    static var modelData: ModelData&lt;Self&gt; {get}
//MARK: - Writing
    func save()
}

extension Datable {
    static var modelData: ModelData&lt;Self&gt; {
        return ModelData()
    }
    func map(from object: Object) -&gt; Self {
        return Self.map(from: object)
    }
    func save() {
        _ = object
        let viewContext = PersistenceController.shared.container.viewContext
        do {
            try viewContext.save()
        }catch {
            print(String(describing: error))
        }
    }
}

extension Array {
    func model&lt;T: Datable&gt;() -&gt; [T] {
        return self.map({T.map(from: $0 as! T.Object)})
    }
}
</code></pre>
<p>ModelData.swift:</p>
<pre><code> class ModelData&lt;T: Datable&gt;: NSObject, ObservableObject, NSFetchedResultsControllerDelegate {
    var publishedData = CurrentValueSubject&lt;[T], Never&gt;([])
    private let fetchController: NSFetchedResultsController&lt;NSFetchRequestResult&gt;
    override init() {
        let fetchRequest = T.Object.fetchRequest()
        fetchRequest.sortDescriptors = []
        fetchController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: PersistenceController.shared.container.viewContext, sectionNameKeyPath: nil, cacheName: nil)
        super.init()
        fetchController.delegate = self
        do {
            try fetchController.performFetch()
            publishedData.value = (fetchController.fetchedObjects as? [T.Object] ?? []).model()
        }catch {
            print(String(describing: error))
        }
    }
    func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {
        guard let data = controller.fetchedObjects as? [T.Object] else {return}
        self.publishedData.value = data.model()
    }
}
</code></pre>
<p>Attempt.swift:</p>
<pre><code>struct Attempt: Identifiable, Hashable {
    var id: UUID?
    var password: String
    var timestamp: Date
    var image: Data?
}

//MARK: - Datable
extension Attempt: Datable {
    var object: AttemptData {
        let viewContext = PersistenceController.shared.container.viewContext
        let newAttemptData = AttemptData(context: viewContext)
        newAttemptData.password = password
        newAttemptData.timestamp = timestamp
        newAttemptData.image = image
        return newAttemptData
    }
    static func map(from object: AttemptData) -&gt; Attempt {
        return Attempt(id: object.aid ?? UUID(), password: object.password ?? &quot;&quot;, timestamp: object.timestamp ?? Date(), image: object.image)
    }
}
</code></pre>
<p>ViewModel.swift:</p>
<pre><code>class HomeViewModel: BaseViewModel {
    @Published var attempts = [Attempt]()
    required init() {
        super.init()
        Attempt.modelData.publishedData.eraseToAnyPublisher()
            .sink { [weak self] attempts in
                self?.attempts = attempts
            }.store(in: &amp;cancellables)
    }
}
</code></pre>
<p>So far this is working like a charm, however I wanted to check if this is the best way to do it, and improve it if possible. Please note that I have been using <code>@FetchRequest</code> with <code>SwiftUI</code> for over a year now and decided to move to <strong>MVVM</strong> since I am using it in all my <code>Storyboard</code> projects.</p>
","13278922","","13278922","","2022-08-01 13:16:56","2022-08-01 13:16:56","Core Data with SwiftUI MVVM Feedback","<swift><mvvm><core-data><swiftui>","1","0","","","","CC BY-SA 4.0"
"71941789","1","71945202","","2022-04-20 14:50:57","","0","43","<p>I have two classes here. <code>Music</code> which is used to store music url and load metadata, and <code>MusicManager</code> which is used to store a list of music and sort them after loading of  all music's metadata finished.</p>
<p>Since the loading of metadata for each music <code>let metadata = try? await asset.load(.commonMetadata)</code> is asynchronous, I can't directly call sort function in <code>init()</code>.</p>
<p>I tried to find some solution using <code>Publisher</code> in Combine framework that when the metadata is loaded, the publisher will emit a completion, and if <code>MusicManager</code> received enough completion (same as music list's count), it will perform the sort.</p>
<pre><code>class Music: ObservableObject, Identifiable {
    static let publisher = PassthroughSubject&lt;Void,Error&gt;
......
}

class MusicManager: ObservableObject {
......
    static var count = 0
    let subscriber = Music.pub.sink { completion in
        switch completion {
        case .finished:
            count += 1
            if musicList.count == count {
                ......
            }
        case .failure(_):
        }
    } receiveValue: { _ in }
......
}
</code></pre>
<p>But it said <code>Instance member 'library' cannot be used on type 'MusicListManager'; did you mean to use a value of this type instead?</code></p>
<p>How can I am informed, when all music's metadata are already loaded. I would appreciate it if you can give me some advice.</p>
","14367125","","","","","2022-05-01 14:18:11","Is there a way in SwiftUI to transport and handle data from an property to the class?","<swift><swiftui>","1","1","0","","","CC BY-SA 4.0"
"71944529","1","71944646","","2022-04-20 18:27:31","","0","29","<p>I am trying to decode a Publisher in another file which is dataService.$data, it is:</p>
<pre><code>@Published var data: Data? = nil
</code></pre>
<p>Before I was using a Networking manager and it returned AnyPublisher&lt;Data, Error&gt;</p>
<pre><code>let dataDownload = NetworkingManager.download(url: url)
</code></pre>
<pre><code>casaSubscription = dataService.$data
            .decode(type: [House].self, decoder: XMLDecoder())
            .sink(receiveCompletion: NetworkingManager.handleCompletion, receiveValue: { [weak self] (returnedCasas) in
                self?.house = returnedCasas
                self?.houseSubscription?.cancel()
            })
</code></pre>
<p>Instead of dataService.$data I had dataDownload and it all worked fine, but now, I try to use dataService.$data and it throws the error below</p>
<p><code>Instance method 'decode(type:decoder:)' requires the types 'Published&lt;Data?&gt;.Publisher.Output' (aka 'Optional&lt;Data&gt;') and 'Data' be equivalent</code></p>
","8307719","","","","","2022-04-20 18:42:25","Decode Data? from another publisher","<swift>","1","1","","","","CC BY-SA 4.0"
"71990061","1","71991527","","2022-04-24 15:55:20","","0","303","<p>I'm currently migrating code that was using Combine Publisher to an AsyncSequence.  I previously used this alongside <code>@Published</code> search query that user could type in and now trying to &quot;combine&quot; that search term with <code>AsyncSequence</code> based data source such as following (using <code>values</code> to convert the search query to <code>AsyncSequence</code> as well).  However, I'm only seeing the <code>flatMap</code> code being executed once initially.</p>
<pre><code>@MainActor
class FantasyPremierLeagueViewModel: ObservableObject {
    @Published var playerList = [Player]()
    @Published var query: String = &quot;&quot;
    
    private let repository: FantasyPremierLeagueRepository
    init(repository: FantasyPremierLeagueRepository) {
        self.repository = repository
        
        Task {
            let playerStream = asyncStream(for: repository.playerListNative)
            
            let filteredPlayerStream = $query
                .debounce(for: 0.5, scheduler: DispatchQueue.main)
                .values
                .flatMap { query in
                    playerStream
                        .map { $0.filter { uery.isEmpty || $0.name.contains(query) } }
                }
                .map { $0.sorted { $0.points &gt; $1.points } }
                
            
            for try await data in filteredPlayerStream {
                self.playerList = data
            }
        }
    }
}
</code></pre>
<p>Code pushed to branch and can also be viewed in <a href=""https://github.com/joreilly/FantasyPremierLeague/blob/kmp_native_coroutines/ios/FantasyPremierLeague/FantasyPremierLeague/ViewModel.swift"" rel=""nofollow noreferrer"">https://github.com/joreilly/FantasyPremierLeague/blob/kmp_native_coroutines/ios/FantasyPremierLeague/FantasyPremierLeague/ViewModel.swift</a></p>
","793861","","793861","","2022-04-24 16:00:23","2022-04-24 19:06:33","Using Combine Publisher with AsyncSequence","<swift><async-await><combine>","1","4","","","","CC BY-SA 4.0"
"71990764","1","71996142","","2022-04-24 17:31:18","","1","33","<p>I am new to swift .I want to display the records with image view in table view cell . I have defined the property with leadingAnchor , trailingAnchor, widthAnchor, heightAnchor with content view . But when I run the app it overlapping the view .</p>
<p>Here is the code in cell .</p>
<pre><code>import UIKit

class PeopleCell: UITableViewCell {

    
    static let identifier = &quot;PeopleCell&quot;
    
    let containerView:UIView = {
        let view = UIView()
        view.translatesAutoresizingMaskIntoConstraints = false
        view.clipsToBounds = true // this will make sure its children do not go out of the boundary
        return view
    }()
    
    let profileImageView:UIImageView = {
        let img = UIImageView()
        img.contentMode = .scaleAspectFill // image will never be strecthed vertially or horizontally
        img.translatesAutoresizingMaskIntoConstraints = false // enable autolayout
        img.layer.cornerRadius = 35
        img.clipsToBounds = true
        return img
    }()
    
    let firstnameTitleLabel:UILabel = {
        let label = UILabel()
        label.font = UIFont.boldSystemFont(ofSize: 20)
        label.textColor = .black
        label.translatesAutoresizingMaskIntoConstraints = false
        return label
    }()
    
    let lastnameTitleLabel:UILabel = {
        let label = UILabel()
        label.font = UIFont.boldSystemFont(ofSize: 14)
        label.textColor =  .white
        label.backgroundColor = #colorLiteral(red: 0.1764705926, green: 0.4980392158, blue: 0.7568627596, alpha: 1)
        label.layer.cornerRadius = 5
        label.clipsToBounds = true
        label.translatesAutoresizingMaskIntoConstraints = false
        return label
    }()

    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        
        self.contentView.addSubview(profileImageView)
        containerView.addSubview(firstnameTitleLabel)
        containerView.addSubview(lastnameTitleLabel)
        self.contentView.addSubview(containerView)
         
        profileImageView.centerYAnchor.constraint(equalTo:self.contentView.centerYAnchor).isActive = true
        profileImageView.leadingAnchor.constraint(equalTo:self.contentView.leadingAnchor, constant:10).isActive = true
        profileImageView.widthAnchor.constraint(equalToConstant:70).isActive = true
        profileImageView.heightAnchor.constraint(equalToConstant:70).isActive = true
        
        containerView.centerYAnchor.constraint(equalTo:self.contentView.centerYAnchor).isActive = true
        containerView.leadingAnchor.constraint(equalTo:self.profileImageView.trailingAnchor, constant:10).isActive = true
        containerView.trailingAnchor.constraint(equalTo:self.contentView.trailingAnchor, constant:-10).isActive = true
        containerView.heightAnchor.constraint(equalToConstant:40).isActive = true
        
        firstnameTitleLabel.topAnchor.constraint(equalTo:self.containerView.topAnchor).isActive = true
        firstnameTitleLabel.leadingAnchor.constraint(equalTo:self.containerView.leadingAnchor).isActive = true
        firstnameTitleLabel.trailingAnchor.constraint(equalTo:self.containerView.trailingAnchor).isActive = true
        
        lastnameTitleLabel.topAnchor.constraint(equalTo:self.firstnameTitleLabel.bottomAnchor).isActive = true
        lastnameTitleLabel.leadingAnchor.constraint(equalTo:self.containerView.leadingAnchor).isActive = true
        lastnameTitleLabel.topAnchor.constraint(equalTo:self.firstnameTitleLabel.bottomAnchor).isActive = true
        lastnameTitleLabel.leadingAnchor.constraint(equalTo:self.containerView.leadingAnchor).isActive = true
        
        
    }
   
    
   required init?(coder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    func configureCell(firstName: String, lastName: String) {
        firstnameTitleLabel.text = &quot;Firstname :\(firstName)&quot;
        lastnameTitleLabel.text = &quot;Lastname : \(lastName)&quot;
        
        }
        
    
    func configureImageCell(row: Int, viewModel: ViewModel) {
        
        profileImageView.image = nil
        
        viewModel
            .downloadImage(row: row) { [weak self] data in
                let image = UIImage(data: data)
                self?.profileImageView.image = image
            }
    }
}
</code></pre>
<p>Here is the view controller code .</p>
<pre><code>import UIKit
import Combine

class PeopleViewController: UIViewController {
    
    var coordinator: PeopleBaseCoordinator?
    
    
    init(coordinator: PeopleBaseCoordinator) {
        super.init(nibName: nil, bundle: nil)
        self.coordinator = coordinator
        title = &quot;People&quot;
    }
    required init?(coder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    private let viewModel = ViewModel()
    private var subscribers = Set&lt;AnyCancellable&gt;()
    
    
    var activityIndicator = UIActivityIndicatorView(style: .medium)
    
    
    private lazy var tableView: UITableView = {
        let tableview = UITableView()
        tableview.translatesAutoresizingMaskIntoConstraints = false
        tableview.dataSource = self
        tableview.prefetchDataSource = self
        tableview.showsVerticalScrollIndicator = false
        tableview.register(PeopleCell.self, forCellReuseIdentifier: PeopleCell.identifier)
        
        return tableview
    }()
    
   

    override func viewDidLoad() {
        super.viewDidLoad()
        
        activityIndicator.startAnimating()
        setUpUI()
       
        setUpBinding()
        self.activityIndicator.stopAnimating()
     
        // Do any additional setup after loading the view.
    }
    
    
    private func setUpUI() {
        view.backgroundColor = .white
        
        title = &quot;People List &quot;
        
      
        view.addSubview(tableView)
   
        tableView.topAnchor.constraint(equalTo:view.safeAreaLayoutGuide.topAnchor).isActive = true
        tableView.leftAnchor.constraint(equalTo:view.safeAreaLayoutGuide.leftAnchor).isActive = true
        tableView.rightAnchor.constraint(equalTo:view.safeAreaLayoutGuide.rightAnchor).isActive = true
        tableView.bottomAnchor.constraint(equalTo:view.safeAreaLayoutGuide.bottomAnchor).isActive = true
       
        
        
        // Creating constrain for Indecator
        activityIndicator.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(activityIndicator)
        activityIndicator.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true
        activityIndicator.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true
          
    }
    
    private func setUpBinding() {
        viewModel
            .$peoples
            .receive(on : RunLoop.main)
            .sink { [weak self ] _ in
                self?.tableView.reloadData()
            }
            .store(in: &amp;subscribers)
        viewModel.getPeople()
        
    }

}
extension PeopleViewController: UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        return viewModel.peoples.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
        
        guard let cell = tableView.dequeueReusableCell(withIdentifier: PeopleCell.identifier, for: indexPath) as? PeopleCell
        else { return UITableViewCell() }
        
        
        let row = indexPath.row
        let people = viewModel.peoples[row]
        cell.configureCell(firstName: people.firstName, lastName: people.lastName)
    
        cell.configureImageCell(row: row, viewModel: viewModel)
        
        return cell
        
    }
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {
        return 100
    }
}
extension PeopleViewController: UITableViewDataSourcePrefetching {
    
    func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [IndexPath]) {
        viewModel.getPeople()
    }
    
}
</code></pre>
<p>Here is the result .</p>
<p><a href=""https://i.stack.imgur.com/c4XTa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/c4XTa.png"" alt=""enter image description here"" /></a></p>
","10051291","","","","","2022-04-25 07:51:27","Table View Design overlapping","<swift><uitableview>","1","4","","","","CC BY-SA 4.0"
"72009766","1","72009946","","2022-04-26 07:14:08","","0","32","<p>I've implemented a two-way binding in a Foreach statement that seems to <strong>work properly</strong>:</p>
<pre><code>struct ContentView: View {
    @ObservedObject var dataManager: ContentViewModel
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false){
            HStack(spacing: 20){
                ForEach($dataManager.data) { $item in 
                    if item.status == true {
                        Button(item.tag){
                            item.status.toggle()
                        }
                        .foregroundColor(.white)
                        .background(Color.red)
                    } else {
                        Button(item.tag){
                            item.status.toggle()
                        }
                        .foregroundColor(.white)
                        .background(Color.blue)
                    }
                }
            }
        }
    }
}
</code></pre>
<p>The <strong>problem</strong> is when I've to use some nested views like:</p>
<pre><code>struct ContentView: View {
    @ObservedObject var dataManager: ContentViewModel
    var body: some View {
        
        ScrollView(.horizontal, showsIndicators: false){
            HStack(spacing: 20){
                ForEach($dataManager.data) { $item in
                    if item.status == true {
                        DetailView(dataManager: dataManager, item: item)
                            .foregroundColor(.white)
                            .background(Color.red)
                    } else {
                        Button(item.tag){
                            item.status.toggle()
                        }
                        .foregroundColor(.white)
                        .background(Color.blue)
                    }
                }
            }
        }
    }
}
</code></pre>
<p>and:</p>
<pre><code>struct DetailView: View {
    
    @ObservedObject var dataManager: ContentViewModel
    var item: SMTTagBoardItem
    
    var body: some View {
        Button(item.tag){
            item.status.toggle()
        }
    }
}

struct DetailView_Previews: PreviewProvider {
    static var previews: some View {
        DetailView(dataManager: ContentViewModel(), item: SMTTagBoardItem(id: UUID(), tag: &quot;tag1&quot;, rank: 0, status: true))
    }
}
</code></pre>
<p>I receive this error:</p>
<pre><code>Cannot use mutating member on immutable value: 'self' is immutable

</code></pre>
<p>at line :</p>
<pre><code>item.status.toggle() 
</code></pre>
<p>How can I implement a two-way binding in a ForEach statement that works by passing values to nested views?</p>
","1937003","","","","","2022-04-26 07:28:14","How to implement a two-way binding in a ForEach statement with nested views with Swift?","<swift><binding><combine>","1","0","","","","CC BY-SA 4.0"
"72010969","1","72211472","","2022-04-26 08:46:22","","0","318","<p>This question has effectively been asked before (<a href=""https://stackoverflow.com/questions/64957228/combine-assign-publisher-to-passthroughsubject"">Combine assign publisher to PassthroughSubject</a>) but the answer assumed the architecture of the question's example was totally wrong.</p>
<p>I'm faced with the same issue, in what I feel is a different example case, and I'd dearly love clarity on the issue.</p>
<hr />
<p>I have a viewmodel class which provides a public <code>errorMessage</code> publisher for the client layer to do what it will with. Just a string here. Privately this publisher is backed by a <code>PassthroughSubject</code> - I'm &quot;entering the monad&quot; from different places internally and so I want to send error messages imperatively at that stage.</p>
<p>One of my entry points here happens to be another Combine publisher. I'd like to just map and bind, as I would in RxSwift:</p>
<pre><code>private let _errorMessageSubject = PublishSubject&lt;String&gt;()
public let errorMessageRail = _errorMessageSubject.asObservable()

private func setup() {
   ...

   myEngine.errorMessages
     .map { msg in &quot;Internal error: \(msg)&quot; } 
     .bind(to: _errorMessageSubject)
   
   ...
}

private func someOtherMethod() {
   _errorMessageSubject.onNext(&quot;Surprise&quot;)
}
</code></pre>
<p>In Combine I'm not sure how to do it other than:</p>
<pre><code>private let _errorMessageSubject = PassthroughSubject&lt;String,Never&gt;()
public let errorMessageRail = _errorMessageSubject.eraseToAnyPublisher()

private func setup() {
   ...

   myEngine.errorMessages
     .map { msg in &quot;Internal error: \(msg)&quot; } 
     .sink { [weak self] msg in
         self?._errorMessageSubject.send(msg)
     }
   
   ...
}

private func someOtherMethod() {
   _errorMessageSubject.send(&quot;Surprise&quot;)
}
</code></pre>
<hr />
<p>Before we get into chatting concurrency issues, let's say I'm always carefully pushing to <code>_errorMessageSubject</code> on a specific dispatch queue. I omit that from the code above for clarity.</p>
<p>So given this example, unless I'm missing something staggeringly obvious a flatMap won't help me here.</p>
<ul>
<li>Am I stuck with this sink -&gt; send dance?</li>
<li>Or is there some eye-watering code-smell about my public/private publisher/subject pattern (that I use a lot for bridging imperative with reactive architectures) and can some kind soul point me in the direction of self-improvement?</li>
</ul>
","1602875","","","","","2022-05-12 07:15:45","Combine bind Publisher to PassthroughSubject","<ios><swift><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"72015020","1","72015255","","2022-04-26 13:41:55","","0","39","<p>I am currently using the following flow to call an api and decode the response:</p>
<pre><code>            .dataTaskPublisher(for: urlRequest)
            .mapError { error -&gt; NetworkClientError in
                print(error)
                return NetworkClientError.network(description: error.localizedDescription)
            }
            .tryMap { element -&gt; Data in
                guard let httpResponse = element.response as? HTTPURLResponse,
                      httpResponse.statusCode == 200 else {
                    throw NetworkClientError.network(description: URLError(.badServerResponse).localizedDescription)
                }
                return element.data
            }
            .decode(type: T.self, decoder: decoder)
            .mapError { error in
                print(error)
                return NetworkClientError.parsing(description: error.localizedDescription)
            }
            .receive(on: queue)
            .retry(retries)
            .eraseToAnyPublisher()
</code></pre>
<p>When i call it i get a 200 response but also a decoding error:</p>
<pre><code>keyNotFound(CodingKeys(stringValue: &quot;leagues&quot;, intValue: nil), Swift.DecodingError.Context(codingPath: [CodingKeys(stringValue: &quot;data&quot;, intValue: nil), CodingKeys(stringValue: &quot;leagues&quot;, intValue: nil), _JSONKey(stringValue: &quot;Index 0&quot;, intValue: 0)], debugDescription: &quot;No value associated with key CodingKeys(stringValue: \&quot;leagues\&quot;, intValue: nil) (\&quot;leagues\&quot;).&quot;, underlyingError: nil))
parsing(description: &quot;The data couldn’t be read because it is missing.&quot;)
</code></pre>
<p>All i want to do is view the json that has been received so that i can see what it is expecting. I can see that The model i have given it says to expect a value <code>leagues</code> but this is not what it can find. How can i see what it has found?</p>
","6734301","","","","","2022-04-26 15:40:19","View received json to debug JSONDecoder error","<swift>","1","3","","","","CC BY-SA 4.0"
"72016368","1","72016583","","2022-04-26 15:11:26","","0","45","<p>I created table view cell programmatically and set the constrains as well.It is able to display the image , firstname , lastname property into cell but when I added new label with values , it not displaying the values .</p>
<p>Here is the cell code .</p>
<pre><code>import UIKit

class PeopleCell: UITableViewCell {

    
    static let identifier = &quot;PeopleCell&quot;
    
    let containerView:UIView = {
        let view = UIView()
        view.translatesAutoresizingMaskIntoConstraints = false
        view.clipsToBounds = true // this will make sure its children do not go out of the boundary
        return view
    }()
    
    let profileImageView:UIImageView = {
        let img = UIImageView()
        img.contentMode = .scaleAspectFill // image will never be strecthed vertially or horizontally
        img.translatesAutoresizingMaskIntoConstraints = false // enable autolayout
        img.layer.cornerRadius = 35
        img.clipsToBounds = true
        return img
    }()
    
    let firstnameTitleLabel:UILabel = {
        let label = UILabel()
        label.font = UIFont.boldSystemFont(ofSize: 20)
        label.textColor = .black
        label.translatesAutoresizingMaskIntoConstraints = false
        return label
    }()
    
    let lastnameTitleLabel:UILabel = {
        let label = UILabel()
        label.font = UIFont.boldSystemFont(ofSize: 14)
        label.textColor =  .white
        label.backgroundColor = #colorLiteral(red: 0.1764705926, green: 0.4980392158, blue: 0.7568627596, alpha: 1)
        label.layer.cornerRadius = 5
        label.clipsToBounds = true
        label.translatesAutoresizingMaskIntoConstraints = false
        return label
    }()
    
    let jobTitleLabel:UILabel = {
        let label = UILabel()
        label.font = UIFont.boldSystemFont(ofSize: 20)
        label.textColor = .black
        label.translatesAutoresizingMaskIntoConstraints = false
        return label
    }()

    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        
        self.contentView.addSubview(profileImageView)
        containerView.addSubview(firstnameTitleLabel)
        containerView.addSubview(lastnameTitleLabel)
        containerView.addSubview(jobTitleLabel)
        self.contentView.addSubview(containerView)
         
        profileImageView.centerYAnchor.constraint(equalTo:self.contentView.centerYAnchor).isActive = true
        profileImageView.leadingAnchor.constraint(equalTo:self.contentView.leadingAnchor, constant:10).isActive = true
        profileImageView.widthAnchor.constraint(equalToConstant:70).isActive = true
        profileImageView.heightAnchor.constraint(equalToConstant:70).isActive = true
        
        containerView.centerYAnchor.constraint(equalTo:self.contentView.centerYAnchor).isActive = true
        containerView.leadingAnchor.constraint(equalTo:self.profileImageView.trailingAnchor, constant:10).isActive = true
        containerView.trailingAnchor.constraint(equalTo:self.contentView.trailingAnchor, constant:-10).isActive = true
        containerView.heightAnchor.constraint(equalToConstant:40).isActive = true
        
        firstnameTitleLabel.topAnchor.constraint(equalTo:self.containerView.topAnchor).isActive = true
        firstnameTitleLabel.leadingAnchor.constraint(equalTo:self.containerView.leadingAnchor).isActive = true
        firstnameTitleLabel.trailingAnchor.constraint(equalTo:self.containerView.trailingAnchor).isActive = true
        
        lastnameTitleLabel.topAnchor.constraint(equalTo:self.firstnameTitleLabel.bottomAnchor).isActive = true
        lastnameTitleLabel.leadingAnchor.constraint(equalTo:self.containerView.leadingAnchor).isActive = true
        lastnameTitleLabel.topAnchor.constraint(equalTo:self.firstnameTitleLabel.bottomAnchor).isActive = true
        lastnameTitleLabel.leadingAnchor.constraint(equalTo:self.containerView.leadingAnchor).isActive = true
        
        jobTitleLabel.topAnchor.constraint(equalTo:self.lastnameTitleLabel.bottomAnchor).isActive = true
        jobTitleLabel.leadingAnchor.constraint(equalTo:self.containerView.leadingAnchor).isActive = true
        jobTitleLabel.topAnchor.constraint(equalTo:self.lastnameTitleLabel.bottomAnchor).isActive = true
        jobTitleLabel.leadingAnchor.constraint(equalTo:self.containerView.leadingAnchor).isActive = true
        
    }
   
    
   required init?(coder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    func configureCell(firstName: String, lastName: String,jobtitle: String ) {
        firstnameTitleLabel.text = &quot;Firstname :\(firstName)&quot;
        lastnameTitleLabel.text = &quot;Lastname : \(lastName)&quot;
        jobTitleLabel.text = &quot;Occupation : \(jobtitle)&quot;
      
        
        }
    func configureImageCell(row: Int, viewModel: ViewModel) {
        
        profileImageView.image = nil
        
        viewModel
            .downloadImage(row: row) { [weak self] data in
                let image = UIImage(data: data)
                self?.profileImageView.image = image
            }
    }
}
    
</code></pre>
<p>Here is the view controller code .</p>
<pre><code>import UIKit
import Combine

class PeopleViewController: UIViewController {
    
    var coordinator: PeopleBaseCoordinator?
    
    
    init(coordinator: PeopleBaseCoordinator) {
        super.init(nibName: nil, bundle: nil)
        self.coordinator = coordinator
        title = &quot;People&quot;
    }
    required init?(coder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    private let viewModel = ViewModel()
    private var subscribers = Set&lt;AnyCancellable&gt;()
    
    
    private  var activityIndicator = UIActivityIndicatorView(style: .medium)
    
    
    private lazy var tableView: UITableView = {
        let tableview = UITableView()
        tableview.translatesAutoresizingMaskIntoConstraints = false
        tableview.dataSource = self
        tableview.prefetchDataSource = self
        tableview.showsVerticalScrollIndicator = false
        tableview.register(PeopleCell.self, forCellReuseIdentifier: PeopleCell.identifier)
        
        return tableview
    }()
    
   

    override func viewDidLoad() {
        super.viewDidLoad()
        
        activityIndicator.startAnimating()
        setUpUI()
       
        setUpBinding()
        self.activityIndicator.stopAnimating()
     
        // Do any additional setup after loading the view.
    }
    
    
    private func setUpUI() {
        view.backgroundColor = .white
        
        title = &quot;People List &quot;
        
        view.addSubview(activityIndicator)
        view.addSubview(tableView)
       // self.tableView.rowHeight = 100.00
        
        tableView.rowHeight = UITableView.automaticDimension
        tableView.rowHeight = 100
       
        tableView.topAnchor.constraint(equalTo:view.safeAreaLayoutGuide.topAnchor).isActive = true
        tableView.leftAnchor.constraint(equalTo:view.safeAreaLayoutGuide.leftAnchor).isActive = true
        tableView.rightAnchor.constraint(equalTo:view.safeAreaLayoutGuide.rightAnchor).isActive = true
        tableView.bottomAnchor.constraint(equalTo:view.safeAreaLayoutGuide.bottomAnchor).isActive = true
       
        
        
        // Creating constrain for Indecator
        activityIndicator.translatesAutoresizingMaskIntoConstraints = false
       
        activityIndicator.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true
        activityIndicator.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true
          
    }
    
    private func setUpBinding() {
        viewModel
            .$peoples
            .receive(on : RunLoop.main)
            .sink { [weak self ] _ in
                self?.tableView.reloadData()
            }
            .store(in: &amp;subscribers)
        viewModel.getPeople()
        
    }

}
extension PeopleViewController: UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        return viewModel.peoples.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
        
        guard let cell = tableView.dequeueReusableCell(withIdentifier: PeopleCell.identifier, for: indexPath) as? PeopleCell
        else { return UITableViewCell() }
        
        
        let row = indexPath.row
        
    
        let people = viewModel.peoples[row]
        cell.configureCell(firstName: people.firstName, lastName: people.lastName,jobtitle: people.jobtitle)
    
        cell.configureImageCell(row: row, viewModel: viewModel)
        
        return cell
        
    }
  
}
extension PeopleViewController: UITableViewDataSourcePrefetching {
    
    func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [IndexPath]) {
        viewModel.getPeople()
    }
    
}
</code></pre>
<p><strong>Here is the screenshot . As it not showing the job title property into cell</strong> .
<a href=""https://i.stack.imgur.com/V6bUk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/V6bUk.png"" alt=""enter image description here"" /></a></p>
","10051291","","","","","2022-04-26 15:25:56","Design the custom table view cell programatically","<swift><uitableview><viewcontroller>","1","12","","","","CC BY-SA 4.0"
"72018779","1","72020095","","2022-04-26 18:22:52","","1","57","<p>I am new to swift . I am trying to create table view and cell programmatically. I want to display the three label properties one below to another . I added the content view with respective label properties . I have set the row height but when I run the app  is overlapping.</p>
<p>Here is the my Table view code with view controller .</p>
<pre><code>class RoomViewController: UIViewController {

    var coordinator: RoomBaseCoordinator?
    
    init(coordinator: RoomBaseCoordinator) {
        super.init(nibName: nil, bundle: nil)
        self.coordinator = coordinator
        title = &quot;People&quot;
    }
    required init?(coder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    private let roomviewModel = RoomViewModel()
    private var subscribers = Set&lt;AnyCancellable&gt;()
    
    
    var activityIndicator = UIActivityIndicatorView(style: .medium)
   
    private lazy var tableView: UITableView = {
        let tableview = UITableView()
        tableview.translatesAutoresizingMaskIntoConstraints = false
        tableview.dataSource = self
        tableview.prefetchDataSource = self
        tableview.showsVerticalScrollIndicator = false
        tableview.register(RoomCellTableViewCell.self, forCellReuseIdentifier: RoomCellTableViewCell.identifier)
        
        return tableview
    }()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        
        activityIndicator.startAnimating()
        setUpUI()
      
        setUpBinding()
        self.activityIndicator.stopAnimating()
     
    }
    private func setUpUI() {
        view.backgroundColor = .white
        
        title = &quot;Room List &quot;
        view.addSubview(tableView)
        tableView.rowHeight = 100
        
        // create constraints
        tableView.topAnchor.constraint(equalTo:view.safeAreaLayoutGuide.topAnchor).isActive = true
        tableView.leftAnchor.constraint(equalTo:view.safeAreaLayoutGuide.leftAnchor).isActive = true
        tableView.rightAnchor.constraint(equalTo:view.safeAreaLayoutGuide.rightAnchor).isActive = true
        tableView.bottomAnchor.constraint(equalTo:view.safeAreaLayoutGuide.bottomAnchor).isActive = true
        tableView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor).isActive = true
      
        
        // Creating constrain for Indecator
        activityIndicator.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(activityIndicator)
        activityIndicator.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true
        activityIndicator.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true
          
    }
    private func setUpBinding() {
        roomviewModel
            .$rooms
            .receive(on : RunLoop.main)
            .sink { [weak self ] _ in
                self?.tableView.reloadData()
            }
            .store(in: &amp;subscribers)
        roomviewModel.getRoom()
        
    }

}

extension RoomViewController: UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        return roomviewModel.rooms.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
        
        guard let cell = tableView.dequeueReusableCell(withIdentifier: RoomCellTableViewCell.identifier, for: indexPath) as? RoomCellTableViewCell
        else { return UITableViewCell() }
        
        
        let row = indexPath.row
        let room = roomviewModel.rooms[row]
        cell.configureCell(createdAt: room.createdAt, IsOccupied: room.isOccupied, maxOccupancy: String(room.maxOccupancy), id: room.id)
        return cell
        
    }
}
extension RoomViewController: UITableViewDataSourcePrefetching {
    
    func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [IndexPath]) {
        roomviewModel.getRoom()
    }
    
}
</code></pre>
<p>Here is the cell .</p>
<pre><code>class RoomCellTableViewCell: UITableViewCell {

    static let identifier = &quot;RoomCell&quot;
    
 
    
    private lazy var createdAtLabel: UILabel = {
        let label = UILabel()
        label.translatesAutoresizingMaskIntoConstraints = false
        label.font = UIFont.boldSystemFont(ofSize: 15)
        label.numberOfLines = 0
        label.textAlignment = .left
        return label
    }()
    
    private lazy var IsOccupiedLabel: UILabel = {
        let label = UILabel()
        label.translatesAutoresizingMaskIntoConstraints = false
        label.font = UIFont.boldSystemFont(ofSize: 15)
        label.numberOfLines = 0
        //label.backgroundColor = #colorLiteral(red: 0.1764705926, green: 0.4980392158, blue: 0.7568627596, alpha: 1)
        label.textAlignment = .left
        return label
    }()
    
    private lazy var maxOccupancyLabel: UILabel = {
        let label = UILabel()
        label.translatesAutoresizingMaskIntoConstraints = false
        label.font = UIFont.boldSystemFont(ofSize: 15)
        label.numberOfLines = 0
        label.textAlignment = .left
        return label
    }()
    
    private lazy var idLabel: UILabel = {
        let label = UILabel()
        label.translatesAutoresizingMaskIntoConstraints = false
        label.font = UIFont.boldSystemFont(ofSize: 15)
        label.numberOfLines = 0
        label.textAlignment = .left
        return label
    }()
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
       
      // self.contentView.addSubview(containerView)
        contentView.addSubview(createdAtLabel)
        contentView.addSubview(IsOccupiedLabel)
        contentView.addSubview(maxOccupancyLabel)
      
        
        createdAtLabel.centerYAnchor.constraint(equalTo:self.contentView.centerYAnchor).isActive = true
        createdAtLabel.leadingAnchor.constraint(equalTo:self.contentView.leadingAnchor, constant:10).isActive = true
        createdAtLabel.widthAnchor.constraint(equalToConstant:50).isActive = true
        createdAtLabel.heightAnchor.constraint(equalToConstant:50).isActive = true
        
        contentView.centerYAnchor.constraint(equalTo:self.contentView.centerYAnchor).isActive = true
        contentView.leadingAnchor.constraint(equalTo:self.createdAtLabel.trailingAnchor, constant:10).isActive = true
        contentView.trailingAnchor.constraint(equalTo:self.contentView.trailingAnchor, constant:-10).isActive = true
        contentView.heightAnchor.constraint(equalToConstant:50).isActive = true
        
        IsOccupiedLabel.topAnchor.constraint(equalTo:self.contentView.topAnchor).isActive = true
        IsOccupiedLabel.leadingAnchor.constraint(equalTo:self.contentView.leadingAnchor).isActive = true
        IsOccupiedLabel.trailingAnchor.constraint(equalTo:self.contentView.trailingAnchor).isActive = true
        
        maxOccupancyLabel.topAnchor.constraint(equalTo:self.IsOccupiedLabel.bottomAnchor).isActive = true
        maxOccupancyLabel.leadingAnchor.constraint(equalTo:self.contentView.leadingAnchor).isActive = true
        maxOccupancyLabel.topAnchor.constraint(equalTo:self.IsOccupiedLabel.bottomAnchor).isActive = true
        
    }
    
    required init?(coder: NSCoder) {
         fatalError(&quot;init(coder:) has not been implemented&quot;)
     }
    
    func configureCell(createdAt: String, IsOccupied: Bool, maxOccupancy: String, id : String ) {
        createdAtLabel.text = &quot;CreatedAt :\(createdAt)&quot;
        IsOccupiedLabel.text = &quot;IsOccupied : \(IsOccupied)&quot;
        maxOccupancyLabel.text = &quot;MaxOccupancy : \(maxOccupancy)&quot;
        idLabel.text = &quot;Id : \(id)&quot;
        
        }
}
</code></pre>
<p>Here is the result .</p>
<p><a href=""https://i.stack.imgur.com/t51Ty.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/t51Ty.png"" alt=""enter image description here"" /></a></p>
","8705895","","","","","2022-04-26 20:23:03","Creating custom table View with Cell properties programmatically","<swift><uitableview><uiview>","1","0","","","","CC BY-SA 4.0"
"72020769","1","72192652","","2022-04-26 21:33:22","","1","136","<p>Is there a way to have the publisher emit a value only to the latest subscriber/observer?</p>
<p>An example for that would be; a manager class that can be subscribed to by multiple observers. When an event occurs, I would like only the latest subscriber to be observed. As far as I know, there is no way for the publisher to keep track of its subscribers but my knowledge regarding Combine and reactive programming is limited so I am unsure if this is possible in the first place.</p>
","7294871","","","","","2022-05-10 22:06:51","How to have a publisher emit only to the last subscriber in Combine","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"72023252","1","72023302","","2022-04-27 04:24:08","","1","42","<p>I am trying to figure how to have a SwiftUI view properly react to the changes made to an NSManagedObject property.</p>
<p>Example:</p>
<pre><code>class MyViewModel: ObservableObject {
            
    @Published var car:Car // &lt;-- NSManagedObject
    @Published var sold:Bool = false // &lt;-- I don't want to do this, I want to simply observe the sold property on car and not have to implement this sink logic below
    var subs = [AnyCancellable]()
    
    init(car:Car) {
        self.car = car
        self.sold = car.sold
        self.car.publisher(for: \.sold)
            .removeDuplicates()
            .receive(on: RunLoop.main)
            .sink { [weak self] sold in
                self?.sold = sold
            }
            .store(in: &amp;subs)
    }
    
}
</code></pre>
<p>As an example, I have a Toggle that lets me set the <code>sold</code> property on the Car entity.</p>
<pre><code>Toggle(isOn: Binding&lt;Bool&gt;(get: { model.car.sold }, set: { model.car.sold = $0 } )) {
    if model.car.sold {
        Text(&quot;ON&quot;)
    } else {
        Text(&quot;OFF&quot;)
    }
}
</code></pre>
<p>Toggling the control does set the <code>sold</code> property on the car instance, but, the Toggle label:</p>
<pre><code>    if model.car.sold {
        Text(&quot;ON&quot;)
    } else {
        Text(&quot;OFF&quot;)
    }
</code></pre>
<p>does not update accordingly.</p>
<p>So, if I change the car entity as a whole, things update, if I change a property of the entity the view does not update. So then I implemented the <code>sink</code> logic to then set a published <code>sold</code> property on the model. So the <code>sold</code> property on the car is set by the toggle, the sink kicks in and sets the model.sold, and then the Toggle label Text does update.</p>
<p>How can I do away with the additional <code>@Published var sold:Bool = false</code> in the model and simply cause the Toggle label to react to the actual <code>car.sold</code> property?</p>
","728246","","","","","2022-04-27 04:32:16","SwiftUI: react to NSManagedObject property change in SwiftUI view?","<ios><swift><core-data><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"72032736","1","72463897","","2022-04-27 17:03:38","","2","273","<p>I'm learning combine and I want to use combine instead a delegate between cell and tableview. I have managed to connect and receive the information, but the problem is when the cell is reused, every time I generate the same event, I receive it as many times as it has been used previously in that reused cell.</p>
<p>I have declared cancelables in the view controller as</p>
<pre><code>var cancellables: Set&lt;AnyCancellable&gt; = []
</code></pre>
<p>And this is the cellForRow method</p>
<pre><code>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
    guard let cell = tableView.dequeueReusableCell(withIdentifier: MyCell.celdaReuseIdentifier, for: indexPath)
        as? MyCell else {
            return MyCell()
    }
    
    cell.index = indexPath
    cell.lbTitle.text = String(&quot;Cell \(indexPath.row)&quot;)
    
    
    cell.tapButton.compactMap{$0}
        .sink { index in
        print(&quot;tap button in cell \(index.row)&quot;)
    }.store(in: &amp;cancellables)
    
    return cell
}
</code></pre>
<p>and the cell is</p>
<pre><code>class MyCell: UITableViewCell {
static let cellNibName = &quot;MyCell&quot;
static let celdaReuseIdentifier = &quot;MyCellReuseIdentifier&quot;

@IBOutlet weak var lbTitle: UILabel!
@IBOutlet weak var button: UIButton!

var index: IndexPath?

let tapButton = PassthroughSubject&lt;IndexPath?, Never&gt;()

override func awakeFromNib() {
    super.awakeFromNib()
    // Initialization code
}

@IBAction func tapButton(_ sender: Any) {
    self.tapButton.send(index)
}
}
</code></pre>
<p>Thanks for your help</p>
","6151270","","","","","2022-06-01 14:50:19","Connect UITableviewCell with UITableview using Combine repeat values","<swift><swift5><combine>","2","4","1","","","CC BY-SA 4.0"
"72064180","1","72494728","","2022-04-29 22:17:37","","1","133","<p>I'm working on an app that displays a PDF using PDFKit, and I need to be able to set the minimum zoom level - otherwise the user can just zoom out forever. I've tried to set <code>minScaleFactor</code> and <code>maxScaleFactor</code>, and because these turn off <code>autoScales</code>, I need to set the <code>scaleFactor</code> to <code>pdfView.scaleFactorForSizeToFit</code>. However, this setting doesn't result in the same beginning zoom as <code>autoScales</code> and despite changing the actual <code>scaleFactor</code> number, the beginning zoom doesn't change. This photo is with <code>autoScales</code> on:
[![image with autoscales on][1]][1]</p>
<p>and then what happens when I use the <code>scaleFactorForSizeToFit</code>:
[![image with scaleFactorForSizeToFit][2]][2]</p>
<p>To quote the apple documentation for <code>scaleFactorForSizeToFit</code>, this is the</p>
<blockquote>
<p>&quot;size to fit&quot; scale factor that autoScales would use for scaling the current document and layout.</p>
</blockquote>
<p>I've pasted my code below. Thank you for your help.</p>
<pre class=""lang-swift prettyprint-override""><code>import PDFKit
import SwiftUI
import Combine

class DataLoader : ObservableObject {
    @Published var data : Data?
    var cancellable : AnyCancellable?
    
    func loadUrl(url: URL) {
        cancellable = URLSession.shared.dataTaskPublisher(for: url)
            .map { $0.data }
            .receive(on: RunLoop.main)
            .sink(receiveCompletion: { (completion) in
                switch completion {
                case .failure(let failureType):
                    print(failureType)
                    //handle potential errors here
                case .finished:
                    break
                }
        }, receiveValue: { (data) in
            self.data = data
        })
    }
}

struct PDFSwiftUIView : View {
    @StateObject private var dataLoader = DataLoader()
    var StringToBeLoaded: String
    
    var body: some View {
        VStack {
            if let data = dataLoader.data {
                PDFRepresentedView(data: data)
                    .navigationBarHidden(false)
            } else {
                CustomProgressView()
                   //.navigationBarHidden(true)
            }
        }.onAppear {
            dataLoader.loadUrl(url: URL(string: StringToBeLoaded)!)
        }
    }
}

struct PDFRepresentedView: UIViewRepresentable {
    typealias UIViewType = PDFView
    
    let data: Data
    let singlePage: Bool = false
    
    func makeUIView(context _: UIViewRepresentableContext&lt;PDFRepresentedView&gt;) -&gt; UIViewType {
        let pdfView = PDFView()
        
        
     
       // pdfView.autoScales = true
       // pdfView.maxScaleFactor = 0.1
      
        pdfView.minScaleFactor = 1
        pdfView.scaleFactor = pdfView.scaleFactorForSizeToFit
        pdfView.maxScaleFactor = 10
        
       
        if singlePage {
            pdfView.displayMode = .singlePage
        }
        return pdfView
    }
    
    func updateUIView(_ pdfView: UIViewType, context: UIViewRepresentableContext&lt;PDFRepresentedView&gt;) {
        pdfView.document = PDFDocument(data: data)
    }
    func canZoomIn() -&gt; Bool {
           return false
       }
}


struct ContentV_Previews: PreviewProvider {
    static var previews: some View {
        PDFSwiftUIView(StringToBeLoaded: &quot;EXAMPLE_STRING&quot;)
            .previewInterfaceOrientation(.portrait)
    }
}

</code></pre>
","","user18457910","","user18457910","2022-06-14 03:15:03","2022-06-14 03:15:03","PDFKit's scaleFactorForSizeToFit isn't working to set zoom in SwiftUI (UIViewRepresentable)","<swift><swiftui><zooming><pdfkit><apple-pdfkit>","2","0","","","","CC BY-SA 4.0"
"72101970","1","72112729","","2022-05-03 15:41:26","","-2","103","<p>When uncommenting the code in the following code block I get the following error.</p>
<p><code>Cannot infer return type for closure with multiple statements; add explicit type to disambiguate</code></p>
<p>But I can't figure out the syntax for explicitly adding a type. How do I do it?</p>
<pre class=""lang-swift prettyprint-override""><code>let path:String = path ?? Self.path
let publisher: AnyPublisher&lt;[Self]?, Error&gt; = NetworkableManager.getAll(path: path) 
    .flatMap {
//     if path == &quot;menus&quot; {
//        print(&quot;It's a menu&quot;)
//     }
       return StorableManager.shared.saveAll($0)
                
    }
    .merge(with: StorableManager.shared.fetchAll(predicate: filters))
    .eraseToAnyPublisher()

</code></pre>
","11920147","","1015258","","2022-05-03 16:46:49","2022-05-04 12:10:05","Add explicit type to flatmap","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"72111025","1","72112141","","2022-05-04 09:54:13","","-1","72","<p><code>@Published</code> publishes correctly when used in an <code>ObservableObject</code>. But does not seem to publish when used in an <code>NSManagedObject</code> (which conforms to <code>ObservableObject</code>).</p>
<p>In the following example when using <code>Data1</code> the text below the picker is updated. But using <code>Data2</code> it is not. Why is that?</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import CoreData

class Data1: ObservableObject {
    @Published var direction: Direction = .left
}

class Data2: NSManagedObject { // NSManagedObject conforms to ObservableObject
    @Published var direction: Direction = .left
}

enum Direction {
    case left
    case right
}

@main
struct SwiftUITestApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView().environmentObject(Data2()) // Or Data1() as needed
        }
    }
}

struct ContentView: View {
    @EnvironmentObject private var data: Data2
    
    var body: some View {
        VStack {
            Picker(&quot;&quot;, selection: $data.direction) {
                Text(&quot;Left&quot;).tag(Direction.left)
                Text(&quot;Right&quot;).tag(Direction.right)
            }.pickerStyle(.wheel)
            switch data.direction {
            case .left:
                Text(&quot;Selected: Left&quot;)
            case .right:
                Text(&quot;Selected: Right&quot;)
            }
        }.padding()
    }
}
</code></pre>
","1228933","","","","","2022-05-22 00:37:03","Why does @Published not work in NSManagedObject?","<core-data><swiftui><combine><nsmanagedobject><observableobject>","1","6","","","","CC BY-SA 4.0"
"72117159","1","72117262","","2022-05-04 17:29:45","","0","29","<p>I noticed that <code>sink</code> is called only once</p>
<pre><code>class StorefrontViewModel {
    @Published var page = 0
        @Published var string = &quot;lorem ipsum&quot;

        private var cancellableBag = Set&lt;AnyCancellable&gt;()

        init() {

            let publisher = $page
                .map { [unowned self] in
                    return $0 == 1 ? self.string.lowercased() : self.string.uppercased()
            }

            publisher
                .eraseToAnyPublisher()
                .assign(to: \.string, on: self)
                .store(in: &amp;cancellableBag) // must store the subscriber to get the events
        }
}
</code></pre>
<pre><code>    var pager = StorefrontViewModel()
        pager.$string.sink {  print($0)}
        pager.page = 1 // lorem ipsum
        pager.page = 2 // LOREM IPSUM
        pager.page = 3 // LOREM IPSUM
        pager.page = 4 // LOREM IPSUM
        pager.page = 1 // lorem ipsum
        pager.page = 1 // lorem ipsum
</code></pre>
<p>Here  is the output <code>LOREM IPSUM</code>.</p>
<p>Wondering why <code>sink</code> is called even though I set <code>pager.page</code> value multiple times</p>
","802766","","560942","","2022-05-04 17:31:14","2022-05-04 17:38:17","iOS Combine framework @Published doesnt capture post modification values","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"72196004","1","72204497","","2022-05-11 05:52:04","","1","101","<p>I am trying to subscribe to multiple publishers. The Output type of publishers may not be determined.</p>
<pre class=""lang-swift prettyprint-override""><code>static func listen&lt;T&gt;(publisher: Published&lt;T&gt;.Publisher){
    publisher.sink { _Arg in
        // do something
    }.store(in: &amp;cancellables)
}
listen(publisher: env.$showMenuIcon)
listen(publisher: env.$dateFormatLunar)
listen(publisher: env.$dateFormatAd)
listen(publisher: env.$showWeek)
listen(publisher: env.$showWeather)
// in env class
@Published var timeItem = true
@Published var dateFormatAd = &quot;yyyy-MM-dd&quot;
</code></pre>
<p>Each of my publishers may have different generic parameter types, and I can only call listen by copying multiple lines of code like this. Is there any way to modify the Listen method to accept an array type? Or is there another way I can simplify my code?</p>
","8545825","","","","","2022-05-11 16:24:41","In Swift, how to assign values when generic parameters are different","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"72196892","1","72196948","","2022-05-11 07:16:46","","1","47","<p>If I create an <code>ObservableObject</code> with a <code>@Published</code> property and inject it into a SwifUI view with <code>.environmentObject()</code>, the view responds to changes in the ObservableObject as expected.</p>
<pre class=""lang-swift prettyprint-override""><code>class CounterStore: ObservableObject {
    @Published private(set) var counter = 0
    func increment() {
        counter += 1
    }
}

struct ContentView: View {
    @EnvironmentObject var store: CounterStore

    var body: some View {
        VStack {
            Text(&quot;Count: \(store.counter)&quot;)
            Button(action: { store.increment() }) {
                Text(&quot;Increment&quot;)
            }
        }
    }
}
</code></pre>
<p>Tapping on &quot;Increment&quot; will increase the count.</p>
<p>However, if I don't use the <code>EnvironmentObject</code> and instead pass the store instance into the view, the compiler does not complain, the store method <code>increment()</code> is called when the button is tapped, but the count in the <code>View</code> does <strong>not</strong> update.</p>
<pre><code>struct ContentViewWithStoreAsParameter: View {
    var store: CounterStore

    var body: some View {
        VStack {
            Text(&quot;Count: \(store.counter) (DOES NOT UPDATE)&quot;)
            Button(action: { store.increment() }) {
                Text(&quot;Increment&quot;)
            }
        }
    }
}
</code></pre>
<p>Here's how I'm calling both Views:</p>
<pre><code>@main
struct testApp: App {
    var store = CounterStore()
    
    var body: some Scene {
        WindowGroup {
            VStack {
                ContentView().environmentObject(store) // works
                ContentViewWithStoreAsParameter(store: store) // broken
            }
        }
    }
}

</code></pre>
<p>Is there a way to pass an <code>ObservableObject</code> into a View as a parameter? (Or what magic is <code>.environmentalObject()</code> doing behind the scenes?)</p>
","18158","","","","","2022-05-11 08:26:53","SwiftUI: Must an ObservableObject be passed into a View as an EnvironmentObject?","<swiftui><combine><observableobject>","2","0","","","","CC BY-SA 4.0"
"72208508","1","72208615","","2022-05-11 23:07:54","","1","35","<p>I am trying to better understand the Combine framework. AFAIK, <code>.sink()</code> connects a publisher to a subscriber. In an Xcode Playground page, who exactly is the subscriber? Consider the following example:</p>
<pre><code>PlaygroundPage.current.needsInfiniteExecution = true

var subscriptions: Set&lt;AnyCancellable&gt; = []

Timer.TimerPublisher(every: 1, on: .main, in: .common)
    .autoconnect()
    .sink { print($0) }    // Who is this sink connecting the timer publisher to?
    .store(in: &amp;subscriptions)
</code></pre>
<p>I know the pub-sub link is taking place because the publisher does indeed start publishing. It is just unclear who the subscriber is. Is there a way to deterministically query Combine for who the subscriber is?</p>
<p>Also, if the subscriber of this timer publisher is the playgroundPage's current instance, then why do I have to store the subscription using <code>store(in:)</code>? Shouldn't this be unnecessary since the subscriber is not going out of scope any time soon (not until I stop the playground)?</p>
","5565491","","","","","2022-05-11 23:35:26","Who exactly is the subscriber of an Xcode Playground Publisher?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"72222778","1","72224949","","2022-05-12 22:42:42","","0","100","<p>I am trying to create a class that executes data loading once and returns the data to all callers of the method while the data was loading to not perform the data loading for the same item (identifier) more than once. The issue I am having is that it seems to crash on the first initialization of <code>CurrentValueSubject</code> for an identifier. This only happens if the <code>downloadStuff</code> returns an <code>Error</code> I have no idea what's wrong. Here is a reproduction of the issue.</p>
<p>Class that does the synchronization:</p>
<pre><code>class FetchSynchronizer&lt;T, ItemIdentifier: Hashable&gt; {

typealias CustomParams = (isFirstLoad: Bool, result: Result&lt;T, Error&gt;)

    enum FetchCondition {
        // executes data fetching only once
        case executeFetchOnlyOnce
        // re-executes fetch if request failed
        case retryOnlyIfFailure
        // always executes fetch even if response is cached
        case noDataCache
        // custom condition
        case custom((CustomParams) -&gt; Bool)
    }
    
    struct LoadingState&lt;T&gt; {
        let result: Result&lt;T, Error&gt;
        let isLoading: Bool
        
        init(result: Result&lt;T, Error&gt;? = nil, isLoading: Bool = false) {
            self.result = result ?? .failure(NoResultsError())
            self.isLoading = isLoading
        }
    }
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    private var isLoading: [ItemIdentifier: CurrentValueSubject&lt;LoadingState&lt;T&gt;, Never&gt;] = [:]
    
    func startLoading(identifier: ItemIdentifier,
                      fetchCondition: FetchCondition = .executeFetchOnlyOnce,
                      loaderMethod: @escaping () async -&gt; Result&lt;T, Error&gt;) async -&gt; Result&lt;T, Error&gt; {
        
        // initialize loading tracker for identifier on first execution
        var isFirstExecution = false
        if isLoading[identifier] == nil {
            print(&quot;----0&quot;)
            isLoading[identifier] = CurrentValueSubject&lt;LoadingState&lt;T&gt;, Never&gt;(LoadingState&lt;T&gt;())
            isFirstExecution = true
        }
        
        guard let currentIsLoading = isLoading[identifier] else {
            assertionFailure(&quot;Should never be nil because it's set above&quot;)
            return .failure(NoResultsError())
        }
        
        if currentIsLoading.value.isLoading {
            // loading in progress, wait for finish and call pending callbacks
            return await withCheckedContinuation { continuation in
                currentIsLoading.filter { !$0.isLoading }.sink { currentIsLoading in
                    continuation.resume(returning: currentIsLoading.result)
                }.store(in: &amp;cancellables)
            }
        } else {
            // no fetching in progress, check if it can be executed
            let shouldFetchData: Bool
            switch fetchCondition {
            case .executeFetchOnlyOnce:
                // first execution -&gt; fetch data
                shouldFetchData = isFirstExecution
            case .retryOnlyIfFailure:
                // no cached data -&gt; fetch data
                switch currentIsLoading.value.result {
                case .success:
                    shouldFetchData = false
                case .failure:
                    shouldFetchData = true
                }
            case .noDataCache:
                // always fetch
                shouldFetchData = true
            case .custom(let completion):
                shouldFetchData = completion((isFirstLoad: isFirstExecution,
                                              result: currentIsLoading.value.result))
            }
            
            if shouldFetchData {
                
                currentIsLoading.send(LoadingState(isLoading: true))
                // fetch data
                return await withCheckedContinuation { continuation in
                    Task {
                        // execute loader method
                        let result = await loaderMethod()
                        let state = LoadingState(result: result,
                                                 isLoading: false)
                        currentIsLoading.send(state)
                        continuation.resume(returning: result)
                    }
                }
            } else {
                // use existing data
                return currentIsLoading.value.result
            }
        }
    }
}
</code></pre>
<p>Example usage:</p>
<pre><code>class Executer {
    
    let fetchSynchronizer = FetchSynchronizer&lt;Data?, String&gt;()
    
    func downloadStuff() async -&gt; Result&lt;Data?, Error&gt; {
        await fetchSynchronizer.startLoading(identifier: &quot;1&quot;) {
            return await withCheckedContinuation { continuation in
                sleep(UInt32.random(in: 1...3))
                print(&quot;-------request&quot;)
                continuation.resume(returning: .failure(NSError() as Error))
            }
        }
    }
    
    init() {
        start()
    }
    
    func start() {
        Task {
            await downloadStuff()
            print(&quot;-----3&quot;)
        }
        DispatchQueue.global(qos: .utility).async {
            Task {
                await self.downloadStuff()
                print(&quot;-----2&quot;)
            }
        }
        
        DispatchQueue.global(qos: .background).async {
            Task {
                await self.downloadStuff()
                print(&quot;-----1&quot;)
            }
        }
    }
}
</code></pre>
<p>Start the execution:</p>
<pre><code>Executer()
</code></pre>
<p>Crashes at</p>
<pre><code>isLoading[identifier] = CurrentValueSubject&lt;LoadingState&lt;T&gt;, Never&gt;(LoadingState&lt;T&gt;())
</code></pre>
<p>Any guidance would be appreciated.</p>
","1310984","","","","","2022-05-15 16:44:42","EXC_BAD_ACCESS when initializing Dictionary of CurrentValueSubject in Swift","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"72234481","1","72236104","","2022-05-13 19:17:13","","0","67","<p>How can I observe changes on an array with Combine framework but without SwiftUI?</p>
<p>Basically, I want this sink block to get called when an element is added or removed.</p>
<pre><code>import Combine

var list = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]
list.publisher
    .collect()
    .sink { value in
        print(value)
    }

// I want to observe these changes.
list.append(&quot;D&quot;)
list.removeAll { $0 == &quot;B&quot;}
</code></pre>
<p>I read <a href=""https://stackoverflow.com/questions/71097740/how-to-observe-arrays-new-values-with-combine"">this article</a> and I know <code>@Published</code> property wrapper works this way.
But I can't use SwiftUI and am looking for another solution.</p>
","376482","","","","","2022-05-17 20:11:55","How do I observe changes on an array with Combine framework?","<ios><swift><combine>","1","4","","","","CC BY-SA 4.0"
"72240977","1","72306773","","2022-05-14 14:07:11","","0","93","<p>I have a <code>PassthroughSubject</code> which is connected to a <code>ScrollView</code> and it emits while it scrolls. I want the subject to emit the current scroll value, but only once per second. I tried <code>throttle</code> and <code>debounce</code>, but they don't seem to be doing what I need.</p>
<p>Like this, I can see every time it emits while I'm scrolling, so my base setup of scroll detection is working well.</p>
<pre><code>scrollSubject
    .sink { value in
        print(value)
    }
    .store(in: &amp;subscription)
</code></pre>
<p>But when I try to use either of these:</p>
<p><code>.throttle(for: 1, scheduler: RunLoop.main, latest: false)</code> (tried <code>latest: true</code> also)`</p>
<p><code>.debounce(for: 1, scheduler: RunLoop.main)</code></p>
<p>What happens is they are not emitting while I'm scrolling, only after I've stopped it emits the latest value. How is it possible to achieve the desire behaviour?</p>
","13505419","","","","","2022-05-19 14:53:13","Swift Combine - Emit the latest value once per second","<ios><swift><combine>","1","1","","","","CC BY-SA 4.0"
"72308801","1","72321316","","2022-05-19 17:29:29","","0","160","<p>I'm trying to use a Combine subscriber to wait for a specific value from a publisher, which seems easy enough if I handle the values in <code>sink(receiveValue:)</code>, but I want to convert the publisher to another publisher that just finishes when the specific value is received.</p>
<p>This is the code that works:</p>
<pre><code>let publisher: AnyPublisher&lt;Int, Never&gt; = ...

let cancellable = publisher.sink(receiveValue: { value in
    if value == myFavoriteNumber {
        // we're finished!
    }
})
</code></pre>
<p>What I'm trying to accomplish is something like this:</p>
<pre><code>let modifiedPublisher: AnyPublisher&lt;Never, Never&gt; = publisher.compactMap({ 
    $0 == myFavoriteNumber ? Publishers.Completion.finished : nil 
}).eraseToAnyPublisher()
</code></pre>
<p>Is there a way to do this?</p>
","1275947","","1275947","","2022-05-19 18:13:07","2022-05-20 15:20:21","How to have Combine subscriber finish upon receiving specific value","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"72313228","1","72313511","","2022-05-20 03:19:24","","1","80","<p>I'm working on <strong>Tabview</strong> with <strong>page style</strong> and I want to scroll tabview on button actions. Buttons are added inside <code>NavigationMenu</code>.</p>
<p><code>NavigationMenu</code> <strong>view</strong> and <code>NavigationModel(ViewModel)</code> are separated from a parent.</p>
<p>Selection handling is done inside <code>NavigationModel</code>.</p>
<p>On tab page swipe I'm able to see the change in <code>NavigationMenu</code> which is fine.</p>
<p>But if I tap on buttons the tabview page is not swiping. Even I receive change event on method <code>onReceive</code>.</p>
<h2>Code:</h2>
<pre><code>import SwiftUI
import Combine

final class NavigationModel: ObservableObject {
    @Published var selectedItem = &quot;&quot;
    @Published var items: [String] = [
        &quot;Button 1&quot;, &quot;Button 2&quot;, &quot;Button 3&quot;
    ]
}

struct NavigationMenu: View {

    @ObservedObject var viewModel: NavigationModel

    var body: some View {
        HStack {
            ForEach(0..&lt;3, id: \.self) { index in
                let title = viewModel.items[index]
                Button {
                    viewModel.selectedItem = title
                } label: {
                    Text(title)
                        .font(.system(.body))
                        .padding()
                        .foregroundColor(
                            viewModel.selectedItem == title ? .white : .black
                        )
                        .background(viewModel.selectedItem == title ? .black : .yellow)
                }
            }
        }
    }
}

final class TabViewModel: ObservableObject {
    var navModel = NavigationModel()
}

struct TabviewWithMenuView: View {

    @ObservedObject var viewModel = TabViewModel()

    var body: some View {
        parentView
    }

    private var parentView: some View {
        VStack(spacing: 0) {
            Spacer()
            NavigationMenu(viewModel: viewModel.navModel)
            pageView
        }
        .onReceive(viewModel.navModel.$selectedItem) { output in
            print(&quot;Button tapped:&quot;, output)
        }
    }

    private var pageView: some View {
        TabView(selection: $viewModel.navModel.selectedItem) {
            ForEach(0..&lt;3, id: \.self) { index in
                let tag = viewModel.navModel.items[index]
                item(tag: tag)
                    .tag(tag)
            }
        }
        .tabViewStyle(.page(indexDisplayMode: .never))
        .transition(.slide)
    }

    private func item(tag: String) -&gt; some View {
        VStack {
            Text(&quot;PAGE: &quot; + tag)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color.red)
    }

}
</code></pre>
<h2>Image:</h2>
<img src=""https://i.stack.imgur.com/hbDkj.png"" width=""380"" height=""640"">
","5589073","","12299030","","2022-05-20 04:11:47","2022-05-20 04:11:47","SwiftUI Combine: TabView is not updating on selection when property stored in different viewmodel","<ios><swift><swiftui><tabview>","1","1","","","","CC BY-SA 4.0"
"72323457","1","72323510","","2022-05-20 18:35:03","","0","45","<p>I am trying to learn ARC and I'm having a hard time with a weakly captured self. My project is using MVVM with SwiftUI. I'm presenting a sheet (AuthenticationLoginView) that has a <code>@StateObject var viewModel = AuthenticationLoginViewModel()</code> property. On dismiss of the presented sheet, I expect that the viewModel will have it's <code>deinit</code> called and so it does <em><strong>until</strong></em> I run an asynchronous function within a <code>Task</code> block.</p>
<pre><code>class AuthenticationLoginViewModel: ObservableObject {

    @Published var isLoggingIn: Bool = false
    
    private var authenticationService: AuthenticationService
    
    private var cancellables: Set&lt;AnyCancellable&gt; = Set()
    private var onLoginTask: Task&lt;Void, Never&gt;?
    
    init(authenticationService: AuthenticationService) {
        self.authenticationService = authenticationService
    }
    
    deinit {
        onLoginTask?.cancel()
        LoggerService.log(&quot;deallocated&quot;)
    }
    
    public func onLogin() {
        guard !isLoggingIn else { return }
        isLoggingIn = true
        onLoginTask = Task { [weak self] in
            await self?.login()
        }
    }
    
    private func login() async {
        LoggerService.log(&quot;Logging in...&quot;)
        sleep(2)
        // 
        // self is still allocated here &lt;&lt;&lt;---- ???
        //
        let authResponse = try? await self.authenticationService.authenticate(username: username, password: password)
        LoggerService.log(self.isLoggingIn) // &lt;&lt;--- prints `true`
        handleLoginResponse(authResponse: authResponse)
    }
}
</code></pre>
<p>So I have my two cases here:</p>
<h4>Case #1</h4>
<ol>
<li>I present the sheet.</li>
<li>I dismiss the sheet.</li>
<li>The <code>deinit</code> function is getting called (app logs: &quot;deallocated&quot;)</li>
</ol>
<h4>Case #2</h4>
<ol>
<li>I present the sheet.</li>
<li>I press the login button so the <code>onLogin</code> function is getting called.</li>
<li>I dismiss the sheet before the <code>sleep(2)</code> ends.</li>
<li>---- I EXPECT the &quot;deallocated&quot; message to be printed from <code>deinit</code> and the logging at <code>LoggerService.log(self.isLoggingIn)</code> to print <code>nil</code> and the <code>self.authenticationService.authenticate(...</code> to never be called as self doesn't exist anymore.</li>
<li>Not expected but happening: the app prints &quot;Logging in&quot;, sleeps for 2 seconds, calls the service, prints true, and then deallocates the view model (the view was dismissed 2 seconds ago)</li>
</ol>
<p>What am I doing wrong?</p>
<p>I'm still learning and I'm pretty much unsure if this is normal or I miss something. Anyway, I expect the view model to be deallocated as the view referencing it was dismissed.</p>
","5615274","","","","","2022-05-20 18:40:28","Weakly captured self won't let the view model deallocate until the Task finishes","<swift><memory><automatic-ref-counting><self>","1","0","","","","CC BY-SA 4.0"
"72338747","1","72339453","","2022-05-22 15:04:36","","0","112","<p>I am a little uncertain about task cancellation in swift. My question is:</p>
<p><strong>If a task reaches its return line (in this example, <code>Line 4</code>), does this mean it will be automatically canceled?</strong> (and thus free up memory + any used thread(s) previously occupied by the Task?)</p>
<pre class=""lang-swift prettyprint-override""><code>someBlock {
    Task&lt;Bool, Never&gt; {
        await doSomeWork()
        return true // Line 4
    }
}
</code></pre>
<p>As a follow-up, what if we then call <code>.task</code> on a SwiftUI <code>View</code>? Does anything change?</p>
<pre class=""lang-swift prettyprint-override""><code>SomeView
    .task {
        await doSomeWork()
    }
</code></pre>
<p>Thank you for your time!</p>
","14602519","","14602519","","2022-05-22 15:18:00","2022-05-22 16:37:05","Are Tasks automatically cancelled upon return/completion in Swift?","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"72350432","1","72364692","","2022-05-23 14:42:13","","0","315","<p>The following is the content of a playground that illustrates the problem. Basically I have a value stored in <code>UserDefaults</code> and accessed by a variable wrapped in the <code>@AppStorage</code> property wrapper. This lets me access the updated value in a <code>View</code> but I'm looking for a way to listen to changes in the property in <code>ViewModel</code>s and other non-<code>View</code> types.</p>
<p>I have it working in the follow code but I'm not sure it's the best way to do it and I'd love to avoid having to declare a <code>PassthroughSubject</code> for each property I want to watch.</p>
<p>Note: I did originally <code>sink</code> the <code>ObservableObject</code>'s <code>objectWillChange</code> property however that will reflect any change to the object and I'd like to do something more fine grained.</p>
<p>So does anyone have any ideas on how to improve this technique?</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine
import PlaygroundSupport
import SwiftUI

class AppSettings: ObservableObject {
    var myValueChanged = PassthroughSubject&lt;Int, Never&gt;()
    @AppStorage(&quot;MyValue&quot;) var myValue = 0 {
        didSet { myValueChanged.send(myValue) }
    }
}

struct ContentView: View {

    @ObservedObject var settings: AppSettings
    @ObservedObject var viewModel: ValueViewModel

    init() {
        let settings = AppSettings()
        self.settings = settings
        viewModel = ValueViewModel(settings: settings)
    }

    var body: some View {
        ValueView(viewModel)
            .environmentObject(settings)
    }
}

class ValueViewModel: ObservableObject {

    @ObservedObject private var settings: AppSettings
    @Published var title: String = &quot;&quot;
    private var cancellable: AnyCancellable?

    init(settings: AppSettings) {
        self.settings = settings
        title = &quot;Hello \(settings.myValue)&quot;

        // Is there a nicer way to do this?????
        cancellable = settings.myValueChanged.sink {
            print(&quot;object changed&quot;)
            self.title = &quot;Hello \($0)&quot;
        }
    }
}

struct ValueView: View {

    @EnvironmentObject private var settings: AppSettings
    @ObservedObject private var viewModel: ValueViewModel

    init(_ viewModel: ValueViewModel) {
        self.viewModel = viewModel
    }

    var body: some View {
        Text(&quot;This is my \(viewModel.title) value: \(settings.myValue)&quot;)
            .frame(width: 300.0)
        Button(&quot;+1&quot;) {
            settings.myValue += 1
        }
    }
}

PlaygroundPage.current.setLiveView(ContentView())
</code></pre>
","247090","","","","","2022-08-06 09:07:28","How can I listen to changes in a @AppStorage property when not in a view?","<swift><swiftui><combine>","3","2","","","","CC BY-SA 4.0"
"72384846","1","72386328","","2022-05-25 22:39:21","","0","301","<p>I am setting up a <code>sink</code> like so:</p>
<pre><code>    name.publisher
        .removeDuplicates()
        .receive(on: RunLoop.main)
        .sink { [weak self] config in
            guard let self = self else { return }

            // this closure gets called right away at setup even though the @Published property `name` was already setup and did not change
            
        }.store(in: &amp;subscribers)
</code></pre>
<p>The property is declared like so in an observable object:</p>
<pre><code> @Published var name:String = &quot;&quot;
</code></pre>
<p>So, I'm obviously missing something here. Why is sink called once at setup even though <code>name</code> did not change? I can avoid this behavior by using the <code>dropFirst()</code> operator but, I'd like to understand why the closure is always called once immediately after setup?</p>
<p>Why is that?</p>
","728246","","728246","","2022-05-26 03:16:57","2022-05-26 04:11:52","Swift Combine sink called once at setup?","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"72386187","1","72386626","","2022-05-26 02:56:58","","1","109","<p>I am using <code>WkWebView</code> for my app. When the view is loaded I would like to display the score Natively and not in the <code>WkWebView</code>. I used the <code>combine</code> Frame work to create an <code>ObservableObject</code> in order to display my score to the view and other views when the score changes in the <code>WkWebview</code>. I use <code>window.onload</code> to get the most recent score and display it when the page first renders. I do so by calling a JS function which sends a message to the Native side <code>webkit.messageHandlers.bridge.postMessage(&quot;0&quot;) </code> with the score and assign the sent score to my <code>ObservedObject</code>. The issue is on the Native side. The <code>UserContentController</code> function, which handles the message from the <code>WkWebview</code>, keeps printing out the score and reassigning the score to my <code>ObservedObject</code>.  It seems to be stuck in a loop. I provided a simplified version of the code below. Have been stuck on this for a few days now and cant seem to fix the issue.</p>
<pre><code> //Holds the score
class Myscore:ObservableObject{
@Published var score = &quot;0&quot;

}


 //Wkwebview
struct WebView: UIViewRepresentable {
@ObservedObject var myScore : Myscore

 class Coordinator: NSObject, WKNavigationDelegate, WKScriptMessageHandler {
    var webView: WKWebView?
    var myScore: Myscore
    init(myScore:Myscore) {
        self.myScore = myScore
        super.init()
        
    }
    
    
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        self.webView = webView
    }
    
    // receive message from wkwebview
    func userContentController(
        _ userContentController: WKUserContentController,
        didReceive message: WKScriptMessage
    ) {
        // This is where the issue occurs
        var newscore = message.body as! String
        myScore.score = newscore
        print(myScore.score)
    
    }
    
  }

func makeCoordinator() -&gt; Coordinator {
    return Coordinator(myScore:myScore)
}

func makeUIView(context: Context) -&gt; WKWebView {
    let coordinator = makeCoordinator()
    let userContentController = WKUserContentController()
    userContentController.add(coordinator, name: &quot;bridge&quot;)
    
    let configuration = WKWebViewConfiguration()
    configuration.userContentController = userContentController
    
    let _wkwebview = WKWebView(frame: .zero, configuration: configuration)
    _wkwebview.navigationDelegate = coordinator
    
    return _wkwebview
}

  func updateUIView(_ webView: WKWebView, context: Context) {
    guard let path: String = Bundle.main.path(forResource: &quot;index&quot;, ofType: &quot;html&quot;) 
 else { return }
    let localHTMLUrl = URL(fileURLWithPath: path, isDirectory: false)
    webView.loadFileURL(localHTMLUrl, allowingReadAccessTo: localHTMLUrl)
   }
 }

//Content View to display the Score
struct ContentView: View {
 @StateObject var myScore = Myscore()

var body: some View {
    VStack {
     
        Text(&quot;Your Score is\( myScore.score)&quot;)
        WebView(myScore: myScore)
    }
   }
  }
</code></pre>
<p>Edit here is the html side:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1, minimum-scale=1, viewport-fit=cover&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;button&gt;click me&lt;/button&gt;
&lt;hr/&gt;
&lt;div id=&quot;log&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    window.onload = function () {
        webkit.messageHandlers.bridge.postMessage(&quot;98 points&quot;)

    
    }
 
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Edit 2: This is what the console prints out
<a href=""https://i.stack.imgur.com/kX97a.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kX97a.png"" alt=""This is what the console prints out"" /></a></p>
","2029602","","2029602","","2022-05-26 04:04:19","2022-05-26 12:46:01","Change ObservedObject Value with Wkwebview","<swift><swiftui><wkwebview><combine>","2","4","","","","CC BY-SA 4.0"
"72394424","1","72395634","","2022-05-26 15:38:20","","0","139","<p>I want to use Alamofire to query my backend, encode the response using Alamofire's built-in Codable parsing and then publish an extract from the resulting Struct to be consumed by the caller of my API class.  Say I have some JSON data from my backend (simplified, but shows the structure):</p>
<pre><code>{
    &quot;total&quot;: 123,
    &quot;results&quot;: [
        {&quot;foo&quot; : &quot;bar&quot;},
        {&quot;foo&quot; : &quot;baz&quot;}
    ]
}
</code></pre>
<p>and the associated <code>Codable</code> Structs</p>
<pre><code>struct MyServerData: Codable {
    let total: Int
    let results: [Result]
}

struct Result: Codable {
    let foo: String
}
</code></pre>
<p>I can get, parse, publish, and subscribe all fine with the following:</p>
<pre class=""lang-swift prettyprint-override""><code>func myAPI() -&gt; DataResponsePublisher&lt;MyServerData&gt; {
    return AF.request(&quot;https://backend/path&quot;)
        .validate()
        .publishDecodable(type: MyServerData.self)
}

myAPI()
    .sink { response in /* Do stuff, e.g. update @State */ }
</code></pre>
<p>What I'd like to do is to publish just the <code>[Result]</code> array.  What's the correct approach to this?  Should I use <code>.responseDecodable()</code> and create a new publisher (somehow - <code>.map()</code>?) that returns a <code>[Result].publisher</code>?</p>
<p>While I think I understand the reactive/stream based principles my Combine-fu is still weak and I don't have a clear handle on the transformation of one publisher into another (I'm guessing?)</p>
<p>Thanks in advance!</p>
","2431627","","2431627","","2022-05-26 16:22:37","2022-05-26 17:15:00","Transforming Alamofire response when using Codable and Combine","<swift><alamofire><combine>","1","1","","","","CC BY-SA 4.0"
"72430252","1","72430345","","2022-05-30 06:58:00","","0","30","<p><code>DataResponse</code> is the object of Alamofire. It returns <code>Decodable</code> object and <code>Error</code> in success itself in .</p>
<p>Requirement is to pass on received <code>Decodable</code> object and <code>Error</code> separately. Is it feasible to transform <code>AnyPublisher&lt;DataResponse&lt;T, Error&gt;, Never&gt;</code> to <code>AnyPublisher&lt;T, Error&gt;</code>.</p>
<p>Consider <code>T</code> as any data type object.</p>
<pre><code>func fetchDataViaAlamofire(usingURl url: String) -&gt; AnyPublisher&lt;T, Error&gt; {
        return AF.request(url,
                          method: .get)
        .validate()
        .publishDecodable(type: T.self)
        .map { response in
            
            // ?
            // Cannot convert value of type 'DataResponse&lt;T?, AFError&gt;' to closure result type 'T'
            response.map { value in
                return response.value
            }
            
            // ?
            // Any way to convert AFError to Error in AnyPublisher&lt;T, Error&gt;
        }
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
        
    }
</code></pre>
","3035317","","12299030","","2022-05-30 07:07:01","2022-05-30 07:07:01","How to convert AnyPublisher<DataResponse<T, Error>, Never> to AnyPublisher<T, Error>","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"72436930","1","72437428","","2022-05-30 15:45:44","","0","70","<p>I've got a class class MapSearch that I instantiate when I need to auto-complete address results. It works perfectly but it never deinitializes and I can't figure out why.</p>
<p>Easily test by creating the files below. Use the back button after navigating to the test page and watch the console messages. You will see that the view model initializes and deinitializes as it should, but you'll only see MapSearch initialize.</p>
<p>HomeView.swift</p>
<pre><code>import SwiftUI

struct HomeView: View {

    var body: some View {
        NavigationView {
            NavigationLink(destination: TestView(viewModel: TestViewModel()) {
                Text(&quot;TestView&quot;)
            }
        }
    }
}
</code></pre>
<p>TestView.swift</p>
<pre><code>import SwiftUI

struct TestView: View {
    @StateObject var viewModel: ViewModel

    var body: some View {
        Text(&quot;Hello World&quot;)
    }
}
</code></pre>
<p>TestViewModel.swift</p>
<pre><code>import Foundation

extension TestView {
    @MainActor
    class ViewModel: ObservableObject {
        @Published var mapSearch: MapSearch()
        init() {
            print(&quot;Test View Model Initialized&quot;)
        }
        deinit {
            print(&quot;Test View Model Deinitialized&quot;)
        }
    }
}
</code></pre>
<p>MapSearch.swift</p>
<pre><code>import Combine
import CoreLocation
import Foundation
import MapKit

/// Uses MapKit and CoreLocation to auto-complete an address
class MapSearch: NSObject, ObservableObject {
    @Published var countryName: String = &quot;United States&quot;
    @Published var locationResults: [MKLocalSearchCompletion] = []
    @Published var searchTerm = &quot;&quot;

    private var cancellables: Set&lt;AnyCancellable&gt; = []

    private var searchCompleter = MKLocalSearchCompleter()
    private var currentPromise: ((Result&lt;[MKLocalSearchCompletion], Error&gt;) -&gt; Void)?

    override init() {
        super.init()
        searchCompleter.delegate = self
        searchCompleter.resultTypes = MKLocalSearchCompleter.ResultType([.address])

        $searchTerm
            .debounce(for: .seconds(0.2), scheduler: RunLoop.main)
            .removeDuplicates()
            .flatMap({ (currentSearchTerm) in
                self.searchTermToResults(searchTerm: currentSearchTerm, countryName: self.countryName)
            })
            .sink(receiveCompletion: { (_) in
            }, receiveValue: { (results) in

                // Show country specific results
                self.locationResults = results.filter { $0.subtitle.contains(self.countryName) }
            })
            .store(in: &amp;cancellables)

        print(&quot;MapSearch Initialized&quot;)
    }

    deinit {
        print(&quot;MapSearch Deinitialized&quot;)
    }

    func searchTermToResults(searchTerm: String, countryName: String) -&gt; Future&lt;[MKLocalSearchCompletion], Error&gt; {
        Future { promise in
            self.searchCompleter.queryFragment = searchTerm
            self.currentPromise = promise
        }
    }
}

extension MapSearch: MKLocalSearchCompleterDelegate {
    func completerDidUpdateResults(_ completer: MKLocalSearchCompleter) {
            currentPromise?(.success(completer.results))
        }

    func completer(_ completer: MKLocalSearchCompleter, didFailWithError error: Error) {
        // deal with the error here, it will finish the Combine publisher stream
         currentPromise?(.failure(error))
    }
}
</code></pre>
","11053343","","","","","2022-05-30 16:28:48","SwiftUI Class won't DeInit","<swift><class><memory><swiftui><delegates>","1","1","","","","CC BY-SA 4.0"
"72437943","1","72439402","","2022-05-30 17:17:21","","1","36","<p>I'm trying to make my SwiftUI views more &quot;Previewable&quot; therefore I'm making them generic over their Store (ViewModel) so I can more easily mock them.</p>
<p>Consider the following example:</p>
<pre class=""lang-swift prettyprint-override""><code>public protocol HomeViewStore: ObservableObject {
    associatedtype AnimatableImageStoreType = AnimatableImageStore

    var title: String { get }
    var animatableImageStores: [AnimatableImageStoreType] { get }
    var buttonTapSubject: PassthroughSubject&lt;Void, Never&gt; { get }
    var retryTapSubject: PassthroughSubject&lt;Void, Never&gt; { get }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>public protocol AnimatableImageStore: ObservableObject, Identifiable {
    var imageConvertible: Data? { get }
    var onAppear: PassthroughSubject&lt;Void, Never&gt; { get }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>struct AnimatableImage&lt;
    AnimatableImageStoreType: AnimatableImageStore
&gt;: View {
    @ObservedObject private var store: AnimatableImageStoreType

    public init(store: AnimatableImageStoreType) {
        self.store = store
    }

    ...
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>public struct HomeView&lt;
    HomeViewStoreType: HomeViewStore
&gt;: View {
    @StateObject private var store: HomeViewStoreType

    public init(store: HomeViewStoreType) {
        self._store = StateObject(wrappedValue: store)
    }

    public var body: some View {
        VStack {
            Text(store.title)
            Button {
                store.buttonTapSubject.send(())
            } label: {
                Text(&quot;API Call&quot;)
            }
            .background(Color(.accent))
            .padding()
            Button {
                store.retryTapSubject.send(())
            } label: {
                Text(&quot;Retry&quot;)
                    .font(.monserrat(.bold, 14))
            }
            .padding()
            List(store.animatableImageStores) { animatableImageStore in
                AnimatableImage(store: animatableImageStore)
            }
        }
        .background(Color(.accent))
    }
}
</code></pre>
<p>The code gives me the following error messages:</p>
<p><a href=""https://i.stack.imgur.com/aXc5P.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aXc5P.png"" alt=""enter image description here"" /></a></p>
<p>My questions would be, why is HomeViewStoreType.AnimatableImageStoreType not conforming to AnimatableImageStore protocol when inside HomeViewStore protocol I'm constraining it to AnimatableImageStore protocol and the same goes for Identifiable which AnimatableImageStore conforms to?</p>
<p>Would appreciate if someone could show me a proper way to achieve this :)</p>
","10974598","","5318223","","2022-05-30 19:36:40","2022-05-30 19:51:21","Why does associatedtype not conform to protocols defined in its constraining protocol?","<ios><swift><generics><swift-protocols><associated-types>","1","1","","","","CC BY-SA 4.0"
"72444221","1","72444317","","2022-05-31 08:07:24","","0","203","<p>I have a <code>CurrentValueSubject</code> to hold data received from <code>Firebase</code> fetch request.</p>
<pre><code>final class CardRepository: ObservableObject {

    private let store = Firestore.firestore()
    var resultSubject = CurrentValueSubject&lt;[Card], Error&gt;([])
    init() {
    }
    
    func get() {
        store.collection(StorageCollection.EnglishCard.getPath)
            .addSnapshotListener { [unowned self] snapshot, err in
                if let err = err {
                    resultSubject.send(completion: .failure(err))
                }
                if let snapshot = snapshot {
                    let cards = snapshot.documents.compactMap {
                        try? $0.data(as: Card.self)
                    }
                    resultSubject.send(cards)
                }
            }
    }
}
</code></pre>
<p>In my ViewModel, I want whenever <code>resultSubject</code> sends or <code>emits</code> a <code>value</code>. It will change the <code>state</code> and has that <code>value</code> attached to the <code>succes</code> state.</p>
<pre><code>class CardViewModel: CardViewModelProtocol, ObservableObject {
    
    @Published var repository: CardRepository
    @Published private(set) var state: CardViewModelState = .loading
    private var cancellables: Set&lt;AnyCancellable&gt; = []

    required init (_ repository: CardRepository) {
        self.repository = repository
        bindingCards()
        
    }
    
    private func bindingCards() {
        let _ = repository.resultSubject
            .sink { [unowned self] comp in
                switch comp {
                case .failure(let err):
                    self.state = .failed(err: err)
                case .finished:
                    print(&quot;finised&quot;)
                }
            } receiveValue: { [unowned self] res in
                self.state = .success(cards: res)
            }

    }
    
    func add(_ card: Card) {
        repository.add(card)
    }
    
    func get() {
        repository.get()
    }

}
</code></pre>
<p>On my ContentView, it will display a button that <code>print</code> the <code>result</code>.</p>
<pre><code>struct ContentView: View {
    @StateObject var viewModel = CardViewModel(CardRepository())
    var body: some View {
        Group {
            switch viewModel.state {
            case .loading:
                ProgressView()
                Text(&quot;Loading&quot;)
            case .success(cards: let cards):
                let data = cards
                Button {
                    print(data)
                } label: {
                    Text(&quot;Tap to show cards&quot;)
                }
            case .failed(err: let err):
                Button {
                    print(err)
                } label: {
                    Text(&quot;Retry&quot;)
                }
            }
            Button {
                viewModel.get()
            } label: {
                Text(&quot;Retry&quot;)
            }
        }.onAppear {viewModel.get() }
    }
}

</code></pre>
<p>My problem is the block below only trigger once when I first bind it to the <code>resultSubject</code>.</p>
<pre><code>} receiveValue: { [unowned self] res in
                self.state = .success(cards: res)
            }
</code></pre>
<p>I did add a debug and  <code>resultSubject.send(cards)</code> works every time.</p>
","11390095","","11390095","","2022-06-01 03:06:59","2022-06-01 05:48:31","CurrentValueSubject send(value) doesn't trigger receiveValue","<swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"72453046","1","72453099","","2022-05-31 19:13:06","","0","59","<p>I want to do something from the model file when the app goes to the background, like stop the timer or something else. But when I run the app and check for the <code>scenePhase</code> value it returns <code>.background</code> while the app is in the foreground.</p>
<pre><code>import SwiftUI
import Combine

class Model {
    @Environment(\.scenePhase) var scenePhase
    var timerSubscription: AnyCancellable?
    init() {
        timerSubscription = Timer.publish(every: 1, on: .main, in: .common).autoconnect().sink { _ in
            if self.scenePhase == .background {
                // do something when the app goes to the background.
            }
            print(self.scenePhase) // print background while the app is in the foreground.
        }
    }
}

struct ContentView: View {
    var model = Model()
    var body: some View {
        Text(&quot;Hello, world!&quot;)
            .padding()
            
    }
}
</code></pre>
","16153605","","","","","2022-05-31 19:35:19","Why scenePhase value is .background while the app is in the foreground?","<swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"72485945","1","72485957","","2022-06-03 07:12:31","","2","79","<p>I have a binding on my SwiftUI view</p>
<pre><code>@Binding var pinValue: String
</code></pre>
<p>I want to get update every time the value is changed. I tried below as I'd do on a <code>publisher</code> but I'm getting errors because it's not a <code>publisher</code>.</p>
<pre><code>.onReceive($pinValue, perform: { output in
            print(output)
        })
</code></pre>
<p>I've also tried to access <code>$pinValue.publisher</code> but the <code>.onReceive</code> block wont' work.</p>
<p>How can I get an update every time the value of <code>pinValue</code> is changed?</p>
","1563260","","","","","2022-06-23 04:37:21","Get value change update on Binding in SwiftUI","<swift><swiftui><combine>","1","0","","2022-06-23 06:28:55","","CC BY-SA 4.0"
"72500580","1","72511133","","2022-06-04 14:30:31","","0","81","<p>I have an <code>actor</code> which throttles requests in a way where the first one will suspend subsequent requests until finished, then share its response with them so they don't have to make the same request.</p>
<p>Here's what I'm trying to do:</p>
<pre><code>let cache = Cache()
let operation = OperationStatus()

func execute() async {
    if await operation.isExecuting else {
        await operation.waitUntilFinished()
    } else {
        await operation.set(isExecuting: true)
    }

    if let data = await cache.data {
        return data
    }

    let request = myRequest()
    let response = await myService.send(request)
    await cache.set(data: response)

    await operation.set(isExecuting: false)
}

actor Cache {
    var data: myResponse?

    func set(data: myResponse?) {
        self.data = data
    }
}

actor OperationStatus {
    @Published var isExecuting = false
    private var cancellable = Set&lt;AnyCancellable&gt;()

    func set(isExecuting: Bool) {
        self.isExecuting = isExecuting
    }

    func waitUntilFinished() async {
        guard isExecuting else { return }

        return await withCheckedContinuation { continuation in
            $isExecuting
                .first { !$0 } // Wait until execution toggled off
                .sink { _ in continuation.resume() }
                .store(in: &amp;cancellable)
        }
    }
}

// Do something
DispatchQueue.concurrentPerform(iterations: 1_000_000) { _ in execute() }
</code></pre>
<p>This ensures one request at a time, and subsequent calls are waiting until finished. It seems this works but wondering if there's a pure Concurrency way instead of mixing <code>Combine</code> in, and how I can test this? Here's a test I started but I'm confused how to test this:</p>
<pre><code>final class OperationStatusTests: XCTestCase {
    private let iterations = 10_000 // 1_000_000
    private let outerIterations = 10

    actor Storage {
        var counter: Int = 0

        func increment() {
            counter += 1
        }
    }

    func testConcurrency() {
        // Given
        let storage = Storage()
        let operation = OperationStatus()
        let promise = expectation(description: &quot;testConcurrency&quot;)
        promise.expectedFulfillmentCount = outerIterations * iterations

        @Sendable func execute() async {
            guard await !operation.isExecuting else {
                await operation.waitUntilFinished()
                promise.fulfill()
                return
            }

            await operation.set(isExecuting: true)
            try? await Task.sleep(seconds: 8)
            await storage.increment()
            await operation.set(isExecuting: false)
            promise.fulfill()
        }

        waitForExpectations(timeout: 10)

        // When
        DispatchQueue.concurrentPerform(iterations: outerIterations) { _ in
            (0..&lt;iterations).forEach { _ in
                Task { await execute() }
            }
        }

        // Then
        // XCTAssertEqual... how to test?
    }
}
</code></pre>
","235334","","","","","2022-06-05 21:07:16","How to suspend subsequent tasks until first finishes then share its response with tasks that waited?","<swift><swift-concurrency>","1","0","","","","CC BY-SA 4.0"
"72501184","1","72501915","","2022-06-04 15:59:23","","0","157","<p>I have the following code that makes an API call, receives data and assigns it to Core Data managed objects. This works well, and updates my data.</p>
<pre><code>func importUsers(url: URL) {
    URLSession.shared.dataTaskPublisher(for: url)
        .map(\.data)
        .sink(receiveCompletion: { completion in
            if case .failure(let error) = completion {
                print(&quot;DataImporter.runImport failed with error: \(error)&quot;)
            }
        }, receiveValue: { [weak self] data in
            guard let self = self
            else { return }
            
            self.importContext.perform {
                do {
                    // 2. Decode the response. This decodes directly to the Core Data Store
                    let users = try self.decoder.decode([GitUser].self, from: data)
                    
                    try? self.importContext.save()
                } catch {
                    print(&quot;DataImporter.runImport failed to decode json with error: \(error)&quot;)
                }
            }
        })
        .store(in: &amp;self.cancellables) // store the returned cancellable in a property on `DataImporter`
}
</code></pre>
<p>However, I need to return the number of objects returned and decoded as a result of this call. If it fails, I return 0. Essentially, I want this:</p>
<pre><code>func importUsers(url: URL) -&gt; Int {
    URLSession.shared.dataTaskPublisher(for: url)
        .map(\.data)
        .sink(receiveCompletion: { completion in
            if case .failure(let error) = completion {
                print(&quot;DataImporter.runImport failed with error: \(error)&quot;)
            }
        }, receiveValue: { [weak self] data in
            guard let self = self
            else { return 0 }
            
            var users: [GitUser] = []
            self.importContext.perform {
                do {
                    // 2. Decode the response. This decodes directly to the Core Data Store
                    users = try self.decoder.decode([GitUser].self, from: data)
                    
                    try? self.importContext.save()
                } catch {
                    print(&quot;DataImporter.runImport failed to decode json with error: \(error)&quot;)
                }
            }
            return users.count
        }).store(in: &amp;self.cancellables) // error: Cannot convert return expression of type '()' to return type 'Int'
}
</code></pre>
<p>How do I return the count of objects received as a result of the network call?</p>
","7129318","","","","","2022-06-04 18:27:51","Swift Combine Return Int From URLSession.shared.dataTaskPublisher","<swift><combine>","1","7","","","","CC BY-SA 4.0"
"72571978","1","72572087","","2022-06-10 09:24:24","","0","95","<p>Hello i have an issue with the refresh of my view when i toggle a boolean.
Here is the code</p>
<pre><code>class MyItem: Identifiable {
   @Published var isActive: Bool
}

struct myView: View {
   @Binding var item: MyItem
   var body: some View {
      HStack {
         Toggle(&quot;&quot;, isOn: $item.isActive)
         Spacer()
         TextField(&quot;&quot;, text: item.isActive ? $text : .constant(&quot;&quot;)) { isFocused in
             guard !isFocused &amp;&amp; text.count == 0 else { return }
             item.isActive.toggle
         }
            .background(item.isActive ? Color.white : Color.clear)
      }
   }
}
</code></pre>
<p>when i lose my focus and run <code>item.isActive.toggle</code> it change correctly his value, but my <code>Toggle</code> and my <code>TextField</code> doesn't update their UI (the Toggle is still active and the background of the TextField is still white)</p>
<p>Any idea of what i am missing ?</p>
","3227545","","3227545","","2022-06-10 09:31:15","2022-06-10 09:33:50","Toggle a Boolean in a Binding object doesn't update UI","<ios><swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"72574869","1","72580680","","2022-06-10 13:11:39","","1","62","<p>Using HalfASheet (<a href=""https://github.com/franklynw/HalfASheet"" rel=""nofollow noreferrer"">https://github.com/franklynw/HalfASheet</a>).</p>
<p>I have a View called <code>ProjectsView</code>, and in the <code>ZStack</code> in <code>ProjectsView</code> I have <code>ProjectSorting</code> and <code>SortingView</code>(both injected with the <code>EnvironmentObject</code>). I want the <code>Text</code>(🟩) in <code>ProjectSorting</code> to be changed, and the <code>HStack</code>(🟦) in <code>SortingView</code> to have a checkmark, both depending on the value of the <code>sorting</code> variable in <code>SortingValues</code>. Users can change the value of the <code>sorting</code> by pressing the <code>Button</code> in <code>SortingView</code>.</p>
<p>For whatever reason, the <code>Text</code>(🟩) in <code>ProjectSorting</code> does not change at all. And the <code>HStack</code>(🟦) in <code>SortingView</code> only gets the checkmark when its <code>ancestor stack</code> has another <code>Text</code>(🟨) which includes the <code>@State variable from the environment</code>, which I find very weird.</p>
<p>What should I change? Is there any way I can make this work using <code>@EnvironmentObject</code>? I'm a newbie and couldn't really understand other wrappers so I'd like to make this work within <code>@State</code>, <code>@Binding</code>, <code>@EnvirionmentObject</code>.
Thanks in advance.</p>
<p>SortingValues.swift</p>
<pre><code>import Combine

class SortingValues: ObservableObject {

    @Published var sorting = &quot;Top Rated&quot;

}
</code></pre>
<p>ProjectsView.swift</p>
<pre><code>struct ProjectsView: View {

    @Binding var isPresented: Bool

    @State var showSortingSheet = false

    var body: some View {

        ZStack {
            NavigationView {
                VStack(spacing: 0) {
                    ProjectsTopView(isPresented: $isPresented)
                    ProjectSorting(showSortingSheet: $showSortingSheet)
                        .environmentObject(SortingValues())
                    ProjectList()
                }
                .navigationBarHidden(true)
            }

            SortingView(showSortingSheet: $showSortingSheet)
                .environmentObject(SortingValues())
        }

    }
}
</code></pre>
<p>ProjectSorting.swift</p>
<pre><code>import SwiftUI
struct ProjectSorting: View {
    @EnvironmentObject var sortingValues: SortingValues
    @Binding var showSortingSheet: Bool
    @State var sortingValue = &quot;&quot;

    var body: some View {
        VStack {
            HStack {
                Text(&quot;Projects&quot;)

                Spacer()

                Button {
                    showSortingSheet.toggle()
                } label: {
                    HStack(spacing: 3) {
                        Image(&quot;sortingArrows&quot;)
                        Text(sortingValue)  // &lt; 🟩 this is the Text I want to be changed
                    }
                }
            }

            // Another HStack goes here
        }
        .onReceive(sortingValues.$sorting) { sorting in
            print(&quot;This is ProjectSorting. sorting:&quot;, sorting)  // &lt; this does not print when I close the half sheet
            sortingValue = sorting
        }
    }
}
</code></pre>
<p>SortingView.swift</p>
<pre><code>import SwiftUI
import HalfASheet

struct SortingView: View {
    @EnvironmentObject var sortingValues: SortingValues

    @Binding var showSortingSheet: Bool

    @State var sortingValue = &quot;&quot;

    var body: some View {
        VStack {

            HalfASheet(isPresented: $showSortingSheet) {
                let sorting = [&quot;Most Recent&quot;, &quot;Most Reviewed&quot;, &quot;Top Rated&quot;, &quot;Lowest Price&quot;, &quot;Highest Price&quot;]

                VStack(alignment: .leading) {

                    ForEach(sorting, id: \.self) { sorting in

                            VStack(alignment: .leading, spacing: 14) {

                                Button (action: {
                                    sortingValues.sorting = sorting
                                }, label: {
                                    HStack {  // 🟦
                                        Text(sorting)
                                        Spacer()
                                        if sorting == sortingValue {  // &lt; this is where I add the checkmark
                                            Image(systemName: &quot;checkmark&quot;)
                                        }
                                    }
                                    .foregroundColor(.primary)
                                })

                                if sorting != &quot;Highest Price&quot; {
                                    Divider()
                                }
                            }

                    }

                }
            }
            .height(.fixed(325))

            // Text(&quot;Inside VStack, outside HalfASheet&quot;)  // adding this Text DOES NOT make the HStack have a checkmark
            Text(&quot;Inside VStack, outside HalfASheet: \(sortingValue)&quot;)  // 🟨 adding this Text DOES make the HStack have a checkmark
        }
        .onReceive(sortingValues.$sorting) { sorting in
            // the two printing lines below print correctly every time I tap the Button
            print(&quot;This is SortingView. sorting:&quot;, sorting)
            print(&quot;sortingValues.sorting: \(sortingValues.sorting)&quot;)
            sortingValue = sorting
        }
    }
}
</code></pre>
","19314106","","19314106","","2022-06-10 14:55:55","2022-06-10 23:36:59","SwiftUI @State variable does not change view","<ios><swift><swiftui>","1","2","","","","CC BY-SA 4.0"
"72602568","1","72604247","","2022-06-13 12:07:00","","0","42","<p>I have a basic view controller subclass which contains a UIStackView and a UIButton. I want to run some code each time a view is added or removed from the stack view's <code>arrangedSubviews</code> array using Combine. Here's is my failed attempt to do this:</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine
import UIKit

class ViewController: UIViewController {
    @IBOutlet var stackView: UIStackView!
    @IBOutlet var button: UIButton!

    var cancelables = Set&lt;AnyCancellable&gt;()

    override func viewDidLoad() {
        super.viewDidLoad()

        stackView.publisher(for: \.arrangedSubviews).sink { views in
            button.isEnabled = views.count &lt; 5
        }
        .store(in: &amp;cancelables)
    }

    @IBAction func addTapped(_ sender: UIButton) {
        let customView = CustomView()
        stackView.addArrangedSubview(customView)
    }
}
</code></pre>
<p>Each time I tap the button, a new view is added to the stack view, but the change to <code>arrangedSubviews</code> is not published, which doesn't trigger the code in the <code>sink</code> block. In the case above, the button is still enabled even if <code>arrangedSubviews.count</code> is more than 5.</p>
<p>How can I fix this so that I can correctly publish changes whenever a new view is added or removed from the <code>arrangedSubviews</code> array?</p>
<p>Thank you for any help.</p>
","10654098","","","","","2022-06-13 14:24:28","Combine publisher for changes to UIStackView's arrangedSubviews array","<ios><swift><uikit><combine>","1","4","","","","CC BY-SA 4.0"
"72606185","1","72606308","","2022-06-13 16:33:07","","1","30","<p>I am trying to pop a SwiftUI view upon a particular event from an observed object. How can I do this? This code does not work because I can't refer to <code>self</code> inside the <code>sink</code> method.</p>
<pre><code>struct MyView: View {
  @Environment(\.presentationMode) var presentationMode
  @ObservedObject var observable: MyObservable

  init() {
    observable.$state.sink { state in    // !! Escaping closure captures mutating 'self' parameter !!
      presentationMode.wrappedValue.dismiss()
    }
  }
}
</code></pre>
","64505","","","","","2022-06-13 16:44:11","SwiftUI pop view upon observable event","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"72609975","1","72611881","","2022-06-13 23:10:40","","1","121","<p>A typical way to chain AnyPublisher is to use Combine operators like flatMap.</p>
<pre class=""lang-swift prettyprint-override""><code>
class MyService {
    func getUserList() -&gt; AnyPublisher&lt;[User], Error&gt; {
        ....
    }

    func getPostList(user: User) -&gt; AnyPublisher&lt;[Post], Error&gt; {
        ...
    }
}

class ViewModel: ObserableObject {
    let service = MyService()
    
    @published var post: [Post] = []
    
    func fetchAllPostFromLastUser() {
        service.getUserList().flatMap { [weak self] users in
            if let user = users.last {
                return self.service.getPosts(user: user)
            } else {
                return Fail(error:APIError.emptyUsers).eraseToAnyPublisher()
            }
        }
        .sink { result in
            
        }
    }
}

</code></pre>
<p>Is there a more elegant way to use async/await, so the code can be similar like</p>
<pre class=""lang-swift prettyprint-override""><code>class ViewModel: ObserableObject {
    let service = MyService()
    
    @published var post: [Post] = []
    
    func fetchAllPostFromLastUser() {
        let users = await service.getUserList().somethingMagicToConvertPublisherToAsync()
        let posts = await service.getPostList(user: user.first).somethingMagicToConvertPublisherToAsync()
    }
}

</code></pre>
","1861935","","","","","2022-06-14 14:51:13","How to chain AnyPublisher with async/await in SwiftUI","<swiftui><async-await><combine>","1","1","","","","CC BY-SA 4.0"
"72630551","1","72630806","","2022-06-15 11:30:07","","0","52","<p>Hello 👋🏼 I had spend over 10 hour to implement <code>Combine</code> framework but can't clear understanding how to link <code>Publisher</code> and <code>Subscriber</code>. In example I just wanna call <code>setTheme</code> funk from <code>Theme</code> class and automatically update <code>game</code> variable in <code>Game</code> class. I know how to achieve it with <code>didSet</code> but main goal to make it with <code>Combine</code>. Would be thankfull for help.</p>
<pre><code>import SwiftUI
import Combine
import Foundation

class Theme: ObservableObject {
    
    @Published private(set) var choosenTheme: Color? // Publisher right?
    
    func setTheme(with color: Color?) {
        if let unwrappedColor = color {
            self.choosenTheme = unwrappedColor
        } else {
            self.choosenTheme = nil
        }
    }
}

class Game: ObservableObject {
    
    @Published var game: String? // Subscriber right?
    private let gameTheme = Theme()
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        addSubscribers()
    }
    
    private func addSubscribers() { // I think something wrong here
        gameTheme.$choosenTheme
            .map(createGame)
            .sink { [weak self] (returnedString) in
                print(&quot;Value from sink \(String(describing: returnedString))&quot;)
                self?.game = returnedString
            }
            .store(in: &amp;cancellables)
    }
    
    private func createGame(for theme: Color?) -&gt; String? {
       if let unwrappedTheme = theme {
           print(unwrappedTheme)
           return String(&quot;\(unwrappedTheme)&quot;)
       } else {
           return nil
       }
   }
}

// Test:
var testTheme = Theme()
testTheme.setTheme(with: .orange)

var testGame = Game()
print(testGame.game) // Should be Orange

testTheme.setTheme(with: .blue)
print(testGame.game) // Should be Blue

testTheme.setTheme(with: nil)
print(testGame.game) // Should be nil
</code></pre>
","14737138","","","","","2022-06-15 11:46:29","Data flow with Combine in SwiftUI","<swift><swiftui><combine>","2","5","","","","CC BY-SA 4.0"
"72634192","1","72634478","","2022-06-15 15:39:16","","1","64","<p>I'm trying to understand how to chain and then recombine one-to-many network queries using Combine.</p>
<p>I have an initial request that retrieves some JSON data, decodes it and maps that to a list of IDs:</p>
<pre class=""lang-swift prettyprint-override""><code>let _ = URLSession.shared
    .dataTaskPublisher(for: url)
    .receive(on: apiQueue)
    .map(\.data)
    .decode(type: MyMainResultType.self, decoder: JSONDecoder())
    .map { $0.results.map { $0.id } } // 'results' is a struct containing 'id', among others
    // .sink() and .store() omitted
</code></pre>
<p>This gives me the expected array of ints: <code>[123, 456, ...]</code></p>
<p>For each of the ints I'd like to start another request that queries another endpoint using that ID as a parameter, retrieves some JSON, extracts an appropriate piece of data and then recombines that with the ID to give me a final list of <code>[(id, otherData), ...]</code>.</p>
<p>The second request is working as a function in isolation, with its own <code>sink()</code> and <code>store()</code>, and also as an <code>AnyPublisher&lt;&gt;</code>.</p>
<p>I've tried any number of <code>map { Publishers.Sequence ...}</code>, <code>.flatMap()</code>, <code>.combine()</code> etc. but think that maybe my mental model of what's happening is incorrect.</p>
<p>What I think I should be doing is <code>map()</code> each int to the secondary details request publisher, then doing a <code>flatMap()</code> to get back a single publisher, and <code>collect()</code>ing all the results, possibly with another map to bring in the ID, but nothing seems to give me a simple list, as described above, at the end.</p>
<p>How can I take my list of ints and spawn a number of further requests, waiting until all of them have completed, and then reassemble the id and the additional info into a single Combine chain?</p>
<p>TIA!</p>
","2431627","","","","","2022-06-15 16:01:04","Combine: how to chain and then recombine one-to-many network queries","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"72634444","1","72634941","","2022-06-15 15:58:42","","0","141","<p>I have an enum in my project:</p>
<pre><code>enum Remote&lt;Content&gt; {
  case .notAsked
  case .loading
  case .loaded(Content)
  case .failed(Error)
}
</code></pre>
<p>I then have a class:</p>
<pre><code>class MyViewModel: ObservableObject {
  @Published var content: Remote&lt;ContentStruct&gt; = .notAsked

  func fetchContent() {
    content = .loading

    service.fetchContent()
      .receive(on: queue)
      .map(Remote&lt;ContentStruct&gt;.loaded)
      .catch { error in Just(.failed(error)) }
      .assign(to: &amp;self.content)
  }
}
</code></pre>
<p>But this complains to me that:</p>
<pre><code>Cannot convert value of type 'Remote&lt;ContentStruct&gt;' to expected argument type 'Published&lt;Remote&lt;ContentStruct&gt;&gt;.Publisher'
</code></pre>
<p>I can change it to use this:</p>
<pre><code>func fetchContent() {
  content = .loading

  service.fetchContent()
    .receive(on: queue)
    .map(Remote&lt;ContentStruct&gt;.loaded)
    .catch { error in Just(.failed(error)) }
    .assign(to: \.content, on: self)
    .store(in: &amp;cancellables)
}
</code></pre>
<p>And this works and assigns the value correctly. But I don't understand why I can't use the <code>.assign(to: keyPath)</code> function on there?</p>
<p>Do I need to do something different? We've only recently updated to support a minimum of iOS14 and so not been using <code>assign(to:</code> before due to memory leaks and now I'm just not sure how this is working.</p>
<p>Thanks</p>
","421018","","421018","","2022-06-15 16:22:15","2022-06-15 16:38:07","Combine assign(to:) with a @Published var","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"72714509","1","72714650","","2022-06-22 11:14:54","","1","50","<p>I have a <code>DatePicker</code> and <code>TextField</code> which should be synced.</p>
<p>When I choose date in <code>DatePicker</code> value is updated in <code>TextField</code>.</p>
<p>When I type date in <code>TextField</code> value is updated in <code>DatePicker</code>, but I choose date in <code>DatePicker</code> after that <code>TextField</code> stay focused and value didn't update.</p>
<p>I read about <code>@FocusState</code> but <strong>iOS 14 should be supported</strong>.</p>
<p>How can I say <code>TextField</code> get lost focus when I tapped on <code>DatePicker</code>?</p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    @State private var selectedDate = Date()
    @State private var isHidden = true


    let formatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = &quot;MM/dd/yyyy&quot;
        return formatter
    }()

    var body: some SwiftUI.View {
        VStack(alignment: .center) {
            ZStack {

                HStack(alignment: .center) {

                    Text(&quot;Start Date&quot;)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .background(Color.yellow)
                        .onTapGesture {
                        self.onExpandTapped()
                    }
                    Spacer()
                        .background(Color.yellow)
                    if isHidden {
                        Text(selectedDate, style: .date)
                            .onTapGesture {
                            self.onExpandTapped()
                        }
                    } else {
                        TextField(&quot;Date&quot;, value: $selectedDate, formatter: formatter)
                            .multilineTextAlignment(.trailing)
                            .background(Color.red)
                            .fixedSize()

                    }
                }
            }

            if !isHidden {
                DatePicker(&quot;&quot;,
                    selection: $selectedDate,
                    displayedComponents: .date)
                    .padding(.horizontal)
                    .frame(width: 333)
                    .datePickerStyle(.graphical)
                    .labelsHidden()

            }
        }
    }

    private func onExpandTapped() {
        isHidden.toggle()
        UIApplication.shared.endEditing()
    }
}
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}


extension UIApplication {
    func endEditing() {
        sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
    }
}
</code></pre>
<p><a href=""https://i.stack.imgur.com/gOVrz.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gOVrz.gif"" alt=""enter image description here"" /></a></p>
","3295921","","","","","2022-06-22 11:41:02","SwiftUI: unfocus TextField when DatePicker date has been chosen","<ios><swift><macos><swiftui>","1","0","","","","CC BY-SA 4.0"
"72792881","1","72803557","","2022-06-28 20:36:22","","0","49","<p>I have a function that that builds several Publishers and returns them all in a single Publisher with MergeMany. The problem is that some users might have a LOT of endpoints in this publisher, and hitting all these endpoints at once frequently results in server timeouts. Is there a way to limit the concurrent network requests (like DispatchSemaphore) in Combine?</p>
<pre><code>let mergedPubs = Publishers.MergeMany(urlRequests.map { dataTaskPublisher(for: $0)
            .decode(type: RawJSON.self, decoder: JSONDecoder())
            .mapError { _ in
                return URLError(URLError.Code.badServerResponse)
            }
    })
        .collect()
        .eraseToAnyPublisher()
</code></pre>
","1349972","","","","","2022-06-29 17:41:08","Swift Combine MergeMany Publishers","<swift><networking><combine>","1","0","","","","CC BY-SA 4.0"
"72801416","1","72801518","","2022-06-29 12:25:12","","-2","41","<p>I've just started learning Combine and am quite confused with behaviour of KVO publishers. They just do not publish any events except for the initial value.
Here is the sample code I used:</p>
<pre><code>@objc class SampleClass: NSObject {
    @objc var name: NSString = &quot;1&quot;
}

var a = SampleClass()

let kvoPublisher = a.publisher(for: \.name)
    .sink(receiveCompletion: {
        print(&quot;completion \($0)&quot;)
    }, receiveValue: { newVal in
        print(&quot;new val - \(newVal)&quot;)
    })

a.name = &quot;2&quot;
a.name = &quot;3&quot;

print(&quot;Finished; publisher = \(kvoPublisher) | a.name = \(a.name)&quot;)
</code></pre>
<p>The console output is</p>
<pre><code>new val - 1
Finished; publisher = Combine.AnyCancellable | a.name = 3
</code></pre>
<p>Could you please explain what am I missing here and how to fix it?</p>
<p>Thanks.</p>
","7592330","","","","","2022-06-29 12:54:09","KVO publisher does not send signal on property change","<swift><reactive-programming><combine><key-value-observing>","1","0","","","","CC BY-SA 4.0"
"72861985","1","72863692","","2022-07-04 21:01:17","","0","36","<p>I created this function for decoding locally saved data.</p>
<pre><code>private func getLocalCertificates(_ data: [CovidCertificateEntity]) -&gt; [CovidCertificateDomainItem]? {
    var newCertificates: [CovidCertificateDomainItem]?
    
    Publishers
        .MergeMany(
            data.map { result -&gt; AnyPublisher&lt;Result&lt;EUDCC, ErrorType&gt;, Never&gt; in
                self.certificateToDelete = result.qrCodeValue ?? &quot;&quot;
                return repository.getCertificateDetails(result.qrCodeValue ?? &quot;&quot;)
            })
        .map { result -&gt; CovidCertificateDomainItem? in
            switch result {
            case .success(let eudcc):
                do {
                    return try CovidCertificateDomainItem(eudcc: eudcc, qrCode: self.certificateToDelete)
                }
                catch {
                    return nil
                }
                
            case.failure(_):
                return nil
            }
        }
        .compactMap { $0 }
        .collect()
        .sink { result in
            newCertificates = result.reversed()
        }
        .store(in: &amp;cancellables)
    
    return newCertificates
}
</code></pre>
<p>I wanted to achieve that value <em>result</em> from <em>data.map</em> inside <em>MergeMany</em> operator is proceeded to <em>.map</em> operator, so I can use it in constructor of <em>CovidCertificateDomainItem</em></p>
<p>I tried to made this with help variable <em>certificateToDelete</em>, but it always have last value from <em>data.map</em>.</p>
<p>Is there any way to achieve this?</p>
","16366914","","12299030","","2022-07-05 03:03:40","2022-07-05 03:25:44","Using value inside MergeMany operator in another pipeline","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"72877933","1","72878105","","2022-07-06 04:22:33","","1","41","<p>I am using Apollo Client subscriptions for my app. I follow the codes here on the documentation from Apollo <a href=""https://www.apollographql.com/docs/ios/subscriptions"" rel=""nofollow noreferrer"">https://www.apollographql.com/docs/ios/subscriptions</a> but I keep having an error on when I subscribe to the apollo subscription</p>
<p><code>Value of type 'Apollo.Cancellable' does not conform to 'Combine.Cancellable' in assignment</code></p>
<p>Here is my code</p>
<pre><code>self.subscription = ApolloNetwork.shared.apollo
            .subscribe(subscription: UserBalanceSubscription()) { [weak self] result in
            guard let self = self else {
                return
            }
            
            switch result {
            case .success(let graphQLResult):
                print(graphQLResult)
            case .failure(let error):
                print(&quot;error: \(error)&quot;)
            }
        }
</code></pre>
<p>Here is how I declare the var subscription</p>
<p><code>private var subscription: Cancellable?</code></p>
<p>I am getting confused what causing the issue and how to fix it.</p>
","8903723","","8903723","","2022-07-06 04:40:44","2022-07-06 04:54:06","Swift 'Apollo.Cancellable' does not conform to 'Combine.Cancellable'","<swift><graphql><apollo><apollo-client><combine>","1","3","","","","CC BY-SA 4.0"
"72903454","1","72903667","","2022-07-07 19:46:59","","0","43","<p>In my watch app, I wish to display list of events. When the view is opened, I send a request to iPhone app to send the events list. This is working so far and I am getting the events list back to Watch. However when I try to display the data on the list, I am getting errors due to custom object type. What I want is to display the events list when the data is available or just show a text on the view when there are no events.</p>
<p>Note: Watch connectivity to transfer data between devices/OS's does not allow custom data types, so have to conform to Codable and convert the data from CustomDataModel to Data type before transferring and then convert from Data to CustomDataModel in my Watch project.</p>
<p><em><strong>Below is the code and error that I see:</strong></em></p>
<p><em><strong>CustomDataModel</strong></em></p>
<pre><code>import Foundation

struct CustomDataModel: Codable {
    var startEndDate: String?
    
    var startEndTime: String?

    var locationDetails: String?
    
    var actions: Dictionary&lt;String, String&gt; = [:]
    
    var title: String?
    
    // Has more properties
    
    func encodeIt() -&gt; Data {
        let data = try! PropertyListEncoder.init().encode(self)
        return data
    }
    
    static func decodeIt(_ data:Data) -&gt; CustomDataModel {
        let customDataModel = try! PropertyListDecoder.init().decode(CustomDataModel.self, from: data)
        return customDataModel
    }
}
</code></pre>
<p><em><strong>CustomViewModel</strong></em></p>
<pre><code>import Foundation
import Combine

class CustomViewModel: ObservableObject, SessionCommands {
    @Published var eventsList:[CustomDataModel] = []
    
    init() {
        NotificationCenter.default.addObserver(forName: Notification.Name(&quot;eventsListReady&quot;), object: nil, queue: nil, using: self.processEventsList(_:))
    }
    
    @objc func processEventsList(_ notification: Notification) {
        if let response = (notification.object as! CommandStatus).response as? [Data] {
            response.forEach { event in
                eventsList.append(CustomDataModel.decodeIt(event))
            }
        }
     }
    
    func getEventsList() {
        self.eventsList = []
        sendMessage([&quot;functionality&quot;: Functionality.events.rawValue, &quot;notificationName&quot;: Notification.Name(&quot;requestEventsList&quot;)])
    }
}
</code></pre>
<p><em><strong>CustomView</strong></em></p>
<pre><code>import SwiftUI

struct CustomView: View {
    @ObservedObject var viewModel: CustomViewModel
    
    var body: some View {
        VStack {
            if !viewModel.eventsList.isEmpty {
                List(viewModel.eventsList) { item in
                    let _ = print(&quot;##### !viewModel.eventsList.isEmpty&quot;)
                    NavigationLink(destination: EventsDetailsView(eventItem: item)) {
                        EventRowView(eventItem: item)
                    }.navigationViewStyle(StackNavigationViewStyle())
                }
            } else {
                let _ = print(&quot;##### viewModel.eventsList.isEmpty&quot;)
                VStack {
                    Text(&quot;No events to display&quot;)
                }.frame(maxWidth: .infinity, maxHeight: .infinity)
            }
        }.navigationBarTitle(&quot;Back&quot;).onAppear() {
            self.viewModel.getEventsList()
        }
    }
}
</code></pre>
<p><em><strong>Error I get on &quot;List(viewModel.eventsList)&quot; in CustomView :</strong></em> <code>Initializer 'init(_:rowContent:)' requires that 'CustomDataModel' conform to 'Identifiable'</code></p>
<p>I am getting data in eventList object in CustomViewModel, but am not able to display it.</p>
","697033","","","","","2022-07-07 22:12:51","SwiftUI - Error - Initializer 'init(_:rowContent:)' requires that 'CustomDataModel' conform to 'Identifiable'","<ios><swift><swiftui><watchos>","1","4","","","","CC BY-SA 4.0"
"72919047","1","72922279","","2022-07-09 04:56:42","","0","67","<p>Consider the below Observable Object.</p>
<pre><code>class User: ObservableObject {
    @Published var age: Int
    @Published var name: String {
        didSet {
            objectWillChange.send()
        }
    }
    
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}

</code></pre>
<p>The below code prints blank value or Void block. Any reason why? If we change Integer value age it should simply print that value.</p>
<pre><code>let userJohnCancellable = userJohn.objectWillChange.sink { val in

    print(&quot;Changed Value \(val)&quot;)
    
}
userJohn.age = 21
userJohn.age = 39
</code></pre>
<p>We can try to print the values in the closure using <code>userJohn.age</code>. But why does val not return a Integer value in this case.</p>
<p>Also what would be the best way to handle <code>sink</code> changes for age and name, both, one is String other is Int.</p>
","908124","","","","","2022-07-09 14:41:34","sink value is Void with publisher","<swift><combine>","2","2","","","","CC BY-SA 4.0"
"72925444","1","72926326","","2022-07-10 00:21:31","","0","58","<p>I have a function which I use to make api call but sometimes, I could get a decaying error and debugging this has been difficult. Below is my function, is there any way to maybe log or print the bad decoding key since I am using combine.</p>
<pre><code>    func request&lt;T&gt;(with builder: BaseRequest, customDecoder: JSONDecoder) -&gt; AnyPublisher&lt;T, APIError&gt; where T: Codable {
        
        let encoding: ParametersEncoder = [.get, .delete].contains(builder.method) ? URLParameretersEncoder() : JSONParametersEncoder()
        customDecoder.keyDecodingStrategy = .convertFromSnakeCase
        var url: URL {
            var components = URLComponents()
            components.scheme = &quot;http&quot;
            components.host = builder.baseUrl
            components.path = &quot;/api/v1&quot; + builder.path
            
            guard let url = components.url else {
                preconditionFailure(&quot;Invalid URL components: \(components)&quot;)
            }
            
            return url
        }
        var urlRequest = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalAndRemoteCacheData, timeoutInterval: 46.0)
        urlRequest.httpMethod = builder.method.rawValue
        builder.headers.forEach { key, value in
            urlRequest.setValue(value, forHTTPHeaderField: key)
        }
        if let token = tokenManager.token {
            urlRequest.setValue(&quot;Bearer &quot; + token, forHTTPHeaderField: &quot;Authorization&quot;)
        }
        if let parameters = builder.parameters {
            guard let encoded = try? encoding.encode(parameters: parameters, in: urlRequest) else {
                fatalError()
            }
            urlRequest = encoded
        }
        self.log(request: urlRequest)
        return URLSession.shared
            .dataTaskPublisher(for: urlRequest)
            .receive(on: DispatchQueue.main)
            .mapError { _ in .unknown }
            .flatMap { data, response -&gt; AnyPublisher&lt;T, APIError&gt; in
                guard let response = response as? HTTPURLResponse else {
                    return Fail(error: APIError.invalidResponse).eraseToAnyPublisher()
                }
                self.log(response: response, data: data, error: nil)
                if (200...299).contains(response.statusCode) {
                    return Just(data)
                        .decode(type: T.self, decoder: customDecoder)
//                        .map {
//                            print($0)
//                            return $0
//                        } //added
                        .mapError {_ in .decodingError}
                        .eraseToAnyPublisher()
                } else {
                    guard let errorResponse = try? customDecoder.decode(BaseResponse.self, from: data) else {
                        return Fail(error: APIError.decodingError).eraseToAnyPublisher()
                    }
                    return Fail(error: APIError.server(response: errorResponse))
                        .eraseToAnyPublisher()
                }
            }
            .eraseToAnyPublisher()
    }
</code></pre>
","8310287","","","","","2022-07-10 06:14:57","decoding key issue swift codable","<swift><combine><codable>","1","3","","","","CC BY-SA 4.0"
"72955404","1","72955595","","2022-07-12 16:17:47","","3","58","<p>The question is best explained in an example:</p>
<pre><code>struct MyEditor: View {
    @Environment(\.managedObjectContext) var managedObjectContext
    
    @ObservedObject var song: Song
    
    var body: some View {
        TextEditor(text: $song.lyrics)
            .navigationTitle(song.title)
            .onChange(of: song.lyrics) { newValue in
                try? managedObjectContext.save()
            }
    }
}
</code></pre>
<p>It feels wrong to spam <code>save</code> but I want to make sure the data is stored. Is this allowed and a correct way to do it?</p>
<p>Another way I can think of is to create a publisher that smoothens the signal to save. If this is the correct way to do it. Can I retrieve the publisher from the ObservedObject or do I have to create a different <code>@State</code> property for that and use <code>onChange</code> to pass the values.</p>
<pre><code>struct MyEditor: View {
    @Environment(\.managedObjectContext) var managedObjectContext
    
    @ObservedObject var song: Song
    
    @State private var lyricsPublisher = PassthroughSubject&lt;String, Never&gt;()
    
    var body: some View {
        TextEditor(text: $song.lyrics)
            .navigationTitle(song.title)
            .onChange(of: song.lyrics) { newValue in
                lyricsPublisher.send(newValue)
            }
            .onReceive(lyricsPublisher
                .debounce(for: 0.5, scheduler: RunLoop.main)
                .removeDuplicates()
            ) { value in
                try? managedObjectContext.save()
            }
    }
}
</code></pre>
<p>This is what Song looks like as a <code>ManagedObject</code>.</p>
<pre><code>@objc(Song)
class Song: NSManagedObject, Identifiable {
    @nonobjc class func fetchRequest() -&gt; NSFetchRequest&lt;Song&gt; {
        return NSFetchRequest&lt;Scribble&gt;(entityName: &quot;Song&quot;)
    }

    @NSManaged public var id: UUID
    @NSManaged public var title: String
    @NSManaged public var lyrics: String
}
</code></pre>
","174655","","174655","","2022-07-12 16:44:49","2022-07-12 17:38:20","Are you allowed to save to the managed object context (Core Data) while typing in a TextEditor (Text Field Input)?","<core-data><swiftui><combine><observedobject>","2","4","1","","","CC BY-SA 4.0"
"72971969","1","72972358","","2022-07-13 19:59:58","","4","48","<p>Just getting into <code>Combine</code>, and for some reason I can't get <code>passthrough subjects</code> to work. Even though I have copy-pasted examples from multiple different sources, they just won't print anything. I have tried with <code>Publishers</code> and <code>CurrentValueSubjects</code> and they work fine, but with <code>PassThroughSubjects</code>; nope. Here's an example that I have tried:</p>
<pre><code>let mySubject = PassthroughSubject&lt;String, Error&gt;()

mySubject.sink(receiveCompletion: { completion in
        print(&quot;-- completion&quot;, completion)
    }, receiveValue: { value in
        print(&quot;-- value&quot;, value)
}).cancel()

mySubject.send(&quot;one&quot;)
mySubject.send(&quot;two&quot;)
mySubject.send(&quot;three&quot;)
</code></pre>
<p>This is run in <code>viewDidLoad</code>.
What am I doing wrong?</p>
<p>Like I said, I have tried <code>Publishers</code> and <code>CurrentValueSubjects</code> with success:</p>
<pre><code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;].publisher
    .sink(receiveValue: { v in
        print(&quot;-- hello&quot;, v)
}).cancel()

let subject = CurrentValueSubject&lt;String, Error&gt;(&quot;Initial Value&quot;)

subject.send(&quot;Hello&quot;)

subject.sink(receiveCompletion: { c in
    print(&quot;-- completion&quot;, c)
}, receiveValue: { v in
    print(&quot;-- value&quot;, v)
}).cancel()
</code></pre>
","8591381","","","","","2022-07-13 20:36:20","Why can't I get passthrough subjects to work for combine?","<ios><swift><combine>","2","2","","","","CC BY-SA 4.0"
"73010850","1","73010928","","2022-07-17 10:00:31","","2","55","<p>I'm creating a journaling app that would encourage the user to write at least a 100 characters in the Morning Pages section. I’d like to do that by placing a ProgressView at the bottom of a TextEditor. The progress bar would then go from 0 to 100% based on the user's input and stay at 100 if they write more than say 100 characters. The progress bar indicates the minimum chars needed to create the entry.</p>
<pre><code>import SwiftUI
import Combine

struct AddNewEntryView: View {

@Environment(\.dismiss) var dismiss
@EnvironmentObject var data : JournalEntriesData
@State var typeOfNewEntry : EntryType
@State var newEntry : Entry
@State var progressValue: Double = 0.0
let MIN_ENTRY_CHARS = 10

let detector = PassthroughSubject&lt;Void, Never&gt;()
let publisher: AnyPublisher&lt;Void, Never&gt;

init(entryType: EntryType) {
    _typeOfNewEntry = State(initialValue: entryType)
    _newEntry = State(initialValue: Entry(type: entryType, text: &quot;&quot;))
    
    publisher = detector
        .debounce(for: .seconds(1), scheduler: DispatchQueue.main)
        .eraseToAnyPublisher()
}

func limitTo(num: Double, maxNum: Double) -&gt; Double {
    return num &gt; maxNum ? maxNum : num
}

private func updateProgressBar() {
    print(&quot;char count&quot;, newEntry.text.count)
    progressValue = Double(newEntry.text.count / MIN_ENTRY_CHARS)
}

var body: some View {
    VStack {
        Form {
            Text(newEntry.created, style: .date)
                .font(.headline)
            Section(&quot;Entry&quot;) {
                TextEditor(text: $newEntry.text)
                    .foregroundColor(.secondary)
                    .padding(.horizontal)
                    .frame(minHeight: 80)
                    .onChange(of: newEntry.text) { _ in detector.send() }
                    .onReceive(publisher) {  updateProgressBar() 
                    }
                }
            ProgressView(&quot;Character count&quot;, value: $progressValue, total: 1.0)
        }
    }
    .toolbar {
        ToolbarItem {
            Button(&quot;Add&quot;) {
                data.entries.append(newEntry)
                dismiss()
            }
        }
      }
  }
}

struct AddNewEntryView_Previews: PreviewProvider {
    static var previews: some View {
        AddNewEntryView(entryType: .MORNING_PAGES)
    }
}
</code></pre>
<p>I almost got it now, but my ProgressView tells me that it cannot convert value of type Double to expected argument type Binding but I’m already using the $dollar sign there. It also says in the second error that initializer(in it value total) requires that binding Conforms to ‘BinaryFloatingPoint’. I’m new to Swift and getting a little lost in the typings here.</p>
","1354053","","","","","2022-07-17 11:26:44","Connect TextEditor text count to ProgressView in SwiftUI","<ios><swift><mobile><swiftui><playgrounds>","2","1","","","","CC BY-SA 4.0"
"73015462","1","73015746","","2022-07-17 21:22:59","","1","50","<p>I'm trying to change my function from using a completion handler to a function that uses combine, but I'm getting an error message.</p>
<ol>
<li><p>with completionHandler:</p>
<pre><code> typealias AuthorizationCompletion = (UNAuthorizationStatus) -&gt; ()

 func reloadAuthorizationStatus(completion: @escaping AuthorizationCompletion) {
 UNUserNotificationCenter.current().getNotificationSettings { settings in
     DispatchQueue.main.async {
         let notificationStatus = settings.authorizationStatus
         completion(notificationStatus)
     }
 }
</code></pre>
</li>
<li><p>Using Combine:</p>
<pre><code> func reloadAuthorizationStatus() -&gt; AnyPublisher&lt;UNAuthorizationStatus, Error&gt;  {
 UNUserNotificationCenter.current().getNotificationSettings { settings in
     Just(settings)
         .tryMap({$0.authorizationStatus})
         .eraseToAnyPublisher()
 }
</code></pre>
</li>
</ol>
<p>But getting the error Cannot convert return expression of type 'Void' to return type 'AnyPublisher&lt;UNAuthorizationStatus, Error&gt;'</p>
<p>From the moment I add the return type to the function, the settings let will change from type UNNotificationSettings to error type</p>
<p>What am I missing here ?</p>
","4795917","","560942","","2022-07-17 21:53:21","2022-07-17 22:19:14","Convert function with completionHandler to Combine","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"73033391","1","73033648","","2022-07-19 08:13:51","","0","95","<p>I am trying to learn Combine and understand how I can make it work with the new async/await syntax. I have this code which consists of a view controller with a button and a table view, the button triggers a request to MapKit's <code>MKLocalSearchCompleter</code> with a random text, which then publishes the update to reload the view controller's table view, with the data fetched from the <code>MKLocalSearchCompleter</code>.</p>
<p>For some reason, the second time that I tap the button and <code>withCheckedContinuation</code> gets called again, I get this error:</p>
<blockquote>
<p>Fatal error: SWIFT TASK CONTINUATION MISUSE: fillTableView(with:) tried to resume its continuation more than once, returning [&quot;Recklinghausen&quot;, &quot;Recquignies&quot;, &quot;Recloses&quot;, &quot;Recco&quot;, &quot;Recy&quot;, &quot;Reconvilier&quot;, &quot;Rectorat de Paris&quot;, &quot;Recke&quot;, &quot;Recques-sur-Course&quot;, &quot;Recto Versoi&quot;, &quot;Rechberghausen&quot;, &quot;Rechlin&quot;, &quot;Reclinghem&quot;, &quot;Reckange-sur-Mess&quot;, &quot;Récourt&quot;]!</p>
</blockquote>
<p>I don't understand because I though that the continuation was correctly resuming after the first call. What is happening?</p>
<p>Here is the code:</p>
<pre><code>import _Concurrency
import Combine
import MapKit
import UIKit

class ViewController: UIViewController {
    private var components: [String] = []
    // View Properties
    private let randomTexts = [&quot;re&quot;, &quot;ma&quot;, &quot;so&quot;, &quot;lem&quot;, &quot;tap&quot;, &quot;do&quot;, &quot;rec&quot;]
    // MapKit Properties
    private var searchCompleter = MKLocalSearchCompleter()
    // Combine Properties
    private var cancellables = Set&lt;AnyCancellable&gt;()
    private var publisher = PassthroughSubject&lt;[String], Never&gt;()
    
    @IBOutlet weak var tableView: UITableView!
    
    // Methods
    @IBAction func tapped() {
        guard let randomText = randomTexts.randomElement() else {
            return
        }
        searchCompleter.queryFragment = randomText
        fillTableView(with: randomText)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        searchCompleter.delegate = self
    }
    
    private func fillTableView(with randomElement: String) {
        Task {
            let autocompletedComponents = await withCheckedContinuation { continuation in
                publisher
                    .sink { continuation.resume(returning: $0) }
                    .store(in: &amp;cancellables)
            }
            components = autocompletedComponents
            tableView.reloadData()
        }
    }
}

extension ViewController: MKLocalSearchCompleterDelegate {
    func completerDidUpdateResults(_ completer: MKLocalSearchCompleter) {
        publisher.send(
            completer.results.map { $0.title }
        )
    }
}

extension ViewController: UITableViewDataSource, UITableViewDelegate {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        return components.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
        let cell = UITableViewCell()
        cell.textLabel?.text = components[indexPath.row]
        return cell
    }
}
</code></pre>
<p>Thank you for your help</p>
","14553929","","","","","2022-07-23 06:45:49","Swift: using combination of Combine and async/await results in Fatal error: SWIFT TASK CONTINUATION MISUSE tried to resume its continuation","<swift><async-await><combine><continuations>","2","2","","","","CC BY-SA 4.0"
"73037061","1","73037617","","2022-07-19 12:37:54","","-1","49","<p>I am sorry if this sounds very beginner, but after looking at Apple doc as well as several tutorials I still struggle to understand how Combine's Future works.</p>
<p>I have this very simple code which stores the current date on first button tap, and prints the interval on the second one:</p>
<pre><code>import UIKit

class MyViewController: UIViewController {
    private var startTime: Date = .now
    private var completion: (TimeInterval) -&gt; Void = { _ in }
    private var isOn = false
    
    @IBAction func tapped() {
        if isOn {
            completion(Date.now.timeIntervalSince(startTime))
        } else {
            startTime = .now
        }
        isOn.toggle()
    }

    init(_ completion: @escaping (TimeInterval) -&gt; Void) {
        super.init(nibName: &quot;MyViewController&quot;, bundle: .main)
        self.completion = completion
    }
    
    required init?(coder: NSCoder) {
        fatalError()
    }
}
</code></pre>
<p>In my AppDelegate:</p>
<pre><code>window?.rootViewController = MyViewController {
    print(&quot;Tapped with time interval: \($0)&quot;)
}
</code></pre>
<p>Now I would like to replace that completion handler with a <code>Future</code>, but I'm confused about what to do. I guess I have to create a function like this in my view controller:</p>
<pre><code>func afterSecondTap() -&gt; Future&lt;TimeInterval, Error&gt; {
    return Future { promise in
        // what to do here?
    }
}
</code></pre>
<p>And in the <code>AppDelegate</code> something like this:</p>
<pre><code>window?.rootViewController = MyViewController()
    .afterSecondTap()
    .sink(receiveCompletion: { completion in
            
    }, receiveValue: { value in
            
    })
    .store(in: &amp;subscriptions)
</code></pre>
<p>However this would not work because I get an error saying</p>
<blockquote>
<p>Cannot assign value of type '()' to type 'UIViewController'</p>
</blockquote>
<p>Thank you for helping me understand this</p>
","19579501","","","","","2022-07-19 13:15:02","Swift: how to replace a completion handler with a Future in an element initializer?","<swift><future><combine>","2","1","","","","CC BY-SA 4.0"
"73075094","1","73079344","","2022-07-22 04:22:31","","0","56","<p>In my app I have a task and a note object that both can contain an array of tags. The tasks and notes are fetched and stored in their respective stores. I pass these two classes down as environment objects. When a user is editing a task or a note, depending on the type, they go to the TaskEditView or NoteEditView. They can add a new tag, however if a tag already exists it will add that existing tag to the object. Because the tags are spread across two different stores how can I merge the two arrays and find if the tag exists without duplicating code?</p>
<pre><code>struct Task: Identifiable {
    var id: String = UUID().uuidString
    var tags: [Tag] = []
    // Other task properties
}

struct Note: Identifiable {
    var id: String = UUID().uuidString
    var tags: [Tag] = []
    // Other note properties
}

struct Tag {
    var title: String
    var color: Color
}

class TaskStore: ObservableObject {
    @Published var tasks = [Task]()
    // Other TaskStore properties and functions
}

class NoteStore: ObservableObject {
    @Published var notes = [Note]()
    // Other NoteStore properties and functions
}
</code></pre>
<hr />
<p>The only solution I have found is to pass the NoteStore and TaskStore down as environment objects and then map the tasks and notes arrays into a combined array of tag objects. However, I do not like this because I have to duplicate this code for the NoteEditView, TaskEditView and any other edit view of an object that contains a list of tags as a property. At the same time I have to pass every store that has objects that contain tags. Ideally I would want to create a class called TagStore that uses combine that subscribes to these two arrays.</p>
<pre><code>let tags = [taskStore.tasks.flatMap { $0.tags }, noteStore.notes.flatMap { $0.tags }]
     .flatMap { $0 }

if let tag = tags.first(where: { $0.title == &quot;History&quot; }) {
    // Tag already exists                       
}
</code></pre>
","","user19555877","","user19555877","2022-07-22 04:23:38","2022-07-22 11:11:45","How can I use combine to merge arrays from different ObservableObjects?","<arrays><swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"73132771","1","73136687","","2022-07-27 05:44:09","","2","34","<p>In all tutorials and in official documentation I only see initialization of timer straight up when the view loads.</p>
<pre><code>@State private var timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
</code></pre>
<p>and later on</p>
<pre><code>.onReceive(timer) {....}
</code></pre>
<p>but how should I init timer only on button click and assign it to the unassigned / not connected timer.</p>
<p>Later on I will need to cancel and reconnect, but that is not the issue here. Issue here is connecting only after button click.</p>
<p>I tried to init it like this</p>
<pre><code>@State private var timer: Cancellable?
</code></pre>
<p>....</p>
<pre><code>timer = Timer.publish(every: 1, on: .main, in: .common).connect()
</code></pre>
<p>But I can not call onReceive on timer inited like this, because first:</p>
<pre><code>Protocol 'Cancellable' as a type cannot conform to 'Publisher'
</code></pre>
<p>and second</p>
<pre><code>Argument type 'Cancellable?' does not conform to expected type 'Cancellable'
</code></pre>
","7507291","","","","","2022-07-27 10:56:53","Timer publisher init timer after button click","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"73140609","1","73140877","","2022-07-27 15:20:52","","1","24","<p>I created a simple Publisher from an array of paths I want to fetch from the internet. I am setting the failure type to match the DataTaskPublisher, and then I flatMap to get the new Publisher with the DataTask results. However, when I subscribe to the stream with sink, nothing gets called.</p>
<p>Here is my code:</p>
<pre><code>import Combine
import Foundation

class NetworkManager {
    var tasks = Set&lt;AnyCancellable&gt;()
    
    init() {
        getData()
    }
    
    func getData() {
        let baseUrl = URL(string: &quot;https://fmi.unibuc.ro&quot;)!
        [&quot;/prezentare&quot;, &quot;/cazare&quot;].publisher
            .setFailureType(to: URLError.self)
            .flatMap { path -&gt; URLSession.DataTaskPublisher in
                let url = baseUrl.appendingPathComponent(path)
                return URLSession.shared.dataTaskPublisher(for: url)
            }
            .sink(receiveCompletion: { completion in
                print(completion)
            }, receiveValue: { value in
                print(value)
            })
            .store(in: &amp;tasks)
    }
}

let manager = NetworkManager()
</code></pre>
<p>What am I doing wrong? 🤔</p>
","19633958","","4667835","","2022-07-27 15:40:42","2022-07-27 15:40:42","Combine's DataTaskPublisher does not output when passed through flatMap in Playgrounds","<swift><combine><swift-playground><urlsession>","1","0","","","","CC BY-SA 4.0"
"73160043","1","73162563","","2022-07-28 23:05:26","","0","47","<p>I have a function using Combine that provides a list of results based on user entry.</p>
<p>For example:
If the user types rain it will display a list of results with the word rain in it.</p>
<p>The data is being stored in a struct and I need to first match on one element and if there are no matches, try matching on another element.</p>
<p>For example:</p>
<pre><code>struct dataSet: Codable, Hashable {
    let nameShort: String
    let nameLong: String
}
</code></pre>
<p>When the user enters a value in the form field, I want it to first look through nameShort, and then if there are no results, look through nameLong.</p>
<p>The second part of the equation is that I need it to match using the entire string, but with separate words.</p>
<p>For example:
If the user enters brown, it should look through the nameShort for brown and then the nameLong for brown. However, if there are tons of entries matching brown and the user then types brown chair, I need it to return results that match both of those values.</p>
<p>Likewise, if the user types brow chai, it should still return brown chair as the initial characters match a word in the struct, even if nameLong is Brown - Side Chair.</p>
<p>Here's an example of my current function:</p>
<pre><code>func editingChangedName(_ value: String) {
    $myName
        .debounce(for: 0.3, scheduler: RunLoop.main)
        .receive(on: DispatchQueue.global()) // Perform filter on background
        .map { [weak self] filterString in
            guard filterString.count &gt;= 3, let self = self else { return [] }
            return self.nameArray.filter {
                $0.nameShort
                    .lowercased()
                    .contains(
                        filterString.lowercased()
                    ) ||
                $0.nameLong
                    .lowercased()
                    .contains(
                        filterString.lowercased()
                    )
            }
        }
        .receive(on: RunLoop.main) // Switch back to main thread
        .assign(to: &amp;$allNamesArray)
} // End func
</code></pre>
<p>This runs onChange of the form field so it's constantly updating the results.</p>
<p>I've tried things like:</p>
<pre><code>let searchString = filterString.lowercased().components(separatedBy: &quot; &quot;)
</code></pre>
<p>below the guard statements, and then removed $0.nameShort and $0.nameLong from the return, replacing it with:</p>
<pre><code>searchString.contains(where: $0.nameLong.contains)
</code></pre>
<p>but then all the results get screwy.</p>
<p>If I remove $0.nameShort and only use $0.nameLong, and change .contains to .hasPrefix it will only read from left to right and match exactly those characters that exist. So, if I was to type chair I would get 0 results, whereas if I typed brown I would get all the results that start with brown.</p>
<p>I feel like I'm close but can't figure out how to do this properly.</p>
","11053343","","","","","2022-07-29 06:41:40","Swift Combine Compare String","<arrays><swift><filter><combine>","1","0","","","","CC BY-SA 4.0"
"73169591","1","73169666","","2022-07-29 18:25:18","","1","43","<p>I have an array of notifications in my view model that are of type <em>NotificationsEnum</em> so that I can send different <em>types</em> of notifications from my backend and display them in their matching SwiftUI view depending on their type. (like, comment, etc...)</p>
<p>NotificationEnum data type is used to switch on the notification's type property so I can assign it to its appropriate View.</p>
<p>I want the ability to remove all notifications from ProfileViewModel's notifications array that are have the same userId.</p>
<p>The problem I am having is figuring out how to remove these notifications from the ProfileViewModels notifications array (of type [NotificationsEnum]) by userId when the userId property is not directly accessed from type NotificationsEnum and is &quot;obscured away&quot;.</p>
<p>If I print out each notification, you can see their structure below:</p>
<pre><code>[
    App.NotificationsEnum.like (
      App.LikeNotification(id: &quot;62ed8df9fd9df47c&quot;, type: &quot;like&quot;, userId: 
        &quot;634k32816fjh35sd35182d3&quot;, )
   )
]
</code></pre>
<p>How can I write code that will remove all notifications where: { userId == userId } inside of my ProfileViewModel's static subscription <em>removeNotifications</em>??</p>
<p>Thank you!</p>
<p><strong>VIEW MODEL</strong></p>
<pre><code>class ProfileViewModel: ObservableObject {
    
    @Published var notifications: [NotificationsEnum] = []
    
    var subscriptions = Set&lt;AnyCancellable&gt;()
    static let removeNotifications = PassthroughSubject&lt;String, Never&gt;()
    
    init() {
        Self.removeNotifications.sink { [weak self] userId in
            guard let self = self else { return }
           // Need code that functions like below example...
           // self.notifications.removeAll(where: {$0.userId == userId})
        }.store(in: &amp;subscriptions)
    }
}
</code></pre>
<p><strong>NOTIFICATION ENUM TYPE</strong></p>
<pre><code>enum NotificationsEnum: Decodable, Identifiable {
    
    var id: String {
        switch self {
            case .like(let like):
                return like.id
            case .comment(let comment):
                return comment.id
       
            }
    }

    case like(LikeNotification)
    case comment(CommentNotification)
 
        
    private enum CodingKeys: String, CodingKey {
        case type
    }
    
   init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
    
    let type = try container.decode(String.self, forKey: .type)
        switch type {
        case &quot;like&quot;:
            self = try .like(LikeNotification(from: decoder))
        case &quot;comment&quot;:
            self = try .comment(CommentNotification(from: decoder))
        default:
             throw DecodingError.wrongJSON
        }
    }
}
</code></pre>
<p><strong>LIKE &amp; COMMENT NOTIFICATION MODELS</strong></p>
<pre><code>struct CommentNotification: Codable, Identifiable {
    let id: String
    let type: String
    let userId: String
    let comment: String
}

struct LikeNotification: Codable, Identifiable {
    let id: String
    let type: String
    let userId: String
}

</code></pre>
","19070329","","12299030","","2022-07-29 18:34:58","2022-07-29 18:34:58","How to remove objects in Enum type array?","<ios><swift>","1","0","","","","CC BY-SA 4.0"
"73194185","1","73194355","","2022-08-01 13:10:14","","0","46","<p>I've been writing Swift with Combine for a while now. I've even finished an app that I use privately.  I've been struggling to understand and use Combine effectively.  Lately I'm working through the books &quot;Using Combine with Swift&quot; by Joseph Heck and &quot;Combine Mastery&quot; from Big Mountain by Mark Moeykens.  Both books have been extremely helpful in understanding Combine.</p>
<p>BUT..... I'm struggling to understand why in the examples I see code where the publisher / subscriber code is placed within init() {} like this example from Combine Mastery :</p>
<pre><code>
//  Copyright © 2021 Mark Moeykens. All rights reserved. | @BigMtnStudio
class Published_IntroductionViewModel: ObservableObject {
    var characterLimit = 30
    @Published var data = &quot;&quot;
    @Published var characterCount = 0
    @Published var countColor = Color.gray

    init() {
        $data
            .map { data -&gt; Int in
                return data.count
            }
            .assign(to: &amp;$characterCount)
        
        $characterCount
            .map { [unowned self] count -&gt; Color in
                let eightyPercent = Int(Double(characterLimit) * 0.8)
                if (eightyPercent...characterLimit).contains(count) {
                    return Color.yellow
                } else if count &gt; characterLimit {
                    return Color.red
                }
                return Color.gray
            }
            .assign(to: &amp;$countColor)
    }
}
</code></pre>
<p>and for other examples the code is not in init() {}
like this from Combine Mastery:</p>
<pre><code>
//  Copyright © 2021 Mark Moeykens. All rights reserved. | @BigMtnStudio

class Just_IntroductionViewModel: ObservableObject {
    @Published var data = &quot;&quot;
    @Published var dataToView: [String] = []
    
    func fetch() {
        let dataIn = [&quot;Julian&quot;, &quot;Meredith&quot;, &quot;Luan&quot;, &quot;Daniel&quot;, &quot;Marina&quot;]
        
        _ = dataIn.publisher
            .sink { [unowned self] (item) in
                dataToView.append(item)
            }
        
        if dataIn.count &gt; 0 {
            Just(dataIn[Int.random(in: 0..&lt;5)])
                .map { item in
                    item.uppercased()
                }
                .assign(to: &amp;$data)
        }
    }
}
</code></pre>
<p>The answer may be &quot;Duh that's so obvious&quot; but I'm afraid it completely escapes me and would appreciate any guidance on this topic.</p>
","13622371","","4667835","","2022-08-01 13:25:19","2022-08-01 13:48:54","Combine why publish in init or not in init","<swift><combine>","2","4","","","","CC BY-SA 4.0"
"73232961","1","73233048","","2022-08-04 08:51:25","","-1","33","<p>Let's assume you have a publisher that returns a list of some entity. Let's say it comes from a use case that fetches something from an api</p>
<pre><code>protocol SomeAPI {
    func fetchSomeEntity() -&gt; AnyPublisher&lt;[SomeEntity], Error&gt;
}
</code></pre>
<p>Now you want to run some side effect on the output. Say, saving the result into a repository.</p>
<p>You would go with the <code>handleEvents</code> operator wouldn't you.</p>
<pre><code>    api.fetchSomeEntity().handleEvents(receiveOutput: {[unowned self] list in 
         repository.save(list) 
    })
</code></pre>
<p>But what if someone did that using/misusing the map operator:</p>
<pre><code>api.fetchSomeEntity().map { [unowned self] list in
   repository.save(list)
   return list
}
</code></pre>
<p>Would you say there's something fundamentally wrong with that approach or is it just another path to the same end?</p>
","5724584","","","","","2022-08-04 09:36:53","Swift Combine: handleEvents vs map","<swift><combine>","1","6","","","","CC BY-SA 4.0"
"73279525","1","73279688","","2022-08-08 14:28:38","","0","27","<p>I use a pattern like this for mocking:</p>
<pre><code>protocol Foo {
    func bar() -&gt; AnyPublisher&lt;Bool, Never&gt;
}

final class MockFoo: Foo {

    var barResult: Result&lt;Bool, Never&gt;?

    init(barResult: Result&lt;Bool, Never&gt;? = nil) {
        self.barResult = barResult
    }

    func bar() -&gt; AnyPublisher&lt;Bool, Never&gt; {
        switch barResult {
        case let .some(result):
            return result
                .publisher
                .eraseToAnyPublisher()
        case .none:
            return Empty&lt;Bool, Never&gt;()
                .eraseToAnyPublisher()
        }
    }
}
</code></pre>
<p>Which means I end up mapping a <code>Result?</code> to publisher. It is trivial but I type it so often that I am really tempted to make it generic in order to be able to just write this:</p>
<pre><code>func bar() -&gt; AnyPublisher&lt;Bool, Never&gt; {
    barResult.publisher
}
</code></pre>
<p>Unfortunately I am having problems with defining the extension on <code>Optional</code>. I need something roughly like this:</p>
<pre><code>extension Optional where Wrapped == Result&lt;Success,Failure&gt; {

    var publisher: AnyPublisher&lt;Success, Failure&gt; {
        switch self {
        case .none:
            return Empty&lt;Success, Failure&gt;()
                .eraseToAnyPublisher()
        case let .some(result):
            return result.publisher
                .eraseToAnyPublisher()
        }
    }

}
</code></pre>
<p>But the above won't compile. Is it possible? How to declare it so that the compiler understands?</p>
","7948372","","","","","2022-08-08 14:39:30","How to declare an extension on Optional where Wrapped is a Result?","<swift><generics><combine>","1","0","","","","CC BY-SA 4.0"
"73297313","1","73298040","","2022-08-09 19:46:37","","0","58","<p>I would like to pass a timer from <code>ContentView</code> to <code>SecondView</code>, but I don't know how to manage it because I never used it before.</p>
<p>Can someone figure this out for me?</p>
<h2>ContentView</h2>
<pre><code>struct ContentView: View {
    @State private var timer = Timer.publish(every: 1, tolerance: 0.5, on: .main, in: .common).autoconnect()
    @State private var timeRemaining = 10
    
    
    var body: some View {
        NavigationView {
            VStack {
                Text(&quot;\(timeRemaining)&quot;)
                    .onReceive(timer) { _ in
                        if timeRemaining &gt; 0 {
                            timeRemaining -= 1
                        }
                    }
                
                NavigationLink {
                    SecondView(timer: ???) // &lt;-- What should i pass here?
                } label: {
                    Text(&quot;Change View&quot;)
                }
            }
        }
    }
}
</code></pre>
<h2>SecondView</h2>
<pre><code>struct SecondView: View {
    @Binding var timer: ??? // &lt;-- What type?
    @State private var timeRemaining = 5
    
    var body: some View {
        Text(&quot;Hello&quot;)
            .onReceive(timer) { _ in
                if timeRemaining &gt; 0 {
                    timeRemaining -= 1
                }
            }
    }
}

struct SecondView_Previews: PreviewProvider {
    static var previews: some View {
        SecondView(timer: ???) // &lt;-- Same thing here in SecondView preview
    }
}
</code></pre>
","18758938","","6950415","","2022-08-09 21:05:06","2022-08-10 08:39:06","How can I pass Binding<Timer> in SwiftUI?","<ios><swift><swiftui><timer><combine>","3","2","","","","CC BY-SA 4.0"
"73330179","1","73330281","","2022-08-12 06:43:41","","3","23","<p>Right now, I've been running into an issue of registering protocol conforming to <code>ObservableObject</code>. Since <code>ObservableObject</code> uses an associated type, I cannot find a way to register it without compiling error.</p>
<p>This is my simple model, called A</p>
<pre><code>protocol A: ObservableObject {}
</code></pre>
<p>This is my simple class, called B</p>
<pre><code>final class B: A {}
</code></pre>
<p>Here is my Assembly</p>
<pre><code>final class ViewStoreAssembly: Assembly{
    func assemble(container: Container) {
        container.register(A.self) { _ in
            B()
        }
    }
}
</code></pre>
<p>I'm trying to register A comforming to ObservableObject, but the compilation error shows that</p>
<blockquote>
<p>Protocol 'A' can only be used as a generic constraint because it has
Self or associated type requirements</p>
</blockquote>
<p>Does anyone know how to tackle the issue? The benefits of doing this will be</p>
<ol>
<li>In SwiftUI, we can decouple view out of ViewStore/presenter so that view can be separated from viewModel holder</li>
<li>ViewStore/Presenter can be tested easily by mocking a view</li>
</ol>
","10344746","","","","","2022-08-12 06:53:30","How to use Swinject to register protocol conforming to ObservableObject?","<swift><swiftui><protocols><combine><swinject>","1","0","","","","CC BY-SA 4.0"