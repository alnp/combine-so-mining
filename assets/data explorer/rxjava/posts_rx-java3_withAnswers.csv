Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"49154069","1","49154248","","2018-03-07 14:16:59","","13","3463","<p>When creating an Observable like this: </p>

<pre><code>public void foo() {

    Observable observable = Observable.fromCallable(() -&gt; {
        bar();
        return """";
      })
      .doOnSubscribe(disposable -&gt; System.out.println(""onSubscribe""))
      .doOnDispose(() -&gt; System.out.println(""onDispose""));

    Disposable disposable = observable.subscribe();
    disposable.dispose();    
}

private void bar() {
    System.out.println(""bar"");
}
</code></pre>

<p><code>doOnSubcribe</code> is called, <code>doOnDispose</code> is not called. </p>

<p>Why is that?</p>
","804967","","5739006","","2021-08-22 04:04:27","2021-08-22 04:04:27","Why is doOnDispose not called?","<java><rx-java><rx-java2><rx-java3>","1","0","3","","","CC BY-SA 3.0"
"49154248","2","","49154069","2018-03-07 14:26:19","","27","","<p>You need to use the <code>doFinally()</code> operator. </p>

<p><code>doOnDispose()</code> has a very narrow use case, where the observable is explicitly disposed. In your example, the observable terminates ""naturally"" by <code>onComplete()</code>. By the time that you call <code>dispose()</code>, the observable is done, and nothing will happen -- disposing a completed observable has no effect.</p>
","1241193","","61158","","2018-03-07 14:37:47","2018-03-07 14:37:47","","","","0","","","","CC BY-SA 3.0"
"60970014","1","","","2020-04-01 11:39:51","","1","86","<p>I am trying to write a simple example that uses the <code>switchOnNext</code> operator. I want to generate an infinite stream of infinite streams. EAch individual stream will generate from 1 to infinity. </p>

<p>Using <code>switchOnNext</code> I would expect that each observable will emit it's first <code>n</code> elements, and then the next one, and so on.</p>

<p>To generate an observable that generates values from 1 to infinty I have implemented the static <code>rangeInf</code> function. The <code>main</code> method contains the logic that is supposed to print the values. </p>

<p>When running the program however only the first stream is subscribed to and only its values are printed to the console. For sanity's sake I took the interval observable (built-in and also infinite), but there the behaviour is as expected. </p>

<p>What am I missing here?</p>

<p>At first I figured it would be because interval is on its own seperate thread. But I tried adding <code>.observeOn(Schedulers.computation())</code> in the <code>rangeInf</code> method, but that doesn't seem to fix the problem either.</p>

<h2>Output with <code>interval</code></h2>

<pre><code>&gt; Task :Main.main()
Next observable
id 144: value 1
id 144: value 1
id 144: value 1
id 144: value 1
id 144: value 1
id 144: value 1
id 144: value 1
id 144: value 1
id 144: value 1
Next observable
id 115: value 1
id 115: value 1
id 115: value 1
id 115: value 1
...
</code></pre>

<h2>Output with <code>Observable.generate</code></h2>

<pre><code>&gt; Task :Main.main()
Next observable
id 173: value 0
id 173: value 1
id 173: value 2
id 173: value 3
id 173: value 4
id 173: value 5
...
</code></pre>

<h2>Source</h2>

<pre><code>import io.reactivex.rxjava3.annotations.NonNull;
import io.reactivex.rxjava3.core.*;
import io.reactivex.rxjava3.functions.BiConsumer;
import io.reactivex.rxjava3.functions.BiFunction;
import io.reactivex.rxjava3.functions.Consumer;
import io.reactivex.rxjava3.functions.Supplier;
import io.reactivex.rxjava3.schedulers.Schedulers;

import java.util.Random;
import java.util.concurrent.TimeUnit;

public class Main {
    static Random r = new Random();
    public static void main(String[] args) throws InterruptedException {
        Observable&lt;Observable&lt;String&gt;&gt; inf =
                Observable.interval(0, 10, TimeUnit.SECONDS)
                        .map(x -&gt; {
                            int id = r.nextInt(1000);
                            return Main.rangeInf().map(v -&gt; String.format(""%d: %d"", id, v));
                        })
                        .doOnNext(i -&gt; System.out.println(""Next observable""));

        Observable.switchOnNext(inf)
                .subscribe(System.out::println);

        while(true) {
            Thread.sleep(10000);
        }
    }

    public static Observable&lt;Integer&gt; inf() {
        Observable&lt;Integer&gt; inf=  Observable.interval(1, TimeUnit.SECONDS)
                .map(x -&gt; (int) Math.random() * 3000 + 1);

        return inf;

    }
    public static Observable&lt;Integer&gt; rangeInf() {
        // Initial state.
        Supplier&lt;Integer&gt; s = () -&gt; 0;
        // Generator.
        BiFunction&lt;Integer, Emitter&lt;Integer&gt;, Integer&gt; nxt = (i, e) -&gt; {
            e.onNext(i);
            delay(); // delay random amount of time.
            return i + 1;
        };
        return Observable.generate(s, nxt);
    }

    public static void delay() {
        int random = (int) (Math.random() * 1 + 1);
        try {
            Thread.sleep(random * 1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
","1225786","","","","","2020-04-01 11:39:51","RxJava `switchOnNext` with infinite streams","<java><rx-java><rx-java3>","0","2","","","","CC BY-SA 4.0"
"61164480","1","61170006","","2020-04-11 22:23:23","","0","312","<p>I have multiple functions that return an <code>Observable&lt;String&gt;</code>. Each function execute command on the file system. I need to execute each function one after another and get the output of the function in the observable. At the end i want a single <code>Observable&lt;String&gt;</code> that contains the output of all the functions in the order of functions calls</p>

<p>Individually, each function work as expected but i need to merge output correctly.</p>

<p>I have try Observable.concatArray(func1, func2, ... ) like this:</p>

<pre><code>    return Observable.concatArray(
        func1(),
        func2(),
        func3(), 
        func4()
    );
</code></pre>

<p>but this just preserve the sequence of the observable's events. Not the sequence of the functions. I means if func1 emit events A and A' et func2 emit B and B', i will have A->A'->B->B'. But func2 will start immediately after func1. This cause me problem are func1 need to be finished before func2 can start.</p>

<p>The first function generate directory on the file system via maven. So, a long duration task. The second, writes a file inside this directory. But concatArray launch the second immediately after the first. And the command fail because the directory does not exist at this time.</p>

<p>Is there a way to avoid something ugly like this :</p>

<pre><code>Subject&lt;String&gt; result = PublishSubject.create();
Observable&lt;String&gt; func1Obs = funct1(); 
Observable&lt;String&gt; func2Obs = funct2(); 

func1Obs.subscribe(output -&gt; result.onNext(output));
func1Obs.onDoComplete(() -&gt; {
    func2Obs.subscribe(output -&gt; result.onNext(output);
}
return result;
</code></pre>
","1387310","","1387310","","2020-04-12 07:51:52","2020-04-12 10:27:20","RXJava Sequentially execute observable","<java><rx-java><rx-java3>","1","8","","","","CC BY-SA 4.0"
"61170006","2","","61164480","2020-04-12 10:27:20","","1","","<p>As Suggest Progman, the error was not with concatArray, this is the method to use. The problem was, that in my list of function, I was using this sort of code :</p>

<pre><code>public Observable&lt;String&gt; func1() {
    Subject&lt;String&gt; result = PublishSubject.create();
    String output = dosomething()
    result.onNext(output);
}
</code></pre>

<p>The problem here is that the function doSomething() is call immediately when you create the observable.</p>

<p>The solution is to use either <code>Observable.create()</code> if you need onNext, onComplete, etc... :    </p>

<pre><code>public Observable&lt;String&gt; func1() {
    // See how we wrap our instruction inside create method
    return Observable.create( result -&gt; {
        String output = dosomething()
        result.onNext(output);   
    });
}
</code></pre>

<p>or <code>Observable.defer()</code>, if you just need to wait for subscribe : </p>

<pre><code>public Observable&lt;String&gt; func1() {
    // See how we wrap our instruction inside create method
    return Observable.defer( () -&gt; dosomething());
}
</code></pre>

<p>After that you can call:</p>

<pre><code>return Observable.concatArray(
    func1(),
    func2(),
    func3(), 
    func4()
);
</code></pre>
","1387310","","","","","2020-04-12 10:27:20","","","","0","","","","CC BY-SA 4.0"
"61377933","1","","","2020-04-23 01:41:03","","0","136","<p>I am using RxJava for a server microservice project, where using Jetty as HTTP Servlet server.</p>

<p>I am handling requests either from client or main server with Observable for different flows.
When a request hitting the api below, I will return a Response after Observable finishes the job.</p>

<pre><code>@GET
@Path(""{uuid}"")
@Produces(MediaType.APPLICATION_JSON)
public Response doThingsForClient(@PathParam(""uuid"") String uuid) {
   Worker worker = new Worker(uuid);
   worker.run();
   return Response.ok(""Awesome"").build();
}

class Worker {
   String uuid = null;
   public Worker(String uuid) {
      this.uuid = uuid;
   }

   public void run() {
      Observable.concat(Observable1,Observable2,Observable3);
   }
}

</code></pre>

<p>I am wondering if I need to dispose these Observables or Flowables.
According to this: <a href=""https://stackoverflow.com/questions/45589930/does-rxjava2-auto-dispose-observable-when-they-call-completed-or-error"">Does RxJava2 auto dispose observable when they call completed or error?</a> 
and the RxJava3 sourcecode, i don't think Flowable at least is disposed automatically?</p>

<p>If I need to manually dispose the resources,
Is it better to create a <code>CompositeDisposable</code>, then add disposable to the <code>CompositeDisposable</code> at each Observer(<code>Observable1...Observable3</code>)'s <code>onSubscribe()</code> being called, call <code>compositeDisposable.dispose()</code> after the <code>concat</code> finishes.</p>

<p>Should I also monitor the Jetty <code>AbstractLifeCycle</code> to dispose these Observables(It sounds similar as Android)? I am not sure how other people are using RxJava at the server side, open to any suggestions to these questions and general Rx approach at server projects.</p>

<p>Thanks!</p>
","9036539","","9036539","","2020-04-23 07:09:18","2020-04-23 07:09:18","RxJava disposing Observable/Flowable in a microservice Server project","<server><rx-java><rx-java2><rx-java3>","0","2","","","","CC BY-SA 4.0"
"61490318","1","","","2020-04-28 21:33:06","","2","1477","<p>I am having trouble implementing RxJava3/Retrofit2, what I need to accomplish is:</p>

<p><strong>The general idea is to sync a cloud DB to an SqLite DB (Room) on a device.</strong>
The DB could get large, around 100,000 registers or more, so the sync process can take some time, my first attempt was to do it in one request and get all registers, then save them to SqLite (Room), but this in some cases, depending on the device generated some out of memory exceptions, so after some research I found out that RxJava is the answer, also implementing some API call pagination as well.</p>

<ol>
<li>First, I was trying to do a proof of concept, to fire a first Retrofit call and show the response on the activity, but I haven't been able to make it work, I am stuck!!</li>
</ol>

<p>This is the Error I get: <strong><code>java.lang.ClassCastException: io.reactivex.rxjava3.internal.observers.LambdaObserver cannot be cast to io.reactivex.rxjava3.core.Observable</code></strong></p>

<ol start=""2"">
<li>What I am trying to do is and I am asking for help here is; a first call where I can get to total number of register and define the number of pages, based on that, send multiple Retrofit request, every time I get the response (<strong>List &lt; Item ></strong>), save them to room.</li>
</ol>

<p>Following some code</p>

<p>gradle</p>

<pre><code>//Retrofit
implementation 'com.squareup.retrofit2:retrofit:2.8.1'
implementation 'com.squareup.retrofit2:converter-gson:2.8.1'
//Retrofit2 Adapter for RxJava 3
implementation ""com.github.akarnokd:rxjava3-retrofit-adapter:3.0.0""
//okhttp3 Logging Interceptor
implementation ""com.squareup.okhttp3:logging-interceptor:4.5.0""
//RxJava
implementation ""io.reactivex.rxjava3:rxjava:3.0.2""
implementation 'io.reactivex.rxjava3:rxandroid:3.0.
</code></pre>

<p>class Item</p>

<pre><code>public class Item {
    private String epc;
    private String barcode;
    private String name;
    private String description;
    private String brand;
    @SerializedName(""serial_number"")
    private String serialNumber;
    private double cost;
    @SerializedName(""fk_item_state"")
    private int status;
    @SerializedName(""fk_category"")
    private int category;
    @SerializedName(""fk_location"")
    private int location;
    private String parent;
    @SerializedName(""responsable"")
    private String responsible;
    @SerializedName(""purchase_date"")
    private String purchaseDate;
    @SerializedName(""creation_date"")
    private String creationDate;
    @SerializedName(""last_update"")
    private String lastUpdate;
    @SerializedName(""inventory_date"")
    private String inventoryDate;
    @SerializedName(""last_seen"")
    private String lastSeen;
...
</code></pre>

<p>class ItemSyncDetails </p>

<pre><code>public class ItemSyncDetails {
    @SerializedName(""CurrentPage"")
    int currentPage;
    @SerializedName(""PageCount"")
    int pageCount;
    @SerializedName(""PageSize"")
    int pageSize;
    @SerializedName(""RecordCount"")
    int recordCount;
    @SerializedName(""Results"")
    List&lt;Item&gt; mItemList;
...
</code></pre>

<p>interface FrekuencyApi</p>

<pre><code>import io.reactivex.rxjava3.core.Observable;
import retrofit2.http.GET;
import retrofit2.http.Query;

public interface FrekuencyApi {

    @GET(""item"")
    Observable&lt;ItemSyncDetails&gt; getItemsPageDetails(
            @Query(""pageSize"") Integer pageSize,
            @Query(""currentPage"") Integer currentPage,
            @Query(""sortBy"") Integer sortBy
    );
...
</code></pre>

<p>class MainActivity</p>

<pre><code>import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.disposables.CompositeDisposable;
import io.reactivex.rxjava3.schedulers.Schedulers;
import okhttp3.Interceptor;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.logging.HttpLoggingInterceptor;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;
...

public class MainActivity extends AppCompatActivity {

    private TextView tvResult;
    private Button send;
    private ProgressDialog mProgressDialog;
    private ItemSyncDetails mItemSyncDetails;
    private List&lt;Item&gt; mItemsList;
    private CompositeDisposable disposables = new CompositeDisposable();
    private FrekuencyApi frekuencyApi;
    private Retrofit retrofit;
    private int mNumPages;
    private CompositeDisposable compositeDisposable;
    private HttpLoggingInterceptor logging;

    private static final String TAG = ""MainActivity"";
    private Object handleResults;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        tvResult = findViewById(R.id.tv_result);
        send = findViewById(R.id.btnSend);
        mItemSyncDetails = new ItemSyncDetails();
        mProgressDialog = new ProgressDialog(this);

        mItemsList = new ArrayList&lt;Item&gt;();

        HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();
        interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
        OkHttpClient client = new OkHttpClient.Builder()
                .addInterceptor(interceptor)
                .addNetworkInterceptor(new Interceptor() {
                    @Override
                    public okhttp3.Response intercept(Chain chain) throws IOException {
                        Request request = chain.request().newBuilder()
                                .build();
                        return chain.proceed(request);
                    }
                }).build();

        retrofit = new Retrofit.Builder()
                .baseUrl(""http://192.168.1.10:82/api/v1.0/"")
                .client(client)
                .addCallAdapterFactory(RxJava3CallAdapterFactory.create())
                .addConverterFactory(GsonConverterFactory.create())
                .build();

        send.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //TODO: EVENTO AL HACER CLICK EN BOTON
                getRecordsCount();
            }
        });
    }

    private void getRecordsCount(){
        FrekuencyApi frekuencyApi = retrofit.create(FrekuencyApi.class);
        Observable&lt;ItemSyncDetails&gt; observable = (Observable&lt;ItemSyncDetails&gt;) frekuencyApi.getRecordsCount(1,1,1)
                .subscribeOn(Schedulers.io())
                .retry(3)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(this::HandleResults, this::handleError );
    }

    private void HandleResults(ItemSyncDetails itemSyncDetails) {
        this.mItemSyncDetails = itemSyncDetails;
        int pageSize = 100;
        int numPages = itemSyncDetails.getPageCount()/pageSize;
        if (itemSyncDetails.getRecordCount() &lt; pageSize || itemSyncDetails.getRecordCount()%pageSize != 0){
            numPages++;
        }
        this.mNumPages = numPages;
        tvResult.append(""Page size: "" + pageSize + ""\n"");
        tvResult.append(""Page number: "" + this.mNumPages + ""\n"");
        tvResult.append(""Total items: "" + itemSyncDetails.getRecordCount() + ""\n"");
    }

    private void handleError(Throwable throwable) {
        Log.e(""Observer"", """"+ throwable.toString());
        Toast.makeText(this, ""ERROR DE CONEXION"",
                Toast.LENGTH_LONG).show();
    }
...
</code></pre>

<p>Error Log</p>

<pre><code>D/AndroidRuntime: Shutting down VM
E/AndroidRuntime: FATAL EXCEPTION: main
    Process: com.frekuency.retrofitapptest, PID: 9120
    java.lang.ClassCastException: io.reactivex.rxjava3.internal.observers.LambdaObserver cannot be cast to io.reactivex.rxjava3.core.Observable
        at com.frekuency.retrofitapptest.views.MainActivity.getRecordsCount(MainActivity.java:110)
        at com.frekuency.retrofitapptest.views.MainActivity.access$000(MainActivity.java:39)
        at com.frekuency.retrofitapptest.views.MainActivity$2.onClick(MainActivity.java:98)
        at android.view.View.performClick(View.java:5273)
        at android.view.View$PerformClick.run(View.java:21315)
        at android.os.Handler.handleCallback(Handler.java:743)
        at android.os.Handler.dispatchMessage(Handler.java:95)
        at android.os.Looper.loop(Looper.java:150)
        at android.app.ActivityThread.main(ActivityThread.java:5659)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:822)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:712)
D/OkHttp: --&gt; GET http://192.168.1.10:82/api/v1.0/item?pageSize=1&amp;currentPage=1&amp;sortBy=1
    --&gt; END GET
I/Process: Sending signal. PID: 9120 SIG: 9
I/System: core_booster, getBoosterConfig = false
</code></pre>

<p>json for - <a href=""http://192.168.1.10:82/api/v1.0/item?pageSize=1&amp;currentPage=1&amp;sortBy=1"" rel=""nofollow noreferrer"">http://192.168.1.10:82/api/v1.0/item?pageSize=1&amp;currentPage=1&amp;sortBy=1</a></p>

<pre><code>{
  Results: [
  {
    epc: ""202020202020202030303031"",
    barcode: ""0001"",
    name: ""Televisor Samnsung"",
    description: ""0001"",
    creation_date: ""2020-02-26T10:55:06"",
    last_update: ""2020-02-26T10:55:06"",
    last_seen: ""2020-02-26T10:55:06"",
    brand: ""Samnsung"",
    serial_number: ""0001"",
    parent: """",
    fk_category: 1,
    responsable: """",
    purchase_date: ""2020-02-26T10:55:06"",
    cost: 0,
    fk_location: 1008,
    fk_item_state: 1,
    inventory_date: ""2020-02-26T10:55:06""
  }
 ],
 CurrentPage: 1,
 PageCount: 65565,
 PageSize: 1,
 RecordCount: 65565
}
</code></pre>

<h2>Thanks in advance, I really appreciate your help.</h2>

<p>I did some changes to class MainActivity</p>

<pre><code>public class MainActivity extends AppCompatActivity {
...
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        tvResult = findViewById(R.id.tv_result);
        send = findViewById(R.id.btnSend);
        mItemSyncDetails = new ItemSyncDetails();
        mProgressDialog = new ProgressDialog(this);

        mItemsList = new ArrayList&lt;Item&gt;();

        HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();
        interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
        OkHttpClient client = new OkHttpClient.Builder()
                .addInterceptor(interceptor)
                .addNetworkInterceptor(new Interceptor() {
                    @Override
                    public okhttp3.Response intercept(Chain chain) throws IOException {
                        Request request = chain.request().newBuilder()
                                .build();
                        return chain.proceed(request);
                    }
                }).build();

        retrofit = new Retrofit.Builder()
                .baseUrl(""http://192.168.1.10:82/api/v1.0/"")
                .client(client)
                .addCallAdapterFactory(RxJava3CallAdapterFactory.create())
                .addConverterFactory(GsonConverterFactory.create())
                .build();

        send.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
              showProgressDialog(""Items"");
              getRecordsCount();
            }
        });
    }

private void getRecordsCount(){
    retrofit.create(FrekuencyApi.class)
    .getRecordsCount(1,1,1)
            .subscribeOn(Schedulers.io())
            .retry(3)
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(this::HandleResults, this::handleError,this::getNumPagesHandlerComplete );
}

private void HandleResults(ItemSyncDetails itemSyncDetails) {
    this.mItemSyncDetails = itemSyncDetails;
    int pageSize = 100;
    int numPages = itemSyncDetails.getRecordCount()/pageSize;
    if (itemSyncDetails.getRecordCount() &lt; pageSize || itemSyncDetails.getRecordCount()%pageSize != 0){
        numPages++;
    }
    this.mNumPages = numPages;
    tvResult.append(""Tamaño de pagina: "" + pageSize + ""\n"");
    tvResult.append(""Numero de paginas: "" + this.mNumPages + ""\n"");
    tvResult.append(""Numero total de registros: "" + itemSyncDetails.getRecordCount() + ""\n"");
}

private void getNumPagesHandlerComplete() {
    getAllRecords(mNumPages);
}

private void getAllRecords(int numPages){
    frekuencyApi = retrofit.create(FrekuencyApi.class);
    //numPages: total of pages are the number of times to send the request to API
    Observable.range(1, numPages)
    .concatMap(i -&gt; frekuencyApi.getItemsPageDetails(100,i,1))
            .subscribeOn(Schedulers.newThread())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(this::getAllHandleResults, this::handleError,this::handleComplete);
}

private void getAllHandleResults(ItemSyncDetails itemSyncDetails) {
    //TODO: Should it be the right place to save data to DB?
    //Get the progress
    int tmp = getProgress(itemSyncDetails.getPageCount(),
            itemSyncDetails.getCurrentPage(),itemSyncDetails.getPageSize());
    //Update ProgressDialog Progress
    mProgressDialog.setProgress(tmp);
    tvResult.setText(""Progreso: ""+ tmp + ""%\n"");
    if (itemSyncDetails.getCurrentPage() == itemSyncDetails.getPageCount()){
        //Showing on screen when last request is done
        tvResult.append(""******************\n"");
        tvResult.append(itemSyncDetails.getItemList().toString());
        tvResult.append(""******************\n"");
    }
}

private void handleComplete() {
    //when the last request finished
    tvResult.append(""\nProceso de Sincronizacion terminado con exito!"");
    closeProgressDialog();
}

private void handleError(Throwable throwable) {
    Log.e(""Observer"", """"+ throwable.toString());
    tvResult.append(""\n******************\n"");
    tvResult.append(""ERROR DE CONEXION...\n"");
    tvResult.append(throwable.toString());
    Toast.makeText(this, ""ERROR DE CONEXION"",
            Toast.LENGTH_LONG).show();
    closeProgressDialog();
}
...
</code></pre>

<p>With the changes to the MainActivity class, basically there are two methods getRecordsCount() and getAllRecords(int numPages), each one fires an RX Java call process, the first one invokes one Retrofit call, and based on the answer of that first call, the second method is called and it will send (n) request to the API, where n is parameter numPages, I use a progressDialog that it is updated and when the hole process finished the progressDialog is close(). On the onComplete method of the first RX java call finished, it called the second RX Java method, at this point what I need is:</p>

<ol>
<li>How can I improve this to a more elegant code in one Rx java process, instead of two calls?</li>
<li>I am thinking to put a Room insert call to the DB for a List on the getAllHandleResults() method, it is the right place to do the insert to the DB?</li>
<li>Right now I am using concatMap on the getAllHandleResults() method, as far as I understand, this operator execute the Retrofit calls in a sequential order, I am doing it this way, because before trying RX Java + Retrofit, I was using Volley + Room + LiveData + ViewModel + AsyncTask, I did notice that the DB insertion was done one at a time, this operation is slower than the Retrofit Call, and one insertion operation needs to wait to the previous insertion to finished, so now I have the DB part using Room + LiveData + ViewModel + AsyncTask, so when the insert method is invoke from the onNext method (this happens on the Main-thread), the insertion will be execute on an AsyncTask in the background Thread, do you have any recommendation on this matter? can be this DB part done as well using RX Java? do you have some web-page where I can get information about it? Once again, thanks a lot for your help. </li>
</ol>
","2139348","","2139348","","2020-05-01 02:47:59","2020-05-01 02:47:59","Rxjava 3, retrofit2 and multiple calls problem","<android><retrofit2><android-room><rx-java3>","0","7","","","","CC BY-SA 4.0"
"61588457","1","","","2020-05-04 08:55:10","","1","231","<p>this is a method written in RxJava</p>

<pre><code>    public Observable&lt;String&gt; method() {
    return model.getOffers()
            .filter(new Func1&lt;Offers, Boolean&gt;() {
                @Override
                public Boolean call(Offers offers) {
                    if (offers == null)
                        return false;
                    return offers.hasSuperOffer();
                }
            })
            .flatMap(new Func1&lt;Offers, Observable&lt;Long&gt;&gt;() {
                @Override
                public Observable&lt;Long&gt; call(Offers offers) {
                    Long offerEndTime = offers.getRemainingTime();
                    if (offerEndTime == null) {
                        return Observable.empty();
                    }
                    AtomicLong remainingTimeSec;
                    Long currentTimeSec = System.currentTimeMillis() / 1000;
                    if (remainingTimeSec.get() == -1 &amp;&amp; (offerEndTime &gt; currentTimeSec)) {
                        remainingTimeSec.set(offerEndTime - currentTimeSec);
                    } else {
                        return Observable.empty();
                    }
                    return Observable.interval(1, TimeUnit.SECONDS)
                            .onBackpressureDrop()
                            .subscribeOn(Schedulers.io())
                            .observeOn(Schedulers.io())
                            .take(remainingTimeSec.intValue())
                            .doOnUnsubscribe(new Action0() {
                                @Override
                                public void call() {
                                }
                            })
                            .doOnCompleted(new Action0() {
                                @Override
                                public void call() {
                                }
                            })
                            .map(new Func1&lt;Long, Long&gt;() {
                                @Override
                                public Long call(Long elapsedTimeSec) {
                                    return remainingTimeSec.getAndDecrement();
                                }
                            });
                }
            })
            .map(new Func1&lt;Long, String&gt;() {
                @Override
                public String call(Long remainingTime) {
                    return DateUtils.getRemainingTimeStr(remainingTime);
                }
            });
}
</code></pre>

<p>I am trying to convert it to RxJava3 but some parameters have changed:
Func1 has been changed to Function
Action0 has been changed to Action</p>

<p>After I'm making the changes the following error appears at filter: </p>

<pre><code>filter (io.reactivex.rxjava3.functions@io.reactivex.rxjava3.annotations.NonNull Predicate &lt;? MyClass&gt; in Observable cannot be applied to (anonymous.io.reactivex.rxjava3.functions.Function &lt;MyClass.model.Offers.java.lang.Boolean&gt;)
</code></pre>

<p>Can anyone help me? 
Thank you!</p>
","13032345","","13032345","","2020-05-04 09:02:44","2020-05-04 09:02:44","RxJava method conversion to RxJava3","<java><android><rx-java><rx-java3>","0","2","","","","CC BY-SA 4.0"
"61652896","1","","","2020-05-07 08:11:18","","1","258","<p>I have an API call which verifies some status against an ""Id"". The API returns Single or error. I have a list of such Id's, Only one Id is valid to return success or none (all id's return error). What I need is, Iterate through each Id and skip the errors from API call, until either a success or end of the list. I am able to achieve this sequentially. However, I am trying to do the same, using ParallelFlowable.
It works fine when an Id returns success, But when there is no id which returns success (all ids fail), then it just skip all the errors from API, but does not notify the subscriber after all the ids are validated. I am not sure how to handle this.</p>

<pre><code>// API call
fun getStatus(Id: String): Single&lt;String&gt; {
  //... returns Single&lt;String&gt; or error
}

//Sequential flow, Working
fun getStatus(ids: List&lt;String&gt;): Single&lt;String&gt; {
  Observable.fromIterable(ids)
                .flatMapSingle { id -&gt;
                    getStatus(id)
                        .onErrorResumeWith { singleSource -&gt;
                            if (ids.last() == id)) { //If this is last item in list, return error
                                singleSource.onError(NoStatusFoundException())
                            } else {
                                // Skip errors until valid id is found or till the list reached end.
                                Flowable.empty&lt;String&gt;()
                            }
                        }
                }.firstOrError()
}

// Parallel Flow, How to identify the list is completed and return NoStatusFoundException in case of all id's fail?
fun getStatus(ids: List&lt;String&gt;): Single&lt;String&gt; { 
              Flowable.fromIterable(ids)
                .parallel()
                .runOn(io())
                .flatMap{ id -&gt; getStatus(id).toFlowable()
                          .onErrorResumeWith { Flowable.empty&lt;String&gt;() }
                        }
                .sequentialDelayError()
                .firstOrError()
                .onErrorResumeNext { Single.error(it) }
}

// Subscription
getStatus(listOf(""1"",""2"",""3"",""4"",""5"",))
 .subscribeOn(Schedulers.io())
 .observeOn(AndroidSchedulers.mainThread())
 .subscriber({ id-&gt;
       // success
       this is notified when an id is success
    },
    { // error handler - Need help here
       Never notified when all the id's fail?
    })

</code></pre>
","2571200","","2571200","","2020-05-12 05:56:13","2020-05-13 01:46:46","RxJava: Skip all the errors in fromIterable() and notify subscriber when all the items are emitted - Flowable.parallel execution","<android><rx-java2><flowable><rx-java3>","3","0","","","","CC BY-SA 4.0"
"61696684","1","","","2020-05-09 12:25:56","","1","163","<p>I try to consume the Streaming API from Twitter: statuses/filter as the following link(1)
(1)<a href=""https://stream.twitter.com/1.1/statuses/filter.json?track=twitter"" rel=""nofollow noreferrer"">https://stream.twitter.com/1.1/statuses/filter.json?track=twitter</a> </p>

<p>Docs: <a href=""https://developer.twitter.com/en/docs/tweets/filter-realtime/api-reference/post-statuses-filter"" rel=""nofollow noreferrer"">https://developer.twitter.com/en/docs/tweets/filter-realtime/api-reference/post-statuses-filter</a></p>

<p>However, after getting a correct token on <code>request_Token</code> (2) response, and make the request to statuses/filter, I do get a response 200 but still not hitting <code>onNext</code> or <code>onError</code> endlessly. </p>

<p>(2) <a href=""https://api.twitter.com/oauth/request_token"" rel=""nofollow noreferrer"">https://api.twitter.com/oauth/request_token</a> </p>

<p><code>2020-05-09 13:09:26.023 28542-28617/com.example.myapplication D/OkHttp: &lt;-- 200 https://stream.twitter.com/1.1/statuses/filter.json?track=foo&amp;follow=1234 (1002ms)</code></p>

<p>I am not sure if there is something missing from my code or is wrong.
Please could I have some feedback? Here is my code:</p>

<pre class=""lang-java prettyprint-override""><code>package com.example.myapplication

import android.os.Bundle
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
import hu.akarnokd.rxjava3.retrofit.RxJava3CallAdapterFactory
import io.reactivex.rxjava3.core.BackpressureStrategy
import io.reactivex.rxjava3.core.Flowable
import io.reactivex.rxjava3.core.Observable
import io.reactivex.rxjava3.disposables.CompositeDisposable
import io.reactivex.rxjava3.disposables.Disposable
import io.reactivex.rxjava3.schedulers.Schedulers
import okhttp3.Interceptor
import okhttp3.OkHttpClient
import okhttp3.ResponseBody
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.scalars.ScalarsConverterFactory
import retrofit2.http.*
import se.akerfeldt.okhttp.signpost.OkHttpOAuthConsumer
import se.akerfeldt.okhttp.signpost.SigningInterceptor
import java.util.concurrent.TimeUnit


class MainActivity : AppCompatActivity() {

    companion object {
        private const val REQUEST_TOKEN = ""https://api.twitter.com/oauth/request_token""
        private const val consumerKeyValue = ""{{consumerKeyValue}}""
        private const val consumerKeySecretValue = ""{{consumerKeySecretValue}}""
        private const val accessTokenValue = ""{{accessTokenValue}}""
        private const val accessTokenSecretValue = ""{{accessTokenSecretValue}}""
    }

    val disposable = CompositeDisposable()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }

    override fun onResume() {
        super.onResume()
        disposable.add(calls())
    }

    private fun calls(): Disposable {
        return retrofit()
            .requestToken(REQUEST_TOKEN)
            .subscribeOn(Schedulers.io())
            .observeOn(Schedulers.io())
            .toFlowable(BackpressureStrategy.BUFFER)
            .flatMap { getData(it.string().split(""&amp;"")) }
            .subscribe({
                print(""onNext: $it"")
            }, {
                print(""onError: ${it.localizedMessage}"")
            }, {
                print(""onComplete"")
            })
    }

    private fun getData(resArray: List&lt;String&gt;): Flowable&lt;ResponseBody&gt; {
        val oauthToken = resArray.first().split(""="")
        val oauthTokenSecret = resArray[1].split(""="")
        return retrofit().requestFiltered(HashMap&lt;String, String&gt;().apply {
            this[oauthToken.first()] = oauthToken.last()
            this[oauthTokenSecret.first()] = oauthTokenSecret.last()
        })
    }

    private fun retrofit(): TwitterService {
        return Retrofit.Builder()
            .baseUrl(""https://stream.twitter.com/1.1/"")
            .addConverterFactory(ScalarsConverterFactory.create())
            .addCallAdapterFactory(RxJava3CallAdapterFactory.create())
            .client(getClient())
            .build()
            .create(TwitterService::class.java)
    }

    private fun getClient(): OkHttpClient {
        val clientBuilder = OkHttpClient.Builder()
            .apply {
                connectTimeout(10, TimeUnit.SECONDS) // connect timeout
                writeTimeout(30, TimeUnit.SECONDS) // write timeout
                readTimeout(30, TimeUnit.SECONDS) // read timeout
            }
        if (BuildConfig.DEBUG) {
            val loggingInterceptor = HttpLoggingInterceptor()
            loggingInterceptor.level = HttpLoggingInterceptor.Level.BODY
            clientBuilder.addInterceptor(loggingInterceptor)
        }

        val consumer = OkHttpOAuthConsumer(consumerKeyValue, consumerKeySecretValue)
        consumer.setTokenWithSecret(accessTokenValue, accessTokenSecretValue)
        clientBuilder.addInterceptor(SigningInterceptor(consumer))

        clientBuilder
            .addNetworkInterceptor { chain -&gt;
                val requestBuilder = chain.request().newBuilder()
                requestBuilder.addHeader(""Content-Type"", ""application/json"")
                chain.proceed(requestBuilder.build())
            }
        clientBuilder.interceptors().add(object : Interceptor {
            override fun intercept(chain: Interceptor.Chain): okhttp3.Response {
                val request = chain.request()
                Log.e(""OkHttp3 ${request.method}"", request.body.toString())
                return chain.proceed(request)
            }

        })
        return clientBuilder.build()
    }

    interface TwitterService {

        @Headers(""Content-Type: text/html;charset=utf-8"")
        @GET
        fun requestToken(@Url url: String): Observable&lt;ResponseBody&gt;

        @Headers(""Cache-Control: max-age=640000"")
        @POST(""statuses/filter.json"")
        @Streaming
        fun requestFiltered(
            @HeaderMap headers: HashMap&lt;String, String&gt;,
            @Query(""track"") track: String = ""foo"",
            @Query(""follow"") follow: String = ""1234""
        ): Flowable&lt;ResponseBody&gt;

    }

}

// Dependencies:
    implementation 'com.squareup.retrofit2:retrofit:2.8.1'
    implementation 'com.squareup.retrofit2:converter-gson:2.8.1'
    implementation 'com.squareup.retrofit2:converter-scalars:2.8.1'
    implementation 'com.github.akarnokd:rxjava3-retrofit-adapter:3.0.0'
    implementation 'io.reactivex.rxjava3:rxandroid:3.0.0'
    implementation 'io.reactivex.rxjava3:rxjava:3.0.0'
    implementation 'com.squareup.okhttp3:okhttp:4.6.0'
    implementation 'com.squareup.okhttp3:logging-interceptor:4.6.0'
    implementation 'se.akerfeldt:okhttp-signpost:1.1.0'
    implementation 'oauth.signpost:signpost-core:1.2.1.2'
</code></pre>

<p>Thank you all in advance.</p>
","3058271","","3058271","","2020-05-09 13:01:40","2020-05-09 13:01:40","Android Twitter API statuses/filter with Retrofit + RxJava: never hits onNext or onError","<android><kotlin><twitter><retrofit2><rx-java3>","0","3","0","","","CC BY-SA 4.0"
"61704933","1","61764955","","2020-05-09 23:00:51","","3","1250","<p>I am trying to do the following; sync a cloud DB using Retrofit to a local SqLite DB (Room) on a device. The DB could get large, around 100,000 registers or more, so the sync process can take some time. So it send a first Retrofit request to get the number of register, so it can calculate the total number of pages, after that it will send multiple Retrofit Request, to get all the data from API, after each request, it saves the data to Room.</p>

<p>Right now, I am having trouble combining two RxJava calls or process, also on the second RxJava process, after a Retrofit call, there is a Room Insert of a List-of-Objets, but after the hole process ends, I notice that not 100% of all the records are inserted, every time that I run the process, the number of records inserted change, it is around 80% - 98%, but never 100%, even though all the Retrofit calls are sent.</p>

<p>Please help me with:</p>

<ol>
<li>How to make all the process in one RxJava call, not 2 like I have it
now?</li>
<li>How to insert 100% of records to Room?</li>
</ol>

<p>Following the code:</p>

<p>Gradle</p>

<pre><code>def room_version = ""2.2.5""
//RxJava 2
implementation ""io.reactivex.rxjava2:rxjava:2.2.19""
implementation 'io.reactivex.rxjava2:rxandroid:2.1.1'
//Retrofit
implementation 'com.squareup.retrofit2:retrofit:2.8.1'
implementation 'com.squareup.retrofit2:converter-gson:2.8.1'
//Retrofit2 Adapter for RxJava 2
implementation ""com.squareup.retrofit2:adapter-rxjava2:2.8.1""
//okhttp3 Logging Interceptor
implementation ""com.squareup.okhttp3:logging-interceptor:4.5.0""
//Room
implementation ""androidx.room:room-runtime:$room_version""
annotationProcessor ""androidx.room:room-compiler:$room_version""
//RxJava support for Room
implementation ""androidx.room:room-rxjava2:$room_version"" 
</code></pre>

<p>ItemSyncDetails</p>

<pre><code>...
public class ItemSyncDetails {
    @SerializedName(""CurrentPage"")
    int currentPage;
    @SerializedName(""PageCount"")
    int pageCount;
    @SerializedName(""PageSize"")
    int pageSize;
    @SerializedName(""RecordCount"")
    int recordCount;
    @SerializedName(""Results"")
    List&lt;Item&gt; mItemList;
...
}
</code></pre>

<p>ItemDao</p>

<blockquote>
  <p>Note: I haven't used Observer/Flowable/Maybe/Single, because I having
  been able to make it work with RxJava</p>
</blockquote>

<pre><code>import io.reactivex.Flowable;

@Dao
public interface ItemDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    long insert(Item item);

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    List&lt;Long&gt; insertAll(List&lt;Item&gt; items);
...
</code></pre>

<p>DataApi</p>

<pre><code>import io.reactivex.rxjava3.core.Observable;
...

public interface DataApi {

    @GET(""item"")
    Observable&lt;ItemSyncDetails&gt; getItemsByPage(
            @Query(""pageSize"") Integer pageSize,
            @Query(""currentPage"") Integer currentPage,
            @Query(""sortBy"") Integer sortBy
    );
</code></pre>

<p>ItemRepository </p>

<pre><code>import io.reactivex.Observable;
    ...

    public class ItemRepository {
    ...

        public ItemRepository(Application application) {
            mDataApi = RetrofitClient.getRetrofitInstance(""http://192.168.1.100"").create(DataApi.class);
            RfidDatabase db = RfidDatabase.getAppDatabase(application);
            itemDao = db.itemDao();
            itemList = itemDao.getAllItems();
            inserts = 0;
        }

        public List&lt;Long&gt; insertAllLocal (List&lt;Item&gt; itemList) {
            List&lt;Long&gt; items = itemDao.insertAll(itemList);
            inserts += items.size();
            Log.i(TAG, ""************insertAllLocal - ItemRepository: "" + inserts + ""*************"");
            Log.i(TAG, ""************insertAllLocal - ItemRepository: "" + items);
            return items;
        }

        public Observable&lt;ItemSyncDetails&gt; getRecordsCount(){
            return mDataApi.getItemsByPage(1,1,1);
        }

        public Observable&lt;ItemSyncDetails&gt; getItemsPerPage(int pageSize,int currentPage){
            return mDataApi.getItemsByPage(pageSize,currentPage,1);
        }
    ...

SyncConfigFragment 

    import io.reactivex.Observable;
    import io.reactivex.android.schedulers.AndroidSchedulers;
    import io.reactivex.disposables.CompositeDisposable;
    import io.reactivex.functions.Function;
    import io.reactivex.schedulers.Schedule
    ...

    public class SyncConfigFragment extends Fragment {


        private ItemViewModel itemViewModel;
        private ImageView imageSyncItems;
        private ProgressDialog progressDialog;
        private TextView tvSyncDescriptionItems;
        private DataApi service;
        private ItemSyncDetails mItemSyncDetails;
        private List&lt;Item&gt; mItemlist;
        private CompositeDisposable mCompositeDisposable;
        private int mNumPages;
        private int syncProgress;
        ...

        @Override
        public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
            View view =  inflater.inflate(R.layout.fragment_config_sync,container, false);
            progressDialog = new ProgressDialog(getActivity());
            sharedPref = getActivity().getSharedPreferences(
                    getString(R.string.sharepref_filename), Context.MODE_PRIVATE);
            mItemlist = new ArrayList&lt;Item&gt;();
            mCompositeDisposable = new CompositeDisposable();
            itemViewModel = ViewModelProviders.of(this).get(ItemViewModel.class);
            tvSyncDescriptionItems = view.findViewById(R.id.tvDescriptionSyncItems);
            if(sharedPref.contains(""last_sync_item"")) {
                tvSyncDescriptionItems.setText(""Última actualización "" + sharedPref.getString(""last_sync_item"",""""));
            } else{
                tvSyncDescriptionItems.setText(""No se ha Sincronizado"");
            }
            imageSyncItems = view.findViewById(R.id.imageViewSyncItems);
            imageSyncItems.setOnClickListener(clickListener);
            return view;
        }

        private View.OnClickListener clickListener = new View.OnClickListener() {
            public void onClick(View v) {
                    if (v.equals(imageSyncItems)) {
                //If I uncomment the next line it does not work
                        //mCompositeDisposable.add(
                        mNumPages = 0;
                        syncProgress = 0;
                        showProgressDialog(""Items"");
                        getRecordsCount();
                       //); Closing round bracket for mCompositeDisposable
                }
            }
        };//End View.OnClickListener 

        private void getRecordsCount(){
            itemViewModel.getRecordsCount()
                    .subscribeOn(Schedulers.io())
                    .retry(3)
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe(this::HandleResults, this::handleError,this::getNumPagesHandlerComplete );
        }

        private void HandleResults(ItemSyncDetails itemSyncDetails) {
            this.mItemSyncDetails = itemSyncDetails;
            int pageSize = 100;
            int numPages = itemSyncDetails.getRecordCount()/pageSize;
            if (itemSyncDetails.getRecordCount() &lt; pageSize || itemSyncDetails.getRecordCount()%pageSize != 0){
                numPages++;
            }
            this.mNumPages = numPages;
        }

        private void getNumPagesHandlerComplete() {
            getAllRecords(mNumPages);
        }

        private void handleError(Throwable throwable) {
            tvSyncDescriptionItems.setText(""**********Error de conexión..."");
            closeProgressDialog();
        }

        private void getAllRecords(int numPages){
            //numPages: total of pages are the number of times to send the request to API
            Observable.range(1, numPages)
                    .flatMap(i -&gt; itemViewModel.getItemsPerPage(100,i))
                    .map(new Function&lt;ItemSyncDetails, Integer&gt;() {
                        @Override
                        public Integer apply(ItemSyncDetails itemSyncDetails) throws Throwable {
                            return itemViewModel.insertAllLocal(itemSyncDetails.getItemList()).size();
                        }
                    })
                    .subscribeOn(Schedulers.newThread())
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe(this::getAllHandleResults, this::handleError,this::handleComplete);
        }

        private void getAllHandleResults(Integer i) {
            progressDialog.setProgress(getProgress(i));
        }

        private void handleComplete() {
            //last request finished
            closeProgressDialog();
        }

        private int getProgress(int newItems){
            syncProgress += newItems;
            int progress = 0;
            if (syncProgress == mItemSyncDetails.getRecordCount()){
                progress = 100;
            } else {
                progress = (100 * syncProgress)/mItemSyncDetails.getRecordCount();
            }
            return progress;
        }
    ...
    }
</code></pre>

<p><a href=""http://192.168.1.10:82/api/v1.0/item?pageSize=1&amp;currentPage=1&amp;sortBy=1"" rel=""nofollow noreferrer"">http://192.168.1.10:82/api/v1.0/item?pageSize=1&amp;currentPage=1&amp;sortBy=1</a></p>

<blockquote>
  <p>Note: The page size could change, I am using a fixed size of a 100
  items per page.</p>
</blockquote>

<pre><code>{
  Results: [
  {
    epc: ""202020202020202030303031"",
    barcode: ""0001"",
    name: ""Televisor Samnsung"",
    description: ""0001"",
    creation_date: ""2020-02-26T10:55:06"",
    last_update: ""2020-02-26T10:55:06"",
    last_seen: ""2020-02-26T10:55:06"",
    brand: ""Samnsung"",
    serial_number: ""0001"",
    parent: """",
    fk_category: 1,
    responsable: """",
    purchase_date: ""2020-02-26T10:55:06"",
    cost: 0,
    fk_location: 1008,
    fk_item_state: 1,
    inventory_date: ""2020-02-26T10:55:06""
  }
 ],
 CurrentPage: 1,
 PageCount: 65565,
 PageSize: 1,
 RecordCount: 65565
}
</code></pre>
","2139348","","2139348","","2020-05-13 14:25:35","2020-05-13 14:25:35","Rxjava 3 + Retrofit2 - multiple inserts to DB problem","<android><retrofit2><android-room><rx-java3>","1","2","","","","CC BY-SA 4.0"
"61764955","2","","61704933","2020-05-13 01:42:25","","1","","<p>You posted a json response here before the edit.</p>

<pre><code>    CurrentPage: 1,
    PageCount: 65566,
    PageSize: 1,
    RecordCount: 65566
</code></pre>

<p>If I understand correctly, then you have 65k items and 1 item in each page. Meaning 65k pages which means 65k network calls. That's a lot. You could improve this design first.</p>

<ol>
<li>Divide the entire records into a few pages (maybe even 10 or 20). 1 page will still have thousands of items if the entire records has 10s of thousands of items.</li>
<li>Then use gzip compression to compress the json responses for each page and serve that from the server. Or don't divide the records into pages and pass them all in one response compressed with gzip (if it's not that big).</li>
<li>Unzip the response on android, parse it and then do whatever you want.</li>
</ol>

<p>This way you reduce a lot of network calls and possibly reduce the wait time for sync.</p>

<p>As to your actual rx question:</p>

<pre class=""lang-kotlin prettyprint-override""><code>val pageSize = 100
viewModel.getRecordsCount()
    .map {
        // logic from `HandleResults` function
        // do some calculation
        var numPages: Int = it.records / pageSize
        if (it.records &lt; pageSize || it.records % pageSize != 0) {
            numPages++
        }
        return@map numPages
    }
    .flatMap { pages -&gt; Observable.range(1, pages) }
    .flatMap { page -&gt; viewModel.getItemsPerPage(pageSize, page) }
    .flatMap { itemSyncDetails -&gt;
        val items = viewModel.insertAllLocal(itemSyncDetails.getItemList())
        return@flatMap Observable.just(items.size)
    }
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(....)
</code></pre>

<blockquote>
  <p>I notice that not 100% of all the records are inserted, every time that I run the process, the number of records inserted change, it is around 80% - 98%, but never 100%, even though all the Retrofit calls are sent.</p>
</blockquote>

<p>Log the error in <code>handleError</code> function and see what the actual problem is.</p>
","2235972","","","","","2020-05-13 01:42:25","","","","5","","","","CC BY-SA 4.0"
"61801954","1","","","2020-05-14 16:03:09","","2","69","<p>RxAndroidBle is a great piece of software and has reduced development time for Ble projects and has increased stability and readability significantly.</p>

<p>I just want to ask, what the status is of the rxjava3 branch of RxAndroidBle?
It says it is a test branch and stale at this moment.
So is it not recommended to take the rxjava3 branch for production applications?</p>

<p>I wonder if there are future plans to concentrate on rxjava3, since on the RxJava page it says:</p>

<p><em>The 2.x version is in maintenance mode and will be supported only through bugfixes until February 28, 2021.</em></p>

<p>Greetings from t4rj4n</p>
","13542758","","","","","2020-05-14 16:03:09","What is the status of RxAndroidBle and RxJava3?","<bluetooth-lowenergy><rx-android><rxandroidble><rx-java3>","0","1","","","","CC BY-SA 4.0"
"61819722","1","","","2020-05-15 12:53:40","","1","376","<p>I have three Integer observers like below :</p>

<p>First Observer :</p>

<pre><code> private Observer&lt;Integer&gt; getFirstObserver() {
        return new Observer&lt;Integer&gt;() {

            @Override
            public void onSubscribe(Disposable d) {
            }

            @Override
            public void onNext(Integer integer) {
                Log.d(LOG_TAG, ""onNext First "" + integer);

            }

            @Override
            public void onError(Throwable e) {
            }

            @Override
            public void onComplete() {

            }
        };
    }
</code></pre>

<p>Second Observer :</p>

<pre><code>private Observer&lt;Integer&gt; getSecondObserver() {
        return new Observer&lt;Integer&gt;() {

            @Override
            public void onSubscribe(Disposable d) {
            }

            @Override
            public void onNext(Integer integer) {
                Log.d(LOG_TAG, ""onNext Second "" + integer);

            }

            @Override
            public void onError(Throwable e) {
            }

            @Override
            public void onComplete() {
            }
        };
    }
</code></pre>

<p>ThirdObserver :</p>

<pre><code>    private Observer&lt;Integer&gt; getThirdObserver() {
    return new Observer&lt;Integer&gt;() {

        @Override
        public void onSubscribe(Disposable d) {
        }

        @Override
        public void onNext(Integer integer) {
            Log.d(LOG_TAG, ""onNext Third "" + integer);

        }

        @Override
        public void onError(Throwable e) {
        }

        @Override
        public void onComplete() {
        }
    };
}
</code></pre>

<p>Now if I fun the following code :</p>

<pre><code>    void asyncSubjectDemo1() {
        Observable&lt;Integer&gt; observable = Observable.just(1, 2, 3, 4);
        PublishSubject&lt;Integer&gt; asyncSubject = PublishSubject.create();
        observable.subscribe(asyncSubject);
        asyncSubject.subscribe(getFirstObserver());
        asyncSubject.subscribe(getSecondObserver());
        asyncSubject.subscribe(getThirdObserver());

    }
</code></pre>

<p>Nothing is printed in the Logcat as expected from the documentation</p>

<blockquote>
  <p>PublishSubject emits to an observer only those items that are emitted by the source Observable(s) subsequent to the time of the subscription.</p>
</blockquote>

<p>But if I add observeOn while creating the Observable like below and run it</p>

<pre><code>void asyncSubjectDemo1() {
            Observable&lt;Integer&gt; observable = Observable.just(1, 2, 3, 4).observeOn(AndroidSchedulers.mainThread());
            PublishSubject&lt;Integer&gt; asyncSubject = PublishSubject.create();
            observable.subscribe(asyncSubject);
            asyncSubject.subscribe(getFirstObserver());
            asyncSubject.subscribe(getSecondObserver());
            asyncSubject.subscribe(getThirdObserver());

        }
</code></pre>

<p>The following is the output</p>

<pre><code>D/MY_LOG: onNext First 1
D/MY_LOG: onNext Second 1
D/MY_LOG: onNext Third 1
D/MY_LOG: onNext First 2
D/MY_LOG: onNext Second 2
D/MY_LOG: onNext Third 2
</code></pre>

<p>Why is there any ambiguity in such a case ?</p>
","9494420","","","","","2020-05-15 21:43:34","RxJava PublishSubject with and without ObserveOn","<rx-java><reactivex><rx-java3>","1","1","","","","CC BY-SA 4.0"
"61827190","1","61827243","","2020-05-15 19:47:36","","1","342","<p>I have a fragment In which I have implemented some code :</p>

<pre><code>    public void onViewCreated(@androidx.annotation.NonNull View v, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(v, savedInstanceState);
        button = v.findViewById(R.id.button2);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Observable&lt;String&gt; bookObservable = getBookObservalbel();
                Observer&lt;String&gt; bookObserver = getBookObserver();
                bookObservable.observeOn(Schedulers.io())
                        .subscribeOn(AndroidSchedulers.mainThread())
                        .subscribe(bookObserver);
            }
        });
    } 

 private Observer&lt;String&gt; getBookObserver() {
        return new Observer&lt;String&gt;() {
            @Override
            public void onSubscribe(@NonNull Disposable d) {

            }

            @Override
            public void onNext(@NonNull String s) {
                Log.d(TAG, ""onNext: "" + s);
            }

            @Override
            public void onError(@NonNull Throwable e) {

            }

            @Override
            public void onComplete() {

            }
        };
    }


    private Observable&lt;String&gt; getBookObservalbel() {
        return Observable.just(""1"", ""2"", ""3"");

    }
</code></pre>

<p>But while running it  I am getting this error:-</p>

<pre><code>    java.lang.BootstrapMethodError: Exception from call site #1 bootstrap method
        at io.reactivex.rxjava3.android.schedulers.AndroidSchedulers.&lt;clinit&gt;(AndroidSchedulers.java:33)
        at io.reactivex.rxjava3.android.schedulers.AndroidSchedulers.mainThread(AndroidSchedulers.java:44)
        at com.example.rxjavatut.second$1.onClick(second.java:58)
        at android.view.View.performClick(View.java:6608)
        at android.view.View.performClickInternal(View.java:6585)
        at android.view.View.access$3100(View.java:785)
        at android.view.View$PerformClick.run(View.java:25921)
        at android.os.Handler.handleCallback(Handler.java:873)
        at android.os.Handler.dispatchMessage(Handler.java:99)
        at android.os.Looper.loop(Looper.java:201)
        at android.app.ActivityThread.main(ActivityThread.java:6810)
        at java.lang.reflect.Method.invoke(Native Method)
     Caused by: java.lang.ClassCastException: Bootstrap method returned null
</code></pre>

<p>I am using these dependencies in my grade for rxjava and rxandroid</p>

<pre><code>  implementation 'io.reactivex.rxjava3:rxandroid:3.0.0'

  implementation 'io.reactivex.rxjava3:rxjava:3.0.3'
</code></pre>

<p>I tried to run this code in the older version of rxjava and rxandroid in my mainActivity there it runs perfectly.</p>

<p>I am unable to figure out where the issue is, could you please share some info on what I might be doing wrong.</p>
","10224590","","115145","","2020-05-15 19:49:53","2020-05-15 19:50:50","Error in executing AndroidSchedulers.mainThread()","<android><rx-java2><rx-android><rx-java3>","1","0","1","","","CC BY-SA 4.0"
"61827243","2","","61827190","2020-05-15 19:50:50","","3","","<p>RxJava3 requires Java 8. Update your Java version:</p>

<pre><code>android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}
</code></pre>
","5288316","","","","","2020-05-15 19:50:50","","","","0","","","","CC BY-SA 4.0"
"61881002","1","","","2020-05-19 00:04:50","","2","63","<p>Does anyone know how to execute the following:
The content of an element must be parsed and the sub-elements must be grouped by making a parallel query
You should advance to the next item in the list only if the group query was previously completed</p>

<pre><code>Element element = new Element(); 
element1.get(0) = urlA
element1.get(1) = urlB
element1.get(2) = urlC

List&lt;Element&gt; list = new ArrayList();
list.get(0); //consult in parallel  [urlA, urlB, urlC]

//You must wait for the previous query to finish
list.get(1); //consult in parallel  [urlX, urlY, urlZ] 
</code></pre>

<p>I currently use rxjava-3.0.3</p>
","10071373","","10071373","","2020-05-19 03:47:50","2020-05-22 12:01:06","Group parallel calls in RX Java","<java><rx-java><rx-java3>","1","0","","","","CC BY-SA 4.0"
"61931324","1","","","2020-05-21 09:25:32","","0","46","<p>I have multiple <code>Observable&lt;Boolean&gt;</code> delivering data from ""alert sensors"". They are delivering only value changes. How to wait until all of them switch to <code>false</code> which would indicate there is no alert anymore?</p>
","412409","","","","","2020-05-22 10:01:17","RxJava, wait for multiple Observables to provide desired result in the same time","<java><rx-java><reactive-programming><rx-java2><rx-java3>","2","0","","","","CC BY-SA 4.0"
"61937367","1","61938069","","2020-05-21 14:57:01","","1","56","<p>In Ammonite, I execute the following codes...
Trying to do an orderedMerge of two Flowables,</p>

<pre><code>import $ivy.{
    `io.circe::circe-generic:0.13.0`                    ,
    `io.circe::circe-parser:0.13.0`                     ,
    `io.circe::circe-optics:0.13.0`                     ,
    `com.softwaremill.sttp::core:1.7.2`                 ,
    `org.scalaz::scalaz-core:7.2.27`                    ,
    `com.lihaoyi::requests:0.2.0`                       ,
    `io.get-coursier::coursier-core:2.0.0-RC4`          ,
    `io.lemonlabs::scala-uri:1.4.10`                    ,
    `net.liftweb::lift-json:3.4.0`                      ,
    `io.reactivex.rxjava3:rxjava:3.0.3`                 ,
    `com.github.akarnokd:rxjava3-extensions:3.0.0-RC7`
}

import io.lemonlabs.uri._
implicit val formats = net.liftweb.json.DefaultFormats
import net.liftweb.json.JsonAST._
import net.liftweb.json.Extraction._
import net.liftweb.json._
import io.reactivex.rxjava3.core._
import io.reactivex.rxjava3.functions._
import net.liftweb.json.JsonDSL._
import collection.JavaConverters._
import io.reactivex.rxjava3.subjects._
import scala.collection.mutable.HashMap
import io.reactivex.rxjava3.internal.functions.Functions
Flowables.orderedMerge(
    List(
        Flowable.just(3, 5),
        Flowable.just(2, 4, 6)
    ).toIterable.asJava, 
    Functions.naturalComparator[Int]()
    ).subscribe(i=&gt;println(i))
</code></pre>

<p>But after printing 2, it throw exception:</p>

<pre><code>java.lang.NoSuchMethodError: io.reactivex.rxjava3.internal.subscribers.InnerQueuedSubscriber.requestOne()V
  hu.akarnokd.rxjava3.operators.BasicMergeSubscription.drain(BasicMergeSubscription.java:268)
  hu.akarnokd.rxjava3.operators.BasicMergeSubscription.innerComplete(BasicMergeSubscription.java:161)
  io.reactivex.rxjava3.internal.subscribers.InnerQueuedSubscriber.onSubscribe(InnerQueuedSubscriber.java:69)
  io.reactivex.rxjava3.internal.operators.flowable.FlowableFromArray.subscribeActual(FlowableFromArray.java:39)
  io.reactivex.rxjava3.core.Flowable.subscribe(Flowable.java:15750)
  io.reactivex.rxjava3.core.Flowable.subscribe(Flowable.java:15696)
  hu.akarnokd.rxjava3.operators.BasicMergeSubscription.subscribe(BasicMergeSubscription.java:79)
  hu.akarnokd.rxjava3.operators.FlowableOrderedMerge.subscribeActual(FlowableOrderedMerge.java:94)
  io.reactivex.rxjava3.core.Flowable.subscribe(Flowable.java:15750)
  io.reactivex.rxjava3.core.Flowable.subscribe(Flowable.java:15686)
  io.reactivex.rxjava3.core.Flowable.subscribe(Flowable.java:15618)
  ammonite.$sess.cmd63$.&lt;clinit&gt;(cmd63.sc:1)
</code></pre>

<p>Could anyone help me with it? I have no any idea about it...</p>

<p>The weird part is, it could print the first ordered item, but not the following ones...</p>
","2057092","","","","","2020-05-21 16:07:40","(Scala + RxJava3) Flowables.orderedMerge NoSuchMethodError","<scala><rx-java><rx-java3>","2","0","","","","CC BY-SA 4.0"
"61938069","2","","61937367","2020-05-21 15:31:06","","2","","<p><code>rxjava3-extensions:3.0.0-RC7</code> is not compatible with <code>rxjava:3.0.3</code>. Release candidates don't provide strict compatibility guarantees.</p>

<p>Upgrade to <code>rxjava3-extensions:3.0.0</code> or up.</p>

<p>For future reference <code>NoSuchMethodError</code> almost always indicates incompatible libraries. The unfound method in the exception message and the method at the top of the stacktrace are good indicators of which libraries are involved.</p>
","1374461","","1374461","","2020-05-21 15:38:31","2020-05-21 15:38:31","","","","0","","","","CC BY-SA 4.0"
"62258222","1","62260657","","2020-06-08 08:44:33","","0","941","<p>I can't convert this method to RxJava3 despite having upgraded the dependencies</p>

<pre><code>fun setSearchField(searchField: EditText) {
        searchDisposable = searchField.afterTextChangeEvents()
            .skipInitialValue()
            .debounce(400, TimeUnit.MILLISECONDS)
            .map { it.editable()?.toString() ?: """" }
            .distinctUntilChanged()
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(::onSearchQueryUpdated)
    }
</code></pre>

<p>Type mismatch.
Required:
io.reactivex.rxjava3.disposables.Disposable?
Found:
io.reactivex.disposables.Disposable!</p>

<pre><code>    def retrofit_version = '2.9.0'
    implementation ""io.reactivex.rxjava3:rxjava:3.0.4""
    implementation ""io.reactivex.rxjava3:rxkotlin:3.0.0""
    implementation ""io.reactivex.rxjava3:rxandroid:3.0.0""
    implementation ""com.jakewharton.rxbinding3:rxbinding:3.1.0""
    implementation ""com.squareup.retrofit2:retrofit:$retrofit_version""
    implementation ""com.squareup.retrofit2:converter-gson:$retrofit_version""
    implementation ""com.github.akarnokd:rxjava3-retrofit-adapter:3.0.0""
    implementation ""com.squareup.okhttp3:logging-interceptor:4.7.2""
</code></pre>

<p>How should I accurately clean  the project from RxJava2?</p>

<p>I tried Invalidate caches/Restart: nothing happened.</p>

<p><a href=""https://i.stack.imgur.com/Vy89v.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Vy89v.png"" alt=""enter image description here""></a></p>
","13072160","","13072160","","2020-06-08 09:25:33","2020-06-08 11:07:30","Can't migrate accurately from RxJava2 to RxJava3","<android><rx-java2><rx-kotlin><rx-binding><rx-java3>","1","2","","","","CC BY-SA 4.0"
"62260657","2","","62258222","2020-06-08 11:07:30","","3","","<p>Dependencies: ./gradlew :dependencies</p>

<pre><code>implementationDependenciesMetadata
+--- io.reactivex.rxjava3:rxjava:3.0.4
|    \--- org.reactivestreams:reactive-streams:1.0.3
+--- io.reactivex.rxjava3:rxkotlin:3.0.0
|    \--- io.reactivex.rxjava3:rxjava:3.0.0 -&gt; 3.0.4 (*)
+--- io.reactivex.rxjava3:rxandroid:3.0.0
|    \--- io.reactivex.rxjava3:rxjava:3.0.0 -&gt; 3.0.4 (*)
+--- com.jakewharton.rxbinding3:rxbinding:3.1.0
|    +--- androidx.annotation:annotation:1.0.0 FAILED
|    +--- org.jetbrains.kotlin:kotlin-stdlib:1.3.41 -&gt; 1.3.71
|    |    +--- org.jetbrains.kotlin:kotlin-stdlib-common:1.3.71
|    |    \--- org.jetbrains:annotations:13.0
|    +--- io.reactivex.rxjava2:rxjava:2.2.10
|    |    \--- org.reactivestreams:reactive-streams:1.0.2 -&gt; 1.0.3
|    \--- io.reactivex.rxjava2:rxandroid:2.1.1
|         \--- io.reactivex.rxjava2:rxjava:2.2.6 -&gt; 2.2.10 (*)
</code></pre>

<p>You see, that rxbinding3 has a transitive dependency to </p>

<pre><code>|    +--- io.reactivex.rxjava2:rxjava:2.2.10
</code></pre>

<p>Which overwrites RxJava3</p>

<h1>Solution:</h1>

<pre><code>implementation 'com.jakewharton.rxbinding4:rxbinding:4.0.0'
</code></pre>
","7057156","","","","","2020-06-08 11:07:30","","","","0","","","","CC BY-SA 4.0"
"62371640","1","","","2020-06-14 11:05:08","","6","3373","<p>I am using RxJava3 with Room in my project but I am getting the following error</p>

<p>error: Not sure how to convert a Cursor to this method's return type (io.reactivex.rxjava3.core.Flowable>)</p>

<p>Below is DAO interface method on which I am getting the error</p>

<pre><code>@Query(""SELECT * FROM wishlist_table"")
Flowable&lt;List&lt;WishListMovie&gt;&gt; getWishList();
</code></pre>

<p>I think maybe its because I am using the dependency below in my grade file:</p>

<pre><code>implementation ""androidx.room:room-rxjava2:$room_version""
</code></pre>

<p>I tried to find the above dependency for RxJava 3 but I was unable to find it.</p>

<p>I want to know how can I use RxJava 3 with Room or should I use RxJava 2 instead in my project.</p>
","11227994","","","","","2020-09-13 15:36:48","RxJava 3 support for Room","<android><rx-java><android-room><rx-java3>","4","0","","","","CC BY-SA 4.0"
"62559431","1","62561339","","2020-06-24 16:08:12","","1","355","<p>Most of the <code>Flowable.subscribe()</code> overloads return a <code>Disposable</code> which enable a flow to be cleaned up. I'm in the habit of doing:</p>
<pre class=""lang-java prettyprint-override""><code>Disposable d = Flowable.just()
    .map(...)
    .subscribe(
        n -&gt; ...
        t -&gt; ...
        () -&gt; ...
    );

// someone clicks &quot;cancel&quot; in another thread
d.dispose();
</code></pre>
<p>However, when using <code>.subscribe(Subscriber)</code> the <code>Disposable</code> is not returned. I'd like to use <code>.subscribe(Subscriber)</code> so I can pass in a <code>TestSubscriber</code> to verify behaviour. So how would I dispose the flow in this case?</p>
<p>I searched the Javadoc for appropriate <code>Subscriber</code>s. There's <a href=""http://reactivex.io/RxJava/3.x/javadoc/index.html?io/reactivex/rxjava3/subscribers/DisposableSubscriber.html"" rel=""nofollow noreferrer""><code>DisposableSubscriber</code></a> which looks like it would work, but two problems:</p>
<ol>
<li>The class description reads as follows, which suggests <code>cancel()</code> cannot be used from outside a flow:</li>
</ol>
<blockquote>
<p>Use the protected request(long) to request more items and <strong>cancel() to cancel the sequence from within an onNext implementation</strong>.</p>
</blockquote>
<ol start=""2"">
<li>TestSubscriber does not extend DisposableSubscriber.</li>
</ol>
","28190","","286934","","2020-06-24 16:20:11","2020-06-24 19:59:46","Why doesn't Flowable.subscribe(Subscriber) return a Disposable?","<java><rx-java><reactive-programming><rx-java3>","1","0","","","","CC BY-SA 4.0"
"62561339","2","","62559431","2020-06-24 18:02:14","","1","","<p>You can use <a href=""http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Flowable.html#subscribeWith-E-"" rel=""nofollow noreferrer""><code>Flowable.subscribeWith(Subscriber)</code></a> instead of <code>subscribe</code>, so that your <code>Subscriber</code> is returned, instead of <code>void</code>.</p>
<p>In RxJava 3.x <code>TestSubscriber</code> no longer implements <code>Disposable</code>. It does implement the <a href=""http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/subscribers/TestSubscriber.html#dispose--"" rel=""nofollow noreferrer""><code>dispose</code></a> and <a href=""http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/subscribers/TestSubscriber.html#isDisposed--"" rel=""nofollow noreferrer""><code>isDisposed</code></a> methods, as defined by <code>BaseTestConsumer</code>, which it extends. However, both of those methods have been made <code>protected</code>, so you can't actually use them directly. Luckily, there is <a href=""http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/subscribers/TestSubscriber.html#cancel--"" rel=""nofollow noreferrer""><code>TestSubscriber.cancel()</code></a>/<a href=""http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/subscribers/TestSubscriber.html#isCancelled--"" rel=""nofollow noreferrer""><code>TestSubscriber.isCancelled()</code></a>, which are public, and are equivalent to <code>dispose()</code>/<code>isDisposed()</code>, so you can use those instead.</p>
<p>As for the reason <code>Flowable.subscribe</code> does not return a <code>Disposable</code>, this change was made in RxJava 2, <a href=""https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-2.0#subscriber"" rel=""nofollow noreferrer"">to adhere to the Reactive-Streams specification</a>:</p>
<blockquote>
<p>Due to the Reactive-Streams specification, <code>Publisher.subscribe</code> returns <code>void</code> ...To remedy this, the method <code>E subscribeWith(E subscriber)</code> has been added to each base reactive class which returns its input subscriber/observer as is.</p>
</blockquote>
","2073595","","2073595","","2020-06-24 19:59:46","2020-06-24 19:59:46","","","","7","","","","CC BY-SA 4.0"
"62580094","1","","","2020-06-25 16:32:49","","0","20","<p>I have some <code>Flowable</code>s composed using <code>FlowableTransformer</code> like this:</p>
<pre><code>public static FlowableTransformer&lt;I, O&gt; transformer() {
    return f -&gt; {
        return Flowable.mergeArray(5, 5, f.filter(...).map(...), f.filter(...).map(...));
    }
}
</code></pre>
<p><strong>The basic use case here is have some form of branching logic</strong> - if the elements are A (<code>filter</code>) then do B (<code>map</code>) or if they are C then do D.</p>
<p>However, downstream, when I store the <code>Disposable</code> and later call <code>cancel</code> on it, cancellation only bubbles up the stream as far as the <code>Flowable</code> returned by <code>mergeArray</code>. Upstream of that, i.e. the operators upstream of the call to <code>compose(transformer())</code>, cancellation is never received.</p>
<p>So I thought this was a problem with <code>Flowable.merge()</code> itself (or rather: my lack of understanding), so I changed to using a <code>replay()</code> and a <code>ConnectableFlowable</code>:</p>
<pre><code>public static FlowableTransformer&lt;I, O&gt; transformer() {
    return f -&gt; {
        ConnectableFlowable&lt;TaggedUpdates&gt; cf = taggedUpdateFlowables.replay(5);
        
        Flowable&lt;O&gt; o = f
            .filter(...)
            .map(...)
            .concatWith(
                    cf
                        .filter(...)
                        .map(...)
            );
        
        cf.connect();
        return o;
    };
}
</code></pre>
<p>However - the same thing happens. <code>cancellation</code> only bubbles up as far as the <code>ConnectableFlowable</code>.</p>
<p>However, I need to propogate cancellation up the full Flowable so that the source of items stops producing.</p>
<p>Is there a way of doing that? Or should I go about the branching logic in a different way?</p>
","28190","","","","","2020-06-26 09:28:30","Cancellation across the Flowables when implementing branching logic","<java><rx-java><reactive-programming><rx-java3>","1","0","","","","CC BY-SA 4.0"
"62762831","1","","","2020-07-06 19:04:37","","0","102","<p>Recently, our project was migrated to RxJava 3 from RxJava 2. When we run our tests in Firebase Test Lab, we see the app crashing during testing:</p>
<pre><code>java.lang.NoSuchMethodError: No static method fromRunnable(Ljava/lang/Runnable;)Lio/reactivex/rxjava3/disposables/Disposable; in class Lio/reactivex/rxjava3/disposables/Disposable; or its super classes (declaration of 'io.reactivex.rxjava3.disposables.Disposable' appears in /data/app/com.example.client.developer-OsNMqNiVevCOI094EihlVg==/base.apk!classes7.dex)
</code></pre>
<p>RxJava 3 contains static interface methods, as denoted <a href=""https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-3.0#disposables"" rel=""nofollow noreferrer"">here</a>, but the Android Gradle Plugin should be desugaring these usages and making them work on pre-Java 8 API levels. Does anyone know what is going on here?</p>
","895797","","","","","2020-07-06 19:04:37","No static method fromRunnable when running tests in Firebase Test Lab","<android><firebase><android-testing><firebase-test-lab><rx-java3>","0","2","","","","CC BY-SA 4.0"
"62816267","1","62829523","","2020-07-09 13:41:41","","0","265","<p>I replaced the action call to Consumer in my code but while subscribing it keeps asking me to cast it to observer</p>
<p>Below is the code</p>
<pre><code>public void fetchSubscriptionPlans(String url, String apiKey, String authToken,
                                   final Consumer&lt;List&lt;ContentDatum&gt;&gt; subscriptionPlans) {
    appCMSSubscriptionPlanRest.getPlansById(url,authHeaders).enqueue(new Callback&lt;List&lt;ContentDatum&gt;&gt;() {
        @Override
        public void onResponse(Call&lt;List&lt;ContentDatum&gt;&gt; call, Response&lt;List&lt;ContentDatum&gt;&gt; response) {
            try {

                Observable.just(response.body())
                        .onErrorResumeNext(throwable -&gt; Observable.empty())
                        .subscribe(subscriptionPlans);
            } catch (Exception e) {
                Observable.just((List&lt;ContentDatum&gt;) null)
                        .onErrorResumeNext(throwable -&gt; Observable.empty())
                        .subscribe(subscriptionPlans);
            }
        }

        @Override
        public void onFailure(Call&lt;List&lt;ContentDatum&gt;&gt; call, Throwable t) {

        }
    });
}
</code></pre>
<p>I get the error on <code>.subscribe(subscriptionPlans);</code>to cast it as <code>.subscribe((Observer&lt;? super List&lt;ContentDatum&gt;&gt;) subscriptionPlans);</code></p>
<p>What should be correct way?</p>
<p>And on running the code I get the exception</p>
<pre><code>cannot be cast to rx.Observer
</code></pre>
","2569793","","2569793","","2020-07-10 07:03:33","2020-07-10 07:44:51","Subscribing to consumer in rxjava?","<android><retrofit><rx-java><rx-java3>","2","2","","","","CC BY-SA 4.0"
"62817462","1","","","2020-07-09 14:43:12","","0","22","<p>Learning RxJava so will be appreciate for any advice.</p>
<p>Need to receive objects when calculation is ready, so I made <code>PublishSubject</code> in models method:</p>
<pre><code>public PublishSubject&lt;BaseUnit&gt; exec(int inputNumber) {

    if (unitList.size() &gt; 0) {
        for (BaseUnit unit : unitList) {
            unit.setInProgress();
        }
    }

    PublishSubject&lt;BaseUnit&gt; subject = PublishSubject.create();

    list = new ArrayList&lt;&gt;();

    populateList(inputNumber).
            subscribeOn(Schedulers.from(Executors.newFixedThreadPool(ThreadPool.getPoolSize())))
            .subscribe(calculatedList -&gt; {
                list = calculatedList;

                for (List&lt;Integer&gt; elem : list) {
                    for (ListOperationName operationName : ListOperationName.values()) {
                        ListUnit unit = new ListUnit(operationName, elem, 0);
                        calculate(unit);
                        unitList.add(unit);
                        subject.onNext(unit);
                    }
                }

            }, error -&gt; Log.d(&quot;ERROR&quot;, error.toString()));

    return subject;
}


public Observable&lt;ArrayList&lt;List&lt;Integer&gt;&gt;&gt; populateList(int inputNumber) {
    return Observable.fromCallable(() -&gt; {

        ArrayList&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();

        Integer[] populatedArray = new Integer[inputNumber];
        Arrays.fill(populatedArray, insertValue);

        list.add(new ArrayList&lt;&gt;(Arrays.asList(populatedArray)));
        list.add(new LinkedList&lt;&gt;(Arrays.asList(populatedArray)));
        list.add(new CopyOnWriteArrayList&lt;&gt;(Arrays.asList(populatedArray)));

        return list;
    });
}
</code></pre>
<p>And then trying to subscribe in presenter:</p>
<pre><code>public void calculate(int inputNumber) {

    fragment.showAllProgressBars();

    repository.exec(inputNumber)
            .observeOn(AndroidSchedulers.mainThread())
            .subscribeOn(Schedulers.from(Executors.newFixedThreadPool(ThreadPool.getPoolSize())))
            .subscribe(unit -&gt; {
                Log.d(&quot;PRESENTER RESULT&quot;, unit.toString());
                fragment.setCellText(unit.getViewId(), unit.getTimeString());

            }, error -&gt; Log.d(&quot;PRESENTER ERROR&quot;, error.toString()));
}
</code></pre>
<p>This gives me nothing. But if I use <code>ReplaySubject</code> - it gives me all results, but seems like it uses only one thread. So I assume there is somethings wrong I made with subscription and it should be somewhere earlier.
I need to use exactly <code>PublishSubject</code> for giving me results as they are ready using multiple threads.</p>
<p>How to fix that? Or maybe there is other problem?</p>
","4974229","","","","","2020-07-09 14:43:12","RxJava PublishSubject subscribe doesn't give anything. Something's wtong with subscription?","<java><android><multithreading><rx-java><rx-java3>","0","7","","","","CC BY-SA 4.0"
"62829523","2","","62816267","2020-07-10 07:44:51","","0","","<p>I had the wrong import for Observable. Have to use this</p>
<pre><code>io.reactivex.rxjava3.core.Observable
</code></pre>
","2569793","","","","","2020-07-10 07:44:51","","","","0","","","","CC BY-SA 4.0"
"62896595","1","","","2020-07-14 13:41:15","","1","168","<p>Using RxJava3, given an <code>Observable</code> and a <code>Subject</code>, I can subscribe the Subject to the Observable:</p>
<pre class=""lang-java prettyprint-override""><code>observable.subscribe(subject); // returns void, not a subscription
</code></pre>
<p>Later, my Subject is not interested anymore in the Observable, how to unsubscribe it from the Observable ?</p>
","287058","","11606728","","2020-07-14 13:45:03","2020-07-14 14:42:10","RxJava: how to unsubscribe a subject from an observable","<rx-java><rx-java3>","1","0","","","","CC BY-SA 4.0"
"62963794","1","63253771","","2020-07-18 01:48:10","","2","126","<p>Is there an operator in RxJava, an external library or a way I'm missing to create a flowable/observable that recieves a function that controls the emission of data, like a valve?</p>
<p>I have a huge json file I need to process but I have to get a portion of the file, a list of entities, process it and then get another portion, I have tried using windows(), buffer() but the BiFunction I pass to Flowable.generate() keeps executing after I recieved the first list and I haven't finished processing it. I also tried FlowableTransformers.valve() from hu.akarnokd.rxjava3.operators but it just piles up the items before the flatMap() function that process the list</p>
<pre><code>private Flowable&lt;T&gt; flowable(InputStream inputStream) {

    return Flowable.generate(() -&gt; jsonFactory.createParser(new GZIPInputStream(inputStream)), (jsonParser, emitter) -&gt; {

        final var token = jsonParser.nextToken();

        if (token == null) {
            emitter.onComplete();
        }

        if (JsonToken.START_ARRAY.equals(token) || JsonToken.END_ARRAY.equals(token)) {
            return jsonParser;
        }

        if (JsonToken.START_OBJECT.equals(token)) {
            emitter.onNext(reader.readValue(jsonParser));
        }

        return jsonParser;
    }, JsonParser::close);
}
</code></pre>
<p>Edit: I need to control de emission of items to don't overload the memory and the function that process the data, because that function reads and writes to database, also the processing needs to be sequentially. The function that process the data it's not entirely mine and it's written in RxJava and it's expected that I use Rx.</p>
<p>I managed to solve it like this but if there is another way let me know please:</p>
<pre><code>public static &lt;T&gt; Flowable&lt;T&gt; flowable(InputStream inputStream, JsonFactory jsonFactory, ObjectReader reader, Supplier&lt;Boolean&gt; booleanSupplier) {
    return Flowable.generate(() -&gt; jsonFactory.createParser(new GZIPInputStream(inputStream)), (jsonParser, emitter) -&gt; {

        if (booleanSupplier.get()) {
            final var token = jsonParser.nextToken();

            if (token == null) {
                emitter.onComplete();
            }

            if (JsonToken.START_ARRAY.equals(token) || JsonToken.END_ARRAY.equals(token)) {
                return jsonParser;
            }

            if (JsonToken.START_OBJECT.equals(token)) {
                emitter.onNext(reader.readValue(jsonParser));
            }

        }
        
        return jsonParser;
    }, JsonParser::close);
}
</code></pre>
<p>Edit2: This is one of the ways I'm currently consuming the function</p>
<pre><code>public Flowable&lt;List&lt;T&gt;&gt; paging(Function&lt;List&lt;T&gt;, Single&lt;List&lt;T&gt;&gt;&gt; function) {
    final var atomicInteger = new AtomicInteger(0);
    final var atomicBoolean = new AtomicBoolean(true);

    return flowable(inputStream, jsonFactory, reader, atomicBoolean::get)
            .buffer(pageSize)
            .flatMapSingle(list -&gt; {

                final var counter = atomicInteger.addAndGet(1);

                if (counter == numberOfPages) {
                    atomicBoolean.set(false);
                }

                return function.apply(list)
                        .doFinally(() -&gt; {
                            if (atomicInteger.get() == numberOfPages) {
                                atomicInteger.set(0);
                                atomicBoolean.set(true);
                            }
                        });
            });
}
</code></pre>
","6580416","","6580416","","2020-07-27 19:26:29","2020-08-04 19:22:40","RxJava valve use case","<java><reactive-programming><rx-java2><rx-java3>","1","5","0","","","CC BY-SA 4.0"
"62985598","1","","","2020-07-19 20:59:17","","0","49","<p>I'm new to RxJava, so would be great if someone could clarify this...</p>
<p>Consider the following flow:</p>
<ol>
<li>Generate/emit an Integer each time a value is requested by a subscriber.</li>
<li>Group generated integers so that each value constitutes its own group. <strong>Note:</strong> the goal is to simulate a case, in which a very large number of groups is present in an input.</li>
<li>Now for each group:</li>
</ol>
<ul>
<li>Collect values into a series of 1 second-long chunks and stop when the first empty chunk arrives. <strong>Note:</strong> in real world there will be more than one value per group, but here there will be exactly 2 buffers per group: 1 buffer with a single int and 1 empty buffer, which will effectively complete the sequence.</li>
<li>Merge all non-empty chunks (1 in this case) into a single list.</li>
<li>Print resulting list into a standard output and request 1 more element.</li>
</ul>
<p>Primitive implementation of the flow above:</p>
<pre><code>import static java.util.stream.Collectors.toList;
import io.reactivex.rxjava3.annotations.NonNull;
import io.reactivex.rxjava3.core.Flowable;
import io.reactivex.rxjava3.core.FlowableSubscriber;
import org.reactivestreams.Subscription;

import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Stream;

public static void main(String[] args) {
final AtomicInteger ai = new AtomicInteger();
Flowable&lt;Integer&gt; flowable =
        Flowable.generate(emitter -&gt; emitter.onNext(ai.getAndIncrement()));
flowable.groupBy(value -&gt; value, value -&gt; value, false, 1)
        .flatMap(grouped -&gt; grouped.buffer(1, TimeUnit.SECONDS)
                .takeWhile(list -&gt; !list.isEmpty())
                .reduce((list1, list2
                ) -&gt; Stream.concat(list1.stream(), list2.stream()).collect(toList()))
                .toFlowable(), false, Integer.MAX_VALUE, 1)
        .subscribe(
                new FlowableSubscriber&lt;&gt;() {
                    private Subscription s;

                    @Override
                    public void onSubscribe(@NonNull Subscription s) {
                        this.s = s;
                        s.request(1);
                    }

                    @Override
                    public void onNext(List&lt;Integer&gt; groupedValues) {
                        assert groupedValues.size() == 1;
                        System.out.println(groupedValues);
                        s.request(1);
                    }

                    @Override
                    public void onError(Throwable t) {
                        t.printStackTrace();
                    }

                    @Override
                    public void onComplete() {
                        System.out.println(
                                &quot;Done.&quot;);
                    }
                }); }
</code></pre>
<p>As you can see, I create only 1 custom subscriber, which requests 1 item upon subscription creation and 1 more each time a list is processed. Though <code>flatMap</code>'s <code>maxConcurrency</code> is set to <code>Integer.MAX_VALUE</code> (since I want to handle as many groups as possible) - all other &quot;hints&quot; (such as groupBy's and flatMap's <code>bufferSize</code>) are set to 1 and no other buffering (such as <code>onBackpressureBuffer</code>, which &quot;buffers a limited number of items from the current <code>Flowable</code> and allows it to emit as fast it can&quot;) is requested.</p>
<hr />
<p>So problem is that number of times of <code>onNext</code>'s invocations (and, hence, requests for a value by it) is <strong>way much lower</strong> than a number of invocations of a lambda that I passed to <code>Flowable.generate</code> - by more than 40,000 most of the times, and I'd like it to be at least the same order of magnitude as the number of elements requested via <code>Subscrtiption.request</code>.
As I can judge by the lambda's callstack, each time a group is created, it invokes <code>io.reactivex.rxjava3.internal.operators.flowable.FlowableGroupBy.GroupBySubscriber#onSubscribe</code>, which, in turn, invokes <code>org.reactivestreams.Subscription#request</code> passing <code>bufferSize</code> (configured as 1 in the code snippet above) to it, so the process is pretty much self-perpetuating, so to speak. I can't specify <code>bufferSize</code> as 0, neither can I restrict the number of the groups being processed at the same time: finite <code>maxConcurrency</code> value quickly leads to <code>MissingBackpressureException</code>...</p>
<p>Am I missing something fundamental here or there is no way to truly apply back pressure in such a use case?</p>
<p>Thanks in advance.</p>
","11964844","","","","","2020-07-19 20:59:17","Flowable ignores Subscription.request when groupBy operator is used","<java><reactive-programming><reactive-streams><rx-java3>","0","5","","","","CC BY-SA 4.0"
"62997465","1","62997715","","2020-07-20 14:20:43","","2","152","<p>Now I use nested loops with <code>ReplaySubject</code> to get multiple observables and this need to be converted without using any loops, just observables.</p>
<pre><code>private Observable&lt;BaseUnit&gt; getUnitObservables(ArrayList&lt;Map&lt;Integer, Integer&gt;&gt; list, ReplaySubject&lt;BaseUnit&gt; subject) {

    ArrayList&lt;Observable&lt;BaseUnit&gt;&gt; observables = new ArrayList&lt;&gt;();
    
    for (Map&lt;Integer, Integer&gt; elem : list) {
        for (MapOperationName operationName : MapOperationName.values()) { // MapOperationName type is enum

            Observable&lt;BaseUnit&gt; observable = Observable.fromCallable(() -&gt; {
                // some operations here

                subject.onNext(unit);
                observables.add(observable);
            });
        }
    }
    return Observable.merge(observables);
}
</code></pre>
<p>&quot;<code>Map&lt;Integer, Integer&gt; elem : list</code>&quot; has 3 elements.
&quot;<code>MapOperationName.values()</code>&quot; return 7 elements.
So totally should be 21 as I get in example above.</p>
<p>Trying to refactor something like this but get only 3 elements:</p>
<pre><code>private Observable&lt;BaseUnit&gt; getUnitObservables(ArrayList&lt;Map&lt;Integer, Integer&gt;&gt; list, ReplaySubject&lt;BaseUnit&gt; subject) {

    Observable&lt;ListOperationName&gt; observableOperation = 
    Observable.fromArray(MapOperationName.values());
    Observable&lt;List&lt;Integer&gt;&gt; observableList = Observable.fromIterable(list);
    return Observable.zip(observableList, observableOperation, (listElem, operationElem) -&gt; {

        subject.onNext(unit);
        //some operations here
    });

}
</code></pre>
<p>How to combine correctly this <code>ArrayList</code> and <code>Enum</code> to get full set of pair combination?</p>
","4974229","","","","","2020-07-20 14:56:15","RxJava: how to use Observable instead nested loops?","<java><android><rx-java><rx-java3>","2","0","","","","CC BY-SA 4.0"
"62997715","2","","62997465","2020-07-20 14:31:23","","3","","<p>You can nest the operations you need to do inside of a <code>flatMap</code> to achieve this:</p>
<pre class=""lang-java prettyprint-override""><code>private Observable&lt;BaseUnit&gt; getUnitObservables(ArrayList&lt;Map&lt;Integer, Integer&gt;&gt; list, ReplaySubject&lt;BaseUnit&gt; subject) {

    Observable&lt;ListOperationName&gt; observableOperation = 
        Observable.fromArray(MapOperationName.values());
    Observable&lt;List&lt;Integer&gt;&gt; observableList = Observable.fromIterable(list);
    return observableList
        .flatMap(listElem -&gt; observableOperation
            .map(operationElem -&gt; {
                // some operations here
                subject.onNext(unit);
                return unit;  // Assuming unit is a BaseUnit
            })
        );
}
</code></pre>
","2073595","","","","","2020-07-20 14:31:23","","","","0","","","","CC BY-SA 4.0"
"63013443","1","63063646","","2020-07-21 11:24:52","","1","252","<p>Please, coorect me if I wrong in my conclusions about async work and give any suggestions how to make this work asynchronously.</p>
<p>This code performs setting result of calculations in grid cells.
As I assume asynchronous work should display grid cells by portions. So if we have 8 cores as result we can see that 8 cells displayed and during some time another 8 and so on (in case if I set some time delay). But for now as result cells displaying become one by one.</p>
<p>Model:</p>
<pre><code>public class ListRepository implements ListRepositoryInterface {
private final Integer insertValue = 1000000;

private HashMap&lt;String, BaseUnit&gt; unitMap = new HashMap&lt;&gt;();

@Inject
public ListRepository() {}

public PublishSubject&lt;BaseUnit&gt; exec(int inputNumber) {

    PublishSubject&lt;BaseUnit&gt; subject = PublishSubject.create();
    Observable&lt;BaseUnit&gt; observable = getListObservable(inputNumber)
            .subscribeOn(Schedulers.computation())
            .flatMap(resultList -&gt;

                Observable.fromIterable(resultList)
                        .flatMap(listElem -&gt;
                        Observable.fromArray(ListOperationName.values())
                                .map(operationElem -&gt; {

                            ListUnit unit = new ListUnit(operationElem, listElem, 0);
                            calculate(unit, listElem);
                            unitMap.put(unit.getViewId(), unit);
                            return unit;
                        })
                )
            );
    observable.subscribe(subject);
    return subject;
}


private Observable&lt;ArrayList&lt;List&lt;Integer&gt;&gt;&gt; getListObservable(int inputNumber) {
    return Observable.fromCallable(() -&gt; {

        ArrayList&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();

        Integer[] populatedArray = new Integer[inputNumber];
        Arrays.fill(populatedArray, insertValue);

        list.add(new ArrayList&lt;&gt;(Arrays.asList(populatedArray)));
        list.add(new LinkedList&lt;&gt;(Arrays.asList(populatedArray)));
        list.add(new CopyOnWriteArrayList&lt;&gt;(Arrays.asList(populatedArray)));

        return list;
    });
}


private void calculate(ListUnit unit, List&lt;Integer&gt; list) {
    try {
        TimeUnit.MILLISECONDS.sleep(50);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    double start = getTime();

    //noinspection SynchronizationOnLocalVariableOrMethodParameter
    synchronized (list) {

        switch (unit.getOperationName()) {
            case ADD_FIRST:
                list.add(0, insertValue);
                break;
            case ADD_MID:
                list.add(list.size() / 2, insertValue);
                break;
            case ADD_LAST:
                list.add(insertValue);
                break;
            case SEARCH:
                //noinspection unused
                boolean contains = list.contains(insertValue);
                break;
            case RM_FIRST:
                list.remove(0);
                break;
            case RM_MID:
                list.remove(list.size() / 2);
                break;
            case RM_LAST:
                list.remove(list.size() - 1);
                break;
        }
    }

    unit.setTime(getTime() - start);
}

private double getTime() {
    return System.nanoTime();
}

public HashMap&lt;String, BaseUnit&gt; getUnitMap() {
    return unitMap;
}

}
</code></pre>
<p>Presenter:</p>
<pre><code>public void calculate(int inputNumber) {
    fragment.showAllProgressBars();

    PublishSubject&lt;BaseUnit&gt; subject = repository.exec(inputNumber);

        Disposable disposable = subject.observeOn(AndroidSchedulers.mainThread())
                .subscribe(unit -&gt; {
                    fragment.setCellText(unit.getViewId(), unit.getTimeString());

                }, Throwable::printStackTrace);

}
</code></pre>
<p>UPD: now I made test example and trying to subscribe to subject correctly.
If I use subject.onNext() it works asynchronously, but I assume this is wrong because it doesn't get to check subject.hasComplete() and get &quot;true&quot;.
See comments &quot;TODO&quot; below.</p>
<pre><code>private void run() {

    Log.d(&quot;APP&quot;, &quot;INIT&quot;);

    PublishSubject&lt;String&gt; subject = exec(1000000);
    subject.observeOn(AndroidSchedulers.mainThread())
        .subscribe(unit -&gt; {
            Log.d(&quot;STRING RESULT = &quot;, unit);
            if (subject.hasComplete()) {
                //TODO: this condition should work if we use observable.subscribe(subject), not subject.onNext
                Log.d(&quot;SUBJECT&quot;, &quot;COMPLETED&quot;);
            }
        }, Throwable::printStackTrace);
}

private int insertValue = 1000000;

public PublishSubject&lt;String&gt; exec(int inputNumber) {
    PublishSubject&lt;String&gt; subject = PublishSubject.create();

    getListObservable(inputNumber)
        .flatMap(resultList -&gt; getOperationsObservable()
        .flatMap(operationElem -&gt; getResultListObservable(resultList)
            .map(listElem -&gt;
                                    calculate(operationElem, listElem)
//TODO: should be smth like this, i.e. calculate.subscribe(subject)
//                        .subscribe(subject)
                                        .subscribe(subject::onNext)

                        )
                )
        ).subscribe();

    return subject;
}


private Observable&lt;ArrayList&lt;List&lt;Integer&gt;&gt;&gt; getListObservable(int inputNumber) {
    return Observable.fromCallable(() -&gt; {

        ArrayList&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();

        Integer[] populatedArray = new Integer[inputNumber];
        Arrays.fill(populatedArray, insertValue);

        list.add(new ArrayList&lt;&gt;(Arrays.asList(populatedArray)));
        list.add(new LinkedList&lt;&gt;(Arrays.asList(populatedArray)));
        list.add(new CopyOnWriteArrayList&lt;&gt;(Arrays.asList(populatedArray)));

        return list;
    }).subscribeOn(Schedulers.computation());
}


private Observable&lt;String&gt; calculate(ListOperationName operationName, List&lt;Integer&gt; list) {
    return Observable.fromCallable(() -&gt; {
        try {
            TimeUnit.MILLISECONDS.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        double start = getTime();

        synchronized (list) {

            switch (operationName) {
                case ADD_FIRST:
                    list.add(0, insertValue);
                    break;
                case ADD_MID:
                    list.add(list.size() / 2, insertValue);
                    break;
                case ADD_LAST:
                    list.add(insertValue);
                    break;
                case SEARCH:
                    //noinspection unused
                    boolean contains = list.contains(insertValue);
                    break;
                case RM_FIRST:
                    list.remove(0);
                    break;
                case RM_MID:
                    list.remove(list.size() / 2);
                    break;
                case RM_LAST:
                    list.remove(list.size() - 1);
                    break;
            }
        }
        return Double.toString(getTime() - start);
    }).subscribeOn(Schedulers.newThread());
}

private Observable&lt;ListOperationName&gt; getOperationsObservable() {
    return Observable.fromArray(ListOperationName.values());
}

private Observable&lt;List&lt;Integer&gt;&gt; getResultListObservable(ArrayList&lt;List&lt;Integer&gt;&gt; list) {
    return Observable.fromIterable(list);
}

private double getTime() {
    return System.nanoTime();
}

public enum ListOperationName {
    ADD_FIRST,
    ADD_MID,
    ADD_LAST,
    SEARCH,
    RM_FIRST,
    RM_MID,
    RM_LAST;
}
</code></pre>
<p>Gradle:</p>
<pre><code>    dependencies {
    implementation 'io.reactivex.rxjava3:rxandroid:3.0.0'
    implementation 'io.reactivex.rxjava3:rxjava:3.0.4'
}
</code></pre>
","4974229","","4974229","","2020-07-23 14:48:41","2020-07-23 21:53:09","RxJava: how to make code working asynchronously?","<java><android><rx-java><rx-java3>","1","4","","","","CC BY-SA 4.0"
"63055413","1","63055414","","2020-07-23 13:26:31","","2","915","<p>I want to use retrofit2 and rxjava3 but I see the following error</p>
<pre><code>Caused by: java.lang.IllegalArgumentException: Could not locate call adapter for io.reactivex.rxjava3.core.Observable&lt;java.lang.Object&gt;.
      Tried:
       * retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory
       * retrofit2.CompletableFutureCallAdapterFactory
       * retrofit2.DefaultCallAdapterFactory
</code></pre>
<p>This error says that there is <em><strong>NO ADAPTER for the Rxjava</strong></em> but I added it in the line below</p>
<blockquote>
<p>.addCallAdapterFactory(RxJava2CallAdapterFactory.create())</p>
</blockquote>
<pre><code>public class ServiceGenerator {
  private static final String BASE_URL = &quot;http://example.com/&quot;;
  private static final OkHttpClient okHttpClient = new OkHttpClient.Builder()

    .connectTimeout(30, TimeUnit.SECONDS)
    .writeTimeout(30, TimeUnit.SECONDS)
    .readTimeout(30, TimeUnit.SECONDS)
    .build();

  public static &lt;S&gt; S createServiceSample(Class&lt;S&gt; serviceClass) {
    Retrofit.Builder builder =
      new Retrofit.Builder()
        .client(okHttpClient)
        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
        .addConverterFactory(GsonConverterFactory.create());
    builder.baseUrl(BASE_URL);
    Retrofit retrofit = builder.build();
    return retrofit.create(serviceClass);
  }

}
</code></pre>
<p>and my ApiInterface</p>
<pre><code>public interface ApiInterface {
  @Headers(&quot;Content-Type: application/json&quot;)
  @GET(&quot;api/v1/movies?q=[]&amp;page=[1]&quot;)
  Observable&lt;Object&gt; check();
}
</code></pre>
<p>and used in activity</p>
<pre><code>  ApiInterface apiInterface = ServiceGenerator.createServiceSample(ApiInterface.class);
    Observable&lt;Object&gt; cryptoObservable = apiInterface.check();
    cryptoObservable.subscribeOn(Schedulers.newThread())
      .observeOn(AndroidSchedulers.mainThread())
      .subscribe(new Observer&lt;Object&gt;() {
        @Override
        public void onSubscribe(@NonNull Disposable d) {
          Log.i(TAG, &quot;onSubscribe: &quot;);
        }

        @Override
        public void onNext(@NonNull Object o) {
          Log.i(TAG, &quot;onNext: &quot; + new Gson().toJson(o));

        }

        @Override
        public void onError(@NonNull Throwable e) {
          Log.i(TAG, &quot;onError: &quot;);
        }

        @Override
        public void onComplete() {
          Log.i(TAG, &quot;onComplete: &quot;);
        }
      });
</code></pre>
<p>and build.gradle</p>
<pre><code>    implementation 'io.reactivex.rxjava3:rxandroid:3.0.0'
    implementation 'io.reactivex.rxjava3:rxjava:3.0.4'

    implementation 'com.squareup.retrofit2:retrofit:2.9.0'
    implementation 'com.squareup.retrofit2:adapter-rxjava2:2.9.0'
    implementation 'com.squareup.retrofit2:converter-gson:2.9.0'

    implementation 'com.google.code.gson:gson:2.8.2'
</code></pre>
","8748900","","","","","2020-07-23 13:26:31","retrofit2 and rxjava3: java.lang.IllegalArgumentException: Could not locate call adapter for io.reactivex.rxjava3.core.Observable","<android><retrofit2><rx-java><adapter><rx-java3>","1","0","2","","","CC BY-SA 4.0"
"63055414","2","","63055413","2020-07-23 13:26:31","","4","","<p>You just need to <em>replace</em> the following line in <strong>build.gradle</strong></p>
<pre><code>implementation 'com.squareup.retrofit2:adapter-rxjava3:2.9.0'
</code></pre>
<p>with this line</p>
<pre><code>implementation 'com.squareup.retrofit2:adapter-rxjava2:2.9.0'
</code></pre>
<p>and <em>replace</em> the following line in <strong>ServiceGenerator</strong></p>
<pre><code>.addCallAdapterFactory(RxJava3CallAdapterFactory.create())
</code></pre>
<p>with this line</p>
<pre><code>.addCallAdapterFactory(RxJava2CallAdapterFactory.create())
</code></pre>
<p>It worked for me</p>
","8748900","","","","","2020-07-23 13:26:31","","","","0","","","","CC BY-SA 4.0"
"63063646","2","","63013443","2020-07-23 21:53:09","","1","","<p>If I remove <code>.subscribeOn(Schedulers.newThread());</code> from the <code>calculate(...)</code> method in your most recent example and make the following change to <code>exec(...)</code>, I seem to get the desired parallelism.</p>
<pre><code>public Observable&lt;String&gt; exec( int inputNumber )
{
    return getListObservable( inputNumber )
            .flatMap( resultList -&gt; getOperationsObservable()
                .flatMap( operationElem -&gt; getResultListObservable( resultList )
                        .flatMap( listElem -&gt; Observable.just( listElem )
                                .subscribeOn( Schedulers.computation() )
                                .flatMap( __ -&gt; calculate( operationElem, listElem )))));
}
</code></pre>
<p>I removed <code>PublishSubject</code> - it seems redundant, you can just subscribe to the resulting <code>Observable</code>, no?</p>
","2734169","","","","","2020-07-23 21:53:09","","","","0","","","","CC BY-SA 4.0"
"63088675","1","63160396","","2020-07-25 13:05:37","","0","141","<p>There is a very intuitive operator named <code>delayElements</code> available in the @ProjectReactor publisher Flux to introduce a delay between each element emitted. Say, for example, following cod emit an element per second.</p>
<pre><code>Flux.fromIterable(List.of(1, 2, 3))
      .delayElements(Duration.ofSeconds(1))
      .map(i -&gt; i * 2)
      .doOnNext(r -&gt; System.out.println(ZonedDateTime.now().toEpochSecond() + &quot;: &quot; + r))
      .blockLast();
</code></pre>
<p>To get the same behavior done in @Rxjava, I had to do some ceremony.</p>
<pre><code>final List&lt;Integer&gt; data = List.of(1, 2, 3);    
Flowable.interval(1, TimeUnit.SECONDS)
      .take(data.size())
      .map(i -&gt; data.get(i.intValue()) * 2)
      .doOnNext(r -&gt; System.out.println(ZonedDateTime.now().toEpochSecond() + &quot;: &quot; + r))
      .blockingLast();
</code></pre>
<p>Does anyone know a better way to do the above in @Rxjava?</p>
","2583726","","","","","2020-07-29 18:43:11","Delay Element in RxJava Flowable","<rx-java><project-reactor><rx-java3>","1","0","1","","","CC BY-SA 4.0"
"63136488","1","","","2020-07-28 14:29:19","","0","34","<p>First time testing Rx, so please give some advice.</p>
<p>Need to test observable chain in model that gives as a result 21 data objects:</p>
<pre><code>    public Observable&lt;BaseUnit&gt; exec(int inputNumber) {
    return getListObservable(inputNumber).subscribeOn(Schedulers.computation())
        .flatMap(resultList -&gt; getOperationsObservable()
            .flatMap(operationElem -&gt; getResultListObservable(resultList)
                .flatMap(listElem -&gt; Observable.just(listElem)
                    .flatMap(__ -&gt; calculate(operationElem, listElem) 
                    .subscribeOn(Schedulers.computation())))));
}
</code></pre>
<p>Here is some way I tried.</p>
<p>First try (here I have problems with get results and check them separately, because results of calculations inside each object unknown):</p>
<pre><code> TestObserver&lt;BaseUnit&gt; observer = repository.exec(1000000)
        .test()
        .awaitDone(5, TimeUnit.SECONDS)
                 .assertNoErrors()
        .assertValueCount(21)
        .assertComplete();
</code></pre>
<p>Second way:</p>
<pre><code>    ArrayList&lt;BaseUnit&gt; result = new ArrayList&lt;&gt;();

    Observable&lt;BaseUnit&gt; observable = repository.exec(1000000);
    observable.subscribe(result::add);

    try {
        TimeUnit.MILLISECONDS.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }


    assertNotNull(result);
    assertEquals(21, result.size());
    // here may be some loop of &quot;assers&quot;
</code></pre>
<p>Is that correct to test like I pointed it second way with time delay and loop?</p>
<p>How to check correctly that as a result it gives 21 object and check with condition that some property of data class is greater than zero? Is there any other cheks that need to be performed?</p>
<p>Also have one general question: need to test mvp presenter that use this model method and as a result display recieved values. How to do this using only JUnit4?</p>
","4974229","","4974229","","2020-07-28 14:38:44","2020-07-28 14:38:44","RxJava Junit4 multiple observable test","<android><junit><rx-java><junit4><rx-java3>","0","3","","","","CC BY-SA 4.0"
"63160396","2","","63088675","2020-07-29 18:43:11","","0","","<p>I found a rather simple approach <a href=""https://stackoverflow.com/a/41718758/2583726"">here</a>. Thanks, <a href=""https://stackoverflow.com/users/235123/mina-samy"">Mina</a>.</p>
<pre><code>Flowable.just(1,2,3)
  .zipWith(Flowable.interval(1, TimeUnit.SECONDS), (item, interval) -&gt; item)
  .subscribe(r -&gt; System.out.println(r));
</code></pre>
","2583726","","","","","2020-07-29 18:43:11","","","","0","","","","CC BY-SA 4.0"
"63189228","1","63195987","","2020-07-31 09:30:06","","1","93","<p>I am reading the content from file, I put some name into the file with new line separator but while reading the file by vertx file-system I am not able to provide the required filter. every-time it print all the data of file.</p>
<p>Here is the code snippet :-</p>
<pre><code>vertx.fileSystem().open(&quot;data.txt&quot;, new OpenOptions(), handler -&gt; {
                final AsyncFile asyncFile = handler.result();
                final Observable&lt;Buffer&gt; observable = asyncFile.toObservable();
                observable.subscribe(item -&gt; {
                    final String[] split = item.toString().split(&quot;\n\r&quot;);
                    List&lt;String&gt; list = Arrays.asList(split);
                    final Observable&lt;String&gt; stringObservable = Observable.fromIterable(list);
                    stringObservable
                            .filter(name -&gt; name.toString().startsWith(&quot;R&quot;))
                            .take(2)
                            .subscribe(str -&gt; System.out.println(str), err -&gt; System.out.println(err), () -&gt; System.out.println(&quot;Inner loop completed&quot;));


                }, error -&gt; System.out.println(error), () -&gt; System.out.println(&quot;Completed !!!&quot;));
            });
</code></pre>
<p>Internal observable I used after i find out the above observable have all the data of file in one go.</p>
","6568836","","","","","2020-08-04 13:28:34","Vertx RxJava Operator iteration not filtering the content","<rx-java><reactive-programming><rx-java2><vert.x><rx-java3>","1","3","","","","CC BY-SA 4.0"
"63195987","2","","63189228","2020-07-31 16:50:06","","3","","<p>This code snippet actually works fine for me if I split on &quot;\n&quot; instead of &quot;\n\r&quot;. If you're having issues with it printing everything, my guess is that the first character in the whole file is &quot;R&quot;, and then you don't actually have &quot;\n\r&quot; anywhere in the file. So when you try to split, you end up with just one large String that has the whole file in it.</p>
<p>That said, you can simplify this code significantly by using <code>rxOpen</code> instead of <code>open</code>, avoiding the nesting of subscribes, and simplifying how you turn the <code>Buffer</code> into an <code>Observable</code> that emits each line in the <code>Buffer</code>.</p>
<p>Also note that I used <a href=""https://vertx.io/docs/apidocs/io/vertx/reactivex/core/parsetools/RecordParser.html"" rel=""nofollow noreferrer""><code>RecordParser</code></a> to split the contents of the file into tokens using  the &quot;\n&quot; character as a delimiter. Just directly turning <code>AsyncFile</code> into an <code>Observable&lt;Buffer&gt;</code> using <code>toObservable()</code> could result in a <code>Buffer</code>s that cut off partway through a line, which would screw up your parsing.</p>
<p>So putting it all together:</p>
<pre class=""lang-java prettyprint-override""><code>vertx.fileSystem().rxOpen(&quot;data.txt&quot;, new OpenOptions())
    .flatMapObservable(af -&gt; RecordParser.newDelimited(&quot;\n&quot;, af).toObservable())
    .map(Buffer::toString)
    .filter(name -&gt; name.startsWith(&quot;R&quot;))
    .take(2)
    .subscribe(System.out::println, System.err::println, () -&gt; System.out.println(&quot;Completed&quot;));
</code></pre>
<p>You go from 13 lines to 6.</p>
","2073595","","2073595","","2020-08-04 13:28:34","2020-08-04 13:28:34","","","","5","","","","CC BY-SA 4.0"
"63253771","2","","62963794","2020-08-04 19:22:40","","0","","<p>Managed to solve it like this</p>
<pre><code> public static Flowable&lt;Object&gt; flowable(JsonParser jsonParser, ObjectReader reader, PublishProcessor&lt;Boolean&gt; valve) {
    return Flowable.defer(() -&gt; {
        final var token = jsonParser.nextToken();

        if (token == null) {

            return Completable.fromAction(jsonParser::close)
                    .doOnError(Throwable::printStackTrace)
                    .onErrorComplete()
                    .andThen(Flowable.empty());
        }


        if (JsonToken.START_OBJECT.equals(token)) {
            final var value = reader.readValue(jsonParser);
            final var just = Flowable.just(value).compose(FlowableTransformers.valve(valve, true));
            return Flowable.concat(just, flowable(jsonParser, reader, valve));
        }


        return flowable(jsonParser, reader, valve);
    });
}
</code></pre>
","6580416","","","","","2020-08-04 19:22:40","","","","0","","","","CC BY-SA 4.0"
"63331118","1","63333117","","2020-08-09 20:40:01","","1","79","<p>Why is the <code>subscribe</code> never printing anything here? Just out of curiosity. This is bad practice anyways: I would normally use <code>observeOn</code> instead. However, I can't figure out why the <code>subscribe</code> is never reached...</p>
<pre><code>val subject: PublishSubject&lt;Int&gt; = PublishSubject.create()
val countDownLatch = CountDownLatch(1)

subject
    .map { it + 1 }
    .subscribeOn(Schedulers.computation())
    .subscribe {
        println(Thread.currentThread().name)
        countDownLatch.countDown()
    }

subject.onNext(1)
countDownLatch.await()
</code></pre>
","2414457","","365102","","2020-11-13 12:59:02","2020-11-13 12:59:02","PublishSubject `subscribeOn` behavior","<kotlin><rx-java3>","1","2","1","","","CC BY-SA 4.0"
"63333117","2","","63331118","2020-08-10 01:49:27","","1","","<h2>Why this happens</h2>
<p>In the process of <em>subscribing</em>, an observer signals its readiness to receive items to the observable via a <code>Subscribe</code> notification. See the <a href=""http://reactivex.io/documentation/contract.html"" rel=""nofollow noreferrer""><code>Observable</code> contract</a> for details.</p>
<p>Furthermore, the <a href=""http://reactivex.io/documentation/subject.html"" rel=""nofollow noreferrer""><code>Subject</code></a> documentation states:</p>
<blockquote>
<p>Note that a <code>PublishSubject</code> may begin emitting items immediately upon creation (unless you have taken steps to prevent this), and <strong>so there is a risk that one or more items may be lost between the time the <code>Subject</code> is created and the observer subscribes to it</strong>.</p>
</blockquote>
<p>When you call <code>subject.onNext(_)</code> <em>immediately</em> after attempting to subscribe on a new thread via <code>.subscribeOn(Schedulers.computation())</code>, the observable (i.e. <code>subject</code>) may still be waiting for a <code>Subscribe</code> notification from the observer. For example:</p>
<pre><code>subject
    .subscribeOn(Schedulers.computation())
    .subscribe { println(&quot;received item&quot;) }

// this usually prints nothing!
subject.onNext(1)
</code></pre>
<p>However, if you add a bit of a time delay before you emit your first item, the observable is much more likely to receive the <code>Subscribe</code> notification from the observer before you call <code>subject.onNext(_)</code>. For example:</p>
<pre><code>subject
    .subscribeOn(Schedulers.computation())
    .subscribe { println(&quot;received item&quot;) }

// wait for subscription to be established properly
Thread.sleep(1000)

// this usually prints &quot;received item&quot;
subject.onNext(1)
</code></pre>
<hr />
<h2>What to do?</h2>
<p>If you want all your subscriptions to receive all the items emitted by an observable, you can do one of the following:</p>
<ul>
<li>Block the main thread to wait until all observers are subscribed before you call <code>subject.onNext(_)</code>.</li>
<li>Create a new observable that waits until all observables are subscribed before calling <code>subject.onNext(_)</code> inside itself.</li>
</ul>
<p>These might also be of use:</p>
<ul>
<li><code>ReplaySubject</code>: This allows you to store a history of all previous items, and re-emit them on each subscription. Downside: you need to store some arbitrary number of items in memory.</li>
<li><a href=""http://reactivex.io/RxJava/javadoc/rx/observables/ConnectableObservable.html"" rel=""nofollow noreferrer""><code>ConnectableObservable</code></a>: This ensures that an observable only emits items after <code>.connect()</code> is called. In particular, the <code>.autoConnect(n)</code> operator ensures that the observable only emits after <code>n</code> observers have successfully subscribed.</li>
</ul>
<h3>Example: blocking the main thread until subscribed</h3>
<pre><code>val subject: PublishSubject&lt;Int&gt; = PublishSubject.create()
val countDownLatch = CountDownLatch(1)
val isSubscribedLatch = CountDownLatch(1)

subject
    .subscribeOn(Schedulers.computation())
    .doOnSubscribe { isSubscribedLatch.countDown() }
    .map { it + 1 }
    .subscribe {
        countDownLatch.countDown()
        println(Thread.currentThread().name)
    }

isSubscribedLatch.await()
subject.onNext(1)
countDownLatch.await()
</code></pre>
","365102","","365102","","2020-11-13 12:55:29","2020-11-13 12:55:29","","","","0","","","","CC BY-SA 4.0"
"63518754","1","63635073","","2020-08-21 07:52:15","","2","171","<p>RxJava rule for testing with schedulers was</p>
<pre><code>import io.reactivex.Scheduler
import io.reactivex.android.plugins.RxAndroidPlugins
import io.reactivex.internal.schedulers.ExecutorScheduler
import io.reactivex.plugins.RxJavaPlugins
import org.junit.rules.TestRule
import org.junit.runner.Description
import org.junit.runners.model.Statement
import java.util.concurrent.Executor

class RxImmediateSchedulerRule : TestRule {

    private val immediate = object : Scheduler() {

        override fun createWorker(): Worker {
            return ExecutorScheduler.ExecutorWorker(Executor { it.run() }, true)
        }
    }

//    private val immediate = Schedulers.trampoline()

    override fun apply(base: Statement, description: Description): Statement {
        return object : Statement() {
            @Throws(Throwable::class)
            override fun evaluate() {
                RxJavaPlugins.setInitIoSchedulerHandler { immediate }
                RxJavaPlugins.setInitComputationSchedulerHandler { immediate }
                RxJavaPlugins.setInitNewThreadSchedulerHandler { immediate }
                RxJavaPlugins.setInitSingleSchedulerHandler { immediate }
                RxAndroidPlugins.setInitMainThreadSchedulerHandler { immediate }

                try {
                    base.evaluate()
                } finally {
                    RxJavaPlugins.reset()
                    RxAndroidPlugins.reset()
                }
            }
        }
    }
}
</code></pre>
<p>Now with RxJava3</p>
<pre><code>ExecutorScheduler.ExecutorWorker(Executor { it.run() }, true, true)
</code></pre>
<p>Second parameter here is called <code>fair</code> but there is no JavaDoc or explanation for this parameter in <code>ExecutorScheduler</code> class. Wha is fair paramater used for, and when it should be used?</p>
","5457853","","","","","2020-08-28 13:46:43","RxJava3 RxImmediateSchedulerRule ExecutorScheduler fair parameter","<android><unit-testing><rx-java3>","1","0","1","","","CC BY-SA 4.0"
"63613919","1","","","2020-08-27 10:20:45","","1","33","<p>I am trying to convert my fornt end code to java native code.But getting bit difficulty how to convert and what is similar operator which i can use in rxjava3.</p>
<p><strong>Forntend rxjs example</strong></p>
<pre><code>createOrAlterTable$(dataType: string) {
    return forkJoin(this.readTableFromBackend$(dataType),
      this.readLastSyncFile$(), this.getUserData$())
      .pipe(switchMap(combineresult =&gt; {
        var sqlliteddl: any = combineresult[0];
        var lastfv: any = combineresult[1];
        var userDataFlag: any = combineresult[2];
        let obslist$ = [];
        ...
        ...
         let obseravel$ = this..createOrAlterTable(JSON.stringify(queryjson), type);
          obslist$.push(obseravel$);
        
        ...
        ...
        ...
        return forkJoin(obslist$);
      }));
  }
</code></pre>
<p>Same above i want to achieve in java 1.8 program using rxjava3. how?</p>
<p>Any help is very appriciated.</p>
<p>Thanks.</p>
","9948050","","","","","2020-08-27 10:20:45","what is the similar of rxjs forkJoin operator in rxjava3","<java><rx-java3>","0","1","","","","CC BY-SA 4.0"
"63635073","2","","63518754","2020-08-28 13:46:43","","1","","<blockquote>
<p>no JavaDoc or explanation for this parameter in ExecutorScheduler class</p>
</blockquote>
<p>That's because <code>ExecutorScheduler</code> is an internal class an is not meant to be or expected to be used directly.</p>
<p>The fairness is explained in the JavaDocs of <a href=""http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/schedulers/Schedulers.html#from-java.util.concurrent.Executor-boolean-boolean-"" rel=""nofollow noreferrer""><code>Schedulers.from()</code></a>.</p>
","61158","","","","","2020-08-28 13:46:43","","","","2","","","","CC BY-SA 4.0"
"63697844","1","","","2020-09-02 02:30:46","","0","282","<p>I'm playing around with reactive flows using RxJava2, Micronaut and Cassandra. I'm new to rxjava and not sure what is the correct way to return a of List Person in the best async manner?</p>
<p>data is coming from a Cassandra Dao interface</p>
<pre><code>public interface PersonDAO {    
    @Query(&quot;SELECT * FROM cass_drop.person;&quot;)
    CompletionStage&lt;MappedAsyncPagingIterable&lt;Person&gt;&gt; getAll(); 
}
</code></pre>
<p>that gets injected into a micronaut controller</p>
<blockquote>
<pre><code>   return Single.just(personDAO.getAll().toCompletableFuture().get().currentPage())
            .subscribeOn(Schedulers.io())
            .map(people -&gt; HttpResponse.ok(people));
</code></pre>
</blockquote>
<p>OR</p>
<blockquote>
<pre><code>return Single.just(HttpResponse.ok())
        .subscribeOn(Schedulers.io())
        .map(it -&gt; it.body(personDAO.getAll().toCompletableFuture().get().currentPage()));
</code></pre>
</blockquote>
<p>OR switch to RxJava3</p>
<blockquote>
<pre><code>    return Single.fromCompletionStage(personDAO.getAll())
            .map(page -&gt; HttpResponse.ok(page.currentPage()))
            .onErrorReturn(throwable -&gt; HttpResponse.ok(Collections.emptyList()));
</code></pre>
</blockquote>
","755706","","","","","2021-02-04 17:41:59","the right way to return a Single from a CompletionStage","<rx-java2><cassandra-3.0><micronaut><rx-java3>","2","0","","","","CC BY-SA 4.0"
"63702704","1","63844688","","2020-09-02 09:31:07","","0","28","<p>I am using <code>rxjava3</code> and not quite understanding why method are not getting called in stream after added <code>ObserveOn</code> and <code>SubscribeOn</code>.</p>
<p>Here is the example java code:</p>
<pre><code>package mytestapp.error;

import io.reactivex.rxjava3.annotations.NonNull;
import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.schedulers.Schedulers;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;

/**
 * Hello world!
 *
 */
public class App {
    public static void main(String[] args) {
        System.out.println(&quot;Hello World!&quot;);
        String apiUrl = &quot;myApiUrl&quot;;
        try {
            App app = new App();
            app.syncNow(apiUrl);
        } catch (JSONException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    private void syncNow(String apiUrl) throws JSONException, IOException {
        createOrAlterTable().observeOn(Schedulers.newThread())
                .switchMap(d -&gt; menuTableRecords(apiUrl))
                .observeOn(Schedulers.newThread()).subscribe(res -&gt; {
                    System.out.println(res);

                }, onError -&gt; {
                    System.out.println(onError);
                }, () -&gt; {
                    System.out.println(&quot;Completed!!&quot;);
                });
        ;
    }

    private @NonNull Observable&lt;Object&gt; createOrAlterTable()
            throws IOException, JSONException {
        // Read table from backend
        // Read last sync file
        // get user data
        return Observable.zip(readTableFromBackend(), readLastSyncFile(),
                getUserData(),
                (s1, s2, s3) -&gt; readTableFromBackendZipperFun(s1, s2, s3)).subscribeOn(Schedulers.io())
                .observeOn(Schedulers.io()).map(
                d -&gt; d);
    }

    private @NonNull Observable&lt;String&gt; readTableFromBackend()
            throws JSONException, IOException {
        return Observable.fromArray(&quot;testing&quot;);
    }

    private @NonNull Observable&lt;JSONObject&gt; readLastSyncFile()
            throws JSONException {
        return Observable.fromArray(new JSONObject());
    }

    private @NonNull Observable&lt;Boolean&gt; getUserData() throws JSONException {
        return Observable.fromArray(true);
    }

    private JSONArray readTableFromBackendZipperFun(String sqlliteDDL,
            JSONObject lastFV, boolean userDataFlag) throws JSONException {
        System.out.println(&quot;zip ops&quot;);
        return new JSONArray();
    }

    private @NonNull Observable&lt;String&gt; menuTableRecords(String apiUrl)
            throws JSONException, IOException {
        
        return Observable.fromArray(&quot;MENU_TABLE_RECORDS&quot;);
    }
}
</code></pre>
<p>I want to execute each method on separate thread and on subscription also on different thread.</p>
<p>what is the cause making problem .how to solve above case?</p>
<p>Thanks.</p>
","9948050","","","","","2020-09-11 09:50:40","After added SubscribeOn and ObserveOn in stream method chaining not getting trigger","<java><rx-java3>","1","0","","","","CC BY-SA 4.0"
"63772661","1","","","2020-09-07 06:52:48","","2","100","<p>I stumbled upon a weird testScheduler behavior that I cannot wrap my head around. The code below is greatly simplified, but it origins in a real life issue.</p>
<p>Consider this test:</p>
<pre><code>@Test
fun testSchedulerFun(){

    val testScheduler = TestScheduler()

    val stringsProcessor = PublishProcessor.create&lt;String&gt;()

    val completable = Completable.complete()

    completable
        .doOnComplete { stringsProcessor.onNext(&quot;onComplete&quot;) }
        .subscribeOn(testScheduler)
        .subscribe()

    val testSubscriber = stringsProcessor
        .subscribeOn(testScheduler) //this line of code messes the test
        .test()

    testScheduler.triggerActions()

    testSubscriber
        .assertValues(&quot;onComplete&quot;)

}
</code></pre>
<p>**When I subscribe the tested <code>stringsProcessor</code> on <code>testScheduler</code>, the test fails. When I remove that line it succeeds. **</p>
<p>The flow of events as I see it is:</p>
<ol>
<li>triggerActions</li>
<li>completable and stringsProcessor are being subscribed and propagate their events downstream.</li>
<li>And apparently the <code>stringsProcessor.onNext(&quot;onComplete&quot;)</code> is evaluated <strong>after</strong> the testSubscriber has finished.</li>
</ol>
<p><strong>I want to know why</strong></p>
","1118475","","1118475","","2020-09-07 07:28:13","2020-09-11 09:42:35","rxjava testScheduler race condition","<unit-testing><kotlin><rx-java><rx-java3>","1","5","","","","CC BY-SA 4.0"
"63841999","1","","","2020-09-11 06:41:56","","2","72","<p>I am new to RxAndroid, that's why referring to all the operators of Rx. I have found out that <code>observable.takeFirst()</code> is showing redline as it could not be found in RxJava3. Can anyone tell me what is the alternative to <code>takefirst()</code> method?</p>
","2924305","","10682289","","2020-09-14 07:44:20","2020-09-14 07:44:20","What is the alternative to takeFirst method","<observable><rx-android><rx-java3>","1","0","","","","CC BY-SA 4.0"
"63844688","2","","63702704","2020-09-11 09:50:40","","1","","<p>Looks like you don't wait for the async activity to finish in the <code>main</code> method and your application just quits. Recommended reading: <a href=""https://github.com/ReactiveX/RxJava#simple-background-computation"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxJava#simple-background-computation</a></p>
<p>You can workaround the problem by using <code>blockingSubscribe</code> instead of just <code>subscribe</code> in this particular case.</p>
","61158","","","","","2020-09-11 09:50:40","","","","0","","","","CC BY-SA 4.0"
"64098293","1","","","2020-09-28 08:10:32","","0","40","<p>in below code lines</p>
<pre><code>@Test
fun rx() {
    val items = Observable.just(1, 2, 3, 4, 5)
            .observeOn(Schedulers.io()) //&lt;---- if remove this line each item is emitted by sequentially (i.e 12345)

    items
            .filter { it == 1 }
            .doOnNext { print(&quot;1&quot;) }
            .subscribe()

    items
            .filter { it == 2 }
            .doOnNext { print(&quot;2&quot;) }
            .subscribe()

    items
            .filter { it == 3 }
            .doOnNext { print(&quot;3&quot;) }
            .subscribe()

    items
            .filter { it == 4 }
            .doOnNext { print(&quot;4&quot;) }
            .subscribe()

    items
            .filter { it == 5 }
            .doOnNext { print(&quot;5&quot;) }
            .subscribe()

    Thread.sleep(1000)
}
</code></pre>
<p>I expect log should say &quot;12345&quot;, but it's say 23415, 31245, 53124 etc.. (i.e. Order looks like random)</p>
<p>The each item 1, 2, 3, 4, 5 seem that it's not emitted sequentially.</p>
<p>Is there any reason about that? and How can I fix it with using &quot;.observeOn(Schedulers.io())&quot; ?</p>
","5677633","","","","","2020-09-28 08:39:08","rxjava - items not emitted by sequentially","<android><rx-java><rx-java2><rx-java3>","1","1","","","","CC BY-SA 4.0"
"64178233","1","64421934","","2020-10-02 21:03:08","","0","44","<p>Let's say I have an <code>Person</code> interface, that have an <code>name</code> observable:</p>
<pre><code>interface Person {
  Observable&lt;String&gt; name;
}
</code></pre>
<p>And it's implementation:</p>
<pre class=""lang-java prettyprint-override""><code>class David implements Person {
  Observable&lt;String&gt; name = BehaviorSubject&lt;&gt;.createDefault(&quot;David&quot;);
}
</code></pre>
<p>And now there is a problem, because I can't get current value of <code>name</code> observable:</p>
<pre><code>class Main {
  public static void main(String[] args) {
    Person person = PersonFactory.create();
    System.out.println(??person.name.currentValue??);
  }
}
</code></pre>
<p>I don't want to expose the name as BehaviorSubject in my interface, because then everyone would be able to change the name, which isn't what I want.</p>
<p>I kind of understand a logic of Observables, so I know they aren't designed to store any value. So what is &quot;an immutable observable with current value&quot; in RxJava?</p>
<p>In Android there is a <code>LiveData</code> and <code>MutableLiveData</code>. To my understanding <code>MutableLiveData</code> is the equivalent of <code>BehaviorSubject</code>, so what is the equivalent of <code>LiveData</code> in RxJava?</p>
","7122582","","","","","2020-10-19 06:04:03","Observable that stores last value, but cannot push new ones?","<java><rx-java><reactive-programming><rx-java3>","2","1","1","","","CC BY-SA 4.0"
"64284023","1","","","2020-10-09 16:36:31","","0","54","<p>I am trying to use reactive non blocking approach to create Rest API.</p>
<pre><code>public HttpResponse&lt;Single&lt;ProductViewModel&gt;&gt; findById(String id) {
        LOG.info(String.format(&quot;Finding the product with id : %s&quot;, id));
        iProductManager.findById(id).subscribe(item -&gt; {
            if (item == null)
                return HttpResponse.notFound();
            return HttpResponse.ok().eTag(item.getId())
                    .location(new URI(String.format(&quot;/%s&quot;, item.getId())))
                    .body(item);
        }, error -&gt; {
            LOG.error(error.getMessage());
            return HttpResponse.status(HttpStatus.INTERNAL_SERVER_ERROR, &quot;URI Syntax Exception&quot;);
        });
    }
</code></pre>
<p>The below code has error on</p>
<pre><code>return HttpResponse.ok().eTag(item.getId())
                    .location(new URI(String.format(&quot;/%s&quot;, item.getId())))
                    .body(item);
</code></pre>
<p>and in the error method, I want to create eTag and location header when returning the value. How can I achieve this</p>
<p>#Error</p>
<pre><code>Incompatible types: expected void but the lambda body is neither a statement expression nor a void-compatible block
</code></pre>
<p>Can someone show me the appropriate code for above in the reactive way using rxjava 3</p>
","1162409","","","","","2020-10-09 16:36:31","Reactive Get method in Micronaut 2.1.0 with RXjava 3","<java><rx-java><micronaut><rx-java3><micronaut-rest>","0","0","","","","CC BY-SA 4.0"
"64421934","2","","64178233","2020-10-19 06:04:03","","0","","<p>I've decided to create my own <code>LiveData</code>, using a field delegation</p>
<pre><code>interface LiveData&lt;out T&gt; {
    val observable: Observable&lt;out T&gt;
    val value: T

    fun subscribe(onNext: Consumer&lt;in T&gt;): Disposable = observable.subscribe(onNext)
}

class MutableLiveData&lt;T&gt;(initial: T) : LiveData&lt;T&gt; {
    private val subject: BehaviorSubject&lt;T&gt; = BehaviorSubject.createDefault(initial)

    override val observable: Observable&lt;out T&gt; = subject

    override var value: T
        get() = subject.value
        set(value) = subject.onNext(value)

    fun mutate(mutationFunction: T.() -&gt; Unit) {
        value.mutationFunction()
        value = value
    }
}
</code></pre>
","7122582","","","","","2020-10-19 06:04:03","","","","2","","","","CC BY-SA 4.0"
"64444007","1","64444789","","2020-10-20 11:14:34","","1","78","<p>I need to check that an infinite observable (events from a device) emits ne specific event lets call it &quot;Started&quot; which is then followed by another one, &quot;Finished&quot;. However in between these two events, any number of different events can be received and they must be ignored. The result of this should be a Completable.complete() which is successful when the &quot;Started&quot; event was followed by the &quot;Finished&quot; event before a set timeout.</p>
<p>I have a working solution for this problem, however it looks ugly and too complex and I think there probably is a more elegant/simple solution. My current code looks like this, I have generalized my code so it is easier to understand, basically in this example I check that after the Flowable emits the number &quot;5&quot; before a timeout of 10 seconds the number &quot;8&quot; is received.:</p>
<pre><code>    Flowable&lt;Long&gt; events = Flowable.interval(1, TimeUnit.SECONDS, testScheduler)
            .publish().autoConnect(1);

    return events
            .filter(number -&gt; number == 5)
            .firstElement()
            .concatMapCompletable(number -&gt; {
                if (number == 5) {
                    return events
                            .filter(number2 -&gt; number2 == 8)
                            .firstElement()
                            .concatMapCompletable(number2 -&gt; {
                                if (number2 == 8) {
                                    return Completable.complete();
                                } else {
                                    return Completable.error(new Exception(&quot;Number 3 expected, got &quot; + number2));
                                }
                            });
                } else {
                    return Completable.error(new Exception(&quot;Number 2 expected, got &quot; + number));
                }
            })
            .timeout(10, TimeUnit.SECONDS, Completable.error(new Exception(&quot;Timeout!&quot;)));
</code></pre>
<p>EDIT:
I have found a cleaner version, however it seems weird since I am using the .filter operator to then Complete on the first element received, I post it here below for reference:</p>
<pre><code>    Flowable&lt;Long&gt; events = Flowable.interval(1, TimeUnit.SECONDS, testScheduler)
            .publish().autoConnect(1);

    TestObserver testObserver = events
            .filter(number -&gt; number == 5)
            .firstElement()
            .concatMapCompletable(number -&gt;
                    events
                            .filter(number2 -&gt; number2 == 8)
                            .firstElement()
                            .concatMapCompletable(number2 -&gt;
                                    Completable.complete()))
            .timeout(10, TimeUnit.SECONDS, Completable.error(new Exception(&quot;Timeout!&quot;)))
            .test();
</code></pre>
<p>UPDATE2:
Version which I am much more happy about:</p>
<pre><code>    Flowable&lt;Long&gt; events = Flowable.interval(1, TimeUnit.SECONDS, testScheduler)
            .publish().autoConnect(1);

    TestObserver testObserver = events
            .skipWhile(number -&gt; number != 5)
            .firstElement()
            .flatMapCompletable(number -&gt; Completable.fromObservable(events
                    .takeUntil(number2 -&gt; number2 == 8)
                    .toObservable()
            ));
</code></pre>
","13322198","","13322198","","2020-10-21 12:54:30","2020-10-21 15:55:22","Check one specific event is followed by another one and emit success using RxJava","<java><rx-java><rx-java3>","1","0","","","","CC BY-SA 4.0"
"64444789","2","","64444007","2020-10-20 12:04:43","","0","","<p>I'm not sure to understand what you want to do exactelly but you can use <code>buffer</code> or <code>window</code> operators like the following:</p>
<pre class=""lang-java prettyprint-override""><code>Flowable.just(1, 2, 3, 4, 5)
        .buffer(2, 1)
        .filter(e -&gt; e.size() &gt; 1)
        .flatMapCompletable(e -&gt; {
            int first = e.get(0);
            int second = e.get(1);
            if (first == 2) {
                if (second == 3) {
                    return Completable.complete();
                } else {
                    return Completable.error(new Exception(&quot;...&quot;));
                }
            }

            return Completable.fromObservable(Observable.just(e));
        })
</code></pre>
<hr />
<p><strong>UPDATE</strong></p>
<pre class=""lang-java prettyprint-override""><code>Observable&lt;Long&gt; source = Observable.interval(1, TimeUnit.SECONDS)
        .share();

source
        .skipWhile(e -&gt; e != 5)
        .flatMapCompletable(e -&gt; Completable.fromObservable(source
                .takeUntil(x -&gt; x == 8)
                .timeout(10, TimeUnit.SECONDS)))
        .subscribe();
</code></pre>
","8325761","","8325761","","2020-10-21 15:55:22","2020-10-21 15:55:22","","","","10","","","","CC BY-SA 4.0"
"64456570","1","","","2020-10-21 04:12:59","","1","56","<p>here I have a flowable that emits elements every millisecond.</p>
<pre><code>   Flowable&lt;Long&gt; source = Flowable.interval(1,TimeUnit.MILLISECONDS).take(14000);
        source.map(e-&gt;{
            Log.d(&quot;TAGBefore&quot;,&quot;before &quot; + e);
            return e;
        })
        .onBackpressureDrop()
        .observeOn(Schedulers.computation())
        .subscribe(
                        e-&gt; {
                            Log.d(&quot;TAGNext&quot;,&quot;onNext: &quot; + e);
                            Thread.sleep(100);
                        },
                        e-&gt; Log.d(&quot;TAGError&quot;,&quot;error: &quot; + e),
                        ()-&gt; Log.d(&quot;TAGComplete&quot;,&quot;onComplete&quot;)
        );
</code></pre>
<p>I use the before to know the moment in which the observable emits elements, my doubt is that here from 127 (when the observer is full) it goes to 9688</p>
<pre><code>   TAGNext: onNext: 125
   TAGNext: onNext: 126
   TAGNext: onNext: 127
   TAGNext: onNext: 9668
   TAGNext: onNext: 9669
   TAGNext: onNext: 9670
</code></pre>
<p>However, when I check the console more (with other search filters), I realize that when 127 was issued it already goes to 12794, so instead of 9688 it shouldn't be 12794 or a close number? , thanks.</p>
<pre><code>   TAGBefore: before: 12793
   TAGBefore: before: 12794
   TAGNext:   onNext: 127
   TAGBefore: before: 12795
   TAGBefore: before: 12796
 
</code></pre>
<p>However, when I check the console more (with other search filters), I realize that when 127 was emitted it already goes for 12794, so instead of 9688 it should not be 12794 or a close number that is when the observable is already free ?, I clarify that I am new in RxJava in case I said something wrong, thanks.</p>
","13446152","","","","","2020-10-21 09:19:49","Why is this happening in with onBackpressureDrop () in RxJava","<rx-java><reactive-programming><rx-java2><rx-android><rx-java3>","1","0","1","","","CC BY-SA 4.0"
"64686530","1","","","2020-11-04 19:29:47","","2","77","<p>new to Micronaut and am wondering how people are handling errors. The example in the documentation uses blocking which I do not want to use to handle errors. Basically, what i'd like to do is be able to detect if error and if so, convert it to Errors class. If it can't convert to Errors class, let a global handler handle it. Does anyone have good sample code for my scenario? Below is my code. Thank you</p>
<pre><code>@Client(value = &quot;${my.host}&quot;, errorType = Errors.class)
@Header(name = &quot;ClientId&quot;, value = &quot;${clientId}&quot;)
@JacksonFeatures(enabledDeserializationFeatures = UNWRAP_ROOT_VALUE,
    disabledDeserializationFeatures = FAIL_ON_UNKNOWN_PROPERTIES)
public interface MyClient {

    @Get(&quot;/myurl/{?queryParams*}&quot;)
    public Single&lt;MyResult&gt; search(@Nullable @QueryValue Map&lt;String, Object&gt; queryParams);

}
</code></pre>
","634904","","","","","2020-11-04 19:42:56","How to handle error when using @Client interface in Micronaut","<java><rx-java><micronaut><rx-java3>","0","0","","","","CC BY-SA 4.0"
"64701875","1","","","2020-11-05 17:01:36","","1","23","<p>I want to receive success after successful retry. Here's my minimal working example:</p>
<pre><code>        var i = 0

        Observable.just(i)
            .flatMapSingle {
                println(i)
                i++
                when {
                    it &lt; 3 -&gt; Single.error(Exception())
                    else -&gt; Single.just(it)
                }
            }
            .retryWhen { errorObservable -&gt; errorObservable
                .take(4)
            }
            .subscribe { println(&quot;subscribe $i&quot;) }
</code></pre>
<p>this will subscribe and print <code>0, subscribe 1</code>. If I uncomment commented lines, I'll get only <code>0, 1, 2, 3</code>
How do I get successful value in subscribe in given example?</p>
","1870447","","","","","2020-11-05 17:01:36","not getting success when using retryWhen","<rx-java><rx-java3>","0","1","","","","CC BY-SA 4.0"
"64876856","1","64877492","","2020-11-17 14:07:19","","0","38","<p>I have class three classes. Pref, ClassA, and ClassB.</p>
<pre><code>public class Pref{
     public static ArrayList&lt;Pref&gt; prefList;
     public static Observable&lt;ArrayList&lt;Pref&gt;&gt; observable;

     public static void loadData(){
         prefList = getFromDb();
         observable = Observable.just(prefList);
    }  
}
</code></pre>
<p>Application runs the ClassA First.</p>
<pre><code>    public ClassA{
         public ClassA(){
              initObserver();
              setObserver();
         }
         public void initObserver(){
               Pref.loadData();
         }

         public void setObserver(){
              Observer&lt;ArrayList&lt;Pref&gt;&gt; obs = new Observer() {
                @Override
                public void onSubscribe(Disposable dspsbl) {
                      System.out.println(&quot;Subscribed&quot;);
                }

              @Override
              public void onNext(ArrayList&lt;Pref&gt;&gt; t) {
                    System.out.println(&quot;Loading Preference.&quot;);
                    //Need to do some other works here.
              }

              @Override
              public void onError(Throwable thrwbl) {
              }

             @Override
             public void onComplete() {
             }
          };
         Pref.observable.subscribe(obs);
     }
}
</code></pre>
<p>Now I want to change the list from ClassB.</p>
<pre><code>     public class ClassB{
            private void changeList(){
                  Pref.prefList = loadDataFromSomeSource();
           }
     }
</code></pre>
<p>When I run <code>ClassA</code>, the <code>System.out works</code> fine. But when I change the list from <code>ClassB</code> nothing happens. My question is, is the right way to work with <code>Rxjava</code>. Is it for <code>Rxjava</code> built? If I am wrong how can I achieve this functionality? How can I write several <code>ClassA</code> like classes so that When the <code>ClassB::changeList()</code> runs, I can listen it in <code>ClassA?</code></p>
","1701191","","","","","2020-11-17 14:46:29","How to notify the obsever when list changes in Rxjava","<java><swing><rx-java3>","1","0","","","","CC BY-SA 4.0"
"64877492","2","","64876856","2020-11-17 14:46:29","","1","","<p>By setting <code>Pref.prefList = loadDataFromSomeSource();</code>, you assign a new list instance to <code>Pref.prefList</code>. This will not update <code>Pref.observable</code> in any way, because this still refers to the old <code>Pref.prefList</code> instance.</p>
<p>I also think that you can not use an <code>Observable</code> to publish events through it. As far as I understand your situation, you need an <code>ObservableSource</code> (see <a href=""http://reactivex.io/RxJava/javadoc/io/reactivex/ObservableSource.html"" rel=""nofollow noreferrer"">http://reactivex.io/RxJava/javadoc/io/reactivex/ObservableSource.html</a>). For example, it is implemented by <code>PublishSubject</code>. You could use it like this:</p>
<pre class=""lang-java prettyprint-override""><code>PublishSubject&lt;String&gt; source = PublishSubject.create();
source.subscribe(System.out::println);
source.onNext(&quot;test 1&quot;);
source.onNext(&quot;test 2&quot;);
source.onNext(&quot;test 3&quot;);
</code></pre>
<p>Or, in your case: in class <code>Pref</code>, you can use <code>public static PublishSubject&lt;ArrayList&lt;Pref&gt;&gt; source = PublishSubject.create();</code>. When loading the data, you can publish the new data using <code>onNext</code>, like this in <code>ClassB</code>: <code>Pref.source.onNext(loadDataFromSomeSource())</code></p>
","5428154","","","","","2020-11-17 14:46:29","","","","0","","","","CC BY-SA 4.0"
"65001397","1","","","2020-11-25 08:58:16","","0","45","<p>I have an <code>Observable&lt;List&lt;Event&gt;&gt;</code> and I want this Observable to be shared by multiple Subscribers.
Each Subscriber will filter each Event and process it.</p>
<p>The <code>Observable&lt;List&lt;Event&gt;&gt;</code> has been created this way :</p>
<pre><code>    @Override
    public List&lt;Event&gt; findNewEvents() {
        List&lt;Event&gt; results = new ArrayList&lt;&gt;();
        while(! fetchedEvents.isEmpty()) {
            results.add(fetchedEvents.poll());
        }
        return results;
    }

    @Override
    public Observable&lt;List&lt;Event&gt;&gt; findNewObservableEvents() {
        return Observable.just(findNewEvents());
    }
</code></pre>
<p>Here is the code :</p>
<pre><code>            Observable&lt;List&lt;Event&gt;&gt; newEvents = reader.findNewObservableEvents();

            Disposable riskApproveRiskEventsDisposable = newEvents.flatMapIterable(riskEvents -&gt; riskEvents)
                    .flatMap(Observable::just)
                    .filter(risk::isForRiskApproval)
                    .subscribe(risk::approveRisk);

            Disposable fundingCheckFundabilityEventsDisposable = newEvents.flatMapIterable(riskEvents -&gt; riskEvents)
                    .flatMap(Observable::just)
                    .filter(funding::isForFundingFundabilityCheck)
                    .subscribe(funding::checkFundability);

            Disposable fundingFundEventsDisposable = newEvents.flatMapIterable(riskEvents -&gt; riskEvents)
                    .flatMap(Observable::just)
                    .filter(funding::isForFundingFund)
                    .subscribe(funding::fund);
</code></pre>
<p>I have tried :</p>
<p><code>newEvents.share()</code> and also <code>newEvents.publish()</code>.</p>
<p>When trying : <code>newEvents.create()</code> I need to supply a <code>ObservableOnSubscribe</code> object, but I don't understand how to obtain it.</p>
<p>What is the trick ?</p>
","4587314","","","","","2020-11-26 14:15:28","How to subscribe multiple Observers on a single Observable with RxJava?","<java><rx-java3>","1","0","","","","CC BY-SA 4.0"
"65154637","1","","","2020-12-05 07:08:35","","0","91","<p>I am trying to understand how to use repeatWhen in RxJava. The javadoc is confusing, when I searched online someone suggested to use like below</p>
<p>MyRepeatFunction myRepeatFunction = new MyRepeatFunction(3);
observable1.repeatWhen(myRepeatFunction).subscribe((t) -&gt; System.out.print(t));</p>
<p>class MyRepeatFunction implements Function&lt;Observable, ObservableSource&gt; {
private int repeatCount;</p>
<pre><code>public MyRepeatFunction(int repeatCount) {
    this.repeatCount = repeatCount;
}

@Override
public @NonNull ObservableSource&lt;Object&gt; apply(@NonNull Observable&lt;Object&gt; t) throws Throwable {
    return t.delay(1, TimeUnit.SECONDS);
}
</code></pre>
<p>}</p>
<p>The code &quot;return t.delay(1, TimeUnit.SECONDS);&quot; will make it continue forever. It doesn't stop until the main thread stops. I want to repeat the observable but only repeatCount times or till a particular is not true.</p>
<p>I am confused. Help is appreciated.</p>
","14109018","","","","","2020-12-05 21:28:08","how to use RxJava repeatWhen","<rx-java3>","1","0","","","","CC BY-SA 4.0"
"65160089","1","","","2020-12-05 17:48:48","","0","121","<p>Using reactivex to map and return the value from the method as below</p>
<pre><code>public Single&lt;ProductViewModel&gt; Create(ProductViewModel model) {
        Product product = new Product();
        product.setName(model.getName());
        product.setDescription(model.getDescription());
        product.setPrice(model.getPrice());

        return Single.fromPublisher(this.repository.getCollection(&quot;product&quot;, Product.class)
        .insertOne(product)).map(success -&gt; {
             return new ProductViewModel(
                    success.getInsertedId(),
                    product.getName(),
                    product.getDescription(),
                    product.getPrice());
        });
    }
</code></pre>
<p>When I use the .map function the record is not inserted into the database, however, on the .subscribe method, the record is inserted successfully into the database.</p>
<p>But I want to map the inserted record and return the value to the consumer method.</p>
","1162409","","3347384","","2020-12-12 12:46:42","2020-12-12 12:46:42","Single.fromPublisher subscribe and map to the return type reactivex java","<java><rx-java><reactivex><rx-java3>","0","3","","","","CC BY-SA 4.0"
"65193002","1","65199397","","2020-12-08 04:15:03","","2","73","<p>The use case is,
there are 2 sources of the data:</p>
<ol>
<li>Service 1 - fetches from source-1</li>
<li>Service 2 - fetches from the source-2</li>
</ol>
<p>The app should return data at least from source-1. If all is fine with source-2 - the data will be &quot;enhanced&quot;, say multiplied by 100.</p>
<p>Service 1 calls service 2.</p>
<p>if all successful user gets the data from service-1 and service-2
if there is an error on service 2, users gets data only from service 1 (at least)
if there is an error on service 1 - user will get an error.</p>
<p>There is hello-world-bench code, that emulate this scenario:</p>
<pre><code>import io.reactivex.rxjava3.core.Observable;
import java.util.concurrent.TimeUnit;

class Response {

    public Integer value;
    public String warning;
    public Response(Integer value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return &quot;Response{&quot; +
                &quot;value=&quot; + value +
                &quot;, warning='&quot; + warning + '\'' +

                '}';
    }
}

class Service1 {

    public Observable&lt;Response&gt; call(int arg) {
        return Observable
                .just(
                        new Response(1),
                        new Response(2),
                        new Response(3),
                        new Response(4))
                .delay(100, TimeUnit.MILLISECONDS);
    }
}

class Service2 {

    public Observable&lt;Response&gt; call(int arg) {

        if ( arg % 2 == 0) {

            System.out.println(&quot;service 2: &quot; + arg);

            return Observable
                    .just(new Response(100 * arg)) // service 2 multiplies x 100 on the result it gets from the service 1 
                    .delay(10, TimeUnit.MILLISECONDS);

        } else {

            System.out.println(&quot;service 2: &quot; + arg);

            return Observable.error(new RuntimeException(&quot;service 2 error&quot;));
        }
    }
}

public class Step1 {

    static Service1 service1 = new Service1();
    static Service2 service2 = new Service2();

    public static void main(String[] args) throws InterruptedException {

        var oo1 = service1.call(1);

        var oo3 = oo1.switchMapDelayError(x -&gt; {

            final Observable&lt;Response&gt; oo2 = service2.call(x.value);

            return oo2
                    .onErrorReturn((ex) -&gt; {
                        //System.out.println(&quot;Error handling...&quot; + ex.getMessage() + &quot; &quot; + x);
                        x.warning = ex.getMessage();
                        return x; // returns at least service1 result
                    });
        });

        oo3.subscribe(x -&gt; {
            System.out.println(x);
        });


        Thread.sleep(100000);
    }

}
</code></pre>
<hr />
<p>The result of this code is:</p>
<pre><code>service 2: 1
Response{value=1, warning='service 2 error'}
service 2: 2
service 2: 3
Response{value=3, warning='service 2 error'}
service 2: 4
Response{value=400, warning='null'}
</code></pre>
<p>The problem is: there is no expected: <code>value=200</code>  2*100</p>
<p>yet, if I comment a delay at service2.call()  //.delay(10, TimeUnit.MILLISECONDS) then its get the expected result:</p>
<pre><code>service 2: 1
Response{value=1, warning='service 2 error'}
service 2: 2
Response{value=200, warning='null'}
service 2: 3
Response{value=3, warning='service 2 error'}
service 2: 4
Response{value=400, warning='null'}
</code></pre>
<p><strong>The question is</strong>: why  with <code>.delay(10, TimeUnit.MILLISECONDS) on service2.call()</code> it fails to produce value=200 ? what's wrong with that solution, what do I miss?</p>
<p>Thanks.</p>
","369759","","369759","","2020-12-08 04:20:20","2020-12-08 12:57:31","rxjava combines 2 calls with error handling, fails with delay","<java><rx-java><rx-java3>","1","0","","","","CC BY-SA 4.0"
"65199397","2","","65193002","2020-12-08 12:57:31","","1","","<p>your problem is the <code>switchMapDelayError</code> operator. You should either use concatMap or flatMap</p>
<p>I took the liberty to write a test for your use-case. As a note, always use the overload to provide a <code>Scheduler</code> in order provide a <code>TestScheduler</code> for testing.</p>
<h2>What does switchMap do?</h2>
<p>On each upstream emit switchMap subscribes to given inner-stream. When a new value is emitted from upstream, the old inner-stream gets unsubscribed and the lambda of switchMap is called again in order to subscribe to the new inner-stream.</p>
<p>The problem is probably this code:</p>
<pre><code>return Observable
            .just(
                    new Response(1),
                    new Response(2),
                    new Response(3),
                    new Response(4))
            .delay(100, TimeUnit.MILLISECONDS);
</code></pre>
<p>It emits Response 1 to 4 on the stack almost instantly one after another and each emit is delayed on another thread. Therefore Response 1 to 4 will be emitted almost instantly. They will not be emitted like: Response(1) at 100ms, Response(2) at 200ms, etc.</p>
<p>Lets see what the output is for</p>
<pre><code>Observable.just(
    new Response(1), //
    new Response(2),
    new Response(3),
    new Response(4))
    .delay(100, TimeUnit.MILLISECONDS)
    .subscribe(r -&gt; {
      System.out.println(&quot;received value at &quot; + Schedulers.io().now(TimeUnit.MILLISECONDS));
    });
</code></pre>
<p>Output</p>
<pre><code>received value at 1607432032768
received value at 1607432032769
received value at 1607432032769
received value at 1607432032769
</code></pre>
<p>Therefore all values are emitted almost instantly and overwrite each other with the switchMap. The previously emitted value is almost instantly cancelled by the new value.</p>
<h2>Solution</h2>
<p>Use concatMap or flatMap or change your test-setup to emit each value at 100ms intervals.</p>
<p>flatMap just subscribes to each value, at max by default 128 inner streams. ConcatMap will only subscribe to the next value, when the inner-stream completes.</p>
<p>Test</p>
<pre><code>public class So65193002 {
      @Test
      void so() {
        TestScheduler testScheduler = new TestScheduler();
        Service1 service1 = new Service1(testScheduler);
        Service2 service2 = new Service2(testScheduler);
    
        Observable&lt;Response&gt; service1Call = service1.call(1);
    
        Observable&lt;Response&gt; combined =
            service1Call.concatMapEagerDelayError(
                x -&gt; {
                  return service2
                      .call(x.value)
                      .onErrorReturn(
                          (ex) -&gt; {
                            x.warning = ex.getMessage();
                            return x; // returns at least service1 result
                          });
                },
                true);
    
        TestObserver&lt;Response&gt; test = combined.test();
    
        testScheduler.advanceTimeBy(1, TimeUnit.HOURS);
    
        test.assertValueCount(4)
            .assertValueAt(
                0,
                r -&gt; {
                  assertThat(r.value).isEqualTo(1);
                  assertThat(r.warning).isNotEmpty();
                  return true;
                })
            .assertValueAt(
                1,
                r -&gt; {
                  assertThat(r.value).isEqualTo(200);
                  assertThat(r.warning).isNull();
                  return true;
                })
            .assertValueAt(
                3,
                r -&gt; {
                  assertThat(r.value).isEqualTo(400);
                  assertThat(r.warning).isNull();
                  return true;
                });
      }
    }
</code></pre>
<p>Domain</p>
<pre><code>class Response {
  public Integer value;
  public String warning;

  public Response(Integer value) {
    this.value = value;
  }

  @Override
  public String toString() {
    return &quot;Response{&quot; + &quot;value=&quot; + value + &quot;, warning='&quot; + warning + '\'' + '}';
  }
}

class Service1 {
  private final Scheduler scheduler;

  Service1(Scheduler scheduler) {
    this.scheduler = scheduler;
  }

  public Observable&lt;Response&gt; call(int arg) {
    return Observable.just(
            new Response(1), //
            new Response(2),
            new Response(3),
            new Response(4))
        .delay(100, TimeUnit.MILLISECONDS, scheduler);
  }
}

class Service2 {
  private final Scheduler scheduler;

  Service2(Scheduler scheduler) {
    this.scheduler = scheduler;
  }

  public Observable&lt;Response&gt; call(int arg) {
    if (arg % 2 == 0) {
      return Observable.just(new Response(100 * arg)).delay(10, TimeUnit.MILLISECONDS, scheduler);

    } else {
      return Observable.error(new RuntimeException(&quot;service 2 error&quot;));
    }
  }
}
</code></pre>
<h2>Note</h2>
<p>Do not use mutable objects. Always ensure, that emitted values are immutable or you get into trouble.</p>
","7057156","","","","","2020-12-08 12:57:31","","","","1","","","","CC BY-SA 4.0"
"65278056","1","","","2020-12-13 16:39:52","","0","30","<p>Map the return type in RXJava</p>
<pre><code>@Queue(ProductTopicConstants.DELETE_PRODUCT)
    public Single&lt;String&gt; Delete(String id) {
        LOG.info(String.format(&quot;Listener --&gt; Delete the document from the database&quot;));
        ProductSearchCriteria criteria = new ProductSearchCriteria();
        criteria.setId(id);
        Bson query = QueryBuilder.QueryBuilder(criteria, Bson.class).get(0);
        return  Single.fromPublisher(
                this.repository.getCollection(ProductConstrants.PRODUCT_COLLECTION_NAME, Product.class)
                        .deleteOne(query)).flatMap(item -&gt;{
                            if(item.getDeletedCount() == 0)
                                return Single.just(&quot;Success&quot;);
                            else
                                return Single.just(id);
        });
    }
</code></pre>
<p>Now return type is <strong>Disposable</strong> type, is it possible to convert to other Type such as <code>Single&lt;String&gt;</code> I tried <code>flatMap</code> and <code>MAP</code>, but when I subscribe the method it is again converted to the <strong>Disposable</strong></p>
","1162409","","1968","","2020-12-14 10:47:33","2020-12-14 10:47:33","Mapping the return type of subscribe to other type","<java><rx-java><rx-java3>","0","11","","","","CC BY-SA 4.0"
"65291131","1","65291478","","2020-12-14 14:53:08","","1","39","<p>I have trouble creating an Observable with the following conditions:</p>
<ol>
<li>Fetch items from API. API can return between 0 and 10 items.</li>
<li>If less then 10 items is returned, request more items from the API.</li>
<li>Repeat 5 times or till 10 or more items are collected.</li>
</ol>
<p>So far I have this Observable:</p>
<pre><code>fetchData().flatMapIterable { dataList }
            .distinct()
            .filter { --some filtering--- }
            .repeat(5)
            .take(10)
            .toList()
</code></pre>
<p>This works ok, with one nitpick. If API returns 9 items and then 10 items, the Observable returns 10 items. The remaining 9 are discarded and I don't want that. Any way to make it work that way?</p>
","1841941","","1841941","","2020-12-14 15:02:01","2020-12-14 15:14:54","Repeat a request X number of times or till Y items is returned","<android><rx-java><reactive-programming><rx-java2><rx-java3>","1","0","","","","CC BY-SA 4.0"
"65291478","2","","65291131","2020-12-14 15:14:54","","1","","<p>Have it collect into a list shared across multiple steps and perform a conditional repeat:</p>
<pre class=""lang-kotlin prettyprint-override""><code>Single.defer {
    var list = ArrayList&lt;T&gt;()
    var count = AtomicInteger()

    fetchData()
    .flatMapIterable { dataList }
    .distinct()
    .filter { --some filtering--- }
    .collectInto(list, { list, item -&gt; list.add(item) })
    .repeatUntil { list.size() &gt;= 10 || count.getAndIncrement() &gt; 4 }
    .ignoreElements()
    .andThen(Single.just(list))
}
</code></pre>
","61158","","","","","2020-12-14 15:14:54","","","","1","","","","CC BY-SA 4.0"
"65336058","1","65336845","","2020-12-17 07:07:29","","2","102","<p>I want every item emitted from flatMap to run on its own thread<br />
This is a simplified example of a real usage where each item will be a url request.<br />
Adding subscribeOn(Schedulers.io()) on each single still run on a single thread<br />
What's the rule here?</p>
<pre class=""lang-java prettyprint-override""><code>
Integer[] array= new Integer[100];
for (int i = 0; i &lt; 100; i++){
    array[i] = i+1;
}

Observable.fromArray(array)
        .flatMapSingle(new Function&lt;Integer, SingleSource&lt;Integer&gt;&gt;() {
            @Override
            public SingleSource&lt;Integer&gt; apply(Integer i) throws Throwable {
                Log.i(TAG, &quot;apply &quot; +  i + &quot; &quot; + Thread.currentThread().getName());
                return Single.just(i).subscribeOn(Schedulers.io());
            }
        })
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread()) 
        .subscribe(new Observer&lt;Integer&gt;() {
            @Override
            public void onSubscribe(@NonNull Disposable d) {
            }

            @Override
            public void onNext(@NonNull Integer i) {
               // Log.i(TAG, &quot;onNext &quot; + Thread.currentThread().getName() + i);
            }

            @Override
            public void onError(@NonNull Throwable e) {

            }

            @Override
            public void onComplete() {
            }
        });
</code></pre>
<p>Result:</p>
<pre><code>2020-12-16 22:54:47.010 10649-10700/com.example.rxjava I/MYTAG: apply 1 RxCachedThreadScheduler-1
2020-12-16 22:54:47.037 10649-10700/com.example.rxjava I/MYTAG: apply 2 RxCachedThreadScheduler-1
2020-12-16 22:54:47.038 10649-10700/com.example.rxjava I/MYTAG: apply 3 RxCachedThreadScheduler-1
2020-12-16 22:54:47.039 10649-10700/com.example.rxjava I/MYTAG: apply 4 RxCachedThreadScheduler-1
2020-12-16 22:54:47.040 10649-10700/com.example.rxjava I/MYTAG: apply 5 RxCachedThreadScheduler-1
2020-12-16 22:54:47.043 10649-10700/com.example.rxjava I/MYTAG: apply 6 RxCachedThreadScheduler-1
2020-12-16 22:54:47.051 10649-10700/com.example.rxjava I/MYTAG: apply 7 RxCachedThreadScheduler-1
2020-12-16 22:54:47.051 10649-10700/com.example.rxjava I/MYTAG: apply 8 RxCachedThreadScheduler-1
</code></pre>
","5777189","","5515287","","2020-12-17 07:38:00","2020-12-17 08:13:16","rxJava how to make flatMap run on multi threads","<java><multithreading><rx-java><rx-java3>","1","2","","","","CC BY-SA 4.0"
"65336845","2","","65336058","2020-12-17 08:13:16","","3","","<p>You were on the right track except the use of <code>just</code>, which takes an <strong>existing</strong> object thus whatever created and computed that object happened before. In this case, it was the lambda of the <code>flatMapSingle</code> which is called from the same thread.</p>
<p>You have to make the computation itself part of the flow to be run in parallel via <code>fromCallable</code> for example:</p>
<pre class=""lang-java prettyprint-override""><code>Observable.fromArray(array)
.flatMapSingle(i -&gt; {
    return Single.fromCallable(() -&gt; {
        Log.i(TAG, &quot;apply &quot; +  i + &quot; &quot; + Thread.currentThread().getName());
        return i + 1000;
    })
    .subscribeOn(Schedulers.io());
})
.observeOn(AndroidSchedulers.mainThread())
// ...
;
</code></pre>
","61158","","","","","2020-12-17 08:13:16","","","","0","","","","CC BY-SA 4.0"
"65340201","1","","","2020-12-17 11:52:06","","0","44","<p>I have a case in my app where I want to fetch from multiple sources and return first valid data. I'd think .concatDelayArray() and .first() would be valid choices for this, but using them causes a crash if any of the non-last Singles throw an error.</p>
<p>Here's my test case:</p>
<pre><code>Single&lt;String&gt; first = Single.fromCallable(() -&gt; {
    throw new Exception(&quot;Random exception&quot;);
});
Single&lt;String&gt; second = Single.fromCallable(() -&gt; &quot;&quot;);
Single&lt;String&gt; third = Single.fromCallable(() -&gt; &quot;value&quot;);

Single.concatArrayDelayError(first, second, third)
    .filter(value -&gt; !value.isEmpty())
    .firstOrError()
    .test()
    .assertValue(&quot;value&quot;);      
</code></pre>
<p>This ends with a crash:</p>
<pre><code>io.reactivex.rxjava3.exceptions.UndeliverableException: The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with.
</code></pre>
<p>Is there a better operator for this case?</p>
","1841941","","","","","2020-12-17 11:52:06","Single.concatDelayArray and .firstOrError() operator","<android><reactive-programming><rx-java2><rx-java3>","0","4","","","","CC BY-SA 4.0"
"65546601","1","65584391","","2021-01-03 04:19:37","","0","32","<p>I have following code:</p>
<pre><code>private static void log(Object msg) {
        System.out.println(
                Thread.currentThread().getName() +
                        &quot;: &quot; + msg);
}

Observable&lt;Integer&gt; naturalNumbers = Observable.create(emitter -&gt; {
            log(&quot;Invoked&quot;); // on main thread
            Runnable r = () -&gt; {
                log(&quot;Invoked on another thread&quot;);
                int i = 0;
                while(!emitter.isDisposed()) {
                    log(&quot;Emitting &quot;+ i);
                    emitter.onNext(i);
                    i += 1;
                }
            };
            new Thread(r).start();
        });
Disposable disposable = naturalNumbers.subscribe(i -&gt; log(&quot;Received &quot;+i));
</code></pre>
<p>So here we have 2 important lambda expressions. First is the one we pass to Observable.create, second is the callback one we pass to Observable.subscribe(). In first lambda, we create a new thread and then emit values on that thread. In second lambda, we have the code to receive those values emitted in first lambda code. I observe that both code are executed on same thread.</p>
<pre><code>Thread-0: Invoked on another thread
Thread-0: Emitting 0
Thread-0: Received 0
Thread-0: Emitting 1
Thread-0: Received 1
Thread-0: Emitting 2
Thread-0: Received 2
</code></pre>
<p>Why is it so? Does RxJava by default run code emitting values(observable) and the code receiving values(observer) on same thread?</p>
","2444661","","286934","","2021-01-05 18:38:54","2021-01-05 18:38:54","Thread execution of value emitting code and value receiving code in RxJava","<java><rx-java3>","1","3","","","","CC BY-SA 4.0"
"65569246","1","65575831","","2021-01-04 20:17:51","","0","58","<p>I've tried the Resilience4J example, but the rate limiter does not seem to obey my demands:</p>
<pre><code>@Test
public void simpleReactiveWithRateLimiter() {
    RateLimiterConfig rateLimiterConfig = RateLimiterConfig.custom()
        .limitForPeriod(5)
        .limitRefreshPeriod(Duration.ofSeconds(1))
        .timeoutDuration(Duration.ofMillis(100))
        .build();
    RateLimiterRegistry rateLimiterRegistry = RateLimiterRegistry.of(rateLimiterConfig);
    RateLimiter rateLimiter = rateLimiterRegistry.rateLimiter(&quot;tenPerSec&quot;, rateLimiterConfig);
    Flowable.interval(1, TimeUnit.MILLISECONDS)
        .takeWhile(f -&gt; f &lt; 100)
        .compose(RateLimiterOperator.of(rateLimiter))
        .blockingSubscribe(i -&gt; log.info(&quot;Received {}&quot;, i));
}
</code></pre>
<p>It still processes 100 items in less then 200ms. I must be doing something wrong, not sure what. Could someone help?</p>
","564092","","564092","","2021-01-04 20:43:40","2021-01-05 09:01:21","Slowing down RxJava3 Flowable with Resilience4j RateLimiter","<rx-java><resilience4j><rx-java3>","1","0","","","","CC BY-SA 4.0"
"65575831","2","","65569246","2021-01-05 09:01:21","","1","","<p>the Resilience4j RateLimiter does not limit the rate of items consumed by one subscription (or emitted by one Flowable).
The RateLimiter limits the number of (concurrent) subscriptions on one Flowable.
For example if many clients want to subscribe to the same upstream Flowable, e.g. HTTP Call.</p>
","5077433","","","","","2021-01-05 09:01:21","","","","1","","","","CC BY-SA 4.0"
"65584391","2","","65546601","2021-01-05 18:17:13","","1","","<p>Let's see, what happens, if you use a <code>Thread</code> to execute a runnable:</p>
<h2>Test</h2>
<pre><code>@Test
  void threadTest() throws Exception {
    log(&quot;main&quot;);
    CountDownLatch countDownLatch = new CountDownLatch(1);

    new Thread(
            () -&gt; {
              log(&quot;thread&quot;);
              countDownLatch.countDown();
            })
        .start();

    countDownLatch.await();
  }
</code></pre>
<h2>Output</h2>
<pre><code>main: main
Thread-0: thread
</code></pre>
<p>It seems, that the main entry point is called from <code>main</code> thread and the newly created <code>Thread</code> is called <code>Thread-0</code>.</p>
<blockquote>
<p>Why is it so? Does RxJava by default run code emitting values(observable) and the code receiving values(observer) on same thread?</p>
</blockquote>
<p>By default <code>RxJava</code> is single-threaded. Therefore the the producer, if not definied differently by <code>observeOn</code>, <code>subscribeOn</code> or different threading layout, will emit values on the <code>consumer</code> (subsriber)-thread. This is because <code>RxJava</code> runs everything on the subscribing stack by default.</p>
<h2>Example 2</h2>
<pre><code>@Test
  void fdskfkjsj() throws Exception {
      log(&quot;main&quot;);

      Observable&lt;Integer&gt; naturalNumbers =
        Observable.create(
            emitter -&gt; {
              log(&quot;Invoked&quot;); // on main thread
              Runnable r =
                  () -&gt; {
                    log(&quot;Invoked on another thread&quot;);
                    int i = 0;
                    while (!emitter.isDisposed()) {
                      log(&quot;Emitting &quot; + i);
                      emitter.onNext(i);
                      i += 1;
                    }
                  };
              new Thread(r).start();
            });
    Disposable disposable = naturalNumbers.subscribe(i -&gt; log(&quot;Received &quot; + i));

    Thread.sleep(100);
  }
</code></pre>
<h2>Output2</h2>
<pre><code>main: main
main: Invoked
Thread-0: Invoked on another thread
Thread-0: Emitting 0
Thread-0: Received 0
Thread-0: Emitting 1
</code></pre>
<p>In your example it is apparent, that the main method is called from the main thread. Furthermore the <code>subscribeActual</code> call is also run on the calling-thread (<code>main</code>). But the <code>Observable#create</code> lambda calls <code>onNext</code> from the newly created thread <code>Thread-0</code>. The value is pushed to the subscriber from the calling thread. In this case, the calling thread is <code>Thread-0</code>, because it calls <code>onNext</code> on the downstream subscriber.</p>
<h2>How to separate producer from consumer?</h2>
<p>Use <code>observeOn</code>/ <code>subscribeOn</code> operators in order to handle concurrency in <code>RxJava</code>.</p>
<h2>Should I use low-level Thread constructs ẁith RxJava?</h2>
<p>No you should not use <code>new Thread</code> in order to seperate the producer from the consumer. It is quite easy to break the contract, that <code>onNext</code> can not be called concurrently (interleaving) and therefore breaking the contract. This is why <code>RxJava</code> provides a construct called <code>Scheduler</code> with <code>Worker</code>s in order to mitigate such mistakes.</p>
<p>Note:
I think this article describes it quite well: <a href=""http://introtorx.com/Content/v1.0.10621.0/15_SchedulingAndThreading.html"" rel=""nofollow noreferrer"">http://introtorx.com/Content/v1.0.10621.0/15_SchedulingAndThreading.html</a> . Please note this is Rx.NET, but the principle is quite the same. If you want to read about concurrency with <code>RxJava</code> you could also look into Davids Blog (<a href=""https://akarnokd.blogspot.com/2015/05/schedulers-part-1.html"" rel=""nofollow noreferrer"">https://akarnokd.blogspot.com/2015/05/schedulers-part-1.html</a>) or read this Book (Reactive Programming with RxJava <a href=""https://www.oreilly.com/library/view/reactive-programming-with/9781491931646/"" rel=""nofollow noreferrer"">https://www.oreilly.com/library/view/reactive-programming-with/9781491931646/</a>)</p>
","7057156","","","","","2021-01-05 18:17:13","","","","0","","","","CC BY-SA 4.0"
"65608109","1","65609213","","2021-01-07 07:21:06","","0","42","<h2>This is the flow I need to follow to create a file record in my server</h2>
<p>Black arrow is flow<br />
Red arrow is dependency<br />
This is one big function<br />
<a href=""https://i.stack.imgur.com/XEx12.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/XEx12.png"" alt=""enter image description here"" /></a></p>
<h2>I need help designing this in rxjava that make them happen sequentially while the later single is  able to get the reference</h2>
<p>I can create some single for each time taking task</p>
<pre class=""lang-java prettyprint-override""><code>public static Single&lt;byte[]&gt; processData(byte[] fileData))
public static Single&lt;APIResponse&gt; callAPI(String id, byte[] processedData)
public static Single&lt;UploadResponse&gt; uploadData(String url)
</code></pre>
<p>This is my attempt<br />
I tried using flatMap's resultSelector as described here<br />
<a href=""https://stackoverflow.com/questions/41786439/retrofit-and-rxjava-how-to-combine-two-requests-and-get-access-to-both-results"">Retrofit and RxJava: How to combine two requests and get access to both results?</a></p>
<pre class=""lang-java prettyprint-override""><code>

    private static Single&lt;FinalResult&gt; bigFunction(String id, int type, String jwt, byte[] fileData){

        return processData(fileData).flatMap(new Function&lt;byte[], SingleSource&lt;APIResponse&gt;&gt;() {
            @Override
            public SingleSource&lt;APIResponse&gt; apply(byte[] processedData) throws Throwable {
                return callAPI(id, processedData);
            }
        }, new BiFunction&lt;byte[], APIResponse, UploadResponse&gt;() {
            @Override
            public FinalResult apply(byte[] processData, APIResponse apiResponse) throws Throwable {
                if (processData.size() &gt; LIMIT){
                    uploadData(apiResponse.getUrl());  // I am stuck here how to return a FinalResult() after this uploadData() is complete
                }else{
                   return new FinalResult(); // if no need to upload, done
                }
                
            }
        });
    }

</code></pre>
","5777189","","","","","2021-01-07 22:19:55","rxJava how to make sequential call while being able to acess previous parameter","<rx-java><rx-java3>","1","0","0","","","CC BY-SA 4.0"
"65609213","2","","65608109","2021-01-07 08:49:56","","1","","<p>If you don't need a result then you can <a href=""http://reactivex.io/RxJava/javadoc/io/reactivex/Single.html#ignoreElement--"" rel=""nofollow noreferrer""><code>ignoreElement()</code></a> to convert your flow into <code>Completable</code> and use <a href=""http://reactivex.io/RxJava/javadoc/io/reactivex/Completable.html#toSingleDefault-T-"" rel=""nofollow noreferrer""><code>toSingleDefault(...)</code></a> function:</p>
<pre><code>uploadData(apiResponse.getUrl())
    .ignoreElement()
    .toSingleDefault(new FinalResult());
</code></pre>
<p>In case you just need to convert the response into <code>FinalResult</code> then you can use <code>map(...)</code>:</p>
<pre><code>uploadData(apiResponse.getUrl())
     .map(uploadResponse -&gt; new FinalResult(uploadResponse));
</code></pre>
<p>In case you have to utilize the result from <code>uploadData(..)</code> with any external calls or whatever then <code>flatMap()</code> is your choice:</p>
<pre><code>uploadData(apiResponse.getUrl())
    .flatMap(uploadResponse -&gt; {
        // do whatever you want with response
        return Single.just(new FinalResult(uploadResponse));
    });
</code></pre>
<p><strong>UPDATE:</strong></p>
<p>In your case it can be simplified:</p>
<pre><code>return processData(fileData)
    .flatMap(processedData -&gt; {
        Single&lt;FinalResult&gt; postProcessing;
        if (processedData.length &gt; LIMIT) {
            postProcessing = uploadData(apiResponse.getUrl())
                                .map(response -&gt; new FinalResult(response));
        } else {
            postProcessing = Single.just(new FinalResult());
        }
        return callAPI(id, processedData)
            .ignoreElement()
            .andThen(postProcessing);
            
    });
</code></pre>
","5178057","","5178057","","2021-01-07 22:19:55","2021-01-07 22:19:55","","","","2","","","","CC BY-SA 4.0"
"65730487","1","","","2021-01-15 04:22:47","","0","172","<p>In RxJava what is the difference between Emitter interface and Observer interface ? both have same methods</p>
<pre><code>public interface Emitter&lt;@NonNull T&gt; {

    /**
     * Signal a normal value.
     * @param value the value to signal, not {@code null}
     */
    void onNext(@NonNull T value);

    /**
     * Signal a {@link Throwable} exception.
     * @param error the {@code Throwable} to signal, not {@code null}
     */
    void onError(@NonNull Throwable error);

    /**
     * Signal a completion.
     */
    void onComplete();
}


public interface Observer&lt;@NonNull T&gt; {

    /**
     * Provides the {@link Observer} with the means of cancelling (disposing) the
     * connection (channel) with the {@link Observable} in both
     * synchronous (from within {@link #onNext(Object)}) and asynchronous manner.
     * @param d the {@link Disposable} instance whose {@link Disposable#dispose()} can
     * be called anytime to cancel the connection
     * @since 2.0
     */
    void onSubscribe(@NonNull Disposable d);

    /**
     * Provides the {@link Observer} with a new item to observe.
     * &lt;p&gt;
     * The {@link Observable} may call this method 0 or more times.
     * &lt;p&gt;
     * The {@code Observable} will not call this method again after it calls either {@link #onComplete} or
     * {@link #onError}.
     *
     * @param t
     *          the item emitted by the Observable
     */
    void onNext(@NonNull T t);

    /**
     * Notifies the {@link Observer} that the {@link Observable} has experienced an error condition.
     * &lt;p&gt;
     * If the {@code Observable} calls this method, it will not thereafter call {@link #onNext} or
     * {@link #onComplete}.
     *
     * @param e
     *          the exception encountered by the Observable
     */
    void onError(@NonNull Throwable e);

    /**
     * Notifies the {@link Observer} that the {@link Observable} has finished sending push-based notifications.
     * &lt;p&gt;
     * The {@code Observable} will not call this method if it calls {@link #onError}.
     */
    void onComplete();

}
</code></pre>
","3551773","","","","","2021-01-15 08:32:11","In RxJava what is the difference between Emitter interface and Observer interface ? both have same methods","<java><rx-java><rx-java2><reactive><rx-java3>","2","0","","","","CC BY-SA 4.0"
"65809269","1","","","2021-01-20 12:09:05","","0","47","<p>I have AsyncTask where I perform downloading of data. But as Async is deprecated in Android 11 I want to switch from Async to RxJava. I want to use Volley with RxJava, is this possible as I am not getting any good solution to perform downloading of data using Volley and RxJava replacing AsyncTask&lt;&gt;</p>
<pre><code>public class DataDownloadAsyncTask extends AsyncTask&lt;Void,Void,Void&gt; { 

    @Override
    protected void onPreExecute() {
        super.onPreExecute();
                         
    }

    @Override
    protected Void doInBackground(Void... void) { 
       //do work
       downloadData(); // use volley for downloading and get response from api as json data

       return null;
    }

    @Override
    protected void onPostExecute(Void void) {
        super.onPostExecute();
    }
}

</code></pre>
<p>This is my AsyncTask&lt;&gt; I want to replace this with RxJava3 or RxJava
How to achieve this??????</p>
<p>Please help as I am new in implementing RxJava.</p>
","7113477","","7113477","","2021-01-21 14:26:08","2021-01-21 14:26:08","How to replace AsyncTask with RxJava for downloading data from URL in Android","<android><android-asynctask><rx-java><deprecated><rx-java3>","0","0","","","","CC BY-SA 4.0"
"65856535","1","65861311","","2021-01-23 06:49:23","","3","111","<p>I have an Observable, <code>source</code>, that may emit items at unpredictable times. I'm trying to use it to build another Observable that reliably emits its values every 500ms.</p>
<p>Let's say that <code>source</code> emits values at these times:</p>
<ul>
<li>100ms - first item</li>
<li>980ms - second item</li>
<li>1020ms - third item</li>
<li>1300ms - fourth item, etc.</li>
</ul>
<p>I'd like to &quot;smooth&quot; this stream, so that I get outputs like:</p>
<ul>
<li>500ms - first item</li>
<li>1000ms - second item</li>
<li>1500ms - third item</li>
<li>2000ms - fourth item</li>
</ul>
<p>A naive approach might be to just add a delay in between emissions of source items. But, that won't create evenly spaced intervals, like I want.</p>
<p>I've tried various combinations of <code>.timer()</code>, <code>.interval()</code>, and <code>.flatMap()</code>, but nothing promising, yet.</p>
","695787","","","","","2021-01-28 21:40:23","Build ""Heartbeat"" Observable from Unpredictable Source Observable","<rxjs><rx-java><reactive-programming><rx-java2><rx-java3>","3","1","","","","CC BY-SA 4.0"
"65861311","2","","65856535","2021-01-23 16:00:52","","1","","<h3>For a source emitting faster than your interval</h3>
<p><code>zip</code> your source with an <code>interval</code> of the required time span.</p>
<pre class=""lang-ts prettyprint-override""><code>zip(source, interval(500)).pipe(
  map(([value, _]) =&gt; value)  // only emit the source value
)
</code></pre>
<p><a href=""https://i.stack.imgur.com/4Q76j.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/4Q76j.png"" alt=""enter image description here"" /></a></p>
<p><code>zip</code> emits the 1st item from <code>source</code> with the 1st item from <code>interval</code>, then the 2nd item from <code>source</code> with the 2nd item from <code>interval</code> and so on. If the output observable should only emit when <code>interval</code> emits, the Nth value from <code>source</code> has to arrive <strong>before</strong> the Nth value from <code>interval</code>.</p>
<p><strong>Potential Problem:</strong>
If your <code>source</code> emits slower than <code>interval</code> at some point (i.e. the Nth value from <code>source</code> arrives <strong>after</strong> the Nth value from <code>interval</code>) then <code>zip</code> will emit directly without waiting for the next time <code>interval</code> emits.</p>
<pre class=""lang-ts prettyprint-override""><code>// the 5th/6th value from source arrive after the 5th/6th value from interval
                                              v    v
source:       -1--------2-3---4---------------5----6-----
interval:     -----1-----2-----3-----4-----5-----6-----7-
zip output:   -----1-----2-----3-----4--------5----6-----
                   ✓     ✓     ✓     ✓        ⚠️    ⚠️
// emits 5 and 6 don't happen when interval emits
</code></pre>
<h3>For a source emitting at any rate</h3>
<pre class=""lang-ts prettyprint-override""><code>function emitOnInterval&lt;T&gt;(period: number): MonoTypeOperatorFunction&lt;T&gt; {
  return (source: Observable&lt;T&gt;) =&gt;
    defer(() =&gt; {
      let sourceCompleted = false;
      const queue = source.pipe(
        tap({ complete: () =&gt; (sourceCompleted = true) }),
        scan((acc, curr) =&gt; (acc.push(curr), acc), []) // collect all values in a buffer
      );
      return interval(period).pipe(
        withLatestFrom(queue), // combine with the latest buffer
        takeWhile(([_, buffer]) =&gt; !sourceCompleted || buffer.length &gt; 0), // complete when the source completed and the buffer is empty
        filter(([_, buffer]) =&gt; buffer.length &gt; 0), // only emit if there is at least on value in the buffer
        map(([_, buffer]) =&gt; buffer.shift()) // take the first value from the buffer
      );
    });
}

source.pipe(
  emitOnInterval(500)
)
</code></pre>
<pre class=""lang-ts prettyprint-override""><code>// the 5th/6th value from source arrive after the 5th/6th value from interval
                                              v    v
source:       -1--------2-3---4---------------5----6-----
interval:     -----1-----2-----3-----4-----5-----6-----7-
output:       -----1-----2-----3-----4-----------5-----6-
                   ✓     ✓     ✓     ✓           ✓     ✓   
// all output emits happen when interval emits
</code></pre>
<p><a href=""https://stackblitz.com/edit/rxjs-qdlktm?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-qdlktm?file=index.ts</a></p>
","9423231","","9423231","","2021-01-28 21:40:23","2021-01-28 21:40:23","","","","0","","","","CC BY-SA 4.0"
"65908423","1","","","2021-01-26 20:02:13","","1","250","<p>The problem is that I can use an <code>Observer</code> but I can't use a <code>SingleObserver</code>. It gives me this error:</p>
<pre><code>Inferred type 'E' for type parameter 'E' is not within its bound; should implement 'io.reactivex.rxjava3.core.Observer&lt;? super com.xxx.Network.Response.ResponseLogin&gt;'
</code></pre>
<p>and</p>
<pre><code>.subscribeWith(new SingleObserver&lt;ResponseLogin&gt;(){
                ^
  required: E
  found: &lt;anonymous SingleObserver&lt;ResponseLogin&gt;&gt;
  reason: inferred type does not conform to upper bound(s)
    inferred: &lt;anonymous SingleObserver&lt;ResponseLogin&gt;&gt;
    upper bound(s): Observer&lt;? super ResponseLogin&gt;
  where E,T are type-variables:
    E extends Observer&lt;? super ResponseLogin&gt; declared in method &lt;E&gt;subscribeWith(E)
    T extends Object declared in class Observable
</code></pre>
<p>Here are some implementation details:</p>
<pre><code>//build.gradle
    implementation &quot;io.reactivex.rxjava3:rxandroid:3.0.0&quot;
    implementation &quot;io.reactivex.rxjava3:rxjava:3.0.2&quot;
</code></pre>
<pre><code>//ApiInterface.java
import io.reactivex.rxjava3.core.Observable;
...
public interface ServerAPIInterface {
    // For POST request
    @FormUrlEncoded
    @POST(&quot;/login&quot;)
    public Observable&lt;ResponseLogin&gt; login(
        // the POST params to server
        @Field(&quot;user_email&quot;) String user_email,
        @Field(&quot;user_password&quot;) String user_password
    );
</code></pre>
<p>and the fault is at:</p>
<pre><code>import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;
import io.reactivex.rxjava3.core.Observer;
import io.reactivex.rxjava3.core.SingleObserver;
import io.reactivex.rxjava3.disposables.CompositeDisposable;
import io.reactivex.rxjava3.disposables.Disposable;
import io.reactivex.rxjava3.schedulers.Schedulers;
...
        myApiInterface
                .login(myUserEmail, myPassword)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeWith(new SingleObserver&lt;ResponseLogin&gt;() {
                    @Override
                    public void onSuccess(ResponseLogin data) {
                        // update the adapter
                    }


                    @Override
                    public void onSubscribe(Disposable d) {
                        disposables.add(d);
                    }

                    @Override
                    public void onError(Throwable e) {
                        // display an error message
                    }
                });
</code></pre>
<p>If I replace <code>SingleObserver</code> with <code>Observer</code> (and implement all the required <code>onXXX()</code> methods it compiles OK. But I want a single observer.</p>
<p>Shall I downgrade to rxjava2 (untested)?</p>
<p>I suspect my imports are confused.</p>
<p>it seems there are 2 <code>SingleObserver</code>, another one is at <code>io.reactivex.SingleObserver</code>.</p>
<p>I did try to use these imports and skipped the <code>rxjava3</code> prefix for most of them. However <code>AndroidSchedulers</code> can only be found in <code>io.reactivex.rxjava3.android.schedulers.AndroidSchedulers</code>.</p>
","385390","","","","","2021-01-26 20:02:13","RxJava3 on Android/Java: problem using SingleObserver (but Observer is fine!)","<android><observers><rx-java3>","0","4","","","","CC BY-SA 4.0"
"66092910","1","","","2021-02-07 20:43:16","","0","18","<p>Trying to get preloaded content for further displaying it in WebView but get some very small piece of html like this</p>
<p><a href=""https://i.stack.imgur.com/ub8gG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ub8gG.png"" alt=""enter image description here"" /></a></p>
<p>What am I doing wrong?</p>
<p>Thanks.</p>
<pre><code>public void function exec () {
        WebView webView = R.id.webView;
        webView.getSettings().setJavaScriptEnabled(true);

        webView.getSettings().setJavaScriptCanOpenWindowsAutomatically(true);


        getPreloadData(link).subscribe(htmlData -&gt; {
            if (htmlData.length() &gt; 0) {
                webView.loadData(htmlData, &quot;text/html&quot;, &quot;UTF-8&quot;);
            }
        });
}

private Observable&lt;String&gt; getPreloadData(String link) {
    return Observable.fromCallable(() -&gt; {
        StringBuilder buffer = new StringBuilder(&quot;&quot;);
        try {
            URL url = new URL(&quot;https://oracle.com&quot;);
            url.getContent();
            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));

            while (reader.readLine() != null) {
                buffer.append(reader.readLine());
            }
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        System.out.println(&quot;BUFFER ::: &quot; + buffer.toString());
        return buffer.toString();
    }).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());
}
</code></pre>
<p>System out shows this and this is more but still not all data</p>
<p><a href=""https://i.stack.imgur.com/7UpZe.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7UpZe.png"" alt=""enter image description here"" /></a></p>
","4974229","","","","","2021-02-07 20:43:16","Android: How to get correct html string via BufferedReader?","<android><bufferedreader><rx-java3>","0","1","","","","CC BY-SA 4.0"
"66120330","1","","","2021-02-09 13:51:39","","1","55","<p>I'm trying to share the same Flowable to multiple subscribers based on an id, while each subscriber can cancel the subscription when it needs in order to unsubscribe. A new subscription should be created if all of the subscribers for a certain id unsubscribed and then another one tries to subscribe for that id. The following code is written in Kotlin, trying to achieve this functionality.</p>
<pre><code>class SharedFlowProvider() {
    private val flowProvider = FlowProvider()
    private val eventFlowById = HashMap&lt;String, Flowable&lt;ComputedProperties&gt;&gt;()

    @Synchronized
    override fun subscribeToProperties(subscriber: CancellableSubscriber&lt;ComputedProperties&gt;, id: String){
        eventFlowById.computeIfAbsent(id) { buildFlowable(id) }
                .subscribe(orderBasedSubscriber)
    }

    private fun buildFlowable(id: String) = 
        flowProvider.getFlowable(id)
            .doFinally { removeSubscription(id) }
            .share()

    @Synchronized
    private fun removeSubscription(id: String) {
        eventFlowById.remove(id)
    }
}
</code></pre>
<p>The problem appears when there is a cancel followed by a subscribe on the same id.
I discovered a possible deadlock in this approach, because of the way the FlowableRefCount returned by share works. In the underlying implementation, FlowableRefCount uses a synchronization mechanism in its subscribeActual and cancel methods, and while it isn't obvious at first sight, the action from the doFinally method is run inside that locking mechanism. This is a little bit counterintuitive, since in the doFinally doc it says that:</p>
<blockquote>
<p>Note that the onFinally action is shared between subscriptions and as such should be thread-safe.</p>
</blockquote>
<p>Because of this, the following scenario appeared:</p>
<ul>
<li>lock on the FlowableRefCount instance through cancel</li>
<li>subscribeToProperties called on the same id as in the cancel</li>
<li>subscribeToProperties blocked when calling subscribe(and then subscribeActual), since the lock is already acquired on the FlowableRefCount through cancel</li>
<li>call on removeOrderSubscription blocked, since the lock on SharedFlowProvider is already taken through subscribeToProperties method</li>
</ul>
<p>I've also tried to split the locking from subscribeToProperties method, using a ConcurrentHashMap in the following way:</p>
<pre><code>private val eventFlowById = ConcurrentHashMap&lt;String, Flowable&lt;ComputedProperties&gt;&gt;()

override fun subscribeToProperties(subscriber: CancellableSubscriber&lt;ComputedProperties&gt;, id: String){
    val flow = eventFlowById.computeIfAbsent(id) { buildFlowable(id) }
    flow.subscribe(orderBasedSubscriber)
    //the flow associated with an id could be removed by a cancel done before the subscribe call, so we need to make sure it is added to the map
    eventFlowById.computeIfAbsent(id) { flow }
}
</code></pre>
<p>But in this approach, if we have a subscribe followed by a quick cancel done before the last line from the method, we could end up with the flow being put in the map, even though we don't have subscribers to it.</p>
<p>I would appreciate some ideas on how I could achieve this functionality without a deadlock or a race condition.</p>
<p>Thank you</p>
","15175374","","15175374","","2021-02-09 14:01:57","2021-02-09 14:01:57","RxJava3 - How to avoid deadlock when using doFinally with a thread-safe action while using the share operator?","<rx-java><rx-java2><rx-java3>","0","1","","","","CC BY-SA 4.0"
"66177410","1","","","2021-02-12 18:46:12","","0","75","<p>I have a issue about Flowable. I've tried using a library of mongodb to connect with java reactivity (not spring-data), and I need to update a attribute in object of flowable, this att is &quot;downloadInCsv&quot;.
I've used io.reactivex.rxjava3 and mongodb-driver-reactivestreams
My attempt of solution was:</p>
<pre><code>public Flowable&lt;LoanEntity&gt; updateStatus(Flowable&lt;LoanEntity&gt; loans) {
    return loans.flatMap(loan -&gt; {
      try (MongoClient client = this.mongoConnection.getClient()) {
        return Single.fromPublisher(client.getDatabase(this.databaseName)
                                          .getCollection(&quot;LoanRequest&quot;,LoanEntity.class)
                                          .updateOne(Filters.eq(&quot;_id&quot;, loan.getId()),
                                                     new Document(&quot;$set&quot;, new Document(&quot;downloadInCsv&quot;,Boolean.TRUE))))
                    .map(result -&gt; {
                         loan.setDownloadInCsv(true);
                         return loan;
                        })
                     ;
                                                 
      } catch (Exception e) {
        log.info(&quot;error&quot; + e.getLocalizedMessage());
        return Flowable.empty();
      }
    });
  }
</code></pre>
<p>the problem is Single.fromPublisher or maybe the flatMap in first flowable, because I couldn't use map to return the same loan, or maybe all of my code is wrong.</p>
<p>Thanks for your answers.</p>
","10508681","","","","","2021-02-12 18:46:12","RxJava - Mongodb - In flowable, execute a publisher method one by one","<java><mongodb><rx-java3>","0","0","","","","CC BY-SA 4.0"
"66234860","1","68869750","","2021-02-17 02:19:28","","0","49","<p>We upgraded our Auth0 Android library from 1.30 to 2.0 and some of our unit tests that use OkHttp's <code>MockWebServer</code> broke.</p>
<ol>
<li>The first test fails with a <code>java.lang.ExceptionInInitializerError</code> which in turn is caused by <code>java.lang.RuntimeException: Method getMainLooper in android.os.Looper not mocked.</code></li>
<li>Next three tests fail with <code>java.lang.NoClassDefFoundError: Could not initialize class com.auth0.android.request.internal.DefaultThreadSwitcher</code></li>
<li>The rest of the tests are stuck until cancelled.</li>
</ol>
<p>For context, we use RxJava3 and Android Jetpack libs such as LiveData in our code base, and Retrofit for REST API.</p>
<p>I tried adding
<code>@ExtendWith(InstantExecutorExtension::class, RxImmediateScheduler::class)</code> in the class declaration like this:</p>
<pre><code>@ExtendWith(InstantExecutorExtension::class, RxImmediateScheduler::class)
class AuthManagerTest {
</code></pre>
<p>But afterwards, all tests return with &quot;Test ignored&quot; in the logs:</p>
<pre><code>Test ignored.

java.lang.InstantiationException
    at sun.reflect.InstantiationExceptionConstructorAccessorImpl.newInstance(InstantiationExceptionConstructorAccessorImpl.java:48)
    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
    at org.junit.platform.commons.util.ReflectionUtils.newInstance(ReflectionUtils.java:513)
    at org.junit.platform.commons.util.ReflectionUtils.newInstance(ReflectionUtils.java:488)
    at org.junit.jupiter.engine.extension.MutableExtensionRegistry.registerExtension(MutableExtensionRegistry.java:176)
    at java.util.ArrayList.forEach(ArrayList.java:1257)
    at org.junit.jupiter.engine.extension.MutableExtensionRegistry.createRegistryFrom(MutableExtensionRegistry.java:117)
    at org.junit.jupiter.engine.descriptor.ExtensionUtils.populateNewExtensionRegistryFromExtendWithAnnotation(ExtensionUtils.java:77)
    at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.prepare(ClassBasedTestDescriptor.java:143)
    at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.prepare(ClassBasedTestDescriptor.java:78)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$prepare$1(NodeTestTask.java:111)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.prepare(NodeTestTask.java:111)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:79)
    at java.util.ArrayList.forEach(ArrayList.java:1257)
    at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129)
    at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84)
    at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)
    at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
    at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)
    at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108)
    at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)
    at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)
    at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)
    at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)
    at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96)
    at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75)
    at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:69)
    at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)
    at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230)
    at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58)
</code></pre>
<p>Here is a code snippet on how we initialize the test class:</p>
<pre><code>class AuthManagerTest {

    ...
    private lateinit var authManager: AuthManager
    private lateinit var config: Auth0Config
    private lateinit var server: MockWebServer

    @MockK
    private lateinit var context: Context

    @MockK
    private lateinit var credentialsManager: SecureCredentialsManager

    ...

    ...

    @BeforeEach
    fun setup() {
        MockKAnnotations.init(this)
        every { context.getSharedPreferences(any(), any()) } returns mockk()
        every { credentialsManager.authToken } returns null
        every { credentialsManager.userId } returns null
        every { credentialsManager.refreshToken } returns null
        every { credentialsManager.saveCredentials(any()) } just Runs

        ...

        mockkObject(Credentials.Companion)
        every { Credentials.fromAuth0Creds(any(), any()) } returns mockk()
        server = MockWebServer().apply {
            // we didn't use useHttps before but with the new version of Auth0 it seems https is mandatory
            useHttps(testSslSocketFactory(), false)
            start()
        }
...
}
</code></pre>
<p>Here is the first test that fails:</p>
<pre><code>    @Test
    fun `sendEmailCode returns EmailSent when response is successful`() {
        server.enqueue(mockResponse(200, email_success_response))
        val emailResult = authManager.sendEmailCode(&quot;me@example.org&quot;).blockingGet()
                as EmailResult.EmailSent
        assertEquals(&quot;me@example.org&quot;, emailResult.email)
        assertNoToken()
    }
</code></pre>
","4612653","","4612653","","2021-02-17 02:43:49","2021-08-21 02:52:56","Unit tests involving MockWebServer fails with Auth0's Android library version 2","<android><auth0><junit5><mockk><rx-java3>","1","0","","","","CC BY-SA 4.0"
"66283257","1","","","2021-02-19 18:39:01","","0","24","<p>using kotlin, having code</p>
<pre><code>fun fetchRemoteDataApi(): Single&lt;RemoteDataResponse&gt; = networkApi.getData()

    // it is just a retrofit
    @GET(&quot;.../api/getData&quot;)
    fun getData() : Single&lt;RemoteDataResponse&gt;

fun mergeApiWithDb(): Completable = fetchRemoteDataApi()
            .zipWith(localDao.getAll())
            .flatMapCompletable { (remoteData, localData) -&gt;
                doMerge(remoteData, localData) //&lt;== return a Completable
            }

</code></pre>
<p>the code flow:</p>
<pre><code>    val mergeApiDbCall = mergeApiWithDb().onErrorComplete().cache() //&lt;=== would like do some inspection at this level
    PublishSubject.create&lt;Unit&gt;().toFlowable(BackpressureStrategy.LATEST)
                .compose(Transformers.flowableIO())
                .switchMap {
                    //merge DB with api, or local default value first then listen to DB change
                    mergeApiDbCall.andThen(listAllTopics())
                            .concatMapSingle { topics -&gt; remoteTopicUsers.map { topics to it } }
                }
                .flatMapCompletable { (topics, user) -&gt;
                    // do something return Completable
                }
                .subscribe({
                    ...
                }, { throwable -&gt;
                    ...
                })
</code></pre>
<p>and when making the call</p>
<pre><code>val mergeApiDbCall = mergeApiWithDb().onErrorComplete().cache()
</code></pre>
<p>the question is if would like to inspect on the <code>Singles&lt;RemoteDataResponse&gt;</code> returned from <code>fetchRemoteDataApi()</code> (i.e. using Log.i(...) to printout the content of <code>RemoteDataResponse</code>, etc.), either in got error or success case, how to do it?</p>
<pre><code>/// the functions
fun listAllTopics(): Flowable&lt;List&lt;String&gt;&gt; = localRepoDao.getAllTopics()

// which a DAO:
    @Query(&quot;SELECT topic FROM RemoteDataTable WHERE read = 1&quot;)
    fun getAllTopics(): Flowable&lt;List&lt;String&gt;&gt;

///
private val remoteTopicUsers: Single&lt;List&lt;User&gt;&gt;
        get() {
            return Single.create {
                networkApi.getTopicUsers(object : ICallback.IGetTopicUsersCallback {
                    override fun onSuccess(result: List&lt;User&gt;) = it.onSuccess(result)
                    override fun onError(errorCode: Int, errorMsg: String?) = it.onError(Exception(errorCode, errorMsg))
                })
            }
        }
</code></pre>
","2987953","","","","","2021-02-19 21:48:05","rxjava, how to inspect the result of a Single","<kotlin><rx-java3><rx-java-completable>","1","0","","","","CC BY-SA 4.0"
"66356884","1","","","2021-02-24 18:36:40","","0","37","<p>I was reading the parallel flows documentation <a href=""https://github.com/ReactiveX/RxJava/wiki/Parallel-flows"" rel=""nofollow noreferrer"">here</a> and it mentioned:</p>
<blockquote>
<p>By default, the parallelism level is set to the number of available CPUs (Runtime.getRuntime().availableProcessors()) and the prefetch amount from the sequential source is set to Flowable.bufferSize() (128). Both can be specified via overloads of parallel().</p>
</blockquote>
<p>I still don't understand the purpose of this prefetch, and why it is so big. I guess this means the operators below it will hold onto more than 1 emissions (by default 128). However, I can't imagine this is a good idea, since downstream operators will effectively be single threaded until we have more than 128 emissions from upstream? (e.g. if we have 130, the first 128 will be prefetched by one thread, and the last 2 will be given to the second one. And all other threads will do nothing.).</p>
<p>I guess smaller objects in faster flowables should have a larger prefetch, since the cost of passing data between the rx chain will cost relatively more, so we want prefetch to be higher. I am not sure which numbers to pick here though.</p>
","7365866","","7365866","","2021-02-24 18:47:36","2021-02-24 18:47:36","What is/ how to select ""prefetch"" for parallel flowable?","<rx-java2><rx-java3>","0","3","","","","CC BY-SA 4.0"
"66437641","1","","","2021-03-02 10:31:16","","0","313","<p>I'm using RxPermissions to handle permissions inside my project.</p>
<pre><code> 'com.github.tbruyelle:rxpermissions:0.12'
 'io.reactivex.rxjava3:rxjava:3.0.4'
</code></pre>
<p>This is my code for handling the <code>CAMERA</code> permission:</p>
<pre><code>new RxPermissions((FragmentActivity) context).request(Manifest.permission.CAMERA)
            .subscribe(granted -&gt; {
                if(granted){
                    Intent packageReceiveIntent = new Intent(context, ReceivePackageActivity.class);
                    context.startActivity(packageReceiveIntent);
                }
            });
</code></pre>
<p>This gets called <code>onClick</code> event.</p>
<p>For some reason the code inside the <code>Consumer</code> is not called after the <code>permission</code> is <code>granted</code> and I have to tap on the button twice to open the activity.</p>
<p>I've used the same code in a different part of the application and it works fine, I don't get it why in a Fragment it works fine and in another it doesn't.</p>
<p>I also tried it like this but was unsuccessful:</p>
<pre><code> new RxPermissions(requireActivity()).request(Manifest.permission.CAMERA)
            .subscribeOn(Schedulers.newThread())
            .observeOn(Schedulers.computation())
            .subscribe(aBoolean -&gt; {
                if (aBoolean) {
                    Intent packageReceiveIntent = new Intent(requireActivity(), ReceivePackageActivity.class);
                    requireActivity().startActivity(packageReceiveIntent);
                }
            });
</code></pre>
","3170486","","","","","2021-07-26 06:40:45","RxPermissions not called after permission granted","<android><rx-java><android-permissions><rx-java3><rxpermissions>","2","3","","","","CC BY-SA 4.0"
"66506281","1","","","2021-03-06 13:40:43","","2","101","<p>I'm aware it's a complex question that cannot have a definite answer without posting a few hundreds of lines of code, which is why I'm looking for help through general ideas and pointers.</p>
<p>I have a Room <code>@Query</code> returning a RxJava3 <code>Flowable&lt;List&lt;...&gt;&gt;</code> which I subscribe to on RxJava thread <code>Schedulers.io()</code>, and observe from an activity-scoped <code>ViewModel</code> on RxJava thread <code>AndroidSchedulers.mainThread()</code>. The data is then stored in my ViewModel as <code>LiveData</code>, which plays better than RxJava when it comes to handle Android components' lifecycle.</p>
<p>The idea is to have a clean and immediate data update pattern, not to have to handle disposal and re-subscription separately on each activity or fragment lifecycle event such as <code>onPaused</code> and <code>onResumed</code>, and being updated in the background even when my activity is hidden in order to avoid that awful refresh lag when returning to my activity. I was pretty amazed at that design pattern. I still am, but I'm beginning to have doubts.</p>
<p>When starting another activity with the same design pattern, I do change a value and immediately get an updated <code>List&lt;...&gt;</code> from the other <code>ViewModel</code>. Different <code>Activity</code>, different <code>ViewModel</code>, same design, same database table. When returning to the first <code>Activity</code>, I find that the new data does never get updated: Room did not emit any update even though the data set has changed. I have to dispose and subscribe again in order to see the new data.</p>
<p>So my question is: any pointer on where the source of my problem might be?! Is there something rotten in the core of this design pattern? Something I misunderstood about all those things are supposed to work together? Is it just a mistake of mine due to some threading issue? Or should I fill a bug report for Room?</p>
<p>I tried to observe another non-Room RxJava3 observable from the <code>ViewModel</code> of my first <code>Activity</code>, and it does get updates when its data set is updated.</p>
<p>By the way, I also use Hilt in order to inject eveything as <code>@Singleton</code>.</p>
<p>Thank you for your time :-)</p>
","9521509","","","","","2021-03-12 09:38:21","Why doesn't my Android ViewModel's Room RxJava3 Flowable publish any result when my Activity is paused?","<android-room><android-lifecycle><android-viewmodel><rx-java3>","1","0","1","","","CC BY-SA 4.0"
"66513357","1","","","2021-03-07 05:00:22","","0","57","<p>Trying to use Flowable, do then, and finally using RxJava3.</p>
<pre><code>public String post(Publisher&lt;CompletedFileUpload&gt; files) {
    return Flowable.fromPublisher(files).doOnNext(file -&gt; {
        MultipartBody requestBody = MultipartBody.builder()
                .addPart(&quot;file&quot;, file.getFilename(), MediaType.MULTIPART_FORM_DATA_TYPE, file.getBytes())
                .addPart(&quot;id&quot;, &quot;asdasdsds&quot;)
                .build();
    }).doOnComplete((value) -&gt; {
        return this.iProduct.post(requestBody);
    });
}
</code></pre>
<p>The above code has error, But what I am trying to achieve is described in the below scenarios</p>
<ol>
<li>Iterate on files</li>
<li>add file.getFilename() and bytes to requestBody</li>
<li>Then call the this.iProduct.post(requestBody) which returns the string</li>
<li>Finally return the string value</li>
</ol>
","1162409","","","","","2021-03-08 15:15:48","Do then and finally with Flowable reactive x Java","<java><rx-java><rx-java2><reactivex><rx-java3>","1","4","","","","CC BY-SA 4.0"
"66517449","1","66527019","","2021-03-07 14:14:06","","0","56","<p>I have the below method</p>
<pre><code>public Maybe&lt;HttpResponse&lt;?&gt;&gt; post(Publisher&lt;CompletedFileUpload&gt; files) {
        MultipartBody.Builder requestBody = MultipartBody.builder();
        return Flowable.fromPublisher(files).flatMap(file -&gt; {
            requestBody
                    .addPart(&quot;file&quot;, file.getFilename(), MediaType.TEXT_PLAIN_TYPE, file.getBytes())
                    .addPart(&quot;id&quot;, &quot;asdasdsds&quot;);
            return this.iProductClient.post(requestBody.build());
        });
    }
</code></pre>
<p>The return type from <code>this.iProductClient.post(requestBody.build());</code> is <code>Maybe&lt;HttpResponse&lt;?&gt;&gt;</code></p>
<p>How can I convert the below code to return <code>Maybe&lt;HttpResponse&lt;?&gt;&gt;</code>, currently the below method has error</p>
<pre><code>return Flowable.fromPublisher(files).flatMap(file -&gt; {
            requestBody
                    .addPart(&quot;file&quot;, file.getFilename(), MediaType.TEXT_PLAIN_TYPE, file.getBytes())
                    .addPart(&quot;id&quot;, &quot;asdasdsds&quot;);
            return this.iProductClient.post(requestBody.build());
        });
</code></pre>
","1162409","","","","","2021-03-08 09:12:32","Convert Publisher<CompletedFileUpload> to Maybe<HttpResponse<?>>","<java><rx-java><rx-java2><reactivex><rx-java3>","1","2","","","","CC BY-SA 4.0"
"66527019","2","","66517449","2021-03-08 09:12:32","","1","","<p>You can use <code>collect</code> and then flatmap in the requrest sending:</p>
<pre class=""lang-java prettyprint-override""><code>return Flowable.fromPublisher(files)
    .collect(MultipartBody::builder, (requestBody, file) -&gt; {
        requestBody
            .addPart(&quot;file&quot;, file.getFilename(), MediaType.TEXT_PLAIN_TYPE, file.getBytes())
            .addPart(&quot;id&quot;, &quot;asdasdsds&quot;);
    })
    .flatMapMaybe(requestBody -&gt; iProductClient.post(requestBody.build()))
    ;
</code></pre>
","61158","","","","","2021-03-08 09:12:32","","","","6","","","","CC BY-SA 4.0"
"66562033","1","66569832","","2021-03-10 09:41:17","","0","38","<p>Perform task and finally return the value using Flowable rxjva3. I have below code</p>
<pre><code>public Maybe&lt;List&lt;String&gt;&gt; uploadObject(Publisher&lt;CompletedFileUpload&gt; images) {
        Storage storage = StorageOptions.getDefaultInstance().getService();
        var returnValue = Flowable.fromPublisher(images)
                .collect((List&lt;String&gt; returnImages, CompletedFileUpload image) -&gt; {
                    BlobId blobId = BlobId.of(googleUploadObjectConfiguration.bucketName(), image.getName());
                    BlobInfo blobInfo = BlobInfo.newBuilder(blobId).build();
                    Blob updatedImage = storage.create(blobInfo, image.getBytes());
                    returnImages.add(updatedImage.getName());
                })
                .flatMapMaybe(returnImages -&gt; Maybe.just(returnImages));
    }
</code></pre>
<p>Basically, it iterates and uploads the image to google storage. Then the return media URL should return to the list of String. Tried the below code however, the return type is <code>Maybe&lt;U&gt;</code>. What is the proper way of performing this?</p>
<p>Update 1</p>
<pre><code>Flowable.fromPublisher(images).collect(ArrayList::new, (returnImages, image) -&gt; {
            BlobId blobId = BlobId.of(googleUploadObjectConfiguration.bucketName(), image.getName());
            BlobInfo blobInfo = BlobInfo.newBuilder(blobId).build();
            Blob updatedImage = storage.create(blobInfo, image.getBytes());
            returnImages.add(updatedImage.getName());
            LOG.info(
                    String.format(&quot;File %s uploaded to bucket %s as %s&quot;, image.getName(),
                            googleUploadObjectConfiguration.bucketName(), image.getName())
            );
        }).flatMapMaybe((returnImages)-&gt; List.of(returnImages));
</code></pre>
<p>This is also not correct, the return type should be <code>Maybe&lt;List&lt;String&gt;&gt;</code></p>
","1162409","","1162409","","2021-03-10 16:03:21","2021-03-10 17:23:40","Flowable to perform task and return List of String Rx Java ReactiveX","<java><rx-java><rx-java2><reactivex><rx-java3>","1","2","","","","CC BY-SA 4.0"
"66569832","2","","66562033","2021-03-10 17:23:40","","1","","<p>From the comments, use the two argument <code>collect</code> and then use <code>toMaybe</code>. You may have to reinforce the collection type as shown below:</p>
<pre class=""lang-java prettyprint-override""><code>Flowable.fromPublisher(images)
.&lt;List&lt;String&gt;&gt;collect(ArrayList::new, (returnImages, image) -&gt; {
    BlobId blobId = BlobId.of(googleUploadObjectConfiguration.bucketName(), image.getName());
    BlobInfo blobInfo = BlobInfo.newBuilder(blobId).build();
    Blob updatedImage = storage.create(blobInfo, image.getBytes());
    returnImages.add(updatedImage.getName());
    LOG.info(
        String.format(&quot;File %s uploaded to bucket %s as %s&quot;, image.getName(),
                            googleUploadObjectConfiguration.bucketName(), image.getName())
            );
}).toMaybe();
</code></pre>
","61158","","","","","2021-03-10 17:23:40","","","","0","","","","CC BY-SA 4.0"
"66576755","1","66580513","","2021-03-11 05:01:52","","3","4463","<p>Getting an UndeliverableException while using <code>completable</code></p>
<pre><code>public Completable createBucketWithStorageClassAndLocation() {
        return Completable.complete()
                .doFinally(() -&gt; {
            Bucket bucket =
                    storage.create(
                            BucketInfo.newBuilder(googleUploadObjectConfiguration.bucketName())
                                    .setStorageClass(storageClass)
                                    .setLocation(googleUploadObjectConfiguration.locationName())
                                    .build());       
        }).doOnError(error -&gt; LOG.error(error.getMessage()));
    }
</code></pre>
<p>The exception is thrown from the Google storage which is correct, But trying to handle on <code>doOnError</code> method</p>
<pre><code>Caused by: com.google.cloud.storage.StorageException: You already own this bucket. Please select another name.
</code></pre>
<p>RXJava exception</p>
<pre><code>io.reactivex.exceptions.UndeliverableException: The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | com.google.cloud.storage.StorageException: You already own this bucket. Please select another name.
    at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)
    at io.reactivex.internal.operators.completable.CompletableDoFinally$DoFinallyObserver.runFinally(CompletableDoFinally.java:99)
    at io.reactivex.internal.operators.completable.CompletableDoFinally$DoFinallyObserver.onComplete(CompletableDoFinally.java:79)
    at io.micronaut.reactive.rxjava2.RxInstrumentedCompletableObserver.onComplete(RxInstrumentedCompletableObserver.java:64)
    at io.reactivex.internal.disposables.EmptyDisposable.complete(EmptyDisposable.java:68)
    at io.reactivex.internal.operators.completable.CompletableEmpty.subscribeActual(CompletableEmpty.java:27)
    at io.reactivex.Completable.subscribe(Completable.java:2309)
    at io.micronaut.reactive.rxjava2.RxInstrumentedCompletable.subscribeActual(RxInstrumentedCompletable.java:51)
    at io.reactivex.Completable.subscribe(Completable.java:2309)
    at io.reactivex.internal.operators.completable.CompletableDoFinally.subscribeActual(CompletableDoFinally.java:43)
    at io.reactivex.Completable.subscribe(Completable.java:2309)
    at io.micronaut.reactive.rxjava2.RxInstrumentedCompletable.subscribeActual(RxInstrumentedCompletable.java:51)
    at io.reactivex.Completable.subscribe(Completable.java:2309)
    at io.reactivex.internal.operators.completable.CompletablePeek.subscribeActual(CompletablePeek.java:51)
    at io.reactivex.Completable.subscribe(Completable.java:2309)
    at io.micronaut.reactive.rxjava2.RxInstrumentedCompletable.subscribeActual(RxInstrumentedCompletable.java:51)
    at io.reactivex.Completable.subscribe(Completable.java:2309)
    at io.reactivex.Completable.subscribe(Completable.java:2410)
    at fete.bird.StartUp.onApplicationEvent(StartUp.java:24)
    at fete.bird.StartUp.onApplicationEvent(StartUp.java:12)
    at io.micronaut.context.DefaultBeanContext.notifyEventListeners(DefaultBeanContext.java:1323)
    at io.micronaut.context.DefaultBeanContext.publishEvent(DefaultBeanContext.java:1308)
    at io.micronaut.http.server.netty.NettyHttpServer.fireStartupEvents(NettyHttpServer.java:507)
    at io.micronaut.http.server.netty.NettyHttpServer.start(NettyHttpServer.java:350)
    at io.micronaut.http.server.netty.NettyHttpServer.start(NettyHttpServer.java:113)
    at io.micronaut.runtime.Micronaut.lambda$start$2(Micronaut.java:77)
    at java.base/java.util.Optional.ifPresent(Optional.java:176)
    at io.micronaut.runtime.Micronaut.start(Micronaut.java:75)
    at io.micronaut.runtime.Micronaut.run(Micronaut.java:311)
    at io.micronaut.runtime.Micronaut.run(Micronaut.java:297)
    at fete.bird.FeteBirdServiceApplication.main(FeteBirdServiceApplication.java:16)
</code></pre>
<p>From the rxjava documentation <a href=""https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-2.0#error-handling"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling</a> I need to handle the error in the application.</p>
<p>I need to write the below code,</p>
<pre><code>/ If Java 8 lambdas are supported
RxJavaPlugins.setErrorHandler(e -&gt; { });
</code></pre>
<p>My question is where should I write this code. I have a Micronaut application using java or this is the only way to handle the exception.</p>
","1162409","","1162409","","2021-03-11 05:10:00","2021-06-22 10:16:13","io.reactivex.exceptions.UndeliverableException The exception could not be delivered to the consumer because it has already canceled/disposed","<java><rx-java><rx-java2><reactivex><rx-java3>","2","0","","","","CC BY-SA 4.0"
"66580513","2","","66576755","2021-03-11 10:17:19","","1","","<p>Use <code>Completable.fromAction</code> and perhaps try-catch the exception instead of that <code>doFinally</code> contraption:</p>
<pre class=""lang-java prettyprint-override""><code>Completable.fromAction(() -&gt; {
    try {
        Bucket bucket = storage.create(
            BucketInfo.newBuilder(googleUploadObjectConfiguration.bucketName())
                      .setStorageClass(storageClass)
                      .setLocation(googleUploadObjectConfiguration.locationName())
                      .build()); 
    } catch (Throwable error) {
        LOG.error(error.getMessage());
    }
})
</code></pre>
","61158","","","","","2021-03-11 10:17:19","","","","2","","","","CC BY-SA 4.0"
"66781251","1","66786464","","2021-03-24 12:40:06","","0","23","<p>I get a list of the index composition (102 tickers) and I want to find out detailed information about them, but out of 102 queries, no more than 10 are always executed, and the ticker is randomly selected. All requests are executed via retrofit2 using RxJava3. What could be the problem?
Here is the ViewModel code:</p>
<pre><code>var price: MutableLiveData&lt;CompanyInfoModel&gt; = MutableLiveData()

    fun getCompanyInfoObserver(): MutableLiveData&lt;CompanyInfoModel&gt; {
        return price
    }

    fun makeApiCall(ticker: String) {
        val retrofitInstance = RetrofitYahooFinanceInstance.getRetrofitInstance().create(RetrofitService::class.java)
        retrofitInstance.getCompanyInfo(ticker)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(getCompanyInfoObserverRx())
    }

    private fun getCompanyInfoObserverRx(): Observer&lt;CompanyInfoModel&gt; {
        return object : Observer&lt;CompanyInfoModel&gt; {
            override fun onComplete() {
                // Hide progress bar
            }

            override fun onError(e: Throwable?) {
                price.postValue(null)
            }

            override fun onNext(t: CompanyInfoModel?) {
                price.postValue(t)
            }

            override fun onSubscribe(d: Disposable?) {
                // Show progress bar
            }
        }
    }
</code></pre>
<p>Here is the initialization of the model:</p>
<pre><code>companyInfoModel = ViewModelProvider(this).get(CompanyInfoViewModel::class.java)
        companyInfoModel.getCompanyInfoObserver().observe(this, Observer&lt;CompanyInfoModel&gt; { it -&gt;
            if(it != null) {
                retrieveList(Helper.companyInfoToStock(it))
            }
            else {
                Log.e(TAG, &quot;Error in fetching data&quot;)
            }
        })
</code></pre>
<p>And here is the request method itself:</p>
<pre><code>fun getCompanyInfo(ticker: String) {
        companyInfoModel.makeApiCall(ticker)
    }
</code></pre>
","15162021","","","","","2021-03-24 17:42:11","Random processing of retrofit2 requests","<android><kotlin><retrofit2><rx-java3>","1","2","","","","CC BY-SA 4.0"
"66786464","2","","66781251","2021-03-24 17:42:11","","0","","<p>Thank you, Pawel. The problem really turned out to be in the API limit, I changed the provider and everything started working as it should.</p>
","15162021","","","","","2021-03-24 17:42:11","","","","0","","","","CC BY-SA 4.0"
"66804625","1","","","2021-03-25 17:25:39","","0","81","<p>Have a controller:</p>
<pre><code>@Controller
@CircuitBreaker
public class ExampleController {

    @Get(&quot;/&quot;)
    public Single&lt;String&gt; endpoint() {
        return Single.fromSupplier(this::serviceCall);
    }

    private String serviceCall() {
        throw new RuntimeException();
    }
}
</code></pre>
<p>Fist call works absolutely fine. However, second call won't fail with the same exception, if happens when CircuitBreaker is open. Instead, it will case CircuitOpenException in micronaut infrastructure that will result in broken request.</p>
<p>Is any workaround for that issue?</p>
<p>Full example: <a href=""https://github.com/artfable/micronaut-test"" rel=""nofollow noreferrer"">https://github.com/artfable/micronaut-test</a></p>
<p><strong>Update:</strong></p>
<p>Created an issue: <a href=""https://github.com/micronaut-projects/micronaut-rxjava3/issues/87"" rel=""nofollow noreferrer"">https://github.com/micronaut-projects/micronaut-rxjava3/issues/87</a></p>
<p>Annotation works fine with Single from rxjava2. So, as a workaround, use service that will have the annotation and return rxjava2 Single, convert to rxjava3 Single in a controller.</p>
","10955240","","10955240","","2021-03-26 11:57:07","2021-03-26 11:57:07","Wrong behaviour for CircuitBreaker in Micronaut","<micronaut><rx-java3>","0","3","","","","CC BY-SA 4.0"
"66809505","1","66811630","","2021-03-26 00:40:43","","0","47","<p>Can anyone …</p>
<ol>
<li>explain why the following code keeps retrying indefinitely, once <code>retryWhen</code> is called?</li>
<li>correct the code to stop retrying when <code>Random.nextBoolean()</code>
returns <code>true</code>?</li>
</ol>
<p>I think there is a 50% chance that <code>retryWhen</code> is called because of <code>Random.nextBoolean()</code>. However, once it is called, it goes into an infinite loop.</p>
<pre class=""lang-kotlin prettyprint-override""><code>import io.reactivex.rxjava3.core.Observable
import kotlin.random.Random

fun main() {
    Observable
        .just(Unit)
        .flatMap {
            if (Random.nextBoolean()) {
                Observable.just(Unit)
            } else {
                Observable.error(Throwable())
            }.retryWhen {
                it.flatMap {
                    println(&quot;retryWhen&quot;)
                    Observable.just(Unit)
                }
            }
        }
        .subscribe()
}
</code></pre>
<p>Output:</p>
<pre><code>retryWhen
retryWhen
retryWhen
⋮
(continued)
</code></pre>
","10867055","","","","","2021-03-26 06:55:46","RxJava's retryWhen unexpectedly keeps retrying forever","<kotlin><rx-java><rx-java3><retrywhen>","2","0","","","","CC BY-SA 4.0"
"66811630","2","","66809505","2021-03-26 05:48:10","","2","","<ol>
<li><p>You've applied the <code>retryWhen</code> to the result of the execution of either branch of the if-statement.</p>
</li>
<li><p>Chain the <code>retryWhen</code> operator to the stream produced by <code>flatMap</code>:</p>
</li>
</ol>
<p>e.g.</p>
<pre><code>Observable
  .just(Unit)
  .flatMap {
    if(Random.nextBoolean()) {
      Observable.just(Unit)
    } else {
      Observable.error(Throwable())
    }
  }
  .retryWhen {
      it.flatMap {
        println(&quot;retryWhen&quot;)
        Observable.just(Unit)
      }
  }
  .subscribe()
</code></pre>
","2539472","","","","","2021-03-26 05:48:10","","","","0","","","","CC BY-SA 4.0"
"66821383","1","","","2021-03-26 17:08:08","","0","33","<p>I am trying to find any video or course about RxJava and RxFirebase, but all I find is an endless number of videos repeating the same stuff, like an introduction.</p>
<p>Is there any course with a bit advanced stuff about rxAndroid and RxJava especially about RxFirebase?</p>
<p>tnx</p>
","13560904","","","","","2021-03-26 17:08:08","How to Login Firebase user with RxJava","<firebase><android-studio><rx-java2><rx-android><rx-java3>","0","0","","","","CC BY-SA 4.0"
"66911519","1","","","2021-04-01 21:01:45","","1","353","<p>For example, let's say I have a WebFilter that writes some Context</p>
<pre><code>public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
  return chain.filter(exchange)
    .contextWrite(Context.of(&quot;my-context&quot;, &quot;foobar&quot;));
}
</code></pre>
<p>Downstream, my controller does this</p>
<pre><code>@GetMapping(path = &quot;test&quot;)
public Mono&lt;String&gt; test() throws Exception {
  final Mono&lt;ContextView&gt; contextMono = Mono.deferContextual(Mono::just);
  return contextMono.flatMap(ctx -&gt; Mono.just(ctx.get(&quot;my-context&quot;)));
}
</code></pre>
<p>The above all works fine.</p>
<p>What if I wanted to return a Single from the controller method? I tried using <code>RxJava3Adapter.monoToSingle()</code> but it breaks the reactor chain.</p>
<pre><code>@GetMapping(path = &quot;test&quot;)
public Single&lt;String&gt; test() throws Exception {
  final Mono&lt;ContextView&gt; contextMono = Mono.deferContextual(Mono::just);
  return RxJava3Adapter.monoToSingle(
    contextMono.flatMap(ctx -&gt; Mono.just(ctx.get(&quot;my-context&quot;))));
}
</code></pre>
<p>My guess is that since I'm not returning the Mono, nothing subscribes to this contextMono inside of the RxJava3Adapter. Is that the right explanation?</p>
<p>Is there any way to return a Single while having the Context be passed in?</p>
","1007922","","6051176","","2021-04-02 15:01:58","2021-04-02 15:13:41","Why context is not propagated to (RxJava) Single from (Reactor) Mono?","<java><rx-java><spring-webflux><project-reactor><rx-java3>","1","1","","","","CC BY-SA 4.0"
"66929272","1","66929928","","2021-04-03 08:50:01","","0","36","<p>I am using RxJava3 in my project and I can't write a request, I've been wrestling my head for several hours.</p>
<p>I have List&lt;Stream&gt; and have a function that returns a Single&lt;List&lt;Topic&gt;&gt; by Stream, i want to get a Single&lt;Map&lt;Stream, List&lt;Topic&gt;&gt;&gt;,</p>
<pre><code>fun getMockTopics(streamId: Long): Single&lt;List&lt;Topic&gt;&gt; {
        return Single.just(listOf(Topic(1, &quot;&quot;)))
    }
</code></pre>
<pre><code>typealias SteamTopics = Map&lt;Stream, List&lt;Topic&gt;&gt;

override fun getTopics(streams: List&lt;Stream?&gt;): Single&lt;SteamTopics&gt; {
        return Observable.fromCallable { streams.filterNotNull() }.flatMapIterable { it }
            .map { stream -&gt;
                Pair(stream, getMockTopics(streamId = stream.streamId))
            }.flatMap {
                TODO(&quot;???&quot;)
            }
            .toMap({ it.first }, { it.second })
    }
</code></pre>
","15177513","","15177513","","2021-04-03 09:02:39","2021-04-03 10:12:40","RxJava 3 Mapper","<android><kotlin><rx-java><rx-java3>","1","1","","","","CC BY-SA 4.0"
"66929928","2","","66929272","2021-04-03 10:12:40","","0","","<pre><code>fun getMockTopics(streamId: Long): Observable&lt;List&lt;Topic&gt;&gt; {
    return Observable.just(listOf(Topic(1, &quot;&quot;)))
}

override fun getTopics(streams: List&lt;Stream?&gt;): Single&lt;SteamTopics&gt; {
    return Observable.fromCallable { streams.filterNotNull() }.flatMapIterable { it }
        .flatMap({ stream -&gt;
            getMockTopics(streamId = stream.streamId)
        }, { stream, topics -&gt;
            Pair(stream, topics)
        }).toMap({ it.first }, { it.second })
}
</code></pre>
","15177513","","","","","2021-04-03 10:12:40","","","","0","","","","CC BY-SA 4.0"
"67063811","1","67064111","","2021-04-12 18:29:54","","0","46","<p>I am trying to use RxJava and return a <code>Single&lt;Long&gt;</code> when an insert to my room database is successful, but I have the following error when compiling:</p>
<pre><code>Not sure how to handle insert method's return type.
    Single&lt;Long&gt; insert(List&lt;T&gt; obj);
</code></pre>
<p>This interface is extended by all my Dao classes:</p>
<pre><code>import androidx.room.Insert;
import androidx.room.OnConflictStrategy;
import io.reactivex.rxjava3.core.Single;
    
public interface MyAppDao&lt;T&gt; {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    Single&lt;Long&gt; insertOrReplace(T obj);

    @Insert(onConflict = OnConflictStrategy.IGNORE)
    Single&lt;Long&gt; insert(List&lt;T&gt; obj);
}
</code></pre>
<p><strong>UPDATE</strong></p>
<p>The trouble is that when I just have 1 insert method, it works, but when I have 2 or more (as you can see, for example to insert a <code>List&lt;T&gt;</code>) it does not work...</p>
<p>And my build.gradle:</p>
<pre><code>plugins {
    id 'com.android.application'
}

apply plugin: 'dagger.hilt.android.plugin'

android {
    compileSdkVersion 30
    buildToolsVersion &quot;30.0.1&quot;
defaultConfig {
    applicationId &quot;com.gimlite&quot;
    minSdkVersion 21
    targetSdkVersion 30
    versionCode 1
    versionName &quot;1.0&quot;

    testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;
}

buildTypes {
    release {
        minifyEnabled false
        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
    }
}
compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
}

buildFeatures {
    dataBinding true
}

}

dependencies {
def room_version = &quot;2.3.0-alpha01&quot;
def work_manager_version = &quot;2.3.4&quot;
def nav_version = &quot;2.1.0&quot;
def rxjava_version = &quot;3.0.7&quot;
def rxandroid_version = &quot;3.0.0&quot;;
def retrofit_version = &quot;2.9.0&quot;;
def lifecycle_version = &quot;2.2.0&quot;
def timber_version = &quot;4.7.1&quot;;

implementation 'androidx.appcompat:appcompat:1.2.0'
implementation 'com.google.android.material:material:1.3.0'
implementation 'androidx.annotation:annotation:1.1.0'

//UI
implementation 'androidx.constraintlayout:constraintlayout:2.0.4'

//ViewModel &amp;&amp; LiveData
implementation 'androidx.lifecycle:lifecycle-livedata-ktx:2.3.0'
implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.0'
implementation &quot;android.arch.lifecycle:extensions:1.1.0&quot;
implementation &quot;android.arch.lifecycle:viewmodel:$lifecycle_version&quot;
implementation &quot;android.arch.lifecycle:reactivestreams:$lifecycle_version&quot;

//Room
implementation &quot;androidx.room:room-runtime:$room_version&quot;
annotationProcessor &quot;androidx.room:room-compiler:$room_version&quot;
implementation &quot;androidx.room:room-rxjava3:$room_version&quot;

//Dagger Core
implementation &quot;com.google.dagger:dagger:2.28&quot;
annotationProcessor &quot;com.google.dagger:dagger-compiler:2.28&quot;

//Dagger Android
api 'com.google.dagger:dagger-android:2.27'
api 'com.google.dagger:dagger-android-support:2.27'
annotationProcessor 'com.google.dagger:dagger-android-processor:2.27'

//Hilt
implementation &quot;com.google.dagger:hilt-android:2.28-alpha&quot;
annotationProcessor &quot;com.google.dagger:hilt-android-compiler:2.28-alpha&quot;

//Retrofit
implementation &quot;com.squareup.retrofit2:adapter-rxjava3:$retrofit_version&quot;
implementation &quot;com.squareup.retrofit2:retrofit:$retrofit_version&quot;
implementation &quot;com.squareup.retrofit2:converter-gson:$retrofit_version&quot;

//OkHttp
implementation 'com.squareup.okhttp3:okhttp:4.2.2'
implementation 'com.squareup.okhttp3:logging-interceptor:4.2.2'

//ReactiveX
implementation &quot;io.reactivex.rxjava3:rxjava:$rxjava_version&quot;
implementation &quot;io.reactivex.rxjava3:rxandroid:$rxandroid_version&quot;

//RecyclerView
implementation 'androidx.recyclerview:recyclerview:1.0.0'

//PlayServices
implementation 'com.google.android.gms:play-services-location:17.0.0'

//Fragment Navigation
implementation &quot;androidx.navigation:navigation-fragment:$nav_version&quot;
implementation &quot;androidx.navigation:navigation-ui:$nav_version&quot;

//Soap
implementation files('libs/ksoap2-android-assembly-3.6.4-jar-with-dependencies.jar') {
    configurations {
        compile.exclude module: 'okhttp'
    }
}

//Timber (Logging)
implementation &quot;com.jakewharton.timber:timber:$timber_version&quot;

//Stetho
implementation 'com.facebook.stetho:stetho:1.5.1'

//TESTING
testImplementation 'junit:junit:4.+'
androidTestImplementation 'androidx.test.ext:junit:1.1.1'
androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
}
</code></pre>
<hr />
","9811147","","9811147","","2021-04-15 19:31:02","2021-04-15 19:31:02","Error when returning Single<Long> using Room @Insert method","<android><rx-java><android-room><rx-java2><rx-java3>","1","2","","","","CC BY-SA 4.0"
"67064111","2","","67063811","2021-04-12 18:53:37","","1","","<p>It seems like using RxJava3 types specifically are not supported in <code>2.3.0-alpha01</code> but support has been added in <code>2.3.0-alpha02</code>.</p>
<p>Specifically the <a href=""https://developer.android.com/jetpack/androidx/releases/room#2.3.0-alpha02"" rel=""nofollow noreferrer"">release notes</a> for <code>2.3.0-alpha02</code> say:</p>
<blockquote>
<p>RxJava3 Support: Room now supports RxJava3 types. Similar to RxJava2 you can declare DAO methods whose return type are Flowable, Single, Maybe and Completable. Additionally a new artifact androidx.room:room-rxjava3 is available to support RxJava3. (b/152427884)</p>
</blockquote>
","10082297","","","","","2021-04-12 18:53:37","","","","4","","","","CC BY-SA 4.0"
"67130089","1","","","2021-04-16 17:59:02","","0","29","<p>How to print elements in buffer when using backpressure:</p>
<pre><code> Flowable.range(1, 1000)
                .onBackpressureBuffer(20, () -&gt;{}, BackpressureOverflowStrategy.DROP_OLDEST)
                .onBackpressureDrop(v -&gt; System.out.println(&quot;Dropped.. :&quot; + v))
                .delay(0, TimeUnit.MILLISECONDS, Schedulers.io())
                .doOnNext(value -&gt; System.out.println(&quot;got &quot; + value))
                .map(value -&gt; {
                    try {
                        TimeUnit.SECONDS.sleep(1);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    return value;
                })
                .observeOn(Schedulers.newThread(),false, 20)
                .subscribe(
                        value -&gt; System.out.println(&quot;handled:  &quot; + value),
                        Throwable::printStackTrace,
                        () -&gt; System.out.println(&quot;completed&quot;)
                );
        sleep(10000);
</code></pre>
<p><strong>the output:</strong><br />
got 1<br />
Dropped.. :21<br />
Dropped.. :22<br />
Dropped.. :23<br />
Dropped.. :24<br />
Dropped.. :25<br />
.<br />
.<br />
.</p>
<p><strong>I want</strong><br />
got 1<br />
elements in buffer: 2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20<br />
Dropped.. :21<br />
.<br />
.<br />
.</p>
<p>I do not know if that is possible or not.
Please help I'am new in reactive programming<br />
Thanks</p>
","9782778","","","","","2021-04-16 17:59:02","Print Elements on buffer, Flowable rxJava","<java><rx-java><rx-java3>","0","3","","","","CC BY-SA 4.0"
"67210808","1","67211728","","2021-04-22 09:45:02","","0","22","<p><a href=""http://reactivex.io/documentation/contract.html"" rel=""nofollow noreferrer"">The Observable Contract</a></p>
<blockquote>
<p>Observables must issue notifications to observers serially (not in parallel). They may issue these notifications from different threads, but there must be a formal happens-before relationship between the notifications.</p>
</blockquote>
<p>When it says &quot;happens-before&quot;, Does it mean that all the effects by the last onNext notification, (e.g. change an shared state in Observer.onNext() method), will be totally visible to the next onNext notification, just like <strong>happens-before guarantee in Java Memory Model</strong>?</p>
<p>After reading source code of SerializedObserver(RxJava version 3.0.11), I found downstream.onNext(t) method is not called in the synchronized code block. So, could I say the answer is not?</p>
","8415067","","","","","2021-04-22 10:47:10","RxJava: When ""The Observable Contract"" says ""happens-before"", what does it actually mean?","<concurrency><thread-safety><observable><happens-before><rx-java3>","1","0","","","","CC BY-SA 4.0"
"67211728","2","","67210808","2021-04-22 10:47:10","","1","","<blockquote>
<p>will be totally visible to the next onNext notification, just like happens-before guarantee in Java Memory Model?</p>
</blockquote>
<p>Yes.</p>
<blockquote>
<p>SerializedObserver [...] I found downstream.onNext(t) method is not called in the synchronized code block. So, could I say the answer is not?</p>
</blockquote>
<p>Still yes. The <a href=""https://github.com/ReactiveX/RxJava/blob/3.x/src/main/java/io/reactivex/rxjava3/observers/SerializedObserver.java#L98-L112"" rel=""nofollow noreferrer"">synchronized (this)</a> ensures visibility as well as the property that only one thread will be calling <code>onNext</code> because of the <code>emitting</code> flag.</p>
","61158","","","","","2021-04-22 10:47:10","","","","1","","","","CC BY-SA 4.0"
"67253100","1","67262156","","2021-04-25 11:54:23","","0","29","<p>I have Java TCP client Socket reading InputStream and distributing data packets to various parts of the application via RxJava PublishSubject. This works.</p>
<p>Also sometimes I write to OutputStream. Commands are converted into single data packet(byte[]) and pushed onto the stream. For this I use</p>
<pre><code>public void writeToSocket(byte[] packet) {
    Completable.fromAction(() -&gt; {
         outputStream.write(packet);
         outputStream.flush();
    }).subscribeOn(Schedulers.io()).subscribe(); 
}
</code></pre>
<p>Now I want to execute</p>
<pre><code>    outputStream.write(packet);
    outputStream.flush();
</code></pre>
<p>in such a way that meets below condition</p>
<blockquote>
<ol>
<li>Though source packet is getting created from multiple places (with different commands) simultaneously, execute above for each packet with a delay of 50 milliseconds. Ideally queue-up the packets and execute with delay.</li>
</ol>
</blockquote>
<pre><code>Example:
Place1: createCommand1(), 
Place2: createCommand1(), createCommand4()
Place3: createCommand1(), createCommand2(), .... createCommand10()
</code></pre>
<p>Is there any way to achieve this using RxJava. Thanks in advance!</p>
","7494831","","","","","2021-04-26 07:02:43","RxJava receive data packets from multiple source and write to OutputStream with delay between each packet","<rx-java><rx-java2><rx-java3>","1","0","","","","CC BY-SA 4.0"
"67262156","2","","67253100","2021-04-26 07:02:43","","1","","<p>You could use a serialized <code>PublishSubject</code> to collect up bytes, then use <code>concatMapCompletable</code> to execute the write and then have a delay:</p>
<pre class=""lang-java prettyprint-override""><code>var subject = PublishSubject.&lt;byte[]&gt;create().toSerialized();

subject
  .concatMapCompletable(bytes -&gt; 
       Completable.fromAction(() -&gt; {
           outputStream.write(packet);
           outputStream.flush();
       })
       .subscribeOn(Schedulers.io())
       .andThen(Completable.timer(50, TimeUnit.MILLISECONDS))
   )
   .subscribe();
</code></pre>
<p>Alternatively, if you don't mind dedicating a single thread to the emission at all times, you could just execute the write and sleep in <code>doOnNext</code>:</p>
<pre class=""lang-java prettyprint-override""><code>var subject = PublishSubject.&lt;byte[]&gt;create().toSerialized();

subject
  .observeOn(Schedulers.io())
  .doOnNext(packet -&gt; {
     outputStream.write(packet);
     outputStream.flush();
     Thread.sleep(50);
  })
  .subscribe();
</code></pre>
","61158","","","","","2021-04-26 07:02:43","","","","1","","","","CC BY-SA 4.0"
"67336233","1","67366674","","2021-04-30 15:07:51","","0","29","<p>I'm using RxJava3 and I have the following code setup where I want to emit an item in the middle, between the first and second flowable. Is there a way to do it?</p>
<pre><code>firstFlowable.firstElement()
//I want to emit an item here
.flatMap { secondFlowable.firstElement() }
</code></pre>
<p>The reason I want to do this is because after <code>firstFlowable</code> initializes there is a long period of time until the <code>secondFlowable</code> initializes and I want to notify the UI with a message that there the operation has started and I'm waiting on the data computation from <code>secondFlowable</code>.</p>
<p>I tried to use <code>startWithItem</code>, but that initializes my whole chain at the beginning, but I want to emit only after <code>firstFlowable</code> produces its first value.</p>
","3140006","","1115491","","2021-06-18 05:32:05","2021-06-18 05:32:05","How to emit an item while waiting another Flowable to emit","<java><observable><reactive-programming><rx-java3>","2","2","","","","CC BY-SA 4.0"
"67366674","2","","67336233","2021-05-03 09:40:59","","0","","<p>You could use merge to inject a value, then act based on the value type. In case <code>secondFlowable</code> finishes immediately, you may want to avoid displaying the string after all via <code>takeUntil</code>.</p>
<pre class=""lang-java prettyprint-override""><code>firstFlowable.firstElement()
.flatMap(v -&gt;
    Maybe.&lt;Object&gt;merge(
        secondFlowable.firstElement(),
        Maybe.just(&quot;Second in progress&quot;)
    )
)
.takeUntil(v -&gt; !(v instanceof String))
.observeOn(mainThread())
.subscribe(v -&gt; {
   if (v instanceof String) {
       // display message here
   } else {
       // cast and display results of second
   }
});
</code></pre>
","61158","","","","","2021-05-03 09:40:59","","","","1","","","","CC BY-SA 4.0"
"67457058","1","","","2021-05-09 11:13:14","","0","20","<p><strong>Overview</strong>
I'm trying my best to follow the MVVM pattern. In my data model, I have an entity 'languages' and its corresponding DAO accessed via repository. This repository, in turn, feeds my viewmodel, and is instantiated via factory within my fragment. Or, from the other way, my fragment -&gt; ViewModelFactory -&gt; ViewModel -&gt; Repository -&gt; DAO -&gt; Entity</p>
<p>I'm a bit confused as to where ArrayAdapters 'fit' into the MVVM pattern. The particular fragment is designed to display a bunch of fields (name, language, etc) to serve as a 'profile' creation page within the app.</p>
<p><strong>Problem:</strong>
I'm trying to populate a spinner with a list of languages such that when a language in the spinner is selected, a corresponding value is actually used in software (think: text-value-pair). I don't really know what I'm doing, but I'm failing as fast as I can. At the moment, I'm running into the following error in my fragment onViewCreated method:</p>
<p><em>Android Studio Error: &quot;Cannot resolve method 'observe' in 'Observable'&quot;</em></p>
<p><strong>CODE</strong></p>
<p><strong>languages entity</strong></p>
<pre><code>@Entity
public class languages {
    @PrimaryKey(autoGenerate = true)
    @NonNull
    public Long langNo;
    public String langDesc;
    @ColumnInfo(defaultValue = &quot;CURRENT_TIMESTAMP&quot;)
    public Long langUpdatedDate;
    @ColumnInfo(defaultValue = &quot;CURRENT_TIMESTAMP&quot;)
    public Long langCreatedDate;
}
</code></pre>
<p><strong>DAO</strong></p>
<pre><code>@Dao
public interface languagesDAO {
    @Update
    Completable update(languages language);

    @Insert
    Completable insert(languages language);

    @Delete
    Completable delete(languages language);

    //for array deletion
    @Delete
    Completable delete(languages... language);

    //Queries
    @Query(&quot;SELECT * FROM languages;&quot;)
    Single&lt;List&lt;languages&gt;&gt; getLanguages();
}

</code></pre>
<p><strong>Repository</strong></p>
<pre><code>public class newProfileRepository {
    private final syllableDB m_db;
    private static newProfileRepository s_Instance;
    private usersDAO u_dao;
    private languagesDAO l_dao;
    private usersXlanguagesDAO uxl_dao;
    

    public newProfileRepository(final syllableDB db){
        m_db  = db;
        u_dao = m_db.usersDao();
        l_dao = m_db.languagesDAO();
        uxl_dao = m_db.usersXlanguagesDAO();
    }

    public static newProfileRepository getInstance(final syllableDB db) {
        if (s_Instance == null) {
            synchronized (newProfileRepository.class) {
                if (s_Instance == null) {
                    s_Instance = new newProfileRepository(db);
                }
            }
        }
        return s_Instance;
    }

    public Single&lt;List&lt;languages&gt;&gt; getLanguages(){
        return l_dao.getLanguages();
    }
    //...
}

</code></pre>
<p><strong>SpinLangAdapter</strong></p>
<pre><code>public class SpinLangAdapter extends ArrayAdapter&lt;language&gt; {

    private Context context;
    private ArrayList&lt;language&gt; tvPairs = new ArrayList&lt;&gt;();
    private List&lt;languages&gt; langs;
    private newProfileRepository newP_repo;
    private syllableDB db;

    public SpinLangAdapter(Context context, int textViewResourceId,List&lt;language&gt; list){
        super(context,textViewResourceId);
        this.context = context;
        this.tvPairs = new ArrayList&lt;language&gt;(list);
    }


    //This isn't used as I'm not even getting this far...
    public void setLangs(List&lt;languages&gt; newLangs){
        langs = newLangs;
        notifyDataSetChanged();
    }

   /* @Override
    public int getCount(){
        return tvPairs.size();
    }

    @Override
    public language getItem(int position){
        return tvPairs.get(position);
    }*/

    @Override
    public long getItemId(int position){
       return position;
    }

    //SO Link: https://stackoverflow.com/questions/1625249/android-how-to-bind-spinner-to-custom-object-list   
    //again, not used (yet)
    /*@Override
    public View getView(int position, View convertView, ViewGroup parent) {        
        TextView label = (TextView) super.getView(position, convertView, parent);
        label.setTextColor(Color.BLACK);        
        label.setText(tvPairs.get(position).getLangDesc());
        return label;
    }*/
}

</code></pre>
<p><strong>ViewModel</strong></p>
<pre><code>public class createNewProfileViewModel extends AndroidViewModel {
    private static final String QUERY_KEY = &quot;QUERY&quot;;

    private final newProfileRepository m_Repository;
    private Single&lt;List&lt;languages&gt;&gt; m_Langs;   

    public createNewProfileViewModel(Application application,  newProfileRepository newProfileRepo) {
        super(application);
        m_Repository = newProfileRepo;
        m_Langs = m_Repository.getLanguages();
       
    }
   
    public Observable&lt;List&lt;languages&gt;&gt; getLangListObservable(){
        Single&lt;List&lt;languages&gt;&gt; items = m_Repository.getLanguages();
        items.flattenAsObservable(new Function&lt;List&lt;languages&gt;, Iterable&lt;?&gt;&gt;() {
            @Override
            public Iterable&lt;?&gt; apply(List&lt;languages&gt; languages) throws Throwable {
                return languages;
            }
        })
        .toList();
        return null;
    }
}
</code></pre>
<p><strong>Fragment</strong></p>
<pre><code>public class createNewProfileFragment extends Fragment implements View.OnTouchListener,View.OnClickListener {
    private static final String LOG_TAG = com.electricbamboo.syllable.ui.createNewProfileFragment.class.getSimpleName();
    private CreateNewProfileBinding mBinding;
    private Context m_Context;

    private profileService PCS;

    private SpinLangAdapter nativeSLAdapter;
    private SpinLangAdapter targetSLAdapter;
    private List&lt;language&gt; spinnerListLangs;

    private Float tmpFZero=null;
    private Long tmpNativeLangNo = 0L;
    private ArrayList&lt;Long&gt; tmpTargetLangNos = new ArrayList&lt;&gt;();

    public createNewProfileFragment(){}

    @Override
    public void onAttach(Context context) {
        super.onAttach(context);
        m_Context = context;
    }

    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
                                @Nullable Bundle savedInstanceState) {
        Log.d(LOG_TAG, &quot;Starting New Profile Creation&quot;);

        mBinding = DataBindingUtil.inflate(getLayoutInflater(), R.layout.create_new_profile, container, false);

        return mBinding.getRoot();
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState){
        newProfileViewModelFactory factory = new newProfileViewModelFactory(requireActivity().getApplication());

        final createNewProfileViewModel model = new ViewModelProvider(this,factory).get(createNewProfileViewModel.class);
        mBinding.setLifecycleOwner(getViewLifecycleOwner());

        nativeSLAdapter = new SpinLangAdapter(m_Context, android.R.layout.simple_spinner_dropdown_item,spinnerListLangs);
        mBinding.spCreateNativeLang.setAdapter(nativeSLAdapter);

        targetSLAdapter = new SpinLangAdapter(m_Context, android.R.layout.simple_spinner_dropdown_item,spinnerListLangs);
        mBinding.spCreateTargetLang.setAdapter(targetSLAdapter);

        // Doesn't compile, error thrown here (&quot;Cannot resolve method 'observe' in 'Observable'&quot;)
        model.getLangListObservable().observe(this, new Observer&lt;List&lt;languages&gt;&gt;(){
            @Override
            public void onChanged(@Nullable final List&lt;languages&gt; langs){
                for(languages l : langs){
                    language tmpLang = null;
                    tmpLang.setLangNo(l.langNo);
                    tmpLang.setLangDesc(l.langDesc);
                    spinnerListLangs.add(tmpLang);
                }
                targetSLAdapter.notifyDataSetChanged();
                nativeSLAdapter.notifyDataSetChanged();
            }
        });

        mBinding.spCreateNativeLang.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int position, long l) {
                language language = nativeSLAdapter.getItem(position);
                tmpNativeLangNo = language.getLangNo();
            }

            @Override
            public void onNothingSelected(AdapterView&lt;?&gt; adapterView) {}
        });

        mBinding.spCreateTargetLang.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int position, long l) {
                language language = targetSLAdapter.getItem(position);
                tmpTargetLangNos.add(language.getLangNo());
            }

            @Override
            public void onNothingSelected(AdapterView&lt;?&gt; adapterView) {}
        });

        subscribeToModel(model);
    }

    private void subscribeToModel(final createNewProfileViewModel model){
          //Fairly certain SOMETHING is supposed to go here, just unsure as to what
    }

  //...omitting onClick, onTouch, onStart, onPause, onResume, etc.

</code></pre>
<p><strong>language class</strong> <em>Not to be confused with languages!</em></p>
<p>This exists because I thought it might be easier to work with something that extends LiveData rather than
a RxJava Single&lt;List&gt;. Based on an answer presented here :<a href=""https://stackoverflow.com/questions/46312937/when-to-use-rxjava-in-android-and-when-to-use-livedata-from-android-architectura"">When to use RxJava in Android and when to use LiveData from Android Architectural Components?</a>
(look at kzotin's response). This was my attempt.</p>
<pre><code>public class language extends LiveData {
    private Long langNo;
    private String langDesc;

    //Getters
    public Long getLangNo(){
        return langNo;
    }

    public String getLangDesc(){
        return langDesc;
    }

    //Setters
    public void setLangNo(Long langNo){
        this.langNo = langNo;
    }

    public void setLangDesc(String langDesc){
        this.langDesc = langDesc;
    }

}
</code></pre>
<p><strong>What I've tried</strong></p>
<p>I've really tried to bring the text-value-pair functionality presented here:
<a href=""https://stackoverflow.com/questions/59350020/populate-spinner-from-livedata-room-database"">Populate Spinner from LiveData (Room Database)</a>
(Which has me scratching my head as to why 'observe' is causing problems).</p>
<p>With the Observable machinery presented here:
<a href=""https://stackoverflow.com/questions/39804056/transform-a-singlelistitem-to-an-observableitem"">Transform a Single&lt;List&lt;Item&gt;&gt; to an Observable&lt;Item&gt;?</a></p>
<p>...and the ID stuff here (I've commented a lot of the code that came from these next two links because I'm not even getting that far):
<a href=""https://stackoverflow.com/questions/1625249/android-how-to-bind-spinner-to-custom-object-list"">Android: How to bind spinner to custom object list?</a>
and
<a href=""https://stackoverflow.com/questions/1587028/android-configure-spinner-to-use-array"">Android - configure Spinner to use array</a></p>
<p>The issue that usually comes to haunt me is that I can't traverse through a Single&lt;List&gt; object with a for-each loop because &quot;foreach not defined for RxJava...Single&quot; (or something like that) when I go to convert the list of 'languages' objects to a list of 'language' object.</p>
<p>I thought I could retrieve the languages objects as Singles, and then in a .map or .flatMap function add them into my List onObservable, but that's led me here.</p>
<p><strong>Questions</strong></p>
<ol>
<li><p>Do my choices for where I'm accessing my repository and handling the initialization of the Spinner seem reasonable for the MVVM pattern? I want to make sure I'm working with the framework, not against it, but I don't know what I'm doing and with RxJava, feel pretty well over my head. I'm thinking if I got some direction on how better to organize my code, then perhaps it will keep me from trying to do something dumb.</p>
</li>
<li><p>Should I even try to make the 'intermediate' 'language.java' class work, or abandon it altogether? In other words, should I just not worry about whatever advantages might be had (or what I thought I understood to be) converting RxJava to LiveData? It seems like I misunderstood something, it's confused my code, and made my life far harder than it needed to be.</p>
</li>
<li><p>How <em>should</em> I be doing this?</p>
</li>
<li><p>What should I be doing in my subscribeToModel? I've read that business logic should be reserved for services. So, in my mind so far, it's the repository that's supposed to be responsible for passing things along for computation, but I'm a little hazy on how to classify 'populating' logic and so hesitant to put any sort of maniuplation on the fragment level. However, this leaves me wondering &quot;okay, so what IS supposed to go there??&quot;</p>
</li>
</ol>
<p>Thank you so much in advance for any light you can throw on this.</p>
","379486","","","","","2021-05-09 11:13:14","Issue Populating Spinner in Fragment from Room Database using RxJava3","<java><android><android-fragments><android-spinner><rx-java3>","0","0","","","","CC BY-SA 4.0"
"67587532","1","67589856","","2021-05-18 13:46:35","","0","38","<p>I am trying to upload database entities in batches using workmanager. The work fires alright, however the service doing the paging doesn't work as expected.</p>
<p>What I would like to do:</p>
<ol>
<li>Paginate through the database entries I need to upload (last timestamp on the server is newer than on the client). Get the page as a <code>List</code></li>
<li>map the entries to the api objects</li>
<li>pass on the entities to another method which fires the API call once, sending a list of entries</li>
</ol>
<p>Problems:</p>
<ol>
<li>The pagination seemingly ignores the <code>takeWhile</code> operator and executes until it hits the maximum execution limit</li>
<li>The <code>uploadEntitiesFor</code> call is never executed</li>
</ol>
<pre class=""lang-java prettyprint-override""><code>private void pageEntityAndUpload(long lastTimestamp) {
    Disposable ax = Observable.range(0, MAX_ITERATION)
            .doOnNext(integer -&gt; {
                logInformation.logInformation(TAG, null,
                        String.format(&quot;Paging %s for user: %s, Offset (page:%s): %s, Limit: %s&quot;,
                                resourceName, userId, integer, integer * limit, limit)
                );
            })
            .concatMap(integer -&gt; pageSupplierFunction.page(userId, lastTimestamp, integer * limit, limit))
            .doOnNext(dbEntities -&gt; {
                logInformation.logInformation(TAG, null,
                        String.format(&quot;Found %s: %s&quot;, resourceName, dbEntities.stream()
                                .map(EntityBase::getId)
                                .collect(Collectors.joining(&quot;,&quot;)))
                );
            })
            .takeWhile(dbEntities -&gt; !dbEntities.isEmpty())
            .flatMapIterable(a -&gt; a)
            .map(e -&gt; entityToApiMapper.apply(e))
            .toList()
            //.subscribeOn(Schedulers.io())
            .subscribeOn(Schedulers.single())
            .subscribe(
                    apiEntities -&gt; uploadEntitiesFor(apiEntities),
                    throwable -&gt; logError.logError(TAG, throwable, String.format(&quot;Failed to read and convert %s to api objects.&quot;, resourceName))
            );
}

</code></pre>
<p>The interfaces:</p>
<pre class=""lang-java prettyprint-override""><code>private PageSupplierFunction&lt;DBT&gt; pageSupplierFunction;
...
@FunctionalInterface
public interface PageSupplierFunction&lt;T&gt; {
    public Observable&lt;List&lt;T&gt;&gt; page(String userId, long lastTimestamp, int offset, int limit);
}
</code></pre>
<pre class=""lang-java prettyprint-override""><code>private Function&lt;DBT, AT&gt; entityToApiMapper;
</code></pre>
<p>The page supplier comes from a Room Dao, for example (it's an internal application, I need to store every users's stuff...):</p>
<pre><code>@Query(&quot;SELECT * FROM partner &quot; +
        &quot;WHERE user_id = ....)&quot; +
        &quot;LIMIT :limit OFFSET :offset&quot;)
Observable&lt;List&lt;Partner&gt;&gt; pagePartnerSuggestionsFor(String userId, long lastTimestamp, int offset, int limit);
</code></pre>
<p>During execution, the log output:</p>
<pre><code>2021-05-18 15:41:33.684 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:0): 0, Limit: 1000
2021-05-18 15:41:34.189 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:1): 1000, Limit: 1000
2021-05-18 15:41:34.191 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:2): 2000, Limit: 1000
2021-05-18 15:41:34.206 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:3): 3000, Limit: 1000
2021-05-18 15:41:34.207 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:4): 4000, Limit: 1000
2021-05-18 15:41:34.209 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:5): 5000, Limit: 1000
2021-05-18 15:41:34.217 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:6): 6000, Limit: 1000
2021-05-18 15:41:34.219 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:7): 7000, Limit: 1000
2021-05-18 15:41:34.226 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:8): 8000, Limit: 1000
2021-05-18 15:41:34.230 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:9): 9000, Limit: 1000
2021-05-18 15:41:34.240 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:10): 10000, Limit: 1000
2021-05-18 15:41:34.247 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:11): 11000, Limit: 1000
2021-05-18 15:41:34.253 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:12): 12000, Limit: 1000
2021-05-18 15:41:34.254 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:13): 13000, Limit: 1000
2021-05-18 15:41:34.255 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:14): 14000, Limit: 1000
2021-05-18 15:41:34.258 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:15): 15000, Limit: 1000
2021-05-18 15:41:34.259 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:16): 16000, Limit: 1000
2021-05-18 15:41:34.262 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:17): 17000, Limit: 1000
2021-05-18 15:41:34.265 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:18): 18000, Limit: 1000
2021-05-18 15:41:34.267 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:19): 19000, Limit: 1000
2021-05-18 15:41:34.268 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:20): 20000, Limit: 1000
2021-05-18 15:41:34.270 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:21): 21000, Limit: 1000
2021-05-18 15:41:34.271 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:22): 22000, Limit: 1000
2021-05-18 15:41:34.276 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:23): 23000, Limit: 1000
2021-05-18 15:41:34.279 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:24): 24000, Limit: 1000
2021-05-18 15:41:34.283 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:25): 25000, Limit: 1000
2021-05-18 15:41:34.285 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:26): 26000, Limit: 1000
2021-05-18 15:41:34.287 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:27): 27000, Limit: 1000
2021-05-18 15:41:34.291 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:28): 28000, Limit: 1000
2021-05-18 15:41:34.294 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:29): 29000, Limit: 1000
2021-05-18 15:41:34.298 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:30): 30000, Limit: 1000
2021-05-18 15:41:34.307 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:31): 31000, Limit: 1000
2021-05-18 15:41:34.311 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:32): 32000, Limit: 1000
2021-05-18 15:41:34.314 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:33): 33000, Limit: 1000
2021-05-18 15:41:34.316 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:34): 34000, Limit: 1000
2021-05-18 15:41:34.316 25902-26058/... I/PartnerUploadService: Found Partner: 957690320dee4f7983070a1fb630f487
2021-05-18 15:41:34.317 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:35): 35000, Limit: 1000
2021-05-18 15:41:34.318 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:36): 36000, Limit: 1000
2021-05-18 15:41:34.319 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:37): 37000, Limit: 1000
2021-05-18 15:41:34.321 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:38): 38000, Limit: 1000
2021-05-18 15:41:34.322 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:39): 39000, Limit: 1000
2021-05-18 15:41:34.335 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:40): 40000, Limit: 1000
2021-05-18 15:41:34.337 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:41): 41000, Limit: 1000
2021-05-18 15:41:34.342 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:42): 42000, Limit: 1000
2021-05-18 15:41:34.343 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:43): 43000, Limit: 1000
2021-05-18 15:41:34.346 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:44): 44000, Limit: 1000
2021-05-18 15:41:34.359 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:45): 45000, Limit: 1000
2021-05-18 15:41:34.361 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:46): 46000, Limit: 1000
2021-05-18 15:41:34.362 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:47): 47000, Limit: 1000
2021-05-18 15:41:34.363 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:48): 48000, Limit: 1000
2021-05-18 15:41:34.369 25902-26054/... I/PartnerUploadService: Paging Partner for user: TWnF0Tk....Uk1, Offset (page:49): 49000, Limit: 1000

</code></pre>
<p>I only have a single partner to upload right now. The upload is not fired and the pagination still executes until it hits the limit and does not stop after the first page.</p>
","840315","","","","","2021-05-18 16:27:24","RxJava takeWhile seems ignored. Should only execute for the first page","<android><rx-java><rx-java3>","1","0","","","","CC BY-SA 4.0"
"67589856","2","","67587532","2021-05-18 15:58:24","","0","","<p>You provide your <code>concatMap</code> with observables which will be processed in order. Every next observable will be proccesed only if the previous one was completed.</p>
<p>The thing is, your Dao returns observable, which actually does not complete - room table will be observed unless subscriber is disposed.</p>
<p>In your case, you should only get only the current value from the database by changing Dao method, to return <code>Single</code> instead of <code>Obervable</code> (and also change <code>concatMap</code> to <code>concatMapSingle</code>.)</p>
<hr />
<p><strong>Example</strong></p>
<p><em>I intentionally did not call <code>onComplete</code> on the <code>emitter</code> to simulate your case.</em></p>
<pre><code>Observable.range(0, 5)
    .concatMap { id -&gt;
        Observable.create&lt;Int&gt; { emitter -&gt;
            emitter.onNext(id)
            // emitter.onComplete()
        }
    }
    .subscribe(
        { println(&quot;Next-$it&quot;) },
        { println(&quot;Error&quot;) },
        { println(&quot;Complete&quot;) }
    )
</code></pre>
<p>Result:</p>
<pre><code>Next-0
</code></pre>
<p>Which can be fixed by changing <code>Observable</code> to <code>Single</code>.</p>
<pre><code>Observable.range(0, 5)
    .concatMapSingle { id -&gt;
        Single.create&lt;Int&gt; { emitter -&gt;
            emitter.onSuccess(id)
        }
    }
    .subscribe(
        { println(&quot;Next-$it&quot;) },
        { println(&quot;Error&quot;) },
        { println(&quot;Complete&quot;) }
    )
</code></pre>
<p>Result:</p>
<pre><code>Next-0
Next-1
Next-2
Next-3
Next-4
Complete
</code></pre>
","12026640","","12026640","","2021-05-18 16:27:24","2021-05-18 16:27:24","","","","0","","","","CC BY-SA 4.0"
"67595613","1","","","2021-05-19 00:53:53","","0","37","<p>I have this function below:</p>
<pre><code>    fun setDefaultUser(): Completable {
        return userRepository.getUser()
            .flatMapCompletable { user -&gt;
                setDefaultUser(user)
            }
            .doOnError {
                Timber.e(it, &quot;Setting default user failed&quot;)
            }
    }
</code></pre>
<p><code>userRepository.getUser()</code> returns <code>Single&lt;User&gt;</code></p>
<p>I have a unit test below:</p>
<pre><code>    @Test
    fun `Given userRepository getUser throws an error, when executed, return the error`() {
        whenever(userRepository.getUser()).thenThrow(RuntimeException())

        val observable = systemUnderTest.setDefaultUser().test()

        observable.assertError(RuntimeException::class.java)
    }
</code></pre>
<p>I want to be able to catch the exception inside the <code>.doOnError</code> block however it is not working.</p>
<p>What am I doing wrong here?</p>
<p>Thanks</p>
","5179960","","","","","2021-05-19 00:53:53","RxJava: How to catch an error if a function that returns a Single throws an exception?","<android><kotlin><rx-java><rx-java2><rx-java3>","0","1","","","","CC BY-SA 4.0"
"67809485","1","67822224","","2021-06-02 16:58:02","","0","36","<p>I'm converting some RxJava code to Kotlin Flow in a project.</p>
<p>I came across a piece of code where <code>BehaviorSubject#onError(Throwable)</code> was being called.</p>
<p>I didn't find any way to do it with a <code>Flow</code> object.</p>
<pre><code>// RxJava
val behaviorSubject = BehaviorSubject.create&lt;Int&gt;()
behaviorSubject.onError(RuntimeException())

// Kotlin Flow
val mutableSharedFlow = MutableSharedFlow&lt;Int&gt;()
mutableSharedFlow.???
</code></pre>
<p>Is there any way to do it?</p>
","5564683","","61158","","2021-06-03 07:20:08","2021-06-03 13:17:10","RxJava BehaviorSubject#onError(Throwable) equivalent in Kotlin Flow","<kotlin><rx-java><rx-java2><kotlin-flow><rx-java3>","1","2","","","","CC BY-SA 4.0"
"67822224","2","","67809485","2021-06-03 13:17:10","","1","","<p>From the <a href=""https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/"" rel=""nofollow noreferrer"">docs</a>: &quot;SharedFlow cannot be closed like BroadcastChannel and can never represent a failure. All errors and completion signals should be explicitly materialized if needed.&quot;</p>
<p>So you'd probably have to create a data class with slots for values and the exception, then use <code>takeWhile</code> to stop it.</p>
<p>(Sidenote: I happen to have a <a href=""https://github.com/akarnokd/kotlin-flow-extensions#behaviorsubject"" rel=""nofollow noreferrer""><code>BehaviorSubject</code></a> for kotlin flow that does offer an <a href=""https://github.com/akarnokd/kotlin-flow-extensions/blob/master/src/test/kotlin/hu/akarnokd/kotlin/flow/BehaviorSubjectTest.kt#L95-L124"" rel=""nofollow noreferrer"">error channel</a>.)</p>
","61158","","","","","2021-06-03 13:17:10","","","","0","","","","CC BY-SA 4.0"
"67856375","1","67856832","","2021-06-06 06:31:27","","0","73","<p>When I turned minifyEnabled in build.gradle to true, seems like rxjava3 suddenly can't work as expected, when I go through the log and the API response correctly.</p>
<p>So what I do is create a empty new project.</p>
<ol>
<li><p>Import Rxjava3 (3.0.13):
<code>implementation &quot;io.reactivex.rxjava3:rxjava:3.0.13&quot;</code></p>
</li>
<li><p>Changed buildTypes to:</p>
</li>
</ol>
<pre><code>buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
</code></pre>
<ol start=""3"">
<li>Change MainActivity.java's onCreate function to following:</li>
</ol>
<pre><code> @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // Simply give me &quot;Test&quot;
        Single.just(&quot;Test&quot;)
                .subscribe(new SingleObserver&lt;String&gt;() {
                    @Override
                    public void onSubscribe(@NonNull Disposable d) {

                    }

                    @Override
                    public void onSuccess(@NonNull String s) {
                        Log.d(&quot;TAG&quot;, s); // (s expect: &quot;Test&quot;, get: null)
                    }

                    @Override
                    public void onError(@NonNull Throwable e) {

                    }
                });
    }
</code></pre>
<ol start=""4"">
<li>Set breakpoint in onSuccess then connect device and press debug.</li>
<li>In onSuccess you will get null instead of &quot;Test&quot;.</li>
</ol>
<p>If you switch debug's minifyEnabled back to false, it will work as expected.
I also add these lines in proguard-rules.pre file:</p>
<pre><code>##---------------Begin: proguard configuration for rxjava  ----------
-dontwarn java.util.concurrent.Flow*
##---------------End: proguard configuration for rxjava  ----------
</code></pre>
<p>It did not work.</p>
<p>Can someone show me some way to go from here? Thank you in advance.</p>
","3405938","","","","","2021-06-06 07:41:23","Rxjava3 not working as expected when minifyEnabled set to true","<java><android><rx-java3>","1","4","1","","","CC BY-SA 4.0"
"67856832","2","","67856375","2021-06-06 07:41:23","","1","","<p>Try adding this instead in Proguard.</p>
<pre><code>-dontwarn java.util.concurrent.**
</code></pre>
","15690398","","","","","2021-06-06 07:41:23","","","","0","","","","CC BY-SA 4.0"
"67930956","1","","","2021-06-11 03:36:24","","0","40","<p>I have an Activity that kicks off three fragments.
The first is a loading splash screen where I just want to show the name of the app for a couple seconds.
The second, in my current case, is a screen that gathers the users name and language.
The third fragment will gather which languages they would like to learn. I'm trying to use an Observable in my ViewModel to hold my data, but the info entered at the first fragment is being lost upon switching to the second fragment.</p>
<p>I think I'm running into two problems (or more) simultaneously:</p>
<ol>
<li>I don't think I'm sharing my runOnceViewModel correctly across fragments</li>
<li>I don't think I'm using Observables quite right.</li>
</ol>
<p>After permissions are checked from the splash screen, I fire a function (launchProfile) that loads the next fragment like this:</p>
<pre><code>public void launchProfile(){

        if(model.getLearnerPK() &gt; 0){
            learningScreenFragment fragment = new learningScreenFragment(model.getUser());
            getParentFragmentManager()
                    .beginTransaction()
                    .addToBackStack(null)
                    .replace(R.id.fragment_container, fragment, null)
                    .commit();
        } else {
            runOnceNameAndNativeLangFragment fragment = new runOnceNameAndNativeLangFragment();
            getParentFragmentManager()
                    .beginTransaction()
                    .addToBackStack(null)
                    .replace(R.id.fragment_container, fragment, null)
                    .commit();
        }
    }
</code></pre>
<p>Since this is a new user, the primary key will be 0 and so I load the runOnceNameAndNativeLangFragment:</p>
<pre><code> @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
                             @Nullable Bundle savedInstanceState) {
        Log.d(LOG_TAG, &quot;RUNONCE: Gather Name and Native Language&quot;);

        mBinding = DataBindingUtil.inflate(getLayoutInflater(), R.layout.runonce_name_native, container, false);

        TransitionInflater TI = TransitionInflater.from(requireContext());
        setEnterTransition(TI.inflateTransition(R.transition.slide_right));

        return mBinding.getRoot();
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState){
        runOnceViewModelFactory factory = new runOnceViewModelFactory(requireActivity().getApplication());
        model = new ViewModelProvider(this,factory).get(runOnceViewModel.class);
        //super.onViewCreated(view,savedInstanceState); //remains of a road I tried to go down, but perhaps should have gone farther...
        //model = new ViewModelProvider(requireActivity()).get(runOnceViewModel.class);

        ArrayList&lt;language&gt; spinnerListLangs = model.getLangList();

        nativeSLAdapter = new SpinLangAdapter(m_Context, android.R.layout.simple_spinner_dropdown_item, spinnerListLangs);
        mBinding.spCreateNativeLang.setAdapter(nativeSLAdapter);

        mBinding.spCreateNativeLang.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int position, long l) {
                language lang = nativeSLAdapter.getItem(position);
                tmpNativeLangNo = lang.getLangNo();
            }

            @Override
            public void onNothingSelected(AdapterView&lt;?&gt; adapterView) {}
        });

        mBinding.btnNext.setOnClickListener(this::onClick);
    }



    @Override
    public void onClick(View view) {
        if (view.getId() == R.id.btnNext) {
            String tmpName = mBinding.etCreateProfileName.getText().toString();
            if(tmpNativeLangNo != null &amp;&amp; !tmpName.equals(&quot;&quot;)){

                model.getNewUser().observeOn(Schedulers.io()) //I'm doing something dumb here
                        .map(user -&gt; {
                            user.setName(tmpName);
                            user.setNativeLang(tmpNativeLangNo);
                            return user;
                        });

                runOnceSelectTargetLangsFragment fragment = new runOnceSelectTargetLangsFragment();
                getParentFragmentManager()
                        .beginTransaction()
                        .addToBackStack(null)
                        .replace(R.id.fragment_container, fragment, null)
                        .commit();
            } else {
                Toast.makeText(m_Context,&quot;Name and Native Language required.&quot;,Toast.LENGTH_SHORT).show();
            }
        }
    }
</code></pre>
<p>If I put a breakpoint on &quot;runOnceSelectTargetLangsFragment fragment = new runOnceSelectTargetLangsFragment();&quot; then I can verify that model.getNewUser() returns an Observable with the name and native language of whatever I input on the UI. What's killing me is that once I load the next fragment (runOnceSelectTargetLangsFragment), and try to save the target languages in its click handler, the name and native language info are lost. Ala, I'm not sharing the viewmodel right (or, worse, I'm using an Observable when I shouldn't be -- side note: I chose to use an Observable because it makes handling the thread stuff quite a bit easier and I imagine I'll appreciate its flexibility down the road as the app becomes more complicated. At least, that's what I'm telling myself.)</p>
<p><strong>Select Targets Fragment</strong></p>
<pre><code>@Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
                             @Nullable Bundle savedInstanceState) {
        Log.d(LOG_TAG, &quot;RUNONCE: Gather Target Languages&quot;);

        mBinding = DataBindingUtil.inflate(getLayoutInflater(), R.layout.runonce_select_targets, container, false);

        TransitionInflater TI = TransitionInflater.from(requireContext());
        setEnterTransition(TI.inflateTransition(R.transition.slide_right));

        return mBinding.getRoot();
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState){
        //runOnceViewModelFactory factory = new runOnceViewModelFactory(requireActivity().getApplication());
        //model = new ViewModelProvider(this,factory).get(runOnceViewModel.class); //I think this was on the right track...maybe?
        //super.onViewCreated(view,savedInstanceState);
        model = new ViewModelProvider(requireActivity()).get(runOnceViewModel.class);

        mBinding.btnNext.setOnClickListener(this::onClick);
    }


    @Override
    public void onClick(View view) {
        if (view.getId() == R.id.btnNext) {
            if(hasChecked()){

                model.getNewUser().observeOn(Schedulers.io())
                        .subscribe(user -&gt; {
                            user.setTargetLangs(getTargetLangs());
                        });

               String restHereWearyTraveler = &quot;&quot;; //the inn :)
               //...do more stuff 
    
            } else {
                Toast.makeText(m_Context,&quot;You must select at least one target language.&quot;,Toast.LENGTH_SHORT).show();
            }
        }
    }
</code></pre>
<p>At the inn, model.getNewUser() returns an Observable with the target languages all set, but the name and native language info are gonezo.</p>
<p><strong>View Model</strong></p>
<pre><code>public class runOnceViewModel extends AndroidViewModel {

    private final profileRepository m_Repository;
    private profileService PCS;
    private ArrayList&lt;language&gt; m_Langs;
    private Observable&lt;User&gt; newUser;

    public runOnceViewModel(Application application, profileRepository newProfileRepo) {
        super(application);
        m_Repository = newProfileRepo;
        m_Langs = m_Repository.getLanguages();
        PCS = profileService.getInstance(m_Repository);
    }

    public Observable&lt;User&gt; getNewUser(){
        if(newUser == null){
            User tmpUser = new User();
            newUser = Observable.just(tmpUser);
        }
        return newUser;
    }
}
</code></pre>
","379486","","","","","2021-06-11 03:36:24","RxJava Observable across fragments using shared ViewModel","<android><fragment><android-viewmodel><rx-java3>","0","4","","","","CC BY-SA 4.0"
"67937772","1","67938511","","2021-06-11 13:20:32","","0","37","<p>I am new into RxJava and I was under the impression that for each event each subscriber is being notified. So if we have N subscribers and a stream of X events the <code>onNext</code> for each of the N subscribers would be called. But when I run the following code:</p>
<pre><code>public static void main(String[] args) {
        Observable&lt;String&gt; source = Observable.create(emitter -&gt; {
            emitter.onNext(&quot;Hello&quot;);
            emitter.onNext(&quot;Foo&quot;);
            emitter.onNext(&quot;Bar&quot;);
            emitter.onNext(&quot;RxJava&quot;);
        });

        source.subscribe(e -&gt; System.out.println(&quot;Observer 1: &quot; + e));
        source.subscribe(e -&gt; System.out.println(&quot;Observer 2: &quot; + e));
    } 
</code></pre>
<p>I see:</p>
<pre><code>Observer 1: Hello
Observer 1: Foo
Observer 1: Bar
Observer 1: RxJava
Observer 2: Hello
Observer 2: Foo
Observer 2: Bar
Observer 2: RxJava  
</code></pre>
<p>So basically after all the <code>onNext</code> are done only then the next observer is being triggered.</p>
<p>I was expecting to see:</p>
<pre><code>Observer 1: Hello 
Observer 2: Hello
Observer 1: Foo
Observer 2: Foo
Observer 1: Bar
Observer 2: Bar
Observer 1: RxJava
Observer 2: RxJava 
</code></pre>
<p>That seems to me inefficient for very long streams, am I doing something wrong?</p>
","9055634","","","","","2021-06-13 08:05:57","Are subscribers notified after all events or per event?","<java><observable><rx-java><reactive-programming><rx-java3>","1","0","","","","CC BY-SA 4.0"
"67938511","2","","67937772","2021-06-11 14:08:46","","2","","<p>RxJava sequences are synchronous by default thus the subscribe call above will run your emission code right there. To achieve the interleaving, you need a way to tell the source when both consumers are ready to receive. This can be done several ways:</p>
<pre class=""lang-java prettyprint-override""><code>ConnectableObservable&lt;String&gt; source = Observable.&lt;String&gt;create(emitter -&gt; {
            emitter.onNext(&quot;Hello&quot;);
            emitter.onNext(&quot;Foo&quot;);
            emitter.onNext(&quot;Bar&quot;);
            emitter.onNext(&quot;RxJava&quot;);
        }).publish();

        source.subscribe(e -&gt; System.out.println(&quot;Observer 1: &quot; + e));
        source.subscribe(e -&gt; System.out.println(&quot;Observer 2: &quot; + e));

        source.connect();
</code></pre>
<p>or</p>
<pre class=""lang-java prettyprint-override""><code>ConnectableObservable&lt;String&gt; source = Observable.&lt;String&gt;create(emitter -&gt; {
            emitter.onNext(&quot;Hello&quot;);
            emitter.onNext(&quot;Foo&quot;);
            emitter.onNext(&quot;Bar&quot;);
            emitter.onNext(&quot;RxJava&quot;);
        }).publish().refCount(2);

        source.subscribe(e -&gt; System.out.println(&quot;Observer 1: &quot; + e));
        source.subscribe(e -&gt; System.out.println(&quot;Observer 2: &quot; + e));
</code></pre>
","61158","","61158","","2021-06-13 08:05:57","2021-06-13 08:05:57","","","","9","","","","CC BY-SA 4.0"
"67946545","1","67946591","","2021-06-12 07:20:24","","0","537","<p>i have problem and really don't know how to fix this. I try to find similar posts several days, but didn't find.</p>
<p>I use retrofit for parsing api and put it in  room database and use rxjava3
because it will be asynchronously</p>
<p>That my JSON</p>
<pre class=""lang-json prettyprint-override""><code>{
  &quot;coord&quot;: {
    &quot;lon&quot;: -0.1257,
    &quot;lat&quot;: 51.5085
  },
  &quot;weather&quot;: [
    {
      &quot;id&quot;: 803,
      &quot;main&quot;: &quot;Clouds&quot;,
      &quot;description&quot;: &quot;broken clouds&quot;,
      &quot;icon&quot;: &quot;04d&quot;
    }
  ],
  &quot;base&quot;: &quot;stations&quot;,
  &quot;main&quot;: {
    &quot;temp&quot;: 22.78,
    &quot;feels_like&quot;: 22.81,
    &quot;temp_min&quot;: 21.23,
    &quot;temp_max&quot;: 23.92,
    &quot;pressure&quot;: 1020,
    &quot;humidity&quot;: 65
  },
  &quot;visibility&quot;: 10000,
  &quot;wind&quot;: {
    &quot;speed&quot;: 0.45,
    &quot;deg&quot;: 264,
    &quot;gust&quot;: 2.68
  },
  &quot;clouds&quot;: {
    &quot;all&quot;: 75
  },
  &quot;dt&quot;: 1623415339,
  &quot;sys&quot;: {
    &quot;type&quot;: 2,
    &quot;id&quot;: 2019646,
    &quot;country&quot;: &quot;GB&quot;,
    &quot;sunrise&quot;: 1623383015,
    &quot;sunset&quot;: 1623442617
  },
  &quot;timezone&quot;: 3600,
  &quot;id&quot;: 2643743,
  &quot;name&quot;: &quot;London&quot;,
  &quot;cod&quot;: 200
}
</code></pre>
<p>Api service</p>
<pre><code>interface OpenWeatherApiService {

@GET(&quot;weather&quot;)
fun getCurrentWeather(
    @Query(&quot;q&quot;) location:String,
    @Query(&quot;appid&quot;) key:String,
    @Query(&quot;units&quot;) units:String,
    @Query(&quot;lang&quot;) language:String = &quot;en&quot;
):Observable&lt;CurrentWeatherResponse&gt;}
</code></pre>
<p>That my app module</p>
<pre><code>@Module
@InstallIn(ActivityComponent::class)
object AppModule {
@Provides
fun provideOkHttpClient() =if(BuildConfig.DEBUG) {
    val interceptor = HttpLoggingInterceptor()
    interceptor.setLevel(HttpLoggingInterceptor.Level.BODY)
    OkHttpClient
        .Builder()
        .addInterceptor(interceptor)
        .build()
}else{
    OkHttpClient
        .Builder()
        .build()
}
@Provides
fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit = Retrofit.Builder()
    .baseUrl(&quot;https:/api.openweathermap.org/data/2.5/&quot;)
    .addCallAdapterFactory(RxJava3CallAdapterFactory.create())
    .addConverterFactory(GsonConverterFactory.create())
    .client(okHttpClient)
    .build()

@Provides
fun provideGson(): Gson = GsonBuilder().create()

@Provides
fun provideOpenWeatherApiService(retrofit: Retrofit):OpenWeatherApiService = retrofit.create(OpenWeatherApiService::class.java)

@Provides
fun provideOpenWeatherApiHelper(openWeatherApiHelper: OpenWeatherApiHelperImpl):OpenWeatherApiHelper = openWeatherApiHelper

@Provides
fun provideForecastDatabase(@ApplicationContext appContext: Context) = ForecastDatabase.getDatabase(appContext)

@Provides
fun provideCurrentWeatherDao(db: ForecastDatabase) = db.currentWeatherDao()


}
</code></pre>
<p>My response</p>
<pre><code>const val CURRENT_WEATHER_ID = 0

@Entity(tableName = &quot;current_weather&quot;)
data class CurrentWeatherResponse(
        val main: List&lt;Main&gt; ,
        val name: String? = &quot;&quot;,
        val visibility: Int? = 0,
        val weather: List&lt;Weather&gt; ,
        val wind:List&lt;Wind&gt;
){
    @PrimaryKey(autoGenerate = false)
    var id_current_weather:Int = CURRENT_WEATHER_ID
}
</code></pre>
<p>My type converter for Main, i put it in on a database</p>
<pre><code>class MainConverter {
    val gson = Gson()

    @TypeConverter
    fun listMainToString(mainList: List&lt;Main?&gt;?):String?{
        return gson.toJson(mainList)
    }
    @TypeConverter
    fun stringToListMain(dataMain:String?):List&lt;Main?&gt;?{
        if (dataMain ==  null){
            return Collections.emptyList()
        }
        val listType: Type = object :
                TypeToken&lt;List&lt;Main&gt;?&gt;() {}.type
        return gson.fromJson&lt;List&lt;Main?&gt;?&gt;(dataMain,listType)
    }
}
</code></pre>
","16197791","","15690398","","2021-06-14 08:53:54","2021-06-14 08:53:54","com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_ARRAY but was BEGIN_OBJECT at line 1 column 148 path $.main","<android><retrofit2><android-room><dagger-hilt><rx-java3>","1","0","","","","CC BY-SA 4.0"
"67946591","2","","67946545","2021-06-12 07:26:25","","1","","<p>The data class you are generating for your JSON response is not correct. Many of the things are objects, but you have assigned it as a <code>List</code> item. Here is the correct data class response based on your JSON. So the JSON response is not being parsed properly.</p>
<pre class=""lang-kotlin prettyprint-override""><code>data class CurrentWeatherResponse(
    val base: String,
    val clouds: Clouds,
    val cod: Int,
    val coord: Coord,
    val dt: Int,
    val id: Int,
    val main: Main,
    val name: String,
    val sys: Sys,
    val timezone: Int,
    val visibility: Int,
    val weather: List&lt;Weather&gt;,
    val wind: Wind
)

data class Clouds(
    val all: Int
)

data class Coord(
    val lat: Double,
    val lon: Double
)

data class Main(
    val feels_like: Double,
    val humidity: Int,
    val pressure: Int,
    val temp: Double,
    val temp_max: Double,
    val temp_min: Double
)

data class Sys(
    val country: String,
    val id: Int,
    val sunrise: Int,
    val sunset: Int,
    val type: Int
)

data class Weather(
    val description: String,
    val icon: String,
    val id: Int,
    val main: String
)

data class Wind(
    val deg: Int,
    val gust: Double,
    val speed: Double
)
</code></pre>
<p>I suggest you try to use this and try again. Here is also a plugin that automatically generates data classes based of JSON. It might help you more.</p>
<p><a href=""https://plugins.jetbrains.com/plugin/10054-generate-kotlin-data-classes-from-json"" rel=""nofollow noreferrer"">https://plugins.jetbrains.com/plugin/10054-generate-kotlin-data-classes-from-json</a></p>
","15690398","","","","","2021-06-12 07:26:25","","","","0","","","","CC BY-SA 4.0"
"67983559","1","67988349","","2021-06-15 09:23:54","","0","52","<p>I am new to RxJava and if I understand correctly the <code>Observer</code> is passed the <code>Disposable</code> on the <code>onSubscribe</code> so it can manually stop the processing if the <code>dispose()</code> has already been called.<br />
I created the following code:</p>
<pre><code>@NonNull Observable&lt;Long&gt; src = Observable.interval(1, TimeUnit.SECONDS);
src.subscribe(new Observer&lt;Long&gt;() {
      private Disposable d;

      @Override
      public void onSubscribe(@NonNull Disposable d) {
           this.d = d;
      }

      @Override
      public void onNext(@NonNull Long aLong) {
           if(!d.isDisposed()) {
              System.out.println(&quot;Number onNext = &quot; + aLong);
           }
      }

       @Override
       public void onError(@NonNull Throwable e) {

       }

       @Override
       public void onComplete() {
           System.out.println(&quot;completed&quot;);
       }
 });
</code></pre>
<p>but I can't figure out how to call <code>dispose()</code> for that subscription. <code>subscribe</code> with passing <code>Observer</code> as an argument returns <code>void</code> and <code>subscribeWith</code> does not accept my <code>Observer</code> without compile errors.</p>
<p>How is this supposed to work? What am I misunderstanding here?</p>
","9055634","","9055634","","2021-06-15 09:45:53","2021-06-16 08:50:26","Calling dispose() when passing a subscriber that overrides onSubscribe","<java><rx-java><rx-java3>","2","0","","","","CC BY-SA 4.0"
"67988349","2","","67983559","2021-06-15 14:36:05","","1","","<p>The <a href=""http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Observable.html"" rel=""nofollow noreferrer"">JavaDocs</a> of <code>Observable</code> has a straightforward example:</p>
<pre class=""lang-java prettyprint-override""><code>Disposable d = Observable.just(&quot;Hello world!&quot;)
     .delay(1, TimeUnit.SECONDS)
     .subscribeWith(new DisposableObserver&lt;String&gt;() {
         @Override public void onStart() {
             System.out.println(&quot;Start!&quot;);
         }
         @Override public void onNext(String t) {
             System.out.println(t);
         }
         @Override public void onError(Throwable t) {
             t.printStackTrace();
         }
         @Override public void onComplete() {
             System.out.println(&quot;Done!&quot;);
         }
     });

 Thread.sleep(500);
 // the sequence can now be disposed via dispose()
 d.dispose();
</code></pre>
<p><strong>Edit</strong></p>
<p>The following examples are ways to get the <code>Disposable</code> out of the <code>onSubscribe</code> method but are generally not recommended:</p>
<pre class=""lang-java prettyprint-override""><code>// field in the owner class
Disposable disposable;

public void doReactive() {
    Observable&lt;Long&gt; src = Observable.interval(1, TimeUnit.SECONDS);
    src.subscribe(new Observer&lt;Long&gt;() {

        @Override
        public void onSubscribe(@NonNull Disposable d) {
           disposable = d;
        }

        // ...
    });
}

public void cleanup() {
   if (disposable != null) {
       disposable.dispose();
       disposable = null;
   }
}
</code></pre>
<p>or</p>
<pre class=""lang-java prettyprint-override""><code>SerialDisposable sd = new SerialDisposable();

Observable&lt;Long&gt; src = Observable.interval(1, TimeUnit.SECONDS);
    src.subscribe(new Observer&lt;Long&gt;() {

        @Override
        public void onSubscribe(@NonNull Disposable d) {
           sd.set(d);
        }

        // ...
    });

// ...

sd.dispose();
</code></pre>
","61158","","61158","","2021-06-16 08:50:26","2021-06-16 08:50:26","","","","7","","","","CC BY-SA 4.0"
"68082725","1","68083755","","2021-06-22 11:27:35","","0","37","<p>I have DB table 'order' with 6000 rows and I want to create searching in it by number using switchmap for canceling previous request. But it's not work, it always returns result of previous request. What is wrong with my code?</p>
<p><strong>Example:</strong> enter 1..0..7 returns 107%, then 10%, then 1%. It should return only 107%</p>
<pre><code>disposable.add(
                Observable.just(orderParameter)
                .debounce(1, TimeUnit.SECONDS)
                .distinctUntilChanged()
                .switchMapSingle(orderParameter1 -&gt; orderInteractor.getSearchOrderList(orderParameter1))
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(orders -&gt; {
                    getView().showOrders(orders);
                }, throwable -&gt; Timber.e(throwable.getMessage())));


@Query(&quot;SELECT `order`.order_id as id, &quot; +
            &quot;client.last_name || ' ' || SUBSTR(client.first_name,1,1) || '. ' || SUBSTR(client.middle_name,1,1) || '.' as client_name, &quot; +
            &quot;`order`.status as status, &quot; +
            &quot;agency.short_name as agency_name, &quot; +
            &quot;`order`.creation_date as date, &quot; +
            &quot;`order`.price as price &quot; +
            &quot;FROM `order`, agency, client where &quot; +
            &quot;`order`.status =:status and agency.id = `order`.agency_id and client.id = `order`.client_id &quot; +
            &quot;and `order`.agency_id =:agencyId and `order`.order_id like :orderId&quot;)
    Single&lt;List&lt;Order&gt;&gt; getOrdersByStatusAndOrderIdAndAgencyId(String status, String orderId, long agencyId);


public class OrderParameter {
    public long searchNumber = -1;
    public long agencyId = -1;
}


OrderParameter orderParameter = new OrderParameter();
        try {
            if (TextUtils.isEmpty(searchText.trim())) {
                orderParameter.searchNumber = -1;
            } else {
                orderParameter.searchNumber = Long.parseLong(searchText);
            }
        } catch (Exception e) {
        }
        orderParameter.agencyId = agencyId;
</code></pre>
<p><strong>UPD:</strong> Added getting an OrderParameter</p>
","8614594","","8614594","","2021-06-22 12:45:25","2021-06-23 06:38:17","switchMapSingle() doesn't cancel previous request","<java><android><rx-java><android-room><rx-java3>","1","5","","","","CC BY-SA 4.0"
"68083755","2","","68082725","2021-06-22 12:42:52","","0","","<p>With the help of RxBinding, try this in onCreate:</p>
<pre class=""lang-java prettyprint-override""><code>disposable.add(
    RxView.clicks(textField).map(v -&gt; {
            String searchText = searchTextField.getText().toString();
            OrderParameter orderParameter = new OrderParameter();
            try {
                if (TextUtils.isEmpty(searchText.trim())) {
                    orderParameter.searchNumber = -1;
                } else {
                    orderParameter.searchNumber = Long.parseLong(searchText);
                }
            } catch (Exception e) {
            }
            orderParameter.agencyId = agencyId;
            return orderParameter;
          })
          .debounce(1, TimeUnit.SECONDS)
          .distinctUntilChanged()
          .switchMapSingle(orderParameter1 -&gt; 
                  orderInteractor.getSearchOrderList(orderParameter1))
          .subscribeOn(Schedulers.io())
          .observeOn(AndroidSchedulers.mainThread())
          .subscribe(orders -&gt; {
               getView().showOrders(orders);
          }, throwable -&gt; Timber.e(throwable.getMessage())));
</code></pre>
","61158","","61158","","2021-06-23 06:38:17","2021-06-23 06:38:17","","","","1","","","","CC BY-SA 4.0"
"68132838","1","68133748","","2021-06-25 14:42:17","","1","29","<p>I am new in RxJava and trying to understand it. I have the following source:</p>
<pre><code>Observable&lt;Employee&gt; obs = Observable.just(
    new Employee(101, &quot;Jim&quot;, 68_000, 4.2),
    new Employee(123, &quot;Bill&quot;, 194_000, 6.7));  

obs.groupBy(e -&gt; e.getRating())
                .flatMap(e-&gt; {
                    return Observable.fromIterable(
                        Arrays.asList(e.getKey())
                    );
                })
                .subscribe(System.out::println);
 
</code></pre>
<p>This prints the key which is the ratings but I can't print the values.<br />
Is it possible using <code>flatMap</code>?</p>
","9055634","","13302","","2021-06-25 14:45:11","2021-06-25 15:46:47","Use flatmap with grouped observables","<rx-java><rx-java3>","1","0","","","","CC BY-SA 4.0"
"68133748","2","","68132838","2021-06-25 15:46:47","","1","","<p><code>groupBy</code> returns an <code>Observable</code> that emits a <code>GroupedObservable</code> for each unique key. A <code>GroupedObservable</code> is really just an <code>Observable</code> with the addition of the <code>getKey</code> method, so you can identify which key that <code>GroupedObservable</code> is associated with. So, if you want to emit each value in each <code>GroupedObservable</code>, just pass the whole thing directly to the <code>flatMap</code> call:</p>
<pre><code>Observable&lt;Employee&gt; obs = Observable.just(
    new Employee(101, &quot;Jim&quot;, 68_000, 4.2),
    new Employee(123, &quot;Bill&quot;, 194_000, 6.7));  

obs.groupBy(e -&gt; e.getRating())
    .flatMap(e -&gt; e)
    .subscribe(System.out::println);
</code></pre>
","2073595","","","","","2021-06-25 15:46:47","","","","10","","","","CC BY-SA 4.0"
"68207167","1","","","2021-07-01 08:50:24","","1","20","<p>I am new in RxJava and trying to understand it. I have the following source:</p>
<pre><code>Observable&lt;Employee&gt; obs = Observable.just(
    new Employee(101, &quot;Jim&quot;, 68_000, 4.2),
    new Employee(123, &quot;Bill&quot;, 194_000, 6.7));  

obs.groupBy(e -&gt; e.getRating())
   .flatMapSingle(e -&gt; e.toMultimap(key -&gt; e.getKey(), emp -&gt; emp.getName()))
   .subscribe(System.out::println);
 
</code></pre>
<p>This approach prints the keys and the associated value.<br />
If I do:</p>
<pre><code>obs.groupBy(e -&gt; e.getRating())
       .flatMapSingle(e -&gt; e.toList())
       .subscribe(System.out::println);   
</code></pre>
<p>It seems to print the list of values associated with the key.<br />
But how does <code>flatMapSingle</code> exactly work? What is the difference with <code>flatMap</code>?</p>
","9055634","","","","","2021-07-01 09:52:50","flatMap and flatMap single for groupped observables","<rx-java><rx-java3>","1","0","","","","CC BY-SA 4.0"
"68221945","1","68222170","","2021-07-02 08:24:44","","1","107","<p>This is my test code in Kotlin:</p>
<pre><code>fun main() {
    rxjava()
}

fun rxjava() {
    val queuSubject = PublishSubject.create&lt;String&gt;()
    queuSubject
        .map { t -&gt;
            val a = t.toLong()
            Thread.sleep(6000 / a)
            println(&quot;map $a called ${Thread.currentThread().name} &quot;)
            a
        }
        .subscribeOn(Schedulers.io())
        .observeOn(Schedulers.io())
        .subscribe({
            println(&quot;thread in subscription ${Thread.currentThread().name}&quot;)
        }, {
            println(&quot;error ${it.message}&quot;)
        })
    for (i in 1..3) {
        Thread {
            queuSubject.onNext(&quot;$i&quot;)
        }.start()
    }
    Thread.sleep(15000)
}
</code></pre>
<p>I'm trying to run <code>map</code> block and <code>subscribe's onNext</code> block in different IO threads. But the output is like this:</p>
<pre><code>map 3 called Thread-2 
thread in subscription RxCachedThreadScheduler-2
map 2 called Thread-1 
thread in subscription RxCachedThreadScheduler-2
map 1 called Thread-0 
thread in subscription RxCachedThreadScheduler-2
</code></pre>
<p>As you can see It seems that calling <code>subscribeOn</code> has no effect on <code>PublishSubject's</code> stream and <code>thread-0,thread-1 and thread-2</code> refers to the threads that call <code>onNext</code> methods.</p>
<p>Additionally consider the code below:</p>
<pre><code>fun main() {
    rxjava()
}

fun rxjava() {
    val queuSubject = PublishSubject.create&lt;String&gt;()
    queuSubject
        .map { t -&gt;
            val a = t.toLong()
            Thread.sleep(6000 / a)
            println(&quot;map $a called ${Thread.currentThread().name} &quot;)
            a
        }
        .subscribeOn(Schedulers.io())
        .observeOn(Schedulers.io())
        .subscribe({
            println(&quot;thread in subscription ${Thread.currentThread().name}&quot;)
        }, {
            println(&quot;error ${it.message}&quot;)
        })
    queuSubject.onNext(&quot;1&quot;)
    queuSubject.onNext(&quot;2&quot;)
    queuSubject.onNext(&quot;3&quot;)
    Thread.sleep(15000)
}
</code></pre>
<p>I wrote the code above and saw that no output is printed. But If I remove <code>subscribeOn</code> from the stream, messages are printed sequentially like the following:</p>
<pre><code>map 1 called main 
thread in subscription RxCachedThreadScheduler-1
map 2 called main 
thread in subscription RxCachedThreadScheduler-1
map 3 called main 
thread in subscription RxCachedThreadScheduler-1
</code></pre>
<p>What is the problem of these codes? Thanks.</p>
","6940373","","6940373","","2021-07-02 10:07:19","2021-07-02 10:07:19","Why doesn't subscribeOn effect on PublishSubject in Rxjava?","<java><kotlin><rx-java3>","1","0","","","","CC BY-SA 4.0"
"68222170","2","","68221945","2021-07-02 08:42:52","","3","","<p>Because <code>subscribeOn</code> only affects subscription side-effects of a source. Such side-effect would be if the source starts emitting events right when an observer subscribes:</p>
<pre class=""lang-java prettyprint-override""><code>Observable.just(1, 2, 3)
.subscribeOn(Schedulers.io())
.doOnNext(v -&gt; System.out.println(Thread.currentThread() + &quot; - &quot; + v)
.blockingSubscribe();
</code></pre>
<p><code>PublishSubject</code> has no subscription side-effect as it only relays signals from its <code>onXXX</code> method to the observers' <code>onXXX</code> methods.</p>
<p>However, <code>subscribeOn</code> has a time effect as it delays the actual subscription to the source, thus in case of <code>PublishSubject</code>, it might not see a registered observer in time some other thread calls its <code>onXXX</code> methods.</p>
<p>If you want to move the processing off of the original thread, use <code>observeOn</code>:</p>
<pre class=""lang-java prettyprint-override""><code>val queuSubject = PublishSubject.create&lt;String&gt;()
    queuSubject
        .observeOn(Schedulers.io()) // &lt;----------------------------------------
        .map { t -&gt;
            val a = t.toLong()
            Thread.sleep(6000 / a)
            println(&quot;map $a called ${Thread.currentThread().name} &quot;)
            a
        }
        .observeOn(Schedulers.io())
        .subscribe({
            println(&quot;thread in subscription ${Thread.currentThread().name}&quot;)
        }, {
            println(&quot;error ${it.message}&quot;)
        })
</code></pre>
","61158","","","","","2021-07-02 08:42:52","","","","9","","","","CC BY-SA 4.0"
"68228943","1","68229089","","2021-07-02 17:03:52","","0","57","<p>I want to call  api  using rxjava3 inside getCampaigns function in CampaignRepositoryImpl.kt class but I am getting following error <a href=""https://i.stack.imgur.com/PmQOJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/PmQOJ.png"" alt=""error"" /></a> A 'return' expression required in a function with a block body ('{...}')</p>
<p>below  CampaignRepositoryImpl.kt class</p>
<pre><code>import de.westwing.campaignbrowser.domain.Campaign
import de.westwing.campaignbrowser.domain.CampaignRepository
import io.reactivex.rxjava3.core.Single

class CampaignRepositoryImpl(private val apiInterface: ApiInterface) : CampaignRepository {

    override fun getCampaigns(): Single&lt;List&lt;Campaign&gt;&gt; {

       apiInterface.getCampaigns()

    }

}
</code></pre>
<p>below my interface class I am getting API call</p>
<pre><code>interface ApiInterface {

    @GET(&quot;cms/test/campaigns.json&quot;)
    fun getCampaigns(): Single&lt;CampaignsResponse&gt;

}
</code></pre>
<p>below CampaignRepository</p>
<p>interface CampaignRepository {</p>
<pre><code>fun getCampaigns(): Single&lt;List&lt;Campaign&gt;&gt;
</code></pre>
<p>}</p>
<p>below my CompaignResponse.kt</p>
<pre><code>data class CampaignsResponse(val metadata: CampaignsMetadata)
</code></pre>
<p>below CampaingsMetadata</p>
<pre><code>data class CampaignsMetadata(val data: List&lt;CampaignDto&gt;)
</code></pre>
<p>below</p>
<pre><code>data class Campaign(val name: String, val description: String)
</code></pre>
<p>below CampaignDto</p>
<pre><code>class CampaignDto(val name: String, val description: String, val image: ImageDto)
</code></pre>
<p>I want to know where I am making mistake what I have to do in order to avoid error</p>
","16341969","","16341969","","2021-07-02 18:08:02","2021-07-02 18:48:43","A 'return' expression required in a function with a block body ('{...}'","<android><kotlin><retrofit2><clean-architecture><rx-java3>","2","23","","","","CC BY-SA 4.0"
"68229089","2","","68228943","2021-07-02 17:17:20","","2","","<p>From your api interface, we can see that the type of <code>getCampaigns()</code> is <code>Single&lt;CampaignsResponse&gt;</code>. In your repository implementation, on the other hand, the type of <code>getCampaigns()</code> is <code>Single&lt;List&lt;Campaign&gt;&gt;</code>.</p>
<p>Since both are <code>Single&lt;Foo&gt;</code>, you'll need to <code>map</code> from one to the other.</p>
<p>Given your class implementations, this should work:</p>
<pre><code>override fun getCampaigns(): Single&lt;List&lt;Campaign&gt;&gt; {
   return apiInterface.getCampaigns().map { response -&gt;
       response.metadata.data.map {
           Campaign(it.name, it.description)
       }
   }
}
</code></pre>
<p>This <code>map</code> call is taking a <code>CampaignResponse</code> and turning it into a <code>List&lt;Campaign&gt;</code>.</p>
","8298909","","8298909","","2021-07-02 18:48:43","2021-07-02 18:48:43","","","","4","","","","CC BY-SA 4.0"
"68255705","1","","","2021-07-05 11:53:08","","0","10","<p>I have a problem when using Singles in a recyclerview, where the viewholders can be dragged.</p>
<p>I have a recyclerview with different types of viewholders. Every viewholder shows different content. In two of my viewholders, data are being diplayed by using Single ( Rx Java )  to emit the data. This recyclerview is also draggable, which means that the viewholders can change their positions. My problem is that when I drag a viewholder that uses Single ( Rx Java ), data are being displayed twice, in the old and in the new position of the viewholder.</p>
<p>What I need is the data to be removed from the position that the viewholder was and only to be shown in the position that is being dragged to !</p>
<p>I have tried disposing the observable when the viewholder is being removed from a position and then creating/ subscribing to it again when the viewholder is being created again.</p>
<p>I have also tried unsubscribing from the observable when the viewholder is being removed from a position and then subscribing to it again when the viewholder is being created again.
Nothing from the 2 things I have tried is working.</p>
<p>What can I do to fix it ?
Any help is appreciated.</p>
","10865112","","10865112","","2021-07-05 11:58:44","2021-07-05 11:58:44","Single Rx Java shows double data in draggable Reyclerview","<android><kotlin><rx-java><rx-java3>","0","0","","","","CC BY-SA 4.0"
"68365256","1","","","2021-07-13 15:24:21","","0","28","<p>I have the below method which throws an exception and want to catch that exception on the global level</p>
<pre><code>public Maybe&lt;FindProductCommand&gt; get(ProductSearchCriteriaCommand searchCriteria) {
        LOG.info(&quot;Controller --&gt; Finding all the products&quot;);
        return iProductManager.find(searchCriteria);
    }
</code></pre>
<p>As per the reactivex documentation <a href=""http://reactivex.io/documentation/plugins.html"" rel=""nofollow noreferrer"">http://reactivex.io/documentation/plugins.html</a></p>
<p>To do this, extend the <code>class RxJavaErrorHandler</code> and override this method:</p>
<pre><code>void handleError(Throwable e)
</code></pre>
<p>I am using micronaut application with java and have the below dependency</p>
<pre><code>implementation(&quot;io.micronaut.rxjava3:micronaut-rxjava3&quot;)
</code></pre>
<p>And tried below code</p>
<pre><code>public class RxJavaExceptionHandler extends RxJavaErrorHandler{
}
</code></pre>
<p>Cannot import RxJavaErrorHandler</p>
<p>While looking for the solution the below code is used in many examples</p>
<pre><code>RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
        @Override
        public void handleError(Throwable e) {
            Timber.e(e.toString());
        }
    });
</code></pre>
<p>However, getInstance().registerErrorHandler is not found in RxJavaPlugins</p>
","1162409","","","","","2021-07-13 15:24:21","Global error handling with RxJavaErrorHandler","<java><rx-java><rx-java2><reactivex><rx-java3>","0","3","","","","CC BY-SA 4.0"
"68513706","1","","","2021-07-24 20:49:53","","0","19","<p>I wanna know more about RxJava PublishProcessor. Does it handle back pressure by default or we should add this behavior to it by onBackPressure funtions?</p>
","8532604","","","","","2021-07-26 07:06:38","Does RxJava PublishProcessor cares about back pressure by default?","<android><rx-java><rx-java2><rx-java3>","1","1","","","","CC BY-SA 4.0"
"68803309","1","","","2021-08-16 13:03:44","","0","17","<p>I am implementing reading data from Firestore with RxJava3 and converting it to LiveData via LiveDataReactiveStreams. I have list of food items, and on click of the food I want to load details about that specific food. The problem is, that when user clicks one item and loads it, after clicking on second item he gets values from previous item for a second until new data is loaded.
I noticed that my flowable from repository is always triggering on new clicks and returning previous data, but I would like to display first loading state for new item and then display that loaded item.
How would I prevent it from returning previous values, or clear that LiveData?</p>
<p>Repository</p>
<pre><code>@NonNull
public Flowable&lt;Resource&lt;FoodDetailModel&gt;&gt; getFoodDetail(@NonNull String entityId, @NonNull String foodId) {
    return Flowable.&lt;Resource&lt;FoodDetailModel&gt;&gt;create(emitter -&gt; {
        CollectionReference entitiesRef = FirebaseFirestore.getInstance().collection(Common.COLLECTION_ENTITIES);
        entitiesRef.document(entityId)
                .collection(Common.COLLECTION_MENU_ITEMS)
                .document(foodId).get().addOnCompleteListener(itemTask -&gt; {
            if(itemTask.isSuccessful()) {
                DocumentSnapshot document = itemTask.getResult();
                if(document != null &amp;&amp; document.exists()) {
                    FoodModel foodModel = document.toObject(FoodModel.class);
                    if(foodModel != null) {
                        foodModel.setLocalizedFields();
                        entitiesRef.document(entityId)
                                .collection(Common.COLLECTION_MENU_ITEMS_DETAILS)
                                .document(foodId).get().addOnCompleteListener(detailsTask -&gt; {
                            if(detailsTask.isSuccessful()) {
                                DocumentSnapshot detailsDocument = detailsTask.getResult();
                                if(detailsDocument != null &amp;&amp; detailsDocument.exists()) {
                                    FoodDetailModel foodDetailModel = detailsDocument.toObject(FoodDetailModel.class);
                                    if(foodDetailModel != null) {
                                        foodDetailModel.setFoodModel(foodModel);
                                        emitter.onNext(Resource.success(foodDetailModel));
                                        emitter.onComplete();
                                    }
                                    else
                                        emitter.onNext(Resource.error(null, Resource.MESSAGE_SUCCESS_BUT_NO_DATA));
                                }
                                else
                                    emitter.onNext(Resource.error(null, Resource.MESSAGE_SUCCESS_BUT_NO_DATA));
                            }
                            else
                                emitter.onError(detailsTask.getException());
                        });
                    }
                    else
                        emitter.onNext(Resource.error(null, Resource.MESSAGE_SUCCESS_BUT_NO_DATA));
                }
                else
                    emitter.onNext(Resource.error(null, Resource.MESSAGE_SUCCESS_BUT_NO_DATA));
            }
            else
                emitter.onError(itemTask.getException());
        });        
    }, BackpressureStrategy.MISSING)
            .subscribeOn(Schedulers.io())
            .startWithItem(Resource.loading())
            .onErrorReturn(throwable -&gt; Resource.error(null, &quot;Error loading FoodDetails return: &quot;, throwable));
}
</code></pre>
<p>ViewModel</p>
<pre><code>public LiveData&lt;Resource&lt;FoodDetailModel&gt;&gt; getFoodLiveData() {
   return Transformations.switchMap(cartItemMutableLiveData, input -&gt;
            LiveDataReactiveStreams.fromPublisher(cartRepository.getFoodDetail(getEntityId(),
                    input.getId()).map(CartViewModel.this::mapSizesAddons)));
}
</code></pre>
","14252974","","","","","2021-08-16 13:03:44","How to clear data from LiveDataReactiveStreams","<android><rx-java><android-livedata><rx-java3><android-livedata-transformations>","0","0","","","","CC BY-SA 4.0"
"68851980","1","68852347","","2021-08-19 17:05:18","","0","64","<p>I'm adapting some sample code from what3words for accessing their API via their Java SDK. It uses RXJava.</p>
<p>The sample code is:</p>
<pre><code>Observable.fromCallable(() -&gt; wrapper.convertTo3wa(new Coordinates(51.2423, -0.12423)).execute())
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(result -&gt; {
            if (result.isSuccessful()) {
                Log.i(&quot;MainActivity&quot;, String.format(&quot;3 word address: %s&quot;, result.getWords()));
            } else {
                Log.e(&quot;MainActivity&quot;, result.getError().getMessage());
            }
        });
</code></pre>
<p>First of all. this gives a deprecation warning when building and a IDE warning (<code>Result of 'Observable.subscribe()' is ignored</code>).</p>
<p>To resolve this first issue I have added <code>Disposable myDisposable = </code> in front of the <code>Observable</code>. Is this correct? (See below for where it is added)</p>
<p>Next I need to add a timeout so that I can show a warning etc if the request times out. To do this I have added <code>.timeout(5000, TimeUnit.MILLISECONDS)</code> to the builder.</p>
<p>This works, but the way <code>timeout</code>s seem to work on <code>Observable</code>s is that they throw an exception and I cannot figure out how to catch and handle that exception.</p>
<p>What I have right now is:</p>
<pre><code>Disposable myDisposable = Observable.fromCallable(() -&gt; wrapper.convertTo3wa(new Coordinates(51.2423, -0.12423)).execute())
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .timeout(5000, TimeUnit.MILLISECONDS)
        .subscribe(result -&gt; {
            if (result.isSuccessful()) {
                Log.i(&quot;MainActivity&quot;, String.format(&quot;3 word address: %s&quot;, result.getWords()));
            } else {
                Log.e(&quot;MainActivity&quot;, result.getError().getMessage());
            }
        });
</code></pre>
<p>This builds and runs fine, and the API/deprecation warning is not shown, BUT when no network is available this correctly times out and throws the unhandled exception.</p>
<p>So, the code seems to be correct, but how on earth do add the exception handling to catch the timeout <code>TimeoutException</code> that is thrown?</p>
<p>I've tried numerous things, including: adding a <code>try-catch</code> clause around the whole <code>Observable</code> - this warns that <code>TimeoutException</code> is not thrown by the code in the `try; and adding an error handler.</p>
<p>Adding the error handler has got me closest, and so the code below is as far as I have got:</p>
<pre><code>Disposable myDisposable = Observable.fromCallable(() -&gt; wrapper.convertTo3wa(new Coordinates(51.2423, -0.12423)).execute())
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .timeout(5000, TimeUnit.MILLISECONDS)
        .subscribe(result -&gt; {
            if (result.isSuccessful()) {
                Log.i(&quot;MainActivity&quot;, String.format(&quot;3 word address: %s&quot;, result.getWords()));
            } else {
                Log.e(&quot;MainActivity&quot;, result.getError().getMessage());
            }
         }, error -&gt; {
             runOnUiThread(new Runnable() {
                 @Override
                 public void run() {
                     myTextView.setText(R.string.network_not_available);
                 }
             });
         });
</code></pre>
<p>This catches the Timeout correctly and updates my UI without error, however when the network is restored it seems that the Observable might be trying to return and a null pointer exception is thrown.</p>
<p>(Update, this NPE might actually be being thrown sometimes after a short time whether the network is restored or not... but it is always thrown when the network restores.)</p>
<p>I get <code>FATAL EXCEPTION: RxCachedThreadScheduler-1</code> and <code>java.lang.NullPointerException: Callable returned a null value. Null values are generally not allowed in 3.x operators and sources.</code></p>
<p>Do I need to destroy the <code>Observable</code> or something to prevent the NPE?</p>
","2211491","","2211491","","2021-08-20 12:41:15","2021-08-20 12:59:55","Problems with RXJava","<java><android><rx-java><rx-java2><rx-java3>","2","4","","","","CC BY-SA 4.0"
"68852347","2","","68851980","2021-08-19 17:36:01","","0","","<p>You need to add an <code>onError</code> handler to your <code>subscribe</code> call:</p>
<pre><code>    .subscribe(result -&gt; {
        if (result.isSuccessful()) {
            Log.i(&quot;MainActivity&quot;, String.format(&quot;3 word address: %s&quot;, result.getWords()));
        } else {
            Log.e(&quot;MainActivity&quot;, result.getError().getMessage());
        }
     },
     error -&gt; {
         // handle error here
     });
</code></pre>
<p>When a an exception makes it to a subscribe call that does not have an onError handler, it will throw a OnErrorNotImplementedException, like this:</p>
<pre><code>io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | java.util.concurrent.TimeoutException: The source did not signal an event for 1 seconds and has been terminated.
</code></pre>
<p>Adding the onError handler will prevent that, and the onError handler will get called instead.</p>
","2073595","","2073595","","2021-08-19 17:45:28","2021-08-19 17:45:28","","","","9","","","","CC BY-SA 4.0"
"68869750","2","","66234860","2021-08-21 02:52:56","","0","","<p>Already fixed with version 2.3.0 of Auth0 android lib--see the README on how to solve this issue <a href=""https://github.com/auth0/Auth0.Android#unit-testing-with-junit-4-or-junit-5"" rel=""nofollow noreferrer"">here</a></p>
","4612653","","","","","2021-08-21 02:52:56","","","","0","","","","CC BY-SA 4.0"
"68881889","1","","","2021-08-22 13:43:37","","1","16","<p>I want to pull asynchronous json data with retrofit and rxjava 3 in the foreground service and show it to the user as a notification, but so far I have not been successful.</p>
<pre><code>@Streaming
@GET(&quot;v2/top-headlines&quot;)
fun getDayNewsRxJava(
    @Query(&quot;country&quot;) language : String,
    @Query(&quot;apiKey&quot;) key : String
) : Observable&lt;Model1&gt;

val retrofit = Retrofit.Builder()
        .baseUrl(&quot;https://newsapi.org/&quot;)
        .addCallAdapterFactory(RxJava3CallAdapterFactory.create())
        .addConverterFactory(GsonConverterFactory.create())
        .build()

fun returnEveryDay() : everydayNews {
    return retrofit.create(everydayNews::class.java)
}

newsRetrofit.returnEveryDay().getDayNewsRxJava(&quot;language&quot; , &quot;apiKey&quot;)
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(object : Observer&lt;Model1&gt; {
            override fun onSubscribe(d: Disposable?) {
            }
            override fun onNext(t: Model1?) {
                val title = t!!.articles[0].title
                Log.d(TAG , &quot;Rx Java Data : ${t?.articles[0].title}&quot;)
                sendNotification(title)
            }

            override fun onError(e: Throwable?) {
                Log.e(TAG , &quot;Rx Java Error : $e&quot;)
            }

            override fun onComplete() {
                Log.d(TAG , &quot;Rx Java Completed&quot;)
            }

        })
</code></pre>
<p>I looked at different examples in this way, they did not use a very different structure, but I do not understand why an asynchronous call is not made.</p>
<p>thanks for your help</p>
","15198949","","","","","2021-08-22 13:43:37","How to work Rxjava3 with Retrofit foreground service asynchronous","<android><kotlin><retrofit2><rx-java2><rx-java3>","0","0","","","","CC BY-SA 4.0"
"68924101","1","","","2021-08-25 13:45:13","","0","16","<p>I am using <code>RxJava</code> with <code>ViewModel</code>, so when viewModel's <code>onCleared</code> method is called, I call <code>disposable.clear()</code>, being the disposable object a <code>CompositeDisposable</code>.</p>
<p>The thing is that, sometimes, I concatenate several calls through the <code>flatMap</code> call returning different <code>Flowable</code> or <code>Single</code> objects, so I hav two questions:</p>
<ol>
<li><strong>Shall I add to the composite all the Flowable/Single objects I use in the flatMap calls? Or just the first one of the whole chain?</strong></li>
<li><strong>Is there any way to know if I forgot to 'add into the composite' any disposable?</strong></li>
</ol>
","9811147","","","","","2021-08-25 13:45:13","How to know if all disposables were cleared?","<android><rx-java><rx-java2><rx-java3><disposable>","0","0","","","","CC BY-SA 4.0"
"69421918","1","","","2021-10-03 03:44:05","","0","7","<p>I have time consuming process in the subscriber. So while this is processed there will be other incoming messages. But this message is kind of trigger and doesn't contain any state. Hence it is not required to process all the messages. It would be enough to process the most recent message that will be there when subscriber finish the current one.</p>
<p>I tried couple of ways.</p>
<ol>
<li>Configure back pressure strategy to drop. But, this wouldn't work because RXJava has internal buffer and backpressure only drops messages if that number is reached.</li>
<li>ThrottleLast, Debounce, ..etc depends on time time period so even the subscriber is finished work it will wait. I need to get the latest as soon as subscriber finishes work.</li>
</ol>
","1270622","","","","","2021-10-03 03:44:05","RXJava drop and emit only the most recent message after waiting for subscriber to finish","<rx-java><rx-java2><vert.x><rx-java3>","0","0","","","","CC BY-SA 4.0"