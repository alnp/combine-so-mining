Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"50217376","1","50218581","","2018-05-07 15:11:09","","1","1732","<p>I'm trying to test a very simple view model:</p>

<pre><code>struct SearchViewModelImpl: SearchViewModel {
    let query = PublishSubject&lt;String&gt;()
    let results: Observable&lt;BookResult&lt;[Book]&gt;&gt;

    init(searchService: SearchService) {
        results = query
            .distinctUntilChanged()
            .throttle(0.5, scheduler: MainScheduler.instance)
            .filter({ !$0.isEmpty })
            .flatMapLatest({ searchService.search(query: $0) })
    }
}
</code></pre>

<p>I'm trying to test receiving an error from service so I doubled it this way:</p>

<pre><code>class SearchServiceStub: SearchService {
    let erroring: Bool

    init(erroring: Bool) {
        self.erroring = erroring
    }

    func search(query: String) -&gt; Observable&lt;BookResult&lt;[Book]&gt;&gt; {
        if erroring {
            return .just(BookResult.error(SearchError.downloadError, cached: nil))
        } else {
            return books.map(BookResult.success) // Returns dummy books
        }
    }
}
</code></pre>

<p>I'm testing a query that errors this way:</p>

<pre><code>func test_when_searchBooksErrored_then_nextEventWithError() {
    let sut = SearchViewModelImpl(searchService: SearchServiceStub(erroring: true))
    let observer = scheduler.createObserver(BookResult&lt;[Book]&gt;.self)

    scheduler
        .createHotObservable([
            Recorded.next(200, (""Rx"")),
            Recorded.next(800, (""RxSwift""))
        ])
        .bind(to: sut.query)
        .disposed(by: disposeBag)

    sut.results
        .subscribe(observer)
        .disposed(by: disposeBag)

    scheduler.start()

    XCTAssertEqual(observer.events.count, 2)
}
</code></pre>

<p>To begin I'm just asserting if the count of events is correct but I'am only receiving one not two. I thought it was a matter of asynchronicity so I changed the test to use RxBlocking:</p>

<pre><code>func test_when_searchBooksErrored_then_nextEventWithError() {
    let sut = SearchViewModelImpl(searchService: SearchServiceStub(erroring: true))
    let observer = scheduler.createObserver(BookResult&lt;[Book]&gt;.self)

    scheduler
        .createHotObservable([
            Recorded.next(200, (""Rx"")),
            Recorded.next(800, (""RxSwift""))
        ])
        .bind(to: sut.query)
        .disposed(by: disposeBag)

    sut.results.debug()
        .subscribe(observer)
        .disposed(by: disposeBag)

    let events = try! sut.results.take(2).toBlocking().toArray()

    scheduler.start()

    XCTAssertEqual(events.count, 2)
}
</code></pre>

<p>But this never ends.</p>

<p>I don't know if there is something wrong with my stub, or maybe with the viewmodel, but the production app works correctly, emitting the events as the query fires.</p>

<p>Documentation of RxTest and RxBlocking is very very short, with the classic examples with a string or an integer, but nothing related with this kind of flow... it is very frustrating.</p>
","191059","","","","","2018-05-07 16:22:24","RxSwift, tests with RxBlocking do not end","<ios><swift><rx-swift><rx-blocking>","1","3","","","","CC BY-SA 4.0"
"52123969","1","52127656","","2018-09-01 00:34:56","","1","883","<p>I'm using the logic below to check the state of my subject using RxBlocking. I'm getting a weird value of <code>Int??</code> out of <code>try? subject.verifier.toBlocking().first()</code>. </p>

<p>The syntax below pleases the compiler but makes my eyes bleed. </p>

<p><strong>How do I get an unwrapped value out of RXBlocking expectation?</strong></p>

<pre><code>func checkSubjectState() -&gt; Int
    {
      let updatedChecksum = try? subject.verifier.toBlocking().first() ?? 0
      return updatedChecksum ?? 0
    }

let expectedCheckSum = checkSubjectState()
expect(expectedCheckSum).to(equal(knownValue))
</code></pre>
","967484","","967484","","2018-09-08 11:51:42","2018-09-08 11:51:42","iOS RxSwift - How to unwrap an `Optional<Optional<T>>` or `T??`?","<swift><unit-testing><swift4><rx-swift><rx-blocking>","4","5","1","","","CC BY-SA 4.0"
"56425073","1","56506817","","2019-06-03 10:04:41","","1","397","<p>I'm trying to test the main functionality of my ViewModel. The important step is to test te loaded state completed. But for sure, for a better test it could be interesting to test al states.</p>

<p>I was reading a lot of post and information about RxTest and RxBlocking but I'm not able to test this module. If someone can help me, it would be great!</p>

<pre><code>struct Product: Equatable { }
struct Promotion { }

protocol ProductsRepository {
    func fetchProducts() -&gt; Observable&lt;Products&gt;
    func fetchPromotions()  -&gt; Observable&lt;[Promotion]&gt;
}

struct ProductCellViewModel: Equatable {
    let product: Product
}

struct Products {
    let products: [Product]
}

enum ProductsViewState: Equatable {
    case loading
    case empty
    case error
    case loaded ([ProductCellViewModel])
}

class ProductsViewModel {

    var repository: ProductsRepository

    let disposeBag = DisposeBag()
    private var productCellViewModel: [ProductCellViewModel]
    private var promotions: [Promotion]

    // MARK: Input

    init(repository: ProductsRepository) {
        self.repository = repository
        productCellViewModel = [ProductCellViewModel]()
        promotions = [Promotion]()
    }

    func requestData(scheduler: SchedulerType) {
        state.onNext(.loading)
        resetCalculate()
        repository.fetchProducts()
            .observeOn(scheduler)
            .flatMap({ (products) -&gt; Observable&lt;[ProductCellViewModel]&gt; in
                return self.buildCellViewModels(data: products)
            }).subscribe(onNext: { (cellViewModels) in
                self.productCellViewModel = cellViewModels
            }, onError: { (error) in
                self.state.onNext(.error)
            }, onCompleted: {
                self.repository.fetchPromotions()
                    .flatMap({ (promotions) -&gt; Observable&lt;[Promotion]&gt; in
                        self.promotions = promotions
                        return Observable.just(promotions)
                    }).subscribe(onNext: { (_) in
                        self.state.onNext(.loaded(self.productCellViewModel))
                    }, onError: { (error) in
                        self.state.onNext(.error)
                    }).disposed(by: self.disposeBag)
            }).disposed(by: disposeBag)
    }

    // MARK: Output

    var state = PublishSubject&lt;ProductsViewState&gt;()

    // MARK: ViewModel Map Methods

    private func buildCellViewModels(data: Products) -&gt; Observable &lt;[ProductCellViewModel]&gt; {
        var viewModels = [ProductCellViewModel]()
        for product in data.products {
            viewModels.append(ProductCellViewModel.init(product: product))
        }
        return Observable.just(viewModels)
    }

    func resetCalculate() {
        productCellViewModel = [ProductCellViewModel]()
    }
}
</code></pre>

<p>The goal is to be able to test all of ProductsViewState after viewmodel.requestData() is being called</p>
","2468765","","506441","","2019-06-08 13:33:56","2019-06-08 13:33:56","Test PublishSubject for ViewState","<mvvm><rx-swift><rxtest><rx-blocking>","1","11","","","","CC BY-SA 4.0"