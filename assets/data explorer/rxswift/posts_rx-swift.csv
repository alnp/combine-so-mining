Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"31663012","1","31769457","","2015-07-27 20:48:17","","3","2241","<p>I'm trying to implement the following RxSwift example:</p>

<p>Login in with facebook in my application -> retrieve the user information -> retrieve user's profile photo.</p>

<p>I have these three functions and they must be executed in this order: requestAccess() -> fetchUserInformation() -> fetchUserPhoto()</p>

<pre><code>func requestAccess() -&gt; Observable&lt;(ACAccount)&gt; {
    return create { observer -&gt; Disposable in
        let accountStore = ACAccountStore()
        let accountType = accountStore.accountTypeWithAccountTypeIdentifier(ACAccountTypeIdentifierFacebook)
        let dictionary: [NSObject : AnyObject] = [ACFacebookAppIdKey:""***APPID***"", ACFacebookPermissionsKey:[""public_profile"", ""email"", ""user_friends""]]

        accountStore.requestAccessToAccountsWithType(accountType, options: dictionary) { granted, error in
            if granted == false || error != nil {
                sendError(observer, error ?? UnknownError)
            } else {
                let accounts = accountStore.accountsWithAccountType(accountType)
                let account = accounts.last as! ACAccount
                sendNext(observer, account)
                sendCompleted(observer)
            }
        }

        return AnonymousDisposable({})
    }
}

func fetchUserInformation(account: ACAccount) -&gt; Observable&lt;User&gt; {
    return create { observer -&gt; Disposable in
        let url = NSURL(string: ""https://graph.facebook.com/me"")
        let request = SLRequest(forServiceType: SLServiceTypeFacebook, requestMethod: .GET, URL: url, parameters: nil)
        request.account = account

        request.performRequestWithHandler { (data, response, error) -&gt; Void in
            if data == nil || response == nil {
                sendError(observer, error ?? UnknownError)
            } else {
                let result: AnyObject? = NSJSONSerialization.JSONObjectWithData(data, options: nil, error: nil)
                let user = User()
                user.updateInformationWithJSON(result! as! JSONObject)

                sendNext(observer, user)
                sendCompleted(observer)
            }
        }

        return AnonymousDisposable({})
    }
}

func fetchUserPhoto(user: User) -&gt; Observable&lt;AnyObject&gt; {
    return create { observer -&gt; Disposable in
        let url = NSURL(string: ""https://graph.facebook.com/***myid***/picture"")
        let params = [""redirect"":""false"", ""height"":""200"", ""width"":""200""]

        let request = SLRequest(forServiceType: SLServiceTypeFacebook, requestMethod: .GET, URL: url, parameters: params)
        request.account = SocialController.account

        request.performRequestWithHandler { (data, response, error) -&gt; Void in
            if data == nil || response == nil {
                sendError(observer, error ?? UnknownError)
            } else {
                let result: AnyObject? = NSJSONSerialization.JSONObjectWithData(data, options: nil, error: nil)                    
                sendNext(observer, result!)
                sendCompleted(observer)
            }
        }

        return AnonymousDisposable({})
    }
}
</code></pre>

<p>I already tried to implement this flow but it doesn't feel right. What is the best way to solve this problem?</p>

<pre><code>        requestAccess()
        &gt;- subscribeNext { account in
            fetchUserInformation(account)
                &gt;- map { user in return UserViewModel(model: user) }
                &gt;- subscribeNext { viewModel in self.viewModel = viewModel }
        }
</code></pre>
","493642","","2664670","","2015-07-30 11:14:10","2019-05-31 15:32:02","Facebook login using RxSwift","<facebook><swift><reactive-programming><rx-swift>","2","0","","","","CC BY-SA 3.0"
"31756537","1","31980353","","2015-07-31 23:17:25","","4","4160","<p>I'd like to create an observable that behaves behaves something like this.</p>

<pre><code>var count = 0

func setupCountdownTimer() {
  let rx_countdownTimer = CountdownTimer.observable(5)

  rx_countdownTimer &gt;- subscribeNext {
    secondsRemaining in
    println(secondsRemaining) // prints 5, then 4, 3, 2, 1, then finally 0
    count = secondsRemaining
  }

  rx_countdownTimer &gt;- subscribeCompleted {
    println(count) // prints 5, assuming countdownTimer stopped 'naturally'
  }
}

@IBAction func stop(sender: UIButton) {
  rx_countdownTimer.sendCompleted() // Causes 2nd println above to output, say, 3, if that's how many seconds had elapsed thus far.
}
</code></pre>

<p>It seems like I should be able to somehow combine a <a href=""http://reactivex.io/documentation/operators/timer.html"" rel=""nofollow"">timer observable</a> and an <a href=""http://reactivex.io/documentation/operators/interval.html"" rel=""nofollow"">interval observable</a> here, but I can't seem to figure out the correct strategy for doing this. New to Rx, so I'm open to the possibility that I'm going about it all wrong. ¯\_(ツ)_/¯</p>
","230615","","230615","","2015-08-01 02:51:57","2015-08-13 05:47:21","Combine RxSwift timer and interval observables into a single observable with completion","<swift><timer><countdown><reactive-programming><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"32358929","1","32361451","","2015-09-02 16:56:19","","7","4371","<p>I'm trying to learn the library <a href=""https://github.com/ReactiveX/RxSwift"" rel=""noreferrer"">RxSwift</a></p>
<p>I have some code like this:</p>
<pre><code>if data.checkAllIsOk()
{ 
    [do things]
}
else
{ 
    [show alert]
}
</code></pre>
<p>Now i need to update the data from the server before checking, so i have modeled a getData() that return an Observable.</p>
<p>My current approach is this:</p>
<pre><code>getData()  
    &gt;- flatMap{ (data:Data) -&gt; Observable&lt;Bool&gt; in
        _=0 // workaround for type inference bugs
        return just(data.checkAllIsOk())
    }
    &gt;- subscribeNext{ (ok) -&gt; Void in
        if ok
        {
            [do the things]
        }
        else
        {
            [show the alert]
        }
    } 
    &gt;- disposeBag.addDisposable()
</code></pre>
<p>It works (or it should, i'm still writing it), but it feels wrong.. is there a more &quot;reactive&quot; way to do it?
What are the most appropriate operators to use?</p>
<p>Maybe returning an error for “false” and use the catch block?</p>
<p><strong>Update</strong></p>
<p>Following the approach suggested by ssrobbi i splitted the 2 branches in 2 different subscribeNext, and used filter to select the positive or negative branch. This is the code resulting:</p>
<pre><code>let checkData=getData()  
        &gt;- flatMap{ (data:Data) -&gt; Observable&lt;Bool&gt; in
            _=0 
            return just(data.checkAllIsOk())
        }
        &gt;- shareReplay(1)
}
[...]
checkData
    &gt;- filter{ (ok) -&gt; Bool in
        ok == true
    }
    &gt;- subscribeNext{ (_) -&gt; Void in
        [do the things]
    }
    &gt;- disposeBag.addDisposable()

checkData
    &gt;- filter{ (ok) -&gt; Bool in
        ok == false
    }
    &gt;- subscribeNext{ (_) -&gt; Void in
        [show the alert]
    } 
    &gt;- disposeBag.addDisposable()
</code></pre>
<p>The advantage of this approach is that i can reuse only one of the two branches in other parts of the code, without rewriting the subscribe body (less duplication is always good!)</p>
<p><strong>Update</strong></p>
<p>After some discussions in the RxSwift slack i added the shareReplay(1), so the getData() isn't repeated.</p>
","527935","","-1","","2020-06-20 09:12:55","2017-02-03 20:08:47","how to translate an if-else in RxSwift?","<swift><reactive-programming><rx-swift>","4","0","","","","CC BY-SA 3.0"
"32542846","1","32581824","","2015-09-12 19:29:41","","262","29816","<p>So now with swift, the <a href=""https://github.com/ReactiveCocoa/ReactiveCocoa"">ReactiveCocoa</a> people have rewritten it in version 3.0 for swift</p>

<p>Also, there's been another project spun up called <a href=""https://github.com/ReactiveX/RxSwift"">RxSwift</a>.</p>

<p>I wonder if people could add information about what the differences in design/api/philosophy of the two frameworks are (please, in the spirit of SO, stick to things which are true, rather than opinions about which is ""best"")</p>

<p>[Note for StackOverflow mods: This question DOES have definitive answers, the answer is the differences between the two frameworks. I think it is also highly on topic for SO]</p>

<p>To get started, my initial impression from reading their ReadMe's is:</p>

<ul>
<li>As someone who is familiar with the ""real"" C# Rx from microsoft, RxSwift looks a lot more recognisable.</li>
<li>ReactiveCococa seems to have gone off into it's own space now, introducing new abstractions such as Signals vs SignalProducers and Lifting. On the one hand this seems to clarify some situations (what's a Hot vs Cold signal) but on the other hand this seems to increase the complexity of the framework a LOT</li>
</ul>
","234","","8334818","","2018-05-30 13:20:41","2018-05-30 13:20:41","ReactiveCocoa vs RxSwift - pros and cons?","<swift><reactive-programming><rx-swift><reactive-cocoa-3>","1","8","134","","","CC BY-SA 3.0"
"32746415","1","33068660","","2015-09-23 17:58:54","","5","8902","<p>I'm using RxSwift to simply my code. For my current project I'd like to apply RxSwift's principles to a mess of completion blocks from the LayerKit: </p>

<pre><code>layerClient.connectWithCompletion { (success, error) -&gt; () in
  if (!success) {
     // Error     
  } else {
    layerClient.requestAuthenticationNonceWithCompletion { (nonce, error) -&gt; () in
      // Even more blocks
    }
  }
}
</code></pre>

<p>I'm thinking about something like this:</p>

<pre><code>// In extension
public func rx_connect() -&gt; Observable&lt;Bool&gt; {
    return create { observer in

        self.connectWithCompletion { (success, error) -&gt; ()in
            if (success) {
                observer.on(.Next(success))
                observer.on(.Completed)
            } else {
                observer.on(.Error(error))
            }
        }
        return NopDisposable.instance
    }
} 

public func rx_requestAuthenticationNonce() -&gt; Observable&lt;String&gt; {
    // Same for annother method
}

// In AppDelegate
self.layerClient.rx_connect()
 .then() // requestAuthenticationNonceWithCompletion and use the nonce for next action
 .then()
 .subscribeNext(…
 .onError(… // To catch all errors
</code></pre>

<p>RxSwift does not have a <code>then()</code> method. Is there another way to do this chaining stuff or am I thinking wrong on how to use ReactiveX in general?</p>
","1850179","","5073840","","2015-09-23 18:08:59","2016-04-05 07:01:40","Sequence of actions with RxSwift","<swift><reactive-programming><rx-swift>","2","0","","","","CC BY-SA 3.0"
"32774313","1","34444821","","2015-09-25 03:27:34","","6","1912","<p>Just for the record before I launch into my question I am using Swift 2 and xcode 7 beta.</p>

<p>So I am using RxSwift and RxCocoa to bind my ViewModel to the TableView. In my <code>UITableViewController</code> <code>viewDidLoad</code> I am doing this binding...</p>

<pre><code>someCollectionOfViewModels
    .bindTo(self.tableView.rx_itemsWithCellIdentifier(""SomeCell"")) { 
        (_, viewModel, cell: SomeTableViewCell) in
            cell.tripViewModel = viewModel
    }
</code></pre>

<p><code>someCollectionOfViewModels</code> is just an array of view models wrapped in a <code>Variable&lt;&gt;</code>, so <code>Variable&lt;[SomeViewModel]&gt;.cell.tripViewModel</code> is of type <code>SomeViewModel</code>.</p>

<p>None of that is really pertinent to the problem, it all works great and when my view model updates, my table updates. The problem is that I want my table cells to be non-editable and the <code>UITableViewDataSource</code> that RxCocoa puts in place for the above binding doesn't implement the optional <code>canEditRowAtIndexPath</code> method on this protocol and it defaults to true making the cells editable. I know I can implement my own <code>RxTableViewDataSourceType</code> and that is fairly straightforward but a lot of code just to get this one little thing to work. I am fairly new to both RxSwift and iOS, am I missing something simple? Is there a way in the closure above where I have access to the <code>UITableCellView</code> to set some property on the cell itself to make it non-editable? How about something in the RxCocoa extensions that I am missing. If I have to I will go off and write my own <code>RxTableViewDataSource</code>, but I thought I would ask here first.</p>

<p>Thanks,</p>

<p>-Bill</p>
","5374600","","5130481","","2019-12-16 13:47:15","2019-12-16 13:47:15","How can I take control of canEditRowAtIndexPath when using RxCocoa extension for UITableView","<ios><swift><uitableview><reactive-programming><rx-swift>","1","1","3","","","CC BY-SA 4.0"
"32825795","1","32945918","","2015-09-28 14:43:15","","4","4019","<p>I'm playing around with RxSwift and I'm stuck with a simple toy programm. My program essentially contains a model class and a viewcontroller. The model contains an observable that gets updated on the main queue after an asynchronous network call, the viewcontroller subscribes in viewDidLoad(). The AppDelegate initializes the model and passes it to ViewController and triggers the network request.</p>

<pre><code>class GalleryModel {

    var galleryCount: BehaviorSubject&lt;Int&gt;

    init() {
        galleryCount = BehaviorSubject.init(value:0)
    }

    func refresh() {
         doAsyncRequestToAmazonWithCompletion { (response) -&gt; AnyObject! in
             var counter = 0
             //process response
             counter = 12

             dispatch_async(dispatch_get_main_queue()) {
                self.galleryCount.on(.Next(counter))
             }
             return nil
        }
    }

class ViewController: UIViewController {

    @IBOutlet weak var label: UILabel!

    var galleryModel: GalleryModel?

    override func viewDidLoad() {
        super.viewDidLoad()
        galleryModel?.galleryCount.subscribe { e in
            if let gc = e.element {
               self.label.text = String(gc)
            }
        }
   }
}

class AppDelegate: UIResponder, UIApplicationDelegate {
    var galleryModel: GalleryModel?

    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {        
        //do amazon setup        
        galleryModel = GalleryModel()
        if let viewController = window?.rootViewController as? ViewController {
            viewController.galleryModel = GalleryModel()
        }    
        return true
    }

    func applicationDidBecomeActive(application: UIApplication) {
        galleryModel?.refresh()
    }
</code></pre>

<p>The label gets updated only one, it shows ""0"". I expected the label to get updated twice, showing ""0"" after the first update and showing ""12"" after the second update after the processing of the network request. A breakpoint in the dispatch_async block gets hit, but it seems that galleryCount lost its observer. Anybody any idea what's happening or how to debug this?</p>

<p>Best</p>
","280774","","2564301","","2015-11-09 00:11:37","2017-09-14 19:34:13","RxSwift subscribe block not called","<ios><swift><rx-swift>","3","2","","","","CC BY-SA 3.0"
"33003863","1","33003864","","2015-10-07 23:01:00","","4","612","<p>In RxSwift example this works:</p>

<pre><code>        viewModel.rows
        .bindTo(resultsTableView.rx_itemsWithCellIdentifier(""WikipediaSearchCell"")) { (_, viewModel, cell: WikipediaSearchCell) in
            cell.viewModel = viewModel
        }
        .addDisposableTo(disposeBag)
</code></pre>

<p>How to write it using rx_itemsWithCellFactory?</p>
","2493141","","","","","2015-10-07 23:01:00","rx_itemsWithCellFactory call syntax","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"33316936","1","33325621","","2015-10-24 10:06:30","","26","12738","<p>While exploring <a href=""https://github.com/ReactiveX/RxSwift"" rel=""noreferrer"">RxSwift</a></p>

<p>I found just <code>textField.rx_text.asObservable()</code> property, that fires event every keyboard button is hit. </p>

<p>But how do we handle ""search"" or ""done"" button press events? I'd like to fire search only after these actions, not ""search as you type"".</p>
","1209976","","","","","2020-09-10 18:45:06","How to handle ""Done"" return key press event in rxSwift?","<swift2><reactive-programming><rx-swift>","3","0","4","","","CC BY-SA 3.0"
"33456359","1","36108541","","2015-10-31 20:38:22","","6","883","<p>I'm still a reactive newbie and I'm looking for help.</p>

<pre><code>func doA() -&gt; Observable&lt;Void&gt;
func doB() -&gt; Observable&lt;Void&gt;

enum Result {
    case Success
    case BFailed
}

func doIt() -&gt; Observable&lt;Result&gt; {

    // start both doA and doB. 
    // If both complete then emit .Success and complete
    // If doA completes, but doB errors emit .BFailed and complete
    // If both error then error

}
</code></pre>

<p>The above is what I think I want... The initial functions <code>doA()</code> and <code>doB()</code> wrap network calls so they will both emit one signal and then <code>Complete</code> (or <code>Error</code> without emitting any <code>Next</code> events.) If <code>doA()</code> completes but <code>doB()</code> errors, I want <code>doIt()</code> to emit <code>.BFailed</code> and then complete.</p>

<p>It feels like I should be using <code>zip</code> or <code>combineLatest</code> but I'm not sure how to know which sequence failed if I do that. I'm also pretty sure that <code>catchError</code> is part of the solution, but I'm not sure exactly where to put it.</p>

<p>--</p>

<p>As I'm thinking about it, I'm okay with the calls happening sequentially. That might even be better...</p>

<p>IE: </p>

<pre><code>Start doA() 
    if it completes start doB() 
        if it completes emit .Success 
        else emit .BFailed.
    else forward the error.
</code></pre>

<p>Thanks for any help.</p>
","506441","","343299","","2016-07-13 12:17:29","2016-07-13 12:17:29","Combining two Observable<Void>s","<swift><reactive-programming><rx-swift>","3","0","1","","","CC BY-SA 3.0"
"33815399","1","33862700","","2015-11-19 22:18:03","","9","4174","<p>I'm just learning RxSwift and have a simple example that I'm not sure why it is not working. I have a text field and a label field. ANY time the text field changes, I'd like the label field to be updated. If I type in the text field, everything works as expected. If I set the text field programmatically, such as when I push a button and set the text field explicitly, the label field is not updated.</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class ViewController: UIViewController {
  @IBOutlet weak var myTextField: UITextField!
  @IBOutlet weak var myLabel: UILabel!

  override func viewDidLoad() {
    super.viewDidLoad()
    myTextField.rx_text.bindTo(myLabel.rx_text)
  }

  @IBAction func pBtn(sender: UIButton) {
    myTextField.text = ""45""
  }
}
</code></pre>

<p>How do I get the label field to update? I've looked at a lot of examples but can't seem to find one that answers this question.</p>
","1801315","","1113632","","2018-04-02 17:17:17","2018-04-02 17:17:17","RxSwift - UILabel field not being updated when UITextField updated programmatically","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"33874937","1","41442782","","2015-11-23 15:41:25","","1","892","<p>I would like to hide my Realm implementation and instead of working on <code>RLMNotificationBlock</code> I would like to use RXSwift. Below how my method looks like now (<code>RLMNotificationBlock</code> is a block that takes String and <code>RLMRealm</code>):</p>

<pre><code>func addNotificationBlock(block: RLMNotificationBlock) -&gt; RLMNotificationToken? {
    let rlmObject = ...
    return rlmObject.addNotificationBlock(block)
}
</code></pre>

<p>But I would like to switch to more reactive observer-pattern way. I looked at RxSwift docs and source code of <code>rx_clickedButtonAtIndex</code>, but I cannot figure out how I should put all these things together. I guess my code at the end would look like:</p>

<pre><code>public var rx_realmContentChanged: ControlEvent&lt;Int&gt; {
    let controlEvent = ControlEvent()
    // My code go here
    return controlEvent
}
</code></pre>

<p>I'm new with RXSwift and know only the basics. Any help will be appreciated.</p>
","2116172","","","","","2017-01-03 11:44:49","Realm notification to RX block","<ios><swift><realm><rx-swift>","2","1","","","","CC BY-SA 3.0"
"33885108","1","33885958","","2015-11-24 03:46:45","","3","5329","<p>I have a <code>BehaviorSubject</code> named <code>createObservable</code> in my view model. And my view controller subscribe it. </p>

<pre><code>viewModel!.createObservable.subscribe(onNext: {[unowned self] (obj:PassbookModelType?) -&gt; Void in
    if let _ = obj{
       self.dismissVC()
    }
}, onError: { (error) -&gt; Void in
     print(error)
}).addDisposableTo(self.dispose)
</code></pre>

<p>I have a function named <code>saveObject()</code> also in the view model. If I click the navigation bar right item it will be emitted.  And there is an error will send to <code>createObservable</code>'s observer.</p>

<pre><code>func saveObject(){
     ```````
     ```````
    if condition {
        createObservable.on(Event.Next(model))
        createObservable.onCompleted()
    }else{
       createObservable.onError(MyError.someError)
    }
}
</code></pre>

<p>The problem is that if the error happened the createObservable will be closed, so I won't receive any <code>Next</code> event in the future. I tried to use <code>retry()</code>, but it seems will cause deadlock, view controller can't response any touch event any more. So can some one tell me how to fix this issue? Thanks a lot </p>

<pre><code>viewModel!.createObservable.retry().subscribe(onNext: {[unowned self] (obj:PassbookModelType?) -&gt; Void in
    if let _ = obj{
       self.dismissVC()
    }
}, onError: { (error) -&gt; Void in
     print(error)
}).addDisposableTo(self.dispose)
</code></pre>
","2593760","","","","","2015-11-24 05:18:39","rxswift error handle issue","<swift><rx-swift>","1","0","0","","","CC BY-SA 3.0"
"33916518","1","33970838","","2015-11-25 12:25:12","","7","7544","<p>I know I can do the following to map changes to a custom object's Notes' text field to a UITextView.</p>

<pre><code>self.notesViewModel.currentNote()
           .map { $0.text }
           .bindTo(self.notesTextView.rx_text)
</code></pre>

<p>How can I do the reverse using the same kind of pattern? The pattern is notesTextView.rx_text, map it to the current note's text. I know how to do the following which feels non-RxSwift-y:</p>

<pre><code>_ = notesTextView.rx_text.subscribeNext { someText in
    self.notesViewModel.currentNote().value.text = someText
}
</code></pre>

<p>IOW, it seems like I should be able to take the UITextView (aka notesTextView), map, and bind changes into the current note. Current note returns a Variable with a Note having a text String field.</p>
","175956","","175956","","2015-11-25 12:30:31","2016-03-19 09:31:44","RxSwift Way To Map and Bind UITextView's Text to Custom Object's text field?","<swift><rx-swift>","2","0","4","","","CC BY-SA 3.0"
"33968378","1","","","2015-11-28 06:22:43","","1","2426","<p>Suppose that I have a UIButton <code>loginButton</code>, I want to send a network request while tapping the button with the following code:</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    let session = self.session // NSURLSession
    loginButton.rx_tap.subscribeNext { [unowned self] in
        session.rx_response(myRequest).subscribe { event in
            switch event {
            case .Next(let data, let response):
                // Handling Response
            case .Error(let error):
                // Handling Error
            default:
                return
            }
        }.addDisposableTo(disposeBag)
     }.addDisposableTo(disposeBag)
}
</code></pre>

<p>And in such case I can resend the request by tapping the button even if an error occurred with the network request.</p>

<p>Although the code works very well, I thought it is a little bit ugly due to the nested subscription. I tried the <code>flatMap</code> method to flatten the subscription:</p>

<pre><code>loginButton.rx_tap
    .flatMap {
        return session.rx_response(myRequest)
    }
    .subscribe { event in
        switch event {
        case .Next(let data, let response):
            print(""Next"")
        case .Error(let error):
            print(error)
        default:
            return
        }
     }
     .addDisposableTo(disposeBag)
</code></pre>

<p>It seems that the two snippets above are of different logic. The latter  subscription only works while no error happened just like normal subscription rather than subscribe the network request every time the button has been tapped.</p>

<p>Is there any way to flatten the formal snippet?</p>

<hr>

<p>Added a snippet of nested subscription:</p>

<pre><code>loginButton.rx_tap
    .debug(""LoginButtonTapped"")
    .subscribeNext {
        let disposable = session.rx_response(myRequest)
            .debug(""AuthorizationRequest"")
            .subscribe(
                onNext: { [unowned self] data, response in
                    // Handling Response
            },
                onError: { [unowned self] error in
                    // Showing Error
            })

        disposable.addDisposableTo(self.disposeBag)

        let alert = UIAlertController(title: ""Please Wait."", message: ""Requesting Tokens"", preferredStyle: .Alert)
        alert.addAction(UIAlertAction(title: ""Cancel"", style: .Cancel) { _ in
            disposable.dispose()
            alert.dismissViewControllerAnimated(true, completion: nil)
        })
        self.presentViewController(alert, animated: true, completion: nil)
    }.addDisposableTo(disposeBag)
</code></pre>

<hr>

<p>Error can be caught using the following code:</p>

<pre><code>let disposable = loginButton.rx_tap
    .map { session.rx_response(request) }
    .flatMap { [unowned self] in $0.catchError(self.presentError) }
    .subscribeNext { data, response in
        // Handling Response
    }
</code></pre>

<p>I also need to cancel the network request if necessary. If I manually dispose the <code>disposable</code> in the above snippet, the subscription will be disposed and I can not send the request again.</p>
","3831195","","3831195","","2015-11-28 14:50:37","2015-11-28 14:50:37","How to transform rx_tap of UIButton to a network request directly without sending the request in a nested subscribe?","<ios><swift><reactive-programming><rx-swift>","1","0","2","","","CC BY-SA 3.0"
"33999423","1","33999732","","2015-11-30 13:09:27","","8","8340","<p>In RxSwift/RxCocoa 2.0.0- beta 3, I have a ViewModel with:</p>

<pre><code>let someString = Variable("""")

func isValidSomeString() -&gt; Observable&lt;Bool&gt;  {

    if someString.value.characters.count == 0 {
        return just(false)
    }
    return just(true)
}   
</code></pre>

<p>I have the someString bound already to a text field in the ViewController. </p>

<p>Whenever the someString (or perhaps the text field if that's a better way) changes, I want a button enabled based on if someString is valid. </p>

<p>I tried using the ""Observable&lt; Bool >"", but started going down another path. I could do this in the ViewController:</p>

<pre><code>    someViewModel.someString.subscribeNext { text -&gt; Void in

        // could just someUIButton.enabled = someViewModel.isValidSomeString(text)

    }.addDisposableTo(disposeBag)
</code></pre>

<p>Isn't there another way that is less verbose than the isValidSomeString(text) approach? We already have had nice success with a isValidLogin that returns Observable&lt; Bool > which used combineLatest. </p>
","175956","","","","","2015-12-20 20:37:59","Using RxSwift, How To Enable UIButton Based on Valid Text?","<ios><swift><rx-swift>","2","1","3","","","CC BY-SA 3.0"
"34003905","1","34007187","","2015-11-30 17:00:06","","1","553","<p>I'm using RxSwift. I have an array of textfields that is dependent on which UI is visible; it could have 1, 3, or 4 textfields in the array. </p>

<p>Iterating over the array, I create signals for each of them that maps it to a boolean indicating if the field is valid.</p>

<pre><code>let textFields: [UITextField] = ...
var signals: [Observable&lt;Bool&gt;] = []
textFields.forEach { tf in
     let sig = tf.rx_text
                 .map { string in
                        return string.length &gt; 0
                 }
     signals.append(sig)
}
</code></pre>

<p>Usually, to combine multiple signals, I would use <code>combineLatest</code> which has multiple variations to take in a different number of arguments, which would generally look like this if I had three signals</p>

<pre><code>_ = combineLatest(sig1, sig2, sig3) { $0 }
        .subscribeNext { [weak self] valid in
            self!.someButton.enabled = valid
        }
        .addDisposableTo(disposeBag)
</code></pre>

<p>Is there a way to combine signals when the number of signals being combined is unknown? </p>

<p>Alternatively, is there a way to write a function that has a variable number of generic arguments? I'm thinking this would be the starting point to write a function to combine multiple signals without knowing how many. </p>
","544094","","","","","2015-12-02 13:40:55","Combining an unkown number of Observables","<swift><generics><swift2><rx-swift>","2","0","","","","CC BY-SA 3.0"
"34060976","1","","","2015-12-03 08:22:46","","8","12646","<p>I have to enable a button based on the characters count on two textfields using RxSwift</p>

<pre><code>@IBOutlet weak var userTextField: UITextField!
@IBOutlet weak var passwordTextField: UITextField!
@IBOutlet weak var buttonToEnableDisable: UIButton!

var enabledObservable = combineLatest(userTextField.rx_text, passwordTextField.rx_text) 
{ (user,password) in
   self.loginButton.enabled = a.characters.count &gt; 0 &amp;&amp; b.characters.count &gt; 0
}
</code></pre>

<p>Finally i acomplish by doing this, but i'm not sure if its the best way:</p>

<pre><code>    _ = combineLatest(emailTextField.rx_text, passwordTextField.rx_text) { (a: String, b:String) in
        self.loginButton.enabled = (a.characters.count &gt; 0 &amp;&amp; b.characters.count &gt; 0)
    }.subscribeNext { (result) -&gt; Void in
    }
</code></pre>

<p>Edit final version:</p>

<pre><code>    _ = combineLatest(emailTextField.rx_text, passwordTextField.rx_text) { (a: String, b:String) in
        return (a.characters.count &gt; 0 &amp;&amp; b.characters.count &gt; 0)
        }.subscribeNext { enabled in
            self.loginButton.alpha = enabled ? 1 : 0.5
            self.loginButton.enabled = enabled
        }
        .addDisposableTo(disposeBag)
</code></pre>
","588125","","588125","","2015-12-03 09:43:08","2019-10-21 11:15:41","RxSwift: enable/disable button based on textfields are not empty","<swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"34087027","1","","","2015-12-04 11:10:44","","4","320","<p>We're using Swift 2.x (latest) and want to BDD (unit test) our code. As an aside, we're using <a href=""https://github.com/ReactiveX/RxSwift/"" rel=""nofollow"">RxSwift</a> too. Our overridden method does not get called in our custom test stub. Our code:</p>

<pre><code>protocol SomethingDeliverable {
    func fetchSomething(somethingId: String, associatedList: String) -&gt; Observable&lt;String&gt;
}

extension SomethingDeliverable {
    func fetchSomething(somethingId: String, associatedList: String) -&gt; Observable&lt;String&gt; {
        return create { observer in
            return NopDisposable.instance
        }
    }
}
</code></pre>

<p>For testing's sake, we have this test code:</p>

<pre><code>private class StubSomethingApi: SomethingDeliverable {

    var responseClosure: ((AnyObserver&lt;String&gt;) -&gt; Void)?

    func fetchSomething(somethingId: String, associatedList: String) -&gt; Observable&lt;String&gt; {
        return create { observer in
            if let responseClosure = self.responseClosure {
                responseClosure(observer)
            }
            return NopDisposable.instance
        }
    }
}
</code></pre>

<p>Instead of fetchSomething returning Observable&lt;<strong>String</strong>>, we would like to return Observable&lt;<strong>T</strong>> and have the StubSomethingAPI override it successfully for testing sakes. 
How can we do that?</p>
","175956","","634576","","2016-02-07 03:54:36","2016-07-17 03:56:13","How to Override Observable<T> for Testing's Sake?","<swift><unit-testing><bdd><rx-swift>","1","3","1","","","CC BY-SA 3.0"
"34091718","1","","","2015-12-04 15:26:03","","2","214","<p>I have undetermined resources that need to be fetched from a server. I tried to accomplish this by using the <code>repeatElement()</code> and <code>concat()</code> operators like this:</p>

<pre><code>repeatElement(0, CurrentThreadScheduler.instance).map({ _ -&gt; Observable&lt;[Task]&gt; in
    // API.getTasks() uses Alamofire to request data
    return API.getTasks(loggedUser, after: loggedUser.taskPullTime)
}).concat().takeWhile({ (tasks) -&gt; Bool in
    return tasks.count &gt; 0
})
</code></pre>

<p>Unfortunately, <code>repeatElement</code> will just emit an item without waiting for the old one to be handled. I think the reason is that Alamorfire executes in a private serial queue.
However, I cannot figure out how to solve this problem.</p>

<p>I used the strategy inspired from <a href=""https://stackoverflow.com/a/29594194/2408447"">here</a> in my Android project. Everything works fine because Retrofit init HTTP request in a synchronous manner.</p>
","2408447","","-1","","2017-05-23 11:54:25","2016-07-13 09:48:59","RxSwift - Fetch undetermined resources via HTTP","<swift><rx-swift>","0","4","","","","CC BY-SA 3.0"
"34092822","1","","","2015-12-04 16:22:44","","1","259","<p>I'm getting the following error when using <code>RxTableViewSectionedAnimatedDataSource</code> to a UITableView's <code>rx_itemsAnimatedWithDataSource()</code>.</p>

<p>Here's a screengrab of the error:</p>

<p><a href=""https://i.stack.imgur.com/5vrBd.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5vrBd.png"" alt=""Xcode Error""></a></p>

<blockquote>
  <p>Cannot invoke 'rx_itemsAnimatedWithDataSource' with an argument list
  of type
  '(RxTableViewSectionedAnimatedDataSource)'</p>
  
  <p>Expected an argument list of type '(DataSource)'</p>
</blockquote>

<p><code>self.dataSource</code> is of type: </p>

<p><code>RxTableViewSectionedAnimatedDataSource&lt; DateSelectorSectionModel&gt;</code></p>

<p>and here's the generated interface for <code>DateSelectorSectionModel</code>, plus related types:</p>

<pre><code>typealias DateSelectorSectionModel = SectionModel&lt;SectionDesc, SectionDesc&gt;

enum SectionType {
    case StartDate, EndDate, TimeZone, AllDay
}

enum SectionState {
    case Present, Missing, Dirty
}

enum SectionSelection {
    case NotSelected, Selected
}

struct SectionDesc {
    var type: SectionType
    var state: SectionState
    var selectionState: SectionSelection
    init(type: SectionType, state: SectionState, selection: SectionSelection)
    public func getSectionModel() -&gt; DateSelectorSectionModel
}

extension EventDetailsDateSelectorViewModel {
    public var rows: RxCocoa.Driver&lt;[DateSelectorSectionModel]&gt; { get }
}
</code></pre>

<p>Any ideas?  Thanks!</p>
","405863","","405863","","2015-12-04 16:46:12","2015-12-07 21:20:58","Build error when binding a `RxTableViewSectionedAnimatedDataSource` to a UITableView","<ios><swift><uitableview><rx-swift>","1","0","","","","CC BY-SA 3.0"
"34095592","1","34095866","","2015-12-04 19:00:15","","12","15155","<p>I'm using RxSwift 2.0.0-beta</p>

<p>How can I combine 2 observables of different types in a zip like manner? </p>

<pre><code>// This works
[just(1), just(1)].zip { intElements in
    return intElements.count
}

// This doesn't
[just(1), just(""one"")].zip { differentTypeElements in 
    return differentTypeElements.count
}
</code></pre>

<p>The current workaround I have is to map everything to an optional tuple that combines the types, then zips optional tuples into a non-optional one.</p>

<pre><code>    let intObs = just(1)
        .map { int -&gt; (int: Int?, string: String?) in
            return (int: int, string: nil)
    }
    let stringObs = just(""string"")
        .map { string -&gt; (int: Int?, string: String?) in
        return (int: nil, string: string)
    }
    [intObs, stringObs].zip { (optionalPairs) -&gt; (int: Int, string: String) in
        return (int: optionalPairs[0].int!, string: optionalPairs[1].string!)
    }
</code></pre>

<p>That's clearly pretty ugly though. What is the better way?</p>
","2474498","","","","","2020-03-30 20:21:58","RxSwift: Use Zip with different type observables","<swift><rx-swift>","3","0","3","","","CC BY-SA 3.0"
"34112349","1","34164026","","2015-12-05 23:54:31","","7","15448","<p>How can I create a RxSwift-style TableViewController?</p>

<p>I am trying to create a simple TableViewController that uses RxSwift and doesn't have any sections.</p>

<p>I have looked and played around with <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/TableView/TableViewController.swift"" rel=""noreferrer"">https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/TableView/TableViewController.swift</a> extensively.</p>

<p>I got the code down to only one section and using only users. However, it seems like I'm stuck with having a SectionModel.</p>

<pre><code>//
//  TableViewController.swift
//  RxExample
//
//  Created by carlos on 26/5/15.
//  Copyright (c) 2015 Krunoslav Zaher. All rights reserved.
//
// modified by Mike Finney for a StackOverflow question

import UIKit
#if !RX_NO_MODULE
import RxSwift
import RxCocoa
#endif

class TableViewController: ViewController, UITableViewDelegate {


    @IBOutlet weak var tableView: UITableView!

    var disposeBag = DisposeBag()

    let users = Variable([User]())

    let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;String, User&gt;&gt;()

    typealias Section = SectionModel&lt;String, User&gt;

    override func viewDidLoad() {
        super.viewDidLoad()

        self.navigationItem.rightBarButtonItem = self.editButtonItem()

        users
            .map { [ SectionModel(model: ""ok"", items: $0) ] }
            .bindTo(tableView.rx_itemsWithDataSource(dataSource))
            .addDisposableTo(disposeBag)

        dataSource.cellFactory = { (tv, ip, user: User) in
            let cell = tv.dequeueReusableCellWithIdentifier(""Cell"")!
            cell.textLabel?.text = user.firstName + "" "" + user.lastName
            return cell
        }

        // customization using delegate
        // RxTableViewDelegateBridge will forward correct messages
        tableView.rx_setDelegate(self)
            .addDisposableTo(disposeBag)

        tableView.rx_itemSelected
            .subscribeNext { [unowned self] indexPath in
                self.showDetailsForUserAtIndexPath(indexPath)
            }
            .addDisposableTo(disposeBag)

        tableView.rx_itemDeleted
            .subscribeNext { [unowned self] indexPath in
                self.removeUser(indexPath)
            }
            .addDisposableTo(disposeBag)

        RandomUserAPI.sharedAPI.getExampleUserResultSet()
            .subscribeNext { [unowned self] array in
                self.users.value = array
            }
            .addDisposableTo(disposeBag)

    }

    override func setEditing(editing: Bool, animated: Bool) {
        super.setEditing(editing, animated: animated)
        tableView.editing = editing
    }

    // MARK: Table view delegate ;)

    func tableView(tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat {
        return 0
    }

    // MARK: Navigation

    private func showDetailsForUserAtIndexPath(indexPath: NSIndexPath) {
        let sb = UIStoryboard(name: ""Main"", bundle: NSBundle(identifier: ""RxExample-iOS""))
        let vc = sb.instantiateViewControllerWithIdentifier(""DetailViewController"") as! DetailViewController
        vc.user = getUser(indexPath)
        self.navigationController?.pushViewController(vc, animated: true)
    }

    // MARK: Work over Variable

    func getUser(indexPath: NSIndexPath) -&gt; User {
        var array: [User]
        switch indexPath.section {
        case 0:
            array = users.value
        default:
            fatalError(""Section out of range"")
        }
        return array[indexPath.row]
    }

    func moveUserFrom(from: NSIndexPath, to: NSIndexPath) {
        var user: User
        var fromArray: [User]
        var toArray: [User]

        fromArray = users.value
        user = fromArray.removeAtIndex(from.row)
        users.value = fromArray

        toArray = users.value
        toArray.insert(user, atIndex: to.row)
        users.value = toArray
    }

    func addUser(user: User) {
        var array = users.value
        array.append(user)
        users.value = array
    }

    func removeUser(indexPath: NSIndexPath) {
        var array: [User]
        switch indexPath.section {
        case 0:
            array = users.value
            array.removeAtIndex(indexPath.row)
            users.value = array
        default:
            fatalError(""Section out of range"")
        }
    }

}
</code></pre>

<p>I don't want to even use a SectionModel if I can help it.</p>

<p>So perhaps another way to ask is ""What is the non-section version of RxTableViewSectionedReloadDataSource?""</p>
","175956","","","","","2015-12-08 19:09:01","RxSwift and How To Make Simple TableViewController?","<swift><rx-swift>","1","4","6","","","CC BY-SA 3.0"
"34134365","1","","","2015-12-07 13:08:38","","9","10240","<p>I have this custom implementation of <code>Alamofire</code>:</p>

<pre><code>protocol HTTPProtocol: class {
    typealias RequestType
    typealias RespondType
    func doRequest(requestData: RequestType) -&gt; Self
    func completionHandler(block:(Result&lt;RespondType, NSError&gt;) -&gt; Void) -&gt; Self
}

//example of a request:
locationInfo
      //Make a request
    .doRequest(HTTPLocationInfo.RequestType(coordinate: $0))

      //Call back when request finished
    .completionHandler { result in
        switch result {
            case .Success(let info): self.locationInfoRequestSuccess(info)
            case .Failure(let error): self.locationInfoRequestFailed(error)
        }               
    }
</code></pre>

<p>I want to apply MVVM and RxSwift into my project. However, I can't find a proper way to do this.</p>

<p>What I want to achieve is a <code>ViewModel</code> and a <code>ViewController</code> that can do these things:</p>

<pre><code>class ViewController {
    func googleMapDelegate(mapMoveToCoordinate: CLLocationCoordinate2D) {
        // Step 1: set new value on `viewModel.newCoordinate` and make a request
    }

    func handleViewModelCallBack(resultParam: ...*something*) {
        // Step 3: subscribeOn `viewModel.locationInfoResult` and do things.
    }
}

class ViewModel {
    //Result if a wrapper object of Alamofire.
    typealias LocationInfoResult = (Result&lt;LocationInfo.Respond, NSError&gt;) -&gt; Void
    let newCoordinate = Variable&lt;CLLocationCoordinate2D&gt;(kInvalidCoordinate)
    let locationInfoResult: Observable&lt;LocationInfoResult&gt;

    init() {
        // Step 2: on newCoordinate change, from step 1, request Location Info
        // I could not find a solution at this step
        // how to make a `completionHandler` set its result on `locationInfoResult`
    }
}
</code></pre>

<p>Any help is deeply appreciated. Thank you.</p>
","2816225","","","","","2017-11-14 12:27:11","Combining Alamofire and RxSwift","<ios><swift><mvvm><rx-swift>","2","1","3","","","CC BY-SA 3.0"
"34168018","1","34200825","","2015-12-08 23:23:50","","5","4247","<p><strong>Say I have the following <a href=""https://github.com/ReactiveX/RxSwift"">SwiftRx</a> (2.0.0-beta.4) <a href=""https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel"">MVVM</a> situation:</strong></p>

<p>I have 4 things: </p>

<ul>
<li>ItemListViewController</li>
<li>ItemsViewModel</li>
<li>ItemsManager</li>
<li>Item</li>
</ul>

<p><strong>ItemsManager</strong> has a func called <strong>items()</strong> that will return Items in an observable RxSwift way.  </p>

<p><strong>ItemsViewModel</strong> only needs to pass the items on up for now. Later maybe apply display logic on an Item attribute for the View Controller's sake (like displaying a date correctly.) </p>

<p><strong>ItemListViewController</strong> will put the items in a table, one Item per row.</p>

<p>An Item has 4 attributes (like an identifier, date, ...) that will be displayed in the table row cell.</p>

<p><strong>How does one set it up in the ItemsViewModel and ItemsManager so that when items are added, removed, changed in the manager that they go through the ItemsViewModel?</strong></p>

<p>From reading the <a href=""https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Subjects.md"">documentation</a> and looking at the <a href=""https://github.com/ReactiveX/RxSwift"">Rx.playground</a>, it seems like the thing to use for now is an RxSwift <strong>PublishSubject&lt; Item ></strong> or maybe an RxSwift <strong>map</strong> that is somehow subscribed to the manager's items()</p>

<p>How to do this well?</p>

<p>The ItemsManager has something like this right now:</p>

<pre><code>func items() -&gt; Observable&lt;Item&gt; {
    // placeholder for now
    return [Item(identification: ""123"", content: """"), Item(identification: ""456"", content:""""), Item(identification: ""789"", content:"""")].toObservable()
}
</code></pre>

<p>The View Model has this in it:</p>

<pre><code>let items = Variable(/* how to subsribe to the items in the manager? */)
</code></pre>
","175956","","175956","","2015-12-08 23:36:05","2015-12-10 11:33:50","RxSwift MVVM How to Set up View Model With Item Manager?","<swift><rx-swift>","1","0","9","","","CC BY-SA 3.0"
"34175540","1","","","2015-12-09 09:47:34","","4","2313","<p>I have a project where I'm using Moya with RxSwift extensions.
The simple use cases work fine, I'm able to do requests and get responses in the form of Observables.</p>

<pre><code>public func test() -&gt; Observable&lt;Response&gt; {
    return provider
    .request(.test)
    .retry(5)
}
</code></pre>

<p>I can then subscribe to the observable and print the response with no problem.</p>

<p>But now I need to handle authentication logic. The way it works is that I run the above request with a token added as an HTTP Header Field. Moya allows me to that transparently by using <em>endpointByAddingHTTPHeaderFields</em> in the endpointClosure. No problem so far.</p>

<p>The problem arises when the request fails with HTTP status 401, that means I need to re-authenticate by calling another endpoint</p>

<pre><code>provider.request(.auth(user, pass)).retry(5)
</code></pre>

<p>This returns another Observable that I can easily map to JSON to get the new token.</p>

<p>I then just have to call <em>test()</em> again!</p>

<p><strong>So my question is...</strong> How can I add this authentication logic inside the <em>test()</em> function above, so that the Observable returned by <em>test()</em> is already guaranteed to have run the re-authentication logic in case of failure and be the result of a second re-authenticated request.</p>

<p>I'm very new to RXSwift and RX in general, so I'm a bit clueless about the operators I would use to do this.</p>

<p>Thanks! </p>
","1286977","","","","","2017-01-25 13:55:56","Handling re-authentication with RxSwift and Moya","<ios><swift><rx-swift>","1","3","","","","CC BY-SA 3.0"
"34259870","1","43484684","","2015-12-14 04:38:30","","4","1048","<p>I am attempting to upload multiple photos to a server using ReactiveX (RxSwift), gathering the responses from each request, and then making one final request to complete the submission. </p>

<p>Everything seems to be working fairly well until I attempt to <code>reduce</code> all of the responses. The final <code>subscribeNext</code> is never called. (Perhaps I misunderstand how <code>flatMap</code> or <code>reduce</code> works?)</p>

<p>Specifically, this is how I am attempting to perform this procedure. </p>

<ul>
<li><p>Prepare an observable to encode each photo (<code>self.imageMgr</code> is an instance of <code>PHCachingImageManager()</code>)</p>

<pre><code>func getPhotoDataObservable(asset: PHAsset) -&gt; Observable&lt;NSData&gt; {
    return create { observer in
        self.imageMgr.requestImageForAsset(asset,
            targetSize: PHImageManagerMaximumSize,
            contentMode: .AspectFit,
            options: nil,
            resultHandler: { (myImage, myInfo) -&gt; Void in
                let data = UIImageJPEGRepresentation(myImage!, 1.0)!
                NSLog(""Encoded photo"")
                observer.onNext(data)
                self.converts += 1
                if self.converts == self.userReview.photos.count {
                    NSLog(""Completed encoding photos"")
                    observer.onCompleted()
                }
            })
        return NopDisposable.instance
    }
}
</code></pre></li>
<li><p>Prepare an observable to upload each photo once encoded (with Alamofire and RxAlamofire)</p>

<pre><code>func getPostPhotoObservable(photoData: NSData) -&gt; Observable&lt;ReviewPhotoObject&gt; {
    return create { observer in
        NSLog(""Uploading Photo"")

        upload(.POST,
            urlRequest.URLString,
            headers: nil,
            multipartFormData: { mfd in
                mfd.appendBodyPart(data: photoData, name: ""image"", fileName: ""image"", mimeType: ""image/jpeg"")
            },
            encodingMemoryThreshold: Manager.MultipartFormDataEncodingMemoryThreshold,
            encodingCompletion: { encodingResult in
                switch encodingResult {
                case .Success(let upload, _, _):
                    upload.responseJSON(completionHandler: { (myResponse) -&gt; Void in
                        if let photoResponse = myResponse.result.value {
                            let photoObject = photoResponse.objectForKey(""photo"")!
                            let photo = ReviewPhotoObject()
                            photo.photoID = photoObject.objectForKey(""id"")! as! NSNumber
                            NSLog(""Uploaded Photo"")
                            observer.onNext(photo)
                        }

                        self.uploads += 1
                        if self.uploads == self.userReview.photos.count {
                            NSLog(""Completed uploading photos"")
                            observer.onCompleted()
                        }
                    })

                case .Failure(let encodingError):
                    observer.onError(encodingError)
                    print(encodingError)
                }
            })

        return NopDisposable.instance
    }
}
</code></pre></li>
<li><p>Finally, put it all together</p>

<pre><code>func postReview(review: MyReview) {
    self.userReview = review

    _ = review.photos.toObservable().flatMap { photos in
        return self.getPhotoDataObservable(photos)
    }.flatMap { photoData in 
        return self.getPostPhotoObservable(photoData)
    }.reduce([], { var accumulator, photo: ReviewPhotoObject) -&gt; [Int] in
        accumulator.append(Int(photo.photoID))
        return accumulator
    }).subscribeNext({ (photoIds) -&gt; Void in
        print(photoIds) // Never called
    })
}
</code></pre></li>
</ul>

<p>When run (with 2 photos for example), this is the output:</p>

<pre><code>Encoded photo
Uploading photo
Encoded photo
Uploading photo
Completed encoding photos
Uploaded photo
Uploaded photo
Completed uploading photos
</code></pre>

<p>But <code>subscribeNext</code> is never called. Since documentation on RxSwift specifically is still a little thin, I was hoping someone around here could clue me in on what I'm misunderstanding. </p>
","2246189","","","","","2017-04-19 01:21:10","Managing multiple uploads with ReactiveX (on iOS with Swift and Alamofire)","<ios><reactive-programming><alamofire><rx-swift>","1","1","1","","","CC BY-SA 3.0"
"34351664","1","34497802","","2015-12-18 08:48:39","","13","18544","<p>I have a function that return a Bool Observable depending if it was ok or not.</p>

<pre><code>func test() -&gt; Observable&lt;Bool&gt; {
   if everythingIsOk {
      return just(true)
   }
   return just(false) &lt;- how can i here return a custom error to retrieve what failed?
}
</code></pre>
","588125","","","","","2017-01-03 05:45:15","RxSwift: Return a new observable with an error","<ios><swift><rx-swift>","3","1","2","","","CC BY-SA 3.0"
"34406196","1","34419079","","2015-12-21 23:37:14","","41","11929","<p>We're trying to use Swift structs where we can. We are also using RxSwift which has methods which take closures. When we have a struct that creates a closure that refers to <strong>self</strong>, that creates a <a href=""https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html"" rel=""noreferrer"">strong reference cycle</a>.</p>

<pre><code>import Foundation
import RxSwift

struct DoesItLeak {

    var someState: String = ""initial value""
    var someVariable: Variable&lt;String&gt; = Variable(""some stuff"")

    let bag = DisposeBag()

    mutating func someFoo() {

        someVariable.subscribeNext { person in

            self.someState = ""something""
        }
        .addDisposableTo(bag)
    }
}
</code></pre>

<p>How do I know this? If I create 100,000 DoesItLeak objects and call someFoo() on each of them, I believe I have 100,000 objects with strong reference cycles. In other words, when I get rid of the DoesItLeak array containing those objects, the objects stay in memory. If I do not call someFoo(), there is no problem. </p>

<p>Variable is a class. So, I can see this memory issue by using xcode's Instruments' Allocations and filtering in <strong>Variable&lt; String ></strong> </p>

<p><a href=""https://i.stack.imgur.com/DYvDY.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/DYvDY.png"" alt=""Filtering By Variable""></a></p>

<p><a href=""https://i.stack.imgur.com/4wb98.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/4wb98.png"" alt=""enter image description here""></a></p>

<p>If I try to use [weak self] such as in the following, I get a compiler error:</p>

<pre><code>someVariable.subscribeNext { [weak self] person in
</code></pre>

<p>The compiler error is ""weak cannot be applied to non-class type"" </p>

<p>In real/non-example code, we access methods and variables via self and it's a memory issue.</p>

<p><strong>How can I resolve this memory issue while keeping the DoesItLeak a struct?</strong> </p>

<p>Thanks for your help.</p>
","175956","","175956","","2015-12-22 00:37:47","2020-08-02 05:29:27","Swift Struct Memory Leak","<swift><memory-leaks><rx-swift>","4","14","18","","","CC BY-SA 3.0"
"34510854","1","","","2015-12-29 12:14:25","","0","410","<p>Let's say I have a stream of dogs <code>private var dogs: Observable&lt;[Dogs]&gt;</code>. Every time a new value is produced my block is called where I create a new dataSource and delegate for my <code>UIPickerView</code> and then within the block I call <code>pickerView.reloadAllComponents()</code> but my view appears with an empty pickerView, even though the dataSource and delegate are queried.</p>

<p>Example code:</p>

<pre><code>self.dataStream
        .subscribeNext {
            self.dataSource = PickerViewDataSource(data: $0)
            self.pickerView.dataSource = self.dataSource
            self.delegate = PickerViewDelegate(data: $0, selectedRow: self._selectedRowStream)
            self.pickerView.delegate = self.delegate
            self.pickerView.reloadAllComponents()
        }.addDisposableTo(self.disposeBag)
</code></pre>

<p>Debugging the dataSource and delegate I know these are queried and the reason I am keep dataSource and delegate reference in the UIViewController is due to the fact that the <code>UIPickerView</code> holds a weak reference for these.</p>

<p>This one of the last strategies I have tried and still get the same result. Any help would be appreciated. Thanks.</p>

<p>Update:</p>

<p>DogPickerViewDataSource:</p>

<pre><code>class DogPickerViewDataSource: NSObject, UIPickerViewDataSource {

    private var dogs: [Dog]

    init(
        dogs: [Dog]
    ) {
        self.dogs = dogs
    }

    func numberOfComponentsInPickerView(pickerView: UIPickerView) -&gt; Int {
        return 1
    }

    func pickerView(pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int {
        return dogs.count
    }
}
</code></pre>

<p>DogPickerViewDelegate:</p>

<pre><code>class DogPickerViewDelegate: NSObject, UIPickerViewDelegate {

    private var selectedRow: BehaviorSubject&lt;Int&gt;
    private var dogs: [Dog]

    init(
        dogs: [Dog],
        selectedRow: BehaviorSubject&lt;Int&gt;
    ) {
        self.dogs = dogs
        self.selectedRow = selectedRow
    }

    func pickerView(pickerView: UIPickerView, attributedTitleForRow row: Int, forComponent component: Int) -&gt; NSAttributedString? {
        let dogName = (self.dogs[row].name)!
        return NSAttributedString(string: dogName)
    }

    func pickerView(pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {
        self.selectedRow.onNext(row)
    }
}
</code></pre>
","2982993","","2982993","","2015-12-29 14:05:53","2015-12-30 10:58:49","UIPickerView not displaying data even after requery","<ios><swift><swift2><uipickerview><rx-swift>","1","5","1","","","CC BY-SA 3.0"
"34529132","1","34574813","","2015-12-30 11:56:44","","1","2083","<p>This is a short version of my code which will reproduce the problem:</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class ViewController: UIViewController {
    @IBOutlet weak var button: UIButton!

    let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        let source = button.rx_tap.map { _ in ""source"" }

        let delay = source.map { _ in ""delayed"" }
            .delaySubscription(2.0, MainScheduler.sharedInstance)

        [source, delay].toObservable().merge()
            .subscribeNext { print($0) }
            .addDisposableTo(disposeBag)
    }
}
</code></pre>

<p>I want the 'delayed' signal to fire 2 seconds after I tap the button, but no such luck. What actually happens: the first time I tap the button, 'source' fires but nothing else happens. Then when I tap again, 'source' and 'delayed' fire at the same time. I figured it was some thread problem, so I tried adding <code>observeOn(MainScheduler.sharedInstance)</code> everywhere but it didn't help. Any ideas?</p>

<p>Update: by adding <code>.debug()</code> to the streams I found out that the delayed stream actually subscribes to the source 2 seconds later. But that still doesn't explain why it doesn't fire its notifications 2 seconds later as well.</p>
","5706863","","1113632","","2018-01-29 15:20:06","2018-01-29 15:20:06","delaySubscription doesn't work with rx_tap","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"34548158","1","34687380","","2015-12-31 15:04:11","","7","4624","<p>I have an <code>HTTPService</code> which returns an <code>Observable&lt;NSData&gt;</code>. My goal is to compose that service into another service, <code>ServiceA</code> which transforms that data for my use case. Using <code>Observable.create</code> in RxSwift 2.0.0-rc.0 in <code>ServiceA</code> it's straight forward enough. My question is how to properly handle the disposable returned from the subscription of the <code>HTTPService</code>. </p>

<p>If I don't do anything I get the compile time warning that the <code>result of call is unused</code>: <a href=""http://git.io/rxs.ud"" rel=""noreferrer"">http://git.io/rxs.ud</a>. I understand from reading that if I do nothing it's likely ok: (where <code>xs</code> mentioned below is <code>let xs: Observable&lt;E&gt; ....</code></p>

<blockquote>
  <p>In case xs terminates in a predictable way with Completed or Error message, not handling subscription Disposable won't leak any resources, but it's still preferred way because in that way element computation is terminated at predictable moment. </p>
</blockquote>

<p>So here is how I am currently addressing it, and also where I am wondering if I am doing this properly or if I have misunderstood something.</p>

<pre><code>public struct ServiceA{

    public static func changes() -&gt; Observable&lt;ChangeSet&gt;{
        return Observable.create{ observable in

            // return's Observable&lt;NSData&gt;
            let request = HTTPService.get(""https://httpbin.org/get"")

            let disposable = request.subscribe(
                onNext: { data in
                    // Do more work to transform this data
                    // into something meaningful for the application.
                    // For example purposes just use an empty object
                    observable.onNext(ChangeSet())
                    observable.onCompleted()
                },

                onError:{ error in
                    observable.onError(error)
                })

            // Is this the right way to deal with the
            // disposable from the subscription in this situation?
            return AnonymousDisposable{
                disposable.dispose()
            }
        }
    }
}
</code></pre>
","1060314","","","","","2016-01-08 22:47:16","Proper way to dispose of a disposable within an observable","<swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"34611578","1","34705652","","2016-01-05 12:20:17","","6","189","<p>I'm exploring Rx, and I wanted to see if I could declaratively define the input <em>and</em> output of some UI element in terms of each other, before this element's component is initialized.</p>

<p>This is what it would look like:</p>

<pre><code>class ViewController: UIViewController {
    @IBOutlet weak var button: UIButton!

    var child: ButtonComponent!

    override func viewDidLoad() {
        super.viewDidLoad()

        let buttonInput = PublishSubject&lt;()&gt;()
        let buttonOutput = buttonInput
            .scan(0) { count, _ in
                count + 1
            }
            .map { $0.description }

        self.child = ButtonComponent(
            button: self.button,
            input: buttonInput,
            output: buttonOutput
        )
    }
}

class ButtonComponent {
    weak var button: UIButton!
    let disposeBag = DisposeBag()

    init(button: UIButton, input: PublishSubject&lt;()&gt;, output: Observable&lt;String&gt;) {
        self.button = button

        output
            .subscribeNext { string in
                button.setTitle(string, forState: .Normal)
            }
            .addDisposableTo(disposeBag)

        button.rx_tap
            .subscribeNext {
                input.onNext($0)
            }
            .addDisposableTo(disposeBag)
    }
}
</code></pre>

<p>The problem here is that I'm using the PublishSubject to push updates to the input stream, which is imperative and advised against. Does Rx provide a way to somehow add sequences to an already running observable?</p>
","5706863","","","","","2016-01-10 13:00:01","Is there a way to declaratively push updates to an observable after it has been defined?","<system.reactive><rx-swift>","1","1","","","","CC BY-SA 3.0"
"34641578","1","34657005","","2016-01-06 19:51:37","","1","1188","<p>I am using <code>ModelView-ViewModel</code> in the project I am currently working and using <code>RxSwift</code>, <code>RxBlocking</code> &amp; <code>RxTests</code>. Currently I am attempting to test the ViewModel but having many troubles to get my head around this.</p>

<p>So lets say I have an <code>ExampleViewModel</code> for my <code>ExampleViewController</code>. My <code>ExampleViewModel</code> is expecting an <code>Observable</code> stream which is the combination (<code>combineLatest</code>) of two streams from <code>UITextField</code>, one being if the textField is either focused and the other is the stream of text; so something like <code>Observable&lt;(Bool, String)&gt;</code>. Depending on whether focused and the context of the string my <code>ExampleViewModel</code> will emit an event into its internally exposed property which is an <code>Observable</code> the state of the <code>UITextField</code>'s backgroundColor; <code>Observable&lt;UIColor&gt;</code>. </p>

<p><code>ExampleViewModel.swift</code> :</p>

<pre><code>class ExampleViewModel {

private let disposeBag = DisposeBag()

private let _textFieldColor: PublishSubject&lt;UIColor&gt;
var textFieldColor: Observable&lt;UIColor&gt; { get { return self._textFieldColor.asObservable() } }

init(textFieldObservable: Observable&lt;(Bool, String)&gt;) {
    textFieldObservable.subscribeNext { (focus, text) in
        self.validateTextField(focus, text: text)
    }.addDisposableTo(self.disposeBag)
}

func validateTextField(focus: Bool, text: String) {
    if !focus &amp;&amp; !text.isEmpty {
        self._textFieldColor.onNext(UIColor.whiteColor())
    } else {
        self._textFieldColor.onNext(UIColor.redColor())
    }
}
}
</code></pre>

<p>(sorry I don't know how to format it correctly)</p>

<p>Basically I would like to test the <code>ExampleViewModel</code> class and test that it emits the correct <code>UIColor</code> by controlling the focus and text inputs.</p>

<p>Thanks</p>
","2982993","","2982993","","2016-01-07 10:06:31","2016-01-07 13:58:45","Testing ViewModel with RxSwift","<mvvm><swift2><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"34654999","1","35941186","","2016-01-07 12:20:55","","11","2667","<p>I'm trying to understand in detail</p>

<pre><code>.drive(resultsTableView.rx_itemsWithCellIdentifier(""WikipediaSearchCell"",
       cellType: WikipediaSearchCell.self)) 
          { (_, viewModel, cell) in
              cell.viewModel = viewModel
          }
</code></pre>

<p>from WikipediaSearchViewController.swift lines 47-64.
I've tried to extract the arguments to look at the concrete type signatures, but a rewrite to</p>

<pre><code>    let temp1 = searchBar.rx_text
        .asDriver()
        .throttle(0.3)
        .distinctUntilChanged()
        .flatMapLatest { query in
            API.getSearchResults(query)
                .retry(3)
                .retryOnBecomesReachable([], reachabilityService: ReachabilityService.sharedReachabilityService)
                .startWith([]) // clears results on new search term
                .asDriver(onErrorJustReturn: [])
        }
        .map { results in
            results.map(SearchResultViewModel.init)
    }

    let driveArg1 = resultsTableView.rx_itemsWithCellIdentifier(""WikipediaSearchCell"", cellType: WikipediaSearchCell.self)
    let driveArg2 = { (_, viewModel: SearchResultViewModel, cell: WikipediaSearchCell) in
        cell.viewModel = viewModel
    }
    temp1.drive(driveArg1, curriedArgument: driveArg2)
        .addDisposableTo(disposeBag)
</code></pre>

<p>gives </p>

<blockquote>
  <p>cannot invoke 'rx_itemsWithCellIdentifier' with an argument list of type '(String, cellType: UITableViewCell.Type)'</p>
</blockquote>

<p>for driveArg1 and</p>

<blockquote>
  <p>type of expression is ambiguous without more context</p>
</blockquote>

<p>for driveArg2.</p>

<p>The signatures of <code>drive</code> and <code>rx_itemsWithCellIdentifier</code> are</p>

<pre><code>public func drive&lt;R1, R2&gt;(with: Self -&gt; R1 -&gt; R2, curriedArgument: R1) -&gt; R2 {}

public func rx_itemsWithCellIdentifier(cellIdentifier: String, cellType: Cell.Type = Cell.self)(source: O)(configureCell: (Int, S.Generator.Element, Cell) -&gt; Void) -&gt; Disposable {}
</code></pre>

<p>but at this point Swift syntax is darn incomprehensible for me. Can anyone explain the signatures and what happens in the code?</p>
","280774","","1173513","","2016-03-11 13:16:34","2016-03-14 07:52:05","What does the following example code from RxSwift/RxCocoa do?","<swift><rx-swift>","1","1","1","","","CC BY-SA 3.0"
"34668242","1","35582632","","2016-01-08 01:49:19","","10","11822","<p>I am trying to convert a project to use RxSwift and MVVM. I have a service that syncs a list of data from Parse on every app launch and I basically want to make sure I am taking the correct approach.</p>

<p>What I have done is made a Variable subject and then allow my models to listen to this.
ParseService:</p>

<pre><code>let rx_parseMushrooms = Variable&lt;[ParseMushroom]&gt;([])
</code></pre>

<p>MushroomLibraryModel:</p>

<pre><code>_ = parseService.rx_parseMushrooms
    .asObservable()
    .map { (parseMushrooms:[ParseMushroom]) -&gt; [Mushroom] in
        let mushrooms = parseMushrooms.map { (parseMushroom:ParseMushroom) -&gt; Mushroom in
            let mushroom = Mapper&lt;Mushroom&gt;().map(parseMushroom.dictionaryWithValuesForKeys(parseMushroom.allKeys()))
            return mushroom!
        }

        return mushrooms
    }
    .subscribeNext({ (mushrooms:[Mushroom]) -&gt; Void in
        self.mushrooms = mushrooms
        print(mushrooms)
    })
</code></pre>

<p>I do the same for expressing the sync state.</p>

<p>ParseService:</p>

<pre><code>struct SyncState {
    enum State {
        case Unsynced, ConnectingToServer, SyncingInfo, FetchingImageList, SyncingImages, SyncComplete, SyncCompleteWithError
    }

    var infoToSync = 0
    var imagesToSync = 0
    var imagesSynced = 0

    var state = State.Unsynced
}

let rx_syncState = Variable(SyncState())
</code></pre>

<p>I then update the variable a la</p>

<pre><code>self.rx_syncState.value = self.syncState
</code></pre>

<p>SyncViewModel:</p>

<pre><code>_ = parseService.rx_syncState
     .asObservable()
     .subscribeNext { [weak self] (syncState:ParseService.SyncState) -&gt; Void in
          switch syncState.state {
              //show stuff based on state struct
          }
      }
</code></pre>

<p>Anyways, I would greatly appreciate if someone can tell me if this is a good way of going about it or if I am misusing RxSwift (and guide me on how I should be doing this).</p>

<p>Cheers! </p>
","3247557","","1082528","","2019-08-02 12:36:36","2019-08-02 12:36:36","RxSwift Using Variables Correctly","<swift><mvvm><architecture><rx-swift>","1","0","4","","","CC BY-SA 4.0"
"34772494","1","34789400","","2016-01-13 16:53:43","","46","44767","<p>Currently I am trying to get RxSwift working. And I want to create a custom Observable. But I think I am doing something wrong. </p>

<p>I have distilled what I do to this minimal sample:</p>

<pre><code>import Foundation
import RxSwift

class Example
{

    let exampleObservable : Observable&lt;String&gt; = Observable.create { (observer) in
        observer.on(.Next(""hello""))
        observer.on(.Completed)

        return AnonymousDisposable { }
    }

    let exampleObserver : AnyObserver&lt;String&gt;?

    func run()
    {
        self.exampleObserver = exampleObservable.subscribeNext({ (text) -&gt; Void in
            print(text)
        })  
    }

}

let ex = Example()
ex.run()
</code></pre>

<p>Is this correct? In the run method, the subscribeNext method is autocompleted that way by XCode.</p>

<p><a href=""https://i.stack.imgur.com/kMKjb.png""><img src=""https://i.stack.imgur.com/kMKjb.png"" alt=""Example""></a></p>

<p>But when I run it I get the following compilation error: </p>

<pre><code>Cannot Invoke 'substribeNext' with an argument list of type ((String) -&gt; Void)
</code></pre>
","393548","","","","","2021-03-23 10:04:51","RxSwift minimal Observable.create example","<swift><rx-swift>","4","0","18","","","CC BY-SA 3.0"
"34860272","1","35139696","","2016-01-18 17:07:08","","6","1718","<p>I have a <code>ViewController</code> in which on the <code>init()</code> I create a hot stream using <code>PublishSubject</code>. I then pass in the stream to my <code>ViewModel</code> using <code>stream.asObservable()</code> in the <code>viewDidLoad()</code>, as the <code>ViewModel</code> has other dependencies which are streams generated from the views, so it has to wait until the binding of the views is finished before creating the <code>ViewModel</code>. After creating the <code>ViewModel</code> I push an event in my <code>ViewController</code> into the stream and then expect the ViewModel to react to the event by firing off an asynchronous request (which has also been wrapped with Rx).</p>

<p>ViewController:</p>

<pre><code>class ExampleViewController: ViewController {

    ....

    private let exampleStream: PublishSubject&lt;Bool&gt;

    init() {
        self.exampleStream = PublishSubject&lt;Bool&gt;()
    }

    viewDidLoad() {
        self.viewModel = viewModelFactory.create(exampleStream.asObservable())
        self.exampleStream.onNext(true)
    }

    ....
}
</code></pre>

<p>ViewModel:</p>

<pre><code>class ExampleViewModel {

    init(stream: Observable&lt;Bool&gt;) {
        stream.flatMap { _ in
            doSomethingAsyncThatReturnsAnObservable()
        }
    }

    private func doSomethingAsyncThatReturnsAnObservable() -&gt; Observable&lt;CustomObject&gt; { ... }
}
</code></pre>

<p>My problem is that <code>doSomethingAsyncThatReturnsAnObservable()</code> is called twice when only one event is inside the stream. I have checked that fact by using <code>var count = 1; stream.subscribeNext { _ in print(count++) }</code> which prints <code>1</code>.</p>

<p>Any idea as to why <code>subscribeNext()</code> fires once on each event but <code>flatMap()</code> fires twice?</p>
","2982993","","343299","","2016-07-13 11:16:52","2016-07-13 11:16:52","flatMap() called twice on single event","<swift><mvvm><swift2><rx-swift>","1","0","","","","CC BY-SA 3.0"
"34971834","1","35063723","","2016-01-24 03:20:31","","2","1799","<p>I'm dipping toes into RxSwift and would like to create a ""streaming API"" for one of my regular API calls.</p>

<p>My idea is to take the regular call (which already uses observables without any problems) and have a timer fire such calls and send the results on the same observable, so the view controller can update automatically, so instead of doing this (pseudocode follows):</p>

<pre><code>func getLocations() -&gt; Observable&lt;[Location]&gt; {
  return Observable&lt;[Location]&gt;.create {
    sink in
    NSURLSession.sharedSession.rx_JSON(API.locationsRequest).map {
       json in
       return json.flatMap { Location($0) }
    }
  }
}
</code></pre>

<p>I'd like for this to happen (pseudocode follows):</p>

<pre><code>func getLocations(interval: NSTimeInterval) -&gt; Observable&lt;[Location]&gt; {
  return Observable&lt;[Location]&gt;.create {
    sink in
    NSTimer(interval) {
      NSURLSession.sharedSession.rx_JSON(API.locationsRequest).map {
        json in
        sink.onNext(json.flatMap { Location($0) })
      }
    }
  }
}
</code></pre>

<p>Last thing I tried was adding an NSTimer to the mix, but I can't figure out how to take the reference to the sink and pass it around to the method called by the timer to actually send the events down the pipe, given that the handler for the timer must be on a standalone method. I tried throwing in the block timer extensions from BlocksKit but the timer was fired every second instead of being fired at the specified interval, which defeated the purpose.</p>

<p>I've also read about the <code>Interval</code> operator but I'm not sure it's the right way to go.</p>

<p>Any pointers on how to get this right?</p>

<p>The end goal would be to have the timer re-fire only after the previous call has finished (either success or fail).</p>
","314718","","","","","2016-01-28 14:07:26","Creating a ""reactive"" API with RxSwift","<ios><swift><nstimer><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"35003355","1","35004501","","2016-01-25 22:07:49","","44","14765","<p>Do i need to use <code>[weak self]</code> within RXSwift subscribeNext closures?</p>

<p>I have the code:</p>

<pre><code>    searchController.searchBar.rx_text.throttle(0.2, scheduler: MainScheduler.instance).subscribeNext { searchText in
        self.viewModel.searchForLocation(searchText)
    }.addDisposableTo(DisposelBag.sharedDisposelBag.disposeBag)
</code></pre>

<p>Do i need to modify it so that there is a <code>[weak self]</code> capture list at the beginning of the closure? Like this:</p>

<pre><code>    searchController.searchBar.rx_text.throttle(0.2, scheduler: MainScheduler.instance).subscribeNext { [weak self] searchText in
        self?.viewModel.searchForLocation(searchText)
    }.addDisposableTo(DisposelBag.sharedDisposelBag.disposeBag)
</code></pre>
","1783511","","8334818","","2018-05-31 06:05:20","2020-05-31 06:51:42","'[weak self]' in RXSwift closures","<swift><closures><rx-swift>","4","1","9","","","CC BY-SA 3.0"
"35011983","1","","","2016-01-26 10:43:11","","6","7547","<p>I learned <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/SimpleTableViewExample/SimpleTableViewExampleViewController.swift"" rel=""noreferrer"">example</a> in the demo to create a UITableView and render cells.</p>

<p>In my opinion, <code>items</code> is viewModel, I want to request some data across network by using Alamofire or other library. When I get the response, How can I update the cell's text relevant?</p>

<p>In the other words, I want to bind viewModel to Cells. When the model's data changed, cell's content could changed automatically.</p>

<p>I have a idea is: create a Observable sequence for the cell's content (bind to cell).When the server response data, it call function <code>tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: UITableViewRowAnimation.Top)</code>. But this seems not a grace or good method.</p>

<p>So, hope some can help me :)</p>

<pre><code>let items = Observable.just([
            ""First Item"",
            ""Second Item"",
            ""Third Item""
        ])

    items
        .bindTo(tableView.rx_itemsWithCellIdentifier(""Cell"", cellType: UITableViewCell.self)) { (row, element, cell) in
            cell.textLabel?.text = ""\(element) @ row \(row)""
            /* to do some binding or something else ? */
        }
        .addDisposableTo(disposeBag)


    tableView
        .rx_modelSelected(String)
        .subscribeNext { value in
            DefaultWireframe.presentAlert(""Tapped `\(value)`"")
        }
        .addDisposableTo(disposeBag)
</code></pre>
","2222919","","1113632","","2018-10-05 13:58:24","2018-10-05 13:58:24","How should I do to update UITableViewCell by using RxSwift?","<ios><swift><reactive-programming><rx-swift>","3","0","4","","","CC BY-SA 3.0"
"35040529","1","35051566","","2016-01-27 14:50:25","","6","1278","<p>I have a  wrapper for delegate in RXSwift</p>

<pre><code>func tableView(tableView: UITableView,movedRowAtIndexPath sourceIndexPath: NSIndexPath,toIndexRowPath destinationRowIndexPath: NSIndexPath)    
</code></pre>

<p>And they looks like </p>

<pre><code>public var rx_itemRowMoved: ControlEvent&lt;ItemMovedEvent&gt; {
    let source: Observable&lt;ItemMovedEvent&gt; = rx_delegate.observe(""tableView:movedRowAtIndexPath:toIndexRowPath:"")
        .map { a in
            return ((a[1] as! NSIndexPath), (a[2] as! NSIndexPath))
    }

    return ControlEvent(events: source)
}
</code></pre>

<p>But I have delegate with return value</p>

<pre><code> func selectionViewForTableView(tableView: UITableView,destinitionCell cell:UITableViewCell,toIndexRowPath destinationRowIndexPath: NSIndexPath) -&gt; UIView
</code></pre>

<p>how I can implement  wrapper for this delegate ?</p>
","1302654","","1302654","","2016-01-27 15:08:23","2016-01-28 01:56:39","RXSwift How to create wrapper for delegate method with return value","<ios><swift><uitableview><rx-swift>","1","0","","","","CC BY-SA 3.0"
"35093017","1","","","2016-01-29 19:59:18","","0","125","<p>As I am migrating some of the old functionality related to web service calls from synchronous calls to asynchronous - I was curious about the following.</p>

<p>What is the best technology pick?</p>

<p>I am considering between NSURLSession and Reactive Extensions.</p>

<p>In general, I would prefer to go with NSURLSession mainly because of framework support in terms of maintenance. In contrary, I've used Reactive Extensions so far in some other systems written in Scala, and has proven to be quite suited for handling API requests - though I have to say that the concepts were at the beginning harder to understand then just examining the Apple's documentation onto NSURLSession. </p>

<p>What is you experience with this kind of things? What would you recommend, and most importantly, why? </p>
","1076426","","","","","2016-01-29 19:59:18","Swift async API requests - NSURLSession or ReactiveExtensions?","<swift><asynchronous><nsurlsession><rx-swift>","0","2","","","","CC BY-SA 3.0"
"35206671","1","35206837","","2016-02-04 16:42:15","","36","20555","<p>I have an array of <code>Thing</code> objects that I want to convert to <code>ConvertedThing</code> objects, using an asynchronous function that returns <code>Observable&lt;ConvertedThing&gt;</code>.</p>

<p>I'd like to create an <code>Observable&lt;[ConvertedThing]&gt;</code> that emits one value when all the conversions have completed.</p>

<p>How can this be accomplished?  Any help much appreciated!</p>
","64239","","","","","2017-02-24 11:47:19","How do I create an observable of an array from an array of observables?","<arrays><swift><rx-swift>","2","0","10","","","CC BY-SA 3.0"
"35253866","1","","","2016-02-07 13:08:34","","0","275","<p>I want to write a function that wraps an observable in a way I can terminate it, and perform some code after it completes. I thought of doing:</p>

<pre><code>class ObsrevableWrapper {

  var terminating: Bool = false
  var terminatingObservable: Observable&lt;Int&gt;?
  func wrapObservable(o: Observable&lt;Int&gt;) -&gt; Observable&lt;Int&gt; {
    terminatingObservable = Observable
      .deferred { () -&gt; Observable&lt;Int&gt; in
        if self.terminating {
          return Observable.empty()
        } else {
          return o
        }
      }
      .takeWhile {_ in
        return !self.terminating
      }
      .publish().refCount()

    return terminatingObservable!
  }

  func terminateObservable() {
    terminating = true
    terminatingObservable!
      .map { _ -&gt; Void in
        return ()
      }
      .ignoreElements()
      .concat(Observable.just(()))
      .subscribeNext {
        self.output(""Performing completion code"")
    }
  }

}
</code></pre>

<p>Can I do it without the <code>var terminating: Bool</code> instance variable? (i.e. more functional..)</p>
","1346426","","","","","2016-02-07 13:08:34","Terminate all observables and wait until they're complete","<system.reactive><rx-swift>","0","2","","","","CC BY-SA 3.0"
"35255508","1","","","2016-02-07 15:44:52","","2","5313","<p>Trying to wrap my head around RxSwift, but the very first example they provide fails to build.</p>

<p>I'm trying to run the RxSwift code from <a href=""https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Examples.md"" rel=""nofollow"">https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Examples.md</a></p>

<pre class=""lang-c prettyprint-override""><code>let a /*: Observable&lt;Int&gt;*/ = Variable(1)   // a = 1
let b /*: Observable&lt;Int&gt;*/ = Variable(2)   // b = 2

// This will ""bind"" rx variable `c` to definition
// if a + b &gt;= 0 {
//      c = ""\(a + b) is positive""
// }
let c = Observable.combineLatest(a, b) { $0 + $1 }     // combines latest values of variables `a` and `b` using `+`
    .filter { $0 &gt;= 0 }               // if `a + b &gt;= 0` is true, `a + b` is passed to map operator
    .map { ""\($0) is positive"" }      // maps `a + b` to ""\(a + b) is positive""
</code></pre>

<p>But it fails with error:</p>

<blockquote>
  <p><code>Cannot invoke 'combineLatest' with an argument list of type '(Variable&lt;Int&gt;, Variable&lt;Int&gt;, (_, _) throws -&gt; _)'</code></p>
</blockquote>

<p>Is this an error in the example code or am I missing something?</p>

<hr>

<p>Steps I did to reproduce:</p>

<ol>
<li><p>Create a new iOS Single View Application, save, close it.</p></li>
<li><p>Create a Podfile in project root, containing:</p></li>
</ol>

<pre class=""lang-none prettyprint-override""><code># Podfile
use_frameworks!

pod 'RxSwift',    '~&gt; 2.0'
pod 'RxCocoa',    '~&gt; 2.0'
pod 'RxBlocking', '~&gt; 2.0'
pod 'RxTests',    '~&gt; 2.0'
</code></pre>

<ol start=""3"">
<li><p>Run <code>pod install</code></p></li>
<li><p>Open xcworkspace file</p></li>
<li><p>Put the example code into ViewController's viewDidLoad function:</p></li>
</ol>

<pre class=""lang-c prettyprint-override""><code>import UIKit
import RxSwift

class ViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        let a = Variable(1)
        let b = Variable(2)

        let c = Observable.combineLatest(a, b) { $0 + $1 }
            .filter { $0 &gt;= 0 }
            .map { ""\($0) is positive"" }
    }
}
</code></pre>

<ol start=""6"">
<li><p>Build. Xcode might complain that it can't load RxSwift. Restart Xcode -> problem solved.</p></li>
<li><p>Build. Xcode might complain something about bitcode. Disable bitcode everywhere in the project settings -> problem solved.</p></li>
<li><p>Build. Xcode complains about combineLatest: <code>Cannot invoke 'combineLatest' ...</code></p></li>
</ol>

<hr>

<p>Xcode version: 7.2</p>

<p>pod version: 0.39.0</p>

<p>RxSwift version: 2.1.0</p>

<hr>

<p>EDIT: It seems that other examples also fail with various errors, such as:</p>

<blockquote>
  <p>Cannot invoke 'concat' with no arguments</p>
</blockquote>

<p>Which probably means that something is missing from my project configuration or RxSwift changed dramatically and no one had time to update beginner examples to match the changes. Either way, these were some pretty frustrating first hours with RxSwift.</p>
","1448202","","1448202","","2016-02-07 16:08:02","2016-02-10 16:22:38","The first RxSwift example fails with ""Cannot invoke 'combineLatest' with an argument list ...""","<ios><swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"35268085","1","","","2016-02-08 11:04:20","","2","2510","<p>Imagine a user profile which allows editing of fields like <em>name</em>, <em>surname</em>, <em>age</em> and <em>avatarImage</em>. When the user clicks <code>Save</code>, requests are sent for each value that has been changed.</p>

<p>Now please think of functions with signatures like those:</p>

<pre><code>func rx_updateUserName(name: String) -&gt; Observable&lt;UpdateUserNameResponse&gt;
func rx_updateSurname(surname: String) -&gt; Observable&lt;UpdateSurnameResponse&gt;
func rx_updateAge(age: Int) -&gt; Observable&lt;UpdateAgeResponse&gt;
</code></pre>

<p>Normally we would just <code>zip</code> those requests like this:</p>

<pre><code>let nameReqObservable = rx_updateUserName(""Gandalf"")
let surnameReqObservable = rx_updateSurname(""The White"")
let ageReqObservable = rx_updateAge(123)

let zippedRequests = Observable.zip(nameReqObservable, surnameReqObservable, ageReqObservable, 
    resultSelector: { (userNameResponse, surnameResponse, areResponse) in

    return (userNameResponse, surnameResponse, areResponse)
}).subscribeNext(...)
</code></pre>

<p>What should I do when I only want to perform the requests for the values that changed?</p>
","1171404","","","","","2016-03-20 21:27:14","RxSwift: Zip Observables only if requirements are met","<swift><reactive-programming><reactive-cocoa><rx-swift><reactivex>","1","7","","","","CC BY-SA 3.0"
"35311937","1","35312036","","2016-02-10 09:58:54","","7","4676","<p>I'm switching from RAC and want to have a repeated network request, returning different result types depending on the API of the request.</p>

<p>I want to use an interval, but I don't know how to match the return types. </p>

<pre><code>var loop: Observable&lt;Element&gt; {
    return Observable&lt;Int&gt;.interval(5.0, scheduler: MainScheduler.instance).map { _ in
        // Do network request and return Observable&lt;Element&gt;
    }
}
</code></pre>

<p>I need to invoke Observerable.interval with type Int - but return Observable. How would I do that?</p>
","2181333","","1113632","","2018-01-29 16:29:49","2018-01-29 16:29:49","RxSwift repeated action","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"35329892","1","35401750","","2016-02-11 02:44:00","","4","1826","<p>I have a UITableView, which I want to put into an editing state if certain conditions are met. The primary way to toggling edit is through an edit button.</p>

<p>So the view elements I have are</p>

<pre><code>let tableView = UITableView()
let editButton = UIButton()
</code></pre>

<p>And whether the tableView should be in editing mode is fed from:</p>

<pre><code>let editing = BehaviorSubject(value: false)
</code></pre>

<p>Which will be hooked up to the tableView using something like:</p>

<pre><code>editing.subscribeNext { isEditing in
  tableView.setEditing(isEditing, animated: true)
}
</code></pre>

<p>When the edit button is tapped, I want that to push a new value to <code>editing</code>, that is the negation of the most recent value sent to <code>editing</code>. The most recently value may have been set by a tap on <code>editButton</code>, or it may have come from somewhere else.</p>

<p>I don't understand how to combine the stream for the button press with the stream for <code>editing</code> in such a way that allows this without an infinite loop e.g.</p>

<pre><code>Obervable.combineLatest(editButton.rx_tap.asObservable(), editing) { _, isEditing in
  editing.onNext(!isEditing)
}
</code></pre>

<p>I'm aware that the tableView has an <code>editing</code> property, but I don't want to rely on that as I am looking for a more general solution that I can re-use elsewhere. I'm also not looking to track the value of isEditing in an instance var, or even as a Variable(), as I am looking for a stateless, stream based solution (if this is at all possible).</p>

<p>Thank you!</p>
","270836","","270836","","2016-02-11 22:38:45","2016-02-15 05:06:43","How to have a subject in RxSwift push values to itself without creating an infinite loop","<swift><reactive-programming><rx-swift>","2","0","","","","CC BY-SA 3.0"
"35344504","1","35346699","","2016-02-11 16:16:34","","4","3577","<p>Lets imagine we have an array of AnObject instances and need to have following sequence of actions to execute:</p>

<ul>
<li>send objects to backend via separate calls</li>
<li><em>after step 1 finishes</em> store this array to DB in batch</li>
<li><em>after step 2 finishes</em> do additional processing for each item </li>
</ul>

<p>and we'd want to receive the signal only after all those steps were executed (or there was an error). What is the correct way to achieve this via <strong>RxSwift</strong> and is it actually possible? </p>

<p>Please find my prototype functions below. Unfortunately I didn't come up with a valid code sample for chaining, so there's nothing to demo.</p>

<pre><code>func makeAPIRequest(object: AnObject) -&gt; Observable&lt;Void&gt; {
    ...
}

func storeData(data: [AnObject]) -&gt; Observable&lt;Void&gt; {
    ...
}

func additionalProcessing(object: AnObject) -&gt; Observable&lt;Void&gt; { 
    ...
} 

func submitData()
{
   let data: [AnObject] = ...;

   let apiOperations = data.map{ makeAPIRequest($0) };
   let storageOperation = storeData(data);
   let processingOperations = data.map{ additionalProcessing($0) };

   ... // some code to chain steps 1-3
   .subscribe { (event) -&gt; Void in
       // should be called when operations from step 3 finished  
   }.addDisposableTo(disposeBag);
}
</code></pre>
","1136481","","","","","2018-08-28 07:32:37","RxSwift: chaining several actions","<swift><chaining><method-chaining><rx-swift>","1","0","3","","","CC BY-SA 3.0"
"35360804","1","35377007","","2016-02-12 10:55:35","","6","4845","<p>I'm using RxSwift to fetch some network data and I'm having trouble with performing a request for each iteration of an array. This was my idea:</p>

<ul>
<li>I have an API endpoint that returns an array of Objs which doesn't contain location data. Then I would loop through the array of Objs and for each get the location details with the Obj id. Something like this:</li>
</ul>

<p>(code simplified)</p>

<pre><code>var arrayObj = networkClient.request(getObjsEndpoint)
        .fetchObjLocationDetails(withNetworkClient: networkClient)
</code></pre>

<ul>
<li>And the fetchObjLocationDetails() would be something like:</li>
</ul>

<p>(code simplified)</p>

<pre><code>extension ObservableType where E == [Obj]? {
func fetchObjsLocationDetails(withNetworkClient networkClient: NetworkClient) -&gt; Observable&lt;[Obj]?&gt; {
        return flatMap { Objs -&gt; Observable&lt;[Obj]?&gt; in
            guard let unwrappedObjs = Objs as [Obj]? else { return Observable.just(nil) }

            let disposeBag = DisposeBag()
            var populatedObjs = [Obj]()

            unwrappedObjs.forEach { obj in
                let getLocationDetailsEndpoint = WeDriveParkAPI.getLocation(id: String(obj.id))

                networkClient.request(getLocationDetailsEndpoint)
                    .observeOn(MainScheduler.instance)
                    .subscribe(onNext: { json in
                        guard let populatedObj = Obj.fromJSON(json) as Obj? else { return }

                        populatedObjs += [populatedObj]
                        }, onError:{ e in

                    }).addDisposableTo(disposeBag)
            }
            return Observable.just(populatedObjs)
        }
    }
}
</code></pre>

<p>This solution is not really working because the code doesn't even go inside the subscribe next closure.</p>

<p>Please have in mind I'm new to both Swift and RxSwift programming so be gentle :) Any help would be greatly appreciated.</p>
","734702","","","","","2016-02-13 06:52:41","RxSwift request for each iteration of array","<swift><networking><rx-swift>","1","0","","","","CC BY-SA 3.0"
"35438268","1","35439227","","2016-02-16 16:47:05","","25","10850","<p>Let's say I have an instant messaging app that plays a beep sound every time a message arrives. I want to <code>debounce</code> the beeps, but I'd like to play the beep sound for the first message arrived and not for the following ones (in a timespan of, say, 2 seconds).</p>

<p>Another example might be: my app sends typing notifications (so the user I'm chatting with can see that I'm typing a message). I want to send a typing notification when I start typing, but only send new ones in X-seconds intervals, so I don't send a typing notification for every character I type.</p>

<p>Does this make sense? Is there an operator for that? Could it be achieved with the existing operators?</p>

<p>This is my code for the first example. I'm solving it now with <code>debounce</code>, but it's not ideal. If I receive 1000 messages in intervals of 1 second, it won't play the sound until the last message arrives (I'd like to play the sound on the first one).</p>

<pre><code>self.messagesHandler.messages
            .asObservable()
            .skip(1)
            .debounce(2, scheduler: MainScheduler.instance)
            .subscribeNext { [weak self] message in
                    self?.playMessageArrivedSound()
            }.addDisposableTo(self.disposeBag)
</code></pre>

<p>Thanks!</p>
","912254","","","","","2016-09-21 06:06:28","RxSwift - Debounce/Throttle ""inverse""","<ios><swift><rx-swift>","2","1","4","","","CC BY-SA 3.0"
"35492146","1","","","2016-02-18 20:50:02","","0","1756","<p>I'm relatively new to RxSwift. I have an Observable and want to bind it to a UITableView. All examples and solutions I found so far use Observables&lt;[Item]> to bind it to a TableView - but I don't have the result of type Array.</p>

<p>How would I convert my Observable to an Observable&lt;[Item]>? Or how would I use the Observable to show the results in a TableView?</p>
","2181333","","1113632","","2018-01-29 15:48:42","2018-01-29 15:48:42","How to bind an Observable to a UITableView","<swift><uitableview><rx-swift>","1","1","","","","CC BY-SA 3.0"
"35514606","1","35520722","","2016-02-19 20:40:34","","2","7857","<p>I am starting in RxSwift, coming from ReactiveCocoa. I have a conceptual question.</p>

<p>Let's say I have a value I want to observe over time, e.g. a temperatue. So there are many cases and places I subscribe this value to react on changes. No problem!</p>

<p>But there are also use cases when I just need the latest value e.g.:</p>

<pre><code>if temperatue &gt; 5 {
    // do something
}
</code></pre>

<p>So i just want to do a decision/operation on that value or at least based on that value. That drives me close to using a shareReplay observable. But would I need to subscribe that value even when I just want to use it once?</p>

<p>Or is this approach wrong at all? How would I do that use case (value over time vs. accessing last value only once)? Would I need to sources, one hot one cold?</p>
","2181333","","5887605","","2016-02-20 09:07:27","2016-02-20 09:07:27","Get only one value from Observable","<swift><reactive-programming><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"35570959","1","","","2016-02-23 07:07:46","","2","1050","<p>It seems that rx-swift has not yet implemented <a href=""http://reactivex.io/documentation/operators/defaultifempty.html"" rel=""nofollow"">DefaultIfEmpty</a>. Is there another way I can mimic this behavior?</p>

<pre><code>let myList:[Int] = []
myList.toObservable()
    .switchIfEmpty { () in // &lt;- Not (yet?) implemented
        return Observable.of(1)
    }.subscribeNext { num in
        print(num)
    }

// prints 1
</code></pre>
","2246189","","1113632","","2018-01-29 15:09:23","2018-01-29 15:09:23","RxSwift equivalent of DefaultIfEmpty","<swift><rx-swift>","3","0","2","","","CC BY-SA 3.0"
"35575305","1","35637700","","2016-02-23 10:44:09","","6","2366","<p>In RxSwift / RxCocoa you can create a reactive wrapper for a delegate (e.g. <code>UIScrollViewDelegate</code> or <code>CLLocationManagerDelegate</code>) to enable Rx observable sequences for certain delegate methods.</p>

<p>I am trying to implement this for the <code>UIApplicationDelegate</code> method <code>applicationDidBecomeActive:</code></p>

<p>What I tried so far is pretty straightforward and similar to the <code>DelegateProxy</code> subclasses that are included in RxCocoa.</p>

<p>I created my <code>DelegateProxy</code> subclass:</p>

<pre><code>class RxUIApplicationDelegateProxy: DelegateProxy, UIApplicationDelegate, DelegateProxyType {

    static func currentDelegateFor(object: AnyObject) -&gt; AnyObject? {
        let application: UIApplication = object as! UIApplication
        return application.delegate
    }

    static func setCurrentDelegate(delegate: AnyObject?, toObject object: AnyObject) {
        let application: UIApplication = object as! UIApplication
        application.delegate = delegate as? UIApplicationDelegate
    }
}
</code></pre>

<p>And an Rx extension for <code>UIApplication</code>:</p>

<pre><code>extension UIApplication {
    public var rx_delegate: DelegateProxy {
        return proxyForObject(RxUIApplicationDelegateProxy.self, self)
    }

    public var rx_applicationDidBecomeActive: Observable&lt;Void&gt; {
        return rx_delegate.observe(""applicationDidBecomeActive:"")
            .map { _ in
                return
            }
    }
}
</code></pre>

<p>In my AppDelegate I subscribe to the observable:</p>

<pre><code>func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
    // the usual setup
    // and then:
    application.rx_applicationDidBecomeActive
        .subscribeNext { _ in
            print(""Active!"")
        }
        .addDisposableTo(disposeBag)

    return true
}
</code></pre>

<p>When I start my app ""Active!"" gets printed and then I get the following crash in RxCocoa's <code>_RXDelegateProxy_</code> class:</p>

<p><a href=""https://i.stack.imgur.com/FCKXq.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/FCKXq.png"" alt=""enter image description here""></a></p>

<p>Does anybody have an idea what the problem might be? Or has anybody successfully implemented something like <code>rx_applicationDidBecomeActive</code>?</p>
","790877","","790877","","2016-02-25 14:38:39","2021-04-22 14:38:48","Transform UIApplicationDelegate methods into RxSwift Observables","<ios><swift><observable><uiapplicationdelegate><rx-swift>","1","2","3","","","CC BY-SA 3.0"
"35598485","1","35599494","","2016-02-24 09:43:33","","4","306","<p>I am using RxSwift for my iOS app.</p>

<p>I have a function which returns an <code>Observable</code> of items called <code>Repository</code>.</p>

<pre><code>func search(query: String) -&gt; Observable&lt;Repository&gt;
</code></pre>

<p>Basically it makes a network request to github to download the repositories given a search query.</p>

<p>Now, when I call this function, I follow the example in <a href=""https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#creating-your-own-observable-aka-observable-sequence"" rel=""nofollow"">RxSwift documentation</a>:</p>

<pre><code>search(queryText).subscribeNext({ repo in
            print(repo)
        })
</code></pre>

<p>But Xcode says</p>

<blockquote>
  <p>Cannot invoke 'subscribeNext' with an argument list of type '((Repository) -> ())'</p>
</blockquote>

<p>That's weird because that's what Xcode suggests to sue when I use autocompletion. I already tried clean and re-build. I get the same kind of error even if I use another subscribe method.</p>

<p>So, what's wrong with this?</p>
","1226219","","","","","2016-02-24 10:28:12","RxSwift cannot recognize a subscribe method","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"35712190","1","","","2016-02-29 23:57:46","","0","1697","<p>I'm attempting to do a simple two way binding using the <code>&lt;-&gt;</code> operator from the Examples.</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class ViewController: UIViewController {

    let textview = UITextView()
    let testVar = Variable("""")

    override func viewDidLoad() {
        super.viewDidLoad()
        view.addSubview(textview)
        textview.frame = view.bounds
        textview.backgroundColor = UIColor.whiteColor()

        textview.rx_text &lt;-&gt; testVar
    }
}

infix operator &lt;-&gt; {
}

func &lt;-&gt; &lt;T&gt;(property: ControlProperty&lt;T&gt;, variable: Variable&lt;T&gt;) -&gt; Disposable {
    let bindToUIDisposable = variable.asObservable()
        .bindTo(property)
    let bindToVariable = property
        .subscribe(onNext: { n in
            variable.value = n
            }, onCompleted:  {
                bindToUIDisposable.dispose()
        })

    return StableCompositeDisposable.create(bindToUIDisposable, bindToVariable)
}
</code></pre>

<p>Editing this textview causes an exception and I'm not sure how to resolve it.</p>

<pre><code>2016-02-29 18:44:23.322 TestRX[71117:38702571] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '-[NSLayoutManager _fillLayoutHoleForCharacterRange:desiredNumberOfLines:isSoft:] *** attempted layout while textStorage is editing.  It is not valid to cause the layoutManager to do layout while the textStorage is editing (ie the textStorage has been sent a beginEditing message without a matching endEditing.)'
*** First throw call stack:
(
    0   CoreFoundation                      0x000000010cd64e65 __exceptionPreprocess + 165
    1   libobjc.A.dylib                     0x000000010eaa4deb objc_exception_throw + 48
    2   CoreFoundation                      0x000000010cd64d9d +[NSException raise:format:] + 205
    3   UIFoundation                        0x000000011444636e -[NSLayoutManager(NSPrivate) _fillLayoutHoleForCharacterRange:desiredNumberOfLines:isSoft:] + 531
    4   UIFoundation                        0x000000011444da73 _NSFastFillAllLayoutHolesForGlyphRange + 1467
    5   UIFoundation                        0x000000011444b01a -[NSLayoutManager(NSPrivate) _rectArrayForRange:withinSelectionRange:rangeIsCharRange:singleRectOnly:fullLineRectsOnly:inTextContainer:rectCount:rangeWithinContainer:glyphsDrawOutsideLines:rectArray:rectArrayCapacity:] + 822
    6   UIFoundation                        0x000000011444e488 -[NSLayoutManager(NSPrivate) _rectArrayForRange:withinSelectionRange:rangeIsCharRange:singleRectOnly:fullLineRectsOnly:inTextContainer:rectCount:rangeWithinContainer:glyphsDrawOutsideLines:] + 117
    7   UIFoundation                        0x0000000114486f42 -[NSLayoutManager rectArrayForCharacterRange:withinSelectedCharacterRange:inTextContainer:rectCount:] + 80
    8   UIKit                               0x000000010df3a801 -[_UITextContainerView updateInsertionPointStateAndRestartTimer:] + 311
    9   UIFoundation                        0x0000000114452daf -[NSLayoutManager(NSPrivate) _invalidateLayoutForExtendedCharacterRange:isSoft:invalidateUsage:] + 2118
    10  UIKit                               0x000000010df23a98 -[UITextView setAttributedText:] + 950
    11  UIKit                               0x000000010df2bc95 -[UITextView setText:] + 188
    12  RxCocoa                             0x000000010c805fc7 _TFFE7RxCocoaCSo10UITextViewg7rx_textGVS_15ControlPropertySS_U0_FTS0_SS_T_ + 119
    13  RxCocoa                             0x000000010c806027 _TTRXFo_oCSo10UITextViewoSS_dT__XFo_oS_iSS_dT__ + 55
    14  RxCocoa                             0x000000010c7f300b _TFC7RxCocoa17UIBindingObserver2onu0_Rq_Ss9AnyObject_fGS0_q_q0__FGO7RxSwift5Eventq0__T_ + 747
    15  RxCocoa                             0x000000010c7f342f _TTWu0_Rq_Ss9AnyObject_GC7RxCocoa17UIBindingObserverq_q0__7RxSwift12ObserverTypeS0_FS3_2onuRq_S3__fq_FGOS2_5Eventqq_S3_1E_T_ + 63
    16  RxSwift                             0x000000010c8fbd31 _TPA + 113
    17  RxSwift                             0x000000010c8fb933 _TFV7RxSwift11AnyObserver2onurfGS0_q__FGOS_5Eventq__T_ + 387
    18  RxCocoa                             0x000000010c7ac198 _TFV7RxCocoa15ControlProperty2onurfGS0_q__FGO7RxSwift5Eventq__T_ + 1000
    19  RxCocoa                             0x000000010c7ac56c _TTWurGV7RxCocoa15ControlPropertyq__7RxSwift12ObserverTypeS_FS2_2onuRq_S2__fq_FGOS1_5Eventqq_S2_1E_T_ + 92
    20  RxSwift                             0x000000010c8fbd31 _TPA + 113
    21  RxSwift                             0x000000010c8fb933 _TFV7RxSwift11AnyObserver2onurfGS0_q__FGOS_5Eventq__T_ + 387
    22  RxSwift                             0x000000010c8fba44 _TTWurGV7RxSwift11AnyObserverq__S_12ObserverTypeS_FS1_2onuRq_S1__fq_FGOS_5Eventqq_S1_1E_T_ + 68
    23  RxSwift                             0x000000010c903e35 _TFeRq_7RxSwift12ObserverType_S_VS_3Bag2onuRq_S0__fGS1_q__FGOS_5Eventqq_S0_1E_T_ + 1141
    24  RxSwift                             0x000000010c90dbb3 _TFC7RxSwift15BehaviorSubject16_synchronized_onurfGS0_q__FGOS_5Eventq__T_ + 3747
    25  RxSwift                             0x000000010c90cc7c _TFC7RxSwift15BehaviorSubject2onurfGS0_q__FGOS_5Eventq__T_ + 380
    26  RxSwift                             0x000000010ca0fbfd _TFC7RxSwift8Variables5valueq_ + 365
    27  TestRX                              0x000000010c6fcc0b _TFZF6TestRXoi3lsgurFTGV7RxCocoa15ControlPropertyq__GC7RxSwift8Variableq___PS2_10Disposable_U_FQ_T_ + 91
    28  TestRX                              0x000000010c6fcc58 _TTRGrXFo_iq__dT__XFo_iq__iT__ + 24
    29  TestRX                              0x000000010c6fc8b1 _TPA__TTRGrXFo_iq__dT__XFo_iq__iT__ + 97
    30  RxSwift                             0x000000010c991ec4 _TFFeRq_7RxSwift14ObservableType_S_S0_9subscribeuRq_S0__Fq_FT6onNextGSqFqq_S0_1ET__7onErrorGSqFPSs9ErrorType_T__11onCompletedGSqFT_T__10onDisposedGSqFT_T___PS_10Disposable_U_FGOS_5EventQQPS0_1E_T_ + 772
    31  RxSwift                             0x000000010c9911ec _TPA__TFFeRq_7RxSwift14ObservableType_S_S0_9subscribeuRq_S0__Fq_FT6onNextGSqFqq_S0_1ET__7onErrorGSqFPSs9ErrorType_T__11onCompletedGSqFT_T__10onDisposedGSqFT_T___PS_10Disposable_U_FGOS_5EventQQPS0_1E_T_ + 284
    32  RxSwift                             0x000000010c8fb368 _TFC7RxSwift17AnonymousObserver6onCoreurfGS0_q__FGOS_5Eventq__T_ + 392
    33  RxSwift                             0x000000010c9a03ae _TFC7RxSwift12ObserverBase2onurfGS0_q__FGOS_5Eventq__T_ + 974
    34  RxSwift                             0x000000010c9a094f _TTWurGC7RxSwift12ObserverBaseq__S_12ObserverTypeS_FS1_2onuRq_S1__fq_FGOS_5Eventqq_S1_1E_T_ + 63
    35  RxSwift                             0x000000010c9e2121 _TFC7RxSwift4Sink9forwardOnuRq_S_12ObserverType_fGS0_q__FGOS_5Eventqq_S1_1E_T_ + 625
    36  RxSwift                             0x000000010c9ed4af _TFC7RxSwift15SubscribeOnSink2onu0_Rq_S_14ObservableTypeq0_S_12ObserverTypezqq_S1_1Eqq0_S2_1E_fGS0_q_q0__FGOS_5Eventqq_S1_1E_T_ + 463
    37  RxSwift                             0x000000010c9ede13 _TTWu0_Rq_7RxSwift14ObservableTypeq0_S_12ObserverTypezqq_S0_1Eqq0_S1_1E_GCS_15SubscribeOnSinkq_q0__S1_S_FS1_2onuRq_S1__fq_FGOS_5Eventqq_S1_1E_T_ + 83
    38  RxSwift                             0x000000010c9e2121 _TFC7RxSwift4Sink9forwardOnuRq_S_12ObserverType_fGS0_q__FGOS_5Eventqq_S1_1E_T_ + 625
    39  RxSwift                             0x000000010c9684bf _TFC7RxSwift12DeferredSink2onu0_Rq_S_14ObservableTypeq0_S_12ObserverTypezqq_S1_1Eqq0_S2_1E_fGS0_q_q0__FGOS_5Eventqq_S1_1E_T_ + 463
    40  RxSwift                             0x000000010c9688c3 _TTWu0_Rq_7RxSwift14ObservableTypeq0_S_12ObserverTypezqq_S0_1Eqq0_S1_1E_GCS_12DeferredSinkq_q0__S1_S_FS1_2onuRq_S1__fq_FGOS_5Eventqq_S1_1E_T_ + 83
    41  RxSwift                             0x000000010c9e2121 _TFC7RxSwift4Sink9forwardOnuRq_S_12ObserverType_fGS0_q__FGOS_5Eventqq_S1_1E_T_ + 625
    42  RxSwift                             0x000000010c96c286 _TFC7RxSwift24DistinctUntilChangedSink2onu0_Rq_S_12ObserverType_fGS0_q_q0__FGOS_5Eventqq_S1_1E_T_ + 2326
    43  RxSwift                             0x000000010c96cdc3 _TTWu0_Rq_7RxSwift12ObserverType_GCS_24DistinctUntilChangedSinkq_q0__S0_S_FS0_2onuRq_S0__fq_FGOS_5Eventqq_S0_1E_T_ + 83
    44  RxSwift                             0x000000010c9e2121 _TFC7RxSwift4Sink9forwardOnuRq_S_12ObserverType_fGS0_q__FGOS_5Eventqq_S1_1E_T_ + 625
    45  RxSwift                             0x000000010c97ee49 _TFC7RxSwift7MapSink2onu0_Rq0_S_12ObserverType_fGS0_q_q0__FGOS_5Eventq__T_ + 985
    46  RxSwift                             0x000000010c97f423 _TTWu0_Rq0_7RxSwift12ObserverType_GCS_7MapSinkq_q0__S0_S_FS0_2onuRq_S0__fq_FGOS_5Eventqq_S0_1E_T_ + 83
    47  RxSwift                             0x000000010c8fbd31 _TPA + 113
    48  RxSwift                             0x000000010c8fb933 _TFV7RxSwift11AnyObserver2onurfGS0_q__FGOS_5Eventq__T_ + 387
    49  RxSwift                             0x000000010c8fba44 _TTWurGV7RxSwift11AnyObserverq__S_12ObserverTypeS_FS1_2onuRq_S1__fq_FGOS_5Eventqq_S1_1E_T_ + 68
    50  RxSwift                             0x000000010c903e35 _TFeRq_7RxSwift12ObserverType_S_VS_3Bag2onuRq_S0__fGS1_q__FGOS_5Eventqq_S0_1E_T_ + 1141
    51  RxSwift                             0x000000010c9a4df0 _TFC7RxSwift14PublishSubject16_synchronized_onurfGS0_q__FGOS_5Eventq__T_ + 1744
    52  RxSwift                             0x000000010c9a4689 _TFC7RxSwift14PublishSubject2onurfGS0_q__FGOS_5Eventq__T_ + 425
    53  RxCocoa                             0x000000010c7af712 _TFC7RxCocoa13DelegateProxy19interceptedSelectorfS0_FTV10ObjectiveC8Selector13withArgumentsGSQGSaPSs9AnyObject____T_ + 530
    54  RxCocoa                             0x000000010c7af7cd _TToFC7RxCocoa13DelegateProxy19interceptedSelectorfS0_FTV10ObjectiveC8Selector13withArgumentsGSQGSaPSs9AnyObject____T_ + 125
    55  RxCocoa                             0x000000010c78ede4 -[_RXDelegateProxy forwardInvocation:] + 180
    56  CoreFoundation                      0x000000010ccba727 ___forwarding___ + 487
    57  CoreFoundation                      0x000000010ccba4b8 _CF_forwarding_prep_0 + 120
    58  UIFoundation                        0x00000001144aa4ef -[NSTextStorage processEditing] + 283
    59  UIFoundation                        0x00000001144aa18b -[NSTextStorage endEditing] + 82
    60  UIKit                               0x000000010df740fd -[UITextInputController _insertText:fromKeyboard:] + 505
    61  UIKit                               0x000000010df74bcd -[UITextInputController insertText:] + 365
    62  UIKit                               0x000000010df2778b -[UITextView insertText:] + 62
    63  UIKit                               0x000000010d829a9b -[UIKeyboardImpl insertText:] + 149
    64  UIKit                               0x000000010d826278 -[UIKeyboardImpl performKeyboardOutput:] + 496
    65  UIKit                               0x000000010d825e65 __55-[UIKeyboardImpl handleKeyboardInput:executionContext:]_block_invoke_2 + 164
    66  UIKit                               0x000000010df94724 -[UIKeyboardTaskQueue continueExecutionOnMainThread] + 332
    67  Foundation                          0x000000010d149067 __NSThreadPerformPerform + 283
    68  CoreFoundation                      0x000000010cc90a31 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17
    69  CoreFoundation                      0x000000010cc8695c __CFRunLoopDoSources0 + 556
    70  CoreFoundation                      0x000000010cc85e13 __CFRunLoopRun + 867
    71  CoreFoundation                      0x000000010cc85828 CFRunLoopRunSpecific + 488
    72  GraphicsServices                    0x0000000113e90ad2 GSEventRunModal + 161
    73  UIKit                               0x000000010d581610 UIApplicationMain + 171
    74  TestRX                              0x000000010c6fd47d main + 109
    75  libdyld.dylib                       0x00000001105bd92d start + 1
    76  ???                                 0x0000000000000001 0x0 + 1
)
</code></pre>

<p>I am able to reproduce this on <code>2.1.0</code> and <code>2.2.0</code></p>

<p>Does anyone have any thoughts on how to fix this?</p>
","580291","","580291","","2016-03-01 13:59:08","2016-07-03 22:33:50","RxSwift rx_text two way binding crash","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"35752866","1","","","2016-03-02 16:26:59","","7","3044","<p>I'm trying to write a MVVM with RxSwift and comparing to what I was used to do in ReactiveCocoa for Objective-C it's been a little hard to write my service in the right way. </p>

<p>An exemple is a Login service. </p>

<p>With ReactiveCocoa (Objective-C) I code something like this:</p>

<pre><code>// ViewController


// send textfield inputs to viewmodel 
RAC(self.viewModel, userNameValue) = self.fieldUser.rac_textSignal;
RAC(self.viewModel, userPassValue) = self.fieldPass.rac_textSignal;

// set button action
self.loginButton.rac_command = self.viewModel.loginCommand;

// subscribe to login signal
[[self.viewModel.loginResult deliverOnMainThread] subscribeNext:^(NSDictionary *result) {
    // implement
} error:^(NSError *error) {
    NSLog(@""error"");
}];
</code></pre>

<p>and my viewModel should be like this:</p>

<pre><code>// valid user name signal
self.isValidUserName = [[RACObserve(self, userNameValue)
                         map:^id(NSString *text) {
                             return @( text.length &gt; 4 );
                         }] distinctUntilChanged];

// valid password signal
self.isValidPassword = [[RACObserve(self, userPassValue)
                         map:^id(NSString *text) {
                             return @( text.length &gt; 3);
                         }] distinctUntilChanged];

// merge signal from user and pass
self.isValidForm = [RACSignal combineLatest:@[self.isValidUserName, self.isValidPassword]
                                           reduce:^id(NSNumber *user, NSNumber *pass){
                                               return @( [user boolValue] &amp;&amp; [pass boolValue]);
                                           }];


// login button command
self.loginCommand = [[RACCommand alloc] initWithEnabled:self.isValidForm
                                            signalBlock:^RACSignal *(id input) {
                                                return [self executeLoginSignal];
                                            }];
</code></pre>

<p>now in RxSwift I've written the same as:</p>

<pre><code>// ViewController

// initialize viewmodel with username and password bindings
    viewModel = LoginViewModel(withUserName: usernameTextfield.rx_text.asDriver(), password: passwordTextfield.rx_text.asDriver())

// subscribe to isCredentialsValid 'Signal' to assign button state
   viewModel.isCredentialsValid
        .driveNext { [weak self] valid in
            if let button = self?.signInButton {
                button.enabled = valid
            }
    }.addDisposableTo(disposeBag)

// signinbutton
    signInButton.rx_tap
        .withLatestFrom(viewModel.isCredentialsValid)
        .filter { $0 }
        .flatMapLatest { [unowned self] valid -&gt; Observable&lt;AutenticationStatus&gt; in
            self.viewModel.login(self.usernameTextfield.text!, password: self.passwordTextfield.text!)
            .observeOn(SerialDispatchQueueScheduler(globalConcurrentQueueQOS: .Default))
        }
        .observeOn(MainScheduler.instance)
        .subscribeNext {
            print($0)
        }.addDisposableTo(disposeBag)
</code></pre>

<p>I'm changing the button state this way because I can't this to work:</p>

<pre><code>viewModel.isCredentialsValid.drive(self.signInButton.rx_enabled).addDisposableTo(disposeBag)
</code></pre>

<p>and my viewModel</p>

<pre><code>let isValidUser = username
    .distinctUntilChanged()
        .map { $0.characters.count &gt; 3 }

    let isValidPass = password
    .distinctUntilChanged()
        .map { $0.characters.count &gt; 2 }

    isCredentialsValid = Driver.combineLatest(isValidUser, isValidPass) { $0 &amp;&amp; $1 }
</code></pre>

<p>and</p>

<pre><code>func login(username: String, password: String) -&gt; Observable&lt;AutenticationStatus&gt;
{
    return APIServer.sharedInstance.login(username, password: password)
}
</code></pre>

<p>I'm using Driver because it wrap some nice features like: catchErrorJustReturn(), but I really don't like the way I'm doing this:</p>

<p>1) I have to send username and password fields as a parameter to the viewModel (by the way, that's the easier to solve)</p>

<p>2 ) I don't like the way my viewController do all the work when login button is tapped, viewController doesn't need to know which service it should call to get login access, it's a viewModel job. </p>

<p>3 ) I can't access the stored value of username and password outside of a subscription. </p>

<p>Is there a different way to do this? how are you Rx'ers doing this kind of thing? Thanks a lot.</p>
","1772384","","","","","2016-07-06 13:23:06","RxSwift right way","<swift><mvvm><reactive-cocoa><frp><rx-swift>","1","0","4","","","CC BY-SA 3.0"
"35766600","1","35792203","","2016-03-03 08:14:00","","7","9787","<p>Here is my class:  </p>

<pre><code>class ViewController: UIViewController {
   var myArray : NSArray!
} 
</code></pre>

<p>I want to fire an event every time myArray points to a new array, like this:</p>

<pre><code>self.myArray = [""a""]

self.myArray = [""b""]
</code></pre>

<p>I've tried rx_observe but failed, here is my code:</p>

<pre><code>self.rx_observe(NSArray.self, ""myArray"").subscribeNext { (array) -&gt; Void in
   print(array)
}
</code></pre>

<p>It only fires the first time, what's the problem?</p>
","2570865","","1113632","","2018-04-02 14:12:02","2018-04-02 14:12:02","How to observe array property changes in RxSwift","<swift><key-value-observing><rx-swift>","1","0","3","","","CC BY-SA 3.0"
"35841054","1","","","2016-03-07 10:16:24","","1","1034","<p>I'm quite new to RX and I'm trying to understand how I can continue a task, after an error which requires user input.  </p>

<p>A concrete example would be two factor authentication.. We have an auth-service and a protected resource. Logging in, we receive from the auth-service a LOA-2 (username&amp;password used) token. trying to fetch data from the protected resource we receive an error stating we need LOA-3 (two-factor). So we have to get the input from the user, send it to the auth-service, get a new token (LOA-3) und retry our fetch call with the new token.  </p>

<p>There are a lot of examples for logins, but I can't wrap my head around continuing a chain, which requires user input.  </p>

<p>Any ideas? Thanks :)</p>
","375047","","","","","2016-07-13 02:26:22","RXSwift User input on error and continuation","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"35858805","1","35985913","","2016-03-08 04:11:31","","0","768","<p>I am very new to Rx and have been trying to make a Bonjour discovery client that resolves services. This is very simple to do imperatively, but I wanted to try with RxSwift.</p>

<p>Since the discovered NSNetService objects need to be persisted before resolution, I'm having to make a nested subscription call, the outer one for discovery, and the inner on for resolution...but something tells me this is not the best way.</p>

<pre><code>import UIKit
import RxSwift

class BonjourClient: NSObject {

    let disposeBag = DisposeBag()
    var servicesArray = [NSNetService]()

    func startBrowsing() {
        let browser = NSNetServiceBrowser()
        browser.rx_netServiceBrowserDidFindServiceMoreComing
            .subscribeNext { (service: NSNetService) in
                        self.servicesArray.append(service)
                        self.servicesArray.last!.rx_netServiceDidResolveAddress
                            .subscribeNext { (sender: NSNetService) in
                                print(""Resolved \(sender.name)"")
                                let data = sender.TXTRecordData()
                                let dict: [String: NSData?] = NSNetService.dictionaryFromTXTRecordData(data!)
                                for (key, value) in dict {
                                    print(""\(key) : \(String(data: value!, encoding: NSUTF8StringEncoding)!)"")
                                }
                        }.addDisposableTo(self.disposeBag)
                        self.servicesArray.last!.resolveWithTimeout(5)
                }.addDisposableTo(disposeBag)
        browser.searchForServicesOfType(""_amzn-wplay._tcp."", inDomain: ""local."")
        NSRunLoop.currentRunLoop().run()
    }

}
</code></pre>

<p>My proxy classes are as follows:</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class RxNSNetServiceBrowserDelegateProxy: DelegateProxy, NSNetServiceBrowserDelegate, DelegateProxyType {

    static func currentDelegateFor(object: AnyObject) -&gt; AnyObject? {
        let browser: NSNetServiceBrowser = object as! NSNetServiceBrowser
        return browser.delegate
    }

    static func setCurrentDelegate(delegate: AnyObject?, toObject object: AnyObject) {
        let browser: NSNetServiceBrowser = object as! NSNetServiceBrowser
        browser.delegate = delegate as? NSNetServiceBrowserDelegate
    }

}

class RxNSNetServiceDelegateProxy: DelegateProxy, NSNetServiceDelegate, DelegateProxyType {

    static func currentDelegateFor(object: AnyObject) -&gt; AnyObject? {
        let service: NSNetService = object as! NSNetService
        return service.delegate
    }

    static func setCurrentDelegate(delegate: AnyObject?, toObject object: AnyObject) {
        let service: NSNetService = object as! NSNetService
        service.delegate = delegate as? NSNetServiceDelegate
    }

}

extension NSNetServiceBrowser {

    public var rx_delegate: DelegateProxy {
        return proxyForObject(RxNSNetServiceBrowserDelegateProxy.self, self)
    }

    public var rx_netServiceBrowserDidFindServiceMoreComing: Observable&lt;NSNetService&gt; {
        return rx_delegate.observe(""netServiceBrowser:didFindService:moreComing:"")
            .map { params in
                let service = params[1] as! NSNetService
                return service
        }
    }

}

extension NSNetService {

    public var rx_delegate: DelegateProxy {
        return proxyForObject(RxNSNetServiceDelegateProxy.self, self)
    }

    public var rx_netServiceDidResolveAddress: Observable&lt;NSNetService&gt; {
        return rx_delegate.observe(""netServiceDidResolveAddress:"")
            .map { params in
                return params[0] as! NSNetService

        }
    }
}
</code></pre>

<p>If I use <code>flatMap</code> after the <code>browser.rx_netServiceBrowserDidFindServiceMoreComing</code> call instead of <code>subscribeNext</code>, the service won't resolve because I can't persist it to an array from within <code>flatMap</code> for reasons that escape me, mostly from never having touched Rx. Am I bound to using nested calls?</p>

<p>Short version of my problem is the above works, but seems convoluted to me. Any ideas would be greatly appreciated.</p>
","239318","","","","","2016-03-14 11:10:28","RxSwift and Nested Subscriptions for Bonjour Discovery","<swift><bonjour><rx-swift>","1","0","","","","CC BY-SA 3.0"
"35875923","1","35885401","","2016-03-08 19:08:33","","0","1325","<p>I'm quite new and I'm wondering how to catch error from requests which are zipped (see snipped above) in one place. In current implementation I have error handling in two places, but my goal is to have it in one place. My requests are zipped because if one of this req gets failed whole sequence will fail so in result I want to have one error handling place in code for both request.</p>

<pre><code> let firstReq =  self.sendReq() // returns  Observable&lt;Bool&gt;
        .catchError {
            error in
            return self.just(true)
    }

    let secondReq =  self.sendReqTwo() // returns  Observable&lt;Bool&gt;
        .catchError {
            error in
            return self.just(true)
    }


    goBttnOutlet.rx_tap
        .subscribeNext {
          Observable.zip(firstReqRes, secondReqRes) { (firstRes, secondRes) -&gt; Bool in
                return firstRes &amp;&amp; secondRes
            }.subscribeNext { summaryRes in
                print(""🎿 \(summaryRes)"")
            }.addDisposableTo(self.rx_disposableBag)
        }.addDisposableTo(rx_disposableBag)
</code></pre>

<p>..maybe some link with example code with handling error in common place will be great for me.
Thanks a lot.</p>
","2069114","","2069114","","2016-03-08 19:21:01","2016-03-09 07:24:08","How to catch errors from two requests in one place using RxSwift","<swift><functional-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"35897681","1","35912089","","2016-03-09 16:51:21","","22","12404","<p>I have an observable that I only want to kick off once. The docs say:</p>

<blockquote>
  <p>Using dispose bags or takeUntil operator is a robust way of making sure resources are cleaned up. We recommend using them in production even if the sequences will terminate in finite time.</p>
</blockquote>

<p>My observable terminates after just one event</p>

<pre><code>let observable = Observable.create() { observer in
  webservice.makeHTTPRequestWithCompletionBlock {
    if something {
      observer.on(.Next(...))
      observer.onCompleted()
    } else {
      observer.on(.Error(...))
    }
  }
}
</code></pre>

<p>Say I wasn't interested in cancelling subscribers to this observable, I just want it run once and complete. I want the lifecycle of this observable to end when the work itself is completed. Meaning there are no good candidates for disposeBag that I can see. takeUntil also expects an 'event', and there are no good ones that I can see. </p>

<p>Right now I just solve the warning by throwing away the disposable:</p>

<pre><code>_ = observeable.subscribeNext { ... }
</code></pre>

<p>Is there a way to do this, or a different paradigm that I should use?</p>
","175225","","1113632","","2018-04-02 13:34:43","2018-07-06 17:47:03","Proper way to dispose a one-off observable in RxSwift","<ios><swift><rx-swift>","1","0","5","","","CC BY-SA 3.0"
"35936387","1","","","2016-03-11 09:25:12","","10","10958","<p>I am still a beginner in Reactive programming, and RxSwift in general.
I want to chain two different operation. In my case I simply want to download a zip file from a web server, and then unzip it locally.
I also want, at the same time to show the progress of the downloaded files.
So I started creating the first observable:</p>

<pre><code> class func rx_download(req:URLRequestConvertible, testId:String) -&gt; Observable&lt;Float&gt; {

    let destination:Request.DownloadFileDestination = ...

    let obs:Observable&lt;Float&gt; = Observable.create { observer in
       let request =  Alamofire.download(req, destination: destination)
        request.progress { _, totalBytesWritten, totalBytesExpectedToWrite in
            if totalBytesExpectedToWrite &gt; 0 {
                observer.onNext(Float(totalBytesWritten) / Float(totalBytesExpectedToWrite))
            }
            else {
                observer.onNext(0)
            }
        }
        request.response {  _, response, _, error in
            if let responseURL = response {
                if responseURL.statusCode == 200 {
                    observer.onNext(1.0)
                    observer.onCompleted()
                } else  {
                    let error = NSError(domain: ""error"", code: responseURL.statusCode, userInfo: nil)
                    observer.onError(error)
                }
            } else {
                let error = NSError(domain: ""error"", code: 500, userInfo: nil)
                observer.onError(error)
            }

            }
            return AnonymousDisposable () {
                request.cancel()
            }
        }
    return obs.retry(3)

}
</code></pre>

<p>After that, I create a similar function for the unzip</p>

<pre><code>class func rx_unzip(testId:String) -&gt; Observable&lt;Float&gt; {
    return Observable.create { observer in
        do {
            try Zip.unzipFile(NSURL.archivePath(testId), destination: NSURL.resourceDirectory(testId), overwrite: true, password: nil)
                {progress in
                    observer.onNext(Float(progress))
                }
        } catch let error {
            observer.onError(error)
        }
        observer.onCompleted()
        return NopDisposable.instance
    }
}
</code></pre>

<p>For now I have this logic on the ""View model layer"", so I download-> subscribe on completed-> unzip</p>

<p>What I want is to combine the two Observable in one, in order to perform the download first, then on completed unzip the file. Is there any way to do this? </p>
","878797","","","","","2016-11-15 15:43:43","RxSwift, how do I chain different observables","<ios><swift><alamofire><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"35946969","1","35957529","","2016-03-11 18:04:13","","1","1809","<p>I have a simple server request that I want to filter and generate a new Observable validating the request with the JSON data.</p>

<p>I have to do this because even when my request is invalid, my server response returns status code 200. But I can filter this result in my Json response:</p>

<p>Server response:</p>

<pre><code>&lt;NSHTTPURLResponse: 0x7fb2d2617850&gt; { URL: http://service-.herokuapp.com/--} { status code: 200, headers ...
</code></pre>

<p>Json:</p>

<pre><code>{""system"": {""code"": ""401"",""message"": ""Access Not Authorized""}}
</code></pre>

<p>My rx request is: </p>

<pre><code>let manager = Manager.sharedInstance
return manager.rx_request(method, ""\(ApiRoutes.baseURL)\(path)"", parameters: parameters)
// then validate server response
.flatMap{
     $0.validate(statusCode: 200..&lt;300)
     .rx_responseData()
}
// then I create a new Observable validating the received json
.flatMapLatest { response, data in
     return Observable.create{ observer in
          let json = JSON(data: data)

          let statusCode = Int(json[""system""][""code""].numberValue) ?? 400

          if 200..&lt;300 ~= statusCode {
                observer.onNext((response,data))
          }else{
                observer.onError(NSError(domain: ""test"", code: 1, userInfo: nil))
          }
          observer.onCompleted()
          return NopDisposable.instance
     }
}
.observeOn(MainScheduler.instance)
</code></pre>

<p>My question is: When my json pass (status code between 200 and 300) I send an Event Next and after an Event Complete, this completes this signal and first signal Completes as well. But when I send an Event Error when validating my JSON the first signal never completes or fail. How can I do this?</p>

<p>Thank you</p>
","1772384","","","","","2016-03-12 12:16:48","RxAlamofire + Combine Signals","<swift><alamofire><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"36031546","1","","","2016-03-16 09:31:07","","7","3542","<p>I'm trying to use RxSwift for binding in MVVM.
I have a <code>Enum</code>:</p>

<pre><code>enum Color : Int {
    case Red = 0, Green
}
</code></pre>

<p>and class for test</p>

<pre><code>class Test : NSObject {
    var color: Color = .Red
    dynamic var test: String? {
        didSet {
            print(""didSet \(test)"")
        }
    }
}
</code></pre>

<p>And want to observe changes like:</p>

<pre><code>test.rx_observe(Color.self, ""color"").subscribeNext { (color) -&gt; Void in
     print(""Observer \(color)"")
}.addDisposableTo(bag)
</code></pre>

<p>But the program chashes with 
<code>*** Terminating app due to uncaught exception 'NSUnknownKeyException', reason: '[&lt;RDProject.Test 0x7ff373513020&gt; addObserver:&lt;RxCocoa.KVOObserver 0x7ff37351a420&gt; forKeyPath:@""color"" options:5 context:0x0] was sent to an object that is not KVC-compliant for the ""color"" property.'</code></p>

<p>Code for simple <code>String</code> works:</p>

<pre><code>test.rx_observe(String.self, ""test"").subscribeNext { string in
     print(""Observer \(string)"")
}.addDisposableTo(bag)

test.test = ""1""
test.test = ""2""
</code></pre>

<p>I found <a href=""https://stackoverflow.com/questions/35766600/how-to-observe-array-property-changes-in-rxswift/35792203#35792203"">here</a> that to make class inherited not from <code>NSObject</code> I should make it <code>dynamic</code>, but I can't make <code>Enum</code> dynamic.
Is there a way to make <code>Enum</code> observable?</p>
","1023952","","-1","","2017-05-23 10:32:33","2019-10-14 08:29:28","Is there a way to make observable enum in Swift (KVO)","<swift><key-value-observing><rx-swift>","3","0","0","","","CC BY-SA 3.0"
"36043122","1","36044092","","2016-03-16 17:44:10","","15","12186","<p>I'm a newbie in RxSwift and need a very basic help.<br/>
Assump that I have an Observable and subscribe it like this.</p>

<pre><code> let source: Observable&lt;Void&gt; = Observable.create { [weak self] observer in

        guard let _ = self else {
            observer.on(.Completed)
            return NopDisposable.instance
        }

        observer.on(.Next())

        return AnonymousDisposable {

        }
    }
</code></pre>

<p>And the subscribe like this:<br/></p>

<pre><code> source.subscribeNext { () -&gt; Void in

    }
</code></pre>

<p>The question is: how can I emit the event to subscribeNext manually every time I need. This is like <code>rx_tap</code> behavior on <code>UIButton</code>.<br/>
I see in the example code has something like this <code>source = button.rx_tap.asObservale()</code>. After that, every time user tap to button, there will emit an event and trigger on subscribeNext(). I also want to have that behavior but in programmatically, not from UI event.</p>
","1066518","","","","","2017-01-04 20:41:13","Emit an event manually in RxSwift","<ios><swift><reactive-cocoa><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"36050347","1","36050818","","2016-03-17 02:00:39","","23","20441","<p>I have a Variable which is an array of enum values. These values change over time.</p>

<pre><code>enum Option {
    case One
    case Two
    case Three
}

let options = Variable&lt;[Option]&gt;([ .One, .Two, .Three ])
</code></pre>

<p>I then observe this variable for changes. The problem is, I need to know the diff between the newest value and the previous value. I'm currently doing this:</p>

<pre><code>let previousOptions: [Option] = [ .One, .Two, .Three ]

...

options
    .asObservable()
    .subscribeNext { [unowned self] opts in
        // Do some work diff'ing previousOptions and opt
        // ....
        self.previousOptions = opts
    }
</code></pre>

<p>Is there something built in to RxSwift that would manage this better? Is there a way to always get the previous and current values from a signal?</p>
","1212209","","","","","2019-02-21 23:40:33","Observable Current and Previous Value","<swift><rx-swift>","7","0","8","","","CC BY-SA 3.0"
"36050580","1","36056827","","2016-03-17 02:26:10","","0","809","<p>I am having some issues understanding if there is any support to combine RxSwift with Realm, as Realm explicitly states the supported variable types.</p>

<p>Is it possible instead of the following.</p>

<pre><code>import RealmSwift

class Dog: Object {
  dynamic var name = """"
}
</code></pre>

<p>To do something like this.</p>

<pre><code>import RealmSwift
import RxSwift

class Dog: Object {
  var name = Variable&lt;String&gt;("""")
}
</code></pre>

<p>I have done some googling and haven't found any up to date information about extensions or other solutions to do this. Would appreciate any help or just pointing in the right direction.</p>
","1322872","","1322872","","2016-03-17 02:27:17","2016-03-17 09:45:49","RxSwift Variable with Realm object storing","<ios><swift><realm><rx-swift>","1","1","","","","CC BY-SA 3.0"
"36059483","1","36059686","","2016-03-17 11:39:15","","4","1348","<p>I need to  emit a sequence of items if it encounters an error in RxSwift. In JAVA it can be done with ""onErrorResumeNext"" operator. But I can not find the same operator or its substitute in Swift. </p>
","4092466","","1173513","","2016-03-17 11:45:03","2016-03-17 11:47:56","What is the analog of RxJava onErrorResumeNext operator in RxSwift?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"36070549","1","","","2016-03-17 19:59:35","","2","535","<p>I have a View and a View Model. The View contains a button, and every time the user presses it, I want the View Model to be informed. I also want a second View Model to be informed when the first view model gets the event.</p>

<p>So the tap event would be propagated as follows:</p>

<pre><code>Button -&gt; ViewModel1 -&gt; ViewModel2
</code></pre>

<p>I could design this by binding <code>button.rx_tap</code> to <code>viewModel1.onButtonTapped()</code>, however since I want <code>viewModel2</code> to subscribe to also get the event, I need some kind of observable that receives an action and propagates it. I believe that is what <code>RACCommand</code> does.</p>

<p>How can I implement this using RxSwift?</p>
","646960","","","","","2016-03-18 08:41:30","What is the equivalent of RACCommand in RxSwift?","<ios><swift><events><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"36173034","1","","","2016-03-23 08:25:17","","1","624","<p>I used to use ReactiveCocoa in Objective-C but I've since switched to RxSwift as I found it easier to understand than RAC4.  However there's something I used to do in RAC that was useful:</p>

<pre><code>@weakify(self);
[[RACCommand alloc] initWithEnabled:RACObserve(self, valid) signalBlock:^RACSignal *(id input) {
    @strongify(self);
    return [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

        //make network call

        //send responseObject to subscriber
        [subscriber sendNext:responseObject];

        [subscriber sendCompleted];
        return nil;
    }] materialize];
}];
</code></pre>

<p>This allowed me to subscribe to the command for it's executing state as well as its execution signals so that I could observe data that is returned from the call.</p>

<p>I'm not sure how to reproduce this with RxSwift Action.  I am only able to subscribe to its executing observable:</p>

<pre><code>    var loader: NotificationType?
    formButton.rx_action!.executing.subscribeNext({ [weak self] (executing) -&gt; Void in
        if executing {
            loader = self?.showNotification(.Loading, title: self?.viewModel.loaderTitle.value, message: ""Please wait"".localized, timeout: -1)
        }
        else {
            if let loader = loader {
                loader.dismiss()
            }
        }
    }).addDisposableTo(disposeBag)
</code></pre>

<p>But I then have to create an additional <code>PublishSubject</code> to send my response data:</p>

<pre><code>    viewModel.submitSubject.subscribe(onNext: { (response) -&gt; Void in
        print(response)
        }, onError: { (error) -&gt; Void in
            print(error)
        }, onCompleted: { () -&gt; Void in
            //completed
        }) { () -&gt; Void in
    }.addDisposableTo(disposeBag)
</code></pre>

<p>Is there a way to create a similar pattern in RxSwift with Action?</p>
","2271759","","","","","2016-03-23 13:59:12","Send object to subscriber of RxSwift Action","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"36190967","1","36208058","","2016-03-23 23:56:46","","4","10751","<p>Hi I am trying to get an understanding of the RxSwift library to write better, functional code.</p>

<p>Currently I am stuck at a very basic problem. Lets say I got this variables of type <code>Variable&lt;[CiteModel?]&gt;</code>:</p>

<pre><code>var allCites: Variable&lt;[CiteModel?]&gt; = Variable([])
var shownCites: Variable&lt;[CiteModel?]&gt; = Variable([])
</code></pre>

<p>Now I want to filter all cites from <code>allCites</code> array which contain a specific text and add them to <code>shownCites</code>.</p>

<p>This is what I have tried but it does not compile because inside my filter block <code>$0</code> is <code>[CiteModel?]</code> <strong>not</strong> <code>CiteModel?</code> what I would expect. Could you explain to me what I did wrong ?</p>

<pre><code>private func filterCitesByQuery(query: String) {
    self.shownCites = self.allCites.asObservable().filter {
        $0?.cite.containsString(query)
    }
}
</code></pre>

<p><strong>Error</strong> when executing the above code:</p>

<pre><code>Cannot assign value of type 'Observable&lt;[CiteModel?]&gt;' (aka 'Observable&lt;Array&lt;Optional&lt;CiteModel&gt;&gt;&gt;') to type 'Variable&lt;[CiteModel?]&gt;' (aka 'Variable&lt;Array&lt;Optional&lt;CiteModel&gt;&gt;&gt;')
</code></pre>
","720133","","642626","","2016-03-24 00:35:37","2016-03-24 19:00:51","RxSwift filter Variable array","<ios><swift><functional-programming><rx-swift>","3","2","6","","","CC BY-SA 3.0"
"36282157","1","36287979","","2016-03-29 10:48:36","","1","1029","<p>I have this result datatype called 🍒 which wraps a type and a progress</p>

<pre><code>public enum 🍒&lt;T&gt; {
    case Success(T)
    case Progress(CGFloat)
}

class func rx_request(router: Router) -&gt; Observable&lt;🍒&lt;AnyObject&gt;&gt;
</code></pre>

<p>This <code>AnyObject</code> needs to be transformed into a <code>Mappable</code> structure (ObjectMapper), so because I have several of these Mappable structs, I wanted to achieve something like this, a generic map that I can use:</p>

<pre><code>class func rx_convert&lt;T : Mappable&gt;(value: 🍒&lt;AnyObject&gt;) -&gt; Observable&lt;🍒&lt;T&gt;&gt; {

        return Observable.create { observer in

            switch value {
            case .Success(let object):
                guard let convertedObject = Mapper&lt;T&gt;().map(object) else {
                    observer.onError(NetworkError.IncorrectDataReturned)
                    return NopDisposable.instance
                }

                observer.on(.Next(🍒&lt;T&gt;.Success(convertedObject)))
                observer.on(.Completed)

            case .Progress(let progress):
                observer.on(.Next(🍒&lt;T&gt;.Progress(progress)))
                break
            }

            return NopDisposable.instance
        }
}
</code></pre>

<p>It seems the above definition is wrong because this cannot be compiled: <code>Cannot explicitly specialize a generic function</code></p>

<pre><code>.flatMapLatest({ _ in
    🐯.rx_request(Router.Pipeline)
})
.flatMapLatest({ result -&gt; Observable&lt;🍒&lt;ResponsePipeline&gt;&gt; in
    🐯.rx_convert&lt;ResponsePipeline&gt;(result)
    // Cannot explicitly specialize a generic function
})
</code></pre>

<p>What am I doing wrong here?</p>
","4726244","","343299","","2016-07-06 12:51:38","2016-07-06 12:51:38","Issue with generic conversion method using RxSwift","<swift><generics><rx-swift><objectmapper>","1","0","1","","","CC BY-SA 3.0"
"36354927","1","36355551","","2016-04-01 11:14:34","","11","10448","<p>I have this piece of code:</p>

<pre><code>let appActiveNotifications: [Observable&lt;NSNotification&gt;] = [
    NSNotificationCenter.defaultCenter().rx_notification(UIApplicationWillEnterForegroundNotification),
    NSNotificationCenter.defaultCenter().rx_notification(Constants.AppRuntimeCallIncomingNotification)
]

appActiveNotifications.merge()
  .takeUntil(self.rx_deallocated)
  .subscribeNext() { [weak self] _ in
  // notification handling
}
.addDisposableTo(disposeBag)
</code></pre>

<p>It's supposed to listen to either of the specified notifications and handle when any of them is triggered.</p>

<p>However this does not compile. I get the following error:</p>

<pre><code>Value of type '[Observable&lt;NSNotification&gt;]' has no member 'merge'
</code></pre>

<p>How should I merge these two signals to one then?</p>
","1370986","","","","","2016-04-01 11:56:37","Merging two notification observers in RxSwift","<swift><rx-swift><reactivex>","1","0","1","","","CC BY-SA 3.0"
"36358111","1","36362227","","2016-04-01 13:50:57","","1","2943","<p>I am new to RxSwift and I was wondering how I would be able to ""reactively"" use a UIRefreshControl with a UITableView instead of the normal way of creating a target, and manually calling <code>beginRefreshing()</code> and <code>endRefreshing()</code>.</p>

<p>For instance, say I am loading some strings from an API:</p>

<pre><code>class TableViewController: UITableViewController {

    var data : [String] = []

    let db = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        refreshControl = UIRefreshControl()

        //I don't want to use
        //refreshControl?.addTarget(self, action: #selector(getData), forControlEvents: .ValueChanged)

        //Do something to refreshControl.rx_refreshing?
    }

    override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
        let cell = tableView.dequeueReusableCellWithIdentifier(""Cell"", forIndexPath: indexPath)
        let str = data[indexPath.row]
        cell.textLabel?.text = str
        return cell
    }

    //MARK: - Requests

    private func getData() {
        let myData = MyAPI.getData() //Returns Observable&lt;[String]&gt;
        myData
            .subscribe({ [weak self] (event) in
                switch event {
                case .Next(let strings):
                    self?.data = strings
                    self?.tableView.reloadData()
                    break
                case .Error(let err):
                    print(err)
                    break
                case .Completed:
                    break
                }
                // self?.refreshControl?.endRefreshing()
                })
            .addDisposableTo(db)
    }
}
</code></pre>

<p><code>MyAPI</code> sends a request for some string values, how can I bind the <code>refreshControl</code> to call <code>getData()</code> and also stop refreshing when it's finished (or error'd) the network request? Do I need to bind to <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxCocoa/iOS/UIRefreshControl%2BRx.swift"" rel=""nofollow"">refreshControl.rx_refreshing</a>?</p>
","4684652","","343299","","2016-07-06 11:47:32","2016-07-06 11:47:32","Binding to a UIRefreshControl after network call","<ios><swift><uirefreshcontrol><rx-swift>","1","0","3","","","CC BY-SA 3.0"
"36408772","1","","","2016-04-04 17:10:42","","2","1718","<p>I am making an app for iPad using RXSwift and MVVM.</p>

<p>I have a UIViewController with a UICollectionView and a ViewModel which acts as the dataSource and the delegate for the collectionView.</p>

<p>Part of the collection cells' functionality is that when a button is tapped to present a popover. Now with the newer popover functionality in iOS 9 (possibly earlier) you need to present the view normally within the view controller, and modify the popoverPresentationController.</p>

<p>Now, as far as i'm aware you are not able to present a UIViewController from a UICollectionViewCell. Makes sense.</p>

<p>But the only way i thought to do this would be to have a delegate that points to the ViewController.</p>

<p>Looking at the class diagram (attached), the viewModel would have to set the delegate upon cell dequeue. To do that the ViewModel would have to know what ViewController to set as the delegate which i'm fairly sure goes against the point of the viewModel. According to MVVM (for iOS) the view model should not know about the view controller. The view controller can know about the view model.</p>

<p>And so my question is what would be the best way to do this following MVVM? If it requires moving the dataSource/Delegate to a different class i'm all for it.</p>

<p><a href=""https://i.stack.imgur.com/jdL2H.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jdL2H.png"" alt=""UML Diagram""></a></p>
","1783511","","","","","2016-04-05 08:13:05","What would the proper MVVM architecture be for a UICollectionViewController","<ios><swift><mvvm><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"36421172","1","","","2016-04-05 08:37:18","","2","866","<p>I'm trying to use a PublishSubject to forward button clicks. However this PublishSubject triggers on initialisation and that interferes with my logic. This is what I'm doing:</p>

<pre><code>var buttonClick = PublishSubject&lt;Void&gt;()
</code></pre>

<p>(This initialisation line will trigger the first Next event)</p>

<p>Then on the button tap action:</p>

<pre><code>@IBAction func buttonClicked(sender: AnyObject) {
        buttonClick.onNext()
    }
</code></pre>

<p>and then I subscribe to it like this:</p>

<pre><code>buttonClick
            .asDriver(onErrorJustReturn: ())
            .driveNext { () in

            }.addDisposableTo(disposeBag)
</code></pre>

<p>Is there any way to do this without triggering the first ""Next"" event published upon initialisation?</p>

<p>Cheers!</p>
","734702","","","","","2016-04-06 20:26:58","RxSwift PublishSubject triggers unintentionally on initialization","<swift><rx-swift>","1","2","","","","CC BY-SA 3.0"
"36428668","1","36700137","","2016-04-05 14:04:23","","6","1802","<p>I am using RxSwift and wondering what is difference between subscribeNext and bindNext?</p>

<p>Thanks for your input.</p>
","66086","","","","","2016-04-18 17:05:30","Difference between subscribeNext and bindNext","<ios><rx-swift><reactivex>","1","1","1","","","CC BY-SA 3.0"
"36434108","1","36439614","","2016-04-05 18:21:11","","0","1265","<p>I'm wondering how to write my code in more elegant way... I have two requests, the second request have to wait for the first one. If the first one gets failed the whole sentence should failed, I'm wondering how to catch error in one common place?</p>

<pre><code>    enum TestError: ErrorType {
        case Connection
    }

    private func runTest() {
        rx_firstReq()
            .subscribeNext() { _ in
                return self.rx_secondReq()
                    .subscribeNext() { _ in
                        print(""whole req sequence finished with success!"")
                }.addDisposableTo(self.myDisposeBag)
        }.addDisposableTo(myDisposeBag)
    }

    func rx_firstReq() -&gt; Observable&lt;Bool&gt; {
        return Observable.create() { observable -&gt; Disposable in
            observable.onError(TestError.Connection) // We are assuming that first req gets failed
            observable.onCompleted()

            return NopDisposable.instance
        }
    }

    func rx_secondReq() -&gt; Observable&lt;Bool&gt; {
        return Observable.create() { observable -&gt; Disposable in
            observable.onNext(true)
            observable.onCompleted()

            return NopDisposable.instance
        }
    }
</code></pre>

<p>As you see there is no any place for error handling... I have no idea how to model it, at this moment each next request in my chain gonna create next indentation level... in my opinion it is not good usage of the RxSwift... 😕</p>

<p>..some hint or link with example code with handling error in common place will be great for me.</p>
","2069114","","","","","2017-11-08 18:59:56","How to chain Observables and create one common place for error handling","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"36460542","1","37391859","","2016-04-06 19:23:27","","1","4229","<p>I'm trying to come up with a simple observable object in Swift and thought to use <a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow"">RxSwift</a>. I couldn't find a simple example to do something like this:</p>

<pre><code>protocol PropertyObservable {
  typealias PropertyType
  var propertyChanged: Event&lt;(PropertyType, Any)&gt; { get }
}

class Car: PropertyObservable {
  typealias PropertyType = CarProperty
  let propertyChanged = Event&lt;(CarProperty, Any)&gt;()

  dynamic var miles: Int = 0 {
    didSet {
      propertyChanged.raise(.Miles, oldValue as Any)
    }
  }

  dynamic var name: String = ""Turbo"" {
    didSet {
      propertyChanged.raise(.Name, oldValue as Any)
    }
  }
}
</code></pre>

<p>The above is pure Swift solution for observables from <a href=""http://blog.scottlogic.com/2015/02/11/swift-kvo-alternatives.html"" rel=""nofollow"">this blog post</a>; I really like how it's a protocol-based solution and not invasive. In my case, I have an object in my project where each property is set asynchronously under the hood (bluetooth device). So I need to observe/subscribe to the changes instead of getting/setting the properties in real-time.</p>

<p>I keep hearing RxSwift will do just that and more. However, I can't find a simple example to match above and beginning to think RxSwift is overkill for my need? Thanks for any help.</p>
","235334","","","","","2016-05-23 13:07:23","Simple observable struct with RxSwift?","<swift><swift2><rx-swift><reactive-cocoa-3>","1","1","1","","","CC BY-SA 3.0"
"36472690","1","36477536","","2016-04-07 09:57:33","","7","828","<p>I’m starting with RxJava, and I would like to create an observable that can save the last state… </p>

<p>In RxSwift, that would be Variable (<a href=""https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#variables"">https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#variables</a>), but I can’t found an equivalente in RxJava… </p>

<p>I found a work around but it’s a lot of boiler plate code</p>

<pre><code>private boolean isGettingCompanies = false;

public boolean isGettingCompanies() {
    return isGettingCompanies;
}

private void setIsGettingCompanies(boolean isGettingCompanies) {
    this.isGettingCompanies = isGettingCompanies;
    isGettingCompaniesPublishSubject.onNext(isGettingCompanies);
}

private final PublishSubject&lt;Boolean&gt; isGettingCompaniesPublishSubject = PublishSubject.create();

public Observable&lt;Boolean&gt; isGettingCompaniesPublishSubject() {
    return isGettingCompaniesPublishSubject.asObservable();
}
</code></pre>

<p>the RxSwift equivalent is this</p>

<pre><code>private(set) var isGettingCompanies: Variable = Variable(false)
</code></pre>

<p>Can you help me please? Thanks</p>
","976628","","","","","2016-04-07 13:22:57","RxJava Observable with last state","<java><rx-java><observable><frp><rx-swift>","1","0","","","","CC BY-SA 3.0"
"36507262","1","","","2016-04-08 18:57:46","","0","1268","<p>How can I implement observable for Local notification and Push notifications when they are received.
In app delegate, We are notify on</p>

<pre><code>didReceiveLocalNotification
</code></pre>

<p>and</p>

<pre><code>didReceiveRemoteNotification
</code></pre>

<p>How can I listen these notification on other screen? I've used NotificationCenter for notify but now I want to use RX-Swift. I've tried with this way but not working.</p>

<pre><code>  extension UILocalNotification {
   var notificationSignal : Observable&lt;UILocalNotification&gt; {
        return Observable.create { observer in
            observer.on(.Next(self))
            observer.on(.Completed)
            return NopDisposable.instance
        }
    }
}
</code></pre>

<p>Can anyone help me?</p>

<p>Updated: </p>

<p>Hi, I found a solution for that using same way as you are used but some changes.</p>

<pre><code>class NotificationClass {
    static let bus = PublishSubject&lt;AnyObject&gt;()

    static func send(object : AnyObject) {
        bus.onNext(object)
    }

    static func toObservable() -&gt; Observable&lt;AnyObject&gt; {
        return bus
    }

}
</code></pre>

<p>Send notification from AppDelegate:</p>

<pre><code>func application(application: UIApplication, didReceiveLocalNotification notification: UILocalNotification) {
    NotificationClass.send(notification)
}
</code></pre>

<p>Then observe on any other class.</p>

<pre><code>    NotificationClass.bus.asObserver()
        .subscribeNext { notification in
            if let notification : UILocalNotification = (notification as! UILocalNotification) {
                print(notification.alertBody)
            }
    }
    .addDisposableTo(disposeBag)
</code></pre>

<p>Best thing of this class is we can emit and consume anyObject through it.</p>
","5359254","","5359254","","2016-04-09 11:49:29","2016-04-09 11:49:29","Rx_Swift for Local and Push Notifications","<ios><swift><reactive-programming><rx-swift>","1","1","1","","","CC BY-SA 3.0"
"36516940","1","36518957","","2016-04-09 12:46:02","","1","4190","<p>I am currently trying to learn Rx programming. I found Moya intriguing and have been trying to implement a simple network request which then gets mapped to objects which I can then use to populate a tableView.</p>

<p>I have been following this tutorial: <a href=""http://www.thedroidsonroids.com/blog/ios/rxswift-examples-3-networking/"" rel=""nofollow"">http://www.thedroidsonroids.com/blog/ios/rxswift-examples-3-networking/</a></p>

<p>I believe I am getting a successful response as I am using <code>.debug</code> and getting the following output:</p>

<pre><code>2016-04-09 13:29:30.398: MyApi.swift:37 (findRepository) -&gt; subscribed
2016-04-09 13:29:30.400: MyApi.swift:35 (findRepository) -&gt; subscribed
2016-04-09 13:29:32.633: MyApi.swift:35 (findRepository) -&gt; Event Next(Status Code: 20..., Data Length: 5747)
2016-04-09 13:29:32.633: MyApi.swift:35 (findRepository) -&gt; Event Completed
</code></pre>

<p>Here is the code that I am using:</p>

<pre><code>let provider: RxMoyaProvider&lt;MyApi&gt;
let repositoryName: Observable&lt;String&gt;

func trackIssues() -&gt; Observable&lt;[Train]&gt; {
    return repositoryName
        .observeOn(MainScheduler.instance)
        .flatMapLatest { name -&gt; Observable&lt;[Train]?&gt; in
            print(""Name: \(name)"")

            return self.findRepository(name)
        }.replaceNilWith([])
}

internal func findRepository(name: String) -&gt; Observable&lt;[Train]?&gt; {
    print(""help"")
    return self.provider
        .request(MyApi.Trains(name, ""c76a46ce2b3d8685982b/raw/10e86080c3b1beedd46db47f5bb188cc74ce5c78/sample.json""))
        .debug()
        .mapArrayOptional(Train.self)
        .debug()
}
</code></pre>

<p>And here is the object I am trying to map to:</p>

<pre><code>import Mapper

struct Train: Mappable {

    let distance: String
    let eta: String

    init(map: Mapper) throws {
        try distance = map.from(""distance"")
        try eta = map.from(""eta"")
    }
}
</code></pre>

<p>I have looked at the network response and am wondering if I first need to abstract the ""trains"" data. I have tried this by mapping to the following object with out luck:</p>

<pre><code>import Mapper

struct TrainsResponse: Mappable {

    let trains: String

    init(map: Mapper) throws {
        try trains = map.from(""trains"")
    }
}
</code></pre>

<p>Please find example json response here: <a href=""http://pastebin.com/Wvx8d5Lg"" rel=""nofollow"">http://pastebin.com/Wvx8d5Lg</a></p>

<p>So I was wondering if anyone can help me see why I am unable to turn the response into objects. Thanks.</p>

<p>=======</p>

<p>I have tried doing a pod update and it's still not working. Here is where I am binding it to the tableView:</p>

<pre><code>func setupRx() {
    // First part of the puzzle, create our Provider
    provider = RxMoyaProvider&lt;MyApi&gt;()

    // Now we will setup our model
    myApi = MyApi(provider: provider, repositoryName: userName)

    // And bind issues to table view
    // Here is where the magic happens, with only one binding
    // we have filled up about 3 table view data source methods
    myApi
        .trackIssues()
        .bindTo(tableView.rx_itemsWithCellFactory) { (tableView, row, item) in
            let cell = tableView.dequeueReusableCellWithIdentifier(""issueCell"", forIndexPath: NSIndexPath(forRow: row, inSection: 0))
            cell.textLabel?.text = ""Hello""

            print(""Hello"")

            return cell
        }
        .addDisposableTo(disposeBag)
}
</code></pre>

<p>The code inside bind to (where I set the cell) never gets called. Also if I put a break point inside my Train mapper class that also never gets called.</p>
","2126233","","2126233","","2016-04-09 14:03:38","2016-04-09 15:36:58","Mapping JSON response to objects using Rx programming (Moya)","<ios><swift><networking><rx-swift><moya>","1","5","1","","","CC BY-SA 3.0"
"36522769","1","","","2016-04-09 21:11:53","","0","928","<p>I am using <code>RxSwift</code> library in my app. I am trying to convert my app logic for processing GPS location updates and move that over to an observable. For that, I have been using this code as baseline:
<a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/GeolocationExample/GeolocationViewController.swift"" rel=""nofollow"">https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/GeolocationExample/GeolocationViewController.swift</a></p>

<p>However, in the code above, the updates are delivered directly to an UIElement via the UIView extension. This is of no use to me, as I need these updates to be delivered to a non-UI observer variable for further background processing. </p>

<p>I am new to RxSwift and I am not aware how to build the type of Observer that I need in this case. Neither have I been able to find this within RxSwift documentation.</p>

<p>I would appreciate if someone can comment on how to achieve this implementation of CLLocationManager with RxSwift.</p>
","1519045","","","","","2016-04-09 22:17:59","How to create an Observable from CLLocationManager updates","<swift><cllocationmanager><rx-swift>","1","0","","","","CC BY-SA 3.0"
"36523753","1","41073120","","2016-04-09 23:01:26","","7","1418","<p>I'm trying to use UIPickerView with RxSwift. Is there a way to wrap the UIPickerView dataSource and delegate methods to be used with Observables? I'm trying to do something like</p>

<pre><code>dataSequence
    .bindTo(pickerView.rx_itemsWithDataSource(dataSource))
</code></pre>

<p>I see there is a premade library for UITableview 
<a href=""https://github.com/RxSwiftCommunity/RxDataSources"" rel=""nofollow"">https://github.com/RxSwiftCommunity/RxDataSources</a> but I'm wondering if there's an easy way to generalize this for other things that require dataSource and delegate using RxSwift.</p>
","1327871","","18278","","2016-04-20 14:18:06","2016-12-10 07:12:21","How to use dataSource and delegate methods with RxSwift","<ios><swift><reactive-programming><rx-swift>","1","1","3","","","CC BY-SA 3.0"
"36534964","1","36535460","","2016-04-10 20:10:05","","2","2635","<p>Following a similar example to question 39 here: <a href=""http://reactivex.io/learnrx/"" rel=""nofollow"">http://reactivex.io/learnrx/</a></p>

<p>I'm trying to transform a method call <code>search(query: String)</code> into a sequence of those calls.
They way I'm achieving this is by creating a <code>Variable</code> which I update with the <code>query</code> value every time 
the <code>search(query: String)</code> method is called.</p>

<p>Then I have this in my <code>init()</code>:</p>

<pre><code>_ = queryVariable.asObservable().flatMap({ query -&gt; Observable&lt;[JSON]&gt; in
    return self.facebookSearch(query).takeUntil(self.queryVariable.asObservable())
}).subscribeNext({ result in
    if let name = result[0][""name""].string {
        print(name)
    } else {
        print(""problem"")
    }
})
</code></pre>

<p>If I type <code>""ABC""</code>, my <code>search(query: String)</code> method will be called 3 times with <code>""A""</code>, <code>""AB""</code>, <code>""ABC""</code>.
That would be mapped to <code>seq([""A"", ""AB"", ""ABC""])</code> with <code>queryVariable.asObservable()</code>.
Then I'm mapping it to Facebook searches (searching people by their names on Facebook).
And with <code>subscribeNext</code> I print the name.
If I don't use the <code>takeUntil</code>, it works as I'd expect, I get 3 sets of results, one for each of my queries(<code>""A""</code>, <code>""AB""</code>, <code>""ABC""</code>).</p>

<p>But if I type fast (before Facebook has time to respond to the request), I'd want only one result, for the query <code>""ABC""</code>. That's why I added the <code>takeUntil</code>. With it I'd expect the <code>facebookSearch(query: String)</code> call to be ignored when the next <code>query</code> comes in, but it is being canceled for the current query, so with this <code>takeUntil</code> I end up printing nothing.</p>

<p>Is this a known issue or am I doing something wrong?</p>
","1116465","","343299","","2016-07-06 13:37:47","2016-07-06 13:37:47","RXSwift - takeUntil canceling before next event","<ios><swift><facebook><rx-swift><reactivex>","1","0","1","","","CC BY-SA 3.0"
"36536059","1","36543442","","2016-04-10 22:03:23","","2","2173","<p>I am trying to attach data to a UITableView. I have download the project form here and am using the code where data is attached to the tableView: <a href=""http://yannickloriot.com/2016/01/make-uitableview-reactive-with-rxswift/"" rel=""nofollow noreferrer"">http://yannickloriot.com/2016/01/make-uitableview-reactive-with-rxswift/</a>:</p>

<p>Firstly I have created the following variable:</p>

<pre><code>let currentQuestion: Variable&lt;Taxi?&gt;   = Variable(nil)
</code></pre>

<p>I then try to do the following: </p>

<pre><code> currentQuestion
        .asObservable()
        .bindTo(tableView.rx_itemsWithCellIdentifier(""ChoiceCell"", cellType: ChoiceCell.self)) { (row, element, cell) in
            cell.choiceModel = element
        }
        .addDisposableTo(disposeBag)
</code></pre>

<p>But I am getting the following warning: 'Extra argument in call' on the line <code>.bindTo</code>. I have tried adding a new cell and get the same result. Not sure if it is relevant, but I have registered the cell.</p>

<p>I have read here that you can get this warning if the types of the arguments don't match: <a href=""https://stackoverflow.com/questions/24795035/swift-extra-argument-in-call"">Swift - Extra Argument in call</a> . However it looks like the arguments match fine.</p>

<p>I am new to Rx and was hope someone could help me understand what might be going wrong here. Thanks.</p>

<p>======</p>

<p><strong>Edit</strong></p>

<p>Here is my new code. I have tried <code>rx_itemsWithCellIdentifier(""ChoiceCell"")</code> alone and <code>rx_itemsWithCellIdentifier(""ChoiceCell"", cellType: ChoiceCell.self)</code>:</p>

<pre><code>let currentQuestion = Variable&lt;[Taxi]&gt;(taxis)

    currentQuestion.asObservable()
        .bindTo(tableView.rx_itemsWithCellIdentifier(""ChoiceCell"")) {(row, element, cell) in
        cell.choiceModel = element
        }.addDisposableTo(disposeBag)
</code></pre>

<p>Where I have used (taxis), it is an array of taxi items. See picture below:</p>

<p><a href=""https://i.stack.imgur.com/RXiLf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RXiLf.png"" alt=""enter image description here""></a></p>

<p>Also once I have called .asObservable(), I have the following:</p>

<p><a href=""https://i.stack.imgur.com/FvyL5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FvyL5.png"" alt=""enter image description here""></a></p>

<p>I managed to print these out by removing the line <code>.bindTo</code>. If I add that line back I get the same error as before.</p>

<p>IMPORTANT: I played around with code base from article I linked to earlier. If I remove from ChoiceCell I can replicate the same error:</p>

<pre><code>//  var choiceModel: ChoiceModel? {
//    didSet {
//          layoutCell()
//    }
//  }
</code></pre>
","2126233","","-1","","2017-05-23 11:53:44","2016-12-16 19:24:48","RxCocoa extra argument in call","<swift><uitableview><rx-swift><reactivex><moya>","3","0","","","","CC BY-SA 3.0"
"36538755","1","","","2016-04-11 02:10:29","","3","2224","<p>So I want to be able to lazily subscribe to shared data without it persisting when nobody is subscribed.  Then if someone subscribes again, a new observable will be created.  I would use a Variable, but I don’t want it to persist if no one is subscribed (because if I were using arrays or something larger than an int I don’t want to keep them in memory).  My current implementation works, except when resubscribing it still gets the last value, which means the value is still persisted.  I’m thinking of setting the observable to nil, but I don’t know where to do that.  Can anyone help me complete this?  The code below shows it mostly working, but it looks like the data is sticking around when no one is subscribed.</p>

<pre><code>    var switchTwoDisposable: Disposable? = nil
​    
    @IBAction func switchOneChanged(sender: UISwitch) {
        if sender.on {
            self.switchOneDisposable = currentNumber().subscribeNext { (value) in
            log.debug(""Switch 1: \(value)"")
        }
      } else {
        switchOneDisposable?.dispose()
      }
    }
    ​
    @IBAction func switchTwoChanged(sender: UISwitch) {
      if sender.on {
        self.switchTwoDisposable = currentNumber().subscribeNext { (value) in
          log.debug(""Switch 2: \(value)"")
        }
      } else {
        switchTwoDisposable?.dispose()
      }
    }
    ​
    var numberObservable: Observable&lt;Int&gt;? = nil
    ​
    func currentNumber() -&gt; Observable&lt;Int&gt; {
      if let number = numberObservable {
        return number
      }
      self.numberObservable = Observable&lt;Int&gt;.interval(5.0, scheduler: MainScheduler.instance).shareReplay(1)
      return self.numberObservable!
    }
    ​
    ​
    // Switch 1 turned on
    // logs ""Switch 1: 0""
    // logs ""Switch 1: 1""
    // Switch 2 turned on
    // immediately logs ""Switch 2: 1""
    // logs ""Switch 1: 2""
    // logs ""Switch 2: 2""
    // Switch 1 turned off
    // logs ""Switch 2: 3""
    // Switch 2 turned off
    // nothing happens here until we take action again
    // Switch 1 turned on
    // logs ""Switch 1: 3""
    // logs ""Switch 1: 0""
</code></pre>
","2554467","","2554467","","2016-04-11 04:59:08","2016-04-11 04:59:08","RxSwift: How to use shareReplay to lazily get subscription","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"36554154","1","","","2016-04-11 16:22:22","","2","300","<p>What is the recommended approach in RxSwift to implement RAC <code>tryMap</code>-like functionality?</p>
<p>The following code is how I do mapping of json objects to an internal response wrapper class. If the response fails to comply with certain conditions, <code>nil</code> will be returned, which turns into an Error Event(tryMap implementation).</p>
<pre><code>extension RACSignal{
    
    func mapToAPIResponse() -&gt; RACSignal{
        return tryMap({ (object) -&gt; AnyObject! in
            if let data = object as? [String:AnyObject]{
                //Some Logic
                return data[&quot;key&quot;]
            }
            return nil
        })
    }
}
</code></pre>
<p>How should this be implemented in RxSwift?</p>
<h2>Updated-Possible Solution</h2>
<p>I came up with following solution for Rx-Swift. Open for better solutions.</p>
<pre><code>extension Observable{
    
    func mapToAPIResponse() -&gt; Observable&lt;APIResponse&gt;{
        return map({ (object) in
            
            guard let dictionary = object as? [String:AnyObject] else{
                //APIResponseError.InvalidResponseFormat is defined in other class.
                throw APIResponseError.InvalidResponseFormat
            }
           
            
            let response = APIResponse()

            //Complete API Response
            return response

        })
}
</code></pre>
<p>My conclusion is to use throw inside a map to handle errors.</p>
","1239426","","-1","","2020-06-20 09:12:55","2016-04-12 07:48:00","RAC tryMap alternative in RxSwift","<ios><swift><reactive-cocoa><rx-swift>","2","0","","","","CC BY-SA 3.0"
"36557510","1","36581835","","2016-04-11 19:24:55","","22","11274","<p>I have an Observable which is only used for triggering <code>flatMap</code>/<code>map</code>.  So I only ever need the <code>Next</code> event and never a value.  I could use my own concept for such a trash value, but I'm wondering if there's an RxSwift convention for it.</p>

<p>Here's what I'm dealing with:</p>

<pre><code>// I'd rather not have an Element type that someone might use
let triggeringObservable: Observable&lt;SomeSessionClass&gt; 

// ...

triggeringObservable.map { _ -&gt; String in // The actual value is ignored
    return SomeLibrary.username() // `username()` is only ready when `triggeringObservable` sends Next
}
</code></pre>

<p>In this example, <code>triggeringObservable</code> is <code>rx_observer</code> on some property in the library which will let us know that <code>username()</code> is ready to be called.</p>
","343299","","343299","","2016-07-06 10:49:32","2019-06-07 04:00:38","Is there a preferred type for an Observable with no need for a value in Next events?","<swift><rx-swift><reactivex>","5","0","1","","","CC BY-SA 3.0"
"36557713","1","36561923","","2016-04-11 19:36:12","","4","9016","<p>Is there an operator that can filter <code>nil</code>?  The closest I've come is the solution mentioned here: <a href=""https://github.com/ReactiveX/RxSwift/issues/209#issuecomment-150842686"" rel=""nofollow"">https://github.com/ReactiveX/RxSwift/issues/209#issuecomment-150842686</a></p>

<p>Relevant excerpt:</p>

<pre><code>public protocol OptionalType {
    func hasValue() -&gt; Bool
}

extension Optional: OptionalType {
    public func hasValue() -&gt; Bool {
        return (self != nil)
    }
}

public extension ObservableType where E: OptionalType {
    @warn_unused_result(message=""http://git.io/rxs.uo"")
    public func notNil() -&gt; Observable&lt;E&gt; {
        return self.filter { $0.hasValue() }
    }
}
</code></pre>

<p>However, after <code>.notNil()</code>, <code>E</code> is still optional, so subsequent chained operators still see <code>self</code> as <code>Observer&lt;E&gt;</code> where <code>E</code> is optional.  So I'm still needing an extra operator that does:</p>

<pre><code>.map { (username: String?) -&gt; String in
    return username!
}
</code></pre>

<p>I must be missing something. This seems like it would be a very common need.</p>
","343299","","343299","","2016-07-06 10:47:22","2021-01-13 09:54:08","Ignoring/filtering nil","<swift><rx-swift><reactivex>","3","0","1","","","CC BY-SA 3.0"
"36561397","1","","","2016-04-12 00:06:59","","1","563","<p>I'm trying to implement user-driven refreshing in my Rx based networking code, and my current design is as follows:</p>

<ol>
<li>Create a sink that has <code>Void</code> values passed into it every time the user initiates a refresh action</li>
<li><code>flatMap</code> the latest <code>.Next</code> event on that sink's <code>Observable</code> into a new network call</li>
<li>Transform the network response into a new view model and pass that back into the view controller</li>
</ol>

<p>The part I'm getting hung up on is how to create a sink for those events to go down. My current code is as follows:</p>

<pre><code>func contactListModel() -&gt; Observable&lt;ContactListViewModel&lt;Contact&gt;&gt; {
    // Create a sink for refresh events
    var refreshSink: AnyObserver&lt;Void&gt; = AnyObserver { event in }
    let refreshObservable = Observable&lt;Void&gt;.create { observer in
        refreshSink = observer
        return NopDisposable.instance
    }

    // Define action handlers
    let searchClosure = { (query: String?) in
        self.contactsSearchTerm.value = query
    }
    let refreshClosure = refreshSink.onNext

    // TODO: [RP] Make contact list view controller handle a nil view model to remove the need for this code
    let initialViewModel = ContactListViewModel&lt;Contact&gt;(contacts: [], searchClosure: searchClosure, refreshClosure: refreshClosure)

    // Perform an initial refresh
    defer {
        refreshSink.onNext()
    }

    // Set up subscription to push a new view model each refresh
    return refreshObservable
        .flatMapLatest {
            return self.networking.request(.ListContacts)
        }
        .mapToObject(ListContactsResponse)
        .map { response in
            return ContactListViewModel(contacts: response.contacts, searchClosure: searchClosure, refreshClosure: refreshClosure)
        }
        .startWith(initialViewModel)
}
</code></pre>

<p>Now it's obvious why my code to create an event sink doesn't work here. The block being passed into <code>refreshObservable</code>'s <code>create</code> method is only called once the observer is subscribed to, so the <code>refreshSink</code> won't be reassigned until then. Furthermore, if this observable is subscribed to more than once, the <code>refreshSink</code> variable will be reassigned.</p>

<p>So my question is this: <em>how do I create an <code>Observable</code> that I can manually push events down? Or alternatively, is there a better design I could be using here?</em></p>

<p>I know ReactiveCocoa has the <code>pipe</code> static method on <code>Signal</code> that will do something like what I'm looking for, but I've found no equivalent in the Rx API.</p>
","569582","","","","","2016-04-12 00:06:59","Creating a user-controllable RxSwift Observer","<swift><system.reactive><frp><rx-swift>","0","1","","","","CC BY-SA 3.0"
"36677878","1","","","2016-04-17 14:34:53","","2","1698","<p>I've just started playing around with Rx and decided to try out making a simple OSX app using RxSwift.</p>

<p>Since my app has a login form, I've found that <a href=""https://github.com/ReactiveX/RxSwift/tree/master/RxExample/RxExample/Examples/GitHubSignup/UsingDriver"" rel=""nofollow"">GithubSignup example</a> is pretty similar to what I'm doing.</p>

<p>I'm, however having an issue that my <code>Drivers</code> get disposed after first value is emitted from them, and I can't figure out how or why. Since my code is really similar to one from the Github example, I must be overlooking something.</p>

<p>Here is my ViewModel:</p>

<pre><code>class LoginVM {

    let isWorking: Driver&lt;Bool&gt;
    let loginEnabled: Driver&lt;Bool&gt;

    init(
        input: (
            email: Driver&lt;String&gt;,
            password: Driver&lt;String&gt;,
            loginRequests: Driver&lt;Void&gt;
        ),
        dependency: (
            RoundedClient
        )
    ) {
        self.isWorking = Variable(false).asDriver()

        let credentials = Driver
            .combineLatest(input.email, input.password){ (email: $0, password: $1) }

        let credentialsEmpty = credentials
            .map{ credentials in
                credentials.email.characters.count &gt; 0 &amp;&amp; credentials.password.characters.count &gt; 0
            }
            .distinctUntilChanged()

        self.loginEnabled = Driver
            .combineLatest(credentialsEmpty, self.isWorking){ !($0 || $1) }
            .distinctUntilChanged()
    }

}
</code></pre>

<p>And here is my ViewController:</p>

<pre><code>class LoginViewController: NSViewController {

    var screenManager: ScreenManager!

    @IBOutlet weak var emailField: NSTextField!
    @IBOutlet weak var passwordField: NSSecureTextField!
    @IBOutlet weak var loginButton: NSButton!
    @IBOutlet weak var loginSpinner: NSProgressIndicator!
    @IBOutlet weak var errorLabel: NSTextField!

    let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        let vm = LoginVM(
            input: (
                email: self.emailField.rx_text.asDriver(),
                password: self.passwordField.rx_text.asDriver(),
                loginRequests: self.loginButton.rx_tap.asDriver()
            ),
            dependency: RoundedClient.sharedInstance
        )

        vm.loginEnabled
            .driveNext{ [weak self] enabled in
                self?.loginButton.enabled = enabled
                self?.loginButton.alphaValue = enabled ? 1.0 : 0.5
            }.addDisposableTo(self.disposeBag)

        vm.isWorking
            .drive(self.loginSpinner.ex_animating)
            .addDisposableTo(self.disposeBag)
    }

}
</code></pre>

<p>Here is an example when I attach "".debug()"" to <code>credentialsEmpty</code> driver on <code>LoginVM</code>:</p>

<pre><code>2016-04-17 16:32:36.730: LoginViewController.swift:38 (init(input:dependency:)) -&gt; subscribed
2016-04-17 16:32:36.731: LoginViewController.swift:38 (init(input:dependency:)) -&gt; Event Next(false)
2016-04-17 16:32:39.081: LoginViewController.swift:38 (init(input:dependency:)) -&gt; Event Next(true)
2016-04-17 16:32:39.081: LoginViewController.swift:38 (init(input:dependency:)) -&gt; disposed
</code></pre>

<p>It is getting disposed as soon as value is emitted after initial one.</p>
","2800648","","343299","","2016-07-06 11:14:21","2017-08-04 15:52:24","RxSwift Driver gets disposed after first value","<swift><cocoa><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"36691483","1","","","2016-04-18 10:33:01","","4","1281","<p>I am new to RxSwift and whole concept of RX and I would like to know how to handle global application state fetched from remote server by RxSwift.</p>

<p>Let's assume I need to fetch JSON and parse it to list of objects to show it in table view but also I need to create map in format <code>[{id: object}, ...]</code> to use the data in other sections of application.</p>

<p>For example: App repetitively fetches a person list from server and needs the data for person table view as for persons messages to display avatar and status with related message. So the data are needed for view models <code>PersonViewModel</code> and <code>MessageViewModel</code> composed by models Person and Message.</p>

<p>Would be the correct way to have such structure:</p>

<pre><code>struct Person {
    let id: personId
    let fullName: String
    let status: personStatus
}

class PeopleStore {
    var order: [personId] = []
    var dataMap: [personId: Person] = [:]

    init(people: [Person]) {
        order = people.map { $0.id }
        for person in people {
            dataMap[person.id] = person
        }
    }
}

class AppState {
    let rx_peopleStore: Variable&lt;PeopleStore&gt;

    init(peopleStore: PeopleStore) {
        self.rx_peopleStore = Variable(peopleStore)
    }
}
</code></pre>

<p>And to adjust the app state by fetch from server:</p>

<pre><code>...
_ = PeopleApi
    .rx_peopleStore
    .asDriver(onErrorJustReturn: [])
    .driveNext { peopleStore in
        sharedAppState.rx_peopleStore.value = peopleStore
    }
...
</code></pre>

<p>And in viewModels:</p>

<pre><code>...
_ = sharedAppState
    .rx_peopleStore
    .asDriver()
    .driveNext { store in
        // refreshUI by data from store
    }
    .addDisposableTo(bag)
...
</code></pre>

<p>Is this correct way or exists some different and better approach? I would like to also (in future) the fetched data persist. What is the best practice? Thank you.</p>

<p>P.S. sorry for typos in code, if are there. I just wrote it without compiling.</p>
","2182817","","343299","","2016-07-06 13:23:25","2017-08-22 10:37:02","How to handle application state with RxSwift","<swift><rx-swift><application-state>","1","1","","","","CC BY-SA 3.0"
"36696133","1","36723650","","2016-04-18 13:58:20","","1","156","<p>I want to add an observer on zoom (Float) property of GMSMapView. I wonder if it is possible and how can I do it?</p>
","4092466","","","","","2016-04-19 16:00:27","Can I add observer to ""zoom"" property of GMSMapView()?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"36699772","1","36839785","","2016-04-18 16:46:33","","7","6646","<p>I need to show a progress bar upon an API call and hide it after the API call completes. The following is code I have written to populate a table. Where should I make calls to show and hide progress for the API being called? Is there an <code>RxSwift</code> way of doing this?</p>

<pre><code>items = fetchAllAnswers()
items.bindTo(self.myTableView.rx_itemsWithCellIdentifier(""cellIdentifier"", cellType: UITableViewCell.self)){ (row, element, cell) in
    cell.textLabel?.text = element
}
.addDisposableTo(disposeBag)

func fetchAllAnswers() -&gt; Observable&lt;[String]&gt;{
    let api = Observable.create { (obsever: AnyObserver&lt;[String]&gt;) -&gt; Disposable in
        //progress.show()
        let items = Api.getUsers()

        obsever.onNext(items)
        obsever.onCompleted()
        //progress.hide
        return AnonymousDisposable{
            print(""api dispose called"")
        }
    }
    return api
}
</code></pre>
","1201374","","343299","","2016-07-06 11:46:16","2020-03-19 02:46:49","Rxswift - how to show a progress bar","<ios><swift><rx-swift>","4","0","1","","","CC BY-SA 3.0"
"36709503","1","36788483","","2016-04-19 05:41:16","","6","9131","<p>Currently I have created a function <code>unwrapOptional</code> to safely unwrap the optional input in the stream.</p>

<pre><code>    func unwrapOptional&lt;T&gt;(x: Optional&lt;T&gt;) -&gt; Observable&lt;T&gt; {
       return x.map(Observable.just) ?? Observable.empty()
    }

    let aOpt: String? = ""aOpt""
    _ = Observable.of(aOpt).flatMap(unwrapOptional).subscribeNext { x in print(x)}

    let aNil: String? = nil
    _ = Observable.of(aNil).flatMap(unwrapOptional).subscribeNext { x in print(x)}

    let a: String = ""a""
    _ = Observable.of(a).flatMap(unwrapOptional).subscribeNext { x in print(x)}

   // output 
    aOpt
    a
</code></pre>

<p>What I want to archive is to create a handy function instead of using <code>flatMap(unwrapOptional)</code>, for example</p>

<pre><code>Observable.of(a).unwrapOptional()
</code></pre>

<p>Something I tried to do, but it never compiles...</p>

<pre><code>extension ObservableType {
    func unwrapOptional&lt;O : ObservableConvertibleType&gt;() -&gt; RxSwift.Observable&lt;O.E&gt; {
        return self.flatMap(unwrapOptional)
    }
}
</code></pre>
","3803724","","743923","","2016-10-15 23:56:26","2020-06-18 14:52:59","RxSwift unwrap optional handy function?","<swift><rx-swift>","4","0","1","","","CC BY-SA 3.0"
"36799380","1","","","2016-04-22 16:51:17","","1","1212","<p>I am using RSwift library in my app. I am trying to get the user location in order to send it in a network request. To get this location, I need to use Observables because the function must throw an error in case of user did not authorize location.</p>

<p>This algorithm is a part of a concatenated array of many Observables ran in an another thread than the main thread (in order to not freeze the UI). I need to execute the ""get user location"" function in the main thread because if not executed in the main thread it crash and the crash log is :</p>

<pre><code>fatal error: Executing on backgound thread. Please use `MainScheduler.instance.schedule` to schedule work on main thread
</code></pre>

<p>In the above code, there is the geolocation helper init (this is a singleton) and the method executed to get the user location (or an error).</p>

<pre><code>private var authorized: Observable&lt;Bool?&gt;
private var location: Observable&lt;CLLocationCoordinate2D&gt;
private let locationManager = CLLocationManager()

private init() {
    locationManager.desiredAccuracy = LocationOptions.desiredAccuracy

    authorized = Observable.just(false)
        .map({ _ in CLLocationManager.authorizationStatus() })
        .concat(locationManager.rx_didChangeAuthorizationStatus)
        .distinctUntilChanged()
        .map({ authorizedStatus in
            switch authorizedStatus {
            case .AuthorizedAlways, .AuthorizedWhenInUse:
                return true
            case .NotDetermined:
                return nil
            case .Restricted, .Denied:
                return false
            }
        })
        .catchErrorJustReturn(false)

    location = locationManager.rx_didUpdateLocations
        .filter { $0.count &gt; 0 }
        .map({ return $0.last!.coordinate })
}


func getLocation() -&gt; Observable&lt;Location&gt; {
    return authorized
        .flatMap({ authorized -&gt; Observable&lt;CLLocationCoordinate2D&gt; in
            guard let authorized = authorized else {
                self.locationManager.requestAlwaysAuthorization()
                return Observable.empty()
            }

            if authorized {
                self.startUpdating()
                return self.location
            } else {
                return Observable.error(
                    NSError(
                        domain:"""",
                        code: 0,
                        userInfo:nil )
                )
            }
        })
        // We just need one position updated
        .take(1)
        .map({ coordinate in
            self.stopUpdating()

            let location = Location(longitude: coordinate.longitude, latitude: coordinate.latitude, latestUpdatedDate: NSDate())
            if location.isValid() {
                saveLocation(location)
            }
            return location
        })
        .doOnError({ error in self.stopUpdating() })
}
</code></pre>

<p>I see in the RXSwift geolocation example ( <a href=""https://github.com/ReactiveX/RxSwift/pull/429"" rel=""nofollow"">https://github.com/ReactiveX/RxSwift/pull/429</a> ) a class that can handle it with Drivers but I really need to have an error and Drivers cannot return errors. </p>

<p>I would appreciate if someone can help me on how to achieve this.</p>

<p>I already tried to add "" .observeOn(MainScheduler.instance) "" to the 2 observables but it freezes the UI.. maybe there is a better way to do this without freezing UI.</p>

<p>Thanks</p>
","2911881","","","","","2017-08-21 04:45:46","RxSwift and CLLocation : crash when trying to get user location","<ios><swift><multithreading><cllocationmanager><rx-swift>","2","0","","","","CC BY-SA 3.0"
"36805449","1","","","2016-04-23 01:07:16","","8","971","<p>example:</p>

<pre><code>tapGestureRecognizer.rx.event.asDriver()
    .drive(onNext: { [unowned self] _ in
        self.view.endEditing(true)
    })
    .disposed(by: disposeBag)
</code></pre>

<p>since the <code>disposeBag</code> is controlled by self, I would assume yes?</p>
","782808","","1460929","","2017-10-10 09:33:38","2018-04-26 09:14:00","is it safe to use [unowned self] in RxSwift Drivers?","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"36807392","1","36816077","","2016-04-23 06:17:02","","3","4143","<p>I am trying to sort an observable array and havent had any luck (RxSwift n00b)</p>

<pre><code>let items = [AnyObject]? 
let locations = Observable.just(items)
</code></pre>

<p>I want to achieve something like this on locations</p>

<pre><code>items.sortInPlace({$0.name &lt; $1.name})
</code></pre>

<p>Any pointers will be appreciated!</p>
","4076760","","343299","","2016-07-06 11:22:45","2019-02-16 20:03:46","RxSwift Observable Array Sorting","<swift><sorting><observable><rx-swift>","3","0","","","","CC BY-SA 3.0"
"36823686","1","","","2016-04-24 13:22:20","","3","57","<pre><code>let stream = PublishSubject&lt;Int&gt;()
let trigger = PublishSubject&lt;Void&gt;()

stream.sample(trigger).subscribeNext { value in print(""value \(value)"") }

stream.onNext(5)
trigger.onCompleted()
</code></pre>

<p>The above prints ""value 5"" to the console. I find that surprising since I never called onNext() on the trigger.</p>

<p>In my case the <code>trigger</code> represents a save button <code>rx_tap</code> and the <code>stream</code> represents valid input to be saved. My problem is that the stream is getting saved when the trigger completes (on destruction) even if it wasn't tapped.</p>
","506441","","343299","","2016-07-06 12:09:45","2016-07-06 12:09:45","`sample` triggers when complete. How to avoid?","<swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"36838248","1","36838779","","2016-04-25 10:41:01","","1","720","<p>i created an observable for an api call and bind to a tableview. Now i am unclear <strong><em>how to call the same api once again? so as to do a refresh</em></strong> - say on an button click?. The following is my sample code. </p>

<p>Please let me know your thoughts it will be helpfull</p>

<pre><code> var items : Observable&lt;[String]&gt;? 
   func viewDidLoad(){

            items = fetchAllAnswers()
          items.bindTo(....).addDisposableTo(bag)
    }
   func fetchAllAnswers() -&gt; Observable&lt;[String]&gt;{
   let api = Observable.create { (obsever: AnyObserver&lt;[String]&gt;) -&gt; Disposable in
        let answers = API.allAnswers()
                     obsever.onNext(answers)
                     obsever.onCompleted()
                    return AnonymousDisposable{
                        print(""api dispose called"")
                    }
                }
                return api

            }

    func onClickRefresh()
   {
   // how to call api here again?


   //  let items = fetchAllAnswers() 
    // items.bindTo(....).addDisposableTo(bag)

   }
</code></pre>
","1201374","","1201374","","2016-04-25 10:52:04","2016-04-26 08:57:10","RXSwift - How to recall an api","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"36839826","1","38516497","","2016-04-25 11:54:47","","3","511","<p>Does anyone know how you'd go about wrapping <a href=""https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKPaymentQueue_Class/"" rel=""nofollow"">SKPaymentQueue</a> in an Rx Observable? SKPaymentQueue requires that you register an observer that conforms to the <a href=""https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKPaymentTransactionObserver_Protocol/index.html#//apple_ref/swift/intf/c:objc(pl)SKPaymentTransactionObserver"" rel=""nofollow"">SKPaymentTransactionObserver</a> via the <a href=""https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKPaymentQueue_Class/#//apple_ref/occ/instm/SKPaymentQueue/addTransactionObserver:"" rel=""nofollow"">SKPaymentQueue.addTransactionObserver</a> method. </p>

<p>So far I've tried the following but it doesn't work. I suspect because the observer proxy is getting deallocated before it's called. It feels like I'm missing some kind of idiomatic Rx trick here:</p>

<pre><code>class StoreService {
    let paymentQueue = SKPaymentQueue.defaultQueue()

    func purchase(product: SKProduct) -&gt; Observable&lt;SKProduct&gt; {
        return Observable.create { (observer) in
            let transactionObserver = PaymentTransactionProxyObserver(observer)

            self.paymentQueue.addTransactionObserver(transactionObserver)

            let payment = SKPayment(product: product)
            self.paymentQueue.addPayment(payment)

            return AnonymousDisposable {
                self.paymentQueue.removeTransactionObserver(transactionObserver)
            }
        }
    }
}

class PaymentTransactionProxyObserver: NSObject, SKPaymentTransactionObserver {

    let observer: AnyObserver&lt;SKPaymentTransaction&gt;

    init(_ observer: AnyObserver&lt;SKPaymentTransaction&gt;) {
        self.observer = observer
    }

    func paymentQueue(queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) {
        for transaction in transactions {
            observer.onNext(transaction)
        }
        observer.onCompleted()
    }
}
</code></pre>

<p>I've also hunted around in the RxCocoa source looking for inspiration however the closest example, the <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxCocoa/Common/Observables/NSNotificationCenter%2BRx.swift"" rel=""nofollow"">NSNotificationCenter</a> extension, uses a closure as opposed to an observer with multiple callback methods an a register and unregister step. It also doesn't seem to fit the DelegateProxy pattern used by other extensions.</p>
","219379","","","","","2016-07-22 00:55:05","How to wrap SKPaymentQueue in Rx Observable","<ios><swift><storekit><rx-swift>","1","0","","","","CC BY-SA 3.0"
"36845892","1","36878460","","2016-04-25 16:18:03","","6","2828","<p>I feel like I'm beginning to get the hang of RxSwift - however I've just hit a roadblock. 
Here's an object I've built for a demo (I've simplified it before posting to SO). My issue is, when there's a network error during the upload process, all of the subscriptions get disposed of. So when I tap the <code>rightBarButtonItem</code> again, nothing happens.</p>

<p>What's the correct/better way of modelling this? I'm not sure I've grasped the use of <code>PublishSubject</code>s correctly!</p>

<pre><code>let activityIndicator = ActivityIndicator()
let disposeBag = DisposeBag()

let rx_upload = PublishSubject&lt;Void&gt;()
let rx_progress = PublishSubject&lt;RxProgress&gt;()
let rx_uploadComplete = PublishSubject&lt;Look&gt;()

override init() {
    super.init()

    activityIndicator
        .drive(UIApplication.sharedApplication().rx_networkActivityIndicatorVisible)
        .addDisposableTo(disposeBag)

    let upload = rx_upload
        .debug(""Upload"")
        .flatMapLatest { [unowned self] -&gt; Observable&lt;(JSON?, RxProgress)&gt; in
            return self.upload()
        }
        .share()

    upload
        .map { $0.1 }
        .debug(""Upload Progress"")
        .bindTo(rx_progress)
        .addDisposableTo(disposeBag)

    upload
        .filter { $0.0 != nil }
        .map { Post(jsonData: $0.0!) }
        .filterNil()
        .debug(""Upload Complete"")
        .bindTo(rx_uploadComplete)
        .addDisposableTo(disposeBag)

}

func upload() -&gt; Observable&lt;(JSON?, RxProgress)&gt; {
    // ...
}
</code></pre>

<p>And in <code>ViewController.swift</code>...</p>

<pre><code>self.navigationItem.rightBarButtonItem?.rx_tap
.bindTo(postUploader.rx_upload)
.addDisposableTo(disposeBag)
</code></pre>
","2198905","","","","","2016-04-27 00:59:16","Re-subscribing to an Observable after error","<ios><swift><rx-swift><reactivex>","1","0","2","","","CC BY-SA 3.0"
"36895225","1","36898550","","2016-04-27 16:07:36","","11","2149","<p>Implementations of rx provide <code>BehaviorSubject&lt;T&gt;</code> and <code>Variable&lt;T&gt;</code> as mechanisms for modeling properties that change over time (a useful replacement for C# INotifyPropertyChanged).</p>

<p>Generally these are exposed as <code>Observable&lt;T&gt;</code> but it would be more useful to expose properties as something like:</p>

<pre><code>class ObservableValue&lt;T&gt; : Observable&lt;T&gt;{
  var currentValue:T { get }
}
</code></pre>

<p>This can be created along these lines in swift:</p>

<pre><code>class ObservableValue&lt;Element&gt; : ObservableType {

  typealias E = Element

  private let subject:BehaviorSubject&lt;E&gt;

  var currentValue:E {
      get {
          return try! subject.value()
      }
  }

  init(subject:BehaviorSubject&lt;E&gt;) {
      self.subject = subject
  }

  func subscribe&lt;O: ObserverType where O.E == E&gt;(observer: O) -&gt; Disposable {
      return self.subject.subscribe(observer)
  }
</code></pre>

<p>}</p>

<p>Does this already exist? and if not is it because it's against the aims of Rx?</p>

<p>The only way around it is to expose a separate currentValue or write consumers that assume the concrete implementation behind the exposed Observable is a BehaviourSubject or somewhere in the chain a replay() has occured e.g. the following snippet doesn't make it explicit that as soon as I subscribe I will get a value:</p>

<pre><code>class MyViewModel {
  // 'I will notify you of changes perhaps including my current value'
  myProperty:Observable&lt;String&gt; 
}
</code></pre>

<p>so code has to be written as if its 'asynchronous' with an underlying assumption it will act in an almost synchronous manner rather than:</p>

<pre><code>class MyViewModel {
  // 'I have a current value and will notify you of changes going forward'
  myProperty:ObservableValue&lt;String&gt; 
}
</code></pre>
","69548","","69548","","2016-04-27 16:30:20","2016-04-28 19:04:59","Does a read only BehaviorSubject interface exist in RX and if not, is it a bad idea to make one?","<swift><system.reactive><rx-swift>","2","0","3","","","CC BY-SA 3.0"
"36905120","1","54580229","","2016-04-28 04:14:14","","10","1793","<p>So I have some RxSwift code where I want to perform a chain of asynchronous operations, all composed using observables. <code>flatMap</code> is the way to do this, and it works great, however it doesn't seem to be able to pass variables down the chain that I can figure out. This is best illustrated by some pseudocode</p>

<p>Assume have 3 functions</p>

<pre><code>class Connection {
    static func establish(address:String) -&gt; Observable&lt;Connection&gt;
    func sendData(data:String) -&gt; Observable&lt;Int&gt; // num bytes written or something
    func close() -&gt; Observable&lt;Void&gt;
}
</code></pre>

<p>And I want to call them in a chain such that we connect, send, then close. Something like this</p>

<pre><code>Connection.establish(host)
    .flatMap{ connection in connection.sendData(""foo"") }
    .flatMap{ numBytes in ????.close() }
    .subscribeNext{ /* all done */ }
</code></pre>

<p>The problem is that <code>flatMap</code> doesn't pass it's input parameters down the chain, so that the closure passed to <code>subscribeNext</code> doesn't have access to the <code>connection</code> object, and as such it can't call close.</p>

<p>I could do some awful hack like the following, but I'd really rather not!</p>

<pre><code>var connection:Connection?
Connection.establish(host)
    .flatMap{ c in 
        connection = c
        return c.sendData(""foo"") 
    }
    .flatMap{ numBytes in connection!.close() }
    .subscribeNext{ /* all done */ }
</code></pre>

<p>In the C# version of Rx, this is solved by using an overload to <code>SelectMany</code> which takes a second closure, which combines the 2 values (usually into a Tuple) and then <em>that</em> thing is propagated down the chain. I've written this as an extension for RxSwfit, and it works as follows:</p>

<pre><code>Connection.establish(host)
    .flatMap(
        { connection in connection.sendData(""foo"") },
        combine: { ($0, $1) }) // tupleify
    .flatMap{ (connection, numbytes) in connection.close() }
    .subscribeNext{ /* all done */ }
</code></pre>

<p>This is all well and good, but my primary question is - Is there a better way to do this which is built into RxSwift as it currently stands?</p>

<p>Additionally, writing this extension method is not simple nor easy. I basically re-implemented FlatMap from scratch by copy/pasting the one in <a href=""https://github.com/borland/StockFighterApiClient/blob/master/MiniRxSwift.swift#L322"" rel=""noreferrer"">MiniRxSwift</a> and modifying it. If we have to write this extension, is there a better way to implement it using RxSwift constructs?</p>
","234","","","","","2019-02-07 19:06:14","RxSwift propagating a value through a chain of flatMaps","<swift><rx-swift>","2","0","3","","","CC BY-SA 3.0"
"36925857","1","37171997","","2016-04-28 21:33:22","","10","5843","<p>I am currently using Moya to make my network requests. I have implemented the following from one of the example projects @ <a href=""https://github.com/DroidsOnRoids/RxSwiftExamples#tutorials"" rel=""noreferrer"">https://github.com/DroidsOnRoids/RxSwiftExamples#tutorials</a></p>

<p>Below I have set up restaurantSearch so that when someone enters text it makes a new request.</p>

<pre><code>var restaurantSearch: Observable&lt;(String)&gt; {
    return searchBar
        .rx_text
        .throttle(0.5, scheduler: MainScheduler.instance)
        .distinctUntilChanged()
}
</code></pre>

<p>I have a method that returns an observable of type [Restaurant]</p>

<pre><code>func restaurants() -&gt; Observable&lt;[Restaurant]&gt; {
    return restaurantSearch
        .observeOn(MainScheduler.instance)
        .flatMapLatest { postcode -&gt; Observable&lt;[Restaurant]?&gt; in
            return self.getRestaurants(postcode, cuisine: """", restaurantName: """")
        }.replaceNilWith([])
}

internal func getRestaurants(postcode: String, cuisine: String, restaurantName: String) -&gt; Observable&lt;[Restaurant]?&gt; {
    return self.justEatProvider
        .request(.Restaurant(postcode, cuisine, restaurantName))
        .debug()
        .mapArrayOptional(Restaurant.self, keyPath: ""Restaurants"")
}
</code></pre>

<p>I am calling this method and binding it to a tableView like so:</p>

<pre><code>func setupRx() {

    api = JustEatApi(provider: provider, restaurantSearch: restaurantSearch)

    api
        .restaurants()
        .bindTo(tableView.rx_itemsWithCellIdentifier(""RestaurantTableViewCell"", cellType: RestaurantTableViewCell.self)) { (row, element, cell) in
            cell.restaurant = element
        }
        .addDisposableTo(disposeBag)
}
</code></pre>

<p>This is working fine. If I enter a postcode it does the search and the tableView is populated. </p>

<p>If I turn off the internet and try and change the postcode the tableView remains as is. However when I scroll it crashes my app with the following:</p>

<pre><code>@noreturn func rxFatalError(lastMessage: String) {
    // The temptation to comment this line is great, but please don't, it's for your own good. The choice is yours.
    fatalError(lastMessage)
}
</code></pre>

<p>Also if I don't scroll but instead just turn back on the internet and change the postcode nothing happens. It seems like it has lost it's binding.</p>

<p>Firstly I tried adding catchOnError before the <code>bindTo</code> method call but I read here in comment that it shouldn't be handled as part of UIBinding: <a href=""http://blog.scottlogic.com/2014/05/11/reactivecocoa-tableview-binding.html"" rel=""noreferrer"">http://blog.scottlogic.com/2014/05/11/reactivecocoa-tableview-binding.html</a></p>

<p>I am guessing I should handle it in the method:</p>

<pre><code>func restaurants() -&gt; Observable&lt;[Restaurant]&gt; {
    return restaurantSearch
        .observeOn(MainScheduler.instance)
        .flatMapLatest { postcode -&gt; Observable&lt;[Restaurant]?&gt; in
            return self.getRestaurants(postcode, cuisine: """", restaurantName: """")
        }.replaceNilWith([])
}
</code></pre>

<p>So I have 2 questions:</p>

<p>1) Where and how should I handle a network error?</p>

<p>2) Why does the tableView not update after I turn back on the internet?</p>

<p>Any help much appreciated.</p>
","2126233","","491239","","2016-04-28 23:20:57","2019-01-22 03:32:52","Handling Network error in combination with binding to tableView (Moya, RxSwift, RxCocoa)","<swift><uitableview><rx-swift><moya>","2","0","4","","","CC BY-SA 3.0"
"36927823","1","","","2016-04-29 00:54:30","","3","2381","<p>I have a simple RxSwift Observable sequence that I am trying to unit test.</p>

<pre><code>    var pass = false
    _ = service!.authenticate().subscribeNext { res in
        XCTAssert(res.tokenValue == ""abc123"")
        pass = true
    }
    XCTAssertTrue(pass)
</code></pre>

<p>This test will fail intermittently as if the subscribeNext block is not always hit. Any ideas on what I'm doing wrong?</p>

<p><strong>Edit 1</strong></p>

<p>This authenticate call is simply returning static JSON data and is not actually hitting the network.</p>
","1154950","","1154950","","2016-04-29 03:30:03","2016-04-29 03:30:03","RxSwift Unit Testing","<ios><swift><unit-testing><rx-swift>","1","0","","","","CC BY-SA 3.0"
"36968830","1","36971936","","2016-05-01 16:10:54","","4","3951","<p>I have a <code>UIViewController</code> with 3 <code>UITextField</code>s. Every time either of the fields gets focus, I want to set a new text value for a tip label above. What is the best way to achieve this with <code>RxSwift</code>? </p>
","1100641","","343299","","2016-07-06 11:21:46","2016-07-06 11:21:46","RxSwift: upgrade model state when textfield gets focus","<swift><rx-swift>","1","1","","","","CC BY-SA 3.0"
"36978312","1","","","2016-05-02 08:39:53","","4","457","<p>When jumping to a definition with <code>ctrl-cmd-j</code> in Xcode, I often get sent to a generated interface for the method instead of the actual implementation.  How can I jump to the actual implementation instead?  I end up having to manually find the file/implementation manually, which is very cumbersome.</p>

<p>For example, while browsing <a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow"">RxSwift</a>, if I <code>ctrl-cmd-j</code> while over a <code>subscribeNext</code> call, I get sent to a generated interface file which just has the method signature: <code>public func subscribeNext(onNext: (Self.E) -&gt; Void) -&gt; Disposable</code>.  However, I know the real implementation lives at <code>RxSwift/Observable+Extensions.swift</code> and I end up having to manually navigate to that file.</p>

<p>How can I get off this crazy train?</p>
","343299","","343299","","2016-07-23 10:04:00","2016-07-23 10:04:00","Jumping to the implementation instead of the generated interface in Xcode with Swift","<ios><swift><xcode><frameworks><rx-swift>","0","2","3","","","CC BY-SA 3.0"
"36990570","1","","","2016-05-02 19:52:31","","20","3437","<p>I'm a very beginner with RxSwift and I'm trying to begin with a simple login screen. So I have 2 text fields and a login button, which is bind to a <code>PublishSubject</code> so every time I tap the button, I'll send a network request to perform authentication.</p>

<p>Since authentication may fails, I went with a <code>Driver</code> so I could replay my request each time I click the button.</p>

<p>I have 2 version of what I think is the same code but one works and one doesn't.
I'm trying to understand what happens behind the scene.</p>

<p>Here the first version which works (request every time I touch the button) :</p>

<pre><code>let credentials = Driver.combineLatest(email.asDriver(), password.asDriver()) { ($0, $1) }
self.signIn = signInTaps
    .asDriver(onErrorJustReturn: ())
    .withLatestFrom(credentials)
    .flatMapLatest { email, password in // returns Driver&lt;Result&lt;AuthenticateResponse, APIError&gt;&gt;
        return provider.request(.Authenticate(email: email, password: password))
            .filterSuccessfulStatusCodes()
            .mapObject(AuthenticateResponse)
            .map { element -&gt; Result&lt;AuthenticateResponse, APIError&gt; in
                return .Success(element)
            }
            .asDriver { error in
                let e = APIError.fromError(error)
                return Driver&lt;Result&lt;AuthenticateResponse, APIError&gt;&gt;.just(.Failure(e))
            }
            .debug()
    }
</code></pre>

<p>And here's the one which doesn't work (request fires only on first click) :</p>

<pre><code>let credentials = Observable.combineLatest(email.asObservable(), password.asObservable()) { ($0, $1) }
self.signIn = signInTaps.asObservable()
    .withLatestFrom(c)
    .flatMapLatest { email, password in // returns Observable&lt;AuthenticateResponse&gt;
        return provider.request(.Authenticate(email: email, password: password))
            .filterSuccessfulStatusCodes()
            .mapObject(AuthenticateResponse)
    }
    .map { element -&gt; Result&lt;AuthenticateResponse, APIError&gt; in // returns Observable&lt;Result&lt;AuthenticateResponse, APIError&gt;&gt;
        return .Success(element)
    }
    .asDriver { error in // returns Driver&lt;Result&lt;AuthenticateResponse, APIError&gt;&gt;
        let e = APIError.fromError(error)
        return Driver&lt;Result&lt;AuthenticateResponse, APIError&gt;&gt;.just(.Failure(e))
    }
    .debug()
</code></pre>

<p>For information, here's my properties declaration :</p>

<pre><code>let email = Variable("""")
let password = Variable("""")
let signInTaps = PublishSubject&lt;Void&gt;()    
let signIn: Driver&lt;Result&lt;AuthenticateResponse, APIError&gt;&gt;
</code></pre>
","1224751","","3975480","","2016-05-02 20:31:52","2016-05-05 02:10:05","RxSwift - Misundestanding some concept","<ios><swift><rx-swift>","1","1","2","","","CC BY-SA 3.0"
"36994434","1","36999129","","2016-05-03 02:04:39","","2","1719","<p>How do I implement an event emitter using RxSwift? (An object that can emit data that is consumed by other objects that are subscribed to it.)</p>

<p>After going through the Rx docs and examples, I feel like a complete idiot and am still extremely confused on how to manually emit events from Observers to Observables. My understanding that we have some Observable that can emit events with data to all Observers that are subscribed to that Observable. However, I have zero idea on how this is actually implemented in Swift.</p>

<p>Here's an example of something I'm trying to implement:</p>

<pre><code>class VendingMachine {

    let dispenser = Observable&lt;Drink&gt;

    // Notify all subscribed Observers that this machine dispensed a drink.
    func dispenseDrink(item: Drink) {
        dispenser.onNext(item)
    }

}
</code></pre>

<p>And a second file:</p>

<pre><code>class MachineReporter: Observer {

    let dispenser = VendingMachine().dispenser

    init() {
        dispenser.subscribe(self)
    }

    onNext { drink in
        print(""Vending machine dispensed a drink: \(drink)""
    }

}
</code></pre>

<p>My brain is fried. I'm just going to switch to a specialized library like EmitterKit for now because I'm clearly misunderstanding how this works.</p>

<p>But I need to figure out how Rx works or I will go crazy. Help!</p>
","2901933","","","","","2017-04-20 14:42:36","How do I emit events manually (i.e., make an EventEmitter) using RxSwift?","<swift><rx-swift><reactivex>","2","0","","","","CC BY-SA 3.0"
"37080718","1","37110686","","2016-05-06 20:15:03","","1","303","<p>I've been working on a search controller that is using RxSwift to update DataSource when user types in Search field, like it's described here: <a href=""http://www.thedroidsonroids.com/blog/ios/rxswift-examples-3-networking/"" rel=""nofollow"">http://www.thedroidsonroids.com/blog/ios/rxswift-examples-3-networking/</a></p>

<p>That is my viewmodel:</p>

<pre><code>struct SearchControllerViewModel {

    let provider: RxMoyaProvider&lt;ThreadifyEndpoint&gt;
    let startsWith: Observable&lt;String&gt;

    func startSearching() -&gt; Observable&lt;[SearchedNodeViewModel]&gt; {
        return startsWith
            .observeOn(MainScheduler.instance)
            .flatMapLatest { query -&gt; Observable&lt;[SearchedNodeViewModel]?&gt; in
                return self.findNodes(query)
        }.replaceNilWith([])


    }

    internal func findNodes(startsWith: String) -&gt; Observable&lt;[SearchedNodeViewModel]?&gt; {
        return self.provider
            .request(ThreadifyEndpoint.SearchForNodes(startsWith: startsWith))
            .mapArrayOptional(SearchedNodeViewModel.self)
    }
}
</code></pre>

<p>Now I want new data to be loaded not only when user is typing but either when sh's scrolling down. 
I was thinking to use combineLatest to observe both rx_text and rx_offset but I can't pass Observable to combineLatest because of compilation error. </p>
","1100641","","343299","","2016-07-06 11:49:29","2016-07-06 11:49:29","RxSwift: Observe rx_text & rx_offset simultaneously","<swift><rx-swift>","1","3","","","","CC BY-SA 3.0"
"37102693","1","37110512","","2016-05-08 17:25:16","","8","10748","<p>I have an array (<code>Observable&lt;[_]&gt;</code>) that is a datasource for a tableview. I want to be able to append new elements to it and update the tableview every time new elements are appended to the array. I can't find how to add new elements to <code>Observable&lt;[_]&gt;</code>.</p>
","1100641","","343299","","2016-07-06 10:44:26","2016-07-06 10:44:26","RxSwift: Append elements to Observable<[_]>","<swift><rx-swift>","1","0","3","","","CC BY-SA 3.0"
"37249413","1","37250143","","2016-05-16 08:12:39","","3","1298","<p>I'm new in RxSwift. Some strange thing happens in my code.
I have a collection view and</p>

<blockquote>
  <p>Driver[""String""]</p>
</blockquote>

<p>Data for binding.</p>

<pre><code>var items = fetchImages(""flower"")   
 items.asObservable().bindTo(self.collView.rx_itemsWithCellIdentifier(""cell"", cellType: ImageViewCell.self)) { (row, element, cell) in
           cell.imageView.setURL(NSURL(string: element), placeholderImage: UIImage(named: """"))           
}.addDisposableTo(self.disposeBag)
</code></pre>

<blockquote>
  <p>fetchImages</p>
</blockquote>

<p>Function returns data</p>

<pre><code>private func fetchImages(string:String) -&gt; Driver&lt;[String]&gt; {

        let searchData = Observable.just(string)
        return searchData.observeOn(ConcurrentDispatchQueueScheduler(globalConcurrentQueueQOS: .Background))
            .flatMap
            { text in // .Background thread, network request

                return RxAlamofire
                    .requestJSON(.GET, ""https://pixabay.com/api/?key=2557096-723b632d4f027a1a50018f846&amp;q=\(text)&amp;image_type=photo"")
                    .debug()
                    .catchError { error in
                        print(""aaaa"")
                        return Observable.never()
                }
            }
            .map { (response, json) -&gt; [String] in // again back to .Background, map objects
                var arr = [String]()
                for  i in 0 ..&lt; json[""hits""]!!.count {
                     arr.append(json[""hits""]!![i][""previewURL""]!! as! String)
                }

                return arr
            }
            .observeOn(MainScheduler.instance) // switch to MainScheduler, UI updates
            .doOnError({ (type) in
                print(type)
            })
            .asDriver(onErrorJustReturn: []) // This also makes sure that we are on MainScheduler
    }
</code></pre>

<p>Strange thing is this. First time when I fetch with ""flower"" it works and return data, but when I add this code</p>

<pre><code>self.searchBar.rx_text.subscribeNext { text in
      items = self.fetchImages(text)
}.addDisposableTo(self.disposeBag)
</code></pre>

<p>It doesn't work. It doesn't steps in flatmap callback, and because of this, doesn't return anything.</p>
","5238927","","105466","","2016-07-06 09:56:45","2016-07-06 09:56:45","RxSwift: code working only first time","<ios><swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"37416121","1","37423769","","2016-05-24 14:10:33","","1","276","<p>New to RxSwift / Reactivex. Basically what I'm trying to do is to make a server call whenever something happens, but make sure it's not done more often than every 10 seconds. Less often if possible.</p>

<p>For instance, whenever an event (""needs update"") is generated I'd like to call the server immediately if more than 10 seconds have passed since my last call. If less time has passed I'd like to make the call on the 10 second mark from the last one. It doesn't matter how many events have been generated within these 10 seconds.</p>

<p>I looked at the description of <code>throttle</code> but it appears to starve if events happen very quickly, which isn't desirable.</p>

<p>How can I achieve this?</p>
","220820","","","","","2016-05-24 20:58:44","RxSwift: Receive events immediately, unless the last event was processed within a certain interval","<ios><swift><rx-swift><reactivex>","1","5","","","","CC BY-SA 3.0"
"37421537","1","37423694","","2016-05-24 18:45:03","","0","1233","<p>I'm new to RxSwift and I came across the next situation:</p>

<pre><code>self.viewModel!.country
        .flatMapLatest { country -&gt; Observable&lt;City&gt; in
            country!.cities!.toObservable()
        }
        .map { city -&gt; SectionModel&lt;String, String&gt; in
            SectionModel(model: city.name!, items: city.locations!)
        }
        .toArray()
        .bindTo(self.tableView.rx_itemsWithDataSource(dataSource))
        .addDisposableTo(self.disposeBag)
</code></pre>

<p>Seems to me like toArray() does nothing and I don't know why. On the other hand this code does what I want. I would like to know why the previous code does not work the same way:</p>

<pre><code>self.viewModel!.country
        .flatMapLatest { country -&gt; Observable&lt;[SectionModel&lt;String, String&gt;]&gt; in
            var models = [SectionModel&lt;String, String&gt;]()
            for city in country!.cities! {
                models.append(SectionModel(model: city.name!, items: city.locations!))
            }
            return Observable.just(models)
        }
        .bindTo(self.tableView.rx_itemsWithDataSource(dataSource))
        .addDisposableTo(self.disposeBag)
</code></pre>

<p>Thanks in advance.</p>

<p>EDIT:</p>

<p>View model implementation is as follow:</p>

<pre><code>class LocationViewModel {

    let country = BehaviorSubject&lt;Country?&gt;(value: nil)

}
</code></pre>

<p>Country has a property 'cities' which is an array of City.</p>

<p>@solidcell You must be right, if I put debug() before and after toArray() I get 2 subscriptions, one for each debug(), and 1 next event for each array item only for the before toArray() debug().</p>

<p>But then, why isn't it completing?</p>
","2367942","","2367942","","2016-05-25 00:53:16","2016-05-25 00:53:16","How to convert Observable array of a type to Observable array of a different type with RxSwift","<ios><swift><rx-swift><reactivex>","1","1","","","","CC BY-SA 3.0"
"37446620","1","37447140","","2016-05-25 20:04:15","","3","6838","<p>In my OS X status bar app I'm using <code>interval</code> function to periodically call an external api and display the result:</p>

<pre><code>Observable&lt;Int&gt;
    .interval(120.0, scheduler: MainScheduler.instance)
    .startWith(-1) // to start immediately
    .flatMapLatest(makeRequest) // makeRequest is (dummy: Int) -&gt; Observable&lt;SummaryResponse?&gt;
    .subscribeNext(setSummary)
    .addDisposableTo(disposeBag)
</code></pre>

<p>However, if user changes the preferences in the meantime, I would like to ""restart"" this interval and make a new call immediately to reflect the changes (without having to wait for the next call). </p>

<p>What's the best way to do this?</p>

<ol>
<li>Store the observable as a property and set it to <code>nil</code> or call <code>.dispose()</code> on it (or both) and create a new observable ?</li>
<li>Set <code>disposeBag</code> to <code>nil</code> and create a new observable ?</li>
<li>Any other way?</li>
</ol>
","603268","","","","","2016-05-25 20:35:18","Correct way to restart observable interval in RxSwift","<swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"37454481","1","","","2016-05-26 07:39:44","","2","305","<p>I stub my providers with a stub closure in my test target, but I want to determine if a given provider is stubbed or not. </p>

<pre><code>let myProvider = RxMoyaProvider&lt;MyAPI&gt;(stubClosure: MoyaProvider.ImmediatelyStub)
</code></pre>

<p>but I can't get the stubClosure to tell me what StubBehaviour it's gonna return. Is there anyway to get the stubClosure for a given provider to tell me its return type?</p>

<p>Something like this.</p>

<pre><code>switch(myProvider.stubClosure.??) {
    case StubBehavior.Immediate:
        // I'm a stubbed provider
    case StubBehaviour.Never:
        // I'm not a stubbed provider
}
</code></pre>
","250553","","343299","","2016-07-06 12:40:38","2016-07-06 12:40:38","Determine if Moya provider is stubbed or not","<swift><rx-swift><moya>","0","0","","","","CC BY-SA 3.0"
"37455901","1","37459461","","2016-05-26 08:48:10","","18","14769","<p>I learn the sample code in RxSwift. In the file GithubSignupViewModel1.swift, the definition of validatedUsername is:</p>

<pre><code>validatedUsername = input.username //the username is a textfiled.rx_text
    .flatMapLatest { username -&gt; Observable&lt;ValidationResult&gt; in
        print(""--------&gt;1:"")
        return validationService.validateUsername(username)
            .observeOn(MainScheduler.instance)
            .catchErrorJustReturn(.Failed(message: ""Error contacting server""))
    }
    .shareReplay(1)
</code></pre>

<p>the validateUsername method is finally called the following method:</p>

<pre><code>func usernameAvailable(username: String) -&gt; Observable&lt;Bool&gt; {
    // this is ofc just mock, but good enough
    print(""--------&gt;2:"")
    let URL = NSURL(string: ""https://github.com/\(username.URLEscaped)"")!
    let request = NSURLRequest(URL: URL)
    return self.URLSession.rx_response(request)
        .map { (maybeData, response) in
            print(""--------&gt;3:"")
            return response.statusCode == 404
        }
        .catchErrorJustReturn(false)
}
</code></pre>

<p>Here is my confusion: </p>

<p>whenever I input a character quickly in the username textfield, message -------->1:, -------->2: showed, and a little later message -------->3: showed, but only showed one -------->3: message. </p>

<p>When I input characters slower, message -------->1:, -------->2:, -------->3: showed successively. </p>

<p>But when I change the flatMapLatest to flatMap, how many characters I input, I will get the same number of -------->3: message. </p>

<p>So how did the flatMapLatest work here?</p>

<p>How the flatMapLatest filter the early response from NSURLResponse ?</p>

<hr>

<p>I read some about the flatMapLatest, but none of them will explain my confusion.</p>

<p>What I saw is something like:</p>

<pre><code>let a = Variable(XX)
a.asObservable().flatMapLatest(...)
</code></pre>

<p>When changed <code>a.value</code> to another Variable, the Variable(XX) will not influence the subscriber of a. </p>

<p>But the <code>input.username</code> isn't changed, it is always a <code>testfield.rx_text</code>! So how the flatMapLatest work?</p>
","4738084","","4738084","","2016-05-26 09:48:20","2018-04-14 16:40:02","Confusion about flatMapLatest in RxSwift","<swift><functional-programming><reactive-cocoa><rx-swift>","4","0","6","","","CC BY-SA 3.0"
"37475122","1","37476573","","2016-05-27 04:55:13","","4","3980","<p>I want to start a login task by a login button tapped, after this finished, fetch user order list, shipping address, wish list, other info.
startTask is a button, user tap it, i will start these tasks, but now if the login task failure, user tap startTask button again, i can't start these tasks again, why?<br>
Sample code </p>

<pre><code>private func test() {

    let data = [""fetch order list"", ""fetch shipping addresses"", ""fetch wishlist"", ""fetch other info""]

    let fetchInfoTasks = data.map{ asyncTask($0) }.toObservable()
    let someTasks = fetchInfoTasks.merge().toArray()
    let result = login().flatMapLatest{ _ in someTasks }

    startTask
        .rx_tap
        .flatMapLatest{ result }
        .catchError{ error in
            .....error......
            return Observable.empty()
        }
        .subscribeNext{ tasks in
            .....all completed....
        }
        .addDisposableTo(disposeBag)
}

private func login()-&gt; Observable&lt;String&gt; {
    return Observable.create{ observer in
        performClosure(afterDealy: 1, onMainQueue: false) {
            if arc4random() % 4 == 0 {
                observer.onNext(""login finished"")
                observer.onCompleted()
            } else {
                observer.onError(NSError(domain: """", code: -1, userInfo: [NSLocalizedDescriptionKey: ""some error""]))
            }
        }
        return AnonymousDisposable{}
    }
}

private func asyncTask(name: String)-&gt; Observable&lt;String&gt; {
    return Observable.create{ observer in
        let delay = Double(arc4random() % 6 + 1)
        performClosure(afterDealy: delay, onMainQueue: false) {
            observer.onNext(name)
            observer.onCompleted()
        }
        return AnonymousDisposable{}
    }
}

func performClosure(afterDealy delay: Double, onMainQueue mainQueueOrNot: Bool, action: dispatch_block_t) {
    let delayIntervals = Double(NSEC_PER_SEC) * delay
    let time = dispatch_time(DISPATCH_TIME_NOW, Int64(delayIntervals))
    let queue = mainQueueOrNot ? dispatch_get_main_queue() : dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
    dispatch_after(time, queue, action)
}
</code></pre>
","5771769","","5771769","","2016-05-27 05:29:12","2016-05-27 11:13:41","RxSwift async task","<swift><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"37481328","1","37483087","","2016-05-27 10:39:57","","5","4306","<p>I have a <code>UISwitch</code> that needs to be selected in order to continue onto the next form screen. So I would like to bind the <code>UISwitch</code> selected to the <code>UIButton</code> enabled. I just can't get this sample going.</p>

<p>Here's what I'm trying but doesn't compile:</p>

<pre><code>let termsValidation = termsSwitch
    .rx_selected
    .shareReplay(1)

termsValidation
    .bindTo(signupButton.rx_enabled)
    .addDisposableTo(disposeBag)
</code></pre>

<p>What's the correct way to get this to work in RxSwift and RxCocoa?</p>
","235334","","343299","","2016-07-06 11:22:42","2017-08-14 09:42:43","How to bind UISwitch to UIButton enable in RxSwift?","<ios><swift><rx-swift><rx-cocoa>","2","0","","","","CC BY-SA 3.0"
"37491547","1","37494625","","2016-05-27 20:11:16","","0","1025","<h3>Problem:</h3>

<p>I am currently facing a problem with developing an iOS Mobile Application in <code>Swift</code> that utilizes:</p>

<ul>
<li><code>BTLE</code>: Connecting to a peripheral device and sending/receiving data to/from it.</li>
<li><code>Networking</code>: If the peripheral is connected to a network (wireless and/or ethernet), then the communication over <code>BTLE</code> ""could"" instead happen over the network.</li>
<li><code>Model-View-ViewModel</code> architecture</li>
<li><a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow"">RxSwift</a></li>
</ul>

<h3>About the App:</h3>

<p>It starts with a <strong>Bluetooth Setup</strong> view, which walks the user through the process of pairing with the peripheral device (disjoint from the <code>TabBarController</code>).</p>

<p>After successfully pairing with the device, all configuration is requested by the iOS App from the device, which is sent as <code>JSON</code>.</p>

<p>This <code>JSON</code> contains the different <code>Model</code> information (programming) that the App displays to the user for manipulation and needs to be stored in a array somehow in a <code>Singleton</code> manor to where a <code>view-model</code> can request any index for displaying to the user.</p>

<p>After all the data is received, the <strong>Bluetooth View</strong> dismisses and the <strong>TabBarView</strong>'s are presented. </p>

<h3>Current Examples:</h3>

<p>A good example to relate this App to would be the <code>Apple Watch</code> and the correlating iOS App that allows you to configure everything. I am having to do somewhat the same concept.</p>

<p>Another good example app from this <a href=""http://twocentstudios.com/2015/12/08/an-experimental-ios-architecture-based-on-radical-decoupling/"" rel=""nofollow"">blog post</a> where they are doing something similar to what I am trying to achieve. The difference I am running into though, is their dependency injection setup for MVVM (as well as other similar examples). I've used a storyboard, where as they have programmatically instantiated their view controllers in the <code>AppDelegate</code>.</p>

<h3>And my problem...</h3>

<p>How can I pass the data (efficiently) from <strong>BluetoothView</strong> to <strong>TabBarView</strong> without <code>NSNotifications</code> or <code>PrepareForSegues</code>? Keeping in mind that I am intending to use the library <a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow"">RxSwift</a> for asynchronous event handling and event/data streams. I am trying to keep this App as stateless as possible.</p>

<p>Are the <code>Servers</code> in this <a href=""http://twocentstudios.com/2015/12/08/an-experimental-ios-architecture-based-on-radical-decoupling/"" rel=""nofollow"">blog post</a> a good practice for retrieving <code>view-models</code> and/or updating them?</p>
","3349270","","","","","2016-05-28 02:35:17","iOS App architecture implementing MVVM, Networking and Bluetooth, how?","<ios><mvvm><bluetooth><swift2><rx-swift>","1","2","","","","CC BY-SA 3.0"
"37496074","1","37497468","","2016-05-28 06:45:38","","16","16297","<p>I read the two way binding operator in sample code of RxSwift.</p>

<pre><code>func &lt;-&gt; &lt;T&gt;(property: ControlProperty&lt;T&gt;, variable: Variable&lt;T&gt;) -&gt; Disposable {
    let bindToUIDisposable = variable.asObservable()
        .bindTo(property)
    let bindToVariable = property
        .subscribe(onNext: { n in
            variable.value = n
        }, onCompleted:  {
            bindToUIDisposable.dispose()
        })

    return StableCompositeDisposable.create(bindToUIDisposable, bindToVariable)
}
</code></pre>

<p>When <code>property</code> changed, it will notify variable, and set the variable's value, while the variable's value is set, it will notify the property. I think it will lead to endless loop...</p>
","4738084","","","","","2019-11-14 13:04:37","Two way binding in RxSwift","<ios><swift><functional-programming><reactive-cocoa><rx-swift>","6","0","6","","","CC BY-SA 3.0"
"37522344","1","37526421","","2016-05-30 09:37:08","","4","5727","<p>I have a TableView of notification. I want to refresh by pull to refresh using UIRefreshControl. How to do that with rx-swift? This is my code. Why tableView not refreshed after I set value to variable data</p>

<pre><code>var refreshControl = UIRefreshControl()
var disposeBag = DisposeBag()

let loadingData = ActivityIndicator()

var data: Observable&lt;[Notification]&gt;!

override func viewDidLoad() {
    super.viewDidLoad()

    self.view = v

    v.tableView.registerClass(NotificationsViewCell.self, forCellReuseIdentifier: ""Cell"")
    v.tableView.addSubview(refreshControl)
    data = getNotifications()

    configureTableDataSource()
    configureActivityIndicatorsShow()

    refreshControl.rx_controlEvent(.ValueChanged)
        .flatMapLatest{ [unowned self] _ in
            return self.getNotifications()
            .trackActivity(self.loadingData)
        }.subscribe(
            onNext: {notification in
                print(""success"")
                self.data = Observable.just(notification) // NOT REFRESH TABLEVIEW
            },
            onError: { error in
                print(""Error \(error)"")
            },
            onCompleted: {() in
                print(""complete"")
            },
            onDisposed: {() in
                print(""disposed"")
            })
        .addDisposableTo(disposeBag)
}


func configureTableDataSource(){
    data
        .retry(3)
        .doOnError{ [weak self] error in
            self?.v.emptyLabel.hidden = false
            self?.v.retryButton.hidden = false
        }
        .doOnNext{ [weak self] result in
            if result.count == 0 {
                self?.v.emptyLabel.hidden = false
                self?.v.emptyLabel.text = ""Tidak ada bisnis favorit""
            } else {
                self?.v.emptyLabel.hidden = true
                self?.v.retryButton.hidden = true
            }
        }
        .trackActivity(loadingData)
        .retryWhen{ _ in
            self.v.retryButton.rx_tap
        }
        .asDriver(onErrorJustReturn: [])
        .map{ results in
            results.map(NotificationsViewModel.init)
        }
        .drive(v.tableView.rx_itemsWithCellIdentifier(""Cell"", cellType: NotificationsViewCell.self)) { (index, viewModel, cell) in
            cell.viewModel = viewModel

            let tap = UITapGestureRecognizer(target: self, action: #selector(self.goToProfile(_:)))
            tap.numberOfTapsRequired = 1
            cell.photo.tag = index
            cell.photo.addGestureRecognizer(tap)
        }
        .addDisposableTo(disposeBag)
}

func configureActivityIndicatorsShow(){
    loadingData
        .driveNext{ isLoading in
            if !isLoading {
                self.v.indicatorView.stopAnimating()
            } else {
                self.v.indicatorView.startAnimating()
                self.v.retryButton.hidden = true
                self.v.emptyLabel.hidden = true
            }
        }
        .addDisposableTo(disposeBag)

    loadingData.asObservable()
        .bindTo(refreshControl.rx_refreshing)
        .addDisposableTo(disposeBag)
}

func getNotifications() -&gt; Observable&lt;[Notification]&gt; {
    let parameters = [
        ""token"": NSUserDefaults.standardUserDefaults().objectForKey(""token"")! as! String
    ]
    return string(.POST, NOTIFICATION_LIST, parameters: parameters)
        .map { json in
            return Notification.parseJSON(JSON.parse(json)[""notifications""])
        }
        .observeOn(MainScheduler.instance)
}
</code></pre>

<p>EDIT::</p>

<pre><code>var data = Variable&lt;[Notification]&gt;([])

override func viewDidLoad() {
    getNotifications()
        .retry(3)
        .doOnError{ [weak self] error in
            self?.v.emptyLabel.hidden = false
            self?.v.retryButton.hidden = false
        }
        .doOnNext{ [weak self] result in
            if result.count == 0 {
                self?.v.emptyLabel.hidden = false
                self?.v.emptyLabel.text = ""Tidak ada notifikasi""
            } else {
                self?.v.emptyLabel.hidden = true
                self?.v.retryButton.hidden = true
            }
        }
        .trackActivity(loadingData)
        .retryWhen{ _ in
            self.v.retryButton.rx_tap
        }
        .bindTo(data)
        .addDisposableTo(disposeBag)


    refreshControl.rx_controlEvent(.ValueChanged)
        .flatMapLatest{ [unowned self] _ in
            return self.getNotifications()
                .doOnError{ [weak self] error in 
                    // This not call after the second pull to refresh if No network connection, so refresh control still appear
                    self?.refreshControl.endRefreshing()  
                }
                .doOnCompleted{ [weak self] result in
                    self?.refreshControl.endRefreshing()
                }
        }.bindTo(data)
        .addDisposableTo(disposeBag)
}

func configureTableDataSource(){
    datas.asObservable()
        .asDriver(onErrorJustReturn: [])
        .map{ results in
            results.map(NotificationsViewModel.init)
        }
        .drive(v.tableView.rx_itemsWithCellIdentifier(""Cell"", cellType: NotificationsViewCell.self)) { (index, viewModel, cell) in
            cell.viewModel = viewModel
        }
        .addDisposableTo(disposeBag)
}


func configureActivityIndicatorsShow(){
    loadingData
        .driveNext{ isLoading in
            if !isLoading {
                self.v.indicatorView.stopAnimating()
            } else {
                self.v.indicatorView.startAnimating()
                self.v.retryButton.hidden = true
                self.v.emptyLabel.hidden = true
            }
        }
        .addDisposableTo(disposeBag)
}
</code></pre>
","3941805","","3941805","","2016-05-31 09:59:43","2016-05-31 09:59:43","Binding to a UIRefreshControl after refresh using RxSwift","<ios><swift><uirefreshcontrol><rx-swift>","1","0","5","","","CC BY-SA 3.0"
"37525712","1","37525872","","2016-05-30 12:28:55","","3","12230","<p>I have two Bool properties in my VC.swift:</p>

<pre><code>var isRecording = false
var isPlaying = false
</code></pre>

<p>In the viewDidLoad() method I have such code:</p>

<pre><code>let observable = Observable.combineLatest(self.rx_observe(Bool.self, ""isRecording""), self.rx_observe(Bool.self, ""isPlaying"")) { (val1, val2) -&gt; Void in
        if(val1 == false &amp;&amp; val2 == false){
            self.recordButton.enabled = true
            self.playButton.enabled = true
            self.recordButton.setImage(UIImage(named: ""record""), forState: UIControlState.Normal)
            self.playButton.setImage(UIImage(named: ""play""), forState: UIControlState.Normal)
        } else if(val1 == true &amp;&amp; val2 == false){
            self.recordButton.enabled = true
            self.recordButton.setImage(UIImage(named: ""stop""), forState: UIControlState.Normal)
            self.playButton.enabled = false
        } else if(val1 == false &amp;&amp; val2 == true){
            self.recordButton.enabled = false
            self.playButton.enabled = true
            self.playButton.setImage(UIImage(named: ""stop""), forState: UIControlState.Normal)
            self.recordButton.setImage(UIImage(named: ""record""), forState: UIControlState.Normal)
        }
    }.observeOn(MainScheduler.instance)
    addSubscription(observable.subscribe())
</code></pre>

<p>The function addSubscription(:_) adds subscription to DisposableBag. 
The problem is that the code in the closure works only once. It does not work when properties ""isRecording"" and ""isPlaying"" change. What should I do if I want this code to be performed after I have these bool properties changed?</p>
","4092466","","","","","2021-01-17 18:42:06","How to observe Bool properties with RxSwift?","<ios><swift><rx-swift>","2","1","1","","","CC BY-SA 3.0"
"37573170","1","","","2016-06-01 15:40:05","","1","1664","<p>I have created a custom control thad works as <code>UISlider</code>. Now I want to use it with RxSwift and for this I need <code>rx_value</code> like property for my control. 
I have found RxSwift code for <code>UISlider</code> on GitHub: </p>

<pre><code>extension UISlider {

    /**
    Reactive wrapper for `value` property.
    */
    public var rx_value: ControlProperty&lt;Float&gt; {
        return UIControl.rx_value(
            self,
            getter: { slider in
                slider.value
            }, setter: { slider, value in
                slider.value = value
            }
        )
    }

}
</code></pre>

<p>It does look simple enough so I decided just to repeat it in my control but apparently <code>rx_value</code> property of <code>UIControl</code> is private. What could be a workaround for this? </p>

<p><strong>UPDATE:</strong> </p>

<p>That is how I'm going to use this property:</p>

<pre><code>var latestRank: Observable&lt;Int&gt; {
        return oneSlider
            .rx_distance.asObservable()
            .throttle(0.5, scheduler: MainScheduler.instance)
            .distinctUntilChanged()
</code></pre>

<p>and in viewModel:</p>

<pre><code>distanceRank
            .observeOn(MainScheduler.instance).subscribeNext { rank in
                print(rank)
                self.discoverNodes(true)
        }
</code></pre>

<p>In viewModel <code>distanceRank</code> is defined as this:</p>

<pre><code>let distanceRank: Observable&lt;Int&gt;
</code></pre>

<p>And this is extension for <code>rx_distance</code>: </p>

<pre><code>#if os(iOS) || os(tvOS)
import Foundation
#if !RX_NO_MODULE
    import RxSwift
    import RxCocoa
#endif
import UIKit

extension OneSlider {

    public var rx_distance: ControlProperty&lt;Int&gt; {
        return UIControl.valuePublic(
            self,
            getter: { slider in
                slider.distanceRank
            }, setter: { slider, value in
                slider.distanceRank = value
            }
        )
    }

}

extension UIControl {
    static func valuePublic&lt;T, ControlType: UIControl&gt;(control: ControlType, getter:  ControlType -&gt; T, setter: (ControlType, T) -&gt; ()) -&gt; ControlProperty&lt;T&gt; {
        let values: Observable&lt;T&gt; = Observable.deferred { [weak control] in
            guard let existingSelf = control else {
                return Observable.empty()
            }

            return existingSelf.rx_controlEvent([.AllEditingEvents, .ValueChanged])
                .flatMap { _ in
                    return control.map { Observable.just(getter($0)) } ?? Observable.empty()
                }
                .startWith(getter(existingSelf))
        }
        return ControlProperty(values: values, valueSink: UIBindingObserver(UIElement: control) { control, value in
            setter(control, value)
            })
    }
}

#endif
</code></pre>
","1100641","","1100641","","2016-06-01 16:35:49","2016-06-01 16:35:49","Custom UISlider with RxSwift support","<ios><swift><rx-swift>","0","8","2","","","CC BY-SA 3.0"
"37676994","1","37677228","","2016-06-07 10:35:10","","1","92","<p>In an ObjC project I am using this ReactiveCocoa pattern </p>

<pre><code>RAC(self.pagingControl, currentPage) = RACObserve(self.pagingView, index);
</code></pre>

<p>What's the Swift equivalent with RAC4 and RxSwift?
I am a bit lost in the docs on that.</p>
","33165","","","","","2016-06-07 10:46:48","observing and assigning properties","<swift><reactive-cocoa><frp><rx-swift>","1","0","","","","CC BY-SA 3.0"
"37724766","1","37725469","","2016-06-09 11:31:24","","12","5499","<p>We create a <code>DisposeBag</code>, and a <code>Observable</code>, subscribe the <code>Observable</code> and then <code>addDisposableTo(disposeBag)</code>, I know when the <code>DisposeBag</code> is going to deinit, it will call <code>dispose()</code> to release resources otherwise it will lead memory leak. </p>

<p>If the <code>Observable</code> send <code>Complete</code> or <code>Error</code> that terminate in finite time. When the <code>Observable</code> terminate before <code>DisposeBag</code> deinit, do I have the need to call <code>addDisposableTo(disposeBag)</code>? Does <code>DisposeBag</code> automatically release the observer that subscribed to it when it received terminated message?</p>

<pre><code>let disposeBag = DisposeBag()

Observable.just(""🔴"")
    .subscribe { event in
        print(event)
    }
    .addDisposableTo(disposeBag)
</code></pre>

<p>Should I have to <code>.addDisposableTo(disposeBag)</code> explicitly? I think after sending ""🔴"", the <code>Observable</code> will terminate and releasing the observer?</p>
","4738084","","1368342","","2018-10-31 16:00:30","2018-10-31 16:00:30","When should we call addDisposableTo(disposeBag) in RxSwift?","<ios><swift><functional-programming><rx-swift>","2","0","2","","","CC BY-SA 4.0"
"37746584","1","37748990","","2016-06-10 11:02:30","","5","2727","<p>When I started to use <strong>RxSwift</strong> I used to create <code>BaseViewController</code> and extend it with all my controllers where I use <strong>RxSwift</strong>. 
The code of BaseViewController.swift:</p>

<pre><code>class BaseViewController: UIViewController {
var mSubscriptions: CompositeDisposable?

func addSubscription(subscription: Disposable){
    if(mSubscriptions == nil){
        mSubscriptions = CompositeDisposable()
    }
    if let mSub = mSubscriptions{
        mSub.addDisposable(subscription)
    }
}

func unsubscribeAll(){
    if let mSub = mSubscriptions{
        mSub.dispose()
        mSubscriptions = nil
    }

}

override func viewWillDisappear(animated: Bool) {
    super.viewWillDisappear(animated)
    unsubscribeAll()
}

deinit{
    unsubscribeAll()
}
}
</code></pre>

<p>And I use addSubscription(:_) method everywhere in my child controllers. For example a piece of code from:</p>

<pre><code>class TasksViewController: BaseViewController{
   overrided func viewWillAppear(){
       //...
     var subscribe = dataLoader.load(requestNetwork, dataManager: taskDataManager)
    .observeOn(ConcurrentDispatchQueueScheduler(queue: queue))
    .subscribe({ (event) -&gt; Void in
        //...

    })
    addSubscription(subscribe!)
   }
} 
</code></pre>

<p>What if I do not use BaseViewController and just create an instance of <code>DisposeBag()</code> in every controller and add all my subscriptions to that disposeBag? And how should I treat Disposables correct? </p>
","4092466","","3747974","","2016-06-10 13:29:38","2016-06-10 13:29:38","How to treat Disposables correct in project with RxSwift?","<ios><swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"37749508","1","37791181","","2016-06-10 13:27:03","","1","1476","<p>I am using Alamofire with rx and i'm having one issue that if the call is a success (status 200) there is no JSON returned. This triggers my error code. If I get status 400 I get JSON so the call is fine.</p>

<p>How do I specify that the response is JSON, but not to error if empty and status code 200?</p>

<p>Thanks!</p>

<pre><code>func createUser(httpBody: AccountDetails!) -&gt; Observable&lt;(NSHTTPURLResponse, AnyObject)&gt; {

    return Alamofire.Manager.rx_request(.POST,
        APIService.REGISTER_ENDPOINT,
        parameters: httpBody.getParameters(),
        encoding: .JSON,
        headers: nil)
        .flatMap {
            $0
                .validate(statusCode: 200..&lt;501)
                .validate(contentType: [""application/json""])
                .rx_responseJSON()
            .map { (response:NSHTTPURLResponse, object:AnyObject) -&gt; (NSHTTPURLResponse, AnyObject) in
                    return (response, object)
            }
    }
}
</code></pre>

<p>EDIT:</p>

<p>I fixed this by changing .rx_responseJSON() to .rx_responseData() and returning NSData instead of AnyObject as the second parameter. Now the call succeeds and I manually convert the data to JSON. Not sure if this is the correct solution but it will suffice for now. Happy to hear better solutions though.
Thanks</p>
","488888","","488888","","2016-06-10 19:23:15","2016-06-13 13:33:54","RX Alamofire Swift empty response JSON","<swift><alamofire><rx-swift>","1","1","","","","CC BY-SA 3.0"
"37758051","1","37768138","","2016-06-10 22:35:55","","2","2123","<p>This Observable is executing the following</p>

<ul>
<li>Given a source observable</li>
<li>we use map to perform some async work</li>
<li>we use concat to return the result of the async work in order</li>
</ul>

<p>The following is returning the desired result, but I would like to start 
the async work in parallel. </p>

<p>What the correct way of doing it with Rx?</p>

<pre><code>import RxSwift

func delay(time: Int, closure: () -&gt; Void) {
  dispatch_after(
    dispatch_time(DISPATCH_TIME_NOW, Int64(time * Int(NSEC_PER_SEC))),
    dispatch_get_main_queue(), closure)
}

func doAsyncWork(value: Int, desc: String, time: Int) -&gt; Observable&lt;Int&gt; {
  return Observable.create() { (observer) -&gt; Disposable in
    print(desc)
    delay(time) {
      observer.onNext(value)
      observer.onCompleted()
    }
    return NopDisposable.instance
  }
}

let seq = Observable
  .of(1, 2, 3, 4, 5)
  .map { (n) -&gt; Observable&lt;Int&gt; in
    return doAsyncWork(n,
      desc: ""start \(n) - wait \(5 - n)"",
      time: 6 - n
    )
  }
  .concat()

let sharedSeq = seq.shareReplay(0)
sharedSeq.subscribeNext { print(""=&gt; \($0)"") }
sharedSeq.subscribeCompleted { print(""=&gt; completed"") }
</code></pre>

<p>This produce</p>

<pre><code>//start 1 - wait 4
// =&gt; 1
//start 2 - wait 3
// =&gt; 2
//start 3 - wait 2
// =&gt; 3
//start 4 - wait 1
// =&gt; 4
//start 5 - wait 0
// =&gt; 5
</code></pre>

<p>The desired output would be</p>

<pre><code>//start 1 - wait 4
//start 2 - wait 3
//start 3 - wait 2
//start 4 - wait 1
//start 5 - wait 0
// =&gt; 1
// =&gt; 2
// =&gt; 3
// =&gt; 4
// =&gt; 5
</code></pre>
","920489","","920489","","2016-06-12 18:02:10","2017-04-04 05:35:29","Rxswift map + concat in parallel","<swift><rx-swift>","4","3","","","","CC BY-SA 3.0"
"37815029","1","","","2016-06-14 14:34:25","","1","628","<p>I am using nsurlsession on RxSwift.
I am facing two problems about nsurlsession on RxSwift.
I created Custom Observable.
This Observable has used nsurlsession.
nsurlsession.datataskwithrequst was canceled everytime on RxSwift.
My code is here</p>

<pre><code>func getWorkInfo(request:NSURLRequest,type1:C.Type,type2:W.Type? = nil) -&gt; Observable&lt;(C?,[W]?, NSHTTPURLResponse)&gt;{

    return Observable.create { observer in

        var d: NSDate?

        if Logging.URLRequests(request) {
            d = NSDate()
        }

        let session = NSURLSession.sharedSession()   
        let task = session.dataTaskWithRequest(request) { (data, response, error) in
            guard let response = response, data = data else {
                ColorLogger.defaultInstance?.error(error)
                observer.on(.Error(error ?? RxCocoaURLError.Unknown))
                return
            }

            guard let httpResponse = response as? NSHTTPURLResponse else {
                observer.on(.Error(RxCocoaURLError.NonHTTPResponse(response: response)))
                return
            }

            guard let jsonString: String = NSString(data:data, encoding:NSUTF8StringEncoding) as? String else{
                observer.on(.Error(ApiError.FormatError))
                return
            }

            //カウント系
            let countObj = Mapper&lt;C&gt;().map(jsonString)
            //一覧系
            //二つ目を指定してない場合はnilを返す
            if type2 != nil{
                let aryObj = Mapper&lt;W&gt;().mapArray(jsonString)
                observer.on(.Next(countObj,aryObj, httpResponse))
            }else{
                observer.on(.Next(countObj,nil, httpResponse))
            }

            observer.on(.Completed)

        }


        let t = task
        t.resume()

        return AnonymousDisposable{task.cancel()}
    }
}
</code></pre>

<p>Above method was called by here.</p>

<pre><code>func getWorkCount(dicParam: NSDictionary) -&gt; Observable&lt;WorkCount?&gt; {

    // URL作成
    let strParam = dicParam.urlEncodedString()
    let strUrl = Const.ShiftApiBase.SFT_API_DOMAIN+Const.ApiUrl.WORK_COUNT+""?""+strParam


    // 求人リストデータを取得
    let url = NSURL(string: strUrl)!
    let request = NSURLRequest(URL: url)
    let client = WorkClient&lt;WorkCount,Work&gt;()
    ColorLogger.defaultInstance?.debug(strUrl)
    return client.getWorkInfo(request, type1: WorkCount.self)
        .observeOn(Dependencies.sharedDependencies.backgroundWorkScheduler)
        .catchError{(error) -&gt; Observable&lt;(WorkCount?,[Work]?, NSHTTPURLResponse)&gt; in
            print(""error"")
            ColorLogger.defaultInstance?.error(""UnknownError"")
            return Observable.empty()

        }
        .map { countObj,workObj,httpResponse in

            if httpResponse.statusCode != 200 {

                throw ApiError.Bad

            }
            return countObj

        }
        .observeOn(Dependencies.sharedDependencies.mainScheduler)



}
</code></pre>

<p>And My subscribe is here.</p>

<pre><code>/**
 検索件数を取得

 - parameter param: &lt;#param description#&gt;
 */
func getSearchCount(param: [String:String]){
    let dicParam = NSDictionary(dictionary: param)
    api.getWorkCount(dicParam)
        .catchError{
            error -&gt; Observable&lt;WorkCount?&gt; in
            switch error{
            case ApiError.Bad:
                ColorLogger.defaultInstance?.error(""status error"")
                break
            case ApiError.FormatError:
                ColorLogger.defaultInstance?.error(""FormatError"")
                break
            case ApiError.NoResponse:
                ColorLogger.defaultInstance?.error(""NoResponse"")
                break
            default:
                ColorLogger.defaultInstance?.error(""UnKnownError"")
                break
            }


            return Observable.just(nil)
        }
        .subscribeNext { [weak self] countObj in
            self?.count.value = countObj?.returned_count
        }
        .addDisposableTo(disposeBag)

}
</code></pre>

<p>I have two problems.</p>

<p>1:nsurlsession was canceled every time.I don know reason.</p>

<p>2:Even if I got error on NSURLSession,I could not catch error on ""CatchError"".</p>

<p>By the way,when i try to use the following code,But nsurlsession might be canceled.</p>

<p>It might be a base nsurlsession on RxSwift.</p>

<pre><code>func getWorkCount4(dicParam: NSDictionary) -&gt; Observable&lt;WorkCount?&gt; {

    // URL作成
    let strParam = dicParam.urlEncodedString()
    let strUrl = Const.ShiftApiBase.SFT_API_DOMAIN+Const.ApiUrl.WORK_COUNT+""?""+strParam


    // 求人リストデータを取得
    let url = NSURL(string: strUrl)!
    let request = NSURLRequest(URL: url)
    let session = ApiBase.sharedObj.createNSURLSession()
    return NSURLSession.sharedSession().rx_response(request)
        .observeOn(Dependencies.sharedDependencies.backgroundWorkScheduler)
        .map { data,httpResponse in

            if httpResponse.statusCode != Const.HTTP_RESPONSE.HTTP_STATUS_CODE_OK {
                throw ApiError.Bad
            }

            guard let jsonString: String = NSString(data:data, encoding:NSUTF8StringEncoding) as? String else{
                throw ApiError.FormatError
            }

            let countObj = Mapper&lt;WorkCount&gt;().map(jsonString)
            return countObj

        }
        .observeOn(Dependencies.sharedDependencies.mainScheduler)

}
</code></pre>

<p>What is this problem?</p>
","4023047","","4023047","","2016-06-14 15:03:28","2016-06-14 15:15:29","Why nsurlsession.datataskwithrequst was canceled","<ios><swift><nsurlsession><rx-swift>","1","2","","","","CC BY-SA 3.0"
"37882812","1","38264048","","2016-06-17 13:26:25","","0","997","<p>hey !!!</p>

<p>I'm on OSX, the last one, using the last xcode version, and the last version of iOS :)</p>

<p>I've some problems to implement mvvm and reactive programming in my test project.
For reactive i'm using RxSwift libraries from here <a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow"">RxSwift</a></p>

<pre><code>// so here my implementation of SettingsVC.swift

import UIKit
import SpeedLog
import RxCocoa
import RxSwift
import Eureka

class SettingsVC: FormViewController {
    let viewModel = SettingsVM()

    override func viewDidLoad() {
        super.viewDidLoad()

        self.setupFormer()
    }

    func setupFormer() {
        //        self.tableView?
        //            .rx_setDelegate(self)
        //            .addDisposableTo(disposeBag)
        //        
        //        // Setup Observer


        self.setRegisterAndLoginRows()
        self.setProfileRow()
    }

    func setRegisterAndLoginRows() {
        self.form
            +++= ButtonRow(""connectDisconnect"") {
                $0.title = ""Connexion""
                } .onCellSelection { row in
                    SpeedLog.print((row.cell.textLabel?.text)! + "" called"")
                    UIViewController.pushModal(self, pushModalTo: PushModalTo.Connection)
            }

            &lt;&lt;&lt; ButtonRow(""registration"") {
                $0.title = ""Inscription""
                } .onCellSelection { row in
                    SpeedLog.print((row.cell.textLabel?.text)! + "" called"")
                    //UIViewController.pushModal(self, pushModalTo: PushModalTo.Connection)
        }
    }

    func setProfileRow() {
        form
            +++= Section(""Mon compte"")

            &lt;&lt;&lt; LabelRow(""profile"") {
                $0.title = ""Mon profil""
                $0.value = ""Non enregistré""
                let cell = $0
                Session.appUser?.username
                    .asObservable()
                    .subscribeNext { username in
                        if let usernameTemp = username {
                            cell.value = usernameTemp
                        }
                    }
                    .addDisposableTo((Session.appUser?.disposeBag)!)
                } .onCellSelection { row in
                    SpeedLog.print((row.cell.textLabel?.text)! + "" called"")
                    UIViewController.pushView(self, pushSettingsTo: PushSettingsTo.MyProfile)
        }
    }
}

// my SessionManager

import Foundation
import RxSwift

let Session = SessionManager.sharedInstance

class SessionManager {
    static let sharedInstance = SessionManager()

    var appUser: AppUser?

    init() {
        self.appUser = nil
    }
}

// and my class User, because AppUser just inherit from User

import Foundation
import SpeedLog
import RxSwift

class User {
    var username: Variable&lt;String?&gt; = Variable(nil)
    var accessToken: Variable&lt;String?&gt; = Variable(nil)
    var country: Variable&lt;String?&gt; = Variable(nil)
    var created: Variable&lt;NSDate?&gt; = Variable(nil)
    var disabled: Variable&lt;Bool?&gt; = Variable(nil)
    var displayName: Variable&lt;String?&gt; = Variable(nil)
    var email: Variable&lt;String?&gt; = Variable(nil)
    var emailVerified: Variable&lt;Bool?&gt; = Variable(nil)
    var locale: Variable&lt;LocaleContainer?&gt; = Variable(nil)
    var modified: Variable&lt;NSDate?&gt; = Variable(nil)
    var phoneNumber: Variable&lt;String?&gt; = Variable(nil)
    var phoneVerified: Variable&lt;Bool?&gt; = Variable(nil)
    var userID: Variable&lt;String?&gt; = Variable(nil)
    var picture: Variable&lt;UIImage?&gt; = Variable(nil)
    var pictureURL: Variable&lt;String?&gt; = Variable(nil)
    let disposeBag = DisposeBag()

    func set(kiiUser: KiiUser) {
        self.username.value = kiiUser.username
        self.accessToken.value = kiiUser.accessToken
        self.country.value = kiiUser.country
        self.created.value = kiiUser.created
        self.disabled.value = kiiUser.disabled
        self.displayName.value = kiiUser.displayName
        self.email.value = kiiUser.email
        self.emailVerified.value = kiiUser.emailVerified
        self.locale.value = kiiUser.locale
        self.modified.value = kiiUser.modified
        self.phoneNumber.value = kiiUser.phoneNumber
        self.phoneVerified.value = kiiUser.phoneVerified
        self.userID.value = kiiUser.userID
        self.picture.value = UIImage()
        self.pictureURL.value = String()
    }
}
</code></pre>

<p>I've already try to change just the Singleton to Variable() but it doesn't work ..
What i make bad ?
Sorry for my bad english :/</p>

<p>Thanks for your helps</p>
","5899647","","5899647","","2016-06-17 14:11:20","2016-07-08 10:08:16","How can i make my program reactive in swift with RxSwift","<swift><mvvm><reactive-programming><rx-swift><eureka-forms>","1","3","1","","","CC BY-SA 3.0"
"37965953","1","","","2016-06-22 10:55:09","","1","1772","<p>I got this class which I'd like to write tests for:</p>

<pre><code>import CoreLocation
import RxCocoa
import RxSwift

struct LocationManager {

    private (set) var authorized: Driver&lt;Bool&gt;
    private let coreLocationManager = CLLocationManager()

    init() {
        coreLocationManager.distanceFilter = kCLDistanceFilterNone
        coreLocationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation

        authorized = Observable.deferred { [weak coreLocationManager] in
            let status = CLLocationManager.authorizationStatus()
            guard let coreLocManager = coreLocationManager else {
                return Observable.just(status)
            }
            return coreLocManager
                .rx_didChangeAuthorizationStatus
                .startWith(status)
            }
            .asDriver(onErrorJustReturn: CLAuthorizationStatus.NotDetermined)
            .map {
                switch $0 {
                case .AuthorizedWhenInUse:
                    return true
                default:
                    return false
                }
        }

        coreLocationManager.requestWhenInUseAuthorization()
    }
}
</code></pre>

<p>Basically I want to test whether the authorized <code>Driver</code> has the correct value based on possible <code>CLAuthorizationStatuses</code>. I need a hint in the right direction since I am not familiar with unit testing with RxSwift. I guess my best option is to create a mock of <code>CLLocationManager</code> which returns some CLAuthorizationStatus when <code>authorizationStatus()</code> is called and afterwards I would check the value of the authorized <code>Driver</code> right ?</p>

<p>Any explanation on how to test this <code>LocationManager</code> class is appreciated.</p>
","720133","","","","","2016-06-22 13:40:36","Write Unit Tests for RxSwift","<xcode><swift><unit-testing><rx-swift>","2","0","0","","","CC BY-SA 3.0"
"37973445","1","37986481","","2016-06-22 16:18:53","","36","10236","<p>I'm a little bit confused about the order you can call the <code>subscribeOn</code> and <code>observeOn</code> methods on observables. I read a couple of posts and one guys says that it doesn't matter and just uses thing in his example and other people say it does matter. So here is my question:</p>

<p>For example:</p>

<pre><code>self.remoteService.rxGetAllLanguages()
            .observeOn(MainScheduler.instance)
            .subscribeOn(ConcurrentDispatchQueueScheduler(globalConcurrentQueueQOS: .Background))
            .subscribe({ e in
                switch e {
                case .Next(let element):

                case .Error(let e):
                    DDLogError(""Error in  \(e)"")
                case .Completed:
                    DDLogDebug(""Completed"")
                }
                }
            ).addDisposableTo(self.disposeBag)
</code></pre>

<p>Is that the same as:</p>

<pre><code>  self.remoteService.rxGetAllLanguages()
                    .subscribeOn(ConcurrentDispatchQueueScheduler(globalConcurrentQueueQOS: .Background))
                    .observeOn(MainScheduler.instance)
                    .subscribe({ e in
                        switch e {
                        case .Next(let element):

                        case .Error(let e):
                            DDLogError(""Error in  \(e)"")
                        case .Completed:
                            DDLogDebug(""Completed"")
                        }
                        }
                    ).addDisposableTo(self.disposeBag)
</code></pre>

<p>If I correctly understand the mechanisms they are different. The first one does all the work on the main thread and the second does all the work on another thread and then dispatches back to the main thread. But I'm nut sure so can someone clear this for me please?</p>
","1007522","","2401535","","2017-05-16 10:07:17","2017-05-16 10:08:14","Does the order of subscribeOn and observeOn matter?","<swift><multithreading><rx-swift>","3","0","11","","","CC BY-SA 3.0"
"37985390","1","","","2016-06-23 07:53:29","","3","1213","<p>I bind my dataSource to tableview using <code>rxswift</code>, but by default cells are editable when I am doing like that, how can I disable that functionality?</p>

<p>Here the example of tableview what I got:</p>

<p><a href=""https://i.stack.imgur.com/ORt3U.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ORt3U.jpg"" alt=""here the example of tableview what I got""></a></p>
","6502878","","6201755","","2016-06-23 08:46:59","2016-08-18 07:46:38","Disable UITableViewCell edit mode with rxswift","<ios><swift2><rx-swift>","3","2","","","","CC BY-SA 3.0"
"38201532","1","","","2016-07-05 10:50:04","","1","1099","<p>Here's the code from the RxSwift repo for a simple spreadsheet (adding three numbers):</p>

<pre><code>Observable.combineLatest(number1.rx_text, number2.rx_text, number3.rx_text) { textValue1, textValue2, textValue3 -&gt; Int in
        return (Int(textValue1) ?? 0) + (Int(textValue2) ?? 0) + (Int(textValue3) ?? 0)
    }
    .map { $0.description }
    .bindTo(result.rx_text)
    .addDisposableTo(disposeBag)
</code></pre>

<p>I want to add a ""Clear all"" UIButton, that will cause the three boxes to be reset to zero and the total also set to zero. In imperative style, very easy.</p>

<p>What is the correct way of adding this button in RxSwift?</p>
","1204298","","343299","","2016-07-06 11:24:40","2016-07-06 11:24:40","RxSwift How to add ""clear all"" UIButton to simple spreadsheet example","<ios><swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"38208551","1","38219962","","2016-07-05 16:40:21","","1","700","<p>I have to fetch three types of data (<code>AType</code>, <code>BType</code>, <code>CType</code>) using three separate API requests. The objects returned by the APIs are related by one-to-many:</p>

<ul>
<li>1 <code>AType</code> object is parent of N <code>BType</code> objects</li>
<li>1 <code>BType</code> object is parent of P <code>CType</code> objects)</li>
</ul>

<p>I'm using the following three functions to fetch each type:</p>

<pre><code>func get_A_objects() -&gt; Observable&lt;AType&gt; { /* code here */ }
func get_B_objects(a_parentid:Int) -&gt; Observable&lt;BType&gt; { /* code here */}
func get_C_objects(b_parentid:Int) -&gt; Observable&lt;CType&gt; { /* code here */}
</code></pre>

<p>and to avoid nested subscriptions, these three functions are chained using <code>flatMap</code>:</p>

<pre><code>func getAll() -&gt; Observable&lt;CType&gt; {
  return self.get_A_objects()
     .flatMap { (aa:AType) in  return get_B_objects(aa.id) }
     .flatMap { (bb:BType) in  return get_C_objects(bb.id) }
}

func setup() {
  self.getAll().subscribeNext { _ in
    print (""One more item fetched"") 
  }
}
</code></pre>

<p>The above code works fine, when there are M objects of <code>AType</code>, I could see the text <code>""One more item fetched""</code> printed MxNxP times.</p>

<p>I'd like to setup the <code>getAll()</code> function to deliver status updates <strong>throughout the chain</strong> using <code>ReplaySubject&lt;String&gt;</code>. My initial thought is to write something like:</p>

<pre><code>func getAll() -&gt; ReplaySubject&lt;String&gt; {
  let msg = ReplaySubject&lt;String&gt;.createUnbounded()
  self.get_A_objects().doOnNext { aobj in msg.onNext (""Fetching A \(aobj)"") }
    .flatMap { (aa:AType) in 
       return get_B_objects(aa.id).doOnNext { bobj in msg.onNext (""Fetching B \(bobj)"") }
    }
    .flatMap { (bb:BType) in
       return get_C_objects(bb.id).doOnNext { cobj in msg.onNext (""Fetching C \(cobj)"") }
    }

  return msg
}
</code></pre>

<p>but this attempt failed, i.e., the following <code>print()</code> does not print anything.</p>

<pre><code>getAll().subscribeNext {
  print ($0)
}
</code></pre>

<p>How should I rewrite my logic?</p>
","2628487","","343299","","2016-07-06 09:49:57","2016-07-06 09:49:57","RxSwift: Nested Queries and ReplaySubject","<swift><reactive-programming><rx-swift><behaviorsubject>","1","0","","","","CC BY-SA 3.0"
"38252111","1","","","2016-07-07 17:50:09","","1","1852","<p>I'm having 2 methods like this:</p>

<pre><code>func rxGetAllTonicsForLanguage(language: Language) -&gt; Observable&lt;AnyObject?&gt;
func saveTonics(list: [Tonic]) -&gt; Observable&lt;AnyObject?&gt;
</code></pre>

<p>Now I want to first do the getAllTonics call and then with the result of that call I want to do the next action. So I thought this was something I could do with FlatMap. But I'm stuck I can't figure out how to chain these.</p>

<p>I tried like follows:</p>

<pre><code>   self.remoteService.rxGetAllTonicsForLanguage(language)
        .subscribeOn(ConcurrentDispatchQueueScheduler(globalConcurrentQueueQOS: .Background))
        .flatMap{tonics -&gt; Observable&lt;[Tonic]&gt; in
            print(""Tonics: \(tonics)"")
            let x = tonics as! [Tonic]
            return TonicAdapter.sharedInstance.saveTonics(x)
    }.observeOn(MainScheduler.instance)
        .subscribe({ e in
            switch e {
            case .Next(let element):
                if let result = element as? String {
                    DDLogDebug(""Saved something \(result)"")
                }
            case .Error(let e):
                DDLogError(""Error in save tonics \(e)"")
            case .Completed:
                DDLogDebug(""Completed save tonics"")
            }
            }
        ).addDisposableTo(self.disposeBag)
</code></pre>

<p>It gives me this error on the line of return TonicAdapter:</p>

<pre><code>Cannot convert return expression of type 'Observable&lt;AnyObject?&gt;' (aka 'Observable&lt;Optional&lt;AnyObject&gt;&gt;') to return type 'Observable&lt;[Tonic]&gt;' (aka 'Observable&lt;Array&lt;Tonic&gt;&gt;')
</code></pre>

<p>I don't see the problem because both methods are returning Observables?</p>
","1007522","","","","","2018-05-04 05:52:52","RXSwift flatMap two methods","<ios><swift><swift2><rx-swift>","2","2","","","","CC BY-SA 3.0"
"38255500","1","38257936","","2016-07-07 21:22:25","","3","681","<p>I have a method that receives <code>[Int]</code>, which are <strong>ids</strong> of some <strong>Items</strong>. </p>

<p>I'd like to go through this list and download every <strong>Item</strong> using another method that returns/download <code>Observable&lt;Item&gt;</code> to finally return an <code>Observable&lt;[Item]&gt;</code> in this very same function.</p>

<p>How can I do this using RxSwift/RxCocoa operators?</p>
","2683201","","790877","","2016-07-09 11:10:16","2016-07-09 11:10:16","RxSwift - fetch every item on the list","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"38281760","1","38328753","","2016-07-09 12:22:27","","18","8365","<p>I found this example on <a href=""http://sapandiwakar.in/refresh-oauth-tokens-using-moya-rxswift/"" rel=""noreferrer"">How to refresh oauth token using moya and rxswift</a> which I had to alter slightly to get to compile. This code works 80% for my scenario. The problem with it is that it will run for all http errors, and not just 401 errors. What I want is to have all my other http errors passed on as errors, so that I can handle them else where and not swallow them here.</p>

<p>With this code, if I get a <code>HttpStatus 500</code>, it will run the authentication code 3 times which is obviously not what I want.</p>

<p>Ive tried to alter this code to handle only handle <code>401</code> errors, but it seem that no matter what I do I can't get the code to compile. It's always complaining about wrong return type, <code>""Cannot convert return expression of type Observable&lt;Response&gt; to return type Observable&lt;Response&gt;""</code> which makes no sense to me..</p>

<p>What I want: handle 401, but stop on all other errors</p>

<pre><code>import RxSwift
import KeychainAccess
import Moya

public extension ObservableType where E == Response {

  /// Tries to refresh auth token on 401 errors and retry the request.
  /// If the refresh fails, the signal errors.
  public func retryWithAuthIfNeeded() -&gt; Observable&lt;E&gt; {
    return self.retryWhen {
      (e: Observable&lt;ErrorType&gt;) in
      return Observable.zip(e, Observable.range(start: 1, count: 3), resultSelector: { $1 })
        .flatMap { i in
          return AuthProvider.sharedInstance.request(
            .LoginFacebookUser(
              accessToken: AuthenticationManager.defaultInstance().getLoginTokenFromKeyChain(),
              useFaceBookLogin: AuthenticationManager.defaultInstance().isFacebookLogin())
            )
            .filterSuccessfulStatusCodes()
            .mapObject(Accesstoken.self)
            .catchError {
              error in
              log.debug(""ReAuth error: \(error)"")
              if case Error.StatusCode(let response) = error {
                if response.statusCode == 401 {
                  // Force logout after failed attempt
                  log.debug(""401:, force user logout"")
                  NSNotificationCenter.defaultCenter().postNotificationName(Constants.Notifications.userNotAuthenticated, object: nil, userInfo: nil)
                }
              }
              return Observable.error(error)
            }.flatMapLatest({
              token -&gt; Observable&lt;Accesstoken&gt; in
              AuthenticationManager.defaultInstance().storeServiceTokenInKeychain(token)
              return Observable.just(token)
            })
      }
    }
  }
}
</code></pre>
","215400","","","","","2018-09-24 12:37:11","Using retryWhen to update tokens based on http error code","<ios><swift><alamofire><rx-swift><moya>","3","1","4","","","CC BY-SA 3.0"
"38325626","1","38326538","","2016-07-12 10:00:02","","1","844","<p>I try to migrate delegate of SRWebSocket to observable. This is my RxSocketManagerDelegateProxy.swift:</p>

<pre><code>class RxSocketManagerDelegateProxy: DelegateProxy, DelegateProxyType{

static func currentDelegateFor(object: AnyObject) -&gt; AnyObject?{
    let socket: SRWebSocket = object as! SRWebSocket
    return socket.delegate
}

static func setCurrentDelegate(delegate: AnyObject?, toObject object: AnyObject) {
    let socket: SRWebSocket = object as! SRWebSocket
    socket.delegate = delegate as? SRWebSocketDelegate
}

}

extension SRWebSocket{
    public var rx_delegate: DelegateProxy{
    return DelegateProxyType.proxyForObject(self)
}

// ...

}
</code></pre>

<p>The problem is in proxyForObject function. It is not compiled like above. I get warning ""Static member 'proxyForObject' cannot be used on instance of type 'DelegateProxyType.Protocol'"". </p>

<p>When I try to use proxyForObjectFunction like this (though it is deprecated):</p>

<pre><code>public var rx_delegate: DelegateProxy{
    return proxyForObject(RxSocketManagerDelegateProxy.self, self)
}
</code></pre>

<p>I get message ""assertion failed: : file /Users/Agentum/Documents/Xcode/Telemetry/Pods/RxCocoa/RxCocoa/Common/DelegateProxyType.swift"".</p>

<p>How should I use proxyForObject() function in order to migrate the delegate correct?</p>
","4092466","","","","","2016-07-12 10:40:23","Can not use proxyForObject function in DelegateProxyType (rxSwift)","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"38372747","1","38384328","","2016-07-14 11:16:39","","13","15658","<p>I have authorization controller with 2 UITextField properties and 1 UIButton. I want to bind my View to ViewModel but don't know how to to do it. 
This is my AuthorizatioVC.swift:</p>

<pre><code>class AuthorizationViewController: UIViewController {

let disposeBag = DisposeBag()

@IBOutlet weak var passwordTxtField: UITextField!
@IBOutlet weak var loginTxtField: UITextField!

@IBOutlet weak var button: UIButton!

override func viewDidLoad() {
    super.viewDidLoad()

    addBindsToViewModel()

}

func addBindsToViewModel(){
    let authModel = AuthorizationViewModel(authClient: AuthClient())

    authModel.login.asObservable().bindTo(passwordTxtField.rx_text).addDisposableTo(self.disposeBag)
    authModel.password.asObservable().bindTo(loginTxtField.rx_text).addDisposableTo(self.disposeBag)
  //HOW TO BIND button.rx_tap here?

}

}
</code></pre>

<p>And this is my AuthorizationViewModel.swift:</p>

<pre><code>final class AuthorizationViewModel{


private let disposeBag = DisposeBag()

//input
//HOW TO DEFINE THE PROPERTY WHICH WILL BE BINDED TO RX_TAP FROM THE BUTTON IN VIEW???
let authEvent = ???
let login = Variable&lt;String&gt;("""")
let password = Variable&lt;String&gt;("""")

//output
private let authModel: Observable&lt;Auth&gt;

init(authClient: AuthClient){

   let authModel = authEvent.asObservable()
            .flatMap({ (v) -&gt; Observable&lt;Auth&gt; in
                    return authClient.authObservable(String(self.login.value), mergedHash: String(self.password.value))
                        .map({ (authResponse) -&gt; Auth in
                            return self.convertAuthResponseToAuthModel(authResponse)
                        })
              })
}


func convertAuthResponseToAuthModel(authResponse: AuthResponse) -&gt; Auth{
    var authModel = Auth()
    authModel.token = authResponse.token
    return authModel
}
}
</code></pre>
","4092466","","","","","2017-08-19 13:10:20","How to bind rx_tap (UIButton) to ViewModel?","<ios><swift><rx-swift>","3","0","5","","","CC BY-SA 3.0"
"38391021","1","","","2016-07-15 08:07:55","","1","2441","<p>Hi I have a question here, all the docs I found on RxSwift so far are using observable interval as below:</p>

<pre><code>let subscription = Observable&lt;Int&gt;.interval(0.3, scheduler: scheduler)
    .subscribe { event in
        print(event)
    }

NSThread.sleepForTimeInterval(2)

subscription.dispose()
</code></pre>

<p>Now I have the need to implement a <code>Observable&lt;Double&gt;.interval</code> timer, I would like to a Double value in my subscribeNext calls from Observable.</p>

<p>After change above code to <code>Double</code> as a testing, I have an error saying <code>Type Observable&lt;Double&gt; has no member IntegerLiteralType</code> , anyone knows how to implement this in RxSwift?</p>
","874585","","790877","","2016-08-31 14:47:57","2016-08-31 14:47:57","Is it possible to use Observable<Double>.interval in RxSwift?","<ios><swift><rx-swift>","2","1","","","","CC BY-SA 3.0"
"38470277","1","38478027","","2016-07-19 23:49:01","","1","864","<p>I am using RxSwift for caching in my iOS app and have a piece of code like this:</p>

<pre><code>let observable = Observable.of(cache.getItem(itemID), network.getItem(itemID)).concat().take(1)

observable.subscribeNext // and do some stuff
</code></pre>

<p>I have the <code>cache.getItem</code> method doing an <code>onError</code> if it has no value, and would like it to then defer to the network, but for some reason the network is never run. I assume its because I am using the take(1), but I would like the observable to stop emitting once the cache finds something (or continue to the network if it does not).</p>

<p>Any ideas on how to do this?</p>

<p>I've been following <a href=""http://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/"" rel=""nofollow"">this</a> guide but he does not go into detail about his cache's behavior when it fails to find something.</p>
","2938665","","343299","","2016-07-20 10:51:03","2016-07-20 10:51:03","ReactiveX RxSwift get first non error from concat of observables","<ios><swift><system.reactive><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"38497874","1","38505069","","2016-07-21 07:36:56","","3","1921","<p>I have a view model who's behaviour is controlled by an <code>Observable.interval</code>. In essence, it updates a timer label on every <code>next</code> and after a certain period, updates another value.</p>

<p>A trimmed example:</p>

<pre><code>class WorkoutViewModel {
    private var _oneSecondTimer: Observable&lt;Int&gt; {
        return Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)
    }
    private let _exerciseRemainingTime: Variable&lt;Int&gt; = Variable(20)

    func setupBehaviour() {
        _oneSecondTimer.subscribeNext() { [unowned self] _ in
            self._exerciseRemainingTime.value -= 1
            if self._exerciseRemainingTime.value == 0 {
                self.progressToNextExercise()
            }
        }
    }
}
</code></pre>

<p>I would like to have a test for this, to observe the time of event and value of <code>_exerciseRemainingTime</code>.</p>

<p>Is there a way how to use the <code>TestScheduler</code> to simulate virtual time in which the <code>_oneSecondTimer</code> would tick?</p>
","1370986","","","","","2016-07-21 13:04:37","How to test RxSwift Observable.interval progress","<ios><swift><reactive-programming><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"38578847","1","38658330","","2016-07-25 23:22:24","","7","4768","<p>I am using the <code>UIRefreshControl</code> + <code>Variable</code> binding to reload data.</p>

<p>It is working, however, the following feels wrong to me:</p>

<p>1) I know there is a <code>rx_refreshing</code> variable in the <code>RXCocoa</code> extension, but I am unable to get it to work in this context.</p>

<p>2) I am binding answers (which is a <code>Variable</code> of array) twice. Once when I load the view controller and again when the <code>UIRefreshControl</code> is refreshing.</p>

<p>3) The parts where I check for whether the <code>UIRefreshControl</code> is refreshing or not looks really awkward. It feels like it defeats the purpose of using reactive?</p>

<pre><code>...

let answers: Variable&lt;[Answer]&gt; = Variable([])

override func viewDidLoad() {       
  loadAnswers()
     .shareReplay(1)
     .bindTo(answers)
     .addDisposableTo(self.disposeBag)
  setupRx()
}

func loadAnswers() -&gt; Observable&lt;[Answer]&gt; {
  return Network.rxArrayRequest(Spark.Answers)
}  

func setupRx() {
  rc.rx_controlEvent(.ValueChanged)
    .map { _ in !self.rc.refreshing }
    .filter { $0 == false }
    .flatMapLatest { [unowned self] _ in
      return self.loadAnswers()
    }
    .bindTo(answers)
    .addDisposableTo(self.disposeBag)

  rc.rx_controlEvent(.ValueChanged)
    .map { _ in self.rc.refreshing }
    .filter { $0 == true }
    .subscribeNext { [unowned self] _ in
      self.rc.endRefreshing()
    }
    .addDisposableTo(self.disposeBag)
}

...
</code></pre>
","180663","","343299","","2016-07-29 11:25:57","2016-07-29 12:01:31","RxSwift: using rx_refreshing for uirefreshcontrol","<ios><swift><uirefreshcontrol><rx-swift>","1","0","2","","","CC BY-SA 3.0"
"38650044","1","38672465","","2016-07-29 03:24:51","","1","929","<p>I'm a new one to learn RxSwift.   </p>

<p>I modified the Simple Numbers example in the RxSwift Example App, which will add three numbers into a result number. </p>

<p>I add a <code>testStr</code> <code>UITextField</code>, and an <code>upperCase</code> <code>UILabel</code>. I map <code>testStr</code> to uppercase and <code>bindTo</code> the <code>upperCase</code> label, that's good. And I also map <code>testStr</code> to its <code>length</code>, and <code>bindTo</code> the <code>num1</code> field. Strange things happen, although the contents of the <code>num1</code> field changes, it does not emit any event, so it has no effect on the <code>result</code> label. Even if I input some number into another number field, the <code>result</code> number does not count the <code>num1</code>.</p>

<p>Have I made any wrong use of <code>bindTo</code>? In what way can I make the <code>num1</code> emit an event?</p>

<p>Thanks!!!</p>

<pre><code>@IBOutlet weak var num1: UITextField!
@IBOutlet weak var num2: UITextField!
@IBOutlet weak var num3: UITextField!
@IBOutlet weak var result: UILabel!

@IBOutlet weak var testStr: UITextField!
@IBOutlet weak var upperCase: UILabel!

let disposeBag = DisposeBag()

override func viewDidLoad() {
    super.viewDidLoad()

    // Do any additional setup after loading the view, typically from a nib.
    Observable.combineLatest(num1.rx_text, num2.rx_text, num3.rx_text) {
        (textval1, textval2, textval3) -&gt; Int in
            return (Int(textval1) ?? 0) + (Int(textval2) ?? 0) + (Int(textval3) ?? 0)
        }
        .map{$0.description}
        .bindTo(result.rx_text)
        .addDisposableTo(disposeBag)

    let obStr = testStr.rx_text

    obStr
        .map {$0.uppercaseString}
        .bindTo(upperCase.rx_text)
        .addDisposableTo(disposeBag)

    obStr
        .map{ $0.characters.count }
        .map{ $0.description }
        .bindTo(num1.rx_text)
        .addDisposableTo(disposeBag)
}
</code></pre>
","6652321","","343299","","2016-07-30 09:26:52","2016-07-30 09:35:59","bindTo rx_text of a UITextField did not trigger the UITextField's emit event","<ios><swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"38766175","1","38767022","","2016-08-04 11:31:26","","3","959","<p>I'm using RxSwift's <a href=""http://reactivex.io/documentation/operators/zip.html"" rel=""nofollow""><code>zip</code></a> operator to combine <code>Observable</code> items. I want to combine more than 8 (the max currently supported). Does RxSwift have a <code>zip</code> operator similar to RxJava? - <a href=""http://reactivex.io/RxJava/javadoc/rx/Observable.html#zip(java.lang.Iterable,%20rx.functions.FuncN)"" rel=""nofollow"">RxJava Zip Operator Documentation</a></p>
","1404600","","343299","","2016-08-04 12:15:25","2016-08-04 12:15:25","RXSwift Zip operator N items via an enumerable","<ios><swift><rx-java><rx-swift>","1","1","","","","CC BY-SA 3.0"
"38783335","1","","","2016-08-05 07:15:16","","1","156","<p>here is my code:</p>

<pre><code>    let aDisposeBag = DisposeBag()
    class LoginController: NSViewController {
    @IBOutlet weak var accountField: NSTextField!
    @IBOutlet weak var passwdField: NSSecureTextField!
    @IBOutlet weak var loginBtn: NSButton!
    override func viewDidLoad() {
        super.viewDidLoad()
        let accAvailable = accountField.rx_text.map({(aa)-&gt; Bool in
            print(""aa"")
            return aa.characters.count &gt; 0
        })

        let passAvailable = passwdField.rx_text.map({(aa)-&gt; Bool in
            print(""bb"")
            return aa.characters.count &gt; 0
        })

        let allAvailable = Observable.combineLatest(accAvailable, passAvailable){$0 &amp;&amp; $1}
        allAvailable.bindTo(loginBtn.rx_enabled).addDisposableTo(aDisposeBag)

    }
}
</code></pre>

<p>When I input contents into accountField,nothing prints in the console.</p>

<p>But if I replace <code>allAvailable.bindTo(loginBtn.rx_enabled).addDisposableTo(aDisposeBag)</code> into </p>

<pre><code>allAvailable.subscribeNext { (available) in
            print(available)
        }.addDisposableTo(aDisposeBag)
</code></pre>

<p>Then I can see <code>aa</code> or <code>bb</code> is printed in the console.
Anyone can tell what's wrong with my code,thanks a lot!</p>
","4562661","","","","","2016-08-05 07:15:16","RxSwift 'bindTo(aNSButton.rx_enabled)' failed","<swift><macos><rx-swift><rx-cocoa>","0","1","","","","CC BY-SA 3.0"
"38794316","1","38802736","","2016-08-05 16:56:03","","1","259","<p>I've noticed on RxSwift <a href=""https://github.com/ReactiveX/RxSwift/tree/master/RxExample/RxExample/Examples/GitHubSignup/UsingVanillaObservables"" rel=""nofollow"">GitHub Login Example</a> that observables are passed from the ViewController into the ViewModel upon its initialization :</p>

<pre><code>let viewModel = GithubSignupViewModel1(
            input: (
                username: usernameOutlet.rx_text.asObservable(),
                password: passwordOutlet.rx_text.asObservable(),
                repeatedPassword: repeatedPasswordOutlet.rx_text.asObservable(),
                loginTaps: signupOutlet.rx_tap.asObservable()
            ),
            dependency: (
                API: GitHubDefaultAPI.sharedAPI,
                validationService: GitHubDefaultValidationService.sharedValidationService,
                wireframe: DefaultWireframe.sharedInstance
            )
        )
</code></pre>

<p>Is this the right way to be binding the login tap and text fields in reactive programming?</p>

<p>Before seeing this example I created a function in my ViewModel <code>onSignUpClick()</code> and from the view controller bound clicks to run that function. Is that bad form? </p>

<p>Seems like if everything is passed through the init it results in a very fat init function </p>
","4577878","","343299","","2016-08-06 09:33:27","2016-08-06 09:33:27","Where to bind observables in MVVM?","<mvvm><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"38797538","1","","","2016-08-05 20:45:45","","0","1677","<p>Hi I'm learning some RxSwift, I don't understand why makeLoginRequest is called two times...when login is correct i push to an other controller, but the observable still notifies an other event so it push two times the next controller..</p>

<p>In the viewModel the code is this:</p>

<pre><code>let userName : Driver&lt;String&gt;
let password : Driver&lt;String&gt;

var credentials : Driver&lt;(String, String)&gt; {
    return Driver.combineLatest(userName, password) { usr, pwd in
        return (usr, pwd)
    }
}

var credentialValid : Driver&lt;Bool&gt; {
    let usrValid = userName
        .map { $0.rangeOfString(""@"") != nil }
    let pwdValid = password
    .map { $0.utf8.count &gt; 5 }

    return Driver.combineLatest(usrValid, pwdValid) { usr, pwd in
        return (usr &amp;&amp; pwd)
    }
}

func login() -&gt; Observable&lt;Login?&gt;
{
    return credentials.asObservable()
        .observeOn(MainScheduler.instance)
        .flatMapLatest { credential -&gt; Observable&lt;Login?&gt; in
            return self.makeLoginRequest(user: credential.0, password: credential.1)
        }
}

func makeLoginRequest(user user: String, password: String) -&gt; Observable&lt;Login?&gt;
{
    return self.provider
        .request(APIProvider.Login(credentials: (user, password)))
        .debug()
        .mapObjectOptional(Login.self)
}
</code></pre>

<p>and in the controller </p>

<pre><code>    loginModel = LoginViewModel(provider: apiProvider! as! RxMoyaProvider&lt;APIProvider&gt;, userName: userTextField.rx_text.asDriver(), password: passwordTextField.rx_text.asDriver())

    loginModel.credentialValid
        .driveNext { [unowned self] valid in
            self.loginButton.enabled = valid
        }
        .addDisposableTo(disposeBag)

    loginButton.rx_tap
        .debug()
        .flatMap({ self.loginModel.login() })
        .subscribeNext({ login  in
          // handle here login data
        })
        .addDisposableTo(disposeBag)
</code></pre>

<p>Anyone can explain what's going on?</p>

<p>Thanks!</p>
","1870602","","1113632","","2018-01-29 19:08:40","2018-01-29 19:08:40","Two events fired with RxSwift","<swift><rx-swift><moya><disposable>","1","0","","","","CC BY-SA 3.0"
"38862024","1","38868029","","2016-08-09 23:31:32","","0","668","<p>How do I leverage <a href=""http://reactivex.io"" rel=""nofollow"">ReactiveX</a> to execute async calls in sequence?
I.e., execute a second call after first one has finished.</p>

<p>More specifically, I'm working with <a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow"">RxSwift</a> in iOS, and the asyncs I want to chain together are <code>UIView</code> animations (instead of calling the second animation inside the <code>completion</code> block of the first one).</p>

<p>I know I have other options like <a href=""https://github.com/icanzilb/EasyAnimation"" rel=""nofollow"">Easy Animation</a>, but I'd like to leverage Rx, since I'm already using it for streams.</p>

<p>Also, one solution would be (for 3 chained animations):</p>

<pre><code>_ = UIView.animate(duration: 0.2, animations: {
        sender.transform = CGAffineTransformMakeScale(1.8, 1.8)
    })
    .flatMap({ _ in
        return UIView.animate(duration: 0.2, animations: {
            sender.transform = CGAffineTransformMakeScale(0.8, 0.8)
        })
    })
    .flatMap({ _ in
        return UIView.animate(duration: 0.2, animations: {
            sender.transform = CGAffineTransformIdentity
        })
    })
    .subscribeNext({ _ in })
</code></pre>

<p>But I'm looking for something more elegant, the right way of doing it with Rx.</p>
","1116465","","343299","","2016-08-10 08:29:58","2017-11-01 12:38:18","How to user ReactiveX to execute async's in sequence","<ios><swift><asynchronous><rx-swift><reactivex>","2","2","","","","CC BY-SA 3.0"
"38866237","1","","","2016-08-10 06:53:53","","0","1238","<p>I don't understand why <code>Driver</code> (in RxSwift) complains about the initializer here:</p>

<pre><code>class LoginVM
{
    let userName : Driver&lt;String&gt;?
    let password : Driver&lt;String&gt;?
}
</code></pre>

<p>I also tried the implicit unwrap, but the compiler says class <code>LoginVM</code> has no initializer. How do I solve this? Thanks</p>
","1870602","","343299","","2016-08-10 07:50:20","2016-08-14 05:59:30","Has no initializer, with Driver","<swift><rx-swift>","1","1","","","","CC BY-SA 3.0"
"38880717","1","","","2016-08-10 18:14:23","","1","2988","<p>I have a question about RxSwift and the use with Driver.</p>

<p>I tried only with this pattern</p>

<pre><code>        loginButton.rx_tap
             .doOn({[unowned self] _ in
                 self.loginButton.enabled = false
             })
             .debug()
             .flatMap({[unowned self] in self.loginViewModel.login() })
             .subscribeNext({ [weak self] login  in
               // Custom code
        })
        .addDisposableTo(disposeBag)
</code></pre>

<p>So all starts with a tap to a button...but If I can try to start in this way:</p>

<pre><code>    let contractCode = Variable(contractDetail.contractCode).asDriver()
    viewModel = viewModel(provider: apiProvider! as! RxMoyaProvider&lt;APIProvider&gt;, contractCode: contractCode)
    _ = viewModel?.getStatus()
    .subscribeNext({ data in
        print(data)
        guard data?.result == 1 else {
            // ALERT
            return;
        }
        // Custom code
    })
</code></pre>

<p>Where contractDetail.contractCode is a String, contractCode in the viewModel is a Driver. 
It subscribes to it but doesn't fires onNext so subscribeNext doesn't get called.
Can you help me? what is wrong about this approach?
Thanks</p>
","1870602","","","","","2016-08-11 05:45:07","Subscription using Driver with RxSwift","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"38906661","1","39080825","","2016-08-11 21:49:26","","3","1732","<p>I have a basic problem with rxswift.
I have a login screen that should call my login method inside view model when and only when I tap the login button</p>

<pre><code>        loginButton.rx_tap
        .doOn({[unowned self] _ in
            self.loginButton.enabled = false
        })
        .flatMap({[unowned self] in self.loginModel.login() })
        .subscribeNext({ [weak self] login  in
            self?.loginButton.enabled = true

            guard login?.result == 1 else {
                self?.showErrorWithMessage(login!.message)
                return;
            }

           // Logged in!
        })
        .addDisposableTo(disposeBag)
</code></pre>

<p>Looks fine, but if the login failed because of credential not valid and the user restart typing on to the text field the call to loginModel.login() is fired again...</p>

<p>Inside the view model there is also:</p>

<pre><code>    var credentials : Driver&lt;(String, String)&gt; {
    return Driver.combineLatest(userNameDriver.distinctUntilChanged(), passwordDriver.distinctUntilChanged()) { usr, pwd in
        return (usr, pwd)
    }
}

var usrValid : Driver&lt;Bool&gt; {
    get {
        return userNameDriver
            .throttle(0.5)
            .filterEmpty()
            .distinctUntilChanged()
            .map { ($0.rangeOfString(""@"") != nil) || ($0.utf8.count == 0) }
    }
}

var pwdValid : Driver&lt;Bool&gt; {
    get {
        return passwordDriver
        .throttle(0.5)
        .filterEmpty()
        .distinctUntilChanged()
        .map { ($0.utf8.count &gt; 5) || ($0.utf8.count == 0) }
    }
}

var usernameBorderColor : Observable&lt;UIColor&gt;!
var passwordBorderColor : Observable&lt;UIColor&gt;!

var credentialValid : Driver&lt;Bool&gt; {
    return Driver.combineLatest(usrValid, pwdValid) { usr, pwd in
        return (usr &amp;&amp; pwd)
    }
}
</code></pre>

<p>Someone can help me with this?
Thanks</p>
","1870602","","","","","2016-08-22 13:25:22","call method only on rx_tap event","<swift><rx-swift>","1","2","","","","CC BY-SA 3.0"
"38959169","1","","","2016-08-15 16:37:23","","0","479","<p>I'm working on my own OAuth2 implementation using RxSwift. In order to authenticate a request I have an Authenticator that fetches and stores the access token. So if I have a valid access token, the Authenticator will return it right away otherwise it will perform a request to the server. That's exactly what <code>accessTokenRequest()</code> does.</p>

<pre><code>request = authenticator
            .accessTokenRequest()
            .map(toAuthorizationHeader)
            .flatMap {self.actualRequest(withEndpoint: endpoint, authHeader: $0)}
</code></pre>

<p>The problem is that when I have multiple requests requesting authentication and no valid access token stored, the Authenticator will make multiple access token requests as well. This is not desirable, as ideally only the first access token request should be performed and all the subsequent requests should wait until the Authenticator finishes fetching the access token.</p>

<p>Basically I would like to serialize the function <code>accessTokenRequest()</code>, much like a critical region.</p>

<p>Any ideas on how to achieve this?</p>

<p>Thanks a lot!</p>

<p><strong>UPDATE</strong></p>

<p>This is the simplified content of the <code>accessTokenRequest()</code> function</p>

<pre><code>func accessTokenRequest() -&gt; Observable&lt;OAuth2Credential&gt; {
    if let credential = self.cachedCredential where !credential.isExpired  {

        // All subsequent requests should already enter here and return right away

        return Observable.just(credential)
    }

    ...

    // First request should reach here and request access token from the server.

    return NetworkClient.AccessToken()
            .doOnNext(cacheCredential)
}
</code></pre>
","734702","","734702","","2016-08-16 17:26:23","2017-01-19 10:08:40","Serialize RxSwift","<concurrency><rx-swift>","1","3","","","","CC BY-SA 3.0"
"38969328","1","38969849","","2016-08-16 07:49:48","","17","9982","<p>I want to cancel a request and one of the ways is to manually remove the disposable bag.</p>

<pre><code>.addDisposableTo(disposeBag)
</code></pre>

<p>As I have the disposeBag object, is there a good way to cancel the request other than that I mentioned above?</p>
","5615274","","","","","2016-08-18 01:15:32","Manually disposing a DisposeBag in RxSwift","<swift><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"39005943","1","","","2016-08-17 20:43:00","","3","434","<p>While creating reactive extensions for my networking layer I've noticed some <em>patterns</em> which I'd like to extract just to simplyfy my logic for future implementations... So what I have right now is a couple of methods similiar to this one:</p>

<pre><code>static func create(params: [ String: AnyObject ]) -&gt; Observable&lt;Type&gt; {
    return Observable&lt;Type&gt;.create { observer -&gt; Disposable in
        let request = Alamofire.request(TypeAPI.Create(params: params).responseJSON { response in
            switch response.result {
            case .Success(let value):
                guard response.response?.statusCode != 409 else {
                    observer.onError(RequestError.TypeAlreadyExists)
                    return
                }

                guard let dict = value as? [ String: AnyObject ] else {
                    observer.onError(RequestError.ParsingError)
                    return
                }

                guard let parsedType: Type = try? Unbox(dict) else {
                    observer.onError(RequestError.MappingError)
                    return
                }

                observer.onNext(parsedType)
            case .Failure(let error):
                observer.onError(RequestError.convert(error))
            }
        }

        return AnonymousDisposable {
            request.cancel()
        }
    }
}
</code></pre>

<p>And for example <code>AnonymousDisposable</code> thing is always repeating.
I've looked at <code>RxAlamofire</code> implementation and their <a href=""https://github.com/RxSwiftCommunity/RxAlamofire/blob/develop/RxAlamofire/Source/RxAlamofire.swift#L338"" rel=""nofollow""><code>rx_request</code> method</a> is basically following pretty familiar pattern, but I'm a bit stuck when I try to actually use <code>RxAlamofire</code> with my current wrapper. So far I've ended with something like:</p>

<pre><code>static func rx_create(params: [ String: AnyObject ]) -&gt; Observable&lt;Type&gt; {
    let manager: Manager = Manager.sharedInstance
    manager.rx_request { manager -&gt; Request in
        return Alamofire.request(TypeAPI.Create(params: params))
    }
}
</code></pre>

<p>But <code>rx_request</code> returns <code>Observable&lt;Request&gt;</code> and I need <code>Observable&lt;Type&gt;</code>. If I go and add <code>.flatMap</code> than I'll finish with <code>AnonymousDisposable</code> again...</p>

<p>Any suggestions what's the right approach? Am I somewhere near at least? Or am I going completely wrong direction?</p>
","1911042","","1911042","","2016-08-17 20:49:34","2016-08-18 20:39:43","Creating reactive wrapper around networking","<swift><alamofire><reactive-programming><rx-swift><reactivex>","1","0","1","","","CC BY-SA 3.0"
"39013307","1","","","2016-08-18 08:26:51","","1","506","<p>I'm trying to achieve the following: </p>

<pre><code>let reachedTopMostMessage = PublishSubject&lt;Int?&gt;()
reachedTopMostMessage.startWith(nil).subscribeNext { (_) in
    //
}
</code></pre>

<p>But the compiler complains with this error:</p>

<blockquote>
  <p>'Int?' (aka 'Optional') is not convertible to '(Int?...)' (aka
  '(Optional...)')</p>
</blockquote>

<p>What is wrong with this?</p>
","5424345","","343299","","2016-08-18 17:36:37","2016-08-18 17:36:37","RxSwift PublishSubject of type Optional<Any type> startWith nil","<swift><frp><rx-swift>","1","0","0","","","CC BY-SA 3.0"
"39047603","1","39048097","","2016-08-19 21:00:48","","5","3661","<p>I am willing to force a reload of a <code>collectionView</code> when new content is fetched from a web-service while using <code>RxSwift</code>. I can't figure out why I don't receive an event on newContent with the following code when my onComplete closure is properly called.</p>

<pre><code>class ListingView : UIView {

    var newContentStream: Observable&lt;Bool&gt;?
    let disposeBag = DisposeBag()

    @IBOutlet weak var collectionView: UICollectionView!

    weak var viewModel: ListingViewModel?

    func bind(viewModel: ListingViewModel) {
        self.viewModel = viewModel
    }

    func configure() {
        guard let viewModel = self.viewModel else { return }

        self.newContentStream = viewModel.newContent.asObservable()
        self.newContentStream!.subscribeNext { _ in
            self.collectionView.reloadData()
        }
        .addDisposableTo(self.disposeBag)
    } 
}
</code></pre>

<p>and then within my viewModel:</p>

<pre><code>class ListingViewModel {
    let dataSource = ListingViewDataSoure()
    var newContent = Variable(false)

    func mount() {
        let onComplete : ([item]? -&gt; Void) = { [weak self] items  in
            self?.dataSource.items = items
            self?.newContent = Variable(true)
        }

        guard let URL = API.generateURL() else { return }
        Requestor.fetchAll(onComplete, fromURL: URL)
    }
}
</code></pre>
","997084","","997084","","2016-08-19 21:43:03","2016-08-19 21:56:23","How to configure a Bool Stream in RxSwift","<ios><swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"39050059","1","39057793","","2016-08-20 03:04:49","","18","15777","<p>How should I merge 2 different types of <code>Observable</code>s in RxSwift?</p>

<p>For example:</p>

<pre><code>var a: Observable&lt;Int&gt;
var b: Observable&lt;Void&gt;
</code></pre>

<p><code>Observable.of(a,b).merge()</code> is not possible because of type parameter difference.</p>
","5424345","","343299","","2016-08-20 19:11:16","2020-02-24 14:57:34","RxSwift merge different kind of Observables","<swift><frp><rx-swift>","2","0","2","","","CC BY-SA 3.0"
"39069011","1","39088998","","2016-08-21 21:26:00","","2","786","<p>I've been looking at options for persistence when using RxSwift and Realm was looking attractive due to it's relative simplicity and the availability of some extensions in the community repo.</p>

<p>Unfortunately although I can get Realm and RxSwift working nicely in Xcode 8b6, things of seriously wrong as soon as you try to connect them together as RxRealm does not currently compile (there seems to be more going wrong with it than the Grand Renaming as far as I can tell). </p>

<p>Is there a workaround that is reliable? I can't believe for a moment that there isn't, I just can't find a resource at present. I was thinking of converting the Result object into an Set or Array and making this Observable but. I'm not sure if the contents (Realm Objects) are going to be handled correctly. Knowing my luck, I suspect not!</p>
","2733214","","","","","2016-08-22 21:26:55","Realm and RxSwift connectivity","<realm><swift3><rx-swift>","1","0","","","","CC BY-SA 3.0"
"39079491","1","39122988","","2016-08-22 12:24:04","","24","17249","<p>I'w wonder is there any code example for <code>RxSwift</code> when I can use multiple custom cells inside one table view. So for example I have two section and first section has 10 cells with type <code>CellWithImage</code> identifier and second section has 10 cells with type <code>CellWithVideo</code> identifier. </p>

<p>All tuts and code examples which I've founded are using only one cell type, for instance <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/SimpleTableViewExample/SimpleTableViewExampleViewController.swift"">RxSwiftTableViewExample</a></p>

<p>Thanks for any help</p>
","1290161","","","","","2020-08-10 05:42:36","RxSwift table view with multiple custom cell types","<ios><swift><uitableview><swift2><rx-swift>","3","0","3","","","CC BY-SA 3.0"
"39110710","1","","","2016-08-23 21:09:22","","0","1118","<p>I'm trying to use Action / CocoaAction library.
The primary usage for now is to show an UIAlertController and when an UIAlertAction button is tapped it has to call a function defined in my viewModel (changeAddress that returns an Observable).</p>

<p>My understanding of this would be:</p>

<pre><code>let ac = CocoaAction(workFactory: {[unowned self] _ in
    self.viewModel!.requestChangeAddress()
        .subscribeNext({ [unowned self] data in
            if let response = data?.result
            {
                self.showResultOperation(response)
            }
        })
        .addDisposableTo(self.disposeBag)
        return .empty()
    })

let OKAction = UIAlertAction.Action(""OK"", style: .Default)
OKAction.rx_action = ac
</code></pre>

<p>But unfortunately it doesn't work. The workFactory closure is correctly called but the subscription doesn't take effect. I know something is wrong when I return .empty but I cannot understand how to solve.</p>

<p>How can I correct this? What I'm doing wrong?</p>
","1870602","","6296561","","2018-10-05 13:04:28","2018-10-05 13:04:28","CocoaAction / Action with UIAlertController","<swift><uialertcontroller><rx-swift><rx-cocoa>","1","0","1","","","CC BY-SA 4.0"
"39115360","1","39149771","","2016-08-24 05:51:14","","4","3441","<p>In purpose of education MVVM and RxSwift I want to build simple search screen, which will have a table view and a search bar. When user types something into the search bar I will show what he have in this table. Sounds pretty simple, but I can't find any tutorial which suits me.</p>

<p>I have already written all code in view controller, I just can't understand have to observe search text changes and then call database method, which will filter items by search text.</p>

<p>Some code, which I already have.</p>

<p>My ViewController</p>

<pre><code>import Foundation
import UIKit
import RxSwift
import RxCocoa

class PlaceSearchViewController: UIViewController {

    //MARK: - 

    @IBOutlet weak var searchBar: UISearchBar!
    @IBOutlet weak var tableView: UITableView!

    //MARK: - Dependencies

    private var viewModel: PlaceSearchViewModel!
    private let disposeBag = DisposeBag()

    //MARK: - Lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()

        viewModel = PlaceSearchViewModel()
        addBindsToViewModel(viewModel)
    }

    //MARK: - Rx

    private func addBindsToViewModel(viewModel: PlaceSearchViewModel) {

        searchBar.rx_text.bindTo(viewModel.searchTextObservable)

        viewModel.placesObservable.bindTo(tableView.rx_itemsWithCellFactory) {
            (tableView: UITableView, index, place: Place) in

            let indexPath = NSIndexPath(forItem: index, inSection: 0)
            let cell = tableView.dequeueReusableCellWithIdentifier(""Cell"", forIndexPath: indexPath) as PlaceCell

            cell.configureWithObject(place)

            return cell

            }
            .addDisposableTo(disposeBag)

        tableView.rx_contentOffset
            .subscribe { _ in
                if self.searchBar.isFirstResponder() {
                    _ = self.searchBar.resignFirstResponder()
                }
            }
            .addDisposableTo(disposeBag)
    }
}
</code></pre>

<p>And my view model:</p>

<pre><code>import Foundation
import RxSwift
import RxCocoa

class PlaceSearchViewModel {

    //MARK: - Dependecies
    private let disposeBag = DisposeBag()

    //MARK: - Model

    private let placesObservable: Observable&lt;[Place]&gt;
    var searchTextObservable = Variable&lt;String&gt;("""")

    //MARK: - Set up

    init() {

        placesObservable = searchTextObservable.asObservable()
            //wait 0.3 s after the last value to fire a new value
            .debounce(0.3, scheduler: MainScheduler.instance)
            //only fire if the value is different than the last one
            .distinctUntilChanged()
            //convert Observable&lt;String&gt; to Observable&lt;[Place]&gt;
            .flatMapLatest { searchString -&gt; Observable&lt;[Place]&gt; in

                // some code here which I can't write.

            }
            //make sure all subscribers use the same exact subscription
            .shareReplay(1)
    }

}
</code></pre>

<p>Also, I have method <code>[DataBase searchPlaces:searchText]</code> which returns array of places - <code>[Place]</code>. I can't understand where and how place it in <code>flatMapLatest</code> of my ViewModel.</p>
","1150441","","","","","2016-08-25 15:54:23","MVVM and RxSwift for Search Screen","<ios><uitableview><mvvm><uisearchbar><rx-swift>","1","3","","","","CC BY-SA 3.0"
"39119601","1","39805775","","2016-08-24 09:36:59","","1","4279","<p>I am writing a simple <a href=""https://en.wikipedia.org/wiki/Diceware"" rel=""nofollow noreferrer"">Diceware</a> password generator to experiment with RxSwift.
I am struggling with using <code>flatMap</code> and <code>reduce</code> in separate steps.</p>

<p><strong>Current code</strong></p>

<p>I have an observable <code>wordCount</code> that is bound to the <code>UIStepper</code> value and generate a new password with a given number of words.</p>

<p><a href=""https://i.stack.imgur.com/8vMZz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8vMZz.png"" alt=""enter image description here""></a></p>

<pre><code>    let rawPassword = wordCount
        .asObservable()
        .map { wordCount in
            self.rollDice(numberOfDice: wordCount)
                .map { numbers in wordMap[numbers]! }
        }
</code></pre>

<p><code>rollDice</code> returns an <code>Observable&lt;String&gt;</code> (for example: <code>[""62345"", ""23423"", ""14231"", ...]</code>) and is then mapped to words.</p>

<p><code>rawPassword</code> is an <code>Observable&lt;Observable&lt;String&gt;&gt;</code></p>

<p>In this example, it would be: <code>[[""spec"", ""breed"", ""plins"", ""wiry"", ""chile"", ""cecil""]]</code>.</p>

<p>I then have a <code>reducedPassword</code> which <code>flatMap</code> and <code>reduce</code> to a <code>String</code>:</p>

<pre><code>    let reducedPassword = rawPassword
        .flatMap { raw in
            raw.reduce("""") { prev, value in
                let separator = ""-""
                return prev == """" ? value : ""\(prev)\(separator)\(value)""
            }
    }
</code></pre>

<p>This works and I end up with the string: <code>spec-breed-plins-wiry-chile-cecil</code>.</p>

<p><strong>The problem</strong></p>

<p>Now I want to change the word separator from the UI. I just want to re-apply the reduce on my <code>rawPassword</code> when the text from the <code>UITextField</code> is updated.</p>

<p>I am trying to use <code>combineLatest</code> to combine the <code>Observable&lt;String&gt;</code> for the separator with my <code>Observable&lt;Observable&lt;String&gt;&gt;</code> <code>rawPassword</code>, like this:</p>

<pre><code>    let reducedPassword = Observable.combineLatest(rawPassword, separator.asObservable()) { raw, sep in
        raw.reduce("""") { prev, value in
            return prev == """" ? value : ""\(prev)\(sep)\(value)""
        }
    }
</code></pre>

<p>But the <code>reduce</code> never fires and clicking the stepper does nothing.
I have tried to <code>flatMap</code> in a separate step but then, with <code>combineLatest</code> I only end up with the last word. Is <code>combineLatest</code> the right approach at all? </p>
","6643055","","6643055","","2016-08-24 10:38:56","2016-10-01 11:18:18","RxSwift: Need help using flatMap and reduce","<ios><swift><rx-swift>","1","3","4","","","CC BY-SA 3.0"
"39120624","1","39123102","","2016-08-24 10:21:57","","3","2133","<p>How to create Observable which streams an event repeatedly while a button holds down?</p>
","2053939","","","","","2019-04-06 14:14:06","RxSwift: Observable while a button holds down","<swift><rx-swift>","2","0","4","","","CC BY-SA 3.0"
"39138681","1","","","2016-08-25 07:00:52","","2","1047","<p>I was looking at those two:</p>

<ul>
<li><a href=""http://sapandiwakar.in/refresh-oauth-tokens-using-moya-rxswift/"" rel=""nofollow noreferrer"">http://sapandiwakar.in/refresh-oauth-tokens-using-moya-rxswift/</a></li>
<li><a href=""https://stackoverflow.com/questions/38281760/using-retrywhen-to-update-tokens-based-on-http-error-code"">Using retryWhen to update tokens based on http error code</a></li>
</ul>

<p>And trying to create <em>similiar</em> thing, but without Moya, using Alamofire + RxSwift.</p>

<p>First of all is obviously where should I stick this, since my implementation is divided into a couple smaller parts.
First of all I have my custom method for generating <strong>reactive</strong> requests:</p>

<pre><code>static func rx_request&lt;T&gt;(requestConvertible: URLRequestConvertible, completion: (Request) -&gt; Observable&lt;T&gt; ) -&gt; Observable&lt;T&gt; {
    let manager: Manager = Manager.sharedInstance
    return manager
        .rx_request { manager -&gt; Request in
            return Alamofire.request(requestConvertible)
        }
        .flatMap { request -&gt; Observable&lt;T&gt; in
            return completion(request)
        }
        .shareReplay(1)
}
</code></pre>

<p>Which is later used by specific <code>Request</code>s convenience classes. For example my <code>UserRequests</code> has this private extension to extract some common code from it's methods:</p>

<pre><code>private extension Request {

    func rx_userRequest() -&gt; Observable&lt;User&gt; {
        return self
            .validate()
            .rx_responseJSON()
            .flatMap{ (request, json) -&gt; Observable&lt;User&gt; in
                guard
                    let dict = json as? [ String: AnyObject ],
                    let parsedUser: User = try? Unbox(dict) else {
                        return Observable.error(RequestError.ParsingError)
                }

                return Observable.just(parsedUser)
            }
            .rx_storeCredentials()
    }

}
</code></pre>

<p>Because of how things looks like I wonder whare's the <em>right</em> place to put a <code>retry</code> method and also how to implement it? Because depending on the location I can get different input arguments.</p>
","1911042","","-1","","2017-05-23 12:08:31","2016-08-27 12:45:06","Alamofire retry request - reactive way","<swift><alamofire><rx-swift><reactivex>","1","0","","","","CC BY-SA 3.0"
"39183323","1","","","2016-08-27 16:28:48","","0","123","<p>When I add an execution line in the flatmap function, it causes the whole 
sequence to fail compilation.</p>

<p>The error is:</p>

<pre><code>error: generic parameter 'O' could not be inferred
  }.addDisposableTo(DisposeBag())
</code></pre>

<p>Example: </p>

<pre><code>private func askPayment(question: String) -&gt; Observable&lt;Void&gt; { return Observable.just() }
private func askQuestion(question:String) -&gt; Observable&lt;Int&gt; {return Observable.just(9) }

askPayment(""xxx"")
  .flatMapLatest { _ in return
    Observable.just()
  }.flatMapLatest { _ in
    // the offending line
    print (""this causes an error"")
    return askQuestion(""xxx"")
  }.subscribeNext{ q in
    print (""subscribed"")
  }.addDisposableTo(DisposeBag())
</code></pre>

<p>It does not appear to matter even when i add more type declaration. </p>
","180663","","","","","2016-08-28 17:44:58","Adding a execution line in flatmap causes the sequence to fail compilation","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"39184148","1","39215786","","2016-08-27 17:58:09","","1","1156","<p>I'm using RxSwift to wrap a mobile app's server sync process. I have an <code>Observable&lt;RemoteEvent&gt;</code> that wraps a websocket connection and emits each message received as an <code>Event</code>. Similarly, I have an <code>Observable&lt;SynchronizationResult&gt;</code> that wraps an API sync process. Once my application opens the WebSocket connection, the server sends a <code>hello</code> message. After that message is received, I want to start the sync process and buffer any events until the sync is completed. This is where I'm struggling. Currently, I have:</p>

<pre><code>self.eventStreamService.observe(connection).scan((nil, [])) { (state, event) -&gt; (Observable&lt;RemoteEvent&gt;?, [RemoteEvent]) in
  guard event.type == ""hello"" else {
    return (state.0?.concat(Observable.just(event)), state.1 + [event])
  }

  // This is the sync operation
  return (
    self.synchronizationService
      .synchronize(ConnectionSynchronizationContext(connection: connection), lightweight: true)
      .toArray()
      .flatMap { results -&gt; Observable&lt;RemoteEvent&gt; in
        (state.1 + [event]).toObservable()
      },
    []
  )
}
.flatMapLatest { $0.0 ?? Observable.empty() }
</code></pre>

<p>Despite this being fairly ugly, it also has a significant bug: <em>any</em> incoming event results in the synchronization <code>Observable</code> being re-subscribed to, which then restarts the whole sync process. I'm sure there must be a better way to do this.</p>
","683077","","343299","","2016-08-29 21:56:31","2016-08-29 21:56:31","Buffer Observable Until Another Observable Completes","<swift><rx-swift><reactivex>","1","4","1","","","CC BY-SA 3.0"
"39185109","1","","","2016-08-27 19:46:37","","6","7590","<p>I'm using Moya with RxSwift for networking in an iOS app, and I'd like to be able to consume my API's custom error responses when my <code>Observer</code>s get calls to <code>onError</code>.</p>

<p>The API always returns error responses in the following JSON format:</p>

<pre><code>{
   ""error"": {
      ""message"": ""Error message goes here"",
      ""code"": ""String error code""
   }
}
</code></pre>

<p><strong>The goal is to achieve something similar to the following code snippet, where the error passed in <code>onError</code> is my custom error type instead of the <code>Moya.Error</code> type:</strong></p>

<pre><code>observable
    .subscribe(
        onNext: { response in
            // Do typical onNext stuff
        },
        onError: { error in
            // Get and consume my custom error type here:
            let customError = error as! MyCustomErrorModel
            print(""My API's error message: \(customError.error?.message)"")
            print(""My API's error code: \(customError.error?.code)"")
        })
</code></pre>

<p>I'm able to successfully intercept and deserialize these errors into my custom error model using a custom <code>PluginType</code> (pasted below, from <a href=""https://stackoverflow.com/questions/34706689/how-to-handle-the-response-of-all-types-of-requests-in-one-handler-but-also-uni"">this SO question</a>), but I do not know how to finally pass these models along to the <code>Observer</code>. </p>

<pre><code>import Foundation
import Moya
import ObjectMapper
import Result

struct CustomAPIErrorPlugin: PluginType {

// Called immediately before a request is sent over the network (or stubbed).
func willSendRequest(request: RequestType, target: TargetType) { }

// Called after a response has been received, but before the MoyaProvider has invoked its completion handler.
func didReceiveResponse(result: Result&lt;Moya.Response, Moya.Error&gt;, target: TargetType) {
    let responseJSON: AnyObject
    if let response = result.value {
        do {
            responseJSON = try response.mapJSON()
            if let errorResponse = Mapper&lt;MyCustomErrorModel&gt;().map(responseJSON) {
                print(""Custom error code from server: \(errorResponse.error?.code)"")
            }
        } catch {
            print(""Failure to parse JSON response"")
        }
    } else {
        print(""Network Error = \(result.error)"")
    }
}
</code></pre>
","6451462","","-1","","2017-05-23 11:46:55","2017-04-20 17:43:43","Custom Error Response Handling with Moya + RxSwift","<ios><swift><rx-swift><objectmapper><moya>","1","0","5","","","CC BY-SA 3.0"
"39214669","1","39305426","","2016-08-29 20:27:56","","1","1084","<p>I want to make a simple long polling request with RxSwift which may be the similar to RxJava code below:</p>

<pre><code>api.loadHotels(searchRequest)
    .repeatWhen(obs -&gt; observable.delay(3, TimeUnit.SECONDS))
    .takeUntil(searchResponse -&gt; searchResponse.isCompleted)
    .subscribe(listener::hotelListLoaded);
</code></pre>

<p>In RxSwift, there is a <a href=""https://github.com/RxSwiftCommunity/RxSwiftExt/issues/38"" rel=""nofollow"">repeatWhen</a> operator that takes an ObservableConvertibleType as a parameter, not passing the chained Observable to its closure as an argument, unlike its synonym in RxJava.</p>

<p>What I expected in RxSwift: <code>api.loadHotels(searchRequest).repeatWhen{result -&gt; ObservableConvertibleType}</code> so I can write the exact same logic as RxJava code. But I cannot achieve this. Because it is only as <code>api.loadHotels(searchRequest).repeatWhen(ObservableConvertibleType)</code> The exact same thing applies for RxSwift's <code>takeUntil</code> operator.</p>

<p>However I also tried:
<a href=""https://github.com/RxSwiftCommunity/RxSwiftExt/issues/38"" rel=""nofollow"">repeatWhen operator in RxSwift</a> and
<a href=""https://github.com/ReactiveX/RxSwift/issues/396"" rel=""nofollow"">repeatWhen substituter in RxSwift</a></p>

<p>So my question is: how can I achieve the same logic in RxSwift as the given RxJava code? Am I getting the workflow of current <code>repeatWhen</code> and <code>takeUntil</code> operators of RxSwift wrong?</p>
","3408316","","343299","","2016-09-03 09:38:00","2016-09-03 09:38:00","Long Polling with RxSwift","<swift><operators><rx-java><long-polling><rx-swift>","1","0","","","","CC BY-SA 3.0"
"39300143","1","39305256","","2016-09-02 20:18:18","","1","932","<p>I am trying to develop a pagination system in an iOS app using RxSwift. The use case is simple: the user can enter text in a search field and the app performs a request that is paginated. When he changes the value, a new request is performed on the first page (that means the value of the observable must be reseted to 1). If the user clears the search field (or enters a text with less than 2 characters), the list of results is cleared and the current page is reset. The next page is fetched when the user scrolls to the bottom of the list.</p>

<p>This is not a swift or iOS specific case and I suppose it could be written in an identical way using RxKotlin or RxJs or any other reactive extension.</p>

<p>My current attempt is to set up an observable for the text and a observable for the current page and to combine them in order to perform the request with both parameters.
I already succeeded in doing exactly what I am looking for but using global attributes for storing the current query and the current page. I would like to find a way to use only the values emitted by the observables without having to maintain them (I guess the code will be more concise and easy to read and understand).</p>

<p>Here is my current code : </p>

<pre><code>    // self.nextPage is a Variable&lt;Int&gt;
    let moreObs: Observable&lt;Int&gt; = self.nextPage.asObservable()
        .distinctUntilChanged() // Emit only if page has changed.

    // self.searchTextObservable is a PublishedSubject&lt;String&gt; that receives the values from the textfield
    let searchObs: Observable&lt;String&gt; = self.searchTextObservable
        .throttle(0.4, scheduler: MainScheduler.instance) // Wait 400ms when the user stops writing.
        .distinctUntilChanged() // Emit only if query has changed.

    self.resultsObservable = Observable
        .combineLatest(searchObs, moreObs) { query, page in
            return [""q"": query, ""p"": ""\(page)""]
        }
        .subscribeOn(MainScheduler.instance) // Emit on main thread.
        .observeOn(ConcurrentDispatchQueueScheduler(globalConcurrentQueueQOS: .Background)) // Perform on background thread.
        .map { params in
            if params[""q""]!.characters.count &gt; 2 {
                return params
            }
            return [:]
        }
        .flatMap { params in 
          return params.isEmpty ?
            Observable.of([]) :
            self.search(params)
        }
        .map { results in
            if results.count &gt; 0 {
                self.results.appendContentsOf(results)
            } else {
                self.results = []
            }
            return self.results
    }
</code></pre>

<p>So far, the only feature that does not work is the reset operation on the nextPage's value. If I force it to <code>1</code> when the searchObs emits: </p>

<pre><code>let searchObs: Observable&lt;String&gt; = self.searchTextObservable
        .throttle(0.4, scheduler: MainScheduler.instance) // Wait 400ms when the user stops writing.
        .distinctUntilChanged() // Emit only if query has changed.
        .map {query in
          self.nextPage.value = 1
          return query
        }
</code></pre>

<p>Then I have 2 requests that are performed.</p>

<p>Am I misusing Rx?</p>
","534192","","534192","","2016-09-05 08:24:09","2016-09-05 08:24:09","How to combine two observables in Reactive Extensions in order to paginate results?","<swift><reactive-programming><observable><rx-swift><reactivex>","1","0","","","","CC BY-SA 3.0"
"39305585","1","","","2016-09-03 09:52:29","","0","1473","<p>I'm new in RxSwift and Reactive programming. Here is my code:  </p>

<pre><code>let disposeBag = DisposeBag()
  let dartScore = PublishSubject&lt;Int&gt;()
  dartScore.asObserver()
    .scan(501, accumulator: {
      intermediate, newValue in
      var result = intermediate - newValue
      return result &gt;= 0 ? result : intermediate
    })
    .do(onNext: {
      if $0 == 0 {
        dartScore.onCompleted()
      }
    })
    .subscribe(onNext:{print($0)}, onCompleted:{print(""Game over"")})
    .addDisposableTo(disposeBag)

  dartScore.onNext(13)
  dartScore.onNext(60)
  dartScore.onNext(50)
  dartScore.onNext(0)
  dartScore.onNext(0)
  dartScore.onNext(378)
</code></pre>

<p>You may notice <code>dartScore.asObserver()</code>. If I remove <code>.asObserver()</code> or replace it with <code>.asObservable()</code>, the end results are the same:</p>

<pre><code>488
428
378
378
378
Game over
</code></pre>

<p>Can anybody help to explain what the difference is between <code>asObserver</code>, <code>asObservable</code> or nothing which is a normal <code>observable</code> object) in <code>Subject</code>?</p>
","118562","","","","","2016-09-03 10:23:03","What's the difference between asObserver, asObservable and none in RxSwift","<swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"39327800","1","","","2016-09-05 09:41:19","","1","1311","<p>I am using <a href=""https://github.com/Moya/Moya"" rel=""nofollow"">Moya</a> and <a href=""https://github.com/ivanbruel/Moya-ObjectMapper"" rel=""nofollow"">Moya-ObjectMapper</a> with Rxswift to make network requests.</p>

<p>My network request is below.</p>

<pre><code>let provider = RxMoyaProvider&lt;APIClient&gt;()

requestHospitalButton.rx_tap
    .withLatestFrom(hospitalCode)
    .flatMapLatest { [unowned self] code in
        self.provider.request(.Hospital(code: code))
     }
     .mapObject(Hospital)
     .subscribe { [unowned self] event in
         switch event {
         case .Next(let hospital):
             // success
         case .Error(let error):
             // error
         default: break
         }
     }
     .addDisposableTo(rx_disposeBag)
</code></pre>

<p>If the error occurs, then my hospital request <code>Observable</code> terminates and I can never make my hospital request again.</p>

<p>How can I retry my hospital request when the <code>requestHospitalButton</code> is tapped?</p>
","2053939","","343299","","2016-09-05 09:58:28","2016-09-05 09:58:28","Rxswift + Moya + Moya-ObjectMapper Error handling","<swift><rx-swift><reactivex><moya>","1","0","","","","CC BY-SA 3.0"
"39335889","1","39338084","","2016-09-05 18:21:57","","1","1418","<p>I'm starting to learn Swift and I'm implementing an Observable (using RxSwift) to simplify Network calls via AlamoFire in an OSX app. </p>

<p>Imports:</p>

<pre><code>import RxSwift
import RxCocoa
import Alamofire
</code></pre>

<p>Method:</p>

<p>The create identifier below is reporting:
<strong>Use of unresolved identifier <code>create</code></strong></p>

<pre><code>func getAPI(body: String) -&gt; Observable&lt;AnyObject?&gt; {
    return create { observer in
        let request = AlamoFireXMLPostRequest(body)
            .responseData(completionHandler: { request, response, data, error in
                if ((error) != nil) {
                    observer.on(.Error(error!))
                } else {
                    observer.on(.Next(getXMLfromFreshbooksResponse(response)))
                    observer.on(.Completed)
                }
            })
        return AnonymousDisposable {
            request.cancel()
        }
    }
}
</code></pre>

<p>CocoaPods:</p>

<pre><code># Uncomment this line to define a global platform for your project
# platform :ios, '9.0'
# Needed by SWXMLHash
source 'https://github.com/CocoaPods/Specs.git'
platform :osx, '10.10'

target 'Tractor Beam' do
  # Comment this line if you're not using Swift and don't want to use dynamic frameworks
  use_frameworks!

  # Pods for Tractor Beam
  pod 'Alamofire', '~&gt; 3.4'

  # Convert HTTP AF Responses to XML    
  pod 'AlamofireXmlToObjects'
  pod 'SWXMLHash', '~&gt; 2.5.0'

  # Rx
  pod 'RxSwift', '~&gt; 2.6.0'
  pod 'RxCocoa', '~&gt; 2.6.0'

  target 'Tractor BeamTests' do
    inherit! :search_paths
    # Pods for testing
  end

  target 'Tractor BeamUITests' do
    inherit! :search_paths
    # Pods for testing
  end

end

#post_install do |installer|
#    installer.pods_project.targets.each do |target|
#        target.build_configurations.each do |config|
#            config.build_settings['SWIFT_VERSION'] = '3.0'
#            config.build_settings['MACOSX_DEPLOYMENT_TARGET'] = '10.10'
#        end
#    end
#end
</code></pre>
","4797412","","","","","2016-09-05 21:50:14","Swift use of unresolved identifier `create` in RxSwift","<swift><macos><rx-swift>","1","0","","","","CC BY-SA 3.0"
"39356720","1","39364332","","2016-09-06 19:46:48","","5","4817","<p>I use the following setup to retrieve objects (e.g. GitHub issues) from an API. This works fine.</p>

<pre><code>let provider: RxMoyaProvider&lt;GitHub&gt;
let issues: Driver&lt;[IssueViewModel]&gt;

init(provider: RxMoyaProvider&lt;GitHub&gt;) {
    self.provider = provider
    issues = provider.request(.Issue)
              .mapArray(Issue.self, keyPath: ""issues"")
              .asDriver(onErrorJustReturn: [])
              .map { (models: [Issue]) -&gt; [IssueViewModel] in
                  let items = models.map {
                      IssueViewModel(name: $0.name,
                          description: $0.description
                      )
                  }
                  return items
              }
}
</code></pre>

<p>Now I'd like to periodically update the list of issues (e.g., every 20 seconds). I thought about an <code>NSTimer</code> to accomplish this task, but I guess there might be a clean(er) solution (i.e. in a Rx manner) that I didn't think about.</p>

<p>Any hint in the right direction is highly appreciated.</p>
","184245","","184245","","2016-09-16 08:04:43","2016-09-16 08:04:43","Updating periodically with RxSwift","<ios><swift><rx-swift><reactivex><moya>","2","0","5","","","CC BY-SA 3.0"
"39384958","1","39386409","","2016-09-08 07:27:52","","0","94","<p>I want to create a cold observable that would only start doing expensive operation if there is an actual subscription.  <code>ReplaySubject</code> would fit nicely except for the part that I need to be able to start an expensive background operation when the actual subscription is made and not on create of the observable.  Is there a way to do so?  Some sort of <code>onSubscribed { ... }</code> method.</p>
","1542569","","343299","","2016-09-08 08:46:06","2016-09-08 08:46:06","Is it possible to make `ReplaySubject` to run a closure on being subscribed to?","<swift><rx-swift><reactivex>","1","3","","","","CC BY-SA 3.0"
"39441030","1","39445825","","2016-09-11 21:58:25","","11","18904","<p>I'm looking for something like this:</p>

<pre><code>let observable = PublishSubject&lt;String&gt;()
observable.onNext(""1"")
observable.onCompleted()

_ = observable.subscribeNext { s in
    print(s)
}
</code></pre>

<p>So I want to subscribe to the Observable after it has already been completed and still get the values (or just the last value).</p>
","1116465","","343299","","2016-09-12 07:41:44","2016-09-12 08:04:39","Subscribe to last value after completed on RxSwift PublishSubject","<swift><rx-swift><reactivex>","1","0","1","","","CC BY-SA 3.0"
"39450565","1","39450626","","2016-09-12 12:40:40","","15","10615","<p>I create an observable using the following code:</p>

<pre><code>let disposeBag = DisposeBag()

let myJust = { (element: String) -&gt; Observable&lt;String&gt; in
    return Observable.create { observer in
        observer.on(.next(element))
        //observer.on(.completed)
        return Disposables.create()
    }
}
</code></pre>

<p>That code comes from RxSwift's sample code. </p>

<p>If I create an empty Observable <code>myJust</code>, and later I try to send it a value:</p>

<pre><code>myJust(""🔴"").on(.completed)
</code></pre>

<p>I get the following error:</p>

<pre><code>error: value of type 'Observable&lt;String&gt;' has no member 'on'
</code></pre>
","4738084","","1810596","","2018-08-31 02:02:09","2018-08-31 02:02:09","How to manually send next signal to a observable in RxSwift?","<ios><swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"39458195","1","39465098","","2016-09-12 20:20:10","","4","4967","<p>If I have something that looks like this:</p>

<pre><code>  func foo() -&gt; Observable&lt;Foo&gt; {
    return Observable.create { observer in
      // ...
    }
  }

  func bar() {
    foo().observeOn(MainScheduler.instance)
      .subscribeNext {
        // ...
      }
      .addDisposableTo(disposeBag)
  }
</code></pre>

<p>If I want to <a href=""http://reactivex.io/RxJava/javadoc/rx/Subscription.html#unsubscribe()"" rel=""nofollow"">unsubscribe</a> from the observable later on in <code>bar</code>, how would I do that?</p>

<p><strong>Update</strong></p>

<p>I'm aware I can call <code>dispose</code>, but according to the <a href=""https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#disposing"" rel=""nofollow"">RxSwift docs</a>:</p>

<blockquote>
  <p>Note that you usually do not want to manually call dispose; this is only educational example. Calling dispose manually is usually a bad code smell.</p>
</blockquote>

<p>So is <code>unsubscribe</code> just not implemented?  I've gone spelunking through the RxSwift code, and to the extent that I can understand what's going on, it doesn't look like the <code>Disposable</code> that is returned from the subscribe methods is ever anything with useful functionality (other than disposing).</p>
","74815","","74815","","2016-09-13 16:12:44","2020-01-20 11:59:38","How do I unsubscribe from an observable?","<swift><rx-swift>","5","0","","","","CC BY-SA 3.0"
"39476874","1","39484814","","2016-09-13 18:35:23","","1","533","<p>I've seen the <code>&gt;-</code> operator in various code fragments involving RxSwift (e.g. <a href=""https://github.com/ReactiveX/RxSwift/issues/35"" rel=""nofollow"">https://github.com/ReactiveX/RxSwift/issues/35</a>), but can't find any documentation on it. What does it mean?</p>

<p>Here's an example:</p>

<pre><code>combineLatest(emailIsValid, passwordIsValid)
    &gt;- and
    &gt;- signupButton.rx_subscribeEnabledTo
    &gt;- disposeBag.addDisposable
</code></pre>
","1008891","","343299","","2016-09-14 07:31:55","2016-12-08 12:20:11","What does the >- operator mean in RxSwift and where is it documented?","<ios><swift><reactive-programming><rx-swift><reactivex>","1","0","","","","CC BY-SA 3.0"
"39553432","1","","","2016-09-18 02:16:09","","1","385","<p>I'm trying to figure out how I can retry an API call at the ViewController layer when dealing with an RxSwift stream. I understand that I can either wrap my errors in an <code>Element</code> or I can return a stream <code>Error</code>. In either case, it's not at all clear how I can ""retry"" the operation the discretion of the user (e.g. after putting up an alert).</p>

<p>If I wrap the error, how can/should I communicate back ""down"" to the API layer to attempt a retry?  If I don't wrap the error, I have two questions:
1) How can I make the <code>retry</code> conditional on the user's response to the alert? and
2) How can/should I ""re-initialize"" the stream?</p>

<p>The only thing I've been able to come up with is passing back a ""retry subject"" with the error and having the view controller indicate the retry request by emitting something on the associated observable (i.e. assign a value to the subject) which would in term be associated with the API stream. That seems awfully convoluted, however.</p>

<p>More generally, I'd appreciate any references to helpful literature on the subject of application error handling with streams/observables. I feel like I have a pretty good grasp of the RxSwift objects and operators and how to handle the ""happy path"" situation, but it's just not clear to me how to robustly handle errors in the context of continuously running application.</p>
","1008891","","","","","2016-09-25 18:32:51","How to display and recover from API errors in ViewController when using RxSwift","<ios><uiviewcontroller><error-handling><rx-swift><reactivex>","1","0","0","","","CC BY-SA 3.0"
"39554305","1","","","2016-09-18 05:02:55","","2","610","<p>I am encountering a lot of my users complaining about their app freezing, and I suspect it is due to the network requests.</p>

<p>It has been hard to reproduce tho, but my solution has been to add a subscribeOn and observeOn to my custom mapArray function, which is chained after the moya request but before any ui usage.</p>

<p>Questions:</p>

<ul>
<li>does this sequence of calling subscribeOn and observeOn make sense as an approach to solve the freezing issue?</li>
<li>it feels weird to be calling subscribeOn <em>after</em> the function to call, but i do not want to wrap my request in yet another dispatch block</li>
</ul>

<p>Overall, i am pretty confused by thread switching in Moya and Alamofire, and hoping someone can shine some light:</p>

<p>PS: I have read up the <a href=""https://github.com/Moya/Moya/issues/423"" rel=""nofollow"">issue in moya</a> discussing this, and it mentions that alamofire does the network call on the main thread, which is also confusing to me</p>

<p>PS2: this solution is also based on this <a href=""http://www.thedroidsonroids.com/blog/ios/rxswift-examples-4-multithreading/"" rel=""nofollow"">blog post</a>, but my question, besides the above ones, is why it might advocate for running the network call on a background thread when it does not appear to be the case for the Moya guys.</p>

<pre><code> // How the network call is 
 func load() -&gt; Observable&lt;Void&gt; {
    let apiProvider: RxMoyaProvider()
    return apiProvider.request(.GetFeed(page: 1))
      .mapArray(Question.self, keyPath: ""questions"")
      .doOnNext { questions, pagination in
        // updates the results to a variable, which is bound to the UI
        self.pagination = pagination
        self.data.value = questions
      }
      .flatMapLatest { _ in
        Observable.just()
      }
  }

 // My observable extension, a function to map responses to a 
extension ObservableType where E == Response {

  func mapObject&lt;T: Mappable&gt;(type: T.Type, keyPath: String) -&gt; Observable&lt;T&gt; {
    return
      // this makes sure that the beginning of the call is made on the background thread. but it can be changed later, so we need an observe on later on
      subscribeOn(ConcurrentDispatchQueueScheduler(globalConcurrentQueueQOS: .Background))
      .doOnError(networkFailureCallback)
      .filterSuccessfulStatusCodes()
      .handleUnauthorizedRequest()
        // this makes sure that the mapping happens on a background thread as well
      .observeOn(ConcurrentDispatchQueueScheduler(globalConcurrentQueueQOS: .Background))
      .flatMap { response -&gt; Observable&lt;T&gt; in
        return Observable.just(try response.mapObject(T.self, keyPath: keyPath))
      }
  }
}


// In my viewController
dataAccessor.load()
  .observeOn(MainScheduler.instance)
  .subscribe { error in
    // do actions
  }
  .addDisposableTo(self.disposeBag)
</code></pre>
","180663","","1173513","","2016-09-19 08:00:57","2016-09-19 08:00:57","Using observeOn and subscribeOn to solve my app freezing issue","<ios><multithreading><grand-central-dispatch><rx-swift><moya>","0","0","","","","CC BY-SA 3.0"
"39580085","1","","","2016-09-19 18:47:07","","7","9743","<p>I'm using <code>RxSwift</code> with my <code>UIViewController</code> that contains a <code>UICollectionView</code>. I have tried to add a header to my collection view but this is never called:  </p>

<pre><code>func collectionView(collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, atIndexPath indexPath: NSIndexPath)
</code></pre>
","1100641","","343299","","2016-09-20 07:59:40","2020-11-09 02:00:42","RxSwift and UICollectionView Header","<ios><swift><uicollectionview><rx-swift>","3","0","4","","","CC BY-SA 3.0"
"39583139","1","39589367","","2016-09-19 22:40:00","","2","569","<p>I have many subscriptions that update the UI, but I'd like to suspend them when the app goes in the background because they are still firing and updating parts of my view controller.</p>

<p>What is the best way to handle this to be conscious of memory and unnecessary UI updates in the background?</p>
","235334","","","","","2016-09-26 23:02:46","Suspend subscription for UI updates in the background and restart it on foreground?","<ios><swift><uikit><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"39583543","1","39645113","","2016-09-19 23:28:20","","12","9163","<p>I am starting my first RxSwift project for an iOS app and learning about reactive programming.</p>

<p>So far, the idea is quite simple, the user searches for films matching the search bar text, this fires a request that populates a UITableView with the results. Using tutorials and examples found online I've managed to implement this bit without too much trouble.</p>

<p>The tricky part comes when I'm trying to load the next page of results triggered by scrolling the bottom of the table view.</p>

<p>Here is the code used so far:</p>

<pre><code>public final class HomeViewModel: NSObject {

    // MARK: - Properties

    var searchText: Variable&lt;String&gt; = Variable("""")
    var loadNextPage: Variable&lt;Void&gt; = Variable()

    lazy var pages: Observable&lt;PaginatedList&lt;Film&gt;&gt; = self.setupPages()

    // MARK: - Reactive Setup

    fileprivate func setupPages() -&gt; Observable&lt;PaginatedList&lt;Film&gt;&gt; {
        return self.searchText
            .asObservable()
            .debounce(0.3, scheduler: MainScheduler.instance)
            .distinctUntilChanged()
            .flatMapLatest { (query) -&gt; Observable&lt;PaginatedList&lt;Film&gt;&gt; in
                return TMDbAPI.Films(withTitle: query, atPage: 0)
            }
            .shareReplay(1)
    }
}
</code></pre>

<p>Here is what I have so far: The observable <code>pages</code> is binded to my table view in <code>HomeViewController</code> and its search bar text is binded to <code>searchText</code>.</p>

<p>I'm using Alamofire to perform API calls behind the scenes, and <code>TMDbAPI.Films(withTitle: query)</code> returns an Observable of paginated lists.</p>

<p>Here is my model structure <code>PaginatedList</code> </p>

<pre><code>public struct PaginatedList&lt;T&gt; {

    // MARK: - Properties

    let page: Int
    let totalResults: Int
    let totalPages: Int
    let results: [T]

    // MARK: - Initializer

    init(page: Int, totalResults: Int, totalPages: Int, results: [T]) {
        self.page = page
        self.totalResults = totalResults
        self.totalPages = totalPages
        self.results = results
    }

    // MARK: - Helper functions / properties

    var count: Int { return self.results.count }

    var nextPage: Int? {
        let nextPage = self.page + 1
        guard nextPage &lt; self.totalPages else { return nil }
        return nextPage
    }

    static func Empty() -&gt; PaginatedList { return PaginatedList(page: 0, totalResults: 0, totalPages: 0, results: []) }
}

extension PaginatedList {

    // MARK: - Subscript

    subscript(index: Int) -&gt; T {
        return self.results[index]
    }
}
</code></pre>

<p>I am now looking for a reactive way to hook my <code>loadNextPage</code> variable to the observable of paginated lists in a way that it would trigger a request for the next page.
And when the search bar text changes it would reset the pagination to 0.</p>

<p>I believe the use of the operators <code>scan</code> and <code>concat</code> would be needed but I'm still not sure how...</p>

<p>Any suggestions on how to achieve this would be much appreciated...</p>
","1571197","","1571197","","2016-09-19 23:41:15","2016-09-22 17:15:15","Paginated API Calls with RxSwift","<swift><pagination><observable><rx-swift><reactivex>","2","0","7","","","CC BY-SA 3.0"
"39587996","1","39591955","","2016-09-20 07:20:51","","2","1502","<p>I'm using Moya for handling communication between my swift application and api, I'm able to post and get data but unable to post file to api server, following is my code</p>

<pre><code>enum TestApi {
    ...
    case PostTest(obj: [String: AnyObject])
    ...
}

extension TestApi: TargetType {

    var baseURL: NSURL {
        switch self {
            case .PostTest:
                return NSURL(string: ""http://192.168.9.121:3000"")!
        }
    }

    var path: String {
        switch self {
            case .PostTest:
                return ""/api/file""
        }
    }

    var method: Moya.Method {
        switch self {
            case .PostTest:
                return .POST
        }
    }

    var parameters: [String: AnyObject]? {
        switch self {
            case .PostTest(let obj):
                return [""image"": obj[""image""]!]
        }
    }

    var sampleData: NSData {
        return """".dataUsingEncoding(NSUTF8StringEncoding)!
    }

    var multipartBody: [MultipartFormData]? {
        switch self {
            case .PostTest(let multipartData):

                guard let image = multipartData[""image""] as? [NSData] else { return[] }

                let formData: [MultipartFormData] = image.map{MultipartFormData(provider: .Data($0), name: ""images"", mimeType: ""image/jpeg"", fileName: ""photo.jpg"")}
                return formData


            default:
                return []
        }
    }
}
</code></pre>

<p>and following is the way I called</p>

<pre><code>return testApiProvider.request(.PostTest(obj: _file)).debug().mapJSON().map({ JSON -&gt; EKResponse? in
    return Mapper&lt;EKResponse&gt;().map(JSON)
})
</code></pre>

<p>I dont receive no response and no hit was sent to the api server </p>
","2552551","","","","","2017-01-19 09:33:41","unable to upload file RXSwift Moya multipart","<swift><multipartform-data><rx-swift><moya>","2","0","1","","","CC BY-SA 3.0"
"39595019","1","39595748","","2016-09-20 13:09:05","","1","413","<p>RxSwift <code>toArray</code> is not working for me when using generics:</p>

<pre><code>struct SaveModelsCommand&lt;M&gt; where M:Model {

    let models:[M]

    func create() -&gt; Observable&lt;[M]&gt; {

        let cloudKitRecords:[CKRecord] = models.map({ 
            // convert models to CKRecords
            ... 
        })

        return SaveRecordsCommand(cloudKitRecords)
            .createObservable()
            .flatMap({ savedRecords in
                // convert array to multiple emissions so we can iterate it
                return Observable.from(savedRecords)
            })
            .flatMap({ (record:CKRecord) -&gt; M in
                // convert CKRecord back to a model (aka M)
                ... create model (e.g. Member) ...
                return model
            })
            // convert back to a single emission (array)
            .toArray() // &lt;&lt;&lt;&lt;&lt; ERROR
    }
}
</code></pre>

<p>Here is the error:</p>

<blockquote>
  <p>Cannot convert return expression of type 'Observable&lt;[M.E]>' (aka 'Observable>') to return type 'Observable&lt;[M]>' (aka 'Observable>') </p>
</blockquote>

<p>The only difference that I can see in the return type is <code>M.E</code> vs <code>M</code>.</p>

<p>Any ideas?</p>
","203549","","","","","2016-09-20 13:41:10","RxSwift toArray does not compile with generic parameter","<swift><generics><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"39599127","1","39599715","","2016-09-20 16:17:05","","1","1463","<p>After following the <a href=""https://github.com/RxSwiftCommunity/RxDataSources"" rel=""nofollow noreferrer"">Documentation</a> of <em>RxDataSources</em> I'm not able to make it work.</p>
<p>When I click on an element of the CollectionViews It is removed as my code shows but nothing happens on the views, despite there is an element less on my <code>sections[0].items</code>. I reckon that I'm doing some wrong binding the data source with the view but I'm not able to figure it out.</p>
<pre><code>    let dataSource = RxCollectionViewSectionedAnimatedDataSource&lt;SectionOfCategoryMO&gt;()
    private var e1cat = CatMngr.SI.getAlphabeticallyOrderedCategories(type: .e1)

    dataSource.configureCell = { ds, tv, ip, item in
        let cell = tv.dequeueReusableCellWithReuseIdentifier(&quot;cell&quot;, forIndexPath: ip) as! CategoryCollectionViewCell
        cell.categoryName.text = item.identity.string
        cell.categoryName.numberOfLines = 0
        cell.categoryCircle.makeCircle()
        cell.categoryCircle.backgroundColor = self.categoryColors[ip.row]
        
        return cell
    }
    
    dataSource.animationConfiguration = AnimationConfiguration(insertAnimation: .Fade, reloadAnimation: .Fade, deleteAnimation: .Automatic)
    
    var sections = [SectionOfCategoryMO(header: &quot;a&quot;, items: e1cat)]
    
    Observable.just(sections)
        .bindTo(myCollection.rx_itemsWithDataSource(dataSource))
        .addDisposableTo(disposeBag)
 
    myCollection.rx_itemSelected.subscribeNext{
        sections[0].items.removeAtIndex($0.row)
    }.addDisposableTo(disposeBag)
</code></pre>
<p>The view is loaded perfectly with all initial categories, but when I remove one of them the view is not refreshed.</p>
<p>Anyone know what is happening?</p>
<p>Thanks in advance.</p>
","4397640","","-1","","2020-06-20 09:12:55","2016-09-20 16:51:28","Not animation on item removed in UICollectionView with RxDataSources","<ios><swift><uicollectionview><rx-swift>","1","0","","","","CC BY-SA 3.0"
"39627440","1","39633558","","2016-09-21 22:19:39","","25","24129","<p>I want to observe the property <code>UITextfield.editing</code>. I'm using this code:</p>

<pre><code>self.money.rx_observe(Bool.self, ""editing"").subscribeNext { (value) in
    print("""")
}.addDisposableTo(disposeBag)
</code></pre>

<p>But in the process of running, it's only performed once. How do I solve this，please</p>
","6860998","","343299","","2016-09-22 08:02:56","2018-07-25 06:07:06","Observing UITextField.editing with RxSwift","<ios><swift><rx-swift><reactivex><rx-cocoa>","3","0","6","","","CC BY-SA 3.0"
"39708434","1","39732725","","2016-09-26 17:01:10","","4","4027","<p>I'm trying to migrate my FRP understanding from <strong>ReactiveCocoa 2.5</strong> to <strong>RxSwift</strong> and I have one misunderstanding. In ReactiveCocoa, I used <code>rac_signalForSelector</code> when I wanted to observe an invocation of a method. Is there any way to implement this logic using RxSwift?</p>

<p>I wrote a small example in which I want to dispose a subscription when the <code>test</code> method invokes. But in the subscribe block I can still see a <code>next(6)</code> event. What am I doing wrong?</p>

<pre><code>let subject = PublishSubject&lt;Int&gt;()
subject.takeUntil(self.rx.sentMessage(#selector(test))).subscribe { event in
    print(event)
}

subject.onNext(3)
test()
subject.onNext(6)

//////////////////

func test() {

}
</code></pre>
","3733734","","343299","","2016-09-28 07:18:55","2019-11-07 02:01:57","Observable for selector - RxSwift","<ios><swift><rx-swift><reactivex><rx-cocoa>","5","2","","","","CC BY-SA 3.0"
"39733708","1","","","2016-09-27 20:26:49","","0","117","<p>How can I transform this (simplified for clarity, if you can believe it)…</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    viewModel.track
        .asObservable()
        .subscribe(onNext: { upcomingTrack in

            self.showLoadingView()

            upcomingTrack.fetchYoutubeData()
                .observeOn(ConcurrentDispatchQueueScheduler(globalConcurrentQueueQOS: .background))
                .subscribe(onNext: { metadata in
                    if metadata.isInvalid {
                        viewModel.skip(upcomingTrack)
                        return
                    }

                    XCDYouTubeClient.default().getVideoWithIdentifier(metadata.youTubeId, completionHandler: { (video, error) in
                        if video != nil {

                            if let streamUrls = video?.streamURLs,
                                let streamUrl = streamUrls[NSNumber(value: XCDYouTubeVideoQuality.HD720.rawValue)]
                                    ?? streamUrls[NSNumber(value: XCDYouTubeVideoQuality.medium360.rawValue)] {

                                // 🏃 DO STUFF WITH streamURL
                                // 🏃 DO STUFF WITH upcomingTrack
                                self.hideLoadingView()
                            } else {
                                // ☠️ Not happy about this duplication
                                viewModel.skip(upcomingTrack)
                            }
                        } else {
                            viewModel.skip(upcomingTrack)
                        }
                    })

                }).addDisposableTo(self.disposeBag)
        }).addDisposableTo(self.disposeBag)
}
</code></pre>

<p>…into something like this:</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    viewModel.trackBeganLoading
        .drive(onNext: { _ in
            self.showLoadingView()
    }

    viewModel.loadedTrack
        .drive(onNext: { upcomingTrack in
            // 🏃 DO STUFF WITH upcomingTrack
            self.hideLoadingView()
        })
        .addDisposableTo(disposeBag)

    viewModel.streamURL
        .drive(onNext: { url in
            // 🏃 DO STUFF WITH streamURL
        })
        .addDisposableTo(disposeBag)
}
</code></pre>

<p>Apologies in advance for the open-ended nature of this question. I'm not even sure where to start unravelling this beast!</p>
","230615","","","","","2016-09-27 20:26:49","How to simplify long subscription into multiple observers/drivers","<swift3><rx-swift>","0","2","","","","CC BY-SA 3.0"
"39735929","1","40600488","","2016-09-27 23:41:56","","0","595","<p>Had a quick question: I have an <code>Variable&lt;[Session]&gt;</code>, where <code>Session</code>: </p>

<pre><code>class Session {
  ...
  var rx_serverRequestable: Driver&lt;SessionRequestable&gt;
  ...
}
</code></pre>

<p>which emits a .next event every time the session has all the information it needs to be passed on to the backend  and I want to be able to <code>flatMapLatest</code> on the array of sessions, and do something like:</p>

<pre><code>let sessions: Variable&lt;[Session]&gt;
sessions
    .flatMapLatest { sessions in sessions.map { $0. rx_serverRequestable } }
    .flatMap { $0.requestFromServer() }
</code></pre>

<p>but I only want to request each session once. There are two ways I see that failing with my current implementation:
1. flatMapLatest gets a new array of sessions, potentially disposing a request from server thats still in progress
2. rx_serverRequestable gets called each time the session has all the information required to be loaded from server, so it will get called multiple times, each time the session loads in any new information. I only  want the session to be requested the first time, should I be using something like <code>.multicast</code> or <code>.replay(1)</code>?</p>

<p>any pointers on solving the two issues, or switching up my approach?</p>
","3128543","","790877","","2016-10-03 17:36:25","2016-11-15 01:13:16","RxSwift flatMap latest one time without disposing","<swift><reactive-programming><rx-swift>","1","2","","","","CC BY-SA 3.0"
"39742899","1","39743644","","2016-09-28 09:11:52","","1","1353","<p>When i add toArray() before subscribing i get no callback.</p>

<pre><code>    googleCalendarUseCase.getEventsFromCalendars(calendars: selectedCalendars).subscribe(onNext: { (event) in
        print(event.summary) //print thousands of elements
    }).addDisposableTo(disposeBag)
    googleCalendarUseCase.getEventsFromCalendars(calendars: selectedCalendars).toArray().subscribe(onNext: { (events) in
        print(events.count)  // Never gets called
    }).addDisposableTo(disposeBag)
</code></pre>

<p>Maybe the problem is with the function getEventsFromCalendar but unsure why it works if i dont do toArray():</p>

<pre><code>func getEventsFromCalendars(calendars: [GoogleCalendar.Calendar], nextPageToken: String? = nil) -&gt; Observable&lt;GoogleCalendar.Event&gt; {
    return Observable&lt;GoogleCalendar.Event&gt;.create { observer -&gt; Disposable in
        var parameters: [String: Any] = [:]
        if let nextPageToken = nextPageToken {
            parameters[""pageToken""] = nextPageToken
        }
        _ = self.oauthswift.client.get(GoogleCalendarAPI.events, parameters: parameters, success: { (data, response) in
            if let json = try? JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions.allowFragments) as? [String: AnyObject] {
                if let nextPageToken = self.nextPageToken(json: json) {
                    _ = Observable.of(Observable.from(self.getEventsFromJSON(json: json)), self.getEventsFromCalendars(calendars: calendars, nextPageToken: nextPageToken))
                        .merge().subscribe(observer)
                } else {
                    _ = Observable.from(self.getEventsFromJSON(json: json))
                }
            } else {
                observer.onError(CustomError.other)
            }}, failure: { (error) in  observer.onError(CustomError.noInet) }
        )
        return Disposables.create()
    }
}
</code></pre>
","588125","","","","","2016-09-28 09:57:42","RxSwift toArray() not subscribing","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"39813242","1","39842789","","2016-10-02 02:16:16","","0","1469","<p>I am looking for a way in which the <code>throttle()</code> operator gives up the first element in an <code>Observable</code> within a given time-interval, rather than the last element.</p>

<p>A similar question has been asked (and answered) in <a href=""https://stackoverflow.com/questions/35438268/rxswift-debounce-throttle-inverse"">RxSwift - Debounce/Throttle &quot;inverse&quot;</a>, but there is an imperfection in those answers that I would like to avoid. That is, in an ideal scenario, the first element emitted in the <code>Observable</code> is obtained and any future ones are ignored for the duration of the time-interval. However, when working with <code>window()</code> or <code>timer()</code>, it is possible that two elements proceed <em>within</em> the given time-interval, because the timer happened not to run parallel to the start of the <code>throttle()</code> call. Example:</p>

<pre><code>|..........|..........|..........|
                    ^   ^
                first   second
</code></pre>

<p>They fall into different windows and are therefore both accepted by the imperfect solution described in the linked answer.</p>

<p>Ideally, there would be a way to restart the timer as soon as the first element in a window comes in, so that the above example would instead look something like:</p>

<pre><code>|..........|.......|..........|
                    ^   ^
                first   second (ignored)
</code></pre>

<p>Any ideas?</p>

<p>Edit: to be clear, I am not sure how the throttle() variety of RxSwift 3.0-beta1 handles this, but I am looking for a solution for RxSwift 2.x implementations.</p>
","6900003","","-1","","2017-05-23 12:16:45","2016-10-04 01:13:56","RxSwift throttle() to get first element","<swift><rx-swift><reactivex>","1","0","1","","","CC BY-SA 3.0"
"39902650","1","","","2016-10-06 17:54:08","","3","1113","<p>I bind Button pressed to <code>PublishSubject</code> in a router like so:</p>

<pre><code>hambugerButton
   .rx_tap
   .bindTo(router.openMenu)
   .addDisposableTo(disposeBag)
</code></pre>

<p>In my Router:</p>

<pre><code>let openMenu = PublishSubject&lt;Void&gt;()
//...
openMenu
   .map { _ in
       menuNavigationController
    }
    .bindTo(mainNavigationController.rx_present())
    .addDisposableTo(disposeBag)
</code></pre>

<p>However, when the controller is being deallocated, the button is sending 'complete' signal. When <code>PublishSubject</code> receives it, it won't react to signals from another controller (which is understandable: it is an <code>Observable</code> guarantee).  </p>

<p>The only solution I came up with:</p>

<pre><code>hambugerButton
    .rx_tap
    .subscribeNext {
        self.router.openMenu.onNext()
    }
    .addDisposableTo(disposeBag)
</code></pre>

<p>Which looks ugly and kinda spoils the idea of a reactive interface.
My question is, is there a way to avoid propagation of the <code>Completed</code> event to <code>PublishSubject</code>? Can I make some <code>Observer</code> which will ignore such events?</p>
","1923879","","1923879","","2016-10-06 18:14:17","2016-10-06 18:14:17","RxSwift PublishSubject is being disposed","<swift><rx-swift><reactivex>","1","0","","","","CC BY-SA 3.0"
"39928928","1","","","2016-10-08 05:15:52","","3","1360","<p>I am relatively new to <strong>RxSwift</strong>, but I am looking forward to using it more in my projects and I would love to hear some feedback on an operator I just wrote.</p>

<p>The functionality I am missing is a debounced buffer: A buffer that behaves exactly like the <code>debounce</code> operator, but instead of emitting only the latest value it should emit all collected values since the last emission.</p>

<p>In <strong>RxJava</strong> this is easily achievable by using a buffer with another observable as a ""closing selector"":</p>

<pre><code>// From: https://github.com/ReactiveX/RxJava/wiki/Backpressure
//
// we have to multicast the original bursty Observable so we can use it
// both as our source and as the source for our buffer closing selector:
Observable&lt;Integer&gt; burstyMulticast = bursty.publish().refCount();
// burstyDebounced will be our buffer closing selector:
Observable&lt;Integer&gt; burstyDebounced = burstMulticast.debounce(10, TimeUnit.MILLISECONDS);
// and this, finally, is the Observable of buffers we're interested in:
Observable&lt;List&lt;Integer&gt;&gt; burstyBuffered = burstyMulticast.buffer(burstyDebounced);
</code></pre>

<p>In <strong>RxSwift</strong> though this version of the buffer operator doesn't exist (I think this issue is related: <a href=""https://github.com/ReactiveX/RxSwift/issues/590"" rel=""nofollow"">https://github.com/ReactiveX/RxSwift/issues/590</a>), so I tried to solve the issue myself.</p>

<hr>

<p>My first approach was just building the debounced buffer:</p>

<pre><code>extension ObservableType {
    func debouncedBuffer(_ dueTime: RxTimeInterval, scheduler: SchedulerType) -&gt; Observable&lt;[E]&gt; {
        var valueBuffer: [E] = []

        let observable = self.do(onNext: { (value) in
            valueBuffer.append(value)
        }, onError: { (error) in
            valueBuffer = []
        }, onCompleted: {
            valueBuffer = []
        }, onSubscribe: {
            valueBuffer = []
        }, onDispose: {
            valueBuffer = []
        }).debounce(dueTime, scheduler: scheduler).flatMap { (value) -&gt; Observable&lt;[E]&gt; in
            let emitValues = valueBuffer
            valueBuffer = []
            return Observable&lt;[E]&gt;.just(emitValues)
        }

        return observable
    }
}
</code></pre>

<hr>

<p>My second approach was building the buffer which any closing condition (like the RxJava version):</p>

<pre><code>extension ObservableType {
    func buffer&lt;R&gt;(_ selector: Observable&lt;R&gt;) -&gt; Observable&lt;[E]&gt; {
        var valueBuffer: [E] = []

        return Observable.create { observer in
            let selectorSubscription = selector.subscribe(onNext: { (value) in
                let emitValues = valueBuffer
                valueBuffer = []
                observer.on(.next(emitValues))
            }, onError: { (error) in
                valueBuffer = []
                observer.on(.error(error))
            }, onCompleted: {
                valueBuffer = []
                observer.on(.completed)
            }, onDisposed: {
                valueBuffer = []
            })

            let subscription = self.subscribe(onNext: { (value) in
                valueBuffer.append(value)
            }, onError: { (error) in
                observer.on(.error(error))
                selectorSubscription.dispose()
            }, onCompleted: {
                observer.on(.completed)
                selectorSubscription.dispose()
            }, onDisposed: {
                observer.on(.completed)
                selectorSubscription.dispose()
            })
            return subscription
        }
    }
}
</code></pre>

<hr>

<p>I have tested these two operators and they seem to work, also tested handling different combinations of onError, onDispose, and onCompleted events.</p>

<p>But I would still love to hear some feedback from more experienced people if this is at least an acceptable solution without leaks, and if I am violating any RX contracts.</p>

<p>I also created a pasterbin with some test code: <a href=""http://pastebin.com/1iAbUPf8"" rel=""nofollow"">http://pastebin.com/1iAbUPf8</a></p>
","968099","","968099","","2016-10-08 05:22:55","2017-04-14 11:47:25","Implementing a debounced buffer with RxSwift, is this correct?","<swift><rx-swift><reactivex>","1","2","1","","","CC BY-SA 3.0"
"39972512","1","39995134","","2016-10-11 07:42:37","","6","2995","<p>In MyModule, I have this enum:</p>

<pre><code>enum MyError: ErrorType {
    case failToSendMessage
    case notAuthenticated
    case noResponseReceived
}
</code></pre>

<p>In MyModuleTests:</p>

<pre><code>import XCTest
@testable import MyModule

class MyModuleTests: XCTestCase {
    func testNotAuthenticated() {
        myClass.doSomething()
        .subscribeError { error in 
            XCTAssertEqual(error, MyError.notAuthenticated)
        }
    }
}
</code></pre>

<p><code>doSomething</code> returns an <code>Observable</code>.</p>

<p>Why do I get this error message:
<code>Cannot invoke 'XCTAssertEqual' with an argument list ((ErrorType), MyError)</code> ?</p>
","6373924","","6373924","","2016-10-11 09:21:18","2016-10-12 09:28:22","Cannot invoke 'XCTAssertEqual' with an argument list ((ErrorType), XMPPError)","<ios><swift><xcode><rx-swift>","3","2","","","","CC BY-SA 3.0"
"39996937","1","","","2016-10-12 11:00:40","","13","19056","<p>I want to unsubscribe from Observable in RxSwift. In order to do this I used to set Disposable to nil. But it seems to me that after updating to RxSwift 3.0.0-beta.2 this trick does not work and I can not unsubscribe from Observable:</p>

<pre><code>//This is what I used to do when I wanted to unsubscribe
var cancellableDisposeBag: DisposeBag?

func setDisposable(){
    cancellableDisposeBag = DisposeBag()
}

func cancelDisposable(){
    cancellableDisposeBag = nil
}
</code></pre>

<p>So may be somebody can help me how to unsubscribe from Observable correctly?</p>
","4092466","","","","","2020-04-11 14:12:34","How to unsubscribe from Observable in RxSwift?","<ios><swift><rx-swift>","2","2","1","","","CC BY-SA 3.0"
"40010446","1","","","2016-10-13 00:28:35","","1","2311","<p>I am currently using RxSwift and the <code>ActivityIndicator</code> extension (<a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Services/ActivityIndicator.swift"" rel=""nofollow"">https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Services/ActivityIndicator.swift</a>).</p>

<p>I am trying to achieve showing an activity indicator (spinner) image when an API request takes more than 2 seconds. The RxSwift <code>ActivityIndicator</code> is basically a (so-called hot) <code>Observable&lt;Bool&gt;</code> that emits <code>true</code> when the API calls is made, and <code>false</code> when the whole thing is done.</p>

<p>To get the desired behavior, I have played around with many combinations of <code>throttle</code>ing, <code>debounce</code>ing and such, together with operators like <code>window</code> and <code>pausable</code>, but I can never get it quite right.</p>

<p>Thoughts?</p>
","6900003","","","","","2016-10-15 12:35:58","Show an activity indicator after x seconds, using RxSwift","<ios><swift><reactive-programming><rx-swift>","1","5","","","","CC BY-SA 3.0"
"40030449","1","","","2016-10-13 20:32:42","","1","336","<p>I need a function that encapsulates a complicated IAP purchase tree into a simple attemptPurchase function that returns a boolean observable (true -&gt; success, false -&gt; cancelled, error -&gt; any error)</p>
<p>But I am stumped at how to create that function, mainly because the start of the decision is async.</p>
<p>Decision tree and code below.</p>
<p><a href=""https://i.stack.imgur.com/MCJp9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/MCJp9.png"" alt=""enter image description here"" /></a></p>
<pre><code>// fails -&gt; missing return function
// but I cannot return the credit check, since the execution is different depending on the result

func attemptPurchase(amount: Int) -&gt; Observable&lt;Bool&gt;{
  
  let creditCheck = creditCheck(amount)
   
  creditCheck.filter{$0}.subscribeNext{ _ in
    return Observable.just(true)
  }

  creditCheck.filter{$0}.subscribeNext{ _ in
    return confirmIAP().processIAP()
  }
}

func creditCheck(amount: Int) -&gt; Observable&lt;Bool&gt;{
  return API.creditCheck.map{$0 &gt; amount}
}

func confirmIAP() -&gt; Observable&lt;Bool&gt; {
  // UI for confirming IAP
}

func processIAP() -&gt; Observable&lt;Bool&gt; {
  // UI for uploading IAP on my server
}
</code></pre>
","180663","","472495","","2021-05-27 22:38:10","2021-05-27 22:38:10","Observable with an a decision tree","<swift><reactjs><rx-java><rx-swift>","2","0","","","","CC BY-SA 4.0"
"40038319","1","40041243","","2016-10-14 08:18:13","","0","268","<p>I am starting my first RxSwift project.</p>

<p>I want all the pagination url of this page : <a href=""http://mangafox.me/directory/"" rel=""nofollow"">http://mangafox.me/directory/</a>
So far, I can get the next page url.
Here is the code used so far:</p>

<pre><code>    func getNextPageUrl(currentStringUrl: String) -&gt; Observable&lt;String&gt; {
    return Observable.create { observer -&gt; Disposable in
        let request = Alamofire.request(currentStringUrl)
            .validate()
            .responseString { response in
                if response.result.isSuccess {
                    if let doc = HTML(html: response.result.value!, encoding: .utf8) {
                        if let nextPage = doc.css(""a &gt; span.next"").first?.parent {
                            observer.onNext(""\(currentStringUrl)\(nextPage[""href""]!)"")
                        }
                    }
                    observer.onCompleted()
                }else{
                    observer.onError(response.result.error!)
                }
        }

        return Disposables.create {
            request.cancel()
        }
    }
}
</code></pre>

<p>Now I want to make a string list of other next pagination link. How can I make that?</p>
","645092","","1113632","","2018-01-29 15:58:18","2018-01-29 15:58:18","How to get all page url of a paginated page with RxSwift","<swift><pagination><rx-swift>","1","0","","","","CC BY-SA 3.0"
"40042255","1","40076805","","2016-10-14 11:38:01","","5","7091","<p>I'm trying to gradually convert my App to RxSwift / MVVM. But I think I'm doing some things incorrectly.</p>

<p>In this example I have a static table with this specific information.</p>

<pre><code>    let itens = Observable.just([
        MenuItem(name: GlobalStrings.menuItemHome,      nameClass: ""GPMainVC""),
        MenuItem(name: GlobalStrings.menuItemProfile,   nameClass: ""GPMainVC""),
        MenuItem(name: GlobalStrings.menuItemLevels,    nameClass: ""GPLevelsVC""),
    ])
</code></pre>

<p>I need to know the model(MenuItem) and the index when the user select a cell, but I am having trouble doing that</p>

<pre><code> tableView.rx
        .itemSelected
        .map { [weak self] indexPath in
            return (indexPath, self?.modelView.itens.elementAt(indexPath.row))
        }
        .subscribe(onNext: { [weak self] indexPath, model in

            self?.tableView.reloadData()

            //can´t get MenuItem because model its a observable
            //self?.didSelect((indexPath as NSIndexPath).row, name.nameClass)

        })
        .addDisposableTo(disposeBag)
</code></pre>

<p>Thanks in advance</p>
","745459","","","","","2016-10-17 14:24:33","RxSwift obtain value from one item in Observable sequence","<ios><swift><rx-swift>","1","2","0","","","CC BY-SA 3.0"
"40055402","1","","","2016-10-15 05:38:11","","1","725","<p>I have a searchBar to query results from an API. If i query directly from the VC without passing the text to the presenter i get this which works perfectly fine:</p>

<pre><code>searchBar.rx.text
        .skip(1)
        .throttle(0.5, scheduler: MainScheduler.instance)
        .distinctUntilChanged()
        .flatMapLatest({ (text) -&gt; Observable&lt;[MarvelCharacter]&gt; in
            return GetCharacters().execute(offset: 0, name: text)
        }).subscribe(onNext: { (characters) in
            self.showCharacters(characters: characters)
        }).addDisposableTo(disposeBag)
</code></pre>

<p>What i really want is to subscribe from GetCharacters() in the presenter.
Could be like this:</p>

<p>ViewController</p>

<pre><code>    searchBar.rx.text
        .skip(1)
        .throttle(0.5, scheduler: MainScheduler.instance)
        .distinctUntilChanged()
        .map(presenter.searchTextDidChanged)
        .subscribe().addDisposableTo(disposeBag)
</code></pre>

<p>Presenter</p>

<pre><code>func searchTextDidChanged(text: String) {
    getCharacters.execute(offset: offset, name: text)
        .subscribe(onNext: { characters in
        (self.offset == 0) ?
            self.ui.showCharacters(characters: characters) : self.ui.appendCharacters(characters: characters)
    }).addDisposableTo(disposeBag)
}
</code></pre>

<p>But sometimes i send RxSw (show the result RxSwift) and RxSwZ (empty results), but since i lost the “chain”, getCharacters from the presenter gets executed twice. Then if the 2nd request terminates before the good request i end up in the searchBar with RxSw5 and in the results with RxSwift, how can i deal with this?</p>
","588125","","","","","2016-10-15 05:38:11","RxSwift using MVP subscribe from the Presenter","<ios><swift><rx-swift>","0","2","","","","CC BY-SA 3.0"
"40058666","1","50929040","","2016-10-15 11:50:27","","7","12030","<p>I find this very puzzling. Coming from ReactiveCocoa I would expect something like this possible.</p>

<p><a href=""https://i.stack.imgur.com/UZFpB.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/UZFpB.png"" alt=""enter image description here""></a></p>

<p>How can I initialize the RxSwift observable to 5?</p>
","788100","","4511639","","2018-06-18 06:09:27","2018-06-19 12:56:31","How do I initialize an observable property in RxSwift?","<ios><swift><rx-swift>","5","0","","","","CC BY-SA 4.0"
"40127674","1","","","2016-10-19 09:40:59","","0","1012","<p>I'm trying to implement the current behavior with a textfield and a button:
1 - the textfield should be validated not realtime but only after tapping the button it has to show an error label for the validation error
2 - if the textfield is validate I have to show an uialertcontroller to cancel or continue the operation</p>

<p>I tried especially the second part with the following code but It works only the first time, if I tap cancel for example and I tap an other time the button it looks like disabled....no more taps are allowed.</p>

<pre><code>            let action = CocoaAction {
            return Observable.create {
                [weak self] observer -&gt; Disposable in
                let alertController = self.getAlertController()
                let ok = UIAlertAction.Action(NSLocalizedString(""OK_BUTTON"", comment: ""OK_BUTTON""), style: .Default)
                ok.rx_action = CocoaAction { _ in
                    return self!.viewModel!.modify(self?.addressTextFiled.rx_text)
                        .doOnNext({ data in
                            if let data = data
                            {
                                self!.showMessage(data.message)
                            }
                        })
                        .map { _ in Void() }
                }
                let cancelAction = UIAlertAction(title: NSLocalizedString(""CANCEL_BUTTON"", comment: ""CANCEL_BUTTON""), style: .Cancel) { (_) in }

                alertController.addAction(ok)
                alertController.addAction(cancelAction)

                self!.presentViewController(alertController, animated: true, completion: nil)
                return NopDisposable.instance
            }
        }
        confirmButton.rx_action = action
</code></pre>

<p>For the first point do you have some advise?</p>

<p>Thanks to help me out!!</p>
","1870602","","","","","2016-10-20 16:10:02","CocoaAction with RxSwift and UIAlertController","<ios><uialertcontroller><rx-swift>","1","2","","","","CC BY-SA 3.0"
"40129498","1","40130055","","2016-10-19 10:58:36","","0","314","<p>I have a array like this:</p>

<pre><code>    var arrayPoints:Variable&lt;[Point]&gt;?
</code></pre>

<p>Later the user can sort the listlike this:</p>

<pre><code>  func orderPointsByDistance(){
       self.arrayPoints?.value.sort{ $0.stringDistance.compare($1.stringDistance) == .orderedAscending  }
  }
</code></pre>

<p>However i am receiving this error:</p>

<pre><code>fatal error: Executing on backgound thread.
Please use MainScheduler.instance.schedule to schedule work on main thread.: file /Users/dasilvans/Desktop/GeoPlay/Pods/RxSwift/RxSwift/Rx.swift, line 23
</code></pre>

<p>In a way I perceive the error, but do not know how to solve it.
Any suggestion?</p>
","745459","","","","","2016-10-19 11:28:29","RxSwift error using Sort on Variable<[Element]>","<io><ios10><rx-swift>","1","0","","","","CC BY-SA 3.0"
"40172231","1","40177223","","2016-10-21 08:50:18","","1","4633","<p>I have started new empty project in Swift 3.0 and try use <code>RxAlamofire</code>. I use <code>Carthage</code> for dependecies library (<a href=""https://www.twilio.com/blog/2016/05/getting-started-with-carthage-to-manage-dependencies-in-swift-and-ios.html"" rel=""nofollow"">tutorial</a>) but I got framework crash and message:</p>

<pre><code>dyld: Symbol not found: __TMp7RxSwift18ReactiveCompatible
  Referenced from: /Users/michu/Library/Developer/CoreSimulator/Devices/7249C3ED-2CBC-41E4-A66D-BBC010CD70CD/data/Containers/Bundle/Application/B625B9D2-687C-4703-A6BF-C9E5F8861F44/recipemaster.app/Frameworks/RxAlamofire.framework/RxAlamofire
  Expected in: /Users/michu/Library/Developer/CoreSimulator/Devices/7249C3ED-2CBC-41E4-A66D-BBC010CD70CD/data/Containers/Bundle/Application/B625B9D2-687C-4703-A6BF-C9E5F8861F44/recipemaster.app/Frameworks/RxSwift.framework/RxSwift
 in /Users/michu/Library/Developer/CoreSimulator/Devices/7249C3ED-2CBC-41E4-A66D-BBC010CD70CD/data/Containers/Bundle/Application/B625B9D2-687C-4703-A6BF-C9E5F8861F44/recipemaster.app/Frameworks/RxAlamofire.framework/RxAlamofire
</code></pre>

<p>I don't know where might be a problem. Below General configuration</p>

<p><a href=""https://i.stack.imgur.com/69fCv.png"" rel=""nofollow""><img src=""https://i.stack.imgur.com/69fCv.png"" alt=""general""></a></p>
","2228201","","","","","2016-10-21 12:54:26","iOS app with framework crashed on device, dyld: Symbol not found, Xcode 8","<ios><xcode><rx-swift><carthage>","2","0","","","","CC BY-SA 3.0"
"40175821","1","40211147","","2016-10-21 11:42:47","","0","1112","<p>Im using RxMoya and I was wondering about usage of fiterSuccesfulStatusCodes, I will try to describe what my problem is...So when you use some Network call like this</p>

<pre><code>func getAllApps(gwId: Int) -&gt; Observable&lt;Response&gt; {
    return provider.request(RestAPI.GetAllApps(gwId: gwId)).filterSuccessfulStatusCodes()
}
</code></pre>

<p>When you get response with status code above 299 nothing will happen, my problem is that I would like to display error message to user, but when you inspect what does filterSuccessfulStatusCodes do: </p>

<pre><code>public func filterSuccessfulStatusCodes() -&gt; Observable&lt;E&gt; {
    return flatMap { response -&gt; Observable&lt;E&gt; in
        return Observable.just(try response.filterSuccessfulStatusCodes())
    }
}
</code></pre>

<p>Now we are getting closer to the problem I have. So implementation of filterSuccessfulStatusCodes uses public instance function of Moya.Resposne with this implementation : </p>

<pre><code>public func filterSuccessfulStatusCodes() throws -&gt; Response {
    return try filterStatusCodes(200...299)
}
</code></pre>

<p>As you can see, this thing throws exceptions...but the function above, it doesnt rethrow, it returns Observable of generic type E. </p>

<p>My first question, How come you can use return Observable.just(try response.filterSuccessfulStatusCodes()) when the function doesnt throw/rethrow. You can use try withou do/chatch?(I know with try!/try? you can but with try, I can only imagine case with rethrow).</p>

<p>Second question, it there a way to react to error status codes, on the level of observables.</p>

<p>Thank you</p>
","1762099","","","","","2016-10-24 05:17:24","How properly filterSuccessfulStatusCodes in RxMoya","<swift><rx-swift><moya>","1","0","1","","","CC BY-SA 3.0"
"40189724","1","40236888","","2016-10-22 07:56:11","","1","3827","<p>When I observe my realm model and bind changes to table view it works. But when I try to add row to the table I have some crash</p>

<blockquote>
  <p>Terminating app due to uncaught exception
  'NSInternalInconsistencyException', reason: 'attempt to insert row 1
  into section 0, but there are only 1 rows in section 0 after the
  update'</p>
</blockquote>

<p>Can I do it without using standard delegates methods?</p>

<p>Here is my code snippet</p>

<pre><code>        let realm = try! Realm()

    let places = realm.objects(Place.self)

    Observable.from(places)
        .bindTo(tableView.rx.items(cellIdentifier: ""PlaceCell"", cellType: PlaceCell.self)) { (row, element, cell) in
            let viewModel = PlaceCellViewModel(place: element)
            cell.setup(viewModel: viewModel)
        }
        .addDisposableTo(disposeBag)

    Observable.changesetFrom(places).subscribe(onNext: { [weak self] result, changes in

        if let changes = changes {
            self?.tableView.beginUpdates()
            let indexes = changes.inserted.map { IndexPath(row: $0, section: 0) }
            self?.tableView.insertRows(at: indexes, with: .bottom)
            self?.tableView.endUpdates()
        } else {
            self?.tableView.reloadData()
        }

        })
        .addDisposableTo(disposeBag)
</code></pre>
","2493555","","","","","2017-01-12 09:04:18","RxSwift + RxRealm + RxCocoa insert rows to UITableView","<swift><realm><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"40219842","1","","","2016-10-24 13:34:14","","2","498","<p>I'm trying to wrap my API calls with RxSwift. I'm not using any third party library for these calls. The problem I'm facing is with custom error object. All API calls return a standard JSON error Object. This is an example:</p>

<pre><code>{
  ""error"": {
     ""code"": 11001,
     ""message"": ""Bad request"",
     ""errors"": [
            ""The accesstoken field is required.""
            ]
  }
}
</code></pre>

<p>This is the code that will Send the API request</p>

<pre><code>func CallAPI(withParameters parameters: [String : AnyObject]?,
             queryToSearchFor query: String?) -&gt; Observable&lt;AnyObject?&gt;? {

    return Observable.create({ (observable) -&gt; Disposable in
        ServerInterface.getRequest(
            withBaseURl: nil,
            withFunctionName: ""util/load_companies/"" + (query ?? """"),
            havingFunctionsParameters: nil,
            andHeaderParameters: parameters,
            withCompletionHandler: { (response) in
                guard response.responseCode == kSuccessCode else {
                    observable.on(.error( response.responseError  as! Error))
                    return
                }

                observable.on(.next(response.responseData))
                observable.on(.completed)
        })
        return Disposables.create {
            print(""Request Cancelled"")
        }
    })

}
</code></pre>

<p><code>ServerInterface.getRequest()</code> has a completion handler of type <code>ServerInterfaceResponse</code> that contains a <code>ServerInterfaceError</code>. This object i want to <code>ObserverOn</code> when the API returns an error 
The problem appears on this line </p>

<p><code>observable.on(.error( response.responseError  as! Error))
</code></p>

<p>At Runtime it crashes with error </p>

<blockquote>
  <p>'could not cast value of type ServerInterfaceError' to 'Error'</p>
</blockquote>

<p>Here's my custom error object </p>

<pre><code>class ServerInterfaceError: NSObject, Error {
    var errorCode: Int?
    var errorMessage: String?
    var errorDebugger: [String]?

    func error(_ code: Int?, message: String?,
               debugger: [String]?) -&gt; ServerInterfaceError {

        let serverError = ServerInterfaceError.init()
        serverError.errorCode = code
        serverError.errorMessage = message
        serverError.errorDebugger = debugger

        return serverError

    }
}
</code></pre>

<p>Here's my custom APIResponse Object. it contains the a property <code>responseError</code> of type  ServerInterfaceError.</p>

<pre><code>class ServerInterfaceResponse: NSObject {
    var responseCode: Int?
    var responseData: AnyObject?
    var responseMessage: String?
    var responseError: ServerInterfaceError?

    func response(_ code: Int?, data: AnyObject?, message: String?, error: ServerInterfaceError?) -&gt; ServerInterfaceResponse {
         let serverResponse = ServerInterfaceResponse.init()
         serverResponse.responseCode = code
         serverResponse.responseData = data
         serverResponse.responseMessage = message
         serverResponse.responseError = error

        return serverResponse
    }

    override var description: String {
      return ""Response Code = \(responseCode) | Response Data = \(responseData) | Response Message = \(responseMessage) | Response Error = {\(responseError)}""
    }
}
</code></pre>

<p>How can i send a custom object to the <code>observable.on(.error( ))</code></p>
","3795432","","3795432","","2016-10-24 16:29:02","2016-10-24 16:29:02","RxSwift Custom API Wrapper","<ios><swift><rx-swift>","0","7","","","","CC BY-SA 3.0"
"40247502","1","40587669","","2016-10-25 18:50:01","","2","465","<p>Im trying to achieve dependency injection with protocols in Swift :)</p>

<p>My system under test calls .rx.signIn() on the dependency, meaning that it has extended Reactive where Base : ConcreteObject.</p>

<p>Is it possible to setup a protocol ready to receive .rx calls?</p>

<p>Any small example or alternative would be greatly appreciated.</p>
","4840289","","","","","2016-11-14 11:27:40","Mocking a class with Rx extensions","<ios><swift><swift-protocols><rx-swift>","1","0","","","","CC BY-SA 3.0"
"40255597","1","","","2016-10-26 06:54:37","","0","1292","<p>Recently started writing code in Swift using reactive programming. Reactive programming is little confusing concept, anyway i want to implement tableview with expand and collapse concept using reactive programming. I tried in my own way, i am able to write code  for implementing normal, section tableview and <a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow"">here</a> they provided examples also, but for expand and collapse tableview i did not find any example. Can any one please provide the solution for this.</p>
","2750260","","2750260","","2016-10-26 07:07:31","2017-05-15 07:57:37","Swft3 (RxSwift, RxCocoa) - TableView Expand and collapse concept using reactive programming","<ios><swift><swift3><rx-swift><rx-cocoa>","1","1","","","","CC BY-SA 3.0"
"40259211","1","40259954","","2016-10-26 10:00:13","","6","4091","<p>I want to design my swift app using clean architecture.</p>

<p>I have read the link below on clean architecture for swift</p>

<p><a href=""http://clean-swift.com/blog/"" rel=""noreferrer"">http://clean-swift.com/blog/</a></p>

<p>I have used these templates to create the app.</p>

<p>I wanted to ask if this is the best architecture to use as I want to code using Rx-Swift.</p>

<p>Also I would appreciate if someone could point out a few working examples for clean architecture with reactive swift.</p>

<p>Is using  Uncle Bob’s Clean Architecture for swift(<a href=""http://clean-swift.com/blog/"" rel=""noreferrer"">http://clean-swift.com/blog/</a>) a best practise for RxSwift or should I go with MVVM architecture</p>

<p>Any help will be appreciated. Thank you.</p>
","5443885","","5443885","","2016-10-26 12:12:24","2016-10-26 12:12:24","Rx-Swift Clean architecture","<ios><swift><rx-swift>","1","0","2","2016-10-26 11:58:04","","CC BY-SA 3.0"
"40295260","1","40298220","","2016-10-27 22:34:44","","1","310","<p>I´m kind of new to the reactive pattern and now I have my first bigger question.</p>

<p>I have done a few asychronous requests in the reactive way. But what I wan´t to do now is a ""Eventlistener"". </p>

<p>I have a <code>Session</code> object, at the moment I have an <code>SessionEventListener</code> protocol. The Session has a list of listeners and informs all of them about a successfull login and an logout. This Listeners can subscribe and unsubscribe. This thing I want to create reactive now.</p>

<p>How would you do that? </p>

<hr>

<p>My Idea is to define a BehaviourSubject:</p>

<pre><code>public let loginEventBehaviourSubject = BehaviorSubject(value: true)
</code></pre>

<p>now I can send onNext true if the session logged in, and false if it was logged out:</p>

<pre><code>loginEventBehaviourSubject.onNext(true) // on login
loginEventBehaviourSubject.onNext(false) // on logout
</code></pre>

<p>And my ""listeners"" can subscribe to it.</p>

<p>But I would prefere to have subjects for every event:</p>

<pre><code>public let loginEventBehaviourSubject = BehaviorSubject(value: )
public let logoutEventBehaviourSubject = BehaviorSubject(value: )
</code></pre>

<p>But then I wouldn´t need the bool. Can I make a kind of ""empty"" Subject, that only fire ""events"" without submitting really data.</p>

<p>And then my last question:
Why do I have to add an instance to the initializer of the Subject. Why can´t I create it like: <code>BehaviourSubject&lt;Bool&gt;()</code>?</p>
","1640012","","1640012","","2016-10-27 22:47:24","2016-10-28 04:49:11","RXSwift eventlistener","<listener><rx-swift>","1","0","","","","CC BY-SA 3.0"
"40309299","1","40314099","","2016-10-28 16:26:07","","1","1180","<p>I am quite new in the reacitve world and now I have a problem:</p>

<p>I have two functions that returns observables:</p>

<pre><code>func connect() -&gt; Observable&lt;Connection&gt;
</code></pre>

<p>and </p>

<pre><code>func execute(_ statement: Statement) -&gt; Observable&lt;Result&gt;
</code></pre>

<p>What I now need to do is, that <code>connect</code> has to run before <code>execute</code> and then I have to return the result of <code>execute</code>...</p>

<p>What I thought I will do is to run the <code>execute</code> function inside of the <code>map</code> function of the observable returned by <code>connect</code>, like this:</p>

<pre><code>public func executeFetch(_ query: Statement) -&gt; Observable&lt;Result&gt; {
    return self.connect()
    .map({ (connection) -&gt; Result in
        return execute(query) // here is my problem because execute returns an Observable&lt;Result&gt;.
    })
}
</code></pre>

<p>But because <code>execute</code> returns an <code>Observable&lt;Result&gt;</code> I get an <code>Observable&lt;Observable&lt;Result&gt;&gt;</code></p>

<p>How can I solve this problem?</p>
","1640012","","","","","2016-10-28 22:44:39","RXSwift first element of one observable after result of other observable","<rx-swift>","1","0","","","","CC BY-SA 3.0"
"40322851","1","40324345","","2016-10-29 19:28:15","","3","817","<p>I'm trying to achieve a <em>reactive</em> way to perform some operations:</p>

<ol>
<li>Request a photo download</li>
<li>Get the download progress from <code>next</code> events</li>
<li>When completed then save that photo locally</li>
</ol>

<p>So I started with RxSwift and implemented it like</p>

<pre><code>photoController.downloadPhoto(photoItem.photo)
.doOnNext { downloadTaskInfo in
    photoItem.viewState = .NetworkProgress(task: downloadTaskInfo.task, progress: downloadTaskInfo.progress)
}
.flatMapLatest { downloadTaskInfo in
    return PHPhotoLibrary.savePhoto(downloadTaskInfo.buffer)
}
.observeOn(MainScheduler.instance)
.subscribe(
    onError: { error in
        photoItem.viewState = .NetworkFailed
    },
    onCompleted: {
        photoItem.viewState = .Default
    }
)
.addDisposableTo(disposeBag)
</code></pre>

<p>but the <code>flatMapLatest</code> doesn't do what I was expecting. I thought that <code>flatMapLatest</code> would allow me to grab the latest event and make another operation.</p>

<p>So, I decided to replace it with <code>reduce</code> to achieve what I had in mind but I think it's not the right operator because I don't want to join all the download progress in one variable. What I want is something where it's possible to wait for the download to complete and then get the latest to continue with other operations like saving the photo locally.
With <code>concat</code> I cannot receive the result from the first Observable. </p>

<p>I need something like </p>

<pre><code>// 😅
.waitUntilDownloadFinishesAndContinueWith { downloadTaskInfo in
    return PHPhotoLibrary.savePhoto(downloadTaskInfo.buffer)
}
</code></pre>

<p>Can someone explain me the right way to design this?</p>

<h2>UPDATE</h2>

<p>I decided to go with <code>withLatestFrom</code> but even so I'm having some problems. The <code>downloadPhotoObservable</code> is being disposed too soon.</p>

<pre><code>let downloadPhotoObservable = photoController.downloadPhoto(photoItem.photo)
    .doOnNext { downloadTaskInfo in
        photoItem.viewState = .NetworkProgress(task: downloadTaskInfo.task, progress: downloadTaskInfo.progress)
    }

Observable.just(photoItem)
    .withLatestFrom(downloadPhotoObservable)
    .map { downloadTaskInfo in
        PHPhotoLibrary.savePhoto(downloadTaskInfo.buffer)
    }
    .observeOn(MainScheduler.instance)
    .subscribe(
        onError: { error in
            photoItem.viewState = .NetworkFailed
        },
        onCompleted: {
            photoItem.viewState = .Default
        }
    )
    .addDisposableTo(disposeBag)
</code></pre>

<p>I'm doing something wrong for sure.</p>
","3641812","","","","","2016-10-29 22:33:11","RxSwift: use a combination of operators to download a photo and save it locally","<swift><rx-swift><reactivex>","1","0","1","","","CC BY-SA 3.0"
"40334098","1","40335765","","2016-10-30 22:01:22","","0","3393","<p>I created simple project to check libraries like RxAlamofire and AlamofireObjectMapper. I have simple <code>ApiService</code> with one endpoint where is <code>PHP</code> script which works properly and returns <code>JSON</code>. I want call to <code>recipeURL</code> and I use <code>flatMap</code> operator to get response and provide it into <code>Mapper</code> where I should get <code>Recipe</code> object. How I can to do that?</p>

<p>Or is there other way?</p>

<pre><code>class ApiService:  ApiDelegate{
    let recipeURL = ""http://example.com/test/info.php""

    func getRecipeDetails() -&gt; Observable&lt;Recipe&gt; {
        return request(.get, recipeURL)
            .subscribeOn(MainScheduler.asyncInstance)
            .observeOn(MainScheduler.instance)
            .flatMap({ request -&gt; Observable&lt;Recipe&gt; in
                let json = """"//request.??????????? How to get JSON response?
                guard let recipe: Recipe = Mapper&lt;Recipe&gt;().map(JSONObject: json) else {
                    return Observable.error(ApiError(message: ""ObjectMapper can't mapping"", code: 422))
                }
            return Observable.just(recipe)
        })
    }
}
</code></pre>
","2228201","","1173513","","2016-10-31 09:11:37","2016-10-31 09:11:37","Swift 3, RxAlamofire and mapping to custom object","<swift><swift3><alamofire><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"40363779","1","40372177","","2016-11-01 15:58:12","","1","2299","<p>By using RxSwift, the purpose of my project is whenever an user types a city in search bar, it will make a call to wrap the current temperature. Currently, I have <code>viewModel</code> which contains</p>

<pre><code>var searchingTerm = Variable&lt;String&gt;("""") // this will be binded to search text from view controller
var result: Observable&lt;Weather&gt;!         // this Observable will emit the result based on searchingTerm above.
</code></pre>

<p>In api service, I'm wrapping a network call using RxSwift by following</p>

<pre><code>func openWeatherMapBy(city: String) -&gt; Observable&lt;Weather&gt; {
    let url =   NSURL(string: resourceURL.forecast.path.stringByReplacingOccurrencesOfString(""EnterYourCity"", withString: city))

    return Observable&lt;WeatherModel&gt;.create({ observer -&gt; Disposable in
        let downloadTask    =   self.session.dataTaskWithURL(url!, completionHandler: { (data, response, error) in
            if let err = error {
                observer.onError(err)
            }
            else {
                do {
                    let json = try NSJSONSerialization.JSONObjectWithData(data!, options: .AllowFragments) as! [String: AnyObject]

                    let weather = Weather(data: json)
                    observer.onNext(weather) 
                    observer.onCompleted()
                }
                catch {

                }

            }
        })

        downloadTask.resume()

        return AnonymousDisposable {
            downloadTask.cancel()
        }
    })
}
</code></pre>

<p>As long as the model created, I'll send it to an observer and complete</p>

<p>At view controller, I'm doing</p>

<pre><code>viewModel.result
            .subscribe( onNext:     { [weak self] model  in
                            self?.weatherModel = model
                            dispatch_async(dispatch_get_main_queue(), { 
                                self?.cityLabel.text        = model.cityName
                                self?.temperatureLabel.text = model.cityTemp?.description
                            })

                        },
                        onError:    { (error) in
                            print(""Error is \(error)"")
                        },
                        onCompleted:{
                            print(""Complete"")
                        }
                      )
                            { print(""Dealloc"")}
            .addDisposableTo(disposeBag)
    }
</code></pre>

<p>It works as expected, UI is updated and show me what I want. However, I have just realized that <code>onCompleted</code> never gets called. I assume if I do everything right, I must have it printed out.</p>

<p>Any ideas about this issue. All comments are welcomed here.</p>
","792562","","792562","","2016-11-01 19:13:33","2016-11-02 03:48:14","onCompleted never gets called","<ios><swift><reactive-programming><rx-swift>","1","4","","","","CC BY-SA 3.0"
"40387230","1","","","2016-11-02 18:27:57","","7","2461","<p>What is the difference betweeen these two operators ? <a href=""http://reactivex.io"" rel=""noreferrer"">http://reactivex.io</a> dont mention .subscribeNext at all.</p>
","4730700","","","","","2018-01-18 15:18:17","RxSwift - .subscribe vs .subscribeNext what is the difference?","<rx-java><rx-swift><reactivex>","1","2","0","","","CC BY-SA 3.0"
"40405811","1","40612719","","2016-11-03 15:44:59","","2","1687","<p>The thing is that I have a Protocol that contains properties I want to sort on when they are available. As I'm trying to making everything ultra Reactive.</p>

<pre><code>protocol DeviceConnectionProtocol {
...
    var id : Observable&lt;String&gt; { get }
...
}
</code></pre>

<p>And I'm in a situation where I want to find the last device I was connected to regardless of url/name/etc changed.</p>

<pre><code>  class DeviceFinder {

    let rx_DeviceList = Variable([DeviceConnectionProtocol]())
    let disposeBag = DisposeBag()

    init() {
        SMOIPConnection.FindDevices().subscribe(onNext : { smoip in
            self.rx_DeviceList.value.append(smoip)
        }).addDisposableTo(disposeBag)

        MockDevice.FindDevices().subscribe(onNext : { mock in
            self.rx_DeviceList.value.append(mock)
        }).addDisposableTo(disposeBag)

    }

}
</code></pre>

<p>...</p>

<p>This is the function I have so far for sorting. But it is not workable as device.id.map returns a Observable not a Bool that is needed for a filter operation </p>

<pre><code>struct LastConnectedDevice {

    private static let lastConnectedKeyForID = ""lastConnected""

    static func get() -&gt; Observable&lt;DeviceConnectionProtocol&gt;{
    let lastID = UserDefaults.standard.string(forKey: lastConnectedKeyForID)
       return DeviceFinder().rx_DeviceList.asObservable().flatMap{list in
            return Observable.from(list)
            }.filter { (device : DeviceConnectionProtocol) -&gt; Bool in
                return device.id.map{ id in
                    return id == lastID
                }
        }
    }
}
</code></pre>
","5061215","","2436789","","2016-11-03 16:39:35","2016-11-16 17:15:17","How do I filter a Observable on a property that is an Observable?","<ios><swift3><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"40414719","1","40415060","","2016-11-04 03:14:58","","1","1395","<p>I am beginner in RxSwift in general trying to chain two different  operation with my REST API to get all detailed products.</p>

<p>I wrapped some REST API to return RxSwift Observable, one return a list of product and other the product detail.</p>

<pre><code>class API {
    func listProduct() -&gt; Observable&lt;[Product]&gt; { ... }
    func detailProdcut(code: Int) -&gt; Observable&lt;[ProductDetail]&gt; { ... }
}
</code></pre>

<p>Now I want to get the product detail from a product list, how can I do this in Rx way ? I'm trying to do something like </p>

<pre><code>API.init().listProduct()
    .flapMap { products -&gt; &lt;Product&gt; in return products[0] }
    .map { product in API.init(product.code) }
    .merge()
    .toArray
</code></pre>

<p>But isn't work, and I very confused about how to transform one list of products code into an array of products detail</p>
","1422457","","","","","2016-11-04 03:58:39","How can I get a detailed array from another observable of array","<swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"40455824","1","","","2016-11-06 23:41:08","","8","6610","<p>I am trying to create a table view with multiple sections using RxSwift. Each section displays data representing a different type.</p>

<p>I found the <a href=""https://github.com/RxSwiftCommunity/RxDataSources"" rel=""noreferrer""><code>RxSwiftDataSources</code></a> library and implemented the example from their documentation.</p>

<p>Here is a quick runthrough of how that example is implemented:</p>

<p>A custom data type <code>CustomData</code> is defined:</p>

<pre><code>struct CustomData {
  var anInt: Int
  var aString: String
  var aCGPoint: CGPoint
}
</code></pre>

<p>Then, the representations for the section are added (note that <code>SectionModelType</code> is implemented here):</p>

<pre><code>struct SectionOfCustomData {
  var header: String    
  var items: [Item]
}
extension SectionOfCustomData: SectionModelType {
  typealias Item = CustomData

   init(original: SectionOfCustomData, items: [Item]) {
    self = original
    self.items = items
  } 
}
</code></pre>

<p>Finally, some sample data is created and bound to the table view:</p>

<pre><code>let sections: [SectionOfCustomData] = [
  SectionOfCustomData(header: ""First section"", items: [CustomData(anInt: 0, aString: ""zero"", aCGPoint: CGPoint.zero), CustomData(anInt: 1, aString: ""one"", aCGPoint: CGPoint(x: 1, y: 1)) ]),
  SectionOfCustomData(header: ""Second section"", items: [CustomData(anInt: 2, aString: ""two"", aCGPoint: CGPoint(x: 2, y: 2)), CustomData(anInt: 3, aString: ""three"", aCGPoint: CGPoint(x: 3, y: 3)) ])
]
</code></pre>

<p>I now want to modify the example and only want to display <code>String</code>s rather than instances of <code>CustomData</code> in the second section, so somewhat like this:</p>

<pre><code>let sections = [
  SectionOfCustomData(header: ""First section"", items: [CustomData(anInt: 0, aString: ""zero"", aCGPoint: CGPoint.zero), CustomData(anInt: 1, aString: ""one"", aCGPoint: CGPoint(x: 1, y: 1)) ]),
  SectionOfString(header: ""Second section"", items: [""a"", ""b"", ""c""])
]
</code></pre>

<p>This will obviously not compile as <code>sections</code> now contains elements of different types <code>SectionOfCustomData</code> an <code>SectionOfString</code>. I tried to work around this by trying to declare sections as <code>[SectionModelType]</code> but this doesn't work, the compiler complains with:</p>

<p><strong>Protocol '<code>SectionModelType</code>' can only be used as a generic constraint because it has Self or associated type requirements</strong></p>
","1779113","","1779113","","2016-11-07 01:22:29","2017-05-11 02:34:06","How to bind table view with multiple sections that represent different data types using RxSwift and RxSwiftDataSources?","<ios><swift><rx-swift><rxdatasources>","1","1","1","","","CC BY-SA 3.0"
"40456763","1","40461785","","2016-11-07 01:58:06","","0","265","<p>I have one UITableView populated by reactive viewmodel using RxSwift, pagination and refresh are working well. The viewModel.dataSource() is consuming my API and sometime I can receive a empty result parsed as error type.</p>

<p>I want to catch this error and create an empty state, hiding tableview and showing a emptyViewState. I thought I could make it with the catchError.</p>

<p>My problem is after catchError, the dataSource is disposed and I couldn't be able to recovery the empty state and repopulated the tableview, I tried to recreate the dataSource calling self.bindDataSource() but I getting fatal error.</p>

<p>There is a way to avoid dataSource disposed ? How can I reconnect / rebuild the dataSource to recovery from the empty state ?</p>

<pre><code>class MyViewControl: UIViewController {

    fileprivate let disposeBag = DisposeBag()
    fileprivate let viewModel = ViewModel()
    let dataSource = SearchViewModel.SearchDataSource()

    @IBOutlet fileprivate weak var tableView: UITableView!
    @IBOutlet weak var emptyStateView: UIView!

    override func viewDidLoad() {
        super.viewDidLoad()

        // When I disable tableview, can see a hidden view with empty state message and one button
        viewModel.isTableViewHidden
        .bindTo(tableView.rx.isHidden)
        .addDisposableTo(disposeBag)
        self.setupTableView()
    }

    fun setupTableView() {
        // ... setup table view
        self.bindDataSource()
    }
    fileprivate func bindDataSource() {
    // Bind dataSource from search to UITableView
        viewModel.dataSource()
            .debug(""[DEBUG] Loading Search Tableview "")
            .bindTo( tableView.rx.items(dataSource: dataSource) )
            .addDisposableTo( disposeBag )
    }

    @IBAction fileprivate func emptyStateAction(_ sender: UIButton) {
        // Do something and try to recreate the bindDataSource
        self.bindDataSource()
    }
}

class SearchViewModel {
    private let disposeBag = DisposeBag()
    typealias SearchDataSource = RxTableViewSectionedReloadDataSource&lt;PaginationStatus&lt;WorkerEntity&gt;&gt;

    let isTableViewHidden = BehaviorSubject&lt;Bool&gt;(value: false)

    // Controls to refresh and paging tableview
    let refreshTrigger  = BehaviorSubject&lt;Void&gt;(value:())
    let nextPageTrigger = PublishSubject&lt;Void&gt;()

    // Others things happing herer

    func dataSource() -&gt; Observable&lt;[PaginationStatus&lt;WorkerEntity&gt;]&gt; {
        return self.refreshTrigger.debug(""[DEBUG] Refreshing dataSource"")
        .flatMapLatest { [unowned self] _ -&gt; Observable&lt;[PaginationStatus&lt;WorkerEntity&gt;]&gt; in 
            // Access the API and return dataSource
        }
        .catchError { [unowned self] error -&gt; Observable&lt;[PaginationStatus&lt;WorkerEntity&gt;]&gt; in
            // Hidden the tableview
            self.isTableViewHidden.onNext(true)
            // Do others things
            return Observable.of([PaginationStatus.sectionEmpty])
        }
    }
}
</code></pre>
","1422457","","","","","2016-11-07 09:29:46","How to recovery dataSource after disposed from a catchError","<ios><swift><uitableview><rx-swift>","1","0","","","","CC BY-SA 3.0"
"40458241","1","","","2016-11-07 05:14:05","","1","2507","<p>I'm new to RxSwift, trying to wrap my head around it.  I was having trouble getting a UIButton in a cell to show a UIAlertController when it's pressed. </p>

<pre><code>private func setupCellConfiguration() {
        bookListViewModel.data
            .bindTo(collectionView.rx.items(cellIdentifier: BookListCell.Identifier, cellType: BookListCell.self)) { [unowned self] (row, element, cell) in
                cell.configureForBook(book: element)
                cell.moreButton.rx.tap.subscribe { [weak self] in
                    let alertController = UIAlertController(title: nil, message: nil, preferredStyle: .actionSheet)
                    let cancelAction = UIAlertAction(title: ""Cancel"", style: .cancel) {(action) in
                        self?.dismiss(animated: true, completion: nil)
                    }
                    alertController.addAction(cancelAction)
                    let destroyAction = UIAlertAction(title: ""Delete"", style: .destructive) { (action) in

                    }
                    alertController.addAction(destroyAction)
                    self?.present(alertController, animated: true)
                }
                .addDisposableTo(self.disposeBag)
            }
            .addDisposableTo(disposeBag)
 }
</code></pre>

<p>Nothing happens when it's pressed. What am I doing wrong here?</p>
","3354041","","","","","2016-11-16 06:10:06","Subscribing to UIButton tap in a UICollectionViewCell in RxSwift?","<ios><swift><uibutton><frp><rx-swift>","1","1","","","","CC BY-SA 3.0"
"40485563","1","","","2016-11-08 11:19:10","","1","392","<p>I need to create dependent API calls where the second one needs a value returned by the first one. First thing that comes to mind is using flatMap</p>

<pre><code>ApiManager.shared
    .createReport(report: report)
    .flatMap { (report) -&gt; Observable&lt;Report&gt; in
        return ApiManager.shared.createReportStep(reportID: report.ID)
    }
</code></pre>

<p><code>createReport</code> returns <code>Observable&lt;Report&gt;</code> where after successfull call returns updated <code>Report</code> model(with ID), after that I need to call API to create report step, where <code>report.ID</code> is needed.</p>

<p>Everything looks and works fine with that code, but the problem comes when I need to do something after each of these steps(<code>createReport</code> and <code>createReportStep</code>). I placed code in <code>onNext</code> block, but it is called only once, after both of the steps are completed.</p>

<p>Is there a way to receive onNext signal after both steps? I could use something like this:</p>

<pre><code>ApiManager.shared
      .createReport(report: report)
      .concat(ApiManager.shared.createReportStep(reportID: report.ID))
</code></pre>

<p>Which would emmit two signals like I want, but then again where do I get updated <code>report.ID</code> from to pass to <code>createReportStep</code>?</p>
","2659619","","","","","2016-11-13 06:09:23","Chaining dependent observables","<ios><swift><rx-swift><reactivex>","1","1","0","","","CC BY-SA 3.0"
"40489953","1","","","2016-11-08 14:51:26","","0","616","<blockquote>
  <p>How to write rigth it with Alamofire and RxSwift? I try to use
  RxAlamofire but it's look so strange
  How to write rigth it with Alamofire and RxSwift? I try to use
  RxAlamofire but it's look so strange</p>
</blockquote>

<p>My Json%</p>

<pre><code>""session"": {

   ""sessionToken"":  ""16mpmthgkj6vjcco9u073fe61njhikbcn47s1co7bsfg110oefn4"",  
   ""refreshToken"": ""4ap0dqnuttpm5pv18njhthqv2d"",  
   ""expirationDate"":""2016-10-17 03:44:28.826 +0000""       
},   
""profile"":  
{

   ""userId"": ""abUser$gT5d67g"",  
   ""userPhone"": 380995392020,  
   ""createdAt"": ""2016-08-14 03:44:28.826 +0000""  
}


    let registraion = request(.post, baseUrlDev + kRegUrl, parameters: phoneData, encoding:  JSONEncoding.prettyPrinted, headers: headers)
        .flatMap {
            $0
                .validate(statusCode: 200 ..&lt; 300)
                .validate(contentType: [""application/json"",""text/html""])
                .rx.responseJSON()
        }

        .observeOn(MainScheduler.instance)
        .subscribe(onNext: {  response in
            let data = response.1
            let json = JSON(data)
            let sessionArray = json[""session""]
            let userArray  = json[""profile""]
            print(json)
           //here covert to json and save as realm object
            do{
                let session = Session()
                session.mToken = sessionArray[""authToken""].string
                session.mRefreshToken = sessionArray[""refreshToken""].string
                session.mExpirationDate = sessionArray[""expirationDate""].string
                session.mExpired = false

                try realm.write {
                    realm.add(session, update: true)
                }
            }
            catch let err as NSError {
                print(""Error with realm: "" + err.localizedDescription)
            }


        }).addDisposableTo
    }
</code></pre>
","6320257","","2431702","","2016-11-11 10:30:15","2016-11-11 10:30:15","How to write rigth it with Alamofire and RxSwift?","<realm><alamofire><rx-swift>","0","4","","","","CC BY-SA 3.0"
"40519002","1","","","2016-11-10 02:17:25","","0","813","<p>Given my App will download files from a server and I only want <strong>1 download to be progressed at the same time</strong>, then how could this be done with <code>RxAlamofire</code>? I might simply be missing an Rx operator.
Here's the rough code:</p>

<pre><code>Observable
    .from(paths)
    .flatMapWithIndex({ (ip, idx) -&gt; Observable&lt;(Int, Video)&gt; in
        let v = self.files![ip.row] as! Video
        return Observable.from([(idx, v)])
    })
    .flatMap { (item) -&gt; Observable&lt;Video&gt; in
        let req = URLRequest(url: item.1.downloadURL())

        return Api.alamofireManager()
            .rx
            .download(req, to: { (url, response) -&gt; (destinationURL: URL, options: DownloadRequest.DownloadOptions) in
              ...
            })
            .flatMap({ $0.rx.progress() })
            .flatMap { (progress) -&gt; Observable&lt;Float&gt; in
              // Update a progress bar
              ...
            }
            // Only propagate finished items
            .filter { $0 &gt;= 1.0 } 
            // Return the item itself
            .flatMap { _ in Observable.from([item.1]) }
    }
    .subscribe(
      onNext: { (res) in
        ...
      },
      onError: { (error) in
        ...
      },
      onCompleted: {
        ...
      }
    )
</code></pre>

<p>My problem is <strong>a)</strong> RxAlamofire will download multiple items at the same time and <strong>b)</strong> the (progress) block is called multiple times for those various items (with different progress infos on each, causing the UI to behave a bit weird).</p>

<p><strong>How to ensure the downloads are done one by one instead of simultaneously?</strong></p>
","375209","","375209","","2016-11-14 07:45:27","2016-11-15 15:47:40","Limiting simultaneous downloads using RxAlamofire","<alamofire><rx-swift><rxalamofire>","1","2","","","","CC BY-SA 3.0"
"40583685","1","40583895","","2016-11-14 07:21:38","","2","1581","<p>In <a href=""https://stackoverflow.com/questions/35003355/weak-self-in-rxswift-closures"">other stack overflow questions</a>, it was emphasized that the capture <code>[weak self]</code> should be used for closures that aren't owned by the class because <code>self</code> could be nil before the closure completes. An alternative when the closure is owned by the class itself is <code>[unowned self]</code>.</p>

<p>My question is do I need to use <code>[unowned self]</code> when the function I pass as a parameter is an instance method of the current class? </p>

<h2>Example</h2>

<pre><code>import RxSwift

class Person {
    var name = ""Default name""

    class func getPersons() -&gt; Observable&lt;Person&gt; {
        // ...
    }


}

class MyController: UIViewController {
    let disposeBag = DisposeBag()

    // I know this right
    func unownedDisplayPeople() {

        Person.getPersons()
            .subscribeNext { [unowned self ] person in
                self.displayName(person)
            }
            .addDisposableToBag(disposeBag)
    }

    // But what about this?
    func whatAboutThisDisplayPeople() {

        Person.getPersons()
            .subscribeNext(displayName)
            .addDisposableToBag(disposeBag)
    }

    // Or this?
    func orThisDisplayPeople() {

        Person.getPersons()
            .subscribeNext(self.displayName)
            .addDisposableToBag(disposeBag)
    }

    func displayName(person: Person) {
        print(""Person name is \(person.name)"")
    }
}
</code></pre>

<p>If I still need to think about the reference counting when I just pass an instance method, how do I do it? Where do i put the <code>[unowned self]</code>? Or is it considered <code>[unowned self]</code> already when I just pass the instance method?</p>
","1323398","","-1","","2017-05-23 12:08:46","2016-12-13 15:59:24","Using 'self' on RxSwift closures... What about instance methods as param?","<memory><swift2><rx-swift><retain-cycle><retaincount>","1","2","","","","CC BY-SA 3.0"
"40637771","1","","","2016-11-16 16:51:50","","1","699","<p>I have the following setup, where I want to load a GitHub user from the GitHub API based on the username that can be typed into a text field. </p>

<pre><code>class SearchUserViewController: UIViewController {

  @IBOutlet weak var nameTextField: UITextField!
  @IBOutlet weak var activityIndicator: UIActivityIndicatorView!
  @IBOutlet weak var repositoriesButton: UIButton!

  let httpClient = HTTPClient()
  let disposeBag = DisposeBag()

  override func viewDidLoad() {
    super.viewDidLoad()
    repositoriesButton.isEnabled = false
    activityIndicator.hidesWhenStopped = true

    setupUserObservable()
  }

 func setupUserObservable() {

    let maybeUserObservable: Observable&lt;User?&gt;= nameTextField.rx.text
      .throttle(0.5, scheduler: MainScheduler.instance)
      .flatMapLatest { query in
        self.fetchUser(username: query!)
          .observeOn(MainScheduler.instance) 
          .catchErrorJustReturn(nil) 
      }

    // bind button enabled property
    maybeUserObservable
      .map { return $0 != nil }
      .bindTo(repositoriesButton.rx.isEnabled)
      .addDisposableTo(disposeBag)

  }

  func fetchUser(username: String) -&gt; Observable&lt;User?&gt; {

    let url = httpClient.searchUserURL(for: username)!
    let jsonObservable = URLSession.shared.rx.json(url: url)

    let userObservable: Observable&lt;User?&gt; = jsonObservable.map { (json: Any) -&gt; [String: Any]? in
      guard let userInfo = json as? [String: Any] else {
        return nil
      }
      return userInfo
      }.map { (maybeUserInfo: [String: Any]?) -&gt; User? in
        guard let userInfo = maybeUserInfo else {
          return nil
        }
        return self.httpClient.jsonToOptionalUser(userInfo: userInfo)
    }
    return userObservable
  }

}
</code></pre>

<p>So, the setup is pretty standard I believe. It all works well so far, the <code>repositoriesButton</code>'s <code>isEnabled</code>-property is only set to <code>true</code> if a <code>User</code> was found for the provided username.</p>

<p>However, I also would like to animate the <code>activityIndicator</code> when a network request is going on. Ideally, I would also like to <em>bind</em> it's <code>isAnimating</code> property using <code>bindTo</code>. However, that doesn't work because the only info I get that I cam use for bindings based on the <code>maybeUserObservable</code> is whether a <code>User</code> was returned or not. So, this is not the same as saying whether a network request is ongoing or not.</p>

<p>So, how can I make sure that <code>activityIndicator.isAnimating</code> is set to <code>true</code> whenever a network request is started and to <code>false</code> as soon as it returns - no matter whether a <code>User</code> was actually returned or not?</p>
","1779113","","","","","2016-11-16 16:51:50","How to bind UIActivityIndicator using RxSwift?","<ios><swift><rx-swift>","0","1","0","2016-11-17 22:30:51","","CC BY-SA 3.0"
"40650869","1","","","2016-11-17 09:16:42","","0","371","<p>How to map the following Json array using ObjectMapper for realm on RxSwift 3?  please help me. Thank you anyway.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>class func getMessagesRequest(parameters: [String: Any]?, headers: [String:String] )  -&gt; Observable&lt;Any&gt; {
    return request(.post,  kGetMsgHistory , parameters: parameters, encoding: JSONEncoding.default, headers: headers)
        .subscribeOn(MainScheduler.asyncInstance)
        .flatMap {response -&gt;Observable&lt;Any&gt; in
            return response.validate(statusCode: 200..&lt;300)
                .validate(contentType: [""application/json"",""text/json""])
                .rx.json()
        }

""messages"" : 
[
    {
      ""drTime"" : 1478855430000,
      ""messageId"" : ""59257"",
      ""options"" : {
        ""pushBidirectionalUrl"" : null,
        ""img"" : ""https:\/\/lh3.googleusercontent.com\/K272HPMCfs6k_zqvvt83pzowaIctVT6TO60kM561CWrOxGjePNZfiU-6H0Zj4YHHv9-f=w300-rw"",
        ""caption"" : ""Posters"",
        ""action"" : ""https:\/\/details.com?id=com.pomelogames.MarsGame""
      }
    },
    {
      ""drTime"" : 1478855440000,
      ""messageId"" : ""59258"",
      ""options"" : {
        ""pushBidirectionalUrl"" : null,
        ""img"" : ""https:\/\/lh3.googleusercontent.com\/K272HPMCfs6k_zqvvt83pzowaIctVT6TO60kM561CWrOxGjePNZfiU-6H0Zj4YHHv9-f=w300-rw"",
        ""caption"" : ""Posters"",
        ""action"" : ""https:\/\/details.com?id=com.pomelogames.MarsGame""
      }
    },</code></pre>
</div>
</div>
</p>
","6320257","","6320257","","2017-07-04 07:03:52","2017-07-04 07:03:52","How to map this Json array using ObjectMapper for realm?","<swift><realm><rx-swift><objectmapper>","0","5","","","","CC BY-SA 3.0"
"40707094","1","40714047","","2016-11-20 17:30:24","","3","4744","<p>Observable.combineLatest(...){...} contains several observables, but some of these observables were not emitted. </p>

<p>combineLatest emits only when all observables in this method were emitted.</p>

<p>How to skip not emitted observables and emit combineLatest?</p>

<pre><code>let tap = firstButton.rx.tap.asObservable().map{ (_) -&gt; Observable&lt;Item&gt; ...}

let textfieldObservable = viewTextField.rx.text.orEmpty.asObservable()

submitButton.rx.tap.withLatestFrom(Observable.combineLatest(textfieldObservable, tap ... )).flatMapLatest({
...
// this method will not be executed without tap on firstButton before tapping on submitButton

}
)
</code></pre>
","5485334","","","","","2019-02-09 04:04:12","RxSwift. CombineLatest. Not all observables emitted","<ios><swift><rx-swift><rx-cocoa>","1","1","","","","CC BY-SA 3.0"
"40749161","1","","","2016-11-22 18:31:44","","4","764","<p>I would like to have a protocol that looks something like this:</p>

<pre><code>protocol ReturnType {
    var returnType: ImmutableMappable.Type { get }
}
</code></pre>

<p>The part of the enum implementing the protocol:</p>

<pre><code>extension ShimEndPoint: ReturnType {
    var returnType: ImmutableMappable.Type {
        switch self {
        case .deAuthorize(_, _):
            return EmptyResponse.self
        case .authorize(_, _):
            return AuthorizeResponse.self
        case .step(_, _, _, _):
            return StepResponse.self 
        }
    }
}
</code></pre>

<p>EmptyResponse, AuthorizeResponse and StepResponse all implement ImmutableMappable.
Now I would like to use the ""returnType"" property in a function call:</p>

<pre><code>return Shim.provider
    .request(endPoint)
    .timeout(7,
             scheduler: MainScheduler.asyncInstance)
    .retry(3)
    .mapObject(endPoint.returnType)
</code></pre>

<p>The line mapObject gives me the following compiler error:
""Cannot convert value of type 'ImmutableMappable.Type' to expected argument type 'T.Type'</p>

<p>The function signature of ""mapObject"" is:</p>

<pre><code>public func mapObject&lt;T : ImmutableMappable&gt;(_ type: T.Type) -&gt; RxSwift.Observable&lt;T&gt;
</code></pre>

<p><strong>How do I define and implement the protocol so I can pass in my returnType to the mapObject function?</strong></p>

<p>I found a similar question but unfortunately I could not solve my problem with the help of the answer given:
<a href=""https://stackoverflow.com/questions/27404137"">Returning constrained generics from functions and methods</a></p>
","1113632","","-1","","2017-05-23 12:17:54","2016-12-10 08:21:57","How do I implement a Swift protocol with a generic constrained type property?","<ios><swift><generics><protocols><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"40766206","1","40789460","","2016-11-23 13:46:10","","4","4906","<p>I need to bind <code>slider.rx.value</code> to 2 observers with different mappings.</p>

<pre><code>slider.rx.value.map  { [unowned self] in self.formatter.string(from: NSNumber(value: $0)) ?? """" }
    .bindTo(textFieldAlpha.rx.text)
    .addDisposableTo(disposeBag)

slider.rx.value.map { Enhance.Global(alpha: $0) }
    .bindTo(enhance)
    .addDisposableTo(disposeBag)
</code></pre>

<p>But i seems that only last binding works. How to achieve this?</p>
","6248762","","1113632","","2016-11-24 15:23:12","2018-09-04 22:37:47","How to bind multiple observers to one ControlProperty","<ios><swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"40775138","1","","","2016-11-23 22:24:30","","1","1012","<p>I am trying to make an iOS app using <code>MVVM</code> architecture. Now what I want is that if an observable fails, I will show the user a prompt asking if he wants to cancel or retry. This should be simple enough with <code>retryWhen</code> but retry is never called. Here my code:</p>

<pre><code>.retryWhen({ (errorObservable: Observable&lt;Error&gt;) -&gt; Observable&lt;Error&gt; in
  return promptFor(""test"", cancelAction: RetryResult.cancel, actions: [RetryResult.retry])
    .flatMap { action -&gt; Observable&lt;Error&gt; in
      switch action {
      case .retry:
        return errorObservable
      case .cancel:
        return errorObservable.flatMap { Observable.error($0) }
      }
    }
})
</code></pre>

<p>prompt is just a method I took from RxSwiftExample and can be found in the repo, but for ease here it is: </p>

<pre><code>func promptFor&lt;Action : CustomStringConvertible&gt;(_ message: String, cancelAction: Action, actions: [Action]) -&gt; Observable&lt;Action&gt; {
#if os(iOS)
    return Observable.create { observer in
        let alertView = UIAlertController(title: ""RxExample"", message: message, preferredStyle: .alert)
        alertView.addAction(UIAlertAction(title: cancelAction.description, style: .cancel) { _ in
            observer.on(.next(cancelAction))
        })

        for action in actions {
            alertView.addAction(UIAlertAction(title: action.description, style: .default) { _ in
                observer.on(.next(action))
            })
        }

        (UIApplication.shared.delegate as! AppDelegate).window?.rootViewController?.present(alertView, animated: true, completion: nil)

        return Disposables.create {
            alertView.dismiss(animated:false, completion: nil)
        }
    }
#elseif os(macOS)
    return Observable.error(NSError(domain: ""Unimplemented"", code: -1, userInfo: nil))
#endif
</code></pre>

<p>can anyone explain why this is not working? or even offer a solution? </p>
","1818120","","1173513","","2016-11-24 08:08:42","2017-05-04 13:12:41","use RxSwift's retryWhen operator to prompt the user for a retry or cancel","<ios><swift><rx-swift>","0","1","2","","","CC BY-SA 3.0"
"40797515","1","","","2016-11-25 04:00:55","","1","1904","<p>I'm new in RXSwift, I just try to implement a simple async example</p>
<p>but subscribe will never be called.</p>
<p>What I miss ?</p>
<pre><code>let disposeBag = DisposeBag()
        
Observable&lt;Any&gt;.create {

    observer in
    
    DispatchQueue.global(qos: .background).asyncAfter(deadline: .now() + 3) {
        
        observer.onNext(&quot;done&quot;)
        
        observer.onCompleted()
        
    }
    
    return Disposables.create()
    
}
.subscribe { print($0) }
.addDisposableTo(disposeBag)
</code></pre>
<p>================= UPDATE ======================</p>
<p>I'm trying to do something more advanced, a chain which allow pass value from previous, but the result was not expected. what I miss ?</p>
<p>output was</p>
<blockquote>
<p>next(done 1 - done 2)</p>
</blockquote>
<p>what I expected was</p>
<blockquote>
<p>next(done 1)</p>
<p>next(done 1 - done 2)</p>
<p>completed</p>
</blockquote>
<pre><code>class AsyncObject {
    
    func asyncTest1() -&gt; Observable&lt;String&gt; {
        
        return Observable&lt;String&gt;.create {
            
            (o: AnyObserver&lt;String&gt;) -&gt; Disposable in
            
            DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                
                o.onNext(&quot;done 1&quot;)

                o.onCompleted()
                
            }
            
            return Disposables.create()
            
        }
        
    }
    
    func asyncTest2(value: String) -&gt; Observable&lt;String&gt; {
        
        return Observable&lt;String&gt;.create {
            
            (o: AnyObserver&lt;String&gt;) -&gt; Disposable in
            
            DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                
                o.onNext(&quot;\(value) - done 2&quot;)
                
                o.onCompleted()
                
            }
            
            return Disposables.create()
            
        }
        
    }
    
}

class ViewController: UIViewController {
    
    let disposeBag = DisposeBag()
    
    let observer = AsyncObject()
    
    // MARK: Init Methods
    
    override func viewDidLoad() {
        
        super.viewDidLoad()
        
        self.observer.asyncTest1()
        .flatMap { self.observer.asyncTest2(value: $0) }
        .subscribe { print($0) }
        .addDisposableTo(disposeBag)
        
    }

}
</code></pre>
","1822879","","-1","","2020-06-20 09:12:55","2019-11-13 16:37:15","RXSwift simple async example?","<swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"40798441","1","40871453","","2016-11-25 05:43:54","","2","72","<p>Are there solutions for chaining Observables of different types?
I want to <code>merge</code> Observables, and when each of them sends the <code>Completed</code> event, emit the next Observable (<code>signal</code>). </p>

<p>Something similar to <code>ReactiveCocoa</code>'s <code>then</code>.</p>

<pre><code>let signal = Observable&lt;String&gt;.create { observer in
    observer.onCompleted()
    return Disposables.create()
}

let signals: [Observable&lt;Int&gt;] = [Observable.just(1), Observable.just(2), Observable.just(3)]

Observable.from(signals).merge().concat(signal).subscribe {
    print(""completed"")
}
</code></pre>
","3733734","","343299","","2016-11-25 15:55:14","2016-11-29 16:55:52","Merge observables on one type and then chain to obserbable of another type","<ios><swift><rx-swift>","2","0","0","","","CC BY-SA 3.0"
"40798522","1","","","2016-11-25 05:51:39","","2","4172","<p>Is there elegant solution for creating <strong>delay</strong> for <code>retry</code>? When error occurs I want to wait for 5 seconds and restart Observable (<code>retry</code>) </p>
","3733734","","","","","2020-05-31 06:52:27","Delay for Retry - RxSwift","<ios><swift><rx-swift>","2","0","0","","","CC BY-SA 3.0"
"40811273","1","40843641","","2016-11-25 19:25:56","","6","2423","<p>I want to use <code>CLLocationManager</code> with <code>RxSwift</code> like in <br/><a href=""https://github.com/ReactiveX/RxSwift/issues/413"" rel=""noreferrer"">https://github.com/ReactiveX/RxSwift/issues/413</a><br/> but I found that <code>CLLocationManager</code> extension was moved to <code>RxExample</code> <br/>(mentioned here <a href=""https://github.com/ReactiveX/RxSwift/issues/900"" rel=""noreferrer"">https://github.com/ReactiveX/RxSwift/issues/900</a>).</p>

<p>My question is: how to use that code? When I import <code>RxSwift</code> and <code>RxCocoa</code> I don't have access to e.g. <code>locationManager.rx.didUpdateLocations</code>. What should I do so that I can use <code>CoreLocation</code> with <code>RxSwift</code>?</p>

<p>I'm using Xcode 8, Swift 3.</p>

<p>Thanks in advance for your help! </p>

<h2>Update</h2>

<p>I found that it is recommended that for now we must just copy &amp; paste <code>CLLocationManager</code> extension from <code>RxExample</code> (details <a href=""https://github.com/ReactiveX/RxSwift/commit/2e8736b137064101cd98ee01523e6229825cecce#commitcomment-18981218"" rel=""noreferrer"">here</a> in comments of that commit).</p>
","4646572","","4646572","","2016-11-26 08:56:46","2019-05-10 22:21:16","How to use CLLocation extension in RxSwift","<ios><swift3><cllocation><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"40829595","1","40839675","","2016-11-27 13:40:08","","2","1564","<pre><code>func signup(_ username: String, password: String) -&gt; Observable&lt;Bool&gt; {
    // this is also just a mock
    let signupResult = arc4random() % 5 == 0 ? false : true
    return Observable.just(signupResult)
        .concat(Observable.never())
        .throttle(0.4, scheduler: MainScheduler.instance)
        .take(1)
 }
</code></pre>

<p>I see some code in <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/GitHubSignup/DefaultImplementations.swift"" rel=""nofollow noreferrer"">RxSwift</a>, But I could not understand why need to <code>concat(Observable.never())</code></p>
","7204290","","","","","2017-06-03 03:27:58","why concat never() in rxswift","<ios><rx-swift><reactive>","3","0","1","","","CC BY-SA 3.0"
"40845052","1","40845543","","2016-11-28 13:04:18","","1","549","<p>in <code>Swift3</code> i've a problem :</p>

<pre><code>@IBOutlet weak var connectButton: UIButton!
[...]
viewModel.connectButtonTitle.asObservable().bindTo(connectButton.rx_title).addDisposableTo(disposeBag)
</code></pre>

<blockquote>
  <p>Cannont compile -> Ambiguous reference to bindTo.</p>
</blockquote>

<p>I don't understand why.</p>

<p>Declaration of <code>connectButtonTitle</code>:</p>

<pre><code>let connectButtonTitle = Variable&lt;String?&gt;("""")
[...]
driver.isConnected.asObservable()
        .map({(isConnected:Bool) -&gt; String in
            let connected = (!isConnected) ? ""connect"" : ""disconnect"";
            return connected + ""blabla""
    }).bindTo(connectButtonTitle).addDisposableTo(disposeBag)
</code></pre>

<p>Thx for your help ! </p>
","3551984","","1647074","","2016-11-28 13:08:39","2016-11-28 13:30:22","ambiguous reference to bindTo","<ios><swift3><rx-swift>","1","2","","","","CC BY-SA 3.0"
"40894016","1","","","2016-11-30 16:57:57","","3","679","<p>I have an array of images.</p>

<pre><code>let images:[UIImage]
</code></pre>

<p>I want to upload images to the server, after uploading each image I will get the URL of the image as a response. </p>

<p>How to organize a uploading chain(loop) and get all responses using RxAlamofire?</p>

<p>P.S. I did not find examples of uploading multipart data to the server using RxAlamofire</p>
","5485334","","","","","2016-11-30 16:57:57","Uploading file with parameters using RxAlamofire","<ios><swift><rx-swift><rxalamofire>","0","1","","","","CC BY-SA 3.0"
"40902358","1","","","2016-12-01 03:53:58","","0","157","<p>I update a cell by the following code. When cell's data is loaded, the cell looks well at first the time, but when I make some changes on property value of 'selected', the 'bindTo' has no effect? why?</p>

<blockquote>
  <p><strong>MyController.swift</strong>:</p>
</blockquote>

<pre><code>func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
    var model = xxxxxxxxx
    cell.setModel(model)
}
</code></pre>

<blockquote>
  <p><strong>MyTableViewCell.swift</strong>:</p>
</blockquote>

<pre><code>var model = PublishSubject&lt;MyClass&gt;()

func setModel(newModel: MyClass) {
   self.model.onNext(newModel)
}

override func awakeFromNib() {
   super.awakeFromNib()
   // Initialization code
   self.setup()
}

func setup() {
   model.map{$0.selected}
        .bindTo(selectButton.rx_selected)
        .addDisposableTo(disposeBag)
}
</code></pre>
","1707739","","2695387","","2016-12-03 03:34:33","2016-12-03 03:34:33","Why is the method bindTo of RXSwift failing","<swift><tableviewcell><rx-swift>","1","0","","","","CC BY-SA 3.0"
"40919920","1","40920923","","2016-12-01 20:37:09","","14","12095","<p>First of all, I'm new to rxswift so I guess the answer is obvious however at the moment I can't find solution by myself.</p>

<p>I have two functions:</p>

<pre><code>func downloadAllTasks() -&gt; Observable&lt;[Task]&gt;
func getTaskDetails(taskId: Int64) -&gt; Observable&lt;TaskDetails&gt;
</code></pre>

<p>First one is downloading the list of Task objects using network request, second one downloading task details for sepcific task (using it's id)</p>

<p>What I want of achieve is to download all tasks and then for each task I want to download its details and subscribe for the event fired when all tasks details are ready.</p>

<p>So I guess I should subscribe somehow to Observable&lt;[TaskDetails]> but I don't know how to do it.</p>

<pre><code>        downloadAllTasks()
        .flatMap{
            ... // flatMap? something else?
        }
        .subscribe(
            onNext: { details in
                print(""tasks details: \(details.map{$0.name})"")
        })
        .addDisposableTo(disposeBag)
</code></pre>

<p>//EDIT</p>

<p>Thanks to Silvan Mosberger answer I'm much closer to the solution. One problem left. Now I have something like this:</p>

<pre><code>    downloadAllTasks()
        .flatMap{ Observable.from($0) } 
        .map{ $0.id }
        .flatMap{ [unowned self] id in
            self.getTaskDetails(taskId: id).catchError{ error in
                print(""$$$ Error downloading task \(id)"")
                return .empty()
            }
        }
        .do(onNext: { _ in
            print("" $$$ single task details downloaded"")
        } )
        .toArray()
        .debug(""$$$ task details array debug"", trimOutput: false)
        .subscribe({ _ in
            print(""$$$ all tasks downloaded"")
        })
        .addDisposableTo(disposeBag)
</code></pre>

<p>The output is </p>

<pre><code>$$$ task details array debug -&gt; subscribed
$$$ single task details downloaded
$$$ single task details downloaded
$$$ single task details downloaded
</code></pre>

<p>There are 3 tasks available so as you can se all of them are downloaded properly however for some reason the result of toArray() - (<code>Observable&lt;[TaskDetails]&gt;</code>) doesn't produce ""onNext"" once all task details are ready.</p>

<p>// Edit once more</p>

<p>Ok, I'm adding simplified version of functions providing observables, maybe it will help something</p>

<pre><code>func downloadAllTasks() -&gt; Observable&lt;Task&gt; {
    return Observable.create { observer in

            //... network request to download tasks
            //...

            for task in tasks {
                observer.onNext(task)
            }
            observer.onCompleted()

        return Disposables.create()
    }
}


func getTaskDetails(id: Int64) -&gt; Observable&lt; TaskDetails &gt;  {
    return Observable.create { observer in

        //... network request to download task details
            //...

        observer.onNext(taskDetails)

        return Disposables.create()
    }
}
</code></pre>
","3077831","","3040446","","2018-07-07 06:44:25","2018-07-07 06:44:25","Proper usage of RxSwift to chain requests, flatMap or something else?","<ios><swift><rx-swift>","1","0","9","","","CC BY-SA 4.0"
"40936295","1","40943951","","2016-12-02 16:01:26","","10","3845","<p>The <a href=""http://reactivex.io/documentation/operators/create.html"" rel=""noreferrer"">ReactiveX.io documentation</a> uses <code>AnonymousDisposable</code>, which was in RxSwift 2.x, but is an unresolved identifier in RxSwift 3.0.  What should I use instead?</p>

<pre><code>let source = Observable.create { observer in
  for i in 1...5 {
    observer.on(.Next(i))
  }
  observer.on(.Completed)

  // Note that this is optional. If you require no cleanup you can return
  // NopDisposable.instance
  return AnonymousDisposable {
    print(""Disposed"")
  }
}

source.subscribe {
  print($0)
}
</code></pre>
","935579","","935579","","2016-12-02 16:31:07","2019-06-21 17:50:41","What is the RxSwift 3.0 equivalent to AnonymousDisposable from RxSwift 2.x?","<swift><swift3><rx-swift>","3","0","1","","","CC BY-SA 3.0"
"40943500","1","","","2016-12-03 02:02:15","","2","5726","<p>I ran into the following error:</p>

<pre><code>Cannot convert value of type '(_) -&gt; Observable&lt;Response&gt;' 
to expected argument type '([_]) -&gt; _'
</code></pre>

<p>when I tried to compile: </p>

<pre><code>func request(_ token: MyAPI) -&gt; Observable&lt;Moya.Response&gt; {
    switch (target.requiresCSRF, target.requiresOAuth) {
    case (false, false): return actualRequest 
    case (true, false): return CSRFTokenRequest().flatMap { _ in actualRequest }
    case (false, true): return OAuthTokenRequest().flatMap { _ in actualRequest }
    case (true, true): return Observable.zip([CSRFTokenRequest(), OAuthTokenRequest()]) { _ in actualRequest }
    } 
}
</code></pre>

<p>actualRequest is of type <code>Observable&lt;Response&gt;</code>
both CSRFTokenRequest and OAuthTokenRequest is of type <code>Observable&lt;String?&gt;</code></p>

<p>I'm trying to run <strong>CSRFTokenRequest</strong> before <strong>OAuthTokenRequest</strong> and then the actual request.</p>

<p>The following resolves the issue... but I'm not sure if this is the right way to do it...</p>

<pre><code>return RequiresCSRFTokenRequest().flatMap{ _ in
            self.RequiresAuthenticationRequest().flatMap{ _ in actualRequest}
        }



fileprivate extension Networking{

    func RequiresAuthenticationRequest() -&gt; Observable&lt;String&gt; {

        /// This has 3 cases

        // 0. token is not present, error out
        // 1. token is not expired, return token
        // 2. token is expired, needs refresh

        guard let jwt = AuthManager.shared.accessToken else{
            return .just(""Error!! No access tokens"")
        }

        // If access token is valid
        if AuthManager.shared.expiredAccessToken == false{

            return .just(jwt)

        }else{

            return request(.refreshAccessToken(refreshToken: AuthManager.shared.refreshTokenWithBearer!))
                .filterSuccessfulStatusCodes()
                .mapObject(type: UserAuthenticationTokens.self)
                .do(onNext: {
                    $0.save()})
                .map{ (token) -&gt; String in
                    // Get new access token that was just saved
                    return AuthManager.shared.accessToken!
            }
        }

    }


    func RequiresCSRFTokenRequest() -&gt; Observable&lt;String&gt; {

        // Always get a new csrf token
        return request(.getCSRF())
            .filterSuccessfulStatusCodes()
            .mapObject(type: CSRFToken.self)
            .do(onNext: {
                $0.save()
            }).map{ (token) -&gt; String in
                return AuthManager.shared.csrf_token!
            }
    }

}
</code></pre>

<p>Thanks! </p>
","805981","","805981","","2016-12-03 04:42:31","2016-12-03 04:42:31","Cannot convert value of type '(_) -> Observable<Response>' to expected argument type '([_]) -> _'","<swift><reactive-programming><rx-swift><moya>","1","6","2","","","CC BY-SA 3.0"
"40973365","1","40973782","","2016-12-05 11:35:18","","1","1764","<p>I'm new to <code>RxSwift</code> and want to achieve the following. I have a <code>email and password TextField</code>. When you've entered a text in both <code>textfields</code> a button should be enabled. </p>

<p>In my ViewController I do the following:</p>

<pre><code>txtEmail.rx.text.asObservable()
  .bindTo(viewModel.email)
  .addDisposableTo(disposeBag)

txtPassword.rx.text.asObservable()
  .bindTo(viewModel.password)
  .addDisposableTo(disposeBag)

viewModel.buttonEnabled
  .bindTo(btnLogin.rx.isEnabled)
  .addDisposableTo(disposeBag)
</code></pre>

<p>And here is my ViewModel:</p>

<pre><code>import Foundation
import RxSwift
import RxCocoa

class LoginViewModel {

    let email = Variable&lt;String?&gt;("""")
    let password = Variable&lt;String?&gt;("""")

    var buttonEnabled: Observable&lt;Bool&gt;

    init() {

        var processedEmail: Observable&lt;String&gt;!
        var processedPassword: Observable&lt;String&gt;!

        processedEmail = email.asObservable().map(String.toLower as! (String?) -&gt; String).map(String.trimWhiteSpace as! (String?) -&gt; String)
        processedPassword = password.asObservable().map(String.toLower as! (String?) -&gt; String).map(String.trimWhiteSpace as! (String?) -&gt; String)

        let emailValid = processedEmail.asObservable().map(String.isNotEmpty)
        let passwordValid = processedPassword.asObservable().map(String.isNotEmpty)

        buttonEnabled = Observable.combineLatest(emailValid, passwordValid) {
            return $0 &amp;&amp; $1
        }

    }

    func didTapLoginButton() {
        print(""hello \(email.value)"")
    }
}
</code></pre>

<p>For some reason the <code>init</code> method of my <code>viewmodel</code> never gets finished.
Can someone help me? </p>
","965273","","6163022","","2016-12-05 11:41:10","2016-12-05 20:07:22","enable button with RxSwift logic","<ios><iphone><rx-swift><rx-cocoa>","2","4","","","","CC BY-SA 3.0"
"40998059","1","40999136","","2016-12-06 14:45:32","","0","1393","<p>I have some doubts in my approach. I have two type of Observables:</p>

<pre><code>//I can fetch from the server the houses and save them in the database
func houses() -&gt; Observable&lt;[House]&gt;

//Given a houseId, I can fetch it's details and save them in the database
func houseDetail(id: Int) -&gt; Observable&lt;Family&gt;
</code></pre>

<p>I would like to do an Observable which first fetch all houses, and then fetch the families. What I did is something like that:</p>

<pre><code>//I am an observable which, when I complete, all data are saved
func fetchAllHousesAndFamily() -&gt; Observable&lt;Any&gt; {
  var allHousesObservables: [Observable] = []
  for house in houses {
    allHousesObservables.append(houseDetail(house.id))
  }
  return Observable.combineLatest(allHousesObservables)
}
</code></pre>

<p>But this for...it doesn't seem to be <em>reactive style</em> to me, and it seems like a hack because I don't know enough about rx operators.</p>

<p>Do you have the right way to do it in the rxworld ?</p>

<p>Thank you</p>
","3620372","","","","","2016-12-06 15:36:06","rxswift: how to get the Observable<Any> resulting in a combination of Observable<[Category]>?","<swift><reactive-programming><rx-swift><reactivex><reactive>","1","1","","","","CC BY-SA 3.0"
"41001013","1","","","2016-12-06 17:08:35","","1","1347","<p>I add a CocoaAction to a button, like</p>

<pre><code>var speakBtn = UIBarButtonItem(title: ""Speak"", style: .done, target: self, action: nil)
speakBtn.rx.action = viewModel.speakAction
</code></pre>

<p>After that, there is a textView's text to bind to it, like</p>

<pre><code>if let speakBtn = navigationItem.rightBarButtonItems?.first {
    textValid.bindTo(speakBtn.rx.isEnabled)
        .addDisposableTo(disposeBag)
}
</code></pre>

<p>Then, the result is wrong. If I comment the code which adds the cocoaAction to the button, when the app run, the textView's text is nil, so the speakBtn will be unable to click.</p>

<p>But now, the speakBtn is enable to click.</p>

<p>Anyone can give me a explain? thanks.</p>
","3445475","","1113632","","2018-10-05 14:06:23","2018-10-05 14:06:23","RxSwift, adding a CocoaAction to a button will have a side effect when other observables bind to it","<swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"41028329","1","","","2016-12-07 22:12:57","","5","443","<p>I'm trying to learn RxSwift by sample code, tutorials etc, but since most tutorials are for Swift 2 and previous versions of RxSwift, syntax have changed a bit. Normally that wouldn't be a problem, as it is possible to find the new syntax by code completion, but for RxCocoa I'm sometimes getting nothing. Example:</p>

<pre><code>// UITextField
textField.rx.text.
</code></pre>

<p>I'm getting no suggestions at all, even though I know there are methods, since I was able to figure them out manually, but it takes a lot of time. What am I doing wrong?</p>

<p>Using XCode 8.1, Swift 3, RxSwift/RxCocoa 3.1, macOS Sierra and Cocoa Pods (latest stable version, updated yesterday). I've tried to create new projects and deleting DerivedData, but with the same result. </p>
","4092384","","","","","2016-12-07 22:12:57","RxSwift/RxCocoa: Code Completion barely working","<swift><rx-swift><rx-cocoa>","0","3","","","","CC BY-SA 3.0"
"41060254","1","41099315","","2016-12-09 12:13:12","","4","2727","<p>Let's say I have a <code>UIButton</code> in a <code>UITableViewCell</code>.
After dequeuing the cell from the <code>UITableView</code> I want to subscribe to the <code>UIButton.rx.tap</code>. The issue is that if my <code>UITableViewCell</code> is dequeued multiple times, the subscriptions would retain. Currently I solve this problem by allocating a <code>Disposable</code> property in my <code>UITableViewCell</code>, setting it when the subscription is create,  and calling <code>Disposable.dispose()</code> on <code>UITableViewCell.prepareForReuse()</code>, however as far as I understand implementing features in a way that requires you to call <code>Disposable.dispose()</code> implies that you are doing something wrong.</p>

<p>Is there any better way to accomplish uniqueness of the subscription without reallocating <code>UIButton</code>?</p>
","6407425","","","","","2016-12-12 10:58:17","Subscription to a UIButton.rx.tap located in UITableViewCell within UITableViewDataSource","<ios><uibutton><rx-swift><reactivex><rxdatasources>","2","0","3","","","CC BY-SA 3.0"
"41099777","1","","","2016-12-12 11:25:00","","4","904","<p>Say I have a <code>Field</code> class with a <code>harvest</code> function like this:</p>

<pre><code>class Field {

    func harvest(handler: (Vegetable) -&gt; Void) {
        …
        handler(carrot)
        …
        handler(potato)
        …
        handler(carrot)
        …
    }
}
</code></pre>

<p>I also have a <em>Reactive</em> version/API for the same function:</p>

<pre><code>import RxSwift

extension Reactive where Base: Field {

    func harvest() -&gt; Observable&lt;Vegetable&gt; {
        return Observable.create { observer in
            self.base.harvest(handler: observer.onNext)

            return Disposables.create()
        }
    }
}
</code></pre>

<p>For testing purposes, I created a subclass of <code>Field</code> named <code>MockField</code> that overrides <code>harvest(:)</code> to invoke the handler with a set of stubbed <code>Vegetable</code>s. When using the <code>MockField</code> object like <code>field.harvest(:)</code> everything works fine and I get the stubbed vegetables.</p>

<p>Now I want to do the same with the Reactive extension to stub calls to <code>field.rx.harvest</code>, but I cannot override it to return stubbed Vegetables! <strong>How can I override functions in the <code>rx</code> namespace?</strong></p>
","1292020","","1292020","","2016-12-13 09:08:32","2016-12-13 09:08:32","Subclassing RxSwift/Reactive extension for stubbing","<ios><swift><testing><stub><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"41111427","1","","","2016-12-12 23:30:59","","0","1081","<p>Okay, so let's explain my goal first.
I'm trying to build a structure to fetch items from Moya and map my items properly using realm Object in order to save them in the future. All that should be done using rxswift in order to get the reactivity associated.</p>

<p>Here are my 2 class:</p>

<pre><code>import Foundation
import ObjectMapper
import RealmSwift

final class GroupContainer: Mappable {

    private(set) var items = List&lt;Group&gt;()

    required convenience init?(map: Map) {
        self.init()
    }

    func mapping(map: Map) {
        items &lt;- (map[""items""], transformation: RealmListTransform&lt;Group&gt;())

    }
}
</code></pre>



<pre><code>import Foundation
import RealmSwift
import ObjectMapper

final class Group: Object, Mappable {

    private(set) dynamic var tag: String = """"
    private(set) dynamic var name: String = """"
    private(set) dynamic var groupLevel: Int = 0
    private(set) dynamic var groupPoints: Int = 0
    private(set) dynamic var members: Int = 0

    required convenience init?(map: Map) {
        self.init()
    }

    func mapping(map: Map) {
        tag &lt;- map[""tag""]
        name &lt;- map[""name""]
        clanLevel &lt;- map[""groupLevel""]
        clanPoints &lt;- map[""groupPoints""]
        members &lt;- map[""members""]
    }
}
</code></pre>



<p>And here is a sample struct to fetch and parse my data.
Well this is the example provided by RxMoya. However in order to use ObjectMapper I can't the use <code>mapObjectOptionnal</code> method. I tried switching my model to ModelMapper instead but couldn't find a way to transform my array into an List
I also tried to find a replacement to <code>mapObjectOptionnal</code>, for example mapArray, mapObject but for some reason i can't use them directly after making my request.</p>

<pre><code>import Moya
import Moya_ObjectMapper
import RxOptional
import RxSwift

struct TempFetcher {
  let provider = RxMoyaProvider&lt;APIService&gt;()
  let groupName = Observable&lt;String&gt;

    func trackGroup() -&gt; Observable&lt;[Group]&gt; {
        return self.groupName.observeOn(MainScheduler.instance)
                    .flatMapLatest { search -&gt; Observable&lt;GroupContainer&gt; in
                            return self.findGroup(name: search)
                    }
                    .flatMapLatest { container -&gt; Observable&lt;[Group]&gt; in
                            return Observable&lt;[Group]&gt;.just(container.items)
                    }
    }

    private func findGroup(name: String) -&gt; Observable&lt;GroupContainer?&gt; {
        return self.provider
            .request(APIService.Group(fullName: name))
            .debug()
            .mapObjectOptional(type: Repository.self)
    }
}
</code></pre>



<p>Any help to progress in my research would be gladly appreciated!!
Thanks.</p>
","4908472","","","","","2017-08-14 04:11:40","Rxswift + Moya + Realm","<swift><realm><alamofire><rx-swift><moya>","1","0","","","","CC BY-SA 3.0"
"41174527","1","","","2016-12-15 22:41:23","","0","513","<p>I am trying to use RxAlamofire with <code>retry()</code> but I can't make it work. I tried to add <code>retry()</code> block to different positions but it doesn't make any difference. </p>

<p>If I add <code>retry(3)</code> to end of  <code>apiClient.get(type: .posts).retry(3)</code> it seems to work. Is there a way to add retry logic to <code>ApiClient</code> class? Thanks.</p>

<pre><code>class ApiClient {
    var baseURL:String

    init(baseURL:String) {
        self.baseURL = baseURL
    }

    func get(type:ApiType) -&gt; Observable&lt;[Post]&gt;{
        return RxAlamofire
            .request(.get, baseURL + ""/someurl"") //doesn't exist
            .flatMap {
            $0.validate(statusCode: 200..&lt;300)
            .rx.json()
            }.retry(3)
            .map{(data) -&gt; [Post] in
                var posts = [Post]()
                // parse it
                return posts
        }
    }
}
    let apiClient = ApiClient(baseURL: ""https://jsonplaceholder.typicode.com"")
    apiClient.get(type: .posts)
        .subscribe(onNext:  { [weak self] posts in
            self?.objects = posts
            self?.tableView.reloadData()

            }, onError: { error in
                print(error)

        }).addDisposableTo(disposablebag)
</code></pre>
","4170419","","","","","2016-12-15 22:41:23","RxAlamofire retry doesnt work","<swift><rx-swift><rxalamofire>","0","4","","","","CC BY-SA 3.0"
"41184162","1","","","2016-12-16 12:12:48","","15","17620","<p>I'm trying to reproduce a simple timer with RxSwift.</p>

<p>I have a pause/play <code>button</code> only that works for pause and resume.</p>

<pre><code>        gameTimer = Observable&lt;NSInteger&gt;.interval(1, scheduler: MainScheduler.instance)
            .subscribeNext({ sec -&gt; Void in
            print(""\(sec) s"")
        }).addDisposableTo(disposeBag!)


            pauseResumeButton.rx_tap
            .map{ !self.isRunning.value }
            .startWith(true)
            .bindTo( isRunning )
            .addDisposableTo(disposeBag!)
</code></pre>

<p><code>isRunning</code> is an Variable&lt;<code>Bool</code>> obviously.
I can stop the timer settings <code>disposeBag = nil</code> but I cannot pause it....itried to filter events but the count obviously continues to grow...</p>

<p>Can anyone help me? Thanks!</p>
","1870602","","8160252","","2019-06-08 05:17:08","2019-06-08 05:17:08","Simple timer with rxSwift","<swift><timer><rx-swift>","1","0","","","","CC BY-SA 4.0"
"41197024","1","41198551","","2016-12-17 09:07:20","","11","16476","<p>Here is my code:</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa
import RxOptional

class ViewController: UIViewController {

    @IBOutlet weak var collectionView: UICollectionView!

    let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.

        let items = Observable.just(
            (0..&lt;20).map{ ""Test \($0)"" }
        )

        items.asObservable().bindTo(self.collectionView.rx.items(cellIdentifier: CustomCollectionViewCell.reuseIdentifier, cellType: CustomCollectionViewCell.self)) { row, data, cell in
            cell.data = data
            }.addDisposableTo(disposeBag)
    }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/OmT0o.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/OmT0o.png"" alt=""enter image description here""></a></p>

<p>So how to show 3 columns in 1 row.</p>

<p>I can't find any tutorial about collection view with RxSwift.</p>
","4742830","","472495","","2016-12-18 18:31:15","2017-12-08 13:58:57","How to show collection view 3 columns in 1 row with RxSwift","<ios><swift><uicollectionview><rx-swift>","2","6","1","","","CC BY-SA 3.0"
"41200481","1","42918509","","2016-12-17 16:06:22","","7","4863","<p>I have a <code>ViewController</code> connect to a Xib file. In this Xib file I have a View, and inside this View, I have a TableView like so</p>

<p><a href=""https://i.stack.imgur.com/6wyCf.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/6wyCf.png"" alt=""enter image description here""></a></p>

<p>I also have <code>LeftTableViewCell</code> and <code>RightTableViewCell</code> which connected to another Xib files.</p>

<p><a href=""https://i.stack.imgur.com/0zNOz.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/0zNOz.png"" alt=""enter image description here""></a></p>

<p><a href=""https://i.stack.imgur.com/pIilX.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/pIilX.png"" alt=""enter image description here""></a></p>

<p>Now I want to register <code>LeftTableViewCell</code> and <code>RightTableViewCell</code> in this TableView, so how to do this, my code always can not compiled.</p>

<pre><code>class ThirdViewController: UIViewController {

    @IBOutlet weak var tableView: UITableView!

    let items: Variable&lt;[String]&gt; = Variable([""Test 2"", ""Test 3"", ""Test 1"", ""Test 4"", ""Test 5""])

    let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()
    // Do any additional setup after loading the view, typically from a nib.

//        tableView.register(LeftTableViewCell.self, forCellReuseIdentifier: LeftTableViewCell.reuseIdentifier)

//        tableView.register(UINib(nibName: ""LeftTableViewCell"", bundle: nil), forCellReuseIdentifier: LeftTableViewCell.reuseIdentifier)
//        tableView.register(UINib(nibName: ""RightTableViewCell"", bundle: nil), forCellReuseIdentifier: LeftTableViewCell.reuseIdentifier)

    items.asObservable().bindTo(tableView.rx.items(cellIdentifier: LeftTableViewCell.reuseIdentifier, cellType: LeftTableViewCell.self)) { row, data, cell in
        cell.data = data
        }.addDisposableTo(disposeBag)

    tableView.rx.modelSelected(String.self).subscribe { [unowned self] (event) in
        switch event {
        case .next(let element):
            if let selectedRowIndexPath = self.tableView.indexPathForSelectedRow {
                self.tableView.deselectRow(at: selectedRowIndexPath, animated: true)
            }

            break
        default:
            break
        }
        }.addDisposableTo(disposeBag)
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
    // Dispose of any resources that can be recreated.
    }

}
</code></pre>
","4742830","","4742830","","2016-12-17 17:20:08","2017-03-21 04:33:08","Register two custom cells with RxSwift","<ios><swift><xcode><uitableview><rx-swift>","2","2","","","","CC BY-SA 3.0"
"41205106","1","","","2016-12-18 03:07:58","","1","1548","<p>My ThirdViewController is in a Xib file, it has a <code>tableView</code>. I also have 2 cells in another xib files, I want to show 2 custom cells alternately with RxSwift. How to do this. Here is my code:</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class ThirdViewController: UIViewController {

    @IBOutlet weak var tableView: UITableView!

    let items: Variable&lt;[String]&gt; = Variable([""Test 2"", ""Test 3"", ""Test 1"", ""Test 4"", ""Test 5""])

    let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.

        tableView.register(UINib(nibName: ""LeftTableViewCell"", bundle: nil), forCellReuseIdentifier: LeftTableViewCell.reuseIdentifier)
        tableView.register(UINib(nibName: ""RightTableViewCell"", bundle: nil), forCellReuseIdentifier: RightTableViewCell.reuseIdentifier)

        items.asObservable().bindTo(tableView.rx.items(cellIdentifier: LeftTableViewCell.reuseIdentifier, cellType: LeftTableViewCell.self)) { row, data, cell in
            cell.data = data
            }.addDisposableTo(disposeBag)
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
}
</code></pre>
","4742830","","","","","2017-03-21 05:51:17","How to register show 2 custom cells alternately with RxSwift","<ios><swift><uitableview><rx-swift>","1","3","","","","CC BY-SA 3.0"
"41210336","1","41211647","","2016-12-18 16:18:57","","1","159","<p>I have an app that consumes a REST service. It makes requests every time someone e.g. clicks a button. However it needs to get a token first and then refresh every 20 minutes thereafter. Here is a marble diagram that represents the desired combining of the streams ...</p>

<pre><code>TOKEN SOURCE   ---------A--------------B--------------C----------------D-
REQUEST SOURCE ----1-----------2--3---------4-----------5-------6--------


RESULT SOURCE  ---------A1-----A2-A3--------B4----------C5------C6-------
</code></pre>

<p>Typically the request source triggers the result which combines with the latest value of the token source, however there is an exception when no items have been emitted on the token stream - in this case the request is buffered until the first token arrives and then it is sent. </p>

<p>The <a href=""http://reactivex.io/documentation/operators/combinelatest.html"" rel=""nofollow noreferrer""><code>combineLatest</code></a> operator is almost there but it triggers when either stream emits. The marble diagram for <a href=""http://reactivex.io/documentation/operators/sample.html"" rel=""nofollow noreferrer""><code>sample</code></a> operator also seems close but it throttles the output based on a time interval which is not what I want.</p>

<p>Which operator/chain of operators would work for this instance?</p>

<p>I'm prototyping with RxJS but I need to implement in RxSwift.</p>
","199","","199","","2016-12-18 16:26:09","2016-12-18 20:55:56","Reactive pattern for combing operator where one is dependent on another","<operators><rxjs><reactive-programming><rx-swift>","2","0","0","","","CC BY-SA 3.0"
"41221342","1","","","2016-12-19 11:12:12","","0","76","<p>Is there any built-in way to combine two or more <code>DisposeBag</code>s merging them in a single one which triggers as soon as the first trigger? </p>

<p>The use case is something like this: I have a <code>UIViewController</code> with some controls and his own disposeBag; then I have a library which asynchronously hands some data to this <code>UIViewController</code>. This data comes with his own disposeBag, which is bound to some independent logic (network connections basically). I want to bind the data to the controls, and dispose the binding as soon as one of the two DisposeBag is triggered.</p>
","527935","","527935","","2017-04-10 22:55:15","2017-04-10 22:55:15","How to combine two DisposeBags?","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"41222958","1","41229419","","2016-12-19 12:48:30","","0","55","<p>I am trying to use RxSwift in playground and therefore I need RxSwift to be checked out, but <code>carthage update --platform iOS</code> only downloads the framework.</p>

<p>Do you know why and what to do?</p>

<p>Until then I will just git clone.</p>
","699215","","343299","","2016-12-19 19:11:02","2016-12-19 19:11:02","unable to get checkout code","<swift><xcode><rx-swift><carthage>","1","0","","","","CC BY-SA 3.0"
"41301044","1","","","2016-12-23 11:57:16","","0","470","<p>Can I observe read only variable by RxSwift ?</p>

<p>I'm trying observe variable from extendal library (<a href=""https://github.com/nicklockwood/iCarousel"" rel=""nofollow noreferrer"">iCarousel</a>)</p>

<p>This is my code:</p>

<pre><code>carouselView.rx.observe(Bool.self, ""isScrolling"")
    .map { $0 != nil }
    .subscribe(onNext: { (isScrolling) in
        print(""isScrolling"", isScrolling)
    }).addDisposableTo(disposeBag)
</code></pre>

<p>Console print this but only one time:</p>

<pre><code>isScrolling, false
</code></pre>
","3569831","","3569831","","2016-12-23 12:02:24","2016-12-23 17:02:22","Observe read only variable","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"41342623","1","41514031","","2016-12-27 09:39:22","","5","2617","<p>Is it possible to make extension of structure Reactive, where base class is my custom control inherited from UIControl?</p>

<p>When I'm trying following code:</p>

<pre><code>extension Reactive where Base: CustomControl {

    public var value: ControlProperty&lt;CGFloat&gt; {

        return CustomControl.rx.value(

            self.base,

            getter: { customControl in
                customControl.customProperty
            },
            setter: { customControl, value in
                customControl.customProperty = value
            }
        )
    }
}
</code></pre>

<p>I'm getting following error:</p>

<pre><code>Instance member ""value"" cannot be used on type 'Reactive&lt;CustomControl&gt;'
</code></pre>

<p>I will be grateful if you provide me any explanation.</p>
","4697508","","","","","2017-01-06 20:42:46","Create ControlProperty for custom UIControl","<swift><uicontrol><rx-swift><reactive><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"41347705","1","41350145","","2016-12-27 15:17:01","","2","13319","<p>I try to use RxSwift in my project. My podfile looks like below, ↓</p>

<p><a href=""https://i.stack.imgur.com/6b5JT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6b5JT.png"" alt=""Enter image description here""></a></p>

<p>I got this error:</p>

<p><a href=""https://i.stack.imgur.com/7b1jx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7b1jx.png"" alt=""Enter image description here""></a></p>

<p>This is my <em>Link Binary With Libraries</em> status:</p>

<p><a href=""https://i.stack.imgur.com/OPGpR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/OPGpR.png"" alt=""Enter image description here""></a></p>

<p>I have tried to fix it for over three hours. But the answers on the site don't work for me...</p>
","7059115","","1033581","","2018-03-18 07:33:28","2019-09-23 10:00:29","Getting ""No such module 'RxSwift'"" with Xcode 8 and Swift 3.0","<swift><xcode><cocoapods><rx-swift>","2","1","1","2016-12-28 01:23:40","","CC BY-SA 3.0"
"41360676","1","","","2016-12-28 11:02:58","","2","2290","<p><em>How to send Multipart data with RxAlamofire</em></p>

<blockquote>
  <p>For instance in <a href=""https://github.com/Alamofire/"" rel=""nofollow noreferrer"">Alamofire</a></p>
</blockquote>

<pre><code>let URL = try! URLRequest(url: ""http://example.com"", method: .post)


Alamofire.upload(multipartFormData: { formData in
    // multiaprt
}, with: URL, encodingCompletion: {(result: SessionManager.MultipartFormDataEncodingResult) in

})
</code></pre>

<ol>
<li><strong>How to get same behaviour/function with <a href=""https://github.com/RxSwiftCommunity/RxAlamofire"" rel=""nofollow noreferrer"">RxAlamofire</a>?</strong></li>
<li><strong>Or An way of wrapping this function in an Observable?</strong></li>
</ol>
","3600738","","3600738","","2017-01-19 11:09:29","2017-01-19 19:30:48","RxAlamofire post multipart data","<swift3><alamofire><reactive-programming><rx-swift><rxalamofire>","1","0","","","","CC BY-SA 3.0"
"41382557","1","41383098","","2016-12-29 15:23:03","","0","2268","<p>I am using RxSwift 3.1 (Galois) via Carthage in my new project and I've just tried to bind the data to UITableView using some examples I found online and in the documentation - one of them being this file:
<a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/SimpleTableViewExample/SimpleTableViewExampleViewController.swift"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/SimpleTableViewExample/SimpleTableViewExampleViewController.swift</a></p>

<p>My code looks like this right now (I've tried to dumb it down already because what I wanted to work didn't):</p>

<pre><code>class ChooseCityView: UIViewController, UITableViewDelegate {

    @IBOutlet weak var tableView: UITableView!

    override func viewDidLoad() {

        super.viewDidLoad()

        let dataSource = Observable.just((0..&lt;20).map { ""\($0)"" })
        let disposeBag = DisposeBag()

            dataSource.bindTo(tableView.rx.items(cellIdentifier: ""CityCell"", cellType: UITableViewCell.self)) {
                (row, city, cell) in
                cell.backgroundColor = .white
                cell.textLabel?.text = ""test \(city)""
            }.addDisposableTo(disposeBag)

        // Remove empty cells
        tableView.tableFooterView = UIView()

    }
}
</code></pre>

<p>Still, after running the app in simulator this will not show any rows. I have a prototype cell on tableView called ""CityCell"", with type Basic. Also, I made sure the outlet is bound with the actual tableView. What could I be doing wrong? Or is this a bug?</p>

<p>Thanks in advance :)</p>
","6357389","","","","","2016-12-29 15:59:20","RxSwift 3.1 UITableView data source not working","<ios><swift><xcode><rx-swift><reactivex>","1","4","0","","","CC BY-SA 3.0"
"41395928","1","41442866","","2016-12-30 12:00:13","","3","965","<p>I'm trying to get the JSON data from REST (swift 2.3) with rxSwift and Alamofire. This is my code:</p>

<pre><code>  func getArticles(articlesReq: ArticlesReq) - &gt; Observable &lt; [Article] &gt; {
      return Observable &lt; [Article] &gt; .create {
          observer in
              let request = Alamofire.request(.POST, apiPath, parameters: DataHelper().convertStringToDictionary(JSONString), encoding: .JSON)
                  .responseArray {
                      (response: Response &lt; [Article], NSError &gt; ) in
                          if let articlesArray = response.result.value {
                              observer.on(.Next(articlesArray))
                          }
                          observer.on(.Completed)
                  }
          return AnonymousDisposable {
              request.cancel()
          }

      }

  }

  getArticles(articlesReq).observeOn(MainScheduler.instance)
      .subscribe(
          onNext: {
              data in
              print(data)
          },
          onError: {
              error in
              print(error)
          },
          onCompleted: {
              print(""Completed"")
          },
          onDisposed: {
              print(""Disposed"")
          }
      ).addDisposableTo(db)
</code></pre>

<p>onDisposed return data before Alamofire.request return data (onNext, onError, onCompleted not return data ). How to wait for a response?  </p>
","7357704","","7357704","","2016-12-30 12:05:46","2017-01-03 11:49:16","RxSwift: onDisposed activated before Alamofire return data","<swift><alamofire><rx-swift>","1","0","","","","CC BY-SA 3.0"
"41413364","1","41528567","","2017-01-01 04:30:38","","2","4321","<p>The first observable fires, but the second does not. What gives? I switched the events in the block i.e print($0) in the second bloack and vice-versa, then the first does not work, but the second works. What is it about $0 versus a regular string that makes the observable observe?</p>

<pre><code>      let someObservable  = self.inputButton!.rx.tap.subscribe(){
        print($0)
      }

      let someObservable1 = self.inputButton!.rx.tap.subscribe(){
        print(""Hello"")
      }
</code></pre>
","4813652","","","","","2017-01-08 01:40:12","RxSwift Subscribing on ControlEvent","<rx-swift>","1","0","","","","CC BY-SA 3.0"
"41430414","1","","","2017-01-02 16:41:43","","4","2625","<p>i've some crashs on this part of code :</p>

<pre><code>SRNetwork.provider
        .request(SRService.postData(user_id: userId))
        .mapArray(STrain.self)
        .observeOn(ConcurrentDispatchQueueScheduler.init(queue: SDispatchQueue.dataTrain.getQueue()))
        .subscribe({ (event) -&gt; Void in
            switch event {
            case .next(let response):
                self.train.value = response
                SRealmTrain.sharedInstance.cacheTrain(response)
            case .error(let error):
                SRealmTrain.sharedInstance.fetchTrainRx(userId) //CRASH IS HERE
                    .bindTo(self.train)
                    .addDisposableTo(self.disposeBag)
                print(""\(error)"")
            default: break;
            }
        })
        .addDisposableTo(disposeBag);
</code></pre>

<p>I think the problem is that i'm not on the <code>MainScheduler.instance</code> and rxRealm watch on the <code>main thread</code> but i don't want it. Is it possible to fix it ?</p>

<p><strong>fetchTrainRx</strong> :</p>

<pre><code>public func fetchTrainRx(_ userId: String) -&gt; Observable&lt;[STrain]&gt; {

    let predicate = NSPredicate(format: ""userId == %@"", userId)

    if let realm = realm {

        return Observable.from(realm
            .objects(SRTrain.self)
            .filter(predicate)
            .sorted(byProperty: ""order"", ascending: true))
            .map ({
                $0.map(STrain.init)
        })
    }
    return Observable.just([]);
}
</code></pre>
","3551984","","","","","2017-01-03 15:50:28","Can only add notification blocks from within runloops","<swift><realm><rx-swift><moya>","1","0","","","","CC BY-SA 3.0"
"41433337","1","41474121","","2017-01-02 21:12:48","","1","861","<p>I have and observable that never sends onNext if its returned by a function, but if i subscribe to it in the function that returns it, onNext is called. </p>

<pre><code>class InfoViewModel {

    func refreshPushToken() {

        PushNotificationService.sharedInstance.pushToken!
                .flatMapLatest { (pushToken: String) -&gt; Observable&lt;Result&lt;User&gt;&gt; in
                    return UserService.registerPushToken(pushToken)
                }
                .subscribe { (event ) in
                    print(event)
                }
                .addDisposableTo(disposeBag)

    }
}

struct UserService {
    ....
    static func registerPushToken(_ pushToken: String) -&gt; Observable&lt;Result&lt;User&gt;&gt; {
        ...
        return self.postUser(user: user)
    }

    static fileprivate func postUser(user: User) -&gt; Observable&lt;Result&lt;User&gt;&gt; {

        let rxProvider: RxMoyaProvider&lt;Backend&gt; = RxMoyaProvider&lt;Backend&gt;(endpointClosure: Backend.endpointClosure)

         return rxProvider.request(Backend.register(user: user))
            .mapObject(type: User.self)
            .map({ (user: User) -&gt; Result&lt;User&gt; in
                LogService.log(level: .debug, action: ""postUser"", message: ""Posted user with success"", parameters: [""user"": user.deviceId])
                return .success(user)
            })
            .catchError({ error -&gt; Observable&lt;Result&lt;User&gt;&gt; in
                LogService.log(level: .error, action: ""postUser"", message: ""Error posting user"", parameters: [""user"": user.deviceId, ""error"": error.localizedDescription])
                return Observable.just(.failure(error))
            })
    }   
}
</code></pre>

<p>But if I do this</p>

<pre><code>     rxProvider.request(Backend.register(user: user))
     ...
        .subscribe { (event ) in
            print(event)
        }
</code></pre>

<p>in the UserService, i will get a next event.</p>

<p>I have tried to use <code>debug()</code> on the observable in InfoViewModel, there is a subscription, i just never receive any events.</p>
","1366083","","1366083","","2017-01-02 23:47:50","2017-01-04 22:14:06","Observable returned from function never sends onNext","<swift><rx-swift><reactive>","1","6","1","","","CC BY-SA 3.0"
"41441010","1","41441496","","2017-01-03 10:10:19","","2","4780","<p>I am using RxSwift and Moya to call request and get response.</p>

<p>My code:</p>

<pre><code>NetworkManager.shared.request(api: .carrot2diamond, showLoading: false).subscribe({ (response) in
// how to handle with response
}).addDisposableTo(self.disposeBag)
</code></pre>

<p>It shows something like this:</p>

<blockquote>
  <p>[""Moya_Logger: [03/01/2017 16:52:50] Request:
  <a href=""http://api.360live.vn/api_shop/carrot2diamond?appversion=1.0&amp;auth_key=f4aeaa8f9df1fd8ef68e1f3e431cd77995d565ef66e7dff9&amp;devid=EA51920A-5C21-41D8-A420-62AF6AAD20FD&amp;platform=2"" rel=""nofollow noreferrer"">http://api.360live.vn/api_shop/carrot2diamond?appversion=1.0&amp;auth_key=f4aeaa8f9df1fd8ef68e1f3e431cd77995d565ef66e7dff9&amp;devid=EA51920A-5C21-41D8-A420-62AF6AAD20FD&amp;platform=2</a>""]
  [""Moya_Logger: [03/01/2017 16:52:50] Request Headers: [:]""]
  [""Moya_Logger: [03/01/2017 16:52:50] HTTP Request Method: GET""]
  [""Moya_Logger: [03/01/2017 16:52:50] Response:  { URL:
  <a href=""http://api.360live.vn/api_shop/carrot2diamond?appversion=1.0&amp;auth_key=f4aeaa8f9df1fd8ef68e1f3e431cd77995d565ef66e7dff9&amp;devid=EA51920A-5C21-41D8-A420-62AF6AAD20FD&amp;platform=2"" rel=""nofollow noreferrer"">http://api.360live.vn/api_shop/carrot2diamond?appversion=1.0&amp;auth_key=f4aeaa8f9df1fd8ef68e1f3e431cd77995d565ef66e7dff9&amp;devid=EA51920A-5C21-41D8-A420-62AF6AAD20FD&amp;platform=2</a>
  } { status code: 200, headers {\n    \""Access-Control-Allow-Origin\"" =
  \""*\"";\n    \""Content-Length\"" = 53;\n    \""Content-Type\"" =
  \""application/json; charset=utf-8\"";\n    Date = \""Tue, 03 Jan 2017
  09:52:50 GMT\"";\n    Server = \""Jetty(9.2.z-SNAPSHOT)\"";\n<br>
  \""X-Server\"" = 360Live;\n} }""] [""{\""error\"":0,\""message\"":\""exchange
  carrot value invalid\""}""]</p>
</blockquote>

<p>I want to detect the error from this line:</p>

<blockquote>
  <p>[""{\""error\"":0,\""message\"":\""exchange carrot value invalid\""}""]</p>
</blockquote>

<p>When I po <code>response.element?.response?.description</code>, it just give me:</p>

<blockquote>
  <p>▿ Optional
    - some : "" { URL: <a href=""http://api.360live.vn/api_shop/carrot2diamond?appversion=1.0&amp;auth_key=f4aeaa8f9df1fd8ef68e1f3e431cd77995d565ef66e7dff9&amp;devid=EA51920A-5C21-41D8-A420-62AF6AAD20FD&amp;platform=2"" rel=""nofollow noreferrer"">http://api.360live.vn/api_shop/carrot2diamond?appversion=1.0&amp;auth_key=f4aeaa8f9df1fd8ef68e1f3e431cd77995d565ef66e7dff9&amp;devid=EA51920A-5C21-41D8-A420-62AF6AAD20FD&amp;platform=2</a>
  } { status code: 200, headers {\n    \""Access-Control-Allow-Origin\"" =
  \""*\"";\n    \""Content-Length\"" = 53;\n    \""Content-Type\"" =
  \""application/json; charset=utf-8\"";\n    Date = \""Tue, 03 Jan 2017
  09:52:50 GMT\"";\n    Server = \""Jetty(9.2.z-SNAPSHOT)\"";\n<br>
  \""X-Server\"" = 360Live;\n} }""</p>
</blockquote>
","4742830","","2227743","","2017-01-03 10:26:12","2017-01-03 10:33:30","Get response from Moya Response","<ios><swift><rx-swift><moya>","1","1","","","","CC BY-SA 3.0"
"41442391","1","41442703","","2017-01-03 11:23:30","","1","850","<p>Here are some of my codes:</p>

<pre><code>func toObservable() -&gt; Observable&lt;T&gt; {
    return Observable.create {
        observer -&gt; Disposable in
        let urlRequest = try? self.asURLRequest()

        Alamofire.request(urlRequest!)
            .responseObject{ (response: DataResponse&lt;T&gt;) in
                if response.result.isSuccess {
                    if let responseEntity = response.result.value {
                        if let _ = responseEntity.error {
                            observer.onError(ResponseError.generic)
                        } else {
                            observer.onNext(responseEntity)
                        }
                    } else {
                        // TODO
                    }
                } else {
                    // TODO
                }
        observer.onCompleted()

        }

        return Disposables.create()
    }
}
</code></pre>

<p>and when I call this function:</p>

<pre><code>toObservable().subscribe(onNext: {
            print(""onNext"")
            // ... use $0 parameter
        }, onError: {
            print(""onError"")
            // ... use $0 parameter
        }, onCompleted: { 
            print(""onCompelete"")
        }, onDisposed: nil)
    .addDisposableTo(DisposeBag())
</code></pre>

<p>It just can not print anything. So any idea about this? Many thanks!</p>

<p>(I used AlamofireObjectMapper, RxSwift frameworks)</p>

<p>Same question are <a href=""https://stackoverflow.com/questions/41395928/rxswift-ondisposed-activated-before-alamofire-return-data"">here</a> but nobody answered.</p>
","4861655","","-1","","2017-05-23 12:33:49","2017-10-07 04:34:07","RxSwift and Alamofire: can't subscribe events after alamofire handling response data","<swift><alamofire><rx-swift>","2","0","2","","","CC BY-SA 3.0"
"41496467","1","41496523","","2017-01-05 23:21:42","","1","330","<p>I've created a simple project with Cocoapods and installed RxSwift and RxCocoa.</p>

<p>I've written this code:</p>

<pre><code>import UIKit
import RxSwift

class ViewController: UIViewController {

    @IBOutlet weak var field: UITextField!

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.
        //self.field.rx. (only suggests `base`)
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }


}
</code></pre>

<p>so I should be able to get <code>self.field.rx.text</code> right? But I only get <code>self.field.rx.base</code></p>

<p>What am I missing?</p>
","1631615","","3795501","","2017-01-06 01:13:01","2017-01-06 01:13:01","Why are rx.text / rx.observe / rx.etc not available (RxSwift)","<swift><rx-swift>","1","1","","","","CC BY-SA 3.0"
"41508221","1","","","2017-01-06 14:52:51","","1","656","<p>Consider the following arrays</p>

<pre>
<code>

let a = [1,2,3,4,5,6]
let b = [5,6,7,8,9]

</code>
</pre>

<p>How to get c, where <code>c = [1,2,3,4,5,6,7,8,9]</code>? 
In RxSwift, how to do merge, sort, and removing duplicate for the input arrays?</p>
","5079380","","","","","2017-01-10 04:28:49","RxSwift - Arrays merge, sort, remove duplicates","<swift><rx-swift>","1","0","0","","","CC BY-SA 3.0"
"41528685","1","","","2017-01-08 01:58:43","","0","666","<p>I have the following code to configure my collectionView:</p>

<pre><code>viewModel?
    .observableExercises
    .bindTo(
        exercisesCollectionView
            .rx
            .items(cellIdentifier: ""My identifier"",
                   cellType: ExerciseCollectionViewCell.self)) {
                    index, exercise, cell in
                    cell.exercise = exercise
    }
    .addDisposableTo(disposeBag)
</code></pre>

<p>It all works fine at first, but later when my <code>viewModel.observableExercises</code> gets updated I would like to have the <code>exercisesCollectionView</code> reload its data. How should I do it?</p>
","2557380","","2557380","","2017-01-08 02:32:47","2017-01-08 02:32:47","How to observe a change in viewModel in order to reload collectionView using RxSwift?","<swift><mvvm><uicollectionview><rx-swift><rx-cocoa>","0","4","","","","CC BY-SA 3.0"
"41566093","1","41571206","","2017-01-10 10:01:56","","2","2846","<p>I want to get a Observable of UIImageView is Empty by Using Rxswift. </p>

<p>Here is my code:</p>

<pre><code>let usernameValid = firstTextField.rx.text.orEmpty
    .map { $0.characters.count &gt;= 1 }
    .shareReplay(1)

let passwordValid = secondTextField.rx.text.orEmpty
    .map { $0.characters.count &gt;= 1 }
    .shareReplay(1)

let everythingValid = Observable.combineLatest(usernameValid, passwordValid) { $0 &amp;&amp; $1 }
    .shareReplay(1)

everythingValid.bindTo(submitButton.rx.isEnabled).addDisposableTo(disposeBag)
</code></pre>

<p>I want get similar Observable like usernameValid.</p>
","2516526","","","","","2020-11-26 00:52:18","How to get a Observable of UIImageView is Empty by Using Rxswift?","<ios><swift><rx-swift>","2","0","3","","","CC BY-SA 3.0"
"41581774","1","41675888","","2017-01-11 02:30:37","","1","671","<p>Currently I do something like this:</p>

<pre><code>Observable.just([1, 2, 3, 4])
  .flatMapLatest {
    numbers in
    guard number = numbers.first else {
      return Objservable.empty()
    }
    return Observable.just(number)
  }
</code></pre>

<p>Is there a more idiomatic way to do this or any prebuilt operators I can use?</p>
","1653465","","","","","2017-01-23 09:18:30","RxSwift operator for transforming Observable<[T]> to Observable<T> by taking first element","<arrays><swift><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"41587440","1","41588474","","2017-01-11 09:47:35","","1","2420","<p>I'm trying to combine facebook login with a rest call, so when the user is logged in it should make an authenticate call to the server, where the server makes the graph calls, however I'm a bit confused to how I nest the calls with RxSwift? so far I have a FacebookProvider class with following method</p>

<pre><code>func login() -&gt; Observable&lt;String&gt; {
    return Observable.create({ observer in

        let loginManager = LoginManager()

        //LogOut before
        loginManager.logOut()

        //Set Login Method
        loginManager.loginBehavior = .native

        //Login Closure
        loginManager.logIn([ .publicProfile, .userFriends, .email], viewController: self.parentController) { loginResult in
            switch loginResult {
            case .failed(let error):
                print(error)
                observer.onError(FacebookError.NoConnection(L10n.networkError))
            case .cancelled:
                print(""User cancelled login."")
            case .success(_, let declinedPermissions, let accessToken):
                print(""Logged in!"")

                guard declinedPermissions.count &gt; 0 else {
                    observer.onError(FacebookError.DeclinedPermission(L10n.declinedPermission))
                    return
                }

                observer.onNext(accessToken.authenticationToken)
                observer.onCompleted()

            }
        }


        return Disposables.create()
    })

}
</code></pre>

<p>Then I have a <code>LoginViewModel</code> with this model</p>

<pre><code>public func retrieveUserData() -&gt; Observable&lt;User&gt; {
    return Network.provider
                .request(.auth(fbToken: Globals.facebookToken)).retry(5).debug().mapObject(User.self)
}
</code></pre>

<p>then I in my <code>UIViewController</code> do this</p>

<pre><code>    facebookProvider.validate().subscribe({ [weak self] response in

        switch response {
        case .error(_):
            // User is not logged in push to loginController
            break

        case .next():
            //user is logged in retrieveUserData before proceeding

            self?.loginViewModel.retrieveUserData().subscribe { event in
                switch event {
                case .next(let response):
                    print(response)
                case .error(let error):
                    print(error)
                case .completed:
                    print(""completed"")
                }
            }.addDisposableTo(self?.disposeBag)


            break
        case .completed:
            //data is retrieved and can now push to app
            break


        }

    }).addDisposableTo(disposeBag)
</code></pre>

<p><strong>Validate</strong></p>

<pre><code>public func rx_validate() -&gt; Observable&lt;String&gt; {
    return Observable.create({ observer in
        //Check if AccessToken exist
        if AccessToken.current == nil {
            observer.onError(FacebookError.NotLoggedIn)
        } else {
            observer.onNext(Globals.accessToken)
        }
        observer.onCompleted()
        return Disposables.create()
    })
}
</code></pre>
","4034437","","4034437","","2017-01-11 11:07:41","2017-01-11 11:07:41","handle nested observables in RxSwift","<ios><swift><facebook><rx-swift>","1","0","","","","CC BY-SA 3.0"
"41608936","1","","","2017-01-12 09:04:06","","0","402","<p>I'm using RxBluetoothKit 3.0.6 and have this code in a view controller:</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    // Do any additional setup after loading the view.
    DDLogDebug(""DEviceChooser viewDidLoad"")
    self.navigationItem.rightBarButtonItem = self.editButtonItem
    //let timerQueue = DispatchQueue(label: ""com.polidea.rxbluetoothkit.timer"")
    //scheduler = ConcurrentDispatchQueueScheduler(queue: timerQueue)
    scheduler = MainScheduler.instance
    if let favs = EmaxProfile.getFavourites() {
        DDLogDebug(""Got \(favs.count) favourites"")
        var uuids: [UUID] = []
        for (s) in favs {
            if let uuid = UUID(uuidString: s) {
                uuids.append(uuid)
            }
        }
        DDLogDebug(""Got \(uuids.count) uuids"")
        if (!uuids.isEmpty) {
            let cbcm = CBCentralManager()
            let devs = cbcm.retrievePeripherals(withIdentifiers: uuids)
            DDLogDebug(""Direct call to CBCentralManager.retrievePeripherals returned \(devs.count) entries"")
            self.manager.retrievePeripherals(withIdentifiers: uuids)
                    .subscribeOn(MainScheduler.instance)
                    .subscribe(onNext: {
                        DDLogDebug(""Got \($0.count) devices from RXBluetoothKit"")
                        //var list = self.devices[self.favourites]
                        for (dev) in $0 {
                            DDLogDebug(""Adding device \(dev.name)"")
                            let btDev = BTDevice(dev)
                            btDev.suitable = true
                            self.devices[self.favourites].append(btDev)
                        }
                        if (self.devices[self.favourites].isEmpty) {
                            self.startScanning()
                        } else {
                            self.tableView.reloadData()
                        }
                    }, onCompleted: {
                        DDLogDebug(""Retrieve complete"")
                    }).addDisposableTo(disposeBag)
        } else {
            startScanning()
        }
    } else {
        startScanning()
    }
}
</code></pre>

<p>So in <code>viewDidLoad()</code> I'm retrieving a list of previously scanned devices, stored by their UUIDS, and trying to retrieve them without scanning. If I call the Core Bluetooth <code>retrievePeripherals</code> it works correctly every time. However using the Rx BluetoothManager call fails the second time - i.e. when I run the program, the first time this view is shown it works correctly. If I hit Back then immediately reopen the view, neither the <code>onNext:</code> closure nor the <code>onComplete:</code> closure executes. The log output is:</p>

<pre><code>2017-01-12 19:55:13.824088 BlueMAX[559:216265] DEviceChooser viewDidLoad
2017-01-12 19:55:13.835820 BlueMAX[559:216297] Got 1 favourites
2017-01-12 19:55:13.836196 BlueMAX[559:216265] Got 1 uuids
2017-01-12 19:55:13.838832 BlueMAX[559:216265] Direct call to CBCentralManager.retrievePeripherals returned 1 entries
2017-01-12 19:55:13.846427 BlueMAX[559:216265] Got 1 devices from RXBluetoothKit
2017-01-12 19:55:13.846927 BlueMAX[559:216312] Adding device Optional(""DEV"")
2017-01-12 19:55:13.849145 BlueMAX[559:216265] Retrieve complete
2017-01-12 19:55:13.909986 BlueMAX[559:216312] [CoreBluetooth] XPC connection invalid
2017-01-12 19:55:21.515795 BlueMAX[559:216269] Saved 1 favourites, now exiting DeviceChooser
2017-01-12 19:55:22.054481 BlueMAX[559:216335] [CoreBluetooth] XPC connection invalid
2017-01-12 19:55:24.650717 BlueMAX[559:216269] DEviceChooser viewDidLoad
2017-01-12 19:55:24.651417 BlueMAX[559:216269] Got 1 favourites
2017-01-12 19:55:24.651646 BlueMAX[559:216312] Got 1 uuids
2017-01-12 19:55:24.654465 BlueMAX[559:216335] Direct call to CBCentralManager.retrievePeripherals returned 1 entries
2017-01-12 19:55:24.679889 BlueMAX[559:216269] [CoreBluetooth] XPC connection invalid
</code></pre>

<p>I'm not sure if the ""XPC connection invalid"" messages are connected with this or not.</p>

<p>Is this a bug, or am I doing something wrong?</p>
","1690078","","","","","2017-01-12 22:14:29","RxBluetoothkit call to retrievePeripherals fails second time","<rx-swift><rxiosble>","1","0","","","","CC BY-SA 3.0"
"41620234","1","","","2017-01-12 18:17:55","","1","3029","<p>I'm having two observables the first checks whether the AccessToken exist and if not return <code>NotLoggedIn</code> error type. The second fetches user data and should be called if the AccessToken in <code>rx_validate</code> exist. However I can't seem to figure out how I combine these observables to also error handle <code>rx_fetchUserData</code> errors from the response.</p>

<p><strong>Error Enum</strong></p>

<pre><code>enum LoginError: Error {
    case NotLoggedIn
    case Unknown
    case NoConnection
}
</code></pre>

<p><strong>observables in viewModel</strong></p>

<pre><code>// MARK: validate if user is logged in
public func rx_validate() -&gt; Observable&lt;String&gt; {
    return Observable.create({ observer in

        //Check if AccessToken exist
        if let token = AccessToken.current {
            observer.onNext(token.authenticationToken)
            observer.onCompleted()
        } else {
            observer.onError(LoginError.NotLoggedIn)
        }

        return Disposables.create()
    })
}

// MARK: Fetch data
public func rx_fetchUserData(token: String) -&gt; Observable&lt;User&gt; {
    return Network.provider
        .request(.auth(fbToken:  token))
        .retry(1).debug()
        .mapObject(User.self)

}
</code></pre>
","4034437","","","","","2017-01-15 22:06:42","Error handling requests using RxSwift","<ios><swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"41633429","1","41672594","","2017-01-13 11:18:48","","1","953","<p>I am implementing a simple UITableView of addresses using RxSwift and MVVM. I have created a binding in my view controller like this. </p>

<pre><code>viewModel.addressList.asDriver()
   .drive(tableView.rx_itemsWithCellIdentifier(reusableIdentifier, cellType: SavedAddressTableViewCell.self)) { [weak self] (row, viewModel, cell) in
        self?.setUpAddressCell(cell, row: (row + 1))
    }
    .addDisposableTo(disposeBag)
</code></pre>

<p>However, I keep getting this error when I try to open the page in my app.</p>

<pre><code>Maybe delegate was already set in `xib` or `storyboard` and now it's being overwritten in code.
</code></pre>

<p>I Googled and found that I have to set tableView.delegate and tableView.dataSource to nil.</p>

<p>However, there are some UITableViewDataSource methods that I still need, like</p>

<pre><code>canEditRowAtIndexPath
commitEditingStyle
</code></pre>

<p>for deleting addresses.</p>

<p>How should I implement this? Thanks in advance.</p>
","1414770","","1414770","","2017-01-13 11:47:45","2017-02-16 07:22:26","RxSwift, MVVM - Cannot implement UITableViewDataSource methods with RxSwift binding","<ios><swift><mvvm><reactive-programming><rx-swift>","2","0","","","","CC BY-SA 3.0"
"41634912","1","41638649","","2017-01-13 12:41:53","","0","5978","<p>I have a question: how to properly implement such a scenario in Rx-way with RxDataSources:</p>

<p>We have a class with UICollectionView (or UITableView, in my case it's collection view), the results are not immediately present, they come asynchronously after some time.</p>

<p>I have implemented my model with sections according to the tutorial here:
<a href=""https://github.com/RxSwiftCommunity/RxDataSources"" rel=""nofollow noreferrer"">https://github.com/RxSwiftCommunity/RxDataSources</a></p>

<p>But the data is created only once with <code>just</code> there:</p>

<pre><code>let sections = [
  SectionOfCustomData(header: ""First section"", items: [CustomData(anInt: 0, aString: ""zero"", aCGPoint: CGPoint.zero), CustomData(anInt: 1, aString: ""one"", aCGPoint: CGPoint(x: 1, y: 1)) ]),
  SectionOfCustomData(header: ""Second section"", items: [CustomData(anInt: 2, aString: ""two"", aCGPoint: CGPoint(x: 2, y: 2)), CustomData(anInt: 3, aString: ""three"", aCGPoint: CGPoint(x: 3, y: 3)) ])
]

Observable.just(sections)
  .bindTo(collectionView.rx.items(dataSource: dataSource))
  .addDisposableTo(disposeBag)
</code></pre>

<p>What to do in case my items are available after some time and I want my collection view to be updated automatically?</p>

<p>Thanks for any help.</p>
","3990005","","","","","2017-01-13 15:58:54","RxSwift and UICollectionView, UITableView","<ios><swift><uicollectionview><rx-swift><rxdatasources>","1","0","2","","","CC BY-SA 3.0"
"41648830","1","41675651","","2017-01-14 10:12:26","","3","3368","<p>I'm new to RxSwift and I have this code to setup a tableview which contains a textfield:</p>

<pre><code>budget.expenses.asObservable()
  .bindTo(tableView.rx.items(cellIdentifier: ExpenseInputCell.cellIdentifier, cellType: ExpenseInputCell.self)){(row, element, cell) in

  cell.name.text = element.name.value
  cell.name.rx.text
    .bindTo(element.name)
    .addDisposableTo(self.disposeBag)
}
.addDisposableTo(disposeBag)

tableView.rx.itemDeleted
  .subscribe(onNext: {indexPath in
    self.budget.expenses.value.remove(at: indexPath.row)
  })
  .addDisposableTo(disposeBag)
</code></pre>

<p>Everything works fine until a row is deleted, because then the binding of the textfield to the correct object in the array is mixed up. For example lets say I have 7 items in the tableview and I delete the 5th row, the new 5th and 6th row both have the same value</p>
","2529173","","5175709","","2019-06-24 02:12:11","2019-06-24 02:12:11","RxSwift - Textfield-Variable binding in tableview","<ios><swift><uitableview><rx-swift><rx-cocoa>","1","0","1","","","CC BY-SA 3.0"
"41658000","1","41675546","","2017-01-15 05:06:50","","1","2084","<p>Currently, I'm observing the <code>type</code> and <code>value ( int Int instead of Float )</code> of my slider and putting them in the tuple</p>

<pre><code>durationSlider.rx_controlEvent(UIControlEvents.ValueChanged)
              .subscribeNext { in                   
                    viewModel.callback.value = (type:SliderType.Duration, value:Int((self?.durationSlider.value)!))
               }
               .addDisposableTo(disposeBag)
</code></pre>

<p><code>callback</code> is <code>Variable</code> type in view model. To get the changes, I' doing</p>

<pre><code>callback.asObservable()                        
        .subscribeNext {(sliderType, value) in
           print(""value n is \(value)"")        
         }
        .addDisposableTo(disposeBag)
</code></pre>

<p>Since I emits the <code>valueChanged</code> in Int type instead of Float, I'm getting some same values </p>

<pre><code>value is 13
value is 13 
value is 14
...........
</code></pre>

<p>Are there any ways to avoid getting the same values so that I only get the distinct value changed in Int for the slider. I'm not entirely sure if <code>distinctUntilChange()</code> can be used in this case.</p>

<p>All comments are welcomed.</p>
","792562","","1457385","","2017-01-15 15:25:53","2017-01-16 11:37:45","How we can filters an Observable by only allowing 2 distinct items through distinctuntilChange","<ios><objective-c><swift><functional-programming><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"41663930","1","","","2017-01-15 17:14:12","","2","4290","<p>I'm trying to create a collectionView and populate data into it using RxSwift. However even though it seem to return objects in <code>datasource.configureCell</code> it doesn't show any cells. I suspect that there is something wrong with my setup in <code>viewDidLoad</code> ?</p>

<p><strong>Setup collectionView</strong></p>

<pre><code>    // Create a waterfall layout
    let layout = CHTCollectionViewWaterfallLayout()

    //Add CollectionView
    self.collectionView = UICollectionView(frame: CGRect(x: 0, y: 0, width: self.view.frame.width, height: self.view.frame.height), collectionViewLayout: layout)

    self.view.addSubview(collectionView)

    //Customize
    self.collectionView!.alwaysBounceVertical = true

    // Collection view attributes
    self.collectionView.autoresizingMask = [UIViewAutoresizing.flexibleHeight, UIViewAutoresizing.flexibleWidth]
    self.collectionView.alwaysBounceVertical = true

    //Register cell
    collectionView.register(PetsaleCell.self, forCellWithReuseIdentifier: reuseIdentifier)


    //Constraints
    self.collectionView.snp.makeConstraints({ make in
        make.bottom.equalTo(0)
        make.left.equalTo(0)
        make.right.equalTo(0)
        make.top.equalTo(0)

    })

    //Datasource
    setUpDataSource()
</code></pre>

<p><strong>setUpDataSource</strong></p>

<pre><code>func setUpDataSource() {
    dataSource.configureCell = { (_, tv, ip, animal: Animal) in

        let cell = tv.dequeueReusableCell(withReuseIdentifier: self.reuseIdentifier, for: ip) as! PetsaleCell
        cell.petCellViewModel = PetCellViewModel(animal: animal)

        return cell
    }



    let loadNextPageTrigger = self.collectionView.rx.contentOffset
        .flatMap { _ in
            self.collectionView
                .isNearBottomEdge(edgeOffset: 20.0)
                ? Observable.just(())
                : Observable.empty()
    }

    animalViewModel.rx_animals(loadNextPageTrigger)
        .asDriver(onErrorJustReturn: .empty).map { [SectionModel(model: ""Animal"", items: $0.animals)] }
        .drive(collectionView.rx.items(dataSource: dataSource))
        .addDisposableTo(disposeBag)
}


func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAtIndexPath indexPath: IndexPath) -&gt; CGSize {
    return CGSize(width: 200, height: 200)
}
</code></pre>
","4034437","","4034437","","2017-01-15 17:28:31","2017-01-16 14:33:46","collectionView with RxSwift not showing any items","<ios><swift><uicollectionview><rx-swift>","1","1","1","","","CC BY-SA 3.0"
"41681198","1","41681639","","2017-01-16 16:49:30","","3","4617","<p>I am currently having an issue with multiple network requests executing when using RxSwift Observables. I understand that if one creates a cold observable and it has multiple observers, the observable will execute its block each time it is subscribed to. </p>

<p>I have tried to create a shared subscription observable that executes the network request once, and multiple subscribers will be notified of the result. Below is the what I have tried.</p>

<p><strong>Sequence of events</strong></p>

<ol>
<li>Create the view model with the tap event of a uibutton</li>
<li>Create the serviceStatus Observable as a public property on the view model. This Observable is mapped from the buttonTapped Observable. It then filters out the ""Loading"" status. The returned Observable has a shareReplay(1) executed on it to return a shared subscription.</li>
<li>Create the serviceExecuting Observable as a public property on the view model. This observable is mapped from the serviceStatus Observable. It will return true if the status is ""Loading""</li>
<li>Bind the uilabel to the serviceStatus Observable</li>
<li>Bind the activity indicator to the serviceExecuting Observable.</li>
</ol>

<p>When the button is tapped, the service request is executed three time where I would be expecting it to be executed only once. Does anything stand out as incorrect?</p>

<p><strong>Code</strong></p>

<pre><code>class ViewController {

    let disposeBag = DisposeBag()
    var button: UIButton!
    var resultLabel: UILabel!
    var activityIndicator: UIActivityIndicator!

    lazy var viewModel = { // 1
        return ViewModel(buttonTapped: self.button.rx.tap.asObservable())
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        self.viewModel.serviceStatus.bindTo(self.resultLabel.rx_text).addDispsoableTo(disposeBag) // 4
        self.viewModel.serviceExecuting.bindTo(self.activityIndicator.rx_animating).addDispsoableTo(disposeBag) // 5
    }
}

class ViewModel {

    public var serviceStatus: Observable&lt;String&gt; { // 2
        let serviceStatusObseravble = self.getServiceStatusObservable()
        let filtered = serviceStatusObseravble.filter { status in
            return status != ""Loading""
        }
        return filtered
    }

    public var serviceExecuting: Observable&lt;Bool&gt; { // 3
        return self.serviceStatus.map { status in
            return status == ""Loading""
        }
        .startWith(false)
    }

    private let buttonTapped: Observable&lt;Void&gt;

    init(buttonTapped: Observable&lt;Void&gt;) {
        self.buttonTapped = buttonTapped
    }

    private func getServiceStatusObservable() -&gt; Observable&lt;String&gt; {
        return self.buttonTapped.flatMap { _ -&gt; Observable&lt;String&gt; in
            return self.createServiceStatusObservable()
        }
    }

    private func createServiceStatusObservable() -&gt; Observable&lt;String&gt; {
        return Observable.create({ (observer) -&gt; Disposable in

        someAsyncServiceRequest() { result }
            observer.onNext(result)
        })

        return NopDisposable.instance
    })
    .startWith(""Loading"")
    .shareReplay(1)
}
</code></pre>

<p><strong>EDIT:</strong></p>

<p>Based on the conversation below, the following is what I was looking for...</p>

<p>I needed to apply a share() function on the Observable returned from the getServiceStatusObservable() method and not the Observable returned from the createServiceStatusObservable() method. There were multiple observers being added to this observable to inspect the current state. This meant that the observable executing the network request was getting executed N times (N being the number of observers). Now every time the button is tapped, the network request is executed once which is what I needed.</p>

<pre><code>private func getServiceStatusObservable() -&gt; Observable&lt;String&gt; {
    return self.buttonTapped.flatMap { _ -&gt; Observable&lt;String&gt; in
        return self.createServiceStatusObservable()
    }.share()
}
</code></pre>
","1570169","","1570169","","2017-01-25 10:12:15","2017-01-25 10:12:15","RxSwift: Prevent multiple network requests","<ios><rx-swift><reactivex>","1","0","","","","CC BY-SA 3.0"
"41783083","1","41790360","","2017-01-21 18:43:32","","0","279","<p>I try to migrate delegate of DifficultyViewDelegate to observable. This is my DifficultyViewDelegate :</p>

<pre><code>@objc protocol DifficultyViewDelegate: class {
  func levelDidIncrease()
  func levelDidDecrease()
}
</code></pre>

<p>And my DifficultyView :</p>

<pre><code>  weak var delegate: DifficultyViewDelegate?

  @IBAction func decreaseLevel(_ sender: Any) {
    delegate?.levelDidDecrease()
  }

  @IBAction func increaseLevel(_ sender: Any) {
    delegate?.levelDidIncrease()
  }
</code></pre>

<p>And this is my RxDifficultyViewDelegateProxy</p>

<pre><code>class RxDifficultyViewDelegateProxy: DelegateProxy, DelegateProxyType {
  static func currentDelegateFor(_ object: AnyObject) -&gt; AnyObject? {
    let difficultyView: DifficultyView = object as! DifficultyView
    return difficultyView.delegate
  }

  static func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) {
    let difficultyView: DifficultyView = object as! DifficultyView
    difficultyView.delegate = delegate as? DifficultyViewDelegate
  }
}
</code></pre>

<p>I also added an extension on my DifficultyView :</p>

<pre><code>extension DifficultyView {
  public var rx_delegate: RxDifficultyViewDelegateProxy {
    return  RxDifficultyViewDelegateProxy.proxyForObject(RxDifficultyViewDelegateProxy.self)
  }

  public var rx_levelDidIncrease: Observable&lt;Void&gt; {
    return rx_delegate.methodInvoked(#selector(DifficultyViewDelegate.levelDidIncrease)).map { _ in return }
  }
}
</code></pre>

<p>But it seems that when I do :</p>

<pre><code>difficultyView.rx_levelDidIncrease.asObservable().subscribe(onNext: {
  print(""did increase"")
}).addDisposableTo(disposeBag)
</code></pre>

<p>It's never called. Someone has any pointers ?</p>
","5560556","","1113632","","2018-03-27 20:03:29","2018-03-27 20:03:29","Cannot receive event with custom DelegateProxy and Protocol","<ios><swift><swift3><rx-swift>","1","0","0","","","CC BY-SA 3.0"
"41839400","1","41846773","","2017-01-24 21:35:43","","0","1801","<p>I have a <code>CoreLocation</code> manager that should handle all <code>CLLocationManager</code> by offering observable properties through RxSwift (and its Extensions and DelegateProxies). <code>LocationRepository</code> looks like this:</p>

<pre><code>class LocationRepository {
    static let sharedInstance = LocationRepository()
    var locationManager: CLLocationManager = CLLocationManager()
    private (set) var supportsRequiredLocationServices: Driver&lt;Bool&gt;
    private (set) var location: Driver&lt;CLLocationCoordinate2D&gt;
    private (set) var authorized: Driver&lt;Bool&gt;

    private init() {
        locationManager.distanceFilter = kCLDistanceFilterNone
        locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation

        supportsRequiredLocationServices = Observable.deferred {
            let support = CLLocationManager.locationServicesEnabled() &amp;&amp; CLLocationManager.significantLocationChangeMonitoringAvailable() &amp;&amp; CLLocationManager.isMonitoringAvailable(for:CLCircularRegion.self)
            return Observable.just(support)
        }
        .asDriver(onErrorJustReturn: false)

        authorized = Observable.deferred { [weak locationManager] in
            let status = CLLocationManager.authorizationStatus()
            guard let locationManager = locationManager else {
                return Observable.just(status)
            }
            return locationManager.rx.didChangeAuthorizationStatus.startWith(status)
        }
        .asDriver(onErrorJustReturn: CLAuthorizationStatus.notDetermined)
        .map {
            switch $0 {
            case .authorizedAlways:
                return true
            default:
                return false
            }
        }

        location = locationManager.rx.didUpdateLocations.asDriver(onErrorJustReturn: []).flatMap {
            return $0.last.map(Driver.just) ?? Driver.empty()
        }
        .map { $0.coordinate }
    }

    func requestLocationPermission() {
        locationManager.requestAlwaysAuthorization()
    }
}
</code></pre>

<p>My presenter then listens to changes on the repository properties. <code>LocatorPresenter</code> looks like this:</p>

<pre><code>class LocatorPresenter: LocatorPresenterProtocol {
    weak var view: LocatorViewProtocol?
    var repository: LocationRepository?
    let disposeBag = DisposeBag()

    func handleLocationAccessPermission() {
        guard repository != nil, view != nil else {
            return
        }

        repository?.authorized.drive(onNext: {[weak self] (authorized) in
            if !authorized {
                print(""not authorized"")
                if let sourceView = self?.view! as? UIViewController, let authorizationView = R.storyboard.locator.locationAccessRequestView() {
                    sourceView.navigationController?.present(authorizationView, animated: true)
                }
            } else {
                print(""authorized"")
            }
        }).addDisposableTo(disposeBag)
    }
}
</code></pre>

<p>It does work, but I'm getting the <code>Driver</code> calling twice for the first time I try to get the authorization status, so the access request view gets presented twice. What am I missing here?</p>

<p>Regards!</p>
","4793072","","","","","2017-01-25 09:02:55","RxSwift Driver calling twice on first time","<swift><core-location><rx-swift>","1","0","","","","CC BY-SA 3.0"
"41849648","1","41850185","","2017-01-25 10:50:34","","0","3360","<p>I'm new to using RxSwift framework, I'm actually learning and trying to understand the basics and I would like some help from you please.</p>

<pre><code>private func observeCurrentIndex() -&gt; Observable&lt;Int&gt; {
    return Observable&lt;Int&gt;.create { (observer) -&gt; Disposable in
      observer.onNext(self.currentIndex)
      return Disposables.create()
    }
  }
</code></pre>

<p>Here I've created an observable on currentIndex which is an int. When I subscribe to it, I get only the first value of currentIndex which is 2. Is it not supposed to notify me whenever currentIndex changes(just like a KVO would)?</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    observeCurrentIndex()
      .subscribe(onNext: { (valeur) in
        print(""new value \(valeur)"")
      })
      .addDisposableTo(disposeBag)
  }
</code></pre>

<p>To be notified each time currentIndex changes value, I've been told that I have to use a publishSubject for that.</p>

<pre><code>@IBAction func increaseAction(_ sender: UIButton) {
    if currentIndex &lt;= kMaxIndex {
      currentIndex = currentIndex + 1
    }
  }
</code></pre>

<p>Could someone indicate to me where and how to do this? Thanks in advance.</p>
","399059","","1173513","","2017-01-25 13:46:35","2017-01-25 13:46:35","How to use a Publish subject to observe a variable's value?","<swift><reactive-programming><observable><publish-subscribe><rx-swift>","2","0","","","","CC BY-SA 3.0"
"41867044","1","41867446","","2017-01-26 04:45:57","","0","885","<p>I have some test function which observers values and map their to another <code>Observable</code>: </p>

<pre><code>private func test1() {
    selectedTagsVariable
        .asObservable()
        .flatMapLatest { [weak self] tags -&gt; Observable&lt;PostSet&gt; in
            guard let strongSelf = self else { return .empty() }
            return strongSelf.postSetObservable(for: tags)
        }
}
</code></pre>

<p>It's ok, but I don't want each time check <strong>self</strong> value to nil. Of course, I can replace <code>weak</code> to <code>unowned</code>, but it's not correct.</p>

<p>So, I have created the custom <code>flatMapLatest</code>:</p>

<pre><code>extension ObservableType {

func xflatMapLatest&lt;A:AnyObject, O: ObservableType&gt;(weak obj: A, selector: @escaping (A, Self.E) throws -&gt; O) -&gt; Observable&lt;O.E&gt; {
    return flatMapLatest { [weak obj] value -&gt; Observable&lt;O.E&gt; in
        guard let strongObj = obj else {
            return Observable.empty()
        }
        return try selector(strongObj, value) as! Observable&lt;O.E&gt;
    }
}
}
</code></pre>

<p>and it looks like this:</p>

<pre><code>private func test2() {
    selectedTagsVariable
        .asObservable()
        .xflatMapLatest(weak: self) { obj, tags -&gt; Observable&lt;PostSet&gt; in
            return obj.postSetObservable(for: tags)
        }
}
</code></pre>

<p><strong>Question</strong>: I don't like the typecast in <code>xflatMapLatest</code> function in return type (<code>as! Observable&lt;O.E&gt;</code>). Can I somehow remove it? Help to refactor this method :)</p>
","3733734","","","","","2017-01-26 05:29:55","Custom flatMapLatest with nil wrapping","<ios><swift><generics><rx-swift>","1","0","","","","CC BY-SA 3.0"
"41889710","1","41929826","","2017-01-27 08:32:28","","0","1571","<p>I have a method as following</p>

<pre><code>public static func createAlbum(named: String, completion: (album: PHAssetCollection?) -&gt; ()) {
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0)) {

      }) { success, error in


                completion(album: album)
          }
       }
}
</code></pre>

<p>How can i do the background task using RxSwift</p>

<p>complete code</p>

<p><a href=""https://gist.github.com/sazzadislam-dsi/d347909d284674c936e397ac423703cf"" rel=""nofollow noreferrer"">https://gist.github.com/sazzadislam-dsi/d347909d284674c936e397ac423703cf</a></p>
","5421493","","","","","2017-01-30 06:08:03","RxSwift Simple background task example","<swift3><rx-swift>","2","0","","","","CC BY-SA 3.0"
"41911565","1","41911767","","2017-01-28 15:36:03","","5","7357","<p>I'm using a <code>Moya</code>, <code>Moya_ModelMapper</code> and <code>RxSwift</code> to perform network requests.
Here is my example code: </p>

<pre><code>let provider = RxMoyaProvider&lt;MyEndpoint&gt;()
let observable: Observable&lt;RegistrationResponse&gt; = provider.request(.register(firstName: """", lastName: """", email: """", password: """")).mapObject(type: RegistrationResponse.self)
observable.subscribe {
    [weak self] (event: Event&lt;RegistrationResponse&gt;) in
    switch event {
    case .next(let response):
        print(response)
    case .error(let error):
        print(error)
    case .completed:
        break
    }
}
</code></pre>

<p>Everything works fine, but I don't know how to get an error code when I receive for example a <code>409</code> status code response type from the server. 
If I print the error I will get: </p>

<p><code>jsonMapping(Status Code: 409, Data Length: 0)</code></p>

<p>but I don't know how to get this status code by code. The error is <code>MoyaError</code> which is an Enum type. Here it's a <a href=""https://github.com/Moya/Moya/blob/master/Sources/Moya/MoyaError.swift"" rel=""noreferrer"">source code</a> of MoyaError.</p>

<p>Thanks!</p>
","5433235","","5433235","","2017-01-28 15:43:46","2021-07-28 07:44:08","How to get error statusCode from `MoyaError`?","<ios><swift><alamofire><rx-swift><moya>","2","2","","","","CC BY-SA 3.0"
"41915285","1","41920096","","2017-01-28 21:56:39","","2","1358","<p>I'm working on an Apple TV app that uses Parse-Server as a backend and RxSwift and I'm trying to set up an authentication system similar to those on the tv streaming apps.</p>

<p>Right now I have an AuthenticationCode object in the parse database that has a code, device id, and session token column. I'm trying to use RxSwift's interval to perform a fetch on the object every 5 seconds, and am checking if the session token column has been filled out.</p>

<p>Here is the code:</p>

<pre><code>func poll(authorizationCode: AuthorizationCode) -&gt; Observable&lt;AuthorizationCode&gt; {
    return Observable&lt;Int&gt;.interval(5, scheduler: MainScheduler.instance).flatMap({ _ in
        return Observable&lt;AuthorizationCode&gt;.create { observer -&gt; Disposable in
            authorizationCode.fetchInBackground(block: { (authorizationCode, error) in
                if let authorizationCode = authorizationCode as? AuthorizationCode {
                    observer.onNext(authorizationCode)

                    if authorizationCode.sessionToken != nil {
                        observer.onCompleted()
                    }
                } else if let error = error {
                    observer.onError(error)
                }
            })

            return Disposables.create()
        }
    })
}
</code></pre>

<p>I'm emitting on onNext event every time I fetch the object, and I want to terminate the sequence when the session code exists.</p>

<p>The problem I'm having with this code is that even after the session token is filled out and the onCompleted is called, the timer still fires and the subscriber never gets the onCompleted event.</p>

<p>Any help with this is appreciated.</p>

<p>Also, if I'm way off on how I should be doing this, let me know.</p>

<p>I would use Parse-Server live queries but they currently don't support tvOS.</p>

<p>Thanks.</p>
","4408483","","","","","2020-02-24 15:30:00","Polling with RxSwift and Parse-Server","<ios><swift><polling><parse-server><rx-swift>","1","0","","","","CC BY-SA 3.0"
"41932734","1","41967192","","2017-01-30 09:41:25","","6","6031","<p>I'm beginning with MVVM in order to well separate logic code from the view. But I have some concern about where to put the progressHUD related code when tapping a button that makes a request.</p>

<p>Before, I used to do that:</p>

<pre><code>//Before 
@IBAction func startRequestTapped() {
   SVProgressHUD.show()
    self.apiClient.requestObservable().subscribe(onError: { (error) in
        SVProgressHUD.hide()                    
    }, onCompleted: { 
        SVProgressHUD.hide()                                        
    })
}
</code></pre>

<p>But when I use mvvm, I do like that:</p>

<pre><code>//In the viewModel
public var validateButtonDidTap = PublishSubject&lt;Void&gt;()
init() {
    validateButtonDidTap.flatMap { (_)
        return self.apiClient.requestObservable()
    }
}


   // In the viewController
viewDidLoad() {
    let tap = self.validateButton.rx.tap
    tap.bindTo(self.viewModel.validateButtonDidTap)
}
</code></pre>

<p>And amongst that, I don't know where to put the the ProgressHUD hide or show.</p>
","3620372","","1173513","","2017-01-30 09:57:38","2017-12-01 10:37:37","How to show/hide the progressHUD, with MVVM and RxSwift in swift","<ios><swift><mvvm><rx-swift><svprogresshud>","3","0","2","","","CC BY-SA 3.0"
"41975515","1","41978052","","2017-02-01 08:54:26","","1","958","<p>I have the following function in my webservice class:</p>

<pre><code> func loadTransport() -&gt; Observable&lt;[TransportResponse]&gt; {
        let nonce = ""\(Date().timeIntervalSince1970)""
        let csaKey = try! config.apikey()
        let csaSecret = try! config.apiSecret()

        let csaSignature = crypto.generateSignature(nonce: nonce, url: ""http://*****/v1/nmbs"", body: """", secret: csaSecret)
        print(""SIGNATURE = \(csaSignature)"")

        let endpointClosure = { (target: TransportService) -&gt; Endpoint&lt;TransportService&gt; in
            let url = target.baseURL.appendingPathComponent(target.path).absoluteString
            let endpoint = Endpoint&lt;TransportService&gt;(URL: url, sampleResponseClosure: {.networkResponse(200, target.sampleData)}, method: target.method, parameters: target.parameters)
            return endpoint.adding(newHttpHeaderFields: [""CSA-KEY"": csaKey,""CSA-NONCE"": nonce,""CSA-SIGNATURE"": csaSignature])
        }



        let provider = RxMoyaProvider&lt;TransportService&gt;(endpointClosure: endpointClosure, plugins: [NetworkLoggerPlugin(verbose: true)])
        return provider
            .request(TransportService.nmbs)
            .filterSuccessfulStatusCodes()
            .mapArray(type: TransportResponse.self)
    }
</code></pre>

<p>And in my TransportViewModel I have this init method:</p>

<pre><code> init(webService: Webservice) {
        self.webService = webService

        title.value = String.localizedString(key: ""transport_title"")



        transportResponse = active.asObservable()
            .filter { $0 }
            .flatMap {  _  in
                return webService.loadTransport()
            }
            .map { response in
                return [TransportData(items: response)]
        }    
    }
</code></pre>

<p>The problem is it comes in my <code>flatMap</code> method but it never comes inside the <code>map</code> below the <code>flatMap</code>. </p>

<p>When I add a subscribe part to my webservice function like this: </p>

<pre><code> let provider = RxMoyaProvider&lt;TransportService&gt;(endpointClosure: endpointClosure, plugins: [NetworkLoggerPlugin(verbose: true)])
    provider
        .request(TransportService.nmbs)
        .filterSuccessfulStatusCodes()
        .mapArray(type: TransportResponse.self)
        .subscribe { event in
            switch event {
            case .next(let response):
                print(response)
            case .error(let error):
                print(error)
            default: break
            }
    }.addDisposableTo(disposeBag)
</code></pre>

<p>I see that my response is correctly printed. 
Can anybody help me with this?</p>
","965273","","","","","2017-02-01 10:59:47","Mapping moya result with moya_modelMapper","<iphone><swift><rx-swift><moya>","1","1","","","","CC BY-SA 3.0"
"42002153","1","","","2017-02-02 12:20:35","","6","2678","<p>I am having problem understanding the rationale and purpose for <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observable.swift#L26"" rel=""noreferrer"">asObservable method</a> in RxSwift's <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observable.swift#L12"" rel=""noreferrer"">Observable class</a>.</p>

<pre><code>/// A type-erased `ObservableType`. 
///
/// It represents a push style sequence.
public class Observable&lt;Element&gt; : ObservableType {
    /// Type of elements in sequence.
    public typealias E = Element

    public func subscribe&lt;O: ObserverType&gt;(_ observer: O) -&gt; Disposable where O.E == E {
        abstractMethod()
    }

    public func asObservable() -&gt; Observable&lt;E&gt; {
        return self
    }
}
</code></pre>

<p>What's the purpose of asObservable when it's returning self? </p>

<p>Surely if you can run this method, you already have access to the object. Also, what does the ""type-erased <code>ObservableType</code>"" in the comment means?</p>
","66814","","66814","","2017-02-03 22:19:59","2021-07-30 13:45:45","Swift: RxSwift's asObservable() method and type erasure","<swift3><type-erasure><rx-swift>","3","0","1","","","CC BY-SA 3.0"
"42002251","1","42020735","","2017-02-02 12:25:44","","2","1225","<p>I'm creating a custom generic TableView model to work with MVVM and RxSwift. I'm aware of the <code>RxTableViewSectionedReloadDataSource</code> class but not willing to use it now in my project.</p>

<p>The model is created and working</p>

<pre><code>typealias TableViewModel = TableModel&lt;CellDescriptor&gt;

class TableModel&lt;T&gt; {

    var sections = [SectionModel&lt;T&gt;]()

    func add(item: SectionModel&lt;T&gt;) {
        sections.append(item)
    }

    // More funcs there...
}
</code></pre>

<p>I created an instance inside my ViewModel as such :</p>

<pre><code>var tableViewModel = Variable&lt;TableViewModel&gt;(TableViewModel())
</code></pre>

<p>And then listen to event in my viewController</p>

<pre><code>viewModel.tableViewModel.asObservable().subscribe({ [weak self] value in
    self?.tableView.reloadData()
}).addDisposableTo(dispose)
</code></pre>

<p>Several questions here (I'm fairly new to FRP)
 :</p>

<ul>
<li><p>How can I ""emit"" an event to trigger my subscription in the viewController from my custom class?
I know that a solution would be to create my sections array as a RxSwift <code>Variable()</code> and then listen to it directly, but wonder if there's a way to make a class (or struct) itself Observable.</p></li>
<li><p>Is there a better approach to this problem ? I went through the RxSwift playground and example project but it sounds like there's a thousand ways to do the same thing. Maybe an <code>Observable</code> is not what i would be looking for. :) </p></li>
</ul>
","1685644","","343299","","2017-02-03 09:19:55","2017-02-03 09:19:55","RxSwift - Custom class as observable","<ios><swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 3.0"
"42008825","1","","","2017-02-02 17:39:22","","1","2578","<p>I'm using RxSwift and I'm trying to extend another library I'm using to make something observable.</p>

<p>The library basically calls a delegate method every time a value changes, and I want to hook into this and whenever it calls the delegate, also add the new value to an observable sequence I want to create in my subclass.</p>

<p>I've seen how you can create observable sequences, but in each example <code>next</code> events are sent to the observer within the block given to the <code>Observable.create</code> method. I have no idea how I can add things to the observable sequence from ""outside"" this block passed to <code>create</code>.</p>

<p>I just want to create something that I can observe or can drive things with RxSwift, and manually add to the sequence at certain points.</p>

<p>I'd be very grateful if someone could point me in the right direction, as I'm very new to this.</p>
","2026361","","","","","2017-02-02 19:42:13","Creating an observable with RxSwift","<ios><swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"42015597","1","42032679","","2017-02-03 02:07:23","","2","734","<p>I am looking for an operator that combines two <code>Observables</code> by not emitting anything until both <code>Observables</code> have emitted an element (similar to <code>combineLatest</code>), but then only emits elements by combining elements from one <code>Observable</code> with the most recently emitted element of the other <code>Observable</code> (similar to <code>withLatestFrom</code>). The results would look like this (<code>y</code> observable is the ""control""):</p>

<p><a href=""https://i.stack.imgur.com/ChyYZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ChyYZ.png"" alt=""enter image description here""></a></p>

<p>Does an operator like this exist?</p>
","1653465","","1653465","","2017-02-03 02:18:55","2017-02-03 20:46:54","Rx operator that starts like combineLatest but then acts like withLatestFrom","<reactive-programming><rx-swift><reactivex>","2","0","","","","CC BY-SA 3.0"
"42050066","1","42069072","","2017-02-05 08:39:21","","16","25019","<p>I have a table view in my app. I generated the datasource for this table using following code</p>

<pre><code>struct ContactNameNumberBlockStatus {
    var contactThumbnail: Data?
    var contactName : String
    var contactNumber: String
    var blockStatus : Bool
}

class BlockListTableViewCell: UITableViewCell {
    @IBOutlet weak var contactImage: UIImageView!
    @IBOutlet weak var contactName: UILabel!
    @IBOutlet weak var contactNumber: UILabel!
    @IBOutlet weak var blockButton: UIButton!
    var eachCell : ContactNameNumberBlockStatus! {
        didSet {
            // setting ui
        }
    }
}

private func showTableContent(data :   Observable&lt;[ContactNameNumberBlockStatus]&gt;) {
        data.bindTo(tableView.rx.items(
            cellIdentifier: ""BlockListTableViewCell"")) {
            row, contributor, cell in
            if let cell2 = cell as? BlockListTableViewCell {
                cell2.eachCell = contributor
            }
            }.addDisposableTo(disposeBag)
}
</code></pre>

<p>Now when I tap on cell I want to update ui by showing/hiding <code>blockButton</code> mentioned in top</p>

<p>how to do this ??</p>

<p>before using rx i used the didSelectRowAt of table view  as following</p>

<pre><code>func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        contacts[indexPath.row].blockStatus = false
        self?.tableView.reloadData()
}
</code></pre>

<p>I found that <code>tableView.rx.itemSelected</code> is same as above <code>didSelectRowAt</code> but i cant find  how i can update the table view using following code</p>

<pre><code>tableView.rx.itemSelected
  .subscribe(onNext: { [weak self]indexPath in

  }).addDisposableTo(disposeBag)
</code></pre>

<p>So how to update the cell?</p>
","1097800","","","","","2020-10-19 12:56:03","RxSwift modify tableview cell on select","<ios><rx-swift><rx-cocoa>","3","2","3","","","CC BY-SA 3.0"
"42056416","1","","","2017-02-05 19:40:35","","3","5979","<p>I'm very new on Mac / iOS development with Xcode and I have trouble on building my App. I work since 4 days on that issue,  but I have no more ideas to find the reason.</p>

<p>The App has 6 projects, bundled in a xcworkspace. I added via cocoapods and via terminal with command pod install RxSwift, RxCocoa, OMGHTTPURLRQ, PromiseKit and SVWebViewController successfully. The projects without dependencies could build successfully. Two projects (libraries) with command ""import RxCocoa"" and ""import RxSwift"" in *.swift files are failed with error ""No such module 'RxCocoa'"".</p>

<p>I read some Stackoverflow posts and the RxSwift Git documentation to solve the issue, without success.</p>

<p><a href=""https://i.stack.imgur.com/goLQ5.png"" rel=""nofollow noreferrer"">Screenshot of build error and added reference</a></p>

<p>Podfile definition:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '9.1'
use_frameworks!
target 'CheckMyBus' do
    pod ""OMGHTTPURLRQ"", ""~&gt; 3.1.2“
    pod ""RxSwift"", ""~&gt; 2.3.0""
    pod 'RxCocoa', '~&gt; 2.3.0'
    pod 'PromiseKit', '~&gt; 3.2.1'
    pod 'SVWebViewController', '~&gt; 0.2‘
end</code></pre>
</div>
</div>
</p>

<p>Pods installation via terminal:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>MacMinis-Mac-mini:CheckMyBus MacMini$ pod install
Analyzing dependencies
Downloading dependencies
Using OMGHTTPURLRQ (3.1.3)
Using PromiseKit (3.2.1)
Using RxCocoa (2.3.1)
Using RxSwift (2.3.1)
Using SVWebViewController (0.2)
Generating Pods project
Integrating client project
Sending stats
Pod installation complete! There are 5 dependencies from the Podfile and 5 total pods installed.

[!] Your Podfile has had smart quotes sanitised. To avoid issues in the future, you should not use TextEdit for editing it. If you are not using TextEdit, you should turn off smart quotes in your editor of choice.

[!] The `CheckMyBus [Debug]` target overrides the `EMBEDDED_CONTENT_CONTAINS_SWIFT` build setting defined in `Pods/Target Support Files/Pods-CheckMyBus/Pods-CheckMyBus.debug.xcconfig'. This can lead to problems with the CocoaPods installation
    - Use the `$(inherited)` flag, or
    - Remove the build settings from the target.

[!] The `CheckMyBus [Release]` target overrides the `EMBEDDED_CONTENT_CONTAINS_SWIFT` build setting defined in `Pods/Target Support Files/Pods-CheckMyBus/Pods-CheckMyBus.release.xcconfig'. This can lead to problems with the CocoaPods installation
    - Use the `$(inherited)` flag, or
    - Remove the build settings from the target.
MacMinis-Mac-mini:CheckMyBus MacMini$ </code></pre>
</div>
</div>
</p>

<p>Can anybody help me?</p>
","4827685","","","","","2019-08-06 20:04:31","How to solve Xcode build error ""No such module RxCocoa""?","<ios><xcode><cocoapods><rx-swift><rx-cocoa>","2","1","1","","","CC BY-SA 3.0"
"42081789","1","","","2017-02-07 04:33:39","","1","2889","<p>I have a problem when implementing the <a href=""https://developer.apple.com/library/content/samplecode/avloopplayer/Introduction/Intro.html"" rel=""nofollow noreferrer"">AVFoundation Looping Player example</a> in Rxswift. 
In example here is the add observer code:</p>

<pre><code>player.addObserver(self, forKeyPath: ""status"", options: .new, context: &amp;ObserverContexts.playerStatus)
player.addObserver(self, forKeyPath: ""currentItem"", options: .old, context: &amp;ObserverContexts.currentItem)
player.addObserver(self, forKeyPath: ""currentItem.status"", options: .new, context: &amp;ObserverContexts.currentItemStatus)
</code></pre>

<p><code>player</code> is <code>AVQueuePlayer</code></p>

<p>and the observer callback code is:</p>

<pre><code>override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
    if context == &amp;ObserverContexts.playerStatus {
        guard let newPlayerStatus = change?[.newKey] as? AVPlayerStatus else { return }

        ...

    }
    else if context == &amp;ObserverContexts.currentItem {
        guard let player = player else { return }

        if player.items().isEmpty {
            ...
        }
        else {

            ...

            if let itemRemoved = change?[.oldKey] as? AVPlayerItem {
                ...
            }
        }
    }
    else if context == &amp;ObserverContexts.currentItemStatus {
        guard let newPlayerItemStatus = change?[.newKey] as? AVPlayerItemStatus else { return }

        ...
    }
    else {
        super.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)
    }
}
</code></pre>

<p>Please pay attention at the observer of <strong>currentItem</strong> value. In that case we want to get the <strong>old</strong> value when <strong>currentItem</strong> changed. The example work fine.</p>

<p>Here is the code in Rxswift edition:</p>

<pre><code>player.rx.observe(AVPlayerStatus.self, ""status"", options: .new)
        .subscribe(onNext: { [weak self] status in
            ...
        }).addDisposableTo(disposeBag)

player.rx.observe(AVPlayerItem.self, ""currentItem"", options: .old)
        .subscribe(onNext: { [weak self] item in
            guard let `self` = self else { return }
            guard let itemRemoved = item else { return }

            print(""\(itemRemoved)"")

        }).addDisposableTo(disposeBag)

player.rx.observe(AVPlayerItemStatus.self, ""currentItem.status"", options: .new)
        .subscribe(onNext: { [weak self] status in
            ...
        }).addDisposableTo(disposeBag)
</code></pre>

<p><strong>The problem is</strong> the observer of <strong>currentItem</strong> value always <strong>nil</strong>. This confuse me a lot. Why can not get the old value with the <code>NSKeyValueObservingOptions.old</code>.
I try to figure out why.</p>

<p>Found following code (in RxCocoa/Foundation/NSObject+Rx.swift):</p>

<pre><code>fileprivate class KVOObserver
    : _RXKVOObserver
    , Disposable {
    typealias Callback = (Any?) -&gt; Void

    var retainSelf: KVOObserver? = nil

    init(parent: KVOObservableProtocol, callback: @escaping Callback) {
        #if TRACE_RESOURCES
            _ = Resources.incrementTotal()
        #endif

        super.init(target: parent.target, retainTarget: parent.retainTarget, keyPath: parent.keyPath, options: parent.options, callback: callback)
        self.retainSelf = self
    }

    override func dispose() {
        super.dispose()
        self.retainSelf = nil
    }

    deinit {
        #if TRACE_RESOURCES
            _ = Resources.decrementTotal()
        #endif
    }
}

fileprivate class KVOObservable&lt;Element&gt;
    : ObservableType
    , KVOObservableProtocol {
    typealias E = Element?

    unowned var target: AnyObject
    var strongTarget: AnyObject?

    var keyPath: String
    var options: NSKeyValueObservingOptions
    var retainTarget: Bool

    init(object: AnyObject, keyPath: String, options: NSKeyValueObservingOptions, retainTarget: Bool) {
        self.target = object
        self.keyPath = keyPath
        self.options = options
        self.retainTarget = retainTarget
        if retainTarget {
            self.strongTarget = object
        }
    }

    func subscribe&lt;O : ObserverType&gt;(_ observer: O) -&gt; Disposable where O.E == Element? {
        let observer = KVOObserver(parent: self) { (value) in
            if value as? NSNull != nil {
                observer.on(.next(nil))
                return
            }
            observer.on(.next(value as? Element))
        }

        return Disposables.create(with: observer.dispose)
    }
}
</code></pre>

<p>When <code>subscribe</code> the observer, there create a <code>KVOObserver</code> with callback. And <code>KVOObserver</code>'s base class is <code>_RXKVOObserver</code>.</p>

<p>In file(RxCocoa/Runtime/_RXKVOObserver.m), I found following code:</p>

<pre><code>@implementation _RXKVOObserver

-(instancetype)initWithTarget:(id)target
                 retainTarget:(BOOL)retainTarget
                      keyPath:(NSString*)keyPath
                      options:(NSKeyValueObservingOptions)options
                     callback:(void (^)(id))callback {
    self = [super init];
    if (!self) return nil;

    self.target = target;
    if (retainTarget) {
        self.retainedTarget = target;
    }
    self.keyPath = keyPath;
    self.callback = callback;

    [self.target addObserver:self forKeyPath:self.keyPath options:options context:nil];

    return self;
}

-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
    @synchronized(self) {
        self.callback(change[NSKeyValueChangeNewKey]);
    }
}

-(void)dispose {
    [self.target removeObserver:self forKeyPath:self.keyPath context:nil];
    self.target = nil;
    self.retainedTarget = nil;
}

@end
</code></pre>

<p>In <code>observeValueForKeyPath</code> func it only return the <code>change[NSKeyValueChangeNewKey]</code> to callback. And obviously there is no value when I pass the <code>NSKeyValueObservingOptions.old</code> key to watch <code>currentItem</code> change.</p>

<p><strong>My question is:</strong> Did I doing the wrong way to observe the old value of <code>currentItem</code> in Rxswift? If so, how to watch the old value of <code>currentItem</code> in Rxswift?</p>
","7526439","","7526439","","2017-02-10 04:00:59","2017-02-10 04:00:59","RxSwift KVO observe doesn't return the old changed value","<ios><swift><avfoundation><rx-swift>","0","1","","","","CC BY-SA 3.0"
"42082864","1","42086194","","2017-02-07 06:08:20","","16","8978","<p>I am trying to import rxswift in xcode playground by this: </p>

<pre><code>gem install cocoapods-playgrounds
</code></pre>

<p>and after that</p>

<pre><code>pod playgrounds RxSwift
</code></pre>

<p>But it is not happening. How to do it?</p>
","5408958","","733168","","2019-11-02 01:33:54","2020-04-29 13:42:09","How to import RxSwift in Playground of xcode?","<swift><xcode><cocoapods><rx-swift>","7","1","3","","","CC BY-SA 3.0"
"42086454","1","","","2017-02-07 09:43:26","","1","583","<p>When it comes to enforcing that a certain piece of <code>Observable.create</code> code runs in a specific thread (i.e. background thread), i worry that using the <code>subscribeOn</code> operator might not work because there are times that I might chain this observable sequence to another observable sequence that runs on a main thread (using <code>observeOn</code>). </p>

<h2>Example</h2>

<p>The situation is that I have an Observable sequence running on the main thread (i.e. an alert box asking the user for input, as to whether perform the network call or not).</p>

<p>Would it be better to ensure that this <code>Observable.create</code> code runs in the background thread by having something like:</p>

<pre><code>Observable&lt;String&gt;.empty()
   .observeOn(ConcurrentMainScheduler(queue: background.queue))
   .concat(myObservableNetworkCall)
</code></pre>

<h3>Why not just use <code>subscribeOn</code>?</h3>

<p>The problem is if I had used <code>subscribeOn</code> (second) and the previous observable (the alert controller) was set to run on the background thread using <code>subscribeOn</code> (first), then the second <code>subscribeOn</code> operator would not work since the first call is closer to the source observable:</p>

<blockquote>
  <p><em>If you specify multiple subscribeOn() operators, the one closes to the source (the left-most), will be the one used.</em></p>
  
  <ul>
  <li><a href=""http://tomstechnicalblog.blogspot.com/2016/02/rxjava-understanding-observeon-and.html"" rel=""nofollow noreferrer"">Thomas Nield on RxJava's subscribeOn and observeOn operators</a> (February 2016)</li>
  </ul>
</blockquote>

<p>That may be the behavior for RxJava, but I am not sure for Swift. Reactivex.io simply says that we should not call <code>subscribeOn</code> multiple times.</p>

<p>I tend to wrap operations into <code>Observable&lt;Void&gt;</code>s and they need to be run on different threads... That is why I am asking for how to ensure an Observable code run in the thread I specified it to. <code>subscribeOn</code> wouldn't work because I can concatenate the observable.</p>

<p>I want the thread it should run in to be encapsulated in my Observable definition, not higher up in the chain.</p>

<p><strong>Is the best practice to do the following:</strong></p>

<ol>
<li>Start with an Observable.empty using the data type I wish to use.</li>
<li>Use <code>observeOn</code> to force the thread that I want it to run in.</li>
<li>Concatenate it with the actual Observable that I want to use.</li>
</ol>

<h1>Edit</h1>

<ol>
<li><p>I have read the <code>subscribeOn</code> and <code>observeOn</code> documentation on reactivex.io.</p></li>
<li><p>I'm familiar with how to switch between threads using <code>subscribeOn</code> and <code>observeOn</code>.</p></li>
<li><p><strong>What I'm specifically concerned about is the complication of using <code>subscribeOn</code> when concatenating or combining observable sequences.</strong></p></li>
<li><p>The problem is, the observables need to run specifically on one thread, AND they don't know where and who they'll be concatenated with. Since I know exactly which thread they should run on, I'd prefer to encapsulate the scheduler definition within the observable's definition instead of when I'm chaining a sequence.</p></li>
</ol>
","1323398","","1323398","","2017-02-08 04:29:59","2017-02-08 04:29:59","Concatenating two observable sequences that both have subscribeOn. How do I ensure my observable runs on a thread?","<swift><rx-swift>","1","3","0","","","CC BY-SA 3.0"
"42108714","1","","","2017-02-08 09:02:30","","6","7919","<h3>just like UITableView</h3>

<pre><code>    items.bindTo(tableView.rx.items(cellIdentifier: ""cellIdentifier"", cellType: AttentionTableViewCell.self)){(row,dic,cell) in
        cell.configueCell(with: dic)
    }.addDisposableTo(dispose)
</code></pre>
","6671769","","","","","2019-03-17 14:02:19","How to realize UIPickerView with RXSwift","<ios><swift><uipickerview><rx-swift>","3","3","","","","CC BY-SA 3.0"
"42115976","1","","","2017-02-08 14:35:24","","5","5415","<p>I am trying to create a stream that polls a network service. At the moment it queries the service then completes after a short delay. I'd like the onward stream to restart rather than completing thereby polling the service forever.</p>

<p>You could do something like ...</p>

<pre><code>myPollingStream.repeat()
</code></pre>

<p>But <code>repeat</code> in RxSwift is actually <code>repeatElement</code> and so actually generates a stream of observables. You could possibly <code>concatMap</code> these into a flattened serial sequence but RxSwift does not have the <code>concatMap</code> operator.</p>

<p>So how do I loop an observable in RxSwift?</p>

<p>I'd like the requests to be sequential, not concurrent so <code>flatMap</code> is not an option since it merges streams leading to overlapping requests. I'm looking for something similar to how <code>retry()</code> works but restarting <code>onComplete</code> not <code>onError</code></p>
","199","","199","","2017-02-08 15:53:08","2017-02-12 07:29:02","How do I sequentially loop an observable in RxSwift?","<swift><reactive-programming><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"42131816","1","42132003","","2017-02-09 08:42:40","","3","2181","<p>I have tableview in my iOS App</p>

<p>I have initialize the table using following code</p>

<pre><code>var cnList : Observable&lt;[CountryCode]&gt;?
override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
    cnList = readJson()
        cnList?.bindTo(cTableView.rx.items(cellIdentifier: ""country_code_cell"")) {
            _, countryCode, cell in
            if let countryCodeCell = cell as? CountryCodeTableViewCell {
                countryCodeCell.cNameLabel.text = countryCode.name
                countryCodeCell.cCodeLabel.text = countryCode.dial_code!
            }
        }.addDisposableTo(disposeBag)
}
</code></pre>

<p>now I have a text field and I want to filter the cList based on the text of that text field</p>

<p>I can print text as i press key</p>

<pre><code>searchTextField.rx.text.asObservable().subscribe(onNext: {
            text in
            if text != nil &amp;&amp; text != """" {
                // need to filter cnList and update tableview here i think but how ??
            }
        }).addDisposableTo(disposeBag)
</code></pre>

<p>but I am not sure how to filter <code>cnList</code> and update the <code>table view</code></p>

<p>So how to do this ??</p>
","1097800","","","","","2017-02-09 08:51:48","RxSwift filter observable sequence and bind to tableview","<ios><swift><swift3><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"42145623","1","","","2017-02-09 19:51:56","","3","5264","<p>I am trying to detect if a observable(my case <strong>button.rx.tap</strong>) has not emitted any value for say like 3 seconds. If yes, I would like to update the user interface. Here is my attempt so far:</p>

<pre><code>Observable&lt;Int&gt;.interval(3, scheduler: MainScheduler.instance)
    .takeUntil(button.rx.tap) // I know take until will stop the timer sequence 
    .subscribe({ event in
        print(event)
        UIView.animate(withDuration: 0.4, animations: {
            if let number = event.element {
                let scale: CGFloat = number % 2 == 0 ? 1.5 : 1.0
                self.button.transform = CGAffineTransform(scaleX: scale, y: scale)
            }
        })
    })
    .addDisposableTo(disposeBag)
</code></pre>

<p>My goal is to animate the view whenever the button is <strong>not tapped</strong> for three seconds. I have tried <strong>scan</strong>, <strong>distinctUntilChanged</strong> and <strong>debounce</strong> but most combining operators I have encountered will emit items only when an item is emitted by a observable. Any help is much appreciated.</p>
","1417389","","","","","2017-02-10 04:50:43","How to detect if a observable has not emitted any events for specific time in RxSwift","<swift><reactive-programming><rx-swift><rx-cocoa>","1","0","3","","","CC BY-SA 3.0"
"42177890","1","42186330","","2017-02-11 15:52:36","","2","1429","<p>I can see that I can use <code>Subject</code> like <code>Publish</code> or <code>Variable</code> to add new element to table view or collection view and that will show properly at the end but what if need to add new data at the beginning of the table view. what to do then??</p>

<p>How can I prepend data to a observable sequence so that new data shows at the top of tableview or collection view ???</p>
","1097800","","","","","2017-02-13 03:16:17","How to prepend data to tableview or collectionview using RxSwift","<ios><swift><uitableview><swift3><rx-swift>","2","0","","","","CC BY-SA 3.0"
"42179134","1","42180795","","2017-02-11 17:47:24","","6","8452","<p>I have a struct Person and person array as following</p>

<pre><code>struct Person {
  let name : String
  let age : Int
}

let personArray = [
    Person(name : ""Max"", age : 32),
    Person(name : ""Jones"", age : 42),
    Person(name : ""Other"", age : 62)
]
</code></pre>

<p>I create an observable sequence as following</p>

<pre><code>let seq = Observable.just(personArray)
</code></pre>

<p>now How can I filter this array by relevant person name ?</p>

<p>e.g. I want an observable sequence that contains person <code>name</code> that starts with 'M'</p>

<p>how to do this ??</p>
","5421493","","","","","2019-01-06 12:13:19","How to filter array of Observable element | RxSwift","<swift3><rx-swift>","3","1","1","","","CC BY-SA 3.0"
"42186652","1","","","2017-02-12 10:49:01","","2","1403","<p>I am using Firebase FirAuth API and before the API return result, Disposables.create() has been returned and it's no longer clickable (I know this might due to no observer.onCompleted after the API was called. Is there a way to wait for it/ listen to the result?</p>

<pre><code>public func login(_ email: String, _ password: String) -&gt; Observable&lt;APIResponseResult&gt; {

    let observable = Observable&lt;APIResponseResult&gt;.create { observer -&gt; Disposable in

        let completion : (FIRUser?, Error?) -&gt; Void =  {  (user, error) in

            if let error = error {
                UserSession.default.clearSession()
                observer.onError(APIResponseResult.Failure(error))
                observer.on(.completed)
                return
            }

            UserSession.default.user.value = user!
            observer.onNext(APIResponseResult.Success)
            observer.on(.completed)
            return
        }

        DispatchQueue.main.async {
            FIRAuth.auth()?.signIn(withEmail: email, password: password, completion: completion)
        }

        return Disposables.create()
    }

    return observable

}
</code></pre>
","1027396","","","user7574498","2017-02-16 13:05:14","2017-02-16 13:05:14","RxSwift callback return first before result","<ios><swift><firebase><firebase-authentication><rx-swift>","2","3","","","","CC BY-SA 3.0"
"42191460","1","","","2017-02-12 18:24:35","","0","872","<p>I'm using RxSwift to bind view models and views, and I have about 10 drivers that expose the properties in my view model:</p>

<pre><code>let title: Driver&lt;String&gt;
let description: Driver&lt;String&gt;
let price: Driver&lt;String&gt;
...
</code></pre>

<p>What is the best way to drive those observables from the incoming sequence of models? Is it best to observe the incoming for every driver? Is this an odd/in-efficient way of doing things?</p>

<pre><code>self.title = incoming.productObservable.map({ $0.title }).asDriver(onErrorJustReturn: """")
self.description = incoming.productObservable.map({ $0.description }).asDriver(onErrorJustReturn: """")
self.price = incoming.productObservable.map({ $0.price }).asDriver(onErrorJustReturn: """")
...
</code></pre>

<p>I can't think of a better way of doing it other than creating private variables, subscribing to the models observable, setting the variables on each next event, and then having to create another set of public Drivers/Observables from the variable, i.e.:</p>

<pre><code>let titleDriver: Driver&lt;String&gt;
private let title = Variable&lt;String&gt;("""")
...
titleDriver = title.asDriver()
</code></pre>

<p>But I hate the duplication and amount of code required for each property!</p>

<p>I want to ensure I don't expose the <code>Variable</code>s from outside the view model, as you don't want anyone playing with them!</p>
","2026361","","","","","2017-02-12 19:27:02","RxSwift + MVVM: Efficient way map incoming model to exposed Driver/Observable properties","<rx-swift><reactivex>","1","1","","","","CC BY-SA 3.0"
"42242607","1","42242939","","2017-02-15 07:00:55","","0","2644","<p>I have this RxSwift code in swift 3</p>

<pre><code>let bag:DisposeBag = DisposeBag()
var sig:Observable&lt;Int&gt;!
sig = Observable&lt;Int&gt;.interval(1.0, scheduler: MainScheduler.instance)

sig.subscribe(onNext: { (milsec) in
    print(""Mil: \(milsec)"")
}).addDisposableTo(bag)
</code></pre>

<p>i run this code when button tapped, but its not print anything on console.</p>
","7567090","","","","","2017-02-15 07:34:24","Rx Swift simple timer not working","<timer><swift3><observable><rx-swift>","1","0","","","","CC BY-SA 3.0"
"42267827","1","","","2017-02-16 07:46:33","","3","483","<p>I was hunting a weird edge case where a list of files in a directory didn't show results for 0...2 files but worked fine for 3...n files. </p>

<p>It turned out that the original observable sequence worked just fine. But I used a <code>PublishSubject</code> in one subscriber to relay the effect of the change. All of this reportedly happened on the main queue, but it seems the <code>PublishSubject</code> got fed values before it had a subscriber. (Since there's no replay, the subscriber wouldn't know.) </p>

<p>So the set-up of all components (origin -- relaying subscriber -- consuming subscriber) seems to have introduced <em>time</em> as a problem.</p>

<p>Weird observations:</p>

<ul>
<li>If I make the original <code>Observable</code> a <code>Driver</code>, things work fine. </li>
<li>If I insert <code>.observeOn(MainScheduler.instance)</code> somewhere in the original chain (before the relaying subscriber), things work fine. Even though I can see through the use of breakpoints in map operations that the mapping happens on <code>com.apple.main-queue (serial)</code> already.</li>
<li>If I use <code>.subscribeOn(MainScheduler.instance)</code> at the origin or in the subscriber's code, I still get the problem. (Probably because at the origin it only affects the relaying subscriber, and later it's too late.)</li>
</ul>

<p>Now I don't understand how to handle issues like these defensively.</p>

<p>It seems the <code>PublishSubject</code> might not be a good fit for the situation. But why does observing-on the main queue improve the situation?</p>

<p><strong>When should you (defensively) specify observable sequences to run on the main queue <em>upon creation/production</em>?</strong> (Again, this might be a pragmatic fix, but it only accidentally seems to solve the problem.)</p>

<p>Or, put differently, <strong>when should you assume things don't happen in time in the consumer's code</strong>, i.e. when the subscription is set up?</p>

<p>There was no way for me to tell that relaying events from input sequence to <code>PublishSubject</code> caused trouble. It's not perceivable. Leaves me puzzled how to avoid bugs like this.</p>
","1460929","","1460929","","2017-02-16 08:25:42","2017-02-16 08:25:42","How to defensively create Rx Observables and avoid race conditions?","<swift><concurrency><rx-swift><defensive-programming>","0","2","1","","","CC BY-SA 3.0"
"42271750","1","49315858","","2017-02-16 10:49:56","","1","688","<p>I'm trying to implement an alamofire call with max retries. Code is below:</p>

<pre><code>RxAlamofire.request(.post, URL, parameters: parameters, encoding: JSONEncoding.default)
    .observeOn(MainScheduler.instance)
    .retryWhen { (errors: Observable&lt;Error&gt;) in
        return errors.flatMapWithIndex { (e, a) -&gt; Observable&lt;Int64&gt; in
            if a &gt;= self.RETRY_COUNT - 1 {
                return Observable.error(e)
            }
            print(""Error: delay server call retry by \(a+1) second(s)"")
            return Observable&lt;Int64&gt;.timer(RxTimeInterval(a+1), scheduler: MainScheduler.instance)
        }
    }
    .subscribe(
        onNext: {
            (result) in

            print(""I get here when retrying..."")
        },
        onError: { (error) in
            print(error)
        }
    )
    .addDisposableTo(self.disposeBag)
</code></pre>

<p>Unfortunately, on retrying, I get into the onNext block in subscribe - I don't want to get there until I have a result. (The onError gives an error after max retries is exceeded as expected). Please can someone help?</p>
","2138979","","2138979","","2017-08-09 15:27:07","2018-03-16 08:11:36","RxAlamofire: retryWhen drops into subscribe block","<ios><swift><rx-swift><rxalamofire>","1","0","","","","CC BY-SA 3.0"
"42275245","1","42325426","","2017-02-16 13:23:55","","13","1921","<p>I have created below function with chaining of multiple observables however whatever I do it does not seem to call <code>completed</code> ? it only return the following:</p>

<pre><code>(facebookSignInAndFetchData()) -&gt; subscribed
(facebookSignInAndFetchData()) -&gt; Event next(())
</code></pre>

<p>even though when I <code>debug</code> the observables individually they all return <code>completed</code></p>

<p>here is my chaining function</p>

<pre><code>func facebookSignInAndFetchData() {


    observerFacebook.flatMap { (provider: FacebookProvider) in
        return provider.login()
        }.flatMap { token in
            return self.loginViewModel.rx_authenticate(token: token)
        }.flatMap {
            return self.loginViewModel.fetchProfileData()
        }.debug().subscribe(onError: { error in

            //Guard unknown ErrorType
            guard let err = error as? AuthError else {
                //Unknown error message
                self.alertHelper.presentAlert(L10n.unknown)
                return
            }

            //error message handling
            switch err {
            case .notLoggedIn:
                print(""not logged in"")
                break
            default:
                self.alertHelper.presentAlert(err.description)
            }

        }, onCompleted: {
            self.goToInitialController()
        }).addDisposableTo(self.disposeBag)

}
</code></pre>

<p><strong>rx_authenticate</strong></p>

<pre><code>func rx_authenticate(token: String) -&gt; Observable&lt;Void&gt; {


    return Observable.create({ observer in
        let credentials = SyncCredentials.facebook(token: token)
        SyncUser.logIn(with: credentials, server: URL(string: Globals.serverURL)!, onCompletion: { user, error in

            //Error while authenticating
            guard error == nil else {
                print(""error while authenticating: \(error!)"")
                observer.onError(AuthError.unknown)
                return
            }

            //Error while parsing user
            guard let responseUser = user else {
                print(""error while authenticating: \(error!)"")
                observer.onError(AuthError.unknown)
                return
            }

            //Authenticated
            setDefaultRealmConfiguration(with: responseUser)

            //next
            observer.onNext()

            //completed
            observer.onCompleted()


        })

        return Disposables.create()
    })
}
</code></pre>

<p><strong>fetchProfileData</strong></p>

<pre><code>func fetchProfileData() -&gt; Observable&lt;Void&gt; {

     return Observable.create({ observer in

        //Fetch facebookData
        let params = [""fields"" : ""name, picture.width(480)""]
        let graphRequest = GraphRequest(graphPath: ""me"", parameters: params)
        graphRequest.start {
            (urlResponse, requestResult) in
            switch requestResult {
            case .failed(_):
                //Network error
                observer.onError(AuthError.noConnection)
                break
            case .success(let graphResponse):

                if let responseDictionary = graphResponse.dictionaryValue {

                    guard let identity = SyncUser.current?.identity else {
                        //User not logged in
                        observer.onError(AuthError.noUserIdentity)
                        return
                    }

                    //Name
                    let name = responseDictionary[""name""] as! String

                    //Image dictionary
                    let pictureDic = responseDictionary[""picture""] as! [String: Any]
                    let dataDic = pictureDic[""data""] as! [String: Any]
                    let imageHeight = dataDic[""height""] as! Int
                    let imageWidth = dataDic[""width""] as! Int
                    let url = dataDic[""url""] as! String

                    //Create Person object
                    let loggedUser = Person()
                    loggedUser.id = identity
                    loggedUser.name = name

                    //Create photo object
                    let photo = Photo()
                    photo.height = imageHeight
                    photo.width = imageWidth
                    photo.url = url

                    //Append photo object to person object
                    loggedUser.profileImage = photo

                    //Save userData
                    let realm = try! Realm()
                    try! realm.write {
                        realm.add(loggedUser, update: true)
                    }

                    //next
                    observer.onNext()

                    //completed
                    observer.onCompleted()

                } else {
                    //Could not retrieve responseData
                    observer.onError(AuthError.noResponse)
                }
            }
        }



        return Disposables.create()
    })


}
</code></pre>

<p><strong>observerFacebook</strong></p>

<pre><code>//FacebookProvider
private lazy var observerFacebook: Observable&lt;FacebookProvider&gt;! = {
    self.facebookButton.rx.tap.map {

        return FacebookProvider(parentController: self)
    }
}()
</code></pre>
","4034437","","4034437","","2017-02-16 14:03:27","2017-02-19 09:07:44","flatMap Not returning onCompleted","<swift><rx-swift><rx-cocoa>","1","8","1","","","CC BY-SA 3.0"
"42296644","1","42325477","","2017-02-17 11:21:01","","3","6510","<p>I have a dependency problem with my <code>UIViewController</code> and my view model.
Basically I want to listen the <code>viewDidLoad</code> event inside my view model.
At the moment I have a <code>Class A</code> which instantiates view model and <code>UIViewController</code> with parameter the viewModel, so:</p>

<pre><code>let viewModel = ViewModel()
let viewController = UIViewController(viewModel)
</code></pre>

<p>and I've created a RxCocoa extension for the <code>viewDidLoad</code>:</p>

<pre><code>var viewDidLoad: Observable&lt;Void&gt; {
    return self.sentMessage(#selector(Base.viewDidLoad)).map { _ in Void() }
}
</code></pre>

<p>now I'm stuck to bind this <code>rx.viewDidLoad</code> to an observable inside my view model. I am able to do it with <code>Subjects</code> but I want a reactive approach using just <code>Observable</code>.
I know that I could inject <code>rx.viewDidLoad</code> as constructor parameter of the view model but in this way I'd break my architecture and I don't want to allow the <code>UIViewController</code> to instantiate the view model internally but I want to keep it as a injected dependency.</p>

<p>Any suggestions?
Thanks</p>

<p><strong>Solution</strong></p>

<p>Thank to @tomahh I've used this solution:</p>

<p>My view controller:</p>

<pre><code>override func configure(viewModel: ViewModel) {
    viewModel.bindViewDidLoad(rx.viewDidLoad)
}
</code></pre>

<p>My view model:</p>

<pre><code>func bindViewDidLoad(_ viewControllerDidLoad: Observable&lt;Void&gt;) {
    //Create observers which depend on viewControllerDidLoad
}
</code></pre>
","5109911","","5109911","","2017-02-19 14:48:25","2020-11-25 21:59:42","RxSwift: Observe viewDidLoad from view model without Subjects","<swift><reactive-programming><rx-swift><rx-cocoa>","3","0","2","","","CC BY-SA 3.0"
"42305155","1","","","2017-02-17 18:36:07","","6","2909","<p>Is there a way to bind a <code>UIPickerView</code> with an Observable?</p>

<p>For example for a <code>UITableView</code> I would do:</p>

<pre><code>myObservableArray.bindTo(tableView.rx.items(cellIdentifier: ""Identifier"", cellType: MyCustomTableViewCell.self)) { (row, title, cell) in
        cell.textLabel?.text = title
    }
    .disposed(by: disposeBag)
</code></pre>

<p>Is there something similar for <code>UIPickerView</code> ?</p>
","4772647","","","","","2020-03-09 00:30:29","RxSwift and UIPickerView","<ios><swift><uipickerview><rx-swift><rx-cocoa>","2","2","2","","","CC BY-SA 3.0"
"42314067","1","","","2017-02-18 10:43:10","","3","4341","<p>I'd like to observe the height of the iOS keyboard. How do I do that with RxSwift?</p>
","219947","","","","","2018-12-27 23:28:08","How to create an RxSwift Observable that emits the height of the keyboard?","<ios><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"42314909","1","","","2017-02-18 12:05:45","","0","948","<p>I have the following Realm Object:</p>

<pre><code>class GeolocationObject: Object {

    dynamic var id: String = UUID().uuidString

    dynamic var latitude: Double = 0
    dynamic var longitude: Double = 0

    let addresses = LinkingObjects.init(fromType: AddressObject.self, property: ""geolocation"")

    override static func primaryKey() -&gt; String? {
        return ""id""
    }

}
</code></pre>

<p>I also have the linking Address Object (for simplicity reasons I have only a road property):</p>

<pre><code>class AddressObject: Object {

    dynamic public var id: String = UUID().uuidString
    dynamic var road: String = """"
    dynamic var geolocation: GeolocationObject?

    override static func primaryKey() -&gt; String? {
        return ""id""
    }

}
</code></pre>

<p>As you can see I have a To-One Relationship with the <code>GeolocationObject</code> and for the needs of my application there is a chance that on the same Geolocation, I may have many <code>AddressObjects</code>. So there is a <code>LinkingObjects</code> property in my <code>GeolocationObject</code>.</p>

<p>I have created a reactive abstraction layer with RxSwift and RxRealm (<code>RealmProvider</code> just provides a method for easier Realm write transactions):</p>

<pre><code>class GeolocationViewModel {

    let disposeBag: DisposeBag
    let geolocationObject: GeolocationObject
    let id: String

    var latitude: Variable&lt;Double&gt;
    var longitude: Variable&lt;Double&gt;

    let addresses: Observable&lt;[AddressViewModel]&gt;

    init(geolocationObject: GeolocationObject) {

        self.disposeBag = DisposeBag()
        self.geolocationObject = geolocationObject
        self.id = self.geolocationObject.id

        self.latitude = Variable(self.geolocationObject.latitude)
        self.longitude = Variable(self.geolocationObject.longitude)

        self.addresses =
            Observable.array(from: self.geolocationObject.addresses)
                .map({ $0.flatMap({ AddressViewModel.init(addressObject: $0) }) })    

        self.latitude.asObservable()
            .subscribe(onNext: { [unowned self] (latitude) in
                RealmProvider.commitWrite {
                    self.geolocationObject.latitude = latitude
                }
            })
            .disposed(by: disposeBag)

        self.longitude.asObservable()
            .subscribe(onNext: { [unowned self] (longitude) in
                RealmProvider.commitWrite {
                    self.geolocationObject.longitude = longitude
                }
            })
            .disposed(by: disposeBag)

    }

}
</code></pre>

<p>and</p>

<pre><code>class AddressViewModel {

    let disposeBag: DisposeBag
    let addressObject: AddressObject
    let id: String

    var road: Variable&lt;String&gt;

    var geolocation: Variable&lt;GeolocationViewModel?&gt;

    init(addressObject: AddressObject) {

        self.disposeBag = DisposeBag()
        self.addressObject = addressObject
        self.id = self.addressObject.id

        self.road = Variable(self.addressObject.road)

        if let geolocationObject = self.addressObject.geolocation {
            self.geolocation = Variable(GeolocationViewModel.init(geolocationObject: geolocationObject))
        } else {
            self.geolocation = Variable(nil)
        }

        self.road.asObservable()
            .debug()
            .subscribe(onNext: { [unowned self] (road) in
                RealmProvider.commitWrite {
                    self.addressObject.road = road
                }
            })
            .disposed(by: disposeBag)

        self.geolocation.asObservable()
            .subscribe(onNext: { [unowned self] (geolocationViewModel) in
                RealmProvider.commitWrite {
                    self.addressObject.geolocation = geolocationViewModel?.geolocationObject
                }
            })
            .disposed(by: disposeBag)

}
</code></pre>

<p>As you can see I have passed the <code>LinkingObjects</code> property as an <code>Observable</code>, so in case something changes, it will be notified.</p>

<p>To cut a long story short, I create an address with a geolocation object.
All is fine till now. I grab the <code>AddressViewType</code>, and I change the road (which is a <code>Variable</code>). If I have a subscription on the <code>AddressViewType</code> array through the <code>GeolocationViewType</code>, it is correctly notified, but it fires all the time.</p>

<p>For example:</p>

<pre><code>let geolocationViewModel = GeolocationViewModel(geolocationObject: GeolocationViewModel)
let addressViewModel = AddressViewModel(addressObject: AddressObject())
addressViewModel.road.value = test1
addressViewModel.geolocation.value = geolocationViewModel

geolocationViewModel.addresses.subscribe(onNext: { addressArray in

print(addressArray[0].road) 

})
.disposed(by: disposeBag)
</code></pre>

<p>If I try to change the road on the addressViewModel like this:</p>

<pre><code>addressViewModel.road.value = ""Test2""
</code></pre>

<p>it correctly notifies the print statement and it prints. BUT it fires all the time with the new value! It doesn't send the print only once.</p>

<p>I found that it stops if the <code>Observable</code> for the addresses on the <code>GeolocationObject</code> is like this:</p>

<pre><code>self.addresses =
                Observable.array(from: self.geolocationObject.addresses)
                    .map({ $0.flatMap({ AddressViewModel.init(addressObject: $0) }) })
                    .replay(1)
</code></pre>

<p>Later on I also added <code>.share()</code>
Why does it fire all the time if I don't put <code>.replay(1)</code> ?
Shouldn't it just send it once and stop?</p>
","4772647","","4772647","","2017-02-18 20:40:17","2017-02-18 20:40:17","Observable, with Rx-Realm and Rx-Swift, doesn't stop firing [unless I enter .replay(n)]","<ios><swift><realm><rx-swift>","0","4","","","","CC BY-SA 3.0"
"42318755","1","42326034","","2017-02-18 18:01:25","","5","6551","<p>I have three buttons and I want them to be selected only one at a time:</p>

<p><a href=""https://i.stack.imgur.com/PZLVR.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/PZLVR.png"" alt=""enter image description here""></a></p>

<p>and:</p>

<p><a href=""https://i.stack.imgur.com/5HrSa.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/5HrSa.png"" alt=""enter image description here""></a></p>

<p>etc...</p>

<p>My approach is this:</p>

<pre><code>class MyController: UIViewController {

    @IBOutlet var buttonOne: UIButton!
    @IBOutlet var buttonTwo: UIButton!
    @IBOutlet var buttonThree: UIButton!

    var buttonOneIsSelected = Variable(true)
    var buttonTwoIsSelected = Variable(false)
    var buttonThreeIsSelected = Variable(false)


    override func viewDidLoad() {
        super.viewDidLoad()

        buttonOne.isSelected = true

        buttonOneIsSelected.asDriver()
            .drive(buttonOne.rx.isSelected)
            .disposed(by: disposeBag)
        buttonTwoIsSelected.asDriver()
            .drive(buttonTwo.rx.isSelected)
            .disposed(by: disposeBag)
        buttonThreeIsSelected.asDriver()
            .drive(buttonThree.rx.isSelected)
            .disposed(by: disposeBag)

        buttonOne.rx.tap.asObservable().map { (_) -&gt; Bool in
            return !self.buttonOne.isSelected
        }
        .do(onNext: { (isSelected) in
            self.buttonTwoIsSelected.value = !isSelected
            self.buttonThreeIsSelected.value = !isSelected
        })
        .bindTo(buttonOne.rx.isSelected)
        .disposed(by: disposeBag)

        buttonTwo.rx.tap.asObservable().map { (_) -&gt; Bool in
            return !self.buttonTwo.isSelected
            }
            .do(onNext: { (isSelected) in
                self.buttonOneIsSelected.value = !isSelected
                self.buttonThreeIsSelected.value = !isSelected
            })
            .bindTo(buttonTwo.rx.isSelected)
            .disposed(by: disposeBag)

        buttonThree.rx.tap.asObservable().map { (_) -&gt; Bool in
            return !self.buttonThree.isSelected
            }
            .do(onNext: { (isSelected) in
                self.buttonOneIsSelected.value = !isSelected
                self.buttonTwoIsSelected.value = !isSelected
            })
            .bindTo(buttonThree.rx.isSelected)
            .disposed(by: disposeBag)
}
</code></pre>

<p>Is there a better approach? It works, but is there a better 'reactive' way to do it by using RxSwift?</p>
","4772647","","","","","2017-02-19 10:16:23","RxSwift and isSelected property on UIButton","<ios><swift><rx-swift><rx-cocoa>","1","0","6","","","CC BY-SA 3.0"
"42331935","1","42334542","","2017-02-19 19:38:54","","2","2451","<p>I don't know how transfer the data between ModelView and ViewController. In</p>

<p>SelectModelViewController</p>

<pre><code>class SelectModelViewController: UIViewController {

@IBOutlet weak var tableView: UITableView!
@IBOutlet weak var errorLabel: UILabel!
@IBOutlet weak var activityIndicator: UIActivityIndicatorView!

var markViewModel : MarkViewModel?
let markService = MarkService()
let disposeBag = DisposeBag()



override func viewDidLoad() {
    super.viewDidLoad()
    markViewModel = MarkViewModel(markService: markService)
    markViewModel?.data.asObservable()
        .bindTo(tableView.rx.items(cellIdentifier: ""Cell"", cellType: UITableViewCell.self)) { (_, element, cell) in
            cell.textLabel?.text = element
        }
        .addDisposableTo(disposeBag)
}
}
</code></pre>

<p>MarkViewModel has an error. I'am doing something wrong </p>

<p>struct MarkViewModel {</p>

<pre><code>let markService: MarkService
var data: Driver&lt;[Mark]&gt;

init(markService: MarkService) {
    self.markService = markService

    data = markService.get()
        .map { result in
            switch result {
            case.success(let marks):
                return marks.map { mark in
                    return mark
                }
            case .error(let error):
                print(error)
            }

        }.asDriver(onErrorJustReturn: .error(.other))
}}
</code></pre>

<p>MarkService</p>

<p>struct MarkService {</p>

<pre><code>func get() -&gt; Observable&lt;Result&lt;[Mark]&gt;&gt; {
    return URLSession.shared.rx.json(url: URL(string: API.BaseURL)!)
        .retry(3)
        .map {
            var marks = [Mark]()
            guard let json = $0 as? [String: Any],
                let items = json[""RBMarks""] as? [[String : Any]] else {
                    return .error(.badJSON)
            }
            for item in items {
                if let mark = Mark(json: item) {
                    marks.append(mark)
                } else {
                    return .error(.badJSON)
                }
            }
            return .success(marks)
        }
        .catchErrorJustReturn(.error(.noInternet))
}}
</code></pre>
","6905589","","6905589","","2017-02-20 21:53:53","2017-02-20 21:53:53","Correct usage of RxSwift with TableView","<mvvm><swift3><tableview><rx-swift>","1","2","2","","","CC BY-SA 3.0"
"42346622","1","","","2017-02-20 14:02:01","","0","435","<p>I studying rxSwift, and I want to do service for the interaction of c longpolling server to this service imitating a permanent connection. I wrote it, but it seems to me, is not that the decision could have been done better? Is it possible to somehow repeat the Observable, regardless of the error, and depending on longpoll server response.</p>

<p>Can anyone can share the solution? Or help with advice? How it is better to organize? I would like to see a better solution, since only began studying rxswift</p>

<pre><code>class LongPollingService {

    public var messageReciver: PublishSubject&lt;EventProtocol&gt; = PublishSubject&lt;EventProtocol&gt;()

    private let transport = DefaultTransport()

    private let disposeBag = DisposeBag()

    private var currentRequestInfo = Variable&lt;LongpollingServerInfo?&gt;(nil)

    private var currentRequestDisposable: Disposable?

    private var currentLongpollingConnection: Disposable? // Subsribee for request server info

    private var eventListener : Disposable?

    private var currentReqursiveConnection: Disposable? // Subscriber for event listener from longpoll server

    func startObservableEvents() {
        getServerConnection()
        subscribeServerInfo()
        //testing listen events
        eventListener = messageReciver.showMessagesInDebugMode().subscribe()
        eventListener?.addDisposableTo(disposeBag)
    }

    func disconnect() {
        currentRequestDisposable?.dispose()
        currentLongpollingConnection?.dispose()
        currentReqursiveConnection?.dispose()
    }

    private func subscribeServerInfo() {
        currentLongpollingConnection = currentRequestInfo
            .asObservable()
            .filter({$0 != nil})
            .subscribe(onNext: { [weak self] (info) in
                guard let sSelf = self else { return }
                sSelf.subscribeToEvents(timeStamp: info!.ts)
            })
        currentLongpollingConnection?.addDisposableTo(disposeBag)
    }

    private func subscribeToEvents(timeStamp: TimeInterval) {
        if let serverInfo = currentRequestInfo.value {
            currentReqursiveConnection?.dispose()
            currentReqursiveConnection = getEventsFromLongpollServer(serverInfo: serverInfo, with: timeStamp)
                .flatMap(parseUpdates)
                .flatMap(reciveEvents)
                .showErrorsSwiftMessagesInDebugMode()
                .subscribe(onNext: { [weak self] updates in
                    guard let sSelf = self else { return }
                    sSelf.subscribeToEvents(timeStamp: updates)
                },
                onError: { [weak self] error in
                    guard let sSelf = self else { return }
                        if let error = error as? LongPollError {
                            switch error {
                            case .olderHistory(let ts): sSelf.subscribeToEvents(timeStamp: ts)
                            default: sSelf.getServerConnection()
                            }
                        }
                })
            currentReqursiveConnection?.addDisposableTo(disposeBag)
        }
    }

    private func getServerConnection() {
        //get longpolling server info for connection.
        currentRequestDisposable = getLongpollServerInfo()
            .subscribe(onNext: {[weak self] info in
                guard let sSelf = self else { return }
                sSelf.currentRequestInfo.value = info
            })
        currentRequestDisposable?.addDisposableTo(disposeBag)
    }

    private func parseUpdates(json: Any) throws -&gt; Observable&lt;LongPollingUpdates&gt; {
        let response = try Mapper&lt;LongPollingUpdates&gt;().map(JSONObject: json)
        return .just(response)
    }

    private func reciveEvents(updates:LongPollingUpdates) throws -&gt; Observable&lt;TimeInterval&gt; {
        if let errors = updates.failed {
            throw parseErrors(errors: errors)
        }
        if let events = updates.updates {
            parseUpdates(updates: events)
        }
        return Observable.just(updates.timeStamp!)
    }

    private func parseUpdates(updates: [[Any]]) {
        updates.forEach { (array) in
            let firstElementInUpdate = array.first
            if let update = firstElementInUpdate as? Int {
                switch update {
                case 1: break
                case 2: break
                case 3: break
                case 4: messageReciver.onNext(NewMessage(array: array))
                default: break
                }
            }
        }
    }

    private func parseErrors(errors: [String: Any]) -&gt; LongPollError {
        if let error = errors[""failed""] as? Int {
            switch error {
            case 1:
                guard let ts = errors[""ts""] as? TimeInterval else { return .unkownError }
                return .olderHistory(ts: ts)
            case 2: return .needNewkey
            case 3: return .needCaseAndTs
            case 4: return .unkownVersion
            default:
                return .unkownError
            }
        }
        return .unkownError
    }

    private func getEventsFromLongpollServer(serverInfo: LongpollingServerInfo, with ts: TimeInterval) -&gt; Observable&lt;Any&gt; {
        let url = buildLongPollingServerRoute(from: serverInfo, with: ts)
        let request = buldLongPollRequst(route: url)
        let requestConvert = try? URLEncoding.default.encode(request!, with: nil)
        return transport.makeRequest(request: requestConvert!)
    }

    private func getEventsFromLongpollServer(serverInfo: LongpollingServerInfo) -&gt; Observable&lt;Any&gt; {
        let url = buildLongPollingServerRoute(from: serverInfo)
        let request = buldLongPollRequst(route: url)
        let requestConvert = try? URLEncoding.default.encode(request!, with: nil)
        return transport.makeRequest(request: requestConvert!)
    }

    private func getLongpollServerInfo() -&gt; Observable&lt;LongpollingServerInfo&gt; {
        let request = MessageRouter.getLongpollServer(useSsl: false, needPts: false)
        return transport.makeModel(request: request)
    }

}
</code></pre>
","4784553","","7045114","","2017-02-21 04:36:06","2017-02-22 02:28:38","LongPolling With rxSwift","<ios><swift><long-polling><rx-swift>","1","0","","","","CC BY-SA 3.0"
"42347194","1","","","2017-02-20 14:30:40","","0","228","<p>I'm trying to make an MVVM integration on a <code>UITableViewController</code>, however I keep getting:</p>

<p><code>fatal error: unexpectedly found nil while unwrapping an Optional value</code> on <code>super.init(style: style, reuseIdentifier: reuseIdentifier)</code>. </p>

<p>How come? I guess it has something to do with:</p>

<p><code>cell.menuItemViewModel = SideMenuViewModel(menuItem: item)</code> </p>

<p>since there is no error if I remove this line?</p>

<p><strong>setting datasource in sideMenuController</strong></p>

<pre><code>func setupDatasource() {

    let sections = [
        SectionModel(model: ""menu"", items: menuItems)
    ]

    dataSource.configureCell = { (ds, tv, ip, item) in
        let cell: MenuCell = tv.dequeueReusableCell(withIdentifier: self.reuseIdentifier, for: ip) as! MenuCell
        cell.menuItemViewModel = SideMenuViewModel(menuItem: item)


        return cell
    }


    Observable.just(sections)
        .bindTo(tableView.rx.items(dataSource: dataSource))
        .addDisposableTo(disposeBag)
}
</code></pre>

<p><strong>MenuItem model</strong></p>

<pre><code>struct MenuItem {

    var title: String
    var image: Asset
    var imageSelected: Asset
    var controller: UINavigationController

    init(title: String, image: Asset, imageSelected: Asset, controller: UINavigationController) {
        self.title = title
        self.image = image
        self.imageSelected = imageSelected
        self.controller = controller
    }


}
</code></pre>

<p><strong>ViewModel</strong></p>

<pre><code>struct SideMenuViewModel {

    let title: String
    let image: UIImage
    let imageSelected: UIImage


    init(menuItem: MenuItem) {
        self.title = menuItem.title
        self.image = UIImage(asset: menuItem.image)
        self.imageSelected = UIImage(asset: menuItem.imageSelected)
    }

}
</code></pre>

<p><strong>MenuCell</strong></p>

<pre><code>class MenuCell: UITableViewCell {

    var titleLabel: UILabel!
    var iconImageView: UIImageView!

    var menuItemViewModel: SideMenuViewModel! {
        didSet {
            //Set title
            self.titleLabel.text = menuItemViewModel.title

            //Set image
            self.iconImageView.image = menuItemViewModel.image

        }
    }


    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)


        setupUI()
        setupConstraints()

    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
    }

    func setupUI() {

        //Add titleLabel
        self.titleLabel = UILabel()
        self.addSubview(self.titleLabel)

        //Add iconImageView
        self.iconImageView = UIImageView()
        self.addSubview(self.iconImageView)

        //Customize titleLabel
        self.titleLabel.font = FontFamily.Avenir.Regular.font(size: 26)
        self.titleLabel.textColor = UIColor.white.withAlphaComponent(0.6)

        //Customize iconImageView
        self.iconImageView.contentMode = .scaleAspectFit

        //Customize cell
        self.selectionStyle = .none
        self.backgroundColor = UIColor.clear
    }

    func setupConstraints() {

        //titleLabel constraints
        self.titleLabel.snp.makeConstraints({ make in
            make.left.equalTo(self.iconImageView.snp.right).offset(-20)
            make.centerY.equalTo(self)
            make.height.equalTo(50)
            make.width.equalTo(100)
        })

        //iconImageView constraints
        self.iconImageView.snp.makeConstraints({ make in
            make.left.equalTo(80)
            make.centerY.equalTo(self)
            make.height.equalTo(50)
            make.width.equalTo(50)
            make.right.equalTo(self.titleLabel.snp.left).offset(20)
        })

    }


}
</code></pre>
","4034437","","","user5890979","2017-02-20 18:46:32","2017-02-20 18:46:32","MVVM UITableViewCell return nil","<ios><swift><mvvm><rx-swift>","1","3","","","","CC BY-SA 3.0"
"42353074","1","","","2017-02-20 19:48:45","","1","1375","<p>Is there a way with RxSwift to subscribe to a method which returns a completion block?</p>

<p>Example, let's have this object:</p>

<pre><code>struct Service {

    private var otherService = ...
    private var initSucceeded = PublishSubject&lt;Bool&gt;()

    var initSucceededObservale: Observable&lt;Bool&gt; {
        return initSucceeded.asObservable()
    }

    func init() {
        otherService.init {(success) in
            self.initSucceeded.onNext( success)
        }
    }
}
</code></pre>

<p>And in a different place have a way to be notified when the service has been initialised:</p>

<pre><code>service.initSucceededObservable.subscribe(onNext: {
    [unowned self] (value) in
    ...
}).addDisposableTo(disposeBag)

service.init()
</code></pre>

<p>Would be there a simpler solution?</p>
","2515181","","","","","2017-02-20 21:47:14","RxSwift - subscribe to a method","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"42360533","1","42379364","","2017-02-21 06:51:28","","1","928","<p>I want to connect multiple observables to a common Subject. The observables may be disposed and new observables will be created and be subscribed by the same Subject.</p>

<p>I create and remove several custom UIViews that each contain Observers that emit to the same Subject. </p>

<p>For example:  in myView1, I have:</p>

<pre><code>myButton1.rx.tap
   .subscribe(sameViewModel.subject)
   .disposed(by: disposeBag1)
</code></pre>

<p>and in myView2, I have:</p>

<pre><code>myButton2.rx.tap
    .subscribe(sameViewModel.subject)
    .disposed(by: disposeBag2)
</code></pre>

<p>In this simple example, sameViewModel.subject is the same PublishSubject in a instance (sameViewModel) that does not de-initialize when myView1 and myView2 are removed.</p>

<p>When myView1 is removed, its disposeBag1 is disposed and myButton1.rx.tap emits its onComplete and onDispose notifications. This causes sameViewModel.subject to also complete and dispose. The subject no longer responds to further events from myButton2.rx.tap or other observables that I create later.</p>

<p><strong>How do I create/configure a observer-subject relationship where the subject stays active while its observers are disposed?</strong></p>

<p>Can a subject be configured to ignore the complete/dispose events?
Do I need to rewrite the .subscribe to individually handle onNext, onComplete, etc.? Is there some pattern to follow?</p>
","7596803","","","","","2017-02-21 22:51:59","Keep a subject ""listening"" after some of it's observers are complete/disposed","<ios><reactive-programming><rx-swift>","1","0","2","","","CC BY-SA 3.0"
"42380367","1","42382352","","2017-02-22 00:09:27","","0","433","<p>So I'd like to do something really simple with RxSwift as a proof of concept:</p>

<ol>
<li>Crate an observable array;</li>
<li>When button is clicked add an integer to the array;</li>
<li>When the array has > 10 items empty the array.</li>
</ol>

<p>This is mind numbingly impossible in RxSwift if you're a noob.</p>

<p>Thx.</p>
","1131595","","","","","2017-02-22 03:48:25","How do you connect a button to an array in RxSwift?","<rx-swift>","1","0","","","","CC BY-SA 3.0"
"42386960","1","","","2017-02-22 09:04:09","","0","714","<p>I'm working on a alertmessage extension for <code>UIViewcontroller</code> using <code>RXSwift</code>. </p>

<pre><code>    // UIViewController+Alertmessage
        public func observeAlertMessageSignal(alert: Observable&lt;String&gt;) {
            let disposeBag = DisposeBag()

            alert.observeOn(MainScheduler.instance)
                .subscribe(onNext:  { message in
                    self.alertCustomTransitionDelegate = CustomTransitioningDelegate()

                    let viewModel = AlertViewModel(message: message)

                    let storyboard = UIStoryboard(name: ""Alert"", bundle: nil)
                    let viewController = storyboard.instantiateInitialViewController() as! AlertViewController
                    viewController.viewModel = viewModel
                    viewController.delegate = self
                    viewController.modalPresentationStyle = .custom
                    viewController.transitioningDelegate = self.alertCustomTransitionDelegate

                    self.present(viewController, animated: true, completion: nil)

            }).addDisposableTo(disposeBag)
        }

    // ViewModel

    --&gt; Declaration of alertObservable in viewModel
        var alertObservable = PublishSubject&lt;String&gt;()

    --&gt; usage of observable:
    transportResponse = active.asObservable()
                .filter { $0 }
                .flatMap {  _  in
                    return webservice.loadTransport()
                }
                .catchError { [weak self] e in
                    if let moyaError = e as? MoyaError {
                        if case .underlying(let error) = moyaError {
                            let formattedError = error as NSError
                            let message = NSError.localizedDescription(error: formattedError)
                            self?.alertObservable.onNext(message)
                        }
                    }
                    self?.isLoadingObservable.onNext(false)
                    throw e
                }
                .map { response in
                    return [TransportData(items: response)]
            }

//ViewController:
--&gt; code inside viewDidLoad
        self.observeAlertMessageSignal(alert: viewModel.alertObservable)
</code></pre>

<p>The <code>observeAlertMessageSignal</code> function is called but my AlertViewController is not presented. Any help on this one?</p>

<p>Thanks !</p>
","965273","","","","","2017-02-22 09:37:07","UIViewController extension for alert message using RXSwift","<ios><swift><uiviewcontroller><swift3><rx-swift>","1","0","","","","CC BY-SA 3.0"
"42426869","1","","","2017-02-23 21:51:31","","7","9784","<p>I have a quick question:</p>

<ul>
<li>I have a network request that returns <code>Observable&lt;Result&lt;String, RequestError&gt;&gt;</code>, let’s call it <code>requestToken</code></li>
<li>if this request succeeds, I want to use the <code>String</code> (token) to do another request that returns <code>Observable&lt;Result&lt;NSDictionary, RequestError&gt;&gt;</code>, let’s call it <code>requestData</code></li>
<li>when that second request comes back, I wanna merge the token into its dictionary</li>
<li>in the end I wanna map from <code>Observable&lt;Result&lt;String, RequestError&gt;&gt;</code> to <code>Observable&lt;Result&lt;NSDictionary, RequestError&gt;&gt;</code></li>
</ul>

<p>How can I achieve that without multiple nested levels in my code?</p>

<p>This is what I have today:</p>

<pre><code>requestToken()
    .flatMap({ result -&gt; Observable&lt;Result&lt;NSDictionary, RequestError&gt;&gt; in
        switch result {
        case .success(let token):
            return requestData(token: token).map({ $0.map({ $0 + [""token"": token] }) })
        case .failure(let error):
            return Observable.of(.failure(error))
        }
    })
</code></pre>
","1116465","","","","","2017-05-31 02:20:33","How to map RxSwift Observable and Result","<ios><swift><rx-swift><reactivex>","2","2","1","","","CC BY-SA 3.0"
"42433862","1","","","2017-02-24 08:24:09","","1","458","<p>Let's say I have an button and every time that button is tapped I would like to perform a network request and bind the results to a view on the main scheduler. I also need to deal with the chance that this network request might fail. Here was my original idea:</p>

<pre><code>button.rx.tap.asObservable()
  .flatMap(networkRequest)
  .asDriver(onErrorRecover: handleError)
  .drive(uiComponent)
  .disposed(by: disposeBag)
</code></pre>

<p>What I want to happen is for a possible error to be handled by <code>handleError</code> and then make the request again when the button is tapped again. This does not work because in the event of an error, I am now subscribed to the <code>Driver</code> returned by <code>handleError</code>. The only other idea I have is to keep the signal an <code>Observable</code> and handle the error case and next case separately in the <code>subscribe</code>. This would also necessitate a <code>observeOn</code>. I was hoping for something a bit more elegant than that. Does anyone have an alternative approach to this use case?</p>

<p><strong>Edit</strong></p>

<p>I should also mention that one method that has worked for us was to handle the error in the <code>flatMap</code>.</p>

<pre><code>button.rx.tap.asObservable()
  .flatMap {
    return networkRequest()
      .catchError(handleError)
  }
  .asDriver(onErrorDriveWith: Driver.empty())
  .drive(uiComponent)
  .disposed(by: disposeBag)
</code></pre>

<p>However, it again seems less elegant than I would think it should be.</p>
","1653465","","1653465","","2017-02-24 17:44:18","2017-02-24 18:16:31","Handle errors but stay subscribed to original Observable","<ios><swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"42477966","1","42478120","","2017-02-27 04:42:57","","3","3641","<p>I am new to RX Swift and need to display data in table view such that it automatically displays the last cell of the table(Scrolled to bottom by Default).
Here is my code to bind data:</p>

<pre><code>private var dataArray = Variable&lt;[Message]&gt;([])
private let bag = DisposeBag()

dataArray.asObservable()
    .bindTo(tableView.rx.items) { (tableView, row, msg) in
        let cell = tableView.dequeueReusableCell(withIdentifier: ""Cell"")!

        cell.textLabel?.text = obj.title
        return cell
    }
    .addDisposableTo(bag)
</code></pre>

<p>This code displays data to table view but does not scroll table View to bottom every time a new cell is added. I probably need to add the below line but not sure which rx-swift operator to use?</p>

<pre><code>tableView.setContentOffset(CGPoint(x: 0, y : CGFloat.greatestFiniteMagnitude), animated: true)
</code></pre>

<p>Thanks in Advance.</p>

<p>On a related note, would really appreciate if some one can suggest a good open source sample project made in rx-swift which we can refer.</p>
","5178534","","545218","","2017-02-27 07:51:37","2017-02-27 07:51:37","Automatically Scroll UITableView to bottom in Rx Swift","<ios><swift><uitableview><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"42485275","1","42486535","","2017-02-27 11:59:50","","0","1083","<p>I'm trying to add RxSwift to a peace of code using MVVM pattern. My app need to get a list of FoodType (desert, meal, etc.) an Food from an API and save them to Realm database. Then, I have a view with an UITextField and a UIButton. </p>

<p>The user write a food type (ex: desert):</p>

<ul>
<li>Background: the app should get FoodType and FoodList from Api if not in Realm DB</li>
<li>On button click: show list of Food that have the FoodType chosen by the user from Realm</li>
</ul>

<p><strong>ViewModel</strong></p>

<pre><code>struct FoodTypeViewModel { 

    // Get datas from API   
    private func getFoods() {
        foodService.getAll(completionHandler: { result in
            switch result {
            case .Success(let foods):
                for food in foods {
                    food.save()
                }
                break
            case .Failure(let error):
                debugPrint(error)
                break
            }
        })
    }

    // Get datas from API   
    private func getFoodTypes() {
        foodService.getAll(completionHandler: { result in
            switch result {
            case .Success(let foodTypes):
                for type in types {
                    type.save()
                }
                break
            case .Failure(let error):
                debugPrint(error)
                break
            }
        })
    }
}
</code></pre>

<p><strong>ViewController</strong></p>

<pre><code>class SetupViewController: UIViewController {
        @IBOutlet weak var foodTypeTextField: UITextField!
        @IBOutlet weak var foodTypeButton: UIButton!
}
</code></pre>

<p><strong><em>Model</em></strong></p>

<pre><code>class FoodType: Object {
    dynamic var identifier: String = """"
    dynamic var fullName: String?
    let foods = List&lt;Food&gt;()
}
</code></pre>

<p>I would like to add RxSwift to that code but how can I handle the asynchronous API. On first start the app have no datas (I don't want to populate at start) but when the user click the button. So on button click, UI should wait the response from the service (using waiting animation) and ViewModel should update UI when service respond. Any idea ?</p>
","1385773","","2976878","","2017-02-27 13:07:55","2017-03-01 08:59:36","Update view after async API call with RxSwift","<swift><realm><rx-swift>","1","0","","","","CC BY-SA 3.0"
"42507740","1","42521780","","2017-02-28 11:36:22","","0","428","<p>I'd like to extend an RXSwift protocol, namely OsbervableConvertibleType, but I only want to create an extension method only on OsbervableConvertibleTypes, that has a Result object in them. Now, Result is generic again. But I'd like to retain the generic type in my extension function, so the return type of my function is generic as well. Something like this:</p>

<pre><code>extension ObservableConvertibleType where E: Result&lt;T&gt; {
    public func asResultDriver() -&gt; RxCocoa.SharedSequence&lt;RxCocoa.DriverSharingStrategy, Result&lt;T&gt;&gt; {
        return self.asObservable()
            .filter { $0.isSuccess }
            .map { $0.value! }
            .asDriver { _ in Driver.empty() }
    }
}
</code></pre>

<p>Is it possible in Swift 3?</p>

<p>Thanks!</p>
","2087212","","2087212","","2017-03-01 08:52:06","2017-03-01 08:52:06","Swift 3 extension constrained to a type","<generics><swift3><extension-methods><rx-swift>","1","0","","","","CC BY-SA 3.0"
"42514525","1","","","2017-02-28 16:56:29","","2","780","<p>I'm running instruments to check for memory leaks and I'm seeing a memory leak when binding this observable with the UIButton title. Any idea what I'm doing wrong or how I can fix this issue? </p>

<pre><code>override func viewDidLoad() {
...
viewModel?.menuData.asObservable().subscribe(onNext: setupTopMenu).addDisposableTo(disposeBag)
...
}

func setupTopMenu(items: [MenuItemViewModel]) {
        topMenuStackView.subviews.forEach({ $0.removeFromSuperview() })
        for (i, item) in items.enumerated() {
            let button = UIButton(type: .custom)
            item.titleUppercased.bindTo(button.rx.title(for: .normal)).addDisposableTo(disposeBag) // memory leak 

            topMenuStackView.addArrangedSubview(button)
        }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/KGSiM.png"" rel=""nofollow noreferrer"">Instruments screenshot</a></p>
","7607045","","765298","","2017-02-28 17:00:47","2017-03-01 01:16:40","RxSwift binding data to UIButton memory leak","<ios><swift><memory-leaks><rx-swift>","1","0","","","","CC BY-SA 3.0"
"42526873","1","42615243","","2017-03-01 08:37:09","","1","2043","<p>I have a MVVM test project to experiment RxSwift. I have a UItextfield a button. User write a food name, click on the button and a get from an API is triggered to get all recipes with that food.</p>

<p><strong>View model</strong></p>

<pre><code>struct FoodViewModel
    var foodIdentifier: Variable&lt;String&gt; = Variable&lt;String&gt;("""")
    init() {    
        foodIdentifier.asObservable().subscribe(onNext: { (identifier) in
            self.getRecipes() // Get from API
        })
    }
}
</code></pre>

<p><strong>ViewController</strong></p>

<pre><code>class FoodViewController: UIViewController {
    @IBOutlet weak var foodTextField: UITextField!

    @IBAction func setCurrentRace(_ sender: Any) {
        viewModel.foodIdentifier.value = foodTextField.text!
    }
}
</code></pre>

<p>After compile I got an error </p>

<pre><code>Closure cannot implicitly capture a mutating self parameter
</code></pre>

<p>What I'm doing wrong ? I think it's because of struct of FoodViewModel. If yes, how can I achieve that using struct ?</p>
","1385773","","1385773","","2017-03-01 08:50:00","2017-03-05 23:41:38","Observe a string and get from API with RxSwift","<swift><mvvm><rx-swift><rx-cocoa>","1","11","","","","CC BY-SA 3.0"
"42538423","1","42569157","","2017-03-01 17:39:22","","0","661","<p>I'm attempting to write a unit test for <code>Driver</code> from RxCocoa library. Here's my simplified implementation code:</p>

<pre><code>struct LoginViewModel {

    var username: Driver&lt;String?&gt;!
    var password: Driver&lt;String?&gt;!
    var loginTaps: Driver&lt;Void&gt;!

    func login() -&gt; Driver&lt;LoginResult&gt; {
        let credentials = Driver.combineLatest(username, password) { ($0, $1) }
        let latestCredentials = loginTaps.withLatestFrom(credentials)

        return latestCredentials.flatMapLatest { (username, password) in
            .just(.success)
        }
    }
}
</code></pre>

<p>And here's the Quick/Nimble unit test I'm attempting to pass:</p>

<pre><code>let disposeBag = DisposeBag()
var capturedLoginResult = LoginResult.failed

loginViewModel.username = Driver.just(""some username"")
loginViewModel.password = Driver.just(""some password"")
loginViewModel.loginTaps = Driver.just()

loginViewModel.login().drive(onNext: { loginResult in
    capturedLoginResult = loginResult
}).addDisposableTo(disposeBag)

expect(capturedLoginResult == .success)
</code></pre>

<p>Above <code>expect</code> says that <code>capturedLoginResult</code> is still <code>.failed</code>. It appears as though element from <code>return latestCredentials.flatMapLatest { (username, password) in .just(.success) }</code> is not getting received by the <code>.drive(onNext: )</code> in the test.</p>

<p>If the implementation of <code>login</code> is just:</p>

<pre><code>func login() -&gt; Driver&lt;LoginResult&gt; {
    return .just(.success)
}
</code></pre>

<p>The test passes.</p>

<p>Any thoughts on what's happening here? Thanks!</p>
","1261256","","1261256","","2017-03-03 00:53:10","2017-03-03 01:41:36","onNext not getting called unit testing RxCocoa Driver","<swift><rx-swift><rx-cocoa>","1","2","","","","CC BY-SA 3.0"
"42542279","1","","","2017-03-01 21:21:26","","7","952","<p>Is there a way to replace the method </p>

<pre><code>func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize
</code></pre>

<p>from the <code>UICollectionViewDelegateFlowLayout</code> protocol by something reactive using RxSwift? </p>
","1015410","","","","","2017-12-30 02:57:46","How to replace UICollectionViewDelegateFlowLayout by a reactive(RxSwift) call?","<swift><rx-swift><rx-cocoa>","1","1","3","","","CC BY-SA 3.0"
"42570433","1","42594472","","2017-03-03 04:01:50","","0","4853","<p>I am able to bind an Observable sequence of data to a table. 
Now lets say i have a button on each cell which on click changes the 
label of that cell to new value. How to do this ?</p>

<p>I have done so far as follows</p>

<p>I have created an <code>@IBAction</code> for that button in the cell pointing class</p>

<p>then i am doing </p>

<pre><code>label.text = ""new text""
</code></pre>

<p>but when i scroll down then scroll up, the label show previous value not the new value</p>

<p>previously when i use array and set each value to a cell i used to update that array item and called <code>tableview.reloadData</code>.</p>

<p>how can i do this in RxSwift??</p>

<p>I have done so far </p>

<pre><code>tableview.dataSource = nil (then)
myData.bindTo ... (bind again)
</code></pre>

<p>This does not seem to me the right way. so what is the appropriate way to deal with this??</p>
","1097800","","","","","2017-03-04 09:40:40","Rxswift Update Tableview cell value","<ios><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"42588448","1","","","2017-03-03 21:08:07","","3","1042","<p>How to achieve self sizing collectionViewCells using RxDataSource?</p>

<p>I've tried setting </p>

<pre><code>flowLayout.estimatedItemSize = CGSize(width: 187, height: 102)
</code></pre>

<p>But then app crashes when <code>dataSourceObservable</code> changes.</p>

<p>I've tried setting cell size inside </p>

<pre><code>dataSource.configureCell = { [weak self] (dataSource, collectionView, indexPath, _) in 
</code></pre>

<p>Which is not a good idea, because cells overlap, and it is because I am not using </p>

<pre><code>func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize
</code></pre>

<p>Now, is possible to layout cell sizes properly using only observables? That is not to call something like </p>

<pre><code>dataSourceVar.value[indexPath].cellSize
</code></pre>

<p>Inside <code>collectionView sizeForItemAt</code>?</p>
","5595519","","","","","2020-08-29 01:20:41","Self sizing collectionViewCells using RxDataSource","<rx-swift><rxdatasources>","1","0","","","","CC BY-SA 3.0"
"42623766","1","","","2017-03-06 10:55:36","","2","759","<p>I have a collection view cell with a button, and I want to pass the tap control event (<code>button.rx.rap</code>) through the cell's view model, through the view controller's view model and to the collection view controller itself (as I need to present a view controller on tap event).</p>

<p>How can this be achieved in a Rx way (ideally without using subjects)?</p>
","2026361","","","","","2017-03-09 14:30:07","RxSwift: How to pass a control event through multiple view models","<mvvm><rx-swift><reactivex>","1","0","","","","CC BY-SA 3.0"
"42624179","1","","","2017-03-06 11:15:21","","1","786","<p>I have this code with seems to be correct. But it's only react on first search change. So the code is executed only one time. I tried to add <code>concat(Observable.never())</code> to my getAl function but it still running only one time. Did I miss something ? </p>

<pre><code>exists = search.asObservable()
.throttle(0.3, scheduler: MainScheduler.instance)
.distinctUntilChanged()
.flatMapLatest { searchString -&gt; Observable&lt;Bool&gt; in
    guard !searchString.isEmpty else {
        return Observable.empty()
    }
    return ServiceProvider.food.getAll(whereFoodName: searchString)
        .flatMap({ (result) -&gt; Observable&lt;Bool&gt; in
            return Observable.just(result.count &gt; 0)
        })
}
</code></pre>
","1385773","","","","","2017-09-26 13:50:10","API call executed only one time using RxSwift","<swift><xcode><alamofire><rx-swift>","1","2","","","","CC BY-SA 3.0"
"42634508","1","42655030","","2017-03-06 20:00:28","","2","3342","<p>How Can I prevent multiple long api calls (e.g. user tap the button several times) without saving state (e.g. saving state to ""isLoading"" property).</p>
","3249421","","3249421","","2017-03-07 16:00:21","2020-02-28 09:17:40","Prevent multiple api calls","<rx-java><rxjs><reactive-programming><rx-swift><reactivex>","2","2","","","","CC BY-SA 3.0"
"42636065","1","42636877","","2017-03-06 21:38:54","","3","1485","<p>It appears that <code>ThreadSafeReference</code> was added recently to help move across thread boundaries. Prior, according to the sources I read (which were probably not exhaustive) the recommendation to was to just query realm on the thread you intend to use the results on; effectively query it on the UI thread.</p>

<p>Is there a benefit to querying Realm on a background thread or does resolving the <code>ThreadSafeReference</code> basically run the query again? </p>

<p>Using RxSwift here's an example of this:</p>

<pre><code>import RxSwift
import RealmSwift 


public static func getAllMyModels() -&gt; Observable&lt;Results&lt;MyModel&gt;&gt;{

    return Observable&lt;ThreadSafeReference&lt;Results&lt;MyModel&gt;&gt;&gt;.create{
        observer in

        // using this queue in this example only
        DispatchQueue.global(qos: .default).async {

            let realm = try! Realm()
            let models = realm.objects(MyModel.self)
            let safe = ThreadSafeReference(to: models)

            observer.onNext(safe)
            observer.onCompleted()
        }

        return Disposables.create()
    }
    .observeOn(MainScheduler.instance) // push us back to the UI thread to resolve the reference
    .map{
        safeValue in

        let realm = try! Realm()
        let value = realm.resolve(safeValue)!
        return value
    }
    .shareReplayLatestWhileConnected()
}
</code></pre>

<p>Did I gain anything by querying on some background thread and resolving on the UI thread? </p>
","1060314","","1060314","","2017-03-06 22:27:12","2017-03-08 14:34:29","Is there any point in querying realm on a background thread and resolving a ThreadSafeReference on the UI thread?","<swift><realm><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"42656942","1","","","2017-03-07 19:42:20","","7","3645","<p>I am trying to build an Observable which would output a value based on the value of a Variable.</p>

<p>Something like that:</p>

<pre><code>let fullName = Variable&lt;String&gt;("""")
let isFullNameOKObs: Observable&lt;Bool&gt;

isFullNameOKObs = fullName
            .asObservable()
            .map { (val) -&gt; Bool in
                // here business code to determine if the fullName is 'OK'
                let ok = val.characters.count &gt;= 3
                return ok
            }
</code></pre>

<p><strong>Unfortunately the bloc in the map func is never called!</strong></p>

<p>The reason behind this is that:</p>

<ol>
<li>The fullName Variable is binded to a UITextField with the bidirectional operator &lt;-> as defined in the RxSwift example.</li>
<li>The isFullNameOKObs Observable will be observed to <strong>hide or display</strong> the submit button of my ViewController.</li>
</ol>

<p>Any help would be greatly appreciated.</p>

<p>Thanks</p>

<p>The model</p>

<pre><code>class Model {

    let fullName = Variable&lt;String&gt;("""")
    let isFullNameOKObs: Observable&lt;Bool&gt;

    let disposeBag = DisposeBag()

    init(){

        isFullNameOKObs = fullName
            .asObservable()
            .debug(""isFullNameOKObs"")
            .map { (val) -&gt; Bool in
                let ok = val.characters.count &gt;= 3
                return ok
            }
            .debug(""isFullNameOKObs"")


        isRegFormOKObs = Observable.combineLatest(
            isFullNameOKObs,
            is...OK,
            ... ) { $0 &amp;&amp; $1 &amp;&amp; ... }


        isRegFormOKObs
            .debug(""isRegFormOKObs"")
            .asObservable()
            .subscribe { (event) in
                // update the OK button
            }
            // removing this disposedBy resolved the problem
            //.disposed(by: DisposeBag())

    }
}
</code></pre>

<p>The ViewController:</p>

<pre><code>func bindModel() -&gt; Void {

    _ = txFullName.rx.textInput &lt;-&gt; model!.fullName
    ......

}
</code></pre>
","1936491","","1936491","","2017-03-07 21:13:27","2017-03-07 21:13:27","RxSwift Build an Observable based on a Variable","<ios><swift><observable><rx-swift><rx-cocoa>","1","1","","","","CC BY-SA 3.0"
"42657459","1","","","2017-03-07 20:14:37","","4","832","<p>When doing something like this:</p>

<pre class=""lang-swift prettyprint-override""><code>import RxSwift 
let queue = DispatchQueue(label: ""com.myapp.services"")
let scheduler = SerialDispatchQueueScheduler(queue: queue, internalSerialQueueName: ???)
</code></pre>

<p>It wants me to provide an <code>internalSerialQueueName</code> value. I assume I would just use <code>queue.label</code> to keep it all consistent, but I have seen code examples where people just use <code>""""</code> for the <code>internalSerialQueueName</code>.</p>

<p>So, what is the correct use of the value for <code>internalSerialQueueName</code>?</p>
","1060314","","4280337","","2019-03-23 07:03:48","2019-03-23 07:03:48","What is the correct use of internalSerialQueueName when creating a SerialDispatchQueueScheduler from an existing DispatchQueue","<swift><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"42689091","1","","","2017-03-09 07:22:34","","0","1827","<p>I am trying to use RxSwift/RxDataSource with TableView but I am not able to assign configureCell with an existing function. Code below:</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa
import RxDataSources

class BaseTableViewController: UIViewController {
    // datasources
    let dataSource = RxTableViewSectionedReloadDataSource&lt;TableSectionModel&gt;()
    let sections: Variable&lt;[TableSectionModel]&gt; = Variable&lt;[TableSectionModel]&gt;([])
    let disposeBag: DisposeBag = DisposeBag()

    // components
    let tableView: UITableView = UITableView()

    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        setDataSource()
    }

    func setupUI() {
        attachViews()
    }

    func setDataSource() {
        tableView.delegate = nil
        tableView.dataSource = nil
        sections.asObservable()
            .bindTo(tableView.rx.items(dataSource: dataSource))
            .addDisposableTo(disposeBag)
        dataSource.configureCell = cell
        sectionHeader()
    }

    func cell(ds: TableViewSectionedDataSource&lt;TableSectionModel&gt;, tableView: UITableView, indexPath: IndexPath, item: TableSectionModel.Item) -&gt; UITableViewCell! {
        return UITableViewCell()
    }

    func sectionHeader() {

    }
}
</code></pre>

<p>Xcode throws the following error:</p>

<blockquote>
  <p>/Users/.../BaseTableViewController.swift:39:36: Cannot assign value of type '(TableViewSectionedDataSource, UITableView, IndexPath, TableSectionModel.Item) -> UITableViewCell!' to type '(TableViewSectionedDataSource, UITableView, IndexPath, TableSectionModel.Item) -> UITableViewCell!'</p>
</blockquote>

<p>the error is thrown at line</p>

<blockquote>
  <p>dataSource.configureCell = cell</p>
</blockquote>

<p>Do you have any idea?</p>

<p>Thanks</p>
","2661859","","","","","2017-03-19 14:31:51","RxSwift DataSource configureCell not able to assign function","<ios><swift><uitableview><rx-swift><rxdatasources>","1","1","","","","CC BY-SA 3.0"
"42694308","1","42694920","","2017-03-09 11:32:52","","0","2362","<p>So, for example I have this observer in <code>var myObserver: AnyObserver&lt;Bool&gt;</code>
Can I somehow subscribe to it like for an <code>observable</code>, so I would be able to do some operations with it like <code>.subscribe(onNext:)</code> ?</p>
","6473113","","482557","","2018-03-24 00:20:11","2018-03-24 17:35:18","Swift bind AnyObserver to Observable","<ios><iphone><swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"42695105","1","","","2017-03-09 12:12:40","","0","458","<p>I'm trying to add RxSwift to my project. Added RxSwift and RxCocoa to my Podfile but when I compile I get this error:</p>

<p><img src=""https://i.imgur.com/USkk0h2.png"" alt=""error""></p>

<p>Tried in another empty project and it all works fine. Can't find what's causing this.</p>

<p>EDIT:</p>

<p>Seems like it fails to build Rx-Cocoa. No idea why.</p>

<p><img src=""https://i.imgur.com/xaB7NCa.png"" alt=""error""></p>
","1344439","","1344439","","2017-03-09 15:49:32","2018-02-28 20:23:43","Error compiling with RxSwift","<rx-swift>","2","6","","","","CC BY-SA 3.0"
"42703431","1","","","2017-03-09 19:01:58","","0","287","<p>Given a class that maintains a local list of selected things and the initial value for those selected things comes from an Observable that does a network call to fetch it, how can I correctly use Subjects and Observables together?</p>

<p>This is what I want to public expose:</p>

<pre><code>class SelectedThingsRepository {
    public let selectedThings: Observable&lt;[Thing]&gt;

    public toggleSelected(for thing: Thing)
}
</code></pre>

<p>My current thinking is that I should somehow use the network Observable to get the initial data, save it to a local variable, then on every call to <code>toggleSelected</code> I call the Subject's <code>onNext</code> passing the local variable that holds the list of selected values.</p>

<p>My current think is something like this:</p>

<pre><code>var localList: [Thing] = [] // How can I initialize this from serverSelected?

let serverSelected = Observable&lt;[Thing]&gt;.create { observer in 
    thingNetwork.fetch { selectedList
        observer.onNext(selectedList)
        observer.onCompleted()
    }
}.shareReplay(1)

let localSelected = ReplaySubject.create(bufferSize: 1)

selectedThings = localSelected.ifEmpty(switchTo: serverSelected)

public func toggleSelected(for thing: Thing) {
    // ... change localList to add or remove thing
    localSelected.onNext(localList)
}
</code></pre>

<p>Note that I haven't initialized <code>localList</code> with the server data. I thought about doing it in the <code>thingNetwork.fetch</code> call back, just before calling <code>onNext</code> but it feels very wrong to have side effects there.</p>

<p>How can I do this? Bonus round: I'd love to have the network call performed only when <code>localSelected</code> has a first subscriber.</p>
","335974","","335974","","2017-03-10 18:44:16","2017-03-21 03:53:42","How to use a Subject with stateful local data where its initial value comes from an Observable?","<reactive-programming><rx-swift><reactivex>","1","0","","","","CC BY-SA 3.0"
"42718537","1","42734408","","2017-03-10 12:34:10","","0","2739","<p>I am trying to create a searchBar that searches for addresses via a MKLocalSearch with request and using RXSwift and binding to RXCocoa</p>

<p>So far i have done the following
1. filter and debounce to avoid too many requests:</p>

<pre><code>let searchRes = searchBar.rx.text
    .orEmpty
    .filter { query in
        return query.characters.count &gt; 4
    }
    .debounce(1, scheduler: MainScheduler.instance)
</code></pre>

<ol start=""2"">
<li><p>the resulting String query is map:ed to create a MKLocationSearch and then flatMapp:ed to return an array of MKMapItems to be able to bind the array to tableView's items:</p>

<pre><code>searchRes.map{query -&gt; MKLocalSearch in
    let request = MKLocalSearchRequest()
    request.naturalLanguageQuery = query
    request.region = self.mapView.region
    return MKLocalSearch(request: request)
}.flatMapLatest{search -&gt; Observable&lt;[MKMapItem]&gt; in
    search.start(completionHandler:{(response, error) in
        let items: Variable&lt;[MKMapItem]&gt; = Variable([])
        if let resp = response {
            //need to return the result form this
            // i.e. items.value = response.mapItems
        }
        //can not return from here since the request is async
    }
}.bindTo //continue to bind to tableview
</code></pre></li>
</ol>

<p>How can this be done using RXSwift, i could not find any relevant example </p>
","1742233","","","","","2017-03-11 11:05:02","RXSwift flatmap that returns from an async completion handler","<swift><rx-swift><rx-cocoa>","1","0","1","","","CC BY-SA 3.0"
"42747594","1","42756521","","2017-03-12 12:49:43","","1","2416","<p>""signingIn : Observable "" is for the progress bar and to prevent the user to click the button again before i get the response from the API</p>

<pre><code>let validatedUsername: Observable&lt;Bool&gt; 
let validatedPassword: Observable&lt;Bool&gt;
var signingIn : Observable&lt;Bool&gt;    // Is signing process in progress
let signupEnabled: Observable&lt;Bool&gt; //Is signup button enabled

validatedUsername = input.username
        .map { username in
            return username.characters.count &gt; 5
        }
        .shareReplay(1)

validatedPassword = input.password
        .map { password in
            return  password.characters.count &gt; 5
        }
        .shareReplay(1)

signupEnabled = Observable.combineLatest(
        validatedUsername,
        validatedPassword,
        signingIn.asObservable()
    )   { username, password , signing in  //the error at this line

        username.isValid &amp;&amp;
            password.isValid &amp;&amp;
            !signing
        }
        .distinctUntilChanged()
        .shareReplay(1)
}
</code></pre>
","5216000","","","","","2017-03-13 04:13:23","RxSwift :Cannot convert value of type '(_, _, Bool) -> Bool' to expected argument type '(_, _, _) -> _'","<rx-swift>","1","0","","","","CC BY-SA 3.0"
"42782702","1","","","2017-03-14 09:55:19","","1","2157","<p>How to merge two observable to another observable with RxSwift?
In my case:</p>

<pre><code>struct ViewModel {

let items: Observable&lt;[MediaAsset]&gt;

init(type: Observable&lt;AssetMediaType&gt;, provider: DataProvider) {
    items = Observable.combineLatest(type, provider.rx.didAuthorize, resultSelector: { (type, status)  in
        return provider.rx.fetchMedia(type)
    })
}

public var didAuthorize: Observable&lt;AuthorizeResult&gt; {
    return Observable.create { o in
       //....
    }
}

public func fetchMedia(_ withType: AssetMediaType) -&gt; Observable&lt;[MediaAsset]&gt; {
    return Observable.create { observer in
       //....
    }
}
</code></pre>

<p>but xcode build failed for reason: </p>

<p>Cannot convert value of type '(AssetMediaType, <em>) -> Observable&lt;[MediaAsset]>' to expected argument type '(</em>, _) -> _'</p>
","1505670","","1505670","","2017-03-16 06:09:20","2018-09-25 11:02:47","How to merge two observable to another observable with RxSwift?","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"42788423","1","","","2017-03-14 14:16:32","","5","1416","<p>So I have this viewModel which has a validation observable that is simply the combination of 5 other signals into a boolean.</p>

<pre><code>import RxSwift

class SchedulingFormViewModel: BaseViewModel {

    let places = Variable&lt;[String]&gt;([])

    var formIsValid: Observable&lt;Bool&gt;!

    override init() {
        super.init()
        places.value = [""LUGAR 1"", ""LUGAR 2"", ""LUGAR 3""]

        formIsValid = Observable.combineLatest(UserSession.currenctScheduling.dateSignal.asObservable(),
                                               UserSession.currenctScheduling.carSignal.asObservable(),
                                               UserSession.currenctScheduling.locationSignal.asObservable(),
                                               UserSession.currenctScheduling.servicesSignal.asObservable())
        { (date: Date?, car: Car?, location: String?, services: [Service]?) in
            print(""DATE: \(date), CAR: \(car), LOCATION: \(location), SERVICES:\(services)"")
            guard let servicesArray = services else { return false }
            let valid = date != nil &amp;&amp; car != nil &amp;&amp; location != nil &amp;&amp; servicesArray.count &gt; 0
            return valid
        }
    }
}
</code></pre>

<p>And then I have my test class with a method that should just test whether the signal changes or not. I've tried a variety of approaches but none of them really gets the true value at the end. The observable only emits a true signal after the test has run.</p>

<p>My test class is setup like this</p>

<pre><code>import XCTest

import RxSwift
import RxTest

@testable import Automobi

class SchedulingUnitTests: XCTestCase {

    var viewModel: SchedulingFormViewModel!
    var disposeBag: DisposeBag!
    var scheduler: TestScheduler!

    override func setUp() {
        super.setUp()
        viewModel = SchedulingFormViewModel()
        UserSession.clearScheduling()
        disposeBag = DisposeBag()
        scheduler = TestScheduler(initialClock: 0) 
    }
}
</code></pre>

<p>I've tried the TestScheduler</p>

<pre><code>func testFormValidation() {
    UserSession.currenctScheduling.dateSignal.value = Date()
    UserSession.currenctScheduling.carSignal.value = Car()
    UserSession.currenctScheduling.servicesSignal.value = [Service(), Service()]

    let location = scheduler.createHotObservable([
        next(100, ""TEST"")
    ])

    location.subscribe(onNext: { (text) in
        print(""LOCATION: \(text)"")
        UserSession.currenctScheduling.locationSignal.value = text
    }).addDisposableTo(disposeBag)


    let results = scheduler.createObserver(Bool.self)

    scheduler.scheduleAt(0) { 
        self.viewModel.formIsValid.subscribe(results).addDisposableTo(self.disposeBag)
    }

    let expected = [
        next(100, true)
    ]

    scheduler.start()

    XCTAssertEqual(results.events, expected)
}
</code></pre>

<p>Also</p>

<pre><code>func testFormValidation() {
    UserSession.currenctScheduling.dateSignal.value = Date()
    UserSession.currenctScheduling.carSignal.value = Car()
    UserSession.currenctScheduling.servicesSignal.value = [Service(), Service()]

    let location = scheduler.createHotObservable([
        next(100, ""TEST""),
        next(150, ""TEST 2""),
        next(200, ""TEST 3"")
        ])

    location.subscribe(onNext: { (text) in
        print(""LOCATION: \(text)"")
        UserSession.currenctScheduling.locationSignal.value = text
    }).addDisposableTo(disposeBag)


    var results = [Bool]()
    viewModel.formIsValid.subscribe(onNext: { (value) in
        results.append(value)
    }).addDisposableTo(disposeBag)

    let expected = [true, true, true]

    scheduler.start()

    XCTAssertEqual(results, expected)
}
</code></pre>

<p>I've tried things like binding my formIsValid to a Variable and verifying its value at the end.</p>

<pre><code>func testFormValidation() {
        UserSession.currenctScheduling.dateSignal.value = Date()
        UserSession.currenctScheduling.carSignal.value = Car()
        UserSession.currenctScheduling.locationSignal.value = ""TESTE""
        UserSession.currenctScheduling.servicesSignal.value = [Service(), Service()]

        sleep(5)

        XCTAssertTrue(viewModel.formIsValid.value)
}
</code></pre>

<p>But I never get the expected result. I do get a true signal after all the tests fail and the code goes back to executing. Also when running the app the code executes as expecte I just need to catch it in the test. Any ideas?!</p>
","5817585","","","","","2017-03-15 09:06:54","How to test a combineLatest observable with RxTest?","<ios><unit-testing><testing><swift3><rx-swift>","1","0","","","","CC BY-SA 3.0"
"42793796","1","","","2017-03-14 18:27:54","","1","371","<p>I have created tableView with sections by RxDataSources.</p>

<p>ViewController</p>

<pre><code>viewModel.sectionsObservable
        .bindTo(tableView.rx.items(dataSource: viewModel.dataSource))
        .disposed(by: disposeBag)
</code></pre>

<p>sectionsObservable emits the event when a new element is added to the array.</p>

<p>I would like to test if a proper element is on proper indexPath.</p>

<pre><code>func testGettingElementForIndexPath() {
    let element = Element()
    viewModel.addElement(element)
    let fetchedElement = viewModel.getElement(at: IndexPath(row: 0, section: 0))
    XCTAssertEqual(element, fetchedElement)
}
</code></pre>

<p>ViewModel</p>

<pre><code>func getElement(at indexPath: IndexPath) -&gt; Element {
    return self.dataSource.sectionModels[indexPath.section].items[indexPath.row]
}
</code></pre>

<p>it works in the app, but tests fail. fatal error: Index out of range</p>

<p>It's all because of that asynchronous. How to test this case?</p>

<hr>

<p>EDIT 1:
ViewModel</p>

<pre><code>let elementsVariable = Variable&lt;[TaskData]&gt;([])
func addElement(_ element: Element) {
    elementsVariable.value.append(element)
}

var sectionsObservable: Observable&lt;[Day]&gt; {
    return elementsVariable.asObservable().map { (elements) -&gt; [MySection] in
        ...
    }
}
</code></pre>
","2235274","","2235274","","2017-03-14 19:25:43","2017-03-14 21:26:36","RxDataSources testing","<testing><tdd><rx-swift><rxdatasources>","1","0","","","","CC BY-SA 3.0"
"42814478","1","42849370","","2017-03-15 15:43:16","","1","1069","<p><strong>I came across this problem when testing my View:</strong></p>

<p>In my ViewModel I call to an asynchronous operation and when the response arrives, I use a <code>PublishSubject</code> to produce a change in my View. In my View, I call <code>DispatchQueue.main.async</code> in order to hide or show a button.</p>

<p>ViewModel</p>

<pre><code>let refreshButtons = PublishSubject&lt;Bool&gt;(true)
refreshButtons.onNext(true)
</code></pre>

<p>View</p>

<pre><code>model.refreshButtons.asObservable()
                .subscribe(onNext: {
                    [unowned self] success in
                    self.updateButtons(success)
                })
                .addDisposableTo(disposable)

private func updateButtons(_ show:Bool) {
   DispatchQueue.main.async{
      button.isHidden = !show
   }
}
</code></pre>

<p>Now I don't know how to unit test that <code>refreshButtons.onNext(true)</code> will hide or show my button. </p>

<p>The solutions I can think of are:</p>

<ul>
<li>Overriding the method and having an async expectation, but for that I need to make the method public, what I don't want, or</li>
<li>Dispatching the main queue in my ViewModel and not in the view, what it sounds odd to me, but might me ok.</li>
</ul>

<p>How can I solve this?
Thank you in advance.</p>
","6843398","","809944","","2017-03-17 03:24:38","2017-03-17 04:43:35","How to test a function that gets into the main thread in Swift with RxSwift and XCTest?","<swift><unit-testing><mvvm><rx-swift>","2","0","","","","CC BY-SA 3.0"
"42824002","1","42943793","","2017-03-16 01:58:54","","1","294","<p>I'm creating simple messaging app based on CocoaAsyncSocket and STOMP protocol. So I created main class, which use <code>PublishSubject</code>, so the subscribers can observe incoming STOMP frames, something like this:</p>

<pre><code>class StompStream: NSObject {
//MARK: - Public
     var inputFrame = PublishSubject&lt;StompFrame&gt;()

//MARK: - Private
    fileprivate var socket: GCDAsyncSocket!
    ...
    ...
    fileprivate func parse(withData data: Data) {
        let string = String(data: data, encoding: .utf8)
        do {
            let frame = try StompFrame(text: string)
            self.inputFrame.on(.next(frame))
        } catch {
            self.inputFrame.on(.error(error))
        }
     }
 }
//MARK: - GCDAsyncSocketDelegate methods
extension StompStream: GCDAsyncSocketDelegate {
    ...
    ...
    func socket(_ sock: GCDAsyncSocket, didRead data: Data, withTag tag: Int) {
        self.parse(withData: data)
    }
}
</code></pre>

<p>So, other who want to read <code>inputFrame</code>, just do:</p>

<pre><code>fileprivate func subscribeToEvents() {
    self.stompStream.inputFrame
        .observeOn(SerialDispatchQueueScheduler(queue: Queues().stompQueue, internalSerialQueueName: ""stomp""))
        .subscribe( onNext: { inputFrame in
            //do some stuff
        }).addDisposableTo(self.disposeBag)
}
</code></pre>

<p>I'm very new to RxSwift, and I read, that it's better to use <code>Observable&lt;StompFrame&gt;</code>, if we want to just read the events, but with PublishSubject I can init it like this - <code>PublishSubject&lt;StompFrame&gt;()</code>, and with <code>Observable&lt;StompFrame&gt;</code> I couldn't understand how to do such thing, without creating some <code>func</code>, where I will return <code>Observable.create { }</code>, so every time if somebody will want to receive events, it will create another <code>Observable&lt;StompFrame&gt;</code>, but with <code>PublishSubject</code> it's only one.
Thanks for any help to explaining me this Rx stuff :)</p>
","4376284","","","","","2017-03-22 05:56:21","Correct usage of PublishSubject with CocoaAsyncSocket","<swift><observable><rx-swift><cocoaasyncsocket>","1","0","","","","CC BY-SA 3.0"
"42852876","1","42880047","","2017-03-17 08:45:24","","0","982","<p>I am new to reactive programming and I am experiencing difficulty in filtering and accessing object from a specific index. Below is my code snippet.</p>

<pre><code>    private var contacts: Observable&lt;(AnyRealmCollection&lt;Contact&gt;, RealmChangeset?)&gt;!

        override func viewDidLoad() {
            super.viewDidLoad()

            contacts = Observable.changeset(from: contactViewModel.getDeviceContacts())
            let dataSource = RxCollectionViewRealmDataSource&lt;Contact&gt;(cellIdentifier: ""SendFeedContactCell"", cellType: ContactCollectionCell.self) {cell, ip, contact in
                cell.configure(contact)
            }

            contacts
                .bindTo(collectionView.rx.realmChanges(dataSource))
                .addDisposableTo(disposeBag)

            searchBar
                .rx.text
                .orEmpty
                .subscribe(onNext: { [unowned self] query in
                    // Filter query - doesn't work!
                    // self.contacts.filter({ (observable) -&gt; Bool in
                    // observable.0.filter(NSPredicate(format: ""name CONTAINS[c] '\(query)'""))
                    // })
                })
                .addDisposableTo(disposeBag)  

            collectionView.rx.itemSelected
            .subscribe(onNext: { indexPath in
                // TODO: How to access a specific object from the contacts object
            })
            .addDisposableTo(disposeBag)
        }
</code></pre>

<ol>
<li><p>I am receiving query in the search bar but filtering doesn't seems to work. </p></li>
<li><p>I am getting IndexPath when an item is selected in the collection view but I am wondering how I can access a specific model properties based on the index path.</p></li>
</ol>

<p>I am using <a href=""https://github.com/RxSwiftCommunity/RxRealm"" rel=""nofollow noreferrer"">RxRealm</a> and <a href=""https://github.com/RxSwiftCommunity/RxRealmDataSources"" rel=""nofollow noreferrer"">RxRealmDataSources</a> as my data is stored in realm database in device.</p>
","1053097","","","","","2017-03-18 21:23:31","Unable to filter objects with RxSwift/RxRealm","<swift><swift3><realm><rx-swift><rxdatasources>","1","0","1","","","CC BY-SA 3.0"
"42860384","1","42861486","","2017-03-17 14:42:15","","5","7018","<p>I'm new to <code>RxSwift</code> and all example I found are handling simple cases.</p>

<p>I'm trying to do form validation for my textfields.
My custom TextField class has a method <code>isValid()</code> and a <code>regexp</code>. The <code>isValid</code> return is based on the <code>regexp</code> attribute.</p>

<p>So far, I have written the following :</p>

<pre><code>let valids = [mLastName, mFirstName, mEmailField].map {
    $0.rx.text.map {
        text -&gt; Bool in
        // I want more complex logic here
        // Like return field.isValid()
        return text!.characters.count &gt; 0
    }
}    

let _ = Observable.combineLatest(valids) { iterator -&gt; Bool in
    return iterator.reduce(true, { $0 &amp;&amp; $1 })
}.subscribe(onNext: { allValid in
    ///update button according to AllValid
})
</code></pre>

<p>Does anyone know how to update the code to base the first <code>Observable&lt;Bool&gt;</code> be based on my <code>isValid()</code> method instead of <code>text!.characters.count</code></p>
","1535128","","","","","2017-03-17 15:46:44","Rx Swift : Complex TextFields Validation","<ios><swift><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"42871040","1","43855388","","2017-03-18 05:55:51","","6","2166","<pre><code>passWordInputView.inputTextField.rx.controlEvent(.editingDidEnd)
        .bindTo(loginButton.rx.tap)
        .disposed(by: disposeBag)
</code></pre>

<p>when password edit done then login</p>

<p>but get error:
Type 'inout UIButton' does not conform to protocol 'ReactiveCompatible'</p>
","4395705","","672989","","2017-08-14 15:03:38","2017-08-14 15:04:02","Type 'inout UIButton' does not conform to protocol 'ReactiveCompatible'","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"42877504","1","","","2017-03-18 17:22:58","","6","5886","<p>I am new here about RxSwift, In my case, I want to use UserDefaults with RxSwift to simplify my code, so I did this following code</p>

<p>my question is, when I clicked a cell, but the subscribe method submit twice? so what should I do to fix it? thx a lot!</p>

<pre><code>import UIKit

import RxSwift
import RxCocoa
import RxDataSources

class ViewController: UIViewController {
    let disposeBag = DisposeBag()

    @IBOutlet weak var tableView: UITableView! {
        didSet {
            tableView.register(UITableViewCell.self, forCellReuseIdentifier: String(describing: UITableViewCell.self))

            tableView.rx
                .itemSelected
                .subscribe { (indexPath) in
                    UserDefaults.standard.set(""\(indexPath)"", forKey: ""key"")
                }
                .disposed(by: disposeBag)
        }
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.
        UserDefaults.standard.rx
            .observe(String.self, ""key"")
            // .debug()
            .subscribe(onNext: { (value) in
                if let value = value {
                    print(value)
                }
            })
            .disposed(by: disposeBag)

        let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;String, String&gt;&gt;()

        dataSource.configureCell = { (dataSource, tableView, indexPath, item) in
            let cell = tableView.dequeueReusableCell(withIdentifier: String(describing: UITableViewCell.self), for: indexPath)
            cell.textLabel?.text = item

            return cell
        }

        Observable.just([SectionModel(model: """", items: (0..&lt;5).map({ ""\($0)"" }))])
            .bindTo(tableView.rx.items(dataSource: dataSource))
            .disposed(by: disposeBag)
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
}
</code></pre>
","2354622","","","","","2021-04-03 10:48:26","RxSwift + UserDefaults","<ios><swift><rx-swift>","4","0","","","","CC BY-SA 3.0"
"42899259","1","42902885","","2017-03-20 08:54:44","","5","14599","<p>I am using RxSwift for tableview. I need to reload my table each time after getting data from api but I'm failed to do this. I couldn't find any solution for that. Can anybody help?</p>

<p>I have an array of places obtain from response of an Api.I have used this code in view did load, but its is not being called when array is updated.</p>

<p><a href=""https://i.stack.imgur.com/aN0Po.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/aN0Po.png"" alt=""enter image description here""></a></p>
","7738524","","2920193","","2017-03-22 11:49:57","2018-09-01 04:48:18","Reload Tableview using RxSwift","<ios><swift><rx-swift><rx-cocoa>","3","1","4","","","CC BY-SA 3.0"
"42904503","1","42927406","","2017-03-20 13:11:20","","0","133","<p>I am trying to start using RxSwift, therefore I tried to create a function that does a request and I tried to implement the rxResult() function that comes with <a href=""https://github.com/MLSDev/TRON"" rel=""nofollow noreferrer"">TRON</a>, the HTTP library I use. But the documentation on this is not very detailed. Can anyone point me in the right direction on what I am doing wrong? This is the function I have written:</p>

<pre><code>static func readAllWithRx() {
    let token = UserDefaults.standard.value(forKey: Constants.kTokenUserDefaultsKey) as! String
    let url = URL(string: ""api/url"")!
    let request: APIRequest&lt;AssessmentResponse, MyAppError&gt; = APIHelper.tron.request(url.absoluteString)

    _ = request.rxResult().subscribe(onNext: { AssessmentResponse in
        print(""RX AssessmentResponse \(AssessmentResponse)"")
    }, onError: { Error in

    }, onCompleted: { 

    }, onDisposed: { 

    })
}
</code></pre>

<p>Finally I try to call this request within my Controller using:</p>

<pre><code>let read = Assessments.readAllWithRx()
</code></pre>
","1453253","","","","","2017-03-21 12:39:18","Implementing RxSwift with TRON","<rx-swift>","1","0","","","","CC BY-SA 3.0"
"42970040","1","43048505","","2017-03-23 07:47:09","","1","4135","<p>I am working on an app that presents 26 (alphabet) buttons. Right now they're all connected to the same function in the <code>ViewController</code>, that in turn calls another function in the <code>ViewModel</code>, and finally this function calls <code>publishSubject.onNext()</code>. The <code>ViewController</code> subscribes to the <code>PublishSubject</code> and that's the whole circle.</p>

<p>The reason I did it this way, instead of binding the publish subject to the buttons' tap, is that I have to know who the sender is. Is there anyway to do so? If there isn't, is there a more intelligent design than mine in head?</p>

<p>Thanks!</p>
","1596293","","","","","2017-03-27 14:19:11","RxSwift: binding PublishSubject to multiple buttons and receive sender","<bind><rx-swift><publishsubject>","1","3","1","","","CC BY-SA 3.0"
"42977700","1","42983429","","2017-03-23 13:38:45","","3","1738","<p>I have a case where I am using a 3rd party library and I would like to make it into an Observable. Appropriately, the library is designed around delegates as one would expect so I am wrapping it.  The library performs an async operation and calls it's delegate with the results when it completes.</p>

<p>I definitely want to take advantage of the <code>cold</code> nature of the observable and only start the operation when someone subscribes. I have a solution that works, I just don't know if it's deeply flawed and I am missing some important understanding of <code>RxSwift</code> or perhaps there is a simpler way to achieve the same goal.</p>

<pre><code>public final class RxLibBridge: LibDelegate{

    let lib = Lib()
    let _source = PublishSubject&lt;[LibResult]&gt;()

    public init(){
        lib.delegate = self
    }

    public func asObservable() -&gt; Observable&lt;[LibResult]&gt;{
        // create a cold observable to start
        // the Lib's async operation on subscribe.
        return Observable&lt;Void&gt;.create{
            observer in

            self.lib.startOperation()

            // emit and complete
            observer.onNext(())
            observer.onCompleted()
            return Disposables.create()
        }
        // convert the `Void` observable into an observable from the 
        // PublishSubject
        .flatMapLatest{self._source}
    }

    // the lib's completion delegate method
    public func lib(_ lib: Lib, didFinishWithResult results: [LibResult]) {
        // grab the PublishSubject, emit the result and complete
        let observer = _source.asObserver()
        observer.onNext(results)
        observer.onCompleted()
    }
}
</code></pre>

<p>So my question is: Is this an appropriate pattern in Rx? Again, it works:</p>

<pre><code>RxLibBridge()
    .asObservable()
    .subscribe(...)
</code></pre>

<p>Just because it works though doesn't mean I have not fundamentally misunderstood the proper way to work with this situation.</p>

<p>I know there is a way in RxSwift to handle something like this:</p>

<p><a href=""https://medium.com/@maxofeden/rxswift-migrate-delegates-to-beautiful-observables-3e606a863048#.rksg2ckpj"" rel=""nofollow noreferrer"">https://medium.com/@maxofeden/rxswift-migrate-delegates-to-beautiful-observables-3e606a863048#.rksg2ckpj</a></p>

<p><a href=""https://samritchie.net/2016/05/12/rxswift-delegateproxy-with-required-methods/"" rel=""nofollow noreferrer"">https://samritchie.net/2016/05/12/rxswift-delegateproxy-with-required-methods/</a></p>

<p>I tried this approach but it looks like the API changed since 2015. Namely, in the example links above <code>proxyForObject</code> cannot be found when adding the <code>rx_delegate</code> method in the extension. </p>

<p>Additionally, this approach appears to favor pure <code>Objective-C</code> [UIKit/AppKit] APIs. In my attempt to follow the linked example, I was editing the source of the 3rd party lib to make the delegate method <code>optional</code> and exposing it to <code>@objc</code>. The lib's delegate is <code>required</code> and I would rather not have to fork the lib to make the modifications.</p>

<p>This SO answer provided the updated API for the 2 links above:</p>

<p><a href=""https://stackoverflow.com/questions/38325626/can-not-use-proxyforobject-function-in-delegateproxytype-rxswift"">Can not use proxyForObject function in DelegateProxyType (rxSwift)</a></p>
","1060314","","805252","","2018-06-19 09:06:03","2018-06-19 09:06:03","How to properly convert a 3rd party library delegate into a RxSwift Observable","<swift><rx-swift>","1","0","2","","","CC BY-SA 4.0"
"43007690","1","","","2017-03-24 19:29:48","","0","144","<p>I spotted a few memory leaks which are connected with <code>NSMutableArray</code> in <code>Core Foundation</code> and have a big problem with fixing it. My App has been created in Swift 3.0 and it uses <code>rxSwift</code>, <code>CoreData</code> and <code>Zip</code>. As attachment screenshot when this leak appearing. Any suggestions how can I fix it up?</p>

<p><a href=""https://i.stack.imgur.com/DUFMO.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DUFMO.png"" alt=""enter image description here""></a></p>
","5692398","","43832","","2017-03-24 21:13:54","2017-03-24 21:13:54","NSMutableArray Leak, how to avoid them?","<ios><swift><memory-leaks><rx-swift>","0","3","","","","CC BY-SA 3.0"
"43007909","1","43079127","","2017-03-24 19:43:54","","2","4269","<p>Here is my code snippet:</p>

<pre><code>class ProductCategoryCell: UITableViewCell {

  @IBOutlet weak var collectionViewProducts: UICollectionView!

  // other stuff...

  func setProducts() {
    let productsObservable = Observable.just([
      Product(name: ""test"", price: 10.0),
      Product(name: ""test"", price: 10.0),
      Product(name: ""test"", price: 10.0)
    ])

    productsObservable.bindTo(collectionViewProducts.rx.items(cellIdentifier: ""ProductCell"", cellType: ProductCell.self)) {
      (row, element, cell) in
      cell.setProduct(element)
    }.disposed(by: disposeBag)
  }
}
</code></pre>

<p>It is giving me a build error:</p>

<blockquote>
  <p>No 'items' candidates produce the expected contextual result type '(Observable&lt;[Product]>) -> (_) -> _'</p>
</blockquote>

<p>In my view controller, I am populating table view with a similar code:</p>

<pre><code>let productsObservable = Observable.just(testProducts)
productsObservable.bindTo(tableViewProducts.rx.items(cellIdentifier: ""ProductCategoryCell"", cellType: ProductCategoryCell.self)) { (row, element, cell) in
        cell.setCategory(category: element)
}.disposed(by: disposeBag)
</code></pre>

<p>This code works normally for. What am I doing wrong?</p>
","816116","","","","","2017-03-28 20:16:37","No 'items' candidates produce the expected contextual result type '(Observable<[Product]>) -> (_) -> _'","<swift><uicollectionview><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"43012483","1","","","2017-03-25 04:20:31","","0","83","<pre><code>Observable.of(""A"", ""B"", ""C"").subscribe{  print(""test"", $0)  } // run 4 times
</code></pre>

<p>--- output:</p>

<blockquote>
  <p>test next(A) test next(B) test next(C) test completed</p>
</blockquote>

<p>but the code:  why run only 1  times </p>

<pre><code>  Observable.of(""A"", ""B"", ""C"").subscribe{   print(""test"")   }  
</code></pre>

<p>--- output</p>

<blockquote>
  <p>test</p>
</blockquote>
","7765143","","2482410","","2017-03-25 15:57:45","2017-03-25 15:57:45","why the rxswift run only 1 times","<rx-swift>","0","2","","","","CC BY-SA 3.0"
"43015448","1","","","2017-03-25 10:49:47","","4","2223","<p>I have a view controller with UITableView. The table data is populated using RxSwift:</p>

<pre><code>let observable = Observable.just(data)
observable.bindTo(tableView.rx.items(cellIdentifier: ""CategoryCell"", cellType: CategoryCell.self)) { (row, element, cell) in
    cell.setCategory(category: element)
}.disposed(by: disposeBag)

tableView.rx.setDelegate(self).disposed(by: disposeBag)
</code></pre>

<p>and I have the following delegate function:</p>

<pre><code>func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {
    // cell = nil. 
    let cell = tableView.cellForRow(at: indexPath)

    let screenWidth = UIScreen.main.bounds.size.width

    let itemWidth = (screenWidth / 3.0) - 20
    let itemHeight = (itemWidth) / 0.75 + 110

    return itemHeight
}
</code></pre>

<p>I want to access the cell object from inside <code>heightForRowAt</code> but it gives me <code>nil</code>. Is there a way to access the cell here? I have been looking at UITableView+Rx.swift in RxCocoa project but there is no function for this. What other options do I have?</p>

<p><strong>EDIT:</strong> I am trying to achieve the following in my code:</p>

<pre><code>class CategoryCell : UITableViewCell {
     func calculateHeight() {
        let screenWidth = UIScreen.main.bounds.size.width

        let itemWidth = (screenWidth / 3.0) - 20
        let itemHeight = (itemWidth) / 0.75 + 110

        return itemHeight
     }
}

func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {
    // cell = nil. 
    guard let cell : CategoryCell = tableView.cellForRow(at: indexPath) as? CategoryCell {
         return 0.0
    }
    return cell.calculateHeight()
}
</code></pre>
","816116","","816116","","2017-03-25 14:15:43","2017-12-30 03:04:02","RxSwift + UITableViewCell how to get cell object in heightForRowAt","<swift><uitableview><rx-swift><rx-cocoa>","1","9","1","","","CC BY-SA 3.0"
"43029696","1","","","2017-03-26 14:00:32","","3","469","<p>I currently have a <code>UIButton</code> that uses <code>rx.tap</code> function of RxSwift to dismiss a <code>UIVIewController</code></p>

<pre><code>button.rx.tap
        .subscribe(onNext: { [weak self] in
            self?.navigationController?.dismiss(animated: true, completion: nil)
        })
        .disposed(by: disposeBag)
</code></pre>

<p>How can I implement the same function to an <code>ASButtonNode</code> object (from AsyncDisplayKit)</p>

<p>I tried with the below code</p>

<pre><code>buttonNode.rx.tap
        .subscribe(onNext: { [weak self] in
            self?.navigationController?.dismiss(animated: true, completion: nil)
        })
        .disposed(by: disposeBag)
</code></pre>

<p>But I get an error saying <code>Ambiguous reference to member 'tap'</code></p>

<p>Or is there any alternative for this. </p>
","7769632","","","","","2017-03-28 18:23:47","How can I Implement ASButtonNode target using RxSwift","<swift><rx-swift><asyncdisplaykit>","1","1","","","","CC BY-SA 3.0"
"43032682","1","43451895","","2017-03-26 18:13:43","","0","760","<p>While setting up a login view and using Reactive programming for my first time - I am having trouble generating a Signal from my ViewContoller that will alert my <code>observeValues</code> listener in my view with a Bool containing my form validation:</p>

<p><strong>View File</strong></p>

<pre><code>viewModel.outputs.loginSuccess
    .observeValues { [weak self] value in
        print(value)
}
</code></pre>

<p>With my current code <code>loginSuccess</code> is firing every time the email or password text fields are changed (I have <code>.addTarget</code>'s in my View File that update my MutableProperites in My Model View file).  Where I am experiencing trouble is creating a signal for <code>tryLogin</code> that only emits when the login button is pressed, and then maps my form validation ( <code>emailAndPassword.map(isValid)</code> ), which I can respond to in my View File.</p>

<p><strong>Model View File</strong></p>

<pre><code>import ReactiveCocoa
import ReactiveSwift
import Result

public protocol LoginViewModelInputs {

    /// String value of email textfield text
    func emailChanged(_ email: String?)

    /// String value of password textfield text
    func passwordChanged(_ password: String?)

    /// Call when login button is pressed.
    func loginButtonTapped()
}

public protocol LoginViewModelOutputs {

    /// Emits on login.
    var loginSuccess: Signal&lt;(Bool), NoError&gt; { get }
}

public protocol LoginViewModelType {
    var inputs: LoginViewModelInputs { get }
    var outputs: LoginViewModelOutputs { get }
}

public final class LoginViewModel: LoginViewModelType, LoginViewModelInputs,     LoginViewModelOutputs {

    public init() {

        let emailAndPassword = Signal.combineLatest(
            self.emailChangedProperty.signal.skipNil(),
            self.passwordChangedProperty.signal.skipNil()
        )

        let tryLogin = loginButtonTappedProperty.map {
            emailAndPassword.map(isValid)
        }

        self.loginSuccess = tryLogin.value
    }

    fileprivate let emailChangedProperty = MutableProperty&lt;String?&gt;(nil)
    public func emailChanged(_ email: String?) {
        self.emailChangedProperty.value = email
    }
    fileprivate let loginButtonTappedProperty = MutableProperty()
    public func loginButtonTapped() {
        self.loginButtonTappedProperty.value = ()
    }
    fileprivate let passwordChangedProperty = MutableProperty&lt;String?&gt;(nil)
    public func passwordChanged(_ password: String?) {
        self.passwordChangedProperty.value = password
    }

    public let loginSuccess: Signal&lt;(Bool), NoError&gt;

    public var inputs: LoginViewModelInputs { return self }
    public var outputs: LoginViewModelOutputs { return self }
}

func isValid(email: String, password: String) -&gt; Bool {
    return !email.characters.isEmpty &amp;&amp; !password.characters.isEmpty
}
</code></pre>

<p>Any help is appreciated.  I haven't found much good documentation to learn about Signals or Observers, but it's possible I haven't been looking in the right places.</p>
","5314477","","790877","","2017-03-28 18:59:36","2017-04-17 12:51:58","Reacting to a Signal in MVVM?","<swift><mvvm><reactive-programming><reactive-cocoa><rx-swift>","2","0","","","","CC BY-SA 3.0"
"43063208","1","","","2017-03-28 07:28:47","","0","288","<p>I am attempting to integrate this library with my RxSwift project, <a href=""https://github.com/glenyi/FloatRatingView"" rel=""nofollow noreferrer"">https://github.com/glenyi/FloatRatingView</a></p>

<p>I am unable to get the updated rating.
Here is how I have created the FloatRatingView in the <strong>Controller</strong>,</p>

<pre><code>let starRater : FloatRatingView = {
let floatRatingView = FloatRatingView()
floatRatingView.emptyImage = UIImage(named: ""EmptyStar"")
return floatRatingView
}()
</code></pre>

<p>The <strong>Model</strong> contains the following,</p>

<pre><code>let my_rating = Variable&lt;Float?&gt;(nil)
</code></pre>

<p>What I want to be able to do is to update the value in the <code>my_rating</code> variable when a user changes the rating by tapping on a star. Here is what I've written for this,</p>

<pre><code>_ = starRater.rx.rating
   .asObservable()
   .bindTo(viewModel.my_rating.rx_value)
</code></pre>

<p>But here is the error I'm receiving.</p>

<blockquote>
  <p>Value of type 'Reactive FloatRatingView' has no member 'rating'</p>
</blockquote>

<p>Here is how I will retrieve the value from <code>my_rating</code> variable,</p>

<pre><code>let stars = self.my_rating.value
</code></pre>

<p>Kindly help me out. Thanks.</p>
","4008392","","","","","2017-03-28 23:56:10","How to bind FloatRatingView rating to variable using RxSwift","<rx-swift>","1","0","","","","CC BY-SA 3.0"
"43065527","1","43065887","","2017-03-28 09:18:54","","0","2981","<p>If a function returns an Observable.empty(), what i will get after doing a Observable.zip of this value? The problem is that i always want to execute the code inside Observable.zip and since source2() can fail, i do a catchError and then return an empty observable. But i'm unsure if the zip still will call the block with this approax.</p>

<pre><code> func source1() -&gt; Observable&lt;String&gt; {
  return Observable.just(""test"")
}

func source2() -&gt; Observable&lt;Int&gt; {
  return anObservableThatCanFail()
  .catchError { error -&gt; Observable&lt;Int&gt; 
       return Observable.empty()
  }
}

func myFunc() {
    Observable.zip(source1(), source2()) { string, integer 
   //this will be called despite source2() do a empty()? 
   //and if so, what integer contains?
}
</code></pre>
","588125","","","","","2017-03-28 09:34:44","Observable.empty what returns inside a zip?","<ios><swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"43081588","1","","","2017-03-28 23:19:23","","1","87","<p>I'm trying to make a code verification screen. You probably saw it in every app, that requires phone or SMS verification.</p>

<p>The main concern for me is how to set limited available characters for the user to type in the text field.</p>

<p>I'm using reactive Swift, and here is what I came to:</p>

<ol>
<li>Created an observable variable in my view</li>
<li>The presenter is responsible for checking some symbols; a user gave typed. When this type is becoming equal to 10 (for instance) observable variable receives false signal</li>
<li><p>Delegate method is listening to an observable variable. It is working, but when I reach ten symbols, I can't delete anything. So, my return button on keyboard becomes disabled.</p>

<pre><code>func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool {
    return isButtonHidden.value
}
</code></pre></li>
</ol>

<p><a href=""https://i.stack.imgur.com/hhMox.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hhMox.jpg"" alt=""enter image description here""></a></p>

<p>However, I still think it is not the ""best practice"".
What can you recommend in that case?</p>
","6693247","","1579262","","2017-03-29 00:52:25","2017-03-29 00:52:25","How to create textfield with limited amount of symbols to input","<ios><swift><rx-swift><reactive-swift><swiftbond>","0","1","","2017-03-29 23:04:45","","CC BY-SA 3.0"
"43096832","1","43112639","","2017-03-29 14:44:54","","0","121","<p>In RxSwift, do you know why I am not getting any values in this tableView?<br>
Note: allTable is the UITableView</p>

<pre><code>    var strList: Variable&lt;[String]&gt;?

    let disposeBag: DisposeBag = DisposeBag()

    strList?.value.append(""111"")
    strList?.value.append(""222"")
    strList?.value.append(""333"")

    strList?.asObservable()
        .bindTo(
            allTable.rx.items(cellIdentifier: ""Cell"", cellType: UITableViewCell.self)
        ){  (row, item, cell) in
            cell.textLabel?.text = item
        }
        .addDisposableTo(disposeBag)
</code></pre>
","699215","","","","","2017-03-30 08:40:01","RxSwift Binding to UITable from a Variable","<rx-swift>","1","4","","","","CC BY-SA 3.0"
"43097002","1","43108946","","2017-03-29 14:51:02","","1","1997","<p>I'm trying to make chat services chain with RxSwift.
Basically it should do:</p>

<ul>
<li>Check if chat has id, if yes go to next, if no flatMap to createChat Service</li>
<li>Check if sockect connection is Enabled</li>
<li>Send Chat Message</li>
</ul>

<p>Basically function below works, but it is not checking socket connection status for now. 
It should check before second flatMap if sockets are connected, if yes it should go to flatMap with messageUpload if not it should wait until connection returns true. 
I have Variable with is telling me about current connection status(Bool)</p>

<pre><code>chatSocketService.isSubscribedToChannel.asObservable()
</code></pre>

<p>but I can't figure out how to put them together. 
I tried with third flatMap(before current last one) it doesn't work.
Next problem is that user can try to send few messages before connection is back so each time he hits sendButton this method is executed, so it should send only last message when connection is back.
Any idea how I can handle that with Rx?</p>

<pre><code>func sendMessage(withBody body: String) {
    guard !body.isEmpty else { return }

    Observable.just(chatModel.value)
        .filter({ $0.product != nil })
        .flatMap({ [unowned self] chatModel -&gt; Observable&lt;ChatModel&gt; in
            if chatModel.id != nil {
                return Observable.just(chatModel)
            } else {
                return self.createChat(withProductModel: chatModel.product!)
            }
        })
        .flatMap({ [unowned self] chatModel -&gt; Observable&lt;ChatMessageModel&gt; in
            return self.chatService.uploadChatMessage(forChat: chatModel, withBody: body)
                    .trackActivity(self.progressHelper.activityIndicator)
        })
        .subscribe(onNext: { [unowned self] chatMessageModel in
            self.finishedSendingMessage.onNext(())
        })
        .addDisposableTo(disposeBag)
}
</code></pre>
","4316905","","","","","2017-03-30 05:03:30","RxSwift - How to retry when an observable changes but emit only last value?","<swift><reactive-programming><reactive-cocoa><rx-swift>","1","0","","","","CC BY-SA 3.0"
"43097102","1","43140373","","2017-03-29 14:54:47","","27","25840","<p>I'm the first time to ask a question，I'm learning RxSwift, how to use bind to and driver, what's the difference between of driver and bind to.Anyone else learning RxSwift now.If you are learning RxSwift or Swift or OC,i hope we can be friends and learn from each other.</p>
","5813637","","","","","2018-10-09 19:45:39","use RxSwift, driver and bind to","<rx-swift>","2","1","4","2017-06-18 18:57:41","","CC BY-SA 3.0"
"43114155","1","","","2017-03-30 09:46:22","","3","4485","<p>Hi I am trying to make a UIRefreshControl work with RxSwift. Therefore I am using the <a href=""https://github.com/ReactiveX/RxSwift/blob/83bac6db0cd4f7dd3e706afc6747bd5797ea16ff/RxExample/RxExample/Services/ActivityIndicator.swift"" rel=""nofollow noreferrer"">Activity Indicator</a> that is in the RxSwift Example.</p>

<p>In my viewModel I have the following function and variable to get my data. </p>

<pre><code>// MARK: - Variables

var data = Variable&lt;[Data]&gt;([])

// MARK: - Public Interface

func getData() {
    let request = Data.readAll()
    _ = request.rxResult().subscribe(onNext: { response in
        self.data.value = response.data
    }, onError: { (Error) in
    }, onCompleted: {
    }, onDisposed: {
    })
}
</code></pre>

<p>Then in my view controller I try to bind it to the UIRefreshcontrol and the collection view I have. </p>

<pre><code>let refresher: UIRefreshControl = UIRefreshControl()
let indicator = ActivityIndicator()

    indicator.asObservable()
    .bindTo(refresher.rx.isRefreshing)
    .addDisposableTo(disposeBag)

    let resultObservable = viewModel.data.asObservable()
        .trackActivity(indicator)
        .bindTo(self.collectionView.rx.items(cellIdentifier: reuseCell, cellType: DataCollectionViewCell.self)) {
            row, data, cell in
            cell.configureCell(with: data)
        }
    resultObservable.addDisposableTo(disposeBag)
</code></pre>

<p>My question is, what am I missing to make this work? Right now if I start the app nothing happens except a black activity indicator that doesn't stop spinning. </p>
","1453253","","","","","2018-02-26 02:09:16","UIRefreshControl with RxSwift","<swift><rx-swift><rx-cocoa>","2","2","","","","CC BY-SA 3.0"
"43116196","1","43117540","","2017-03-30 11:11:39","","7","7955","<p>I am using RxSwift for TableView.I need to calculate height of dynamic cells previously I did it in WillDisplayCell delegate method. I don't know how to bind TableView Delegate methods with RxSwift. Can any one help?</p>
","7738524","","","","","2018-06-27 19:44:12","TabelView Delegate methods using RxSwift","<ios><swift3><rx-swift><rx-cocoa>","2","6","1","","","CC BY-SA 3.0"
"43134662","1","","","2017-03-31 07:13:53","","3","2684","<p>I'm new to RxSwift. I need to ask how can I bind textField delegate methods using RxSwift like textFieldShouldReturn or textViewDidBeginEditing.  </p>
","7738524","","","","","2020-05-31 07:28:54","RxSwift Text field Delegate Methods","<ios><swift3><rx-swift>","4","0","1","","","CC BY-SA 3.0"
"43138125","1","","","2017-03-31 10:12:23","","0","159","<p>I want to create a list of planet in a separate controller (my <code>PlanetPickerViewController</code>). This controller uses a <code>UITableView</code> to display a given list of <code>Planet</code>. This works fine.</p>

<pre><code>public class PlanetPickerViewController: RxViewController {

    // MARK: - PUBLIC -

    public var selection: ControlEvent&lt;Planet&gt;!

    public init(list: Driver&lt;[Planet]&gt;, active: Planet?) {
        self.list = list
        self.active = active
        super.init(nibName: ""PlanetPickerViewController"", bundle: nil)
    }

    @available(*, unavailable)
    required public init?(coder aDecoder: NSCoder) { fatalError(""init(coder:) has not been implemented"") }

    // MARK: - PRIVATE -

    private let list: Driver&lt;[Planet]&gt;
    private let active: Planet?

    // MARK: IBOutlets

    @IBOutlet private weak var tableView: UITableView!

    // MARK: View life cycle

    override public func viewDidLoad() {
        super.viewDidLoad()
        self.initializeTableView()
    }

    private func initializeTableView() {
        self.list.drive(self.tableView.rx.items(reusable: PlanetTableViewCell.self)) { row, planet, cell in
            cell.display(planet)
            cell.isSelected = planet == self.active
        }
        .disposed(by: self)

        self.selection = self.tableView.rx.modelSelected(Planet.self)
    }
}
</code></pre>

<p>Now I want to forward the event of the user tapping a cell. Usually, I'd create a <code>PlanetPickerViewControllerDelegate</code> with a dedicated function to manually forward this event:</p>

<pre><code>// PlanetPickerViewControllerDelegate
picker(_ picker: PlanetPickerViewController, didSelect planet: Planet)

// PlanetPickerViewController: UITableViewDelegate
func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
    let planet = self.list[indexPath.row]
    self.delegate?.picker(self, didSelect: planet)
}
</code></pre>

<p>But with RxSwift I want to replace this delegate by a <code>ControlEvent&lt;Planet&gt;</code>. This is what I intended with <code>public var selection: ControlEvent&lt;Planet&gt;!</code>. The bad thing is I can't subscribe to it before <code>viewDidLoad</code> occurs...</p>

<p>What should I change to be able to subscribe to my <code>selection</code> as soon as this controller is instantiated ?</p>

<pre><code>let modal = PlanetPickerViewController(list: planets, active: nil)
modal.selection.subscribe { do something }
self.present(modal, animated: true, completion: nil)
</code></pre>
","3769338","","","","","2017-04-02 03:28:53","Forward ControlEvent from UITableView","<ios><swift><uitableview><rx-swift>","1","0","","","","CC BY-SA 3.0"
"43179944","1","","","2017-04-03 08:33:25","","3","1075","<p>I'm trying to leverage RxSwift in my app. One of the use cases is an async loading of an image UITableView which is triggered by a search button (or recycling of the cell). What I can't get to work well is discarding previous results.</p>

<p>It's important for me to keep a correct loading order, as well as being able to discard network requests for unneeded images</p>

<blockquote>
  <p>I'm working on RxSwift, but this could apply to RxJava and Android RecyclerView</p>
</blockquote>

<p>A pseudo code of the current state is:</p>

<pre><code>myModel
  .searchString
  .debounce(0.3)
  .distinctUntilChanged()
  .flatMapLatest({ return fetchImageUrlsFromNetwork($0) })
  .bindTo(tableView.rx.items) { (url,cell,...) in
     reactivelyLoadUrl(url)
        .subscribe({ cell.imageView.image = UIImage(data:$0) })
  }
</code></pre>

<p>The problem in the code, of course, is the lack of connection between the cell observable and the outer observable, which I know is a bad practice,</p>

<p>but I'm not sure how to use the RxCocoa bindings for UITableView with combination of the cell async loading. The fact that the internals of the tableview use load when scrolling and recycling of cells also adds some complexities to this scenario.</p>

<p>It's also important that I wouldn't have to load all tableview data beforehand and therefore display all cells images at the same time.</p>

<p>I was thinking about maybe creating a global observable per tableview index so when it is required by the UI engine (either triggered by recycling or by search engine result callback) the request would go into a sequence which is applied with the <code>flatMapLatest</code> operator and thus the loading would preserve order per cell, but it's not so elegant.</p>

<p>The result is that if I run quickly several search queries, I can see previous image loadings overriding new ones sometimes.</p>
","2870566","","2870566","","2017-04-03 08:40:17","2017-06-21 09:46:37","Async loading of UITableView cells with RxSwift","<android><ios><rx-java><rx-swift><reactivex>","1","0","1","","","CC BY-SA 3.0"
"43201923","1","","","2017-04-04 08:23:21","","1","2476","<p>I want to check the isSelected state of some UIButtons in order to feed the isEnabled state of another button. I wanted the latter button enabled only when one of the other buttons isSelected state is set to true.
However I saw that you have chosen to keep the isSelected property only as an Observer.</p>

<pre><code>@IBAction func checkBoxButtonTaped(sender: UIButton) {
    sender.rx.isSelected.onNext(!sender.isSelected)
}
</code></pre>

<p>Or</p>

<pre><code>@IBAction func checkBoxButtonTaped(sender: UIButton) {
    sender.isSelected = !sender.isSelected
}
</code></pre>

<p>Observable Code:</p>

<pre><code>let state = Observable.just(true)
state.bindTo(checkBoxButton.rx.isSelected)
    .disposed(by: disposeBag)
state.bindTo(loginButton.rx.isEnabled)
    .disposed(by: disposeBag)
</code></pre>

<p>By two code snippets, Observable can't work.</p>
","7812902","","8201581","","2019-06-01 07:55:45","2019-06-01 07:55:45","UIButton.isSelected can't Observable","<ios><swift><swift3><uibutton><rx-swift>","3","2","","","","CC BY-SA 3.0"
"43206862","1","","","2017-04-04 12:09:49","","9","17476","<p>I am subscribing 2 times for 1 UIButton :</p>

<ol>
<li>First subscription, for updating UI on every click</li>
<li>Second subscription, for updating the values on Web Service every 1 second after accumulated clicks.</li>
</ol>

<p><strong>Code:</strong> </p>

<pre><code>class ProductionSize {
    var id : Int?
    var size: Int = 0
    var name: String = """"
}

class ProductionCell: UICollectionViewCell {
    var rxBag = DisposeBag()


    // this will be set in the (cellForItemAt indexPath: IndexPath) of collection view
    var productionSize: ProductionSize? {
        didSet {
            showProductionSize()
            prepareButton()
        }
    }

    func showProductionSize() {
        // ... code for showing ProductionSize in labels
    }

    func prepareButton() {
        // This for subscribing for every click for displaying purpose

        btn_increase.rx.tap
            .subscribe(){event in 
                self.increaseClicked() 
            }
            .addDisposableTo(rxBag)

        // this for subscribing for sending webservice request after 1 second of clicking the button (so that if user click it quickly i send only last request)

        btn_increase.rx.tap
            .debounce(1.0, scheduler: MainScheduler.instance)
            .subscribe(){ event in self.updateOnWS() }
            .addDisposableTo(rxBag)
    }

    func increaseClicked() {
        productionSize.size = productionSize.size + 1
        showProductionSize()
    }

    func updateOnWS() {
        // code for updating on webservice with Moya, RxSwift and Alamofire§
    }


    // when scrolling it gets called to dispose subscribtions
    override func prepareForReuse() {
        rxBag = DisposeBag()
    }

}
</code></pre>

<p><strong>The problem:</strong></p>

<p>Since the dispose happens on <code>prepareForReuse()</code>, If i click on the button many times and scroll immediately, the webservice calls gets disposed and not updated.</p>

<p><strong>what I have tried:</strong></p>

<ol>
<li><p>Added <code>addDisposableTo(vc?.rx_disposableBag)</code> to the parent ViewController DisposableBag.</p>

<p><em>The problem</em>, the subscribtions accumulated and on every click the <code>updateWS()</code> called many times which is subscribed on every scroll and never disposed.</p></li>
<li><p>I have tried to remove the disposableBag re-initialization from <code>prepareForReuse()</code>.</p>

<p><em>The problem</em>, Again the subscriptions to the buttons getting duplicated and accumulated and many webservice calls get called every click.</p></li>
</ol>

<p><strong>Question:</strong>
How can I get the <code>debounce</code> subscriptions called to the end and never repeated with multiple subscriptions (in case of <code>addDisposableTo</code> viewController Bag) ?</p>
","2296787","","","","","2017-04-11 15:33:54","issue with having rx.tap for UIButton in UICollectionViewCell - RxSwift 3","<ios><swift3><reactive-programming><rx-swift><rx-cocoa>","2","5","3","","","CC BY-SA 3.0"
"43227025","1","43256221","","2017-04-05 09:23:13","","2","2200","<p>I'm trying to grasp RxSwift, I need to validate form, I have done simple validation without tableView, but now my text input fields are in collection view and i want to observe changes in text inputs, as textfields are now in reusable cell, i'm not sure how to add observables and get stream from them</p>

<p>Basically I want 2 way binding of my data to my form where inputs are dynamic, if that helps</p>

<p>here is code of my cellForItemAt function</p>

<pre><code>func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {
    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: RegisterCell.identifier, for: indexPath) as! RegisterCell
    var registerField = dataSource[indexPath.item]
    registerField.indexPath = indexPath
    registerField.text = viewModel.getText(indexPath: indexPath)
    let txt = cell.txtfield as UITextField
    txt.delegate = self
    cell.configureCell(registerField)
    return cell
}
</code></pre>

<p>and configure cell</p>

<pre><code>func configureCell(_ fieldData: RegisterFields) {
    txtfield.placeholder = fieldData.placeholderText
    txtfield.isSecureTextEntry = fieldData.isSecureEntry
    txtfield.text = fieldData.text
    txtfield.tag = fieldData.indexPath.item
    imgIcon.image  = fieldData.image
    imgDropDown.isHidden = !fieldData.isDropDown
}
</code></pre>

<p>I want to use Rx for user inputs instead of delegate pattern as done in following line</p>

<blockquote>
  <p>txt.delegate = self</p>
</blockquote>

<p>Following is image of my screen </p>

<p><a href=""https://i.stack.imgur.com/iDVQl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/iDVQl.png"" alt=""enter image description here""></a></p>
","2404859","","2404859","","2017-04-05 12:33:56","2017-04-06 13:10:59","RxSwift with CollectionView/TableView Input/ textfields","<ios><swift><rx-swift>","1","8","0","","","CC BY-SA 3.0"
"43236896","1","","","2017-04-05 16:35:42","","0","317","<p>I'm using RxAlamorefire to handle network task in my app.</p>

<p>My problem is: When I make a request and it return json. If json has a key ""error"" I need emit error notification instead of onNext notification.</p>

<p>My code is like this one:</p>

<pre><code>let observable = RxAlamofire.json(.get, url, parameters: nil, encoding: URLEncoding.default, headers: header)
.map { (json) -&gt; SomeObject? in
//Should check json maybe not in "".map"" to see if the json contain ""error"" then emit onError notification.
return Mapper&lt;SomeObject&gt;().map(JSONObject: json)
}
</code></pre>
","3806992","","1173513","","2017-04-06 07:27:23","2017-04-06 07:33:45","How to emit error when get json with key","<rx-swift><rxalamofire>","1","0","","","","CC BY-SA 3.0"
"43236932","1","","","2017-04-05 16:37:46","","2","1377","<p>I'm trying to work with <code>RxAlamofire</code> to wrap a network request result.</p>

<p>My objective is to fire request, handle JSON response and create and Observable that contain either network operation success or any error occur.</p>

<p>In other place I can call the function that create the Observable and subscribe to it and notify user whether it is success or failure with error message.</p>

<p>My implementation is below:</p>

<pre><code>func discoverMovieList(for url: String, withPagg page: Int) -&gt; Observable&lt;Any&gt; {
        let requestUrl = ""\(url)&amp;page=\(page)""

        return RxAlamofire.json(.get, requestUrl)
            .map{ jsonResponse in
                    self.createOrUpdateMoviesList(from: JSON(jsonResponse))
                }
    }
</code></pre>

<p>How can we correct the code and how we call it from other place to notify the result of the process?</p>
","5532616","","472495","","2018-08-04 21:01:59","2018-08-04 21:01:59","Using RxAlamofire to create Observable contain the result of network request","<ios><rx-swift><rxalamofire>","1","2","","","","CC BY-SA 4.0"
"43239830","1","","","2017-04-05 19:17:57","","3","1090","<p>When I try to bind my <code>UITextField</code> which is in my <code>ViewController</code> with variable <code>var location = Variable&lt;String?&gt;("""")</code> which is in my <code>ViewControllerViewModel</code> using <code>rxSwift</code> I recieve an information about memory leak. I do it like bellow:</p>

<blockquote>
  <p>My ViewController</p>
</blockquote>

<pre><code>class ViewController {

    @IBOutlet weak var locationTextField: UITextField!
    var viewControllerViewModel: ViewControllerViewModel?
    lazy var disposeBag = DisposeBag()
    /*
        Another variables etc.
    */

    override func viewDidLoad() {
    super.viewDidLoad()

        bindDataWithViewModel()
    }

    func bindDataWithViewModel() {
        if let viewModel = viewControllerViewModel {
            locationTextField.rx.text.bindTo(viewModel.location).disposed(by: disposeBag) -&gt; // here shows memory leak
        }
    }
}
</code></pre>

<blockquote>
  <p>My ViewControllerViewModel</p>
</blockquote>

<pre><code>class ViewControllerViewModel {

    var location = Variable&lt;String?&gt;("""")
    var infoStruct = InfoStruct()
    lazy var disposeBag = DisposeBag()

    init() {
        initValueObservable()
    }

    func initValueObservable() {
        location.asObservable().subscribe(onNext: { [unowned self] text in
        self.infoStruct.location = text
    }).addDisposableTo(disposeBag)
    }
}
</code></pre>

<p>Do you have any idea why this memory leak creates itself and how can I avoid it?</p>
","5692398","","","","","2017-04-11 03:09:44","memory leak while binding data with rxSwift","<swift><xcode><memory-leaks><instruments><rx-swift>","1","1","1","","","CC BY-SA 3.0"
"43247444","1","43263020","","2017-04-06 06:33:51","","1","1803","<p>I'm working to integrate RxSwift into my project</p>

<p>I have written an async network request which have result is pass on a callback closure. </p>

<p>Here is my network function</p>

<pre><code>func discoverMovies(for url: String, withPage page: Int, success: @escaping(Bool)-&gt;()) {

        let requestUrl = ""\(url)&amp;page=\(page)""

        requestGETURL(requestUrl, success: { (json) in

            self.createOrUpdateMoviesList(from: json)   
            success(true)

        }) { (error) in
            print(""Could not download due to \(error)"")
            success(false)
        }
    }
</code></pre>

<p>My question is how can we register an <code>Observable</code> that observe the result of the network call (either success is true or false) so that we can write additional handle base on the result (additional code will only be execute after the network has completed).</p>
","5532616","","472495","","2018-12-03 20:29:23","2018-12-03 20:29:23","iOS Use RxSwift to track when the async network call has completed","<ios><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"43263187","1","43265971","","2017-04-06 18:33:26","","0","123","<p>I am using RxSwift and I am trying to access individual items inside my subscribe function. But the .subscribe gives me the array of ShoppingList and I want an individual ShoppingList item. </p>

<pre><code>private var disposeBag = DisposeBag()

var shoppingLists :Variable&lt;[ShoppingList]&gt; = Variable([])

override func viewDidLoad() {
    super.viewDidLoad()

    // add to the shoppinglist
    let shoppingList = ShoppingList(title: ""Walmart"")
    self.shoppingLists.value.append(shoppingList)


    shoppingLists.asObservable()
       .subscribe { shoppingLists in

            // how to access the item inside the shoppingList // Walmart

            print(""subscribe"")
            print(shoppingLists)
        }
        .addDisposableTo(disposeBag)


}
</code></pre>
","810815","","","","","2017-04-06 21:20:58","Accessing Item Inside RxSwift","<ios><rx-swift>","1","0","","","","CC BY-SA 3.0"
"43266439","1","","","2017-04-06 21:57:49","","6","1635","<p>I have the following code and it DOES not call the Tap event. </p>

<pre><code>  self.addNewItemBarButton.rx.tap.subscribe {
            print(""button is clicked"") // NOT GETTING CALLED!
        }.addDisposableTo(disposeBag)
</code></pre>

<p>SOLUTION: </p>

<pre><code> self.addNewItemBarButton!.rx.tap.subscribe { _ in
            print(""button is clicked"") // NOW THIS WORKS
        }.addDisposableTo(disposeBag)
</code></pre>
","810815","","810815","","2017-04-06 23:15:19","2017-04-06 23:15:19","RxSwift UIBarButtonItem Tap Event Not Called","<swift><rx-swift>","0","0","","2018-09-06 13:21:50","","CC BY-SA 3.0"
"43283909","1","43284191","","2017-04-07 17:26:13","","1","756","<p>I am working on RxSwift and started creating few basic. I have added new button however with rx_tap subscribe not working for button action. Below is my code, please let me know what I am doing wrong</p>

<pre><code>    let button = UIButton(frame: CGRect(x: 10, y: 66, width: 100, height: 21))
    button.backgroundColor = UIColor.redColor()
    button.setTitle(""Login"", forState: UIControlState.Normal)

    let disposeBag = DisposeBag()
    button.rx_tap
        .subscribe { [weak self] x in
            self!.view.backgroundColor = UIColor.redColor()
    }
    .addDisposableTo(disposeBag)
    self.view.addSubview(button)
</code></pre>
","833605","","484304","","2017-04-07 17:45:05","2017-04-07 17:45:05","RxSwift not working with UIButton","<ios><iphone><rx-swift>","1","0","","","","CC BY-SA 3.0"
"43285884","1","43413167","","2017-04-07 19:38:50","","1","3050","<p>I am trying to recreate a code snippet that basically counts how many times a button was clicked in a row. The code is in RxJS and I am trying to convert it to RxSwift for learning purposes but can't figure out the buffer and throttle part.</p>
<p><a href=""http://jsfiddle.net/staltz/4gGgs/27/"" rel=""nofollow noreferrer"">You can see the js code on jsfiddle</a></p>
<p>Currently I have this</p>
<pre><code>  tapButton.rx.tap      
  .buffer(timeSpan: 0.25, count: 10, scheduler: MainScheduler.instance)
  .map {$0.count}
  .filter { $0 &gt;= 2 }
  .subscribe(onNext: { events in
    print(events)
  }).addDisposableTo(disposeBag)
</code></pre>
<p>And I can't figure out how can I delay until tapping ends and collect all values since the last emission like in the RxJS example.</p>
","4459650","","4459650","","2020-10-16 11:19:31","2020-10-16 11:19:31","RxSwift - How to throttle buffer's time span","<swift><rxjs><rx-swift><reactivex>","1","0","","","","CC BY-SA 4.0"
"43302284","1","43305352","","2017-04-09 02:05:14","","4","6780","<p>I'm building a chain function which the flow is to take result from previous function and loop through each element do some calculation and final return back the original array</p>

<p>I have </p>

<pre><code>func(A) -&gt; Observable&lt;[Object]&gt;
func(B)(Object) -&gt; Observable&lt;Object&gt;
</code></pre>

<p>How do we make the chaining like this?</p>

<pre><code>Observable&lt;[Object]&gt; -&gt; [Observable&lt;Object&gt;] -&gt; Observable&lt;[Object]&gt;
</code></pre>
","5532616","","472495","","2018-07-18 19:19:00","2018-07-18 19:19:00","IOS RxSwift Create Array of Observable from Observable array","<ios><rx-swift>","1","0","4","","","CC BY-SA 4.0"
"43315753","1","43318469","","2017-04-10 05:46:00","","0","890","<p>I have an question about binding:
I have an array of objects of my custom class: Array. Every object can be updated (change his properties value) in bg.
Also I have separated Controller, which take and store one object from list as variable and can update it (object still the same, so in list it will be updated too)</p>

<p>Is there any way to bind all object.property -> UILabels on Controller in way, when property changes automatically call label update?</p>
","4899912","","","","","2017-04-10 09:17:31","RxSwift - Class property's binding","<ios><swift><data-binding><rx-swift>","1","0","","","","CC BY-SA 3.0"
"43321190","1","48021500","","2017-04-10 10:48:20","","1","1938","<p>I am having trouble finding my way around in RxSwift. Like now I need to update a UILabel When a UIButton is pressed. My take on this is:</p>

<ol>
<li>The button needs two emit at det er pressed, and possible map some values two channeling down the stream.</li>
<li>The UILabel needs two subscribe til button.</li>
</ol>

<p>But I can not find any documentation for RxSwift 3.0 or newer?</p>
","699215","","699215","","2017-04-10 11:13:52","2017-12-29 10:57:22","RxSwift 3 documentation driving, binding and actions","<rx-swift>","1","2","","","","CC BY-SA 3.0"
"43323049","1","","","2017-04-10 12:22:32","","3","4407","<p>I used <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Operators.swift"" rel=""nofollow noreferrer"">official two-way-binding solution</a></p>

<pre><code>func &lt;-&gt; &lt;T&gt;(property: ControlProperty&lt;T&gt;, variable: Variable&lt;T&gt;) -&gt; Disposable{
let bindToUIDisposable = variable.asObservable()
    .bindTo(property)

let bindToVariable = property
    .subscribe(onNext: { n in
        variable.value = n
    }, onCompleted:  {
        bindToUIDisposable.dispose()
    })

return Disposables.create(bindToUIDisposable, bindToVariable)
}
</code></pre>

<p>Usage: <code>(textField.rx.text &lt;-&gt; object.property).addDisposableTo(disposeBag)</code></p>

<p>Property definition: <code>var property = Variable&lt;String?&gt;(nil)</code></p>

<ol>
<li>In onNext method all ok and <code>variable</code> changed its value, but my <code>object.property</code> doesn't changed.</li>
<li>Is there any way to set variable current value into ControlProperty inside of &lt;-> method, bcs I need set initial value, before subscribe starts?</li>
</ol>
","4899912","","","","","2019-04-24 11:34:21","RxSwift: Two way binding","<ios><swift><data-binding><rx-swift>","2","0","3","","","CC BY-SA 3.0"
"43323645","1","","","2017-04-10 12:50:24","","13","10185","<p>I need to select the item at specific index in collection view using RxSwift.This method is not working fine. </p>

<pre><code> collectionView.rx.modelSelected(SearchResult.self).subscribe(onNext:{ menuItem in }).addDisposableTo(disposeBag) 
</code></pre>

<p>Can anybody help?</p>
","7738524","","","user7725461","2017-04-10 18:37:11","2020-10-31 10:43:13","How to select CollectionView cell in RxSwift","<ios><swift3><uicollectionview><rx-swift>","2","5","4","","","CC BY-SA 3.0"
"43335581","1","","","2017-04-11 02:03:47","","1","308","<p>The CollectionView cells' separators are not appearing when I populate the Collection View using RxSwift. I'm using RxDataSources instead of the class functions. I believe the function <code>drawSeparatorIfNeeded</code> isn't being called somewhere along the way, is there any workaround for this?</p>

<p>Collection View preparation:</p>

<pre><code>private func prepareCollectionView() {
  styler.cellStyle = .card
  styler.separatorLineHeight = 3.0
  styler.separatorColor = UIColor(hex: ""#eeeeee"")
  styler.shouldHideSeparators = false
  collectionView?.backgroundColor = UIColor(hex: ""#eeeeee"")
  collectionView?.register(MDCCollectionViewTextCell.self, forCellWithReuseIdentifier: ""eventCell"")

  collectionView?.translatesAutoresizingMaskIntoConstraints = false

  collectionView?.topAnchor.constraint(equalTo: navigationBar.bottomAnchor).isActive = true
  collectionView?.leftAnchor.constraint(equalTo: view.leftAnchor).isActive = true
  collectionView?.rightAnchor.constraint(equalTo: view.rightAnchor).isActive = true
  collectionView?.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true

  collectionView?.layoutIfNeeded()
}
</code></pre>

<p>Cell configuration:</p>

<pre><code>dataSource.configureCell = { _, collectionView, indexPath, model in
  let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ""eventCell"", for: indexPath) as! MDCCollectionViewTextCell
  cell.textLabel?.text = model
  cell.backgroundColor = .white
  return cell
}
</code></pre>

<p>Cell binding:</p>

<pre><code>Observable.just(sections)
  .bindTo(collectionView!.rx.items(dataSource: dataSource))
  .addDisposableTo(disposeBag)
</code></pre>

<p>Inspecting the CollectionView in Reveal shows that the separator UIImageView has a height of 0, but when I use vanilla DataSource methods, it works as expected.</p>
","3411592","","3411592","","2017-04-13 01:01:36","2017-04-13 01:01:36","CollectionView cell separators not appearing when using RxSwift","<ios><swift><rx-swift><material-components><rxdatasources>","0","4","","","","CC BY-SA 3.0"
"43384118","1","","","2017-04-13 05:22:01","","0","1091","<p>I am trying to implement dynamic label height in a <code>tableViewCell</code> after clicking show more button label needs to set <code>label.numberOfLines = 0</code>.</p>

<p>Then cell height and label height should increase dynamically.</p>

<p>Here is my code below (when <code>tableView</code> reloads the same label height taking for reused cell)</p>

<pre><code> func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {

 let cell: UITableViewCell = 
 self.tableView.dequeueReusableCell(withIdentifier: 
 ""BTSTableViewCellIdentifier"")! 
    cell.configureWithPost(posts[indexPath.row])
    cell.delegate = self
    return cell
   }

 func tableView(_ tableView: UITableView, heightForRowAt indexPath: 
  IndexPath) -&gt; CGFloat {
    return UITableViewAutomaticDimension
}

func tableView(_ tableView: UITableView, estimatedHeightForRowAt 
 indexPath: IndexPath) -&gt; CGFloat {
    return UITableViewAutomaticDimension
}


func configureWithPost(_ postViewModel: BTSTableCellViewModel) {
    self.postViewModel = postViewModel
    usernameLabel.text = postViewModel.username
    detailtextLabel.numberOfLines = 2
    detailtextLabel.text = postViewModel.textDetail  
}

@IBAction func showmorePressed(_ sender: Any) {
    detailtextLabel.numberOfLines = 0;
         self.tableView.reload()

}
</code></pre>
","7859910","","7859910","","2017-04-14 15:53:12","2017-04-14 15:53:12","Dynamic label and cell height with show more button action","<ios><objective-c><swift3><reactive-cocoa><rx-swift>","2","4","0","","","CC BY-SA 3.0"
"43388005","1","43454757","","2017-04-13 09:08:09","","0","2802","<p>Trying out RxSwift and trying to convert my network calls. I can't seem to display my data in the view because im not sure how I convert my observable to something my views can use. Here's an example of my request:</p>

<pre><code>class SomeService {

    let provider = Provider()
    func getData() -&gt; Observable&lt;[Object]?&gt; { // Returns json
        return provider
            .request(.getSomething())
            .debug()
            .mapArrayOptional(type: Object.self) 
            // Using Moya_Modelmapper map each item in the array
    }

}
</code></pre>

<p>In my view controller I get the data: </p>

<pre><code> let data = Service.getData()
 print(data) ... &lt;Swift.Optional&lt;Swift.Array&lt;MyApp.Item&gt;&gt;&gt;
</code></pre>

<p>I have tried to subscribe to the response to the sequence but I don't know how I actually convert it to something like an array I can use in my view.</p>

<p><strong>UPDATE:</strong> With answer implemented:   </p>

<pre><code>    func itemsObserver() {
        print(""Time to print step 1"") // This gets printed
        data
        .filter { $0 != nil }.map { $0! }
        .subscribe(
            onNext: { objects in
                print(objects as Any) 
                print(""Step 2"") // This does not get executed at all
            },
            onCompleted:{ objects in
                print(objects as Any) // This is ()
                print(""Complete"") // This gets printed
            }
            ).addDisposableTo(disposeBag)
    }
    itemsObserver()
</code></pre>

<p><strong>Console output:</strong> </p>

<pre><code> Time to print step 1
 Service.swift:21 (getData()) -&gt; subscribed
 Service.swift:21 (getData()) -&gt; Event next(Status Code: 200, Data Length: 141)
 Service.swift:21 (getData()) -&gt; Event completed
 Service.swift:21 (getData()) -&gt; isDisposed
 ()
 Complete
</code></pre>
","3418097","","3418097","","2017-04-18 12:10:27","2017-04-18 13:35:33","Binding an RxSwift Observable to an array","<reactive-programming><observable><rx-swift>","1","2","","","","CC BY-SA 3.0"
"43423597","1","43453202","","2017-04-15 07:48:40","","4","4663","<p>I can't manage to get this solution to work: 
<a href=""https://github.com/liuznsn/RxMoyaPaginationNetworking"" rel=""nofollow noreferrer"">https://github.com/liuznsn/RxMoyaPaginationNetworking</a></p>

<p>Maybe someone can tell me where is the mistake. The loading variable never goes to false. I guess the issue is in the request observable, but I can't find out why.</p>

<pre><code>class PaginationNetworkModel&lt;T1: Mappable&gt;: NSObject {

let refreshTrigger = PublishSubject&lt;Void&gt;()
let loadNextPageTrigger = PublishSubject&lt;Void&gt;()
let loading = Variable&lt;Bool&gt;(false)
let elements = Variable&lt;[T1]&gt;([])
var offset:Int = 0
let error = PublishSubject&lt;Swift.Error&gt;()

private let disposeBag = DisposeBag()

override init() {
    super.init()

    let refreshRequest = loading.asObservable()
        .sample(refreshTrigger)
        .flatMap { [unowned self] loading -&gt; Observable&lt;[T1]&gt; in
            if loading {
                return Observable.empty()
            } else {
                return self.loadData(offset: self.offset)
            }
    }

    let nextPageRequest = loading.asObservable()
        .sample(loadNextPageTrigger)
        .flatMap { [unowned self] loading -&gt; Observable&lt;[T1]&gt; in
            if loading {
                return Observable.empty()
            } else {
                self.offset += 1
                return self.loadData(offset: self.offset)
            }
    }

    let request = Observable
        .of(refreshRequest, nextPageRequest)
        .merge()
        .shareReplay(1)

    let response = request.flatMap { events -&gt; Observable&lt;[T1]&gt; in
        request
            .do(onError: { error in
                self.error.onNext(error)
            }).catchError({ error -&gt; Observable&lt;[T1]&gt; in
                Observable.empty()
            })
    }.shareReplay(1)

    Observable
        .combineLatest(request, response, elements.asObservable()) { [unowned self] request, response, elements in
            return self.offset == 0 ? response : elements + response
        }
        .sample(response)
        .bind(to: elements)
        .addDisposableTo(rx_disposeBag)

    Observable
        .of(request.map { _ in true },
            response.map { $0.count == 0 },
            error.map { _ in false }
        )
        .merge()
        .bind(to: loading)
        .addDisposableTo(rx_disposeBag)
}

func loadData(offset: Int) -&gt; Observable&lt;[T1]&gt; {
    return Observable.empty()
}
</code></pre>
","4539869","","3151675","","2017-04-15 12:00:50","2017-04-18 13:33:33","RxSwift pagination","<swift><rx-swift><moya>","2","3","","","","CC BY-SA 3.0"
"43428733","1","43431344","","2017-04-15 16:55:48","","0","407","<p>I have to use Reactive Cocoa or RxSwift in the following code for dynamic label height and dynamic row height.   </p>

<p>Can I use Reactive Cocoa in Swift3? And What is the difference between ReactiveCocoa and RxSwift?</p>

<pre><code>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
    let cell: BTSTableViewCell = self.tableView.dequeueReusableCell(withIdentifier: ""BTSTableViewCellIdentifier"")! as! BTSTableViewCell

    cell.configureWithPost(posts[indexPath.row])
    cell.delegate = self
    return cell

}
func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {

    // 259.5+ labelHeight+ bigImageHeight

    let postViewModel = posts[indexPath.row]

    //caption height
    var captionHeight = postViewModel.textDetail?.height(withConstrainedWidth: tableView.bounds.size.width - 20, font: UIFont.systemFont(ofSize: 17))

    captionHeight = ceil(captionHeight!)

    var finalCaptionHeight: CGFloat = 0.0;

    if postViewModel.showDetailedCaption {
        finalCaptionHeight = captionHeight!
    }
    else {
        finalCaptionHeight = min(41, captionHeight!)
    }
    return 259.5 + postViewModel.getBigImageHeightFor(tableView.bounds.size.width) + finalCaptionHeight

}
</code></pre>
","7859910","","","","","2017-04-15 21:13:22","Can i use ReactiveCocoa in swift 3?","<ios><swift3><reactive-cocoa><rx-swift>","1","2","","","","CC BY-SA 3.0"
"43456187","1","43458734","","2017-04-17 17:20:49","","1","1089","<p><strong>Goal</strong></p>

<p>I am trying to implement a service which downloads a file using the Range header. This allows me to download a chunk of a file at a time. </p>

<p><strong>Implementation - Observable.generate()</strong></p>

<p>In order to create an observable for each request and save the file I have tried using:</p>

<pre><code>let downloadObservable = Observable.generate(initialState: 0, condition: { $0 &lt; fileSize }, iterate: { $0 + self.defaultChunkSize })
</code></pre>

<p>This seems to work great! Except for larger files it seems to have an error. My requests get cancelled. After debugging I found out that my workflow doesn't work how I expected it to. Here is the rest of the workflow which is appended onto the line above.</p>

<pre><code>.map( { (startChunk) -&gt; (Int64, Int64) in
    // I determine the end chunk so I can download any size file in chunks of size X
    let endChunk = (startChunk + self.defaultChunkSize &gt; fileSize ? fileSize : startChunk + self.defaultChunkSize )

    return (startChunk, endChunk)
}).flatMap( { [unowned self] (startChunk: Int64, endChunk: Int64) -&gt; Observable&lt;FileChunk&gt; in
    // I make the request via alamofire - UNEXPECTED FLOW HERE SEE NOTE #1
    return self.makeChunkRequest(url: downloadUrl, startChunk: startChunk, endChunk: endChunk)

}).flatMap( { [unowned self] (fileChunk: FileChunk) -&gt; Observable&lt;FileSaveChunkResult&gt; in
    // Upon receiving chunk response save to file
    return self.saveChunkToFile(fileChunk: fileChunk, location: localDestinationUrl)

}).flatMap( { (saveResult: FileSaveChunkResult) -&gt; Observable&lt;Progress&gt; in
    // Update progress if successful
    switch (saveResult) {
    case .success(let bytesSaved):
        progress.completedUnitCount += bytesSaved
    case .failure:
        break
    }

    return Observable.just(progress)
})
</code></pre>

<p><strong>Note #1</strong></p>

<p>When I run and debug this, my first <code>flatMap</code> loops until <strong>ALL</strong> of the chunk requests are made. I was expecting this to be more sequential where we would generate an observable and then do all of the conversions via <code>flatMap</code> and then loop back to the beginning.</p>

<p>Is this not how I should be implementing it? </p>

<p>Do I need to do some magic with <code>merge()</code> on my <code>Observable.generate()</code>?</p>
","2505444","","","","","2017-04-20 20:48:53","RxSwift - Observable.generate - Handle sequential requests with additional mapping","<ios><swift><reactive-programming><observable><rx-swift>","1","1","","","","CC BY-SA 3.0"
"43464364","1","43476877","","2017-04-18 05:36:14","","1","881","<p>When run in Debug scheme, there is a fatal error in line 30, if you code are something like this.</p>

<p><a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Implementations/Sink.swift"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Implementations/Sink.swift</a></p>

<pre><code>rxFatalError(""Warning: Recursive call or synchronization error!"")
</code></pre>

<p>If I choose run scheme from Debug to Release. The fatal error won't show. But I wonder if I could do something to suppress it.</p>

<pre><code>class ViewController4: UIViewController {
    var v = Variable(0)
    var disposeBag = DisposeBag()
    var notiBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        v.asObservable()
            .subscribe(onNext: { _ in
                let noti = Notification(name: MyNotificationName)
                NotificationCenter.default.post(noti)
            })
            .disposed(by: disposeBag)

        NotificationCenter.default.rx.notification(MyNotificationName)
            .subscribe(onNext: { [unowned self] _ in
                if self.v.value == 10 { self.notiBag = DisposeBag() }
                else { self.v.value += 1 } // this line cause the issue
                print(self.v.value)
                self.counterTextView.text! += ""\(self.v.value)\n""
            })
            .disposed(by: notiBag)
        v.value = 0
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }

    @IBOutlet weak var counterTextView: UITextView!
}

let MyNotificationName = Notification.Name.init(rawValue: ""My Notification Name"")
</code></pre>
","1606231","","1606231","","2017-04-18 23:41:04","2017-04-19 15:29:08","How to suppress a specify error in RxSwift?","<fatal-error><rx-swift><suppress>","3","1","","","","CC BY-SA 3.0"
"43467339","1","43477819","","2017-04-18 08:31:26","","2","3327","<p>Suppose I have observable <code>A</code>, and I am trying to create observable <code>B</code> that emits two events: the first when <code>A</code> emits an event, and the second 5 seconds later.</p>

<p>So far I have the following:</p>

<pre><code>self.B = Observable.create { [unowned self] observer in
            self.A.subscribe(onNext: {
                observer.onNext(0)
                self.delay(5) {
                    observer.onNext(1)
                }
            })
            return Disposables.create()
        }
</code></pre>

<p>This works, but I feel uncomforatble subscribing to <code>A</code> from a closure. Is there a nicer way to do it?</p>

<p>Thanks!</p>
","1596293","","","","","2017-04-18 16:43:56","RxSwift: how to have one observable trigger another one?","<rx-swift>","1","0","","","","CC BY-SA 3.0"
"43473308","1","43473677","","2017-04-18 13:14:45","","0","97","<p>I'm trying to load a downsized <strong>preview</strong> image, followed by a <strong>hires</strong> image. I want to make sure that if by any chance the <strong>hires</strong> image gets loaded first, the <strong>preview</strong> image is discarded.</p>

<p>Consider the following examples, where:</p>

<ul>
<li>Sequence 1 is preview image requests</li>
<li>Sequence 2 is hires image requests</li>
<li>Sequence 3 is the combined sequence</li>
<li>Sequence 4 is the resulting image rendering sequence</li>
</ul>

<p>.</p>

<pre><code>Example 1:

 1    ------P-------
 2    ---------H----

 3    ------P--H----

 4    ------*--*----


Example 2:

 1   ----H---------
 2   --------P-----

 3   ----H|--------

 4   ----*|--------
</code></pre>

<p>The only solution I've come up with so far is saving a state variable which denotes whether the hires has been loaded already and using <code>takeWhile</code>, but this requires some non-elegant manipulations and also involves side effects.</p>

<p>I'm looking for the correct RX way to do so.</p>
","2870566","","","","","2017-04-18 13:30:53","Progressive image loading with ReactiveX","<rxjs><rx-java><rx-swift><reactivex>","1","0","","","","CC BY-SA 3.0"
"43484976","1","","","2017-04-19 01:55:12","","0","1556","<p>So I'm having a problem with updating the height of a <code>UITableViewCell</code> when the text of its label gets changed.</p>

<p>I'm not good at explaining thing, therefore I've created a repo on <a href=""https://github.com/KelvinJin/DynamicSizeCell"" rel=""nofollow noreferrer"">Github</a> so that you can just grab and run. The problem should show up when you scroll up and down the table view (to make the cell reused).</p>

<hr>

<p><strong>What I did was</strong>:</p>

<ul>
<li>I created a table view with self-size cells.</li>
<li>Each of the cells has a <code>UILabel</code> in it.</li>
<li>I have a view model that will decide what's in the UILabel.</li>
<li>I use <code>RxSwift</code> to register the changes in the view model and update the text of the <code>UITable</code> accordingly. </li>
<li>At the same time, the cell will ask its delegate (in this case, the <code>UITableViewController</code>) to recalculate its height.</li>
<li>The delegate will then call <code>tableView.beginUpdates</code> and <code>tableView.endUpdates</code> to update the height of the cell.</li>
</ul>

<p><strong>Results</strong>:</p>

<ul>
<li>When I scroll up the table view so that the first cell gets reused and then scroll down. The content of the first cell is duplicated across the table view (the second cell becomes a duplicate of the first one.)</li>
</ul>

<p><strong>What I tried</strong>:</p>

<ul>
<li>I tried to call <code>tableView.reloadData()</code>. -> Infinite Loop</li>
<li>I tried to call <code>tableView.reloadRows()</code> -> This works but I don't know why.</li>
</ul>

<p>What I want to achieve:</p>

<ul>
<li>I want to keep Rx and MVVM together since I like the way Rx works.</li>
<li>I want to be able to change the label text of the cell and the height of the cell can be updated to fit the text.</li>
</ul>

<hr>

<p>Some code snippets: (Although it'd better to go check the repo out.):</p>

<p><strong>Cell register view model</strong></p>

<pre><code>override func awakeFromNib() {
    super.awakeFromNib()

    viewModel.title
        .observeOn(MainScheduler.instance)
        .subscribe(onNext: { [weak self] title in
            guard let cell = self else { return }

            cell.label.text = title
            cell.delegate?.requestSizeRecalculate(cell: cell)
        })
        .disposed(by: disposeBag)
}
</code></pre>

<p><strong>Delegate methods in UITableViewController</strong></p>

<pre><code>func requestSizeRecalculate(cell: SimpleCell) {
    print(""Size recalculating...."")

    method1(cell: cell)
    //method2(cell: cell)
    //method3(cell: cell)
}

private func method1(cell: SimpleCell) {
    // Will not cause infinite loop but will have duplicates.
    cell.setNeedsUpdateConstraints()
    tableView.beginUpdates()
    tableView.endUpdates()
}

private func method2(cell: SimpleCell) {
    // Will cause infinite loop
    tableView.reloadData()
}

private func method3(cell: SimpleCell) {
    // This method works pretty well.
    if let indexPath = tableView.indexPath(for: cell) {
        tableView.reloadRows(at: [indexPath], with: .none)
    }
}
</code></pre>

<hr>

<p>It's my first time asking questions on Stackoverflow. I know I might have made things more complicated than it should be. But if anyone can offer any suggestions based on your experience, I would appreciate very much!</p>
","5978321","","","","","2017-04-19 05:28:44","Recalculate the height of the UITableViewCell when the text of the label changes","<ios><uitableview><tableviewcell><rx-swift>","2","0","","","","CC BY-SA 3.0"
"43486597","1","44383131","","2017-04-19 04:46:10","","8","8440","<p>I want to convert the below code into <code>RxSwift</code>. And also please help me how to write button <code>Action</code> code in <code>RxSwift</code>.</p>

<p><code>ReactiveCocoa</code> or <code>RxSwift</code> Which one is better to use in swift3?</p>

<pre><code>func tableView(_ tableView: UITableView, numberOfRowsInSection section: 
Int) -&gt; Int {
    return posts.count
}
func tableView(_ tableView: UITableView, cellForRowAt indexPath: 
IndexPath) -&gt; UITableViewCell {
    let cell: BTSTableViewCell = self.tableView.dequeueReusableCell(withIdentifier: ""BTSTableViewCellIdentifier"")! as! BTSTableViewCell

    cell.configureWithPost(posts[indexPath.row])
    cell.delegate = self
    return cell

}
func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {

    // 259.5+ labelHeight+ bigImageHeight

    let postViewModel = posts[indexPath.row]

    //caption height
    var captionHeight = postViewModel.textDetail?.height(withConstrainedWidth: tableView.bounds.size.width - 20, font: UIFont.systemFont(ofSize: 17))

    captionHeight = ceil(captionHeight!)

    var finalCaptionHeight: CGFloat = 0.0;

   if postViewModel.showDetailedCaption {
        finalCaptionHeight = captionHeight!
    }
    else {
        finalCaptionHeight = min(41, captionHeight!)
    }
    return 259.5 + 
 postViewModel.getBigImageHeightFor(tableView.bounds.size.width) + 
 finalCaptionHeight

}
</code></pre>
","7859910","","1602514","","2017-04-19 10:06:37","2019-04-21 04:07:18","How to write height for row in RxSwift?","<ios><swift3><reactive-cocoa><rx-swift>","3","0","1","","","CC BY-SA 3.0"
"43487616","1","","","2017-04-19 06:02:35","","0","591","<p>I added RxSwift library to my project.But when i tried to run the app then i always got compiler error like <strong>Use of unresolved identifier 'Materialize'</strong>.This error occurs in the  <strong>Observable+Single.swift</strong> class.The error occurs method mentioned below.Please help me how to solve this issue.</p>

<pre><code>extension ObservableType {
     public func materialize() -&gt; Observable&lt;Event&lt;E&gt;&gt; {
        return Materialize(source: self.asObservable())
    }
}

extension ObservableType where E: EventConvertible {
       public func dematerialize() -&gt; Observable&lt;E.ElementType&gt; {
        return Dematerialize(source: self.asObservable())
    }
}
</code></pre>
","1980105","","1980105","","2017-04-20 04:34:22","2017-04-20 04:34:22","Compiler Error RxSwift: Use of unresolved identifier 'Materialize'","<ios><iphone><xcode><swift3><rx-swift>","1","0","","","","CC BY-SA 3.0"
"43496270","1","","","2017-04-19 12:50:14","","3","418","<p>I've inherited some Swift 3 code which uses RxSwift to manage a store. The basic layout of the class is:</p>

<pre><code>class UserActivityStore {
    fileprivate lazy var internalDataCache: Variable&lt;Set&lt;NSUserActivity&gt;?&gt; = Variable(nil)

    func addAction(_ actionToAdd: NSUserActivity) {
        var content = internalDataCache.value ?? Set&lt;NSUserActivity&gt;()
        content.insert(actionToAdd)
        internalDataCache.value = content
    }

    func resolveAction(_ action: NSUserActivity) {
        var content = internalDataCache.value
        _ = content?.remove(action)
        internalDataCache.value = content
    }

    func expectActions(_ filter: @escaping ((NSUserActivity) -&gt; Bool)) -&gt; Observable&lt;NSUserActivity&gt; {
        let observable = Observable&lt;NSUserActivity&gt;.create { (observer) -&gt; Disposable in
            return self.internalDataCache.asObservable().subscribeNext { (newActions) in
                guard let newActions = newActions else { return }
                for eachAction in newActions where filter(eachAction) {
                    observer.onNext(eachAction)
                    self.resolveAction(eachAction)
                }
            }
        }
        return observable
    }
}
</code></pre>

<p>When an action is added to this, it adds the item to the set correctly. However, the observer (in <code>expectActions</code>) catches that change and resolves it. Since this is all in a single thread, the error ""Warning: Recursive call or synchronization error!"" is triggered. </p>

<p>I think this is a perfectly legitimate error and that RxSwift is probably correct in its handling. However, I can't help thinking that this is a bad model. The code is essentially handling a queue of <code>NSUserActivity</code> objects itself. </p>

<p>Is this genuinely a modelling error / abuse of RxSwift or is my limited understanding of RxSwift misunderstanding this? As a hacky solution, I've tried replacing the <code>resolveAction</code> function with a single line <code>internalDataCache.value?.remove(action)</code> but that still triggers the observable and hence the bug. </p>

<p>Changing the observable to use a different queue (Serial or Concurrent dispatch) fixes the problem but I'm not convinced its the correct fix.</p>
","198400","","","","","2017-04-19 19:59:12","RxSwift state changes trigger ""Warning: Recursive call or synchronization error!""","<swift><rx-swift>","0","2","","","","CC BY-SA 3.0"
"43500336","1","43500661","","2017-04-19 15:42:32","","23","6942","<p>See below code.</p>

<pre><code>class ViewController4: UIViewController {
    var disposeBag = DisposeBag()
    let v = Variable(0)

    override func viewDidLoad() {
        super.viewDidLoad()

        v.asObservable()
            .subscribe(onNext: { print($0) })
            .disposed(by: disposeBag)

        v.value = 1
    }
}
</code></pre>

<p>When it runs, it will print</p>

<pre><code>0
1
</code></pre>

<p>However, I don't want it to run on <code>0</code>, or saying <code>0</code> is just the value used to initiate <code>v</code>. Can I do that? Or I have to postpone the code at the time point when I use it?</p>
","1606231","","","","","2017-04-19 16:03:14","Is there a way to not trigger the init value of the Variable<T>?","<rx-swift>","1","0","","","","CC BY-SA 3.0"
"43526733","1","43551733","","2017-04-20 18:02:51","","1","780","<p><strong>Background</strong></p>

<p>I am trying to implement downloading a file via chunks using the <code>Range</code> header. </p>

<p><strong>Goal</strong></p>

<p>I would like to take a large sequence of http requests into four sequences that I can then concat to process 4 requests at a time.</p>

<p><strong>Current Standing</strong></p>

<p>I am currently taking my sequence and using <code>concat</code> to ensure that the first request observable is completed before I start the second. This was done to ensure that I do not overload Alamofire with too many requests and thus end up with requests that time out.</p>

<p>Ideally I would like to divide my sequence into four fairly equal sequences since Alamofire is set up to handle four connections to the host at a time. I want to do this because I believe it would increase my download speeds.</p>

<p><strong>Downloading File Using Chunks</strong></p>

<pre><code>Observable.generate(initialState: 0, condition: { $0 &lt; fileSize }, iterate: {$0 + self.defaultChunkSize})
    .map( { (startChunk) in
        let endChunk = startChunk + self.defaultChunkSize &gt; fileSize ? fileSize : startChunk + self.defaultChunkSize

        return (startChunk, endChunk)
    })
    .map({ (startChunk: Int, endChunk: Int) -&gt; Observable&lt;FileChunkResult&gt; in
        self.filesClient.downloadChunkOf(fileId: file.id, startChunk: Int64(startChunk), endChunk: Int64(endChunk))
    })

    .concat() // &lt;----- This is where I am forcing the large sequence to do one observable at a time

    .flatMap( { (result: FileChunkResult) -&gt; Observable&lt;FileSaveChunkResult&gt; in
        switch (result) {
        case FileChunkResult.success(let chunkData):
            return self.saveChunkToFile(fileChunk: chunkData, location: urlToSaveTo)
        case FileChunkResult.failure: // Maybe change this to just default and return Observable.just(FileSaveChunkResult.failure)
            break
        case FileChunkResult.parserError:
            break
        }

        return Observable.just(FileSaveChunkResult.failure)
    })
    .flatMap( { (result: FileSaveChunkResult) -&gt; Observable&lt;Progress&gt; in
        switch (result) {
        case FileSaveChunkResult.success(let bytesSaved):
            progress.completedUnitCount += bytesSaved
        case FileSaveChunkResult.failure:
            break
        }

        return Observable.just(progress)
    })
</code></pre>
","2505444","","","","","2017-04-21 21:03:09","RxSwift - Split up sequence into smaller sequences to concat on","<ios><swift><concat><rx-swift>","1","1","","","","CC BY-SA 3.0"
"43544705","1","43545636","","2017-04-21 14:01:09","","0","763","<p>I am working on an <a href=""https://github.com/subash-poudel/RxCocoaTableViewDemo"" rel=""nofollow noreferrer"">open source tutorial</a> using MVVM, Coordinators and RxSwift. I am constructing all the viewcontrollers and models in the coordinator. Controller has a strong reference to viewmodel and when a viewmodel is set, I would like to perform some UI related actions(using property observer didSet). The problem I am facing is that <strong>didSet</strong> is called before <strong>viewDidLoad</strong> causing a crash.</p>

<p>Stripped down version of ViewController:</p>

<pre><code>class MessageVC: UIViewController {
  var viewModel: MessageViewModel! {
    didSet {
      manipulateUI() // crashes
    }
  }

override func viewDidLoad() {
  super.viewDidLoad()
  manipulateUI() // works fine if setup is correct in coordinator
}
</code></pre>

<p>Coordinator stripped down version:</p>

<pre><code>extension AppCoordinator {

convenience init() {
 let rootVC = MessageVC() // actual construction from storyboard
 let messages = Message.getMessages()
 rootVC.viewModel = MessageViewModel(withMessage: messages)
}
</code></pre>

<p>My concern is that even though calling <strong>manipulateUI</strong> in viewDidLoad is working for me currently, the app will crash if I forget to set the viewModel from my co-ordinator making me think that I am using a fragile architecture. I really like updating userinterface from didSet but it is called before viewDidLoad.</p>

<p>I know it is a simple problem but from architecture standpoint it seems fragile. Any suggestions, improvements and comments are appreciated a lot.</p>
","2833783","","","","","2017-04-21 14:51:06","Ensure that property observer didSet manipulates User Interface after viewDidLoad","<ios><swift><mvvm><rx-swift>","2","0","","","","CC BY-SA 3.0"
"43551100","1","","","2017-04-21 20:01:37","","1","1041","<p>I have a method which returns an observable.</p>

<p>In this method I subscribe to <code>rxbluetooth</code> observable. It works well except that <code>onComplete</code> is never called.</p>

<p>Here is my code:</p>

<pre><code>private func getWifiConfig() -&gt; Observable&lt;String?&gt; {

  return Observable.create { [ weak self ] observer in

    if let strongSelf = self {

      tileConnect.peripheral.connect()
        .retry(.delayed(maxCount: 30, time: 1), scheduler: MainScheduler.instance)
        .flatMap { $0.discoverServices([ strongSelf.serviceUUID ]) }
        .flatMap { Observable.from($0) }
        .flatMap { $0.discoverCharacteristics([ strongSelf.wifiCharacteristicUUID ])}
        .flatMap { Observable.from($0) }
        .flatMap { $0.readValue() }
        .retry(.delayed(maxCount: 30, time: 1), scheduler: MainScheduler.instance)
        .subscribe(onNext: {
          if let data = $0.value {
            if let configDelimitedString = String(data: data, encoding: .utf8) {
              observer.onNext(configDelimitedString)
            }
          }
        }, onError: { error in
          LOG_SENSOR_MANAGER(""getWifiConfigFromCharacteristic. onError: \(error.localizedDescription)"")
          observer.onError(error)
        }, onCompleted: {
          LOG_SENSOR_MANAGER(""getWifiConfigFromCharacteristic. onCompleted"")
                        observer.onCompleted() // &lt;---- NEVER CALLED
        }, onDisposed: {
          LOG_SENSOR_MANAGER(""getWifiConfigFromCharacteristic. onDisposed"")  // &lt;---- NEVER CALLED
        })
        .disposed(by: strongSelf.disposeBag)
      }

      return Disposables.create()
    }
  }
</code></pre>

<p>Do you have an idea why?</p>
","66086","","3314107","","2018-01-31 09:40:32","2018-01-31 09:40:32","Creating Observable which wraps observable","<swift><rx-swift><rxiosble>","1","5","","","","CC BY-SA 3.0"
"43559738","1","","","2017-04-22 13:22:12","","0","669","<p>(looking for the best approach to save Realm property.</p>

<p>I have a UIViewController with a lot of TextView, etc that I fill from a Realm object.</p>

<p>Each time the textfield are modified, I need to send back to change un the realm property.</p>

<p>The (not cool) thing, are that I cannot save directly, I have to open a write transaction.</p>

<pre><code>object.propertyA= “hello”    // crash

try! realm.write {      //work
        userBeer?.Name = lblbeerName.text!
}
</code></pre>

<p>So, i found a bit painfull (and not clean) to to that for all text.</p>

<p>I’ve looked at rxRealm, but cannot see any (newbies) sample to make that.</p>

<p>So, I have 2 approach un mind</p>

<ol>
<li><p>Modify the model getters and setters for the property</p>

<p>var beerName: String? {
        get {
            return self.Name
        }
        set  {
            try! realm.write {<br>
            self.txtName=beerName!
        }
    }</p></li>
<li><p>use the RXSwift approach from here (<a href=""https://www.raywenderlich.com/149753/bond-tutorial-bindings-swift"" rel=""nofollow noreferrer"">https://www.raywenderlich.com/149753/bond-tutorial-bindings-swift</a>)</p>

<ul>
<li>Bing the TextField.text to a var String, and observe this string to write.</li>
</ul></li>
</ol>

<p>What do you think?</p>

<p>My perfect world will be to find a way to bing the TextField.text property directly, something like:
myRealmObject.property.BindTo(self.txtName)</p>
","618512","","","","","2017-04-24 13:02:03","Realm, best approach to save\update\Observe String to Realm Object","<swift><realm><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"43588032","1","43590494","","2017-04-24 12:25:00","","0","241","<p>I have been trying to figure out a way to implement such behavior but was not able to come to a working solution.</p>

<p><strong>What I want to achieve</strong></p>

<pre><code>var dataSource = Variable&lt;[T]&gt;([])

var arrayObserver: Observable&lt;SomeType&gt; {

    return dataSource.asObservable()
        .map({ (elementoftype[T]) in

        // do something with it and return element of SomeType
        })
}
</code></pre>

<p>The <code>dataSource</code> variable is fed with values coming in 1 by 1. I want the <code>arrayObserver</code> to be able to buffer / ""hold"" onto the <code>map</code>ping until it has been, say, 0.5 seconds since the <code>dataSource</code> last emitted.</p>

<p>Thanks a lot for your suggestions !</p>
","7530977","","","","","2017-04-24 14:14:47","RxSwift - Emit after not receiving items for X seconds","<ios><swift><reactive-programming><rx-swift><reactivex>","1","0","","","","CC BY-SA 3.0"
"43593777","1","43599745","","2017-04-24 16:53:04","","0","2252","<p>I'm using MVVM pattern and try to show warning labels only when user press the sign in button. Now they don't appear, because I don't know how to show them on user action only. Then warning for the corresponding label should hide while user starts to edit it. 
Here is my ViewController which handle reference to viewModel:</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa
class RxLoginViewController: UIViewController {

    @IBOutlet weak var signInButton: UIButton!
    @IBOutlet weak var phoneNumberTextField: UITextField!
    @IBOutlet weak var passwordTextField: UITextField!
    @IBOutlet weak var phoneWarningLabel: UILabel!
    @IBOutlet weak var passwordWarningLabel: UILabel!

    fileprivate var viewModel: RxLoginViewModel?
    private let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        viewModel = RxLoginViewModel(phoneNumber: phoneNumberTextField.rx.text.orEmpty.asDriver(), passwordText: passwordTextField.rx.text.orEmpty.asDriver())
        addBindsToViewModel(viewModel: viewModel!)
        setupButtons()
    }

    fileprivate func addBindsToViewModel(viewModel: RxLoginViewModel) {
        phoneNumberTextField.rx.text
            .orEmpty
            .asObservable()
            .debug(""phoneNumberTextField"")
            .bindTo(viewModel.phoneNumberText)
            .addDisposableTo(disposeBag)

        passwordTextField.rx.text
            .orEmpty
            .asObservable()
            .debug(""passwordTextField"")
            .bindTo(viewModel.passwordText)
            .addDisposableTo(disposeBag)

        viewModel.showPhoneWarning
            .asDriver()
            .debug(""showPhoneWarning"")
            .drive(onNext: { [weak self] showWarning in
                UIView.animate(withDuration: 0.2) {
                    self?.phoneWarningLabel.isHidden = !showWarning
                }}
            )
            .addDisposableTo(disposeBag)

        viewModel.showPasswordWarning
            .asDriver()
            .debug(""showPasswordWarning"")
            .drive(onNext: { [weak self] showWarning in
                UIView.animate(withDuration: 0.2) {
                    self?.passwordWarningLabel.isHidden = !showWarning
                }
            })
            .addDisposableTo(disposeBag)

        viewModel.credentialsValid
            .debug(""credentialsValid"")
            .drive(onNext: { [weak self] valid in
                self?.signInButton.isEnabled = valid
                self?.signInButton.alpha = valid ? 1 : 0.5
            })
            .addDisposableTo(disposeBag)
    }

    private func setupButtons() {

        signInButton.rx.tap
            .bindTo(viewModel!.signInAction)
            .addDisposableTo(disposeBag)
    }
}
</code></pre>

<p>And ViewModel:</p>

<pre><code>class RxLoginViewModel {
    let dataManager = DataManager.sharedInstance()

    private let disposeBag = DisposeBag()

    //MARK: - Model proprties
    var phoneNumberText = Variable&lt;String&gt;("""")
    var passwordText = Variable&lt;String&gt;("""")
    var signInAction: Variable&lt;Void&gt; = Variable&lt;Void&gt;()

    var showPhoneWarning = Variable(false)
    var showPasswordWarning = Variable(false)
    var credentialsValid: Driver&lt;Bool&gt;
    var canLogIn = Variable(false)

    init(phoneNumber: Driver&lt;String&gt;, passwordText: Driver&lt;String&gt;) {

        let phoneValid = phoneNumber
            .distinctUntilChanged()
            .throttle(0.3)
            .map { ($0 =~ RegEx.phone) }

        let passwordValid = passwordText
            .distinctUntilChanged()
            .throttle(0.3)
            .map { ($0.utf8.count &gt; 5) }

        credentialsValid = Driver.combineLatest(phoneValid, passwordValid) { $0 &amp;&amp; $1 }
        phoneNumber.debug(""phone number driver"")
            .drive(onNext: {_ in self.showPhoneWarning.value = false })
            .addDisposableTo(disposeBag)
        phoneNumber.debug(""password driver"")
            .drive(onNext: {_ in self.showPasswordWarning.value = false })
            .addDisposableTo(disposeBag)

        credentialsValid.asObservable()
            .bindTo(canLogIn)
            .addDisposableTo(disposeBag)

        // actions handler
        signInAction
            .asObservable()
            .debug(""signInAction"")
            .do(onNext: { _ in
                 // show warning for any invalid textfield
                 // filter both valid fields
            } )
            // sent url request
            .subscribe(onNext: { status in

                    self.dataManager.login(withPhone: self.phoneNumberText.value, email: """", password: self.passwordText.value, success: { ( result ) in
                    if let response = result as? [String : Any], response[""aboutMe""] == nil {
                        self.dataManager.currentUser().userId = response[""id""] as? NSNumber
//                        self.dataManager.update(.fillProfile)
                    }
                }, failure: { (error) in
//                    print(error.localizedDescription)

                })
            })
            .addDisposableTo(disposeBag)
}
</code></pre>

<p>What should I do to show warning for any invalid textfield and how to filter both valid fields in my ViewModel? </p>
","5942995","","4312558","","2017-04-24 18:46:55","2017-04-25 00:47:45","RxSwift - Show/hide warning label when button was pressed","<ios><swift><mvvm><reactive-cocoa><rx-swift>","1","0","0","","","CC BY-SA 3.0"
"43612211","1","43622570","","2017-04-25 13:33:57","","2","1652","<p>Disclaimer: i'm a half Rx newbie, so it is very possible that the idea is completely bonkers :)</p>

<p>I'm trying to write <code>ObservableType</code> filter, which would pass only certain type, but will pass <strong>that type</strong>, not the original sequence type. This is what i came up with so far:</p>

<pre><code>extension ObservableType where Self.E: RxFilterableType {
  func filterByCast&lt;T: RxFilterableType&gt;(class: T.Type) -&gt; Observable&lt;T&gt; {
    let retval = PublishSubject&lt;T&gt;()
    self.subscribe { event in
      switch event {
      case .next(let element):
        if let passed = element as? T {
          retval.onNext(passed)
        }
      case .error(let error):
        retval.onError(error)
      case .completed:
        retval.onCompleted()
      }
    }
    return retval
  }
}

func test() {
  class A: RxFilterableType {}
  class B: RxFilterableType {}

  let array: [RxFilterableType] = [A(), B()]
  let observable: Observable&lt;RxFilterableType&gt; = Observable.from(array)
  let observableCasted: Observable&lt;A&gt; = observable.filterByCast(class: A.self)
}
</code></pre>

<p>This has two problems: the lesser problem is that the inner <code>subscribe</code> disposable is not taken care of. Ideally i'd like to pass the disposal responsibility onto the return value, but i can take the disposer as parameter. I don't care.</p>

<p>The bigger problem is the compiler objection on the last test line:</p>

<blockquote>
  <p>Using 'RxFilterableType' as a concrete type conforming to protocol 'RxFilterableType' is not supported</p>
</blockquote>

<p>Which means, i'm afraid, that the compiler has not enough informations to infer what i'm trying to do, despite more-than-necessary hints i've added in desperate attempts to help the poor guy.</p>
","886653","","","","","2017-04-25 23:37:27","RxSwift Observable filter with casting","<swift3><rx-swift>","1","1","","","","CC BY-SA 3.0"
"43625287","1","45929436","","2017-04-26 04:48:53","","1","673","<p>I'm trying to set up an empty dataset with DZNEmptyDataSet while my tableview is bound to an Rx variable</p>

<pre><code>let Chats = Variable(Section).

Chats.asObservable()

    .bind(to: tableView.rx.items(dataSource: dataSource))
</code></pre>

<p>and my dzn code is as follows: </p>

<pre><code>tableView.emptyDataSetSource = self
tableView.emptyDataSetDelegate = self


func title(forEmptyDataSet scrollView: UIScrollView) -&gt; NSAttributedString? {
    let str = ""Welcome""
    let attrs = [NSFontAttributeName: UIFont.preferredFont(forTextStyle: UIFontTextStyle.headline)]
    return NSAttributedString(string: str, attributes: attrs)
}

func description(forEmptyDataSet scrollView: UIScrollView) -&gt; NSAttributedString? {
    let str = ""Tap the button below to add your first grokkleglob.""
    let attrs = [NSFontAttributeName: UIFont.preferredFont(forTextStyle: UIFontTextStyle.body)]
    return NSAttributedString(string: str, attributes: attrs)
}
</code></pre>

<p>The problem is, even when Chats is empty, the empty dataSet for the tableview doesn't show. If i remove the bind function, it shows. I was wondering if anyone was able to make the two coexist?</p>
","6595832","","3744013","","2017-04-26 06:40:54","2017-08-29 01:39:54","DZNEmptyDataSet not compatible with tableview binding in RxSwift. Was anyone able to make it work?","<ios><swift><uitableview><rx-swift>","2","0","","","","CC BY-SA 3.0"
"43645451","1","43647203","","2017-04-26 22:18:12","","2","1073","<p>Assume I have a button which can be used to start and stop (toggle) an action.</p>

<pre><code>let toggleStream: Observable&lt;Bool&gt; = toggleBtn.rx.tap.scan(false) { state, _ in !state }
</code></pre>

<p>I have another stream, that emits Integers continuously.</p>

<pre><code>let emitter = Observable&lt;Int&gt;.interval(2.0, scheduler: timerScheduler)
</code></pre>

<p>Now I want to use the toggle stream to start and stop the emitting of the second stream. This is my approach:</p>

<pre><code>Observable.combineLatest(toggleStream, emitter) { shouldEmit, evt in
    return (shouldEmit, evt)
}.takeWhile{ (shouldEmit, evt:Int) in
    return shouldEmit == true
}.map {(_, evt) in
    return evt
}
</code></pre>

<p>This works great for the first time. I can press the button and the <code>Observable</code> starts emitting its <code>Ints</code>. Also stopping works. Sadly I can't start it for a second time, because the stream is completed. How can I restart/retry/repeat it when the user toggles the button again?</p>
","3726405","","","","","2017-04-27 01:34:33","RxSwift: Repeat a (completed) stream","<swift3><observable><rx-swift><reactivex><rx-cocoa>","1","0","1","","","CC BY-SA 3.0"
"43655094","1","","","2017-04-27 10:24:30","","0","223","<p>I have an UITableViewCell with custom UIView with progress bar. By clicking on cell app starts to load some content from API with Alamofire. I know how to get current downloaded progress and how to pass it to progress view but I'm using RxSwift+Realm and when I'm scrolling UITableView cell's progress not showing. I want to show progress even when I'm scrolling UITableView. I've tried to store progress in cell's Realm element variable and subscribed to this variable in cell, but this action loads MainTread. </p>

<p>This is dataSource for my UITableView</p>

<pre><code>let tableData: Observable&lt;[Song]&gt; = Observable.combineLatest(loadedData.asObservable(), dbData.asObservable()) { (loadedData, dbData) -&gt; [Song] in
        var newArray = self.currentPlaylist == nil ? loadedData.filter({ !$0.isInvalidated }) : dbData.filter({ !$0.isInvalidated &amp;&amp; self.currentPlaylist!.plSongs.contains($0) })

        if self.currentPlaylist == nil {
            _ = dbData.filter({ !$0.isInvalidated }).map({ data in
                if newArray.contains(where: { $0.compoundKey == data.compoundKey &amp;&amp; !data.isInvalidated }) {
                    newArray[newArray.index(where: {$0.compoundKey == data.compoundKey &amp;&amp; !data.isInvalidated })!] = data
                }
            })
        }
        return newArray.filter({ !$0.isInvalidated })
    }

    tableData
        .bind(to: self.tableView.rx.items(cellIdentifier: ""SongCell"", cellType: SongTableViewCell.self)) { (_, element, cell) in
            cell.songResponse = element

            cell.selectionStyle = .none
            cell.backgroundColor = .clear
        }
        .disposed(by: bag)
</code></pre>

<p>This is UITableView Cell</p>

<pre><code>var songLoadedProgress = Variable&lt;Float?&gt;(nil)
var songResponse: Song? {
    didSet {
        self.layoutCell()
    }
}

func layoutCell() {
    songLoadedProgress.value = songResponse?.songLoadedProgress

            songLoadedProgress.asObservable()
        .bind { (progress) in
            guard let loadingProgress = progress else { return }
            self.downloadView.circleView.setProgress(value: CGFloat(loadingProgress), animationDuration: 0.1)
        }
        .disposed(by: cellBag)
}
</code></pre>

<p>Thanks!!!</p>
","4460398","","1733883","","2017-04-28 13:55:04","2017-04-28 13:55:04","Set Progress to UITableViewCell element","<ios><swift><uitableview><rx-swift>","0","2","","","","CC BY-SA 3.0"
"43662363","1","","","2017-04-27 15:45:37","","1","129","<p>I'm writing a reactive extension for one of the WKWebView navigation delegates. At the moment I wrote the following code:</p>

<pre><code>public typealias NavigationHttpResponse = (WKWebView, WKNavigationResponse, (WKNavigationResponsePolicy) -&gt; Swift.Void)
public var decidePolicyForNavigationResponse: Observable&lt;NavigationHttpResponse&gt; {
    let selector = #selector(WKNavigationDelegate.webView(_:decidePolicyFor:decisionHandler:)! as ((WKNavigationDelegate) -&gt; (NavigationHttpResponse) -&gt; ()))
    return delegate.methodInvoked(selector)
        .map { params in
            let webView = params[0] as! WKWebView
            let navigationResponse = params[1] as! WKNavigationResponse
            let decisionHandler = params[2] as! ((WKNavigationResponsePolicy) -&gt; Swift.Void)
            return (webView, navigationResponse, decisionHandler)
    }
}
</code></pre>

<p>So far so good but when I launch my app add that code is executed, I get a crash when I'm trying to cast the block with the following line:</p>

<pre><code>let decisionHandler = params[2] as! ((WKNavigationResponsePolicy) -&gt; Swift.Void)
</code></pre>

<p>In the degub console I get:</p>

<pre><code>Could not cast value of type '__NSStackBlock__' (0x12327d1a8) to '(__C.WKNavigationResponsePolicy) -&gt; ()' (0x12218b8f0).
</code></pre>

<p>How can I safely cast from objective-c to Swift?
Or which alternative approach can I take?</p>

<p>Thanks!</p>
","2735326","","2735326","","2017-04-27 16:43:04","2017-04-27 16:43:04","Cast Objective-C block NSStackBlock into Swift 3","<objective-c><swift3><delegates><wkwebview><rx-swift>","0","0","","","","CC BY-SA 3.0"
"43672253","1","43698205","","2017-04-28 04:57:28","","0","187","<p>How do I implement <code>didHighlightRowAt</code> (<code>UITableViewDelegate</code>) in RxSwift? I could find most of the delegate methods but I could not find <code>didHighlightRowAt</code>.</p>
","1677940","","","","","2017-04-29 16:52:28","didHighlightRowAt in RxSwift","<swift><uitableview><rx-swift><frp>","1","0","1","","","CC BY-SA 3.0"
"43687326","1","","","2017-04-28 19:09:59","","3","476","<p>I think it's better if I explain what I'm trying to achieve because I think the error is on my misunderstanding on how Observables work.</p>

<p>I have a UIViewController that contains a UITableView I'm also using RxSwift and RxDataSources, so I'm binding my tableView items like this:</p>

<pre><code>vm.model
.debug()
.drive(tableView.rx.items(dataSource: dataSource))
.disposed(by: disposeBag)
</code></pre>

<p>Where <strong>vm</strong> is a viewModel which contains:</p>

<pre><code>self.model = self.network.provider.getMarkets()
                .map { (markets: [Market]) -&gt; [Row] in
                    var rows = [Row]()
                    for market in markets {                        
                        rows.append(.market(market: market))
                    }
                    return rows
                }
                .map { (rows: [Row]) -&gt; [Model] in
                    return [Model(section: .market, items: rows)]
                }
                .shareReplay(1)
                .asDriver(onErrorJustReturn: [])
</code></pre>

<p>Where model is:</p>

<pre><code>var model: Driver&lt;[Model]&gt;
</code></pre>

<p>This all works great the first time, the tableview displays the items, but the print from the <strong>debug()</strong>:</p>

<pre><code>2017-04-28 20:07:21.382: MarketAndLanguageSelectionViewController.swift:36 (viewDidLoad()) -&gt; subscribed
2017-04-28 20:07:22.287: MarketAndLanguageSelectionViewController.swift:36 (viewDidLoad()) -&gt; Event next(*Multiple items*)
2017-04-28 20:07:22.289: MarketAndLanguageSelectionViewController.swift:36 (viewDidLoad()) -&gt; Event completed
2017-04-28 20:07:22.289: MarketAndLanguageSelectionViewController.swift:36 (viewDidLoad()) -&gt; isDisposed
</code></pre>

<p>The problem is I didn't want the datasource to dispose because I wan't to update it based on the user action. If the user clicks a tableViewCell I want to update the model. Any ideas on how can I achieve this?</p>

<p>Sorry for such a big question.</p>
","2694525","","","","","2017-04-29 00:51:21","Observable being disposed ahead of time","<swift><rx-swift><rxdatasources>","1","0","","","","CC BY-SA 3.0"
"43697065","1","43697277","","2017-04-29 14:55:18","","8","2865","<p>I have the following struct of properties for <code>Chat</code></p>

<pre><code>struct Chat {
    var id = String()
    var gender = String()
    var date = Date()

    init() {}
}
</code></pre>

<p>In a view controller, i declare an instance of Chat called <code>observablechat</code>, and then i used the flatmap operator to attempt and observe only changes in the <code>date</code> property of <code>observablechat</code>. However, if i change the gender property (as shown), the subscription gets triggered. I wonder why that is and how can i fix this code such that the subscription only looks at what happens to the <code>date</code> property and nothing else?</p>

<pre><code>class ViewController: UIViewController {

    var observablechat = Variable(Chat())

        observablechat.asObservable()
        .flatMap { (Chat) -&gt; Observable&lt;Date&gt; in
            return Observable.of(Chat.matchDate)
        }.subscribe(onNext: { (r) in
            print(r)
        }).addDisposableTo(disposeBag)


        self.observablechat.value.gender = ""male"" 
        //triggers subscription above. 
    }
}
</code></pre>
","6595832","","3141234","","2017-04-29 17:38:53","2018-06-07 10:06:39","Changing one property in a variable triggers subcriptions to other properties. RxSwift","<ios><swift><rxjs><system.reactive><rx-swift>","1","1","3","","","CC BY-SA 3.0"
"43735214","1","44065196","","2017-05-02 10:08:21","","0","2015","<p>I have a <code>UITableView</code> where I bind items using <code>RxSwift</code>. Simplified code may look like this, just a <code>Variable</code> holding an array</p>

<pre><code>let data = Variable&lt;[Int]&gt;([1,2,3,4])
</code></pre>

<p>bound to the <code>UITableView</code></p>

<pre><code>tableView.register(GroupCell.self)

data.asObservable().bindTo(tableView.rx.items) { tableView, row, group in
        let indexPath = IndexPath(row: row, section: 0)
        let cell = tableView.dequeueReusableCell(GroupCell.self, indexPath: indexPath)
        return cell
        }
        .disposed(by: disposeBag)
</code></pre>

<p>I delete the items using</p>

<pre><code>tableView.rx.itemDeleted.subscribe(onNext: { [unowned self] indexPath in self.data.value.remove(at: indexPath.row)}).disposed(by: disposeBag)
</code></pre>

<p>The problem is that deleting the first item works, but deleting a second item in the same position does not. The delete button just does not show</p>

<p><a href=""https://i.stack.imgur.com/Cx2RG.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Cx2RG.gif"" alt=""enter image description here""></a></p>

<p>If I tap the delete icon on another row, the delete button shows. It just does not show in the ""position"" of previously deleted item.</p>

<p><strong>Update</strong>: I found out it only happens when I use a custom cell. Does not happen with a simple <code>StoryBoard</code> cell.</p>
","581164","","581164","","2017-05-19 08:17:59","2017-05-19 08:36:17","Deleting multiple UITableView items with RxSwift does not work with a custom cell","<ios><swift><uitableview><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"43750090","1","44050365","","2017-05-03 02:27:12","","1","2114","<p>I am trying to define an array of Rxswift Variable which is of different types (Int, String, Bool, String?, etc...)</p>

<p>So technically I want something like this,</p>

<pre><code>var intVariable = Variable&lt;Int&gt;(10)
var stringVariable = Variable&lt;String&gt;(""Hello, RxSwift"")
let genericArray = [intVariable, stringVariable]
</code></pre>

<p>Reason for this is that, I have a list of variables that i want to subscribe on. </p>

<p>However, i can subscribe on the variables individually like <code>intVariable.asObservable().subscribe</code>, <code>stringVariable.asObservable().subscribe</code> and so on. 
But if its in an array, I could loop through all the elements and subscribe on it.</p>

<p>The Rxswift Variable is defined as <code>public final class Variable&lt;Element&gt;</code></p>

<p>P.S I have tried type erasure but no luck. Any help on this would be appreciated!</p>
","7781755","","","","","2017-05-18 14:19:07","RxSwift array of Variable with different types","<arrays><swift><generics><rx-swift>","1","3","","","","CC BY-SA 3.0"
"43758861","1","","","2017-05-03 11:32:18","","0","138","<p>I am using Moya in my swift app for network requests.</p>

<p>I have used alamofire earlier and I am familiar with how to make post, get requests and read the response .</p>

<p>Following is the code where I am making a request and subscribing to the observable</p>

<pre><code>provider.request(.getDetails)
            .mapArray(Post.self)
            .subscribe { event -&gt; Void in
                switch event {
                case .next(let post):
                 self.sampleText.text = posts.first?.title
                case .error(let error):
                    print(error)
                default:
                    break
                }
            }.addDisposableTo(disposeBag)
</code></pre>

<p>In the .next case I also want to retrieve the status code and response.data.</p>

<p>I am able to do so when the observable is of type Response but when I map it to type Post I cannot get the status code.</p>

<p>How can I get the status code of the request in .next or error case</p>

<p>Any help will be appreciated. Thank you.</p>
","5443885","","","","","2017-05-03 16:06:46","How to get the status code in the onNext case while subscribing to an Observable","<ios><swift><observable><rx-swift><moya>","1","0","","","","CC BY-SA 3.0"
"43785009","1","","","2017-05-04 13:59:35","","0","542","<p>I'm learning RxSwift and i've encountered a problem with login logic.</p>

<p>My code runs ok? once, and partially second time, after logout.</p>

<p>This is from my viewmodel:</p>

<pre><code>func transform(input: Input) -&gt; Output {
    let user = fetchUser(loginAction: input.loginAction, domain: input.domain,
                           username: input.username, password: input.password)

    return Output(user: user, error: errorTracker.asDriver())
}

func fetchUser(loginAction: Driver&lt;Void&gt;, domain: Driver&lt;String&gt;, email: Driver&lt;String&gt;, password: Driver&lt;String&gt;)-&gt;Driver&lt;User&gt;{
    let credentials = Driver.combineLatest(domain, email, password) {
        $0
    }


    return loginAction.withLatestFrom(credentials)
        .flatMapLatest { [unowned self]  (domain, username, password) in
            return self.useCase.login(params: [""domain"": domain, ""username"": username, ""password"": password])
                .trackActivity(self.activityIndicator)
                .trackError(self.errorTracker)
                .asDriverOnErrorJustComplete()
                .map { [unowned self] in
                    if let token = $0.token {
                        return self.decodeUserId(token: token)
                    }
                    return """"
                }
                .flatMapLatest { [unowned self] userId in
                    return self.useCase.getUser(params: [""userId"": userId])
                        .trackActivity(self.activityIndicator)
                        .trackError(self.errorTracker)
                        .asDriverOnErrorJustComplete()
            }
    }
}
    struct Input {
    let loginAction: Driver&lt;Void&gt;
    let tenant: Driver&lt;String&gt;
    let email: Driver&lt;String&gt;
    let password: Driver&lt;String&gt;
}

struct Output {
    let user: Driver&lt;User&gt;
    let error: Driver&lt;Error&gt;
}
</code></pre>

<p>It works first time, login retrieves object which contains a token string, in map part its decoded to get user id, and getUser fetches user by id. </p>

<p>In view controller i have this binding method: </p>

<pre><code>func bindViewModel() {
    let domainChange = domainField.rx.text.orEmpty.asDriver()
    let usernameChange = usernameField.rx.text.orEmpty.asDriver()
    let passwordChange = passwordField.rx.text.orEmpty.asDriver()
    let input = LoginViewModel.Input(loginAction: loginButton.rx.tap.asDriver(),
                                     domain: domainChange,
                                     username: usernameChange,
                                     password: passwordChange)

    let output = viewModel.transform(input: input)
    output.user.drive(successBinding).addDisposableTo(disposeBag)
    output.error.drive(errorBinding).addDisposableTo(disposeBag)
}
</code></pre>

<p>Both successBinding and errorBinding are UIBindingObservers, i think they are not the issue here.
After logout (returning to login, pop) when i try tapping loginButton only the first part runs, login method and retrieves a token successfully, but it doesn't go to mapping logic, or user fetching logic.
Any help would be appreciated.</p>
","1121114","","1113632","","2018-01-31 00:46:34","2018-01-31 00:46:34","RxSwift code runs first time, second time partially","<ios><swift><mvvm><rx-swift>","1","5","","","","CC BY-SA 3.0"
"43787348","1","44034830","","2017-05-04 15:39:07","","7","3680","<p>I am creating a custom subclass of UIControl (I need to override its draw method) and I want to add RxSwift to bind its <strong>isSelected</strong> property to my model.</p>

<p>So far so good. This works fine.</p>

<p>My problem is how can I do to change the value <strong>isSelected</strong> property in response of user touchUpInside event?.</p>

<p>My first try was to use the <strong>addTarget</strong> method of UIControl, but changing the value of <strong>isSelected</strong> programmatically is not reported by the ControlProperty (as stated in the doc). But I can figure another way to resolve this.</p>

<p>Any help appreciated.</p>

<p>Source code of the subclass:</p>

<pre><code>class SYYesNoButton: UIControl {

override init(frame: CGRect) {
    super.init(frame: frame)

    // subscribe to touchUpInside event

    addTarget(
        self,
        action: #selector(userDidTouchUpInside),
        for: UIControlEvents.touchUpInside)
}



func userDidTouchUpInside() {

    // change the value of the property
    // this does not work, 
    // the change is not reported to the ControlProperty
    // HOW CAN I CHANGE THIS ??

    self.isSelected = !isSelected
}

}
</code></pre>

<p>Extensions to add reactive support:</p>

<pre><code>extension SYYesNoButton {

    var rx_isSelected: ControlProperty&lt;Bool&gt; {

    return UIControl.valuePublic(
        self,
        getter: { (button) -&gt; Bool in
            return button.isSelected
    },
        setter: { (button, value) in
            button.isSelected = value
    })


    }
}



extension UIControl {

    static func valuePublic&lt;T, ControlType: UIControl&gt;(_ control: ControlType, getter:  @escaping (ControlType) -&gt; T, setter: @escaping (ControlType, T) -&gt; ()) -&gt; ControlProperty&lt;T&gt; {



        let values: Observable&lt;T&gt; = Observable.deferred { [weak control] in
            guard let existingSelf = control else {
                return Observable.empty()
            }

            return (existingSelf as UIControl).rx.controlEvent([.allEditingEvents, .valueChanged])
                .flatMap { _ in
                    return control.map { Observable.just(getter($0)) } ?? Observable.empty()
                }
                .startWith(getter(existingSelf))
        }


        return ControlProperty(values: values, valueSink: UIBindingObserver(UIElement: control) { control, value in
            setter(control, value)
        })

    }
}
</code></pre>

<p>Thanks for all.</p>
","1936491","","","","","2019-05-09 11:23:14","Custom UIControl subclass with RxSwift","<swift><subclass><rx-swift><uicontrol>","2","2","0","","","CC BY-SA 3.0"
"43790332","1","43794474","","2017-05-04 18:31:22","","1","1403","<p>I am relatively new to RxSwift and am trying to implement best practices as I develop.</p>

<p>On my home view controller, I have to present a custom alert view controller where the user enters text into a textfield and taps confirm. Assuming the text is valid, the alert is dismissed and a new view controller is pushed.</p>

<p>To avoid using a callback or delegate, I present the alert view controller, then my home view controller subscribes to the alert view controller's textfield and confirm button. </p>

<p>Is it bad practice to subscribe to a different view controller?</p>

<p><strong>Pseudocode</strong>: </p>

<pre><code>    let alert = viewModel.textFieldAlert()
    present(alert)
    alertSubscriptions(alert)
</code></pre>

<p><strong>alertSubscriptions</strong>:</p>

<pre><code>    alert.textField.rx.text.subscribe(onNext: { [weak self] text in
        self?.viewModel.numberOfItems.value = text ?? """"
    }).addDisposableTo(disposeBag)

    alert.confirmButton.rx.tap.subscribe(onNext: { [weak self] _ in
        guard self != nil else { return }
        if !self!.viewModel.validText { return }
        alert.dismiss()
        self!.alertConfirmed()
    }).addDisposableTo(disposeBag)
</code></pre>

<p>I have tested this code and it works without any problems.</p>
","7964813","","","","","2017-05-06 00:35:03","RxSwfit: Is it bad practice to subscribe to a presented view controllers view model?","<ios><iphone><swift><reactive-programming><rx-swift>","1","0","0","","","CC BY-SA 3.0"
"43794392","1","43808017","","2017-05-04 23:47:13","","4","1445","<p>Given a service class like this:</p>

<pre><code>class Service {
    let networkService = NetworkService()

    func handleJobA(input: String) -&gt; Observable&lt;ResultA&gt; {
        return networkService
            .computeA(input)
            .map { $0.a }
    }
}
</code></pre>

<p>And when I use it from the caller side like this:</p>

<pre><code>let service = Service()

Observable
    .from([""Hello"", ""World""])
    .flatMap {
        service.handleJobA($0)
    }
    .subscribe()
</code></pre>

<p>Then this would send multiple requests to <code>service</code> at the same time. I wanted for the stream to wait until each request is done. That was achievable using the <code>merge</code> operator.</p>

<pre><code>Observable
    .from([""Hello"", ""World""])
    .flatMap {
        Observable.just(
            service.handleJobA($0)
        )
    }
    .merge(maxConcurrent: 1)
    .subscribe()
</code></pre>

<p>So far, so good - the service will not perform multiple <code>handleJobA</code> tasks at the same time. </p>

<p>However, the concurrency is a service detail and the caller should NOT care about it. In fact, the service, at a later stage, might decide to allow for difference concurrency values.</p>

<p>Secondly, when I add a new method <code>handleJobB</code>, it must not be active at the same time as job A, and vice versa.</p>

<p>So my question is:</p>

<ol>
<li>How can I restrict the maxConcurrency to the handleJobA observable as a implementation detail?</li>
<li>Which RxSwift pattern would allow to restrict this for any service method?</li>
</ol>
","375209","","","","","2017-05-05 14:52:02","Limiting concurrent access to a service class with RxSwift","<swift><reactive-programming><rx-swift>","2","0","","","","CC BY-SA 3.0"
"43822866","1","43823625","","2017-05-06 16:34:24","","1","1001","<p>I need some internal state in a viewModel but also trying to follow the ""no subscription / bind / drive / ..."" ideal approach and only compose between <code>Observables</code>. </p>

<p>How can I specify what a <code>Variable</code> observes?</p>

<p>Example:</p>

<pre><code>private var userProfilesToFetch = Variable&lt;[String]&gt;([])
private var users: Variable&lt;[User]&gt; {

    return //something that observes fetchUserProfiles() and when it emits, appends to its .value
}

private func fetchUserProfiles() -&gt; Observable&lt;User?&gt; {

    let reference = databaseRef.child(""users"")

    return userProfilesToFetch.asObservable()
        .filter({ $0 != [] })
        .map({ $0.last! })
        .flatMap({ (userId) -&gt; Observable&lt;User?&gt; in

            return self.service.observeAllChildren(of: reference.child(userId), by: .value)
                .map({ (snapshot) -&gt; User? in

                        guard let values = snapshot.value as? [String: AnyObject] else { return nil }

                        var user = User(dictionary: values)

                        user.id = snapshot.key

                        return user
                })
        })
} 
</code></pre>
","7530977","","","","","2017-05-06 18:11:38","RxSwift Variable composition without subscribe/bind/drive","<ios><swift><rx-swift><reactivex>","1","2","","","","CC BY-SA 3.0"
"43871267","1","43874717","","2017-05-09 13:30:26","","0","2022","<p>I'm using RxSwift to validate input from user, if everything is valid I want to enable a button and change its color. In my button class I have created <code>Variable&lt;Bool&gt;</code>:</p>

<pre><code>var valid = Variable(false)
</code></pre>

<p>In <code>initWithCoder</code> I'm doing such thing:</p>

<pre><code>valid.asObservable()
    .subscribe(onNext:  { [weak self] valid in
        self?.isEnabled = valid
        self?.titleLabel?.textColor = valid ? .white : .black
    })
    .addDisposableTo(disposeBag)
</code></pre>

<p>I have a method that validates input and returns an <code>Observable&lt;Bool&gt;</code> called <code>validateDate()</code> (I won't post it here for brevity):</p>

<pre><code>let dataValid = viewModel.validateData()

dataValid
    .bind(to: submitButton.valid)
    .addDisposableTo(disposeBag)
</code></pre>

<p>The problem is, that although the <code>valid</code> value in subscription is correct and enabling button works perfectly, setting button's color does not work properly, because it seems like it changes color on next emission, not when valid became <code>true</code>.</p>

<p>Am I doing something wrong here? I would be thankful for any help.</p>
","3990005","","","","","2017-12-13 09:03:36","RxSwift validation button color is not set properly","<ios><swift><validation><rx-swift>","2","2","","","","CC BY-SA 3.0"
"43886705","1","43887572","","2017-05-10 08:01:32","","0","523","<p>I am using rxSwift and I have a dictionary of observables which can be subscribed to.</p>

<pre><code>var observables: [String: Observable&lt;Bool&gt;] = [:]
</code></pre>

<p>At some point I have to clean up some of those observables. I do it as follows</p>

<pre><code>observables.removeValue(forKey: someKey)
</code></pre>

<p>Is it enough to clean up the observables with the above line? Is the observable also killed (or how do I ""kill"" it)? Someone might already be subscribed to the observable and then even after removing it from the dictionary it would still be alive and might fire, right?
Or is the observable gone the moment I remove it because nobody holds a strong reference to it? What happens in the moment the observable is removed to potential subsribers?</p>

<p>I do not have access to the subscribers from the class where the dictionary with the observables is kept.</p>
","1113632","","1113632","","2017-05-10 08:13:21","2017-05-10 09:26:12","Cleaning up observables","<swift><rx-swift><frp>","1","2","","","","CC BY-SA 3.0"
"43888296","1","43889647","","2017-05-10 09:18:41","","7","5232","<p>I have seen a lot of blogs about throttle and debounce. Most of them said they are the same thing. But I get the different result form my example? Here is the example:</p>

<pre><code>let disposeBag = DisposeBag()
Observable.of(1,2,3,4,5)
          .debounce(1, scheduler: MainScheduler.instance)
          .subscribe(onNext: {print($0)})
          .addDisposableTo(disposeBag)
</code></pre>

<p>the result was 5. But when I used throttle, the result was 1</p>

<pre><code>let disposeBag = DisposeBag()
Observable.of(1,2,3,4,5)
        .throttle(1, scheduler: MainScheduler.instance)
        .subscribe(onNext: {print($0)})
        .addDisposableTo(disposeBag)
</code></pre>

<p>So,I can't understand about the throttle operator?</p>
","5478115","","1113632","","2018-01-31 00:44:33","2020-07-27 09:22:51","What's the difference between throttle and debounce in Rxswift3.0?","<ios><swift><rx-swift>","2","0","4","","","CC BY-SA 3.0"
"43893552","1","","","2017-05-10 13:12:37","","0","852","<p>I'd like to use RxSwift in my project, but because I'm newbie I maybe misunderstand some principles. Its clear for me how to catch button presses or use rxswift with UITableView with dynamic cells (there are a lot of tutorials for that), but I don't understand how to use it with UITableView with <strong>STATIC</strong> cells - I'd like to develop something like iOS Settings.app. Could you show me example? Is it a good practice to use rxswift for it? Or maybe I should use something else?</p>
","143511","","","","","2017-05-24 15:56:42","RxSwift and static cells","<ios><swift><uitableview><rx-swift>","2","1","","","","CC BY-SA 3.0"
"43914919","1","43915569","","2017-05-11 12:05:17","","1","1947","<p>I setup the tableview and want to update the UI as soon as the data changes. I simulate a data change with the dispatcher. But the problem is, that the table won't update. Can someone explain how to setup a tableview with RxSwift to update it's cell on data change?</p>

<pre><code>  @IBOutlet private var tableView: UITableView!
  let europeanChocolates: Variable&lt;[Chocolate]&gt; = Variable([])
  let disposeBag = DisposeBag()

  //MARK: View Lifecycle

  override func viewDidLoad() {
    super.viewDidLoad()
    title = ""Chocolate!!!""
    setupCellConfiguration()
    europeanChocolates.value = Chocolate.ofEurope
    DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
      var choclate = self.europeanChocolates.value[0]
      choclate.countryName = ""Denmark""
    }

  }

  //MARK: Rx Setup

  private func setupCellConfiguration() {
    europeanChocolates.asObservable().bindTo(tableView.rx.items(cellIdentifier: ChocolateCell.Identifier, cellType: ChocolateCell.self)) {
      row, chocolate, cell in
      cell.configureWithChocolate(chocolate: chocolate)
    }
    .addDisposableTo(disposeBag)
  }
</code></pre>
","690918","","","","","2020-03-07 03:49:47","RxSwift Observeable doesn't update tableview on data change","<ios><swift><uitableview><rx-swift>","3","0","","","","CC BY-SA 3.0"
"43915887","1","43916214","","2017-05-11 12:47:59","","2","2997","<p>I want to subscribe to an observable, but right after the first element, I want to dispose the subscriber.</p>

<p>Is there some default way for that?</p>

<p>If not, how would you solve this?
I cannot change the observable, by the way.</p>
","1640012","","1033581","","2018-01-31 02:54:53","2018-01-31 02:54:53","RXSwift with one time subscriber","<swift><rx-swift><subscriber>","1","0","3","","","CC BY-SA 3.0"
"43934537","1","43940405","","2017-05-12 09:46:42","","0","2883","<p>I am trying to put together a nice architecture with RxSwift and MVVM. I am wondering how to handle the errors coming from observables correctly.</p>

<p>My ViewModel looks like:</p>

<pre class=""lang-swift prettyprint-override""><code>class MapViewModel {

    private let disposeBag = DisposeBag()

    private let listObservable: Observable&lt;[MyObject]&gt;

    let list: Variable&lt;[MyObject]&gt;
    let showError: Variable&lt;Bool&gt;

    init() {
        self.listObservable = getObservable().shareReplay(1)

        self.list = Variable&lt;[MyObject]&gt;([])
        self.listObservable
            .bind(to: list)
            .addDisposableTo(self.disposeBag)

        self.showError = Variable&lt;Bool&gt;(false)
        self.listObservable
            .subscribe(
                onError: { [weak self] error in
                    print(""Error downloading: \(error)"")
                    self?.showError.value = true
            }).addDisposableTo(disposeBag)
    }
}
</code></pre>

<p>I thought it was to correct way to do it: clean separation of concerns, and shared observable to prevent calling the REST endpoint multiple times.</p>

<p>However when I do this - and the observable sends an error - I get a fatalError from RxSwift because the error is not handled in the <code>bind()</code> call.</p>

<p>To fix this, I changed the code to:</p>

<pre class=""lang-swift prettyprint-override""><code>self.listObservable
    .subscribe(
        onNext: { [weak self] list in
            self?.list.value = list
        },
        onError: { [weak self] error in
            print(""Error downloading: \(error)"")
            self?.showError.value = true
    }).addDisposableTo(disposeBag)
</code></pre>

<p>This seems less clear for me. What should be the correct approach with this ?</p>
","183665","","183665","","2017-05-15 06:21:17","2017-05-15 13:03:52","Handling error with RxSwift and MVVM","<swift><mvvm><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"43960813","1","","","2017-05-14 05:57:25","","2","954","<p>I'm looking for a smart way of implementing a rate limit in an HTTP client. Let's assume the rate limit on the API is 5 requests per second on any of the resources. Right now the implementation looks similar to this:</p>

<pre><code>final class HTTPClient: HTTPClientProtocol {

    func getUser() -&gt; Observable&lt;User&gt; {
        return Observable&lt;User&gt;.create { (observer) -&gt; Disposable in
            ...
        }
    }

    func getProfile() -&gt; Observable&lt;Profile&gt; {
        return Observable&lt;Profile&gt;.create { (observer) -&gt; Disposable in
            ...
        }
    }

    func getMessages() -&gt; Observable&lt;Messages&gt; {
        return Observable&lt;Messages&gt;.create { (observer) -&gt; Disposable in
            ...
        }
    }

    func getFriends() -&gt; Observable&lt;Friends&gt; {
        return Observable&lt;Friends&gt;.create { (observer) -&gt; Disposable in
            ...
        }
    }

}
</code></pre>

<p>Now ideally I would like to use these methods as needed throughout the application without worrying about the rate limit at all.</p>

<p>Back to the example of 5 requests per second: The first five requests can be executed immediately. But all requests after that have to wait. So within a window of 1 second 5 requests can be executed at most. All other requests have to wait.</p>

<p>Is there any smart way of doing this in RxSwift?</p>
","936204","","936204","","2017-05-16 06:59:14","2018-05-18 20:31:54","Rate limit with RxSwift","<swift><reactive-programming><rx-swift>","2","3","3","","","CC BY-SA 3.0"
"43961885","1","","","2017-05-14 08:27:18","","2","2729","<p>A project was created in Objective-C language and later I used Swift in it. In my pod-file I have couple of Objective-C pods. I tried using RxSwift pod, it didn't allow me to have Swift pods and moreover I can't use <code>use_frameworks!</code> because I have Objective-C pods in it.</p>

<pre><code>platform :ios, '8.0'
# use_frameworks!

target 'MyProject' do   
  pod 'STPopup'
  pod 'AFNetworking', '~&gt; 3.1.0'
  pod 'Reachability'
  pod 'SVProgressHUD'
  pod 'CCHMapClusterController'
  pod 'SDWebImage', '~&gt; 3.8.2'
  pod 'DateTools'
  pod 'Fabric'
  pod 'TwitterKit'
  pod 'Crashlytics'
  pod 'SpinKit', '~&gt; 1.1'
  pod 'GPUImage'
  pod 'LLSimpleCamera', '~&gt; 5.0'
  pod 'MGSwipeTableCell'
  pod 'JSONModel'
  pod 'ASIHTTPRequest'
  pod 'PEPhotoCropEditor', :git =&gt; 'https://github.com/luyzdeleon/PEPhotoCropEditor'
  pod 'RSKImageCropper', :git =&gt; 'https://github.com/luyzdeleon/RSKImageCropper'
  pod 'MXParallaxHeader'
  pod 'Toast', '~&gt; 3.0'
  pod 'TransformerKit'
  pod 'FBSDKLoginKit'
  pod 'FBSDKCoreKit'
  pod 'FBSDKShareKit'
  pod 'FRHyperLabel', '~&gt; 1.0.1'
  pod 'STTweetLabel', :git =&gt; 'https://github.com/pabelnl/STTweetLabel.git', :branch =&gt; 'master'
  pod 'STTwitter'
  pod 'YSTutorialViewController'
  pod 'CTAssetsPickerController', :git =&gt; 'https://github.com/pabelnl/CTAssetsPickerController', :branch =&gt; 'master'
  pod 'RDHCollectionViewGridLayout', '~&gt; 1.2'
  pod 'AFNetworking+RetryPolicy'
  pod 'AWSMobileAnalytics', '~&gt; 2.4'
  pod 'CHTCollectionViewWaterfallLayout'
  pod 'BBBadgeBarButtonItem'
  pod 'FMDB'
  pod 'APAddressBook'
  pod 'CTVideoPlayerView'
  pod 'IBProgressButton'
  pod 'VIMVideoPlayer', :git =&gt; 'https://github.com/pabelnl/VIMVideoPlayer', :branch =&gt; 'master'
  pod 'ICGVideoTrimmer'
  pod 'CRGradientNavigationBar', :git =&gt; 'https://github.com/luyzdeleon/CRGradientNavigationBar', :branch =&gt; 'master'
  pod 'KILabel', '~&gt; 1.0.1'
  pod 'Firebase/Auth'
  pod 'GoogleSignIn'
  pod 'SwiftTryCatch'
  pod 'libPhoneNumber-iOS', '~&gt; 0.8'
  pod 'IGListKit'
  pod 'SDWebImage-CircularProgressView'
  pod 'RxSwift'
end
</code></pre>

<ul>
<li><strong>Error i am getting with out <code>use_frameworks!</code>:</strong> </li>
</ul>

<p>[!] Pods written in Swift can only be integrated as frameworks; add <code>use_frameworks!</code> to your Podfile or target to opt into using it. The Swift Pod being used is: RxSwift</p>

<ul>
<li><strong>Error with <code>use_frameworks!</code>:</strong> </li>
</ul>

<p>[!] Unable to integrate the following embedded targets with their respective host targets (a host target is a ""parent"" target which embeds a ""child"" target like a framework or extension):</p>

<ul>
<li>MyProject (true) and share (false) do not both set use_frameworks!.</li>
</ul>
","5431736","","1503502","","2019-01-29 12:21:38","2019-01-29 12:21:38","How to use RxSwift for Objective-C and Swift project?","<ios><objective-c><swift><xcode><rx-swift>","1","13","1","","","CC BY-SA 4.0"
"43975217","1","43976063","","2017-05-15 08:58:01","","0","6962","<p>Anybody can help me with this? I have this small code:</p>

<pre><code>getUserDetailsApi().flatMap(){users in 
    return getScoreApi(users[0])
}.subscribe(
    onCompleted: {
        print(""Done"")
    },
    onError: {
        // which of the two APIs get an error?
    })
</code></pre>

<p>I call two APIs here, in the getUserDetailsApi I want to invoke an error when it failed to get the user details or something went wrong and skip the getScoreApi. Same on the getScoreApi if it fails to get the score of the user it will throw a different error. </p>

<p>is there a way I can throw the said errors on flatMap()?. Note that the two observable must be execute in sequence order and these errors has different message</p>
","3296696","","4180647","","2017-05-15 09:00:53","2017-05-15 09:38:05","RxSwift: how to throw error on a chain observable","<swift3><throw><rx-swift>","1","1","1","","","CC BY-SA 3.0"
"43976426","1","44128732","","2017-05-15 09:54:06","","0","1303","<p>I'm trying to create an array of dictionaries from JSON response.</p>

<p>Here is the <strong>code</strong>.</p>

<pre><code>_ = postView.textView.rx.text
        .subscribe(onNext: {[unowned self] _ in
            let client = Alamofire.SessionManager.default
            _ = client.request(Router.getFriends())
                .rx_responseJSON()
                .subscribe(onNext: { [weak self] data in
                    var names = [String]()
                    do {
                            let json = try JSONSerialization.jsonObject(with: data) as? [String: Any], //'var' declarations with multiple variables cannot have explicit getters/setters 
                            let friends = json[""user""] as? [[String: Any]] {
                            for friend in friends {
                                if let name = friend[""first_name""] as? String {
                                    names.append(name)
                                }
                            }
                        }
                    } catch {
                        print(""Error deserializing JSON: \(error)"")
                    }

                    print(names)
                    }, onError: { (error) -&gt; Void in
                        debugPrint(""Error: \(error)"")
                })

        })
</code></pre>

<p>This is the <strong>error</strong> I'm getting</p>

<blockquote>
  <p>'var' declarations with multiple variables cannot have explicit
  getters/setters</p>
</blockquote>

<p>This is the <strong>JSON response</strong>,</p>

<pre><code>{
  ""user"": [
    {
      ""id"": 2,
      ""first_name"": ""Knysys"",
      ""photo"": ""https://graph.facebook.com/437334666655912/picture/?type=large"",
      ""last_seen_event"": null,
      ""blocked"": false
    },
    {
      ""id"": 3,
      ""first_name"": ""ATester"",
      ""photo"": ""https://graph.facebook.com/379988632393252/picture/?type=large"",
      ""last_seen_event"": 7,
      ""blocked"": false
    }
  ]
}
</code></pre>

<p>The <strong>desired output</strong> is this,,</p>

<pre><code>var friends = [
    [
        ""firstName"": ""SmartApps"",
        ""photo"": ""https://graph.facebook.com/1248984075179327/picture/?type=large""
        ],

    [
        ""firstName"": ""Knysys"",
        ""photo"": ""https://graph.facebook.com/437334666655912/picture/?type=large""
        ],
    [
        ""firstName"": ""ATester"",
        ""photo"": ""https://graph.facebook.com/379988632393252/picture/?type=large""
        ]
]
</code></pre>

<p>Thanks in advance!</p>
","4008392","","1113632","","2018-01-31 00:43:13","2018-01-31 00:43:13","RxSwift parse JSON array","<json><swift><alamofire><rx-swift>","2","8","","","","CC BY-SA 3.0"
"43986177","1","","","2017-05-15 18:10:45","","0","684","<p>I'm currently trying to make a dynamic UIbutton appear and disappear based on number of items loaded into a table view, fetched from a backend url. I want to button to appear if there's 12 or more items loaded into the table view and not appear if there's less than 12. Any ideas on the best way to handle this?</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

public class AllProvidersPickerViewController: InputableTableViewController, ViewModelHolder {

    @IBOutlet private(set) weak var searchBar: UISearchBar!
    @IBOutlet weak var dontSeeProviderButton: UIButton!

    var viewModel: AllProvidersPickerViewModel! = nil
    private let bag = DisposeBag()

    override public func viewDidLoad() {
        super.viewDidLoad()
        setupRx()
    }

    private func setupRx() {
      viewModel.shownProviders
        .bind(to: tableView.rx.items(cellIdentifier: ""ProviderCell"")) { _, mvpd, cell in
            cell.textLabel?.text = mvpd.displayName
        }
        .addDisposableTo(bag)

      tableView
        .rx
        .modelSelected(MVPD.self)
        .bind(to: viewModel.selectedProvider)
        .addDisposableTo(bag)

      searchBar
        .rx.text
        .orEmpty
        .bind(to: viewModel.searchQuery)
        .addDisposableTo(bag)

      dontSeeProviderButton
        .rx.tap
        .bind(to: viewModel.tappedDontSeeProvider)
        .addDisposableTo(bag)
    }
}

private extension MVPD {

    var displayName: String {
        return self.names.first ?? """"
    }
}
</code></pre>
","5865909","","1113632","","2018-01-31 08:48:45","2018-01-31 08:48:45","make dynamic UIbutton appear and dissapear based on number of items in table view","<swift><uibutton><rx-swift>","2","0","","","","CC BY-SA 3.0"
"44001806","1","44037297","","2017-05-16 12:43:19","","0","1213","<p>I have already written an Rx query to perform an async task in a timer. This also handles scenario where i need to discard order request whose response comes later. This is written in C#:</p>

<pre><code>public static IObservable&lt;T&gt; PollingAync&lt;T&gt; (Func&lt;Task&lt;T&gt;&gt; AsyncCall, double TimerDuration)
        {
            return Observable
         .Create&lt;T&gt;(o =&gt;
         {
             var z = 0L;
             return
                 Observable
                     .Timer(TimeSpan.Zero, TimeSpan.FromSeconds(TimerDuration))
                     .SelectMany(nr =&gt;
                         Observable.FromAsync&lt;T&gt;(AsyncCall),
                         (nr, obj) =&gt; new { nr, obj})
                     .Do(res =&gt; z = Math.Max(z, res.nr))
                     .Where(res =&gt; res.nr &gt;= z)
                     .Select(res =&gt; res.obj)
                     .Subscribe(o);
         });

    }
</code></pre>

<p>I wish to write the same implementation in swift which handles an async task and also discard order request whose response comes later. I wish to write this in swift3.0 </p>

<p>Since i am new to swift please help to let me know how can i achieve the same result in swift <strong>without using Rx</strong>. </p>
","1101776","","1101776","","2017-05-16 14:11:58","2017-05-18 15:27:27","Perform polling request for async task","<ios><swift><swift3><system.reactive><rx-swift>","1","5","","","","CC BY-SA 3.0"
"44003947","1","44006175","","2017-05-16 14:14:09","","2","1625","<p>I'm dealing with such case and I think of applying RxSwift here.</p>

<p>I have <code>.xib</code> UIView with button. </p>

<pre><code>class RightButtonItemView: UIView {

    @IBOutlet weak var rightButtonimageView: UIImageView!
    @IBOutlet weak var rightButtonButton: UIButton!

    let performEventSegue = PublishSubject&lt;Bool&gt;()

    class func instanceFromNib() -&gt; RightButtonItemView {
        return UINib(nibName: ""NotificationView"", bundle: nil).instantiate(withOwner: nil, options: nil)[0] as!  RightButtonItemView
    }

    override func awakeFromNib() {
       //I'm not sure how should I link button tap and my subject 
       rightButtonButton.rx.tap
    }
}
</code></pre>

<p>I create an instance of this view in my viewController</p>

<pre><code>var rightButtonItemView = RightButtonItemView.instanceFromNib()
</code></pre>

<p>Bu clicking on this button from my segue I need to move to next VC, so I subscribing to UIView's subject</p>

<pre><code>rightButtonItemView.performEventSegue.asObserver().subscribe(onNext: { (isAuthorized) in

        if isAuthorized {
            let storyboard = UIStoryboard(name: ""Notifications"", bundle: nil)
            let viewController = storyboard.instantiateViewController(withIdentifier: ""UserNotificationsViewController"")
            self.present(viewController, animated: true, completion: nil)
        }
    })
</code></pre>

<p>But I can't get how can I link button tap with changing state of my Publish Subject? </p>
","6693247","","","","","2017-05-17 13:44:47","how to observe PublishSubject on button tap","<ios><uiview><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"44009887","1","","","2017-05-16 19:21:01","","2","178","<p>So I'm completely new to testing and I just needed some help figuring out for example how I would write a test for each of the three cases in the enum of the View Model (none, dontSeeProvider, showAllProviders). </p>

<pre><code>enum ProvidersButtonType {
case none, dontSeeProvider, showAllProviders
}
</code></pre>

<p>I haven't been able to figure out how to write a test for cases ""showAllProviders"" and ""dontSeeProviders"".</p>

<p>This is the View Model: </p>

<pre><code>import RxSwift
import RxCocoa

struct TopProvidersPickerItem {
let provider: MVPD

let logoImage: Observable&lt;UIImage&gt;

init(provider: MVPD, imageLoader: DecodableProviding) {
    self.init(provider: provider, logoImage: imageLoader.image(fromURL: provider.logoUrl))
}

init(provider: MVPD, logoImage: Observable&lt;UIImage&gt;) {
    self.provider = provider
    self.logoImage = logoImage.catchErrorJustReturn(UIImage())
}
}

enum ProvidersButtonType {
case none, dontSeeProvider, showAllProviders
}

struct TopProvidersPickerViewModel {
var caption: String {
    return ""Get access to more full episodes by signing in with your TV Provider""
}

let buttonType = Variable&lt;ProvidersButtonType&gt;(.none)
let items: Observable&lt;[TopProvidersPickerItem]&gt;
let selectedItem: PublishSubject&lt;TopProvidersPickerItem&gt; = PublishSubject()
let showAllProvidersTrigger: PublishSubject&lt;Void&gt; = PublishSubject()
let mvpdPicked: Observable&lt;MVPD&gt;

init(topProviders: Observable&lt;[MVPD]&gt;, imageLoader: DecodableProviding) {
    let items = topProviders.map({ mvpds in
        return mvpds.map { mvpd in
            TopProvidersPickerItem(provider: mvpd, imageLoader: imageLoader)
        }
    })
    self.init(items: items)
}

init(items: Observable&lt;[TopProvidersPickerItem]&gt;) {
    self.items = items
    mvpdPicked = selectedItem.map { $0.provider }
    let buttonType = items.map { (array) -&gt; ProvidersButtonType in
        if array.count &gt; 12 {
            return .showAllProviders
        } else {
            return .dontSeeProvider
        }
    }
    buttonType.bind(to: self.buttonType)
}

}
</code></pre>

<p>This is the View Controller:</p>

<pre><code>import UIKit
import RxCocoa
import RxSwift

public class ProviderCollectionViewCell: UICollectionViewCell {
    @IBOutlet public private(set) weak var imageView: UIImageView!
}

public class TopProvidersPickerViewController: UIViewController, 
ViewModelHolder {
var viewModel: TopProvidersPickerViewModel! = nil
private let bag = DisposeBag()

@IBOutlet public private(set) weak var collectionView: UICollectionView!
@IBOutlet public private(set) weak var captionLabel: UILabel!
@IBOutlet weak var viewAllProvidersButton: UIButton!

override public func viewDidLoad() {
    super.viewDidLoad()
    captionLabel.text = viewModel.caption
    setupRx()
}

private func setupRx() {
    viewModel.buttonType.asObservable().subscribe(onNext: { [button = self.viewAllProvidersButton] type in
        button?.isHidden = false

        switch type {
        case .none:
            button?.isHidden = true
        case .dontSeeProvider:
            button?.setTitle(""Don't see provider"", for: .normal)
        case .showAllProviders:
            button?.setTitle(""Show all providers"", for: .normal)
        }
        })
        .disposed(by: bag)

    viewModel.items
        .bind(to: collectionView
        .rx
        .items(cellIdentifier: ""ProviderCell"", cellType: ProviderCollectionViewCell.self)) { [ unowned self ] _, item, cell in
            item.logoImage.bind(to: cell.imageView.rx.image).addDisposableTo(self.bag)
        }
        .addDisposableTo(bag)

    collectionView
        .rx
        .modelSelected(TopProvidersPickerItem.self)
        .bind(to: self.viewModel.selectedItem)
        .addDisposableTo(bag)

    viewAllProvidersButton
        .rx
        .tap
        .bind(to: self.viewModel.showAllProvidersTrigger)
        .addDisposableTo(bag)
}

}
</code></pre>

<p>I wrote a test for the ""none"" case, but haven't been able to figure out the other two cases:</p>

<pre><code>import FBSnapshotTestCase
import OHHTTPStubs
import RxSwift
@testable import AuthSuite

class TopProvidersPickerViewControllerTests: FBSnapshotTestCase, 
ProvidersViewControllerTests {

override func setUp() {
    super.setUp()
    recordMode = true
}

func testDoesNotShowButtonWhenLoadingProviders() {
    let viewModel = TopProvidersPickerViewModel(items: .never())
    let controller = TopProvidersPickerViewController.instantiateViewController(with: viewModel)
    presentViewController(controller)

    FBSnapshotVerifyView(controller.view)
}
</code></pre>
","5865909","","5865909","","2017-05-17 10:07:24","2017-05-17 10:07:24","How would I write a test to make sure the UIbutton ""Show all Providers"" turns up when there's more than 12 or more items in the table view?","<swift><viewmodel><viewcontroller><rx-swift><fbsnapshottestcase>","1","0","1","","","CC BY-SA 3.0"
"44024755","1","","","2017-05-17 12:22:09","","6","1261","<p>I want to change <strong>view2</strong> position automatically when <strong>view1</strong> position will change and bind the both view position using Rxswift.</p>

<p>I try to observe view frame/position using this</p>

<pre><code>view.rx.observe(CGRect.self,""frame"")
        .subscribe(onNext: {
            print($0 ?? (0,0))
        })
</code></pre>

<p>it <strong>print frame on init time</strong> but when change view position using constraints</p>

<pre><code>self.constraintHorizontalCenterView.constant = 1000
</code></pre>

<p>it print nothing means this code not observe view position...</p>

<p>Is there any way to observe continuously view position or bind view position?</p>
","5573171","","1113632","","2018-10-06 09:32:26","2020-03-04 01:07:18","Bind two UIview fram/Position using Rxswift","<ios><swift><uiview><rx-swift><rx-cocoa>","3","0","2","","","CC BY-SA 3.0"
"44041467","1","","","2017-05-18 07:37:57","","0","248","<p>I'm try to use RxSwift in my code and have a question:</p>

<ul>
<li><p>I have a <code>Settings</code> class with different properties (<code>staticValue</code> for example):</p>

<pre><code>class DeviceSettings: NSObject {    
    var staticValue = Variable&lt;Int&gt;(0)
}
</code></pre></li>
<li><p>I have an UI with UITextField which should be two-way connected with property, which works fine:</p>

<pre><code>settings.staticValue.asObservable()
    .map({ String($0) })
    .bindTo(staticValueField.rx.text)
    .addDisposableTo(disposeBag)

staticValueField.rx.controlEvent([.editingDidEnd]).asObservable()
    .map({ Int(self.staticValueField.text!)! }) // Always Int
    .subscribe(onNext: {
        self.settings.staticValue.value = $0
    }).addDisposableTo(disposeBag)
</code></pre></li>
</ul>

<p>But actual <code>Settings</code> object will be loaded via network request and can be reloaded several times during VC lifecycle. 
So:</p>

<ol>
<li>How I should store my settings object? As usual variable or as
<code>Variable&lt;Settings&gt;</code> with <code>?</code> or <code>!</code>? </li>
<li>Is my two-way-binding correct?</li>
<li>In which order I need to load data and call bind logic to enable binding and set start value at once?</li>
</ol>
","4899912","","","","","2017-05-18 08:47:06","RxSwift var-outlet binding organistaion","<ios><swift><binding><rx-swift>","1","0","","","","CC BY-SA 3.0"
"44043540","1","44124458","","2017-05-18 09:16:22","","3","2763","<p>guys Im totally new in Rxswift, is there is a way to do this scenario in RxSwift ?</p>

<p>What I got is this.. but problem is i dont have indexPath</p>

<pre><code>datasource.sectionModels
        .asObservable()
        .bindTo(tableView.rx.items) { tableView, row, element in
            guard let sectionType = SectionType(rawValue: indexPath.section) else { return 0 }

            let indexPath = IndexPath(row: row, section: 0)

            var itemForIndexPath: SectionViewModel {
                return self.datasource.sectionModels.value[indexPath.section]
            }

            switch sectionType {
            case .nickTitle, .nickIfno:
                let infoCell = tableView.dequeueReusableCell(
                    withIdentifier: InfoTableViewCell.name,
                    for: indexPath
                    ) as! InfoTableViewCell

                var datasource: InfoCellDatasourceProtocol = InfoCellNormalState(text: itemForIndexPath.text)
                if itemForIndexPath.errorStyle {
                    datasource = InfoCellErrorState(text: itemForIndexPath.text)
                }

                infoCell.configureCell(datasource: datasource)
            }
</code></pre>

<p>This is what I need in RxSwift </p>

<pre><code>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
    guard let sectionType = SectionType(rawValue: indexPath.section) else { return UITableViewCell() }

    var itemForIndexPath: SectionViewModel {
        return self.datasource.sectionModels.value[indexPath.section]
    }

    switch sectionType {
    case .nickTitle, .nickInfo:
        let infoCell = tableView.dequeueReusableCell(
            withIdentifier: InfoTableViewCell.name,
            for: indexPath
            ) as! InfoTableViewCell

        var datasource: InfoCellDatasourceProtocol = InfoCellNormalState(text: itemForIndexPath.text)
        if itemForIndexPath.errorStyle {
            datasource = InfoCellErrorState(text: itemForIndexPath.text)
        }

        infoCell.configureCell(datasource: datasource)

        return infoCell
</code></pre>

<p>datasource snippet:</p>

<pre><code>open class RegistrationNickDataSource: NickDatasourceProtocol {
    public var error: Variable&lt;ErrorType&gt;?
    public var success: Variable&lt;Bool&gt; = Variable(false)
    fileprivate let request = ValidateNameRequest()


    public var nickHints: Variable&lt;[String]&gt;?
    public var sectionModels: Variable&lt;[SectionViewModel]&gt; =  Variable([
    SectionViewModel(
        text: ""your_nick_hint"".localized,
        type: .info,
        errorStyle: false
    ),
    SectionViewModel(
        text: ""your_nick_placeholder"".localized,
        type: .input,
        errorStyle: false
    ),
    SectionViewModel(
        text: ""your_nick_info"".localized,
        type: .info,
        errorStyle: false
    )]
)
</code></pre>

<p>Thanks for every help</p>
","6570914","","","","","2017-06-19 04:04:16","RxSwift access to indexPath.section","<ios><swift><uitableview><rx-swift><indexpath>","2","0","1","","","CC BY-SA 3.0"
"44123404","1","44123703","","2017-05-22 23:09:30","","1","836","<p>In the following <code>strList</code> works fine, but when using <code>listOfRemoveEntity</code> I get a compiler error saying:</p>

<p>No 'items' candidates produce the expected contextual result type '(<em>) -> (</em>) -> _'</p>

<p>Only different is an array of <code>String</code> and an array of <code>RemoveEntity</code>. Do you know why?</p>

<pre><code>public class RemoveEntity: Mappable {
    public var name: String?

    required public init?(map: Map){
    }

    public init() {
    }

    public func mapping(map: Map) {
        name &lt;- map[""name""]
    }
}

@IBOutlet weak var aTable: UITableView!
var listOfRemoveEntity = Variable&lt;[RemoveEntity]&gt;([])
var strList = Variable&lt;[String]&gt;([])

let disposeBag = DisposeBag()

func subscribeToStrList() {
    strList.value.append(""111"")
    strList.value.append(""222"")
    strList.value.append(""333"")

    listOfRemoveEntity.asObservable()
        .bindTo(
            aTable.rx.items(cellIdentifier: ""Cell"", cellType: UITableViewCell.self)
        ){  (row, item, cell) in
            cell.textLabel?.text = item
        }
        .addDisposableTo(disposeBag)
}
</code></pre>
","699215","","","","","2017-05-22 23:51:59","No 'items' candidates produce the expected contextual result type '(_) -> (_) -> _'","<rx-swift>","1","0","","","","CC BY-SA 3.0"
"44134004","1","44162876","","2017-05-23 11:48:52","","1","419","<p>The following code example has (Rx)Swift smell to it, but the question is generic to any language with reactive features and throwing capability.</p>

<p>Consider a function which returns an observable sequence, but it does some sanity checking prior to creating the sequence. Check failure means that the sequence can't produce values.</p>

<pre><code>func yieldFoos() -&gt; Observable&lt;Foo&gt; {
  guard isValid(internalFoo) else {
    // throw or return one shot observable?
  }
  return createValidObservable(from: internalFoo)
}
</code></pre>

<p>In case of state validity check failure, should the function throw or return one shot observable, which will ever produce just an error? My coder's guts came up with these pros and cons:</p>

<p>Throwing feels logically cleaner (it is a failure preventing observable creation), but results in cumbersome calling code - catch block, multiple error handling points in different execution scopes.</p>

<p>One shot observable results in shorter and cleaner calling code, but somehow feels wrong. The observable is forced to be a carrier for non sequential error state, for the sake of brevity.</p>

<p>Anyone having a strong opinion worth following? Or another overlooked, elegant solution?</p>
","886653","","886653","","2017-05-23 11:58:52","2017-05-24 15:35:36","Reactive design: throw vs. publish error","<swift><try-catch><reactive-programming><rx-swift>","2","0","","","","CC BY-SA 3.0"
"44134272","1","","","2017-05-23 12:01:05","","2","789","<p>I have some existing code that fetches messages from the server. The server is in Django and returns paginated data. Hence, the first call that goes to the server fetches the 10 latest results, the next call should bring more results and so on...</p>

<p>However, the problem is that only the first request is being send to the server. So it only loads the 10 latest results and nothing else. I want to modify the code such that app is able to fetch all results.</p>

<p><strong>JSON Response</strong></p>

<p><strong>Request: <a href=""http://192.168.0.127:8000/v1/topic/1/message/"" rel=""nofollow noreferrer"">http://192.168.0.127:8000/v1/topic/1/message/</a></strong></p>

<pre><code>{
  ""count"": 12,
  ""next"": ""http://192.168.0.127:8000/v1/topic/1/message/?page=2"",
  ""previous"": null,
  ""results"": [
    {
      ""id"": 12,
      ""topic"": 1,
      ""photo_url"": """",
      ""message"": ""Test12"",
      ""user"": {
        ""id"": 2,
        ""first_name"": ""John"",
        ""photo"": ""https://graph.facebook.com/437334666655912/picture/?type=large"",
        ""last_seen_event"": null,
        ""blocked"": false
      },
      ""created_on"": ""2017-05-22T07:50:42.335694Z""
    },
    {
      ""id"": 11,
      ""topic"": 1,
      ""photo_url"": """",
      ""message"": ""Test11"",
      ""user"": {
        ""id"": 2,
        ""first_name"": ""John"",
        ""photo"": ""https://graph.facebook.com/437334666655912/picture/?type=large"",
        ""last_seen_event"": null,
        ""blocked"": false
      },
      ""created_on"": ""2017-05-22T07:50:13.931648Z""
    },
    {
      ""id"": 10,
      ""topic"": 1,
      ""photo_url"": """",
      ""message"": ""Test10"",
      ""user"": {
        ""id"": 2,
        ""first_name"": ""John"",
        ""photo"": ""https://graph.facebook.com/437334666655912/picture/?type=large"",
        ""last_seen_event"": null,
        ""blocked"": false
      },
      ""created_on"": ""2017-05-22T07:50:07.819994Z""
    },
    {
      ""id"": 9,
      ""topic"": 1,
      ""photo_url"": """",
      ""message"": ""Test9"",
      ""user"": {
        ""id"": 2,
        ""first_name"": ""John"",
        ""photo"": ""https://graph.facebook.com/437334666655912/picture/?type=large"",
        ""last_seen_event"": null,
        ""blocked"": false
      },
      ""created_on"": ""2017-05-22T07:49:59.896686Z""
    },
    {
      ""id"": 8,
      ""topic"": 1,
      ""photo_url"": """",
      ""message"": ""Test8"",
      ""user"": {
        ""id"": 2,
        ""first_name"": ""John"",
        ""photo"": ""https://graph.facebook.com/437334666655912/picture/?type=large"",
        ""last_seen_event"": null,
        ""blocked"": false
      },
      ""created_on"": ""2017-05-22T07:48:47.268219Z""
    },
    {
      ""id"": 7,
      ""topic"": 1,
      ""photo_url"": """",
      ""message"": ""Test7"",
      ""user"": {
        ""id"": 2,
        ""first_name"": ""John"",
        ""photo"": ""https://graph.facebook.com/437334666655912/picture/?type=large"",
        ""last_seen_event"": null,
        ""blocked"": false
      },
      ""created_on"": ""2017-05-22T07:48:36.587173Z""
    },
    {
      ""id"": 6,
      ""topic"": 1,
      ""photo_url"": """",
      ""message"": ""Test6"",
      ""user"": {
        ""id"": 2,
        ""first_name"": ""John"",
        ""photo"": ""https://graph.facebook.com/437334666655912/picture/?type=large"",
        ""last_seen_event"": null,
        ""blocked"": false
      },
      ""created_on"": ""2017-05-22T07:48:29.111922Z""
    },
    {
      ""id"": 5,
      ""topic"": 1,
      ""photo_url"": """",
      ""message"": ""Test5"",
      ""user"": {
        ""id"": 2,
        ""first_name"": ""John"",
        ""photo"": ""https://graph.facebook.com/437334666655912/picture/?type=large"",
        ""last_seen_event"": null,
        ""blocked"": false
      },
      ""created_on"": ""2017-05-22T07:48:22.983123Z""
    },
    {
      ""id"": 4,
      ""topic"": 1,
      ""photo_url"": """",
      ""message"": ""Test4"",
      ""user"": {
        ""id"": 2,
        ""first_name"": ""John"",
        ""photo"": ""https://graph.facebook.com/437334666655912/picture/?type=large"",
        ""last_seen_event"": null,
        ""blocked"": false
      },
      ""created_on"": ""2017-05-22T07:48:12.986871Z""
    },
    {
      ""id"": 3,
      ""topic"": 1,
      ""photo_url"": """",
      ""message"": ""Test3"",
      ""user"": {
        ""id"": 2,
        ""first_name"": ""John"",
        ""photo"": ""https://graph.facebook.com/437334666655912/picture/?type=large"",
        ""last_seen_event"": null,
        ""blocked"": false
      },
      ""created_on"": ""2017-05-22T07:48:05.376769Z""
    }
  ]
}
</code></pre>

<p><strong>Request: <a href=""http://192.168.0.127:8000/v1/topic/1/message/?page=2"" rel=""nofollow noreferrer"">http://192.168.0.127:8000/v1/topic/1/message/?page=2</a></strong></p>

<pre><code>{
  ""count"": 12,
  ""next"": null,
  ""previous"": ""http://192.168.0.127:8000/v1/topic/1/message/"",
  ""results"": [
    {
      ""id"": 2,
      ""topic"": 1,
      ""photo_url"": """",
      ""message"": ""Test2"",
      ""user"": {
        ""id"": 2,
        ""first_name"": ""John"",
        ""photo"": ""https://graph.facebook.com/437334666655912/picture/?type=large"",
        ""last_seen_event"": null,
        ""blocked"": false
      },
      ""created_on"": ""2017-05-22T07:47:59.367765Z""
    },
    {
      ""id"": 1,
      ""topic"": 1,
      ""photo_url"": """",
      ""message"": ""Test1"",
      ""user"": {
        ""id"": 2,
        ""first_name"": ""John"",
        ""photo"": ""https://graph.facebook.com/437334666655912/picture/?type=large"",
        ""last_seen_event"": null,
        ""blocked"": false
      },
      ""created_on"": ""2017-05-22T07:47:49.372195Z""
    }
  ]
}
</code></pre>

<p><strong>Code</strong></p>

<pre><code>fileprivate lazy var _getMessagesAction: Action&lt;EnumerableType, EnumerableType&gt; = Action { (last: EnumerableType?) -&gt; Observable&lt;EnumerableType&gt; in

        self.isNewRequest = last?.next == nil ? true : false

        return self.messagesRequest(last)
}
</code></pre>

<p>The <code>last</code> variable is always nil right now.</p>

<p><code>typealias EnumerableType = Enumerable&lt;Message&gt;</code></p>

<p>Here is the <strong>Enumerable</strong> class</p>

<pre><code>public struct Enumerable&lt;EnumerableType: ResponseCollectionModelSerializable&gt; : ResponseModelSerializable {

    let count: Int
    let prev: String?
    let next: String?
    let results: [EnumerableType]?

    public init?(response: HTTPURLResponse, json: JSON) {
        guard let countOBj = json[""count""] else {
            return nil
        }

        self.count = countOBj as! Int
        self.prev = json[""previous""] as? String
        self.next = json[""next""] as? String

        if let results = json[""results""] as? AnyObject {
            self.results = EnumerableType.collection(response: response, json: JSON(results))
        } else {
            self.results = nil
        }

    }

}
</code></pre>
","4008392","","","","","2019-12-11 11:51:24","Retrieve next page data through Alamofire request using RxSwift","<pagination><alamofire><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"44167040","1","44167379","","2017-05-24 19:32:02","","1","291","<p>I expected to see <code>timer -&gt; Event completed</code> get outputted right after I saw <code>running -&gt; Event completed</code> but it didn't happen.</p>

<p>Can someone explain why and give me some idea on how to complete the <code>timer</code> observable?</p>

<pre><code>/// playground

import RxSwift
import PlaygroundSupport
PlaygroundPage.current.needsIndefiniteExecution = true


struct TimerCountdown {

    let timer: Observable&lt;Int&gt;

    init(running: Observable&lt;Bool&gt;) {
        timer = running.flatMapLatest { $0 ? Observable&lt;Int&gt;.interval(1.0, scheduler: MainScheduler.instance) : Observable&lt;Int&gt;.never() }
    }

}

let running = PublishSubject&lt;Bool&gt;()
let countdown = TimerCountdown(running: running)

_ = running.debug(""running"").subscribe()

_ = countdown.timer.debug(""timer"").subscribe()

running.onNext(true)
DispatchQueue.main.asyncAfter(deadline: .now() + 3.5) {
    running.onNext(false)
}

DispatchQueue.main.asyncAfter(deadline: .now() + 7.5) {
    running.onNext(true)
}

DispatchQueue.main.asyncAfter(deadline: .now() + 10.5) {
    running.onCompleted()
}
</code></pre>
","506441","","","","","2018-11-15 14:23:01","Rx flatMapLatest doesn't pass completed through?","<system.reactive><rx-swift>","1","0","","","","CC BY-SA 3.0"
"44196516","1","44200558","","2017-05-26 07:59:23","","0","601","<p>I've a very strange situation here - call of the <a href=""https://developer.apple.com/reference/uikit/uinavigationcontroller/1621861-setviewcontrollers?language=objc"" rel=""nofollow noreferrer"">method</a> <code>UINAvigationController -&gt; setViewControllers:animated:</code> causes a crash of the app. It's happining only on iOS 10.3.2 and when I'm building the app in release mode.</p>

<p>I've collected more details. Hope they can help to understand what happens.</p>

<p>The issue appears on iOS 10.3.2 and in release mode only. I’ve checked this on iPhone with 10.3.2 and release build fails but debug works OK. Additionally, I’ve checked previous version of the app from AppStore on iOS 10.3.2 and it’s OK too. Debug and release builds work fine on all of the previous versions of iOS.</p>

<p>The previous version in AppStore was built with older version of Xcode, and now I'm using latest Xcode 8.3.2. I suppose it's system issue, which is related to iOS and Xcode versions. </p>

<p>Regarding sources, it looks like:</p>

<p>AppDelegate.swift</p>

<pre><code>func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {
    ...
    window = UIWindow(frame: UIScreen.main.bounds)
    ....
    let navigationController = UINavigationController(rootViewController: viewController)
    window.rootViewController = navigationController
    window.makeKeyAndVisible()
}
</code></pre>

<p>ViewController.swift</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    ...
    continueButton.addTarget(self, action: #selector(navigateForward), for: .touchUpInside)
    ...
}

func navigateForward(sender: UIButton!) {
    let nextController = FinalBuilder.viewController()
    navigationController?.setViewControllers([nextController], animated: true)
}
</code></pre>

<p>I said before, it works fine in all cases except one :). <code>UINAvigationController -&gt; setViewControllers:animated:</code> is standard iOS method, available from iOS 3.0+ and not deprecated now. There are no hacks or something else what can corrupt the program flow. And it’s usual way to use it.</p>

<p>P.S. There is no debug log or any other message which I can provide you because the app just disappears from the screen with no notification at all.</p>
","1423876","","1423876","","2017-05-26 11:34:02","2017-05-26 11:34:02","UINAvigationController -> setViewControllers causes a crash","<ios><swift><uinavigationcontroller><rx-swift><rx-cocoa>","2","4","","","","CC BY-SA 3.0"
"44204583","1","44211209","","2017-05-26 14:53:57","","5","1230","<p>How can I ensure that a subscriber to an <code>Observable</code> will receive the <code>onNext</code> event after another subscriber?</p>

<p>My example is the following:</p>

<pre><code>let firstNameObservable = firstName.asObservable().shareReplay(1)
let lastNameObservable = lastName.asObservable().shareReplay(1)
let bioObservable = bio.asObservable().shareReplay(1)
let websiteObservable = website.asObservable().shareReplay(1)

firstNameObservable.subscribe(onNext: { [unowned self] firstName in self.accountDetails.firstName = firstName }).disposed(by: disposeBag)
lastNameObservable.subscribe(onNext: { [unowned self] lastName in self.accountDetails.lastName = lastName }).disposed(by: disposeBag)
bioObservable.subscribe(onNext: { [unowned self] bio in self.accountDetails.bio = bio }).disposed(by: disposeBag)
websiteObservable.subscribe(onNext: { [unowned self] website in self.accountDetails.website = website }).disposed(by: disposeBag)

Observable.combineLatest(firstNameObservable, lastNameObservable, bioObservable, websiteObservable)
    { [unowned self] _, _, _, _ in return self.accountDetails.validForSignUp }
    .bind(to: isValid)
    .disposed(by: disposeBag)
</code></pre>

<p>I would like for that last <code>combineLatest</code> binding to trigger after any of the 4 <code>subscriptions</code> above it have already executed. This is because it is only after the properties on <code>accountDetails</code> have been set that the <code>validForSignUp</code> will be accurate.</p>

<p>I am aware that a solution to this problem would be to make <code>validForSignUp</code> a <code>Variable</code> and observe it, but let's assume that is not possible.</p>
","1486106","","1486106","","2017-05-26 15:20:05","2017-05-27 02:14:32","RxSwift Shared Subscription Execution Order","<swift><rx-swift><reactive>","2","1","","","","CC BY-SA 3.0"
"44230712","1","44232601","","2017-05-28 18:36:43","","8","17923","<p>I am trying to do a couple of actions in sequence, using RxSwift and am unsure how to get it working. </p>

<p>The problem is returning a <code>Single</code> observable, where the success/error depends on whether a <code>Completable</code> call succeeds or fails.</p>

<p>My code attempt looks roughly like this:</p>

<pre><code>func doSomething(with value: SomeType) -&gt; Single&lt;SomeType&gt; {
    return repository.replace(with: value) // replace() returns a completable
        .asObservable()
        .flatMap { () -&gt; Single&lt;SomeType&gt; in
            return Single.just(value)
    }
}
</code></pre>

<p>Error on line 4 (flatMap):</p>

<blockquote>
  <p>Cannot convert call result type 'Observable&lt;_.E>' to expected type 'PrimitiveSequence&lt; SingleTrait, SomeType >' (aka 'PrimitiveSequence&lt; SingleTrait, SomeType >')</p>
</blockquote>

<p>How can I map this completable to a single?</p>
","991856","","","","","2019-07-20 14:04:14","RxSwift: Mapping a completable to single observable?","<ios><rx-swift>","2","0","2","","","CC BY-SA 3.0"
"44247320","1","","","2017-05-29 16:55:11","","0","521","<p>I've started using RxBluetoothKit with good results for a peripheral we are developing. It works quite well and I am able to perform the transactions we need.</p>

<p>I have a design pattern question. We have a couple of commands where our API includes multi-step commands. For example, the App writes a command start code, the Peripheral confirms with an ACK, then the App writes the command, waits for an ACK, issues another command, waits for another ACK, etc. This can go on until the App issues a command stop code, which will be at some indeterminate point in the future — when the user tells the app to stop, for example.</p>

<p>Is there an appropriate coding idiom or pattern in the Rx world for accomplishing this? I am new to Rx in general, and am curious what might be the simplest, cleanest implementation of something of this sort.</p>

<p>Thanks.</p>
","1184073","","1113632","","2018-02-07 09:30:06","2018-02-07 09:30:06","RxBluetoothKit Code Pattern for Multiple Stage Bluetooth Commands","<swift><rx-swift><rxiosble>","1","0","","","","CC BY-SA 3.0"
"44249124","1","44249297","","2017-05-29 19:11:28","","5","2488","<p>I'm learning RxSwift, what I would like achieve is to get mechanism which prints me <code>text</code> from <code>UITextFied</code>, but after given interval.</p>

<p>How it works now: when I type first character this character is immediately printed out (not after delay how I expected) and if I keep on typing long sentence, <code>text</code> is printed after each two second (as interval is set in throttle), but I would like to have only latest <code>text</code> value.</p>

<p>My code:</p>

<pre><code>inputField.rx.text.orEmpty
        .throttle(2, latest: true, scheduler: MainScheduler.instance)
        .subscribe(onNext: { text in
            print(""\(text)"")
        }, onDisposed: nil)
        .addDisposableTo(disposeBag)
</code></pre>

<p>Im looking for your help Rx fellows :) Thanks</p>
","2069114","","","","","2017-05-29 19:26:08","RxSwift throttle how to get only last value from stream","<swift><uitextfield><rx-swift>","1","0","","","","CC BY-SA 3.0"
"44296776","1","44296979","","2017-06-01 00:46:23","","1","692","<p>I inherited a project that uses disposeBags everywhere, but disposeBag seems to be a massive memory leak. None of the view controllers utilizing the bag ever get deallocated, which leads to subscriptions piling up. I'm</p>

<pre><code>class TestViewController: UIViewController 
{

    @IBOutlet weak var testLabel: UILabel!
    var basePresenter: BasePresenter = BasePresenter()
    var disposeBag: DisposeBag = DisposeBag()
    override func viewDidLoad() {
        super.viewDidLoad()
        bindPresenter()
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        //self.disposeBag = DisposeBag()                 &lt;------------
    }

    func bindPresenter() {
        //super.bindPresenter()
        basePresenter.testVariable.asDriver().drive(onNext: { test in
            if !test.id.isEmpty {
                self.testLabel.text = ""Test text""      //&lt;------------
            }
        }).addDisposableTo(disposeBag)
    }

    deinit{
        print(""TestView was dealloc'd"")
    }
}
</code></pre>

<p>The key issue is the reference in the handler to ""self.""<br>
My theory is that self is a strong reference, which is leading to a situation where even when the view controller gets popped and there are no other references to the view controller, it still doesn't get deallocated because the bag has a strong reference to it. Circular logic where the bag doesn't get disposed because the VC doesn't dealloc and the VC doesn't dealloc because the bag doesn't get disposed. </p>

<p>The commented out line  </p>

<pre><code>//self.disposeBag = DisposeBag()
</code></pre>

<p>when called allows for the view to properly dealloc.</p>

<p>On top of the memory leak, the issue that I'm facing is that I don't want to dispose the bag on viewWillDisappear, but rather when the view is popped. I need it to stick around if I add a view on top in case I pop back to this view.</p>

<p>Any help would be greatly appreciated!</p>
","3838167","","","","","2017-06-01 01:25:39","DisposeBag memory leak?","<ios><memory-leaks><swift3><rx-swift>","1","1","","","","CC BY-SA 3.0"
"44317905","1","44318736","","2017-06-01 22:13:02","","0","1017","<p>This is my non-reactive code that works just fine.</p>

<p>func getLatestHtml2 () {</p>

<pre><code>Alamofire.request(""https://www.everfest.com/fest300"").responseString { response in
    print(""\(response.result.isSuccess)"")
    if let html = response.result.value {
        self.parseHTML(html: html)
    }
}
</code></pre>

<p>}</p>

<p>However when I make it reactive using this code. </p>

<pre><code>  func getLatestHtml1() -&gt; Observable&lt;String&gt; {

        return Observable&lt;String&gt;.create { (observer) -&gt; Disposable in
            let request = Alamofire
                .request(""https://www.everfest.com/fest300"")
                .responseString { response in
                    print(response.result.value)
                    observer.onNext(response.result.value!)
                    observer.onCompleted()

            }
            return Disposables.create { request.cancel() }


        }
    }
</code></pre>

<p>I get no data in the print statement. I even used RxAlamofire, which I feel is the right way with this code and it has error checking:</p>

<pre><code>func getLatestHtml() -&gt; Observable&lt;String?&gt; {
        return RxAlamofire

            .requestData(.get,""https://web.archive.org/web/20170429080421/https://www.everfest.com/fest300"" )
            .debug()
            .catchError { error in
                print(error)
                return Observable.never()
            }
            .map { (response, value) in
                print(response.statusCode)
                guard response.statusCode == 200 else { return nil }
                print(value)
                return String(data: value, encoding: String.Encoding.utf8)
            }
            .asObservable()



    }
</code></pre>

<p>which produced no data or errors anywhere. I need to know if my syntax is wrong or my thinking regarding reactive programming is wrong.</p>

<p>I cam calling it as .getLatestHTMLX(). Thanks !</p>
","6052993","","","","","2017-06-01 23:48:34","RXAlamofire not returning data ( error or not)","<swift><reactive-programming><rx-swift><frp><rxalamofire>","1","0","","","","CC BY-SA 3.0"
"44319788","1","44328289","","2017-06-02 02:14:18","","0","46","<p>What I'm attempting to do is subscribe to an observable that emits a sequence of <code>Enums</code>. The goal being that every time I've seen 3 <code>Enums</code> of a specific kind that my <code>onNext</code> is called. Below is what I've attempted However, it only works once. It doesn't continue on. I'm wondering what is the best way to handle this.</p>

<pre><code>enum Baseball {
 case strike, ball, hit
}

let bag = DisposeBag()
let subject = PublishSubject&lt;Baseball&gt;()

subject.filter { $0 == .strike }
  .elementAt(2)
  .subscribe(onNext: { _ in print(""3 Strikes you're out"") 
}).addDisposableTo(bag)

// First batter
subject.onNext(.strike)
subject.onNext(.ball)
subject.onNext(.ball)
subject.onNext(.ball)
subject.onNext(.strike)
subject.onNext(.strike) // 3 Strikes you're out is printed

// Second batter
subject.onNext(.ball)
subject.onNext(.ball)
subject.onNext(.hit)

// Third batter
subject.onNext(.strike)
subject.onNext(.strike)
subject.onNext(.strike) // Would like this to fire as well
</code></pre>
","315471","","315471","","2017-06-02 11:47:29","2017-06-05 07:23:18","Handle next events after seeing a specific number of them","<swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"44319814","1","44329192","","2017-06-02 02:17:28","","1","293","<p>I realize there is a lot of code here for a SO question, but it's the best I can do at the moment... You can just copy/paste the code into an rx-enabled playground to see the problem.</p>

<p>On line 89 there is a commented out piece of code <code>let creds = Observable.just(credentials)//.concat(Observable.never())</code>. If I remove the <code>//</code> and allow the concat, the code will pass its test. Can anybody give a clue as to why this code fails the test if <code>creds</code> is allowed to send a completion event? </p>

<pre><code>import Foundation
import RxSwift
import RxCocoa
import UIKit

typealias Credentials = (email: String, password: String)

struct User {
    let id: String
    let properties: [Property]
}

struct Property {
    let id: String
    let name: String
}

struct LoginParams {
    let touchIDPossible: Bool
}

class LoginScreen {
    var attemptLogin: Observable&lt;Credentials&gt; {
        assert(_attemptLogin == nil)
        _attemptLogin = PublishSubject()
        return _attemptLogin!
    }

    var _attemptLogin: PublishSubject&lt;(email: String, password: String)&gt;?
}

class DashboardScreen {
    func display(property: Observable&lt;Property?&gt;) {
        property.subscribe(onNext: { [unowned self] in
            self._property = $0
        }).disposed(by: bag)
    }

    var _property: Property?
    let bag = DisposeBag()
}

class Interface {
    func login(params: LoginParams) -&gt; Observable&lt;LoginScreen&gt; {
        assert(_login == nil)
        _login = PublishSubject()
        return _login!
    }

    func dashboard() -&gt; Observable&lt;DashboardScreen&gt; {
        assert(_dashboard == nil)
        _dashboard = PublishSubject()
        return _dashboard!
    }

    var _login: PublishSubject&lt;LoginScreen&gt;?
    var _dashboard: PublishSubject&lt;DashboardScreen&gt;?
    let bag = DisposeBag()
}

class Server {
    func user(credentials: Credentials) -&gt; Observable&lt;User&gt; {
        assert(_user == nil)
        _user = PublishSubject()
        return _user!
    }

    func property(id: String) -&gt; Observable&lt;Property&gt; {
        assert(_property == nil)
        _property = PublishSubject()
        return _property!
    }

    var _user: PublishSubject&lt;User&gt;?
    var _property: PublishSubject&lt;Property&gt;?
}

class Coordinator {

    init(interface: Interface, server: Server) {
        self.interface = interface
        self.server = server
    }

    func start() {
        let credentials = (email: ""foo"", password: ""bar"")

        // remove the `//` and the test will pass. Why does it fail when `creds` completes?
        let creds = Observable.just(credentials)//.concat(Observable.never())

        let autoUser = creds.flatMap {
            self.server.user(credentials: $0)
                .materialize()
                .filter { !$0.isCompleted }
            }.shareReplayLatestWhileConnected()

        let login = autoUser.filter { $0.error != nil }
            .flatMap { _ in self.interface.login(params: LoginParams(touchIDPossible: false)) }

        let attempt = login.flatMap { $0.attemptLogin }
            .shareReplayLatestWhileConnected()

        let user = attempt.flatMap {
            self.server.user(credentials: $0)
                .materialize()
                .filter { !$0.isCompleted }
            }.shareReplayLatestWhileConnected()

        let propertyID = Observable.merge(autoUser, user).map { $0.element }
            .filter { $0 != nil }.map { $0! }
            .map { $0.properties.sorted(by: { $0.name &lt; $1.name }).map({ $0.id }).first }

        let property = propertyID.filter { $0 != nil }.map { $0! }
            .flatMap { self.server.property(id: $0)
                .map { Optional.some($0) }
                .catchErrorJustReturn(nil)
            }.debug(""property"").shareReplayLatestWhileConnected()

        let dashboard = property.flatMap { _ in self.interface.dashboard() }

        dashboard.map { $0.display(property: property) }
            .subscribe()
            .disposed(by: bag)
    }

    let interface: Interface
    let server: Server
    let bag = DisposeBag()
}

do {
    let interface = Interface()
    let server = Server()
    let coordinator = Coordinator(interface: interface, server: server)

    coordinator.start()

    assert(server._user != nil)

    let simpleProperty = Property(id: ""bar"", name: ""tampa"")
    let user = User(id: ""foo"", properties: [simpleProperty])
    server._user?.onNext(user)
    server._user?.onCompleted()
    server._user = nil

    assert(interface._login == nil)

    assert(server._property != nil)

    let property = Property(id: ""bar"", name: ""tampa"")
    server._property!.onNext(property)
    server._property!.onCompleted()
    server._property = nil

    assert(interface._dashboard != nil)

    let dashboard = DashboardScreen()
    interface._dashboard?.onNext(dashboard)
    interface._dashboard?.onCompleted()

    assert(dashboard._property != nil)
    print(""test passed"")
}
</code></pre>

<p>Here is the output of the code as it is above:</p>

<pre><code>2017-06-01 22:22:42.534: property -&gt; subscribed
2017-06-01 22:22:42.552: property -&gt; Event next(Optional(__lldb_expr_134.Property(id: ""bar"", name: ""tampa"")))
2017-06-01 22:22:42.557: property -&gt; Event completed
2017-06-01 22:22:42.557: property -&gt; isDisposed
2017-06-01 22:22:42.559: property -&gt; subscribed
assertion failed: file MyPlayground.playground, line 159
</code></pre>

<p>Why is the <code>property</code> being subscribed to <em>after</em> it has been disposed?</p>

<p>Here is the output if you remove the <code>\\</code>:</p>

<pre><code>2017-06-01 22:23:51.540: property -&gt; subscribed
2017-06-01 22:23:51.553: property -&gt; Event next(Optional(__lldb_expr_136.Property(id: ""bar"", name: ""tampa"")))
test passed
</code></pre>
","506441","","506441","","2017-06-02 16:08:26","2017-06-03 07:05:38","Why is the completion event stopping this test from passing?","<swift><reactive-programming><rx-swift>","1","2","","","","CC BY-SA 3.0"
"44348206","1","","","2017-06-03 20:18:09","","3","2146","<p>I have a view model that has an element that returns an observable array after calling an API.</p>

<p>I then find that result to a table view to display it. The problem I am having is how to call the detail view controller on the specific cell that is clicked. I bound the results with:</p>

<pre><code> let queryResults = eventsViewModel.mainTableItems

       queryResults
            .bind(to: collectionView.rx.items) { collectionView, row, item in

                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ""cell"", for: IndexPath(row: row, section: 0)) as! EventCell
                cell.heroID = ""heroCellID""
                cell.restaurantNameLabel.text = item.name
                cell.restaurantDetailLabel.text = item.location
                cell.timeLabel.text = item.date
                cell.restaurantImageView.kf.setImage(with: URL(string: item.image))

                return cell
        }
        .addDisposableTo(disposeBag)
</code></pre>

<p>I have no way to access the specific element in this observable array that was clicked. It says an Observable array cannot have subscript.</p>

<p>This is the code that says that:</p>

<pre><code> vc.festival = queryResults.value[indexPath.row]
</code></pre>

<p>I am still new to RxSwift and I am struggling to understand this. </p>
","6052993","","6052993","","2017-06-03 22:07:34","2017-08-27 02:42:20","MVVM RxSwift way to send data from main view to detail view controller?","<swift><mvvm><reactive-programming><rx-swift><reactive>","2","0","1","","","CC BY-SA 3.0"
"44363295","1","","","2017-06-05 06:54:56","","0","57","<p>I have a live search with autocompletion in-place (i.e. the text box contents change). </p>

<p>I have a request/response mechanism: like <code>.rx.text.flatMapLatest(requestSuggestion)</code>. But the result is <code>merge</code>d with 2 other sources of changes, all 3 of them <code>Driver</code>s, though (on main thread, sharing replay, not erroring-out).</p>

<p>When binding the result back to the text field, there was a minimal time window where the user can type the next character but gets the suggestion for the last typing. <strong>So the response consumption lacks behind a tiny bit. I want to get rid of that race condition.</strong></p>

<h3>Request enumeration approach</h3>

<p>I figured it'd be good to discard not rely on <code>.flatMapLatest</code> here on client side but make the component's value sink check for <em>out-of-date</em>-ness like you do in a server/client environment. In other words, I enumerate requests, the poor man's time stamp. Now I have a <code>.rx.contentChange</code> where the type has the text value + a <code>requestNumber</code>.</p>

<p>It seems to work, but I cannot come up with a useful design of the sink. Its overall setup looks clunky and the <code>disposable</code> in the capture group is ... not so good.</p>

<p>What I am aiming for is a setup similar to <code>Observable.create</code> where you can combine disposables, only <code>Observers</code>/sinks don't have this kind of stuff.</p>

<pre><code>// Request and response are similar to:
struct Request  { let content: String; let requestNumber: Int }
struct Response { let content: String; let requestNumber: Int }

// Hacky sink that works, but meh:
public var enumeratedResponseSink: AnyObserver&lt;Response&gt; {

    // A reference to the ControlEvent that the client code is observing.
    // Using Driver here because I want to make this a UIBindingObserver later.
    let requestNumbers = self.requests.asDriver()
        .map { $0.requestNumber }
    let publish = PublishSubject&lt;Response&gt;()

    let disposable = publish.asDriver(onErrorDriveWith: .empty())
        .withLatestFrom(requestNumbers) { response, number in (response, number) }
        .filter { response, latestRequestNumber in response.requestNumber &gt;= latestRequestNumber }
        .map { response, _ in response.content }
        .drive(self.content) // is a UIBindingObserver

    // Look, I put a strong reference to the disposable inside so it 
    // doesn't go away, but man that doesn't feel right:
    return AnyObserver { [disposable] event in

        guard case .next(let response) = event else { return }

        publish.onNext(response)
    }
}
</code></pre>

<p>So this is my attempt at letting the component know from inside the <code>Observer</code> declaration what it <em>itself</em> expects the next response number to be.</p>

<ul>
<li>How I can make this freshness check work better?</li>
<li>Is this a proper approach at all, or do you have a better idea to solve the original problem?</li>
</ul>
","1460929","","","","","2017-06-06 01:37:44","How to make Rx value sinks aware of outdated responses?","<swift><concurrency><system.reactive><race-condition><rx-swift>","1","0","","","","CC BY-SA 3.0"
"44371609","1","","","2017-06-05 14:48:37","","0","324","<p><em>Update:</em> I just checked their example projects and it is the same. So, it might be a bug, or this is expected behaviour.</p>

<p>I'm using RxBluetoothKit and cannot figure out the following issue. I'm having this wrapper function to write a characteristics (I'm trying to write many of them with concat, it works nice):</p>

<pre><code>func writeCharacteristicData(for peripheral: Peripheral, characteristicIdentifier: CharacteristicIdentifier, value: Data?) -&gt; Observable&lt;Characteristic&gt; {
guard let value = value else {
  return Observable.error(BTError.noDataProvided(description: ""Missing value for: \(characteristicIdentifier)""))
}
return peripheral
  .connect()
  .flatMap { $0.writeValue(value,
    for: characteristicIdentifier,
    type: .withResponse) }
}
</code></pre>

<p>According to RxBluetoothKit documentation <code>.flatMap { $0.writeValue }</code> is one of the easiest way to write in a characteristic. Actually it works just fine with <code>readValue</code> and even with this <code>writeValue</code>, the write is successful, and if I read it back with readValue after that, the <code>characteristic.value</code> is OK in <code>oNext:</code>.</p>

<p>My problem is that this function returns an <code>Observable&lt;Characteristic&gt;</code> and my assumption was that it will give me back the written value. But that's not the case, or at least it does not work for me. It gives me back previous values or nil, I could not figure this out so far what's the logic on the emitted <code>Observable&lt;Characteristic&gt;</code>. It would be really nice if I can get back the written value. What am I doing wrong?</p>

<p>I even tried the longer ways, and this one, mentioned on github:</p>

<pre><code>characteristic.writeValue(data, type: .withResponse)
.subscribe { event in
    //respond to errors / successful read
}
</code></pre>

<p>The emitted characteristic (in the <code>onNext:</code> callback) is not the one I wrote to the device. It's a previous one or nil. The funny thing is if I try to read it back, and write after that, the characteristic.value will be the one that I've read with <code>$0.readValue</code>. But if I recompile, write a completely new one, it's still the same I've read before. It's like RxBluetoothKit cached a value or I have no idea whatsoever.</p>

<p>Can this be a problem with the ble device? 
Maybe it's a thread issue or something like that? </p>

<p>I'd really appreciate any kind of advice or hints.</p>

<p>Thanks,</p>

<p>Daniel</p>
","2440777","","2440777","","2017-06-05 14:57:15","2017-08-23 08:32:22","flatMap writeValue for characteristic do not return Observable","<swift><bluetooth><rx-swift><ios-bluetooth><rxiosble>","1","0","","","","CC BY-SA 3.0"
"44435022","1","","","2017-06-08 11:51:13","","-1","48","<p>A completed project in swift 3.0, I want to update it with ReactiveX frameworks for swift i.e rxSwift, rxCocoa. </p>

<p>My point is as i'm learning reactive it is so different and new for me. 
But before doing this I have some question in my mind</p>

<ol>
<li><p>Is it worth working, spending time on ReactiveX?</p></li>
<li><p>Does it increase the performance of the application?</p></li>
<li>What do you personally think about the future of ReactiveX?</li>
</ol>
","2125440","","2125440","","2018-05-20 03:26:51","2018-05-20 03:26:51","Queries about ReactiveX programming with swift","<swift><reactive-programming><rx-swift><reactivex><rx-cocoa>","2","0","","2017-08-17 15:07:49","","CC BY-SA 4.0"
"44438214","1","","","2017-06-08 14:16:07","","1","1059","<p>I have such usual task as creating expandable table view cell. 
As my module is written using RxSwift, I decided to use this framework for particular task.
Although, my solution satisfies functional requirements, I want to improve UI. By now I have very rough animation when I deselect my cell.</p>

<p>Here is how my layout looks like:</p>

<pre><code>TableViewCell
-ContentView
--StackView
---MainView
---ExandableView
</code></pre>

<p>So when I tap on a cell, my <code>ExpandableView</code> is being established.</p>

<pre><code>class ExpandableCell: UITableViewCell {

    @IBOutlet weak var expandableView: UIView!
    @IBOutlet weak var faqArrowImageView: UIImageView!

    var isExpanded:Bool = false
    {
        didSet
        {
            self.expandableView.isHidden = !self.isExpanded
            self.faqArrowImageView.image = self.isExpanded ? UIImage(named: ""faq-arrow"") : UIImage(named: ""faq-arrow-rotated"")
        }
    }
} 
</code></pre>

<p>In my VC I have such subscription, which handles main business-logic</p>

<pre><code>faqTableView.rx.itemSelected
    .subscribe(onNext: { [unowned self] indexPath in

        print(""Index path is \(indexPath.row)"")

    let cell = self.faqTableView.cellForRow(at: indexPath) as! ExpandableCell
        switch cell.isExpanded {
        case true:
            self.expandedRows.remove(indexPath.row)
        case false:
            self.expandedRows.insert(indexPath.row)
        }

        cell.isExpanded = !cell.isExpanded
        self.faqTableView.beginUpdates()
        self.faqTableView.endUpdates()
}).addDisposableTo(disposeBag)
</code></pre>

<p>As I have said, I have rough processing on hiding my views. 
Here is demonstration of this problem <a href=""https://www.dropbox.com/s/1h18a2u1mpuyiuo/animation.gif?dl=0"" rel=""nofollow noreferrer"">https://www.dropbox.com/s/1h18a2u1mpuyiuo/animation.gif?dl=0</a></p>

<p>Moreover, I've tried to add animation in the following way in <code>didSet</code> of my variable.
But stil, it didn't help me either</p>

<pre><code>    UIView.animate(withDuration: 10.2, delay: 10.2, options:
        UIViewAnimationOptions.curveEaseOut, animations: {
            self.faqArrowImageView.image = UIImage(named: ""faq-arrow-rotated"")
    }, completion: { finished in
        print(""animted completed"")
    })
} else {
    self.faqArrowImageView.image = UIImage(named: ""faq-arrow"")
}
</code></pre>

<p>What could you suggest me in the following situation?</p>

<p><strong>EDIT:</strong>
Well, if someone is facing with this problem, I coped with it just changing </p>

<pre><code> self.faqTableView.beginUpdates()
 self.faqTableView.endUpdates()
</code></pre>

<p>to</p>

<pre><code>self.faqTableView.reloadData()
</code></pre>
","3911211","","1113632","","2018-01-30 21:34:13","2018-01-30 21:34:13","How can make smooth animation on expandable cell, using RxSwift","<ios><swift><animation><rx-swift>","0","5","1","","","CC BY-SA 3.0"
"44468811","1","44469122","","2017-06-10 01:58:13","","2","1332","<p>I'm a newbie to RxSwift and I'm trying to implement login facebook feature, and here's what I'm doing:</p>

<pre><code>loginButton.rx.tap
            .debug(""login tapped"")
            .flatMap { [weak self] ()-&gt;Observable&lt;AccessToken&gt; in
                guard let strongSelf = self else {
                    throw NetworkError.requestCancelled
                }
                return strongSelf.viewModel.loginFacebook(from: strongSelf)
            }
            .flatMap { [weak self] accessToken-&gt;Observable&lt;(accessToken: String, userId: String)&gt; in
                guard let strongSelf = self else {
                    throw NetworkError.requestCancelled
                }
                return strongSelf.viewModel.requestUserInfo(token: accessToken)
            }
            .flatMap { [weak self] (accessToken: String, userId: String)-&gt;Observable&lt;LoginResult&gt; in
                guard let strongSelf = self else {
                    throw NetworkError.requestCancelled
                }
                return strongSelf.viewModel.authenticate(accessToken: accessToken, userId: userId)
            }
            .catchError({ error -&gt; Observable&lt;LoginResult&gt; in
                return Observable.just(LoginResult.failure(error: error as! NetworkError))
            })
            .subscribe (onNext:{ [weak self] result in
                guard let strongSelf = self else {
                    return
                }

                switch result {
                case .success:
                    // do something with success
                    }
                case .failure(let error):
                    // do something with error
                }
            }, onCompleted: {
                print(""rx.tap completed"")
            })
            .disposed(by: disposeBag)
</code></pre>

<p>The thing is when I tap login button then close the login window of Facebook that pops up, my subscription to <code>rx.tap</code>reaches <code>onCompleted</code>, so then when I try to tap the button again, nothing happens. How should I handle this case? Any suggestion would help. </p>
","1094878","","","","","2017-06-10 03:35:56","Button with rx.tap subscription reaching completed","<ios><swift><reactive-programming><rx-swift>","1","0","2","","","CC BY-SA 3.0"
"44474109","1","44474763","","2017-06-10 13:55:18","","1","1280","<p>I am trying to observe my <code>UserDefaults</code> to monitor changes to <code>locations</code>, which is an array of <code>CLLocationCoordinate2D</code>.</p>

<p>Here's what I'm trying:</p>

<pre><code>extension UserDefaults {

    var ob: Observable&lt;[CLLocationCoordinate2D]&gt; {
        return self.rx.observe(Array.self, ""locations"")
    }

}
</code></pre>

<p>But I get this error:</p>

<pre><code>no 'observe' candidates produce the expected contextual result type 'Observable&lt;[CLLocationCoordinate2D]&gt;' (aka 'Observable&lt;Array&lt;CLLocationCoordinate2D&gt;&gt;
</code></pre>

<p>Any ideas? Thanks!</p>
","1596293","","343299","","2017-06-10 15:03:01","2017-06-10 15:03:01","RxSwift: observe an array stored in UserDefaults","<arrays><swift><nsuserdefaults><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"44497773","1","44502736","","2017-06-12 11:00:09","","2","1918","<p>I have a method 'getProducts' in my view model:</p>

<pre><code>struct MyViewModel {
    func getProducts(categoryId: Int) -&gt; Observable&lt;[Product]&gt; {
        return api.products(categoryId: categoryId)
    }
    var isRunning: Observable &lt;Bool&gt; = {
        ...
    }
}
</code></pre>

<p><code>api.products</code> is a private variable which uses <code>URLSession rx</code> extension: <code>session.rx.data(...)</code> in the background.</p>

<p>I would like to have some isRunning observer in my view model which I could subscribe to to know if it's do a network request.</p>

<p>Is it something I could do without making any amendments to my api class?</p>

<p>I'm new in reactive programming so any help would be appreciated.</p>

<p>Thanks.</p>
","1498493","","","","","2017-06-12 15:05:40","RxSwift network status observable","<ios><swift><reactive-programming><reactive-cocoa><rx-swift>","1","0","","","","CC BY-SA 3.0"
"44511412","1","","","2017-06-13 02:24:47","","0","1004","<p>I noticed when running the Rx debug code from the getting started section (<a href=""https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#debugging-memory-leaks"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#debugging-memory-leaks</a>), my resource total does not decrease when using disposed(by: disposeBag) on a subscription. However, if I instead keep a reference to the subscription and call dispose() on it, the resource total decreases.</p>

<p>I use disposed(by:) because I thought it was an easy way to accomplish the same thing, although now I am not sure. Should I avoid relying on this method for the disposal of my subscriptions? </p>

<p><strong>Note</strong>: If it matters, I use [weak self] in the closures of my subscriptions.</p>
","7964813","","1113632","","2018-01-30 20:23:49","2018-01-30 20:23:49","RxSwift: Does disposed(by: disposeBag) actually work?","<ios><swift><cocoa-touch><rx-swift>","1","0","","","","CC BY-SA 3.0"
"44522025","1","","","2017-06-13 12:48:14","","0","6677","<p>How do I cast <code>Observable&lt;Data&gt;</code> to <code>Data</code>? I.e getting the value of the observable.</p>

<pre><code>Data.rx_subscribeData()
    .map({ data -&gt; [Model] in
      return data.enumerated().map({ (index, item) in
        return Model(data: item)
      })
    })
    .bindTo(tableView.rx.items(dataSource: dataSource))
    .addDisposableTo(disposeBag)
</code></pre>
","8154698","","8154698","","2017-06-13 14:02:49","2017-06-13 15:07:37","Cannot convert value of type 'Observable<Data>' to expected argument type 'Data'","<swift><rx-swift>","1","4","","","","CC BY-SA 3.0"
"44524991","1","44579164","","2017-06-13 14:54:59","","5","1950","<p>I'm rather new to RxSwift and trying to handle the task of toggling between the empty state and populated state of a search autocomplete. </p>

<p>I have one driver that responds to a textfield text changes with length > 0 and makes network requests and another than filters on empty search queries and just populate the tableview with ""Favorites"". I initially used merge() on the two observables but the problem was that quickly clearing the text would show the favorites but when the last fetch request came back it would merge in and override the empty state. </p>

<p>I tried switching to switchLatest() hoping it would cancel the previous fetch request when the final clearResult was fired but this observable never seems to fire at all and I'm a bit stuck. Any help would be greatly appreciated!</p>

<pre><code>let queryFetchResultViewModel: Driver&lt;[NewSearchResultViewModel]&gt;  = queryText
                  .filter { $0.utf8.count &gt; 0 }
                  .throttle(0.5, scheduler: MainScheduler.instance)
                  .flatMapLatest { query in
                      appContext.placeStore.fetchPredictions(withQuery: query)
                  }
                  .map { $0.map { NewSearchResultViewModel.prediction(prediction: $0) } }
                  .asDriver(onErrorJustReturn: [])

let queryClearResultViewModel: Driver&lt;[NewSearchResultViewModel]&gt; = queryText
                      .filter { $0.utf8.count == 0 }
                      .withLatestFrom(favoritePlaces.asObservable())
                      .map { places in places.map(NewSearchResultViewModel.place) }
                      .asDriver(onErrorJustReturn: [])

searchResultViewModel = Driver.of(queryFetchResultViewModel, queryClearResultViewModel).switchLatest()
</code></pre>
","142463","","","","","2017-06-20 21:18:57","How to properly use switchLatest to toggle between search results and empty state of tableview?","<swift><rx-swift>","1","3","2","","","CC BY-SA 3.0"
"44562077","1","","","2017-06-15 08:08:21","","1","715","<p>I have a project I am trying out which is fine in Xcode 8. However, in Xcode 9 the RxSwift framework won't import into the playground. I get the following error</p>

<blockquote>
  <p>Module compiled with Swift 3.1 cannot be imported in Swift 4.0: 
  /Volumes/HGST3tb/CloudStation/Development/Frameworks/GuideView/GuideView/Carthage/Build/tvOS/RxSwift.framework/Modules/RxSwift.swiftmodule/x86_64.swiftmodule</p>
</blockquote>

<p>All frameworks apart from RxSwift are swift 3.2 but the error seems to imply that the playgrounds are compiled with 4.0. I can't see any settings to be able to change this.</p>
","1321728","","1113632","","2018-01-30 18:18:44","2018-01-30 18:18:44","Are playgrounds in Xcode 9 compiled with Swift 4.0","<swift><rx-swift><xcode9-beta>","1","1","1","","","CC BY-SA 3.0"
"44609844","1","","","2017-06-17 22:08:36","","1","2521","<p>I have a simple test project with a <code>UINavigationController</code> as my <code>rootViewController</code>.</p>

<p>I push the first <code>ViewController</code> which has a + button as right bar button item, I subscribe to its taps to present a new <code>ViewController</code> (which is identical to the previous one).
The push segue works as I expect.</p>

<p><code>UIKit</code> manages the back button for me and I think it is <code>UINavigationController</code> that makes the magic behind the scene.</p>

<p>Now, what I need to do is subscribe to the back button, but I can't find how to do this.
I have tried with</p>

<ol>
<li><p><code>navigationController.navigationBar.backItem?.backBarButtonItem?.rx.tap</code></p></li>
<li><p><code>navigationController.navigationItem.backBarButtonItem?.rx.tap</code>
but they seem to be nil, so the optional chaining prevents subscription.</p></li>
</ol>

<p>Thanks for your help, Luca-</p>
","1194774","","1503502","","2019-03-20 04:39:48","2019-03-20 04:39:48","Subscribe to UINavigationController back button with RxSwift / RxCocoa","<ios><uiviewcontroller><rx-swift><rx-cocoa>","1","2","","","","CC BY-SA 4.0"
"44616773","1","","","2017-06-18 15:50:09","","1","919","<p>If I have:</p>

<pre><code>import Moya
import RxSwift
import ObjectMapper
import Moya_ObjectMapper

provider.request(.callApi(id: id))
      .mapObject(Thing.self)
      .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))
      .observeOn(MainScheduler.instance)
</code></pre>

<p>...</p>

<pre><code>struct Thing: Mappable, Equatable {

  var id: String?

  init?(map: Map) {
  }

  mutating func mapping(map: Map) {
    id &lt;- map[""id""]
  }
</code></pre>

<p>Making an http api call and getting back json like {""id: ""123""} and it's all working great. A new Thing struct is made with the right id. But what if I want to add ""flavor"" to Thing and hard code {""id: ""123"", ""flavor"": ""something""}.</p>

<p>i.e. let's just modify the actual http response body and add <code>""flavor"": ""something""</code> before it gets to the .mapObject method. Where is the right place to tap into that?</p>

<p>And it's not just adding it to the mapping func in Thing because ""something"" is different for each id. Might be flavor: ""something1"" and then flavor: ""something2"". I have this value in the same scope as callApi(id: id) so something like:</p>

<pre><code>provider.request(.callApi(id: id))
      .addJSON(""flavor"", flavor)
      .mapObject(Thing.self)
      .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))
      .observeOn(MainScheduler.instance)
</code></pre>

<p>But <code>.addJSON</code> is something I just made up. It doesn't exist. But there must be some simple solution for this?</p>
","148736","","148736","","2017-06-18 15:55:20","2017-06-21 10:07:07","How to add a field to the Moya.Response JSON that wasn't in the real payload from the http response","<swift><swift3><rx-swift><objectmapper><moya>","1","1","","","","CC BY-SA 3.0"
"44630176","1","44725827","","2017-06-19 12:07:51","","30","26670","<p>I have a <code>label</code> with <code>isUserInteractionEnabled</code> set to <code>true</code>. Now, I need to add <code>UITapGestureRecognizer</code> for the label. Is there a way to add in <code>Rx</code> way.</p>

<p>I have looked at the RxSwift library <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxCocoa/iOS/UILabel%2BRx.swift"" rel=""noreferrer"">here</a>. Which they didn't provide any extension for adding gesture. The <code>UILabel+Rx</code> file has only <code>text</code> and <code>attributedText</code>.</p>

<p>Is there any workaround to add gesture to label?</p>
","2849567","","1113632","","2018-01-30 18:03:35","2021-04-28 16:59:54","RxSwift: How to add gesture to UILabel?","<ios><swift><rx-swift><rx-cocoa>","6","0","8","","","CC BY-SA 3.0"
"44633526","1","","","2017-06-19 14:41:27","","0","227","<p>I'm newer to RxSwift. <strong>I want to refresh the tableview to show new data</strong>.The first request that I can get the data. but when I pull down the tableview, the request didn't finished. I have no ideas about this? My code is belowing:</p>

<p>1: My viewController's code:</p>

<pre><code>class RecommendViewController: UIViewController {

lazy var tableView = DefaultManager.createTableView(HomeImageCell.self, 
                                                    HomeImageCell.idenfitier)
let disposeBag = DisposeBag()
lazy var viewModel = HomeViewModel()
lazy var dataSource: [HomeListDetailModel] = []

override func viewDidLoad() {
    super.viewDidLoad()
    viewModel.fetchRecommendList(""answer_feed"",0)
    setupTableView()
    configureRefresh()
    bindDataToTableView()
}

func setupTableView() {
    view.addSubview(tableView)
    tableView.snp.makeConstraints { (make) in
        make.edges.equalTo(0)
    }
    tableView.estimatedHeight(200)
}

func bindDataToTableView() {
    viewModel.recommend
        .observeOn(MainScheduler.instance)
        .do(onNext: { [unowned self] model in
            print(""endAllRefresh"")
            self.endAllRefresh()
        }, onError: { (error) in
            self.endAllRefresh()
            print(""error = \(error)"")
        })
        .map { [unowned self] model in
            return self.handleData(model)
        }.bind(to: tableView.rx.items(cellIdentifier: HomeImageCell.idenfitier , cellType: HomeImageCell.self )) { index, model, cell in
            cell.updateCell(data: model)
        }.disposed(by: disposeBag)
}

func configureRefresh() {
    tableView.mj_header = MJRefreshNormalHeader(refreshingBlock: { [unowned self] in
        let model = self.dataSource[0]
        self.viewModel.fetchRecommendList(""answer_feed"",model.behot_time)

    })
    tableView.mj_footer = MJRefreshAutoNormalFooter(refreshingBlock: { [unowned self] in
        let model = self.dataSource[self.dataSource.count - 1]
        self.viewModel.fetchRecommendList(""answer_feed"",model.behot_time)
    })
}

func endAllRefresh() {
    self.tableView.mj_header.endRefreshing()
    self.tableView.mj_footer.endRefreshing()
}

func handleData(_ model: HomeListModel) -&gt; [HomeListDetailModel] {
    guard let data = model.detailData else {
        return dataSource
    }
    self.dataSource = data
    return data
}
}
</code></pre>

<p>2: My ViewModel</p>

<pre><code>protocol HomeProtocol {
    func fetchRecommendList(_ category: String, _ behot_time: Int) 
}

class HomeViewModel: HomeProtocol  {
    lazy var provider = HTTPServiceProvider.shared
    var recommend: Observable&lt;HomeListModel&gt;!

    init() {}

    init(_ provider: RxMoyaProvider&lt;MultiTarget&gt;) {
       self.provider = provider
    }

    func fetchRecommendList(_ category: String, _ behot_time: Int) {
        recommend = provider.request(MultiTarget(HomeAPI.homeList(category: category,behot_time: behot_time)))
        .debug()
        .mapObject(HomeListModel.self)
    } 
 }
</code></pre>

<p>When I made a breakpoint at request method, it didn't do a request? Does anyone know it ? Thanks first</p>
","5478115","","1113632","","2018-01-30 21:37:03","2018-01-30 21:37:03","RxSwift+Moya+Moya_ObjectMapper+MJRefresh, refresh failed?","<ios><swift><uitableview><rx-swift><moya>","1","0","","","","CC BY-SA 3.0"
"44645257","1","44657100","","2017-06-20 06:21:12","","4","8824","<p>I want to make a function like this example.</p>

<p><strong>example</strong></p>

<pre><code>let num1 = Driver&lt;Int&gt;
let num2 = Driver&lt;Int&gt;
let result = Driver&lt;String&gt;

num1 = Observable.just(...).asDriver()
num2 = Observable.just(...).asDriver()
result = ??? // When both num1 and num2 are subscribed, this becomes a higher value among them as String.

// This type of code will be used
/* 
if $0 &gt;= $1 {
    return ""num1 = \($0)""
} else {
    return ""num2 = \($1)""
}
*/
</code></pre>

<p>How to implement it?</p>
","7690311","","","","","2017-06-20 15:22:47","RxSwift - multiple Observable value within one Observable","<ios><swift><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"44697603","1","44712394","","2017-06-22 11:07:17","","2","619","<p>Is it possible to change the throttle parameter (in this case ""30"") dynamically at runtime? Or do I have to create a new subscription with a new throttle time?</p>

<pre><code>let disposable = Observable.combineLatest(objectA.asObservable().skip(1), 
                                          objectB.asObservable().skip(1))
                           .throttle(30, 
                                     scheduler: ConcurrentDispatchQueueScheduler(qos: .background))
                           .subscribe(onNext: { [unowned self] _ in
                    self.update()
            })
</code></pre>

<p>My solution would be to dispose of the current subscription and create a new subscription with the new desired throttle time. But is there a better solution?</p>
","1113632","","1113632","","2017-06-22 12:39:51","2017-06-23 20:28:46","change throttle parameter dynamically","<ios><swift><rx-swift><frp><throttling>","1","0","1","","","CC BY-SA 3.0"
"44735063","1","","","2017-06-24 09:47:05","","1","49","<p>I have 3 sequences to find out if I need to save changes to a text file:</p>

<ol>
<li><strong>Text ID</strong> (changed when showing another text; its presence also signifies ""here's a note"")</li>
<li><strong>Text editing status changes</strong> (as a guard-clause, so to speak, to ensure the user is really editing and not just viewing the text)</li>
<li><strong>Content change</strong> (when the user types into a text field)</li>
</ol>

<p>The order in which elements are produced matters for the resulting combination. The list above represents the happy path.</p>

<p>A RxSwift/RxTest test case:</p>

<pre><code>func testContentThenEditingThenChange_ProducesEdit() {

    let identifier = scheduler.createHotObservable([next(300, ""identifier"")])
    let isEditing = scheduler.createHotObservable([next(400, true)])
    let changedText = scheduler.createHotObservable([next(500, ""foo"")])

    let viewModel = TextEditingViewModel(
        identifier: identifer.asObservable(),
        changedText: changedText.asObservable(),
        isEditing: isEditing.asObservable())

    let result = scheduler.start { viewModel.textChange }

    XCTAssertEqual(result.events, [next(500, TextChange(identifier: ""identifier"", text: ""foo""))])
}
</code></pre>

<p>How would you write this and keep the readability high?</p>
","1460929","","","","","2017-06-24 09:47:05","How to approach combining sequences and conditions in a natural style in Rx(Swift)","<swift><system.reactive><rx-swift>","1","0","","","","CC BY-SA 3.0"
"44755988","1","44794562","","2017-06-26 08:50:04","","1","1150","<p>I'm following the RxSwift Example <a href=""https://github.com/ReactiveX/RxSwift/tree/master/RxExample/RxExample/Examples/GitHubSignup/UsingDriver"" rel=""nofollow noreferrer"">GitHub SignUp using Driver</a>, and ended up with something similar.</p>

<p>I have a network request that performs authentication and returns a <code>Observable&lt;AuthenticationResult&gt;</code>, in such way that I have this:</p>

<pre><code>public enum AuthenticationResult {
    case canceled
    case usernameEmpty
    case passwordEmpty
    case invalidCredentials
    case granted(AccessToken)
    case other(Error)
}

// Authentication result status
let authenticationResult: Driver&lt;AuthenticationResult&gt;

authenticationResult = input.loginTaps.withLatestFrom(usernameAndPassword)
    .flatMapLatest({ (username, password) -&gt; SharedSequence&lt;DriverSharingStrategy, AuthenticationResult&gt; in
        return API.authenticate(username: username, password: password, applicationScope: .property).trackActivity(signingIn).asDriver(onErrorJustReturn: .canceled)
    })
    .flatMapLatest({ (result) -&gt; SharedSequence&lt;DriverSharingStrategy, AuthenticationResult&gt; in

        switch result {

        case .granted(_):
            // The closure is expecting a return value here that I don't have!
            let portfoliosNavigationController = UINavigationController(rootViewController: PortfoliosTableViewController())
            wireframe.show(viewController: portfoliosNavigationController)

        default:

            return wireframe.promptFor(result.description, cancelAction: ""OK"", actions: [])
                .map({ (_) -&gt; AuthenticationResult in
                    result
                }).asDriver(onErrorJustReturn: result)

        }

    })
</code></pre>

<p>Now, here's the <strong>issue</strong>:</p>

<p>My <code>flatMapLatest</code> expects a <code>SharedSequence&lt;DriverSharingStrategy, AuthenticationResult&gt;</code> and I don't always have that to return!</p>

<p>Inside the closure, I can return <code>SharedSequence&lt;DriverSharingStrategy, AuthenticationResult&gt;</code> <strong>if authentication succeeds</strong>, because my <code>wireframe.promptFor</code> returns an observable. </p>

<p>However, when <strong>authentication fails</strong>, I don't have an observable to return. My <code>wireframe.show</code> method doesn't return anything.</p>

<p>How can I handle this scenario?</p>

<p>Thanks</p>
","1544047","","1544047","","2017-06-26 08:55:20","2017-06-28 05:51:46","How to return different types from flatMapLatest in RxSwift?","<swift><rx-swift>","1","2","1","","","CC BY-SA 3.0"
"44820437","1","","","2017-06-29 08:51:01","","5","709","<p>So ive been using Rxswift for a while and its been working well. Ive managed to get all my code under test but Im struggling to figure out how to test searching with searchbar.rx.bindTo . </p>

<p>There are many tutorials of how to use RxSwift for searching and returning results on a tableview but in none of those tutorials do they show you how to unit test it. 
<a href=""https://www.thedroidsonroids.com/blog/ios/rxswift-by-examples-1-the-basics/"" rel=""nofollow noreferrer"">https://www.thedroidsonroids.com/blog/ios/rxswift-by-examples-1-the-basics/</a></p>

<p>The above linked shows what im trying to achieve with the searchbar and populating the TableView.</p>

<p>Ive tried testing it with RxBlocking but my tests all seem to hang. 
systemUnderTest is the viewModel
results is the Observable&lt;[T]> that comes back from the service.</p>

<pre><code>let results = systemUnderTest.results.toBlocking()
    let noneObservableList = try! results.single()

    //Then
    XCTAssert(noneObservableList?.count == expectedCount)
</code></pre>

<p>It hangs on the try! results.single() and never hits the assert. Anyone know how to test this.</p>

<p>Thanks in advance.</p>

<p>This is systemUnderTest: </p>

<pre><code>public class SearchViewModel: SearchViewModelContract {

public var query: Variable&lt;String?&gt; = Variable(String.EmptyString())
public var results: Observable&lt;[ThirdPartySite]&gt;
let minimumCharacterCount = 4
let dueTime = 0.3
let disposeBag = DisposeBag()

public init() {
    results = Observable.just([Object]())
    results = query.asObservable().throttle(dueTime, scheduler: MainScheduler.instance).flatMapLatest{
        queryString  -&gt; Observable&lt;Object&gt; in

        if let queryString = queryString {
            if queryString.characters.count &gt;= self.minimumCharacterCount {
                return self.Something(siteName: queryString)
            }
            return Observable.just(Object(in: Object()))
        }
        return Observable.just(Object(in: Object()))
        }.map { results in
            return results.items
        }.catchErrorJustReturn([Object]()).shareReplay(1)
    }
}
</code></pre>
","3256267","","3256267","","2018-01-22 10:32:30","2019-09-08 21:36:54","RxSwift : how to Unit Test Searching in Searchbar and displaying results in tableview","<swift><unit-testing><uisearchbar><reactive-cocoa><rx-swift>","1","1","2","","","CC BY-SA 3.0"
"44829725","1","44831429","","2017-06-29 15:45:23","","1","1003","<p>I'm very new to RxSwift and RxCocoa. I want to set image to UIButton by using RxCocoa.</p>

<pre><code> settingButton.rx.image(for: .normal).onNext(UIImage.init(named: ""closeButton""))
</code></pre>

<p>Any one have idea how to set image to UIButton? Am i doing right?</p>
","1216094","","1216094","","2017-06-29 15:57:58","2017-06-29 17:22:21","How to set image to UIButton by using RxCocoa","<swift><uibutton><uiimage><rx-swift><rx-cocoa>","1","3","","","","CC BY-SA 3.0"
"44832750","1","44833369","","2017-06-29 18:44:02","","11","20288","<p>To create an observable array using <code>RxSwift</code> in Swift 2, I use to do this:</p>

<pre><code>[1, 2, 3].toObservable().subscribeNext { print($0) }
</code></pre>

<p>But in Swift 3, it doesn't work anymore, I got this error:</p>

<blockquote>
  <p>Value of type '[Int]' has no member 'toObservable'</p>
</blockquote>

<p>How can I create an <code>RxSwift</code> observable array from a swift array?</p>
","3701102","","5433235","","2017-06-29 20:24:49","2017-07-01 07:04:51","Observe array in Swift 3 using RxSwift","<ios><swift><rx-swift><reactivex>","2","0","4","","","CC BY-SA 3.0"
"44851032","1","","","2017-06-30 16:24:56","","0","1264","<p>similar to <a href=""https://stackoverflow.com/questions/41911565/how-to-get-error-statuscode-from-moyaerror"" title=""this"">this</a> but this time i need to retrieve the JSOn response of the server.</p>

<p>here is my existing code: </p>

<pre><code>return Observable.create{ observer in
            let _ = self.provider
                .request(.getMerchantDetails(qrId: qrId))
                .filterSuccessfulStatusCodes()
                .mapJSON()
                .subscribe(onNext: { response in
                    observer.onNext(RQRMerchant(json: JSON(response)))
                }, onError: { error in
                    observer.onError(error)
                })
            return Disposables.create()
</code></pre>

<p>my question is: I can get the error response code 404 by <code>error.localizedDescription</code> But I also want to get the JSON response of the 404 HTTP request.</p>
","4377095","","4377095","","2017-07-03 01:17:54","2017-10-26 10:11:02","how to get the error response from MoyaError","<swift3><rx-swift><moya>","2","0","","","","CC BY-SA 3.0"
"44886093","1","44889220","","2017-07-03 12:51:10","","1","742","<p>I'm using the latest version of Moya with RxSwift and I've encountered a logical issue for which I can't find a solution, at the moment.</p>

<p>Let's say that I have a UITableViewController with a ViewModel that implements the following interface:</p>

<pre><code>protocol ListViewModelType {

    var items: Observable&lt;[Item]&gt; { get }

}
</code></pre>

<p>The <code>items</code> property is implemented as (using EVReflection):</p>

<pre><code>var items: Observable&lt;[Therapy]&gt; {
        get {
            let provider = RxMoyaProvider&lt;ItemService&gt;()
            return provider
                .request(.all)
                .map(toArray: Item.self)
        }
    }
</code></pre>

<p>In the viewDidLoad method of the UITableViewController, I have set up a binding between the items property and the tableView via the following code:</p>

<pre><code>self.viewModel.items
            .bind(to: tableView.rx.items(cellIdentifier: cellIdentifier, cellType: cellType)) { row, element, cell in
                // cell configuration code
            }
            .disposed(by: self.disposeBag)
</code></pre>

<p>Now, I would like to refresh the content of the UITableView to reflect changes that the user has done through other parts of the app. Considering that the RxMoyaProvider returns an Observable, this should be easily done through another value emitted by the Observable, but I don't know how to communicate to the provider that it should refresh the content from the server and put it into the same Observable.</p>

<p>Am I missing something here? Is there a more recommended way to bind a UITableView to a list of objects coming from a RxMoyaProvider?</p>
","925537","","","","","2017-07-03 15:24:23","Repeat request in RxMoya","<ios><swift><uitableview><rx-swift><moya>","1","0","1","","","CC BY-SA 3.0"
"44893414","1","","","2017-07-03 20:23:19","","1","404","<p>I'm trying to implement a simple TableView with Realm DataSource.
First, I create a ChangeSet</p>

<pre><code>cars = realm.objects(CarModel.self)    
carChangeset = Observable.changeset(from: cars, synchronousStart: false).observeOn(MainScheduler.instance)
</code></pre>

<p>and I created an instance of <code>RxTableViewRealmDataSource</code></p>

<pre><code>let dataSource = RxTableViewRealmDataSource&lt;CarModel&gt;(cellIdentifier: ""Cell"", cellType: CarListTableViewCell.self) { (cell, ip, element) in
    cell.viewModel = CarDetailViewModel(car: element)
}
</code></pre>

<p>Then, I bound my changeset to the tableview</p>

<pre><code>carChangeset
    .bind(to: tableView.rx.realmChanges(dataSource))
    .disposed(by: bag)
</code></pre>

<p>I run my project, but, no matter how I swipe a cell in my TableView, the ""delete"" button will never appear.</p>

<p>After looking for a solution to my problem, I read that, in order to a TableView to present the ""red delete"" button when swiping, the DataSource delegate must implement <code>tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath)</code>. As <code>RxTableViewRealmDataSource</code> is not declared <code>open</code> on the original distribution, and I don't want to modify the sources, I created an extension that implements this function:</p>

<pre><code>extension RxTableViewRealmDataSource where E: CarModel {
    public func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {
        if editingStyle == .delete {
            print(""Should Delete car"")
        }
    }

    public func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool {
        return true
    }
}
</code></pre>

<p>Still nothing. My TableView does not react to the swipe gesture.</p>

<p>Is this a bug on the RxRealm/RxRealmDataSource implementation? Am I doing something wrong? Or do I missed something?</p>

<p>Thanks in advance,</p>
","8250219","","1991710","","2017-09-16 16:24:19","2017-09-16 16:24:19","When binding UITableView with RxTableViewRealmDataSource, swipe for delete is disabled","<ios><uitableview><swift3><rx-swift>","0","0","","","","CC BY-SA 3.0"
"44928752","1","44944644","","2017-07-05 14:16:23","","2","1062","<p>How can I disable auto scroll to the top of table view when I append new data to data source of it.</p>

<p>The problem is visible in the following gif.</p>

<p><a href=""https://i.stack.imgur.com/o3erw.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/o3erw.gif"" alt=""enter image description here""></a></p>

<p>Edit: Added ViewController, ViewModel and MessageEntity. </p>

<p>Used frameworks are: RxSwift, RxDataSources for reactive datasource of table view.</p>

<p>ViewController:</p>

<pre><code>class RabbitMqVC: BaseViewController {

    struct Cells {
        static let message = ReusableCell&lt;MessageCell&gt;(nibName: ""MessageCell"")
        static let messageTheir = ReusableCell&lt;MessageCellTheir&gt;(nibName: ""MessageCellTheir"")
    }

    @IBOutlet
    weak var tableView: UITableView!{
        didSet{
            rabbitMqViewModel.sections
                    .drive(tableView.rx.items(dataSource: dataSource))
                    .addDisposableTo(disposeBag)
        }
    }

    private let dataSource = RxTableViewSectionedAnimatedDataSource&lt;RabbitMqViewModel.MessageSections&gt;()
    private let rabbitMqViewModel : rabbitMqViewModel


    init(rabbitMqViewModel: rabbitMqViewModel) {
        self.rabbitMqViewModel = rabbitMqViewModel
        super.init(nibName: ""RabbitMqVC"", bundle: nil)

        dataSource.configureCell = { _, tableView, indexPath, item in
            let randomNumber = 1.random(to: 2)
            let cell = randomNumber == 1 ? tableView.dequeue(Cells.message, for: indexPath) : tableView.dequeue(Cells.messageTheir, for: indexPath)

            cell.message = item

            return cell
        }

    }


    override func viewDidLoad() {
        super.viewDidLoad()

        tableView.register(Cells.message)
        tableView.register(Cells.messageTheir)
        tableView.rowHeight = UITableViewAutomaticDimension
        tableView.estimatedRowHeight = 80

    }

}
</code></pre>

<p>ViewModel:</p>

<pre><code>class RabbitMqViewModel: ViewModel {

    enum MessageSections: AnimatableSectionModelType {

        typealias Item = MessageEntity
        typealias Identity = Int

        case messages(messages: [MessageEntity])

        var items: [Item] {
            switch self {
            case .messages(messages:let messages):
                return messages
            }
        }

        var identity: Int {
            return 1
        }

        init(original: MessageSections, items: [Item]) {

            switch original {
            case .messages:
                self = .messages(messages: items)
            }
        }
    }

    // input
    let didLoad = PublishSubject&lt;Void&gt;()

    //output
    let sections: Driver&lt;[MessageSections]&gt;

    init(service: RabbitMqService,){
        let messages: Observable&lt;[MessageEntity]&gt; = didLoad
                .flatMapLatest { _ -&gt; Observable&lt;[MessageEntity]&gt; in
                    return service.listenMessages()
                }
                .share()

        self.sections = messages
                .map { (messages) -&gt; [RabbitMqViewModel.MessageSections] in
                    var sections: [MessageSections] = []
                    sections.append(.messages(messages: messages))

                    return sections
                }
                .asDriver(onErrorJustReturn: [])


    }


}
</code></pre>

<p>MessageEntity:</p>

<pre><code>struct MessageEntity {

    let id: String
    let conversationId: String
    let messageText: String
    let sent: Date
    let isSentByClient: Bool
    let senderName: String
    let commodityClientId : Int?

}

extension MessageEntity: IdentifiableType, Equatable {

    typealias Identity = Int

    public var identity: Identity {
        return id.hashValue
    }
    public static func ==(lhs: MessageEntity, rhs: MessageEntity) -&gt; Bool {
        return lhs.id == rhs.id
    }
}
</code></pre>
","3249421","","3747037","","2018-01-30 16:17:57","2018-01-30 16:17:57","How to disable automatic scrolling to top","<ios><swift><rx-swift>","1","6","","","","CC BY-SA 3.0"
"44959834","1","44994678","","2017-07-06 22:27:36","","0","281","<p>when i use RxSwift, i must write many many addDisposableTo, how can i remove it?</p>

<pre><code>usernameTextField.rx.text.orEmpty
            .bindTo(viewModel.username)
            .addDisposableTo(disposeBag)

    passwordTextField.rx.text.orEmpty
        .bindTo(viewModel.password)
        .addDisposableTo(disposeBag)

    repeatPasswordTextField.rx.text.orEmpty
        .bindTo(viewModel.repeatPassword)
        .addDisposableTo(disposeBag)
</code></pre>
","8210445","","1113632","","2018-10-06 04:25:56","2018-10-06 04:25:56","How can i remove “addDisposableTo” when i used RxSwift","<swift><rx-swift>","2","1","","","","CC BY-SA 3.0"
"44986669","1","44990007","","2017-07-08 13:19:03","","-4","62","<p>Now I am reading the famous library ""RxSwift"", but I have a question. </p>

<p>See <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Map.swift"" rel=""nofollow noreferrer"">this page</a>.</p>

<p>As you know the method <code>_map&lt;Element, R&gt;(source: Observable&lt;Element&gt;, transform: @escaping (Element) throws -&gt; R)</code> doesn't belong to any class or extension or something like that.  </p>

<p>How is this explained?</p>

<p>I know the concept of ""top-level"", but this is different with it.</p>

<p>Could you explain?</p>
","7055693","","5501940","","2017-07-08 13:51:52","2017-07-08 19:27:20","Swift: The method which belongs to nothing","<swift><rx-swift>","1","7","","","","CC BY-SA 3.0"
"45013420","1","","","2017-07-10 13:31:33","","1","732","<p>I am adopting the MVVM pattern in my iOS application. I expose a range of Observables as public properties in my view model and bind the UI to these properties. These Observables are created from a private connectable observable. </p>

<p>A view controller class then calls the ""execute"" method to fire the network request. However, if it fails for any reason, I'd like to be able to call ""execute"" again but this does not work. I believe this is due to the fact that the connectable observable has completed.</p>

<p>How can I achieve this without having to recreate the view model each time? I know I could do this by transforming a simple execute publish subject to the userDetailsObservable by using flatMap but I rely on the onCompleted event for other functionality. The onCompleted event would be lost as the publish subject remains active.</p>

<p><strong>Connectable Observable Solution</strong></p>

<pre><code>class ViewModel {
    public var userName: Observable&lt;String&gt; {
         self.userDetailsObservable.map {
             return $0[""username""]
         }
    }

    public var address: Observable&lt;String&gt; {
         self.userDetailsObservable.map {
             return $0[""address""]
         }
    }

    public func execute() {
        self.userDetailsObservable.connect()
    }

    private lazy var userDetailsObservable: ConnectableObservable&lt;JSON&gt; {
        return Observable.create { observer in
            // execute network request
            // assume there is a json object and error object returned
            if error != nil {
                observer.onError(error)
            } else {
                observer.onNext(json)
            }
            observer.onCompleted()
        }.publish()
    }
}
</code></pre>

<p><strong>The FlatMap solution</strong> </p>

<p>This would execute the network request every time an event is pushed on the execute subject. (execute.onNext()). The problem here is that the onCompleted event is lost as we are transforming a publish subject.</p>

<pre><code>class ViewModel {
    public var userName: Observable&lt;String&gt; {
         self.userDetailsObservable.map {
             return $0[""username""]
         }
    }

    public var address: Observable&lt;String&gt; {
         self.userDetailsObservable.map {
             return $0[""address""]
         }
    }

    public var execute: PublishSubject&lt;Void&gt;()

    private lazy var userDetailsObservable: Observable&lt;JSON&gt; {
        return self.execute.flatMapLatest { _ in
            Observable.create { observer in
                // execute network request
                // assume there is a json object and error object returned
                if error != nil {
                    observer.onError(error)
                } else {
                    observer.onNext(json)
                }
                observer.onCompleted()
            }
        }.share()
   }
</code></pre>
","1570169","","3747037","","2018-01-30 16:16:22","2018-01-30 16:16:22","RxSwift: Connect to Connectable Observable multipe times","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 3.0"
"45030852","1","45059955","","2017-07-11 09:40:52","","1","47","<p>I perform a task when the application enters the foreground.
I also want to perform this task as soon as my view model is initialised.</p>

<p>How can I write this to avoid copy and pasting the task code?
Currently the code looks like this:</p>

<pre><code>init(dependencies: Dependencies) {
        self.dependencies = dependencies

        dependencies.apiClient.notificationsCount()
            .map { $0.value &gt; 0 ? String($0.value) : nil }
            .bind(to: tabBadgeValue)
            .disposed(by: disposeBag)
        dependencies.notification.notification(for: .appWillEnterForeground)
            .map { _ in () }
            .flatMapLatest(dependencies.apiClient.notificationsCount)
            .map { $0.value &gt; 0 ? String($0.value) : nil }
            .bind(to: tabBadgeValue)
            .disposed(by: disposeBag)
    }
</code></pre>
","1486106","","","","","2017-07-12 14:05:11","RxSwift Optimising Triggers","<swift><optimization><rx-swift>","1","0","","","","CC BY-SA 3.0"
"45040193","1","45040962","","2017-07-11 16:39:21","","7","7588","<p>I'm combining a <code>viewDidAppear</code> and <code>filter</code> Drivers with RxSwift. And they work great. But when I introduce a third Driver, it stops calling <code>flatMapLatest</code> on the latest combine.</p>

<p>In my View Controller, I have these Drivers:</p>

<pre><code>let filter: Driver&lt;String&gt;
let viewDidAppear: Driver&lt;Void&gt;
let refresh: Driver&lt;Void&gt;
</code></pre>

<p>And in my view model:</p>

<pre><code>// On viewDidAppear, I download a list of portfolios

let viewDidAppearPortfolios = viewDidAppear
    .flatMapLatest({ (_) -&gt; Driver&lt;Result&lt;[PortfolioModel]&gt;&gt; in        
        return networkService.request(Router.portfolios)!
            .responseCollections()
            .trackActivity(fetching)
            .asDriver(onErrorJustReturn: .failure(NSError()))

    })
    .flatMapLatest({ (result: Result&lt;[PortfolioModel]&gt;) -&gt; Driver&lt;[PortfolioModel]&gt; in

        switch result {
        case .success(let value): return Driver.just(value)
        case .failure(_): return Driver.just([])
        }

    })

// Then I combine with a filter from my search bar.

self.portfolios = Driver.combineLatest(viewDidAppearPortfolios, filter)
    .flatMapLatest { (portfolios: [PortfolioModel], filter: String) -&gt; Driver&lt;[PortfolioModel]&gt; in

        if filter.isEmpty {
            return Driver.just(portfolios)
        }

        return Driver.just(portfolios.filter({ (portfolio) -&gt; Bool in
            portfolio.portfolio.localizedCaseInsensitiveContains(filter)
        }))

    }
</code></pre>

<p><strong>The above works!</strong></p>

<p>The network <strong>requests a list</strong> of portfolios, and <strong>I'm able to filter</strong> those results as I type, client side.</p>

<p>However, I'd like for the user to <strong>pull to refresh</strong>, and trigger the network <strong>request again</strong>! And so, I combine with my refresh driver.</p>

<p>And this:</p>

<pre><code>Driver.combineLatest(viewDidAppearPortfolios, filter)
</code></pre>

<p>Becomes this:</p>

<pre><code>Driver.combineLatest(viewDidAppearPortfolios, filter, refresh)
</code></pre>

<p><strong>Problem!</strong></p>

<p>After combining with <code>refresh</code> the <code>flatMapLatest</code> is <strong>no longer called on viewDidAppear</strong>! Only if I manually pullToRefresh. </p>

<pre><code>Driver.combineLatest(viewDidAppearPortfolios, filter, refresh).flatMapLatest { _,_,_ in 
    // No longer get's called on viewDidAppear after combining with refresh
}
</code></pre>

<ol>
<li>The <code>viewDidAppearPortfolios</code> still executes, so the network request
is getting called! </li>
<li>Only if I manually pull to refresh do I get the
list of portfolios that I previously requested...</li>
</ol>

<p>Any idea why?</p>

<p>Thank you!</p>
","1544047","","3040446","","2018-11-04 15:03:58","2021-02-17 05:44:08","How to properly combine multiple Drivers with RxSwift?","<swift><rx-swift><rx-cocoa>","1","0","1","","","CC BY-SA 4.0"
"45072909","1","","","2017-07-13 06:26:38","","1","1262","<p>I have a question about the async api.<br>
May I wait async api to get the response?<br>
In my case, I want when ""isAgreen == true"" and show alertcontroller to user.<br>
I dont know how to do it.<br>
Thanks.<br></p>

<pre><code>Class UserModel:NSObject { 

var isAgree:Bool?

func put(_ params:[String:Any], _ callback: @escaping (JSON) -&gt; Void){

let url = self.customUrl(params)
self.requestJSON( .put, url: url, params: params, callback: { json in
  callback(json)
})
}

func getStatus() {

   API.getUserStatus.put(params, { json in

      guard json[""status""] != ""error"" else {

          if json[""error""] == ""friend agree"" {

              self.isAgreen = true

              self.friendship.updateDatabase()
          }
          return
      }
    })
  }
}


class FriendInfoViewController: UIViewController {

func buttonClick(sender:UIButton) {

   let user:UserModel = UserModel()
   user.getStatus()

   if user.isAgreen == true{ //Wait to response and show alertViewController

        let alert = showAlert(title: ""Warning"", message: ""Test"", style: .alert)
        self.present(alert, animated: true, completion: nil)
     }
   }
}
</code></pre>
","8176735","","","","","2017-07-13 11:03:40","How to Wait async api response using Alamofire and Rxswift?","<ios><swift><asynchronous><alamofire><rx-swift>","2","2","","","","CC BY-SA 3.0"
"45096111","1","","","2017-07-14 06:28:13","","1","177","<p>We're using Firebase DB together with RxSwift and are running into problems with transactions. I don't think they're related to the combination with RxSwift but that's our context.</p>

<p>Im observing a data in Firebase DB for any value changes:</p>

<pre><code>let child = dbReference.child(uniqueId)
let dbObserverHandle = child.observe(.value, with: { snapshot -&gt; () in
    guard snapshot.exists() else {
        log.error(""empty snapshot - child not found in database"")
        observer.onError(FirebaseDatabaseConsumerError(type: .notFound))
        return
    }

    //more checks
    ...

    //read the data into our object
    ...

    //finally send the object as Rx event
    observer.onNext(parsedObject)
}, withCancel: { _ in
    log.error(""could not read from database"")
    observer.onError(FirebaseDatabaseConsumerError(type: .databaseFailure))
})
</code></pre>

<p>No problems with this alone. Data is read and observed without any problems. Changes in data are propagated as they should.</p>

<p>Problems occur as soon as another part of the application modifies the data that is observer with a transaction:</p>

<pre><code>dbReference.runTransactionBlock({ (currentData: FIRMutableData) -&gt; FIRTransactionResult in
    log.debug(""begin transaction to modify the observed data"")

    guard var ourData = currentData.value as? [String : AnyObject] else {
        //seems to be nil data because data is not available yet, retry as stated in the transaction example https://firebase.google.com/docs/database/ios/read-and-write
        return TransactionResult.success(withValue: currentData)
    }
    ...            
    //read and modify data during the transaction
    ...

    log.debug(""complete transaction"")

    return FIRTransactionResult.success(withValue: currentData)
}) { error, committed, _ in
    if committed {
        log.debug(""transaction commited"")
        observer(.completed)
    } else {
        let error = error ?? FirebaseDatabaseConsumerError(type: .databaseFailure)
        log.error(""transaction failed - \(error)"")
        observer(.error(error))
    }
}
</code></pre>

<p>The transaction receives nil data at first try (which is something you should be able to handle. We just just call 
<code>return TransactionResult.success(withValue: currentData)</code>
in that case.
But this is propagated to the observer described above. The observer runs into the ""empty snapshot - child not found in database"" case because it receives an empty snapshot.</p>

<p>The transaction is run again, updates the data and commits successfully. And the observer receives another update with the updated data and everything is fine again.</p>

<p>My questions:
Is there any better way to handle the nil-data during the transaction than writing it to the database with <code>FIRTransactionResult.success</code>
This seems to be the only way to complete this transaction run and trigger a re-run with fresh data but maybe I'm missing something-
Why are we receiving the empty currentData at all? The data is obviously there because it's observed.
The transactions seem to be unusable with that behavior if it triggers a 'temporary delete' to all observers of that data.</p>

<p><strong>Update</strong></p>

<p>Gave up and restructured the data to get rid of the necessity to use transactions. With a different datastructure we were able to update the dataset concurrently without risking data corruption.</p>
","1103945","","1103945","","2017-08-03 07:21:18","2017-08-03 07:21:18","FIRDatabaseReference observe gets empty updates while another reference is running a transaction","<firebase><firebase-realtime-database><rx-swift>","0","0","","","","CC BY-SA 3.0"
"45101153","1","","","2017-07-14 10:51:32","","2","766","<p>I'd like to extend a protocol with a function if the <code>associatedtype E</code> is a <code>Result&lt;T&gt;</code>. What I want to achieve is something like the following:</p>

<pre><code>extension SharedSequenceConvertibleType where E == Result {

    func filterResult(success: Bool) -&gt; RxCocoa.SharedSequence&lt;Self.SharingStrategy, Self.E&gt; {
        return self.filter { result in
            switch (result) {
            case .Success(_):
                return success
            case .Failure(_):
                return !success
            }
        }
    }
}

enum Result&lt;Element&gt; {
    case Success(Element)
    case Failure(Swift.Error)
}
</code></pre>

<p>Unfortunately, Swift complains about <code>Reference to generic type 'Result' requires arguments in &lt;…&gt;</code>. If I apply the suggested Fix-It to change it to <code>Result&lt;Any&gt;</code>, I cannot use <code>filterResult</code> on <code>Result&lt;MyObject&gt;</code> <code>'Result&lt;LoginInfo&gt;' is not convertible to 'Result&lt;Any&gt;'</code>. I don't actually care about the <code>Element</code> type here, as you can see.</p>

<p>Is there a way to achieve this in Swift 3?</p>
","3415618","","","","","2017-07-14 11:24:04","Use generic type without argument in protocol extension clause","<swift3><rx-swift>","1","0","","","","CC BY-SA 3.0"
"45112973","1","45112974","","2017-07-14 23:40:58","","8","11197","<p>I have a Completable being returned from a simple function. 
This is not an async call, so I just need to return a succcessful completion or error depending on a conditional (using Rx here so I can tie into other Rx usages):</p>

<pre><code>func exampleFunc() -&gt; Completable {
    if successful {
        return Completable.just() // What to do here???
    } else {
        return Completable.error(SomeErrorType.someError)
    }
}
</code></pre>

<p>The error case works pretty easily, but am having a block on how to just return a successful completable (without needing to <code>.create()</code> it). </p>

<p>I was thinking I just need to use Completable's <code>.just()</code> or <code>.never()</code>, but <code>just</code> is requiring a parameter, and <code>never</code> doesn't seem to trigger the completion event.</p>
","991856","","991856","","2017-07-16 12:51:09","2017-07-16 12:51:09","Return a completable in RxSwift without using a create block","<ios><swift><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"45128622","1","45171067","","2017-07-16 12:30:40","","9","6747","<p>I understand that if I want to have multiple subscriptions to one observable I need to use .share() operator, but I do not understand why exactly? </p>

<p>I looking for some example based on local data (not network) to demonstrate what is the difference between using .share() and without it.</p>

<p>What's the operator really do - using data from previous subscription or create new one? </p>
","4939621","","3747037","","2018-01-30 16:08:26","2018-01-30 16:08:26","RxSwift multiple subscriptions to one observable","<ios><swift><rx-swift>","1","0","4","","","CC BY-SA 3.0"
"45131228","1","45169953","","2017-07-16 17:02:30","","2","4858","<p>How to get the values while moving the UISlider?</p>

<p>I'm using the following code:</p>

<p><strong>ViewModel:</strong></p>

<pre><code>import Foundation
import RxSwift

final class ViewModel {

    private let disposeBag = DisposeBag()

    var value: Variable&lt;Float&gt;

    init() {

        self.value = Variable(Float(0.0))

    }
}
</code></pre>

<p><strong>ViewController:</strong></p>

<pre><code>@IBOutlet var slider: UISlider!

private var viewModel: ViewModel!
private let disposeBag = DisposeBag()

override func viewDidLoad() {
    viewModel = ViewModel()

    slider.rx.value
        .subscribe(onNext: { (value) in
            self.viewModel.value = Variable(Float(value))
        })
        .addDisposableTo(disposeBag) 
}
</code></pre>

<p>But this code does not work. What's my mistake?</p>
","6723659","","6723659","","2017-07-17 15:48:21","2019-11-13 09:59:22","How to get change the value of the UISlider","<swift><rx-swift>","3","4","","","","CC BY-SA 3.0"
"45141151","1","45141646","","2017-07-17 09:57:23","","15","6519","<p>What are the differences between observable and subject.
When I define a observable type variable. It can emit onNext,onComplete,onDispose. However subject can do the same. When should I use observable and in what case should I use subject?</p>
","4732229","","","","","2017-07-18 23:20:26","What are the differences between observable and subject in rxSwift","<ios><swift><rx-swift>","3","0","4","","","CC BY-SA 3.0"
"45191727","1","46077937","","2017-07-19 13:13:55","","3","225","<p>I'm stuck putting all of the above together. I'll appreciate if I can get any input.</p>

<p>Here's my short setup:</p>

<pre><code>typealias RealmObject = Object

/// Extension to ignore undefined keys when mapping
extension RealmObject : EVReflectable {
    open override func setValue(_ value: Any?, forUndefinedKey key: String) { }
}
</code></pre>

<p>Sample Realm models:</p>

<pre><code>class Product: RealmObject {

    dynamic var productId: String = """"  
    let productLanguages = List&lt;ProductLanguage&gt;()

    override static func primaryKey() -&gt; String? {
        return ""productId""
    }
}

class ProductLanguage: RealmObject {

    dynamic var productLanguageId: String = """"
    dynamic var languageCode: String = """"
    dynamic var productName: String = """"

    override static func primaryKey() -&gt; String? {
        return ""productLanguageId""
    }
}
</code></pre>

<p>To fetch product details I use Moya and RxSwift:</p>

<pre><code>func getProduct(productItemKey: String) -&gt; Observable&lt;Product&gt; {
    return provider.request(.product(productId: productItemKey)).map(to: Product.self)
}
</code></pre>

<p>I think <code>.map(to: Product.self)</code> does not work with realm Lists out of the box. For each object inside the list I get an error:</p>

<pre><code>ERROR: Could not create an instance for type 
dict:{
    CreateDate = ""2015-10-12T11:11:50.013Z"";
    IngredientList = ""Acao ingredient"";
    LanguageCode = ""en-US"";
    ProductId = ""d6bb0084-6838-11e5-9225-00ac14ef2300"";
    ProductLanguageId = ""f96848d0-df77-4594-99b7-d390bb127891"";
    ProductName = Acao;
    Tagline = ""The smart drink - 100% organic, vegan energy booster with guara""
}
</code></pre>

<p>Is there any other way to map Moya response into Realm objects? </p>

<p>Thank you very much for any input!</p>
","7215777","","","","","2017-09-06 14:32:15","EVReflection + Moya + Realm + RxSwift - Could not create an instance for type dict","<ios><swift><realm><rx-swift><moya>","1","0","","","","CC BY-SA 3.0"
"45205245","1","","","2017-07-20 04:34:11","","2","721","<p>I am trying to observe on custom class delegates. I started with </p>

<pre><code>public var didTapAvatar: Observable&lt;()&gt; {
    return delegate
        .methodInvoked(#selector(JSQMessagesCollectionViewDelegateFlowLayout.collectionView(_:didTapAvatarImageView:at:)))
        .map { _ in ()
    }
}
</code></pre>

<p>which will cause an error as below</p>

<blockquote>
  <p>Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[RxCocoa.RxCollectionViewDelegateProxy collectionView:layout:heightForCellTopLabelAtIndexPath:]: unrecognized selector sent to instance 0x618000298b00</p>
</blockquote>

<p>I later tried this </p>

<pre><code>public var jsqdelegate: DelegateProxy {
    return RxJSQMessageCollectionViewCellProxy(parentObject: base)
}

public var didTapAvatar: Observable&lt;()&gt; {
    return jsqdelegate
        .methodInvoked(#selector(JSQMessagesCollectionViewDelegateFlowLayout.collectionView(_:didTapAvatarImageView:at:)))
        .map { _ in ()
    }
</code></pre>

<p>which will succeed on running but will immediately complete and dispose as shown by printing them out onto the console:</p>

<pre><code>self.collectionView.rx.didTapAvatar.asObservable()
    .subscribe(onNext: { (event) in
        print(""next"")
    }, onError: { (error) in
        print(""error"")
    }, onCompleted: { 
        print(""complete"")
    }, onDisposed: { 
        print(""disposed"")
    }).disposed(by: disposeBag)
</code></pre>

<p><em>RxJSQMessageCollectionViewCellProxy.swift</em></p>

<pre><code>public class RxJSQMessageCollectionViewCellProxy: DelegateProxy, JSQMessagesCollectionViewDelegateFlowLayout, DelegateProxyType {

public class func currentDelegateFor(_ object: AnyObject) -&gt; AnyObject? {
    let collectionView: JSQMessagesCollectionView = object as! JSQMessagesCollectionView
    return collectionView.delegate
}

public class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) {
    let collectionView: JSQMessagesCollectionView = object as! JSQMessagesCollectionView
    collectionView.delegate = delegate as? JSQMessagesCollectionViewDelegateFlowLayout
}
</code></pre>

<p>}</p>

<p><em>JSQMessagesCollectionView+RxCreate.swift</em></p>

<pre><code>extension Reactive where Base: JSQMessagesCollectionView {
    public var didTapAvatar: Observable&lt;()&gt; {
        return delegate.methodInvoked(#selector(JSQMessagesCollectionView.messagesCollectionViewCellDidTapAvatar(_:))).map { _ in () }
    }
}
</code></pre>
","4281694","","","","","2017-07-20 04:34:11","Wrapping custom class delegates into RxSwift Observables","<delegates><observable><rx-swift><rx-cocoa>","0","0","","","","CC BY-SA 3.0"
"45234915","1","45238861","","2017-07-21 10:08:41","","22","28495","<p>I am willing to use RxSwift for MVVM binding between model values &amp; view controllers. I wanted to follow this <a href=""https://news.realm.io/news/slug-max-alexander-mvvm-rxswift/"" rel=""noreferrer"">realm.io tutorial</a>, but the binding has apparently changed since then, and the sample code does not compile. Here is the sample code, where I think I've fixed the worst typos / missing things:</p>

<p>LoginViewModel.swift</p>

<pre><code>import RxSwift

struct LoginViewModel {

    var username = Variable&lt;String&gt;("""")
    var password = Variable&lt;String&gt;("""")

    var isValid : Observable&lt;Bool&gt;{
        return Observable.combineLatest(self.username.asObservable(), self.password.asObservable())
        { (username, password) in
            return username.characters.count &gt; 0
                &amp;&amp; password.characters.count &gt; 0
        }
    }
} 
</code></pre>

<p>LoginViewController.swift</p>

<pre><code>import RxSwift
import RxCocoa
import UIKit

class LoginViewController: UIViewController {
    var usernameTextField: UITextField!
    var passwordTextField: UITextField!
    var confirmButton: UIButton!

    var viewModel = LoginViewModel()

    var disposeBag = DisposeBag()

    override func viewDidLoad() {
        usernameTextField.rx.text.bindTo(viewModel.username).addTo(disposeBag)
        passwordTextField.rx.text.bindTo(viewModel.password).addTo(disposeBag)

        //from the viewModel
        viewModel.rx.isValid.map { $0 }
            .bindTo(confirmButton.rx.isEnabled)
    }
}
</code></pre>

<p>The controller bindings do not compile. It is pretty close to impossible to track the correct way to do these, as the RxSwift documentation is pretty unhelpful, and the Xcode autocompletion does not suggest anything useful.</p>

<p>The first issue is with this binding, which does not compile:
<code>usernameTextField.rx.text.bindTo(viewModel.username).addTo(disposeBag)</code></p>

<p>The error:</p>

<p><code>LoginViewController.swift:15:35: Cannot invoke 'bindTo' with an argument list of type '(Variable&lt;String&gt;)'</code></p>

<p>I've tried the following without luck:</p>

<p>1) <code>usernameTextField.rx.text.bind(to: viewModel.username).addTo(disposeBag)</code> - The error still persists:
 <code>LoginViewController.swift:15:35: Cannot invoke 'bind' with an argument list of type '(to: Variable&lt;String&gt;)'</code></p>

<p>2) 
    let _ = viewModel.username.asObservable().bind(to: passwordTextField.rx.text)</p>

<pre><code>let _ = viewModel.username.asObservable()
            .map { $0 }
            .bind(to: usernameTextField.rx.text)
</code></pre>

<p>This second one actually compiles, but does not work (ie. viewModel.username does not change) </p>

<p>The main problem is here that I am shooting blind when passing parameters to the <code>bind</code> and <code>bind(to:</code> methods, since the autocompletion is not really helpful here.. I am using swift 3 and Xcode 8.3.2.</p>
","3364547","","1113632","","2018-01-30 14:50:02","2019-09-04 14:51:20","UITextField binding to ViewModel with RxSwift","<ios><swift><mvvm><rx-swift>","2","0","9","","","CC BY-SA 3.0"
"45238676","1","45254372","","2017-07-21 13:15:24","","2","1481","<p>I have own image class (UICustomImage).</p>

<p>How to track changes to pictures and update GLKView?</p>

<p><strong>ViewModel:</strong> </p>

<pre><code>final class ViewModel {

private let disposeBag = DisposeBag()

let image: UICustomImage
let sliderValue: Variable&lt;Float&gt;

init(image: UIImage) {

    self.sliderValue = Variable(Float(0.0))

    self.image = UICustomImage(image: image)        

    self.sliderValue.asObservable()
        .subscribe(onNext: { (value) in
            self.image.brightness(n: value)
        })
        .disposed(by: disposeBag)
}

}
</code></pre>

<p><strong>ViewController:</strong> </p>

<pre><code>@IBOutlet var slider: UISlider!

private let disposeBag = DisposeBag()
private var viewModel: ViewModel!

var image: UIImage?

override viewDidLoad() {
    viewModel = ViewModel(image: image!)

    slider.rx.value
        .subscribe(onNext: { value in
            self.viewModel.sliderValue.value = value
        })
        .disposed(by: disposeBag)
}
</code></pre>

<p>I want the picture to be updated when the slider moves. </p>
","6723659","","1226963","","2017-07-21 16:48:15","2017-07-22 12:16:06","How to subscribe to changes image","<ios><swift><rx-swift>","1","3","","","","CC BY-SA 3.0"
"45345020","1","45384634","","2017-07-27 08:16:43","","2","424","<p>Could you give some advice on where to place an <code>MFMailComposeViewController</code>?</p>

<p>In a non RxSwift and non Clean Architecture  project, I would implement it in some view controller, like this:</p>

<pre><code>extension ViewController: MFMailComposeViewControllerDelegate {

    func presentMailComposer() {

        if !MFMailComposeViewController.canSendMail() {
            // TODO: - Handle error here
            return
        }

        DispatchQueue.global(qos: DispatchQoS.QoSClass.userInitiated).async {

            let mailComposeViewController = MFMailComposeViewController()
            mailComposeViewController.mailComposeDelegate = self
            mailComposeViewController.setToRecipients([""mail@example.com""])
            mailComposeViewController.setMessageBody(""Message body"", isHTML: false)

            DispatchQueue.main.async(execute: {
                self.present(mailComposeViewController, animated: true, completion: nil)
            })

        }

    }

    func mailComposeController(_ controller: MFMailComposeViewController, didFinishWith result: MFMailComposeResult, error: Error?) {
        if result == MFMailComposeResult.failed {
            // TODO: - Handle error here
        }
    }

}
</code></pre>

<p>Within the Clean Architecture, where would you place the Mail Composer?</p>

<p>Would you present this from the Navigator/Router? It is after all a ""Scene"", even if we don't necessarily have a Navigator/Router and a ViewModel dedicated to the MailComposer.</p>

<p>There are 2 distinct places where errors might occur, and I really don't think the Navigator should handle these. </p>

<p>Thanks!</p>
","1544047","","2124535","","2017-08-22 20:40:43","2017-08-22 20:40:43","From where should I present an MFMailComposeViewController in a Clean Architecture?","<swift><mfmailcomposeviewcontroller><rx-swift><clean-architecture>","2","0","","","","CC BY-SA 3.0"
"45366259","1","","","2017-07-28 06:24:09","","1","1098","<p>I wanna ask about RxSwift. <br>
I got a problem when i want to use tableView delegate function with RxSwift <br>
I don't know the source of the problem .. <br>
The problem is when I do select on a cell with rx.ItemSelected , I got the cell position and event triggered with well at the first time.<br>
The event that i do is pushViewController and then when I pressed back to previous view. After that, i tap again on the same cell .. the cell will triggered twice and if we do the same thing, it'll triggered like incremental from 1 -> 2 -> 3 -> n+1  <br>
Is there any way to fix this ? 
Here's my partial of my code :</p>

<pre><code>root.tableView.rx.itemSelected.subscribe(onNext: { index in
    switch index.row :
    case 0 :
    DSource.navbar?.pushViewController(nextViewController, animated: true)
    case 1:
    Source.navbar?.pushViewController(secondViewController, animated: true)
    default :
    break

}
</code></pre>
","7022534","","","","","2017-08-17 07:57:13","Rx ItemSelected doing action depend on how much action triggered","<ios><swift3><tableview><rx-swift>","1","1","","","","CC BY-SA 3.0"
"45368601","1","","","2017-07-28 08:31:23","","1","701","<p>I am using heavily in my companies project RxSwift. And when running performance tests in Instrument really worrying problem appeared.</p>

<p>Each time <code>.addDisposableTo(disposeBag)</code> gets called, Instruments show up memory leak around 10 bytes. There's no specific pattern of why it would happen, like not using <code>[weak self]</code> in right places, it just happens for no apparent reason.</p>

<p>Some sample code:</p>

<pre><code>class ContactsViewModel: NSObject {
    fileprivate let disposeBag = DisposeBag()
    fileprivate let provider = AuthorizedNetworking().provider

    var contacts: Variable&lt;[User]&gt; = Variable([])
    var suggestedContacts: Variable&lt;[User]&gt; = Variable([])

    func fetchContact(suggestions: Bool = false) {
        ActivityIndicator.showLoadingHUD(message: ""Fetching contacts..."")
        let observable = provider.request(suggestions ?
            .suggest :
            .searchContacts(query: nil, global: false)).filterSuccessfulStatusCodes()
        let mapped = observable.checkForErrors().mapObject(DataListResponse&lt;User&gt;.self)
        mapped.subscribe { [weak self] event in
            switch event {
            case let .next(response):
                ActivityIndicator.hideLoadingHUD()
                if response.success, let contacts = response.data {
                    if suggestions {
                        self?.suggestedContacts.value = contacts
                    } else {
                        self?.contacts.value = contacts.filter { $0.contactType == ""Friend"" }
                    }
                } else {
                    Log(.Network, .Error, ""Unable to retrieve current user"")
                }
            case let .error(error):
                ActivityIndicator.hideLoadingHUD()
                Log(.Network, .Error, error.localizedDescription)
            default:
                break
            }
            }.addDisposableTo(disposeBag) &lt;- Instruments show leak [6 bytes] at this line

    }
}
</code></pre>

<p>I've done some research and I have one version that Instrument might not understand RxSwift and make it look like there's leak but in reality, there isn't. 
But most likely my implementation has problems that I don't know of since I have little experience in RxSwift. 
Any help appreciated.</p>
","","user2082485","","","","2017-09-26 11:00:59","RxSwift `.addDisposableTo(disposeBag)` causes memory leak","<ios><swift><memory-leaks><instruments><rx-swift>","1","0","","","","CC BY-SA 3.0"
"45374112","1","","","2017-07-28 12:53:37","","0","938","<p>My expectation is to add observables on-the-fly (eg: images upload), let them start, and, when I finished dynamically enqueueing everything, wait for all observable to be finished.</p>

<p>Here is my class : </p>

<pre><code>open class InstantObservables&lt;T&gt; {
    lazy var disposeBag = DisposeBag()

    public init() { }

    lazy var observables: [Observable&lt;T&gt;] = []
    lazy var disposables: [Disposable] = []

    open func enqueue(observable: Observable&lt;T&gt;) {
        observables.append(observable)

        let disposable = observable
            .subscribe()

        disposables.append(disposable)

        disposable
            .addDisposableTo(disposeBag)
    }

    open func removeAndStop(atIndex index: Int) {
        guard observables.indices.contains(index)
            &amp;&amp; disposables.indices.contains(index) else {
            return
        }
        let disposable = disposables.remove(at: index)
        disposable.dispose()

        _ = observables.remove(at: index)
    }

    open func waitForAllObservablesToBeFinished() -&gt; Observable&lt;[T]&gt; {
        let multipleObservable = Observable.zip(observables)
        observables.removeAll()
        disposables.removeAll()
        return multipleObservable
    }

    open func cancelObservables() {
        disposeBag = DisposeBag()
    }
}
</code></pre>

<p>But when I subscribe to the observable sent by <code>waitForAllObservablesToBeFinished()</code> , all of them are re-executed (which is logic, regarding how Rx works).</p>

<p>How could I warranty that each are executed once, whatever the number of subscription is ?  </p>
","4609567","","","","","2017-07-28 12:53:37","How to wait for all observable within a mutable array to finish in RxSwift","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"45374622","1","45375353","","2017-07-28 13:19:53","","0","2940","<p>I have problem with adopting RxSwift to my application. My problem is:
If I have many input signals (Variables with different elements) that can be change by user and from this changes I want to build one Observable signal. I think I should use some sort of Combination operator but for example combineLatest only allows for two parameters to combine.</p>

<p>Let's look at example of inputs and outputs that I have.</p>

<pre><code>import RxSwift
import RxCocoa

class ModelView {

    private let api: ApiType

    // inputs
    let inType: Variable&lt;MWItemQueryType&gt;
    let inFilterRetailers: Variable&lt;Set&lt;MWRetailer&gt;&gt;
    let inFilterColors: Variable&lt;Set&lt;MWColor&gt;&gt;
    let inFilterPriceRanges: Variable&lt;Set&lt;MWPriceRange&gt;&gt;

    // outputs
    let outQuery: Observable&lt;MWItemQuery&gt;

    init(initialType: MWItemQueryType, api: ApiType) {
        self.api = api
        self.inType = Variable(initialType)
        self.inFilterRetailers = Variable(Set&lt;MWRetailer&gt;())
        self.inFilterColors = Variable(Set&lt;MWColor&gt;())
        self.inFilterPriceRanges = Variable(Set&lt;MWPriceRange&gt;())

        // TODO How to setup outQuery signal here
    }
}
</code></pre>

<p>So I have problem with setup outQuery that emits signals <code>MWItemQuery</code>. The <code>MWItemQuery</code> signal must be emitted when one of the input parameters changed. The <code>MWItemQuery</code> is then emitted to the api to fetch data from server with the most recent filters selected by the user. I have a lot of other input filter signals and I don't know if any operator can help me.</p>
","752775","","","","","2017-07-28 13:56:11","Combining multiple different observables into one observable","<swift3><reactive-programming><rx-swift>","2","0","","","","CC BY-SA 3.0"
"45390999","1","","","2017-07-29 15:34:53","","1","1518","<p>There is class have a Bool property  </p>

<pre><code>class Coupon: NSObject {
    var invalid: Bool = false
}
</code></pre>

<p>I create a array [Coupon],I need to modify the coupon.invalid to true one by one.when all of these coupon.invalid == true ,then I can process next task,How can I implement this logic with RxSwift ?Please help me ~~</p>
","5561222","","5561222","","2017-07-30 14:43:42","2018-07-05 11:52:21","How to observe the value in array with RxSwift","<ios><swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"45408629","1","45413616","","2017-07-31 06:15:28","","2","2699","<p>I am using Facebook to authenticate users. This process happens async. After this is complete i have to authenticate user through firebase, which happens async. Even though I am using RxSwift, I end up nesting async tasks just as if i were to use callbacks and end up with callback hell .</p>

<p>My current procedure just doesn't seem right. Kinda hard to read also. Is it me or is there a more elegant approach to handling multiple async network calls.  </p>

<p>for this example I took out the error events because it makes the code even less readable. </p>

<p>Thanks for any tips or guidance.</p>

<pre><code>func rx_login(viewController: UIViewController) {

    /// Facebook login
    rx_facebookLogin(viewController: viewController)
        .asObservable()
        .subscribe(onNext: { [weak self] (credentials: AuthCredential, userInfo: [String: Any]) in

            /// Firebase Login
            rx_firebaseLogin(with: credentials)
                .asObservable()
                .subscribe(onNext: { [weak self] (uid) in

                    /// TODO: Save user info firebase db


                }).addDisposableTo(disposeBag)

        }).addDisposableTo(disposeBag)
</code></pre>
","","user6354073","","user6354073","2017-07-31 06:34:33","2017-07-31 10:52:50","synchronize async network calls with RxSwift","<ios><swift><asynchronous><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"45420616","1","","","2017-07-31 16:07:18","","0","743","<p>I have provided the code for my firebase API client. </p>

<p>Is it smart to use generics, to initialize any entity straight from json this way?</p>

<p>To download lists, I needed an indicator to let me know that I'm requesting a list of entities- since there's different implementation, so I added a GETALL  case to my HTTPMethod enum, is this bad, and something that would be confusing to others? </p>

<p>I also feel like this isn't flexible because I can't get desired entities on a node if there are nested at different levels. Hopefully that makes sense. So this probably doesn't follow open/closed principle, because If i have to nest my entities in firebase differently ill have to change implementation inside FirebaseAPI again. </p>

<p>From open source code i've seen, I haven't quite seen an rest client designed like this and not sure if I'm using an anti pattern or something. Any help or guidance to make this maintainable. </p>

<pre><code>class FirebaseAPI {

    private let session: URLSession

    init() {

        self.session = URLSession.shared
    }

    /// Responsible for Making actual API requests &amp; Handling response
    /// Returns an observable object that conforms to JSONable protocol.
    /// Entities that confrom to JSONable just means they can be initialized with json.
    func rx_fireRequest&lt;Entity: JSONable&gt;(_ endpoint: Endpoint) -&gt; Observable&lt;[Entity]&gt; {

        return Observable.create { [weak self] observer in

            self?.session.dataTask(with: endpoint.request, completionHandler: { (data, response, error) in

                /// Parse response from request.
                let parsedResponse = Parser.init(data: data, response: response, error: error)

                    .parse()


                switch parsedResponse {


                case .error(let error):

                    observer.onError(error)

                    return




                case .success(let data):

                    var entities = [Entity]()

                    /// Consider edge case where a list of entities are retrieved, rather than a single entity.
                    /// Iterate through each entity and initialize.
                    /// Denoted by 'GETALL' method.
                    switch endpoint.method {

                    case .GETALL:


                        /// Key (underscored) is unique identifier for each entity, which is not needed here.
                        /// value is k/v pairs of entity attributes.
                        for (_, value) in data {

                            if let value = value as? [String: AnyObject], let entity = Entity(json: value) {

                                entities.append(entity)

                            } else {

                                observer.onError(NetworkError.initializationFailure)

                                return
                            }

                            observer.onNext(entities)

                            observer.onCompleted()

                            return
                        }



                    default:

                        if let entity = Entity(json: data) {

                        observer.onNext([entity])

                        observer.onCompleted()

                    } else {

                        observer.onError(NetworkError.initializationFailure)

                        }

                    }
                }
            })

            return Disposables.create()
        }


    }
}
</code></pre>

<p>Enum below Contains all request that can be made to firebase. 
Conforms to Endpoint protocol, so one of these enum members will be the input for FirebaseAPI request method. 
PROBLEM: Seems redundant to have multiple cases for CRUD operations when the only thing that changes is entity involved in the request.</p>

<pre><code>enum FirebaseRequest {

    case saveUser(data: [String: AnyObject])
    case findUser(id: String)
    case removeUser(id: String)

    case saveItem(data: [String: AnyObject])
    case findItem(id: String)
    case findItems
    case removeItem(id: String)

    case saveMessage(data: [String: AnyObject])
    case findMessages(chatroomId: String)
    case removeMessage(id: String)

}


extension FirebaseRequest: Endpoint {



    var base: String {

        return """"https://&lt;APPNAME&gt;.firebaseio.com/""""
    }

    var path: String {

        switch self {

        case .saveUser(let data): return ""\(Constant.users)/\(data[Constant.id])""
        case .findUser(let id): return ""\(Constant.users)/\(id)""
        case .removeUser(let id): return ""\(Constant.users)/\(id)""

        case .saveItem(let data): return ""\(Constant.items)/\(data[Constant.id])""
        case .findItem(let id): return ""\(Constant.items)/\(id)""
        case .findItems: return ""\(Constant.items)""
        case .removeItem(let id): return ""\(Constant.items)/\(id)""

        case .saveMessage(let data): return ""\(Constant.messages)/\(data[Constant.id])""
        case .findMessages(let chatroomId): return ""\(Constant.messages)/\(chatroomId)""
        case .removeMessage(let id): return ""\(Constant.messages)/\(id)""

        /// This is still incomplete... Will have more request.

        }
    }


    var method: Method {

        /// URLRequest method is GET by default, so just consider PUT &amp; DELETE methods.
        switch self {

            /// If saving, return PUT
            /// If removing, return DELETE

        default: return .GET

        }
    }


    var body: [String : AnyObject]? {

        /// If saving, get associated value from enum case, and return that.

        return nil
    }

}
</code></pre>

<p>Endpoint Protocol </p>

<pre><code>protocol Endpoint {

    var base: String { get }
    var path: String { get }
    var method: Method { get }
    var body: [String: AnyObject]? { get }
    // no params needed for firebase. auth token just goes in url. 
}


extension Endpoint {

    private var urlComponents: URLComponents? {

        var components = URLComponents(string: base)

        components?.path = path + ""auth=\(AuthService.shared.authToken)"" + "".json""

        return components
    }


    var request: URLRequest {

        var request = URLRequest(url: urlComponents!.url!)

        request.httpMethod = self.method.description

        if let body = body {

            do {

                let json = try JSONSerialization.data(withJSONObject: body, options: [])

                request.httpBody = json

            } catch let error {
                // error!
                print(error.localizedDescription)
            }

        }

        return request
    }

}
</code></pre>

<p>HTTP Methods </p>

<pre><code>enum Method {

    case GET

    /// Indicates how JSON response should be parsed differently to abastract a list of entities
    case GETALL

    case PUT

    case DELETE

}

extension Method: CustomStringConvertible {

    var description: String {

        switch self {

        case .GET: return ""GET""
        case .GETALL: return ""GET""
        case .PUT: return ""PUT""
        case .DELETE: return ""DELETE""

        }
    }
}
</code></pre>

<p>AuthService </p>

<pre><code>class AuthService {

    private static let _shared = AuthService()

    static var shared: AuthService {
        return _shared
    }

    private let disposeBag = DisposeBag()

    var currentUserId: String {
        return Auth.auth().currentUser!.uid
    }

    var authToken: AuthCredential {
        return FacebookAuthProvider.credential(withAccessToken: FBSDKAccessToken.current().tokenString)
    }


    func rx_login(viewController: UIViewController) {

        /// Facebook login
        rx_facebookLogin(viewController: viewController)

            .asObservable()
            .subscribe(onNext: { [weak self] (credentials: AuthCredential, userInfo: [String: Any]) in


                /// Firebase Login
                self?.rx_firebaseLogin(with: credentials)

                    .asObservable()
                    .subscribe(onNext: { [weak self] (uid) in

                        /// TODO:  Save in firebase db..





                    }).addDisposableTo((self?.disposeBag)!)

            }).addDisposableTo(disposeBag)

    }




    // - MARK: facebook login
    private func rx_facebookLogin(viewController: UIViewController) -&gt; Observable&lt;(AuthCredential, [String: Any])&gt; {


        return Observable&lt;(AuthCredential, [String: Any])&gt;.create { observable in

            let loginManager = FBSDKLoginManager()

            loginManager.logIn(withReadPermissions: [""public_profile"", ""email""], from: viewController) { (result, error) in


                guard error == nil else {
                    observable.onError(AuthError.custom(message: error!.localizedDescription))
                    print(""debugger: error: \(error!.localizedDescription)"")
                    return
                }

                guard let accessToken = FBSDKAccessToken.current() else {
                    observable.onError(AuthError.invalidAccesToken)
                    print(""debugger: invalid access token"")
                    return
                }


                /// Facebook credentials to login with firebase.
                let credential = FacebookAuthProvider.credential(withAccessToken: accessToken.tokenString)


                /// Build request to get user facebook info.
                guard let request = FBSDKGraphRequest(graphPath: ""me"", parameters: [""fields"":""name""], tokenString: accessToken.tokenString, version: nil, httpMethod: ""GET"") else {
                    observable.onError(AuthError.facebookGraphRequestFailed)
                    print(""debugger: could not create request."")
                    return
                }


                /// - Perform Request
                request.start { (connection, result, error) in

                    guard error == nil else {
                        observable.onError(AuthError.custom(message: error!.localizedDescription))
                        print(""debugger: error: \(error!.localizedDescription)"")
                        return
                    }


                    print(""Debugger: profile results: \(result)"")

                    /// TODO: GET CITY FOR LOCALITY
                    guard let result = result as? [String: AnyObject], let name = result[Constant.name] as? String else {
                        observable.onError(AuthError.invalidProfileData)
                        print(""debugger: error converting profile results"")
                        return
                    }


                    /// Includes data needed to proceed with firebase login process.
                    observable.onNext((credential, [""name"": name]))
                    observable.onCompleted()

                    print(""Debugger: Successfull login"")
                }

            }

            return Disposables.create()
        }
    }




    private func rx_firebaseLogin(with credential: AuthCredential) -&gt; Observable&lt;String&gt; {

        return Observable&lt;String&gt;.create { observable in

            Auth.auth().signIn(with: credential) { (user, error) in


                guard error == nil else {
                    observable.onError(AuthError.custom(message: error!.localizedDescription))
                    print(""error firelogin \(error!.localizedDescription)"")
                    return
                }

                guard user != nil else {
                    observable.onError(AuthError.invalidFirebaseUser)
                    print(""debugger: error with user.."")
                    return
                }

                observable.onNext(user!.uid)
                observable.onCompleted()

            }

            return Disposables.create()

        }

    }

}
</code></pre>
","","user6354073","","user6354073","2017-08-01 00:13:04","2017-08-01 00:13:04","Generic way to call Network Requests for API Client","<ios><swift><design-patterns><client><rx-swift>","0","12","","","","CC BY-SA 3.0"
"45465688","1","45470399","","2017-08-02 15:58:57","","2","3122","<p>I am new to RxSwift and MVVM. </p>

<p>my viewModel has a method named <code>rx_fetchItems(for:)</code> that does the heavy lifting of fetching relevant content from backend, and returns <code>Observable&lt;[Item]&gt;</code>. </p>

<p>My goal is to supply an observable property of the viewModel named <code>collectionItems</code>, with the last emitted element returned from <code>rx_fetchItems(for:)</code>, to supply my collectionView with data. </p>

<p>Daniel T has provided this solution that I could potentially use: </p>

<pre><code>protocol ServerAPI {
    func rx_fetchItems(for category: ItemCategory) -&gt; Observable&lt;[Item]&gt;
}

    struct ViewModel {

        let collectionItems: Observable&lt;[Item]&gt;
        let error: Observable&lt;Error&gt;

        init(controlValue: Observable&lt;Int&gt;, api: ServerAPI) {
            let serverItems = controlValue
                .map { ItemCategory(rawValue: $0) }
                .filter { $0 != nil }.map { $0! } // or use a `filterNil` operator if you already have one implemented.
                .flatMap { api.rx_fetchItems(for: $0)
                    .materialize()
                }
                .filter { $0.isCompleted == false }
                .shareReplayLatestWhileConnected()

            collectionItems = serverItems.filter { $0.element != nil }.dematerialize()
            error = serverItems.filter { $0.error != nil }.map { $0.error! }
        }

    }
</code></pre>

<p>The only problem here is that my current ServerAPI aka FirebaseAPI, has no such protocol method, because it is designed with a single method that fires all requests like this: </p>

<pre><code>class FirebaseAPI {

    private let session: URLSession

    init() {
        self.session = URLSession.shared
    }

    /// Responsible for Making actual API requests &amp; Handling response
    /// Returns an observable object that conforms to JSONable protocol.
    /// Entities that confrom to JSONable just means they can be initialized with json.
    func rx_fireRequest&lt;Entity: JSONable&gt;(_ endpoint: FirebaseEndpoint, ofType _: Entity.Type ) -&gt; Observable&lt;[Entity]&gt; {

        return Observable.create { [weak self] observer in
            self?.session.dataTask(with: endpoint.request, completionHandler: { (data, response, error) in

                /// Parse response from request.
                let parsedResponse = Parser(data: data, response: response, error: error)
                    .parse()

                switch parsedResponse {

                case .error(let error):
                    observer.onError(error)
                    return

                case .success(let data):

                    var entities = [Entity]()

                    switch endpoint.method {

                    /// Flatten JSON strucuture to retrieve a list of entities.
                    /// Denoted by 'GETALL' method.
                    case .GETALL:

                        /// Key (underscored) is unique identifier for each entity, which is not needed here.
                        /// value is k/v pairs of entity attributes.
                        for (_, value) in data {
                            if let value = value as? [String: AnyObject], let entity = Entity(json: value) {
                                entities.append(entity)
                            }
                        }

                        // Need to force downcast for generic type inference.
                        observer.onNext(entities as! [Entity])
                        observer.onCompleted()

                    /// All other methods return JSON that can be used to initialize JSONable entities 
                    default:
                        if let entity = Entity(json: data) {
                        observer.onNext([entity] as! [Entity])
                        observer.onCompleted()
                    } else {
                        observer.onError(NetworkError.initializationFailure)
                        }
                    }
                }
            }).resume()
            return Disposables.create()
        }
    }
}
</code></pre>

<p>The most important thing about the <code>rx_fireRequest</code> method is that it takes in  a <code>FirebaseEndpoint</code>.</p>

<pre><code>/// Conforms to Endpoint protocol in extension, so one of these enum members will be the input for FirebaseAPI's `fireRequest` method.

enum FirebaseEndpoint {

    case saveUser(data: [String: AnyObject])
    case fetchUser(id: String)
    case removeUser(id: String)

    case saveItem(data: [String: AnyObject])
    case fetchItem(id: String)
    case fetchItems
    case removeItem(id: String)

    case saveMessage(data: [String: AnyObject])
    case fetchMessages(chatroomId: String)
    case removeMessage(id: String)

}
</code></pre>

<p>In order to use Daniel T's solution, Id have to convert each enum case from <code>FirebaseEndpoint</code> into methods inside <code>FirebaseAPI</code>. And within each method, call <code>rx_fireRequest</code>... If I'm correct. </p>

<p>Id be eager to make this change if it makes for a better Server API design. So the simple question is, Will this refactor improve my overall API design and how it interacts with ViewModels. And I realize this is now evolving into a code review.</p>

<p>ALSO... Here is implementation of that protocol method, and its helper: </p>

<pre><code> func rx_fetchItems(for category: ItemCategory) -&gt; Observable&lt;[Item]&gt;  {
        // fetched items returns all items in database as Observable&lt;[Item]&gt;
        let fetchedItems = client.rx_fireRequest(.fetchItems, ofType: Item.self)
        switch category {
        case .Local:
            let localItems = fetchedItems
            .flatMapLatest { [weak self] (itemList) -&gt; Observable&lt;[Item]&gt; in
                return self!.rx_localItems(items: itemList)
            }

            return localItems

            // TODO: Handle other cases like RecentlyAdded, Trending, etc..
        }
    }

    // Helper method to filter items for only local items nearby user.
    private func rx_localItems(items: [Item]) -&gt; Observable&lt;[Item]&gt; {
        return Observable.create { observable in
            observable.onNext(items.filter { $0.location == ""LA"" })
            observable.onCompleted()
            return Disposables.create()
        }
    }
</code></pre>

<p>If my approach to MVVM or RxSwift or API design is wrong PLEASE do critique. </p>
","","user6354073","","user6354073","2017-08-03 17:06:56","2017-08-03 17:54:25","Rx Observable that gets value from other Observable","<ios><swift><mvvm><rx-swift>","3","0","","","","CC BY-SA 3.0"
"45471978","1","45476804","","2017-08-02 22:24:05","","1","1962","<p>I need request different types of models from network and then combine them into one model.
How is it possible to chain multiple observables and return another observable?</p>

<p>I have something like:</p>

<pre><code>func fetchDevices() -&gt; Observable&lt;DataResponse&lt;[DeviceModel]&gt;&gt;

func fetchRooms() -&gt; Observable&lt;DataResponse&lt;[RoomModel]&gt;&gt;

func fetchSections() -&gt; Observable&lt;DataResponse&lt;[SectionModel]&gt;&gt; 
</code></pre>

<p>and I need to do something like:</p>

<pre><code>func fetchAll() -&gt; Observable&lt;(AllModels, Error)&gt; {
    fetchSections()

    // Then if sections is ok I need to fetch rooms
    fetchRooms()

    // Then - fetch devices
    fetchDevices()

    // And if everything is ok create AllModels class and return it
    // Or return error if any request fails
    return AllModels(sections: sections, rooms: rooms, devices:devices)
  }
</code></pre>

<p>How to achieve it with RxSwift? I read docs and examples but understand how to chain observables with same type</p>
","1060785","","","","","2017-08-04 06:36:11","Chaining RxSwift observable with different type","<ios><swift><rx-swift><rx-cocoa>","2","1","1","","","CC BY-SA 3.0"
"45511611","1","45532175","","2017-08-04 16:28:34","","1","566","<p>The tableView that my variable is bound to jumps/glitches when the cell that I clicked on to trigger the data change. </p>

<p>Here is how the tableView and variable are bound: </p>

<pre><code>variable.asObservable()
        .bind(to: tableView.rx.items)
            { (tableView, row, dataForRow) in

}
</code></pre>

<p>When one of the buttons in the tableView is pressed I eventually update the variable's value like this:</p>

<pre><code>variable.value = updatedData
</code></pre>

<p>Does anyone know why this would be happening?</p>

<p>Any help would be appreciated.</p>

<p>Thanks in advance.</p>
","4443470","","","","","2017-08-06 12:45:35","TableView made with RxSwift/RxCocoa glitches after a data change in the Variable it's bound to","<ios><swift><uitableview><rx-swift><rx-cocoa>","2","0","0","","","CC BY-SA 3.0"
"45529566","1","","","2017-08-06 07:16:42","","4","379","<p>I'm trying to level up as a developer, and am currently building an app using RxSwift with MVVM. Most of my view models need access to the <code>current user</code> object. In just about every view controller, before I do anything, I have to fetch info for <code>current user</code> from database, and only then, can all other code be executed ( because so much of the logic depends on the state of the <code>User</code>). This also means most code is at least nested one level since fetching user is async. I actually input <code>User</code> into initializer of view model. There must be a better way to persist the current user throughout app. Ive recall reading a bit about dependency injection and how it allows data to be passed along as dependencies to other objects. Is this a scenario where injection could be a viable solution? Im open to other suggestions as well! </p>

<p><strong>Potential solutions I've thought of since time of post</strong></p>

<ul>
<li><p>just pass along <code>User</code> through segues and assign to currentUser property in each view controller </p></li>
<li><p>after login, create a shared observable of type <code>Observable&lt;User&gt;</code> in RootViewController, and subscribe to it wherever need be. But i'd still have to put code into subscription block wherever i subscribe. </p></li>
</ul>
","","user6354073","","user6354073","2017-08-06 07:33:57","2017-08-06 07:33:57","Dependency Injection for access to current User","<ios><swift><mvvm><dependency-injection><rx-swift>","0","5","","","","CC BY-SA 3.0"
"45536476","1","","","2017-08-06 20:44:52","","4","1252","<p><strong>Reason For Post</strong></p>

<p>There are so many different solutions &amp; examples on how to build a proper networking layer, but every app has different constraints, and design decisions are made based on trade-offs, leaving me uncertain about the quality of code I've written. If there are any <code>Anti-Patterns</code>, <code>redundancies</code>, or flat out bad solutions within my code that I have overlooked or simply lacked the knowledge to address, <strong>please</strong> do critique. This is a project I'd like to add to my portfolio, so I'm posting it here to get eyes on it, with some <em>advice/tips</em>.</p>

<p><strong>Thanks for your time in advanced!</strong> </p>

<p>Some characteristics of my networking layer that I think could raise eyebrows:</p>

<p><code>Method</code> contains a <code>GETALL</code> case, to indicate a list of data that must be fetched. I have not seen this in any of the open source code I've read. Is this a code smell? </p>

<pre><code>enum Method {
    case GET
    /// Indicates how JSON response should be handled differently to abastract a list of entities
    case GETALL
    case PUT
    case DELETE
}
</code></pre>

<p>I've made it, so each Swift Entity conforms to JSONable protocol, meaning it can be initialized with json and converted to json. </p>

<pre><code>protocol JSONable {
    init?(json: [String: AnyObject])
    func toJSON() -&gt; Data?
}
</code></pre>

<p>JSONable in practice with one of my entities: </p>

<pre><code>struct User {
    var id: String
    var name: String
    var location: String
    var rating: Double
    var keywords: NSArray
    var profileImageUrl: String
}

extension User: JSONable {
    init?(json: [String : AnyObject]) {
        guard let id = json[Constant.id] as? String, let name = json[Constant.name] as? String, let location = json[Constant.location] as? String, let rating = json[Constant.rating] as? Double, let keywords = json[Constant.keywords] as? NSArray, let profileImageUrl = json[Constant.profileImageUrl] as? String else {
            return nil
        }
        self.init(id: id, name: name, location: location, rating: rating, keywords: keywords, profileImageUrl: profileImageUrl)
    }

    func toJSON() -&gt; Data? {

        let data: [String: Any] = [Constant.id: id, Constant.name: name, Constant.location: location, Constant.rating: rating, Constant.keywords: keywords, Constant.profileImageUrl: profileImageUrl]
        let jsonData = try? JSONSerialization.data(withJSONObject: data, options: [])
        return jsonData
    }
}
</code></pre>

<p>This allows me to use <code>generics</code> to initialize all my entities in my client- <code>FirebaseAPI</code>, after I retrieve JSON response. I also haven't seen this technique in the code I've read.</p>

<p>In the code below, notice how <code>GETALL</code> is implemented to flatten the list of JSON objects. Should I have to do this at all? Is there a better way to handle any type of Json structure response? </p>

<p><strong>AND</strong> Entities are initialized generically, and returned as an <code>Observable</code> ( Using RxSwift ). </p>

<p>Do you sense any code smells? </p>

<pre><code>/// Responsible for Making actual API requests &amp; Handling response
    /// Returns an observable object that conforms to JSONable protocol.
    /// Entities that confrom to JSONable just means they can be initialized with json &amp; transformed from swift to JSON.
    func rx_fireRequest&lt;Entity: JSONable&gt;(_ endpoint: FirebaseEndpoint, ofType _: Entity.Type ) -&gt; Observable&lt;[Entity]&gt; {

        return Observable.create { [weak self] observer in

            self?.session.dataTask(with: endpoint.request, completionHandler: { (data, response, error) in

                /// Parse response from request.
                let parsedResponse = Parser(data: data, response: response, error: error)
                    .parse()

                switch parsedResponse {

                case .error(let error):
                    observer.onError(error)
                    return

                case .success(let data):
                    var entities = [Entity]()
                    switch endpoint.method { 

                    /// Flatten JSON strucuture to retrieve a list of entities.
                    /// Denoted by 'GETALL' method.
                    case .GETALL:

                        /// Key (underscored) is unique identifier for each entity
                        /// value is k/v pairs of entity attributes.
                        for (_, value) in data {
                            if let value = value as? [String: AnyObject], let entity = Entity(json: value) {
                                entities.append(entity)
                            }
                        }
                        /// Force downcast for generic type inference.
                        observer.onNext(entities as! [Entity])
                        //observer.onCompleted()

                    /// All other methods return JSON that can be used to initialize JSONable entities 
                    default:
                        if let entity = Entity(json: data) {
                        observer.onNext([entity] as! [Entity])
                        //observer.onCompleted()
                    } else {
                        observer.onError(NetworkError.initializationFailure)
                        }
                    }
                }
            }).resume()
            return Disposables.create()
        }
    }
}
</code></pre>

<p>I manage different endpoints like so: </p>

<pre><code>enum FirebaseEndpoint {
    case saveUser(data: [String: AnyObject])
    case fetchUser(id: String)
    case removeUser(id: String)

    case saveItem(data: [String: AnyObject])
    case fetchItem(id: String)
    case fetchItems
    case removeItem(id: String)

    case saveMessage(data: [String: AnyObject])
    case fetchMessages(chatroomId: String)
    case removeMessage(id: String)
}


extension FirebaseEndpoint: Endpoint {

    var base: String {
        // Add this as a constant to APP Secrts struct &amp; dont include secrets file when pushed to github.
        return ""https://AppName.firebaseio.com""
    }

    var path: String {
        switch self {
        case .saveUser(let data): return ""/\(Constant.users)/\(data[Constant.id])""
        case .fetchUser(let id): return ""/\(Constant.users)/\(id)""
        case .removeUser(let id): return ""/\(Constant.users)/\(id)""

        case .saveItem(let data): return ""/\(Constant.items)/\(data[Constant.id])""
        case .fetchItem(let id): return ""/\(Constant.items)/\(id)""
        case .fetchItems: return ""/\(Constant.items)""
        case .removeItem(let id): return ""/\(Constant.items)/\(id)""

        case .saveMessage(let data): return ""/\(Constant.messages)/\(data[Constant.id])""
        case .fetchMessages(let chatroomId): return ""\(Constant.messages)/\(chatroomId)""
        case .removeMessage(let id): return ""/\(Constant.messages)/\(id)""
        }
    }

    var method: Method {
        switch self {
        case .fetchUser, .fetchItem: return .GET
        case .fetchItems, .fetchMessages: return .GETALL
        case .saveUser, .saveItem, .saveMessage: return .PUT
        case .removeUser, .removeItem, .removeMessage: return .DELETE
        }
    }

    var body: [String : AnyObject]? {
        switch self {
        case .saveItem(let data), .saveUser(let data), .saveMessage(let data): return data
        default: return nil
        }
    }
}
</code></pre>

<p>Last thing, I'd like someone with professional eyes to look at is, how I use MVVM. I make all network requests from view model,  which comes out looking something like this: </p>

<pre><code>struct SearchViewModel {

    // Outputs
    var collectionItems: Observable&lt;[Item]&gt;
    var error: Observable&lt;Error&gt;

    init(controlValue: Observable&lt;Int&gt;, api: FirebaseAPI, user: User) {

        let serverItems = controlValue
            .map { ItemCategory(rawValue: $0) }
            .filter { $0 != nil }.map { $0! }
            .flatMap { api.rx_fetchItems(for: user, category: $0)
                .materialize()
            }
            .filter { !$0.isCompleted }
            .shareReplayLatestWhileConnected()

        collectionItems = serverItems.filter { $0.element != nil }.dematerialize()
        error = serverItems.filter { $0.error != nil }.map { $0.error! }
    }

}
</code></pre>

<p>In order to call api requests in a more expressive, formalized way, I am able to call <code>api.rx_fetchItems(for:)</code> inside <code>flatmap</code> above, because I <code>extend</code> <code>FirebaseAPI</code> to conform to <code>FetchItemsAPI</code>. I will probably have to follow the same pattern for most other requests. </p>

<pre><code>extension FirebaseAPI: FetchItemsAPI {

    // MARK: Fetch Items Protocol

    func rx_fetchItems(for user: User, category: ItemCategory) -&gt; Observable&lt;[Item]&gt;  {
        // fetched items returns all items in database as Observable&lt;[Item]&gt;
        let fetchedItems = rx_fireRequest(.fetchItems, ofType: Item.self)

        switch category {

        case .Local:
            let localItems = fetchedItems
                .flatMapLatest { (itemList) -&gt; Observable&lt;[Item]&gt; in
                    return self.rx_localItems(user: user, items: itemList)
            }
            return localItems


        case .RecentlyAdded:
            // Compare current date to creation date of item. If its within 24 hours, It makes the cut. 
            let recentlyAddedItems = fetchedItems
                .flatMapLatest { (itemList) -&gt; Observable&lt;[Item]&gt; in
                    return self.rx_recentlyAddedItems(items: itemList)
            }
            return recentlyAddedItems


        case .Trending:

            let trendingItems = fetchedItems
                .flatMapLatest { (itemList) -&gt; Observable&lt;[Item]&gt; in
                    return self.rx_trendingItems(items: itemList)
            }
            return trendingItems


        default:

            let stubItem = Item(id: ""DEFAULT"", createdById: ""createdBy"", creationDate: 1.3, expirationDate: 2.4, title: ""title"", price: 2, info: ""info"", imageUrl: ""url"", bidCount: 4, location: ""LA"")
            return Observable.just([stubItem])
        }
    }




    // MARK: Helper Methods

    private func rx_localItems(user: User, items: [Item]) -&gt; Observable&lt;[Item]&gt; {
        return Observable&lt;[Item]&gt;.create { observer in
            observer.onNext(items.filter { $0.location == user.location }) // LA Matches stubs in db
            return Disposables.create()
        }
    }


    func rx_recentlyAddedItems(items: [Item]) -&gt; Observable&lt;[Item]&gt; {
        return Observable&lt;[Item]&gt;.create { observer in
            let recentItems = items
                .filter {
                    let now = Date(timeIntervalSinceReferenceDate: 0)
                    let creationDate = Date(timeIntervalSince1970: $0.creationDate)
                    if let hoursAgo = now.offset(from: creationDate, units: [.hour], maxUnits: 1) {
                        return Int(hoursAgo)! &lt; 24
                    } else {
                        return false
                    }
            }
            observer.onNext(recentItems)
            return Disposables.create()
        }
    }


    func rx_trendingItems(items: [Item]) -&gt; Observable&lt;[Item]&gt; {
        return Observable&lt;[Item]&gt;.create { observer in
            observer.onNext(items.filter { $0.bidCount &gt; 8 })
            return Disposables.create()
        }
    }




}
</code></pre>

<p>I'm attempting to follow SOLID principles, and level up with RxSWift + MVVM, so I'm still unsure about the best OOP design for clean, maintainable code. </p>
","","user6354073","2273338","","2018-03-08 09:12:36","2018-03-08 09:12:36","iOS Networking Layer Architecture","<ios><oop><networking><mvvm><rx-swift>","0","1","0","","","CC BY-SA 3.0"
"45545771","1","","","2017-08-07 11:24:22","","4","2117","<p>I am using <a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow noreferrer"">RxSwift</a> as part of a project that someone else started.</p>

<p>Wanting to understand a bit more on the theory of ReactiveX I bumped into <a href=""https://facebook.github.io/react-native/releases/next/docs/native-modules-ios.html"" rel=""nofollow noreferrer"">React Native</a> and <a href=""https://github.com/Reactive-Extensions/Rx.NET"" rel=""nofollow noreferrer"">Rx.Net</a>.</p>

<p>I would like to make sure I understand the following correctly:</p>

<ul>
<li><strong>React Native</strong> is a Java Script library that allows developers to build native user interfaces. The library translates Javascript code into native mobile code. </li>
<li><strong>RxSwift</strong> aims to implement concepts of <strong>Rx.Net</strong> but is different and not directly linked to <strong>React Native</strong>. The commonality is that they both implement concepts of <strong><a href=""https://en.wikipedia.org/wiki/Reactive_programming"" rel=""nofollow noreferrer"">Reactive programming</a></strong> hence why the shared use of the word ""React"" / ""Reactive"" in their name. That's where the commonalities should end, right?</li>
</ul>

<p><strong>Conclusions:</strong></p>

<ul>
<li>As both RxSwift and React Native are tightly connected to the user interface implementation it is not possible to use them together. Correct?</li>
</ul>
","382788","","","","","2017-08-09 06:44:10","React Native, Rx.Net and RxSwift: commonalities","<javascript><ios><react-native><rx-swift><rx.net>","2","0","","","","CC BY-SA 3.0"
"45558977","1","","","2017-08-08 03:49:38","","5","14371","<p>I want to subscribe to an observable, but in some logic, I will re-subscribe to it. If I don't want to write some special logic for it, how can I dispose the last subscription when I add a new one? Or, when I subscribe to it, how can I know if this observable has been subscribed to already?</p>
","7215075","","1741639","","2018-07-18 00:22:34","2018-07-18 00:22:34","RxSwift How to subscribe a observable only one time?","<swift><rx-swift>","4","0","1","","","CC BY-SA 4.0"
"45581712","1","45653973","","2017-08-09 04:29:55","","1","999","<p><code>ItemDetailViewModel</code> is initialized with the following signature:</p>

<pre><code>init(item: Item, didPressButton: Observable&lt;Void&gt;, api: FirebaseAPI)
</code></pre>

<p>It is initialized in <code>ItemDetailViewController</code>, which gets an <code>Item</code> from segue of source controller. Im realizing that <code>ItemDetailViewController</code> is technically the <code>View</code>, so it should not have <code>Item</code> as a stored property. How else do I transfer <code>Item</code> to <code>ItemDetailViewModel</code>? This also means that <code>ItemListViewController</code> shouldn't have a <code>selectedItem</code> stored property to use in <code>prepareFor(segue:)</code>.</p>

<p><strong>Potential Solution</strong></p>

<p>So when a <code>CollectionView Cell</code> is tapped in <code>ItemListViewController</code> (source controller), it should trigger <code>ItemListViewModel</code> through binding to store <code>Item</code>, and then <code>perform segue</code>. Meanwhile, in <code>prepareForSegue</code> I use <code>ItemListViewModel</code> to initialize <code>ItemDetailViewModel</code> with <code>Item</code>. Ok.. That could work. </p>

<p>How do I handle the button taps, which changes its image on each tap? through a function? </p>

<p>What is the proper way to initialize <code>view models</code> and <code>inject dependencies</code>? </p>
","","user6354073","5424617","","2017-08-09 04:35:30","2017-08-12 19:09:50","View Model Dependency Injection","<ios><mvvm><dependency-injection><viewmodel><rx-swift>","1","3","0","","","CC BY-SA 3.0"
"45586870","1","","","2017-08-09 09:34:27","","3","4411","<p>I have view controller. Inside it I have view</p>

<pre><code>lazy var statusView: StatusView = {
       var statusView = StatusView()
        return statusView
}()
</code></pre>

<p>Inside statusView I have button</p>

<pre><code>lazy var backButton: UIButton = {
        var button = UIButton(type: .system)
        button.titleLabel?.font = UIFont().regularFontOfSize(size: 20)
        return button
  }()
</code></pre>

<p>In controller I have</p>

<pre><code>override func viewDidLoad() {
        super.viewDidLoad()
        setupRx()
}

func setupRx() {            
        _ = statusView.backButton.rx.tap.subscribe { [weak self] in
            guard let strongSelf = self else { return }
            print(""hello"")
        }
    }
</code></pre>

<p>But when I tap to button, nothing get printed to console.</p>

<p>What am I doing wrong ?</p>
","4730700","","1113632","","2018-01-30 12:50:24","2018-02-21 09:35:01","RxSwift - rx.tap not working","<swift><rx-swift><rx-cocoa>","2","0","","","","CC BY-SA 3.0"
"45620390","1","45620785","","2017-08-10 17:49:32","","1","728","<p>I have the following setup </p>

<pre><code>override func viewDidLoad() {

    super.viewDidLoad()

    navigationItem.leftBarButtonItem = editButtonItem

    navigationItem.leftBarButtonItem?.rx.tap.subscribe(onNext: { [weak self] _ in

        print(""edit tapped"")

        if let isEditing = self?.tableView.isEditing {

            self?.tableView.setEditing(!isEditing, animated: true)

        }

        }).disposed(by: disposeBag)
}
</code></pre>

<p>The problem is left bar button item is not toggled on tap. I.E text in the left bar button should change from <strong>Edit</strong> to  <strong>Done</strong>. </p>

<p>Changing button title in onNext method does not work either. </p>
","7626803","","","","","2017-08-10 18:12:52","How to toggle editButtonItem with rxswift?","<ios><swift><rx-swift><rx-cocoa>","1","1","","","","CC BY-SA 3.0"
"45631746","1","","","2017-08-11 09:35:16","","0","2493","<pre><code>// This button has different images with for selection and no selection which I configured in storyboard different images for two states.

@IBOutlet weak var selectedRestarunt: UIButton!
    // I am binding isSelected state like this which is working when user taps on button.
    selectedRestarunt.rx.tap.scan(false) { lastState, _ in
        return !lastState
    }
</code></pre>

<p>Now I have a case I mark <code>isSelected</code> manually without tap. </p>

<pre><code>selectedRestarunt.isSelected = false/true
</code></pre>

<p>This shouldn't trigger existing mapping.
This should be mapped somehow, so that I need to some action based on <code>isSelected</code> state.
Can anybody explain me how can I achieve this?</p>
","7397702","","105466","","2017-08-11 14:20:24","2017-08-11 16:51:33","How can I bind UIButton.isSelectable with RXSwift","<ios><swift><uibutton><rx-swift>","2","1","1","","","CC BY-SA 3.0"
"45633173","1","","","2017-08-11 10:37:56","","22","13464","<p>How do you get a signal from programmatically made changes to UITextField text property? By using rx.text only reports a signal when the user input the text by keyboard. If you set textField.text programmatically, the signal doesn't fire.</p>

<p>This is how I'm using rx.text</p>

<pre><code>(self.phoneNumberTextField.rx.text).orEmpty.subscribe(onNext: { [weak self] (phone) in
         // do something
    }).addDisposableTo(disposeBag)
    self.phoneNumberTextField.text = ""this is for test""
</code></pre>

<p>Thank you!</p>
","8106726","","","","","2018-11-27 10:12:58","How do you get a signal every time a UITextField text property changes in RxSwift","<ios><swift><rx-swift>","4","0","3","","","CC BY-SA 3.0"
"45638387","1","45645883","","2017-08-11 15:06:57","","0","1164","<p>So, I'm using RxSwift with MVVM and I'm found myself a bit confused. Here's why:</p>

<h2>My Code Right Now</h2>

<h3>ViewModel</h3>

<pre><code>internal protocol DetailViewModelInput {
   func viewDidLoad(with name: String)
}

internal protocol DetailViewModelOutput {
  var gnomeObject: Observable&lt;Gnome?&gt; { get }

}

struct DetailViewModel: DetailViewModelType, DetailViewModelInput, DetailViewModelOutput {

  let disposeBag = DisposeBag()
  let gnomeObject: Observable&lt;Gnome?&gt;

  init() {
    gnomeObject = viewDidLoadProperty
      .asObservable()
      .filter { !$0.isEmpty }
      .map { guard let gnome = Gnome
        .fetch(uniqueValue: $0, forKey: ""name"")! as? Gnome else { return nil }
        return gnome
    }
  }

  let viewDidLoadProperty = Variable&lt;String&gt;("""")
  func viewDidLoad(with name: String) {
    viewDidLoadProperty.value = name
  }

}
</code></pre>

<h3>ViewController</h3>

<p>I make the binding as follows:</p>

<pre><code>  func bindViewModel() {
    viewModel.outputs.gnomeObject
      .subscribe { observable in self.populate(with: observable.element != nil ? observable.element! : nil) }
      .addDisposableTo(viewModel.disposeBag)
  }
</code></pre>

<p>And this is ""fine"". It works perfectly (at least as expected).
But, I while reading the following book: <a href=""https://victorqi.gitbooks.io/rxswift/content/tips.html"" rel=""nofollow noreferrer"">https://victorqi.gitbooks.io/rxswift/content/tips.html</a>
In the tips section it says: </p>

<blockquote>
  <p>Always strive to model your systems or their parts as pure functions. Those pure functions can be tested easily and can be used to modify operator behaviors.</p>
</blockquote>

<p>And after reading it I'm changed my ViewModel as follows:</p>

<h3>ViewModel (Edited)</h3>

<pre><code>internal protocol DetailViewModelInput {
  func viewDidLoad(with name: String)
}

internal protocol DetailViewModelOutput {
  func gnomeObject() -&gt; Observable&lt;Gnome?&gt;
}

protocol DetailViewModelType {
  var disposeBag: DisposeBag { get }
  var inputs: DetailViewModelInput { get }
  var outputs: DetailViewModelOutput { get }
}

struct DetailViewModel: DetailViewModelType, DetailViewModelInput {

  let disposeBag = DisposeBag()

  let viewDidLoadProperty = Variable&lt;String&gt;("""")
  func viewDidLoad(with name: String) {
    viewDidLoadProperty.value = name
  }
}

// MARK: DetailViewModelOutput
extension DetailViewModel: DetailViewModelOutput {
  func gnomeObject() -&gt; Observable&lt;Gnome?&gt; {
    return viewDidLoadProperty
      .asObservable()
      .filter { !$0.isEmpty }
      .map { guard let gnome = Gnome
        .fetch(uniqueValue: $0, forKey: ""name"")! as? Gnome else { return nil }
        return gnome
    }
  }
}
</code></pre>

<p>The difference in the ViewModels is the GnomeObject declaration, in one it is a <code>var</code> and in the ""edited"" is a <code>func</code>.
My concern is, that every time <code>gnomeObject()</code> gets called from the <code>ViewController</code>, it will create a new instance of the observable.</p>

<p>What should best practice in this case?</p>

<p>Thanks in advanced!</p>
","2533874","","","","","2017-08-13 12:18:18","RxSwift with MVVM Best Practice Declaring Output Variable/Function","<swift><mvvm><rx-swift>","3","0","","","","CC BY-SA 3.0"
"45650382","1","","","2017-08-12 12:40:04","","1","56","<p>I am using Alamofire my server will send errors like authentication failure which is common to most of the apis how can I handle this only at place.
Because the error needs to be handled same in all reponses.</p>
","7397702","","","","","2017-08-12 13:02:32","Alamofire multple URLS error handling at one place","<swift><alamofire><rx-swift>","1","1","","","","CC BY-SA 3.0"
"45679754","1","","","2017-08-14 17:22:21","","0","1464","<p>I'm using RxSwift and I want to use <code>UITapGestureRecognizer</code> for dismiss keyBoard:</p>

<pre><code>  let tapGest = UITapGestureRecognizer()
    tapGest.rx.event.subscribe(onNext: {[weak self] _ in
        self?.view.endEditing(true)
    }).disposed(by: disposeBag)
    view.addGestureRecognizer(tapGest)
</code></pre>

<p>but when I use gesture, app is terminating with this error:</p>

<blockquote>
  <p>*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[<em>TtGC7RxCocoa13GestureTargetCSo22UITapGestureRecognizer</em> eventHandler:]: unrecognized selector sent to instance 0x600000446bd0' </p>
</blockquote>
","5396410","","1033581","","2018-10-06 03:21:46","2018-10-06 03:21:46","unrecognized selector for UITapGestureRecognizer in RxSwift","<ios><swift><rx-swift><uitapgesturerecognizer>","3","1","","","","CC BY-SA 4.0"
"45701542","1","45702784","","2017-08-15 21:06:11","","0","594","<p>I'm fairly new to RxSwift, so I have the following problem, lets suppose I have 3 Observable example functions which return different observable types:</p>

<pre><code>func observableFunc1(item1: DummyObject) -&gt; Observable&lt;AVURLAsset&gt; {
    return Observable.create { observer in

        let something_with_AVURLAsset = AVURLAsset(url: URL(fileURLWithPath: ""file""))

        observer.onNext(something_with_AVURLAsset)

        observer.onCompleted()

        return Disposables.create()
    }
}

func observableFunc2(item: AVURLAsset) -&gt; Observable&lt;Data&gt; {
    return Observable.create { observer in

        let something_with_data = Data()

        observer.onNext(something_with_data)

        observer.onCompleted()

        return Disposables.create()
    }
}

func observableFunc3(_ params: [String:Any]) -&gt; Observable&lt;Any&gt; {
    let disposeBag = DisposeBag()
    return Observable.create { observer in
        RxAlamofire.request(api.sendData(params)).debug().subscribe(
            onNext: { reponse in
                observer.onCompleted()
        },
            onError: { error in
                observer.onError(customError.theError(""error""))
        }
            )
            .addDisposableTo(disposeBag)
        return Disposables.create()
    }
}
</code></pre>

<p>How can I execute these 3 functions sequentially with the return value of func1 to be used on func2 and then when func2 is completed finally run func3.</p>

<p>I hope I made the question clear enough, but then again I'm really new to RxSwift and I don't know if these operations are possible or not.</p>
","1065307","","","","","2017-08-15 23:14:38","Chain sequence observables with arguments","<ios><swift><reactive-programming><rx-swift>","1","2","1","","","CC BY-SA 3.0"
"45705154","1","","","2017-08-16 04:29:54","","0","581","<p>I am using <code>Answers</code> event logging from fabric. But sometimes it doesn't recorded as it should be in the fabric dashboard. Right now, i call the API from function that returns its weak reference. Is that matter?</p>

<pre><code>return PINInteractor.registerWithPhoneNumber(phoneNumber: self.phoneNumber, PIN: self.PIN.value, authorizationCode: authorizationCode)
    .map { [weak self] _ -&gt; PINSuccessModel in
        guard let `self` = self else {
            return PINSuccessModel()
        }

        Answers.logLogin(withMethod: ""LOGIN FACEBOOK"", success: true), customAttributes: nil)
        return PINSuccessModel()
    }
})
</code></pre>
","2924335","","2924335","","2017-08-16 04:43:54","2017-08-21 10:10:55","Answer login event from fabric crashlytics did not logging","<swift><crashlytics><rx-swift><google-fabric>","0","5","","","","CC BY-SA 3.0"
"45707413","1","","","2017-08-16 07:22:42","","2","110","<p>I am using Crashlytics from Fabric.io to manage a crash reports from an app.</p>

<p>I am considering to add RxSwift into new project but have doubt if a crash reports would be meaningful? Any experience ?</p>
","1180728","","3747037","","2018-01-30 16:06:10","2021-01-13 10:08:04","Are crash reports meaningful when using RxSwift","<ios><swift><crashlytics><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"45718335","1","","","2017-08-16 16:05:12","","1","195","<p>I can see from RxSwift <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/SimpleTableViewExampleSectioned/SimpleTableViewExampleSectionedViewController.swift"" rel=""nofollow noreferrer"">examples</a> how to create a table with sections. How can I create a table with sections AND index numbers or alphabet, like <a href=""http://www.appcoda.com/ios-programming-index-list-uitableview/"" rel=""nofollow noreferrer"">this</a>.</p>

<p>As there is no examples, I am guessing some extensions needs to be implemented?</p>

<p>Thanks</p>
","699215","","1113632","","2018-01-30 14:04:55","2018-01-30 14:04:55","RxSwift - UITable with sections AND index","<swift><rx-swift>","0","0","","","","CC BY-SA 3.0"
"45725623","1","","","2017-08-17 02:18:48","","1","244","<p>When a user taps button, my viewModel needs to execute some tasks, such as resigning first responder (keyboard). I presume the best way is to set up a trigger in my ViewModel, that the ViewController will observe. Seems like a good time to use an <code>observable</code> <code>output</code> that doesn't emit any values like so: </p>

<p><code>var resignFirstResponder = Observable&lt;Any&gt;.never()</code></p>

<p>how do I emit new event for ViewController to listen to?</p>
","","user6354073","1113632","","2018-01-30 12:43:37","2018-01-30 12:43:37","How to trigger event for `never` operator in RxSwift","<ios><swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 3.0"
"45736522","1","45738297","","2017-08-17 13:31:25","","10","9755","<p>I am not so convinced with RxSwift yet, and it's really hard to cleat understanding. After reviewing different materials, I cant' still work and manipulate sequences.
On the whole I have problem with type converting:</p>

<pre><code>Cannot convert return expression of type 'Observable&lt;Bool&gt;' to return type 'Observable&lt;Void&gt;' (aka 'Observable&lt;()&gt;')    
</code></pre>

<p>I have CocoaAction processing, and should return <code>Observable&lt;Void&gt;</code></p>

<pre><code>func stopProject() -&gt; CocoaAction {
    return CocoaAction { _ in
        let stopProject = stop(project: self.projectId)
        return stopProject.asObservable() //wrong converting
    }
}
</code></pre>

<p>The <code>stop</code> function return <code>Observable&lt;Bool&gt;</code></p>

<p><strong>Finish view:</strong></p>

<pre><code>    return stop(project: self.projectId).flatMap { _ in
        Observable&lt;Void&gt;.empty()
    }
</code></pre>
","1278744","","1278744","","2020-07-13 09:34:20","2020-11-27 12:20:36","RxSwift convert Observable<Bool> to Observable<Void>","<ios><swift><generics><sequence><rx-swift>","3","0","","","","CC BY-SA 4.0"
"45745208","1","45745640","","2017-08-17 21:28:49","","0","1083","<p>When I run my iOS app from Xcode to the iOS simulator or to my physical device, the app crashes within a couple of seconds. As the app then enters the background and I am returned to the iPhone homescreen, the Alert View asking for permission to use my location pops up but then quickly disappears before I can select an answer. </p>

<p>After declaring and initializing a CLLocationManager called ""locationManager"", I believe that the errors are triggered from these statements:</p>

<pre><code>    locationManager.requestWhenInUseAuthorization()
    locationManager.requestLocation()
</code></pre>

<p>The main error that appears in the console logs is: </p>

<pre><code>*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Delegate must respond to locationManager:didFailWithError:'
</code></pre>

<p>I have set my usage description with the ""NSLocationWhenInUseUsageDescription"", so that my app can present to the user what their location will be used for, thus giving the app permission to access their location. Is there anything else I am missing that may contribute to this error? </p>

<p>In order to get the location of the user, do I only need it request it through adding the ""NSLocationWhenInUseUsageDescription"" key to the Info.plist file, or are there more measures I need to approach?</p>
","8421949","","8421949","","2017-08-17 21:46:23","2017-08-17 22:05:44","iOS app crashes on launch screen, location is requested after app crashes (Xcode 8.3.3)","<ios><xcode><geolocation><cllocationmanager><rx-swift>","1","5","","","","CC BY-SA 3.0"
"45766737","1","","","2017-08-19 01:07:46","","0","1115","<p>I need to upload image, and save Item to database on button tap. 
Not sure if I have taken the right approach here. Should I separate the upload request? Is it safe to emit an event in the <code>do(onNext:)</code> <code>operator</code> since its all async? I also need to account for errors, and the only place I do that is when I save Item. I'm banking on any error propagating. Also, Saving Item is a cold observable, so do I need to subscribe to it from the view Model to actually execute the request? It just returns an <code>Observable&lt;Void&gt;</code>.  </p>

<pre><code>class AddItemViewModel {

    private let dispatcher = FirebaseDispatcher()

    var error: Observable&lt;Error&gt;?

    init() {

    }

    // - Add Item
    // 1. upload Image
    // 2. combine imageUrl with other input observables
    // 3. Construct Item &amp; emit in `do` operator? 
    // 4. Save Item
    //
    func addItem(title: Observable&lt;String?&gt;, price: Observable&lt;String?&gt;, tags: Observable&lt;String?&gt;, info: Observable&lt;String?&gt;, weeks: Observable&lt;Int&gt;, image: Observable&lt;UIImage?&gt;, didPressAddButton: Observable&lt;Void&gt;) {

        let item = image.flatMapLatest { image -&gt; Observable&lt;Item&gt; in

            return Observable&lt;Item&gt;.create { observer in

                if let image = image, let imageData = UIImageJPEGRepresentation(image, 0.8) {
                    // 1
                    let imageUrl = ImageAPI.uploadImage(data: imageData, type: .item)

                    _ = Observable.combineLatest(title, price, tags, info, weeks, imageUrl) {
                        (title, price, tags, info, weeks, imageUrl) -&gt; Item? in
                        // 3
                        if let title = title, let price = price, let tags = tags, let info = info, let weeks = Weeks(rawValue: weeks), let expirationDate = weeks.timeInterval {

                            let tagsArray = tags.components(separatedBy: "","") as NSArray

                            let currentUser = AuthService.shared.currentUser
                            let id = NSUUID().uuidString
                            let ownerId = currentUser.id
                            let ownerRating = currentUser.rating
                            let ownerName = currentUser.name
                            let ownerProfileImageUrl = currentUser.profileImageUrl
                            let creationDate = Date().timeIntervalSince1970 as Double
                            let bidCount = 0
                            let location = currentUser.location

                            let item = Item(id: id, ownerId: ownerId, ownerRating: ownerRating, ownerName: ownerName, ownerProfileImageUrl: ownerProfileImageUrl, creationDate: creationDate, expirationDate: expirationDate, title: title, price: price, info: info, imageUrl: imageUrl, bidCount: bidCount, tags: tagsArray, location: location)

                            return item

                        } else {
                            observer.onError(CustomError.invalidItem)
                            return nil
                        }
                        }.filter { $0 != nil }.map { $0! }

                        // Is this proper way to emit element?
                        .do(onNext: {
                            observer.onNext($0)
                        })
                } else {
                    observer.onError(CustomError.invalidImage)
                }
                return Disposables.create()
            }
        }



        // 4
        let savedItem = didPressAddButton.withLatestFrom(item)
            .flatMap { item in
                return SaveItemTask(data: item.toJSON() as [String : AnyObject], resource: .all).execute(in: self.dispatcher).materialize()
            }

        error = savedItem.filter { $0.error != nil }.map { $0.error! }

    }


}
</code></pre>

<p><strong>Reduce arguments by combining latest inside ViewController</strong> </p>

<pre><code>    private func bindInputs() {

    addButton.rx.tap.asObservable()
        .subscribe(onNext: {
            let itemInfo = Observable
                .combineLatest(self.titleTextField.rx.text.asObservable(),
                               self.priceTextField.rx.text.asObservable(),
                               self.tagsTextField.rx.text.asObservable(),
                               self.infoTextField.rx.text.asObservable(),
                               self.weeksSegmentedControl.rx.selectedSegmentIndex.asObservable(),
                               self.imageView.rx.observe(UIImage.self, ""image""))
                { (title, price, tags, info, weeks, image) -&gt; (String?, String?, String?, String?, Int, UIImage?) in
                    return (title, price, tags, info, weeks, image)
            }
            self.viewModel.saveItem(itemInfo)
        })
        .addDisposableTo(disposeBag)
}
</code></pre>
","","user6354073","1113632","","2018-01-30 12:46:08","2018-01-30 12:46:08","Combining Observables in RxSwift","<ios><swift><mvvm><rx-swift>","0","3","","","","CC BY-SA 3.0"
"45772773","1","","","2017-08-19 14:36:33","","0","263","<p>I need to indicate some state with delay, while user is typing. I'm trying to use RxSwift:</p>

<pre><code>_textField.rx.text.orEmpty.debounce(3, scheduler: MainScheduler.instance).distinctUntilChanged().subscribe({[weak self] _ in
        self?.typeViewShould(hide: true)
    }).addDisposableTo(disposeBag)
</code></pre>

<p>The problem is after 3 seconds, I want to wait, block executes as many times as characters I entered, and not only once with latest value. I tried to rewrite code from GitHub example search, but it doesn't work:</p>

<pre><code>        _ = _textField.rx.text.orEmpty.debounce(3, scheduler: MainScheduler.instance).distinctUntilChanged().flatMapLatest {[weak self] query -&gt; Observable&lt;[String]&gt; in
        self?._textField.text = nil
        self?.typeViewShould(hide: true)
        return .just([])
    }.observeOn(MainScheduler.instance)
</code></pre>

<p>What am I doing wrong?</p>
","4275140","","","","","2017-08-21 11:44:28","Problems using RxSwift","<swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"45792815","1","","","2017-08-21 08:46:57","","3","509","<p>I'm starting to use RxSwift at work and I'm on a project right now where I need to capture clicked links in a web view.
But I can’t get this method :<br>
<code>webView(_ webView: UIWebView, shouldStartLoadWith request: URLRequest, navigationType: UIWebViewNavigationType) -&gt; Bool</code><br>
from the UIWebViewDelegate to work. It's never called no matter what I do.</p>

<p>I tried to use the DelegateProxy thing but I think I don’t get it...<br>
I’m also trying to figure out what would be a more “Reactive” way to do this.</p>
","8494003","","","","","2017-08-21 10:16:22","Capture clicked links in a UIWebView using RxSwift","<ios><swift><uiwebview><rx-swift><uiwebviewdelegate>","2","0","0","","","CC BY-SA 3.0"
"45832746","1","","","2017-08-23 07:00:42","","0","1973","<p>I write a subscribe in viewWillAppear.<br>
But it also run once in first launch app.<br>
When I push to another viewcontroller, I use dispose().<br>
Then I back in first viewcontroller, my subscribe func in viewWillAppear don't run.<br>
What's wrong with my rx subscribe?</p>

<pre><code>var listSubscribe:Disposable?

override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)

    listSubscribe = chatrooms.notifySubject.subscribe({ json in
        print(""*1"") //just print once in first launch
        self.loadContents()
    })
}

override func viewWillDisappear(_ animated: Bool) {
    super.viewWillDisappear(animated)

    let controllers = tabBarController?.navigationController?.viewControllers
    if (controllers?.count)! &gt; 1 {
        listSubscribe?.dispose()
    }
}
</code></pre>
","8176735","","4108415","","2017-08-23 09:10:10","2017-08-25 06:07:54","Why RxSwift Subscribe just run once in First launch viewWillAppear?","<ios><swift><observable><rx-swift>","2","0","","","","CC BY-SA 3.0"
"45842917","1","45843324","","2017-08-23 14:44:50","","0","1422","<p>I have just started to learn RxSwift and faced with strange compile-time error.
 Code that works:</p>

<pre><code>let createChatFlow = createChatBinding.createAction
            .withLatestFrom(createChatInputs)
            .map {  ($0.0, $0.1, $0.2.map {$0.id}) }
            .filter { !$0.2.isEmpty &amp;&amp; $0.1?.isEmpty == false }
            .flatMapLatest { element in
                return self.conversationManager.create(chat: Chat(), with: element.0 ?? LetterImage(size: kDefaultAvatarSize, fullName: element.1 ?? kEmptyStringValue).getImage()!)
        }
</code></pre>

<p>Description:</p>

<pre><code>createChatInputs - tuple (UIImage?, String?, [User])
</code></pre>

<p>But when i write some code inside of the last closure:</p>

<pre><code>.flatMapLatest { element in
            var chat = Chat()
            chat.owner = AppState.current.user.id

            return self.conversationManager.create(chat: chat, with: element.0 ?? LetterImage(size: kDefaultAvatarSize, fullName: element.1 ?? kEmptyStringValue).getImage()!)
    }
</code></pre>

<p>The compiler says: <code>'Bool' is not convertible to '() throws -&gt; Bool'</code> and point on row with <code>filter</code>. Any Help would be appreciated.</p>
","6061098","","","","","2017-08-23 15:03:56","'Bool' is not convertible to '() throws -> Bool'","<swift><reactive-programming><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"45854370","1","45854498","","2017-08-24 06:25:00","","1","3853","<p>I am new to RxSwift and working on some sample to test. I have show some data on uitableview with the help of RxSwift. However when I try to delete any item from tableview and reload. Observable array didn't update and due to this scrolling at last item crashes. Below is the code, please help me know what I am doing wrong.</p>

<pre><code>self.itemArray = NSMutableArray(objects: ""First Item"",""Second Item"",""Third Item"",""Fourth Item"",""Fifth Item"",""Sixth Item"",""Seventh Item"",""Eight Item"",""Nineth Item"",""Tenth Item"",""Eleventh Item"",""Twelveth Item"",""Thirtheenth Item"",""Fourtheenth Item"",""Fifteenth Item"",""Sixteenth Item"",""Seventhenth Item"",""First Item"",""Second Item"",""Third Item"",""Fourth Item"",""Fifth Item"",""Sixth Item"",""Seventh Item"",""Eight Item"",""Nineth Item"",""Tenth Item"",""Eleventh Item"",""Twelveth Item"",""Thirtheenth Item"",""Fourtheenth Item"",""Fifteenth Item"",""Sixteenth Item"",""Seventhenth Item"")


var seqValue = Observable.just(self.itemArray)
seqValue
    .bind(to: rxtableView.rx.items) { (tableView, row, seqValue) in
        let cell = tableView.dequeueReusableCell(withIdentifier: ""Cell"")!
        cell.textLabel?.text = self.itemArray.object(at: row) as? String
        cell.backgroundColor = .clear
        return cell
    }.disposed(by: disposeBag)


self.rxtableView.rx.itemDeleted
    .subscribe(onNext: { [unowned self]indexPath in
        self.itemArray.removeObject(at: indexPath.row)
        seqValue = Observable.just(self.itemArray)
        self.rxtableView.reloadData()
    }).addDisposableTo(disposeBag)
</code></pre>
","833605","","7704130","","2017-08-24 06:30:06","2017-08-24 06:38:19","Array of observable element in RxSwift","<ios><iphone><rx-swift>","2","0","","","","CC BY-SA 3.0"
"45868619","1","","","2017-08-24 18:28:50","","1","556","<pre><code>struct SearchViewModel {
    lazy var rx_SearchResults: Driver&lt;[Repository]&gt; = self.fetchSearchResults()
    lazy var rx_FilteredSearchResults: Driver&lt;[Repository]&gt; = self.filteredSearchResults()
    fileprivate var searchQuery: Observable&lt;String&gt;
    fileprivate var scopeIndex:  Observable&lt;Int&gt;
init( searchTextObservable: Observable&lt;String&gt;, changeInScopeIndex: Observable&lt;Int&gt;)
    {
        self.searchQuery = searchTextObservable
        self.scopeIndex = changeInScopeIndex

    }
fileprivate func fetchRepositories() -&gt; Driver&lt;[Repository]&gt; {
        return repositoryName
            .subscribeOn(MainScheduler.instance) // Make sure we are on MainScheduler
            .do(onNext: { response in
                UIApplication.shared.isNetworkActivityIndicatorVisible = true
            })
            .observeOn(ConcurrentDispatchQueueScheduler(qos: .background))
            .flatMapLatest { text in // .background thread, network request
                return RxAlamofire
                    .requestJSON(.get, ""https://api.github.com/users/\(text)/repos"")
                    .debug()
                    .catchError { error in
                        return Observable.never()
                    }
            }
            .observeOn(ConcurrentDispatchQueueScheduler(qos: .background))
            .map { (response, json) -&gt; [Repository] in // again back to .background, map objects
                if let repos = Mapper&lt;Repository&gt;().mapArray(JSONObject: json) {
                    return repos
                } else {
                    return []
                }
            }
            .observeOn(MainScheduler.instance) // switch to MainScheduler, UI updates
            .do(onNext: { response in
                UIApplication.shared.isNetworkActivityIndicatorVisible = false
            })
            .asDriver(onErrorJustReturn: []) // This also makes sure that we are on MainScheduler
    }

}
</code></pre>

<p>Now i am trying to filteredSearchResults like this</p>

<pre><code>    **fileprivate  func filteredSearchResults() -&gt; Driver&lt;[FilesListSearchData]&gt; {
        return scopeIndex
            .subscribeOn(MainScheduler.instance) // Make sure we are on MainScheduler
            .do(onNext: { response in
                UIApplication.shared.isNetworkActivityIndicatorVisible = true
            })
            .observeOn(ConcurrentDispatchQueueScheduler(qos: .background))
            .map { index in // again back to .background, map objects
                return self.rx_SearchResults.asDriver()
            }
            .observeOn(MainScheduler.instance) // switch to MainScheduler, UI updates
            .do(onNext: { response in
                UIApplication.shared.isNetworkActivityIndicatorVisible = false
            })


}**
</code></pre>

<p>// Above method is wrong i am stuck how can i filter data now based on scope index.</p>

<p>As you people understood i am using MVVM I have two quires.</p>

<ol>
<li><p>How can show progress on my view controller which is doing here by this line </p>

<pre><code>        UIApplication.shared.isNetworkActivityIndicatorVisible = false/true
</code></pre></li>
<li><p>How can i filter Driver based on selected scope index.</p></li>
</ol>
","7397702","","","","","2017-08-24 18:28:50","how to filter Driver<[Repository]> objects in rxswift","<ios><swift><rx-swift>","0","3","","","","CC BY-SA 3.0"
"45870180","1","45874882","","2017-08-24 20:15:16","","0","1184","<p>I need to execute a task multiple times inside a for-loop. The task itself returns <code>Observable&lt;Void&gt;</code>. I feel that I may run into some unexpected errors by continuously subscribing. <strong>Is it okay to subscribe n times in <code>for-loop</code>?</strong> </p>

<pre><code>private func removeItem(from locations: Resource...) {
    for resource in locations {
        RemoveItemTask(id: item.value.id, resource: resource)
            .execute(in: self.dispatcher)
            .subscribe { event in
                if let error = event.error {
                    self.error = Observable.of(error)
                }
            }.addDisposableTo(self.disposeBag)
    }
}
</code></pre>
","","user6354073","1113632","","2018-10-06 04:29:32","2018-10-06 04:29:32","RxSwift Multiple subscriptions to same Observable in for-loop","<ios><swift><for-loop><subscription><rx-swift>","1","1","","","","CC BY-SA 3.0"
"45873345","1","","","2017-08-25 02:02:15","","0","2461","<p>I'm trying to combine observables and I want them to run in sequence (e.g., perform step 1, if some condition is met then perform step 2, if some condition is met then perform step 3). The only way I've found to do this is to add the conditions to each step, which I'm not a fan of:  Here's a sample of my current solution:</p>

<pre class=""lang-swift prettyprint-override""><code>enum Status {
    case unknown, exists, missing
}

func refresh() -&gt; Observable&lt;Status&gt; {
    return checkLocalStatus()
        .flatMapLatest { $0 == .exists ? Observable.just($0) : self.attemptRemoteStatusOverride() }
        .flatMapLatest { $0 == .exists ? Observable.just($0) : self.attemptRemoteStatusUpdate() }
}

private func checkLocalStatus() -&gt; Observable&lt;Status&gt; {
    return Observable.create { observer in
        // Regarding Maxim Volgin's comment, here I'm converting a closure to an 
        // observable... why not use Observable.create?
        self.cache.status { (status) in
            guard status != .exists else {
                observer.onNext(status) // .exists
                observer.onCompleted()
            }

            /* I don't want this condition to be here */
            if ignoreRemote {
                // status is !exists and we should ignore remote, throw error
                observer.onError(Errors.remoteDisabled)
            }

            observer.onNext(.missing)
            observer.onCompleted()
        }
    }
}

private func attemptRemoteStatusOverride() -&gt; Observable&lt;Status&gt; {
    return remote.statusOverride()
}

private func attemptRemoteStatusUpdate() -&gt; Observable&lt;Status&gt; {
    return Observable.create { observer in
        // Regarding Maxim Volgin's comment, here I'm converting a closure to an 
        // observable... why not use Observable.create?
        self.remote.updateStatus { (status, error) in
            guard error == nil else {
                observer.onError(error!)
            }
            observer.onNext(status)
            observer.onCompleted()
        }
    }
}
</code></pre>

<p>I'd like to do something like:</p>

<pre class=""lang-swift prettyprint-override""><code>func refresh() -&gt; Observable&lt;Status&gt; {
    return checkLocalStatus()
        .if({ $0 != .exists &amp;&amp; !ignoreRemote },
            then: { self.attemptRemoteStatusOverride() },
            else: { return $0 })
        .if({ $0 != .exists },
            then: { self.attemptRemoteStatusUpdate() },
            else: { return $0 })
}
</code></pre>

<p>or</p>

<pre class=""lang-swift prettyprint-override""><code>func refresh() -&gt; Observable&lt;Status&gt; {
    return checkLocalStatus()
        .flatMapLatest(if: { $0 != .exists &amp;&amp; !ignoreRemote }) { self.attemptRemoteStatusOverride() }
        .flatMapLatest(if: { $0 != .exists }) { self.attemptRemoteStatusUpdate() }
}
</code></pre>

<p>I haven't been able to find anything like what I'm attempting, so I assume I'm going about this wrong. Does anyone have suggestions or alternatives on how to go about this route of combining observables? I've seen examples using <code>combineLatest</code> and returning some results based on the result of something else, but I want to perform each step only if a condition is met. <code>combineLatest</code> would perform each step (every time) and then I would return the result(s) of some steps based on the output of other steps. I also started looking into writing a custom operator, but can't figure a way to do it.</p>

<p><strong>Update:</strong> I've changed to the following and plan to write a method to remove duplication:</p>

<pre class=""lang-swift prettyprint-override""><code>func refresh() -&gt; Observable&lt;Status&gt; {
    return checkLocalStatus()
        .flatMapLatest { status -&gt; Observable&lt;Status&gt;
            guard status != .exists &amp;&amp; !ignoreRemote else {
                return Observable.just(status)
            }
            return self.attemptRemoteStatusOverride()
        }
        .flatMapLatest { status -&gt; Observable&lt;Status&gt;
            guard status != .exists &amp;&amp; !ignoreRemote else {
                return Observable.just(status)
            }
            return self.attemptRemoteStatusUpdate()
        }
}
</code></pre>
","108546","","108546","","2017-08-25 07:25:50","2019-06-20 16:56:32","RxSwift combine observable with conditional","<conditional><observable><rx-swift>","1","3","1","","","CC BY-SA 3.0"
"45878470","1","45879413","","2017-08-25 09:31:24","","3","1535","<p>I'm currently replacing PromiseKit with RxSwift, and need to convert my deferred promise to RxSwift.</p>

<p>Current implementation example in PromiseKit:</p>

<pre><code>private var deferredDidLayout = Promise&lt;()&gt;.pending()

override func layoutSubviews() {
    super.layoutSubviews()

    self.deferredDidLayout.fulfill()
}

func setup() {
    _ = self.didLayout().then {_ -&gt; Void in
        // Do my stuff only one time!
    }
}

private func didLayout() -&gt; Promise&lt;()&gt; {
    return self.deferredDidLayout.promise
}
</code></pre>

<p>Current hack-implementation in RxSwift: </p>

<pre><code>private let observableDidLayout = PublishSubject&lt;Void&gt;()

override func layoutSubviews() {
    super.layoutSubviews()

    self.observableDidLayout.onCompleted()
}

func setup() {
     _ = self.observableDidLayout
        .subscribe(onCompleted: { _ in
            // Do my stuff only one time!
            // Issue: Will be executed on every onCompleted() call
     })
}
</code></pre>

<p>Thank you in regard!</p>

<p>PromiseKit: <a href=""https://github.com/mxcl/PromiseKit"" rel=""nofollow noreferrer"">https://github.com/mxcl/PromiseKit</a>
RxSwift: <a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxSwift</a></p>
","7766093","","7766093","","2017-08-25 09:49:17","2017-08-25 10:29:19","Swift 3: Convert PromiseKit deferred to RxSwift","<swift3><reactive-programming><deferred><rx-swift><rx-cocoa>","1","0","0","","","CC BY-SA 3.0"
"45883214","1","45883592","","2017-08-25 14:06:09","","0","887","<p>Using RxSwift, say I have a class A that contains an observable of integer</p>

<pre><code>class A: {
    let count: Observable&lt;Int&gt;
}
</code></pre>

<p>and a observable collection of objects of A</p>

<pre><code>let data: Observable&lt;[A]&gt;
</code></pre>

<p>I want to define a <code>sum: Observable&lt;Int&gt;</code> that will be the sum of all the <code>count</code> on all the objects in <code>data</code>. Whenever the <code>data</code> observable collection changes or any of the <code>count</code> property changes the <code>sum</code> should also change.</p>

<p>How to achieve this? I tried some <code>flapMap</code> and <code>map</code> combinations but only got to a solution when <code>sum</code> gets updated only when <code>data</code> gets updated, ignoring the  <code>count</code> changes.</p>
","581164","","","","","2017-08-25 15:07:54","Flat mapping observable properties in a observable collection in RxSwift","<ios><swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"45933993","1","","","2017-08-29 08:15:40","","0","958","<p>I am binding the tableview with two diffrent datasources such as one with actual result and another array with after clicking scope button filter.</p>

<pre><code>func bind() {
    self.searchBar.rx.searchButtonClicked
      .throttle(0.3, scheduler: MainScheduler.instance)
      .flatMapLatest { [weak self] _ -&gt; Observable&lt;[String]&gt; in
        guard let `self` = self else { return .just([]) }
        guard let query = self.searchBar.text else { return .just([]) }
        self.view.endEditing(true)
        self.loadingText.isHidden = false
        let items = self.githubService.search(query: query)
        self.githubService.searchItems = items
        return items
      }
      .bind(to: self.tableView.rx.items(cellIdentifier: ""cell"")) { row, name, cell in
        self.loadingText.isHidden = true
        cell.textLabel?.text = name
      }
      .disposed(by: self.disposeBag)
  }

  override func viewDidLayoutSubviews() {
    super.viewDidLayoutSubviews()
    self.tableView.frame = self.view.bounds
  }
}

func searchBar(_ searchBar: UISearchBar, selectedScopeButtonIndexDidChange selectedScope: Int) {
        //filterContentForSearchText(searchBar.text!, scope: searchBar.scopeButtonTitles![selectedScope])

        let filteredResult = self.githubService.filteredSearch(index: selectedScope)
            filteredResult
            .bind(to: self.tableView.rx.items(cellIdentifier: ""cell"")) { row, name, cell in // Getting crash here
                self.loadingText.isHidden = true
                cell.textLabel?.text = name
            }
            .disposed(by: self.disposeBag)
    }
</code></pre>

<p>This is the method which i use for filter.</p>

<pre><code>func filteredSearch(index:Int) -&gt; Observable&lt;[String]&gt; {
        guard index &gt; 0  else { return .just([]) }
        return searchItems!.filter { $0.contains(""a"")}
}
</code></pre>
","7397702","","","","","2017-09-18 20:50:47","RxSwift crash ""Maybe delegate was already set in xib or storyboard and now it’s being overwritten in code.”","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"45936400","1","","","2017-08-29 10:11:40","","1","959","<p>I'm using RxSwift for form handling in collection view and table view. I am facing an issue.</p>

<p>I have a single selection list component and I am creating <code>DisposeBag</code> every time while configuring to remove all previous subscribers. <code>onDisposed</code> method is called for both but I still receive duplicate <code>onNext</code> events. This works fine in that start but when I reload the collection view or the table view I am facing this issue. Please let me know is there something I am doing wrong or is this bug in library.</p>

<pre><code>var selectedIndex = Variable&lt;Int?&gt;(nil)

func configureRx(sender: RxRow&lt;Int&gt;) {

    dateVarDisposable = DisposeBag()

    selectedIndex
        .asObservable()
        .subscribe(onNext: {[weak self] (index) in
            self?.selectRow(selectedIndex: index)
            }, onDisposed: {

                print("""")
        })
        .addDisposableTo(disposableBag)

    sender.dataVariable.asObservable()
        .debug(self.stringTag, trimOutput: false)
        .subscribe(onNext: { (sender) in
            self.selectedIndex.value = sender
        }, onDisposed: {
    })
        .addDisposableTo(disposableBag)        
}
</code></pre>
","2404859","","231684","","2017-08-29 10:37:54","2017-08-30 03:40:36","Observer still receiving events after being disposed in cell RxSwift","<ios><swift><observable><rx-swift>","1","3","","","","CC BY-SA 3.0"
"45937008","1","45937233","","2017-08-29 10:41:06","","2","6049","<p>I am using rxSwift for the first time, I have a textfield in my View, I want to set its value to the viewModels property that corresponds. I have the following code but it throws errors. What am I missing here?</p>

<pre><code>self.loginView.emailTextField.rx.text
            .bindTo(self.loginViewModel.userEmail)
            .addDisposableTo(self.disposeBag)
</code></pre>

<p>Issue:</p>

<blockquote>
  <p>Cannot invoke 'bindTo' with an argument list of type '(String)'</p>
</blockquote>
","8510477","","231684","","2017-08-29 10:51:05","2017-08-29 10:52:24","Setting up rxSwift with a text field?","<ios><swift><rx-swift>","1","2","1","","","CC BY-SA 3.0"
"45940947","1","45941723","","2017-08-29 13:52:59","","2","4457","<p>I have an init that sets up the handling of observers for rxSwift on my viewModel </p>

<pre><code>init(login: Observable&lt;String&gt;, password: Observable&lt;String&gt;, buttonPress: Observable&lt;Void&gt;) {
        let userInputs = Observable.combineLatest(login, password) { (login, password) -&gt; (String, String) in
            return (login, password)
        }

        let callFromPress = buttonPress
            .withLatestFrom(userInputs)
            .map { (login, password) in
                self.makeLoginRequest(userLogin: login, loginPassword: password, loginSecret: self.loginSecret, deviceToken: self.deviceToken)
        }
    }
</code></pre>

<p>However when i tap the button, nothing happens. It is hooked up in the VC as so:</p>

<pre><code>buttonPress: self.loginView.loginButton.rx.tap.asObservable()
</code></pre>

<p>Any solutions as to why the button tap doesn't trigger anything despite no errors?</p>

<p>update:</p>

<pre><code>init(login: Observable&lt;String&gt;, password: Observable&lt;String&gt;, buttonPress: Observable&lt;Void&gt;) {
    let userInputs = Observable.combineLatest(login, password) { (login, password) -&gt; (String, String) in
        return (login, password)
    }

    buttonPress.subscribe(onNext: { each in
        print(each)
            .withLatestFrom(userInputs)
            .map { (login, password) in
                self.makeLoginRequest(userLogin: login, loginPassword: password, loginSecret: self.loginSecret, deviceToken: self.deviceToken)
        }
    }).disposed(by: self.disposeBag)
}
</code></pre>

<p>error:</p>

<blockquote>
  <p>Extraneous argument label 'onNext:' in call</p>
</blockquote>

<p>Update 2:</p>

<pre><code>init(login: Observable&lt;String&gt;, password: Observable&lt;String&gt;) {
    // each time the login and password change, returns login and string value
    didTapLoginButton = { [weak self] _ in
        // allows for strong self reference
        guard let `self` = self else { return }

        Observable.combineLatest(login, password) { (login, password) in
            //
            }
            .subscribe(onNext: { response in
                self.makeLoginRequest(userLogin: login, loginPassword: password, loginSecret: self.loginSecret, deviceToken: self.deviceToken)
                // do something with your response
            })
            .disposed(by: self.disposeBag)

    }
}
</code></pre>
","8510477","","8510477","","2017-08-29 15:30:40","2018-04-04 17:34:34","rxSwift Button Press Observer Issue","<ios><swift><uibutton><rx-swift>","2","0","","","","CC BY-SA 3.0"
"45941875","1","","","2017-08-29 14:34:20","","0","874","<p>In application I am writing I decided to use MVVM patter. I am binding ViewModels with Views using RxSwift + RxCocoa. Now I am facing a problem I cannot find any solution myself.</p>

<p>I have a list of ViewModels which I want to display in UITableView. In <code>tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath)</code> method I am dequeueing a cell and I am binding one of ViewModels from the list to this cell. ViewModel has <code>imageUrl</code> Variable and I use Kingfisher to download this image and put it into ImageView in that cell.</p>

<p>So here is my problem now: when download is completed I have to reload this row so Auto Layout will calculate its correct height. But when I use <code>tableView.reloadRows(at: [indexPath], with: .none)</code> the binding is recreated and it ends up with infinite loop (binding -> image download completion callback -> reload row -> binding -> ...)!</p>

<p>Any ideas how to workaround this?</p>
","3521125","","","","","2017-08-29 14:46:31","Reload UITableView row after downloading image (using MVVM)","<ios><swift><uitableview><rx-swift><rx-cocoa>","1","1","","","","CC BY-SA 3.0"
"45943626","1","45944108","","2017-08-29 16:01:26","","0","3349","<p>I trying setup <code>tableView</code> datasource binding with <code>RxSwift (3.6.1)</code> but I am getting an error when building the app:</p>

<blockquote>
  <p>Ambiguous reference to member 'items(cellIdentifier:cellType:)'</p>
</blockquote>

<p>Here just simple Observable from Array just for test:</p>

<p><img src=""https://i.stack.imgur.com/vC2lO.png"" alt=""Here just simple &lt;code&gt;Observable&lt;/code&gt; from &lt;code&gt;Array&lt;Int&gt;&lt;/code&gt; just for test""></p>

<p>P.S. viewController's <code>tableView</code> is connected in the Storyboard</p>
","8533581","","154603","","2017-08-29 19:44:10","2017-08-29 19:44:10","RxSwift: Ambiguous reference to member 'items(cellIdentifier:cellType:)'","<swift><uitableview><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"45977037","1","","","2017-08-31 08:41:53","","0","754","<p>So basically I have two actions I need to execute:</p>

<ul>
<li>first is login</li>
<li>second is get user profile</li>
</ul>

<p>They have to be done in right order because getting user profile cannot be done without logging in first.</p>

<p>So I had bunch of code that looked like this:</p>

<pre><code>func signIn(signinParameters: SignInParameters) -&gt; Observable&lt;SignInResult&gt; {
        return Observable&lt;SignInResult&gt;.create { [unowned self] observer in

            self.signinParameters = signinParameters

            self.apiConnector
                .signIn(with: signinParameters)
                .do(onNext: { [weak self] signinResult in

                    self!.apiConnector
                        .get()
                        .do(onNext: { user in

                            let realm = RealmManager.shared.newRealm()!

                            let realmUser = RealmUser()
                            realmUser.configure(with: user, in: realm)

                            try? realm.write {
                                realm.add(realmUser, update: true)
                            }

                            self!.setState(.authenticated)

                            observer.onNext(signinResult)

                        }, onError: { (error) in
                            observer.onError(error)
                        }, onCompleted: {
                            observer.onCompleted()
                        }).subscribe()

                    }, onError: { error in
                        observer.onError(error)
                }, onCompleted: {
                    print(""completed"")
                    observer.onCompleted()
                }).subscribe()

            return Disposables.create()
        }
</code></pre>

<p>I know this is not right because I cannot send onNext signal with signin result when both actions are finished. I've been reading and I figured out i need to flatmap both actions, combine them into one signal and then manipulate signinresult but I dont have a clue how to do that. So any help would be nice.</p>

<p>Thank you</p>

<p>EDIT 1:</p>

<p>so I've refactored code to look something like this, but there is still problem that I can't send signal when BOTH actions are finished, or am I wrong?</p>

<pre><code>func signIn(signinParameters: SignInParameters) -&gt; Observable&lt;SignInResult&gt; {
    return Observable&lt;SignInResult&gt;.create { [unowned self] observer in
        self.signinParameters = signinParameters

    self.apiConnector
        .signIn(with: signinParameters)
        .do(onNext: { (result) in

        }, onError: { (error) in

        }, onCompleted: { 

        })
        .flatMap({ (result) -&gt; Observable&lt;User&gt; in
            self.apiConnector.get().asObservable()
        })
        .do(onNext: { (user) in

        }, onError: { (error) in

        }, onCompleted: { 

        }).subscribe()

        return Disposables.create()
    }
}
</code></pre>
","1829206","","1829206","","2017-08-31 08:55:22","2017-09-01 12:38:14","RxSwift Chaining two signals in right order","<swift><swift3><rx-swift>","1","1","","","","CC BY-SA 3.0"
"46058266","1","46106255","","2017-09-05 15:10:18","","0","496","<p>I bind to <code>UIBindingObserver</code> for <code>barTintColor</code> new <code>UIColor</code> and <code>title</code>, but it does not showing. Wired thing is that when I drag UIViewController back and release everything appear</p>

<p><img src=""https://i.stack.imgur.com/HBZUG.gif"" width=""300""></p>

<hr>

<h2>Code</h2>

<pre><code>extension Reactive where Base: UINavigationBar {
  var barTintColor: UIBindingObserver&lt;Base, UIColor&gt; {
    return UIBindingObserver(UIElement: self.base) { navigationBar, barTintColor in
      navigationBar.barTintColor = barTintColor
    }
  }
}

class BaseViewController: UIViewController {
   private(set) var tintColor: Variable&lt;UIColor&gt; = Variable(ColorConstants.tintColor)

   override func viewDidLoad() {
     super.viewDidLoad()
     if let navigationBar = self.navigationController?.navigationBar {
       self.tintColor.asObservable()
         .bind(to: navigationBar.rx.barTintColor)
         .addDisposableTo(self.disposeBag)
      }
   }
}

 class TasksListViewController: BaseViewController {
   var viewModel: TasksListViewModel!
   ...
   override func viewDidLoad() {
     super.viewDidLoad()
     self.viewModel.colorObsrvable
       .unwrap()
       .bind(to: self.tintColor)
       .addDisposableTo(self.disposeBag)

    self.viewModel.titleObsrvable
     .unwrap()
     .bind(to: self.rx.title)
     .addDisposableTo(self.disposeBag)
   }
 }

 class TasksListViewModel {
   private(set) var titleObsrvable: Observable&lt;String?&gt;!
   private(set) var colorObsrvable: Observable&lt;UIColor?&gt;!

   init(from goal: Goal) {
     let goalPredicate = NSPredicate(format: ""(SELF = %@)"", self.goal.objectID)
     self.goalObservable = CoreDataModel.shared.rx.fetchObject(predicate: goalPredicate)
     self.titleObsrvable = goalObservable.map { $0?.name }
     self.colorObsrvable = goalObservable.map { $0?.color }
   }
 }

extension Reactive where Base: CoreDataModel {
  func fetchObjects&lt;T: NSManagedObject&gt;(predicate: NSPredicate? = nil) -&gt; Observable&lt;[T]&gt; {
    let entityName = String(describing: T.self)
    let fetchRequest = NSFetchRequest&lt;T&gt;(entityName: entityName)
    fetchRequest.sortDescriptors = [NSSortDescriptor(key: ""name"", ascending: true)]
    fetchRequest.predicate = predicate
    return base.managedObjectContext.rx.entities(fetchRequest: fetchRequest)
 }
}
</code></pre>

<p>class <code>Goal</code> is just class Entitiy</p>

<hr>

<h2>What I have tried</h2>

<ul>
<li>Yes it's MainThread, I tested. And also run this task on GCD MainThread ❌</li>
<li>added <code>observeOn(MainScheduler.sharedInstance)</code> does not help ❌</li>
<li>put breakpoints inside the UIBindingObserver when drag and release it does not call ❌</li>
<li>added title in storyboard to NavBar and it works, but with wired delay. First it shows ""Ti..."" and then ""Title"" ✅</li>
</ul>

<p>Replaced(And its works✅ idk why):</p>

<pre><code>self.titleObsrvable = goalObservable.map { $0?.name }
self.colorObsrvable = goalObservable.map { $0?.color } 
</code></pre>

<p>with:</p>

<pre><code>self.titleObsrvable = Observable.of(""1234"")
self.colorObsrvable = Observable.of(UIColor.red)
</code></pre>

<p>Any idea what I'm doing wrong?</p>

<hr>

<p>If you want to check whole project you can see it here:
<a href=""https://github.com/Yerkenabildin/my-everest"" rel=""nofollow noreferrer"">https://github.com/Yerkenabildin/my-everest</a></p>

<hr>
","5482826","","5482826","","2017-09-05 16:07:33","2017-09-07 23:03:01","UIBindingObserver for UINavigationBar does not work as expected","<ios><swift><core-data><uinavigationbar><rx-swift>","1","3","","","","CC BY-SA 3.0"
"46081460","1","","","2017-09-06 17:49:46","","1","2008","<p>I'm learning RxSwift, i want used RxDataSources with UICollectionView, but nothing is shown, please tell me where i was wrong, Thanks; 
My code:</p>

<p>---- Model ----</p>

<pre><code>struct Traveler {
    let name: String
    let avater: UIImage?
}

struct Travelers {
    var travelers: [Traveler]
}

extension Travelers: SectionModelType {
    typealias Item = Traveler

    var items: [Traveler] { return travelers }

    init(original: Travelers, items: [Traveler]) {
        self = original
        travelers = items
    }
}
</code></pre>

<p>---- data -----</p>

<pre><code>let items = Variable&lt;[Travelers]&gt;([
            Travelers(travelers: [Traveler(name: ""Bob"", avater: UIImage(named: ""pic1""))])
        ])
</code></pre>

<p>---- View -----</p>

<pre><code>let disposeBag = DisposeBag()

let dataSources = RxCollectionViewSectionedReloadDataSource&lt;Travelers&gt;()

let viewModel = TravelerViewModel()

lazy var travelerCollectionView: UICollectionView = {
    let layout = UICollectionViewFlowLayout()
    layout.minimumInteritemSpacing = 0
    layout.minimumLineSpacing = 0
    layout.scrollDirection = .horizontal
    layout.itemSize = CGSize(width: 44, height: 44)

    let travelerCollectionView = UICollectionView(frame: CGRect(x: 100, y: 100, width: 100, height: 100), collectionViewLayout: layout)
    travelerCollectionView.backgroundColor = .red
    travelerCollectionView.register(TravelerItemCell.self, forCellWithReuseIdentifier: TravelerItemCell.identifier)
    return travelerCollectionView
}()

override init(frame: CGRect) {
    super.init(frame: frame)
    addSubview(travelerCollectionView)

    viewModel.items.asObservable()
        .bind(to: travelerCollectionView.rx.items(dataSource: dataSources))
        .addDisposableTo(disposeBag)

    dataSources.configureCell = { (_, collection, indexPath, traveler) in
        let cell = collection.dequeueReusableCell(withReuseIdentifier: TravelerItemCell.identifier, for: indexPath) as! TravelerItemCell
        cell.setAvaterImage(avater: traveler.avater)
        return cell
    }
}
</code></pre>

<p>thanks, i want used UICollectionView show some people avater.</p>
","7407671","","7407671","","2017-09-07 03:04:40","2017-09-07 03:04:40","RxDataSources with UICollection","<ios><rx-swift><rxdatasources>","0","6","1","","","CC BY-SA 3.0"
"46113378","1","46113379","","2017-09-08 09:41:14","","1","437","<p>How can you navigate through textfields with the next / done keyboard buttons, only using RxSwift + RxCocoa?</p>
","3677221","","","","","2017-09-08 09:41:14","How to navigate through UITextFields (Next / Done Buttons) with Rx","<uitextfield><next><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"46163965","1","46165033","","2017-09-11 20:35:13","","1","1384","<p>As is the case with both Reactive and non-Reactive iOS projects alike, if you have a UI element (e.g. a button or a table view cell that is being selected) that pushes a view controller onto the navigation stack, if there's lag for some reason (especially on older devices) repetitive taps can result in duplicate pushes and thus bad UX. </p>

<p>Normally you could disable the element after the first tap.</p>

<p>For example:</p>

<pre><code>@IBAction func myButtonTap() { 
    button.isEnabled = false
    doTheRestOfTheAction()
}
</code></pre>

<p>I am relatively new to RxSwift. I am trying to figure out an appropriate Reactive way to implement this to fix a few bugs in my app where views get pushed repetitively.</p>

<p>Some thoughts:</p>

<p>Could use <code>debounce</code> or <code>throttle</code> but seems like a bandaid and won't necessarily fix every situation.</p>

<p>I'm currently thinking that the best way is to dispose of the subscription once the expected event has occurred.</p>

<pre><code>let disposable = tableView.rx.itemSelected
    .subscribe(onNext: { [weak self] indexPath in 
        self?.performSegue(withIdentifier: ""MySegueIdentifier"", sender: self)
    })

...

func prepareForSegue() {
    myDisposable.dispose()
    finishPrepareForSegue()
}
</code></pre>

<p>Although if you want to unsubscribe inside the subscribe block, the compiler complains about using a variable inside its own initial value, which makes sense. I suppose there are workarounds but I wonder, is there a better way? Maybe a Reactive operator I'm missing? </p>

<p>Tried searching around for similar examples but the results were limited.</p>

<p>Thanks</p>

<p>EDIT: perhaps the <code>takeUntil</code> operator? </p>

<p><a href=""https://stackoverflow.com/a/35912089/1032372"">Possibly relevant SO question</a>.</p>
","1032372","","1032372","","2017-09-11 20:42:24","2018-03-05 07:59:44","RxCocoa - prevent multiple view controller pushes when there's lag","<ios><uitableview><rx-swift><reactive><rx-cocoa>","2","0","1","","","CC BY-SA 3.0"
"46174275","1","46177488","","2017-09-12 10:40:27","","3","2655","<p>I'm working on an app where I want to achieve the following using RxSwift and RxCocoa</p>

<ol>
<li>Download JSON containing url to X number of files</li>
<li>Download file 1, process file 1</li>
<li>Download file 2, process file 2</li>
<li>Download file 3, process file 3</li>
</ol>

<p>... etc</p>

<p>The key here is that the processing of each file has to complete before downloading the next file. At the very least the order of the file processing must be performed in order. If I can start downloading file 2 while file 1 is processing, that would be awesome, but is not necessary.</p>

<p>I've tried using SerialDispatchQueueScheduler to make this work, but I since the files are of different sizes, the download of each file finishes at different times, and therefore the processing code fires in a different order than I started the downloads.</p>

<p>I could easily implement this without using Rx by using NSOperations and the like, but I'd like to keep using Rx in this app, as it's what I use elsewhere in this app.</p>

<p>Below I've included a snippet with some of the code. Comments have been added for the sake of this question.</p>

<pre><code>       .flatMap { [unowned self] (tasks: [DiffTask]) -&gt; Observable&lt;ApplyDiffStatus&gt; in
            return Observable.from(tasks)
                .observeOn(self.backgroundScheduler) // StackOverflow: backgroundScheduler is a SerialDispatchQueueScheduler
                .flatMapWithIndex({ [unowned self] (task, index) in
                    return self.fetchDiff(for: task, taskIndex: index, taskCount: tasks.count) // StackOverflow: Downloads a file from a URL
                })
                .catchError({ (error) -&gt; Observable&lt;DictionaryUpdater.DiffTaskProgress&gt; in
                    observable.onError(error)
                    throw error
                })
                .map({ (diffTask : DiffTaskProgress) -&gt; DiffTaskProgress.Progress in
                    // Stack Overflow: I've wrapped much of the progress observable in a Observable&lt;UpdateProgress&gt;
                    switch diffTask.progress {
                    case .started(currentTask: let currentTask, taskCount: let taskCount):
                        observable.on(.next(.fetchingDiff(progress: diffTask, currentDiff: currentTask, diffCount: taskCount)))
                    case .finished(data: _, currentTask: let currentTask, taskCount: let taskCount):
                        observable.on(.next(.fetchingDiff(progress: diffTask, currentDiff: currentTask, diffCount: taskCount)))
                    case .progress(completion: _, currentTask: let currentTask, taskCount: let taskCount):
                        observable.on(.next(.fetchingDiff(progress: diffTask, currentDiff: currentTask, diffCount: taskCount)))
                    }

                    return diffTask.progress
                })
                .flatMap({ [unowned self] (progress: DiffTaskProgress.Progress) -&gt; Observable&lt;ApplyDiffStatus&gt; in
                    switch progress {
                    case .finished(data: let data, currentTask: let currentTask, taskCount: let taskCount):
                        return self.applyDiff(data, currentTask: currentTask, taskCount: taskCount) // StackOverflow: PROCESSES THE FILE THAT WAS DOWNLOADED
                    default:
                        return Observable.empty()
                    }
                })
        }
</code></pre>
","37346","","","","","2021-03-04 04:33:37","How to implement a queue of serial network calls then processing in RxSwift?","<swift><rx-swift><rx-cocoa>","1","0","2","","","CC BY-SA 3.0"
"46179068","1","46184697","","2017-09-12 14:28:31","","0","838","<p>I'm subscribing to an observable, but if I'm adding the disposable to the <code>DisposeBag</code> in my class, the <code>onNext</code> block is never called. </p>

<p>Here is my code :</p>

<pre><code>@objc class AppleMusicPlaylistManager: NSObject {

    let disposeBag = DisposeBag()
    let playlists: [MPMediaPlaylist] = []

    func importAppleMusicPlaylist() {
        playlists.forEach { applePlaylist in
            applePlaylist.getItunesStoreTracks().subscribe(onNext: { tracks in
               // Doing things here
            }).addDisposableTo(disposeBag)
        }
    }
}
</code></pre>

<p>where <code>getItunesStoreTracks</code> return a <code>RxSwift.Observable&lt;[SoundsMusicITunesStore]&gt;</code> and the whole thing is used like that <code>AppleMusicPlaylistManager().importAppleMusicPlaylist()</code></p>
","3545547","","","","","2017-09-12 20:17:40","OnNext not called when disposing the result of Observable.subscribe","<swift><rx-swift>","1","2","","","","CC BY-SA 3.0"
"46186398","1","46191563","","2017-09-12 22:49:04","","0","459","<p><a href=""https://i.stack.imgur.com/C0PAK.png"" rel=""nofollow noreferrer"">tableView ambiguous reference error</a></p>

<p>I am facing this error like many of you faced already. I have following code in my UITableViewController:</p>

<pre><code>import Foundation
import RxSwift
import RxCocoa

class DiscoveryViewController : UITableViewController {

// MARK: - Properties
let viewModel = MFMovieListViewModel()
let disposeBag: DisposeBag = DisposeBag()

override func viewDidLoad() {
    super.viewDidLoad()
    setupBindings()
}

// MARK: - Rx binding
private func setupBindings() {
    self.viewModel
        .movies
        .bind(to: tableView
            .rx
            .items(cellIdentifier: MovieListCell.DefaultReuseIdentifier,
                                   cellType: MovieListCell.self)) {
            (row, movie, cell) in
            cell.configure(with: movie)
        }.addDisposableTo(self.disposeBag)       
}
}
</code></pre>

<p>View Model looks like:</p>

<pre><code>import Foundation
import RxSwift
import RxCocoa

class MFMovieListViewModel {

// MARK: - Properties
lazy var movies: Observable&lt;[MovieListMDB]&gt; = {
    return MFAPIClinet.sharedInstance().popularMovies()
}()   
}
</code></pre>

<p>Don't think it's related to Xcode 8.3 or OSX 10.12, but still tried restarting but nothing is resolved. Appreciate any help provided.</p>
","4309727","","","","","2017-09-13 07:36:07","Ambiguous reference to member 'tableView' using RxSwift","<ios><swift><uitableview><rx-swift>","1","0","","","","CC BY-SA 3.0"
"46201795","1","46204812","","2017-09-13 15:45:00","","3","3313","<p>I have a problem with implementing a UITableView using RxSwift.</p>

<p>I tried to bind an observable of an array of models to the table items with the following code.
<code>models.bind(to: self.tableView.rx.items(cellIdentifier: ""Cell"", cellType: ModelTableViewCell.self</code>.</p>

<p>But when I do it gives me the following error: <code>Type 'inout UITableView' does not conform to protocol 'ReactiveCompatible'</code> and I know the error can't be right because NSObject extends ReactiveCompatible so UITableView also does. Also, my project code isn't really different than the examples shown on <a href=""https://github.com/RxSwiftCommunity/RxDataSources"" rel=""nofollow noreferrer"">RxSwiftCommunity</a></p>

<p>I created a small example project that has the error.</p>

<p><a href=""https://i.stack.imgur.com/WSQgP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/WSQgP.png"" alt=""[Example code showing the error (picture)]""></a></p>
","2397741","","1113632","","2018-04-02 13:23:23","2018-04-02 13:23:23","RxSwift, RxCocoa and UITableview","<ios><swift><uitableview><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"46216044","1","46396760","","2017-09-14 09:58:09","","1","1013","<p>I want to show date as section title and group the messages as per their date.
I want to use RxDatasource library and having trouble to create SectionModel to feed directly to datasource.</p>

<pre><code>let source = sut.results.asObservable().map { result -&gt; Observable&lt;Message&gt; in
    switch result {
    case .success(let messages):
        return Observable.from(messages)
    default:
        break
    }
    return Observable.from([Message]())
    }
    .flatMap { $0 }

let group = source.groupBy { $0.date.dateOnly }
group.subscribe(onNext: {
   print($0)
}).disposed(by: disposeBag)
</code></pre>

<p>Below is the output I get in log:</p>

<pre><code>GroupedObservable&lt;String, Message&gt;(key: ""2017-01-01"", source: RxSwift.(GroupedObservableImpl in _FBBDBB31E5DDAA1ED24286DA8D9FFB1F)&lt;Swift.String, Tacos.Message&gt;)
GroupedObservable&lt;String, Message&gt;(key: ""2017-01-02"", source: RxSwift.(GroupedObservableImpl in _FBBDBB31E5DDAA1ED24286DA8D9FFB1F)&lt;Swift.String, Tacos.Message&gt;)
</code></pre>

<p>I am not able to find out the way to transform                <code>GroupedObservable&lt;String, Message&gt;</code> => <code>Observable&lt;SectionModel&lt;String,Message&gt;&gt;</code></p>

<p>The JSON which is converted to <code>Message</code> is as in the image:
<a href=""https://i.stack.imgur.com/LPZeU.png"" rel=""nofollow noreferrer"">json description here</a></p>
","7718634","","7718634","","2017-09-15 01:29:57","2020-03-22 19:40:35","How to transform GroupedObservable<String, Message> to SectionModel<String, Message> using Groupby operator of RxSwift?","<ios><swift><reactive-programming><rx-swift>","4","0","","","","CC BY-SA 3.0"
"46234386","1","","","2017-09-15 07:48:06","","4","2398","<p>Let's say I have some view initally filled with some data. Than I fetch data over network and want to update view with this updated data.</p>

<p>At this point I want to create Driver from this observable to drive UI elements. However in case of error in observable I don't want to do anything, as the view has already some data so I just want to ignore such error. asDriver() function wants to define what should be done in case of error. Is it ok to do it like this:</p>

<pre><code>let dataUpdated: Observable&lt;DataItem&gt; = ...

let driver = dataUpdated.asDriver(onErrorDriveWith: Driver&lt;DataItem&gt;.empty())
</code></pre>

<p>?</p>
","3077831","","","","","2021-07-01 20:20:59","RxSwit - driver from observable ignoring errors","<swift><rx-swift><rx-cocoa>","3","0","2","","","CC BY-SA 3.0"
"46250331","1","46657260","","2017-09-16 05:16:32","","0","152","<p>Object exists on firebase.  Opening a detail view based on the object ID.
It works fine when app is backgrounded and the function is called from</p>

<pre><code>func userNotificationCenter(_ center: UNUserNotificationCenter,
                            didReceive response: UNNotificationResponse,
                            withCompletionHandler completionHandler: @escaping () -&gt; Void)
</code></pre>

<p>When the app is killed and the notification handled the snapshot comes back null.</p>

<p>App Delegate:</p>

<pre><code>AppName.shared.user.shareReplayLatestWhileConnected().filterNil().distinctUntilChanged({ lhs, rhs in
        return lhs.key == rhs.key
    }).subscribe() { event in
        switch event {
        case .next(let user):
            self.userIdString = user.key
           ...
            if let notificationInfo = launchOptions?[UIApplicationLaunchOptionsKey.remoteNotification] as? [AnyHashable: Any] {
                self.handleMessageFromRemoteNotification(notificationInfo)
                }
            }...
</code></pre>

<p>Handler:</p>

<pre><code>Event.load(url.lastPathComponent).single().subscribe(onNext: { event in
            //prepare and present view here...
        }).addDisposableTo(disposeBag)
</code></pre>

<p>Failing event loading function:</p>

<pre><code>static func load(_ id: String) -&gt; Observable&lt;Event&gt; {
    return Observable.create() { observer in
        FirebaseDatabase.sharedInstance.ref.child(""events/\(id)"").observeSingleEvent(of: .value, with: {
            snapshot in
            //This the null snapshot
            if snapshot.exists() {
                if let event = Event(snapshot: snapshot) {
                    observer.onNext(event)
                }
                observer.on(.completed)
            } else {
                observer.on(.completed)
            }
        })
        return Disposables.create()
    }
}
</code></pre>
","1441286","","1441286","","2017-09-18 02:51:23","2017-10-10 01:19:11","RxSwift FirebaseDatabase snapshot <null> when handling launchOptions?[UIApplicationLaunchOptionsKey.remoteNotification]","<ios><swift><firebase><rx-swift>","1","0","","","","CC BY-SA 3.0"
"46285878","1","46290607","","2017-09-18 18:24:32","","0","565","<p>I'm new to RxSwift and trying implement app that using MVVM architecture. I have view model:</p>

<pre><code>class CategoriesViewModel {

fileprivate let api: APIService
fileprivate let database: DatabaseService

let categories: Results&lt;Category&gt;

// Input
let actionRequest = PublishSubject&lt;Void&gt;()

// Output
let changeset: Observable&lt;(AnyRealmCollection&lt;Category&gt;, RealmChangeset?)&gt;
let apiSuccess: Observable&lt;Void&gt;
let apiFailure: Observable&lt;Error&gt;

init(api: APIService, database: DatabaseService) {
    self.api = api
    self.database = database

    categories = database.realm.objects(Category.self).sorted(byKeyPath: Category.KeyPath.name)

    changeset = Observable.changeset(from: categories)

    let requestResult = actionRequest
        .flatMapLatest { [weak api] _ -&gt; Observable&lt;Event&lt;[Category]&gt;&gt; in
            guard let strongAPI = api else {
                return Observable.empty()
            }

            let request = APIService.MappableRequest(Category.self, resource: .categories)
            return strongAPI.mappedArrayObservable(from: request).materialize()
        }
        .shareReplayLatestWhileConnected()

    apiSuccess = requestResult
        .map { $0.element }
        .filterNil()
        .flatMapLatest { [weak database] newObjects -&gt; Observable&lt;Void&gt; in
            guard let strongDatabase = database else {
                return Observable.empty()
            }

            return strongDatabase.updateObservable(with: newObjects)
        }

    apiFailure = requestResult
        .map { $0.error }
        .filterNil()
}

}
</code></pre>

<p>and I have following binginds in view controller: </p>

<pre><code>   viewModel.apiSuccess
        .map { _ in false }
        .bind(to: refreshControl.rx.isRefreshing)
        .disposed(by: disposeBag)

    viewModel.apiFailure
        .map { _ in false }
        .bind(to: refreshControl.rx.isRefreshing)
        .disposed(by: disposeBag)
</code></pre>

<p>But if I comment bindings, part with database updating stops executing. I need to make it execute anyway, without using dispose bag in the view model. Is it possible?</p>

<p>And little additional question: should I use weak-strong dance with <code>api</code>/<code>database</code> and <code>return Observable.empty()</code> like in my view model code or can I just use <code>unowned api</code>/<code>unowned database</code> safely?</p>

<p>Thanks.</p>

<p>UPD: </p>

<p>Function for return observable in APIService:</p>

<pre><code>func mappedArrayObservable&lt;T&gt;(from request: MappableRequest&lt;T&gt;) -&gt; Observable&lt;[T]&gt; {
    let jsonArray = SessionManager.jsonArrayObservable(with: request.urlRequest, isSecured: request.isSecured)
    return jsonArray.mapResponse(on: mappingSheduler, { Mapper&lt;T&gt;().mapArray(JSONArray: $0) })
}
</code></pre>
","4707000","","4707000","","2017-09-19 12:36:54","2017-09-19 12:36:54","RxSwift and MVVM: observable not executing without binding","<swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 3.0"
"46305052","1","","","2017-09-19 16:05:04","","-1","251","<p>I am using RxSwift and Moya. I am getting </p>

<blockquote>
  <p>fatal error: unexpectedly found nil while unwrapping an Optional value</p>
</blockquote>

<p>error at line <code>authors.map {...</code> in tableViewController. When I print <code>authors</code> I found out it is nil. And I couldn't find where the problem is. I am using Moya-ObjectMapper/RxSwift library. In the latest release Observable+Objectmapper.swift file is missing so I found it on github and replaced it. </p>

<pre><code>//import libraries

class AuthorsTableViewController: UITableViewController {

    var viewModel: AuthorsViewModelType!
    var authors: Driver&lt;RequestResult&lt;[Author]&gt;&gt;!
    private let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()
        setUpBindings()
    }

    func setUpBindings() {

        tableView.dataSource = nil
        tableView.delegate = nil

        authors.map { result -&gt; [Author] in ---&gt; Here
            ...
            }.disposed(by: disposeBag)  
    }
}
</code></pre>

<p>My ViewModel:</p>

<pre><code>//import libraries

public protocol AuthorsViewModelType {
    func getAuthors(destination: YazarAPI) -&gt; Driver&lt;RequestResult&lt;[Author]&gt;&gt;
}

public class AuthorsViewModel: AuthorsViewModelType {
    fileprivate var provider = YazarAPI.sharedProviderInstance

    public func getAuthors(destination: YazarAPI) -&gt; Driver&lt;RequestResult&lt;[Author]&gt;&gt; {
        return provider.request(destination)
            .observeOn(MainScheduler.instance)
            .filterSuccessfulStatusCodes()
            .mapAuthors(destination: destination)
            .map { .Success($0) }
            .asDriver(onErrorRecover: { error in
                return .just(.Error(ReqestError(description: error.localizedDescription, code: .requestError)))
            })
    }
}

private extension Observable where E == Response {
    func mapAuthors(destination: YazarAPI) -&gt; Observable&lt;[Author]&gt; {
        let authors: Observable&lt;[Author]&gt;

        switch destination {
        case .authors:
            authors = self.mapObject(Authors.self).map { $0.authors ?? [] }
        default:
            fatalError(""Unexpected request type \""\(destination)\"""")
        } 
        return authors
    }
}
</code></pre>
","4704055","","790877","","2017-09-20 10:19:49","2017-09-22 12:04:34","RxSwift Mapping issue","<swift><rx-swift><moya>","1","0","","","","CC BY-SA 3.0"
"46327195","1","46333844","","2017-09-20 16:23:35","","0","970","<p>When the user taps on a button I display a selection screen. The result is passed into my view model. The code looks like this:</p>

<pre><code>locationButton.rx.tap
            .flatMapLatest(wireframe.displayPlaceSelection)
            .filterNil()
            .map(DiscoverLocationSelection.location)
            .subscribe(onNext: viewModel.updateLocation(with:))
            .disposed(by: disposeBag)
</code></pre>

<p>This code works fine, and the user may select a location and will be returned to this screen with the button.</p>

<p>If the user then taps the button a second time, the <code>displayPlaceSelection()</code> function is called twice. If the user were to do this a third time, the function will be called 3 times. This results in multiple view controllers being pushed on top of each other.</p>

<p>How can I stop these events from stacking up?</p>

<p>The effect is this:</p>

<p><a href=""https://i.stack.imgur.com/EFqNL.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/EFqNL.gif"" alt=""RxSwift Tap Replay""></a></p>
","1486106","","","","","2017-09-21 01:05:53","RxSwift - Replayed Tap Events","<swift><uinavigationcontroller><rx-swift>","1","2","","","","CC BY-SA 3.0"
"46338515","1","","","2017-09-21 08:00:28","","0","1440","<p>I am using RxSwift with RxRealm and RxRealmDataSources. My realm objects are binded to the table view. I'm trying to find a way to filter it based on query typed into search bar. Has anyone of you done sth like this?</p>

<pre><code>class ItemsViewController: UITableViewController {

    let bag = DisposeBag()
    let searchController = UISearchController(searchResultsController: nil)
    let search = BehaviorSubject(value: """")

    override func viewDidLoad() {
        super.viewDidLoad()
        searchController.searchResultsUpdater = self
        definesPresentationContext = true
        tableView.tableHeaderView = searchController.searchBar
        bindTableView()
    }

    func bindTableView() {
        let dataSource = RxTableViewRealmDataSource&lt;Item&gt;(cellIdentifier: ""itemCell"", cellType: UITableViewCell.self) { cell, ip, item in
            cell.textLabel?.text = item.uuid
        }
        Observable.changeset(from: DataStore.sharedInstance.getObjects(Item.self))
            .bind(to: tableView.rx.realmChanges(dataSource))
            .addDisposableTo(bag)
    }

}

extension ItemsViewController: UISearchResultsUpdating {

    public func updateSearchResults(for searchController: UISearchController) {
        search.onNext(searchController.searchBar.text ?? """")
    }

}
</code></pre>
","8646965","","8646965","","2017-09-25 11:54:08","2017-09-26 11:45:45","How can I filter results using RxSwift, RxRealmDataSources and UISearchController?","<ios><swift><realm><uisearchcontroller><rx-swift>","2","1","","","","CC BY-SA 3.0"
"46343661","1","","","2017-09-21 12:13:57","","0","123","<p>RxCocoa version 3.6.1 fails to build in Xcode 9 with error message : </p>

<pre><code>Initializer 'init(parentObject:)' with Objective-C selector   'initWithParentObject:' conflicts with initializer 'init(parentObject:)' from superclass 'RxScrollViewDelegateProxy' with the same Objective-C selector      
</code></pre>
","6210618","","","user8397869","2017-09-21 12:34:56","2017-09-21 12:40:49","CocoaPods RxCocoa 3.6.1 build failed in Xcode 9","<swift><xcode><cocoapods><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"46389034","1","46403880","","2017-09-24 10:26:36","","0","953","<p>I have following code:</p>

<pre><code>let categoriesRequest = APIService.MappableRequest(Category.self, resource: .categories)
let categoriesRequestResult = api.subscribeArrayRequest(categoriesRequest, from: actionRequest, disposedBy: disposeBag)

let newCategories = categoriesRequestResult
    .map { $0.element }
    .filterNil()

let categoriesUpdateData = DatabaseService.UpdateData(newObjectsObservable: newCategories)
let categoriesDatabaseResult = database.subscribeUpdates(from: categoriesUpdateData, disposedBy: disposeBag)

let latestTopicsRequest = APIService.MappableRequest(Topic.self, resource: .latestTopics)
let latestTopicsRequestResult = api.subscribeArrayRequest(latestTopicsRequest, from: actionRequest, disposedBy: disposeBag)

let newLastTopics = latestTopicsRequestResult
    .map { $0.element }
    .filterNil()

let latestTopicsUpdateData = DatabaseService.UpdateData(newObjectsObservable: newLastTopics)
let latestTopicsDatabaseResult = database.subscribeUpdates(from: latestTopicsUpdateData, disposedBy: disposeBag)
</code></pre>

<p>There are two requests that starts from the same publish subject <code>actionRequest</code>, and two database updates after these requests.</p>

<p>I need something like <code>isActive</code>, bool value which will return <code>true</code> if any of api/database task is in progress. Is it possible? I saw <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Services/ActivityIndicator.swift"" rel=""nofollow noreferrer"">ActivityIndicator</a> in RxSwift examples, but I don't know is it possible to use it in my case.</p>

<p>Code from api/database if needed:</p>

<pre><code>// API
func subscribeArrayRequest&lt;T&gt;(_ request: MappableRequest&lt;T&gt;,
                              from triggerObservable: Observable&lt;Void&gt;,
                              disposedBy disposeBag: DisposeBag) -&gt; Observable&lt;Event&lt;[T]&gt;&gt; {
    let result = ReplaySubject&lt;Event&lt;[T]&gt;&gt;.create(bufferSize: 1)

    triggerObservable
        .flatMapLatest {
            SessionManager
                .jsonArrayObservable(with: request.urlRequest, isSecured: request.isSecured)
                .mapResponse(on: APIService.mappingSheduler) { Mapper&lt;T&gt;().mapArray(JSONArray: $0) }
                .materialize()
        }
        .subscribe(onNext: { [weak result] event in
            result?.onNext(event)
        })
        .disposed(by: disposeBag)

    return result
}

// Database
func subscribeUpdates&lt;N, P&gt;(from data: UpdateData&lt;N, P&gt;, disposedBy disposeBag: DisposeBag) -&gt; Observable&lt;Void&gt; {
    let result = PublishSubject&lt;Void&gt;()

    data.newObjectsObservable
        .observeOn(DatabaseService.writingSheduler)
        .subscribe(onNext: { [weak result] newObjects in
            // update db

            DispatchQueue.main.async {
                result?.onNext(())
            }
        })
        .disposed(by: disposeBag)

    return result
}
</code></pre>

<p>Thanks.</p>
","4707000","","","","","2017-09-25 11:20:34","RxSwift track multiple observables activity","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"46392868","1","","","2017-09-24 17:27:42","","1","1299","<p>I try to manage rxswift &amp; Alamofire to get response.<br>
These functions get response successfully when token is not expired.<br>
But when the token is expired, I don't know how to refresh token and then retry to get response using new token.<br>
What should I do to refresh token and retry?<br>
I also read Alamofire documents, and I find ""RequestAdapter"" and ""RequestRetrier"".<br>
Should I use RequestAdapter &amp; RequestRetrier in my case?<br>
But I dont know how to use them in my ""getRequestJSON"" function,<br>
or have any good idea to refresh token and retry.<br>
Thanks.<br></p>

<pre><code>func get(_ callback: @escaping (JSON) -&gt; Void) {
let url = ""http://106.xx.xxx.xxx/user""
self.getRequestJSON( .get, url: url, params: [:], callback: { json in
    callback(json)
})
}

func getRequestJSON(_ method: Alamofire.HTTPMethod, url:String, params:[String:Any] = [:], callback: @escaping (JSON) -&gt; Void) {

var headers:[String:String] = [String:String]()
if token.isEmpty == false {
    headers[""Authorization""] = ""Bearer \(token)""
}

let configuration = URLSessionConfiguration.default
configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders
configuration.timeoutIntervalForRequest = timeout

_ = SessionManager(configuration: configuration)
    .rx.responseJSON(method,
                     url,
                     parameters: params,
                     encoding: ((method == .get) ? URLEncoding.default : JSONEncoding.default),
                     headers: headers)
    .subscribeOn(SerialDispatchQueueScheduler.init(qos: .background))
    .subscribe(onNext: { (r, data) in

        if r.statusCode == 401 {

        //token fail 
        }            

        let json = JSON(data)

        if json[""status""].stringValue == ""successful"" {

            callback(json)
        }else {
            callback(json)
        }
    }, onError: { (error) in

        callback(JSON(error))

    })
    .addDisposableTo(ResfulAPIDisposeBag)
}
</code></pre>
","8169327","","","","","2017-09-24 17:27:42","How to refresh Api authorization token using Alamofire & rxSwift?","<ios><swift><alamofire><rx-swift><rxalamofire>","0","0","1","","","CC BY-SA 3.0"
"46397575","1","46410826","","2017-09-25 04:19:56","","10","9703","<p>I'm trying to emit a sequence on a ”pulse” at a given time interval. Totally new to everything Rx, but thought this would do it:</p>

<pre><code>import RxSwift
let db = DisposeBag()

_ = Observable&lt;Int&gt;.interval(1.0, scheduler: MainScheduler.instance)
    .debug(""interval"")
    .subscribe(onNext: {
        print($0)
    })
    .addDisposableTo(db)
</code></pre>

<p>But it only outputs:</p>

<pre><code>2017-09-25 06:12:41.161: interval -&gt; subscribed
</code></pre>

<p>And nothing more. What am I not understanding here?</p>
","44639","","44639","","2017-09-25 06:22:22","2017-09-25 17:24:11","How to use RxSwift Observable<Int>.interval?","<swift><rx-swift>","1","8","","","","CC BY-SA 3.0"
"46422066","1","46442746","","2017-09-26 09:01:44","","0","758","<p>The following code works:</p>

<pre><code>    let provider = RxMoyaProvider&lt;MyAPI&gt;( stubClosure: MoyaProvider.delayedStub(3))

    provider
        .request(.studentSearch(query: """"))
        .retry(3)
        .observeOn(MainScheduler.instance)
        .asObservable()
        .mapJSON()
        .map { respJSON in
            guard let studentsJsonArray = JSON(respJSON)[""students""].array else {
                throw APIError.wrongJSONParsing
            }
            return studentsJsonArray.map {
                guard let students = Student.fromJSON($0) else {
                    fatalError(""Invalid Student Object"")
                }
                return students
                } as [Student]
        }
        .subscribe(onNext: {
          print($0)
        }, onCompleted: {
          print($0) // This one is being called.
        })
        .disposed(by: rx.disposeBag)
</code></pre>

<p>The method onCompleted is being called in the above code But not in the following one.</p>

<p>I am trying to do it with refresh trigger like the one in the UITableView for refreshing the content. I want to load the contents on start so I use <code>startWith(())</code> in the following code in my ViewModel</p>

<pre><code>let results: Driver&lt;[Student]&gt;
var refreshTrigger = PublishSubject&lt;Void&gt;()
results = refreshTrigger
        .startWith(())
        .do(onNext: {
            execute.value = true
        })
        .flatMapLatest {
            provider
                .request(.studentSearch(query: """"))
                .retry(3)
                .observeOn(MainScheduler.instance)
                .asObservable()
        }
        .mapJSON()
        .map { respJSON in
            guard let studentsJsonArray = JSON(respJSON)[""students""].array else {
                throw APIError.wrongJSONParsing
            }
            return studentsJsonArray.map {
                guard let students = Student.fromJSON($0) else {
                    fatalError(""Invalid Student Object"")
                }
                return students
            }
        }
        .do(onNext: {
            items.value = $0
            execute.value = false
            noResults.value = items.value.isEmpty
        }, onCompleted: {
            print($0)
        })
        .asDriver(onErrorJustReturn: [])
</code></pre>

<p>and in the controller I call following in viewdidload.</p>

<pre><code>viewModel
        .results
        .asObservable()
        .map { StudentGroup(header: ""Follower"", items: $0) }
        .subscribe(onNext: {
            print($0)
        }, onCompleted: {
            print($0) // This is not being called.
        })
        .disposed(by: rx.disposeBag)
</code></pre>

<p>Here onCompleted is not being called. I don't know the reason why?. Please help me out.</p>
","7718634","","","","","2017-09-27 08:16:13","Not getting Completed event on RxSwift with RxMoya","<ios><swift><uitableview><rx-swift><moya>","1","0","","","","CC BY-SA 3.0"
"46469532","1","","","2017-09-28 12:45:43","","0","221","<p>Consider the following two variables:</p>

<pre><code>let int = Variable&lt;Int&gt;(1)

let string = Variable&lt;String&gt;(""hey!"")
</code></pre>

<p>let's assume that they are all bound to some UI already, like: </p>

<pre><code>int.asObservable.bind(to:variable1)
string.asObservable.bind(to:variable2)
</code></pre>

<p>How can I make sure that <code>string.asObservable.bind(to:variable2)</code> is only executed after <code>int.asObservable.bind(to:variable1)</code> has been executed? </p>
","3971959","","5501940","","2017-09-28 12:56:15","2017-09-28 15:55:38","How to do a serial execution on rxSwift variable?","<ios><swift><observable><rx-swift>","1","3","","","","CC BY-SA 3.0"
"46476424","1","46491482","","2017-09-28 18:55:48","","0","364","<p>Given a Service object, I want to be sure that each function call to the service will not result in side effects. In my case whatever function A is doing, nothing will be executed in function B unless the scheduler is available.</p>

<p>Here's what this looks like:</p>

<pre><code>class Service {

    func handleJobA(input: String) -&gt; Observable&lt;String&gt; {
        return Observable.just(input)
            .do(onNext: { (str) in
                print (""Job A: \(str)"")
            })
            .concatMap { input -&gt; Observable&lt;String&gt; in
                return Observable.just(""Job AA: \(input)"")
                    .delay(2, scheduler: self.scheduler)
                    .do(onNext: { (str) in
                        print (str)
                    })
            }

            .subscribeOn(scheduler)
    }

    func handleJobB(input: String) -&gt; Observable&lt;String&gt; {
        return Observable.just(input)
            .do(onNext: { (str) in
                print (""Job B: \(str)"")
            })
            .delay(1, scheduler: scheduler)
            .concatMap { input -&gt; Observable&lt;String&gt; in
                return Observable.just(""Job BB: \(input)"")
                    .do(onNext: { (str) in
                        print (str)
                    })
            }

            .subscribeOn(scheduler)
    }


    let scheduler = SerialDispatchQueueScheduler(internalSerialQueueName: ""Service"")
}


let service = Service()

_ = Observable.from([""1"",""2"",""3""])
    .concatMap { service.handleJobA(input: $0) }
    .subscribe(onNext:{
        print($0 + "" √"")
    })

_ = Observable.from([""1"",""2"",""3""])
    .concatMap { service.handleJobB(input: $0) }
    .subscribe(onNext:{
        print($0 + "" √"")
    })

import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true
</code></pre>

<p>At the moment, the output is:</p>

<pre><code>Job A: 1
Job B: 1
Job BB: 1
Job BB: 1 √
Job B: 2
Job AA: 1
Job AA: 1 √
Job A: 2
Job BB: 2
Job BB: 2 √
Job B: 3
Job BB: 3
Job BB: 3 √
Job AA: 2
Job AA: 2 √
Job A: 3
Job AA: 3
Job AA: 3 √
</code></pre>

<p>However, this shows the fundamental problem. The internal delays (which can happen from anything, really.. network, processing) cause the observable processing to get out of ""order"".</p>

<p>What I want is this:</p>

<pre><code>Job A: 1
Job AA: 1
Job AA: 1 √
Job B: 1
Job BB: 1
Job BB: 1 √
Job B: 2
Job BB: 2
Job BB: 2 √
Job B: 3
Job BB: 3
Job BB: 3 √
Job A: 2
Job AA: 2
Job AA: 2 √
Job A: 3
Job AA: 3
Job AA: 3 √
</code></pre>

<p>That means, once a function has started processing a task, no one else get's access unless it is done.</p>

<p>I received a very good <a href=""https://stackoverflow.com/a/43808017/375209"">answer</a> previously. It's not totally applicable, as flatMap/concatMap (?) both seem to dislike the schedulers.</p>

<p>My theory is that the concatMap call indeed does the right job, but then schedules the child sequence omissions to the end of the schedulers queue, whereas I would want it at the front, to be processed next.</p>
","375209","","375209","","2017-10-02 07:32:02","2017-10-02 07:32:02","concatMap / flatMap should run immediately, on the same scheduler","<reactive-programming><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"46481927","1","","","2017-09-29 04:43:23","","0","607","<p>on my project I use RxSwift and Action to handle refresh indicator, but I got issues when run this code. Refresh control not showing, when I debug subscribe work properly but not showing refreshControl. It will be different when I set <code>self.refreshControl?.beginRefreshing()</code> on outside <code>if (executing == true) {</code> block</p>

<pre><code>self.viewModel.transactionHistoryNetworkRequestAction?.executing
        .subscribeOn(MainScheduler.instance)
        .subscribe(onNext: { (executing) in
            if (executing == true) {
                self.refreshControl?.beginRefreshing()
            } else {
                self.refreshControl?.endRefreshing()
            }
        })
        .addDisposableTo(self.disposeBag)
</code></pre>

<p>thanks for the answer</p>
","3438467","","2227743","","2017-09-29 12:38:33","2017-09-29 12:38:33","RxSwift not show refreshControl when action is executing","<swift><action><rx-swift><uirefreshcontrol>","1","0","","","","CC BY-SA 3.0"
"46482491","1","","","2017-09-29 05:48:49","","0","1197","<p>I have a very simple project, where I want to dynamically filter content in <code>UITableView</code> regarding pressed index in <code>UISegmentedControl</code>. I'm using MVVM with RxSwift, Realm and RxDataSources. So my problem, that if I want to update content in <code>UITableView</code> I need to create 'special' <code>DisposeBag</code>, only for that purposes, and on each selection in <code>UISegmentedControl</code> nil it and create again. Only in this case, if I'm understand right, subscription is re-newed, and <code>UITableView</code> displays new results from Realm. 
    So is there any better way to do such operation? Without subscribing every time, when I switch tab in <code>UISegmentedControl</code>. Here's my code:</p>

<pre><code>//ViewController
class MyViewController : UIViewController {

  //MARK: - Props
  @IBOutlet weak var tableView: UITableView!
  @IBOutlet weak var segmentedControl: UISegmentedControl!

  let dataSource = RxTableViewSectionedReloadDataSource&lt;ItemsSection&gt;()
  let disposeBag = DisposeBag()

  var tableViewBag: DisposeBag!
  var viewModel: MyViewModel = MyViewModel()

  //MARK: - View lifecycle
  override func viewDidLoad() {
    super.viewDidLoad()
    self.setupRxTableView()
  }

  //MARK: - Setup observables
  fileprivate func setupRxTableView() {
    dataSource.configureCell = { ds, tv, ip, item in
      let cell = tv.dequeueReusableCell(withIdentifier: ""ItemCell"") as! ItemTableViewCell
      return cell
    }

    bindDataSource()

    segmentedControl.rx.value.asDriver()
      .drive(onNext: {[weak self] index in
        guard let sSelf = self else { return }
        switch index {
        case 1:
          sSelf.bindDataSource(filter: .active)
        case 2:
          sSelf.bindDataSource(filter: .groups)
        default:
          sSelf.bindDataSource()
        }
      }).disposed(by: disposeBag)
  }

  private func bindDataSource(filter: Filter = .all) {
    tableViewBag = nil
    tableViewBag = DisposeBag()
    viewModel.populateApplying(filter: filter)
      }).bind(to: self.tableView.rx.items(dataSource: dataSource))
      .disposed(by: tableViewBag)
  }
}

//ViewModel
   class MyViewModel {
      func populateApplying(filter: Filter) -&gt; Observable&lt;[ItemsSection]&gt; {
       return Observable.create { [weak self] observable -&gt; Disposable in
         guard let sSelf = self else { return Disposables.create() }
         let realm = try! Realm()
         var items = realm.objects(Item.self).sorted(byKeyPath: ""date"", ascending: false)
         if let predicate = filter.makePredicate() { items = items.filter(predicate) }
         let section = [ItemsSection(model: """", items: Array(items))]
         observable.onNext(section)

         sSelf.itemsToken = items.addNotificationBlock { changes  in
           switch changes {
             case .update(_, _, _, _):
             let section = [ItemsSection(model: """", items: Array(items))]
             observable.onNext(section)
             default: break
          }
        }
        return Disposables.create()
       }
     }
   }
</code></pre>
","4376284","","","","","2017-09-29 06:05:58","Dynamically filter results with RxSwift and Realm","<ios><swift><realm><rx-swift><rxdatasources>","1","0","","","","CC BY-SA 3.0"
"46485193","1","","","2017-09-29 08:51:31","","1","1341","<p>Perhaps I am misunderstanding some basic concept, but it looks like a bug to me. When converting an observable of arrays to observable of individual items, the resulting observable never completes. More specifically, .debug() // #1 line does log completion event, but .debug() // #2 does not. Any ideas on how to make the 'items' observable complete upon completion of the 'array' observable?</p>

<pre class=""lang-swift prettyprint-override""><code>let array: Observable&lt;[Any]&gt; = Observable.just([0])
let items = array.flatMap {
    Observable.from($0)
        .debug() // #1
}
.debug() // #2
</code></pre>
","856588","","856588","","2017-09-29 10:28:29","2017-09-29 13:41:16",".flatMap { Observable.from(array) } never completes in RxSwift","<rx-swift>","1","0","","","","CC BY-SA 3.0"
"46508863","1","","","2017-10-01 03:08:07","","1","194","<p>I'm using <a href=""https://github.com/ReSwift/ReSwift"" rel=""nofollow noreferrer"">ReSwift</a> and <a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow noreferrer"">RxSwift</a> (without that information the question wouldn't make much sense).</p>

<p>Is there a standard way of dispatching an action creator in ReSwift and having something happened after it's finished processing (i.e., finished processing actions and all internal requests that might happen inside the action creator)?</p>

<p>I do know one way to achieve this:</p>

<pre><code>func myActionCreator(_ callback: () -&gt; Void) -&gt; (state: AppState, store: Store&lt;AppState&gt;) -&gt; Action? {
    return { state, store in
        _ = someRequest().subscribe(onNext: { _ in
            callback()
        })

        return nil
    }
}

store.dispatch(myActionCreator({
    // callback
}))
</code></pre>

<p>But there are 2 issues with this:</p>

<ol>
<li>I'd rather use a standard way</li>
<li>I also need this callback as an <code>Observable</code> object.</li>
</ol>

<p>To explain the second reason, I need something like:</p>

<p><code>let observable = store.dispatch(myActionCreator)</code></p>

<p>so I can use the <code>observable</code> variable as I please.</p>

<p>Sure, I could implement all that loging myself and have something like a <code>store.dispatchReturningObservable</code> as an extension of the <code>Store</code>, but I'm looking for a simpler way.</p>

<p>Is there one?</p>
","1116465","","","","","2017-10-01 21:46:54","ReSwift ActionCreator with callback / returning observable after dispatch","<swift><rx-swift><swift4><reswift>","1","0","","","","CC BY-SA 3.0"
"46510054","1","","","2017-10-01 07:09:43","","1","97","<p>I am getting this error:</p>

<blockquote>
  <p>Cannot convert value of type '((ObserveOnSerialDispatchQueueSink,
  Event) -> Disposable)!' to expected argument type '(_) ->
  Disposable'</p>
</blockquote>

<p>Below is my code:</p>

<pre><code>final fileprivate class ObserveOnSerialDispatchQueueSink &lt; O: ObserverType &gt;: ObserverBase &lt; O.E &gt; {
  let scheduler: SerialDispatchQueueScheduler
  let observer: O

  let cancel: Cancelable

  var cachedScheduleLambda: ((ObserveOnSerialDispatchQueueSink &lt; O &gt; , Event &lt; E &gt; ) - &gt; Disposable) !

    init(scheduler: SerialDispatchQueueScheduler, observer: O, cancel: Cancelable) {
      self.scheduler = scheduler
      self.observer = observer
      self.cancel = cancel
      super.init()

      cachedScheduleLambda = {
        sink,
        event in
        sink.observer.on(event)

        if event.isStopEvent {
          sink.dispose()
        }

        return Disposables.create()
      }
    }

  override func onCore(_ event: Event &lt; E &gt; ) {
    let _ = self.scheduler.schedule((self, event), action: cachedScheduleLambda) //error
  }

  override func dispose() {
    super.dispose()

    cancel.dispose()
  }
}
</code></pre>
","8702940","","7291240","","2017-10-01 07:31:06","2017-10-01 07:31:06","Cannot convert value of type error - IOS","<ios><swift><rx-swift>","0","1","","","","CC BY-SA 3.0"
"46521042","1","48171083","","2017-10-02 07:20:53","","10","14823","<p>I want to get object from <code>tableView.rx.itemSelected</code> and after process it. This method return <code>IndexPath</code>, so I can map this value. But how to get object at index from the <code>ViewModel</code>?</p>

<pre><code>struct ViewModel {
    var items: Observable&lt;[Item]&gt;
}
</code></pre>

<p>Approximate I expect something like this (but this flow is wrong):</p>

<pre><code>tableView.rx.itemSelected
        .map { indexPath -&gt; Item in 
        return viewModel.items.map {$0[indexPath.row]}
        }
        ..subscribe(onNext: { [unowned self] item in
        //other actions with Item object
        })
        .disposed(by: disposeBag)
</code></pre>

<p>I showed somewhere this possibility, but cant recollect it. Have you some idea how to do it?</p>
","1278744","","","","","2019-03-27 21:10:00","RxSwift double mapping in tableView.rx.itemSelected","<ios><uitableview><rx-swift><rx-cocoa>","3","4","5","","","CC BY-SA 3.0"
"46545461","1","46547519","","2017-10-03 13:13:19","","5","11364","<p>I have a problem trying to follow this introduction to the MVVM pattern and RxSwift.</p>

<p>About half way down, he binds the data source (cars) to the tableView. This is the part I can't seem to get working in swift 4.</p>

<p>I'm using the following pods:</p>

<pre><code>pod 'RxSwift', '4.0.0-beta.0'
pod 'RxCocoa', '4.0.0-beta.0'
</code></pre>

<p>This is the code I've tried with the error im getting (thought is was easier to see on a picture):
<a href=""https://i.stack.imgur.com/KSmfi.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KSmfi.png"" alt=""enter image description here""></a></p>

<p>I have looked at all other questions mentioning a fix for this:<br>
<a href=""https://stackoverflow.com/questions/46201795/rxswift-rxcocoa-and-uitableview"">RxSwift, RxCocoa and UITableview</a> <br>
<a href=""https://stackoverflow.com/questions/46130494/cannot-set-bindto-uitableview-with-rxswift-variable-asobservable"">Cannot set bind(to: UITableView) with RxSwift Variable asObservable()</a></p>

<p>But can't seem to make it work with the swift 4 version.
Hope you guys can help me out :)</p>
","3065626","","","user3956566","2018-07-12 08:56:44","2018-07-12 08:56:44","RxSwift in swift 4, binding data to a tableview","<ios><uitableview><swift4><xcode9><rx-swift>","1","0","","","","CC BY-SA 4.0"
"46605009","1","","","2017-10-06 11:47:06","","-1","373","<pre><code>extension URLSession {
    fileprivate func loadRepositories(resource: URL) -&gt; Observable&lt;SearchRepositoriesResponse&gt; {
        return self
            .rx.response(request: URLRequest(url: resource))
            .retry(3)
            .map(Repository.parse)
            .retryWhen { $0.delay(1.0, scheduler: MainScheduler.instance) }
    }
}
</code></pre>

<p>Why should I use <code>retryWhen { $0.delay(1.0, scheduler: MainScheduler.instance) }</code> at the last step? What happens if I do not use it?</p>
","5279562","","5235574","","2017-10-06 12:34:30","2017-10-07 10:07:36","RxFeedback Example issues","<swift><rx-swift><rx-cocoa>","1","1","","","","CC BY-SA 3.0"
"46621538","1","46622653","","2017-10-07 14:51:28","","1","104","<p>I have a <code>MapViewModel</code> for my <code>MapViewController</code>.</p>

<p>I have a <code>MapObjectService</code> with a function <code>fetchMapObjects(currentLocation: CLLocation)</code> that returns an <code>Observable&lt;MapObjects&gt;</code></p>

<p>In the MapViewModel I have:</p>

<pre><code>var currentLocation: Observable&lt;CLLocation?&gt;
var mapObjects: Observable&lt;MapObjects&gt;
</code></pre>

<p>I can init the current location like this:</p>

<pre><code>currentLocation = locationManager.rx.didUpdateLocations.map( { locations in
        return locations.filter() { loc in
            return loc.horizontalAccuracy &lt; 20
            }.first
    })
</code></pre>

<p>How can I efficiently init both properties so the <code>fetchMapObjects()</code> uses the currentLocation to set the <code>mapObjects</code> property?</p>

<p>My plan is to bind those properties to the mapView in <code>MapViewController</code> to show the map objects as pins and the current location.</p>

<p>Thanks!  </p>
","1824282","","","","","2017-10-07 16:48:29","Chain observables in ViewModel for fetch but leave as independent properties","<swift><mvvm><mapkit><rx-swift><rx-cocoa>","2","0","","","","CC BY-SA 3.0"
"46649295","1","47029965","","2017-10-09 14:50:59","","1","1352","<p>I have a custom button in a cell, which removes item from observable list.</p>

<pre><code>self.searchListViewModel.genericList.value.remove(at: index)
</code></pre>

<p>All logic works well but I need an animation for deleting cell.Something like this</p>

<pre><code>self.tableView.deleteRows(at: [IndexPath(row: index, section: 0)],
with: .fade)
</code></pre>

<p>but for now if I am trying to use both, app crashes.</p>
","5238927","","790877","","2017-10-09 20:19:07","2017-10-31 07:28:08","RxSwift, remove cell with animation","<swift><rx-swift>","1","2","","","","CC BY-SA 3.0"
"46661971","1","","","2017-10-10 08:27:55","","1","193","<p>I want to build a new project in <em>swift4.0</em>,and I'd prefer using Reactive Cocoa.But,<em>ReactiveCocoa 6.0</em> would not declare official support <em>swift4.0</em>.Is There some other way to solve this problem?Thanks.</p>
","6782527","","1463518","","2017-11-22 09:49:04","2017-11-22 09:53:56","How can I use Reactive Cocoa in swift4.0","<ios><swift4><reactive-cocoa><rx-swift>","1","1","","","","CC BY-SA 3.0"
"46674387","1","","","2017-10-10 19:22:18","","0","611","<p>I'm trying to implement solution from <a href=""http://kean.github.io/post/api-client"" rel=""nofollow noreferrer"">http://kean.github.io/post/api-client</a> which I really like, but I've encountered some problems.
The source code is here: <a href=""https://github.com/gentoo-pl/ApiTest"" rel=""nofollow noreferrer"">https://github.com/gentoo-pl/ApiTest</a></p>

<p>The problem is in <a href=""https://github.com/gentoo-pl/ApiTest/blob/de9d3d6f0474a290fa57b501a0ba97d9ae4c88c8/ApiTest/Model/Client.swift#L52"" rel=""nofollow noreferrer"">Model/Client.swift:52</a> - <em>Type 'JSON' (aka 'Any') has no member ' init '</em></p>

<p>and in the file <a href=""https://github.com/gentoo-pl/ApiTest/blob/de9d3d6f0474a290fa57b501a0ba97d9ae4c88c8/ApiTest/Model/API/ApiDev.swift#L16"" rel=""nofollow noreferrer"">Model/API/ApiDev.swift:16</a> - <em>Generic parameter 'Response' could not be inferred</em></p>

<p>I'm not experienced in SWIFT yet and apologize if these are trivial mistakes but thanks in advance for any tips.</p>
","818121","","","","","2017-10-10 19:22:18","Implementation of API client with SWIFT using Alamofire and rxSwift","<json><swift><api><alamofire><rx-swift>","0","3","","","","CC BY-SA 3.0"
"46690698","1","","","2017-10-11 14:21:15","","1","795","<p>If I want to emulate a standard property of e.g a <code>Bool</code> in RxSwift I can use <code>let isValid = Variable&lt;Bool&gt;(false)</code> and then use <code>.value</code> to get the last value inline and <code>.asObservable()</code> to access the stream. </p>

<p>However I want to emulate a computed propery e.g. <code>var isValid { return self.password.characters.count &gt; 0 }</code> and also be able to get the last value inline as well as in the form of an observable stream.</p>

<p>I want to be able to do both so I can write code like ...</p>

<pre><code>if isValid.value { // isValid is Variable&lt;Bool&gt;
    // ... do something ....
}
</code></pre>

<p>as well as bind to e.g. a TextField</p>

<p>I know I can write as a pure <code>Observable</code>  as follows ...</p>

<pre><code>var isValid: Observable&lt;Bool&gt; {
    return self.username.asObservable().map { username in   // username is Variable&lt;String&gt;
        return username.characters.count &gt; 0
    }
}
</code></pre>

<p>but then I have to refactor the previous example to be ....</p>

<pre><code>isValid.subscribe { isValid in 
    if isValid.element {
        // ... do something ....
    }
}.dispose(of: self.disposeBag)
</code></pre>

<p>How then do I express a computed property in RxSwift which can be consumed as an inline value as well as a stream?</p>
","199","","199","","2017-10-11 14:29:08","2017-10-11 15:18:02","How do I emulate a computed property with access to the latest value in RxSwift?","<swift><observable><rx-swift>","2","0","","","","CC BY-SA 3.0"
"46707198","1","","","2017-10-12 10:22:36","","0","731","<p>Structure with several Variables updated from View and from other class</p>

<pre><code>struct MyViewViewModel  {
    let style: Variable&lt;CustomEnum&gt; = Variable(.value1)
    let displayedValue: Variable&lt;String&gt; = Variable("""")
    let stepIndex = Variable(0)
    let startedDate: Date

    var disposeBag = DisposeBag()
}
</code></pre>

<p><code>style</code> - updated from 3rt part class</p>

<p><code>stepIndex</code> - should update from <code>CocoaAction</code> from View and depends from <code>style</code> changing (reseting)</p>

<p><code>displayedValue</code> - depends from <code>style</code> + <code>stepIndex</code> + <code>startedDate</code></p>

<pre><code>init(style: Observable&lt;CustomEnum&gt;, startedDate: Date) {
    self.startedDate = startedDate

    style
        .bind(to: self.style)
        .disposed(by: disposeBag)

    self.style.asObservable()
        .map { _ in return 0 }
        .bind(to: stepIndex)
        .disposed(by: disposeBag)

    self.style.asObservable()
        .map { return self.string(for: $0) } //error: Closure cannot implicitly capture a mutating self parameter
        .bind(to: displayedValue)
        .disposed(by: disposeBag)
}


mutating func string(for type: CustomEnum) -&gt; String {
    return ""\(self.stepIndex.value) + \(type) + \(self.startedDate.day)""
}
</code></pre>

<p>The main question how to process <code>stepIndex</code> variable firstly and after update <code>startedDate</code> value. </p>

<p>I don't want to use class instead structure I am not sure that it is so needed (to avoid retain-cycles). RxSwift should have a way to do without this.</p>
","1278744","","","","","2017-11-03 17:06:35","RxSwift update several Variable(s) from one Observable","<swift><struct><observable><rx-swift><frp>","1","1","","","","CC BY-SA 3.0"
"46728626","1","46730233","","2017-10-13 11:14:18","","5","430","<p>I have an <code>Observable&lt;Bool&gt;</code> that emits <code>true</code> when an operation begins and <code>false</code> when it ends.  I'd like to show a message while the operation is in progress, but only if it takes longer than two seconds to begin.  Is there a way I can create an observable that I can bind my message to?  Any help much appreciated!</p>
","64239","","","","","2017-10-13 13:33:26","How can I apply a grace time using RX?","<swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"46739589","1","46756596","","2017-10-14 00:23:26","","4","3113","<p>I have the following code:</p>

<pre><code>import RxSwift
import RxCocoa

class ViewModel {

    var text = Variable&lt;String&gt;("""")

    init() {
        text.value = ""hello""
    }

}

class ViewController: UIViewController {
    @IBOutlet weak var textView: UITextView!
    @IBOutlet weak var counterLabel: UILabel!

    var viewModel = ViewModel()

    let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        textView.rx.text
            .orEmpty
            .debug()
            .bind(to: viewModel.text)
            .disposed(by: disposeBag)
    }
}
</code></pre>

<p>The binding works fine (when I change the <code>UITextView</code> it properly updates the <code>viewModel</code>. However, since the binding is unidirectional (or so I understand), the <code>textView</code> doesn't start with the value I set in the <code>ViewModel</code>'s <code>init</code> method.</p>

<p>I can do <code>textView.text = viewModel.text.value</code> just before the binding, but since I'm using RxSwift, I want to understand what's the usual practice here.</p>
","7277","","","","","2017-10-15 15:16:59","RxSwift initial value when binding a Variable","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"46775518","1","46810795","","2017-10-16 17:05:41","","2","386","<p>I'm trying to keep the original order to the stream after applying flatMap in the middle.</p>

<p>Here is the diagram to elaborate what I mean:</p>

<p>----2-4-1------------------ (Original stream)</p>

<p>-----------1--2---------4-- (Network activity - represented by flatMap with delay)</p>

<p>---------------2---------4-1 (The wanted outcome)</p>

<p>Here is a code to elaborate the situation:</p>

<pre><code>    persistMessageEventBus.flatMap({ num -&gt; Observable&lt;Int&gt; in

        print(""aaab Doing \(num)"")

        let t2g = Observable.just(num).delay(Double(num), scheduler: MainScheduler.instance).do(onNext:{ num in print(""aaab Done async \(num)"")})

        return t2g

    }).concatMap({ num -&gt; Observable&lt;Int&gt; in

        print(""aaab Done map \(num)"")

        return Observable.just(num)

    }).subscribe(onNext: { num in

        print(""aaab done \(num)"")

    }).addDisposableTo(disposeBag)

    persistMessageEventBus.onNext(2)
    persistMessageEventBus.onNext(4)
    persistMessageEventBus.onNext(1)
</code></pre>

<p>The output is:</p>

<pre><code>aaab Doing 2
aaab Doing 4
aaab Doing 1
aaab Done async 1
aaab Done map 1
aaab done 1
aaab Done async 2
aaab Done map 2
aaab done 2
aaab Done async 4
aaab Done map 4
aaab done 4
</code></pre>

<p>The wanted output is:</p>

<pre><code>aaab Doing 2
aaab Doing 4
aaab Doing 1
aaab Done async 1
aaab Done async 2
aaab Done map 2
aaab done 2
aaab Done async 4
aaab Done map 4
aaab done 4
aaab Done map 1
aaab done 1
</code></pre>

<p>Is there something like that in RxSwift?</p>
","628659","","491239","","2017-10-17 08:42:12","2017-10-19 16:07:12","Rx swift keeping the original order of the original stream after using flatMap","<reactive-programming><rx-swift>","1","0","0","","","CC BY-SA 3.0"
"46811630","1","46892667","","2017-10-18 13:41:56","","3","2257","<p>I'm using <code>RxSwift</code> to bind a model array to a collection view</p>

<p>How do I get the model object from a given indexPath?</p>

<p>I'm doing the binding like this:</p>

<pre><code>vm.bikeIssueCatagories()
        .drive(self.collectionView.rx.items(cellIdentifier: ""BikeIssueCategoryCollectionViewCell"", cellType: UICollectionViewCell.self)) { row, data, cell in
        }.disposed(by: disposeBag)
</code></pre>

<p>The core of my issue is, that I need to get both the model object and the cell that a user selects. Using <code>collectionView.rx.modelSelected(T.self)</code> only gives me the model og type <code>T</code>. And calling <code>collectionView.rx.itemSelected</code> only gives me the selected <code>IndexPath</code></p>

<pre><code>collectionView.rx.itemSelected.asDriver()
        .driveNext { [unowned self] indexPath in
            guard let model = try? collectionView.rx.model(at: indexPath) else { return }
            guard let cell = self.collectionView.cellForItem(at: indexPath) else { return }
        }.disposed(by: disposeBag)
</code></pre>

<p>But this gives me an error when trying to the the model at indexPath:</p>

<blockquote>
  <p>Type 'inout UICollectionView' does not conform to protocol
  'ReactiveCompatible'</p>
</blockquote>

<p>Just trying:</p>

<pre><code>let indexPath = IndexPath.init()
self.collectionView.rx.model(at: indexPath)
</code></pre>

<p>also gives me an error:</p>

<blockquote>
  <p>Ambiguous reference to member 'model(at:)'</p>
</blockquote>

<p><strong>SO... How to get both the model object and the cell that a user selects?</strong></p>
","2299801","","","","","2020-03-30 08:16:45","Get model from UICollectionView indexpath","<ios><swift><rx-swift><rx-cocoa>","3","0","","","","CC BY-SA 3.0"
"46822719","1","46824324","","2017-10-19 04:10:37","","3","255","<p>I try to create a library called <code>MyLib</code> using RxSwift as dependency, which using cocoapod command <code>pod lib create</code>. However, the following code doesn't work.</p>

<pre><code>import UIKit
import MyLib

class ViewController: UIViewController {

  override func viewDidLoad() {
    super.viewDidLoad()
    // compile error: Use of unresolved identifier 'Observable'
    Observable.just("""")
  }

}
</code></pre>

<p>It only works after I add <code>import RxSwift</code></p>

<p>I would like to just import <code>MyLib</code> only, have any ideas?</p>

<p>Thanks!</p>
","3663635","","3663635","","2018-09-07 06:40:28","2018-09-07 06:40:28","Creating own library that depends on RxSwift still need to import RxSwift?","<swift><cocoapods><rx-swift>","1","6","1","","","CC BY-SA 4.0"
"46844148","1","","","2017-10-20 07:19:31","","4","1933","<p>I recently found an article that says using <code>[unowned self]</code> is always safe as long as you are adding the subscription to a <code>DisposeBag</code> and it is inside the view controller. </p>

<p>Assuming I have a ViewController where <code>deinit</code> is not being called due to a strong reference:</p>

<pre><code>class ViewController: UIViewController {

    @IBOutlet weak var searchBar: UISearchBar!
    @IBOutlet weak var tableView: UITableView!

    private let disposeBag = DisposeBag()
    private var results = Variable&lt;[Item]&gt;([])
    private var searchText = Variable("""")
    var selectedCompletion: ((Item) -&gt; Void)!

    override func viewDidLoad() {
        super.viewDidLoad()
        results.asObservable()
            .bind(to: tableView.rx.items(cellIdentifier: ""CustomCell"", cellType: CustomCell.self)) { row, item, cell in
                cell.configure(with: item)
            }
            .disposed(by: disposeBag)

        tableView.rx.itemSelected
            .subscribe(onNext: { ip in
                self.selectedCompletion(self.results.value[ip.row])
                self.navigationController?.popViewController(animated: true)
            })
            .disposed(by:disposeBag)

        searchBar.rx.text
            .debounce(0.6, scheduler: MainScheduler.instance)
            .subscribe(onNext: { searchText in
                if searchText == nil || searchText!.isEmpty { return }
                self.search(query: searchText!)
            })
            .disposed(by: disposeBag)
    }

    private func search(query: String) {
        // Search asynchronously
        search(for: query) { response in

            // Some logic here...
            self.results.value = searchResult.results
        }
    }
}
</code></pre>

<p>I should simply be able to declare <code>[unowned self]</code> in my subscription closures and not have to worry about my app crashing from <code>self</code> being <code>nil</code>. </p>

<p>Where I'm confused is, because search is asynchronous, doesn't that mean <code>self</code> <strong>can</strong> be <code>nil</code> if the ViewController has been popped off the navigation stack before the query completes?</p>

<p>Or would the <code>disposeBag</code> be deallocated first and the closure wouldn't complete?</p>

<p>Any clarification about how to know whether or not a class owns a closure would be great too.</p>
","7964813","","1113632","","2017-10-20 08:58:28","2018-04-26 09:12:43","RxSwift: Is it safe to always use [unowned self] when a class has a disposeBag property?","<ios><swift><rx-swift>","2","1","0","","","CC BY-SA 3.0"
"46855789","1","","","2017-10-20 19:08:39","","1","5499","<p>I've created an 'observable' boolean variable that is to be bound (via .bind) to a UISwitch.  <br/>(The traditional imperative model would be easier; but I'm trying to learn to nuances of rxCocoa)
<p>
I'm not sure what to do here; I'm basing my logic on some sample code working with Strings. <br/>
I used 'just' because I'm only interested in the one variable's toggled value.<p>
As you can see, the closure parameter is too vague.  <br/>
What am I missing?</p>

<p><a href=""https://i.stack.imgur.com/EVnS3.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/EVnS3.png"" alt=""enter image description here""></a></p>
","715747","","","","","2018-03-22 14:28:07","How do I acquire the value of an observable boolean?","<rx-swift>","2","0","","","","CC BY-SA 3.0"
"46858186","1","","","2017-10-20 22:30:53","","0","1078","<p>In my app, I have a collection of pickers. Each picker takes its values from a service.</p>

<p>The app layout looks something like this:</p>

<pre><code>--------------------
-    picker 1      -
--------------------
-    add picker    -
--------------------
</code></pre>

<p>You can tap <code>add picker</code> to add more pickers, which are placed in a <code>UIStackView</code>. Each picker is backed by its <code>UIViewController</code> and has its own viewModel, while the container view controller has a viewModel as well.</p>

<p>After you tap <code>add picker</code> some times, you get something like this:</p>

<pre><code>--------------------
-    picker 1      -
--------------------
-    picker 2      -
--------------------
-    picker 3      -
--------------------
</code></pre>

<p>When you tap each picker, I display a set of options to the user. The set of options comes from a web service, which is wrapped by the View Model in an <code>Observable&lt;OperationType&gt;</code>.</p>

<p>Say the service returned <code>option 1</code>, <code>option 2</code>, <code>option 3</code>, and the user picks <code>option 1</code> for the first picker, I need that when the second picker opens to only offer the user <code>option 2</code> and <code>option 3</code>.</p>

<p>In my main view model I have this code:</p>

<pre><code>    var children = Variable&lt;[ChildViewModel]&gt;([])

    var allAvailableOperationTypes: Observable&lt;[OperationType]&gt; {
        return RequestManager.sharedInstance.rx
            .catalogues()
            .asObservable()
            .map { return $0.operationTypes }
        }
    }
</code></pre>

<p>I then created a new <code>Observable</code> to handle combining the last value from <code>allAvailableOperationTypes</code> and ""remove"" the ones already selected.</p>

<p>Something like:</p>

<pre><code>var availableOperationTypes: Observable&lt;[OperationType]&gt; {
    return allAvailablePriceOperationTypes
        .map { (operationTypes) in
            operationTypes.filter { // keep those not used in children }
          }
    }
}
</code></pre>

<p>On the View Controller, I'm binding it to the button like:</p>

<pre><code>    operationTypeButton.rx.tap
        .asObservable()
        .withLatestFrom(viewModel.availableOperationTypes)
        .subscribe(onNext: { [unowned self] (operationTypes) in
            self.presentPicker(forOperationTypes: operationTypes)
        })
        .addDisposableTo(disposeBag)
</code></pre>

<p>If the user selects a value on the first picker, and then adds a second one, the second picker will only include the ""free"" options. However, the first picker will still show all the options available.</p>

<p>What I'd like to achieve, is for this to be hot, such that when the user taps the picker button, it only shows options he can pick.</p>
","7277","","","","","2017-10-22 22:25:36","RxSwift - Observable removing used elements","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"46860265","1","46879678","","2017-10-21 05:11:45","","1","155","<p>I create a local var in a <code>awakeFromNib</code> function, use it inside a <code>UIView</code> animation block, but it is never released, why?</p>

<p>Here is the code (inside awakeFromNib in a UITableViewCell)</p>

<pre><code>var fullPhotoDisposeBag = DisposeBag()
fullScreenImageView.rx.tapGesture().when(UIGestureRecognizerState.recognized).subscribe(onNext: { (tap) in

      UIView.animate(withDuration: 0.15, delay: 0, options: UIViewAnimationOptions.curveEaseOut, animations: {
            fullScreenImageView.frame = oldFullScreenFrame
      }, completion: { (finished) in
           fullScreenImageView.removeFromSuperview()
           let _ = fullPhotoDisposeBag //This line avoid early release, but retains too much...
      })
}, onDisposed:{
       print(""disposed"")
}).addDisposableTo(fullPhotoDisposeBag)
</code></pre>

<p>One clue is that the tableView is at the root of one tab of my app, so the UITableView is never deallocated thus the UITableViewCell is never deallocated due to the reusability.
But why would ARC keeps that variable? Used only in a function and a completion block?</p>

<p>PS: I currently use an optional DisposeBag that I set to nil in the completion block, but I don't understand why I need to do that...</p>
","2144128","","819340","","2017-10-22 22:33:03","2017-10-22 22:33:03","Swift, why this local var is not released?","<swift><automatic-ref-counting><rx-swift>","1","0","0","","","CC BY-SA 3.0"
"46860470","1","","","2017-10-21 05:52:10","","0","992","<p>I want to create an extension of <code>ObservableType</code>, but the following code doesn't compile.</p>

<pre><code>public extension ObservableType {
  public func foo&lt;C: Collection&gt;(_ calls: @escaping (E) -&gt; C) -&gt; Observable&lt;[Any]&gt; where C.Iterator.Element: ObservableType {
    return flatMap { input in Observable.zip(calls(input)) { objects in objects }
    }
  }
}

// compile error
Observable.just(""foo"")
  .foo { foo in
    [Observable.just(User()), Observable.just(Repo())]
  }
</code></pre>

<p>It throws an error: <code>Cannot convert value of type '(_) -&gt; [Any]' to expected argument type '(String) -&gt; _'</code></p>

<p>I have no idea where the problem is. Thanks in advance</p>
","3663635","","13302","","2017-10-23 20:35:03","2017-10-23 20:35:03","RxSwift generic `Cannot convert value of type '(_) -> [Any]' to expected argument type '(String) -> _'`","<swift><generics><rx-swift>","1","0","","","","CC BY-SA 3.0"
"46879651","1","","","2017-10-22 22:10:47","","0","716","<p>I have an iOS app that I am rewriting to use <code>RxSwift</code> and <code>RxCocoa</code>. It works really well, but I have problems with collection view data bindings.</p>

<p>In my app, I perform data bindings when <code>viewWillAppear</code> is called on a view controller, for instance:</p>

<pre><code>let view = collectionView
getStuff().bind(to: view.rx.items(cellIdentifier: ""Cell"", cellType: Cell.self)) {
    row, item, cell in
    cell.setup(with: item)
}.disposed(by: disposeBag)
</code></pre>

<p>```</p>

<p>This works great - my data is correctly bound to my collection views.</p>

<p>However, to avoid having active bindings for view controllers that are not currently visible, I dealloc <code>disposeBag</code> whenever <code>viewWillDisappear</code> is called. I then recreate the dispose bag and rebind data whenever the vc is displayed again.</p>

<p>My problem is, that when I rebind data to the collection view, the content offset is reset. Consider a scenario where I list content and navigate to a new view controller when an item is tapped. Whenever I go back to the list, the new data bind will cause the scroll view to scroll to top.</p>

<p>The default behavior for a collection view is to keep its offset even if the data source changes and <code>reloadData</code> is called. Am I missing something here or am I doing something wrong? </p>
","804034","","","","","2017-10-22 22:37:18","RxCocoa data binding causes collection view to scroll to top","<ios><swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"46884511","1","","","2017-10-23 08:03:13","","0","334","<p>I want to change title with an observable int.</p>

<p>in view Model</p>

<pre><code>var index = Variable&lt;Int&gt;(0)
</code></pre>

<p>in view Controller</p>

<pre><code>let title = [""title1"",""title2"",""title3"",""title4"",""title5""]
override func viewWillAppear(_ animated: Bool) {
self.viewModel.index.value = 0
    self.viewModel.index
        .asObservable()
        .map( {self.periodText[$0]
        })
        .bind(to: self.titleLabel.rx.text)

        .addDisposableTo(self.disposeBag)
}
</code></pre>

<p>When i do this i have an error in the blind(to) :</p>

<blockquote>
  <p>fatal error: unexpectedly found nil while unwrapping an Optional value</p>
</blockquote>

<p>The function never pass in the .map </p>

<p>How i can change the title when my index change in RX Swift?</p>
","3333632","","3333632","","2017-10-23 10:10:33","2017-11-29 11:18:26","how i can change title with RX index","<swift3><rx-swift><rx-cocoa>","2","0","","","","CC BY-SA 3.0"
"46885585","1","","","2017-10-23 09:07:24","","0","152","<p>I am building a project from Scratch using MVVM &amp; RxSwift. While building the App I came into a point where I am building a ViewModel properties for login screen where it was built like this:</p>

<pre><code>struct LoginViewModel {

let username = Variable&lt;String&gt;("""")

init(username: String) {
    self.username.value = username
} }
</code></pre>

<p>In code reviewing another developer suggested that it would be written like this:</p>

<pre><code>private let username = Variable("""")
lazy var usernameObservable: Observable = self.username.asObservable()
</code></pre>

<p>As you can see, He created a private property which stores the data and public observable for omitting events. I have a concern in this approach which is that in that case we will duplicate all the properties in the ViewModel to achieve that. Which means that If I have 3 properties then Ill create another 3 corresponding properties. There should be a cleaner way to achieve this. Your recommendations would be very appreciated</p>
","4019584","","","","","2017-10-23 09:07:24","Encapsulation for Rx Variables","<ios><swift><rx-swift>","0","3","","","","CC BY-SA 3.0"
"46885948","1","46890064","","2017-10-23 09:26:54","","4","2753","<p>I'm a newbie in rxSwift. I found some difference when create Observable by 
<code>Observable.of</code> and <code>Observable&lt;String&gt;.create</code></p>

<pre><code>    Observable&lt;String&gt;.create { observer in

    observer.onNext(""1"")

    observer.onNext(""2"")

    return Disposables.create()
    }.take(3).toArray().subscribe(onNext: { (item) in
        print(item)
    }).disposed(by: disposeBag)
</code></pre>

<p>Not emitted util received at least 3 event. In this way observer never emitted.
But with:</p>

<pre><code>    Observable.of(""1"", ""2"")
    // 2
    .take(3).toArray()
    .subscribe(onNext: {
        print($0) })
    .disposed(by: disposeBag)
</code></pre>

<p>But when i create by this way.
Observer always emitted even if i just have 2 elements.
I don't known what difference. </p>
","2353285","","1033581","","2018-04-09 03:27:57","2018-04-09 03:27:57","Rxswift What difference between Observable.of and Observable<String>.create","<rx-swift>","1","0","1","","","CC BY-SA 3.0"
"46891500","1","","","2017-10-23 14:11:48","","0","203","<p>I want to convert a ViewModel that I already have to be full Rx.
The application evaluates arithmetic expressions.</p>

<p>The ViewModel has two strings, one with 'logical' symbols, that will be send to the expression evaluator to get a result, and a 'presentation' string with other symbols that will be showed in the UI.</p>

<p>The ViewController calls a VM function, 'keyPressed(keyID: Int)' that will be used to modify both the 'logical' string, and the 'presentation' string, the 'keyPressed' uses the right symbol for the right string and modify it by appending the new symbol.</p>

<p>How can I convert the VM to be reactive without having any state (any string) or at least not having the presentation string?</p>
","973549","","","","","2017-11-22 10:57:31","RxSwift keep state of string without a Subject or a Variable","<swift><mvvm><reactive-programming><rx-swift>","2","1","","","","CC BY-SA 3.0"
"46902669","1","","","2017-10-24 05:12:45","","0","220","<p>I've got a problem with RxSwift Scheduler:</p>

<p>Whats the difference between this two codes:</p>

<pre><code>let results = query.flatMapLatest { query in
    return search(query)
}
.observeOn(MainScheduler.instance)
</code></pre>

<p>and</p>

<pre><code>let results = query.flatMapLatest { query in
    return search(query)
        .observeOn(MainScheduler.instance)
}
</code></pre>
","5279562","","4000926","","2017-10-24 19:25:01","2017-10-27 12:16:37","Difference between two approaches to query","<swift><rx-swift><reactive><rx-cocoa>","1","3","","","","CC BY-SA 3.0"
"46908598","1","","","2017-10-24 10:51:29","","0","2747","<p>First of all sorry for the confusing title, but I actually can't come up with something better (if you do, please edit).</p>

<p>I have an application using Coordinator pattern and RxSwift, so all in all I wan to pass all <em>navigation</em> related stuff to Coordinator, so it can handle navigation logic.<br>
In one view controller I have <code>UITableView</code> with cells which has <code>UIButton</code> inside of them. For that case I have a:</p>

<pre><code>actionButton.rx.tap.bind(to: viewModel.chapterAction).disposed(by: disposeBag)
</code></pre>

<p><code>chapterAction</code> is a <code>PublishSubject&lt;Void&gt;</code> as it only reflects a button tap, but I need to pass more info to Coordinator, so later I transform this <code>chapterAction</code> to:</p>

<pre><code>var showChapter: Observable&lt;Chapter&gt; = self.chapterAction.mapTo(self.chapter)
</code></pre>

<p>And I <em>assume</em> that up to this point there's nothing wrong with this code, so in View Controller's <code>.bind(to: tableView.rx.items...</code> I have:</p>

<pre><code>viewModel.showChapter.bind(to: self.viewModel.chapterAction).disposed(by: viewModel.disposeBag)
</code></pre>

<p>Since I want to bind this to view controller's <code>viewModel</code> and later <code>subscribe</code> in coordinator.<br>
It all works ok, but for some cells I get <strong>duplicated</strong> taps, why? I've tried putting <code>distinctUntil</code>, <code>shareReply</code>, but nothing seems to help my problem and it's not a deterministic one. I <em>suspect</em> some reusing to be involved, but I have no clue where to start looking for this issue...</p>
","1911042","","12725952","","2020-03-06 20:17:37","2020-03-06 20:17:37","How to prevent duplicate UIButton taps in UITableViewCell with RxSwift disposeBag","<ios><swift><uitableview><rx-swift><rx-cocoa>","2","0","2","","","CC BY-SA 4.0"
"46912177","1","","","2017-10-24 13:44:41","","0","108","<p>I have a <code>LocationService</code> with the following <code>Observable</code>:</p>

<pre><code>let current: Observable&lt;Location?&gt;
init() {
    …
    current = Observable.combineLatest(selected.asObservable(), user) { $0 ?? $1.flatMap { Location(coordinate: $0, name: ""Nearby"") } }.distinctUntilChanged(==).debug()
    …
}
</code></pre>

<p>In a view model I transform the observable like so:</p>

<pre><code>let distance: Driver&lt;String?&gt;
required init(model: Media, dependencies: Dependencies) {
    …
    distance = dependencies.location.current.filterNil().map { media.place.coordinate.distance(to: $0.coordinate) }.asDriver(onErrorJustReturn: nil)
    …
}
</code></pre>

<p>In a view I user this to drive the UI:</p>

<pre><code>viewModel.distance.map { $0 == nil }.drive(distanceView.rx.isHidden).disposed(by: disposeBag)
</code></pre>

<p>By adding <code>.debug()</code> to the end of the <code>current</code> observable I can see that it is definitely emitting an event, but the views don't receive it because they are subscribing after it is emitted. Why don't they automatically receive the last emitted event?</p>

<blockquote>
  <p>2017-10-24 14:33:42.650: LocationService.swift:39 (init()) ->
  subscribed 2017-10-24 14:33:42.975: LocationService.swift:39 (init())
  -> Event next(Optional(Service.Location(coordinate: Service.Coordinate(latitude: 51.509979999999999, longitude:
  -0.13370000000000001), name: ""Nearby"", radius: nil))) 2017-10-24 14:33:50.038: LocationService.swift:39 (init()) -> subscribed</p>
</blockquote>
","1486106","","","","","2017-10-24 13:44:41","Observable Events Not Received","<swift><rx-swift>","0","6","","","","CC BY-SA 3.0"
"46932454","1","","","2017-10-25 12:27:58","","7","3063","<p>As far as I understand <strong>Alamofire</strong> is pulled in with built in <strong>Reachability</strong>, so my own handler would look something like:</p>

<pre><code>import Alamofire

let reachabilityManager = NetworkReachabilityManager()
reachabilityManager.listener = { status in

switch status {

case .notReachable:
 print(""The network is not reachable"")
 self.onInternetDisconnection()

case .unknown :
 print(""It is unknown whether the network is reachable"")
 self.onInternetDisconnection() // not sure what to do for this case

case .reachable(.ethernetOrWiFi):
 print(""The network is reachable over the WiFi connection"")
 self.onInternetConnection()

case .reachable(.wwan):
 print(""The network is reachable over the WWAN connection"")
 self.onInternetConnection()

 }
}
</code></pre>

<p>I'm making a request with:</p>

<pre><code>let provider = MoyaProvider&lt;MyMoyaRequest&gt;()
let token = provider.request(.start(
    username:self.email.value, 
    password: self.password.value) { result in

    switch result { 
    case let .success(moyaResponse):
        //handle success
    case let .failure(error):
        //handle failure
    }
}
</code></pre>

<p>So if I want to have connectivity checked before every <strong>Moya</strong> Request is made what is the best way to go about it?</p>

<ol>
<li>Write an extension for one of Moyas internals to check first </li>
<li>Use the Moya plugin (prepare) to check </li>
<li>Some fancy pants other way so far unthought of...</li>
</ol>

<p>I specifically do <strong>not</strong> want to add a reachability check to every single API call, for readability reasons. But I am interested in hearing about methods previously used.</p>

<p>Thank-you for any assistance you can offer.</p>
","797598","","","","","2019-10-03 17:51:12","How do I check for internet using Moya and RxSwift?","<swift4><rx-swift><connectivity><internet-connection><moya>","1","0","4","","","CC BY-SA 3.0"
"46939975","1","","","2017-10-25 18:48:34","","0","548","<p>I was using <strong>XCode 8.3</strong> with <strong>swift 3.1</strong> and I updated to <strong>Xcode 9</strong> with <strong>swift 4</strong>, now in some classes when I use <strong><em>RXSwift</em></strong>, I have this error compiler logs:</p>

<pre><code>class petViewModel {
    var lastPetID: Int = 0
    var refreshing = Variable&lt;Bool&gt;(false)
    var vaccines: Results&lt;vaccines&gt;? = nil
    let error = Variable&lt;(Int,String)&gt;(0,"""") // Extra argument in call
    let changes = Variable&lt;([Int], [Int], [Int])&gt;([Int](), [Int](), [Int]())  // Extra argument in call
    var firstLoad = Variable&lt;Bool&gt;(false)

    // and more code bla bla bla

}
</code></pre>

<p>using <strong><em>RXSwift</em></strong> what is the best way to implement it? before was compiling me without any problem, any help, please?</p>
","2135917","","7576100","","2017-10-26 12:43:08","2017-10-26 14:21:20","Xcode 9 with Swift 4 Extra argument in call","<ios11><xcode9><swift4><rx-swift>","2","0","","","","CC BY-SA 3.0"
"46949595","1","","","2017-10-26 08:43:01","","0","558","<p>I have a swift project that I am working on . </p>

<p>The backend for it is still not ready so I thought of hosting the server in the app such that I can make a request and have the responses stored with in the app.</p>

<p>Whenever user makes a request the mocked response is displayed.</p>

<p>Is there any tutorial that I can find on how to do this .</p>

<p>I am using the mvvm architecture and Moya for making network calls.</p>

<p>I am familiar with making network calls and parsing it to display responses.</p>

<p>It will be great if anyone could point out to a tutorial on hooking it up with a mocked server within the app.</p>

<p>Any help will be appreciated. Thank you.</p>
","5443885","","","","","2020-07-30 03:03:22","Mocking a server for swift app","<swift><mvvm><mocking><rx-swift><moya>","2","2","1","","","CC BY-SA 3.0"
"46984601","1","46988281","","2017-10-27 23:09:55","","1","752","<p>I'm really really new to Rx and RxSwift and I'm trying to learn by reading and doing at the same time, so maybe this question makes you laugh. Please, excuse me in advance :P</p>

<p>I have this architecture:</p>

<pre><code>MatchView -&gt; MatchViewModel -&gt; P2PSession -&gt; MCSession+Rx
</code></pre>

<p>I've made a Reactive extension of <code>MCSession</code> to make session state changes an observable:</p>

<pre><code>var didChangeState: Observable&lt;(MCPeerID, MCSessionState)&gt; {
    return RxMCSessionDelegateProxy.proxy(for: base).didChangeStateSubject.asObservable()
}
</code></pre>

<p>Then, I have another object, <code>P2PSession</code>, subscribed to that observable in order to transform the received event to emit it to a <code>BehaviorSubject&lt;MCPeerID?&gt;</code> to be observed by my <code>MatchViewModel</code>, that will transform it to emit to a <code>Variable&lt;String&gt;</code> to be shown in a label.</p>

<p>Maybe that chaining is totally ridiculous but here is the complete (but simplified) thing:</p>

<p><strong>P2PSession</strong></p>

<pre><code>var connectedPeer: BehaviorSubject&lt;MCPeerID?&gt; = BehaviorSubject(value: nil)

mcSession.rx.didChangeState
    .subscribe(onNext: { self.connectedPeer.onNext($0.0) })
    .disposed(by: disposeBag)
</code></pre>

<p><strong>MatchViewModel</strong></p>

<pre><code>var peerName = Variable("""")

p2pSession.connectedPeer.asObservable()
    .map({ $0?.displayName ?? ""None"" })
    .subscribe(onNext: { self.peerName.value = $0 })
    .disposed(by: disposeBag)
</code></pre>

<p><strong>MatchView</strong></p>

<pre><code>viewModel.peerName.asDriver()
    .drive(peerLabel.rx.text)
    .disposed(by: disposeBag)
</code></pre>

<p>It works, as a peer connects, a delegate method is called in the <code>RxMCSessionDelegateProxy</code> and data travels through the chain until it is shown in the label.</p>

<p>But I think that could be made way more elegant. Is it possible to forward a transformed event from an observable to a subject without making the subscription to the first observable to transform and inject the value to the subject/variable? (as I make in <code>P2PSession</code>). I don't know if I've explained myself correctly but I think that's possible with <code>flatMap</code> but I'm not getting it correctly, maybe I need the <code>subscribe</code> anyway and I'm trying to do stupid things.</p>

<p>Thank you so much, I need your help!</p>
","191059","","191059","","2017-10-28 09:29:43","2017-10-30 09:05:13","Forward transformed event from Observable directly to BehaviourSubject","<ios><swift><rx-swift><reactivex>","1","3","","","","CC BY-SA 3.0"
"46988049","1","","","2017-10-28 09:09:43","","4","3965","<p>obviously I am new to RxSwift and though I consumed a lot of documentations and speeches, I think I am missing some fundamental concepts. </p>

<p>In my app I have a RESTful web service to load various resources but the base url of the web service is unknown at build/start time. Instead I have a ""URL resolver"" web service which I can call with my apps bundle, version and possible environment (""production"", ""debug"" or any custom string entered in the apps debug settings) to obtain the base url I then use for the actual service. </p>

<p>My thinking was that I would create 2 services, one for the URL resolver and one for the actual web service which gives me my resources. The URL resolver would have a Variable and a Observable. I use the variable to signal the need to refresh the base url via a web service call to the URL resolver. I do this by observing the variable and filter only for true values. A function in the service class set the variables value to true (initially it is false) and inside an observer of the filtered variable, I make the web service call in another Observable (this example uses a dummy JSON web service):</p>

<pre><code>import Foundation
import RxSwift
import Alamofire

struct BaseURL: Codable {
    let title: String
}

struct URLService {
    private static var counter = 0
    private static let urlVariable: Variable&lt;Bool&gt; = Variable(false)
    static let urlObservable: Observable&lt;BaseURL&gt; = urlVariable.asObservable()
        .filter { counter += 1; return $0 }
        .flatMap { _ in
            return Observable.create { observer in
                let url = counter &lt; 5 ? ""https://jsonplaceholder.typicode.com/posts"" : """"
                let requestReference = Alamofire.request(url).responseJSON { response in
                    do {
                        let items = try JSONDecoder().decode([BaseURL].self, from: response.data!)
                        observer.onNext(items[0])
                    } catch {
                        observer.onError(error)
                    }
                }

                return Disposables.create() {
                    requestReference.cancel()
                }
            }
    }

    static func getBaseUrl() {
        urlVariable.value = true;
    }

    static func reset() {
        counter = 0;
    }
}
</code></pre>

<p>Now the problem is that sometimes it can happen that a web service call fails and I would need to show the error to the user so a retry can be made. I thought that the onError was useful for this but it seems to kills all the subscribers forever. </p>

<p>I could put the subscribing in its own function and inside the error handler of the Observer, I could show a alert and then call the subscribe function again like so: </p>

<pre><code>func subscribe() {
        URLService.urlObservable.subscribe(onNext: { (baseURL) in
            let alert = UIAlertController(title: ""Success in Web Service"", message: ""Base URL is \(baseURL.title)"", preferredStyle: .alert)
            let actionYes = UIAlertAction(title: ""Try again!"", style: .default, handler: { action in
                URLService.getBaseUrl()
            })
            alert.addAction(actionYes)
            DispatchQueue.main.async {
                let alertWindow = UIWindow(frame: UIScreen.main.bounds)
                alertWindow.rootViewController = UIViewController()
                alertWindow.windowLevel = UIWindowLevelAlert + 1;
                alertWindow.makeKeyAndVisible()
                alertWindow.rootViewController?.present(alert, animated: true, completion: nil)
            }
        }, onError: { error in
            let alert = UIAlertController(title: ""Error in Web Service"", message: ""Something went wrong: \(error.localizedDescription)"", preferredStyle: .alert)
            let actionYes = UIAlertAction(title: ""Yes"", style: .default, handler: { action in
                URLService.reset()
                self.subscribe()
            })
            alert.addAction(actionYes)
            DispatchQueue.main.async {
                VesselService.reset()
                let alertWindow = UIWindow(frame: UIScreen.main.bounds)
                alertWindow.rootViewController = UIViewController()
                alertWindow.windowLevel = UIWindowLevelAlert + 1;
                alertWindow.makeKeyAndVisible()
                alertWindow.rootViewController?.present(alert, animated: true, completion: nil)
            }
        }).disposed(by: disposeBag)
    }
</code></pre>

<p>Then in my AppDelegate I would call </p>

<pre><code>subscribe()
URLService.getBaseUrl()
</code></pre>

<p>The problem is that all other observers get killed on an error as well but since the the only other observer on the URLService.urlObservable is my other web service class, I guess I could implement the same style subscribe function in there as well. </p>

<p>I read that some people suggest to return a Result enum which has 2 cases: the actual result (.success(result: T)) or an error (.error(error: Error)).</p>

<p>So what is the better way of handling errors web service errors in Rx? I cant wrap my head around this problem and I'm trying for 2 days to understand it. Any ideas or suggestions? </p>

<p><strong>Update</strong></p>

<p>It just came to my mind that I could ignore errors from the web service calls completely and instead post any error to a global ""error"" variable which my app delegate could observe to show alerts. The ""error"" could reference the function which initially caused it so a retry could be made. I'm still confused and not sure what I should do. :/ </p>

<p><strong>Update 2</strong></p>

<p>I think I might found a working solution. As I am still a beginner to Rx and RxSwift, I'm happy to take improvement suggestions. As I was writing the actual code, I splitted my call chain in two parts:</p>

<ul>
<li>The part where I make the web service calls</li>
<li>The part where I click a button and process the result of the web service, whether it is an error or a success</li>
</ul>

<p>In the part where I click the button and process the result, I use catchError and retry as suggested in the comments. The code looks like this:</p>

<pre><code>let userObservable = URLService
    .getBaseUrl(environment: UserDefaults.standard.environment) //Get base url from web service 1
    .flatMap({ [unowned self] baseURL -&gt; Observable&lt;User&gt; in
        UserService.getUser(baseURL: baseURL,
                            email: self.usernameTextField.text!,
                            password: self.passwordTextField.text!) //Get user from web service 2 using the base url from webservice 1
    })


signInButton
    .rx
    .tap
    .throttle(0.5, scheduler: MainScheduler.instance)
    .flatMap({ [unowned self] () -&gt; Observable&lt;()&gt; in
        Observable.create { observable in
            let hud = MBProgressHUD.present(withTitle: ""Signing in..."");
            self.hud = hud
            observable.onNext(())
            return Disposables.create {
                hud?.dismiss()
            }
        }
    })
    .flatMap({ () -&gt; Observable&lt;User&gt; in
        return userObservable
    })
    .catchError({ [unowned self] error -&gt; Observable&lt;User&gt; in
        self.hud?.dismiss()
        self.handleError(error)
        return userObservable
    })
    .retry()
    .subscribe(onNext: { [unowned self] (user) in
        UserDefaults.standard.accessToken = user.accessToken
        UserDefaults.standard.tokenType = user.tokenType
        self.hud?.dismiss()
    })
    .disposed(by: disposeBag)
</code></pre>

<p>The trick was to move the call to the two web services out of the cain into their own variable so I can re-call it at any time. When I now return the ""userObservable"" and an error happens during the web service call, I can show the error in the catchError and return the same ""userObservable"" for the next retry. </p>

<p>At the moment this only properly handles errors when they occur in the web service call chain so I think I should make the button tap a driver. </p>
","1708462","","1708462","","2017-11-02 01:37:50","2017-11-10 02:04:47","RxSwift observable error stops chain - Web services with Rx, how to recover?","<json><swift><web-services><system.reactive><rx-swift>","1","5","1","","","CC BY-SA 3.0"
"46989024","1","","","2017-10-28 11:07:03","","1","556","<p>I want to handle each request, and  if the response of the request not match the condition , start a new request and get the response. How can I restart the old request  </p>

<p>here is my code now </p>

<pre><code>static func request(target: API) -&gt; Observable&lt;Response&gt; {
        let actualRequest = provider.request(target)
        return self.provider.request(target).flatMapLatest { (response) -&gt; Observable&lt;Response&gt; in
            let responseModel = ResponseModel(data:response.data)

            if responseModel.code == -405 {
                let refreshToken = User.shared?.refreshToken
                self.provider.request(.refreshToken(refresh: refreshToken!)).flatMap({ response -&gt; Observable&lt;String&gt; in
                   return Observable.just("""")

                }).shareReplay(1).subscribe(onNext: { refreshToken in
                  // here I get a new token, how to retry the actualRequest , or how to start a new network request with the target 
                }, onError: { (error) in

                },onCompleted: { _ in

                })

            }

                return Observable.just(response)
        }
    }
</code></pre>
","5814921","","","","","2017-10-30 08:24:01","How to restart a net request with moya ,rxswift","<ios><swift><rx-swift><moya>","1","1","","","","CC BY-SA 3.0"
"46995386","1","","","2017-10-28 23:10:28","","1","341","<p>I have (what I think) should be a common scenario.</p>

<p>I have a ViewModel that may have child view models. Both (parent and children) have an <code>Observable&lt;Bool&gt;</code> to reflect if they have changes respect to their original state.</p>

<p>The code looks as follows:</p>

<pre><code>class ParentViewModel {
    var children = Variable&lt;[ChildViewModel]&gt;([])

    var hasChanges: Observable&lt;Bool&gt; {
        return Observable.combineLatest(children.value.map { $0.hasChanges })
            .map { (boolArray) in
                boolArray.reduce(false) { $0 || $1 }
        }
    }
}

class ChildViewModel: CustomStringConvertible {

    let title: Variable&lt;String&gt;
    private let originalValue: String

    var hasChanges: Observable&lt;Bool&gt; {
        return title.asObservable()
            .map { $0 != self.originalValue }
    }

    init(string: String) {
        title = Variable&lt;String&gt;(string)
        originalValue = string
    }

    var description: String {
        return ""\(type(of: self)) - \(title.value)""
    }

}
</code></pre>

<p>This works fine, except <code>ParentViewModel</code> has changes is combining values from <code>children.value</code>, so it's not a true <code>Observable</code> (if I add a <code>ChildViewModel</code> after the binding of <code>hasChanges</code>, it won't be taken into account).</p>

<p>What I want is <code>ParentViewModel</code> <code>hasChanges</code> to be <code>true</code> if <em>any</em> of it's children <code>hasChanges</code> is true as well.</p>

<p>Another failed attempt, looks as follows:</p>

<pre><code>children.asObservable()
    .flatMap { Observable.from($0) }
    .flatMap { $0.hasChanges }
</code></pre>

<p>This will return the latest value of the last child that had any changes, but if two children have changes and one returns to the original value, it makes it return <code>false</code>, which is not what I need.</p>
","7277","","","","","2018-03-29 08:46:34","Combining Observable's within an Observable of an Array","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47000000","1","47000171","","2017-10-29 12:09:26","","0","695","<p>I have two sources for the same action. A regular RxCocoa tap in a <code>UIBarButtonItem</code>:</p>

<pre><code>browseButton.rx.tap
</code></pre>

<p>and a RxGesture tap gesture recognizer in a <code>UIView</code>:</p>

<pre><code>notConnectedView.rx.tapGesture().when(.recognized)
</code></pre>

<p>I subscribe to it the usual way:</p>

<pre><code>&lt;any_of_the_observables&gt;
    .subscribe(onNext: {
        // Do things
    }).disposed(by: disposeBag)
</code></pre>

<p>This works with both observables, and now I want to merge it but cannot achieve it. As they are two observables of different events <code>merge</code> does not work. </p>

<pre><code>Observable.of(notConnectedView.rx.tapGesture().when(.recognized), browseButton.rx.tap)
</code></pre>

<blockquote>
  <p>Type 'inout UIView' does not conform to protocol 'ReactiveCompatible'</p>
</blockquote>

<p>Is it possible to make this? Thanks.</p>
","191059","","","","","2017-10-29 12:28:16","Merge Observables of UIBarButtonItem tap and UIView tapGesture()","<ios><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"47007284","1","47021535","","2017-10-30 02:18:31","","1","3194","<p>I am creating a custom observable that will present a UIAlertController which would like to trigger an API Call when pressed. However, I can't seem to get the Alert to pop unless I manually subscribe to it. Is there a way to get this triggered from the viewModel?</p>

<p>MyController.swift</p>

<pre><code>class MyController: UIViewController {
    @IBOutlet weak var nextBarButton: UIBarButtonItem!

    var viewModel: ViewModel!

    override func viewDidLoad() {
        super.viewDidLoad()


        viewModel = ViewModel( nextBarButton.rx.tap.asDriver(), alertController()asDriver(onErrorJustReturn: """"))
    }

    func alertController() -&gt; Observable&lt;String&gt; {
        return Observable.create { [weak alert = self] observer in
            guard let alert = alert else {
                observer.on(.completed)
                return Disposables.create()
            }

            let alertVc = UIAlertController(title: ""My Title"", message: ""My Message"", preferredStyle: .alert)
            let submit = UIAlertAction(title: ""Continue"", style: .default) { _ in
                observer.onNext(""Test"")
                observer.on(.completed)
            }
            let cancel = UIAlertAction(title: ""Cancel"", style: .cancel) { _ in
                observer.on(.completed)
            }
            alertVc.addAction(cancel)
            alertVc.addAction(submit)
            alert.present(alertVc, animated: true, completion: nil)

            return Disposables.create {
                alertVc.dismiss(animated: true, completion: nil)
            }
        }
    }
}
</code></pre>

<p>ViewModel.swift</p>

<pre><code>public final class ViewModel {
    init(_ manager: SessionManager, _ trigger: Driver&lt;Void&gt;, _ alert: Driver&lt;String&gt;) {
        let _ = trigger.withLatestFrom(alert)
            .flatMap { text in
                return manager.rx
                    .request(urlRequest: Api.test)
                    .retry(3)
                    .asDriverOnErrorJustComplete()
            }
    }
}
</code></pre>
","238975","","","","","2017-10-30 18:00:58","RxSwift trigger observable on button tap","<rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"47030314","1","","","2017-10-31 07:52:07","","0","202","<p>I'm running into an issues with Xcode 9.</p>

<p>I have a new project setup with RxSwift 4.0 installed through CocoaPods. </p>

<p>The issues is I cannot go to method definition using command + click command</p>

<p>Xcode always display this error</p>

<p><a href=""https://i.stack.imgur.com/3SxLm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3SxLm.png"" alt=""enter image description here""></a></p>

<p>Anyone know what is the error about and how we can resolve it in order to view the method definition (I believe it will be inside RxSwift Or RxCocoa pods).</p>
","5532616","","472495","","2018-05-06 14:51:48","2018-05-06 14:51:48","Xcode 9 cannot go to method definition (Cocoa pods, Rxswift)","<xcode9><rx-swift>","1","0","","","","CC BY-SA 4.0"
"47030513","1","","","2017-10-31 08:03:47","","0","182","<p>I build framework, first new project when I test my application - all be ok.
Next step i try build in SDK (framework) package and add this to my project and...
There is a problem... set scheme on build - OK, when I try set scheme on release my SDK crash on: 
`onDisposed: {}).addDisposableTo(disposeBag)</p>

<p>I don't know why my project test its ok, but when i try add it to SDK in release is CRASH ;/</p>

<p>Maybe someone had a similar problem.
RxSwift 3.6.1 - on SDK, project test and application when i add package SDK.</p>

<p>Thanks for help! :)</p>

<p>Edit: 
When setting up a SDK project configuration on debug - it only works on debug configuration (when release is crash related to RxSwift) when the project is setup as release and throws into the package it works only at release configuration (on debug is crash associated with RxSwift).
I want to build one package which will support release and debug.</p>
","8860984","","8860984","","2017-11-03 07:48:07","2017-11-03 07:48:07","RxSwift in Framework crash","<ios><swift><frameworks><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47031210","1","","","2017-10-31 08:49:21","","3","4067","<pre><code>let officialAccountObservable : Observable&lt;[SearchUser]&gt; = SearchAPI.sharedAPI.suggestAccounts()

        officialAccountObservable.bind(to: tableView.rx.items(cellIdentifier: ""followcell"", cellType: FollowCell.self)) {
            (index, user , cell) in
            if user.profileImagePath.isEmpty == false {
                cell.profile.af_setImage(withURL: URL.init(string: user.profileImagePath)!)
            }else {
                cell.profile.image = UIImage.init(named: ""icon_user_03"")
            }
            cell.nickName.text = user.nickName

            cell.follow.rx.tap
                .debounce(0.3, scheduler: MainScheduler.instance)
                .subscribe(onNext: {
                    [unowned self] in
                    cell.setFollow(user: user, completion: { (result) in
                        if(result == true){

                        }
                    })
                }).addDisposableTo(self.disposeBag)
        }.addDisposableTo(disposeBag)

func suggestAccounts() -&gt; Observable&lt;[SearchUser]&gt; {

    let uri = Constants.VyrlSearchURL.suggestUsers

    return Observable.create { observer in
        let request = Alamofire.request(uri, method: .get, parameters: nil, encoding: JSONEncoding.default, headers: Constants.VyrlAPIConstants.getHeader()).responseArray { (response: DataResponse&lt;[SearchUser]&gt;) in
            let value = response.result.value

            observer.onNext(value!)
            observer.onCompleted()
        }

        return Disposables.create(with: request.cancel)
    }
}
</code></pre>

<p>I want to reload the table view in code (result == true)
For reload, OfficialAccountObservable must be received. 
My code is all over and I wonder how I can update it in that state.</p>
","8861168","","8861168","","2017-10-31 09:25:18","2017-11-02 01:47:52","RxSwift reload tableview","<ios><swift><uitableview><rx-swift>","3","1","","","","CC BY-SA 3.0"
"47058231","1","","","2017-11-01 15:23:51","","0","529","<p>I'm trying to use RxSwift to execute actions on multiple data sources. However, I have no idea how to accomplish the following.</p>

<p>I have an array of observabless where the output of each, should be the input of the next. So, I want to do something like, get the first observable, wait for the result and pass it to the next, all the way to the end of the array and return one final value.</p>

<p>Is that possible? Thanks in advance.</p>

<p>*** Update: Ok, I'll be more specific as requested. </p>

<p>The 'observables' I'm using in the array, are custom. I use a function that returns <code>Observable.create { ... }</code>. Inside the closure, I run an asynchronous operation that transforms the value and then send the result to the observer before completing. That resulting value, must pass to the next observable, and so on to the last observable in the array to get a final value.</p>

<p>The observables may send multiple values, but they must pass from one observable to the next like an assembly line.</p>
","705309","","705309","","2017-11-01 22:06:07","2017-11-01 22:06:07","Array of observables where the output of each is the input of the next","<swift><reactive-programming><rx-swift>","1","3","","","","CC BY-SA 3.0"
"47077221","1","","","2017-11-02 14:02:49","","0","331","<p>I have code more less like this:</p>

<pre><code>let requestResult = someSubject
    .flatMapFirst{ [weak self] _ -&gt; Observable&lt;ResponseClass&gt; in
        return self?.triggerNetworkRequest() ?? Observable.never()
    }.share()

requestResult.subscribe(onNext: { [weak self] response in
    if someCondition {
        self?.someSubject.onNext()
    }
}).addDisposableTo(disposeBag)
</code></pre>

<p>So I'm basically emitting new onNext event to repeat the network request in some circumstances.</p>

<p>The problem is that emitting the event this way causes that it's still filtred out by flatMapFrist. If I wrap it in</p>

<pre><code>DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(10)) {
    self.toggleLikeSubject.onNext()
}
</code></pre>

<p>it works. </p>

<p>How to prevent this event from being filtered out?</p>
","3077831","","","","","2017-11-02 14:48:13","RxSwift - how to prevent flatMapFirst to filter out event emited from subscriber","<swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47093231","1","47101191","","2017-11-03 10:14:26","","0","434","<p>I have an app where I am trying to implement RxSwift using MVVM. </p>

<p>I have the SignInViewModel where I am doing the validation and I am updating the login observable with the rest response boolean that I am listening to .</p>

<p>In the controller class when ever the validations pass the login button gets enabled.</p>

<p>In a similar manner I want to be able to start a spinner on click of the button and dismiss when the user receives a response.</p>

<p>When I try to listen to the loginObservable in from view model in the controller class. it does not hit the bind block.</p>

<p>I am not able to figure out what the problem is.</p>

<p>Any help will be appreciated </p>

<p>Following is my SignInViewModel</p>

<pre><code>class SignInViewModel {

    let validatedEmail: Observable&lt;Bool&gt;
    let validatedPassword: Observable&lt;Bool&gt;
    let loginEnabled: Observable&lt;Bool&gt;
    let loginObservable: Observable&lt;Bool&gt;

    init(username: Observable&lt;String&gt;,
         password: Observable&lt;String&gt;,
         loginTap: Observable&lt;Void&gt;) {

        self.validatedEmail = username
            .map { $0.characters.count &gt;= 5 }
            .shareReplay(1)

        self.validatedPassword = password
            .map { $0.characters.count &gt;= 2 }
            .shareReplay(1)

        self.loginEnabled = Observable.combineLatest(validatedEmail, validatedPassword ) { $0 &amp;&amp; $1 }
        let userAndPassword = Observable.combineLatest(username, password) {($0,$1)}

        self.loginObservable = loginTap.withLatestFrom(userAndPassword).flatMapLatest{ (username, password) in
            return RestService.login(username: username, password: password).observeOn(MainScheduler.instance)
        }
    }
}
</code></pre>

<p>Following is the moyaRequest class</p>

<pre><code>final class MoyaRequest{
    func signIn(userData: Creator) -&gt; Observable&lt;Response&gt; {
            return provider.request(.signIn(userData))
                .filter(statusCode: 200)
        }
}
</code></pre>

<p>Following is my RestService class</p>

<pre><code>class RestService:NSObject {

    static var moyaRequest = MoyaRequest()
    static var disposeBag = DisposeBag()

static func login(username: String, password: String) -&gt; Observable&lt;Bool&gt; {
    let userData = Creator()
    userData?.username = username
    userData?.password = password
    print(""Username password"", userData?.username, userData?.password)
    return  Observable.create { observer in moyaRequest.signIn(userData: userData!).subscribe{ event -&gt; Void in
        switch event {

        case .next(let response):
            print(""Response"",response)

        case .error(let error):
            let moyaError: MoyaError? = error as? MoyaError
            let response: Response? = moyaError?.response
            let statusCode: Int? = response?.statusCode

            print(""Sample Response code error"" + String(describing: statusCode))
        default:
            break
        }
        }
        return Disposables.create()
    }

}
</code></pre>

<p>}</p>

<p>I am trying to bind the view model in the controller class.</p>

<pre><code>class SignInViewController: UIViewController{

    let disposeBag = DisposeBag()
    @IBOutlet weak var passwordTextfield: UITextField!
    @IBOutlet weak var usernameTextfield: UITextField!

    private var viewModel : SignInViewModel!
    @IBOutlet weak var signInButton: UIButton!
    override func viewDidLoad() {
        setUpRxViewModel()

    }

    func setUpRxViewModel(){
        self.viewModel = SignInViewModel(username: self.usernameTextfield.rx.text.orEmpty.asObservable(),
                                         password: self.passwordTextfield.rx.text.orEmpty.asObservable(),
                                         loginTap: self.signInButton.rx.tap.asObservable())

        self.viewModel.loginEnabled.bind{ valid  in
            self.signInButton.isEnabled = valid
            }.addDisposableTo(disposeBag)

        self.viewModel.loginObservable.bind{ input in
            print(""Login Clicked"")
            }.addDisposableTo(disposeBag)


    }
}
</code></pre>
","5443885","","5443885","","2017-11-03 10:23:09","2017-11-03 17:17:39","Add a spinner on making a moya request using RxSwift and mvvm and dismiss it when user receives a response","<ios><mvvm><rx-swift><moya><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"47094535","1","47149284","","2017-11-03 11:19:36","","0","160","<p>I'm learning Rx (RxSwift in particular) and I have a question about architecture, layers and boundaries.</p>

<p>I'm used to layered architectures (data, domain, presentation), usually on MVP or VIPER. For this project I'm using MVVM, the recommended architecture for a Reactive app. These are my current collaborators:</p>

<pre><code>**** Presentation ******************************************

                 ________________________
                |                        |
                |   GameViewController   |
                |                        |
                |      ____________      |
                |     |            |     |
                |     | BoardView  |     |
                |     |____________|     |
                |                        |
                |________________________|
                             |
                             |
                            \|/
                 ________________________
                |                        |
                |     GameViewModel      |
                |________________________|
                             |
**** Domain **************** | *****************************
                            \|/
                 ________________________
                |                        |
                |     GameController     |
                |________________________|
</code></pre>

<p>When the user taps (makes a move) the <code>BoardView</code> emits an event, which is being observed by the <code>GameViewController</code>, which calls a method in <code>GameViewModel</code> that communicates with <code>GameController</code> to check if the move is correct and then emits another event being observed by each one in the chain, and finally <code>BoardView</code> draws its stuff according to the correctness of the move.</p>

<p>My question is, is this flow correct? Do I have to stick to this way of doing things or there is a Reactive way that suits better? For example, maybe <code>BoardView</code> can talk directly to the view model without the view controller being involved, and there is not boundary breaking nor ""violation of rules"".</p>

<p>I'm a bit lost in terms of Rx better architectures, MVVM is simple but to make it SOLID you have to create more collaborators, and then the chain of observables could be a bit over-engineered.</p>

<p>Any help will be really appreciated! Thanks :)</p>
","191059","","","","","2017-11-08 02:31:30","ReactiveX, about mobile app architecture and layers","<ios><swift><mvvm><rx-swift><reactive>","2","0","","","","CC BY-SA 3.0"
"47098450","1","47099726","","2017-11-03 14:45:45","","15","11718","<p>I want to achieve result like this:</p>

<pre><code>L -1-2-3------4------5-6-7-8----
R ---------A------B----------C--

O ---------A3-----B4---------C8
</code></pre>

<p>So basically something like withLatestFrom but combining values from both observables (like combine latest).</p>

<p>I guess there is no ready operator for that. Any idea how to achieve this?</p>
","3077831","","","","","2020-02-07 07:14:20","RxSwift - withLatestFrom combining values from both observables","<swift><reactive-programming><rx-swift>","3","0","5","","","CC BY-SA 3.0"
"47131058","1","","","2017-11-06 06:32:11","","0","556","<p>I’m new to rxSwift. I have 3 observables, the checkAccount, fetchMails and fetchFolders.<br>
fetchMails and fetchFolders depend on the checkAccount result. How can I invoke the fetchMails and fetchFolders operation using the UIButton Tap? And if the checkAccount success, I don't what it to run each time I fetchMails and fetchFolders. If checkAccount Failed, I want to retry checkAccount when fetchMails and fetchFolders. How can I To achieve this purpose? and This is my code:</p>

<pre><code>@IBOutlet weak var btn1: UIButton!
@IBOutlet weak var btn2: UIButton!
var checkAccountO: Observable&lt;Bool&gt;?
let bag = DisposeBag()

let fetchO: Observable&lt;[String]&gt; = Observable.create { observer in
        DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(1000)) {
            observer.onNext([""1"",""2""])
        }
        return Disposables.create()
    }

let fetchFolderO: Observable&lt;[String]&gt;  =  Observable.create { observer in
        DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(1000)) {
            observer.onNext([""folder1"",""folder2""])
        }
        return Disposables.create()
    }
override func viewDidLoad() {
    super.viewDidLoad()

    fetchFolders().subscribe { (evetn) in
        print(""folders \(evetn)"")
    }.addDisposableTo(bag)

    fetchMails().subscribe { (evetn) in
        print(""mails \(evetn)"")
    }.addDisposableTo(bag)
}

func checkAccount() -&gt; Observable&lt;Bool&gt; {
    if let ob = checkAccountO {
        return ob
    }
    checkAccountO = Observable.create { (observer) -&gt; Disposable in
        print(""checking..."")
        DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(1000)) {
            let i = arc4random() % 2
            if i == 0 {
                print(""succ"")
                observer.onNext(true)
                observer.onCompleted()
            }else {
                print(""failed:\(i)"")
                let err = NSError.init(domain: ""err"", code: 1001, userInfo: nil)
                observer.onError(err)
            }
        }
        return Disposables.create()
    }.retry(3).shareReplay(1)
    return checkAccountO!
}

func fetchMails() -&gt; Observable&lt;[String]&gt; {
    return checkAccount().flatMap({ (_) -&gt; Observable&lt;[String]&gt; in
        return self.fetchO
    })
}

func fetchFolders() -&gt; Observable&lt;[String]&gt; {
    return checkAccount().flatMap({ (_) -&gt; Observable&lt;[String]&gt; in
        return self.fetchFolderO
    })
}
</code></pre>

<p>according to @Timofey Solonin's answer, I change the fetchFoders and fetchMails observable to flatmap from button.rx.tap like this, but still not known how to use retrywhen</p>

<pre><code>    func fetchMails() -&gt; Observable&lt;[String]&gt; {
    let rxtap = btn1.rx.tap
    return rxtap.flatMap { (_) -&gt; Observable&lt;[String]&gt; in
        return self.checkAccount().flatMap({ (_) -&gt; Observable&lt;[String]&gt; in
            return self.fetchO
        })
    }

}

func fetchFolders() -&gt; Observable&lt;[String]&gt; {
    let rxtap = btn2.rx.tap
    return rxtap.flatMap { (_) -&gt; Observable&lt;[String]&gt; in
        return self.checkAccount().flatMap({ (_) -&gt; Observable&lt;[String]&gt; in
            return self.fetchFolderO
        })
    }
}
</code></pre>
","993080","","993080","","2017-11-07 16:12:36","2017-11-07 16:38:14","rxSwift Observable dependency","<ios><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47143880","1","","","2017-11-06 18:59:21","","0","488","<p>Following is my code for signing up </p>

<pre><code>self.signedUp  = signUpButtonTap.withLatestFrom(userAndPassword).flatMapLatest{
            input -&gt;  Observable&lt;Response&gt; in
            return  Observable.create { observer in
                let userData = Creator()
                userData?.username = input.0
                userData?.password = input.1
                provider.request(.signIn(userData!)).filter(statusCode: 200).subscribe{  event -&gt; Void in

                    switch event {
                    case .next(let response):
                        observer.onNext(response)

                    case .error(let error):
                        let moyaError: MoyaError? = error as? MoyaError
                        let response: Response? = moyaError?.response
                        let statusCode: Int? = response?.statusCode
                        observer.onError(error)

                    default:
                        break
                    }

                }
                return Disposables.create()
            }
        }
</code></pre>

<p>Following is the binding in the View</p>

<pre><code> self.viewModel.signedUp.bind{response in
               self.displayPopUpForSuccessfulLogin()
            }
</code></pre>

<p>When there is a successful response its works fine.</p>

<p>But when the request times out or I get any other status code than 200, I get the following error ""fatalError(lastMessage)"" and the app crashes.</p>

<p>When I replace observer.onError(error) with observer.onNext(response) in the case .error it works for response codes other than 200 , but crashes again when the request times out.</p>

<p>I have gone through this link <a href=""https://stackoverflow.com/questions/36925857/handling-network-error-in-combination-with-binding-to-tableview-moya-rxswift"">Handling Network error in combination with binding to tableView (Moya, RxSwift, RxCocoa)</a></p>

<p>Can anyone help me out with what is wrong. I am completely new to RxSwift . Any help will be appreciated. Thank you</p>
","5443885","","5443885","","2017-11-07 04:13:07","2019-05-08 09:55:03","RxMoya request using mvvm model always crashes in observer.onError(error)","<ios><swift><mvvm><rx-swift><moya>","1","4","1","","","CC BY-SA 3.0"
"47152232","1","","","2017-11-07 07:30:42","","1","354","<p>Following is my code to make a request and bind it to a UI element</p>

<pre><code>func signUpService(_ signUpButtonTap: Observable&lt;Void&gt;, _ userAndPassword: Observable&lt;(String, String)&gt;) -&gt; Observable&lt;Response&gt; {
    return signUpButtonTap
        .withLatestFrom(userAndPassword)
        .flatMapLatest{
            input -&gt;  Observable&lt;Response&gt; in
            return Observable.create { observer in
                let userData = Creator()
                userData?.username = input.0
                userData?.password = input.1
                return provider.request(.signUp(userData!)).filter(statusCode: 201).subscribe{  event -&gt; Void in

                    switch event {
                    case .next(let response):
                        observer.onNext(response)
                        print(""Success response"", response)

                    case .error(let error):
                        let moyaError: MoyaError? = error as? MoyaError
                        let response: Response? = moyaError?.response
                        let statusCode: Int? = response?.statusCode
                        print(""Error response"", response?.statusCode)
                        observer.onError(AuthenticationError.server)

                    default:
                        break
                    }

                }
            }
        }.observeOn(MainScheduler.instance)
}
</code></pre>

<p>In my view I am doing the following</p>

<pre><code>self.viewModel.signedUp?.bind{response in
            self.displayPopUpForSuccessfulLogin()
            }.addDisposableTo(disposeBag)
    }
</code></pre>

<p>Whenever I hit the error block the app crashes. It says Binding error. I am not able to bind error to the UI element.</p>

<p>How are errors handled in Rxswift bindings.
If I get a nil response from the sever how can I handle it.</p>

<p>Any help will be appreciated . Thank you</p>
","5443885","","","","","2017-11-07 07:30:42","How to handle errors in view controller in the MVVM model","<ios><swift><rx-swift><moya><rx-cocoa>","0","1","1","","","CC BY-SA 3.0"
"47153028","1","","","2017-11-07 08:19:16","","0","658","<p>I am still fairly new to the Rx world and I was wondering if I am doing it right or if I have a misconception and are violating the best practices. If so, I'd be happy if you could point me to the right direction.</p>

<p>In my iOS app I need to call a web service to retrieve my data. There are basically two calls I can make: </p>

<ul>
<li>A call to a collection resource (/devices)</li>
<li>A call to a single resource (/devices/{id}) </li>
</ul>

<p>To reduce the amount of calls I need to do I thought it would be a good idea to store the data locally in memory so that when I go from the list view (which displays all devices) to the detail view (which displays a single device), I don't have to make a call to the single resource. </p>

<p>Instead, I would only make this call when the user uses pull to refresh inside the detail screen and then write back the data to the collection which is used as the datasource for the list screen.</p>

<p>Now due to the fact that the app is running on a mobile device, there can be multiple errors while making a call to the web service and if an error occurs I would like to show a message to the user to inform about the problem. </p>

<p>I was thinking about using a Subject inside a Singleton class as my data source to which my UI subscribes. Whenever I need to refresh the list, I would create a new observable with my web service call which, as a side effect, populates new data to the Subject but does not populate onError or onComplete events to the Subject.</p>

<p>I hope this piece of pseudo code explains better what I mean:</p>

<pre><code>//Pull-to-refresh function
Observable.create { observable in
  let hud = HUD(""loading devices"")
  self.hud = hud
  observable.next()
  return Disposable.create { hud.dismiss() }
}
.flatMap {
  return DeviceService.getList() //The web service
}
.flatMap { devices in
  DeviceSingleton.devicesSubject.next(devices) //The singleton
  return Observable.just()
}
.subscribe(
  onNext: { self.hud.dismiss() }
  onError: { error in 
      self.hud.dismiss()
      self.displayError(error)
  }
)
.disposed(by: disposeBag)
</code></pre>

<p>The pull-to-refresh in the detail screen would look similar but it would involve getting the current data from the subject, then replacing the updated device and re-publishing the data like so:</p>

<pre><code>//Pull-to-refresh function in detail screen
let id = ...
Observable.create { observable in
  let hud = HUD(""loading devices"")
  self.hud = hud
  observable.next()
  return Disposable.create { hud.dismiss() }
}
.flatMap {
  return DeviceService.getDevice(id: id) //The web service
}
.flatMap { device in
  let devices = try! DeviceSingleton.devicesSubject.value()
  let updatedDevices = self.updateDevice(device, in: devices) //removing old device, adding new one, sorting, etc.
  DeviceSingleton.devicesSubject.next(devices) 
  return Observable.just()
}
.subscribe(
  onNext: { self.hud.dismiss() }
  onError: { error in 
      self.hud.dismiss()
      self.displayError(error)
  }
)
.disposed(by: disposeBag)
</code></pre>

<p>Is this correct? Is this valid? What could be a better approach? I think one problem might be that reloading a single device can not only happen when the user pulls-to-refresh but also when a remote notification comes in. </p>

<p>I hope you can tell me if I am using Rx correctly or if I am doing something wrong here.</p>
","1708462","","","","","2017-11-13 12:51:30","RxSwift best practice: Shall I use a Subject for my internal data source?","<ios><swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47166312","1","47284386","","2017-11-07 19:50:39","","0","509","<p>I try to start a network request via Moya.</p>

<pre><code>    let provider = MoyaProvider&lt;User&gt;()

    provider.rx.request(.Auth(username: username, password: password))
        .filterSuccessfulStatusAndRedirectCodes()
        .debug()
        .mapOptional(to: Authentication.self)
        .observeOn(MainScheduler.instance)
        .subscribe {
            event in
            print(event)
        }.disposed(by: disposeBag)
</code></pre>

<p>When I do it the above way everything works fine.</p>

<p>But if I do it this way:</p>

<pre><code>func logIn(username: username, password: password) -&gt; Single&lt;Authentication?&gt; {

    let provider = MoyaProvider&lt;User&gt;()

    return provider.rx.request(.Auth(username: username, password: password))
        .filterSuccessfulStatusAndRedirectCodes()
        .debug()
        .mapOptional(to: Authentication.self) 
}
</code></pre>

<p>And then calling the function:</p>

<pre><code>self.loginIn(username: username, password: password)
        .observeOn(MainScheduler.instance)
        .subscribe {
            event in
            print(event)
        }
        .disposed(by: disposeBag)
</code></pre>

<p>The debug output states that it get subscribed, but it won't start the sequence if i return it via the function.</p>
","5124070","","","","","2017-11-14 11:16:03","RxSwift/Moya - Sequence won't start if it is returned via function","<swift><reactive-programming><rx-swift><moya>","1","0","","","","CC BY-SA 3.0"
"47173475","1","50465274","","2017-11-08 07:02:43","","0","1592","<p><strong>Kotlin Code:</strong></p>

<pre class=""lang-kotlin prettyprint-override""><code>fun &lt;T&gt; Observable&lt;T&gt;.circuitBreaker(): Observable&lt;T&gt; {
  val relay = PublishRelay.create&lt;T&gt;()
  this.subscribe(relay)
  return relay.toFlowable(BackpressureStrategy.LATEST).toObservable()
}
</code></pre>

<p>Above is a Kotlin code which I'm trying to convert into Swift. But, I'm facing an error saying <strong>Cannot convert value of type 'PublishRelay' to expected argument type '(Event&lt;_>) -> Void'</strong></p>

<p><strong>Swift Code:</strong></p>

<pre class=""lang-swift prettyprint-override""><code>extension Observable {
  func circuitBreaker&lt;T&gt;() -&gt; Observable&lt;T&gt; {
    let relay = PublishRelay&lt;T&gt;()
    self.subscribe(relay)
    return relay.asObservable()
  }
}
</code></pre>

<p>Any help would be appreciated.</p>
","1083859","","6584288","","2017-11-08 07:09:57","2018-05-22 10:20:39","How to subscribe to PublishRelay from generic observable?","<generics><rx-swift><rx-cocoa><rx-kotlin>","2","0","","","","CC BY-SA 3.0"
"47195991","1","47447705","","2017-11-09 07:14:52","","0","128","<p>I am new to use mocking stubs could you please help any one!!</p>

<p>when doing signUp tests every time getting error  like XCTAssertEqual failed: (""201"") is not equal to (""200"") .</p>

<ul>
<li><p>How to test the hardcode signUp details without using backend data</p></li>
<li><p>How to test the response of status codes for success and failures</p></li>
</ul>

<p>any help should be appreciated - ThankYou</p>

<pre><code>class LoginServiceUnitTests: XCTestCase {
    var stubProvider = RxMoyaProvider&lt;RestApi&gt;()
    override func setUp() {
        super.setUp()
        stubProvider = RxMoyaProvider&lt;RestApi&gt;(stubClosure: MoyaProvider.immediatelyStub)
    }

    func testSignUpForSuccessResponse() {

        let userData = Creator()
        userData?.username = ""raj@naresh.com""
        userData?.password = ""password""
        userData?.displayName = ""username""
        let target: RestApi = .signUp(userData!)
        stubProvider.request(target) { result in
            if case let .success(response) = result {
                XCTAssertEqual(""201"", String(response.statusCode))

            }
        }
    }
}
</code></pre>
","8204597","","8204597","","2017-11-10 08:39:57","2017-11-23 04:43:56","XcTest cases for signUp Validation using Stub provider in RxSwift","<ios><swift><rx-swift><xctestcase>","1","1","0","","","CC BY-SA 3.0"
"47202391","1","","","2017-11-09 12:55:10","","7","7374","<p>I would like to do some heavy lifting in the background thread of my iOS app and NOT freeze the UI while it is being performed. What I try is:</p>

<pre><code>self.someDisposable = heavyLiftingFuncReturningObservable()
            .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))
            .observeOn(MainScheduler.instance)
            .subscribe(
                onNext: { [weak self] image in
                    // update UI
                },
                onError: { ... }
            )
</code></pre>

<p>Why does the above not work as expected and how to make it work?</p>
","5222821","","","","","2021-07-13 07:39:23","RxSwift — background task without freezing UI","<ios><swift><multithreading><rx-swift>","3","2","0","","","CC BY-SA 3.0"
"47202871","1","","","2017-11-09 13:18:11","","1","520","<p>I try to develop iOS app with RxSwift + MVVM architecture.<br>
I have a question. Who should have DisposeBag instance?<br>
Now, I am implementing as the following in my code.  </p>

<ul>
<li>View model has a instance of ""Variable"".</li>
<li>Controller keep the DisposeBag.</li>
<li>View subscribes to observable of view model and attach controller's dispose bag.</li>
</ul>

<p>Is it good design or not?<br>
I want to have code standard, please give me your opinion.</p>
","6540269","","","","","2017-11-10 16:19:43","Who should keep DisposeBag in MVVM(+controller) on swift","<ios><swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47203371","1","","","2017-11-09 13:40:34","","0","1788","<p>I am using RxSwift 4.0 and build tableView content using <code>DTTableViewManager</code></p>

<p>in Presenter, I have model variable</p>

<p><strong>1</strong></p>

<pre><code>lazy var mostRecent: TableTitleHeaderContainer = {
    let container = TableTitleHeaderContainer(isHidden: true, title: ""Title 1"")
    return container
}()

lazy var lastRecent: TableTitleHeaderContainer = {
    let container = TableTitleHeaderContainer(isHidden: false, title: ""Title 2"")
    return container
}()
</code></pre>

<p>code of model</p>

<p><strong>2</strong></p>

<pre><code>class TableTitleHeaderContainer {
    var subject: PublishSubject&lt;Void&gt; = PublishSubject&lt;Void&gt;()
    var isHidden: Bool
    var title: String
    var disposeBag = DisposeBag()
    init(isHidden: Bool, title: String) {
        self.isHidden = false
        self.title = title
    }
}
</code></pre>

<p>and view configuration with model </p>

<p><strong>3</strong></p>

<pre><code>extension TableTitleHeaderView: ModelTransfer {
    func update(with model: TableTitleHeaderContainer) {
        clearButton.isHidden = model.isHidden
        clearButton.rx.tap
            .bind(to: model.subject).disposed(by: disposeBag)
        titleLabel.text = model.title
    }
}
</code></pre>

<p>And I want to listen tap on button in Presenter</p>

<p><strong>4</strong></p>

<pre><code>mostRecent.subject.asObserver().subscribe(onNext: { [weak self] (_) in
    print(""Clear mostRecent"")
}).disposed(by: disposeBag)

lastRecent().subject.asObserver().subscribe(onNext: { [weak self] (_) in
    print(""Clear lastRecent"")
}).disposed(by: disposeBag)
</code></pre>

<p>But after configure view with model subscribe in Presenter does not call?
What is the trouble?</p>
","4896903","","169346","","2017-11-09 14:23:13","2017-11-09 14:23:13","RxSwift Subscribe onNext not called after bind","<ios><swift><rx-swift><rx-cocoa>","0","2","1","","","CC BY-SA 3.0"
"47211942","1","47234388","","2017-11-09 21:34:03","","1","158","<p>Im looking for an operator (or a chain of operators) that, like flatMapFirst, discards items while waiting for the current observable to complete, which when it does, immediately spans another stream for the latest item seen.</p>

<p>I hope this diagram explains it better:</p>

<pre><code>x -&gt; [X1,X2,X3]

Input:  -a-----------b---c--d-------------------------
Output: ---A1-A2-A3----B1--B2--B3--D1-D2-D3-----------
</code></pre>

<p>As you can see, <code>c</code> got skipped, since <code>d</code> arrived after it. But notice as well that <code>d</code> arrived while <code>b</code> was still being processed and as soon as <code>b</code> was done, <code>d</code> started being processed.</p>

<p>This operator allows me to finish computations, as opposed to <code>flatMapLatest</code> which might switch from observable to observable, without ever giving a complete result for a computation. It behaves like <code>flatMapFirst</code> but the last element is still processed, allowing a consistent state in idle periods when the input elements stream does not have any elements.</p>

<p><code>concatMap</code> could be the answer here, but if too many items get between <code>b</code> and <code>d</code>, the output stream would delay the latest item's computation far too long.</p>

<pre><code>flatMapFirst (d is discarded)

Input:  -a-----------b---c--d----------------
Output: ---A1-A2-A3----B1--B2--B3------------

flatMapLatest (periods of starvation can happen)

Input:  -abcdefghijklmnop-----
Output: -------------------P1-

concatMap (too much work can get scheduled)

Input:  -a-----------b-c-d-e-f------------------------------------------
Output: ---A1-A2-A3----B1--B2--B3-C1-C2-C3--D1-D2-D3-E1-E2-E3--F1-F2-F3-
</code></pre>
","843726","","843726","","2017-11-14 17:33:48","2017-11-14 17:33:48","flatMapFirst, but delaying the latest item","<reactive-programming><rx-swift>","1","1","3","","","CC BY-SA 3.0"
"47219629","1","","","2017-11-10 09:35:23","","1","2173","<p>I have a table view that I am trying to make reactive. I have it working using Swift.</p>

<p>Following is the RxSwift code</p>

<pre><code>viewModel.getDetailMessages().asObservable().bind(to: messageTableView.rx.items){ tableView, row, element in
            let indexPath = IndexPath(row: row, section: 0)
            print(""The size is"", InboxData.sharedInstance.inboxdata[messageIndexPath.row].messageDetail.count)
            print(""The size is element"", element)
            if !element.isSender{
                let cell = tableView.dequeueReusableCell(withIdentifier: ""recieverCell"", for: indexPath) as! RecieverMessageTableViewCell
                cell.message.text = element.messageText
                cell.message.preferredMaxLayoutWidth = 287
                cell.message.layer.cornerRadius = 8
                cell.message.layer.masksToBounds = true
                return cell
            }else{
                let cell = tableView.dequeueReusableCell(withIdentifier: ""senderCell"", for: indexPath) as! SenderMessageTableViewCell
                cell.senderMessage.text = element.messageText
                cell.senderMessage.layer.cornerRadius = 8
                cell.senderMessage.preferredMaxLayoutWidth = 287
                cell.senderMessage.layer.masksToBounds = true
                return cell
            }
        }
</code></pre>

<p>Following is my view model</p>

<pre><code>class MessagwViewModel{

    func getDetailMessages() -&gt; Observable&lt;[Message]&gt; {
        return Observable.just(InboxData.sharedInstance.inboxdata[messageIndexPath.row].messageDetail)
    }

}
</code></pre>

<p>And this is the message data class</p>

<pre><code>class MessageData {

    static let sharedInstance = MessageData()

    var message1 = Message(profilePicture: ""Taylor Ward"", artistName: ""Taylor Ward"", messageText: ""Hi How are you?"", isSender: true)

    var messages = [Message]()

    private init() {
        loadMessages()
    }

    func loadMessages() {
        messages.removeAll()
        messages.append(message1)

    }

}
</code></pre>

<p>On Click of a button I am trying to append data to the Message array as follows</p>

<pre><code>sendButton.rx.tap.bind{ value in
            InboxData.sharedInstance.inboxdata[messageIndexPath.row].messageDetail.append(Message(profilePicture: """", artistName: """", messageText: self.messageTextView.text, isSender: true))

       self.messageTableView.reloadData()
            self.messageTableView?.scrollToBottom()
            print(""Button clicked"")
        }
</code></pre>

<p>The count of the array increases every time I append a new element . But the table view does not reload even though the data source has the latest value</p>

<p>Can anyone one point out what the problem is? Thank you.</p>
","5443885","","","","","2017-11-13 02:57:07","Rx table view not being reloaded after the datasource gets updated","<ios><uitableview><rx-swift><rx-cocoa><rxdatasources>","1","0","","","","CC BY-SA 3.0"
"47233714","1","47233809","","2017-11-11 02:20:40","","5","6240","<p>I have following code in Swift 4 with RxSwift</p>

<pre><code>worthReacting.flatMap{ (userSearch) in
        translator.getTranslation(ofWord: userSearch)
        }.subscribe(
            onSuccess: {(dataModel) in
                state.value = .translation(word: dataModel.definition,
                                           translations: dataModel.translations)
        },
            onError: {(error) in
                state.value = .networkError
        },
            onCompleted: {
                state.value = .unknownWord
        }).disposed(by: disposeBag)
</code></pre>

<p><code>worthReacting</code> has type of <code>Observable&lt;String&gt;</code><br>
<code>translator.getTranslation</code> returns <code>Maybe&lt;DataModel&gt;</code>  </p>

<p>I'm getting build error </p>

<blockquote>
  <p>Extra argument 'onError' in call</p>
</blockquote>
","4335243","","790877","","2017-11-14 14:56:26","2018-07-06 05:10:28","RxSwift: Extra argument 'onError' in call","<swift><observable><rx-swift><maybe>","2","0","","","","CC BY-SA 3.0"
"47286569","1","47287469","","2017-11-14 13:00:07","","1","874","<p>I have an <code>Observable&lt;Item&gt;</code> that emits a series of items asynchronously. For each Item in the stream I need to display a UIAlertView. Each time the user dismisses the alert (if there is a new item) I need to grab the next item and show a new alert for it.</p>

<p>The problem I have is that the Observable emits items too quickly. While an alert is displayed, several items are emitted and I lose that information.  </p>

<p>The stream might produce 10 items in one second, and I want to show 10 popups, that will be opened serially, one at a time, one after the other.</p>

<p>Is there a way to consume the next item in the stream only once I am ready to display the alert?</p>
","183952","","183952","","2017-11-14 18:17:36","2017-11-14 18:17:36","RxSwift, How to apply back-pressure to serially display a UIAlertView for each item in a Stream","<ios><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47305554","1","47307332","","2017-11-15 10:54:52","","0","505","<p>I have a seed value <code>Triangle (Bool)</code> and an observable that emits values <code>Circle (Int)</code>. My intention is to generate a new observable <code>(Triangle, Circle)</code>  each time a value is emitted from that observable, transforming the <code>Triangle</code> value negating the current value. This is my marble diagram:</p>

<p><a href=""https://i.stack.imgur.com/XhS0O.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/XhS0O.jpg"" alt=""enter image description here""></a></p>

<p>But I cannot achieve it, and I don't know if <code>scan</code> is the correct operator. This is my code:</p>

<pre><code>typealias Triangle = Bool
typealias Circle = Int

func scan() {
    let triangle: Triangle = false
    circleObservable
        .scan(triangle, accumulator: ({ (triangle, circle) -&gt; (Triangle, Circle) in
            return (!triangle, circle)
        }))
}
</code></pre>

<p>This generates a compiler error:</p>

<blockquote>
  <p>Cannot convert value of type '(Triangle, Circle) -> (Triangle,
  Circle)' (aka '(Bool, Int) -> (Bool, Int)') to expected argument type
  '(_, _) -> _'</p>
</blockquote>

<p>Thanks!</p>
","191059","","","","","2017-11-15 12:23:24","Rx scan(), cannot generate observable from seed and another observable","<ios><swift><reactive-programming><rx-swift>","2","0","","","","CC BY-SA 3.0"
"47309239","1","","","2017-11-15 13:54:19","","0","158","<h2>Problem</h2>

<p>Given an <code>Observable&lt;NaturalNumber&gt;</code> that represent the sequence off all natural numbers.</p>

<p><strong>Example 1</strong> <em>(addressed in <a href=""https://stackoverflow.com/a/47310364/418543"">this answer</a>, check next example)</em></p>

<p>How can I get a <code>Single&lt;String&gt;</code> that contains the sum expression and result of all the numbers between a range?
Ex: for a range from 10 to 13 -> ""11 + 12 = 23""</p>

<p>So far this is what I have (and don't like):</p>

<pre><code>let min = 10
let max = 15
//No special meaning, just to add an ""error"" case
let maxAllowed = 20

Single&lt;String&gt;.create(subscribe: { (complete) -&gt; Disposable in
    return Observable.range(start: 0, count: Int.max)
        .filter { min &lt; $0 &amp;&amp; max &gt; $0 }
        .scan([], accumulator: { (acc: [Int], number) in
            guard number &lt; maxAllowed else {
                complete(.error(SomeError()))
                return []
            }
            return acc + [number]
        })
        .single { $0.count == (max - min - 1) }
        .map { range in
            let sum = range.reduce(0, +)
            return range.reduce("""", { (acc, number) -&gt; String in
                if number == (max - 1) {
                    return acc + "" + \(number) = \(sum)""
                } else {
                    return acc + ""\(acc != """" ? "" + "" : """")\(number)""
                }
        })}
        .subscribe(onNext: { complete(.success($0)) })
}).subscribe(onSuccess: { (s) in
    print(""Success: \(s)"") // ""Success: 11 + 12 + 13 + 14 = 50""
}, onError: { (e) in
    print(""Error"")
}).disposed(by: d)
</code></pre>

<p><strong>Example 2</strong></p>

<p>Given a <code>struct Point3D</code> that needs to be constructed from an array of size 3. How can I get a <code>Single&lt;Point3D&gt;</code> where the values in the input vector should be in a specified range?</p>

<pre><code>let min = 10
let max = 15
//No special meaning, just to add an ""error"" case
let maxAllowed = 20

struct Point3D {
    let x: Int
    let y: Int
    let z: Int

    init(vector: [Int]) {
        x = vector[0]
        y = vector[1]
        z = vector[2]
    }
}

Single&lt;Point3D&gt;.create(subscribe: { (complete) -&gt; Disposable in
    return Observable.range(start: 0, count: Int.max)
        .filter { min &lt; $0 &amp;&amp; max &gt; $0 }
        .scan([], accumulator: { (acc: [Int], number) in
            guard number &lt; maxAllowed else {
                complete(.error(SomeError()))
                return []
            }
            return acc + [number]
        })
        .single { $0.count == 3 }
        .map(Point3D.init(vector:))
        .subscribe(onNext: { complete(.success($0)) })
}).subscribe(onSuccess: { (s) in
    print(""Success: \(s)"") // ""Success: Point3D #1(x: 11, y: 12, z: 13)""
}, onError: { (e) in
    print(""Error"")
}).disposed(by: d)
</code></pre>

<p><em>Keep in mind:</em>
This is an abstraction of a real problem I have that involves an infinite sequence of values coming from a bluetooth connection. So please try to avoid answers that change to problem instead of the solution unless you think it make sense given the above.</p>

<h2>Objective</h2>

<p>The patter I look to extract is: select some values from an infinite sequence and construct a new one with only those values. Once all the values are collected completes with <code>.success(allValues)</code></p>

<p>What I want to improve over the examples is:</p>

<ul>
<li>The need of the <code>Single&lt;T&gt;.create()</code> wrapper. It's there only for been able to complete with and error in some cases (the <code>maxAlloed</code> in the examples). Also I'm not sure if the <code>asSingle()</code> operator completes the returned <code>Single</code> after a value is returned (?).</li>
<li>The use of <code>filter</code>, <code>scan</code> and <code>single</code> to take values from the original sequence and to control when the finite sequence should complete. Think on the <em>Example 2</em>.</li>
</ul>

<p>Thanks</p>
","418543","","418543","","2017-11-15 19:14:49","2017-11-15 19:14:49","How can I get a `Single<T>` from an infinite sequence?","<swift><macos><rx-swift>","1","5","","","","CC BY-SA 3.0"
"47316858","1","47383701","","2017-11-15 20:41:07","","2","1295","<p>I have a View Controller that opens a modal view controller for the user to pick images from its library. For that, I'm using a Rx wrapper of <code>DKImagePickerController</code> that I wrote.</p>

<p>The relevant code in the View Controller is as follows:</p>

<pre><code>fileprivate func addPicturesFromLibrary() {
    guard let viewModel = self.viewModel else { return }

    let pickerController = DKImagePickerController()
    pickerController.singleSelect = false
    pickerController.maxSelectableCount = 10
    pickerController.showsCancelButton = true
    pickerController.sourceType = .photo

    pickerController.rx.didSelectAssets()
        .debug(""👍 1"")
        .bind(to: viewModel.addAssetsInput)
        .disposed(by: disposeBag)

    self.present(pickerController, animated: true, completion: nil)
}
</code></pre>

<p>My view model looks like this:</p>

<pre><code>class MediaViewModel {

      var selectedImages = Variable&lt;[MediaListingImage]&gt;([])

      public let addAssetsInput = PublishSubject&lt;DKAsset&gt;()

      init() {
         bind()
      }

      private func bind() {
          addAssetsInput
              .debug(""👍 2"")
              .flatMap {
                  $0.rx.fetchOriginalImage()
              }
              .map {
                  MediaListingImage.local($0)
              }
              .subscribe(onNext: { [weak self] (mediaListingImage) in
                  self?.selectedImages.value.append(mediaListingImage)
              })
              .disposed(by: disposeBag)
      }
}
</code></pre>

<p>When I open the first modal picker, it works as expected. However, when it disposes, the binding <em>in the view model</em> also disposes, so subsequent presentations of the modal view controller won't work.</p>

<p>Here's the log I get in the console, which might help you understand what I see:</p>

<pre><code>2017-11-15 17:33:15.490: 👍 2 -&gt; subscribed
2017-11-15 17:33:21.452: 👍 1 -&gt; subscribed
2017-11-15 17:33:23.902: 👍 1 -&gt; Event next(&lt;DKImagePickerController.DKAsset: 0x6080002ab940&gt;)
2017-11-15 17:33:23.902: 👍 2 -&gt; Event next(&lt;DKImagePickerController.DKAsset: 0x6080002ab940&gt;)
2017-11-15 17:33:23.902: 👍 1 -&gt; Event completed
2017-11-15 17:33:23.903: 👍 2 -&gt; Event completed
2017-11-15 17:33:23.903: 👍 2 -&gt; isDisposed
2017-11-15 17:33:23.903: 👍 1 -&gt; isDisposed
2017-11-15 17:33:29.924: 👍 1 -&gt; subscribed
2017-11-15 17:33:33.114: 👍 1 -&gt; Event next(&lt;DKImagePickerController.DKAsset: 0x60c0002a62a0&gt;)
2017-11-15 17:33:33.114: 👍 1 -&gt; Event completed
2017-11-15 17:33:33.114: 👍 1 -&gt; isDisposed
</code></pre>

<p>If I change the code in the View Controller to something like:</p>

<pre><code>    pickerController.rx.didSelectAssets()
        .debug(""👍 1"")
        .subscribe(onNext: { (asset) in
            viewModel.addAssetsInput.onNext(asset)
        })
        .disposed(by: disposeBag)
</code></pre>

<p>it works as expected. However, I find using <code>bind</code> more elegant in this case, and would like to keep using it if possible.</p>

<p>What is triggering the binding of the <code>PublishSubject</code> in the view model to dispose? How can I prevent it without leaking resources?</p>
","7277","","7277","","2017-11-15 20:50:37","2017-11-20 00:56:08","RxSwift PublishSubject getting unintentionally disposed","<ios><rx-swift>","1","2","0","","","CC BY-SA 3.0"
"47323576","1","47329110","","2017-11-16 07:07:50","","3","254","<p><strong>Background:</strong></p>

<p>I need to start working on project which we are hoping to maintain it for long time (Basically reusable components which will be reused in multiple projects). I was exploring the Reactive Programming and the benefits Reactive Programming brings to the table is way to high to ignore it. </p>

<p>I started exploring various FRP frameworks available and <code>RxSwift</code>, <code>ReactiveCocoa</code> were few such examples. But looking at the community support and swift implementation, RxSwift was obviously the choice.</p>

<p>Now <code>RxSwift4</code> came with some breaking changes as <code>RxSwift3</code> wasn't compatible with <code>Swift4</code>. Now community did a great job to bridge the changes smooth, though but things like <code>DelegateProxy</code> implemented in <code>RxSwift3</code> started breaking in <code>RxSwift4</code>. So for those who used <code>RxSwift3</code> it wasn't just a pod update but involved loads of changes as well. On following the <a href=""https://github.com/ReactiveX/RxSwift/issues/1442"" rel=""nofollow noreferrer"">RxSwift Git hub issue</a> realized that its because of <code>Swift4</code> changes which lead to this break.</p>

<p><strong>Question:</strong></p>

<p>Now its a very common risk that we take on using all third party frameworks, but with most of the frameworks I used, if broke they would have break a feature or two in app but if I write a complete app in RxSwift and future updates break, finding a replaceable library and replacing it would be a enormous job.</p>

<p><em>Here is why?</em></p>

<p>For example, if you use Alamofire, usually you will have your own Network layer in app which would expose certain API to app and app quite frankly wont worry about the library used under the hood. So replacing it is quite a easy task. But with RxSwift all asynchronous tools like <code>delegates</code>, <code>blocks</code>,<code>notifications</code> are already wrapped in RxSwift components like <code>Observables</code>,<code>Subjects</code>,<code>Units</code> etc to which we cant write a wrapper of our own and if Current RxSwift version breaks in future update we will be left with no other solution than to literally fix them one by one, as replacing library would mean complete re writing of project.</p>

<p><em>I know its a kind of opinion based question</em>, but the problem is there is no much guiding opinion on web for the same. I would really appreciate, if somebody who used FRP frameworks in their project post the best practice to use them so that dependency on framework will be minimal and allow us to shift to new FRP framework easily in future.</p>

<p><strong>EDIT:</strong></p>

<p>The mention of Alamofire above is just to show how easy it is to wrap other frameworks that we use in our app only and has nothing to do with RxSwift in itself. So please don't get carried away by that :)</p>
","5706328","","2976878","","2017-11-16 09:00:10","2017-11-16 11:58:31","How safe it is to use third party FRP frameworks for long running project knowing that swift is constantly being changed?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47328082","1","47329927","","2017-11-16 11:07:13","","1","4420","<p>I'm new to Reactive Programming and I have a big problem that I can't solve alone... I need to upload several video assets and in a orderly sequence but I do not know how to do it, I have an array of PHAssets and I'm trying to iterate thru each element and send it over the network
Here is my code so far with comments:</p>

<pre><code>for item in items {
                    let fileName = item.media.localIdentifier

                    //Observable to generate local url to be used to save the compressed video
                    let compressedVideoOutputUrl = videoHelper.getDocumentsURL().appendingPathComponent(fileName)

                    //Observable to generate a thumbnail image for the video
                    let thumbnailObservable =  videoHelper.getBase64Thumbnail(myItem: item)

                    //Observable to request the video from the iPhone library
                    let videoObservable = videoHelper.requestVideo(myItem: item)

                        //Compress the video and save it on the previously generated local url
                        .flatMap { videoHelper.compressVideo(inputURL: $0, outputURL: compressedVideoOutputUrl) }
                    //Generate the thumbnail and share the video to send over the network
                    let send = videoObservable.flatMap { _ in thumbnailObservable }
                        .flatMap { api.uploadSharedFiles(item, filename: fileName, base64String: $0) }

                    //subscribe the observable
                    send.subscribe(onNext: { data in
                        print(""- Done chain sharing Video -"")
                    },
                                   onError: { error in
                                    print(""Error sharing Video-&gt; \(error.localizedDescription)"")
                    }).disposed(by: actionDisposeBag)

                }
</code></pre>
","1065307","","1180728","","2017-11-16 18:17:52","2017-11-16 18:17:52","Loop with RxSwift","<ios><swift><reactive-programming><rx-swift>","2","0","3","","","CC BY-SA 3.0"
"47335645","1","","","2017-11-16 17:20:47","","0","716","<p>I'm using the latest RxSwift library for reactive programming and facing a strange problem when debugging my code in Xcode 9.1!
I have a <code>collectionView</code> inside <code>tableView</code> header and bind <code>selectedItem</code> of <code>collectionView</code> to ViewModel variable to filter out section items. But when I change selected item of <code>collectionView</code> Xcode crashes and I can't figure out the problem! Is it related to libraries that I use or it's Xcode bug?</p>
","1225850","","","","","2017-11-18 10:42:43","Xcode 9 crashes when debugging in swift","<ios><swift><xcode><swift4><rx-swift>","1","2","","2017-11-21 08:20:09","","CC BY-SA 3.0"
"47359118","1","49336244","","2017-11-17 20:54:54","","3","454","<p>This might be a possible duplicate of <a href=""https://stackoverflow.com/questions/47335645/xcode-9-crashes-when-debugging-in-swift?newreg=c25e942212e14106a478d20becf5f58d"">Xcode 9 crashes when debugging in swift</a> however since I have a new account I can't comment over there. </p>

<p>I'm using XCode 9.1 (9B55) and RxSwift / RxCocoa 4.0.0</p>

<p>I'm trying to migrate my TableView code to RxSwift but every time my ViewController loads in the Simulator or on my device, XCode crashes along with the app.</p>

<p>The ViewController is set as my UIWindow's rootViewController so it's the first thing that loads in the app.</p>

<p>Here is my simplified ViewController:</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

struct DummyProfile {
    let name: String
    let vid: String
    let userName: String
}

class ProfilesCollectionViewController: UITableViewController {

    private let disposeBag = DisposeBag()

    let profileList = [
            DummyProfile(name: ""Test1"", vid: ""VIDASLKDHASKLDH"", userName: ""User""),
            DummyProfile(name: ""Test1adasidhaskljdhaskljdhaksldhjaskdha"", vid: ""VIDASLKDHASKLDH"", userName: ""User""),
            DummyProfile(name: ""86435543536543455324"", vid: ""VIDASLKDHASKLDH"", userName: ""fluigadshkljdhkldjsfgh ask jgfhaklseth kjahgkds"")
        ]

    override func viewDidLoad() {
        super.viewDidLoad()

        tableView.register(ProfileCell.self, forCellReuseIdentifier: ""ProfileCell"")
        tableView?.alwaysBounceVertical = true
        tableView?.backgroundColor = .lightGray

        Observable.just(profileList).bind(to: tableView.rx.items(cellIdentifier: ""ProfileCell"", cellType: ProfileCell.self)) { (_, model, cell) in
                cell.viewModel = model
            }.disposed(by: disposeBag)
    }
}
</code></pre>

<p>I don't think that the code for my ProfileCells is important since it's basically just a few UIViews and the AutoLayout stuff and everything is confirmed working when I don't use RxCocoa / RxSwift.</p>

<p>Here is one of the XCode Crash Reports. I don't have anything else to go on:</p>

<p><a href=""https://pastebin.com/MPpuGZym"" rel=""nofollow noreferrer"">https://pastebin.com/MPpuGZym</a></p>

<p>Am I doing something very wrong or is this a bug somewhere in my Toolchain?</p>
","8959824","","","","","2018-03-17 12:54:24","XCode crashes on deploying to Simulator when using RxCocoa","<ios><swift><xcode><rx-swift><rx-cocoa>","2","0","","","","CC BY-SA 3.0"
"47382906","1","","","2017-11-19 22:55:48","","4","5637","<p>I am observing UISearchBar.rx.text attributes to perform some search related Action when User types some text.
But at some time, I also would like to trigger this search Action programmatically. For instance at the creation of the view like in this example, where unfortunately the ""Searching for [...]"" text is not printed.</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class ViewController: UIViewController {
  @IBOutlet weak var mySearchBar: UISearchBar!

  let disposeBag = DisposeBag()

  override func viewDidLoad() {
    super.viewDidLoad()
    // Trigger search when text changes
    mySearchBar.rx.text.subscribe(onNext: { (text)
         print(""Searching for \(text)..."")
         // do some search Action
    }
    .disposed(by: disposeBag)

    // Programmatically trigger a search
    mySearchBar.text = ""Some text to search""
  }

}
</code></pre>

<p>The problem is changing mySearchBar.text does not trigger a new rx.text Event. Is there some way to do so?</p>

<p>For instance, I know thanks to <a href=""https://stackoverflow.com/questions/33815399/rxswift-uilabel-field-not-being-updated-when-uitextfield-updated-programmatica"">this post</a> that with an UITextField, this is possible using the UITextField.sendActions(for: .ValueChanged) function. Is there some similar way to do so with UISearchBar?</p>
","8968209","","","","","2019-05-14 15:15:38","RxSwift - trigger search programmatically in UISearchBar","<ios><swift><rx-swift><rx-cocoa>","3","0","","","","CC BY-SA 3.0"
"47400755","1","47407231","","2017-11-20 20:45:40","","2","1202","<p>I need to have <code>var isOn: Variable&lt;Bool&gt;</code> that is computed from 2 other Variables. How can I subscribe to value changes of the other Variables while being able to read latest value from my <code>isOn</code> Variable as well?</p>

<p>Below is the bad solution using 2 variables of type <code>Observable</code> and <code>Variable</code>. But I am looking for the correct solution, basically to merge my <code>isOn</code> and <code>isOnVariable</code> into single one.</p>

<pre><code>let from = Variable&lt;Date?&gt;(nil)
let to = Variable&lt;Date?&gt;(nil)

let isOnVariable = Variable&lt;Bool&gt;(false)
var isOn: Observable&lt;Bool&gt; {
    return Observable.combineLatest(from.asObservable(), to.asObservable()) { [weak self] to, from in
        switch (from, to) {
        case (.none, .none):
            self?.isOnVariable.value = false
            return false
        default:
            self?.isOnVariable.value = true
            return true
        }
    }
}
</code></pre>
","2081268","","","","","2017-11-21 22:19:02","RxSwift computed Variable combined from 2 other Variables","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"47446091","1","47451374","","2017-11-23 01:01:45","","3","754","<p>Hey I'm trying to get an UICollectionView, hosted by an UICollectionViewController working with RxCocoa and RxDataSources.</p>

<p>Everything works fine when I use an UIViewController, with an embedded UICollectionView.</p>

<p>But when I try to connect via the same logic:</p>

<pre><code>        self.vm.sections
        .bind(to: self.collectionView!.rx.items(dataSource: self.vm.data))
        .disposed(by: self.bag)
</code></pre>

<p>with an UICollectionView inside an UICollectionViewController, Xcode crashes completely. </p>

<p>Is there something I'm missing about RxDataSources, that you cannot use them with UICollectionViewController?</p>
","6831395","","","","","2018-02-22 10:34:27","Xcode crashes while adding RxDataSource to UICollectionView","<ios><swift><uicollectionview><rx-swift><rxdatasources>","3","1","1","","","CC BY-SA 3.0"
"47449056","1","47450618","","2017-11-23 06:37:28","","3","4230","<p>I have been working on RxSwift, I am using a <code>Variable</code> in RxSwift which is hooked(bind to) to <code>UICollectionView</code>. Now knowing that <code>Variable</code> extends from <code>Behavior Subjects</code> I had to create a <code>Variable</code> with some dummy initial value.</p>

<pre><code> var myArray = Variable&lt;[MyDataModel]&gt;([MyDataModel(data: ""{:}"")])
</code></pre>

<p><code>MyDataModel</code> is a struct that takes <code>json</code> as a init parameter.(As MyModel has nothing to with the question that follows am not posting the structure of it here)</p>

<p>Now, when I hook it to collectionView, I know that I should ignore the first signal emitted so I use <code>skip(1)</code></p>

<pre><code>myArray.asObservable().skip(1).bind(to: collectionView.rx.items(cellIdentifier: ""test"", cellType: MyCollectionViewCell.self){
        //cell implementation    
})
</code></pre>

<p>Though above code works, it solves the problem partially. Though the first change in the <code>value</code> of <code>myArray</code> is ignored, but when I append the actually data to <code>myArray</code> later using</p>

<pre><code>myArray.value.append(someNewData)
</code></pre>

<p>it emits the notification and unfortunately this time <code>myArray.value</code> has two values (dummy one I added while initializing and one that actually triggered <code>onNext</code>)</p>

<p>So as a work around, what I do is before blindly appending data to <code>myArray.value</code> I check if it has dummy object I added, if yes I remove it and add the actual object.</p>

<p>Though work around works, makes my code looks very ugly and non Rx in a way. I believe there must be a proper way to deal with it as it is a very fundamental problem working with <code>Variable</code>.</p>

<p>I would really appreciate your thoughts on the same.</p>
","5706328","","","","","2017-11-23 08:20:27","How to get rid of initial value of Variable in RxSwift","<ios><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"47450069","1","","","2017-11-23 07:46:21","","0","713","<p>so I set up a uipicker for my app, the code is as follows </p>

<pre><code>self.leftPicker.rx.setDelegate(self).disposed(by: bag)
        Driver.just([1, 2, 3, 4, 5, 6])
            .drive(leftPicker.rx.items){
                index, item, view in
                if let label = view as? UILabel{
                    return label
                }
                let label = UILabel()
                label.font = UIFont(name: SRFonts.asap_regular.fontName, size: 13)
                label.textAlignment = .center
                label.text = ""\(item)""
                return label
        }
        .disposed(by: bag)
</code></pre>

<p>if I do this, the app will crash, saying that there is a conflicting delegate... so if I am to remove </p>

<pre><code>self.leftPicker.rx.setDelegate(self).disposed(by: bag)
</code></pre>

<p>the crash is gone... </p>

<p>But the problem is that, I wish to set the height for the uipicker rows, without the delegate, I can't seem to set height in </p>

<pre><code>func pickerView(_ pickerView: UIPickerView, rowHeightForComponent component: Int) -&gt; CGFloat {
        return 44
    }
</code></pre>

<p>This is really weird, cuz it usually works for RxTableView and RxCollectionView. </p>

<p>Anyone knows what is wrong? </p>
","3971959","","","","","2017-11-23 09:28:52","RxSwift UIPicker crashes when setting delegate","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47452582","1","50111033","","2017-11-23 09:59:19","","67","39661","<p>As of RxSwift4, <code>Variable</code> is moved to <code>Deprecated.swift</code> marking the possible deprecation of <code>Variable</code> in future. An alternate proposed to <code>Variable</code> is <code>BehaviorRelay</code>. While posting this question, as I could not find much of the tutorial on web using <code>BehaviorRelay</code> am posting such a fundamental question here in SO.</p>

<p>Assume I have a webService call going on and I receive a chunk of data which is JSONArray, on parsing JSON object one by one I update my Variable's value property</p>

<p>Here is my variable declaration</p>

<pre><code>var myFilter = Variable&lt;[MyFilterModel]&gt;([MyFilterModel(data: ""{:}"")])
</code></pre>

<p>on getting a new element each time I would update my Variable as</p>

<pre><code>myFilter.value.append(newModel)
</code></pre>

<p>As Variable was bind to CollectionView, collectionVie would update its UI immediately with the newly added object.</p>

<p><strong>Issue with BehaviorRelay</strong></p>

<p>Now my declaration looks like</p>

<pre><code>var myFilter = BehaviorRelay&lt;[MyFilterModel]&gt;(value: [MyFilterModel(data: ""{:}"")])
</code></pre>

<p>But biggest issue is <code>myFilter.value</code> is <strong>readOnly</strong>. So obviously </p>

<pre><code>myFilter.value.append(newModel) 
</code></pre>

<p>is not a solution. I figured out that I can use <code>accept</code> rather.</p>

<p>But now when I try to parse each element in response and update the value of myFilter </p>

<pre><code>self?.expertsFilter.accept(newModel)
</code></pre>

<p>The above statement gives error quoting </p>

<blockquote>
  <p>Can not convert the value of NewModel to expected arguement type
  [NewModel]</p>
</blockquote>

<p>Obviously, its expecting a array and not a individual element. </p>

<p><strong>Workaround:</strong></p>

<p><strong>Solution 1:</strong></p>

<p>So one solution is accumulate all the response in a temporary array and once done trigger <code>self?.expertsFilter.accept(temporary_array)</code></p>

<p><strong>Solution 2:</strong></p>

<p>If I have to send <code>onNext</code> event to subscriber on parsing each element, I need to copy the value of self?.expertsFilter to new Array, add the newly parsed element to it and return the new array.</p>

<p><strong>Solution 3:</strong></p>

<p>Get rid of <code>BehaviorRelay</code> and use <code>BehaviorSubject</code>/<code>PublishSubject</code></p>

<p>First two sounds depressing, because there may be a need to trigger UI on parsing each element I cant wait till entire response is parsed. So obviously solution1 is not much of use.</p>

<p>Second solution is much more horrible because it creates a new array (I know its temporary and will be released) every time to send onNext event.</p>

<p><strong>Question:</strong></p>

<p>Because <code>BehaviorRelay</code> is proposed as a alternate to <code>Variable</code> am in dilemma, am using <code>accept</code> correctly?? Is there a better way to solve it? </p>

<p>Please help</p>
","5706328","","412916","","2019-08-23 11:20:45","2021-01-10 00:59:44","How to use BehaviorRelay as an alternate to Variable in RxSwift?","<rx-swift>","8","6","21","","","CC BY-SA 3.0"
"47455857","1","47459405","","2017-11-23 12:43:09","","0","524","<p>I'm new to all of this, so apologies if my RX terminology is a bit off.</p>

<p>So I would like to implement an observable which emits only once when a system callback is received.  Basically the idea is that by subscribing to this observable, it would be guaranteed that the system event has already occurred when the subscription closure is executed.  It may be executed immediately if the system event already happened, or it may be deferred until the event occurs, or never execute if the system callback is never executed.</p>

<p>It seems like a Single is a reasonable fit for the use-case, since it's intended to be a one-time observable which either succeeds or fails.  But it appears a completable's <code>success</code> callback can only be triggered from inside <code>Single.create {}</code>.  </p>

<p>I created a workaround by subscribing to a single inside the create closure, but it feels like a hack:</p>

<pre><code>class MyClass {

    private var systemCallbackSubject = AsyncSubject&lt;Bool&gt;()

    var isReady : Single&lt;Void&gt; {
        let single = Single&lt;Bool&gt;.create { single in
            self.systemCallbackSubject.subscribe(onCompleted: {
                single(.success(()))
            }, onDisposed: nil)
            return Disposables.create {}
        }
        return  single
    }

    func onSystemEventCallback() {
        systemCallbackSubject.onCompleted()
    }

}
</code></pre>

<p>Is there a better way to achieve this behavior?</p>
","814570","","","","","2017-11-23 15:58:46","Trigger a single from outside the create closure?","<rx-swift>","1","0","","","","CC BY-SA 3.0"
"47458203","1","","","2017-11-23 14:51:04","","0","587","<p>I have a product$ which is Variable&lt;[Product]>([]) and have a tableview with custom cell which has textfield. What I want is to update the cell when model change and when text of textfield change I want to update my model. Here what I did.</p>

<pre><code>products$.asObservable()
        .bind(to: self.tableViewCal.rx.items(cellIdentifier: ""edittingCell"")){ (row, product: Product, cell: CaloriesEdittingCell) in
            cell.lblContentName.text = self.products$.value[row].name ?? """"
            cell.textValue.text = ""\(self.products$.value[row].price ?? 0)""
            cell.textValue.rx.text
                .map({ value -&gt; Float in
                    return (value! as NSString).floatValue
                })
                .subscribe({value in
                    self.products$.value[row].price = value.element
                    print(product)
                }).disposed(by: self.bag)
        }.disposed(by: bag)
</code></pre>

<p>Obviously, It will stuck in loop. So What I did is I created a another tempProduct$ with same datatype and assign the values of product$ to tempProduct$. Here is the code</p>

<pre><code>tempProduct$.value = products$.value
tempProduct$.asObservable()
        .bind(to: self.tableViewCal.rx.items(cellIdentifier: ""edittingCell"")){ (row, product: Product, cell: CaloriesEdittingCell) in
            cell.lblContentName.text = self.products$.value[row].name ?? """"
            cell.textValue.text = ""\(self.products$.value[row].price ?? 0)""
            cell.textValue.rx.text
                .map({ value -&gt; Float in
                    return (value! as NSString).floatValue
                })
                .subscribe({value in
                    self.products$.value[row].price = value.element
                    print(product)
                }).disposed(by: self.bag)
        }.disposed(by: bag)
</code></pre>

<p>It works but If there is better solution then please let me know. Thanks in advance.</p>
","1201274","","","","","2017-11-23 17:34:42","Bind model and update cell with RxSwift and RxCocoa","<ios><iphone><swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47466268","1","47585896","","2017-11-24 04:12:19","","3","6135","<p>I would like to create an Observable from anyCollection that will emit each element one by one, after a delay. Also, onNext I would like to perform some updates to the item (model).</p>

<p>For example:</p>

<p>// Feed all dogs, one by one, with an interval of 5 seconds.</p>

<pre><code>class Dog {
    var name: String?
    var age: Int?
    var feeded = false

    init(_ name: String, _ age: Int){
        self.name = name
        self.age = age
    }
}

func feedDogs(){
    let dog1 = Dog(""Ren"", 3)
    let dog2 = Dog(""Bega"", 7)
    let dog3 = Dog(""Xuxu"", 11)
    let delay = 6 // seconds

    let allDogs = [dog1, dog2, dog3]

    // Observable....

    // Expected results after subscribe
    //   Start - &gt; 0 seconds
    // dog1.feeded // true
    //   time lapse -&gt; 6 seconds
    // dog2. feeded  // true
    //    timelapse -&gt; 12 seconds
    // dog3.feeded // true
}
</code></pre>

<p>I tried to use ""zip"" like ""zipWith"" (in RxJava), but it seems that in RxSwift is not supported.</p>
","4231708","","","","","2020-05-08 09:55:54","How to emit items, one by one, from Collection with a delay in RxSwift","<swift><rx-swift>","3","1","","","","CC BY-SA 3.0"
"47487202","1","","","2017-11-25 14:45:40","","1","442","<p>I use RxSwift at work (ont a big fan, too complex, but really powerful indeed), and I want to try to use PromiseKit as a ""smaller"" tool.</p>

<p>I try to create sort of an Observable with PromiseKit, but I can't figure it out. I tried to use the NSObject's extension observe(key path: String) -> Promise, but it does not seems to work.</p>

<p>I noted that I have a struct (hence does not inherit from NSObject) and I tried to observe an NSObject, but it does not seems to work.</p>

<p>Here's what I've done : </p>

<p>in my controller that has the value I want to observe, I declared a variable as follows : </p>

<pre><code>lazy var homeworkPromise: Promise&lt;Homework&gt; = self.observe(keyPath: ""homework"")
</code></pre>

<p>Somewhere in my code, I update the value of the homework variable.</p>

<p>And in my presentingVC, here's what I do : </p>

<pre><code>create.homeworkPromise
            .then(execute: { h -&gt; Void in
            print(h)
        })
</code></pre>

<p>It seems pretty straightforward to me, but I guess I'm missing something ;-)
Thanks for your help.</p>
","637438","","","","","2017-11-25 14:45:40","PromiseKit to act as RxSwift on variable observing","<ios><swift><key-value-observing><rx-swift><promisekit>","0","5","","","","CC BY-SA 3.0"
"47500092","1","","","2017-11-26 19:24:15","","0","591","<p>In my view controller I have a UISearchController associated with the UITableView.  So all my normal table view datasource methods do the old</p>

<pre class=""lang-swift prettyprint-override""><code>if isSearching {
    // use filteredTableData array
} else {
    // use SharedModel.shared.participants 
}
</code></pre>

<p>I'm not clear on how I'd implement that using RxCocoa as I'm brand new to Rx.</p>
","1455351","","","","","2017-12-07 12:24:23","RxSwift UITableView binding when also using a UISearchController","<uitableview><uisearchcontroller><rx-swift><rx-cocoa>","2","0","","","","CC BY-SA 3.0"
"47521572","1","","","2017-11-27 23:34:37","","0","59","<p>I need to be notified exactly at midnight.(I will execute a piece of code but that's besides the point). </p>

<p>How would I set this up in RxSwift? Is there a built in feature that I missed, or is this actually just a standard case of PublishSubject, 
and deciding when (midnight happens) to call next() on it is out of scope of RxSwift?</p>
","788100","","","","","2017-11-28 02:43:20","How can I observe a specific moment in time in RxSwift?","<ios><rx-swift>","1","1","","","","CC BY-SA 3.0"
"47552874","1","47553329","","2017-11-29 12:27:05","","0","141","<p><code>RxSwift</code> is a powerful feature, but sometimes I shoot myself in the leg.
The problem consist with <code>Resource count</code> and object deallocation.
I want to use <code>lazy var</code> for <code>CocoaAction</code> in View Model. It works fine in this flow:</p>

<pre><code>lazy var onCancel: CocoaAction = { [unowned self] _ in
    return CocoaAction {
        return self.coordinator.pop()
    }
}()
</code></pre>

<p><code>Controller</code> and <code>View Model</code> removed from the memory - nice!</p>

<p>The problem appear when I try to use external <code>self</code> value (object doesn't remove because action catch strong <code>reference</code> to <code>self</code>). How to avoid cycle here? </p>

<pre><code>lazy var onCancel: CocoaAction = { this in
    return CocoaAction {
        return this.coordinator.pop()
    }
} (self)
</code></pre>
","1278744","","1278744","","2017-11-29 12:32:33","2017-11-29 13:14:56","lazy CocoaAction without memory leak #2 way","<ios><action><rx-swift>","1","2","","","","CC BY-SA 3.0"
"47564810","1","","","2017-11-30 02:11:50","","0","760","<p>I can bind a <code>UITextField.rx.text</code> to a <code>Variable&lt;T&gt;</code>. This works fine when I'm into a ""creating"" screen. But, supposing I have a already created model and want to edit it on the same screen, how would I do that?</p>

<p>I've also seen a lot about infix operators represented by <code>&lt;-&gt;</code> operator. If I don't have this infix operator configured, I'll always have to do that amount of work to achieve two-way binding?</p>

<p>Here's my code</p>

<pre><code>struct TodoViewModel: CustomDebugStringConvertible {
    let title = Variable&lt;String?&gt;(""Initial title"")
    let description = Variable&lt;String?&gt;("""")
    let dueDate = Variable&lt;Date?&gt;(Date())
    let done = Variable&lt;Bool&gt;(false)

    var debugDescription: String {
        get {
            return
                """"""
                // ======
                Title: \(self.title.value ?? ""Nil"")
                Description: \(self.description.value ?? ""Nil"")
                Due Date: \(String(describing: self.dueDate.value))
                Done: \(self.done.value)
                """"""
        }
    }
}

// ViewController
class AddTaskTableViewController: UITableViewController {
    @IBOutlet weak var labelTitle: UILabel!
    @IBOutlet weak var txtTitle: UITextField!
    @IBOutlet weak var txtDescription: UITextField!
    @IBOutlet weak var txtDate: UITextField!
    @IBOutlet weak var switchDone: UISwitch!

    var todo = TodoViewModel()
    var disposeBag = DisposeBag()
    let dateFormatter = DateFormatter()

    override func viewDidLoad() {
        super.viewDidLoad()

        self.dateFormatter.locale = Locale(identifier: ""en-US"")

        // Configuring reactivity
        // Binds the UITextField's text value to my Model
        // let _ = self.txtTitle.rx.text.bind(to: self.todo.title).disposed(by: self.disposeBag)

        // ⬆⬇ Makes more sense they both being a two-way binding. This way I can edit and add items using the same screen.

        // Binds my model's title to the UITextView's text
        // let _ = self.todo.title.asObservable().bind(to: self.txtTitle.rx.text)
        let _ = self.txtDate.rx.text.map{ strDate in
            return self.dateFormatter.date(from: strDate!)
        }.bind(to: self.todo.dueDate).disposed(by: self.disposeBag)
        let _ = self.txtDescription.rx.text.bind(to: self.todo.description).disposed(by: self.disposeBag)
        let _ = self.switchDone.rx.isOn.bind(to: self.todo.done).disposed(by: self.disposeBag)

        let _ = self.todo.title.asObservable().bind(to: self.labelTitle.rx.text).disposed(by: self.disposeBag)
    }
}
</code></pre>
","1085977","","","","","2018-02-14 16:20:09","RxSwift - Two-way binding to use the same screen to edit and add model","<ios><swift><rx-swift><reactivex><rx-cocoa>","1","0","1","","","CC BY-SA 3.0"
"47615027","1","47618529","","2017-12-03 03:42:21","","5","8094","<p>I'm beginner in RXSwift, and i have problem with my code</p>

<p>I have code:</p>

<pre><code>let dartScore = PublishSubject&lt;Int&gt;()
            dartScore.asObservable()
                .scan(501) { intermediate, newValue in
                    let result = intermediate - newValue
                    return result &gt;= 0 ? result : intermediate
                }
                .do(onNext: {
                    if $0 == 0 {
                        dartScore.onCompleted()
                    }
                })
                .subscribe({
                    print($0.isStopEvent ? $0 : $0.element!)
                })
                .disposed(by: disposeBag)

            dartScore.onNext(13)
            dartScore.onNext(50)
            dartScore.onNext(60)
            dartScore.onNext(378)
</code></pre>

<p>And i get error:</p>

<blockquote>
  <p>⚠️ Reentrancy anomaly was detected. ⚠️</p>
  
  <p>Debugging: To debug this issue you can set a breakpoint in /****RxSwift/RxSwift/Rx.swift:97 and observe the call stack.</p>
  
  <p>Problem: This behavior is breaking the observable sequence grammar. <code>next (error | completed)?</code>
      This behavior breaks the grammar because there is overlapping between sequence events.
      Observable sequence is trying to send an event before sending of previous event has finished.</p>
</blockquote>

<p>why i can't do "".onCompleted()"" inside .do(onNext), and what should i do to avoid the warning?</p>

<p>I'm using XCode 9.0, swift 4, RXSwift 4.0.0</p>

<p>Thank you</p>

<p>Best Regards</p>
","4476665","","","","","2017-12-03 12:50:16","RXSwift, Reentrancy anomaly was detected","<swift><xcode><system.reactive><rx-swift>","1","3","","","","CC BY-SA 3.0"
"47636045","1","","","2017-12-04 14:54:29","","4","4222","<p>I intend to add a UIView instance onto ViewController's view and observe the change of it's frame/bound. But the difference between <code>frame</code> and <code>bounds</code> confused me, code in <code>viewDidLoad</code> like below:</p>

<pre><code>let v = UIView()
view.addSubview(v)
v.snp.makeConstraints { (make) in
    make.edges.equalToSuperview()
}

v.rx.observe(CGRect.self, #keyPath(UIView.frame))
    .subscribe(onNext: { print(""frame: \($0!)"") })
    .disposed(by: rx.disposeBag)
v.rx.observe(CGRect.self, #keyPath(UIView.bounds))
    .subscribe(onNext: { print(""bounds: \($0!)"") })
    .disposed(by: rx.disposeBag)
</code></pre>

<p>the default option of <code>observe</code> method is <code>[.new, .initial]</code> and it will log out like this:</p>

<pre><code>frame: (0.0, 0.0, 0.0, 0.0)
bounds: (0.0, 0.0, 0.0, 0.0)
bounds: (0.0, 0.0, 375.0, 667.0)
</code></pre>

<p>So why <code>bounds</code> could emit the initial and new value but <code>frame</code> only the initial value?</p>
","1349161","","1349161","","2017-12-04 15:12:09","2017-12-04 15:12:09","RxSwift observe frame vs bounds","<ios><swift><rx-swift><frp>","0","10","2","","","CC BY-SA 3.0"
"47640412","1","47652543","","2017-12-04 19:16:35","","2","2027","<p>I started using <code>RxSwift</code> in my iOS project and I have a <code>UITableView</code> with a custom <code>UITableViewCell</code> subclass. Within that subclass, I have a <code>UICollectionView</code>.</p>

<p>Populating the <code>tableview</code> using <code>RxSwift</code> works pretty flawlessly, I'm using another extension of <code>RxSwift</code> for that (<a href=""https://github.com/RxSwiftCommunity/RxDataSources"" rel=""nofollow noreferrer"">RxDataSources</a>)</p>

<p>Here's how I'm doing it:</p>

<pre><code>    self.dataSource = RxTableViewSectionedReloadDataSource&lt;Section&gt;(configureCell: {(section, tableView, indexPath, data)  in
        let cell = tableView.dequeueReusableCell(withIdentifier: ""Cell"", for: indexPath) as! TableViewCellWithCollectionView

        switch indexPath.section {
        case 0:
            cell.collectionViewCellNibName = ""ContactDataItemCollectionViewCell""
            cell.collectionViewCellReuseIdentifier = ""contactDataItemCellIdentifier""
        case 1, 2:
            cell.collectionViewCellNibName = ""DebtCollectionViewCell""
            cell.collectionViewCellReuseIdentifier = ""debtCellIdentifier""
        default:
            break
        }
        cell.registerNibs(indexPath.section, nativePaging: false, layoutDirection: indexPath.section != 0 ? .horizontal : .vertical)

        let cellCollectionView = cell.collectionView!

        data.debts.asObservable().bind(to: cellCollectionView.rx.items(cellIdentifier: ""debtCellIdentifier"", cellType: DebtCollectionViewCell.self)) { row, data, cell in
            cell.setup(debt: data)
        }


        return cell

    })
</code></pre>

<p>This actually works. But the problem arises when a <code>tableview</code> cell gets scrolled off the screen and reappears. This triggers the code block from above and lets the app crash when</p>

<pre><code>    data.debts.asObservable().bind(to: cellCollectionView.rx.items(cellIdentifier: ""debtCellIdentifier"", cellType: DebtCollectionViewCell.self)) { row, data, cell in
        cell.setup(debt: data)
    }
</code></pre>

<p>is invoked twice on the same tableview cell (The funny thing is, even Xcode crashes without any trace).</p>

<p>What can I do to avoid this?</p>

<p>EDIT:</p>

<p>I have found a solution, but I must admit that I'm not really happy with it... Here's the idea (tested and works)</p>

<p>I define another <code>Dictionary</code> in my class:</p>

<pre><code>var boundIndizes = [Int: Bool]()
</code></pre>

<p>and then I make an <code>if</code> around the binding like this:</p>

<pre><code>if let bound = self.boundIndizes[indexPath.section], bound == true {
    //Do nothing, content is already bound
} else {
    data.debts.asObservable().bind(to: cellCollectionView.rx.items(cellIdentifier: ""debtCellIdentifier"", cellType: DebtCollectionViewCell.self)) { row, data, cell in
        cell.setup(debt: data)
        }.disposed(by: self.disposeBag)
    self.boundIndizes[indexPath.section] = true
}
</code></pre>

<p>But I cannot believe there is no ""cleaner"" solution</p>
","2139309","","2139309","","2017-12-04 19:49:50","2017-12-05 11:28:32","UITableViewCell containing a UICollectionView using RxSwift","<ios><swift><uitableview><uicollectionview><rx-swift>","1","2","0","","","CC BY-SA 3.0"
"47664094","1","","","2017-12-05 23:01:02","","1","578","<p>I've just started looking at RxSwift and am a beginner.  Is there a way to observe changes to individual elements within an array?  I have an object that stores an array of Item objects and I would like to be notified when any of the properties of the Item objects change.  So far I have this:</p>

<pre><code>struct Item {
  var dayOfTheWeek = Variable&lt;Int&gt;(1)

  init(dayOfTheWeek: Int) {
    self.dayOfTheWeek.value = dayOfTheWeek
  }
}

class ItemListener {
  var items = Variable&lt;[Item]&gt;([])
  var itemsUpdated: Observable&lt;[Item]&gt;

  init() {
    self.itemsUpdated = items.asObservable()
  }

  func queue(item: Item) {
    self.items.value.append(item)

    self.itemsUpdated.subscribe(onNext: {
        $0.forEach{
            print(""dayOfTheWeek \($0.dayOfTheWeek.value)"")
        }
    })
  }
}
</code></pre>

<p>If I then do this</p>

<pre><code>let itemListener = ItemListener()
var item = Item(dayOfTheWeek: 5)
itemListener.queue(item: item)
</code></pre>

<p>It will observe any items added to the array.  Once an item has been added to the array, how would I observe changes to the state of each item <em>in</em> the array?  If I update the dayOfTheWeek on the item in the array, how would ItemListener get this notification that the dayOfTheWeek changed on the item?</p>

<pre><code>item.dayOfTheWeek = 2  // ItemListener wants to get notified of this update
</code></pre>
","6902806","","","","","2017-12-05 23:01:02","RxSwift: Observing changes to items stored in an array","<swift><rx-swift>","0","1","","","","CC BY-SA 3.0"
"47697673","1","","","2017-12-07 14:49:39","","0","138","<p>i'm new to the world of swift and rxSwfit, and i'm asking for suggestions or criticism with this current solution for example, for syncing blog posts, categories, authors or whatever we need.</p>

<p>Take this classic situation: an observable which gives to every subscriber the last updated data present in the model, and since that moment on, for every synchronization of the model, it emits the new whole pack of data, so the subscribers get and operate on the updated data.</p>

<p>I built an observable who's next value is the combination of his current value (the data present in ram) with the value grabbed from the rest.</p>

<p>Take for the example, the posts:</p>

<pre><code>let articoli2       = BehaviorSubject&lt;[Articolo]&gt;(value: [Articolo]()) // ram data, initially empty
var articoli_rest   = PublishSubject&lt;[Articolo]&gt;()  // net data
var idx_articoli2   = [Int:Articolo]()   // used for filtering duplicates 
</code></pre>

<p>Then i create the subscription which updates ""articoli2""</p>

<pre><code>Observable.zip(articoli2, articoli_rest) { (ram_articoli, rest_articoli) -&gt; [Articolo] in
            var new_articoli = ram_articoli

//Code that merges the data currently present (ram_articoli) 
//with the data grabbed from the net (rest_articoli)
...     
            return new_articoli
            }.subscribe(onNext: { (articoli) in
                self.articoli2.onNext(articoli)

            }).disposed(by: disposeBag)
</code></pre>

<p>Finally, when i want to update the model, i use:</p>

<pre><code>func sync_articoli()
{
        get_rest_array(Articolo.self,""https://rest_route"").retry(4)
            .subscribe(onNext: { (articoli) in
                    self.articoli_rest.onNext(articoli)
}
</code></pre>

<p>This function subscribes to the single observable returned by get_rest_array
an when the data from the net is ready, it emits an item on articoli_rest
which in turn updates my articoli2.
The whole thing works but i'm not sure it's really usable and I'm not confident in my solution. Any words? ( blame as much you want )</p>
","7855933","","","","","2017-12-07 17:53:06","Syncing Model with bare RxSwift and BehaviourSubject","<swift><synchronization><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47710940","1","","","2017-12-08 09:07:52","","0","1151","<p>I'm subscribing an UITableViewCell to an Observer in order to handle changes to that cell (I'm currently doing this at:</p>

<pre><code>tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell
</code></pre>

<p>Problem I have is as the cell on any kind of reload is then re-subscribed and anytime I do an ""onNext"" the observer is fired multiple times.</p>

<p>Is there anyway to stop a particular Observer from being subscribed multiple times?</p>

<p>I've attempted to keep a list of Cells that have been subscribed and stop them from re-subscribing - but this seems to cause other issues further down the line (and doesn't feel like the right solution)</p>
","1910305","","","","","2017-12-08 18:57:20","RxSwift - Stop duplicate subscribes to an observer","<ios><swift><uitableview><rx-swift>","1","2","","","","CC BY-SA 3.0"
"47743717","1","","","2017-12-10 21:36:49","","1","1037","<h2>Problem</h2>
<p>I am trying to load all of the data my application needs before using. Once I have all of the data I want to emit one event back to my subscription in my controller with either a success or failure status.</p>
<p>I am struggling to come up with a way to send an onComplete status on my observable chain so I can use <code>toArray()</code>. Maybe there's a way or just a better approach that I have not thought of.</p>
<h2>Loading Workflow</h2>
<p>Basically I have three different services: version, champion, and skin.</p>
<p>I retrieve the latest version and get all of the champions for that version. Then I download all of the images for each skin the champion has.</p>
<h2>Observable Chain</h2>
<p>My observable chain in my LoadingViewModel is something like this:</p>
<pre><code>return versionService.getLatest().flatMap({ (version: VersionData) in
    return championService.getChampions(forVersion: version)
}).flatMap({ (champions: [Champion]) -&gt; Observable&lt;Champion&gt; in
    // Go through champions and update total skin count
    // emit each champion
}).flatMap({ (champion: Champion) -&gt; Observable&lt;Skin&gt; in
    return skinService.getSkin(forChampion: champion)
}).toArray() // Doesn't work since I don't send complete
.flatMap({ (result: [Skin]) -&gt; Observable&lt;LoadingViewModelResult&gt; in
    return Observable.just(LoadingViewModelResult.success)
})
</code></pre>
<p>If I don't have the toArray() there then I emit a <code>LoadingViewModelResult.success</code> for each skin which floods my view controller with an abundance of unwanted successful results.</p>
<h3>What I've Tried</h3>
<p>I attempted to use <code>.take(count)</code> where I passed in the skin count but since it is initialized to 0 the chain will instantly take 0 and return.</p>
","2505444","","-1","","2020-06-20 09:12:55","2017-12-10 23:46:56","RxSwift: Completing observable sequence of unknown length","<swift><observable><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47746033","1","","","2017-12-11 03:29:06","","3","1212","<p>I want to cancel the previous request using RxAlamofire.<br>
But I don't know where to call the cancel function.<br>
I have a searchBar, and I call the API in function ""textdidchange"".<br>
So, I want to cancel the previous request and call the API with new parameters.<br> 
Have any suggestion to help me?<br>
Thanks.<br></p>

<pre><code>func request(_ method: Alamofire.HTTPMethod, url:String, params:[String:Any] = [:], callback: @escaping (JSON) -&gt; Void) {

    var headers:[String:String] = [String:String]()
    if token.isEmpty == false {
        headers[""Authorization""] = ""Bearer \(token)""
    }

    let configuration = URLSessionConfiguration.default
    configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders
    configuration.timeoutIntervalForRequest = 10.0

    _ = SessionManager(configuration: configuration)
        .rx.responseJSON(method,
                         url,
                         parameters: params,
                         encoding: ((method == .get) ? URLEncoding.default : JSONEncoding.default),
                         headers: headers)
        .subscribeOn(SerialDispatchQueueScheduler.init(qos: .background))
        .subscribe(onNext: { (r, data) in

            let json = JSON(data)

            if json[""status""].stringValue == ""success"" {

                callback(json[""responseData""])

            }else {

                callback(json)
            }
        }, onError: { (error) in

            callback(JSON(error))

        })
        .addDisposableTo(ResfulAPIDisposeBag)
}
</code></pre>
","7941494","","7941494","","2017-12-11 06:22:56","2019-02-19 09:37:35","How to cancel previous request using RxAlamofire?","<ios><swift><alamofire><rx-swift><rxalamofire>","2","5","1","","","CC BY-SA 3.0"
"47769382","1","","","2017-12-12 09:40:08","","1","1451","<p>I'm trying to observe a Variable and when some property of this variable fits a condition, I want to make an ""observable"" API call and bind the results of that call with some UI element. It is working the way I present it here, but I'm having the thought that it could be implemented way better, because now I'm nesting the subscription methods:</p>

<pre><code>self.viewModel.product
    .asObservable()
    .subscribe { [weak self](refreshProduct) in

        self?.tableView.reloadData()
        self?.marketProduct.value.marketProduct = refreshProduct.element?.productId

        if refreshProduct.element?.stockQuantity != nil {

            self?.viewModel.getUserMarketCart()
                .map({ (carts) -&gt; Bool in
                    return carts.cartLines.count &gt; 0
                }).bind(onNext: { [weak self](isIncluded) in
                    self?.footerView.set(buyable: isIncluded)
                }).disposed(by: (self?.disposeBag)!)
        }
    }.disposed(by: disposeBag)
</code></pre>

<p>Is there any other way to do this? I can get a filter on the first observable, but I don't understand how I can call the other one and bind it on the UI. </p>

<p><em>NOTE: I excluded a few other lines of code for code clarity.</em></p>
","1521588","","","","","2017-12-14 13:32:07","How to conditionally observe and bind with RxSwift","<ios><swift><ios11><rx-swift>","1","3","","","","CC BY-SA 3.0"
"47772369","1","47830699","","2017-12-12 12:13:53","","0","1964","<p>What is the best way to handle tap gesture of <code>UIButton</code> in <code>UITableViewCell</code> when working with <code>RxSwift</code> and MVVM pattern? Should I bind it to a variable in <code>viewModel</code>?</p>
","1225850","","","","","2017-12-18 00:49:50","Binding UIButton tap gesture in UITableViewCell to observable in viewModel","<ios><swift><rx-swift>","1","1","1","","","CC BY-SA 3.0"
"47781271","1","47796042","","2017-12-12 20:47:17","","0","129","<p>Given an observable that emits strings every one second, I need another observable that gathers those elements and emits a full list each second.</p>

<pre><code>func oneAtATime() -&gt; Observable&lt;String&gt; {
    return Observable.create{ observable in
        DispatchQueue.global().async {
            let main = DispatchQueue.main

            for i in 0..&lt;10 {

                sleep(1)

                main.async{
                    observable.onNext(""Element\(i)"")
                }
            }

            main.async{
                observable.onCompleted()
            }
        }

        return Disposables.create()
    }
}
</code></pre>

<p>This is what I have at the moment:</p>

<pre><code>let oneEverySecond = oneAtATime()

var accEverySecond : Observable&lt;[String]&gt; = oneEverySecond.reduce([],accumulator: +)
</code></pre>

<p>Where + is a function that inserts an element in an array.</p>

<p>The problem is that I am seeing the full list of elements <strong>only after completion. I am not receiving a new list every second.</strong></p>

<p>Any thoughts?</p>
","183952","","","","","2017-12-14 04:17:33","How to transform an observable (A) that emits each second, into an observable that emits a list of elements by A each second","<reactive-programming><rx-swift><reactive>","2","0","","","","CC BY-SA 3.0"
"47786712","1","","","2017-12-13 06:17:15","","0","1951","<p>I have a getting API request function.<br>
I also have a searchBar to search server Data.<br>
And I want to cancel the previous request when user input every characters.<br>
I search the keywords ""flatMapLatest"".
But I don't know how to using ""flatMapLatest"" to cancel previous request in my case.<br>
I try but I failed.<br>
Have any suggestion to me?<br>
Thanks.<br></p>

<pre><code>func requestTest(_ method: Alamofire.HTTPMethod, url:String, params:[String:Any] = [:], callback: @escaping (JSON) -&gt; Void) {

    var headers:[String:String] = [String:String]()
    if user.token.isEmpty == false {
        headers[""Authorization""] = ""Bearer \(user.token)""
    }

    let configuration = URLSessionConfiguration.default
    configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders
    configuration.timeoutIntervalForRequest = timeout

    _ = SessionManager(configuration: configuration)
        .rx.responseJSON(method,
                         url,
                         parameters: params,
                         encoding: ((method == .get) ? URLEncoding.default : JSONEncoding.default),
                         headers: headers)
        .subscribeOn(SerialDispatchQueueScheduler.init(qos: .background))
        .flatMapLatest({ (&lt;#(HTTPURLResponse, Any)#&gt;) -&gt; ObservableConvertibleType in
          //I fail to get request.
        })
        .subscribe(onNext: { (r, data) in

            let json = JSON(data)

            if json[""status""].stringValue == ""success"" {

                callback(json[""request""])       
            }
            else {
                callback(json)
            }
        }, onError: { (error) in

            callback(JSON(error))
        })
        .addDisposableTo(DisposeBag)
}
</code></pre>
","8169327","","","","","2017-12-13 15:55:27","How to using RxSwift to cancel the previous request","<ios><swift><alamofire><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"47830829","1","47831877","","2017-12-15 10:54:04","","11","6130","<p>Can I raise an error from a map function or do I need to use flatMap? The error should be reported to onError. In RxJava I can simply throw an exception.
How can I do the following (pseudo-)code</p>

<pre><code>observable.map( value -&gt; {if (value.isIllegal) raiseError else return value.count})
</code></pre>

<p>Obviously it is possible using a flatMap, but I am looking for a map solution.</p>
","3569080","","1113632","","2018-01-29 13:11:27","2018-01-29 13:11:27","Can I raise an Error from rxSwift map-Function","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47846932","1","","","2017-12-16 15:00:38","","1","1007","<p>I have a <code>UITextField</code> and would like to perform an action everytime it's focused. Is this something that RxSwift can manage or I would have to do so in the old way?</p>
","1085977","","","","","2017-12-17 13:23:24","RxSwift - Verifying if text field is focused","<ios><swift><reactive-programming><rx-swift><reactivex>","1","2","","","","CC BY-SA 3.0"
"47852762","1","","","2017-12-17 06:29:45","","0","227","<p>I follow this <a href=""https://github.com/RxSwiftCommunity/RxDataSources/blob/master/Example/Example4_DifferentSectionAndItemTypes.swift"" rel=""nofollow noreferrer"">sample</a> and successfully created multi-section <code>tableView</code>, but how can I append items to one of this sections? I can recreate the section but I want to append items instead of reloading <code>tableView</code>.</p>
","1225850","","","","","2018-01-30 12:20:16","Append items to MultipleSectionModel","<ios><swift><rx-swift><rxdatasources>","1","2","","","","CC BY-SA 3.0"
"47856898","1","","","2017-12-17 16:03:07","","0","56","<p>How can observe a <code>Variable&lt;[Game]&gt;</code> from an array of teams (<code>Variable&lt;[Team]&gt;</code>) so that every time a <code>Game</code> comes up (<code>Variable&lt;[Game]&gt;</code> changes since the games array is modified), the array of <code>Team</code> should be updated accordingly, such as assigning points, victories, draw, defeats, and netGoals for the two teams involved in the game? </p>

<p>I have tried using <code>subscribe(onNext:)</code> but as I read, view models should not contain these kind of things as <code>DisposeBag</code>s. Since I am new to RxSwift, how can I observe changes in a <code>Variable&lt;[Game]&gt;</code> from a <code>Variable&lt;[Team]&gt;</code>?</p>
","6096029","","6096029","","2017-12-17 19:43:56","2017-12-19 20:16:25","How to observe Variable<[Game]> from another Variable<[Team]>?","<ios><iphone><swift><rx-swift><rx-cocoa>","1","4","","","","CC BY-SA 3.0"
"47860635","1","","","2017-12-18 00:01:40","","1","1347","<p>I have main <code>UITableView</code> with some Todos that are populated used an array of Observables:</p>

<pre><code>// on viewDidLoad
self.todosViewModel.todos.asObservable()
    .bind(to: tableView.rx.items(cellIdentifier: ""TodoViewCell"", cellType: TodoTableViewCell.self)) { (row, todo, cell) in
        cell.status.image = todo.getStatusImage()
        cell.title.text = todo.title.value
        cell.todoDescription.text = todo.description.value
        cell.dueDate.text = String(describing: Utilities.dateFormatter.string(from: todo.dueDate.value))
}.disposed(by: disposeBag)
</code></pre>

<p>On another screen I can add/edit the data and then, click ""save"" button to append a new todo or modify the one being edited. This works great, except that the <code>tableView</code> don't reload automatically, forcing me to call <code>tableView.reloadData()</code> on <code>viewDidAppear</code>, which is triggered when the other screen is dismissed.</p>

<p>So,</p>

<p><strong>Is there a native way for me to reload a table automatically when then <code>todosViewModel</code> variable is updated</strong>?</p>

<p><strong>EDIT:</strong></p>

<p>If on the screen of edition of the todo I reassociate the <code>todosViewModel</code>'s <code>value</code> property with the same value, it also works:</p>

<pre><code>self.todosViewModel.todos.value = self.todosViewModel.todos.value
</code></pre>

<p>That's pretty ugly, but I only know how to reload a tableView using one of those ways.</p>
","1085977","","1085977","","2017-12-18 00:07:23","2017-12-19 14:04:45","RxSwift - auto reloading UITableView initialized with Observable","<ios><uitableview><reactive-programming><rx-swift><reactivex>","1","2","1","","","CC BY-SA 3.0"
"47878603","1","","","2017-12-19 00:56:43","","0","2166","<p>I have the following code in my <code>UIViewController</code>:</p>

<pre><code>  _ = viewModel.selectedCountryId.asObservable()
       .distinctUntilChanged()
        .scan((0, 0), accumulator: { (prev, curr) in
            return zip(prev, curr)
        })
        .subscribe(onNext: {
            let prevCell = self.tableView.cellForRow(at: IndexPath(row: previous, section: 0))
            prevCell?.accessoryType = .none
            let currCell = self.tableView.cellForRow(at: IndexPath(row: curr, section: 0))
            currCell?.accessoryType = .checkmark
        }).disposed(by: disposeBag)`
</code></pre>

<p>I don't know what to do on <code>scan</code> which I believe to be the solution by looking into some SO posts. </p>

<p>What I want to achieve is selecting a row and deselecting the previous one so as to make the tableview have the single selection mechanism with the checkmark icon on the right. </p>

<p>I use a <code>Variable&lt;Int&gt;</code> from the viewModel because I need to save which row I selected to pass it to another view controller after making some operations. </p>

<p>If anything is incorrect, please give some recommendation. I am still a beginner in MVVM e RxSwift.</p>

<p><strong>EDIT</strong>:</p>

<p>Here is the subscription when an item is selected: </p>

<p><code>_ = tableView.rx.itemSelected.subscribe(onNext: { [weak self] indexPath in
            self?.viewModel.selectedCountryId.value = indexPath.row
        })
</code></p>
","6096029","","","","","2017-12-19 14:53:55","How to observe previous and current value in RxSwift for UITableView tap/selection?","<ios><iphone><swift><uitableview><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47880673","1","47881234","","2017-12-19 05:44:37","","-1","227","<p>Suppose I have an <code>var id = Variable&lt;Int&gt;(0)</code>. I want to observe changes to it from another Variable or Observable called team (<code>var team = Observable&lt;Team&gt;</code>). the team observable will be observed by the view controller and will update the UI there. Therefore, the id variable serves only to create/update (through creating <code>Team(id: id)</code> ) the value of the team observable.</p>

<p>I have been trying multiple approaches such as <code>combineLatest</code> or <code>subscribe</code> but I always get compile error saying:</p>

<blockquote>
  <p>Closure cannot implicitly capture a mutating self parameter</p>
</blockquote>

<p>What's going on?</p>
","6096029","","1226963","","2017-12-19 05:46:45","2017-12-19 06:34:17","How to observe a Variable from another Variable or Observable?","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 3.0"
"47887965","1","","","2017-12-19 13:20:29","","0","617","<p>I have a simple ViewModel:</p>

<pre><code>struct ViewModel {
    var someText = Variable&lt;String&gt;("""")

    func foo() -&gt; Observable&lt;String&gt; {
        return someText.asObservable()
    }
}
</code></pre>

<p>In the ViewController, viewModel is the instance variable, and someTextField is a UITextField with IBOutlet connected properly</p>

<pre><code>var viewModel = ViewModel()
@IBOutlet weak var someTextField: UITextField!
</code></pre>

<p>Then in viewDidLoad() of the ViewController, I set things up and do the following:</p>

<pre><code>someTextField.rx.text.map { $0 ?? """" }.bind(to: viewModel.someText)

let disposeBag = DisposeBag()
let observable = viewMode.foo()
observable.subscribe(onNext: { data in
            print(data)
        }, onError: { error in
            print(error)
        }, onCompleted: {
            print (""complete"")
        }, onDisposed: {
            print(""disposed"")
        }).disposed(by: disposeBag)
</code></pre>

<p>As I enter characters in the textfield, I expect print() to print out these characters. But print() is only invoked once in the debugger (and not subsequently when text field receives input)</p>

<p>What is wrong?</p>
","1244013","","1113632","","2018-01-29 13:33:08","2018-01-29 13:33:08","RxSwift Variable (Behavior Subject) does not emit signals","<swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"47896868","1","","","2017-12-19 23:48:02","","0","347","<p>So the code below compiles with the errror</p>

<pre><code>var doneSubscription: Disposable = item.doneSubjectObservable
        .debug(""doneSubscriptions"")
        .subscribe(
            onNext: {
                done in self.validateDone(done: done, item: item)
        }).disposed(by: disposeBag)
</code></pre>

<blockquote>
  <p>Value of type '()' does not conform to specified type 'Disposable' 
  on the line .disposed(by: disposeBag)</p>
</blockquote>

<p>But I can do this without error:</p>

<pre><code>var doneSubscription: Disposable = item.doneSubjectObservable
        .debug(""doneSubscriptions"")
        .subscribe(
            onNext: {
                done in self.validateDone(done: done, item: item)
        })

    doneSubscription.disposed(by: disposeBag)
</code></pre>

<p>All I've done is moved <code>.disposed(by: disposeBag)</code> out of the subscription chain.  </p>

<p>Am I missing something, aren't these two approaches equivalent?</p>
","6902806","","","","","2017-12-20 00:01:42","RxSwift: disposed(by:) weirdness","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"47904049","1","","","2017-12-20 10:37:01","","1","542","<p>I'm using RxAlamofire for downloading file. I have something like this:</p>

<pre><code>let downloadResult = download(request, to: destination)
</code></pre>

<p>Unfortunately downloadResult observable doesn't emit next event on download completed, it only emits onCompleted. </p>

<p>I need next event when download is finished to flatMap to next request. At the moment I'm basing on progress (download progress >= 1) to emit the event I'm interested in.</p>

<p>But I feel that it's not the best solution, for now it works, however I'm afraid this aproach may fail in some situation.</p>

<p>Can you suggest something? Do I miss something in RxAlamofire download api?</p>
","3077831","","","","","2017-12-29 10:24:21","RxAlamofire - event on download completed missing","<ios><swift><alamofire><rx-swift><rxalamofire>","1","0","1","","","CC BY-SA 3.0"
"47906030","1","47906503","","2017-12-20 12:24:06","","4","5356","<p>Assume I have array of Ints: </p>

<pre><code>var items = [1, 2, 3, 4, 5]
</code></pre>

<p>and a function that takes Int argument and basing on it sends network request:</p>

<pre><code> func sendRequest(argument: Int) -&gt; Observable&lt;Void&gt; {
    // sends network request
    ...
 }
</code></pre>

<p>I want to send network requests for each element of items array, but I want to do it sequentially, send next request only once previous one is finished.</p>

<p>My first attempt was something like this:</p>

<pre><code>let observables = items.map{ [weak self] argument in (self?.sendRequest(argument: argument) ?? Observable.empty()) }

let result = Observable.concat(observables)
</code></pre>

<p>This approach however sends request simultaneously and only combine the results sequentially. </p>

<p>My second approach:</p>

<pre><code>let items = [1, 2, 3, 4, 5]

var result = Observable.just(Void())

for item in items {
    result = result.flatMap{ [weak self] in  
        self?.sendRequest(argument: item) ?? Observable.empty() 
    }
}
</code></pre>

<p>It seems to work, but obviously result emits next element only once all network requests finish. </p>

<p>What I would need is sending requests sequentially with result observable that emits next event once each single request is finished. </p>

<p>Any suggestions?</p>
","3077831","","4831524","","2017-12-20 12:33:01","2018-02-15 12:50:00","RxSwift - how to chain observables sequentially","<ios><iphone><swift><observable><rx-swift>","1","0","3","","","CC BY-SA 3.0"
"47993820","1","48006771","","2017-12-27 14:24:26","","1","1003","<p>I was recently trying to parse JSON to a model using Decodable protocol, and I have done that successfully. But now I want to implement bi-directional binding using RxSwift. For that I need to declare variables of type 'Variable&lt;>'.Here is a snippet from my model:</p>

<pre><code>struct Person : Decodable
{
    var batchcomplete = String()
    var `continue` = Continue()
    var query = Query()
    var limits = Limit()

    enum CodingKeys: String,CodingKey
    {
        case batchcomplete
        case `continue`
        case limits
        case query
    }

    init(from decoder: Decoder) throws
    {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        batchcomplete = try container.decode(String.self, forKey: .batchcomplete)
        `continue` = try container.decode(Continue.self, forKey: .`continue`)
        limits = try container.decode(Limit.self, forKey: .limits)
        query = try container.decode(Query.self, forKey: .query)
    }
}
</code></pre>

<p>Now if I change my 'batchcomplete' from String() to Variable,the init() method throws an error:</p>

<pre><code>No 'decode' candidates produce the expected contextual result type 'Variable&lt;String&gt;'.
</code></pre>

<p>Make these changes and you will get the error.</p>

<pre><code>var batchcomplete = Variable&lt;String&gt;("""")
batchcomplete = try container.decode(Variable&lt;String&gt;.self, forKey: .batchcomplete)
</code></pre>
","3972195","","","","","2017-12-28 11:37:32","Using swift 4 Decodable protocol with RxSwift","<json><protocols><swift4><rx-swift><decodable>","1","0","","","","CC BY-SA 3.0"
"47994787","1","47995747","","2017-12-27 15:35:14","","1","524","<p>I have speed observer that looks like this (it is simple version to describe problem):</p>

<pre><code>class SpeedManager {
    var speed = Variable(0.0)
    private var limit = 0.2

    func speedObserver() -&gt; Observable&lt;Bool&gt; {
        return speed.asObservable().map{$0 &gt;= self.limit}
    }
}
</code></pre>

<p>What I do I just validate speed if limit is reached.</p>

<p>So I receive this kind of stream:</p>

<h2>false----->true----->false----->true----->true----->true----->true</h2>

<p>Than I do this:</p>

<pre><code>let speedManager = SpeedManager()

let observable = speedManager.speedObserver().distinctUntilChanged()
</code></pre>

<p>Where <code>observable</code> will retrun this kind of stream: </p>

<h2>false----->true----->false----->true----->false-----> true----->false</h2>

<p>So I just need to add step that will validate if <code>observable</code> event is <code>true</code> and it is true during 10 seconds.</p>

<p>Basically if <code>observable</code> next event is <code>true</code> I should wait 10 seconds to validate if next event would not be <code>false</code>.</p>
","1213285","","","","","2017-12-27 17:17:19","How it is possible to observe stream of bool values with delay on value change?","<swift><reactive-programming><rx-swift><reactive>","1","2","","","","CC BY-SA 3.0"
"48020001","1","","","2017-12-29 09:00:00","","-2","867","<p>I'm a beginner to MVVM and RxSwift and I want to implement it on my next project. Currently, I'm working on my login module, everything looks fine but every time I run my application it triggers an error when binding text field to my ViewModel saying ""Unexpectedly found nil while unwrapping an Optional value"". </p>

<p>Can anybody help me to get rid of it?
Here's how I do it:</p>

<pre><code>class LoginViewController: UIViewController {
    @IBOutlet weak var emailTextField: UITextField!
    @IBOutlet weak var passwordTextField: UITextField!
    @IBOutlet weak var loginButton: UIButton!

    private var loginViewModel: UserLoginViewModel!
    private let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

         emailTextField.rx.text.orEmpty
            .bind(to: loginViewModel.emailAdd)
            .disposed(by: disposeBag) &lt;---- Displays ""Unexpectedly found nil while unwrapping an Optional value""

         passwordTextField.rx.text.orEmpty
            .bind(to: loginViewModel.password)
            .disposed(by: disposeBag) &lt;---- Displays ""Unexpectedly found nil while unwrapping an Optional value""
    }
}


/////loginProtocol

protocol loginProtocol {
    //MARK - Input
    var emailAdd: Variable&lt;String&gt; { get }
    var password: Variable&lt;String&gt; { get }
    var loginButtonDidTap:PublishSubject&lt;Void&gt;{ get }
    var loginActionResult: Driver&lt;AutenticationStatus&gt; { get }
}


/// VIEW MODEL
class UserLoginViewModel: loginProtocol {
    var emailAdd: Variable&lt;String&gt;
    var password: Variable&lt;String&gt;
    let loginButtonDidTap = PublishSubject&lt;Void&gt;()
    var loginActionResult:Driver&lt;AutenticationStatus&gt;

    init(apiService: API) {
        let emailV = Variable&lt;String&gt;("""")
        let passwordV = Variable&lt;String&gt;("""")
        emailAdd = emailV
        password = passwordV
        let usernameAndPassword = Observable.combineLatest(emailAdd.asObservable(), password.asObservable()) {
            ($0, $1)
        }

        loginActionResult = loginButtonDidTap.asObservable()
            .withLatestFrom(usernameAndPassword)
            .flatMapLatest { (emailAdd, password) in
                return apiService.login(email: emailAdd, password: password)
            }.asDriver(onErrorJustReturn:.error(.server))
    }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/OYaZI.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/OYaZI.png"" alt=""Here&#39;s the screenshot""></a></p>

<p>Thank you.</p>
","3633680","","","","","2018-01-08 12:06:14","RXSwift Binding returns Unexpectedly found nil while unwrapping an Optional value","<ios><swift><mvvm><swift4><rx-swift>","2","1","1","","","CC BY-SA 3.0"
"48060422","1","","","2018-01-02 11:48:16","","2","714","<p>I'm new to RXSwift. I have UITableViewCell, which has a button. I need to change button state once I click on select all button which is outside of the tableview. I'm changing view model value but UI is not getting updated. Following way I'm binding, how to bind it two ways? </p>

<pre><code>var isSelectedAttendee: Variable&lt;Bool&gt;
cellViewModel?.isSelectedAttendee.asObservable().bind(to: selectButton.rx.isSelected).disposed(by: disposeBag)
</code></pre>

<p>Its not duplicated, simple button binding I know but in my case button is inside UITableViewCell. I have tried with different solutions but it didnt solve my problem.</p>
","5770491","","1113632","","2018-01-29 15:51:20","2018-01-29 15:51:20","Two way binding for UIButton in Swift","<ios><swift><uibutton><rx-swift>","1","1","","","","CC BY-SA 3.0"
"48072157","1","","","2018-01-03 06:18:27","","6","610","<p>How do I populate the <em>NSTableview</em> with an array using reactive framework? 
In iOS for UITableview: </p>

<pre><code>self.viewModel.arrayElements.asObservable()
        .observeOn(MainScheduler.instance)
        .bind(to: detailsTableView.rx.items(cellIdentifier: ""comment"", cellType: UITableViewCell.self)){
            (row,element,cell) in
                 cell.addSubview(cellView)
        }.addDisposableTo(disposeBag)
</code></pre>

<p>how can i achieve the same for <strong><em>NSTableView</em></strong></p>

<p><a href=""https://i.stack.imgur.com/wRPgE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wRPgE.png"" alt=""enter image description here""></a></p>
","5312401","","5312401","","2018-02-07 08:27:46","2020-06-01 07:58:38","NSTableview with RXSwift and RxCocoa for OSX","<macos><reactive-programming><nstableview><rx-swift><rx-cocoa>","2","0","","","","CC BY-SA 3.0"
"48093557","1","","","2018-01-04 10:44:18","","1","1109","<p>So basically I have a struct </p>

<pre><code>struct MyStruct {
    var foo : String = """" 
    var bar : String = """"
}
</code></pre>

<p>Now I want to do the following : 
Observe change in an RxVariable of MyStruct, so that whenever that variable is changed, we also have an observer to that variable, we will be able to get the new struct in that observer.</p>

<p>To be clear once again - </p>

<p><strong>Class A</strong></p>

<p><code>var stct : Variable&lt;MyStruct&gt;() // RxSwift variable</code></p>

<p><strong>Class B :</strong> </p>

<pre><code> let observer = instanceClassA.stct.asObserver().subscribe(onNext : 
  {(newStruct) in 
       // newStruct found here -
  }
 observer.dispose(by:disposeBag)
</code></pre>

<p>The reason I want this flow is : I want <code>Class B</code> to know when <code>Class A's</code> variable of <code>myStruct</code> has changed with new values, as everytime <code>myStruct</code> variable changes, <code>foo</code> and <code>bar</code>, will also change</p>

<p>Think it like Class B is an observer to Class A's variable of myStruct. Now I am learning RxSwift hence I want to utilise its reactive nature of approach. Also I think this is a fairly easy thing to do, but the problem is that I cannot make a <code>Variable (read : Rx)</code> of <code>MyStruct</code></p>

<p>P.S - I am using Swift 4.0 and RxSwift's latest version.</p>

<p>Any Help is highly appreciated.</p>
","3755838","","","","","2018-01-06 05:53:34","RXSwift, a Struct as a Variable","<ios><swift><rx-swift>","1","8","","","","CC BY-SA 3.0"
"48100589","1","48124792","","2018-01-04 17:31:48","","0","706","<p>I want to subclass UIStackView to act as observable to i can bind an observer to it. Basically i want to pass an observer and for every element i want to add a subview into the stack.
So basically i would have <code>var myObs: Observable&lt;CanBeDisplayInMyStackViewType&gt;</code> and i want to do <code>myObs.bind(to: myCustomStackView)</code> and add a subview for every element.</p>

<p>This is what i tried so far:</p>

<pre><code>protocol CanBeDisplayInMyStackViewType {
    var title: String { get }
}

class CustomStackViewUIStackView&lt;E&gt;: UIStackView, ObserverType where E:CanBeDisplayInMyStackViewType  {
    typealias E = CanBeDisplayInMyStackViewType

    func on(_ event: Event&lt;CanBeDisplayInMyStackViewType&gt;) {
        switch event {
        case .next(let value): nextElement(value)
        case .completed: break
        case .error(_): break
        }
    }

    func nextElement(e: CanBeDisplayInMyStackViewType) {
        let someViewForStack = SomeViewForStack.init(e: e)
        self.insertSubview(someViewForStack, at: 0)
    }

    class SomeViewForStack: UIView {
        init(e: CanBeDisplayInMyStackViewType) {}
        required init?(coder aDecoder: NSCoder) {}
    }
}
</code></pre>

<p>But resulting in the error: Cannot specialize non-generic type 'Event'
<a href=""https://i.stack.imgur.com/tOcnK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tOcnK.png"" alt=""enter image description here""></a></p>
","588125","","","","","2018-01-06 06:08:38","Subclass UIStackView to ack as observer","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 3.0"
"48108608","1","48124521","","2018-01-05 06:53:03","","0","654","<pre><code>searchController.searchBar.rx.text
            .asDriver()
            .map{ $0 == """" || $0 == nil }
            .drive(onNext: { (empty) in
                if empty {
                    print(""Search empty"")
                } else {
                    print(""!!!!!!!!!!!!! empty"")
                }
            }).disposed(by: disposeBag)
</code></pre>

<p>This will be called once the first time it is started, the second one when I type the first string, but will not be valid anymore，where the error? thank!!!</p>
","7407671","","1292099","","2018-01-06 18:37:15","2018-01-06 18:37:15","RxSwift only trigger once","<ios><swift><uisearchbar><uisearchcontroller><rx-swift>","1","0","","","","CC BY-SA 3.0"
"48114274","1","48124850","","2018-01-05 13:06:38","","14","5316","<p>I am quite new in Reactive Programming, Here is what I'm trying</p>

<p><strong>.drive</strong></p>

<pre><code>searchController.rx.text
        .asDriver()
        .drive(onNext: { (element) in
            print(element)
        }).disposed(by: disposeBag)
</code></pre>

<p><strong>.subscribe</strong></p>

<pre><code>searchController.rx.text
        .asObservable()
        .subscribe(onNext: { (element) in
            print(element)
        }).disposed(by: disposeBag)
</code></pre>

<p>both blocks are working exactly the same, What is the purpose of using <code>.drive</code> over <code>.subscribe</code>? In which scenario we should use <code>.drive</code> over <code>.subscribe</code> ?</p>

<p>Any help will be appreciated</p>
","8675237","","","","","2018-11-12 10:53:51","What is the difference between .subscribe and .drive","<reactive-programming><rx-swift><reactivex>","1","0","5","","","CC BY-SA 3.0"
"48124144","1","","","2018-01-06 04:05:07","","0","414","<p><strong>Question</strong></p>

<p>I'm porting a project that uses RxJava to RxSwift. There is a ConnectableObservable that uses autoconnect(). How would I port this to RxSwift? I'm looking for a similar feature or work around. </p>

<p><strong>Information</strong></p>

<p>I was looking to use refcount() in RxSwift but once the subscriber number goes to 0 it'll stop where autoconnect() would continue. According to these <a href=""https://github.com/ReactiveX/RxJava/releases"" rel=""nofollow noreferrer"">release notes</a>, autoConnect works like only the first half of refCount, or more precisely, it is similar in behavior to refCount(), except that it doesn't disconnect when subscribers are lost.</p>
","753633","","","","","2018-01-16 13:52:11","RxSwift ConnectableObservable missing autoconnect","<swift><rx-java><rx-swift>","1","5","1","","","CC BY-SA 3.0"
"48126388","1","","","2018-01-06 10:21:29","","0","3197","<p>I have the following issue. I use RxSwift to bind my datasource to an UITableView like this: </p>

<pre><code>self.presenter.posts
      .bind(to: self.tableView.rx.items(cellIdentifier: ""ListPostsCell"")) { index, model, cell in
        if let cell = cell as? ImagePostTableViewCell {
          cell.viewModel = model
          cell.actionButton.rx.action = self.action(for: model.postId, index: index)
        }
      }.disposed(by: self.bag)
</code></pre>

<p>When the tableview reaches the end of the datasource count I request more data and update the datasource (infinite scroll) like this: </p>

<pre><code>self.tableView.rx.willDisplayCell
      .map { $0.indexPath.item }
      .distinctUntilChanged()
      .withLatestFrom(self.presenter.posts) { (item, posts) -&gt; Bool in
        return item == posts.count - 3
      }
      .filter { $0 }
      .withLatestFrom(self.presenter.posts)
      .map { UsersPosts.Request(after: $0.last?.postId) }
      .bind(to: self.usersPostsInteractor.receiveUsersPosts.inputs)
      .disposed(by: self.bag)
</code></pre>

<p>This works fine and I can scroll infinite as expected. The problem is within my Cell:</p>

<pre><code>class ImagePostTableViewCell: UITableViewCell {
  @IBOutlet weak var postImageView: UIImageView!
  @IBOutlet weak var haiScoreLabel: UILabel!
  @IBOutlet weak var lastVoteLabel: UILabel!
  @IBOutlet weak var actionButton: UIButton!
  @IBOutlet weak var activtiyIndicator: UIActivityIndicatorView!

  var bag: DisposeBag?

  var viewModel: ImagePostTableViewCellViewModel? {
    didSet {
      let bag = DisposeBag()

      guard let vm = viewModel else { return }

      vm.image.asDriver(onErrorJustReturn: UIImage())
        .drive(onNext: { image in
          self.updateAppearanceFor(image)
        }).disposed(by: bag)

      self.haiScoreLabel.text = vm.haiScoreText
      self.lastVoteLabel.text = vm.lastVoteText
      self.actionButton.setTitle(vm.actionLabelText, for: .normal)
      self.activtiyIndicator.startAnimating()
      self.bag = bag
    }
  }

  func updateAppearanceFor(_ image: UIImage?, animated: Bool = true) {
    DispatchQueue.main.async {
      if animated {
        UIView.animate(withDuration: 0.5) {
          self.displayImage(image)
        }
      } else {
        self.displayImage(image)
      }
    }
  }

  private func displayImage(_ image: UIImage?) {
    if let image = image {
      self.show(image: image)
    } else {
      self.hide()
    }
  }

  private func show(image: UIImage) {
    self.postImageView.image = image
    self.postImageView.alpha = 1.0
    self.haiScoreLabel.alpha = 1.0
    self.lastVoteLabel.alpha = 1.0
    self.activtiyIndicator.stopAnimating()
  }

  private func hide() {
    self.postImageView.image = nil
    self.postImageView.alpha = 0
    self.haiScoreLabel.alpha = 0
    self.lastVoteLabel.alpha = 0
    self.activtiyIndicator.startAnimating()
  }

  override public func prepareForReuse() {
    super.prepareForReuse()
    self.displayImage(.none)
    self.viewModel = nil
    self.bag = nil
  }
}
</code></pre>

<p>As you can see there is an animation which ends up in an super smooth scrolling behaviour - but because of the datasource update, with every reload the animation starts and unchanged content flashes because of the animation. </p>

<p>In the end I want to avoid the reload for the visible cell but I really desperate here. </p>

<p>Any hints to follow? Thanks in advance!!! </p>
","8967264","","","","","2018-01-06 10:21:29","RXSwift + UITableView with animated Cell ends up in flashing reloads","<ios><swift><uitableview><rx-swift>","0","2","1","","","CC BY-SA 3.0"
"48129044","1","","","2018-01-06 15:52:20","","1","94","<p>I want to implement AutoComplete Text field with RxSwift in swift 3. </p>

<p>I have this code in java and it works well, but I don't know to implement it swift 3 with RxSwift.
I have searched for TextChange in rxSwift but I couldn't find anything!</p>

<p>here is my code. </p>

<pre><code>RxTextView.textChanges(mEtAddress)
                .map(CharSequence::toString)
                .debounce(100, TimeUnit.MILLISECONDS)
                .filter(s -&gt; !TextUtils.isEmpty(s))
                .compose(bindUntilEvent(FragmentEvent.STOP))
                .flatMap(q -&gt; mReactiveLocationProvider.getPlaceAutocompletePredictions(
                        q, new LatLngBounds(
                                new LatLng(SOUTHWEST_LATITUDE, SOUTHWEST_LONGITUDE),
                                new LatLng(NORTHEAST_LATITUDE, NORTHEAST_LONGITUDE)), null))
                .subscribe(buffer -&gt; {
                    List&lt;AutocompleteInfo&gt; infos = new ArrayList&lt;&gt;();
                    for (AutocompletePrediction prediction : buffer) {
                        infos.add(new AutocompleteInfo(prediction.getFullText(null).toString(), prediction.getPlaceId()));
                    }
                    buffer.release();
                    mPlaceSuggestionsList.setAdapter(new ArrayAdapter&lt;&gt;(getActivity(), android.R.layout.simple_list_item_1, infos));
                });
</code></pre>
","5892896","","","","","2019-04-28 11:37:16","How to Implement RxJava TextChange in RxSwift","<swift><swift3><uitextfield><rx-swift>","1","0","","","","CC BY-SA 3.0"
"48132558","1","48134695","","2018-01-06 22:29:16","","2","688","<p>Lets say i have an Observable, and an Observable, (names and ages for example), i zip them and i do some transformations with them, but those transformation inside the zip sometimes i have to go to the network (delay in this example) and others just return a value. So the original order of the tuple(String, Int) gets messy.</p>

<pre><code>var shouldDelay = true
func names() -&gt; Observable&lt;String&gt; {
    return Observable.of(""First name"", ""John"", ""Martina"")
}
func ages() -&gt; Observable&lt;Int&gt; {
    return Observable.of(20,15,17)
}
Observable.zip(names(), ages())
    .flatMap{ arg -&gt; Observable&lt;(String, Int)&gt; in
        if shouldDelay {
            shouldDelay = !shouldDelay
            return Observable.just(arg).delay(1, scheduler: MainScheduler.instance)
        }
        return Observable.just(arg)
    }
    .map { $0.0 + "" "" + $0.1.description }
.subscribe { event in
    print(event.element ?? """")
}
</code></pre>

<p>So basically I get <code>John 15, Martina 17, FirstName 20</code> (those tuples are correct), but i expect <code>FirstName 20, John 15, Martina 17</code>.</p>

<p>Any hints to solve this? I only can think of regrouping them (.toArray) and ordering them inside and finally Observable.from </p>
","588125","","588125","","2018-01-06 22:43:20","2018-01-07 05:51:59","RxSwift lost order after zip","<swift><rx-swift>","1","2","","","","CC BY-SA 3.0"
"48138443","1","48139717","","2018-01-07 15:07:14","","1","957","<p>I noticed that RxSwift slows down the app, I don't know if this is my fault or the framework.</p>

<p>I have binding inside custom class of UICollectionViewCell, which is fired for configuring cell. For example this part of code:</p>

<pre><code>viewModel.observableIsHighlighted.asDriver().drive(onNext: { isHighlighted in
    // do nothing
}).disposed(by: disposeBag)
viewModel.observableIsMarked.asDriver().drive(onNext: { isMarked in
    // do nothing
}).disposed(by: disposeBag)
</code></pre>

<p>where <code>observableIsHighlighted</code>, <code>observableIsMarked</code> are just <code>BehaviorRelay&lt;Bool&gt;</code>, takes around 16-20 milliseconds which is unacceptable for UICollectionView of course.</p>

<p>Another part like this:</p>

<pre><code>imageViewTapGestureRecognizer.rx.event.bind(onNext: { _ in
    // do nothing
}).disposed(by: disposeBag)
</code></pre>

<p>takes around 12 milliseconds. </p>

<p><strong>Question</strong></p>

<p>Is it something wrong in my approach or binding in RxSwift is not accurate for views like <code>UICollectionView</code>?</p>

<p>Of course, I assume that binding in RxSwift is exactly for things like <code>UICollectionView</code>.</p>

<p><strong>Edit</strong></p>

<p>How am I measuring time?</p>

<p>I use <code>CACurrentMediaTime()</code> multiplied by <code>1000</code>. I know it's the best way, but methods that are quite simple always take 0 ms, so it suggest that 10-20 ms methods, are should be improved.</p>
","4386668","","4386668","","2018-01-07 17:19:29","2018-01-07 17:27:04","Subscribing to Observable or Driver takes too long in RxSwift","<ios><swift><rx-swift><reactivex><rx-cocoa>","1","6","","","","CC BY-SA 3.0"
"48146918","1","","","2018-01-08 08:57:15","","5","2418","<p>I have read RxSwift/ShareReplayScope.swift file， but a little difficult to understand. </p>

<pre><code>public func share(replay: Int = 0, scope: SubjectLifetimeScope = .whileConnected)
        -&gt; Observable&lt;E&gt; {
        switch scope {
        case .forever:
            switch replay {
            case 0: return self.multicast(PublishSubject()).refCount()
            default: return self.multicast(ReplaySubject.create(bufferSize: replay)).refCount()
            }
        case .whileConnected:
            switch replay {
            case 0: return ShareWhileConnected(source: self.asObservable())
            case 1: return ShareReplay1WhileConnected(source: self.asObservable())
            default: return self.multicast(makeSubject: { ReplaySubject.create(bufferSize: replay) }).refCount()
            }
        }
    }
</code></pre>

<p>0,1 and default,what is the difference? why separate 1 from defalut? </p>

<pre><code> override func subscribe&lt;O : ObserverType&gt;(_ observer: O) -&gt; Disposable where O.E == E {
        _lock.lock()

        let connection = _synchronized_subscribe(observer)
        let count = connection._observers.count
        let disposable = connection._synchronized_subscribe(observer)

        _lock.unlock()

        if count == 0 {
            connection.connect()
        }

        return disposable
    }
</code></pre>

<p>how the <code>lock</code> work, and the most difficult is this function. how the blocked obserables connect to their observers correctly.</p>
","5814921","","5814921","","2018-01-09 09:28:41","2018-11-22 05:44:26","How is the shareReplay function working?","<swift><system.reactive><rx-swift>","1","1","3","","","CC BY-SA 3.0"
"48176547","1","","","2018-01-09 20:58:51","","2","206","<p>I have some third party library that has delegate methods. But I like using RX so I should create RxDelegateProxy to receive delegate's callbacks via RX.</p>

<p>Here my custom DelegateProxy class:</p>

<pre><code>extension Reactive where Base:GalleryController {

  var selectedImages:Observable&lt;(GalleryController, [Image])&gt; {
    let proxy = RxGalleryDelegateProxy.createProxy(for: self.base)
    return proxy.imageSubject.asObservable()
  }

}

private class RxGalleryDelegateProxy: DelegateProxy&lt;GalleryController, GalleryControllerDelegate&gt;, DelegateProxyType, GalleryControllerDelegate {

  private var _imageSubject: PublishSubject&lt;(GalleryController, [Image])&gt;?

  public weak fileprivate(set) var galleryController: GalleryController?

  internal var imageSubject: PublishSubject&lt;(GalleryController, [Image])&gt; {
    if let subject = _imageSubject {
      return subject
    }

    let subject = PublishSubject&lt;(GalleryController, [Image])&gt;()
    _imageSubject = subject

    return subject
  }

  static func currentDelegate(for object: GalleryController) -&gt; GalleryControllerDelegate? {
    return object.delegate
  }

  static func setCurrentDelegate(_ delegate: GalleryControllerDelegate?, to object: GalleryController) {
    object.delegate = delegate
  }

  static func registerKnownImplementations() {
    self.register { RxGalleryDelegateProxy(parentObject: $0) }
  }

  private init(parentObject: GalleryController) {
    self.galleryController = castOrFatalError(parentObject)
    super.init(parentObject: parentObject, delegateProxy: RxGalleryDelegateProxy.self)
  }

  func galleryController(_ controller: GalleryController, didSelectImages images: [Image]) {
    if let subject = _imageSubject {
      subject.on(.next((controller, images)))
    }

    self._setForwardToDelegate(galleryController(controller, didSelectImages: images), retainDelegate: true)
  }

  deinit {
    _imageSubject?.on(.completed)
  }

}
</code></pre>

<p>In my UIViewController I subscribe with:</p>

<pre><code>final class PhotoLibraryViewController: UIViewController {

  private let _bag = DisposeBag()

  override func viewDidLoad() {
    super.viewDidLoad()

    let gallery = GalleryController()
    present(gallery, animated: true, completion: nil)

    gallery.rx.selectedImages
      .debug(""--------"")
      .observeOn(MainScheduler.instance)
      .subscribe(onNext: { (controller, images) in
        print(""\(images)"")
      }, onError: { (error) in
        DDLogError(""Error:\n\(error)"")
      })
      .disposed(by: _bag)

  }

}
</code></pre>

<p>But all I get in console output via .debug(""--------"") is:</p>

<pre><code>2018-01-09 20:05:14.814: -------- -&gt; subscribed
2018-01-09 20:05:14.817: -------- -&gt; Event completed
2018-01-09 20:05:14.817: -------- -&gt; isDisposed
</code></pre>

<p>So my object is immediately disposing just after creation. What did I do wrong?</p>
","3742622","","472495","","2020-04-18 13:26:42","2020-04-18 13:26:42","My custom RxDelegateProxy immediately disposing","<ios><swift><delegates><rx-swift><rx-cocoa>","1","5","","","","CC BY-SA 4.0"
"48181488","1","","","2018-01-10 06:27:46","","1","352","<p>I am new to RxSwift but I am trying to use RxSwift with the MVVM patter to format some text.
I have a textfield where I want the user to write in their credit card number, and as they write I want to format it.</p>

<p>So when they write ""6789430078303201"" I want to format it to: 
""6789 4300 7830 3201""</p>

<p>Any suggestions on how to do this?</p>

<p>Aleksander Aleksic</p>
","5326910","","","","","2020-02-23 21:44:21","RxSwift format text","<ios><swift><mvvm><rx-swift>","3","1","","","","CC BY-SA 3.0"
"48182320","1","","","2018-01-10 07:30:01","","0","1483","<p>I have learned RxSwift for a period of time by following the book named Reactive Programming with swift. There are some tutorials about timer operator that I cannot understand</p>

<pre><code>let elementsPerSecond = 1
let delayInSeconds = 2
let sourceObservable = PublishSubject&lt;Int&gt;()

var current = 1
let timer = DispatchSource.timer(interval: 1.0 / Double(elementsPerSecond), queue: .main) {
    sourceObservable.onNext(current)
    sourceObservable2.onNext(current)
    current = current + 1
}

_ = sourceObservable.subscribe(sourceTimeline)

_ = sourceObservable
.delay(RxTimeInterval(delayInSeconds), scheduler: MainScheduler.instance)
.subscribe(delayedTimeline)

_ = Observable&lt;Int&gt;
.timer(RxTimeInterval(0), scheduler: MainScheduler.instance)
.flatMap { _  in
    return sourceObservable.delay(RxTimeInterval(delayInSeconds), scheduler: MainScheduler.instance)
}
.subscribe(timerTimeline)
</code></pre>

<p>But the result is very strange:
<a href=""https://i.stack.imgur.com/ctnsP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ctnsP.png"" alt=""enter image description here""></a></p>

<p>The third view is timerTimeline and it was second behind second timeline which is delayedTimeline. So where is the second goes? What's more, the first element was ignored by the timerTimeline. I don't know how to use the timer operator and could anyone tell me the reason, thanks.</p>
","6124146","","6189974","","2018-01-10 13:48:09","2018-01-10 13:48:09","How to set due time in timer(_:period:scheduler:)","<swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"48187689","1","48198724","","2018-01-10 12:39:50","","0","1050","<p>I am using Moya with RxSwift and I am trying to set the request timeout for the network call (API Calls) using below code as suggested :</p>

<p>which is including the custom Alamofire Manager when declaring your Provider</p>

<pre><code>lazy var provider: RxMoyaProvider&lt;CAPProviderAPI&gt; = {
    return RxMoyaProvider&lt;CAPProviderAPI&gt;(endpointClosure: Utility.getEndPointClosure(forProviderType: .authorized), manager: DefaultAlamofireManager.sharedManager, plugins: [NetworkActivityPlugin(networkActivityClosure: networkActivityClosure)])
}()
</code></pre>

<p>but I am getting an error saying : Use of unresolved identifier 'networkActivityClosure'</p>
","2967827","","","","","2018-01-11 01:48:56","Set request timeout on RXMoyaProvider","<alamofire><rx-swift><moya><rxalamofire>","1","0","","","","CC BY-SA 3.0"
"48202473","1","48202474","","2018-01-11 08:16:04","","-1","1129","<p>I have a list of player which I want each player stamina to be observed and the observer should be the same. (Sharing observer maybe)</p>

<pre><code>class Player {
  var stamina = Variable(10)
}

let player1 = Player()
let player2 = Player()

var playerList = Variable([player1, player2])
</code></pre>

<p>So, whenever player1.stamina == 0 then I can delete player1 from the list, dan now only player2 to be observed.</p>
","8504232","","8504232","","2018-01-11 08:40:41","2018-01-13 12:46:05","RxSwift : Observe each element observable property in observable array","<arrays><swift><reactive-programming><rx-swift>","1","6","1","","","CC BY-SA 3.0"
"48218770","1","48219520","","2018-01-12 02:34:56","","1","953","<p>In my app I am using Moya and RxSwift to make my web service calls. The calls are async and can be triggered by user interaction as well as remote notifications when new data is available.</p>

<p>Each web service calls needs a authentification taken in its headers. When the user changes the password, the token is re-generated and returned by the change password web service call.</p>

<p>Now it can happen that while the user changes the password, a remote notification comes and causes another web service call. Depending on the servers load and how the system is handling the different threads it could in theory happen that the call is made before the new token is retrieved by the other call but after the server already invalidated the old token. The result is a HTTP 401 unathorized error.</p>

<p>I would like to prevent that but I am not sure what the best approach to that is or if I have some wrong thinking in my concept. </p>

<p>I found this page which talks about locks, mutex and semaphores: <a href=""https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html"" rel=""nofollow noreferrer"">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html</a></p>

<p>It seems that I might should use a ""Read-write lock"" as such:</p>

<ul>
<li>The change password call is the ""writer""</li>
<li>All other calls are the ""readers"" </li>
<li>When a call to reload data is made, either by the user or caused by a remote notification, the reader count is incremented on the lock</li>
<li>When the user changes the password, the writer count is incremented on the lock and new readers are blocked from starting</li>
<li>The change password call waits for all other ""read"" calls to finish</li>
<li>The change password call changes the password, updates the token and finally decrements the lock and releases it</li>
<li>The suspended readers can now continue to run and start incrementing the readers count and reload the data. </li>
</ul>

<p>Is this correct so far? Then next big question is: is there a better approach? And before I start changing all my web service calls: is there a build in mechanism for this in Moya or RxSwift?</p>
","1708462","","","","","2018-01-12 08:34:54","iOS Moya Web Services: make one call wait for all others to finish, then block new calls","<ios><multithreading><web-services><rx-swift><moya>","1","0","0","","","CC BY-SA 3.0"
"48225276","1","48226124","","2018-01-12 11:23:31","","0","830","<p>I am using RxSwift to make a pull to refresh and refreshNextPage.</p>

<p>Currently, here is the viewModel I work so far:</p>

<pre><code>public final class MomentViewModel {
// Property
let refreshTrigger = PublishSubject&lt;Void&gt;()
let loadNextPageTrigger = PublishSubject&lt;Void&gt;()
let loading = Variable&lt;Bool&gt;(false)
let posts = Variable&lt;[Post]&gt;([])
var pageIndex: Int = 0
let error = PublishSubject&lt;Swift.Error&gt;()
private let disposeBag = DisposeBag()

public init() {

    let refreshRequest = loading.asObservable()
        .sample(refreshTrigger)
        .flatMap { loading -&gt; Observable&lt;Int&gt; in
            if loading {
                return Observable.empty()
            } else {
                return Observable&lt;Int&gt;.create { observer in
                    self.pageIndex = 0
                    print(""reset page index to 0"")
                    observer.onNext(0)
                    observer.onCompleted()
                    return Disposables.create()
                }
            }
    }
    .debug(""refreshRequest"", trimOutput: false)

    let nextPageRequest = loading.asObservable()
        .sample(loadNextPageTrigger)
        .flatMap { loading -&gt; Observable&lt;Int&gt; in
            if loading {
                return Observable.empty()
            } else {
                return Observable&lt;Int&gt;.create { [unowned self] observer in
                    self.pageIndex += 1
                    print(self.pageIndex)
                    observer.onNext(self.pageIndex)
                    observer.onCompleted()
                    return Disposables.create()
                }
            }
    }
    .debug(""nextPageRequest"", trimOutput: false)

    let request = Observable.merge(refreshRequest, nextPageRequest)
        .debug(""Request"", trimOutput: false)

    let response = request.flatMapLatest { page in
            RxAPIProvider.shared.getPostList(page: page).materialize()
        }
        .share(replay: 1)
        .elements()
        .debug(""Response"", trimOutput: false)

    Observable
        .combineLatest(request, response, posts.asObservable()) { request, response, posts in
            return self.pageIndex == 0 ? response : posts + response
        }
        .sample(response)
        .bind(to: posts)
        .disposed(by: disposeBag)

    Observable
        .merge(request.map{ _ in true },
            response.map { _ in false },
            error.map { _ in false })
        .bind(to: loading)
        .disposed(by: disposeBag)
    }
}
</code></pre>

<p>The <code>refreshTrigger</code> and <code>loadNextPageTrigger</code> is bind to difference target likes:</p>

<pre><code>self.tableView.rx_reachedBottom
        .map { _ in () }
        .bind(to: self.viewModel.loadNextPageTrigger)
        .disposed(by: disposeBag)

self.refreshControl.rx.controlEvent(.valueChanged)
        .bind(to: self.viewModel.refreshTrigger)
        .disposed(by: disposeBag)


self.rx.sentMessage(#selector(UIViewController.viewWillAppear(_:)))
        .map { _ in () }
        .bind(to: viewModel.refreshTrigger)
        .disposed(by: disposeBag)
</code></pre>

<p><strong>Question:</strong> </p>

<p>When I scroll the tableView to bottom and trigger the <code>loadNextPageTrigger</code>, everything works fine. </p>

<p>However, if there is no more data in the next coming request, the loadnextPageTrigger will be triggered infinitely. 
Any help would be appreciated.</p>

<p>You can download the <a href=""https://github.com/wongzigii/RxPaginationDemo"" rel=""nofollow noreferrer"">Demo</a> here. </p>
","4234171","","4234171","","2018-01-12 11:25:58","2018-01-12 12:28:48","RefreshNextPage with RxSwift","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"48227854","1","48228121","","2018-01-12 14:03:45","","0","961","<p>I'm fairly new to RxSwift and have been banging my head against the following problem for two days now.</p>

<p>I wrapped a closure that reads a partial JSON formatted string from an API:</p>

<pre><code>func readResult() -&gt; Observable&lt;String&gt; {
    return Observable&lt;String&gt;.create { observable -&gt; Disposable in
        API.readValue() { (result: Result&lt;String&gt;) in
            switch result {
            case .success(let value): observable.onNext(value)
            case .failure(let error): observable.onError(error)
            }
            observable.onCompleted()
        }
        return Disposables.create()
    }
}
</code></pre>

<p>As the result from <code>readValue</code> only contains a chunk of the JSON formatted string, and I need to recursively call this method to get the full string. Therefore, it is important to start a new reading only when the previous one has finished.</p>

<p>I tried using an <code>Observable.timer</code> and <code>scan</code> to accumulate the results until I can successfully decode the json, but using a <code>timer</code> does not guarantee that the previous reading finished.</p>

<p>I also thought about using <code>concat</code> but as I don't know the length of the full JSON string in advance, I cannot write something like this:</p>

<pre><code>Observable.concat(readResult(), readResult())
</code></pre>

<p>How could I ensure that the <code>readResult</code> function gets called until I can successfully decode the resulting JSON string?</p>
","4083297","","","","","2018-01-13 07:58:23","RxSwift - Repeat observable until predicate","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"48255164","1","","","2018-01-14 23:21:39","","4","1140","<p>I am reading about RxSwift and there is a lot of discussion around memory leak. Here is quoting from the getting started guide on the main RxSwift <a href=""https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md"" rel=""nofollow noreferrer"">repo</a>: </p>

<blockquote>
  <p>If a sequence does not terminate on its own, such as with a series of button taps, resources will be allocated permanently unless <code>dispose</code> is called manually, automatically inside of a disposeBag, with the takeUntil operator, or in some other way. </p>
</blockquote>

<p>And here is a snippet of code from <strong>Chapter 2: Observables</strong> of <a href=""https://store.raywenderlich.com/products/rxswift"" rel=""nofollow noreferrer"">Reactive Programming with Swift</a> where memory does leak: </p>

<pre><code>Observable&lt;String&gt;.create({ observer in
    observer.onNext(""1"")
    // observer.onError(MyError.anError)
    // observer.onCompleted()
    return Disposables.create()
}).subscribe(
    onNext: { print($0) },
    onError: { print($0) },
    onCompleted: { print(""Completed"") },
    onDisposed: { print(""Disposed"") }
)
</code></pre>

<p>I understand that it is very important to dispose resources (with, for example, a dispose bag). However, what I don't understand is: what resources are leaking and how?</p>
","1035008","","1035008","","2018-01-14 23:27:07","2018-01-15 12:19:02","RxSwift why do we have memory leak without calling dispose","<swift><rx-swift>","1","2","3","","","CC BY-SA 3.0"
"48272368","1","","","2018-01-16 00:02:44","","0","718","<p>I have a PublishObject object, which is feed by coming data (approximately
16 times per second). When objects coming so quickly, that can be a situation, when one is still processing, but the new one is ready to use. Is it a way to block executing another processing, when the earlier doesn't end his job?</p>
","4463435","","","","","2018-01-16 07:59:09","Execute subscribe method only once at the time in RxSwift","<ios><swift><multithreading><rx-swift>","1","3","1","","","CC BY-SA 3.0"
"48282685","1","","","2018-01-16 13:44:11","","2","521","<p>The scan() operator that takes a seed in RxJava emits the seed upon every subscription. Other RX languages, like RxJS &amp; RxSwift do not do this. Seed value is never emitted.</p>

<p>Why is this? Is it safe to assume RxJava has an added feature where other RX languages never expected a scan to act like that.</p>

<p><strong>RxJs &amp; RxSwift</strong>
<a href=""https://i.stack.imgur.com/YIPJY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YIPJY.png"" alt=""RxJS &amp; RxSwift""></a></p>

<p><strong>RxJava</strong>
<a href=""https://i.stack.imgur.com/H8SCH.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/H8SCH.png"" alt=""RxJava""></a></p>
","753633","","","","","2018-01-16 13:44:11","RxJava Scan emits first item, other RX libraries do not. Why?","<rxjs><rx-java><reactive-programming><rx-swift>","0","1","1","","","CC BY-SA 3.0"
"48283809","1","","","2018-01-16 14:43:56","","1","230","<p>I know, that all types of Rx subjects can get elements in subscribe not ordered correctly, eg. if I send three elements in order 1,2,3, there is an option to get it on this order: 1,3,2. </p>

<p>I wonder, is there a way to force the order of emitted elements the same at the start and at the end?</p>
","4463435","","5953643","","2018-01-18 00:08:51","2018-01-18 00:08:51","RxSwift - order of emit on PublishSubject","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 3.0"
"48301533","1","48303519","","2018-01-17 12:46:20","","5","5993","<p>I have the following code:</p>

<pre><code>let fetcher = DiagnosticFetcher(commandSender: sender)
fetcher.fetch()
    .observeOn(MainScheduler.instance)
    .subscribe(
       onNext: { self.store.save(content: $0) },
       onError: { self.view.showError(""Error"") },
       onCompleted: { log.verbose(""Diagnostic fetched"") })
</code></pre>

<p>It does not compile: <code>Extra argument 'onError' in call</code>. I get the same error if I use <code>onSuccess</code> or <code>onDoesNotExistButShowTheBug</code> instead of <code>onNext</code>.</p>

<p>The <code>fetch()</code> method returns a <code>Observable&lt;String&gt;</code> (whose last operator is a <code>reduce</code>). It seems that the <code>subscribe()</code> call expects only one lambda:</p>

<pre><code>fetcher.fetch()
   .observeOn(MainScheduler.instance)
   .subscribe(onNext: { self.store.save(content: $0) })
</code></pre>

<p>Results in: <code>Extraneous argument label 'onNext:' in call</code>. And:</p>

<pre><code>fetcher.fetch()
   .observeOn(MainScheduler.instance)
   .subscribe({ self.store.save(content: $0) })
</code></pre>

<p>compiles fine.</p>

<p>I feel like I get the wrong <code>subscribe()</code> implementation. I want that one: </p>

<pre><code>public func subscribe(onNext: ((ElementType) -&gt; Void)? = nil,
                      onError: ((Swift.Error) -&gt; Void)? = nil,
                      onCompleted: (() -&gt; Void)? = nil) -&gt; Disposable {
</code></pre>

<p>but obviously, the compiler doesn't.
I'm using XCode 9.2 with Swift 4 and RxSwift 4.1.1.</p>

<p>I have other parts in my app that use the <code>onNext:onError:</code> on an observable where it works. I can't put my finger on what is different for this call.</p>

<p>Any thought on how I can identify the root of the issue?</p>
","15361","","15361","","2018-01-17 13:05:00","2019-05-10 14:02:41","RxSwift: Extra argument 'onError' when subscribing on an Observable<String>","<swift><rx-swift>","2","7","","","","CC BY-SA 3.0"
"48306567","1","48325875","","2018-01-17 17:14:16","","1","1540","<p>I have a network request that can Succeed or Fail</p>

<p>I have encapsulated it in an observable.
I have 2 rules for the request</p>

<blockquote>
  <p>1) There can never be more then 1 request at the same time </p>
  
  <p>-> there is a share operator i can use for this</p>
  
  <p>2) When the request was Succeeded i don't want to repeat the same
  request again and just return the latest value</p>
  
  <p>-> I can use shareReplay(1) operator for this</p>
</blockquote>

<p>The problem arises when the request fails, the shareReplay(1) will just replay the latest error and not restart the request again.</p>

<p>The request should start again at the next subscription.</p>

<p>Does anyone have an idea how i can turn this into a Observable chain?</p>

<pre><code>// scenario 1
let obs: Observable&lt;Int&gt; = request().shareReplay(1)
// outputs a value
obs.subscribe()
// does not start a new request but outputs the same value as before
obs.subscribe() 

// scenario 2 - in case of an error
let obs: Observable&lt;Int&gt; = request().shareReplay(1)
// outputs a error
obs.subscribe() 
// does not start a new request but outputs the same value as before, but in this case i want it to start a new request
obs.subscribe() 
</code></pre>

<p>This seems to be a exactly doing what i want, but it consists of keeping state outside the observable, anyone know how i can achieve this in a more Rx way?</p>

<pre><code>enum Err: Swift.Error {
    case x
}

enum Result&lt;T&gt; {
    case value(val: T)
    case error(err: Swift.Error)
}

func sample() {

    var result: Result&lt;Int&gt;? = nil
    var i = 0

    let intSequence: Observable&lt;Result&lt;Int&gt;&gt; = Observable&lt;Int&gt;.create { observer in

        if let result = result {
            if case .value(let val) = result {
                return Observable&lt;Int&gt;.just(val).subscribe(observer)
            }
        }
        print(""do work"")
        delay(1) {
            if i == 0 {
                observer.onError(Err.x)
            } else {
                observer.onNext(1)
                observer.onCompleted()
            }
            i += 1
        }
        return Disposables.create {}
        }
        .map { value -&gt; Result&lt;Int&gt; in Result.value(val: value) }
        .catchError { error -&gt; Observable&lt;Result&lt;Int&gt;&gt; in
            return .just(.error(err: error))
        }
        .do(onNext: { result = $0 })
        .share()

    _ = intSequence
        .debug()
        .subscribe()

    delay(2) {
        _ = intSequence
            .debug()
            .subscribe()

        _ = intSequence
            .debug()
            .subscribe()
    }

    delay(4) {
        _ = intSequence
            .debug()
            .subscribe()
    }
}


sample()
</code></pre>

<p>it only generates work when we don't have anything cached, but thing again we need to use side effects to achieve the desired output</p>
","62009","","62009","","2018-01-18 15:57:54","2018-01-18 16:22:49","RxSwift, Share + retry mechanism","<swift><share><rx-swift>","2","0","","","","CC BY-SA 3.0"
"48315949","1","","","2018-01-18 07:34:22","","0","1662","<p>I can't figure out how to do your dataSource. 
I watched lessons on RxSwift and RxCocoa and realized that for complex tables you need to use your datasource. Found a library RxDataSourced but we're not allowed to use it. Decided to write your own dataSource but nothing happened. If you don't mind can you show examples of writing dataSourse found nothing on the Internet.</p>

<pre><code>class RXSpecificationsDataSource: NSObject, RxTableViewDataSourceType, UITableViewDataSource {
    typealias Element = MaterialEntityRootGroupProperty

    var _sectionModels: [MaterialEntityRootGroupProperty] = []


     public typealias ConfigureCell = (RXSpecificationsDataSource, UITableView, IndexPath) -&gt; UITableViewCell



    func tableView(_ tableView: UITableView, observedEvent: Event&lt;RXSpecificationsDataSource.Element&gt;) { }

    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        guard _sectionModels.count &gt; section else { return 0 }
       return _sectionModels[section].properties.count
    }

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
        precondition(indexPath.item &lt; _sectionModels[indexPath.section].properties.count)  return ConfigureCell(self, tableView, indexPath, self[indexPath])

    }

    func numberOfSections(in tableView: UITableView) -&gt; Int {
       return _sectionModels.count
    }
}

final class MaterialDetailSpecificationsView: UserInterface {

    private var specificationTableView: UITableView!
    private let disposeBag = DisposeBag()

    func setupView(items: Variable&lt;[MaterialEntityRootGroupProperty]&gt;) {
        setNabigationParms()
        drawTableViewSpecifications()

        let dataSource = RXSpecificationsDataSource ()

        dataSource.configureCell = { (dataSource, tv, indexPath, element) in
            let cell = tv.dequeueReusableCell(withIdentifier: ""Cell"")!
            cell.textLabel?.text = ""\(element) @ row \(indexPath.row)""
            return cell
        }

        items.asObservable()
            .bind(to: specificationTableView.rx.items(dataSource: dataSource))
            .disposed(by: disposeBag)



    }
</code></pre>
","9220682","","9220682","","2018-01-18 12:29:20","2018-01-18 16:17:53","RxSwift, How to draw tableView without using RxDataSourced?","<ios><swift><datasource><rx-swift><rx-cocoa>","1","0","0","","","CC BY-SA 3.0"
"48316075","1","","","2018-01-18 07:42:05","","2","927","<p>Sorry I could not come up with better title than that, Ill modify it if anybody suggests a better one after.</p>

<p>I have a protocol </p>

<pre><code>@objc public protocol MyCollectionViewProtocol {
    func scrollViewShouldScrollToTop()
}
</code></pre>

<p>I have declared it to be <code>@objc</code> because unfortunately DelegateProxy does not work with non NSObject protocols (I assume, if somebody can clarify that, will be a great help)</p>

<p>My collectionView</p>

<pre><code>public class MyCollectionView: UICollectionView {
  weak var cvDelegate : MyCollectionViewProtocol?
  ... //rest of the code isnt related to this question in particular 
</code></pre>

<p>Now I declare delegate proxy as</p>

<pre><code>open class RxMyCollectionViewDelegateProxy : DelegateProxy&lt;MyCollectionView, MyCollectionViewProtocol&gt;
    , DelegateProxyType
, MyCollectionViewProtocol {

    public static func currentDelegate(for object: MyCollectionView) -&gt; MyCollectionViewProtocol? {
        return object.cvDelegate
    }

    public static func setCurrentDelegate(_ delegate: MyCollectionViewProtocol?, to object: MyCollectionView) {
        object.cvDelegate = delegate
    }


    public weak private(set) var collectionView: MyCollectionView?


    internal lazy var shouldScrollPublishSubject: PublishSubject&lt;Void&gt; = {
        let localSubject = PublishSubject&lt;Void&gt;()
        return localSubject
    }()

    public init(collectionView: ParentObject) {
        self.collectionView = collectionView
        super.init(parentObject: collectionView, delegateProxy: RxMyCollectionViewDelegateProxy.self)
    }

    // Register known implementations
    public static func registerKnownImplementations() {
        self.register { RxMyCollectionViewDelegateProxy(collectionView: $0) }
    }


    //implementation of MyCollectionViewProtocol
    public func scrollViewShouldScrollToTop() {
        shouldScrollPublishSubject.onNext(())
        self._forwardToDelegate?.scrollViewShouldScrollToTop()
    }

    deinit {
        shouldScrollPublishSubject.onCompleted()
    }
}
</code></pre>

<p>Finally I declare my Reactive extension for MyCollectionView as</p>

<pre><code>extension Reactive where Base: MyCollectionView {
    public var delegate: DelegateProxy&lt;MyCollectionView, MyCollectionViewProtocol&gt; {
        return RxMyCollectionViewDelegateProxy.proxy(for: base)
    }

    public var shouldScrollToTop: ControlEvent&lt;Void&gt; {
        let source = RxMyCollectionViewDelegateProxy.proxy(for: base).shouldScrollPublishSubject
        return ControlEvent(events: source)
    }
}
</code></pre>

<p>Finally, I use it as</p>

<pre><code>    collectionView.rx.shouldScrollToTop.debug().subscribe(onNext: { (state) in
        print(""I should scroll to top"")
    }, onError: { (error) in
        print(""errored out"")
    }, onCompleted: {
        print(""completed"")
    }, onDisposed: {
        print(""Disposed"")
    }).disposed(by: disposeBag)
</code></pre>

<p><strong>Question</strong></p>

<ol>
<li><p>Because none of the online tutorials(Raywenderlich)/courses (<a href=""https://www.udemy.com/reactive-programming-in-ios-with-rxswift/learn/v4/content"" rel=""nofollow noreferrer"">Udemy</a>)/Books(<a href=""https://store.raywenderlich.com/products/rxswift?_ga=2.228822747.676306382.1516178945-187126908.1484119970"" rel=""nofollow noreferrer"">Raywenderlich</a>) explains how to convert the swift protocol to Rx style am confused as what I am doing is correct or wrong. The code works but even the worst designed code might work, hence I wanna be sure what am doing is correct or am messing something. I wrote the above code following the approach used in <code>UIScrollView+Rx.swift</code> and <code>RxScrollViewDelegateProxy.swift</code> </p></li>
<li><p>Though the code above works only for protocols without any return type example method I used above <code>func scrollViewShouldScrollToTop()</code> has no return type associated with it. I could not imagine how could I use the DelegateProxy above to convert the protocol methods with return types, like <code>numberOfRowsInSection</code> which has <code>Int</code> as return type.</p></li>
</ol>

<p>I happened to look at the <code>RxDataSource</code> implementation and realized in order to convert <code>cellForRowAtIndexPath</code> <code>RxDataSource</code> constructor expects you to pass the block as a init parameter and executes it whenever tableView calls <code>cellForRowAtIndexPath</code> in its proxyDelegate. </p>

<p>Now I could do the same thing if thats the only way out. Need to know is that how am supposed to code it or can I modify ProxyDelegate implementation above to convert the protocol method with return types.</p>
","5706328","","1000551","","2018-01-18 07:51:09","2018-01-18 07:51:09","Is this the best way to convert Swift protocol to RxDelegateProxy?","<ios><swift><rx-swift>","0","1","1","","","CC BY-SA 3.0"
"48320878","1","48320956","","2018-01-18 12:01:46","","4","4490","<p>I'm trying to apply some logic to a component when a <code>UITableView</code> is scrolled, but I can't map the <code>contentOffset</code> property to return the <code>y</code>'s value.</p>

<p>I'm testing like this but nothing happens:</p>

<pre><code>table.rx.contentOffset.map {debugPrint($0)}
</code></pre>

<p>How can I do that?</p>
","1085977","","","","","2018-01-18 12:06:28","RxSwift - mapping contentOffset of UITableView","<ios><swift><uitableview><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"48324592","1","","","2018-01-18 15:18:11","","0","4050","<p>In my application I have an array of notifications. Notification can be read and unread.</p>

<p>When user clicks on the unread notification I need to change the model and reload data in my table view.</p>

<p>In my ViewModel I have output stream:</p>

<pre><code>let notifications: Driver&lt;[Notification]&gt;
</code></pre>

<p>And aslo I have an input stream with notification click:</p>

<pre><code>let touchSingleNotificationIntent = PublishSubject&lt;Notification&gt;()
</code></pre>

<p>When I do something like this I get the error that it's let constant and I cannot mutate it.</p>

<pre><code>touchSingleNotificationIntent
        .filter { !$0.isRead }
        .do(onNext: { notification in
            notification.isRead = true // I need to change state of the model immediately after user iteration
        })
        .map { $0.notificationID }
        .flatMap(markNotificationAsRead) // http request which doesn't reply with current notification model status
        .subscribe()
        .disposed(by: bag)
</code></pre>

<p>Do you have any ideas how to make it mutable? Thanks.</p>
","4112910","","","","","2018-01-18 16:13:41","Mutating of RxSwift Driver value","<swift><cocoa-touch><rx-swift>","2","2","1","","","CC BY-SA 3.0"
"48348710","1","48378743","","2018-01-19 20:04:38","","0","281","<p>I am initiating an operation via a REST API in two steps:</p>

<ol>
<li>Start operation and return a task id</li>
<li>Poll task with the given id and complete the sequence when the operation returns complete.</li>
</ol>

<p>The polling the task id will return a 202 which indicates that the operation is still in progress and a 200 when it completes. Any other code is an error.</p>

<p>I need to communicate to the subscribers the response of each step.</p>

<p>Previously, I would have the do operator push the response in between steps to a ReplaySubject.</p>

<pre><code>startReboot()
  .do(onNext: { response in
     operationStatus.next(response)
  )
  .flatMap({ response in
     // If we could not get the task ID from the response we error
     guard let taskID = getTaskIDFromJSON(response) else { return Observable.error(API.serverError) }

     return Observable.just(taskID)
  })
  .flatMap({ taskID in
      return pollTask(withID: taskID) // internally, it uses retryWhen to check the api again with a five second delay
  })
  .do(onNext: { response in
     operationStatus.next(response)
  })
  .subscribe(onError: { _ in
     showOperationFailedIcon()
  }, onCompleted: {
     showOperationCompleteIcon()
  })
</code></pre>

<p>And somewhere else, a subscriber to the subject would do the following:</p>

<pre><code>operationStatus.subscribe(onNext: { response
    showResponse(response)
})
</code></pre>

<p>So essentially I am showing the progress of the operation and the response we get from each step at the same time.</p>

<p>At the time I was not familiar with Rx to come up with a cleaner solution. But now that I have familiarized my self with it, it seems to me that there should be a solution where we don't use side effects and contain this to a single final observable. Still, I cannot find a way to do it.</p>

<p>I was thinking about something like this:</p>

<pre><code>let opObs = startReboot()
let pollingObs = pollTask(/* where does the id come from? */)
Observable.concat(opObs, pollingObs)
   .subscribe(onNext : { response in
     showResponse(response)
   }, onError: { _ in
     showOperationFailedIcon()
   }, onCompleted: {
     showOperationCompleteIcon()
   })
</code></pre>

<p>But that would imply that once opObs is done I would need to save the task id in variable outside of the monad and wrap pollingObs to fetch it when it starts - once again introducing side effects.</p>

<p>Is there an operator or combination of operators that I can use to emit the response of each step to a subscriber and also pass it to another observable?</p>
","9241831","","","","","2018-01-22 09:54:18","Emitting progress items while forwarding result in a single observable","<ios><rx-swift><reactivex>","1","0","","","","CC BY-SA 3.0"
"48355486","1","48357468","","2018-01-20 11:19:06","","2","456","<p>I'm trying to observe array change and bind it to the image of the button.</p>

<p>if the array is empty. set picture of an empty cart.</p>

<p>else set image of a cart.</p>

<p>so what I did was :</p>

<pre><code>let x = itemsArray.observeNext { [weak self] (v) in
    let image = v.source.isEmpty ? #imageLiteral(resourceName: ""emptyCart"") : #imageLiteral(resourceName: ""cart"")
    self?.orderItemsButton.setImage(image, for: .normal)
}
</code></pre>

<p>But if I do use this way I must dispose x in viewWillDisappear or something like that...</p>

<p>What is the right way to do it?</p>
","7475692","","2392683","","2018-01-23 17:43:45","2018-01-23 17:43:45","How to bind array count to replace button image","<ios><swift><rx-swift><reactivekit>","2","2","","","","CC BY-SA 3.0"
"48384278","1","48496007","","2018-01-22 14:51:26","","0","672","<p>iam news to rx swift and i really need help for this..
Firstly i have this enum called Cable</p>

<pre><code>enum Cable {
case iphone
case android
case typec

func setProperty() -&gt; (String, String, UIImage, UIImage) {

    switch self {
    case .iphone:
        return (""Apple line""  , ""1"" , #imageLiteral(resourceName: ""icon_borrow_tiv_iphone"") , #imageLiteral(resourceName: ""icon_borrow_t_iphone""))
    case .android:
        return (""Android line"", ""2"" , #imageLiteral(resourceName: ""icon_borrow_tiv_android"") , #imageLiteral(resourceName: ""icon_borrow_t_android""))
    case .typec:
        return (""Type-C line"" , ""3"" , #imageLiteral(resourceName: ""icon_borrow_tiv_typec"") , #imageLiteral(resourceName: ""icon_borrow_t_typec""))
    }
 }

}
</code></pre>

<p>and I have 3 button we will call it <code>iphone</code> button, <code>android</code> button and <code>typec</code> button and in this code im trying to bind it using rx </p>

<pre><code>private func bindActions() {
let tapStream = Observable.of(
              appleBtn.rx.tap.map  ({Cable.iphone.setProperty()}),
              androidBtn.rx.tap.map({Cable.android.setProperty()}),
              typeCBtn.rx.tap.map  ({Cable.typec.setProperty()}))
.merge()

tapStream.map({ name, type, image1, image2 in localized(""label.powerBank"") + name })
    .do(onNext: {[weak self] type in
     self?.borrowBtn.isEnabled = true})
    .bind(to: lineName)
    .disposed(by: disposeBag)

tapStream.map({ name, type, image1, image2 in type})
    .bind(to: cableType)
    .disposed(by: disposeBag)

tapStream.map({ name, type, image1, image2 in image1})
    .bind(to: powerBankImage.rx.image)
    .disposed(by: disposeBag)

tapStream.map({ name, type, image1, image2 in image2})
    .bind(to: cableImage.rx.image)
    .disposed(by: disposeBag)
}
</code></pre>

<p>When applebtn, androidBtn, typeCbtn map the value using the enum func they return 4 value so that i can use it in other stream. The problem is that i dont like how thing are now. I think ts should be the enum should has 4 func that return for its respective value for example setTitle func return the ""Apple Line"" (i havent created the func yet). But how i can set this func to its stream for example if it bind to lineName the map should call the setTitle func ? Since map only return 1 value which is the name when merge. Please help i kinda lost</p>
","6730975","","1113632","","2018-01-24 16:11:47","2018-01-29 07:02:58","Rx swift merge and enum","<swift><rx-swift>","1","2","","","","CC BY-SA 3.0"
"48394305","1","48399490","","2018-01-23 04:33:16","","0","2180","<p>I am using RxSwift in my app to populate the tableview. Currently data is being shown successfully. Now I want to change the cell height on cell tap.. this is I am doing on cell tap.</p>

<pre><code>       _ = dataTable.rx.itemSelected
            .subscribe(onNext: { [weak self] indexPath in
//                let cell = self?.dataTable.cellForRow(at: indexPath) as? TradebookMyRequestCell

                if (self?.btnMyRequest.isSelected)!{
                    print(""index Path \(Int(indexPath.row)) ="")
                    if self?.selectedCellIndexPath != nil &amp;&amp; self?.selectedCellIndexPath == indexPath {
                        //                selectedCellIndexPath = nil
                        self?.cellTapped = true
                    } else {
                        self?.selectedCellIndexPath = indexPath
                        self?.cellTapped = false
                    }

                    self?.dataTable.beginUpdates()

                    let selectedRowIndex = indexPath
                    self?.currentRow = selectedRowIndex.row
                    if !(self?.indexPaths.contains((self?.selectedCellIndexPath!)!))!{
                        self?.indexPaths.append((self?.selectedCellIndexPath!)!)
                    }
                    else {
                        let index = self?.indexPaths.index(of: (self?.selectedCellIndexPath!)!)
                        self?.indexPaths.remove(at: index!)
                    }
                    self?.dataTable.reloadRows(at: [indexPath], with: .fade)
                    self?.dataTable.endUpdates()
                }
        }).disposed(by: disposeBag)
</code></pre>

<p>This is code for height change of cell </p>

<pre><code>func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {
        // cell = nil.
                if btnMyRequest.isSelected  {
                 if indexPaths.contains(indexPath) {
                    cellTapped = true
                        return 120
                    }
                    else {
                    cellTapped = false
                        return 70
                    }
                }else{
                    return 76
                }

    }
</code></pre>

<p>The problem is when I tap the cell, first heightforrow method is called then my cell tap action gets triggered. Since I am new to rx can anyone tell me what I am doing wrong?
Thanks.</p>
","3535237","","","","","2018-01-23 10:30:53","Change cell height on cell tap using RxSwift","<ios11><swift4><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"48399365","1","48404719","","2018-01-23 10:24:15","","1","3620","<p>I have two screens:</p>

<ol>
<li><code>NewControlTableViewController</code>: contains a textfield for selecting a client from the other view</li>
<li><code>ClientsTableViewController</code>: The second view contains a list clients that can be selected</li>
</ol>

<p><a href=""https://i.stack.imgur.com/Rk5XE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Rk5XE.png"" alt=""enter image description here""></a>
<a href=""https://i.stack.imgur.com/pgl5s.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pgl5s.png"" alt=""enter image description here""></a></p>

<p>The two screens share a viewmodel.</p>

<p>So here is my code: </p>

<pre><code>import RxSwift
import RxCocoa
struct NewControlViewModel {
     var selectedClient = Variable&lt;Client&gt;(Client())
     // other stuff
}
// NewControlTableViewController : viewDidLoad
viewModel.selectedClient.asObservable().subscribe { event in
        debugPrint(event)
}
// ClientsTableViewController: viewDidLoad

/*tableView.rx.itemSelected.subscribe(onNext: { indexPath in
        let client = self.clients[indexPath.row]
        debugPrint(client)
        self.viewModel.selectedClient.value = client
        self.navigationController?.popToRootViewController(animated: true)

    }).disposed(by: self.disposeBag)*/
   // new code
   tableView.rx
        .modelSelected(Client.self)
        .debug(""client selected"", trimOutput: true)
        .do(onNext: { _ in
            self.navigationController?.popViewController(animated: true)
        })
        .subscribe(onNext: { client in
            debugPrint(client)
            self.viewModel.selectedClient.value = client
        }, onError: { error in
        debugPrint(error)
    }).disposed(by: disposeBag)
</code></pre>

<p>The event is fired(with empty values) whenever I view the first screen, then, after selecting a client from the second screen, for some reason, no event is being fired.</p>
","711388","","711388","","2018-01-23 15:20:35","2018-01-24 06:39:21","RxSwift: How to correctly subscribe to a variable change","<swift><rx-swift>","2","15","","","","CC BY-SA 3.0"
"48457434","1","48458796","","2018-01-26 07:46:45","","0","184","<p>So what i have is an application that uses a REST endpoint, but before it can use it. It must call a register endpoint which assigns an DeviceId to the device which must be used in all subsequent API calls.</p>

<p>Currently I'm using Moya and RxSwift to chain and transform request.</p>

<p>What i was thinking that i would call a custom operator on my request like so</p>

<pre><code>self.mapRect
         .waitForDeviceId()
         .flatMap { [weak self] mapRect -&gt; Single&lt;Response&gt; in
                    ...
          weakSelf.provider.rx.request(PCDepartmentTarget.list(coordinate: center, distance: maxDistance))
          }
          .map(to: [PCParkingLot].self)
          .bind(to: self.parkingLotOVariable)
          .disposed(by: self.disposeBag)
</code></pre>

<p>Where i was thinking that waitForDeviceId() should look something like this.</p>

<pre><code>extension ObservableType {

    func waitForDeviceId&lt;R&gt;() -&gt; Observable&lt;R&gt; {

        PCDeviceIdService.shared.deviceIdObservable.flatMap { _ -&gt; Observable&lt;R&gt; in
            return self
        }
    }
}
</code></pre>

<p>Which is clearly not compiling. </p>

<p>Do you have any ideas on how to implement such and operator or a perhaps a different way of doing it. Thank you in advance.</p>
","1366083","","","","","2018-01-26 09:40:16","Custom ""flatmap"" to call before each request","<ios><swift><rx-swift><reactive><moya>","1","3","","","","CC BY-SA 3.0"
"48460847","1","","","2018-01-26 11:52:03","","-1","335","<p>I'm reading the Rx-Reactive Programming books by raywenderlich and I am confused by this syntax of Rx Swift:</p>

<pre><code>extension PHPhotoLibrary {
    static var authorized: Observable&lt;Bool&gt; {
        return Observable.create({ observer in
            DispatchQueue.main.async {
                if authorizationStatus() == .authorized {
                    observer.onNext(true)
                    observer.onCompleted()
                } else {
                    observer.onNext(false)
                    requestAuthorization({ newStatus in
                        observer.onNext(newStatus == .authorized)
                        observer.onCompleted()
                    })
                }
            }

            return Disposables.create()
        })
    }
}
</code></pre>

<p>Why does the code have two <code>return</code> statements? Can somebody explain me why we need 2 return statement in the code?</p>
","9272139","","1066219","","2018-01-29 10:17:42","2018-01-29 10:17:42","Confusion in Rx Swift syntax","<ios><swift><rx-swift><reactive>","1","0","","","","CC BY-SA 3.0"
"48470605","1","48471290","","2018-01-26 22:41:34","","1","1084","<p>Lets say I have a function that takes in two arguments - <code>Observable&lt;String?&gt;</code> and <code>Observable&lt;Person?</code>> and returns Observable</p>

<p>This is my sample code below:</p>

<pre><code>return  Observable.combineLatest(self.id, personStream)
                  map { [weak self] (id,person) -&gt; Person? in

     guard let person = person as? Person else {
       return nil
     }

    if let id = id {
       // How do I return this updated person
       self?.updatePersonDetails(for: person, completion: { (updatedPerson) in
            return updatedPerson
       })     
    } else {
       return person
    }
}
</code></pre>

<p>How do I return this updated person inside this mapping function?</p>

<p>Update: </p>

<pre><code>public func updatePerson(personStream: Observable&lt;Person&gt;) -&gt; Observable&lt;Person&gt; {
    return Observable.combineLatest(
            self.id,
            personStream
        ).flatMap { [weak self] (id,person) -&gt; Observable&lt;Person?&gt; in

            guard let person = person as? Double else {
                return Observable.just(nil)
            }

            if let id = id {
                // How do I return this updated person
                return Observable.create { [weak self] observer in
                    self?.updatePersonDetails(for: person, completion: { (updatedPerson) in
                        observer.on(.next(updatedPerson))
                        observer.on(.completed)
                    })
                    return Disposables.create()
                }
            } else {
                return Observable.just(person)
            }
        }
}
</code></pre>

<p>The above function is called as below:</p>

<pre><code>let personUpdateStream = personService.updatePerson(personStream: personDataStream)
Observable.combineLatest(personUpdateStream, nameStream,profileEnabledStream)
.subscribe(onNext: { [weak self] (person, name, isEnabled) in
                print(name)
                self?.updatePersonView(person: person, name: name, isLocked: !isEnabled)
            })
            .disposed(by: disposeBag)
</code></pre>

<p>Issue: The block inside combineLatest with the <code>print(name)</code> never runs. May I know whats the issue here?</p>

<p>Description of <code>personUpdateStream</code> </p>

<p><code>personUpdateStream   RxSwift.FlatMap&lt;(String?, Person?), RxSwift.Observable&lt;Person?&gt;&gt;    0x0000604001e5af70</code></p>
","1253102","","1113632","","2018-01-28 14:24:18","2018-01-28 14:24:18","RxSwift - Use two observable to make a async call","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 3.0"
"48485091","1","48485564","","2018-01-28 09:56:20","","21","11223","<p>Sorry. I am confused what is binding in Rxswift. As far as I know, <code>observable</code> won't produce value unless a observer subscribed on it, e.g <code>myObservable.subscribe(onNext: {})</code>. 
<br><br>But when I read the follow line of code: <br> </p>

<pre><code>// in LoginViewModel.swift
init() {
    isValid = Observable.combineLatest(username.asObservable(), password.asObservable()) { (username, password) in
        return !username.isEmpty &amp;&amp; !password.isEmpty
    }
}

// in LoginViewController.swift
viewModel.isValid.bind(to: loginButton.rx.isEnabled).disposed(by: disposeBag)
</code></pre>

<p>I am confused here why the <code>isValid</code> Observable is able to be observed without calling a <code>subscribe</code> method on it?<br>Why we can just call bind(to:) in <code>LoginViewController.swift</code> without calling something like <code>viewModel.isValid.subscribe(...)</code></p>
","3068410","","1113632","","2018-01-28 13:29:39","2019-05-24 09:32:31","Rxswift observable bind(to:) vs subscribe(onNext:)","<swift><rx-swift>","2","0","6","","","CC BY-SA 3.0"
"48486687","1","","","2018-01-28 13:08:36","","3","805","<p>I use Pickerview with Rx and i would like to know how you can change view of the selected row with a custom view. i tried on a picker view without RX it works. But the same with Rx and Custom Adapter don't work. Do you have an idea to do this ?</p>

<p>Thanks for your answers :</p>

<p>For example without Rxswift :</p>

<pre><code>func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -&gt; UIView {

        let customView = LimitItemPickerView(frame: CGRect.zero)

        if pickerView.selectedRow(inComponent: component) == row {
            customView.selected()
        }

        return customView

    }
</code></pre>

<p>My implementation : </p>

<pre><code>final class `PickerViewViewAdapter: NSObject, UIPickerViewDataSource, UIPickerViewDelegate, RxPickerViewDataSourceType, SectionedViewDataSourceType {
    typealias Element = [MyMODEL]
    private var items: [MyMODEL] = []

    func model(at indexPath: IndexPath) throws -&gt; Any {
        return items[indexPath.row]
    }

    func numberOfComponents(in pickerView: UIPickerView) -&gt; Int {
        return 1
    }

    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int {
        return items.count
    }

    func pickerView(_ pickerView: UIPickerView, rowHeightForComponent component: Int) -&gt; CGFloat {
        return 80.0
    }

    func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -&gt; UIView {
        let customView = MyCustomView(frame: CGRect.zero, model: items[row])

        return customView
    }

    func pickerView(_ pickerView: UIPickerView, observedEvent: Event&lt;Element&gt;) {
        UIBindingObserver(UIElement: self) { (adapter, items) in
            adapter.items = items
            pickerView.reloadAllComponents()
            }.on(observedEvent)
    }
}`
</code></pre>

<p>To use this :</p>

<pre><code>  let input = MYVIEWMODEL.Input(param1: key,
                                               param2: key2,
                                               param3: key3)

    let output = myViewModel.transform(input: input)


    output.limitsAvailable
        .drive(limitPickerView.rx.items(adapter: PickerViewViewAdapter()))
        .disposed(by: disposeBag)
</code></pre>
","9279509","","9279509","","2018-01-30 08:27:04","2018-01-30 08:27:04","How put a custom view on a selected row for an uipickerview rxswift?","<ios><swift><uipickerview><rx-swift><rx-cocoa>","0","2","","","","CC BY-SA 3.0"
"48486832","1","","","2018-01-28 13:25:40","","0","318","<p>So I have a <code>AddToDoViewModelInput</code> object that stores multiple <code>Observable&lt;T&gt;</code> values.  I'd like to be able to access all of the observable values at once so that I can copy their contents into a <code>AddItemViewControllerProperties</code> object.  This object stores non-observable data.  This object will eventually get converted into a <code>AddToDoViewModelOutput</code> object.  So basically I have:</p>

<pre><code>AddToDoViewModelInput -&gt; AddItemViewControllerProperties -&gt; AddToDoViewModelOutput
</code></pre>

<p>The <code>AddToDoViewModelInput</code> and <code>AddToDoViewModelOutput</code> objects contain observables while <code>AddItemViewControllerProperties</code> does not contain observables.</p>

<p>Currently, I am using <code>combineLatest</code> to combine the observables inside of <code>AddToDoViewModelInput</code> and in my closure passed to <code>combineLatest</code> I am creating an <code>AddItemViewControllerProperties</code> object and returning it.</p>

<p>I'm not sure if using <code>combineLatest</code> in this way is correct or not.  I thought that I remember that <code>combineLatest</code> will fire if <strong>any</strong> of the observables emit events, so in my case this may not be what I want.
Is there an existing pattern or best practice that I can follow to implement this correctly?</p>

<pre><code>let disposeBag = DisposeBag()

struct AddToDoViewModelInput {
    let day: Observable&lt;Int&gt;
    let name: Observable&lt;String&gt;
}

struct AddItemViewControllerProperties {
    let dayOfTheWeek: Int?
    let name: String
}

struct AddToDoViewModelOutput {
    let message: Observable&lt;String&gt;
}

let input = AddToDoViewModelInput(
    day: Observable.of(2),
    name: Observable.of(""Tuesday"")
)

let propertiesObs: Observable&lt;AddItemViewControllerProperties&gt; = 
  Observable.combineLatest(input.name, input.day)
{
    (name, day) in
    return AddItemViewControllerProperties(dayOfTheWeek: day, name: name)
}

let messageObs: Observable&lt;String&gt; = propertiesObs.map{ properties in
    return ""For day #\(properties.dayOfTheWeek!) the name is \(properties.name)""
}

messageObs
    .debug(""messageObs"")
    .subscribe(onNext: { message in print(message) })
    .disposed(by: disposeBag)

let output = AddToDoViewModelOutput(message: messageObs)
}
</code></pre>
","6902806","","","","","2018-01-28 13:25:40","Best way of accessing inner Observables in RxSwift?","<swift><rx-swift>","0","3","","","","CC BY-SA 3.0"
"48505049","1","","","2018-01-29 15:47:53","","1","813","<p>I have a custom <code>UICollectionViewCell</code> with a <code>UILabel</code> inside it.
Is also has the property <code>hour</code>, which is <code>String?</code> for the sake of the example.</p>

<p>I made a private function named <code>bind</code> to configure my bindings. Here is my class:</p>

<pre><code>class HourCollectionViewCell: UICollectionViewCell {
    @IBOutlet weak var hourLabel UILabel!
    let hour Variable&lt;String?&gt; = Variable&lt;String?&gt;("""")
    let disposeBag: DisposeBag = DisposeBag()

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        bind()
    }

    private func bind() {
        hour.asObservable().bind(to: hourLabel.rx.text).disposed(by: disposeBag)
        hour.asObservable().subscribe(onNext: {debugPrint(""New hour: \($0 ?? ""--"")"")}).disposed(by: disposeBag)
    }
}
</code></pre>

<p>Calling <code>bind</code> inside the required init might be a problem. Sometimes the <code>hourLabel</code> is still not initialized. Also, calling this function inside <code>init(frame: CGRect)</code> never gets the <code>bind</code> function to be triggered, which is awkward. I thought this function was always called.</p>

<p>Even though this is a simple binding, I can't achieve it correctly.</p>

<p>From inside my <code>UICollectionViewController</code>, I have this function which fills the <code>hour</code> property from my custom cell:</p>

<pre><code>override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ""HourCollectionViewCell"", for: indexPath) as! HourCollectionViewCell
        var text: String = ""\(indexPath.row)""

        // This does not work because `bind` method
        // is never called.
        cell.hour.value = text

        return cell
    }
</code></pre>

<p><strong>UPDATE:</strong>
I've seen that <code>init:coder</code> is called when I'm initializing the View from a Storyboard, which is the case.</p>

<p>A workaround that I've seen <a href=""https://stackoverflow.com/questions/37957262/custom-uicollectionviewcell-class-init-not-being-called#answers"">here</a> is to call <code>bind</code> from inside <code>layoutSubviews</code>. This way everything worked. Is this the better approach?</p>
","1085977","","1085977","","2018-01-29 17:15:33","2018-01-30 14:14:30","RxSwift - Can't bind variable of custom UICollectionViewCell","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 3.0"
"48544524","1","48546848","","2018-01-31 14:26:16","","3","1389","<p>The question is - where it’s best to:</p>

<ol>
<li>Call error handling popups</li>
<li>Show/Hide loading indicator</li>
</ol>

<p>My app looks like this:</p>

<p><strong>ViewController</strong> that subscribes to trigger of UI update when the model changes:</p>

<pre><code> var viewModel: ViewModel = ViewModel()
</code></pre>

<p>...</p>

<pre><code> viewModel.source.asObservable().subscribe(onNext: { (_ ) in
      self.tableView.reloadData()
     })
    .disposed(by: bag)
</code></pre>

<p><strong>ViewModel</strong></p>

<pre><code>     var source = Variable&lt;[Student]&gt;([])
</code></pre>

<p>And when initialized it fetches the source output</p>

<pre><code>     api.fetchSourceOutput(id: id)
         .do(onError: { (error) in
                //show error here???
         })
         .catchErrorJustReturn([])
         .bind(to: source)
         .disposed(by: bag)
</code></pre>

<p>I can't just pass reference of ViewController into ViewModel, that would break the idea of it's independence from UI. Then how am I supposed to call error popup in view controller's view? Getting top view controller is not a good option either, because I might need specific view to show my popup in.
The loading indicator can be shown when onNext called inside viewModel and hidden onCompleted. But I again don't have reference to my view controller where my loading indicator reference resides. </p>

<p>Ideas?</p>
","2528850","","3031021","","2018-01-31 14:33:34","2018-02-04 13:17:11","In the RxSwift-MVVM architecture what is the best way to trigger UI elements like pop-ups and indicators?","<ios><mvvm><rx-swift>","2","0","3","","","CC BY-SA 3.0"
"48558208","1","48560814","","2018-02-01 08:22:35","","4","2918","<p>with RxSwift 3.6.1 I made this extension to ObservableType to get a new token after an error request:</p>

<pre><code>public extension ObservableType where E == Response {
    public func retryWithToken() -&gt; Observable&lt;E&gt; {
        return retryWhen { error -&gt; Observable&lt;Response&gt; in
            return error.flatMap({ (error) -&gt; Observable&lt;Response&gt; in
                if let myApiError: MyApiError = error as? MyApiError {
                    if (myApiError == MyApiError.tokenError) {
                        return Session.shared.myProvider.request(.generateToken)
                    } else {
                        return Observable.error(myApiError)
                    }
                }
                return Observable.error(error)
            })
        }
    }
}
</code></pre>

<p>and then I can use it:</p>

<pre><code>Session.shared.myProvider.rx
    .request(.mySampleRequest)
    .filterSuccessfulStatusCodes()
    .retryWithToken()
    .subscribe { event in
        ....
    }.disposed(by: self.disposeBag)
</code></pre>

<p>but with RxSwift 4.0.0 now the sequence expect a 
    <code>PrimitiveSequence&lt;SingleTrait, Response&gt;</code></p>

<p>someone can explain to me how to do the same with RxSwift 4.0.0? I try with an extension to PrimitiveSequence but I've some compilation errors.</p>
","7204485","","","","","2018-02-01 10:43:19","correct use of retryWhen operator with RxSwift 4.0.0","<rx-swift><moya>","1","0","","","","CC BY-SA 3.0"
"48560956","1","","","2018-02-01 10:49:46","","0","2500","<p>I have a ViewModel where an service class is defined, This service class is initialized in this ViewModel's initializer. Now I need to update my View when there is any change in its value in ViewModel(getting it from service). Although I have found some examples of using Variable but I could not find it with Class injection.
ViewController:</p>

<pre><code>    var presenter:Variable&lt;CardViewModelProtocol&gt;!
        func setPresenter() {
//Following line has error
            self.presenter = Variable&lt;CardViewModelProtocol&gt;(CardViewModelProtocol(service:CardService()))
            self.presenter.value.attachView(view: self)
        }
</code></pre>

<p>the line where presenter is initialized is giving error.
Error:</p>

<blockquote>
  <p>'CardPresenterProtocol' cannot be constructed because it has no accessible initializers</p>
</blockquote>

<p>Following is how the ViewModel initialized:</p>

<pre><code>var cardService:CardServiceContract!
var materialNum = Variable&lt;String&gt;("""")

init(service:CardServiceContract){
    self.cardService = service
}
</code></pre>

<p><strong>Edit1:</strong> In short I want to convert following line to RxSwift supporting Variables and observe a variable(class object) in CardViewModel:</p>

<pre><code>self.presenter = CardViewModel(service: CardService())
</code></pre>

<p><strong>Edit2:</strong></p>

<pre><code>    protocol CardViewModelProtocol : BaseViewModelProtocol {

    func loadCardInfo(Serial serial:String)

    var materialNum: Variable&lt;String&gt; {get set}
}
protocol BaseViewModelProtocol {
    func attachView(view: BaseViewProtocol)
}
protocol BaseViewProtocol{
    func setViewModel()
}
</code></pre>
","260056","","260056","","2018-02-01 11:51:50","2018-02-01 19:36:24","observing a class Variable for any change in viewModel in RxSwift","<ios><swift><rx-swift>","1","15","","","","CC BY-SA 3.0"
"48578202","1","","","2018-02-02 07:59:29","","5","10503","<p>I am trying to bind a string value in ViewModel to a label in my ViewController but I am getting following error:</p>

<blockquote>
  <p>Value of type 'Observable' has no member 'bind'
  My code for binding in ViewController:</p>
</blockquote>

<pre><code>self.viewModel.myNum
        .map( { $0 })
        .bind(to: serialNumberLabel.rx.text)
</code></pre>

<p>myNum is defined in viewModel as following:</p>

<pre><code>var myNum: Observable&lt;String&gt;
</code></pre>

<p>No I have 2 problems here:
1. Above error in ViewController
2. Initializing myNum in ViewModel
I tried following for initializing myNum but I am getting error:</p>

<pre><code>materialNum = Observable&lt;String&gt;("""")
</code></pre>
","260056","","1776859","","2019-02-18 11:36:54","2019-02-18 11:36:54","Value of type 'Observable<String>' has no member 'bind'","<swift><mvvm><rx-swift>","2","0","1","","","CC BY-SA 4.0"
"48579420","1","48580478","","2018-02-02 09:20:20","","0","406","<p>I'm trying to add an headerView to a collectionView using RxSwift.</p>

<p>I get this error: </p>

<blockquote>
  <p>Cannot convert call result type '(<em>) -> Disposable' to expected type '(</em>) -> </p>
</blockquote>

<p>at this line:</p>

<pre><code>obsHeader.asObservable().bind(to: collectionView.rx.items(dataSource: dataSource)).disposed(by: disposeBag)
</code></pre>

<p>I don't understand how to fix it. Any help?</p>

<p>I post here the rest of the code:</p>

<pre><code>struct SectionItemObject {
    let collectionViewRecommendations: UICollectionView
    let items: [SFCardViewModelListOfCardsProtocol]
}

struct SectionOfItems {
    var items: [Item]
}

extension SectionOfItems: SectionModelType {

    typealias Item = SectionItemObject

    init(original: SectionOfItems, items: [Item]) {
        self = original
        self.items = items
    }

    init(items: [Item]?) {
        self.items = items ?? [Item]()
    }
}
</code></pre>

<p>And this is what I write in the method I call to observe.</p>

<pre><code>let dataSource = RxCollectionViewSectionedReloadDataSource&lt;SectionOfItems&gt;(configureCell: { (datasource, collectionview, indexPath, i) -&gt; UICollectionViewCell in
        let cell = collectionview.dequeueReusableCell(withReuseIdentifier: ""CardView"", for: indexPath) as! CardView
        //                self.setCell(card:card,cell:cell)
        cell.lbTitle.text = ""TEST""
        return cell
    }, configureSupplementaryView: { (datasource, collectionview, kind, indexPath) -&gt; UICollectionReusableView in
        let section = collectionview.dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: ""AddNewCardCollectionHeaderView"", for: indexPath) as! AddNewCardCollectionHeaderView
        section.backgroundColor = UIColor.orange
        section.collectionViewRecommendations = self.collectionViewRecommendations
        return section
    } )

let item = SectionItemObject(collectionViewRecommendations: self.collectionViewRecommendations!, items: viewModelProtocol.searchedCards.value)
let obsHeader = Variable(SectionOfItems(items: [item]))

obsHeader.asObservable().bind(to: collectionView.rx.items(dataSource: dataSource)).disposed(by: disposeBag)
</code></pre>
","3797475","","3797475","","2018-02-02 10:05:39","2018-02-02 10:17:14","RxSwift Cannot convert call result type '(_) -> Disposable' to expected type '(_) ->","<uicollectionview><rx-swift><uicollectionreusableview><rx-cocoa><rxdatasources>","1","2","","","","CC BY-SA 3.0"
"48582797","1","","","2018-02-02 12:33:34","","2","976","<p>I'm using RxSwift, I managed to create the dataSource and I retrieve cells correctly. Problem is with the section headerView. I have created a UICollectionReusableView class, attaching outlets from storyboard. </p>

<p>The problem is that I retrieve the view with collectionview.dequeueReusableSupplementaryView, but awakeFromNib is never called! </p>

<p>This is how I setup the collectionView</p>

<pre><code>collectionView.register(UINib(nibName: ""CardView"", bundle: Bundle.main), forCellWithReuseIdentifier: ""cardView"")
collectionView.register(AddNewCardCollectionHeaderView.self, forSupplementaryViewOfKind: UICollectionElementKindSectionHeader, withReuseIdentifier: ""AddNewCardCollectionHeaderView"")
</code></pre>

<p>this is my UICollectionReusableView class</p>

<pre><code>class AddNewCardCollectionHeaderView: UICollectionReusableView {

    @IBOutlet weak var collectionViewRecommendations: UICollectionView!
    @IBOutlet weak var viewWrapperRecommendations: UIView!

    override func awakeFromNib() {
        super.awakeFromNib()

    }

}
</code></pre>

<p>And this is the dataSource</p>

<pre><code>let dataSource = RxCollectionViewSectionedReloadDataSource&lt;SectionOfItems&gt;(configureCell: { (datasource, collectionview, indexPath, i) -&gt; UICollectionViewCell in
            let cell = collectionview.dequeueReusableCell(withReuseIdentifier: ""cardView"", for: indexPath) as! CardView
            let card = self.getCard(atRow: indexPath.row, isCardRecommendation: false)
            self.setCell(card:card,cell:cell)
            return cell
        }, configureSupplementaryView: { (datasource, collectionview, kind, indexPath) -&gt; UICollectionReusableView in
            let headerView = collectionview.dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: ""AddNewCardCollectionHeaderView"", for: indexPath) as! AddNewCardCollectionHeaderView
            return headerView
        })
</code></pre>

<p>As awakeFromNib is not called, if I do for example headerView. viewWrapperRecommendations it will crash as nil, but I need to access to headerView outlets.</p>

<p>But, instead, awakeFromNib of CardView (the cell class) is called and it works perfectly.</p>

<p>Any help? Thanks!</p>
","3797475","","","","","2021-05-01 22:29:39","awakefromnib not called for UICollectionReusableView when using RxSwift datasource","<ios><rx-swift><uicollectionreusableview><rx-cocoa><rxdatasources>","0","4","1","","","CC BY-SA 3.0"
"48591669","1","48600790","","2018-02-02 22:18:26","","2","1401","<p>I'm trying to create isHighlighted Observable for my UIButton, to send sequence every time isHiglighted for UIButton has changed. And I've write something like this</p>

<pre><code>extension Reactive where Base: UIButton {

    var isHighlighted: Observable&lt;Bool&gt; {

        let property = self.base.rx.controlProperty(editingEvents: .allTouchEvents,
                                                    getter: { _ in self.base.isHighlighted },
                                                    setter: { (_, _) in })
        return property
            .distinctUntilChanged()
            .asObservable()
    }
}
</code></pre>

<p>The problem is, that it doesn't work for <code>.touchUpInside</code>. If I drag finger outside UIButton and then come back, it works fine, but not for tap action. I think immediately after <code>.touchUpInside</code> it's still highlighted for very short time.</p>
","2467179","","2467179","","2018-02-02 22:27:33","2018-02-04 07:09:39","Make Observable for UIButton isHighlighted property","<ios><swift><rx-swift><rx-cocoa>","2","3","1","","","CC BY-SA 3.0"
"48594514","1","","","2018-02-03 06:13:07","","0","748","<p>How to fix this problem <code>Terminating app due to uncaught exception 'RLMException', reason: 'Realm accessed from incorrect thread.'</code> , I spent 2 days looking for the solution for this problem. I hope someone could help me. I tried to debug and trace it and I found out it successfully enter to <code>.subscribe(onNext:)</code> and read <code>controller?.tableView.reloadData()</code> but If I continue program execution it will just terminate and error display in the console log.</p>

<pre><code>        searchBar
            .rx.text
            .orEmpty
            .debounce(0.5, scheduler: MainScheduler.instance)
            .distinctUntilChanged()
            .filter { !$0.isEmpty }
            .map({ [weak controller = self] query -&gt; (tcb: [TrialCourtBranches], query: String)? in
                switch controller?.tcbArray {
                case .some(let array):
                    return (array, query)
                case .none:
                    return nil
                }
            })
            .observeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated)) // change thread before filtering
            .map({ (query) -&gt; [TrialCourtBranches] in // filter and return the result of filtering
                let realm = try! Realm()
                let tcb = realm.objects(TrialCourtBranches.self)
                let tcb_safe = ThreadSafeReference(to: tcb)
                let filtered = realm.resolve(tcb_safe)
                let tcb_filtered:[TrialCourtBranches] = (filtered?.filter({ $0.branch_name.lowercased().contains(searchText.lowercased()) }))!
                return tcb_filtered
            })
            .observeOn(MainScheduler.instance) // go back to main thread
            .subscribe(onNext: { [weak controller = self] (filtered) in
                tcb_filteredArray = filtered
                controller?.tableView.reloadData()
            })
            .disposed(by: bag)
</code></pre>
","6044292","","4667835","","2018-02-03 11:48:32","2018-02-05 05:52:14","How to fix Terminating app due to uncaught exception 'RLMException', reason: 'Realm accessed from incorrect thread.'?","<swift><search><realm><rx-swift><reactiveui>","2","0","","","","CC BY-SA 3.0"
"48622142","1","","","2018-02-05 11:59:59","","1","4284","<p>I have been facing an issue with binding UITextField or button with observables in viewModel.</p>

<pre><code>class VM {
    var emailObservable: Observable&lt;String?&gt; = Observable.just("""")
}
</code></pre>

<p>I have this observable for email in my viewModel and in controller. When i try to bind my textfield with it, it gives me error </p>

<blockquote>
  <p>Cannot invoke 'bind' with an argument list of type '(to: Observable)'.</p>
</blockquote>

<p>But when i replace the observables with Variable, it works fine.</p>

<p>Can someone please help me with this. I found answers which mainly include passing the observable in the init method of viewModel, but i don't want to pass it in the init method.</p>

<p>This is the link i found for binding but it is through init method. </p>

<p><a href=""https://stackoverflow.com/questions/38372747/how-to-bind-rx-tap-uibutton-to-viewmodel"">How to bind rx_tap (UIButton) to ViewModel?</a></p>
","8484106","","2463616","","2018-02-05 12:21:01","2018-05-03 10:19:42","Binding UITextField or button with viewModel","<ios><swift><mvvm><rx-swift>","5","2","1","","","CC BY-SA 3.0"
"48692849","1","","","2018-02-08 18:56:06","","4","1985","<p>Im using <code>RxSwift</code> and <code>RxDataSources</code> to create table view.</p>

<p>But I do not want to reload all cells when only one cell is changed.</p>

<p>How can I achieve this with <code>RxSwift</code>?</p>

<p>Current solution.</p>

<pre><code>private let dataSource = RxTableViewSectionedReloadDataSource&lt;VehicleCheckDeteilsSectionModel&gt;()
</code></pre>

<p>Cell configuration.</p>

<pre><code>dataSource.configureCell = {[weak self] (_, tableView: UITableView, indexPath: IndexPath, item: VehicleCheckDeteilsCellModel) in
    return self?.deteilsCellFactory(in: tableView, for: indexPath, with: item) ?? UITableViewCell()
}
</code></pre>

<p>Bund of the data.</p>

<pre><code>let sectionModelObserver = viewModel?.tableSectionModel.asObservable().observeOn(MainScheduler.instance).share()
sectionModelObserver?.bind(to: self.deteilsTableView.rx.items(dataSource: dataSource)).disposed(by: disposeBag)
</code></pre>
","1213285","","","","","2018-02-09 09:36:59","How can I update only cells in RxDataSources that are changed and not all of them?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"48712791","1","","","2018-02-09 19:24:54","","1","1462","<p>I'm starting to realize the benefits of using <code>RxSwift</code> and making an attempt to incorporate it into my code, but I'm not sure I'm understanding the usage of <code>DelegateProxy</code>.</p>

<p>Currently in my code I have the following:</p>

<pre><code>struct SampleModel: Decodable
{
    var first_name: String
    var last_name: String

    init(first_name: String, last_name: String)
    {
        self.first_name = first_name
        self.last_name = last_name
    }
}

class ViewModel
{
    var model: SampleModel

    public var fullName: String {
        return model.first_name + model.last_name
    }

    init(model: SampleModel)
    {
        self.model = model
    }
}
</code></pre>

<p>I am using a protocol and delegate like so:</p>

<pre><code>protocol NetworkDelegate
{
    func dataReceived(data: [Decodable]?, error: Error?)
}

class Network: NSObject
{
    var databaseLink = String()

    var networkDelegate: NetworkDelegate!

    init(databaseLink: String)
    {
        super.init()

        self.databaseLink = databaseLink
    }

    func getDatabaseData&lt;T: Decodable&gt;(model: T.Type)
    {
        guard let url = URL(string: databaseURL) else {
            return
        }

        request(url).responseJSON { (json) in
            switch json.result
            {
                case .success:
                    guard let data = json.data else {
                        return
                    }

                    do
                    {
                        let models = try JSONDecoder().decode([T].self,
                                                              from: data)

                        self.networkDelegate.dataReceived(data: models,
                                                          error: nil)
                    }
                    catch let jsonErr
                    {
                        print(jsonErr)
                    }

                case .failure(let error):
                    self.networkDelegate.dataReceived(data: nil,
                                                      error: error)
            }
        }
    }
}

extension ViewController: NetworkDelegate
{
    func dataReceived(data: [Decodable]?, error: Error?)
    {
        guard let models = data else {
            return
        }

        for model in models
        {
            guard let myModel = model as? SampleModel else {
                return
            }

            viewModels.append( ViewModel(model: myModel) )
        }
    }
}

var viewModels = [ViewModel]()
weak var networkDelegate: NetworkDelegate?

override func viewDidLoad()
{
    super.viewDidLoad()

    let network = Network(databaseLink: ""some url"")
    network.networkDelegate = self
    network.getDatabaseData(model: SampleModel.self)
}
</code></pre>

<p>On researching this topic <code>RxSwift</code>, I've found the following:</p>

<ol>
<li><a href=""https://stackoverflow.com/questions/48316075/is-this-the-best-way-to-convert-swift-protocol-to-rxdelegateproxy"">Is this the best way to convert Swift protocol to RxDelegateProxy?</a></li>
<li><a href=""https://stackoverflow.com/questions/41783083/cannot-receive-event-with-custom-delegateproxy-and-protocol"">Cannot receive event with custom DelegateProxy and Protocol</a></li>
</ol>

<p>Using it as reference I created some skeleton code:</p>

<pre><code>import RxSwift
import RxCocoa

protocol NetworkDelegate: class
{
    func dataReceived(data: [Decodable]?, error: Error?)
}

class NetworkDeleteProxy: DelegateProxy&lt;ViewController, NetworkDelegate&gt;, DelegateProxyType
{
    public static func registerKnownImplementations()
    {
        &lt;#code#&gt;
    }

    public static func currentDelegate(for object: ViewController) -&gt; NetworkDelegate?
    {
        return object.networkDelegate
    }

    public static func setCurrentDelegate(_ delegate: NetworkDelegate?, to object: ViewController)
    {
        &lt;#code#&gt;
    }
}
</code></pre>

<p>However, I'm a bit confused afterwards on how to implement the rest of the functionality and use like the original way:</p>

<pre><code>let network = Network(databaseLink: ""some url"")
network.networkDelegate = self
network.getDatabaseData(model: SampleModel.self)
</code></pre>

<p>How can I achieve this? Thanks.</p>
","2373410","","","","","2018-02-09 20:10:12","How to replace protocol with DelegateProxy from RxSwift?","<ios><swift><rx-swift>","1","1","1","","","CC BY-SA 3.0"
"48719468","1","","","2018-02-10 09:58:41","","3","3287","<p>Is there a way to ignore a completable if there is an error ?
For example, I wan't to remove value in my <code>Firebase Realtime Database</code>, and delete a picture to <code>Firebase Storage</code> when the first completable has finish :</p>

<pre><code>// MARK: DELETE - FUNCTION
public func delete(id: String) -&gt; Completable {
    return databaseRef.child(""objects"").child(id).rx.removeValueAsCompletable()
        .andThen(storageRef.child(""objects"").child(id).rx.delete())
}
</code></pre>

<p>The picture may not exists on Storage, so the <code>delete</code> function return an error if the child doesn't exist and the Completable of the <code>delete(id: String)</code> function return also an error. I wan't to ignore the second function if it returns an error, is it possible ? Does a function named <code>ignoreOnError()</code> exists in RxSwift, or something like that ?</p>

<p>Thanks for your help !</p>
","4529612","","","","","2021-07-05 14:03:54","Ignore error on Completable - RxSwift","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"48730265","1","","","2018-02-11 09:53:18","","0","1448","<p>How can I retry network requesting with maxCount (some sort of failure), eg. 5 times or until the server is returning something of what I want using RxSwift's <code>retry</code> operator.</p>

<p>What I suppose to do is:</p>

<ol>
<li>when success became ""ok"", stop retrying and emit <code>queryedSuccess</code> immediately</li>
<li>when success is still yet ""fail"", continue retrying until maxCount reaches 5 and emit <code>queryedFail</code></li>
</ol>

<p>The struct of JSON return from server looks like this:</p>

<pre><code>struct QueryAlipayOrderEnvelope {
    var success: String // ""ok"" or ""fail""
    var tradeNumber: String
}
</code></pre>

<p>Here is what I attempt to do:</p>

<pre><code>struct ViewModel {

    var viewWillAppearTrigger = PublishSubject&lt;Void&gt;()
    var rechargeTrigger = PublishSubject&lt;Void&gt;()
    var outTradeNumber = PublishSubject&lt;String&gt;()

    var queryedSuccess: Driver&lt;QueryAlipayOrderEnvelope&gt;
    var queryedFail: Driver&lt;QueryAlipayOrderEnvelope&gt;

    let queryResult = self.outTradeNumber.asObservable()
        .flatMapLatest { tradeNum in
            AppEnvironment.current.apiService.queryAlipayOrder(outTradeNumber: tradeNum).materialize().debug(""queryAlipayOrder"", trimOutput: true)
        }
        .share(replay: 1)
        .retry(5)

    self.queryedSuccess = queryResult
        .elements()
        .skipWhile { $0.success != ""ok"" }
        .takeLast(1)
        .asDriver(onErrorDriveWith: .never())
        .debug(""queryedSuccess"", trimOutput: true)

    // this will emit when all 5 `success` are `fail`
    self.queryedFail = queryResult
        .elements()
        .takeLast(1)
        .filter { $0.success != ""ok"" }
        .asDriver(onErrorDriveWith: .never())
        .debug(""queryedFail"", trimOutput: true)
}
</code></pre>

<p>However, the request only called once and being disposed without any retrying.</p>
","4234171","","4234171","","2018-02-11 10:38:07","2018-02-11 10:38:07","RxSwift - Retry network request with maxCount until success","<swift><rx-swift>","1","2","","","","CC BY-SA 3.0"
"48730658","1","","","2018-02-11 10:44:38","","0","536","<p>I am trying to get a string from <code>ViewModel</code> to <code>View</code> using <code>PublishSubject()</code> but <code>View</code> is not able to get it. Following is my code in <code>ViewModel</code>:</p>

<pre><code>var myImageURL: PublishSubject&lt;String&gt; = PublishSubject&lt;String&gt;()

self.myService.getImage(materialNo: materialNumber).subscribe(
    onNext: { [weak self] imageURL in //I am able to get url here and want to send it to View, following doesn't work
        self?.myImageURL.onNext(imageURL)
        self?.myImageURL.onCompleted()
    },
    onError: { error in },
    onCompleted: { }
)
.disposed(by: disposeBag)
</code></pre>

<p>Code in <code>View</code>:</p>

<pre><code>let disposeBag = DisposeBag()

self.viewModel.myImageURL.subscribe(
    onNext: { 
        print($0 + "" image url"")
        self.myImageView.af_setImage(withURL: URL(string: $0)!, placeholderImage:UIImage(named: ""tool_placeholder""))
    },
    onError: {
        print(String(describing: $0).capitalized)
    }
)
.disposed(by: disposeBag)
</code></pre>

<p>Although viewModel code works fine but I am not able to receive its value in <code>View</code>.</p>

<p><strong>Edit1:</strong>
Updated code in view with drive:</p>

<pre><code>self.viewModel.myImageURL
        .asObservable()
        .asDriver(onErrorJustReturn: ""Error"")
        .drive(onNext: {
                        self. myImageView.af_setImage(withURL: URL(string: $0)!, placeholderImage:UIImage(named: ""tool_placeholder""))
                    }
            )
        .disposed(by: disposeBag)
</code></pre>
","260056","","260056","","2018-02-12 06:55:38","2018-02-12 06:55:38","Getting string from ViewModel to View in RxSwift","<ios><swift><mvvm><rx-swift>","2","1","","","","CC BY-SA 3.0"
"48769783","1","48880695","","2018-02-13 15:04:07","","0","309","<p>I’am studying RxSwift and have this one case. 
From tableView cell, I go to info restaurant, and if I change the rate for this restaurant, I want to change this rate in tableView too, but I don’t want to update tableView, because restaurants are downloaded from the backend,  cause  restaurants data is not loaded every time when viewWillApear is called. Now I’m using cloujers, in prepareForSegue, I’m setting a new rate in cell from its info. I read that the cloujers are used in a lot of resources, can this be done with the help of RxSwift or another best way?</p>
","9287751","","","","","2018-02-20 08:25:51","Best performance to passing data between controllers","<ios><swift><uitableview><rx-swift>","1","1","","","","CC BY-SA 3.0"
"48780488","1","","","2018-02-14 05:53:14","","-1","2594","<p>I am trying to fetch object array values from an observable response in rxswift.  And using the values i want to call another api as a nested observable .Can anyone suggest me a solution to solve this. pls..</p>

<p>this is my code snippet.....</p>

<pre><code>_ = Alamofire.request(""httpbin.org/get"").rx.responseJSON() 
.map { value in 
let json = value as? [String: Any] ?? [:] 
let origin = json[""origin""] as? String ?? ""unknown"" print(origin)
return origin } 
.subscribe(onNext: { print(""Origin:"", $0) })
</code></pre>
","9358391","","9358391","","2018-02-14 11:28:13","2018-02-15 08:59:03","How to fetch objects from observable response in rxswift?","<swift><rx-swift>","1","10","","","","CC BY-SA 3.0"
"48790405","1","48796512","","2018-02-14 15:12:20","","17","7072","<p>I would like to have a UITextField configured with RxSwift/RxCocoa so that it only contains up to ... characters. I do not want to use the <code>UITextFieldDelegate</code> for this but would love to achieve this with RxSwift/RxCocoa. Is there a way to do this?</p>
","27404","","","","","2018-02-14 22:17:15","RxSwift/RxCocoa: prevent UITextField from having more than ... characters","<swift><rx-swift><rx-cocoa>","1","0","4","","","CC BY-SA 3.0"
"48807334","1","","","2018-02-15 12:30:06","","-2","619","<p>How to call an API with the response from another API  using RxSwift and Alamofire library? In order to get a final result array. Can anyone suggest me one example..</p>
","9358391","","3825016","","2018-02-15 15:34:41","2018-02-15 15:34:41","How to call an API with the response from another API using RxSwift and Alamofire library?","<swift><alamofire><rx-swift>","1","0","","","","CC BY-SA 3.0"
"48813011","1","48817234","","2018-02-15 17:26:54","","1","1513","<p>I have a simple <code>ViewModel</code> with one property:</p>

<pre><code>class ViewModel {
    var name = Variable&lt;String&gt;("""")
}
</code></pre>

<p>And I'm binding it to its <code>UITextField</code> in my <code>ViewController</code>:</p>

<pre><code>class ViewController : UIViewController {

    var viewModel : ViewModel!

    @IBOutlet weak var nameField : UITextField!

    private let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()
        // Binding
        nameField.rx.text
            .orEmpty
            .bind(to: viewModel.name)
            .disposed(by: disposeBag)
    }
}
</code></pre>

<p>Now, I want to Unit Test it. </p>

<p>I'm able to fill the <code>nameField.text</code> property though Rx using <code>.onNext</code> event - <code>nameField.rx.text.onNext(""My Name Here"")</code>.</p>

<p>But the <code>viewModel.name</code> isn't being filled. Why? How can I make this Rx behavior work in my XCTestCase?</p>

<p>Please see below the result of my last test run:</p>

<p><a href=""https://i.stack.imgur.com/qEHbY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qEHbY.png"" alt=""Last Test Run Screenshot""></a></p>
","1154508","","1974224","","2018-02-15 19:57:46","2019-09-17 18:10:22","How to test the UI Binding between RxSwift Variable and RxCocoa Observable?","<ios><swift><unit-testing><rx-swift><rx-cocoa>","2","4","","","","CC BY-SA 3.0"
"48836507","1","","","2018-02-16 23:53:56","","0","299","<p>I am very new in RxSwift so question maybe a little strange: 
I need to observe change in UIWebView.request.
At first it is nil so need to catch when it get any assign.
I tried:</p>

<pre>

myWebView.rx.observe(URLRequest.self, #keyPath(UIWebView.request)
.subscribe {
print ($0)
}

</pre>

<p>Nothing. Got at first next(nil). and never call it again.</p>

<p>I tried:</p>

<pre>

myWebView.rx.observe(URLRequest.self, #keyPath(RUIWebView.request), options: [.new, .initial], retainSelf: true)

</pre>

<p>Also nothing.</p>

<p>thanks.</p>
","8760604","","8760604","","2018-02-16 23:59:30","2018-02-16 23:59:30","Observe optional","<swift><optional><rx-swift>","0","8","","","","CC BY-SA 3.0"
"48855982","1","","","2018-02-18 20:00:07","","5","2370","<p>I'm quite new to RxSwift. I have a view controller that has a typeahead/autocomplete feature (i.e., user types in a UITextField and as soon as they enter at least 2 characters a network request is made to search for matching suggestions). The controller's <code>viewDidLoad</code> calls the following method to set up an Observable:</p>

<pre><code>class TypeaheadResultsViewController: UIViewController {

var searchTextFieldObservable: Observable&lt;String&gt;!
@IBOutlet weak var searchTextField: UITextField!
private let disposeBag = DisposeBag()
var results: [TypeaheadResult]?

override func viewDidLoad() {
    super.viewDidLoad()
    //... unrelated setup stuff ...
    setupSearchTextObserver()
}

func setupSearchTextObserver() {
            searchTextFieldObservable =
                self.searchTextField
                    .rx
                    .text
                    .throttle(0.5, scheduler: MainScheduler.instance)
                    .map { $0 ?? """" }

            searchTextFieldObservable
                .filter { $0.count &gt;= 2 }
                .flatMapLatest { searchTerm in self.search(for: searchTerm) }
                .subscribe(
                    onNext: { [weak self] searchResults in
                        self?.resetResults(results: searchResults)
                    },
                    onError: { [weak self] error in
                        print(error)
                        self?.activityIndicator.stopAnimating()
                    }
                )
                .disposed(by: disposeBag)

            // This is the part I want to test:        
            searchTextFieldObservable
                .filter { $0.count &lt; 2 }
                .subscribe(
                    onNext: { [weak self] _ in
                        self?.results = nil
                    }
                )
                .disposed(by: disposeBag)
    }
}
</code></pre>

<p>This seems to work fine, but I'm struggling to figure out how to <em>unit test</em> the behavior of <code>searchTextFieldObservable</code>. 
To keep it simple, I just want a unit test to verify that <code>results</code> is set to <code>nil</code> when <code>searchTextField</code> has fewer than 2 characters after a change event.<br>
I have tried several different approaches. My test currently looks like this:</p>

<pre><code>    class TypeaheadResultsViewControllerTests: XCTestCase {
        var ctrl: TypeaheadResultsViewController!

        override func setUp() {
            super.setUp()
            let storyboard = UIStoryboard(name: ""MainStoryboard"", bundle: nil)
            ctrl = storyboard.instantiateViewController(withIdentifier: ""TypeaheadResultsViewController"") as! TypeaheadResultsViewController
        }

        override func tearDown() {
            ctrl = nil
            super.tearDown()
        }

        /// Verify that the searchTextObserver sets the results array
        /// to nil when there are less than two characters in the searchTextView
        func testManualChange() {
          // Given: The view is loaded (this triggers viewDidLoad)
          XCTAssertNotNil(ctrl.view)
          XCTAssertNotNil(ctrl.searchTextField)
          XCTAssertNotNil(ctrl.searchTextFieldObservable)

          // And: results is not empty
          ctrl.results = [ TypeaheadResult(value: ""Something"") ]

          let tfObservable = ctrl.searchTextField.rx.text.subscribeOn(MainScheduler.instance)
          //ctrl.searchTextField.rx.text.onNext(""e"")
          ctrl.searchTextField.insertText(""e"")
          //ctrl.searchTextField.text = ""e""
          do {
              guard let result =
                try tfObservable.toBlocking(timeout: 5.0).first() else { 
return }
            XCTAssertEqual(result, ""e"")  // passes
            XCTAssertNil(ctrl.results)  // fails
        } catch {
            print(error)
        }
    }
</code></pre>

<p>Basically, I'm wondering how to manually/programmatically fire an event on <code>searchTextFieldObservable</code> (or, preferably, on the <code>searchTextField</code>) to trigger the code in the 2nd subscription marked ""This is the part I want to test:"". </p>
","916757","","916757","","2018-02-19 02:15:39","2021-02-23 22:42:20","Unit-test RxSwift observable in ViewController","<ios><swift><unit-testing><rx-swift>","4","4","","","","CC BY-SA 3.0"
"48870397","1","","","2018-02-19 16:34:39","","0","575","<p>There's a crash in parameter casting: </p>

<blockquote>
  <p>Could not cast value of type NSStackBlock (0x1030b1e78) to '(__C.UNNotificationPresentationOptions) -> ()' (0x1030b0208).
  2018-02-19 17:40:31.204021+0200 [2407:480530]</p>
  
  <p>Could not cast value of type NSStackBlock (0x1030b1e78) to '(C.UNNotificationPresentationOptions) -> ()' (0x1030b0208).</p>
</blockquote>

<pre><code>extension Reactive where Base: UNUserNotificationCenter {

public var delegate: DelegateProxy&lt;UNUserNotificationCenter, UNUserNotificationCenterDelegate&gt; {
    return RxNotificationServiceDelegateProxy.proxy(for: base)
}

var didReceiveResponce: Observable&lt;UNNotificationResponse&gt; {
    return delegate.methodInvoked(#selector(UNUserNotificationCenterDelegate.userNotificationCenter(_:didReceive:withCompletionHandler:))).map { parameters in
        return parameters[1] as! UNNotificationResponse
    }
}

var willPresentNotification: Observable&lt;((UNNotificationPresentationOptions) -&gt; Void)&gt; {
    return delegate.methodInvoked(#selector(UNUserNotificationCenterDelegate.userNotificationCenter(_:willPresent:withCompletionHandler:))).map { parameters in
        return parameters[2] as! ((UNNotificationPresentationOptions) -&gt; Void) **CRASH!!!**
    }
}
}
</code></pre>

<p>All I need is to show localNotifications in the foreground, so delegate method needed accordingly, but can not figure out how to do so I can pass the closure as a parameter to an Observable or if it's not possible or not needed I will be glad to read about your way of solving such issue in RxSwift manner.</p>
","6057584","","8035900","","2018-02-20 08:56:13","2018-02-20 08:56:13","Reactive extension for UNUserNotificationCenter RxSwift","<ios><swift><uilocalnotification><rx-swift><unusernotificationcenter>","0","4","","","","CC BY-SA 3.0"
"48899427","1","","","2018-02-21 06:27:33","","-3","676","<p>How to emit a single object from flatmap to filter in rxswift? </p>

<p>I want to get a single object from an object array response at flatmap, and I want to get that single object in order to filter the object based on its type. Can anyone suggest me how to solve this?</p>
","9389318","","5459839","","2018-02-21 20:19:11","2018-02-21 20:19:11","How to emit a single object from flatmap to filter in RxSwift?","<swift><alamofire><rx-swift>","1","2","","","","CC BY-SA 3.0"
"48908380","1","","","2018-02-21 14:28:10","","0","670","<p>I have a text field that is used to capture the users' login name.</p>

<ol>
<li>The user taps inside of the text field.  The text field emits an empty string event.</li>
<li>The user then taps in some text (""123"").  The text field emits an event for each character.</li>
<li>The user then taps inside of another text field.  The text field emits an event that represents the latest state of the text field (""123"").</li>
</ol>

<p>I'm wondering why the text field emits the last event, and is there a way to suppress the last event.  I tried adding <code>distinctUntilChanged</code> but that had no effect.  I would think that <code>distinctUntilChanged</code> would not fire the last event since it is the same as the previous event.</p>

<pre><code>let userNameStream: Observable&lt;String&gt; = userNameText
  .rx
  .text
  .orEmpty
  .skip(1)
  .debug(""userNameStream"")
  .asObservable()
  .share(replay:1)
  .distinctUntilChanged()
</code></pre>

<p>The output</p>

<pre><code>018-02-21 06:05:29.303: userNameStream -&gt; Event next()
  userNameText : editingDidBegin
2018-02-21 06:05:38.448: userNameStream -&gt; Event next(1)
2018-02-21 06:05:43.369: userNameStream -&gt; Event next(12)
2018-02-21 06:05:48.880: userNameStream -&gt; Event next(123)
2018-02-21 06:06:03.224: userNameStream -&gt; Event next(123) // Duplicate Event!
  userNameText : editingDidEnd
</code></pre>
","6902806","","","","","2018-02-22 02:53:57","Duplicate event when editingDidEnd called on UITextField RxSwift","<rx-swift>","2","0","","","","CC BY-SA 3.0"
"48923958","1","","","2018-02-22 09:37:18","","0","2429","<p>How to emit single values from array using rxswift? Let say I have an array contains user details of a company, and I want to emit each users one by one using rxswift. </p>

<p>Any help would be appreciated.</p>
","9395472","","7128479","","2018-02-22 15:55:13","2018-02-22 15:55:13","How to emit single values from array using rxswift?","<rx-swift>","1","0","","","","CC BY-SA 3.0"
"48971269","1","","","2018-02-25 07:31:50","","2","121","<p>For an example, there is simple task which makes network call and then maps the result.</p>

<pre><code>class Task {

    func execute() -&gt; Single&lt;String&gt; {
        return doSomeRequest().flatMap { [weak self] data in
            if let string = self?.map(data: data) {
                return .just(string)
            }
            return .error(Error())
        }
    }

    func doSomeRequest() -&gt; Single&lt;Data&gt; {
        // makes network call and returns Data 
    }

    func map(data: Data) -&gt; String? {
        // maps Data to String 
    }
}
</code></pre>

<p>And there is function that uses this <code>Task</code>:</p>

<pre><code>func fetchSomeString() {
    Task().execute().subscribe(onSuccess: { string in
        print(string)
    }).disposed(by: disposeBag)
}
</code></pre>

<p>The problem is that <code>Task</code> is deinitialized before even get response from <code>doSomeRequest()</code>, due to <code>weak self</code> in <code>flatMap</code>. One of the solution would be to store Task instance as a property, but let's say there is no place in my case for that. </p>

<p>Is there any solution that doesn't lead to memory leaks in <code>flatMap</code>, but executes <code>Task</code> properly?</p>
","4386668","","","","","2018-02-25 13:14:03","Object is deinited before flatMap is called","<ios><swift><reactive-programming><rx-swift>","4","0","","","","CC BY-SA 3.0"
"48999339","1","52768459","","2018-02-27 00:34:39","","2","2622","<p>I'm trying to use a <code>UISegmentedControl</code> with <code>rx.selectedSegmentIndex</code> to bind to my viewModel actions. In my viewModel I have these properties: </p>

<pre><code>let showSomething1: AnyObserver&lt;Void&gt;
let showSomething2: AnyObserver&lt;Void&gt;
let showSomething3: AnyObserver&lt;Void&gt;
</code></pre>

<p>In my view controller</p>

<pre><code>segmentControl.rx.selectedSegmentIndex.....

viewModel.showSomething1 if index 1
viewModel.showSomething2 if index 2
viewModel.showSomething3 if index 3
</code></pre>

<p>In my <code>rx.selectedSegmentIndex</code> i would like to bind to these but depending on the index of the <code>selectedSegmentIndex</code>, what is the best way to do this with RxSwift?</p>

<p>I also want to an animation regardless of which index is selected.</p>

<p>Thanks in advance</p>
","4016564","","5991255","","2018-02-27 05:07:35","2018-10-11 20:28:53","RxSwift conditional binding","<ios><swift><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"49002619","1","","","2018-02-27 06:39:48","","0","940","<p>How to get response of a nested api call using RxSwift and alamofire? Here i get a response from an alamofire api cal and with that result i need to call another api call. I want to get the second api call response. Can anyone suggest me a solution to solve this. please.</p>

<pre><code>func origin() -&gt; Observable&lt;String&gt; {
return Alamofire.request(""httpbin.org/get"").rx.responseJSON() 
</code></pre>

<p>}</p>

<pre><code>func otherApiCall(with origin: String) -&gt; Observable&lt;YourType&gt; {
// Other api call using origin
return Alamofire...........
</code></pre>

<p>}</p>

<blockquote>
  <p>then</p>
</blockquote>

<pre><code>origin()
.flatMap{ origin in 
    otherApiCall(with: origin)  
}
.subscribe(onNext: { response in 

})
.disposed(by: disposeBag)
</code></pre>
","9395472","","9395472","","2018-02-27 07:16:10","2018-02-27 08:34:22","How to get response of a nested api call using RxSwift and alamofire?","<alamofire><rx-swift><rxalamofire>","1","4","","","","CC BY-SA 3.0"
"49025544","1","","","2018-02-28 09:00:09","","0","324","<p>This is my view model </p>

<pre><code>var filterVM = BehaviorRelay(value: [Filter(title: ""Filter 1"", isSelected: false),
                                     Filter(title: ""Filter 2"", isSelected: false),
                                     Filter(title: ""Filter 3"", isSelected: false),
                                     Filter(title: ""Filter 4"", isSelected: false),
                                     Filter(title: ""Filter 5"", isSelected: false),
                                     Filter(title: ""Filter 6"", isSelected: false),
                                     Filter(title: ""Filter 7"", isSelected: false)])
</code></pre>

<p>When I tapped cell in collectionView,
I want to change its blur effect to be <code>UIBlurEffectStyle.light</code> (focus in this cell) And the remaining cells to be <code>UIBlurEffectStyle.dark</code>, 
and the previous pressed cell became black, how to do it?</p>

<pre><code>filtersCollectionView
        .rx
        .itemSelected
        .subscribe(onNext: { [weak self] indexPath in
            let cell = self?.filtersCollectionView.cellForItem(at: indexPath) as? FilterCollectionViewCell
            cell?.blurForLabel.effect = UIBlurEffect(style: .light)
        }).disposed(by: disposeBag)
</code></pre>

<p><a href=""https://i.stack.imgur.com/nLDuz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nLDuz.png"" alt=""enter image description here""></a></p>
","9287751","","7718634","","2018-02-28 09:56:52","2018-02-28 09:56:52","RxSwift I want editing cell when I Tapped","<ios><swift><reactive-programming><rx-swift>","0","7","","","","CC BY-SA 3.0"
"49029439","1","49043223","","2018-02-28 12:19:30","","1","151","<p>I'm so frustrated on searching what is the equivalent of this java code on swift:</p>

<pre><code>public abstract class BaseApiSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; {
   private WeakReference&lt;MvpView&gt; mvpViewWeakReference;
   private WeakReference&lt;BasePresenter&gt; basePresenterWeakReference;

   public BaseApiSubscriber(BasePresenter basePresenter, MvpView mvpView) {
     this.basePresenterWeakReference = new WeakReference&lt;&gt;(basePresenter);
     this.mvpViewWeakReference = new WeakReference&lt;&gt;(mvpView);
   }

   @Override
   public void onCompleted() {
   }

   @Override
   public void onError(Throwable e) {
      //handle generic errors here, call also the mvpView to handle generic responses on UI
   }

   @Override
   public void onNext(T t) {
   }
</code></pre>

<p>Basically here, I'm extending <code>Subscriber</code> so all of the generic response of API is handled on a single file. This works on my java (android), but I can't find how to make this work on swift. I tried searching about <code>extensions</code>, <code>protocols</code> but it seems they can't be extended. I did try to search, but I don't know the keyword for this, I try to code blindly (hoping it will work) but I can't. Maybe just a keyword, basic sample, or an explanation on this. Am I doing it right, right? Ready also for the downvotes because I just can't post a good code on swift. It is not even close to this.</p>

<p><strong>Update:</strong>
Somehow I got close to it, thanks to @luk2302, but then how can I implement this? Here's my code:</p>

<pre><code>class BaseSubscriber: ObserverType {

typealias E = Response

func on(_ event: Event&lt;Response&gt;) {
    switch event {
    case .next(let _):
        print(""Successing"")
        break
    case .error(let error):
        print(""Erorring"")

        if let serviceError = error as? ServiceError {
            print(""service error: "" + serviceError.errorDescription!)
        }

        print(error)
        break
    case .completed:
        print(""Completing"")
        break
    }
}
}
</code></pre>

<p>Then I need to call this from here:</p>

<pre><code>let base = BaseSubscriber()
repo.login(param: loginParam).subscribe(
     //Ive tried this:
     //base.on: {
     //}
     //but got an syntax error maybe hahahaha
)
</code></pre>

<p>What do you call this? So I can search and read about it. Thank you.</p>

<p><strong>Update 2:</strong>
Thanks to @Cristik, I've managed to do it, and by passing a <code>closures</code>, I can now pass methods to do specific task per request. My updated code:</p>

<pre><code>func baseSubscriber&lt;T&gt;(mvpView: BaseMvpView, onNext: @escaping (T) -&gt; Void, onError: @escaping (Error) -&gt; Void, onCompleted: @escaping () -&gt; Void)  -&gt; (RxSwift.Event&lt;T&gt;) -&gt; Void {
return { [weak mvpView] event in
    switch event {
    case let .next(element):
        mvpView?.hideLoading()
        print(""super next"")
        onNext(element)

    case .completed:
        mvpView?.hideLoading()
        print(""super completed"")
        onCompleted()

    case let .error(error):
        mvpView?.hideLoading()
        print(""super error"")
        if let serviceError = error as? ServiceError {
            print(""Service error: \(serviceError.errorDescription ?? ""Something wrong"")"")
        } else {
            onError(error)
        }
    }
}
</code></pre>

<p>}</p>

<p>But this is different to my approach on java in which I can <code>override</code> the <code>onError()</code> method so in case I want to disregard the generic error handling, I can do it. How can I apply it to swift?</p>

<p>Update 3:</p>

<p>BaseMvpView.swift</p>

<pre><code>protocol BaseMvpView: class {

   func showLoading(message: String)

   func hideLoading()
}
</code></pre>

<p>BaseTableViewController.swift</p>

<pre><code>class BaseTableViewController: UITableViewController, BaseMvpView {

var indicator: UIActivityIndicatorView?

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
    // Dispose of any resources that can be recreated.
}

override func viewDidLoad() {
    super.viewDidLoad()

    indicator = UIActivityIndicatorView(activityIndicatorStyle: UIActivityIndicatorViewStyle.gray)
    indicator?.frame = CGRect(origin: CGPoint.init(x: 0, y: 0), size: CGSize.init(width: 40, height: 40));
    indicator?.center = view.center
    view.addSubview(indicator!)
    indicator?.bringSubview(toFront: view)
    UIApplication.shared.isNetworkActivityIndicatorVisible = true
}

func showLoading(message: String) {
    indicator?.startAnimating()
}

func hideLoading() {
    indicator?.stopAnimating()
}
}
</code></pre>
","9038584","","9038584","","2018-03-06 11:35:54","2018-03-06 11:49:19","Swift overriding methods","<java><swift><rx-java><rx-swift>","1","10","","","","CC BY-SA 3.0"
"49031599","1","49811981","","2018-02-28 14:14:42","","3","597","<p>I was first introduced to reactive programming with <strong>ReactiveCocoa</strong> several years ago. In there they had the notion on <code>RACCommand</code>s, which was carried over to <strong>RxSwift</strong> with the extension library <strong><a href=""https://github.com/RxSwiftCommunity/Action"" rel=""nofollow noreferrer"">Action</a></strong>.</p>
<p>As stated on their GitHub page:</p>
<blockquote>
<p>An action is a way to say &quot;hey, later I'll need you to subscribe to this thing.&quot;</p>
<p>Actions accept a <code>workFactory</code>: a closure that takes some input and produces an observable. When <code>execute()</code> is called, it passes its parameter to this closure and subscribes to the work.</p>
<ul>
<li>Can only be executed while &quot;enabled&quot; (true if unspecified).</li>
<li>Only execute one thing at a time.</li>
<li>Aggregates next/error events across individual executions.</li>
</ul>
</blockquote>
<p>In my experience it is an absolutely <em>indispensable</em> tool in the reactive programming toolbox when doing robust, reactive iOS development.</p>
<hr />
<p>Now we would like to carry this over to <strong>Android</strong> app as well. But after countless hours of research I have not been able to find a corresponding component for either <strong>RxJava</strong> or <strong>RxKotlin</strong>.</p>
<p>The implementation in Swift is relatively straight forward, so we <em>could</em> just port it, but I'd first like to hear if:</p>
<ol>
<li>This really does not exists, and if so</li>
<li>Is there an Android specific reason for this to not exist, i.e. a reason <strong>not</strong> to port it</li>
</ol>
","746968","","-1","","2020-06-20 09:12:55","2018-04-13 07:55:37","RxSwift like Actions for Android","<android><ios><rx-java><rx-swift><rx-kotlin>","1","3","","","","CC BY-SA 3.0"
"49132292","1","","","2018-03-06 13:43:43","","0","270","<p>I've created some <em>very basic data bindings</em> with variables between my VC and VM using RxSwift (which I've very new to), and am now perplexed as to how best communicate other UI actions from the VM that need additional data passed along with them.</p>

<p>Such as trigger popup alerts for error message passing, navigation controls, etc. as I want to send parameters along with them.</p>

<p>I've thought about using delegation again.  But would it be inappropriate to mix bindings and delegation together in the same VM?</p>

<p>I'd like to abstract a pattern that can template to other MVVM areas of the app that would need to do the same thing for each VC/VM mix.</p>
","7599","","","","","2018-03-06 14:00:54","Any alternative to using delegation in passing data to the UI from the ViewModel in iOS?","<ios><mvvm><swift4><rx-swift>","1","4","","","","CC BY-SA 3.0"
"49183310","1","","","2018-03-08 22:09:08","","0","613","<p>I have an object created from  <code>flatMap</code>ing an observable. </p>



<pre class=""lang-swift prettyprint-override""><code>private lazy var childObj: chilView? = {

    let keychainStore = Realm().getStore()

    let selectedElementID = keychainStore.elementID
        .asObservable()
        .distinctUntilChanged {$0 == $1}
        .flatMap({ (elementID) -&gt; Observable&lt;Element?&gt; in
            guard let elementID = elementID else {
                return Observable.error(Errors.InvalidElementID)
            }

            return Observable.create { observer in
                let elementStream: Observable&lt;Result&lt;Element&gt;&gt; = keychainStore.getObservable(id: elementID)
                elementStream.subscribe(onNext: { (result) in
                    switch result {
                    case .success(let element):
                        observer.onNext(element)
                    default: break
                    }
                })
                .disposed(by: self.disposeBag)

                return Disposables.create()
            }
        })

    return self.createChildObject(with: selectedElementID)
}()
</code></pre>

<p>The selectedElement is of type flatMap observable. <code>createChildObject(with:)</code> is called even before <code>observer.onNext(element)</code> is executed. How do I fix this?</p>
","1253102","","2369487","","2018-03-15 08:44:50","2018-03-15 08:44:50","RxSwift Observable race condition","<ios><swift><observable><rx-swift>","1","1","","","","CC BY-SA 3.0"
"49197415","1","49247170","","2018-03-09 15:49:55","","5","2560","<p>I'm new to RxSwift and trying to learn by creating a simple signup form. I want to implement it using a <code>UITableView</code> (as an exercise, plus it will become more complicated in the future) so I'm currently using two types of cells:</p>

<ul>
<li>A <code>TextInputTableViewCell</code> with just a <code>UITextField</code></li>
<li>A <code>ButtonTableViewCell</code> with just a <code>UIButton</code></li>
</ul>

<p>In order to represent each cell, I created an enum which looks like that:</p>

<pre><code>enum FormElement {
    case textInput(placeholder: String, text: String?)
    case button(title: String, enabled: Bool)
}
</code></pre>

<p>and use it in a <code>Variable</code> to feed the tableview:</p>

<pre><code>    formElementsVariable = Variable&lt;[FormElement]&gt;([
        .textInput(placeholder: ""username"", text: nil),
        .textInput(placeholder: ""password"", text: nil),
        .textInput(placeholder: ""password, again"", text: nil),
        .button(title: ""create account"", enabled: false)
        ])
</code></pre>

<p>by binding like that:</p>

<pre><code>    formElementsVariable.asObservable()
        .bind(to: tableView.rx.items) {
            (tableView: UITableView, index: Int, element: FormElement) in
            let indexPath = IndexPath(row: index, section: 0)
            switch element {
            case .textInput(let placeholder, let defaultText):
                let cell = tableView.dequeueReusableCell(withIdentifier: ""TextInputTableViewCell"", for: indexPath) as! TextInputTableViewCell
                cell.textField.placeholder = placeholder
                cell.textField.text = defaultText
                return cell
            case .button(let title, let enabled):
                let cell = tableView.dequeueReusableCell(withIdentifier: ""ButtonTableViewCell"", for: indexPath) as! ButtonTableViewCell
                cell.button.setTitle(title, for: .normal)
                cell.button.isEnabled = enabled
                return cell
            }
        }.disposed(by: disposeBag)
</code></pre>

<p>So far, so good - this is how my form looks like:</p>

<p><a href=""https://i.stack.imgur.com/JDNr0.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/JDNr0.png"" alt=""enter image description here""></a>  </p>

<p>Now, the actual problem I'm facing here, is <strong>how am I supposed to enable the <em>create account</em> button when all the 3 text inputs are not empty and the password is the same in both password textfields</strong>? In other words, what is the right way to apply changes to a cell, based on events happening on one or more of the other cells?</p>

<p>Should my goal be to change this <code>formElementsVariable</code> through the ViewModel or is there any better way to achieve what I want?</p>
","289501","","","","","2018-03-18 14:57:05","How to update a tableview's cell based on values from other cells using MVVM/RxSwift?","<ios><swift><mvvm><rx-swift><rx-cocoa>","4","2","4","","","CC BY-SA 3.0"
"49212915","1","","","2018-03-10 19:02:44","","3","1469","<p>New to RxSwift here. I have a (MVVM) view model that represents a Newsfeed-like page, what's the correct way to subscribe to change in data model's properties? In the following example, <code>startUpdate()</code> constantly updates <code>post</code>. The computed properties <code>messageToDisplay</code> and <code>shouldShowHeart</code> drives some UI event. </p>

<pre><code>struct Post {
    var iLiked: Bool
    var likes: Int
    ...
}

class PostViewModel: NSObject {
    private var post: Post

    var messageToDisplay: String {
        if post.iLiked { return ... }
        else { return .... }
    }

    var shouldShowHeart: Bool {
        return iLiked &amp;&amp; likes &gt; 10
    }

    func startUpdate() {
        // network request and update post
    }
    ...
}
</code></pre>

<p>It seems to me in order to make this whole thing reactive, I have to turn each properties of <code>Post</code> and all computed properties into <code>Variable</code>? It doesn't look quite right to me.</p>
","3808183","","","","","2018-03-15 07:58:37","RxSwift correct way to subscribe to data model property change","<ios><swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49240441","1","","","2018-03-12 16:47:07","","2","1050","<p>I have some array of values in my code and I'd like to pass it through sequence of Single and Completable methods:</p>

<pre><code>let data: [DataClass]

func method1(_ data: DataClass) -&gt; Single&lt;DataClass2&gt; { ... }
func method2(_ data2: DataClass2) -&gt; DataClass3? { ... }
func method3(_ data3: DataClass3) -&gt; Completable { ... }
</code></pre>

<p>I try to do it with this code:</p>

<pre><code>func iNeededMethod() -&gt; Completable {

    return Completable.merge(
      data
        .flatMap { value -&gt; Completable in
          method1(value)
            .map(method2)
            .filter { $0 != nil }
            .map { $0! }
            .map(method3)
    })
  }
</code></pre>

<p>But it doesn't work for me with error:</p>

<pre><code>Cannot convert value of type 'PrimitiveSequence&lt;MaybeTrait, Completable&gt;' (aka 'PrimitiveSequence&lt;MaybeTrait, PrimitiveSequence&lt;CompletableTrait, Never&gt;&gt;') to closure result type 'Completable' (aka 'PrimitiveSequence&lt;CompletableTrait, Never&gt;')
</code></pre>

<p>What did I do wrong?</p>
","3742622","","472495","","2020-02-08 09:11:53","2020-02-08 09:11:53","RxSwift: How to merge array of Completable to Completable","<ios><swift><rx-swift>","0","2","","","","CC BY-SA 4.0"
"49244270","1","49246181","","2018-03-12 20:56:03","","6","11349","<p>Since Variable is deprecated in RxSwift 4, what is the equivalent way for <code>BehaviorSubject</code> to do the following?</p>

<pre><code>let observable = Variable&lt;[Int]&gt;([])
observable.value.append(1)
</code></pre>
","3808183","","","","","2019-06-27 13:27:34","RxSwift how to append to BehaviorSubject<[]>","<swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"49254269","1","","","2018-03-13 10:51:42","","2","769","<p>I'm aware that this is a bit of a taste thing, but:</p>

<p>REST API requests to e.g. <code>GET /entity/{id}</code> can yield either one entity or a 404. In such cases, what would be the best <a href=""https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#maybe"" rel=""nofollow noreferrer"">RxSwift trait</a> to use?</p>

<ul>
<li>A <code>Single&lt;T&gt;</code> that emits an <code>error</code>-event if the entity is not found</li>
<li>A <code>Single&lt;T?&gt;</code> that emits an <code>.next(nil)</code>-event if the entity is not found</li>
<li>A <code>Maybe&lt;T&gt;</code> that emits no elements and just completes if the entity is not found</li>
</ul>

<p>What would be best practice?</p>
","2897872","","2897872","","2018-03-13 12:10:46","2018-03-13 12:55:00","RxSwift: Single<T>, Single<T?> or Maybe<T>?","<swift><traits><rx-swift><reactivex>","1","0","","","","CC BY-SA 3.0"
"49271118","1","49273193","","2018-03-14 06:33:24","","0","1299","<p>Below is the example code of RxAlamofire network request. My problem is that I want to cancel this request whenever the View Controller is dismissed.</p>

<p>I tried to assign this request to a global variable but <code>requestJSON</code> method returns <code>Observable&lt;(HTTPURLResponse, Any)&gt;</code> type.</p>

<p>Is there a way to handle this request when the View Controller is dismissed?</p>

<pre><code>RxAlamofire.requestJSON(.get, sourceStringURL)
            .debug()
            .subscribe(onNext: { [weak self] (r, json) in
                if let dict = json as? [String: AnyObject] {
                    let valDict = dict[""rates""] as! Dictionary&lt;String, AnyObject&gt;
                    if let conversionRate = valDict[""USD""] as? Float {
                        self?.toTextField.text = formatter
                            .string(from: NSNumber(value: conversionRate * fromValue))
                    }
                }
                }, onError: { [weak self] (error) in
                    self?.displayError(error as NSError)
            })
            .disposed(by: disposeBag)
</code></pre>
","5393286","","","","","2018-03-14 16:45:45","RxAlamofire cancel network request","<ios><swift><rx-swift><rx-cocoa><rxalamofire>","2","0","","","","CC BY-SA 3.0"
"49283243","1","","","2018-03-14 16:38:06","","1","2912","<p>I wonder what's the correct way to ""forward"" (if that's the term) an observable to the observer of an observable I create.</p>

<p>Below there's an example.</p>

<p>My function <code>performSomeActionAfterConfirmation</code> displays an <code>UIAlertController</code> and returns a new observable. If ""yes"" is selected in the alert controller, I ""forward"" <code>otherObservable()</code> to the observer of the created observable. If ""no"" is selected, I just complete the observable.</p>

<p>I guess my code will work, since I've done something similar in RxJava, but in this case I get a warning in <code>self?.otherObservable().subscribe(observer)</code> saying that ""Result of call to 'subscribe' is unused"".</p>

<p>I guess I have to assign it to a DisposeBag, but I don't know how, since the bag is managed by the caller of <code>performSomeActionAfterConfirmation</code>. Maybe I should pass it as an argument to the function?</p>

<pre><code>func performSomeActionAfterConfirmation() -&gt; Observable&lt;String&gt; {

    return Observable&lt;String&gt;.create { [weak self] observer in

        let alertCtrl = UIAlertController(title: ""perform action"", message: ""do it?"", preferredStyle: .alert)

        // yes -&gt; forward another observable
        alertCtrl.addAction(UIAlertAction(title: ""yes"", style: .default, handler: { _ in
            self?.otherObservable().subscribe(observer) // Result call is unused
        }))

        // no -&gt; just complete this observable
        alertCtrl.addAction(UIAlertAction(title: ""no"", style: .default, handler: { _ in
            observer.onCompleted()
        }))

        self?.host?.present(alertCtrl, animated: true)

        return Disposables.create()
    }
}

func otherObservable() -&gt; Observable&lt;String&gt; {
    return Observable.empty() // dummy code
}
</code></pre>
","1121497","","","","","2018-03-14 17:11:26","How to return/forward an observable inside Observable.create (RxSwift)","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49296351","1","49299438","","2018-03-15 09:58:15","","0","389","<p>Let's say I have a table view to present products.</p>

<p>Here is my viewModel:</p>

<h3>ProductViewModel.swift</h3>

<pre><code>var selectedObserver: AnyObserver&lt;Product&gt;
var state: Driver&lt;Set&lt;Product&gt;&gt;
var selectedSubject = PublishSubject&lt;Product&gt;()

self.selectedObserver = selectedSubject.asObserver()

self.state =
        selectedSubject.asObservable()
        .scan(Set()) { (acc: Set&lt;Product&gt;, item: Product) in
            var acc = acc
            if acc.contains(item) {
                acc.remove(item)
            } else {
                acc.insert(item)
            }
            return acc
        }
        .startWith(Set())
        .asDriver(onErrorJustReturn: Set())

 self.isSelectedAll = Driver
        .combineLatest(
            self.state.map { $0.count },
            envelope.map { $0.products.count })
        .debug()
        .map { $0.0 == $0.1 }
</code></pre>

<p>As you see, every time I select an object, I will <code>scan</code> it into the state observable, so the cell can then observe the state change.</p>

<p>Here is the RxSwift binding between cell and viewModel:</p>

<h3>ProductViewController.swift</h3>

<pre><code>self.viewModel.deliveries
        .drive(self.tableView.rx.items(cellIdentifier: DeliveryTableViewCellReusableIdentifier, cellType: DeliveryTableViewCell.self)) { (_, item, cell) in
            cell.bind(to: self.viewModel.state, as: item)
            cell.configureWith(product: item)
        }
        .disposed(by: disposeBag)

self.tableView.rx.modelSelected(Product.self)
        .asDriver()
        .drive(self.viewModel.selectedObserver)
        .disposed(by: disposeBag)
</code></pre>

<h3>ProductCell.swift</h3>

<pre><code>func bind(to state: Driver&lt;Set&lt;Product&gt;&gt;, as item: Product) {
    state.map { $0.contains(item) }
    .drive(self.rx.isSelected)
    .disposed(by: rx.reuseBag)
}
</code></pre>

<p>Well, so far so good. </p>

<p>Now my question is how can I make a select all action e.g. tapping a select all button, so that all product will be somehow <em><code>scan</code></em> into states? </p>
","4234171","","","","","2018-03-15 12:25:00","How can I select all item at once using RxSwift operator?","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49299586","1","","","2018-03-15 12:32:15","","2","2005","<p>My view models are fundamentally flawed because those that use a driver will complete when an error is returned and resubscribing cannot be automated.</p>

<p>An example is my <code>PickerViewModel</code>, the interface of which is:</p>

<pre><code>//  MARK: Picker View Modelling
/**
Configures a picker view.
 */
public protocol PickerViewModelling {
    /// The titles of the items to be displayed in the picker view.
    var titles: Driver&lt;[String]&gt; { get }
    /// The currently selected item.
    var selectedItem: Driver&lt;String?&gt; { get }
    /**
    Allows for the fetching of the specific item at the given index.
    - Parameter index:  The index at which the desired item can be found.
    - Returns:  The item at the given index. `nil` if the index is invalid.
    */
    func item(atIndex index: Int) -&gt; String?
    /**
    To be called when the user selects an item.
    - Parameter index:  The index of the selected item.
     */
    func selectItem(at index: Int)
}
</code></pre>

<p>An example of the <code>Driver</code> issue can be found within my <code>CountryPickerViewModel</code>:</p>

<pre><code>    init(client: APIClient, location: LocationService) {
        selectedItem = selectedItemVariable.asDriver().map { $0?.name }
        let isLoadingVariable = Variable(false)
        let countryFetch = location.user
            .startWith(nil)
            .do(onNext: { _ in isLoadingVariable.value = true })
            .flatMap { coordinate -&gt; Observable&lt;ItemsResponse&lt;Country&gt;&gt; in
                let url = try client.url(for: RootFetchEndpoint.countries(coordinate))
                return Country.fetch(with: url, apiClient: client)
            }
            .do(onNext: { _ in isLoadingVariable.value = false },
                onError: { _ in isLoadingVariable.value = false })
        isEmpty = countryFetch.catchError { _ in countryFetch }.map { $0.items.count == 0 }.asDriver(onErrorJustReturn: true)
        isLoading = isLoadingVariable.asDriver()
        titles = countryFetch
            .map { [weak self] response -&gt; [String] in
                guard let `self` = self else { return [] }
                self.countries = response.items
                return response.items.map { $0.name }
            }
            .asDriver(onErrorJustReturn: [])

    }
}
</code></pre>

<p>The <code>titles</code> drive the <code>UIPickerView</code>, but when the <code>countryFetch</code> fails with an error, the subscription completes and the fetch cannot be retried manually.</p>

<p>If I attempt to <code>catchError</code>, it is unclear what observable I could return which could be retried later when the user has restored their internet connection.</p>

<p>Any <code>justReturn</code> error handling (<code>asDriver(onErrorJustReturn:)</code>, <code>catchError(justReturn:)</code>) will obviously complete as soon as they return a value, and are useless for this issue.</p>

<p>I need to be able to attempt the fetch, fail, and then display a <strong>Retry</strong> button which will call <code>refresh()</code> on the view model and try again. How do I keep the subscription open?</p>

<p>If the answer requires a restructure of my view model because what I am trying to do is not possible or clean, I would be willing to hear the better solution.</p>
","1486106","","","","","2018-03-20 18:55:16","Structuring a View Model Using RxSwift","<swift><mvvm><viewmodel><rx-swift>","3","0","1","","","CC BY-SA 3.0"
"49337671","1","","","2018-03-17 13:49:51","","0","1524","<p>I am building an iOS App using RxSwift based on a MVVM pattern. I have a basic signUp/logIn form upon app start and was wondering how to handle those cases correctly in terms of clean reactive programming: Basically I am using the <a href=""https://github.com/ReactiveX/RxSwift/tree/master/RxExample/RxExample/Examples/GitHubSignup/UsingDriver"" rel=""nofollow noreferrer"">RxSwift GitHub example</a> as a blueprint for my login form, but this only handles the ""login"", not the ""signUp"". The concrete issue being the fact, that I have a <code>let loggedIn: Driver&lt;Bool&gt;</code> in my LoginViewModel, on which my LoginViewController will be subscribed, in order to perform appropriate actions upon login, but <code>loggedIn</code> does not only need to be triggered when pressing the ""login button"", but the LoginViewModel should also login, after the ""signUp button"" was being pressed. </p>

<p>Assuming we are instantiating the LoginViewModel from the LoginViewController using the following init:</p>

<pre><code>init(
    username: Driver&lt;String&gt;,
    password: Driver&lt;String&gt;,
    signUpTaps: Signal&lt;Void&gt;,
    signInTaps: Signal&lt;Void&gt;
    ) {
</code></pre>

<p>we use the following code (in the LoginViewModel) to login the user upon a ""signIn"" tap event being sent from the LoginViewController:</p>

<pre><code>let usernameAndPassword = Driver.combineLatest(input.username, input.password) { (username: $0, password: $1) }

loggedIn = signInTaps.withLatestFrom(usernameAndPassword)
        .flatMapLatest { usernameAndPassword in
            return API.loginUser(with: usernameAndPassword.username, and: usernameAndPassword.password)
            .asDriver(onErrorJustReturn: false)
    }
</code></pre>

<p>where API is just my class with static methods, being responsible for creating network requests (as signing up- and logging in users). Note that inside my LoginViewModel no subscriptions are being made!</p>

<p>How do I distinguish between ""signUp"" and ""´signIn"" button pressed in this reactive manner, in order to set the observable <code>loggedIn</code> correctly for both cases?
In order to trigger a ""login"" request just after successful ""signUp"", I could just use <code>flatMap()</code>, but then how do I only login?
I also thought about something like</p>

<pre><code>loggedIn = Observable.combineLatest(signInTaps.withLatestFrom(usernameAndPassword), signUpTaps.withLatestFrom(usernameAndPassword))
</code></pre>

<p>and then somehow differentiate between both events, in order to determine, if I have to signUp a user first and then signIn, or just need to signIn the user.</p>

<p>Any help would be appreciated.</p>
","7210997","","","","","2018-03-17 14:13:51","Handling User Sign up and Sign in using RxSwift in MVVM pattern","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49338628","1","49345509","","2018-03-17 15:35:17","","2","1894","<p>In the future, Variable will be deprecated in RxSwift 4. Instead, Relay classes were first implemented in RxCocoa 4, and an alternate proposed to Variable is BehaviorRelay.</p>

<p>Assigning the value of a Variable is an imperative programming-style command. Its convenient but not belongs in Reactive’s declarative programming environment.</p>

<p><strong>What are their pros and cons?</strong></p>
","5167549","","","","","2018-03-18 07:30:06","RxSwift 4/RxCocoa 4 Deprecating Variable - pros and cons","<swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"49350216","1","49368939","","2018-03-18 16:25:46","","1","709","<p>I've just started implementing RxSwift. </p>

<p>I've got the following function to dynamically fill a collectionView with users returned from a Firebase observe call, but I'm struggling to then dynamically filter the users based on any potential entires in the searchBar.</p>

<p>Rx collectionView binding:</p>

<pre><code>private func bind() {
    viewModel.users.asObservable()
        .bind(to: nearbyCollectionView.rx.items(cellIdentifier: ""NearbyCell"", cellType: NearbyCell.self)) {
            row, user, cell in
            cell.configureCell(user: user)
        }.disposed(by: disposeBag)
}
</code></pre>

<p>Should I return to the default collectionView implementations and simply use Rx to dynamically update the collectionView objects, or is there a better way to do this?</p>

<p>My old implementation used the following:</p>

<pre><code>            if self.viewModel.inSearchMode {
            user = self.viewModel.filteredUsers[indexPath.row]
            cell.configureCell(user: user)
        } else {
            user = self.viewModel.users[indexPath.row]
            cell.configureCell(user: user)
        }
</code></pre>

<p>Thanks a lot for any help!!</p>
","8537330","","","","","2018-03-19 17:26:00","Filtering a collectionView with a searchBar from a RxSwift Variable","<ios><swift><uicollectionview><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49384917","1","","","2018-03-20 13:01:14","","0","581","<p>I have a addButton inside a UITableCieCwell. I want the addButton to be disappear after user click it, so I created a Action and bind it to the addButton.</p>

<p>However, all the addButton is disappeared although I just run my app.</p>

<p>I'm very new to RxSwift, please help me out.</p>

<p><strong>Bind UI</strong></p>

<pre><code>viewModel.courses
        .asObservable()
        .bind(to: collectionView.rx.items(cellIdentifier: AddableCourseCell.reuseIdentifier, cellType: AddableCourseCell.self)) { (row, element, cell) in

            let action = self.viewModel.actions.value[row]
            action.enabled.asObservable()
                .bind(to: cell.addButton.rx.isHidden)
                .disposed(by: self.disposeBag)

            cell.addButton.rx
                .tap
                .debounce(0.3, scheduler: MainScheduler.instance)
                .subscribe({ (event) in

                    action.execute(element)

                }).disposed(by: cell.disposeBag)

        }.disposed(by: disposeBag)
</code></pre>

<p><strong>ViewModel</strong></p>

<pre><code>class ViewModel {

    var courses: Variable&lt;[Course]&gt; = Variable([])
    var selectedCourses: Variable&lt;[Course]&gt; = Variable([])
     var actions = Variable&lt;[Action&lt;Course, Bool&gt;]&gt;([])

    private func generateAddActions(courses: [Course]) -&gt; [Action&lt;Course, Bool&gt;] {
        var actions: [Action&lt;Course, Bool&gt;] = []
        for _ in courses {
            let action = Action&lt;Enrollment, Bool&gt;(workFactory: { (input) -&gt; Observable&lt;Bool&gt; in
                let isAdded = selectedCourses.value.contains(input)
                if !isAdded {
                    self.selectedCourses.value.append(input)
                }
                return Observable.just(isAdded)
            })
            actions.append(action)
        }
        return actions
    }
}
</code></pre>
","5009645","","","","","2018-03-21 01:36:15","Rxswift hide button inside UITableViewCell after tapped","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49393233","1","","","2018-03-20 20:06:46","","0","960","<p>Right now i'm having a situation where i'm starting several request from separated threads, something like a Thread Pool.</p>

<p>I want to make that requests to be synchronous, so they will be started and ended on exactly the same thread, not the Main thread.</p>

<p>I tried to set the <code>.observeOn(CurrentThreadScheduler.instance)</code>, but as the response handler thread was always Main thread instead of a current.</p>

<p>Is it possible to specify the current thread as a handler thread for the response?</p>
","1965117","","","","","2018-03-21 03:35:51","RxSwift and Moya synchronous request","<swift><reactive-programming><rx-swift><moya>","1","0","","","","CC BY-SA 3.0"
"49454505","1","49454788","","2018-03-23 16:37:10","","1","1629","<p>I have a problem with observing array of my custom type, that have a Variable fields. I want to create observable event, that will check, if value of this fields changed.
I have a struct:</p>

<pre><code>struct Type {
    let name: Variable&lt;String&gt;
    let email: Variable&lt;String&gt;
}
</code></pre>

<p>And I have a array:</p>

<pre><code>let array: Variable&lt;[Type]&gt;
</code></pre>

<p>All I need is Observable, that will return true, when field name count will be greater than 0. I try to play with Observable.combineLatest, but I cannot convert properly array.</p>
","4463435","","","","","2018-03-24 12:29:19","RxSwift Observe variable fields of struct type in array","<ios><swift><rx-swift>","2","2","","","","CC BY-SA 3.0"
"49459410","1","49459523","","2018-03-23 23:04:03","","1","679","<p>I made a few gateways / providers to integrate with an API in my API, using RX Swift and I'm trying to handle the pagination in what seems to me like a clean and simple way.</p>

<p>Basically, the function signature would look like that:</p>

<pre><code>func getPlaces(with location: CLLocationCoordinate2D) -&gt; Observable&lt;(value: [Place], next: Observable&lt;(value: [Places], Observable&lt;(value: [Place], next: ... ... &gt;&gt;
</code></pre>

<p>This quickly appears impractical, so I tried creating a typealias for that:</p>

<pre><code>typealias Result = Observable&lt;(value: [Place], next: Result?)&gt;
</code></pre>

<p>So my function signature would look like this:</p>

<pre><code>func getPlaces(with location: CLLocationCoordinate2D) -&gt; Result
</code></pre>

<p>But Xcode wouldn't get fooled so easily and calls me out for referencing my typealias inside itself</p>

<p>So... is it even doable ? How ?</p>
","7243001","","","","","2018-03-31 15:23:53","How to make a type alias that references itself?","<swift><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"49461735","1","49465014","","2018-03-24 05:53:50","","0","703","<p>I want to use <code>Variable</code> in Rxswift to make caseResults search different Results with different boxId, like <code>boxId == 1</code> get Results and <code>boxId == 2</code> get another Results </p>

<pre><code>class MainViewModel {

    let cases: Driver&lt;[CaseItemViewModel]&gt;
    let index = Variable&lt;Int&gt;(1)

    init() {
        let caseResults = realm.objects(RMCase.self)
                            .filter(""boxId == \(index.value)"")
                            .sorted(byKeyPath: ""id"", ascending: true)


        self.cases = Observable.collection(from: caseResults)
            .asDriverOnErrorJustComplete()
            .map { results in results.map { CaseItemViewModel(with: $0) }}
    }
}


class CaseItemViewModel {
    let cased: RMCase
    let id: Int
    let boxId: Int
    let name: String

    init(with cased: RMCase) {
        self.cased = cased
        self.id = cased.id
        self.boxId = cased.boxId
        self.name = cased.name
    }
}
</code></pre>

<p>In the ViewController</p>

<pre><code>    viewModel.boxs
        .drive(tableView.rx.items(cellIdentifier: CellId.main.rawValue, cellType: MainTableViewCell.self)) { [weak self] row, item, cell in
            guard let strongSelf = self else { return }

            cell.setup(with: item)

            // drive collectionView into tableViewCell
            if let collectionView = cell.collectionView {

                strongSelf.viewModel.cases.asObservable()
                    .bind(to:collectionView.rx.items(cellIdentifier: ""testcell"", cellType: MainCollectionViewCell.self)) { _row, _item, _cell in

                     _cell.setup(with: _item)
                    }
                    .disposed(by: cell.disposeBag)
            }

            }.disposed(by: disposeBag)
</code></pre>
","7734135","","7734135","","2018-03-24 17:26:31","2018-03-24 22:49:28","Filter realm results with variable id using RxSwift","<realm><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49466207","1","","","2018-03-24 15:02:58","","2","231","<p>I need to load a lot of small files from an api that allows me to load only one file at a time. As they are very small I start several downloads at a time. Depending on the result I start the next batch load.</p>

<p>For each request I use a observable and then combine several with <code>combineLatest</code>. After <code>combineLatest</code> I do a <code>flatMap</code> and <code>concat</code> a new call to the same function.</p>

<p>As abstraction I do this - <em>pseudo code, not compiling</em>:</p>

<pre><code>func loadRecursively(items) -&gt; Observable&lt;XY&gt; {
    combineLatest(requestObservables)
    .flatMap {
        return loadRecursively(items-loadedItems)
    }
}
</code></pre>

<p>This works perfectly in general. </p>

<p><strong>The problem:</strong> This leads to a growing recursive tail, which is not cut off by compiler optimisation as it seems. So when loading some thousand files the stack will grow and finally the app will close.</p>

<p>How would I avoid the growing tail? Or in general how would I approach this problem with rx?</p>
","2181333","","2181333","","2018-03-24 22:18:03","2018-03-25 11:44:56","Tail recursion when loading lot of items","<swift><observable><rx-swift><reactive>","1","1","","","","CC BY-SA 3.0"
"49474086","1","49552047","","2018-03-25 08:51:58","","1","114","<p>I have this message in console because Api method called multiple times.</p>

<pre><code>curl -X GET 
""https://newsapi.org/v2/top-headlines?apiKey=.............&amp;pageSize=20&amp;category=science&amp;page=2"" -i -v
Canceled (33ms)
2018-03-25 12:47:38.810618+0300 TestNewsApp[19773:2413537] Task &lt;4B122FB1-1F0D-41FF-A102-BE2DE95BCBFC&gt;.&lt;42&gt; finished with error - code: -999
2018-03-25 12:47:38.810779+0300 TestNewsApp[19773:2414036] Task &lt;4B122FB1-1F0D-41FF-A102-BE2DE95BCBFC&gt;.&lt;42&gt; HTTP load failed (error code: -999 [1:89])
curl -X GET 
""https://newsapi.org/v2/top-headlines?apiKey=.............&amp;pageSize=20&amp;category=science&amp;page=2"" -i -v
Canceled (34ms)
2018-03-25 12:47:38.844640+0300 TestNewsApp[19773:2413537] Task &lt;9D6193D7-B757-4CB3-B812-452FE0B382BF&gt;.&lt;43&gt; finished with error - code: -999
2018-03-25 12:47:38.844870+0300 TestNewsApp[19773:2413546] Task &lt;9D6193D7-B757-4CB3-B812-452FE0B382BF&gt;.&lt;43&gt; HTTP load failed (error code: -999 [1:89])
curl -X GET 
""https://newsapi.org/v2/top-headlines?apiKey=.............&amp;pageSize=20&amp;category=science&amp;page=2"" -i -v
Canceled (49ms)
2018-03-25 12:47:38.893744+0300 TestNewsApp[19773:2413579] Task &lt;8A61A548-7F58-43CE-A829-57C8A6F952E5&gt;.&lt;44&gt; finished with error - code: -999
2018-03-25 12:47:38.893937+0300 TestNewsApp[19773:2413546] Task &lt;8A61A548-7F58-43CE-A829-57C8A6F952E5&gt;.&lt;44&gt; HTTP load failed (error code: -999 [1:89])
curl -X GET 
""https://newsapi.org/v2/top-headlines?apiKey=.............&amp;pageSize=20&amp;category=science&amp;page=2"" -i -v
Success (1220ms): Status 200
</code></pre>

<p>Problem is in this code.</p>

<pre><code>    scrollViewDidReachBottom
        .asObservable()
        .withLatestFrom(loadedPage.asObservable())
        .observeOn(MainScheduler.asyncInstance)
        .flatMapLatest { page in
            return NewsAPI.fetchNews(page: page + 1)
        }.subscribe( onNext: { [weak self]result in
            guard let strongSelf = self else { return }
            strongSelf.loadedPage.value = strongSelf.loadedPage.value + 1
            strongSelf.news.value = strongSelf.news.value + result
        })
        .disposed(by: disposeBag)
</code></pre>

<p>fetchNews(page: Int) -> Observable&lt;[News]> is static func </p>

<p>I fix it with this code, but I'm not sure it's the correct way.</p>

<pre><code>    scrollViewDidReachBottom
        .asObservable()
        .observeOn(MainScheduler.asyncInstance)
        .subscribe(onNext: { [weak self] _ in
            guard let strongSelf = self else { return }
            if !strongSelf.inCall {
                strongSelf.inCall = true
                NewsAPI.fetchNews(page: strongSelf.loadedPage.value + 1)
                    .observeOn(MainScheduler.asyncInstance)
                    .subscribe(onNext: { [weak self] news in
                        guard let strongSelf = self else { return }
                        strongSelf.news.value += news
                        strongSelf.loadedPage.value += 1
                        strongSelf.inCall = false
                    })
                    .disposed(by: strongSelf.disposeBag)
            }
        })
        .disposed(by: disposeBag)
</code></pre>
","7841908","","7841908","","2018-03-25 13:15:12","2018-03-29 09:08:33","Can I not call my method again before I get an answer?","<ios><swift><pagination><request><rx-swift>","2","1","","","","CC BY-SA 3.0"
"49474759","1","49475018","","2018-03-25 10:22:30","","0","80","<p>I have this code, but I'm not sure.</p>

<pre><code>    NewsAPI.fetchNews(page: loadedPage.value + 1)
        .observeOn(MainScheduler.asyncInstance)
        .bind(onNext: { [weak self](news) in
            guard let strongSelf = self else { return }
            strongSelf.news.value = strongSelf.news.value + news
            strongSelf.loadedPage.value = strongSelf.loadedPage.value + 1
        })
        .disposed(by: disposeBag)
</code></pre>
","7841908","","7841908","","2018-03-25 10:47:06","2018-03-25 10:55:28","What is correct way to download once in RxSwift?","<ios><swift><request><rx-swift>","1","2","","","","CC BY-SA 3.0"
"49489326","1","49490218","","2018-03-26 10:32:13","","2","1508","<p>Iam using MVVM with RxSwift i have tried Coordinator  and RxFlow to navigate between viewcontroller.
Is there any simply approach to segue between viewcontroller with RxSwift </p>

<pre><code>  viewModel.users.subscribe {
                            model in


                            self.walkthrough = WalkthroughModel(country: (model.element?.country)!, countryCode: (model.element?.countryCode)!,PhoneNumber:"""")

                            DispatchQueue.main.async {
                                self.performSegue(withIdentifier: ""Walkthrough_phone"", sender: self)
                            }
                        }.dispose() 
</code></pre>

<p>these the normal approach iam doing right now  but  is there any way to bind segu to the button </p>
","3950487","","3950487","","2018-03-26 11:04:34","2018-06-25 11:17:39","Performing navigation in mvvm with RxSwift","<ios><swift><rx-swift>","2","4","","","","CC BY-SA 3.0"
"49531284","1","","","2018-03-28 09:47:54","","0","234","<p>I have a very old IOS project with mix Objc and Swift. We would like to use RxSwift for the next big feature coming soon. We tried installing rxSwift via Cocoapods but when I put in the ""#use_framesworks"" line in the pods file, the entire project goes crazy. Something about dynamic vs static frameworks. </p>

<p>So we decided to add RxSwift manually. Add git submodule, drag the project file and link binary with libraries in the build phases. </p>

<p>I can actually import RxSwift and RxCocoa and even write the code and it works on simulator. </p>

<p>However the moment I run the app on a device, it crashes at the very first sight of any Rx related code. In my case would be the declaration of DisposeBag(). I have no idea what to do. I hope someone could shed some light. Please find some screen shots below. There is nothing in the Xcode Logs as well. Just (lldb) </p>

<p><a href=""https://i.stack.imgur.com/NjvoC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/NjvoC.png"" alt=""Link Binary with libraries""></a></p>

<p><a href=""https://i.stack.imgur.com/Zk5ZP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Zk5ZP.png"" alt=""enter image description here""></a></p>
","3085198","","5991255","","2018-03-28 09:54:42","2018-03-28 14:16:44","IOS RxSwift crashing on device when installed manually via submodule","<ios><swift><rx-swift>","1","5","","","","CC BY-SA 3.0"
"49538546","1","49549879","","2018-03-28 15:30:36","","8","5052","<p>I implemented a ""reactive"" <code>UIAlertController</code> so I can get an <code>Observable&lt;Int&gt;</code> of the button press. (See code below).</p>

<p>My question, or questions, are:</p>

<ul>
<li>Is this implementation correct? I don't like storing the observers; I wonder if there's a better solution.</li>
<li>Or... is there already an implementation of this in ReactiveCocoa or RxSwift?</li>
</ul>

<p>Here is the implementation. I removed the parts not relevant to te question.</p>

<pre><code>class AlertBuilder {

    typealias AlertAction = (Int) -&gt; ()

    private let alert: UIAlertController

    /** If observable() is called, we keep here the observers to notify them */
    private var observers: [AnyObserver&lt;Int&gt;] = []

    init(alert: UIAlertController) {
        self.alert = alert
    }

    /** When using observable(), the action is not needed. */
    func button(_ title: String, style: UIAlertActionStyle = .default, action: AlertAction? = nil) -&gt; AlertBuilder {

        let buttonIndex = alert.actions.count
        alert.addAction( UIAlertAction(title: title, style: style, handler: { [weak self] _ in

            // Callback via action
            action?(buttonIndex)

            // Callback via observers
            if let this = self {
                for observer in this.observers {
                    observer.onNext(buttonIndex)
                    observer.onCompleted()
                }
                this.observers = []
            }
        }) )
        return self
    }

    /**
     * Returns an Observable that will emit the pressed button index and complete.
     * It's important to keep a reference to the AlertBuilder, otherwise the events won't be received.
     */
    func observable() -&gt; Observable&lt;Int&gt; {

        return Observable&lt;Int&gt;.create { observer in
            self.observers.append(observer)
            return Disposables.create()
        }
    }
}
</code></pre>

<p>You would use it from a controller, like this:</p>

<pre><code>let alert = UIAlertController(title: ""title"", message: ""msg"", preferredStyle: .actionSheet)

let builder = AlertBuilder(alert: alert)
    .button(""no"", style: .destructive)
    .button(""yes"")

self.present(alert, animated: true, completion: nil)

self.builder.observable()
    .subscribe(onNext: { buttonIndex in /* ... */ })
    .disposed(by: bag)

// keep reference to builder so observable() works
self.builder = builder
</code></pre>
","1121497","","","","","2020-03-12 11:56:05","How to obtain a UIAlertController observable (ReactiveCocoa or RxSwift)?","<ios><reactive-cocoa><rx-swift>","3","0","2","","","CC BY-SA 3.0"
"49545057","1","","","2018-03-28 22:16:00","","1","158","<p>I'm using <code>RxSwift</code> with <code>MVVM</code>. I have a situation where I load a screen of questions. Each is represented by a <code>QuestionViewModel</code>, containing the question and the <code>questionAnswer</code> as <code>Drivers</code>. The problem I have is I want to save the answers from the <code>QuestionViewModels</code> but only when they press Save button on the main screen. Its easy enough to subscribe to when a question is individually answered but this will do each as pressed, instead I want in one batch on save, as they could press back and want to cancel.</p>

<pre><code>struct ClientProfileViewModel { 
    private let service: Service
    private let client: Client?

    let questionnaire: Observable&lt;Questionnaire&gt;
    let answerViewModels: Observable&lt;[QuestionViewModel]&gt;

    init(service: Service, client: Client?) {
        self.service = service
        self.client = client

        self.questionnaire = self.service.questionnaire(client: client)

        self.answerViewModels = self.questionnaire.map { (questionnaire) -&gt; [QuestionViewModel] in
            return questionnaire.questions.map { question in
                let answer = client?.answers.first(where: { (qa) -&gt; Bool in
                    return qa.question.questionId == question.questionId
                }) ?? QuestionAnswer(question: question, answerYesNo: nil, answerText: nil)

                return QuestionViewModel(question: question, answer: answer)
            }
        }
    }
}


struct QuestionViewModel {
    private let question: Question
    private let answer: QuestionAnswer

    let questionOutput: Driver&lt;Question&gt;
    let answerOutput: Driver&lt;QuestionAnswer&gt;


    init(question: Question, answer: QuestionAnswer) {
        self.question = question
        self.answer = answer

        self.questionOutput = BehaviorRelay&lt;Question&gt;(value: self.question).asDriver()
        self.answerOutput = BehaviorRelay&lt;QuestionAnswer&gt;(value: self.answer).asDriver()
    }
}
</code></pre>

<p>Any thoughts?</p>
","4016564","","2463616","","2018-03-29 07:51:00","2018-03-29 07:51:00","RxSwift MVVM State","<swift><mvvm><rx-swift>","0","4","","","","CC BY-SA 3.0"
"49553049","1","49553994","","2018-03-29 09:55:11","","0","2818","<p>I am new to RxSwift and RxCocoa and I'm learning it. </p>

<p>I want to validate all textfield on button click and based on the validation I need to show alert message to user.</p>

<p>After validation is successful I need to insert record in table.</p>

<p>Refer the following code...</p>

<pre><code>var result = txtFname.rx.text
    result.asObservable().subscribe(onNext: { text in
        if text!.isEmpty {
            self.showAlert(msg: ""Plese enter first name."")
            self.txtFname.becomeFirstResponder()
        }
    }).disposed(by: disposeBag)

    result = txtLname.rx.text
    result.asObservable().subscribe(onNext: { text in
        if text!.isEmpty {
            self.showAlert(msg: ""Please enter last name."")
            self.txtLname.becomeFirstResponder()
        }
    }).disposed(by: disposeBag)

    result = txtEmail.rx.text
    result.asObservable().subscribe(onNext: { text in

        if text!.isEmpty {
            self.showAlert(msg: ""Please enter email id."")
            self.txtLname.becomeFirstResponder()
        }
    }).disposed(by: disposeBag)

   //need to check here if all fields are valid or not 
   //if all fields are valid then insert record....
</code></pre>

<p>When I press a button and it check all the validation at one and show alert...</p>

<p>But I want to do like if one validation is fail then it should not go further until previous validation is successful...</p>

<p>I don't know how to achieve this. Any help will be appreciated.</p>
","5020932","","","","","2018-09-22 10:07:40","Validate all textfield on button click using RxSwift and RXCocoa","<ios><swift><uibutton><rx-swift><rx-cocoa>","3","2","1","","","CC BY-SA 3.0"
"49553311","1","49560281","","2018-03-29 10:06:52","","2","2470","<p>I have a function that fires an API request to the server. I want to loop over it until it returns <code>false</code> (<em>no more data</em>).</p>

<pre><code>func getData(id: Int) -&gt; Observable&lt;Bool&gt; {
     return Observable.create { observer in
           // Alamofire request
           // parse data
           // if can decode, 
           //   return true and increment page's property 
           // otherwise false
           // error, if there's a problem
     }
}
</code></pre>

<ul>
<li>First try: I've tried using <code>takeWhile</code>, like : <code>getData(id).takeWhile {$0}</code>. It only iterate over my function 1x only.</li>
<li><p>Second try: using a range. The problem here is that even if my <code>getData</code> function errors out, instead of stopping, the loop continues !</p>

<pre><code>Observable.range(start: 1, count: 100)
  .enumerated()
  .flatMapLatest({ _ in
        self.getData(someID)
  })
  .subscribe(onNext: { _ in
       // save to DB
       observer.onNext(true)
       observer.onCompleted()
   }, onError: { error in
       observer.onError(error)
   })
   .disposed(by: self.disposeBag)
</code></pre></li>
</ul>

<p>Is there a way to do it, <code>rx</code> style ?</p>
","711388","","711388","","2018-03-29 15:07:38","2018-03-30 10:08:31","repeat-while operator in rx-swift","<ios><swift><reactive-programming><rx-swift>","2","1","1","","","CC BY-SA 3.0"
"49564207","1","49571077","","2018-03-29 20:06:08","","0","75","<p>I have this object <code>TryOut</code>, when initialize, it executes a private method every <code>2 seconds</code>. Within that method <strong>func execute()</strong> there is ,<code>internalStream</code>, a local variable of type <code>Observable&lt;Int&gt;</code> that captures data that I wish to emit to the outside world.</p>

<blockquote>
  <p>The issue is that even though <code>internalStream</code> is assigning to a member property  <code>public var outsideStream: Observable&lt;Int&gt;?</code>, There aren't any events coming from subscribing to <code>outsideStream</code>. Why though ? is there any reason behind that ?</p>
</blockquote>

<p><strong>Working Case</strong></p>

<p>The only way it work, is by having a closure as member property <code>public var broadcast:((Observable&lt;Int&gt;) -&gt; ())? = nil</code>, and raise it within the <code>execute</code> method by doing this <code>broadcast?(internalStream)</code>  </p>

<p>A sample code could be found in this <a href=""https://gist.github.com/LamourBt/ef65a5345e4d2c3d117e8616f9945e47"" rel=""nofollow noreferrer"">gist</a>. Thank you for your help.    </p>
","4846736","","","","","2018-03-30 09:07:58","Assigning Observable to another","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49603423","1","","","2018-04-01 23:03:55","","0","629","<p>I'm new to RxSwift trying to find out the simplest way to achieve the following:</p>

<ul>
<li>After login to the app a first '<em>getData</em>' request is done. This data is critical and will be loaded behind a spinner. When received, the data is saved in a Core Data db. When this task is finished (using completion block) the next request is started which should run asynchronously in background, the data here is also saved in the db. A spinner should be shown if the view presenting the latter data is accessed and the data has not yet been received and fetched from db.</li>
</ul>

<p>Model</p>

<pre><code>let subject = ReplaySubject&lt;[MyObject]&gt;.create(bufferSize: 3)
var observable : Observable&lt;[MyObject]&gt;?

 init() {
        self.observable = subject
 }
 ...

 self?.insertFirstDataToDb(firstData){
   self?.api.getNextData(param,  success: { (data) -&gt; Void in
    self?.insertNextDataToDb(firstData)

  })
  ... 
}
</code></pre>

<p>ViewController</p>

<pre><code>override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        // show spinner if data is not available yet
        self.myModel?.observable?
            .subscribe(onNext : { (additionalData) in
                self.updateMyTab(additionalData)
               // hide spinner
        })
        .disposed(by: self.disposeBag)
}
</code></pre>

<p>I suppose this can be done without using RxSwift, would there be any performance issues? Any suggestions how to solve this?</p>
","972587","","","","","2018-04-02 11:34:30","RxSwift design for async request","<swift><asynchronous><rx-swift><urlsession>","1","0","","","","CC BY-SA 3.0"
"49604789","1","","","2018-04-02 03:04:36","","0","217","<p>I couldn't find any answer for that so I'm creating this topic.</p>

<p>I have a table view inside my UI view and through my viewController I'm binding the main view and registering and trying to bind the cells, so I did this:</p>

<pre><code>    private func bindCells() {
    viewModel.address.asObservable()
        .bind(to: TableView.rx.items(cellIdentifier: AccountShippingCell.Identifier, cellType: AccountShippingCell.self))                           {
            row, address, cell in
            cell.address = address
        }.disposed(by: disposeBag)
    viewModel.payment.asObservable()
        .bind(to: TableView.rx.items(cellIdentifier: AccountPaymentCell.Identifier, cellType: AccountPaymentCell.self))                           {
            row, payment, cell in
            cell.payment = payment
        }.disposed(by: disposeBag)
}
</code></pre>

<p>But It crash all time closing my Xcode. I understood that when passing identifier + cell type I was already making it different. but it seems to be competing to register.</p>

<p>What I'm doing wrong?</p>
","8262036","","","","","2018-04-02 03:04:36","Binding 2 cells in a table view (swift 4)","<xcode><tableview><swift4><cells><rx-swift>","0","6","","","","CC BY-SA 3.0"
"49616445","1","","","2018-04-02 18:12:38","","0","251","<p>I'm learning the RxSwift and wanted to use Realm and RxRealm. I've implemented deleting and inserting new items but I've got a problem with updating one value.</p>

<p>Inside database singleton I've got this function:</p>

<pre><code>func updateNew(for primaryKey: Int) {
    if let itemToUpdate = realm.object(ofType: Item.self, forPrimaryKey: primaryKey) {
        try! realm.write {
            itemToUpdate.isNew = !itemToUpdate.isNew
        }
    }
}
</code></pre>

<p>In my view model 'm using RxRealm Observable.changeset and subscribing to results and changes. I can see that if I call this function for primaryKey = 2 then in my <code>subscribe</code> I get:</p>

<pre><code>deleted: [1]
inserted: [2]

Observable.changeset(from: itemsResult!).subscribe(onNext: { results, changes in
            if let changes = changes {
                print(results)
                print(""deleted: \(changes.deleted)"")
                print(""inserted: \(changes.inserted)"")
                print(""updated: \(changes.updated)"")
                ...
}
</code></pre>

<p>Why does <code>changes.updated</code> is not called?</p>
","4386014","","","","","2018-04-02 18:12:38","Deleted and inserted instead of updated when changing one object's property in Realm","<swift><realm><rx-swift>","0","4","","","","CC BY-SA 3.0"
"49627902","1","49628632","","2018-04-03 10:33:46","","12","14001","<p>I can't understand the difference between map and flatMap In RxSwift. In the RxSwift playground examples and the books, flatMap is used as converting Observables which has inner Observable property. </p>

<p>However I see flatMap being used directly on Observable of basic types. For example for below code, both of them produces the same output. Can someone help me to understand the difference between map and flatMap</p>

<pre><code>struct Student {
    let score:Int
}

let ryan = Student(score:80)
let student = PublishSubject&lt;Student&gt;()

let deneme = student.map({ val in
    return Student(score: val.score+10)
})
deneme.subscribe(onNext: {
    print(""StudentMAP: \($0.score)"")
})

let deneme2 = student.flatMap({ val -&gt; Observable&lt;Student&gt; in
    return Observable.of(Student(score: val.score + 10))
})

deneme2.subscribe(onNext: {
    print(""StudentFlatMAP: \($0.score)"")
})

 student.onNext(ryan)
</code></pre>
","4170419","","","","","2019-01-27 07:17:33","RxSwift map and flatMap difference","<swift><rx-swift>","3","0","6","","","CC BY-SA 3.0"
"49636059","1","49636961","","2018-04-03 17:35:15","","2","3784","<p>I have an <code>UITableView</code> and a <code>users</code> variable whose signature is like:</p>

<pre><code>let users: Variable&lt;[User]?&gt; = Variable&lt;[User]?&gt;(nil)
</code></pre>

<p>While I'm trying to bind this array of users in a UITableView, I'm getting the error <code>Generic parameter 'Self' could not be inferred</code>. This only occurs when I'm observing an Optional type. Why does this happen? What's the workaround for this situation?</p>

<p>Here is an example of how I'm doing:</p>

<pre><code>private func bind() {
    // Does not compile: Generic parameter 'Self' could not be inferred
    users.asObservable().bind(to:
        tableView.rx.items(cellIdentifier: ""UserCell"",
            cellType: UITableViewCell.self)) { (index, user, cell) in
            // Cell setup.
    }.disposed(by: disposeBag)
}
</code></pre>
","1085977","","1085977","","2018-04-03 17:49:02","2018-05-17 13:22:31","RxSwift - optional issue on binding to tableView","<ios><swift><generics><optional><rx-swift>","2","1","1","","","CC BY-SA 3.0"
"49639875","1","49953239","","2018-04-03 22:11:51","","3","1749","<p>I am trying to go through the <code>RxSwift</code> tutorial here: </p>

<p><a href=""https://www.raywenderlich.com/138547/getting-started-with-rxswift-and-rxcocoa"" rel=""nofollow noreferrer"">https://www.raywenderlich.com/138547/getting-started-with-rxswift-and-rxcocoa</a></p>

<p>After downloading their example code, and doing <code>pod install</code> successfully, the build is still failing. It is showing the error in the <code>Lock.swift</code> file and is shown below:</p>

<p><a href=""https://i.stack.imgur.com/ATCYN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ATCYN.png"" alt=""enter image description here""></a> </p>

<p>What should I do to eliminate the error and make it to run? It is disappointing that the tutorial is not up to date. Any suggestions would be greatly appreciated. </p>
","3815432","","","","","2018-04-21 06:58:17","RxSwift tutorial example: Attribute can only be applied to types, not declarations","<ios><iphone><rx-swift>","2","0","1","","","CC BY-SA 3.0"
"49643251","1","","","2018-04-04 05:12:32","","2","273","<p>Let's say we retrieve contact list from server with next page:</p>

<pre><code>retrieveContacts()
    .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))
    .observeOn(MainScheduler.instance)
    .subscribe(onNext: { [weak self] contacts, nextPage in 
        self?.nextPage = nextPage
        // do something with contacts
    })
    .disposed(by: disposeBag)
</code></pre>

<p>Now we want to pass these contacts to other observables, but in meantime we have to assign <code>self.nextPage</code> to new <code>nextPage</code>. We can do it on the background like this:</p>

<pre><code>retrieveContacts()
        .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))
        .observeOn(MainScheduler.instance)
        .map { [weak self] contacts, nextPage in 
            self?.nextPage = nextPage
            return Observable.just(contacts)
        }
        .observeOn(ConcurrentDispatchQueueScheduler(qos: .background))
        .map { contacts in
            // do something with contacts but now on background
        }
</code></pre>

<p>Is there any better way to assign property by changing the thread in <code>.observeOn</code> method?</p>
","4386668","","","","","2018-04-22 17:48:38","Assigning property with RxSwift","<ios><swift><rx-swift><reactivex>","1","0","","","","CC BY-SA 3.0"
"49652987","1","49666711","","2018-04-04 13:58:37","","1","554","<p>I wanted to know what is the best practice to handling button tap based on the <code>Observable</code>. I've got enum:</p>

<pre><code>enum ButtonState {
    case idle, valid, nonValid
}
</code></pre>

<p>and <code>Observable</code> which is combining two Observables:</p>

<pre><code>var buttonStateObservable: Observable&lt;ButtonState&gt; {
        return Observable.combineLatest(isAddingVariable.asObservable(), addItemName.asObservable(),
                                        resultSelector: { isAdding, itemName in
                                            if isAdding {
                                                return !itemName.isEmpty ? .valid : .nonValid
                                            }
                                            return .idle
        })
    }
</code></pre>

<p>In my ViewController I'm subscribing to this observable and updating <code>UIButton</code>'s UI. I would like to handle tap on this button and do certain action based on this observable. What is the best approach?</p>
","4386014","","2463616","","2018-04-05 07:20:16","2018-04-05 08:05:11","Handling button touch based on the Observable value","<swift><observable><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49663016","1","49663826","","2018-04-05 01:59:37","","10","2394","<p>I am going through the following tutorial on <code>RxSwift</code>:</p>

<p><a href=""http://adamborek.com/thinking-rxswift/"" rel=""noreferrer"">http://adamborek.com/thinking-rxswift/</a></p>

<p>and having trouble understanding the following pattern:</p>

<pre><code>           searchBar.rx.text.orEmpty
------------&gt; .flatMap { [spotifyClient] query in
                   return spotifyClient.rx.search(query: query)
             }.map { tracks in
                   return tracks.map(TrackRenderable.init)
             }
</code></pre>

<p>This square brackets input parameter: <code>[spotifyClient] query</code> seems very weird for me. I looked over official <code>Apple</code> documentation for closures and functions and I can not see any examples of such input parameters. In <code>Objective C</code> this would not bother me much, but it is <code>Swift</code>. Could anyone explain, what this parameter means here?</p>
","3815432","","1226963","","2018-04-05 01:59:59","2018-04-05 07:11:24","Input parameter to closure in Swift with brackets","<swift><rx-swift>","1","1","3","","","CC BY-SA 3.0"
"49683502","1","49724156","","2018-04-06 00:30:29","","0","353","<p>I am going through the tutorial:</p>

<p><a href=""https://marcosantadev.com/mvvmc-with-swift/"" rel=""nofollow noreferrer"">https://marcosantadev.com/mvvmc-with-swift/</a></p>

<p>Which talks about <code>MVVM-C</code> design pattern. I have real trouble understanding of how and why <code>.never()</code> observable is used there (and in general why we would want to use <code>.never()</code> besides testing timeouts). </p>

<p>Could anyone give a reasonable example of <code>.never()</code> observable usage in <code>swift</code> code (not in testing) and explain why it is necessary and what are the alternatives? </p>
","3815432","","1292099","","2018-04-09 00:35:32","2021-06-16 18:49:25","RxSwift, why using .never() not for testing","<swift><mvvm><rx-swift>","3","0","","","","CC BY-SA 3.0"
"49690757","1","","","2018-04-06 10:29:31","","1","1666","<p>only some api call needs the token. and when 401 occurs refresh token call will be taken place.and for each call the token is refreshing. how to execute more than 1 api synchronously when 401 occurs</p>
","9348302","","1113632","","2018-04-17 05:46:50","2018-04-17 05:46:50","How to implement refresh token in ios","<ios><swift><swift3><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 3.0"
"49719447","1","","","2018-04-08 15:22:25","","0","1239","<p>My implementation of the MVVM pattern with RxSwift, Realm and RxRealm looks like this:</p>

<p><a href=""https://i.stack.imgur.com/ud6iz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ud6iz.png"" alt=""MVVM pattern with realm and RxSwift""></a></p>

<p>E.g. I have a textfield that shows some editable content. I want this to be realtime saved/synched to the DB like this: </p>

<pre><code>//View
textField.rx.text.subscribe(textViewModel.saveText.inputs)
viewModel.stringValue.drive(textField.rx.text)

//ViewModel:
lazy var saveText = Action&lt;String,Void&gt;{ newStringValue in 
   realm.write{
     textObject.stringValue = newStringValue
   }
  //don't block the main thread
  return Observable.just()
}  

lazy var stringValue = Observable(from:textObject).map{$0.stringValue}.asDriver(onErrorJustReturn : ""no string"")
</code></pre>

<p>When typing slowly in the TextField, everything works accordingly. When typing very quickly thought, letters get ""swallowed"" like this: </p>

<ol>
<li>Type ""A""</li>
<li>write ""A"" to DB</li>
<li>Type ""B""</li>
<li>Receive ""A"" from DB 
-> Textfield value becomes A instead of AB. </li>
</ol>

<p>When working with realtime synchronization this is the desired behaviour. For single text typing this seems not a good solution. How would such a 2-way binding be properly implemented and the undesired effect be avoided, especially in a scenario where the viewModel is processing the text value before  write or after read from the source?</p>
","1514892","","","","","2018-04-11 03:58:08","MVVM implementation with RxSwift and Realm - Two way binding","<swift><mvvm><data-binding><realm><rx-swift>","1","0","1","","","CC BY-SA 3.0"
"49731672","1","49733186","","2018-04-09 11:16:48","","0","122","<p>My Structure,</p>

<pre><code>internal struct KeychainManager {    
    static private(set) var accessToken: String? = nil
}
</code></pre>

<p>My UI bind code,</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    let observableToken = Observable.just(KeychainManager.accessToken)

    observableToken
        .debug()
        .map { $0 == nil }
        .bind(to: authenticateButton.rx.isEnabled)
        .disposed(by: disposeBag)
}
</code></pre>

<p>When my app opens, <code>authenticateButton</code> can be seen enabled, but when I make API call then after saving my token successfully in <code>KeychainManager.accessToken</code>, <code>authenticateButton</code> still remains enabled. Why?</p>

<p>What's going wrong here?</p>

<p>Any suggestions will be helpful.</p>
","2713079","","2463616","","2018-04-09 12:39:29","2018-04-09 12:39:29","Observable<String?> runs only first time","<swift><observable><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49751752","1","49777392","","2018-04-10 10:50:09","","0","240","<p>Say I have 2 functions with 2 different <code>Observable</code> return types :</p>

<pre class=""lang-swift prettyprint-override""><code>func getWatchedMovies() -&gt; Observable&lt;[TraktMovie]&gt;
func getDetails(id: Int, language: String) - &gt; Observable&lt;TMDbMovie&gt;
</code></pre>

<p>I'd like to flatMap each value in my <code>getWatchedMovies()</code> request to be able to request the details of each movie like this (I'm not sure it's the best way to do it though..)</p>

<pre class=""lang-swift prettyprint-override""><code> traktDataManager?
  .getWatchedMovies()
  .flatMap({ (traktMovies) -&gt; Observable&lt;[TraktMovie]&gt; in
    let moviesObs = Observable.from(traktMovies)
    let movieDetails = moviesObs.flatMap { 
      self.tmdbDataManager!.getMovieDetails(id: $0.ids.tmdb, language: Device.lang) 
    }
  })
</code></pre>

<p>The thing is, I need to add each <code>TraktMovie</code> to Realm AND update a <code>TraktMovie</code> property, named <code>tmdbMovie</code>, with the nested request value of type <code>TMDbMovie</code> in Realm too.</p>

<p>What I mean is :</p>

<ul>
<li>first, I need to loop in my <code>[TraktMovie]</code> array to save each value of it in Realm (say an object named <code>traktMovie</code>)</li>
</ul>

<pre class=""lang-swift prettyprint-override""><code>for traktMovie in traktMovies {
  let realm = try! Realm()
  realm.write {
    realm.add(traktMovie)
  }  
}
</code></pre>

<ul>
<li><p>second, I need to retrieve the details of each <code>TraktMovie</code> object with the second request (e.g. <code>getDetails(_ , _)</code>) : with something like <code>flatMap</code> ?</p></li>
<li><p>third, I need to update each <code>traktMovie</code> object property as follow with the value retrieved with the <code>getDetails</code> request (say <code>tmdbMovie</code> for the retrieved value):</p></li>
</ul>

<pre class=""lang-swift prettyprint-override""><code>traktMovie.setValue(tmdbMovie, forKeyPath: ""tmdbMovie"")
</code></pre>

<p>Here I have an object retrieved from the first request(<code>getWatchedMovies()</code>) named <code>traktMovie</code> and I update one of its property named <code>tmdbMovie</code> with the object retrieved from the second request (<code>getDetails(_, _)</code>) also named <code>tmdbMovie</code></p>

<p>The thing is my first request returns an array and the second only a single object.</p>

<p>If I return the <code>TMDbMovie</code> object, I got only one object with <code>onNext</code> event and I loose my <code>[TraktMovie]</code> array.</p>

<p>Hope I'm clear enough.</p>

<p>Help is really appreciated ! 😅</p>
","6578423","","6578423","","2018-04-10 13:15:09","2018-04-11 19:42:02","Chained RxSwift request with Realm add() / setValue()","<swift><realm><observable><rx-swift><flatmap>","1","1","1","","","CC BY-SA 3.0"
"49756479","1","50062342","","2018-04-10 14:39:56","","2","1580","<p>currently, I want to bind the value of <code>Observable&lt;UIViewController&gt;</code> to my <code>UIPageViewController</code>. Initial idea is simple and straightforward:</p>

<pre class=""lang-swift prettyprint-override""><code>viewControllerObservable
    .subscribe(onNext: { [weak self] viewController in

        self?.pageVC.setViewControllers([viewController], 
                                        direction: .forward, 
                                        animated: false, 
                                        completion: nil)
     })
    .disposed(by: disposeBag)
</code></pre>

<p>but if values in viewControllerObservable changes too quick, page view controller receives new set command before it's done with adding previous view controller and I'm getting <code>NSInternalInconsistencyException</code>.</p>

<p>I can make that code more ""reactive"", using <code>Binder</code>, but I'll still face the same problem.</p>

<p>Pretty obvious way here is to use throttle, but it seems to be pretty dirty fix, masking problem, not fixing it.</p>

<p>Ideally, I need some way to hold further values handling until <code>completion</code> is called in <code>setViewControllers</code>.</p>

<p>How can I achieve that?</p>
","29503","","29503","","2018-04-27 12:32:13","2018-04-27 12:32:13","Make RxCocoa binding for UIPageViewController.setViewControllers (how to synchronize Observable)","<swift><rx-swift><rx-cocoa>","1","0","2","","","CC BY-SA 3.0"
"49759580","1","","","2018-04-10 17:21:15","","-3","138","<p>I know this is probably a very basic question but it has been nagging at me for a while. Could someone explain what the idea of this <code>let</code> is? Or at least what it is commonly used for? I keep seeing let variables like:</p>

<pre><code>let thisVar = ... { var1, var2, var3 in
    methods
}
</code></pre>

<p>This is an example from the RxRealmDataSources:</p>

<pre><code>let dataSource = RxTableViewRealmDataSource&lt;Lap&gt;(cellIdentifier: ""Cell"", cellType: PersonCell.self) {cell, ip, lap in
    cell.customLabel.text = ""\(ip.row). \(lap.text)""
}
</code></pre>

<p>I am mostly confused about what <code>var1</code>, <code>var2</code>, and <code>var3</code> (or <code>cell</code>, <code>ip</code>, <code>lap</code> in the RxRealmDataSources example) are meant to do. Thanks!</p>
","9241618","","4667835","","2018-04-10 19:39:07","2018-04-10 20:54:23","Swift let ... { in","<swift><closures><rx-swift>","2","3","0","2018-04-10 20:33:50","","CC BY-SA 3.0"
"49764890","1","49765271","","2018-04-11 01:02:31","","2","3056","<p>I have <code>UICollectionViewCell</code>s that have only one <code>UIImageView</code>. I am using <code>RxSwift</code> for the project. The <code>delegate</code> is set in the <code>Main.storyboard</code>, and the <code>datasource</code> is set by the <code>RxSwift</code>. I need to remove the spaces between the cells, but having trouble with that. The methods from this thread are not working:</p>

<p><a href=""https://stackoverflow.com/questions/42698678/aligning-collection-view-cells-to-fit-exactly-3-per-row"">Aligning collection view cells to fit exactly 3 per row</a></p>

<p>I tried both answers but nothing happens.</p>

<p>Here is the <code>UIViewCollectionController</code>s' code:</p>

<pre><code>let disposeBag = DisposeBag()

override func viewDidLoad() {
    super.viewDidLoad()

    // Uncomment the following line to preserve selection between presentations
    // self.clearsSelectionOnViewWillAppear = false

    // Register cell classes
    //self.collectionView!.register(UICollectionViewCell.self, forCellWithReuseIdentifier: reuseIdentifier)

    // Do any additional setup after loading the view.
    collectionView?.dataSource = nil
    setupCellConfiguration()
}

private func setupCellConfiguration() {
    //1
    immuneCells
        .bind(to: self.collectionView!
            .rx //2
            .items(cellIdentifier: CellTypeCollectionViewCell.Identifier,
                   cellType: CellTypeCollectionViewCell.self)) { // 3
                    row, cellType, cell in
                    cell.configureWithCellType(cellType: cellType) //4
        }
        .disposed(by: disposeBag) //5
}

override func numberOfSections(in collectionView: UICollectionView) -&gt; Int {
    // #warning Incomplete implementation, return the number of sections
    return 1
}


override func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int {
    // #warning Incomplete implementation, return the number of items
    let num = CellType.immune.count
    return num
}

    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize {
    let screenWidth = UIScreen.main.bounds.width
    let scaleFactor = (screenWidth / 3) - 6

    return CGSize(width: scaleFactor, height: scaleFactor)
}

func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -&gt; UIEdgeInsets {
    return UIEdgeInsets.zero
}

func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -&gt; CGFloat {
    return 0
}

func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -&gt; CGFloat {
    return 0
}
</code></pre>

<p>Any suggestions would be greatly appreciated</p>

<blockquote>
  <p>Update</p>
</blockquote>

<p>I tried setting up equal width and height, top, left constraints of <code>UIImageView</code> but it did not help.</p>

<p>This is how it looks:</p>

<p><a href=""https://i.stack.imgur.com/mzLIM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mzLIM.png"" alt=""enter image description here""></a></p>
","3815432","","3815432","","2018-04-11 01:17:23","2020-04-01 05:53:53","Remove space between the cells of UICollectionView","<swift><uicollectionview><rx-swift>","3","9","","","","CC BY-SA 3.0"
"49770128","1","49776592","","2018-04-11 08:26:03","","2","934","<p>I've inherited an <strong>RxSwift</strong> project which uses <strong>Moya</strong>. I have a task to move a request from one backend to another. Both backends have their <code>TargetType</code>s sets up just fine as they're being used extensively elsewhere.</p>

<p>The original request looked like this:</p>

<pre><code>return accessProvider.rx
    .request(request)
    .asObservable()
    .debug()
    .flatMapLatest({ [weak self] (response) -&gt; Observable&lt;Bool&gt; in
        //does some processing of the JSON
        return just(true)
    })
    .catchError({ (error) -&gt; Observable&lt;Bool&gt; in
        return just(false)
    })
</code></pre>

<p>This returns just fine and I get the data.</p>

<p>My new request is exactly the same but the only difference is the provider and requests are using the second <code>TargetType</code>. For this one, the requests never takes place (confirmed with Charles). I have checked the <code>TargetType</code> and it looks just fine and performing a non-Rx Moya request works fine, so does an Rx request where I subscribe to it.</p>

<p>Why doesn't it work using flatMapLatest?</p>

<p>I'm new to Rx and very new to Moya so any help is appreciated.</p>

<p>Edit:
Debug messages for the first provider:</p>

<pre><code>Refresh token -&gt; subscribed
Refresh token -&gt; subscribed
Refresh token -&gt; Event next(Status Code: 200, Data Length: 773)
</code></pre>

<p>Second:</p>

<pre><code>Refresh token -&gt; subscribed
</code></pre>

<p>Nothing else</p>
","945247","","945247","","2018-04-11 09:53:41","2018-04-11 13:35:17","Moya request not started for one provider but works for another","<ios><swift><rx-swift><moya>","2","0","","","","CC BY-SA 3.0"
"49808594","1","49809011","","2018-04-13 02:53:57","","1","4348","<p>I have <code>UISearchBar and SearchDisplayController</code> in the <code>Main.storyboard</code> embedded in a <code>UIViewController</code>s' <code>UIView</code>. Below I have <code>UITableView</code>. I am trying to use <code>RxSwift</code> to pipe the user input from <code>UISearchBar</code> straight into <code>UITableView</code>, doing results' filtering in-between. Pretty much it is autocomplete functionality that I am trying to implement. Somehow I am getting an error:</p>

<blockquote>
  <p>Thread 1: Fatal error: Failure converting from Optional() to UISearchBarDelegate</p>
</blockquote>

<p>Here is the code that I have:</p>

<pre><code>private func setUpAutocomplete() {
    // Define intput stream
    searchBar.rx.text
        .orEmpty
        .map({
            (query: String) -&gt; [String] in
            let res = AllGenes.filter { $0.hasPrefix(query) }
            return res
        })
        .bind(to: tableView.rx.items(cellIdentifier: cellIdentifier,
                                     cellType: GeneSeachTableViewCell.self)) {  row, gene, cell in
                                        cell.textLabel?.text = ""\(gene) \(row)""
        }
        .disposed(by: disposeBag)

} 
</code></pre>

<p>What am I doing wrong here? Any suggestions would be greatly appreciated.</p>
","3815432","","","","","2019-05-13 12:43:05","Bind from searchBar to TableView in RxSwift","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"49810194","1","49812270","","2018-04-13 05:55:40","","0","1190","<p>I'm still learning Rx and I'm trying to use RxSwift to make 3 requests that return depend on each other.</p>

<pre><code>* DocumentsA
 - CollectionA
   * DocumentsB
    - CollectionB
     * DocumentsC
      - CollectionC
</code></pre>

<p>The models are something like this:</p>

<pre><code>struct DocumentA {
  let documentsB: [DocumentB] 
}

struct DocumentB {
  let documentsC: [DocumentC] 
}

struct DocumentsC {
  let name: String 
}
</code></pre>

<p>So using RxSwift, I'm trying to request each level of the document using separate methods for each document:</p>

<pre><code>func fetchDocumentsA() -&gt; Observable&lt;DocumentA&gt; {
  return Observable.create { observer in
    fetchDocumentsB().subscribe(onNext: { documentB in
      if let documentA = DocumentA(documentB: documentB) {
        observer.onNext(documentA)
      }
    }, onError: nil, onCompleted: {
      observer.onCompleted()
    }, onDisposed: nil).disposed(by: self.disposeBag)
    return Disposables.create()
  }
}

func fetchDocumentsB() -&gt; Observable&lt;DocumentB&gt; {
  return Observable.create { observer in
    fetchDocumentsC().subscribe(onNext: { documentC in
      if let documentB = DocumentB(documentC: documentC) {
        observer.onNext(documentB)
      }
    }, onError: nil, onCompleted: {
      observer.onCompleted()
    }, onDisposed: nil).disposed(by: self.disposeBag)
    return Disposables.create()
  }
}

func fetchDocumentsC() -&gt; Observable&lt;DocumentC&gt; {
  return Observable.create { observer in
    fetchName().subscribe(onNext: { name in
      observer.onNext(DocumentC(name: name))
    }, onError: nil, onCompleted: {
      observer.onCompleted()
    }, onDisposed: nil).disposed(by: self.disposeBag)
    return Disposables.create()
  }
}
</code></pre>

<p>Is there a better way to do this? It seems very convoluted.</p>
","3191130","","","","","2018-04-13 08:13:39","RxSwift Chaining requests that depend from each other","<swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49831545","1","49866117","","2018-04-14 12:37:59","","2","1489","<p>I want to chain following operations </p>

<ul>
<li>createUserandVerify

<ul>
<li>Create Anonymous User (user)</li>
<li>Verify User -> verifiedUser</li>
<li>If verification successful return verifiedUser else return user</li>
</ul></li>
<li>Get stuff with coredata <code>getStuff</code>

<ul>
<li>If stuff.count > 0 Upload stuff with user credentials <code>uploadStuff</code></li>
</ul></li>
<li>Finally report the result of all operations</li>
</ul>

<p>I wrote createUserandVerify as below. I wonder how should I write <code>uploadStuff</code> in reactive way. Upload function depends on user credentials. Therefore It must only run after createUserandVerify. I know I could just check count of array inside <code>uploadStuff</code> and return empty but I wonder the best practices. </p>

<pre><code>func createUserandVerify() -&gt; Single&lt;User&gt; {
    return Service.sharedInstance.generateAnonUser()
        .flatMap{ user in
            if Service.sharedInstance.isOldRegisteredUser {
                print(""It is old user"")
                // We need to verify the receipt
                return  Service.sharedInstance.verifyReceipt()
                    .flatMap { verifiedUser in
                        print(""Returning Verified new user [Verification Success]"")
                        return Single.just((verifiedUser))

                    }.catchError{ error -&gt;Single&lt;User&gt; in
                        print(""Returning firstly created user [Verification Failed]"")
                        print(""Error Type: \(error)"")
                        return Single.just(user)

                }
            } else {
                //Normal anonymous old user
                print(""Returning firstly created user [Anonymous]"")
                return Single.just(user)
            }
    }
}
</code></pre>
","4170419","","","","","2018-04-16 21:20:15","Chaining operations with RxSwift","<swift><rx-swift>","1","3","1","","","CC BY-SA 3.0"
"49846157","1","","","2018-04-15 19:53:18","","0","147","<p>I am just playing with RxSwift to better understand the concepts. I am trying to validate email. However, the subscriber doesn't call when I return an Observable back. I thought this might work. Any suggestions?</p>

<pre><code>var emailAddressValid: Observable&lt;String&gt;{
        return self.userEmailAddress.asObservable().filter({ (userEmail) -&gt; Bool in
            userEmail.count &gt; 0
        }).flatMap({ (userEmail) -&gt; Observable&lt;String&gt; in
            if userEmail == ""abcd@gmail.com""{
                //This works perfectly
                return .just(""007"")
            } else {
                let emailDomain = userEmail.components(separatedBy: ""@"").last
                if emailDomain != nil {
                    //nothing happens in onNext
                    //This returns back an Observable&lt;String&gt;
                    return DataService.instance.checkDomainIsRegistered(domainName: emailDomain!)
                } else {
                    return .just(""0"")
                }
            }
        })
    }
</code></pre>

<p>Although the app works. However, there isn't any compiler error as well. But the onNext in the Observer doesn't work when I return DataService.instance.checkDomainIsRegistered(domainName: emailDomain!)</p>

<pre><code>func checkDomainIsRegistered(domainName: String) -&gt; Observable&lt;String&gt;{
        print(domainName)
        return Observable&lt;String&gt;.create{ data in
            self._REF_DOMAIN_NAMES.queryOrdered(byChild: ""domainName"").queryEqual(toValue: domainName).observeSingleEvent(of: .value, with: { (domainNameSnapshot) in
                if(domainNameSnapshot.exists()){
                    print(""1"")
                    data.onNext(""1"")
                } else {
                    print(""0"")
                    data.onNext(""0"")
                }
            }, withCancel: { (error) in
                data.onError(error)
            })
            data.onCompleted()
            return Disposables.create()
        }
    }
</code></pre>
","6495579","","","","","2018-04-22 17:22:32","Returning Observable is not working","<swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"49847380","1","","","2018-04-15 22:25:53","","4","1758","<p>Is it possible to map the error type with RxSwift? </p>

<p>For example, I have a helper function like this:</p>

<pre><code>enum InternalError: Error {
   case fooError
   case barError
}

private func helper() -&gt; Observable&lt;MyData&gt; {
    // ... 
}

enum ServiceError: Error {
    case fatalError(message: String)
    case warning(message: String)
}
</code></pre>

<p>I am hoping that we can do sth like this, notice the following <code>mapError</code> doesn't exist: </p>

<pre><code>func getData() -&gt; Observable&lt;MyData&gt; {
    helper().mapError({ error: InternalError -&gt; ServiceError
        switch error {
            case .fooError: 
                return ServiceError.fatalError(message: ""This is bad."")
            case .barError:
                return ServiceError.warning(message: ""Be careful."")
        }
    })
}
</code></pre>

<p>Is it possible? Or is it a bad idea in general? </p>
","1035008","","","","","2018-04-16 14:06:25","How to map one error to a different error with RxSwift","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49859936","1","49865604","","2018-04-16 14:36:14","","2","4476","<p>Let's say I create an Observable for each image download</p>

<pre><code>for _ in 0...N {
    let s : Single&lt;UIImage?&gt; = fetchImage(from url)
}
</code></pre>

<p>How can I:</p>

<ul>
<li>create a new Observable to emit an event when a download is completed</li>
<li>create a new Observable to emit only completed event when all download is completed</li>
</ul>

<p>Thanks!</p>
","3490834","","1113632","","2018-04-16 21:41:42","2020-12-18 10:41:08","How to combine multi Observable in RxSwift","<swift><rx-swift><reactive>","1","0","1","","","CC BY-SA 3.0"
"49862522","1","49877203","","2018-04-16 16:53:23","","1","348","<p>did anyone face RxSwift crash on XCode 9.3? here is the function that causes the problem </p>

<pre><code>func setupValidation(result: Variable&lt;ValidationState&gt;, testValues: Observable&lt;Bool&gt;...) {
let disposeBag: DisposeBag = DisposeBag()
Validation
  .combine(testValues)
  .bind(to: result)
  .disposed(by: disposeBag)}
</code></pre>

<p>here is the error:</p>

<blockquote>
  <p>Undefined symbols for architecture arm64:   ""(extension in
  RxCocoa):RxSwift.ObservableType.bind(to: RxSwift.Variable) ->
  RxSwift.Disposable""</p>
</blockquote>
","2112671","","2112671","","2018-04-17 10:48:38","2018-04-17 11:44:36","RxSwift crashes when running UnitTest on XCode 9.3","<swift><xcode><swift4><xctest><rx-swift>","1","7","","","","CC BY-SA 3.0"
"49863836","1","49991432","","2018-04-16 18:17:53","","0","857","<p>I am trying to respond to <code>UICollectionViewCell</code> selection:</p>

<pre><code>private func setupCellAction() {
    collectionView?.rx.itemSelected
        .asObservable()
        .subscribe(onNext: { [weak self] indexPath in
            print(""itemSelected!"")
            let cell = self?.collectionView?.cellForItem(at: indexPath) as? CellTypeCollectionViewCell
            self?.performSegue(withIdentifier: ""showBarchartSegue"", sender: cell)
        }).disposed(by: disposeBag)
}
</code></pre>

<p>But somehow <code>onNext</code> method is never called. I tried putting <code>setupCellAction()</code> in <code>viewDidLoad</code>, <code>viewWillAppear</code> and <code>viewDidAppear</code> but it is not working. Any suggestions would be greatly appreciated.</p>

<blockquote>
  <p>Update</p>
</blockquote>

<p>I tried the suggestion from the following thread: <a href=""https://stackoverflow.com/questions/43323645/how-to-select-collectionview-cell-in-rxswift"">How to select CollectionView cell in RxSwift</a></p>

<p>and added <code>.debug(""RX: Model selected"")</code> before the <code>subscribe</code> method. I see the output in the console that it is subscribed once.</p>

<blockquote>
  <p>Update</p>
</blockquote>

<p>I tried rewriting the <code>setupCellAction()</code> in the following way:</p>

<pre><code>private func setupCellAction() {
    collectionView?.rx.modelSelected(CellTypeCollectionViewCell.self)
        .asObservable()
        .debug(""RX: Model selected"")
        .subscribe(onNext: { [weak self] cell in
            print(""itemSelected!"")
            self?.performSegue(withIdentifier: ""showBarchartSegue"", sender: cell)
        }).disposed(by: disposeBag)
}
</code></pre>

<p>It is not working either. I see also that it is subscribed once in the console. </p>

<blockquote>
  <p>Update</p>
</blockquote>

<p><code>UICollectionViewController</code> was embedded in another container <code>UIViewController</code>, and in it I defined <code>UITapGestureRecognizer</code>. After commenting out the code for the <code>UITapGestureRecognizer</code>, the <code>itemSelected()</code> method started to work. Right now I need a way to let the tap event through if it happened on the <code>UICollectionViewCell</code>. Is there a way to do that?</p>

<p>The code for tapping in the container controller (<code>viewDidLoad</code>):</p>

<pre><code>let tap = UITapGestureRecognizer(target: self, action: 
#selector(self.handleTap(_:)))
    tap.delegate = self
    view.addGestureRecognizer(tap)
</code></pre>

<p>The <code>handleTap():</code></p>

<pre><code>@objc func handleTap(_ sender: UITapGestureRecognizer) {
    tableView.isHidden = true
    searchBar.resignFirstResponder()
}
</code></pre>
","3815432","","3815432","","2018-04-16 21:59:59","2018-04-23 23:44:07","Selecting UICollectionViewCell in the presence of UITapGestureRecognizer","<swift><uicollectionview><rx-swift>","1","4","","","","CC BY-SA 3.0"
"49866073","1","","","2018-04-16 20:55:24","","0","439","<p>I have developed a struct that generates random data for testing purposes in my app but only does so if the Realm database is empty. The service class responsible for CRUD operations returns outcomes / results as RxSwift Observables. 
Generating new data is predicated on the contents of the Realm - using <code>guard</code> is the logical choice but requires adding a new method to the service that returns <code>Int</code> rather than an <code>Observable</code> which seems to be an unnecessary duplication of code and somewhat inconsistent.</p>

<p>i.e.</p>

<pre><code>class Service {
  let realm = try! Realm()
  ...
  // Existing reactive code
  func patients() -&gt; Observable&lt;Result&lt;Patient&gt;&gt; {
    let results = realm.objects(Patient.self)
    return Observable.collection(from: results)
  }

  func objectCount() -&gt; Int {
    let realm = try! Realm()
    return realm.objects(Patient.self).count
  }
}

struct DataGenerator() {
...
  func createRandomPatients() {
    let service = Service()
    guard service.objectCount() == 0 else { return }
    ...
    //go on to generate patients
</code></pre>

<p>The only way I can figure to replicate this control flow using the reactive service method is to bind the <code>Observable</code> to a <code>Variable</code></p>

<p>i.e.</p>

<pre><code>... service code as above ...
func createRandomPatients() {
   let isEmpty = Variable&lt;Bool&gt;(false)
   service.patients().map{ $0 == 0 }.bind(to: isEmpty)
   guard isEmpty.value else { return }
   // etc
</code></pre>

<p>It seems like a bit of a fudge as it perhaps isn't quite as clear, but it avoids adding code to the service class that won't be used in the production app. Is this bad practice or just personal preference? I'm open to alternative solutions if anyone has one...</p>
","2733214","","","","","2018-04-17 06:19:59","RxSwift and control flow - a bad idea?","<swift><realm><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49895644","1","","","2018-04-18 09:10:24","","1","1306","<p>I'm trying to write an API layer using RxSwift and RxAlamofire. 
Here is the code for API request.</p>

<pre><code>public func _request(_ method: Alamofire.HTTPMethod, url: URLConvertible, parameters: [String : Any]? , encoding: ParameterEncoding, headers: [String : String]?, isSecondTryAfterAuth: Bool = false) -&gt; RxSwift.Observable&lt;(HTTPURLResponse, Any)&gt;
{
    return RxAlamofire
        .requestJSON(method, url, parameters: parameters, encoding: JSONEncoding.default, headers: self.appDelegateInstance.refreshToken)
        .map({ (response, json) -&gt; Observable&lt;(HTTPURLResponse, Any)&gt; in
            return Observable.just(response, json)
        })
}
</code></pre>

<p>I got an error in .map function ""Closure tuple parameter '(HTTPURLResponse, Any)' does not support destructuring"". Any idea about how to solve this?<a href=""https://i.stack.imgur.com/KpWt0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KpWt0.png"" alt=""enter image description here""></a></p>
","5662641","","","","","2018-04-18 21:04:46","Error in closure tuple parameter","<ios><swift><alamofire><rx-swift><rxalamofire>","2","0","","","","CC BY-SA 3.0"
"49906188","1","","","2018-04-18 18:00:59","","0","682","<p>I have this function which doesn't work, because immediately returns without setting <code>data</code></p>

<pre class=""lang-swift prettyprint-override""><code>func fetchedData() -&gt; String {
    var data: String
    networkRequest.suscribe(
        onNext: {
            data = ""successful""
        },
        onError: {
            data = ""unsuccesful""
    }).addDisposableTo(self.disposeBag)
    return data
}
</code></pre>

<p>How can I make it work? Sorry I am fairly new to RxSwift</p>
","2916125","","","","","2018-04-20 08:45:14","How to get a non-observable value from a function?","<rx-swift>","2","0","","","","CC BY-SA 3.0"
"49911250","1","49920689","","2018-04-19 01:19:30","","3","1506","<p>After some flatMap chain, I want use all previous result in the end, suppose I have the following code:</p>

<pre><code>func getObservable1() -&gt; Observable&lt;API1Response&gt; {

    ...
}

func getObservable2(param: API1Response) -&gt; Observable&lt;API2Response&gt; {

    ...
}

func getObservable3(param: API2Response) -&gt; Observable&lt;API3Response&gt; {

    ...
}

getObservable1()
    .flatMap { api1Response in
        return getObservable2(api1Response) 
    }
    .flatMap { api2Response in
        return getObservable3(api2Response) 
    }
    .subscribe(onNext: { api3Response  in
        // I want to use both of api1Response and api2Response here
    })
</code></pre>

<p>How can I do that?</p>

<p>Should I save the api response to out scope variable and then use its latter?</p>

<p>Something like:</p>

<pre><code>var api1Response: API1Response?
func getObservable1() -&gt; Observable&lt;API1Response&gt; {
    ...

    self.api1Response = api1Response
    ...
}
...
getObservable1()
    ...
    .subscribe(onNext: { api3Response  in
        // use ap1Response here
        print(self.api1Response)
    })
</code></pre>

<p>Thanks!</p>

<p>-----UPDATE-----</p>

<p>Base on @Misternewb answer, I post runable code for test.</p>

<pre><code>func getObservable1() -&gt; Observable&lt;Int&gt; {
    return Observable.of(1)
}

func getObservable2(num: Int) -&gt; Observable&lt;Int&gt; {
    return Observable.of(num + 1)
}

func getObservable3(num: Int) -&gt; Observable&lt;Int&gt; {
    return Observable.of(num + 10)
}


getObservable1()
    .flatMap { ret1 in
        return getObservable2(num: ret1).map { (ret1, $0) }
    }
    .flatMap { ret1, ret2 in
        return getObservable3(num: ret2).map { (ret1, ret2, $0) }
    }
    .subscribe(onNext: { ret1, ret2, ret3 in
        print(ret1)
        print(ret2)
        print(ret3)
    })
</code></pre>

<p>Output</p>

<pre><code>1
2
12
</code></pre>
","3490834","","3490834","","2018-04-20 00:39:24","2018-04-20 00:39:24","How to use the result of previous observable chain?","<swift><rx-swift><reactive>","2","0","","","","CC BY-SA 3.0"
"49917217","1","","","2018-04-19 09:16:10","","3","766","<p>I currently have the following code</p>

<pre><code>func updateItems(_ observable: Observable&lt;ContainingEntity&gt;) -&gt; Observable&lt;ContainingEntity&gt;{
    return observable
        .concatMap({ (containingEntity) -&gt; Observable&lt;ContainingEntity&gt; in
            guard let itemEntity = orderEntity.itemEntity,
                itemEntity.name.count == 0 else{
                    return Observable.just(entity)
            }

            print(""Need to fetch name of item #\(itemEntity.id)"")

            return RestManager.getDetailOf(item: itemEntity)
                .flatMap({ (updatedItemEntity) -&gt; Observable&lt;ContainingEntity&gt; in
                    var updatedContainingEntity = containingEntity
                    containingEntity.itemEntity = updatedItemEntity
                    print(""Fetched item name: \(itemEntity.name)"")
                    return Observable.just(containingEntity)
                })
        })
}
</code></pre>

<p>Basically, I need to make sure that the <strong>itemEntity</strong> of each <strong>ContainingEntity</strong> has a name and, if not, request it with Moya.</p>

<p>But I'm facing the following type of output from the two prints:</p>

<ul>
<li>Need to fetch name of item #1</li>
<li>Need to fetch name of item #2</li>
<li>Need to fetch name of item #3</li>
<li>Fetched item name: Name1</li>
<li>Fetched item name: Name2</li>
<li>Fetched item name: Name3</li>
</ul>

<p>Meaning that operations in my concatMap are executed in parallel, which I don't want because of requests redundancies and some cache system I didn't show here: I can have 30 times the same item id and I don't want to request it 30 times.</p>

<p>What I'm expecting is:</p>

<ul>
<li>Need to fetch name of item #1</li>
<li>Fetched item name: Name1</li>
<li><p>Need to fetch name of item #2</p></li>
<li><p>Fetched item name: Name2</p></li>
<li>Need to fetch name of item #3</li>
<li>Fetched item name: Name3</li>
</ul>

<p>How can I fix this issue? Thank you very much for your help.</p>

<p><strong>UPDATE:</strong></p>

<p>I'm now using some kind of simple buffer, which saves <strong>ItemEntities</strong> needing to be updated and assigns these items to the next <strong>ContainingEntities</strong> with the same item identifier. This prevents Moya from performing the same request several times.</p>

<p>It works perfectly but I don't very much like the idea of this mechanism external to RX...</p>
","5385039","","5385039","","2018-04-25 07:28:28","2018-04-25 07:28:28","RxSwift sequential flatMap with Moya request","<swift><rx-swift><reactivex><moya>","1","0","","","","CC BY-SA 3.0"
"49923610","1","49924531","","2018-04-19 14:28:31","","3","1023","<p>I updated from Swift 3 to 4, and i am using RxSwift, When updated i came across an error ""Extra argument in call"" as it expects now of type element. I tried creating tuple of (response, data) but still gives me an error as shown.</p>

<pre><code>     public static func deleteCrush(receiver: String, receiver_type: ProviderType) -&gt; Observable&lt;(HTTPURLResponse, NSArray)&gt; {
    /*
     Delete crush identified by `id`

   */

    let parameters: Parameters = [
        ""receiver"": receiver,
        ""receiver_type"": receiver_type.rawValue
    ]

    print(""deleteCrush paramreters: \(parameters)"")

    return Observable.create({ (observer) -&gt; Disposable in
        Alamofire.request(Router.deleteCrush(parameters: parameters))
            .rx
            .responseJSON()
            .debug()
            .subscribe(onNext: { (response, json) in
                print(""deleteCrush response code: "", response.statusCode)
                if let data = json as? NSArray {
                    observer.on(.next(response, data))
                    observer.on(.completed)
                }
            }, onError: { (error) in
                print(""deleteCrush error: "", error)
                observer.on(.error(error))
            }, onCompleted: nil, onDisposed: nil)
    })
}
</code></pre>

<p><strong>Error:</strong> Extra argument in call.<br>
<strong>After trying to fix:</strong></p>

<pre><code>     var tuple = (response, json)
                 if let data = json as? NSArray {
                    observer.on(.next(tuple))
                    observer.on(.completed)
                }
</code></pre>

<p><strong>Error:</strong></p>

<blockquote>
  <p>Event&lt;(HTTPURLResponse, NSDictionary)>' produces result of type 'Event', but context expects 'Event&lt;(HTTPURLResponse, NSDictionary)></p>
</blockquote>
","4711721","","4711721","","2018-04-19 14:49:57","2018-04-19 15:12:41","Swift 4 ""Extra argument in call"" Rxswift","<swift><rx-swift>","2","6","0","","","CC BY-SA 3.0"
"49926336","1","","","2018-04-19 16:51:44","","0","686","<p>Trying to figure out the reason as i tried removing the whole onError block, it resulted in the error for the onCompleted block.</p>

<pre><code>public static func register(phone_number: String, password: String) -&gt;  Observable&lt;(HTTPURLResponse, NSDictionary)&gt; {
    /*
     Registers a user using their phone number and password

     */
    let parameters: Parameters = [""phone_number"": phone_number, ""password"": password]
    return Observable.create({ (observer) -&gt; Disposable in
        Alamofire.request(Router.register(parameters: parameters))
            .rx
            .responseJSON()
            .subscribe(onNext: { (response, json) in
                if let data = json as? NSDictionary {
                    if let returned_phone_number = data[""phone_number""] as? String
                    {
                        if returned_phone_number == phone_number {
                            print(""success"")
                        } else {
                            print(returned_phone_number)
                        }

                    }

                     observer.on(.next(response, data))
                }
            }, onError: { (error) in \\ error here 'extra argument ""onError"" calls'
                observer.on(.error(error))
            }, onCompleted: { (response)  in
                observer.on(.completed)
            }, onDisposed: nil)
    })

}
</code></pre>
","4711721","","","","","2018-04-20 08:24:39","RxSwift 'Extra argument 'onError' after migration to Swift 4","<ios><swift><xcode><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49941001","1","","","2018-04-20 11:49:39","","0","3074","<p>I am working with web api which load array of data. But the size of data is big, So I want to apply lazy loading, data on demand technique so that I can quickly load small chunk of data and when user reach the last element of tableview cell then it can load next chunk of data. I want to know is it possible with Rxswift?</p>
","8879772","","1113632","","2018-04-20 14:11:33","2018-04-21 14:53:14","UITableView load more when scrolling to bottom using Rxswift","<swift><rx-swift>","1","0","","","","CC BY-SA 3.0"
"49999237","1","","","2018-04-24 10:22:01","","2","824","<p>I'm wondering what best practice is in the following situation:</p>

<ul>
<li>Project setup is Model-View-ViewModel</li>
<li>I need to display a screen with text fields (e.g. <code>name</code>) where the user an edit details of a specific <code>Model</code></li>
<li>ViewModel contains an <code>Observable&lt;Model&gt;</code>; ViewModel is responsible for retrieving data from the API</li>
<li>View contains input fields which need to be pre-populated with the current data from the <code>Model</code></li>
<li>Input fields need to be bound to e.g. <code>BehaviorRelay</code>s in the ViewModel</li>
</ul>

<p>I am struggling with finding the best way to solve this:</p>

<ul>
<li>I don't want subscriptions in the ViewModel</li>
<li>I want the ViewModel to be responsible for retrieving the data and populating the <code>BehaviorRelay</code>s or similar</li>
</ul>

<p>I basically want to have something similar to <code>BehaviorRelay</code>s, but with an initial value from an <code>Observable</code>. Upon subscription (binding) to the BehaviorRelays, I want them to retrieve the data from the API. Or <code>flatMap</code> an <code>Observable</code> to a <code>BehaviorRelay</code>?</p>

<p>What would be the best way to solve this?</p>

<p>The ways I've implemented this before, with their drawbacks:</p>

<ol>
<li>Skip the <code>BehaviorRelay</code>s in the ViewModel, and keep the state in the ViewController. Just subscribe from the ViewController to the <code>Observable&lt;Model&gt;</code> in the ViewModel and bind it to the UI. Then when the user wants to save the data, retrieve the latest value from the UI (<code>withLatestFrom()</code>) and pass it as a value to a <code>func save(attribute: Value)</code> in the ViewModel. This works, but I'd like to keep all the state (and business logic) in the ViewModel.</li>
<li>In the ViewModel, use <code>BehaviorRelay</code> with an empty initial value, then in the <code>init()</code> of the ViewModel, retrieve the data and bind it to the <code>BehaviorRelay</code>s. This means having a subscription in the ViewModel, which I want to avoid.</li>
<li>Having something like a <code>func refresh() -&gt; Completable</code> in the ViewModel, which sets the values in the <code>BehaviorRelay</code>s in its <code>do(onNext:)</code>. This works but feels hacky.</li>
<li><p>Having a <code>let refresh = PublishSubject&lt;()&gt;()</code> in the ViewModel, and e.g. </p>

<pre><code>var model: Observable&lt;Model&gt; {
  refresh
    .startWith(())
    .flatMapLatest { retrieveData() }
}
</code></pre>

<p>again, with a <code>do(onNext:)</code>. Same drawback as previous solution (feels hacky).</p></li>
<li>Retrieve the data before initializing the ViewModel, and initialize the ViewModel with the model instance. I don't like this solution as I want the ViewModel to be responsible for retrieving it's own data.</li>
</ol>

<p>Is there another way?</p>
","2897872","","1113632","","2018-04-25 15:56:26","2018-04-25 15:56:26","RxSwift, ViewModels and UI-bindings","<swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 3.0"
"50002338","1","50008827","","2018-04-24 12:59:10","","0","150","<p>How can I solve this problem? At the <code>map</code> function, it says Expression was too complex to be solved in reasonable time; consider breaking up the expression into distinct sub-expressions.</p>

<pre><code>let manuallyShowFerryInBoundPopup = Observable.merge([
            NotificationCenter.default.rx
                .notification(NSNotification.Name.UIApplicationDidBecomeActive)
                .map { _ in () },
            viewDidAppear
            ])
            .flatMap { VADApi.FerryDestination.list(skip: 0, take: 1, token: VADDataManager.getUserToken()!) }
            .map { $0.first }
            .filter {
                $0 != nil
                &amp;&amp; ""\(String(($0?.ferry?.id)!)),\(String(($0?.id)!))"" != VADDataManager.shownFerryInBoundTrace
            }
            .map { ( ($0?.ferry?.id)!, ($0?.id)! ) } // Expression was too complex to be solved in reasonable time; consider breaking up the expression into distinct sub-expressions
</code></pre>
","1416628","","","","","2018-04-25 07:26:27","RxSwift .map Expression was too complex to be solved in reasonable time; consider breaking up the expression into distinct sub-expressions","<swift><xcode><rx-swift>","2","0","","","","CC BY-SA 3.0"
"50015805","1","","","2018-04-25 06:52:26","","0","563","<p>I am trying to use RxAlamofire for Reactive requests. There is a method for creating <code>POST</code> request with -</p>

<pre><code>public func request(_ method: Alamofire.HTTPMethod,
    _ url: URLConvertible,
    parameters: [String: Any]? = nil,
    encoding: ParameterEncoding = URLEncoding.default,
    headers: [String: String]? = nil
)
</code></pre>

<p>But I cannot pass an Array <code>[[String : Any]]</code> to the parameters for obvious reasons. So how do I create a request with this array as parameters?</p>

<p>Being more specific, I can pass</p>

<pre><code>let student = [""firstName"":""Mayur"", ""lastName"":""Deshmukh""]
</code></pre>

<p>as a parameter because it is of type <code>[String : Any]</code></p>

<p>But I cannot pass array like</p>

<pre><code>let students = [[""firstName"":""Mayur"", ""lastName"":""Deshmukh""],
                [""firstName"":""Kaustubh"", ""lastName"":""Deshmukh""]]
</code></pre>

<p>As now the type of students is <code>[[String : Any]]</code>
So does Alamofire or RxAlamofire have any handy method for creating requests with JSON Array as parameter? Or do we have to take a harder way?</p>
","3683405","","3683405","","2018-04-26 12:29:46","2018-04-26 12:29:46","How to Post request in RxAlamofire with Array as parameters instead of Dictionary?","<swift><rx-swift><rxalamofire>","1","0","","","","CC BY-SA 3.0"
"50017112","1","","","2018-04-25 08:08:50","","0","292","<p>The following code never seems to work as the groups don't appear to terminate and takeLast() does not know what is last: </p>

<pre><code>observableSequence
  .groupBy { $0.key }
  .map { groups in
    groups
    .takeLast(1)
    .subscribe(onNext: { element in
      print(element)
    })
    .disposed(by: self.disposeBag)
  }
  .subscribe()
  .disposed(by: self.disposeBag)
</code></pre>
","1967563","","1967563","","2018-04-25 11:15:20","2018-04-25 12:32:57","RxSwift: Should groupBy send completed to each of its GroupedObservable's when the source is completed?","<swift><rx-swift>","2","0","","","","CC BY-SA 3.0"
"50020345","1","","","2018-04-25 10:47:56","","40","23558","<p>I'm trying to get my head around the golden rule (if any) about:</p>

<blockquote>
  <p>When to use BehaviorSubject ?</p>
</blockquote>

<p>and </p>

<blockquote>
  <p>When to use PublishSubject ?</p>
</blockquote>

<p>The difference between them is very clear</p>

<blockquote>
  <p>There are many kinds of subjects. For this specific requirement, a PublishSubject works well because we wish to continue the sequence from where it left off. So assuming events 1,2,3 were emitted in (B), after (A) connects back we only want to see 4, 5, 6. If we used a ReplaySubject we would see [1, 2, 3], 4, 5, 6; or if we used a BehaviorSubject we would see 3, 4, 5, 6 etc.
  (source : <a href=""https://tech.instacart.com/how-to-think-about-subjects-in-rxjava-part-1-ca509b981020"" rel=""noreferrer"">How to think about Subjects in RxJava (Part 1)</a>)</p>
</blockquote>

<p>I have seen that <code>Subject</code>'s are used in two contexts (at least), UI context and listener context.</p>

<ul>
<li>UI context (MVVM as example)</li>
</ul>

<p>For example <a href=""https://github.com/florina-muntenescu/DroidconMVVM/blob/master/app/src/main/java/upday/droidconmvvm/MainViewModel.java#L22"" rel=""noreferrer"">here</a> a <code>BehaviorSubject</code> is used, and it's clear why they use <code>Subject</code> and not <code>Observable</code> but I have changed the <code>BehaviorSubject</code> to <code>PublishSubject</code> but the app behavior still the same.</p>

<ul>
<li>Listener context</li>
</ul>

<p>Why they make <a href=""https://github.com/kickstarter/android-oss/blob/a5cdac532fbb0c000b6c79e9b8e6744cbdb418ec/app/src/main/java/com/kickstarter/viewmodels/ProjectSocialViewModel.java#L32"" rel=""noreferrer"">project</a> field a <code>BehaviorSubject</code> and not <code>PublishSubject</code> ?</p>
","3672184","","2415178","","2019-10-12 03:49:47","2020-02-27 04:33:25","BehaviorSubject vs PublishSubject","<android><rx-java><rx-swift><reactivex>","4","1","6","","","CC BY-SA 3.0"
"50021467","1","","","2018-04-25 11:44:07","","1","2406","<p>I am new on RxSwift and I am trying to implement UITableView with it.
I successfully implemented UITableView cell with rx.items and now I need to use didSelect method.</p>

<p>My problem is; my first cell selection, it called only once and I printed item. But after the first selection <strong>tableView.rx.modelSelected</strong> called multiple times.</p>

<p>What is the reason for it? How can I prevent from this?</p>

<p>Thanks.</p>

<pre><code> func showContactListView() {
        UIView.transition(with: self.view, duration: 0.5, options: UIViewAnimationOptions.curveEaseIn,
                          animations: {self.view.addSubview(self.contactSelectionView)}, completion: nil)

       self.selectEmployeeFromList()
    }

    func selectEmployeeFromList() {

        self.contactSelectionView.tableView.rx.modelSelected(Employee.self)
            .subscribe(onNext: { item in

                print(item)
                self.contactSelectionView.removeFromSuperview()



            }).disposed(by: self.disposeBag)


    }
</code></pre>
","2622013","","","","","2018-04-25 12:17:33","RxSwift ""tableView.rx.modelSelected"" called multiple time","<swift><xcode><uitableview><rx-swift><rx-cocoa>","1","0","1","","","CC BY-SA 3.0"
"50043435","1","","","2018-04-26 12:49:08","","1","4241","<p>I have a <code>Subject</code> observable representing the result of the network request that needs to be delivered to multiple subscribers.</p>

<p>I can use <code>ReplaySubject</code> of buffer 1 and <code>publish()</code> method. However, the network request gets executed only once.</p>

<p>I'd like to trigger the fetch event at any give point in the future. How can I trigger a new requst?</p>

<p>Currently, I have a <code>Service</code> object that holds the <code>ReplaySubject</code> and has a method <code>reload()</code> which triggers the network request and publishes the result to the a<code>ReplaySubject</code>.</p>

<p><strong>Is there any method on <code>Observable</code> that can ""refresh"" it and deliver a new value to all the current subscribers?</strong></p>
","3667264","","","","","2018-05-01 05:52:43","RxSwift trigger observable execution","<ios><observable><rx-swift><subject-observer><publishsubject>","1","0","1","","","CC BY-SA 3.0"
"50062910","1","50076519","","2018-04-27 12:57:41","","1","745","<p>I'm downloading a list of books from an API, and for each book I want to download its cover image.</p>

<p>I'm stuck with what I think it's a very simple and common task in Rx. I've done a research but I cannot find the solution because all the related questions are about how to return another <code>Observable</code>; for example get Github repositories and then get the issues for each one, but returning <code>Observable&lt;Issue&gt;</code> not a modified <code>Observable&lt;Repository&gt;</code>, that is my case. In my case I want to modify the previous observable result (<code>Observable&lt;[Book]&gt;</code>) with the result of another request returning different observable (<code>Observable&lt;Data&gt;</code>).</p>

<p>For now I have the first part, download books:</p>

<pre><code>func search(query: String) -&gt; Observable&lt;[Book]&gt; {
    return networkSession.rx
        .data(request: URLRequest(url: url))
        .map({ try JSONDecoder().decode([Book].self, from: $0) })
}
</code></pre>

<p><code>Book</code> is a simple struct:</p>

<pre><code>struct Book {
    let title: String
    let authors: [String]
    let coverImageURL: URL
    var coverImage: Data?
}
</code></pre>

<p>After that I'm able to download each image but I don't know how to assign it to each object in order to return the same <code>Observable&lt;[Book]&gt;</code> type without messing with nested observables and a zillion of compile time errors. I'm pretty sure this is a common scenario to use <code>flatMap</code> but it is still kind of obscure to me.</p>

<p>Thank you so much!</p>
","191059","","","","","2018-04-30 11:18:27","RxSwift, chain dependent downloads returning same Observable type","<ios><swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 3.0"
"50084692","1","","","2018-04-29 08:26:49","","0","501","<p>I'm trying to understand mvvm + RxSwift but I got some questions.</p>

<p>I'm currently using this approach which I'm not sure if is the right or can be better. How can I do to like grouping the methods, I mean, maybe something like doFirst(loading = true).doNext(getData).doLast(loading = false).catch(apiError) then subscribe to this event? It's possible?</p>

<p>ViewController:</p>

<pre><code>class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()

        viewModel = UsersViewModel(apiService: apiService)
        configureBindings()
    }

    func configureBindings() {

        tableView.delegate = nil
        tableView.dataSource = nil

        viewModel.isLoading.bind(to: loadingView.rx.isAnimating)
            .disposed(by: disposeBag)

        viewModel.models
            .bind(to: tableView.rx.items(cellIdentifier: ""userCell"", cellType: UserCell.self)) {(_, _, cell) in
                print(""Binding the cell items"")
            }.disposed(by: disposeBag)

        tableView.rx.modelSelected(User.self).subscribe(onNext: { value in
            print(value)
        }).disposed(by: disposeBag)

        viewModel.error.filterNil().subscribe(onNext: { (err) in
            self.tableView.backgroundView = EmptyView(title: ""No Users"", description: ""No users found"")
            print(""Showing empty view..."")
            print(err)
        }).disposed(by: disposeBag)
    }
}
</code></pre>

<p>Then in my UsersViewModel:</p>

<pre><code>class UsersViewModel {

    var models: Observable&lt;[User]&gt; {
        return modelsVariable.asObservable()
    }

    var isLoading: Observable&lt;Bool&gt; {
        return isLoadingVariable.asObservable()
    }

    var error: Observable&lt;ApiError?&gt; {
        return errorVariable.asObservable()
    }

    private var modelsVariable = BehaviorRelay&lt;[User]&gt;(value: [])
    private var isLoadingVariable = BehaviorRelay&lt;Bool&gt;(value: false)
    private var errorVariable = BehaviorRelay&lt;ApiError?&gt;(value: nil)

    // MARK: - Data Manager
    var apiService: API

    required init(apiService: API) {
        self.apiService = apiService

        isLoadingVariable.accept(true)

        apiService.GET(EndPoints.USER_LIST, type: Several&lt;User&gt;.self)
            .subscribe(onNext: { (model) in
                self.isLoadingVariable.accept(false)
                self.modelsVariable.accept(model.items)
            }, onError: { (err) in
                self.isLoadingVariable.accept(false)
                self.errorVariable.accept(err as? ApiError)
            })
    }
}
</code></pre>

<p>My 'GET' function just returns a <code>Observable&lt;Several&lt;User&gt;&gt;.</code></p>

<p>Several:</p>

<pre><code>struct Several {
    var items: [User]
}
</code></pre>

<p>Is there any improvements that I can do?</p>
","6606971","","8069241","","2018-04-30 13:00:41","2018-05-01 04:43:08","MVVM with RxSwift","<ios><swift><observable><alamofire><rx-swift>","1","0","","","","CC BY-SA 3.0"
"50086199","1","","","2018-04-29 11:42:54","","1","281","<p>I have unique cell in UITableView, which has two buttons. I need to bind these actions to viewModel of controller. I bind view with view model in this way:</p>

<pre><code>func attach(wrapper: Attachable&lt;ViewModel&gt;) -&gt; ViewModel {
    self.viewModel = wrapper
    loadViewIfNeeded()
    let viewModel = self.viewModel.bind(bindings: bindings)
    return bind(viewModel: viewModel)
}
</code></pre>

<p>So, when loadViewIfNeeded() method invokes, I still don't have any cells from data source. That's why I can't create bindings from cell's buttons.</p>

<p>I tried to use delegate and relate on this way, but I think I missed better solution:</p>

<pre><code>protocol ProfileActionsViewCellDelegate {
     var addFriendButton: UIButton { get }
}
</code></pre>

<p>code inside cell</p>

<pre><code>func bind(to viewModel: ProfileActionsViewModel) {
    addFriendButton.rx.tap
        .do(onNext: { [unowned self] _ in self.delegate?.addFriendButton.sendActions(for: .touchUpInside) })
        .debug()
        .subscribe()
        .disposed(by: disposeBag)
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/zOV7e.png"" rel=""nofollow noreferrer"">mvvm profile example</a></p>
","9717205","","9717205","","2018-04-29 11:54:01","2018-04-29 11:54:01","How to handle unique cell action with mvvm","<ios><swift><mvvm><rx-swift>","0","0","","","","CC BY-SA 3.0"
"50097291","1","","","2018-04-30 09:06:35","","1","555","<p>I'm having a headache because of this issue. Why my SplashscreenViewController doesn't deinitialize? Do you guys see any potential retain cycles in the code posted below?
I tried to check Malloc stack, but couldn't find any useful informations. </p>

<pre><code>final class SplashscreenViewController: UIViewController {
    var viewModel: SplashscreenViewModelType!

    private let animationStartScale: CGFloat = 0.75
    private let animationEndScale: CGFloat = 1.0
    private let animationDuration: TimeInterval = 0.4

    private let splashscreenDuration: TimeInterval = 1.5

    @IBOutlet private weak var logoImageView: UIImageView!

    override func viewDidLoad() {
        super.viewDidLoad()

        animateLogo(scale: animationStartScale)
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        DispatchQueue.main.asyncAfter(deadline: .now() + splashscreenDuration, execute: { [weak self] in
            self?.viewModel.onFinish.onNext(())
        })
    }

    private func animateLogo(scale: CGFloat) {
        UIView.animate(withDuration: animationDuration, animations: {
            self.transformImage(scale: scale)
        }, completion: { _ in
            if scale == self.animationStartScale {
                self.animateLogo(scale: self.animationEndScale)
            } else {
                self.animateLogo(scale: self.animationStartScale)
            }
        })
    }

    private func transformImage(scale: CGFloat) {
         logoImageView.transform = CGAffineTransform(scaleX: scale, y: scale)
    }
}
</code></pre>

<p>The class which holds an instance of SplaschreenViewController is its coordinator. The code below:</p>

<pre><code>final class SplashscreenCoordinator: BaseCoordinator {
    private let window: UIWindow

    init(window: UIWindow) {
        self.window = window
    }

    override func start() -&gt; Observable&lt;Void&gt; {
        let vc: SplashscreenViewController = SwinjectStoryboard.instantiateInitialViewController()
        window.rootViewController = vc
        window.makeKeyAndVisible()

        let onFinish = vc.viewModel.onFinish
            .asObservable()
            .flatMap { [unowned self] _ -&gt; Observable&lt;Void&gt; in
                guard self.window.rootViewController == vc else {
                    return Observable&lt;Void&gt;.empty()
                }
                if UserPreferencesManager.isLoggedIn() {
                    return self.startAppForLoggedInUser()
                } else {
                    return self.startAppForAnonymousUser()
                }
            }

        return onFinish
    }

    private func startAppForLoggedInUser() -&gt; Observable&lt;Void&gt; {
        let tabBar = TabBarCoordinator(window: window)
        return coordinate(to: tabBar)
    }

    private func startAppForAnonymousUser() -&gt; Observable&lt;Void&gt; {
        let startCoordinator = StartCoordinator(window: window)
        return coordinate(to: startCoordinator)
    }
}
</code></pre>

<p>And some code from BaseCoordinator:</p>

<pre><code>...
private func store(coordinator: BaseCoordinator) {
    childCoordinators[coordinator.identifier] = coordinator
}

private func free(coordinator: BaseCoordinator) {
    childCoordinators[coordinator.identifier] = nil
}

func coordinate(to coordinator: BaseCoordinator) -&gt; Observable&lt;Void&gt; {
    store(coordinator: coordinator)
    return coordinator.start()
        .do(onNext: { [weak self] _ in
            self?.free(coordinator: coordinator)
        })
}
...
</code></pre>

<p>Thanks in advance for your answers!</p>
","3636453","","3636453","","2018-04-30 10:07:51","2018-05-01 03:52:47","UIViewController does not deinitialize (mvvm + coordinators)","<swift><mvvm><rx-swift><swinject><coordinator-pattern>","1","0","","","","CC BY-SA 3.0"
"50129748","1","50129992","","2018-05-02 08:02:26","","2","1096","<p>I have a class with the <code>Variable</code> properties <code>number</code> and <code>text</code> and want to observe any changes done on both variables. The values of these properties are not needed.</p>

<p>In my <strong>real case</strong> I have <strong>more than 10</strong> <code>Variables</code> to observe, so maybe it should be possible to pass them <strong>as an array of</strong> <code>.asObservable()</code>.</p>

<pre><code>let number: Variable&lt;Int&gt;

let text:   Variable&lt;String&gt;

func doSomethingWhenAnyValueWasChanged() {
    // some code
}
</code></pre>

<p>How do I achieve that?</p>

<p>I tried to do it with <code>Observable.combineLatest()</code> in multiple ways, but it didn't work out for me. Maybe I missed something?</p>
","3049705","","3049705","","2018-05-02 08:56:48","2018-05-02 09:34:12","How to observe multiple variables for .next event while ignoring values in RxSwift","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"50129824","1","","","2018-05-02 08:06:55","","2","329","<p>I often find my self chaining multiple http request with flatmap but sometimes i need to carry the result further than the next observable. How would I go about doing that?</p>

<p>Fx:</p>

<pre><code>getAPIKey().flatMap( {key in 
    return getData1(key)
})
.flatMap({ (key, data) in 
   return getData2(key, data)
})
.map({ data in
   data.transform()
})
.subscribe(onNext: { transformed in
//Do something with data
})
</code></pre>

<p>This is not and actual example so don't get caught up on semantics.</p>
","1366083","","","","","2018-05-02 10:31:44","Combine flatMap/Scan to carry intermediate result","<swift><functional-programming><rx-swift><reactive><moya>","1","0","","","","CC BY-SA 4.0"
"50132850","1","","","2018-05-02 10:51:01","","1","1497","<p>I know state is the enemy of Reactive programming but I'm dealing with it in my process of learning RxSwift.</p>
<p>My app is very simple, the first screen is a list and a search of books and the second a detail of the book in which you can <strong>add/remove</strong> a book to your shelf and mark it as <strong>read/unread</strong>.</p>
<p>To show the detail of the book I create a <code>BookViewModel</code> passing a <code>BooksService</code> to perform network operations and the current <code>Book</code> to show.</p>
<p>The problem is that I have to keep track of the changes in the book in order to change the UI: for example, after removing the book the button that previously says &quot;Remove&quot; now it has to say &quot;Add&quot;.</p>
<p>I achieve this behavior using a <code>Variable&lt;Book&gt;</code> exposed to the observers as a <code>Driver&lt;Book&gt;</code>, but I'm messing a lot with it when the network operation returns and I have to update the value of the <code>Variable&lt;Book&gt;</code> in order to trigger the update of the UI.</p>
<p>This is the initializer of the view model:</p>
<pre><code>init(book: Book, booksService: BooksService) {
    self._book = Variable(book)
    self.booksService = booksService
}
</code></pre>
<p>This is the observable I expose</p>
<pre><code>var book: Driver&lt;Book&gt; {
    return _book.asDriver()
}
</code></pre>
<p>And here it is my function to add/remove the book:</p>
<pre><code>func set(toggleInShelfTrigger: Observable&lt;Void&gt;) {
    toggleInShelfTrigger // An observable from a UIBarButtonItem tap
        .map({ self._book.value }) // I have to map the variable's value to the actual book
        .flatMap({ [booksService] book -&gt; Observable&lt;Book&gt; in
            return (book.isInShelf ?
                    booksService.delete(book: book) :
                    booksService.add(book: book))
        }) // Here I have to know if the books is in the shelf or not in order to perform one operation or another.
        .subscribe(onNext: { self._book.value = $0 }) // I have to update the variable's value in order to trigger the UI update
        .disposed(by: disposeBag)
}
</code></pre>
<p>I am very unhappy with this code and the whole view model. It works but it is clunky, and essentially wrong because if the network operation fails the subscription will be disposed and my button will became unresponsive.</p>
<p>If I get rid of the <code>Variable&lt;Book&gt;</code> and return a <code>Driver&lt;Book&gt;</code> from the method <code>set(toggleInShelfTrigger: Observable&lt;Void&gt;)</code> I won't have this mess but I will not be able to know if I have to add or to remove the book.</p>
<p>So, what is the <strong>real world</strong> way to keep track of the state of an object in this kind of app? How can I achieve this by only using Rx operators?</p>
<h1>EDIT</h1>
<p>I've managed to clean that crappy code but I'm still trying to achieve state without <code>Variable</code> and using <code>scan</code> operator.</p>
<p>This is my new <code>BookViewModel</code> initializer:</p>
<pre><code>init(book: Book, booksService: BooksService) {
    self.bookVariable = Variable(book)
    
    let addResult = addBook
        .mapBookFrom(bookVariable)
        .flatMapLatest({ booksService.add(book: $0) })
        .updateBookVariable(bookVariable)

    let removeResult = ... // Similar to addResult, changing service call
    let markReadResult = ... // Similar to addResult, changing service call
    let markUnreadResult = ... // Similar to addResult, changing service call
    
    self.book = Observable.of(addResult, removeResult, markReadResult, markUnreadResult).merge()
        .startWith(.success(book))
}
</code></pre>
<p>I made a couple of custom operators to help me manage the <code>Variable&lt;Book&gt;</code>, one to get the real <code>Book</code>:</p>
<pre><code>private extension ObservableType where E == Void {
    func mapBookFrom(_ variable: Variable&lt;Book&gt;) -&gt; Observable&lt;Book&gt; {
        return map({ _ in return variable.value })
    }
}
</code></pre>
<p>And another to update the <code>Variable</code> after the service returns:</p>
<pre><code>private extension ObservableType where E == BookResult&lt;Book&gt; {
    func updateBookVariable(_ variable: Variable&lt;Book&gt;) -&gt; Observable&lt;BookResult&lt;Book&gt;&gt; {
        return self.do(onNext: { result in
            if case let .success(book) = result {
                variable.value = book
            }
        })
    }
}
</code></pre>
<p>Now I have a very clean view model, but not &quot;perfect&quot;.</p>
","191059","","-1","","2020-06-20 09:12:55","2018-05-16 11:58:58","RxSwift, use .scan to keep track of the state of an object","<ios><mvvm><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"50163947","1","50184425","","2018-05-03 21:14:44","","2","809","<p>I have an Observable that emits a sequence of Equatable elements.
The stream may contain consecutive sequences of equal elements (for instance in the sequence [1, 1, 1, 18, 2, 2, 0, -1] element 1 is repeated 3 times, 2 is repeated 2 times).
I need to compress the sequence substituting for every distinct element a tuple containing the element and the number of repetitions that were present in the original stream:</p>

<pre><code>1, 1, 1, 18, 21, 21, 0, -1, -8, -8, 14, 14, 14...

(1, 3), (18, 1), (21, 2), (0, 1), (-1, 1), (-8, 2), (14, 3)...
</code></pre>

<p>I managed to count repetitions with the <code>scan</code> operator, but it emits all the partial computations that shouldn't be part of the final sequence:</p>

<pre class=""lang-swift prettyprint-override""><code>let numbers = Observable&lt;Int&gt;.from([
    0, 0,
    3, 3, 3, 3, 3,
    2,
    0, 0, 0,
    6, 6,
    ])

let reps = numbers
    .scan((0, 0), accumulator: {
        (prev: (Int, Int), new: (Int)) in
        if prev.0 == new {
            return (new, prev.1 + 1)
        } else {
            return (new, 1)
        }
    })

reps.subscribe(onNext: {
        print(""\($0)"")
    })

// expected:
// (0, 2), (3, 5), (2, 1), (0, 3), (6, 2)
//
// result:
// (0, 1), (0, 2),
// (3, 1), (3, 2), (3, 3), (3, 4), (3, 5),
// (2, 1),
// (0, 1), (0, 2), (0, 3),
// (6, 1), (6, 2)
</code></pre>
","1194774","","1194774","","2018-05-03 22:21:15","2018-05-04 23:56:32","RxSwift, count how many equal consecutive Equatable items are emitted","<swift><rx-swift>","2","4","1","","","CC BY-SA 4.0"
"50174591","1","50175064","","2018-05-04 12:07:46","","0","461","<p>I'm learn to use RxSwift and RxDataSource to separate business logic from View Controller (using MVVM).</p>

<p>Suppose I want to create table view like in the Mail App in iOS, when user swipe left, there are <strong>delete button</strong> and <strong>More button</strong>.</p>

<p>In the normal MVC, I have to implement delegate method <code>editActionsForRowAt</code>.</p>

<p><code>public func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -&gt; [UITableViewRowAction]?</code></p>

<pre><code>        var swipeActions = [UITableViewRowAction]()
        let removeAction = UITableViewRowAction(style: .destructive, title: ""Delete"") { [weak self] (action, indexPath) in
            guard let strongSelf = self else { return }
            strongSelf.deleteBankAccountTrigger.onNext(indexPath)
            tableView.deleteRows(at: [indexPath], with: .fade)
        }
        swipeActions.append(removeAction)

        if *cellIsNotDefault* {
            let makeDefaultAction = UITableViewRowAction(style: .default, title: ""Make Default"") { [weak self] (action, indexPath) in
                guard let strongSelf = self else { return }
                strongSelf.makeBankAccountDefaultTrigger.onNext(indexPath)
            }

            makeDefaultAction.backgroundColor = UIColor.lightGray
            swipeActions.append(makeDefaultAction)
        }

        return swipeActions
</code></pre>

<p>I don't know how to move logic <strong>cellIsNotDefault</strong> from the delegate to ViewModel. Because I think the logic to show/hide <code>SwipeAction</code> button should be in ViewModel.</p>

<p>Any suggestion is welcome.</p>

<p>Thank you.</p>

<p>Update:</p>

<p>I tried to use RxDataSources, but still no clue for custom swipe action. For delete action, I can use <code>tableView.rx.itemDeleted</code> method to subscribe to it. But if I want to subscribe to the custom Swipe action (like my Make Default action). How to do that?</p>
","2601764","","1113632","","2018-05-18 12:25:10","2018-05-18 12:25:10","How to move logic to show UITableViewRowAction from delegate method to View Model (MVVM Architecture)","<ios><swift><mvvm><rx-swift><rxdatasources>","1","0","","","","CC BY-SA 4.0"
"50199020","1","","","2018-05-06 11:12:02","","2","1175","<p>I am using DispatchGroup to download data from 3 different APIs, once this is done I want to return the new created consolidated object from my function. Now Although DispatchGroup is working fine and I am getting data but I am not able to return it to calling function. Following is my function:</p>

<pre><code>func getHowToInfo(materialNo: String) -&gt; Observable&lt;HowToInfo&gt; {
    return Observable.create{ observer in
        let dispatchGroup = DispatchGroup()

        _ = self.getMaterialInfo(materialNo: materialNo).subscribe(onNext:{ material in

            let howto = HowToInfo(videos: [], documents: [], applications: [])

            if (material.documentTargetId?.count)! &gt; 0 {
                dispatchGroup.enter()
                _ = self.materialRepo?.API1(targetIDs: material.documentTargetId!).subscribe(onNext:{documents in
                    howto.documents = documents
                    dispatchGroup.leave()
                }, onError: { (error) in
                    dispatchGroup.leave()
                })
            }
            if (material.applicationDescription?.count)! &gt; 0 {
                dispatchGroup.enter()
                _ = self.materialRepo?.API2(materialNo: materialNo).subscribe(onNext:{applications in
                    howto.applications = applications
                    dispatchGroup.leave()
                }, onError: { (error) in
                    dispatchGroup.leave()
                })
            }
            if ((material.videoApplicationTargetId?.count) != nil &amp;&amp; (material.videoApplicationTargetId?.count)! &gt; 0) {
                dispatchGroup.enter()
                _ = self.materialRepo?.API3(targetIDs: material.videoApplicationTargetId!).subscribe(onNext:{videos in
                    howto.videos = videos
                    dispatchGroup.leave()
                }, onError: { (error) in
                    dispatchGroup.leave()
                })
            }else if ((material.videoSupportTargetId?.count) != nil &amp;&amp; (material.videoSupportTargetId?.count)! &gt; 0) {
                dispatchGroup.enter()
                _ = self.materialRepo?.API4(targetIDs: material.videoSupportTargetId!).subscribe(onNext:{videos in
                    howto.videos = videos
                    dispatchGroup.leave()
                }, onError: { (error) in
                    dispatchGroup.leave()
                })
            }

            dispatchGroup.notify(queue: .main, execute: {
                print(""All functions complete 👍"")
                observer.onNext(howto)
                observer.onCompleted()
            })
        })
        return Disposables.create()
    }
}
</code></pre>

<p>calling function:</p>

<pre><code>func loadHowToUseList(materialNo: String){
    self.serviceMaterial.getHowToInfo(materialNo: materialNo).subscribe({
        howToUse in
        print(howToUse)
    }).disposed(by: DisposeBag())
}
</code></pre>

<p>I am not able to get my object in subscribe method above, it never runs.</p>
","9692737","","","","","2018-05-10 19:21:55","Return object after DispatchGroup with RxSwift","<iphone><swift><grand-central-dispatch><rx-swift><dispatch-queue>","2","0","","","","CC BY-SA 4.0"
"50203876","1","","","2018-05-06 19:48:57","","2","734","<p>I have an array of A objects. I would like to transform it into an array with objects of type B. But the tricky part is to download images in the meantime and do everything using RxSwift or ReactiveSwift. Do you have any tips how could I do it?</p>

<pre><code>struct A {
  let name: String
  let imageURL: URL
  let thumbnailURL: URL
}

struct B {
  let name: String
  let image: UIImage?
  let thumbnail: UIImage?
}
</code></pre>
","770103","","770103","","2018-05-07 07:04:40","2018-05-11 15:33:31","Transform objects with imageURL into objects with downloaded UIImage using reactive programming","<ios><swift><reactive-programming><rx-swift><reactive-swift>","2","1","","","","CC BY-SA 4.0"
"50217376","1","50218581","","2018-05-07 15:11:09","","1","1732","<p>I'm trying to test a very simple view model:</p>

<pre><code>struct SearchViewModelImpl: SearchViewModel {
    let query = PublishSubject&lt;String&gt;()
    let results: Observable&lt;BookResult&lt;[Book]&gt;&gt;

    init(searchService: SearchService) {
        results = query
            .distinctUntilChanged()
            .throttle(0.5, scheduler: MainScheduler.instance)
            .filter({ !$0.isEmpty })
            .flatMapLatest({ searchService.search(query: $0) })
    }
}
</code></pre>

<p>I'm trying to test receiving an error from service so I doubled it this way:</p>

<pre><code>class SearchServiceStub: SearchService {
    let erroring: Bool

    init(erroring: Bool) {
        self.erroring = erroring
    }

    func search(query: String) -&gt; Observable&lt;BookResult&lt;[Book]&gt;&gt; {
        if erroring {
            return .just(BookResult.error(SearchError.downloadError, cached: nil))
        } else {
            return books.map(BookResult.success) // Returns dummy books
        }
    }
}
</code></pre>

<p>I'm testing a query that errors this way:</p>

<pre><code>func test_when_searchBooksErrored_then_nextEventWithError() {
    let sut = SearchViewModelImpl(searchService: SearchServiceStub(erroring: true))
    let observer = scheduler.createObserver(BookResult&lt;[Book]&gt;.self)

    scheduler
        .createHotObservable([
            Recorded.next(200, (""Rx"")),
            Recorded.next(800, (""RxSwift""))
        ])
        .bind(to: sut.query)
        .disposed(by: disposeBag)

    sut.results
        .subscribe(observer)
        .disposed(by: disposeBag)

    scheduler.start()

    XCTAssertEqual(observer.events.count, 2)
}
</code></pre>

<p>To begin I'm just asserting if the count of events is correct but I'am only receiving one not two. I thought it was a matter of asynchronicity so I changed the test to use RxBlocking:</p>

<pre><code>func test_when_searchBooksErrored_then_nextEventWithError() {
    let sut = SearchViewModelImpl(searchService: SearchServiceStub(erroring: true))
    let observer = scheduler.createObserver(BookResult&lt;[Book]&gt;.self)

    scheduler
        .createHotObservable([
            Recorded.next(200, (""Rx"")),
            Recorded.next(800, (""RxSwift""))
        ])
        .bind(to: sut.query)
        .disposed(by: disposeBag)

    sut.results.debug()
        .subscribe(observer)
        .disposed(by: disposeBag)

    let events = try! sut.results.take(2).toBlocking().toArray()

    scheduler.start()

    XCTAssertEqual(events.count, 2)
}
</code></pre>

<p>But this never ends.</p>

<p>I don't know if there is something wrong with my stub, or maybe with the viewmodel, but the production app works correctly, emitting the events as the query fires.</p>

<p>Documentation of RxTest and RxBlocking is very very short, with the classic examples with a string or an integer, but nothing related with this kind of flow... it is very frustrating.</p>
","191059","","","","","2018-05-07 16:22:24","RxSwift, tests with RxBlocking do not end","<ios><swift><rx-swift><rx-blocking>","1","3","","","","CC BY-SA 4.0"
"50222394","1","","","2018-05-07 21:03:42","","0","2414","<p>I have a tableView bound to instance <code>var myStrings: BehaviorRelay&lt;[String]&gt;</code>, such that the label of each cell in the tableView is set to the value of each string in myStrings: </p>

<pre><code>myStrings.bind(to: tableView.rx.items(cellIdentifier: cellReuseId, cellType: MyTableCell.self)) { row, str, cell in
            cell.textLabel?.text = str
        }.disposed(by: disposeBag)
</code></pre>

<p>I'm subscribed to item selection on the tableView.</p>

<pre><code>tableView.rx.itemSelected.subscribe(onNext: { indexPath in
            let currentStr: String = try! self.tableView.rx.model(at: indexPath)
            self.delegate?.use(currentStr)
        }).disposed(by: disposeBag)
</code></pre>

<p>How would I go about testing the closure I have on my subscription to itemsSelected in a unit test?</p>
","1574966","","","","","2020-04-25 22:22:30","Testing UITableView.rx.itemSelected callback in RxSwift","<ios><swift><rx-swift><reactivex><rx-cocoa>","1","1","","","","CC BY-SA 4.0"
"50232330","1","50279182","","2018-05-08 11:18:30","","0","973","<p>I have multiple textFields the criteria for their validation is very straight forward. </p>

<p>For sake of simplifying problem statement, lets assume the criteria are</p>

<blockquote>
  <p>First name should have at least one character,<br>
    Last name should have at least one character <br/>
    and  Age should be greater than 0</p>
</blockquote>

<p>Assume I have a validator action as</p>

<pre><code>   validatorAction = Action&lt;Void,Bool&gt; {
        return Single&lt;Bool&gt;.create(subscribe: { (single) -&gt; Disposable in
            if self.firstName.text?.count ?? 0 &gt; 0 &amp;&amp; self.lastName.text?.count ?? 0 &gt; 0 &amp;&amp; self.age.text?.count ?? 0 &gt; 0 {
                single(.success(true))
            }
            else {
                single(.success(false))
            }
            return Disposables.create()
        })
   }
</code></pre>

<p>I want this action to be executed every time character in any of the textfield changes, so I bind this action to <code>UIControlEvents.editingChanged</code></p>

<pre><code>    self.firstName.rx.bind(to: validatorAction, controlEvent: self.firstName.rx.controlEvent(UIControlEvents.editingChanged)){ (textField) -&gt; Void in
        return Void()
    }

    self.lastName.rx.bind(to: validatorAction, controlEvent: self.lastName.rx.controlEvent(UIControlEvents.editingChanged)){ (textField) -&gt; Void in
        return Void()
    }

    self.age.rx.bind(to: validatorAction, controlEvent: self.age.rx.controlEvent(UIControlEvents.editingChanged)) { (textField) -&gt; Void in
        return Void()
    }
</code></pre>

<p>Finally, I want the action to control the enable and disable state of my button</p>

<pre><code>        validatorAction.elements
        .asObservable()
        .startWith(false)
        .asDriver(onErrorJustReturn: false)
        .drive(self.submitButton.rx.isEnabled)
        .disposed(by: self.disposeBag)
</code></pre>

<p>Unfortunately though code works absolutely fine, every time the <code>validatorAction</code> is executed, textField looses its focus. That causes a huge user experience problem.</p>

<p>I raised a <a href=""https://github.com/RxSwiftCommunity/Action/issues/143"" rel=""nofollow noreferrer"">issue</a> to RxAction repo and got the response</p>

<blockquote>
  <p>Hi there! It sounds like you're slightly misusing the closure that's
  passed into the Action initializer. You'll want to try using the full
  initializer Action(enabledIf:, workFactory:) to separate out one
  closure to enable/disable the action, and another closure to return an
  observable of whatever work you want done. You can then bind the
  action to the button and it will handle enabling/disabling it for you.
  Check out the readme for more information and let us know how it goes.</p>
</blockquote>

<p>But did not get much out of it about how to use it. Can somebody show concrete code with how to use Actions to achieve the intended behavior. </p>
","5706328","","","","","2018-05-10 18:19:08","How to create `RxAction` to enable/disable button if text in `UITextField` is valid?","<swift><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"50240091","1","","","2018-05-08 18:27:38","","0","414","<p>I am trying to develop a generic API fetch method but I am getting above compilation error. After several hours of trying I am still not able to fix it.</p>

<p><strong>Type Alias</strong></p>

<pre><code>typealias RealmResponse&lt;T&gt; = (Int, Results&lt;T&gt;?, ErrorResponse?) where T:Object, T:Mappable
</code></pre>

<p><strong>Class Declaration</strong></p>

<pre><code>class Profile:Object, Mappable{
}
</code></pre>

<p><strong>API Fetch Method</strong></p>

<pre><code>@discardableResult
func requestRealmObject&lt;T&gt;(endPoint:String,
                           disposeBag:DisposeBag,
                           method:HTTPMethod = .get,
                           query:[String:Any] = [:],
                           params:[String:Any] = [:]) -&gt; Observable&lt;RealmResponse&lt;T&gt;&gt; where T:Object, T:Mappable{

    let realmResponse:Observable&lt;ObjectResponse&lt;T&gt;&gt; = APIManager.requestObject(endpoint: endPoint,
                                                                               method: method,
                                                                               query: query,
                                                                               params: params)
        .shareReplay(1)

    realmResponse
        .filter{ 200..&lt;300 ~= $0.0 }
        .map{ response:ObjectResponse&lt;Profile&gt; -&gt; [Profile] in
            if let profile = response.1{
                return [profile]
            }
            return []
        }
        .subscribe(APIManager.shared.realm.rx.add(update: true, onError: nil))
        .disposed(by: disposeBag)

    let realmObjects = APIManager.shared.realm.objects(T.self)
    return Observable.zip(realmResponse, Observable.collection(from: realmObjects)){ (response, results) in
        return (response.0, results, response.2)
    }
}
</code></pre>

<p><strong>Usage</strong></p>

<pre><code>let profileObserver:Observable&lt;RealmResponse&lt;Profile&gt;&gt; = requestRealmObject(endpoint: APIManager.userProfileEndPoint,
                            disposeBag:disposeBag,
                            method: .post,
                            query:[:],
                            params:[""username"":loggedInUser.value])
        .shareReplay(1)
</code></pre>

<p>Any help in this regard would be highly appreciated.</p>
","841614","","907186","","2018-05-16 23:29:05","2018-05-16 23:29:05","Swift Generics - Generic parameter 'T' could not be inferred","<swift><generics><realm><rx-swift><objectmapper>","0","3","","","","CC BY-SA 4.0"
"50318186","1","","","2018-05-13 16:21:24","","1","1327","<p>I am using RxSwift</p>

<pre><code>pod 'RxSwift',    '~&gt; 4.0'
pod 'RxCocoa',    '~&gt; 4.0'
</code></pre>

<p>I saw examples of username, password validation, as it works like</p>

<pre><code> func validateUsername(_ username: String) -&gt; Observable&lt;ValidationResult&gt; {
        if username.isEmpty {
            return .just(.empty)
        }


        // this obviously won't be
        if username.rangeOfCharacter(from: CharacterSet.alphanumerics.inverted) != nil {
            return .just(.failed(message: ""Username can only contain numbers or digits""))
        }

        // this obviously won't be
        if username.rangeOfCharacter(from: CharacterSet.alphanumerics.inverted) != nil {
            return .just(.failed(message: ""Username can only contain numbers or digits""))
        }

        let loadingValue = ValidationResult.validating

        return API
            .usernameAvailable(username)
            .map { available in
                if available {
                    return .ok(message: ""Username available"")
                }
                else {
                    return .failed(message: ""Username already taken"")
                }
            }
            .startWith(loadingValue)
    }
</code></pre>

<p>Now, I need to make validator for Email, I didn't find anything in examples how to do it?</p>

<p>I used to use Validator
<a href=""https://github.com/SwiftValidatorCommunity/SwiftValidator"" rel=""nofollow noreferrer"">https://github.com/SwiftValidatorCommunity/SwiftValidator</a></p>

<p>validator.registerField(emailTextField, errorLabel: emailErrorLabel, rules: [RequiredRule(), EmailRule(message: ""Invalid email"")])</p>

<p>But in Rx, I am totally confused to how to fix it?</p>

<p>Thanks. </p>
","3649855","","1113632","","2018-05-18 13:22:17","2019-01-23 23:12:38","Email Validator RxSwift?","<swift><validation><email-validation><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"50321149","1","","","2018-05-13 22:29:53","","2","6330","<p>I am trying to build an new iOS app and am using the RxSwift Library and Realm as database. </p>

<p>I build a tableview which shows a list of object from realm and these object should be editable and can be removed. (I don't use the tableview editing capabilities for this.)</p>

<p>Now when I remove an item from the table the table should refresh because i used RxSwift to bind the tableview to the Realm results. But instead of updating it crashes the app. </p>

<p>The error I get when the app crashes is <code>'RLMException', reason: 'Object has been deleted or invalidated.'</code>
Also I get a stack trace in the output, but I can't find the source / reason why the crash happens.</p>

<p>Output stacktrace:</p>

<pre><code>2018-05-14 00:09:34.660634+0200 RealmTest[65540:4239839] *** Terminating app due to uncaught exception 'RLMException', reason: 'Object has been deleted or invalidated.'
*** First throw call stack:
(
    0   CoreFoundation                      0x000000010f76e1e6 __exceptionPreprocess + 294
    1   libobjc.A.dylib                     0x000000010ee03031 objc_exception_throw + 48
    2   Realm                               0x000000010d44abd3 _ZL17RLMVerifyAttachedP13RLMObjectBase + 83
    3   Realm                               0x000000010d44c89c _ZN12_GLOBAL__N_18getBoxedIN5realm10StringDataEEEP11objc_objectP13RLMObjectBasem + 28
    4   Realm                               0x000000010d44c877 ___ZN12_GLOBAL__N_115makeBoxedGetterIN5realm10StringDataEEEP11objc_objectm_block_invoke + 39
    5   RealmTest                           0x000000010cf9c6a9 _T09RealmTest0B9ModelItemV8identitySSvg + 41
    6   RealmTest                           0x000000010cf9c6f5 _T09RealmTest0B9ModelItemV14Differentiator16IdentifiableTypeAadEP8identity8IdentityQzvgTW + 21
    7   Differentiator                      0x000000010d29f24e _T014Differentiator4DiffO23calculateAssociatedData33_D199D3FBF4B7CA3AFA95223EE09B4772LLs15ContiguousArrayVyAGyAC04ItemdE0AELLVGG_AKtAGyAGyxGG07initialP5Cache_AM05finalpR0tKAA16IdentifiableTypeRzlFZ + 2094
    8   Differentiator                      0x000000010d2ac30e _T014Differentiator4DiffO16CommandGenerator33_D199D3FBF4B7CA3AFA95223EE09B4772LLV22calculateItemMovementss15ContiguousArrayVyAIyAC0N14AssociatedDataAELLVGG_AMtAIyAIy0N0QzGG07initialN5Cache_AQ05finalnU0AIyAC07SectionrS0AELLVG0twS0AV0vwS0tKFZ + 334
    9   Differentiator                      0x000000010d2a1d65 _T014Differentiator4DiffO16CommandGenerator33_D199D3FBF4B7CA3AFA95223EE09B4772LLV27generatorForInitialSectionsAFy_xGSayxG_AI05finalP0tKFZ + 1253
    10  Differentiator                      0x000000010d2a1395 _T014Differentiator4DiffO27differencesForSectionedViewSayAA9ChangesetVyxGGSayxG15initialSections_AI05finalI0tKAA26AnimatableSectionModelTypeRzlFZ + 277
    11  RxDataSources                       0x000000010e35ede4 _T013RxDataSources0a26TableViewSectionedAnimatedB6SourceC05tableE0ySo07UITableE0C_0A5Swift5EventOySayxGG08observedL0tFyACyxG_AJtcfU_yycfU_ + 660
    12  RxDataSources                       0x000000010e360049 _T013RxDataSources0a26TableViewSectionedAnimatedB6SourceC05tableE0ySo07UITableE0C_0A5Swift5EventOySayxGG08observedL0tFyACyxG_AJtcfU_yycfU_TA + 25
    13  RxDataSources                       0x000000010e35f63d _T0Ieg_IeyB_TR + 45
    14  libdispatch.dylib                   0x0000000113b5b807 _dispatch_call_block_and_release + 12
    15  libdispatch.dylib                   0x0000000113b5c848 _dispatch_client_callout + 8
    16  libdispatch.dylib                   0x0000000113b6792b _dispatch_main_queue_callback_4CF + 628
    17  CoreFoundation                      0x000000010f730c99 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 9
    18  CoreFoundation                      0x000000010f6f4ea6 __CFRunLoopRun + 2342
    19  CoreFoundation                      0x000000010f6f430b CFRunLoopRunSpecific + 635
    20  GraphicsServices                    0x0000000117bb5a73 GSEventRunModal + 62
    21  UIKit                               0x000000010fbeb0b7 UIApplicationMain + 159
    22  RealmTest                           0x000000010cf9a0a7 main + 55
    23  libdyld.dylib                       0x0000000113bd9955 start + 1
    24  ???                                 0x0000000000000001 0x0 + 1
)
</code></pre>

<p>My question is if somebody knows what I do wrong and wat the correct way of removing an realm object is using RxSwift and Databinding?</p>

<p>Edit:</p>

<p>I Made a small test project and put it on my github, it errors when you tab the deleteFirst button. <a href=""https://github.com/Hiiragisan09/ios-example-project-realm-test"" rel=""nofollow noreferrer"">https://github.com/Hiiragisan09/ios-example-project-realm-test</a></p>

<p><a href=""https://i.stack.imgur.com/Neklk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Neklk.png"" alt=""Screenshot of the app crash""></a></p>
","2397741","","2397741","","2018-05-14 08:21:04","2021-07-21 00:47:05","Realm, Object has been deleted or invalidated","<ios><swift><realm><rx-swift>","2","6","1","","","CC BY-SA 4.0"
"50336115","1","","","2018-05-14 17:42:34","","2","380","<p><strong>Question</strong></p>

<p>What's the best equivalent of <code>Variable</code> (deprecated already) or <code>BehaviorRelay</code> from RxSwift for RxJava?</p>

<p><strong>Addition</strong></p>

<p>In this case I assume that I could use <code>BehaviorSubject</code> which is built-in object in RxJava, but is it behaving identically to the objects mentioned above?</p>

<p>I also know that there is external library RxRelay, but is this the only option?</p>
","4386668","","","","","2018-05-14 19:05:39","Built-in equivalent of RxSwift Variable or BehaviorRelay for RxJava","<android><rx-java><rx-java2><rx-swift>","1","0","","","","CC BY-SA 4.0"
"50382711","1","","","2018-05-17 02:59:10","","0","1488","<p>I am new to RxSwift and here I would like to ask a question about where should the DisposeBag be.</p>

<p>My case is, I have retrieve a list of items being displayed in a tableview, and each of them will have its own flag to indicate if it is selected.</p>

<p>So I am not just binding the result list to the tableview. I need to have some logic which editing the list on local while user navigate via the tableview.</p>

<p>I have created an instance <code>Variable([Item])</code> in the <code>ViewModel</code> but if I place the logic in the <code>ViewModel</code> a <code>DisposeBag</code> is needed.</p>

<p>After having some googling, most of the examples of MVVM+RxSwift which have instances of <code>Variable</code> place the <code>DisposeBag</code> in <code>ViewModel</code> but some say it should only be placed in <code>ViewController</code>. Is that true? How can I listen the <code>Observable</code> in <code>ViewModel</code> so that my business logic can be placed in <code>ViewModel</code>?</p>
","1751724","","","","","2018-05-29 16:34:22","On iOS, for the DisposeBag in MVVM, can it be placed in ViewModel?","<ios><swift><mvvm><rx-swift>","3","0","","","","CC BY-SA 4.0"
"50389700","1","","","2018-05-17 10:55:16","","0","944","<p>I have a Singleton class (actually it's going to do web-scraping, but simplified here) with some public available functions. The functions all return a <code>Single&lt;T&gt;</code> but of different types.</p>

<p>It could look like this:</p>

<pre><code>class Singleton {
    static let shared = Singleton()
    private init() { }

    func doSomethingInt() -&gt; Single&lt;Int&gt; {
        return Single.just(1)
            .delay(3, scheduler: MainScheduler.instance)
    }

    func doSomethingString() -&gt; Single&lt;String&gt; {
        return Single.just(""Wow"")
            .delay(3, scheduler: MainScheduler.instance)
    }
}
</code></pre>

<p>When someone calls <code>Singleton.shared.doSomthingInt()</code>, the function should be placed on a queue, not executing until it's passed through the queue. The next observable in the queue should not start executing before everything before it has completed. Ideally <code>Singleton</code> would have a function which would delay the execution of every functions that is passed onto it. Something like this:</p>

<pre><code>private func placeInQueue&lt;T: Any&gt;(operation: Single&lt;T&gt;) -&gt; Single&lt;T&gt; {
    // place in some magic shared queue
    return operation
}
</code></pre>

<p>And then I could just chain this function in the beginning of the functions that should be placed in the queue, like this:</p>

<pre><code>func doSomethingString() -&gt; Single&lt;String&gt; {
    let operation = Single.just(""Wow"")
        .delay(3, scheduler: MainScheduler.instance)
    return placeInQueue(operation)
}
</code></pre>

<p>I feel like this should be possible with a <code>concat</code> operation somehow, but I havn't been able to solve it yet. </p>

<p><strong>Any clues?</strong></p>
","2299801","","","","","2018-05-17 14:44:05","RxSwift - Queue observables of different type from Singleton","<swift><queue><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"50391137","1","","","2018-05-17 12:09:32","","0","1159","<p>I want to map a dict 
and flatMap to return a new Observable.
I am trying Observable as I might either 1 single object or an array of object. </p>

<pre><code>func fetchRibsList() -&gt; Observable&lt;[LCLRibAccount]&gt;  {
        return provider.rxDict(service: .fetchRibsList)
            .map({ (dict, _) -&gt; [String: Any] in
                return dict
            })
            .filter({ dict -&gt; Bool in
                dict[""ribs""] != nil
            })
            .filter({ dict -&gt; Bool in
                dict[""rib""] != nil
            })
            .flatMap({ dict -&gt; Observable&lt;Any&gt; in

                //return either list of ribs or 1 single rib
                if let ribs = dict[""ribs""] as? [String: Any] {
                    return Observable.just(LCLRib.parseAccountList(with: ribs))
                }

                if let rib = dict[""rib""] as? [String: Any] {
                    return Observable.just(LCLRib.parseRib(with: rib))
                }

                return Observable.empty()
            })
    }
</code></pre>

<p>is it possible to include a condition with 2 flatMap and return an array or 1 single object
the issue is that I need to be specific with the Observable type:</p>

<p>this is the error I get : <strong>Cannot convert return expression of type 'Observable' to return type 'Observable&lt;[LCLRibAccount]>'</strong></p>

<p><a href=""https://i.stack.imgur.com/sv7WZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/sv7WZ.png"" alt=""enter image description here""></a></p>
","","user4422315","","","","2018-05-17 18:01:26","filter condition with rx Swift","<swift><filter><rx-swift>","1","0","","","","CC BY-SA 4.0"
"50392283","1","50392955","","2018-05-17 13:08:01","","0","48","<p>I writing async unit tests for RxSwift,this my code,I can't understand subscribe only once  </p>

<pre><code>class TestViewModel: NSObject {
    let result : Observable&lt;Int&gt;

     init(input:Observable&lt;Int&gt;) {
        result = input.flatMapLatest({ (value) -&gt; Observable&lt;Int&gt; in

            return Observable.create({ (observer) -&gt; Disposable in

                DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 1, execute: {
                print(""next""+""  \(value)"")
                    observer.onNext(value)
                })

                return Disposables.create()
            })
        })
    }

}

    func testCount() {
        let expectation = XCTestExpectation(description: ""async"")
        let input = scheduler.createHotObservable([.next(100, 1),.next(200, 10)])
        let viewModel = TestViewModel.init(input: input.asObservable())
        viewModel.result.subscribe(onNext: { (value) in
            print(""subscribe""+""   \(value)"")
        }).disposed(by: disposeBag)
        scheduler.start()
        wait(for: [expectation], timeout: timeout)
    }  
</code></pre>

<p>print info:</p>

<pre><code>next  1
next  10
subscribe   10  
</code></pre>

<p>I think print info should :  </p>

<pre><code>next  1
next  10
subscribe   1  
subscribe   10    
</code></pre>

<p>Someone can give me suggestion？thank</p>
","6202715","","","","","2018-05-17 13:40:24","Observable subscribe alway once issue","<swift><rx-swift><rx-cocoa>","1","2","","","","CC BY-SA 4.0"
"50400864","1","","","2018-05-17 21:38:20","","0","760","<p>This is just a sample.</p>

<p>But I can understand such behavior. Why in the first place a variable is not an optional but in the last is an optional.</p>

<pre><code>let tapEvent: ControlEvent&lt;UITapGestureRecognizer&gt; = chargingView.rx.tapGesture()
            tapEvent.map { _ in
                return CGPoint()
                }.filter { $0 != nil }.map { $0 } // here Comparing non-optional value of type 'CGPoint' to nil always returns true
                .subscribe { point in
                    print(point.element) // Expression implicitly coerced from 'CGPoint?' to Any
                }.disposed(by: bag)
</code></pre>

<p>A screenshot to proof.</p>

<p><a href=""https://i.stack.imgur.com/Hp0Ce.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Hp0Ce.png"" alt=""enter image description here""></a></p>

<p>The same behavior for this similar code</p>

<pre><code>let tapEvent: ControlEvent&lt;UITapGestureRecognizer&gt; = chargingView.rx.tapGesture()
            tapEvent.map { _ in
                return CGPoint()
                }.flatMap { Observable.from(optional: $0) }
                .subscribe { point in
                    print(point.element)
</code></pre>

<p>I'm not familiar with rx. Thanks.</p>
","1979882","","","","","2018-05-18 06:50:43","Unexpected nil value for RxSwift map > subscribe","<swift><rx-swift>","2","1","","","","CC BY-SA 4.0"
"50405897","1","","","2018-05-18 07:21:51","","0","147","<p>Module compiled with Swift 4.0.3 cannot be imported in Swift 4.1</p>

<p><a href=""https://i.stack.imgur.com/kpcIN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kpcIN.png"" alt=""enter image description here""></a></p>
","3773103","","","","","2018-05-18 07:23:33","Cannot import module from RxSwift in Carthage dependency manager iOS","<ios><swift><rx-swift><carthage>","1","1","1","","","CC BY-SA 4.0"
"50449793","1","50456708","","2018-05-21 13:17:27","","1","834","<p>I have a <code>BehaviorSubject&lt;[Int]&gt;</code>, with the length of the array increasing one at a time. I would like to have an <code>Observable</code> that emits a <code>completed</code> event when the first element is added to the array, and I don't care about what happens afterwards. How to do that?</p>
","3808183","","","","","2018-05-21 21:14:51","RxSwift how to map to a onComplete event","<rx-swift>","1","0","1","","","CC BY-SA 4.0"
"50460554","1","51665879","","2018-05-22 05:42:02","","1","1849","<p>I'm trying to set the initial value for UIPickerView.</p>

<p>Here, an example of my code:</p>

<pre><code>@IBOutlet weak var pickerView: UIPickerView!

override func viewDidLoad() {
    super.viewDidLoad()

    Observable.just([1, 2, 3])
        .bind(to: pickerView.rx.itemTitles) { _, item in
            return ""\(item)""
        }
        .disposed(by: disposeBag)

    pickerView.rx.modelSelected(Int.self)
        .subscribe(onNext: { models in
            print(""models selected 1: \(models)"")
        })
        .disposed(by: disposeBag)
}
</code></pre>

<p>I don't know how I can make a two-way binding with my ViewModel or just set the initial value.</p>

<p>Any ideas are welcome!</p>
","6748318","","","","","2018-09-07 08:37:16","RxSwift: Set initial value for UIPickerView","<swift><rx-swift>","3","0","1","","","CC BY-SA 4.0"
"50465639","1","50465640","","2018-05-22 10:39:24","","4","1857","<p>I am trying to run the following test from <strong>Chapter 16: Testing with RxTest</strong> of <strong><a href=""https://store.raywenderlich.com/products/rxswift"" rel=""nofollow noreferrer"">Raywenderlich RxSwift</a></strong> book:</p>

<pre><code>import XCTest
import RxSwift
import RxTest
@testable import Testing

class TestingViewModel : XCTestCase {

var viewModel: ViewModel!
var scheduler: ConcurrentDispatchQueueScheduler!

override func setUp() {
super.setUp()

viewModel = ViewModel()
scheduler = ConcurrentDispatchQueueScheduler(qos: .default)
}

func testColorNameIsRayWenderlichGreenWhenHexStringIs006636() {

// 1
let colorNameObservable = viewModel.colorName.asObservable().subscribeOn(scheduler)

// 2
viewModel.hexString.value = ""#006636""

// 3
XCTAssertEqual(""rayWenderlichGreen"", try! colorNameObservable.toBlocking().first()!)
 }
}
</code></pre>

<p>But I get this error on the simulator:</p>

<blockquote>
  <p>Undefined symbols for architecture x86_64:
    ""type metadata for RxCocoa.DriverSharingStrategy"", referenced from:
        TestingTests.TestingViewModel.testColorNameIsRayWenderlichGreenWhenHexStringIs006636() -> () in TestingViewModel.o
    ""protocol witness table for RxCocoa.DriverSharingStrategy : RxCocoa.SharingStrategyProtocol in RxCocoa"", referenced from:
        TestingTests.TestingViewModel.testColorNameIsRayWenderlichGreenWhenHexStringIs006636() -> () in TestingViewModel.o
    ""RxCocoa.SharedSequence.asObservable() -> RxSwift.Observable"", referenced from:
        TestingTests.TestingViewModel.testColorNameIsRayWenderlichGreenWhenHexStringIs006636() -> () in TestingViewModel.o
  ld: symbol(s) not found for architecture x86_64
  clang: error: linker command failed with exit code 1 (use -v to see invocation)</p>
</blockquote>

<p>And This one on iPhone 6s:</p>

<blockquote>
  <p>Undefined symbols for architecture arm64:
    ""type metadata for RxCocoa.DriverSharingStrategy"", referenced from:
        TestingTests.TestingViewModel.testColorNameIsRayWenderlichGreenWhenHexStringIs006636() -> () in TestingViewModel.o
    ""protocol witness table for RxCocoa.DriverSharingStrategy : RxCocoa.SharingStrategyProtocol in RxCocoa"", referenced from:
        TestingTests.TestingViewModel.testColorNameIsRayWenderlichGreenWhenHexStringIs006636() -> () in TestingViewModel.o
    ""RxCocoa.SharedSequence.asObservable() -> RxSwift.Observable"", referenced from:
        TestingTests.TestingViewModel.testColorNameIsRayWenderlichGreenWhenHexStringIs006636() -> () in TestingViewModel.o
  ld: symbol(s) not found for architecture arm64
  clang: error: linker command failed with exit code 1 (use -v to see invocation)</p>
</blockquote>

<p><a href=""https://forums.raywenderlich.com/t/chapter-16-testing-with-rxtest/34926"" rel=""nofollow noreferrer"">Unfortunately, there is no support for this issue in Raywenderlich's forums.</a></p>
","3409515","","1000551","","2018-05-23 19:13:50","2018-05-23 19:13:50","RxTest: Undefined symbols for architecture x86_64 and arm64","<ios><swift><rx-swift><rx-cocoa><rxtest>","1","0","","","","CC BY-SA 4.0"
"50478280","1","50588856","","2018-05-23 00:40:38","","1","1227","<p>Since <a href=""https://developer.apple.com/documentation/foundation/nsnotificationcenter"" rel=""nofollow noreferrer"">NotificationCenter</a> is a part of <a href=""https://developer.apple.com/documentation/foundation"" rel=""nofollow noreferrer"">Foundation</a>. I expect it should be within RxSwift, not RxCocoa.</p>

<p>But why <a href=""https://github.com/ReactiveX/RxSwift/blob/f043778214c8f182018ccdfbf7f440edbe0aecc8/RxCocoa/Foundation/NotificationCenter%2BRx.swift"" rel=""nofollow noreferrer"">NotificationCenter+Rx</a> is in RxCocoa? Any reason behind that?</p>

<p>In some of our project, we only use RxSwift without RxCocoa. If we use <code>NotificationCenter.default.rx.notification</code>, we will get the error <code>Value of type 'Reactive&lt;NotificationCenter&gt;' has no member 'notification'</code> because NotificationCenter+Rx is in RxCocoa only.</p>
","749786","","","","","2018-05-29 16:32:33","Why `NotificationCenter+Rx` is in RxCocoa not RxSwift","<ios><rx-swift><rx-cocoa>","1","2","","","","CC BY-SA 4.0"
"50480224","1","50481641","","2018-05-23 05:08:57","","1","5242","<p>I have an UITableView and a <code>countries</code> variable whose signature is like:</p>

<pre><code>let countryArray = [""Bangladesh"", ""India"", ""Pakistan"", ""Nepal"", ""Bhutan"", ""China"", ""Malaysia"", ""Myanmar"", ""Sri Lanka"", ""Saudi Arabia""]
</code></pre>

<p>When I'm trying to bind this array of countries in a UITableView, Its showing the error <code>Generic parameter 'Self' could not be inferred</code>.</p>

<p>Here is the snippet that I am doing:</p>

<pre><code>let countries = Observable.just(countryArray)
    countries.bindTo(self.tableView.rx.items(cellIdentifier: ""myCell"",
                                        cellType: MyCell.self)) {
                                            row, country, cell in
                                            // configuring cell
    }
    .addDisposableTo(disposeBag)
</code></pre>
","3427688","","","","","2018-05-23 06:52:23","RxSwift - Generic parameter 'Self' could not be inferred","<ios><swift><generics><rx-swift>","1","0","","","","CC BY-SA 4.0"
"50500794","1","50520114","","2018-05-24 04:08:04","","0","627","<p>I'm trying to solve an async sequential problem, for example:</p>

<p>There are one 'OriginalData' in myclass, and I want to do some sequential operations to it: operationA, operationB and operationC:</p>

<p>operationA accepts OriginalData and return outputA, after it finishes, then operationB should take the outputA as input and return outputB, and move to operationC..</p>

<p>What I've done was using the callbacks:</p>

<pre><code>// pseudocode
class Myclass {
    func operationA(inputA, callback: operationB)
    func operationB(inputB, callback: operationC)
    ..
}
</code></pre>

<p>As a result, if using callbacks, it will result in a callback hell and lots trouble. I turned into RxSwift, but not sure how to use RxSwift to solve it.</p>

<p>(P.S I've already read the RxSwift's official document, but still cannot make my idea clear. Best Appreciated for your helps!)</p>
","3514137","","","","","2018-05-25 01:07:31","RxSwift: how to build up the observable function call chain other than use callback?","<swift><asynchronous><rx-swift>","1","1","0","","","CC BY-SA 4.0"
"50549838","1","","","2018-05-27 07:07:39","","2","1719","<p>I want to call a function every 4 changes in my textview.
how can I perform it with RXswift debounce throttle?
I use UITextViewDelegate to detect changes in my textview.</p>
","2637067","","2637067","","2018-05-28 06:20:36","2020-05-31 08:16:37","RxSwift on UITextview","<swift><uitextview><reactive-programming><rx-swift>","2","0","","","","CC BY-SA 4.0"
"50551309","1","50551677","","2018-05-27 10:42:52","","2","6129","<p>How do I convert an Observable of type Int to a Variable of type Int?</p>

<p>Here is what I have tried so far:</p>

<pre><code>let obs: Observable&lt;Int&gt; = Observable.of(4)

let variable: Variable&lt;Int&gt; = obs
    .flatMap { num in
        return Variable&lt;Int&gt;(num)
    }
</code></pre>

<p>Using flatMap feels like the most logical way of doing the conversion, however, I get a compiler error which essentially says that it does not like the flatMap returning anything that is not an observable. Any ideas?</p>

<p>EDIT:</p>

<p>Just to give some context as to why I need to convert the Observable into a Variable:</p>

<p>I need my viewModel to drive a UIPickerView inside a ViewController. Currently, I have two exposed properties in my ViewModel, items: Observable&lt;[String]> (which is the datasource for the UIPickerView) and selectedIndex: Variable. The selectedIndex will drive the initial value of the UIPickerView but also keep track of any changes the user makes.</p>

<p>The reason I needed to convert from the Observable to Variable was that I needed to figure out which index of the UIPickerView should be selected initially:</p>

<pre><code>items.map { days -&gt; Int in
    if let index = days.index(where: { str in
        return str == selectedDay
    }) {
        return index
    }
    return 0
}
.flatMap { num in
    return Variable&lt;Int&gt;(num)
}
</code></pre>

<p>I'm now wondering if I'm over complicating things, and if instead of the Variable in I should just have an Observable.</p>
","1625364","","1625364","","2018-05-27 11:57:07","2018-05-27 11:57:07","RxSwift: Convert Observable to a Variable","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"50558613","1","51814368","","2018-05-28 03:07:11","","9","3932","<p>I want use UITextfield with RxSwift. My goal is allowing/not input character in User keyboard and removing character from copy paste, I need handle UITextfield's delegate  ""shouldChangeCharactersInRange"" with <strong>RxSwift</strong>. </p>

<p>How to implement with <strong>RxSwift</strong>?</p>

<p>I am using RxSwift version 4.
Case 1: 
Input from keyboard: A123
Process from RxSwift : Accept 123 (not allowing NumberPad)
Output : 123</p>

<p>Case 2:
Input form Copy Paste from Contacts: \U202d1111111111\U202c
Process from RxSwift : remove all control character, accept 1111111111
Output: 1111111111</p>

<p>If in general we can use shouldChangeCharactersInRange , but how to use with RxSwift? </p>
","8460495","","4149826","","2018-08-08 12:51:13","2018-08-13 02:07:33","RxSwift replacement shouldChangeCharactersInRange","<ios><swift><rx-swift>","2","2","4","","","CC BY-SA 4.0"
"50566737","1","","","2018-05-28 12:41:04","","0","457","<p>I'm using RxSwift for binding UITableView to data source. I want to select table cell in table view. Selection does not work by tap, but works well by swipe gesture.  What could be the problem?</p>

<p>That's what I was truing to do:</p>

<ul>
<li>update RxSwift, RxCocoa</li>
<li>clean project</li>
<li>remove derived data</li>
<li>try combinations of settings of table view and table view cell</li>
</ul>

<p>Here my code </p>

<p><em>View Model</em></p>

<pre><code>import Foundation
import RxSwift

class ViewModel {

    let selectItem: AnyObserver&lt;String&gt;
    let didSelectItem: Observable&lt;String&gt;

    let items: Observable&lt;[String]&gt;

    init() {
      let _selectItem = PublishSubject&lt;String&gt;()
      self.selectItem = _selectItem.asObserver()
      self.didSelectItem = _selectItem.asObservable()
      items = TestAppData.getData()
    }
}
</code></pre>

<p><em>ViewController</em></p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class ViewController: BaseViewController {

  @IBOutlet weak var dataTableView: UITableView!

  var viewModel: ViewModel!

  override func viewDidLoad() {
    super .viewDidLoad()
    setup()
  }

  private func setup(){

    viewModel.items
      .observeOn(MainScheduler.instance)
      .bind(to: dataTableView.rx.items(cellIdentifier: ""DataCell"", cellType: UITableViewCell.self)) {
        (_, dataValue, cell) in
        cell.textLabel?.text = dataValue
        cell.selectionStyle = .none
      }
      .disposed(by: disposeBag)

    dataTableView.rx.modelSelected(String.self)
      .bind(to: viewModel.selectItem)
      .disposed(by: disposeBag)
  }
}
</code></pre>

<p>TableView and TableViewCell settings:
<a href=""https://i.stack.imgur.com/d5TK2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/d5TK2.png"" alt=""enter image description here""></a>
RxSwift 4.1.2, RxCocoa 4.1.2</p>
","4685625","","4685625","","2018-05-29 06:56:42","2018-05-29 06:56:42","UITableViewCell selected by swipe not by tap","<ios><swift><uitableview><rx-swift>","1","0","0","","","CC BY-SA 4.0"
"50584324","1","","","2018-05-29 12:22:36","","1","1366","<p>I'm struggling with specific use-case incorporating RxSwift's PublishSubject. </p>

<p>For sake of simplicity unimportant details were omitted.</p>

<p>There is a MVVM setup. In VC I have a UIButton, on tap of which a network call should dispatch. In ViewModel I have a <code>buttonDidTapSubject: PublishSubject&lt;Void&gt;</code>. </p>

<pre><code>class ViewModel {
  let disposeBag = DisposeBag()
  let buttonDidTapSubject = PublishSubject&lt;Void&gt;()
  let service: Service
  typealias Credentials = (String, String)
  var credentials: Observable&lt;Credentials&gt; {
   return Observable.just((""testEmail"", ""testPassword""))
  }
  init(_ service: Service) {
   self.service = service
   buttonDidTapSubject
    .withLatestFrom(credentials)
    .flatMap(service.login) // login method has signature func login(_ creds: Credentials) -&gt; Observable&lt;User&gt;
    .subscribe(onNext: { user in print(""Logged in \(user)"") },
               onError: { error in print(""Received error"") })
    .disposed(by: disposeBag)
  }
}

class ViewController: UIViewController {
  let viewModel: ViewModel
  let button = UIButton()
  init(_ viewModel: ViewModel) { 
    self.viewModel = viewModel
  }
}
</code></pre>

<p>In controller's <code>viewDidLoad</code> I make a binding:</p>

<pre><code>override func viewDidLoad() {
  button.rx.tap.asObservable()
    .subscribe(viewModel.buttonDidTapSubject)
    .disposed(by: disposeBag)
}
</code></pre>

<p><strong>The problem is</strong>, since network request can fail and Observable that is returned from <code>login(_:)</code> method will produce an error, the whole subscription to <code>buttonDidTapSubject</code> in ViewModel will be disposed. And all other taps on a button will not trigger sequence to login in ViewModel.</p>

<p>Is there any way to avoid this kind of behavior?</p>
","6798535","","","","","2019-09-16 18:26:32","Prevent disposal of PublishSubject (RxSwift)","<ios><swift><cocoa-touch><rx-swift>","2","1","","","","CC BY-SA 4.0"
"50643334","1","","","2018-06-01 12:22:24","","0","1500","<p>I am using RxSwift Playground from:
<a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxSwift</a></p>

<p>I implemented following example code to model a simple async task, converting an Observable of Int to an Observable of String :</p>

<pre><code>let pubishSubject = PublishSubject&lt;Int&gt;()
pubishSubject.asObservable()
    .debug(""before"")
    .flatMap ({ (value) -&gt; Observable&lt;String&gt; in
        let task: Observable&lt;String&gt; = Observable.create { observer in
            DispatchQueue.main.asyncAfter(deadline: .now() + 1, execute: {
                print(""Executed \(value)"")
                observer.on(.next(""Async \(value)""))
                observer.on(.completed)
            })
            return Disposables.create(with: {
                print(""Disposed \(value)"")
            })
        }
        return task
    })
    .debug(""after"")
    .subscribe()

pubishSubject.onNext(1)
pubishSubject.onNext(2)
pubishSubject.onNext(3)
</code></pre>

<p>Debug output:</p>

<pre><code>2018-06-01 14:08:35.748: after -&gt; subscribed
2018-06-01 14:08:35.749: before -&gt; subscribed
2018-06-01 14:08:35.751: before -&gt; Event next(1)
2018-06-01 14:08:35.753: before -&gt; Event next(2)
2018-06-01 14:08:35.753: before -&gt; Event next(3)
Executed 1
2018-06-01 14:08:36.785: after -&gt; Event next(Async 1)
Disposed 1
Executed 2
2018-06-01 14:08:36.786: after -&gt; Event next(Async 2)
Disposed 2
Executed 3
2018-06-01 14:08:36.787: after -&gt; Event next(Async 3)
Disposed 3
</code></pre>

<p>I need to complete all async tasks to proceed, which is working totally fine, but I need to subscribe to the latest result (Async 3) only.</p>

<p>I cannot use the flatMapLastest operator, because it would cancel/dispose previous async calls.</p>

<p>I have no idea how to achieve that and I feel like being totally blocked, maybe I can use a simple RxSwift operator for that or I need to split the sequence in some way.</p>

<p>I hope someone has an idea how to achieve that and can help me, thank you very much. </p>

<p>Edit: For me it looks more like a queue implementation, as long as new Int Values are published on the PublishSubject AND there are still Async Tasks running, it should skip all intermediate results and return the last result based on the last emitted Int</p>
","4260338","","4260338","","2018-06-01 14:06:11","2018-06-01 14:34:35","RxSwift flatMapLatest without disposing previous observables","<ios><swift><functional-programming><rx-java><rx-swift>","1","4","","","","CC BY-SA 4.0"
"50659174","1","","","2018-06-02 16:57:09","","3","2438","<p>I have to make several api calls (approx 100) using a for loop and on completion of this I need to complete the Observable. I am using it as following:</p>

<pre><code>func getMaterialInfo(materialNo:[String]) -&gt; Observable&lt;[String: Material]&gt;{
    return Observable.create({ (observable) -&gt; Disposable in
        for (index,mat) in materialNo.enumerated(){
            // Pass the material number one by one to get the Material object
            self.getMaterialInfo(materialNo: mat).subscribe(onNext: { material in
                var materialDict: [String: Material] = [:]
                materialDict[material.materialNumber] = material
                observable.onNext(materialDict)
                if index == (materialNo.count-1){
                    observable.onCompleted()
                }
            }, onError: { (error) in
                observable.onError(error)
            }, onCompleted: {
            }).disposed(by: self.disposeBag)
        }
        return Disposables.create()
    })
}
</code></pre>

<p>Although loop is working fine and observable.onCompleted() is called but the caller method does not receive it.
I am calling it like following:</p>

<pre><code>private func getImage(materialNo:[String]){
    if materialNo.isEmpty {
        return
    }
    var dictMaterials = [String:String]()
    materialService.getMaterialInfo(materialNo: materialNo).subscribe(onNext: { (materials) in
        for (key,value) in materials{
            if (value.imageUrl != nil){
                dictMaterials[key] = value.imageUrl
            }
        }
    }, onError: { (error) in

    }, onCompleted: {
        self.view?.updateToolImage(toolImageList: dictMaterials)
    }, onDisposed: {}).disposed(by: disposeBag)
}
</code></pre>

<p>OnCompleted block of Rx is not executing. How can I fix it?</p>
","260056","","472495","","2018-06-08 10:02:10","2019-03-05 08:28:55","Best way to call multiple API requests in a for loop in RxSwift","<ios><swift><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"50663817","1","50680888","","2018-06-03 06:24:50","","0","450","<p>Do I need to add as a pod?
I need to create a sectioned tableView with RxCocoa UI binding. I have not been able to find the right documentation to implement it.
thanks in advance</p>

<p>this is my Podfile</p>

<pre><code># Uncomment the next line to define a global platform for your project
# platform :ios, '9.0'

target 'NetworkLayer-Rx' do
  # Comment the next line if you're not using Swift and don't want to use dynamic frameworks
  use_frameworks!

  # Pods for NetworkLayer-Rx
  pod 'RxAlamofire'
  pod 'RxSwift'
  pod 'RxCocoa'

  target 'NetworkLayer-RxTests' do
    inherit! :search_paths
    # Pods for testing
  end

end
</code></pre>

<p><a href=""https://i.stack.imgur.com/udjq7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/udjq7.png"" alt=""enter image description here""></a></p>
","","user4422315","","","","2018-06-04 12:40:37","How can I get RxDataSource to work","<observable><rx-swift><rxdatasources>","1","0","","","","CC BY-SA 4.0"
"50664497","1","","","2018-06-03 08:16:43","","0","665","<p>I am trying to subscribe to an observable. What could be the reason for the error  Extra argument 'onError' in call ?
Can someone help me debug find the issue. 
<a href=""https://i.stack.imgur.com/KcYgB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KcYgB.png"" alt=""enter image description here""></a></p>

<p>in my <strong>ViewModel</strong></p>

<pre><code>func loadImages() {
            return dataController.fetchStatusCodeImages()
                .subscribe(
                   onNext: { images in
                   self.imagesDataSource.value = images
                },
                    onError: { error in
                    print(""observer error"")
                    //empty - handle error cases here
                    if let err = error as? NetworkError {
                        switch err {
                        case .invalidURL:
                            self.isInvalid.value = true
                        case .emptyResponse:
                            self.isInvalid.value = true
                        }
                    }
                    //error cases
                }, onCompleted: {
                    print(""completed"")
                }, onDisposed: {

                }).disposed(by: disposeBag)
        }
</code></pre>

<p>and in the <strong>dataController</strong> </p>

<pre><code>func loadImages() {
        return dataController.fetchStatusCodeImages()
            .subscribe(
               onNext: { images in
               self.imagesDataSource.value = images
            },
                onError: { error in
                print(""observer error"")
                //empty - handle error cases here
                if let err = error as? NetworkError {
                    switch err {
                    case .invalidURL:
                        self.isInvalid.value = true
                    case .emptyResponse:
                        self.isInvalid.value = true
                    }
                }
                //error cases
            }, onCompleted: {
                print(""completed"")
            }, onDisposed: {

            }).disposed(by: disposeBag)
    }
</code></pre>
","","user4422315","","","","2018-06-07 22:17:28","cannot resolve Extra argument 'onError' in call error","<observable><rx-swift>","1","0","0","","","CC BY-SA 4.0"
"50668925","1","50669062","","2018-06-03 17:07:31","","0","349","<p>I have the following code:</p>

<pre><code>loginViewModel.facebookLogin
.asObservable()
subscribe() { [unowned self] facebookLogin in
     if let isLoggedIn = facebookLogin.element?.isLoggedIn {
         if isLoggedIn {
              elf.performSegue(withIdentifier: ""toRestaurantSelect"", sender: self)
              }
      }

     if let didLoginFail = facebookLogin.element?.didLoginFail {
         self.errorLabel.isHidden = !didLoginFail
     }
  }
.disposed(by: disposeBag)
</code></pre>

<p>The facebookLogin is a Variable and is updated when the user logs in. However, the performSegue is not called (the condition is true). Strangely enough, if I turn on Slow animations in the emulator the segue is executed. When Slow animations are turned off the segue doesn't execute (the Facebook login works). Any help is appreciated. Thanks!</p>
","4183921","","9215780","","2018-06-03 23:10:59","2018-06-07 21:55:50","swift - performSegue not working in RxSwift Observable subscribe","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"50672265","1","","","2018-06-04 00:49:26","","1","196","<p>This question is very broad but I'm not sure which aspect of it I should focus on.  I have a goal to abstract away the recurring patterns of my screens such as errors, loading, empty data.  The views that represent these states will not change much between the many screens I have.  Perhaps they could be parameterized to allow that flexibility (e.g. <code>showError(message: ""404"")</code>).  </p>

<p>I liked <a href=""https://medium.com/@johnsundell/using-child-view-controllers-as-plugins-in-swift-458e6b277b54"" rel=""nofollow noreferrer"">this article</a> as a method of encapsulating the reusable UI aspects of this.  </p>

<p>But it appears to work in an imperative context.  So I have an API call and I can <code>showError</code> and in the response I can <code>hideError</code>.  Thats all fine.</p>

<p>Now I use an RxSwift/MVVM approach where each screen binds to inputs and outputs.  And I like to simplify the state my screen knows about by using a ""View State"" concept.  </p>

<p>As you can see in this snippet, I can reduce a lot of logic a single Observable that the view renders.</p>

<pre><code>let getFoos: (String) -&gt; Observable&lt;FooViewStateState&gt; = { query in
            fooService.perform(query)
                .map { results in
                    if results.isEmpty {
                        return ViewState.noResults(query: query)
                    } else {
                        return ViewState.matches(query: query, results: results.map { $0.name })
                    }
                }
                .startWith(ViewState.searching(query))
        }
</code></pre>

<p>The problem is that by using an enum <code>ViewState</code> its now unclear to me how to use the imperative API from before ""showLoading / hideLoading ... showError / hideError, etc..."" when I'm switching on the cases of this enum.  If the ViewState Observable emits <code>.loading</code> I'd have to hide the error screen, hide the empty screen, etc..  </p>
","5797668","","","","","2018-06-04 00:49:26","Using ""ViewState"" in RxSwift/MVVM","<swift><mvvm><rx-swift>","0","0","","","","CC BY-SA 4.0"
"50697727","1","","","2018-06-05 10:21:12","","0","860","<p>I am trying to upload firmware to a BLE device. Therefore I push some data, wait for an acknowledgment and then push some more, and so on.
But I am struggling with repeating the observer until the observer returns complete.</p>

<p>This is the observer, so if there are no more packets to be sent, it should complete and stop repeating.</p>

<pre><code>let transferImage = Observable&lt;Void&gt;.create { (obs) -&gt; Disposable in
        guard let nextPacket = dataSendingTracker.getNextPacket() else {
            obs.onCompleted()
            return Disposables.create()
        }

        return self.instrument()
            .flatMap{ $0.sendFWpacket(packet: nextPacket) }
            .subscribe(onNext: { () in
                obs.onNext(())
            }, onError: { (error) in
                obs.onError(error)
            })
    }
</code></pre>

<p>Any suggestion on how I can achieve this?</p>
","5326910","","","","","2018-06-05 16:15:20","RXswift, repeat observable until complete","<ios><swift><rx-swift>","2","1","","","","CC BY-SA 4.0"
"50715701","1","","","2018-06-06 08:30:15","","0","1066","<p>I want to use rxswift to observe hash value of my model.</p>

<p>I have something like registration form and I need to show ""save change"" only if some data was changed.</p>

<p>I'm not using any binding. </p>

<p>I'll just want to observe hash of data.</p>
","9025917","","9025917","","2018-06-06 09:03:28","2018-06-12 11:38:49","RxSwift: How to add simple observer to int value","<swift><rx-swift><observers>","1","2","","","","CC BY-SA 4.0"
"50746575","1","","","2018-06-07 16:55:31","","1","171","<p>Please consider the following structure:</p>

<pre><code>class UpModel {
    var isThisRealLife: Variable&lt;Bool&gt;

    required init(model: UpperModel) {
        isThisRealLife = Variable(upperModel.isThisRealLife) //true
        testFlagChange()
    }

    private func testFlagChange() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            self.isThisRealLife = false
        }
    }
}
</code></pre>

<p>This model is instanced by the <code>UpperViewModel</code>, by injecting it's own <code>UpperModel</code> instance, something like this:</p>

<pre><code>class UpperViewModel {
    init() {
        let upperModel = UpperModel()

        let upModel = UpModel(model: upperModel)
        let upViewModel = UpViewModel(model: upModel)
    }
}
</code></pre>

<p>Now I have my <code>UpViewModel</code> class:</p>

<pre><code>class UpViewModel {
    let bag = DisposeBag()

    init(model: UpModel) {
        let upModelVariable = Variable(model)
        let lowViewModel = LowViewModel&lt;LowModel&gt;(model: upModelVariable)

        upModelVariable.asObservable().flatMap({ $0.isThisRealLife.asObservable() }).subscribe(onNext: { value in
            print(""changed to \(value) -- at UpVM"") //1
        }).disposed(by: bag)
    }
}
</code></pre>

<p><strong>1:</strong>  reacts properly to the flag change after 3 seconds.</p>

<p>Ok, so far, so good.
But now I want to keep sending this <code>UpClass</code> reference down so other classes can react to changes on the <code>isThisRealLife</code> property.</p>

<p>So this is my <code>LowViewModel</code>, who receives the <code>UpModel</code> reference:</p>

<pre><code>class LowViewModel&lt;Model: LowModel&gt; {
    let bag = DisposeBag()
    let lowModel: LowModel

    required init(model: Variable&lt;UpModel&gt;) {
        lowModel = Model(model: model.value) 

        model.asObservable().flatMap({ $0.isThisRealLife.asObservable() }).subscribe(onNext: { value in
            print(""changed to \(value) -- at LowVM"") //2
        }).disposed(by: bag)
    }
}
</code></pre>

<p><strong>2:</strong> This does not react to the flag change.</p>

<p>And this is the <code>LowModel</code> but I'm not even using it just yet, since I seem to be losing reference to <code>isThisRealLife</code> property at the previous step:</p>

<pre><code>class LowModel {
    var isThisRealLife: Observable&lt;Bool&gt;

    required init(model: UpModel) {
        isThisRealLife = model.isThisRealLife.asObservable
    }
}
</code></pre>

<p><strong>Notes</strong>:</p>

<ul>
<li>I understand <code>Variable</code> is deprecated and I will refactor to <code>BehaviorRelay</code> as soon as I can make everything work.</li>
<li>I tried to make the example as reduced as possible to illustrate the problem, but of course the issue might be in the grater scope -- in which case I will gladly provide more information as required.</li>
<li>There are lots of Protocols involved to make things generic and reusable, so I removed all of them to try and focus on (at least what I think is) the issue. Also the GUI is not important right now, just the business logic.</li>
</ul>

<hr>

<p>Some more lengthy context in case anyone's interested:</p>

<p>Me and my team are working on a new architecture for our project. 
Since our design is fairly consistent, we're validating this concept of working with ""components"", which are a set of View, ViewModel and Model that can be reused throughout the app.</p>

<p>The main idea is that each screen is a set of MVVM with ViewController, ViewModel and Model, and they implement the ""components"" as needed. We're implementing Reactive to allow some components to react when there are certain changes in the ""parent""/""upper"" Model.</p>

<p>I've been working with reactive in RxSwift for almost a year now, but the project I worked on was fairly straightforward and the usage was repetitive, so my knowledge on the subject became narrow (which was my mistake, ofc).</p>

<p>Thanks for any help.</p>
","4002897","","","","","2018-06-08 00:35:33","Reference to Observable with class injection","<swift><mvvm><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"50753875","1","52422065","","2018-06-08 05:25:24","","7","9585","<p>I'd like to chain a Completable to an observable element. After calling <em>flatMap</em>, onCompleted and onError callbacks don't seem to be called on subscription.</p>

<pre><code>var user = PublishRelay&lt;User&gt;()

func fetchUserInformation(_ userId: String) -&gt; Completable {
    return Completable.create { observer in
        apiService.fetchInformation(for: userId, completion: { response in
            if let name = response?.name {
                user.accept(User(name: name))
                observer(.completed)
            } else {
                observer(.error(ServiceError.userInformation))
            }
        })
        return Disposables.create()
    }
}

login()
.flatMap{ userId in fetchUserInformation(userId) }
.subscribe(
    onCompleted: {
        print(""Success!"") // Not being called at all
    },
    onError: { error in
        print(error)  // Not being called at all
    }
).disposed(by: disposeBag)
</code></pre>

<p>Although <em>fetchUserInformation</em> and <em>observer(.completed)</em> are being called and user information is being successfully fetched, I won't be able to catch <em>onCompleted</em> on subscription (only when preceded by <em>flatMap</em>).</p>

<p>Is there a clean way to achieve this?</p>

<blockquote>
  <p>Already tried <em>.materialized()</em> just after the <em>flatMap</em> call in order to get an </p>

<pre><code>    Observable&lt;Event&lt;Never&gt;&gt;
</code></pre>
  
  <p>rather than a </p>

<pre><code>    Observable&lt;Never&gt;
</code></pre>
  
  <p>It doesn't work either.</p>
</blockquote>
","5973853","","5973853","","2018-06-08 05:30:35","2018-09-20 10:06:16","RxSwift: Chain Completable to Observable","<ios><swift><observable><rx-swift>","3","1","2","","","CC BY-SA 4.0"
"50776673","1","","","2018-06-09 17:08:29","","1","2621","<p>Is there a way to subscribe to array change only when a new element is appended?</p>

<p>So I want the following closure to be executed only when a new element is appended. </p>

<pre><code>array.asObservable().subscribe(onNext: { array in

}).disposed(by: self.bag)
</code></pre>

<p>If, for example, an element is removed from this array, I don't want this closure to be executed.</p>

<p><strong>EDIT:</strong></p>

<p>Is there a way to only have newly appended elements in the closure? In my case I append subsequences of various lengths, so I can't just look at the last element of the array inside the closure.</p>
","5112590","","5112590","","2018-06-13 17:43:40","2018-08-06 10:01:32","RxSwift observe array change only when appended new element","<ios><swift><rx-swift>","2","0","2","","","CC BY-SA 4.0"
"50776941","1","","","2018-06-09 17:42:07","","5","3051","<p>can someone explain what is the error here ?</p>

<pre><code>Member 'success' in 'SingleEvent&lt;_&gt;' produces result of type 'SingleEvent&lt;Element&gt;', but context expects 'SingleEvent&lt;_&gt;'
</code></pre>

<p>I return a Single either error or success with a generic type
if the result case is .success I want to pass JSON in the single event</p>

<p><a href=""https://i.stack.imgur.com/3h8kt.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/3h8kt.png"" alt=""enter image description here""></a></p>

<p>this is the full code</p>

<pre><code>import Foundation
import RxSwift

public class APIClient&lt;T: APIProtocol&gt; {
    var disposeBag: DisposeBag = DisposeBag()
}

extension APIClient {
    public func get&lt;U&gt;(apiService: T, key: String) -&gt; Single&lt;U&gt; {
        return Single.create { single in

            let task = TaskRequestManager.run(apiService, completion: { result in
                DispatchQueue.main.async {
                    switch result {

                    case .error(let error):
                        single(.error(error))
                    case .success(let json):

                        guard let JSON = json[key] as? [String: Any] else {
                            single(.error(ApiError.jsonParsingFailure))
                            return
                        }
                        single(.success(JSON))
                    }
                }

            })
            task.resume()
            return Disposables.create {
                task.cancel()
            }
    }
        }
}
</code></pre>
","","user4422315","1113632","","2018-06-11 10:15:45","2019-03-10 19:34:54","Member 'success' in 'SingleEvent<_>' produces result of type 'SingleEvent<Element>'","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"50795033","1","50808472","","2018-06-11 09:58:09","","1","2510","<pre><code>   _ = textField.rx.text.orEmpty.filter({ (text) -&gt; Bool in
       text.count &gt; 12
        return true
    }).subscribe(onNext: { (text) in
        let tempText:String = text
        self.textField.text = (tempText as NSString).substring(to: 12)
    })
</code></pre>

<p>it has someBug,i need use textFieldDidEndEditing </p>
","8625999","","6727675","","2018-06-11 15:30:28","2018-06-12 07:01:07","how to use UITextField.delegate textFieldDidEndEditing in rxSwift 4.0","<swift><textfield><rx-swift>","2","3","3","","","CC BY-SA 4.0"
"50839071","1","","","2018-06-13 13:55:52","","1","3650","<p>I have some code like this:</p>

<pre><code>let first = Observable&lt;Int&gt;.create({ observer -&gt; Disposable in
    observer.onNext(1)
    return Disposables.create()
})
let second = Observable.of(4, 5, 6)
let observableConcat = Observable.concat([first, second])
observableConcat.subscribe({ (event) in
    print(event)
})
</code></pre>

<p>What I know about the concat operator is ""It subscribes to the first sequence of the collection, relays its elements until it completes, then moves to the next one. The process repeats until all the observables in the collection have been used"".
So that I expected the result from the code snippet would be 1, 4, 5, 6 but what I got is 1 only.
Please teach me what I did misunderstand about the concat operator.</p>

<p>Thanks so much.</p>
","3087360","","1535128","","2018-06-13 14:17:24","2018-06-13 16:08:20","Concat operator RxSwift","<ios><swift><reactive-programming><concat><rx-swift>","2","0","1","","","CC BY-SA 4.0"
"50843542","1","","","2018-06-13 18:03:16","","0","161","<p>I'm pretty new in RxSwift and I have the following problem.</p>

<p>Given two functions: </p>

<pre><code>struct Checkout { ... }

func getSessionIdOperation() -&gt; Single&lt;UUID&gt;
func getCheckoutForSession(_ sessionId: UUID, asGuestUser: Bool) -&gt; Single&lt;Checkout&gt;
</code></pre>

<p>I have a third function that combines the result of the two:</p>

<pre><code>func getCheckout(asGuestUser: Bool) -&gt; Single&lt;Checkout&gt; {
    return getSessionIdOperation()
        .map { ($0, asGuestUser) }
        .flatMap(getCheckoutForSession)
}
</code></pre>

<p>both <code>getSessionIdOperation</code>and <code>getCheckoutForSession</code> can fail, and in case of failure I would like to restart the whole chain just once. I tried <code>retry(2)</code> but just <code>getCheckoutForSession</code> was repeated. :(</p>
","1754559","","","","","2018-06-20 18:42:08","RxSwift retry full chain","<swift><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"50876928","1","","","2018-06-15 13:48:05","","2","879","<p>I have something like this:</p>

<pre><code>protocol ViewModel: class {
    var eventWithInitialValue: Observable&lt;Int&gt; { get }
}

class ViewModelImpl: ViewModel {

    let eventWithInitialValue: BehaviorSubject&lt;Int&gt; = BehaviorSubject(value: 0)

    init() {
        eventWithInitialValue.onNext(1)
    }
}

class ViewController: UIViewController {

    weak var viewModel: ViewModel?

    private let bag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        viewModel?
            .eventWithInitialValue
            .subscribe(onNext: {
                print($0)
            }).disposed(by: bag)
    }
}
</code></pre>

<p>I want to communicate with <code>viewModel</code> fields from <code>ViewController</code> as an <code>Observables</code>. But inside <code>viewModel</code> this fields should be a <code>[OneOf]Subject</code> types (for safety reasons).</p>

<p>Implementation above have a next compile time error -> <code>Type 'ViewModelImpl' does not conform to protocol 'ViewModel'</code></p>

<p>Can anyone help with the implementation of these requirements?</p>
","6790657","","","","","2018-07-26 07:45:48","How to present PublishSubject as Observable in MVVM?","<swift><mvvm><protocols><rx-swift>","2","0","","","","CC BY-SA 4.0"
"50912058","1","50913509","","2018-06-18 14:44:38","","0","1247","<p>I am doing multiple requests for every section that I have in my collectionView.</p>

<p>The idea was to join them together into an Observable&lt;[FeedSection]> so that I can bind it to the collectionView sections.</p>

<p>Right now I am having an array of observables and I don't know how to transform it. Ideas?</p>

<p>So i'm looking into smth like this: <code>[Observable&lt;FeedSection&gt;] -&gt; Observable&lt;[FeedSection]&gt;</code></p>

<p>Code:</p>

<pre><code>let feedObservable = [flickrProvider.rx.request(.kittens),
                      flickrProvider.rx.request(.dogs),
                      flickrProvider.rx.request(.publicFeed)].map { 
                          $0.map(Feed.self).asObservable()
}
</code></pre>
","1446139","","1446139","","2018-06-18 15:03:51","2018-06-18 16:07:16","Joining multiple requests into one. Array of observables into an observable of an array","<ios><swift><observable><rx-swift><rxdatasources>","1","2","","","","CC BY-SA 4.0"
"50917935","1","","","2018-06-18 21:48:12","","1","530","<p>I have to work with 2 database objects which are related to each other. The way I have done it created nested subscriptions. I read a couple of blogs but couldn't find a way to do away with nested subscriptions. Any pointers would be appreciated.</p>

<p>A topic has a list of children. After retrieving all the children, I need to print ""topic name"" + ""child name"", after iterating over all the children. This is a simplified version of the problem statement. The only catch is data service returns observable of database objects to which I need to subscribe.  </p>

<pre><code>let ds = DatabaseService()    

func createBindings() {
    _ = ds.getTopics()
        .flatMapLatest{self.updateSections(array: $0)}
        .subscribe()
}

func updateSections(array: [Topics]) -&gt; Observable&lt;Void&gt; {
    for topic in array {
        let children = topic.children
        for id in children {
            _ = ds.getChildWith(id: id).map { lo in
                //do business related stuff
                }
                .subscribe()
        }
    }
    return .never()
}
</code></pre>

<p>I want to avoid another subscription in flatMapLatest.</p>
","2899485","","822420","","2018-06-21 07:19:01","2018-06-21 07:19:01","Avoid Nested RxSwift Subscriptions","<ios><nested><subscription><rx-swift>","1","0","","","","CC BY-SA 4.0"
"50940821","1","50948384","","2018-06-20 05:27:20","","1","372","<p>I have a VM that renders a list of ""nodes"". Each node has an <code>isCompleted</code> and <code>isRead</code> property.  They are rendered in a tableview and each cell has buttons to toggle those properties.</p>

<p>On page load, I fetch the list from the server.  Now, I simply want to update those nodes.  In my VM, I have attempted over 20 approaches with various operators, strategies, approaches, etc.. But with each attempt there's always the same issue.  </p>

<p>I'm aware that this is literally just updating something, or View -> ViewModel communication.  Nonetheless, I've spent an embarrassing amount of hours racking my brain trying to model this.  So I must be missing some very fundamental aspect of RxSwift, MVVM and how to model mutations.</p>

<p>Here is my latest attempt.</p>

<pre><code>  let updates = Observable&lt;(NodeIdentifier, AttribUpdate)?&gt;.merge([
        toggleMarkReadSubject.map { ($0, AttribUpdate.isRead) },
        toggleFavoriteSubject.map { ($0, AttribUpdate.isFavorited) }
        ]).startWith(nil)

    nodes = Observable.combineLatest(dataFromService, updates, resultSelector: { (nodes, update) in
        guard let update = update else { return nodes }

        switch update.1 {
        case .isFavorited:
            return nodes.withFavoritedToggled(atId: update.0)
        case .isRead:
            return nodes.withMarkReadToggled(atId: update.0)
        }
    }).debug(""new nodes"", trimOutput: false)
</code></pre>

<p>I have some Subjects that map the toggle events to a tuple with the nodeIdentifier and the update operation (using an enum with cases for each update type)</p>

<p><code>nodes</code> is my main output that drives the tableview.  I <code>combineLatest</code>'d the <code>nodesFromService</code> (the original nodes from the service/api).  </p>

<p>Now, I get events of <code>[Node]</code> where the toggled property looks like the following: <code>[false, true, true, true, true]</code>.  So it always goes from <code>false -&gt; true</code> because <code>combineLatest</code> always takes the initial node array from <code>nodesFromService</code>.    </p>

<p>Here's what is driving me insane..  No matter which way I slice it, this is a cyclical dependency.  What I really need is for the <code>updates</code> (the toggle events) to be combined with the <code>""final nodes""</code> stream (the stream that actually remembers the updates).  But, if I were even able to do that, I'd run into a recursive situation.  Because the <code>updates</code> are what produces that <code>""final nodes""</code> stream in the first place! I feel totally lost.  I greatly appreciate help here.</p>
","5797668","","1113632","","2018-08-03 07:57:47","2018-08-03 07:57:47","Updating a list of something w/ RxSwift in a ViewModel","<swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"50952562","1","","","2018-06-20 16:03:18","","1","1409","<p>I have a UIStepper value binded to a UILabel text:</p>

<pre><code>    unitsStepper.rx.value.asObservable()
        .map { Int($0).description }
        .bind(to: stepperCountLabel.rx.text)
        .disposed(by: rx.disposeBag)
</code></pre>

<p>And i would like to animate the label every time it changes, theres a better way to that instead of this? </p>

<pre><code>    unitsStepper.rx.value.asObservable()
        .map { Int($0).description }.subscribe(onNext: { [weak self] value in
            guard let strongSelf = self else { return }
            UIView.animate(withDuration: 0.4, animations: {
                strongSelf.stepperCountLabel.text = value
                strongSelf.stepperCountLabel.transform = CGAffineTransform(scaleX: 1.5, y: 1.5)
            }, completion: { completed in
                strongSelf.stepperCountLabel.transform = CGAffineTransform.identity
            })

        }).disposed(by: rx.disposeBag)
</code></pre>
","588125","","1113632","","2018-08-03 07:09:07","2018-08-03 07:09:07","RxSwift bind to with animation with RxCocoa","<swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"50970117","1","50988298","","2018-06-21 13:44:36","","6","2533","<p>Lets say i have a CustomView with a value in it. 
I want to expose that value to the world using rx.value (Observable) instead of having to access it by value (Int).</p>

<pre><code>final class CustomView: UIView {
   var value: Int = 0
   ...
}
</code></pre>

<p>I copied this from UIStepper+Rx:</p>

<pre><code>extension Reactive where Base: CustomView {

    var value: ControlProperty&lt;Int&gt; {
        return base.rx.controlProperty(editingEvents: [.allEditingEvents, .valueChanged],
            getter: { customView in
                customView.currentValue
        }, setter: { customView, value in
            customView.currentValue = value
        }
        )
    }

}

final class CustomView: UIControl {

    fileprivate var currentValue = 1 {
        didSet {
            checkButtonState()
            valueLabel.text = currentValue.description
        }
    }

   // inside i set currentValue = 3
}
</code></pre>

<p>But customView.rx.value doesnt emit any values</p>
","588125","","1113632","","2018-08-03 07:56:33","2018-08-03 07:56:33","Add a rx.value to my CustomView","<ios><swift><rx-swift><rx-cocoa>","2","1","2","","","CC BY-SA 4.0"
"51002262","1","","","2018-06-23 14:47:03","","1","1625","<p>I am new in RxSwift and today I face with a problem which I can't solve. I want to observe to <code>controlEvent</code>s in <code>UITextField</code>.</p>

<p>Code:</p>

<pre><code>textField.rx
    .controlEvent([.editingDidEndOnExit, .editingDidEnd])
    .subscribe(onNext: { [weak self] in
        // do stuff
    })
    .disposed(by: disposeBag)
</code></pre>

<p>I want to now when <code>textField</code> resigns to be first responder or user taps on <code>return</code> button. Code works fine when I perform a line: <code>textField.resignFirstResponder()</code> but when I tap on <code>return</code> button I get a warning message:</p>

<blockquote>
  <p>⚠️ Reentrancy anomaly was detected.
  Debugging: To debug this issue you can set a breakpoint in /Users/laxmorek/Documents/projects/meetingapplication-ios/Pods/RxSwift/RxSwift/Rx.swift:97 and observe the call stack.
  Problem: This behavior is breaking the observable sequence grammar. <code>next (error | completed)?</code>
      This behavior breaks the grammar because there is overlapping between sequence events.
      Observable sequence is trying to send an event before sending of previous event has finished.
  Interpretation: This could mean that there is some kind of unexpected cyclic dependency in your code,
      or that the system is not behaving in the expected way.
  Remedy: If this is the expected behavior this message can be suppressed by adding <code>.observeOn(MainScheduler.asyncInstance)</code>
      or by enqueing sequence events in some other way.</p>
</blockquote>

<p>I don't understand this. </p>

<ul>
<li>What is proper way to observe multiple <code>controlEvent</code> in <code>RxSwift</code>?</li>
<li>Why I get this warning message? What is wrong with my observing setup?</li>
</ul>

<h3>Edit</h3>

<p>Temporary workaround is that I split my code like this:</p>

<pre><code>textField.rx
    .controlEvent(.editingDidEndOnExit)
    .subscribe(onNext: { [weak self] in
        self?.isSelected = false
    })
    .disposed(by: disposeBag)
textField.rx
    .controlEvent(.editingDidEnd)
    .subscribe(onNext: { [weak self] in
        self?.isSelected = false
    })
    .disposed(by: disposeBag)
</code></pre>

<p>But this code duplication does not look very well. :/</p>
","4219574","","1113632","","2018-08-02 19:22:04","2018-10-22 15:18:10","Observing multiple controlEvent causes `Reentrancy anomaly was detected.` warning message","<ios><swift><rx-swift><rx-cocoa>","1","0","1","","","CC BY-SA 4.0"
"51004283","1","51004483","","2018-06-23 19:08:39","","3","6155","<p>I have the following <code>Forecast</code> class:</p>

<pre><code>class Forecast {

    let city: City

     var currentTemperature: String {
        didSet {
            print(""cur tepm was set to \(currentTemperature)"")
        }
    }

    init(city: City) {
        self.city = city
        self.currentTemperature = ""0""
    }

    func loadForecast() {
        self.currentTemperature = ""+10""
    }

}
</code></pre>

<p>I am trying to observe <code>currentTemperature</code> property of <code>forecast</code> object in <code>ForecastViewModel</code></p>

<pre><code>class ForecastViewModel {

    fileprivate let variableForecast: Variable&lt;Forecast&gt;

    var navigationTitle: Observable&lt;String&gt; {
        return Observable.just(""No name"")
    }

    init(forecast aForecast: Forecast) {
        self.variableForecast = Variable(aForecast)

        self.variableForecast.asObservable().subscribe(onNext: { (s) in
            print(s.currentTemperature)
        })

        variableForecast.value.currentTemperature  = ""-15""
        variableForecast.value.loadForecast()
    }

}
</code></pre>

<p>However, code in subscribe on next is executed only once and prints 0. <code>didSet</code> block is called every time. </p>

<p>How should I observe a property of this class? </p>
","7626803","","","","","2018-06-23 19:38:16","How to observe object's property in RxSwift?","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"51007938","1","51008388","","2018-06-24 07:49:26","","1","1417","<p>Hi I am trying to learn RXSwift and First time I came across these concepts like Maps and Compact Maps.</p>

<p>I am able to get the response, but this line always returns empty.</p>

<blockquote>
  <p>objects.compactMap(DummyUser.init)</p>
</blockquote>

<pre><code>fileprivate let Users = Variable&lt;[DummyUser]&gt;([])
    fileprivate let bag = DisposeBag()



response
                .filter { response, _ in
                    return 200..&lt;300 ~= response.statusCode
                }
                .map { _, data -&gt; [[String: Any]] in
                    guard (try? JSONSerialization.jsonObject(with: data, options: [])) != nil  else {
                            return []
                    }

                    let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String : Any]

                  //  print(json![""results""])
                    return json![""results""] as! [[String : Any]]
                }
                .filter { objects in
                    return objects.count &gt; 0
                }
                .map { objects in
                  //  objects.forEach{print($0[""name""]!)}
                    let names = objects.map { $0[""name""]!}
                    print(names)
                    return objects.compactMap(DummyUser.init)
                }
                .subscribe(onNext: { [weak self] newEvents in
                    self?.processEvents(newEvents)
                })
                .disposed(by: bag)

func processEvents(_ newEvents: [DummyUser]) {
        var updatedEvents = newEvents + Users.value
        if updatedEvents.count &gt; 50 {
            updatedEvents = Array&lt;DummyUser&gt;(updatedEvents.prefix(upTo: 50))
        }

        Users.value = updatedEvents
        DispatchQueue.main.async {
            self.MianUsertable.reloadData()
        }
     //   refreshControl?.endRefreshing()

        let eventsArray = updatedEvents.map{ $0.dictionary } as NSArray
        eventsArray.write(to: userFileURL, atomically: true)

    }
</code></pre>

<p>My Json Response is Here</p>

<blockquote>
  <p><a href=""https://randomuser.me/api/?results=5"" rel=""nofollow noreferrer"">https://randomuser.me/api/?results=5</a></p>
</blockquote>

<p><strong>DummyUser Class</strong></p>

<pre><code>import Foundation

typealias AnyDict = [String: Any]

class DummyUser {
    let gender: String
    let name: AnyDict
    let dob: String
    let picture: AnyDict

    init?(dictionary: AnyDict) {
        guard let Dgender = dictionary[""gender""] as? String,
             let Dname = dictionary[""name""] as? AnyDict,
             let birthdata = dictionary[""dob""] as? AnyDict,
             let Ddob = birthdata[""dob""] as? String,
             let Dpicture = dictionary[""picture""] as? AnyDict
            else {
                return nil
        }

        gender = Dgender
        name = Dname
        dob = Ddob
        picture = Dpicture
    }



    var dictionary: AnyDict {
        return [
            ""user"": [""name"" : name, ""gender"": gender, ""dob"": dob],
            ""picture"" : [""userImage"": picture]
        ]
    }

}
</code></pre>
","3234352","","3234352","","2018-06-24 07:57:19","2018-06-24 08:59:33","Swift Compact Map returning empty","<ios><iphone><swift><functional-programming><rx-swift>","1","1","","","","CC BY-SA 4.0"
"51010805","1","","","2018-06-24 14:24:55","","0","427","<p>I'm trying to use Rxswift in an application embedded in Tabbar Controller.</p>

<p>I have three view controllers in the tabbar. There are few subscriptions in all view controllers. But for the sake of simplicity lets say first and second view controllers subscribe to the third view controller to get some values. </p>

<p>I get subscribed to the third view controller as coded;</p>

<pre><code>    func startSubscription() {
    let settingsNavigationVC = self.tabBarController?.viewControllers![2] as! UINavigationController
    let settingsVC = settingsNavigationVC.topViewController as! SettingsViewController
    settingsVC.selectedUser.subscribe(onNext: { [weak self] user in
        self?.userToShow = user
    }).disposed(by: disposeBagForFirst)
    }
</code></pre>

<p>This works fine if all the tabs are tapped before any data manipulation so all the subscription can start and all app works fine. But if a user directly taps to third vc after loading the app, and makes a change. Then the data at first vc gets updated since it is already loaded when the app started, but the data at second vc doesn't change since there is no subscription yet because the view was not loaded before the changes made in third vc.</p>

<p>I tried to do it with instantiate vc method but that doesn't work either, because with tab bar controllers there is no instantiating views more than once I suppose.</p>

<p>My question is; how can I make sure all the views get loaded before the user interacts with the app, or how should I change my subscription method in order to make it work regardless if all the tabs clicked(views loaded).</p>

<p>Thanks in advance.</p>
","8447312","","","","","2018-06-25 06:54:17","Swift, Variable subscription for Tabbar Controller using RxSwift","<swift><uitabbarcontroller><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"51055281","1","51055887","","2018-06-27 05:43:51","","1","849","<p>Updating my iOS app from Moya 8 to 11 and I have the following function in a network utility class which is called to get data from a server and map it for use in other classes:</p>

<pre><code>func getServerData(endpoint: MyMoyaService) -&gt; Observable&lt;Any&gt; {
    let provider = RxMoyaProvider&lt;MyMoyaService&gt;()
    return provider.request(endpoint)
        .filterSuccessfulStatusAndRedirectCodes()
        .mapJSON()
        .flatMap { response -&gt; Observable&lt;Any&gt; in
            return Observable(…)
        }
}
</code></pre>

<p>With the updates, <code>RxMoyaProvider</code> was replaced with <code>MoyaProvider</code> and instead you're supposed to use <code>.rx</code> to use the <code>RxSwift</code> extensions. This now returns a <code>Single</code> instead of an <code>Observable</code> so in order to avoid compiler errors I also needed to insert <code>asObservable()</code></p>

<pre><code>func getServerData(endpoint: MyMoyaService) -&gt; Observable&lt;Any&gt; {
    let provider = MoyaProvider&lt;MyMoyaService&gt;()
    return provider.rx.request(endpoint)
        .asObservable()
        .filterSuccessfulStatusAndRedirectCodes()
        .mapJSON()
        .flatMap { response -&gt; Observable&lt;Any&gt; in
            return Observable(…)
        }
}
</code></pre>

<p>But the <code>flatMap</code> portion is not being called at all and my network calls don't work anymore. If I do this without RxSwift, just switching on the result, it works OK (but that doesn't fit with my current setup) so I know that the network call and the updates to the custom <code>TargetType</code> service are done correctly.</p>

<ol>
<li>How do I get this working again, (ideally without completely changing the entire setup, and</li>
<li>(for extra credit) how do I take full advantage of the updated setup with <code>Single</code> instead of <code>Observable</code> (since I assume that by using <code>asObservable</code> I'm just missing out on useful features / cleaner code)</li>
</ol>
","1032372","","","","","2018-06-27 06:25:52","Updating Moya/RxSwift breaking my network calls","<ios><swift><rx-swift><moya>","1","0","","","","CC BY-SA 4.0"
"51071683","1","","","2018-06-27 21:28:56","","0","275","<p>Im wondering if i can use pointfree-style using Swift/RxSwift like so:</p>

<pre><code>class MyClass {
   private let ageService: Observable&lt;Int&gt; = AgeService()
   private let userService: Observable&lt;Bool&gt; = UserService()

    func test() -&gt;  Observable&lt;Int&gt;{
       return userService
                  .getRandomUser()
                  .flatMap(self.networkService.ageFromUser)
    }
</code></pre>

<p>Or should i go always with .. ?</p>

<pre><code>func test2() -&gt;  Observable&lt;Int&gt;{
   return userService.getRandomUser().flatMap { [weak self] user in
       guard let strongSelf = self else { return .empty() }
       return strongSelf.networkService.ageFromUser(user) 
   }
}
</code></pre>
","588125","","588125","","2018-06-28 05:10:46","2018-06-29 05:49:44","RxSwift pointfree style avoid retain cycles","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"51132302","1","51135564","","2018-07-02 08:52:29","","0","76","<p>I know it's not the best use-case but let's say I have a button which calls an API Service every time is tapped. Something like this:</p>

<p><strong>ViewController</strong></p>

<pre><code>myButton.tap.flatMap { [unowned self] _ in 
    return self.webService.apiCall()
}.suscribe(someObserver)
.disposed(by: self.disposeBag)
</code></pre>

<p><strong>WebService</strong></p>

<pre><code>class WebService {
    func apiCall() -&gt; Observable&lt;[Result]&gt; {
        return RxAlamofire.requestData(.get, url).map { [unowned self] response, data -&gt; [MyResult] in
             return self.parse(data)
        }
    }
}   
</code></pre>

<p>So I'm using every tap to request some information. Now, every observable is unique and inmutable and every tap would generate a new Observable I'm subscribing to.</p>

<p>Am I wrong or doesn't it mean that I have a leak here and every requested observable (that is, every API call) isn't being disposed? What would it be an elegant way to solve this?</p>

<p>Thanks in advance</p>
","3846857","","1113632","","2018-08-02 19:57:32","2018-08-02 19:57:32","Reactive API Call on tap button produces a leak","<swift><rx-swift><reactive>","1","0","","","","CC BY-SA 4.0"
"51135844","1","","","2018-07-02 12:05:43","","1","242","<p>I would like to know if it is possible make a queue (with identifier for example, like &quot;Q&quot;) with RxSwift like:</p>
<blockquote>
<p>On ViewController1 I <strong>send</strong> an event1 to queue Q.</p>
<p>On ViewController2 I <strong>send</strong> other event2 to Q.</p>
<p>On ViewController3 I <strong>handle</strong> the events 1 and 2 of the queue, with identifier Q.</p>
</blockquote>
<p><strong>EDIT, specifing the problem:</strong></p>
<p>I have to present multiple ViewControllers as modal. So for example ViewController1 says that needs to show a popup on ViewController2, but ViewController2 have to show another popup too, so I need a queue there in order to not present all popups at the same time, so one after the other.</p>
<p>I am new on Rx so I am not sure if this is possible. Also if there is a way to do it without RxSwift I am open to try it.</p>
<p>Thank you so much.</p>
","5288983","","-1","","2020-06-20 09:12:55","2018-07-02 12:24:55","Make a queue of events RxSwift","<ios><swift><rx-swift>","0","2","","","","CC BY-SA 4.0"
"51145507","1","","","2018-07-03 01:29:26","","0","297","<p>In working through the tutorial at <a href=""https://www.raywenderlich.com/138547/getting-started-with-rxswift-and-rxcocoa"" rel=""nofollow noreferrer"">https://www.raywenderlich.com/138547/getting-started-with-rxswift-and-rxcocoa</a></p>

<p>using Xcode 9.3 and Swift4</p>

<p>There is the code:</p>

<pre><code>private func setupTextChangeHandling() {
  let creditCardValid = creditCardNumberTextField
    .rx
    .text //1
    .throttle(throttleInterval, scheduler: MainScheduler.instance) //2
    .map { self.validate(cardText: $0) } //3

  creditCardValid
    .subscribe(onNext: { self.creditCardNumberTextField.valid = $0 }) //4
    .addDisposableTo(disposeBag) //5
} 
</code></pre>

<p>This is giving an error on the map() call on the $0 parameter:</p>

<blockquote>
  <p>Cannot convert value of type 'String?' to expected argument type 'String'</p>
</blockquote>

<pre><code>func validate(cardText: String) -&gt; Bool
</code></pre>

<p>Is the declaration of the called function inside the map closure.</p>

<p>In looking at the Apple docs, the map (optional) should pass an unwrapped variable in as the parameter so $0 should already be unwrapped and I don't see any notes on it being deprecated or changed.</p>

<p>Not quite sure what is wrong here.  </p>

<p>TIA</p>
","2517001","","1113632","","2018-08-02 15:47:32","2018-08-02 15:47:32","RxCocoa map optional error in Swift4 with 'Cannot convert value of type 'String?'","<swift><swift4><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"51168077","1","51397826","","2018-07-04 07:27:18","","0","1730","<p>I want to use RX  in a way that it will download data from multiple APIs and combine all of them. All of them would execute in parallel and then combine data from the response of all of them. I am executing them in nested calls here &amp; i would like convert the code.</p>

<pre><code>public func searchListings(searchState: SearchState,
                             renderState: SearchRenderState) -  Observable&lt;PropertyNetworkResponse  {
        return Observable.create({ (observer) -  Disposable in

      _ = self.getXData(searchState: searchState, renderState: renderState).subscribe(onNext: { (xData) in

        _ = self.getYData(searchState: searchState, renderState: renderState).subscribe(onNext: { (yData) in

          _ = self.getZData(searchState: searchState, renderState: renderState).subscribe(onNext: { (zData) in

          let results = xData + yData + zData


          observer.onNext(resultNetworkResponse)
          observer.onCompleted()

          }, onError: { (error) in

            observer.onError(error)

          }, onCompleted: nil, onDisposed: nil)
        }, onError: { (error) in

          observer.onError(error)

        }, onCompleted: nil, onDisposed: nil)

      }, onError: { error in

        observer.onError(error)

      }, onCompleted: nil, onDisposed: nil)

      return Disposables.create()   
    }) 
  }
</code></pre>
","315594","","","","","2018-07-18 09:02:14","RX Swift - Parallel Execution of APIs","<ios><swift><observable><observer-pattern><rx-swift>","1","1","","","","CC BY-SA 4.0"
"51177561","1","","","2018-07-04 16:05:02","","4","2411","<p>Let say we have array of InvoiceDataModel</p>

<pre><code>private let invoices Variable&lt;[InvoiceDataModel]&gt; = Variable([])

class InvoiceDataModel { 
    let id: Variable&lt;Int&gt;
    var entity: Variable&lt;InvoiceDto&gt;
    var isSelected: Variable&lt;Bool&gt; 
}
</code></pre>

<p>On tap on checkbox I am changing value of isSelected.
What I want to achieve is to react on isSelect change to:</p>

<ul>
<li>calculate total amount of selected items (each entity has <code>var amount: Double</code>)</li>
<li>detect if all items in collection are selected</li>
</ul>

<p>Is it possible to observe whole array and react on single property from element change?
Not sure how am I supposed to achieve this.</p>

<p>Probably my approach to this case is totally wrong. However I am not sure how am I supposed to operate here in a different way.  </p>
","4453745","","1113632","","2018-08-02 19:56:54","2018-11-23 12:30:19","RxSwift observing changes in array","<ios><swift><rx-swift><rx-cocoa>","2","0","2","","","CC BY-SA 4.0"
"51206550","1","","","2018-07-06 08:55:08","","0","3312","<p>I'm trying to add a switch change state action to each tableview cell on my tableview, The problem is that the first time I run the application the state action gets called for each cell created.
Has an example when I initially have 5 items on the database, the first time I load the tableview the switch will be called 5 times. 
What I want is an action function, outside the binding, to be called <strong>ONLY</strong> when the user has clicked the switch.</p>

<p>Here is the code for the tableview cell:</p>

<pre><code>class SensorCell: UITableViewCell {

    @IBOutlet weak var txtIndex: UILabel!
    @IBOutlet weak var txtSensorItem: UILabel!
    @IBOutlet weak var sensorSwitch: UISwitch!
    var cellBag = DisposeBag()

    override func awakeFromNib() {
        super.awakeFromNib()
    }

    func configure(withViewModel viewModel: SensorItemPresentable) -&gt; (Void) {

        txtIndex.text = viewModel.id!
        txtSensorItem.text = viewModel.textValue!
        sensorSwitch.isOn = viewModel.status!
    }
}
</code></pre>

<p>Here is the code when I do the tableview binding:</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    let nib = UINib(nibName: ""SensorCell"", bundle: nil)

    tableViewItems.register(nib, forCellReuseIdentifier: identifier)

    viewModel = SensorViewModel()

    self.viewModel?.items.asObservable().bind(to: self.tableViewItems.rx.items(cellIdentifier: identifier, cellType: SensorCell.self)) { index, item, cell in


        cell.sensorSwitch.rx.isOn
            .subscribe({ status in
                //on first time loading the view, if my database has 5 items it will run this 5 times
            print(""cell switch set to: \(status)"")

            })
            .disposed(by: cell.cellBag)


        cell.configure(withViewModel: item)

        }.disposed(by: bag)

}
</code></pre>
","1065307","","5383429","","2018-07-06 10:06:09","2018-07-08 02:51:44","Switch button on tableview cell Rxswift","<ios><swift><reactive-programming><rx-swift><rx-cocoa>","1","0","1","","","CC BY-SA 4.0"
"51211585","1","","","2018-07-06 13:32:26","","1","298","<p>I am building an app in Swift 4 using MVVM non reactive. I would like to call viewmodel updates from the tableView's View model in order not to turn it into spagetthi code. Instead of creating one view model for each collectionViewCell I am trying to update from main ViewModel.</p>

<pre><code>//Spaghetti option (VM - ViewModel , VC - ViewController) 
//TableVC - TableVM 
//Cell- CellVM 
//CollectionCell- CollectionVM 
</code></pre>

<p>And models and managers updating. I am using the method below to delegate back to the Main TableViewController to give the MainViewModel all responsibility. Since I have multiple CollectionViews in different cells I think this is the best way to do. Any suggestions?</p>

<pre><code>func setCollectionViewDataSourceDelegate&lt;D: UICollectionViewDataSource &amp; UICollectionViewDelegate&gt;(dataSourceDelegate: D, forRow row:Int){
    self.collectionView.delegate = dataSourceDelegate
    self.collectionView.dataSource = dataSourceDelegate
    self.collectionView.tag = row
    self.collectionView.reloadData()
}
</code></pre>
","10042728","","1226963","","2018-07-06 16:23:10","2018-07-09 08:32:55","CollectionView in tableViewCell MVVM","<ios><swift><mvvm><rx-swift>","1","1","","","","CC BY-SA 4.0"
"51219919","1","","","2018-07-07 04:32:20","","0","106","<p>I am new to RxSwift and have been trying to use tableview with RxSwift. 
I have a switch that toggles between two dataSources and according to it, respective tableviewcells are displayed.</p>

<p>Could anyone help me find what i might be doing wrong?</p>

<pre><code>     func segmentControlledTableView() {
      typeRx.asObservable()
        .subscribe(onNext: { (type) in
            switch type {
            case RatesControllerType.location:
                self.branchList.asObservable()
                    .bind(to: self.tableView.rx.items) {
                        (tableView: UITableView, index: Int, element: 
                         BranchNearList) in
                        let indexPath = IndexPath(row: index, section: 
                          0)
                        let cell = 
                         tableView.dequeueReusableCell(withIdentifier: 
                          ""BranchesNearCell"", for: indexPath) as! 
                           BranchesNearCell
                        cell.loadCell(element)
                        return cell
                    }
                    .disposed(by: self.disposeBag)
                break
            case RatesControllerType.currency:
                self.currencyList.asObservable()
                    .bind(to: self.tableView.rx.items) {
                        (tableView: UITableView, index: Int, element: 
                          CurrencyNearList) in
                        let indexPath = IndexPath(row: index, section: 
                          0)
                        let cell = 
                     tableView.dequeueReusableCell(withIdentifier: 
                      ""CurrencyNearCell"", for: indexPath) as! 
                      CurrencyNearCell
                        cell.loadCell(element)
                        return cell
                    }
                    .disposed(by: self.disposeBag)
            }
        })
        .disposed(by: self.disposeBag)

}
</code></pre>
","4994082","","7493379","","2018-07-07 13:01:44","2018-07-07 13:01:44","configure a tableview to switch between two array as datasouce with RxSwift","<ios><swift><uitableview><rx-swift>","0","3","","","","CC BY-SA 4.0"
"51223749","1","51224495","","2018-07-07 13:35:17","","0","6806","<p>I have this view model in my code:</p>

<pre><code>import RxSwift

protocol ViewModelInput {
    func buttonTouched()
}

protocol ViewModelOutput {
    var done : PublishRelay&lt;Bool&gt; { get set }
}

protocol ViewModelType {
    var inputs: ViewModelInput { get }
    var outputs: ViewModelOutput { get }
}

public final class ViewModel: ViewModelInput, ViewModelOutput, ViewModelType {

    var inputs: ViewModelInput { return self }
    var outputs: ViewModelOutput { return self }

    internal var done = PublishRelay&lt;Bool&gt;.init()

    init() {}

    func buttonTouched() {
        self.outputs.done.accept(true)
    }
}
</code></pre>

<p>And I'm using it's ""output"" like this:</p>

<pre><code>// Somewhere else in my app
        viewModel.outputs.done
        .asObservable()
        .observeOn(MainScheduler.instance)
        .subscribe(onNext: { [weak self] _ in
            // whatever
        }).disposed(by: disposeBag)
</code></pre>

<p>To be honest I don't need that <code>Boolean</code> value with <code>PublishRelay</code>. I don't even need <code>onNext()</code> event. All I need is to notify my coordinator (part of app that uses this view model) about <code>onCompleted()</code>. However there is still some <code>&lt;Bool&gt;</code> generic type added to my output. I don't need any of that. Is there any cleaner way to achieve that?</p>

<p>I though about traits like <code>Completable</code> but as far as I understand I need to emit completed-event inside <code>create()</code> method or use <code>Completable.empty()</code>. Or maybe I don't understand traits that good, I don't know.</p>

<p>Any ideas?</p>
","10046426","","402366","","2018-07-08 11:14:53","2018-07-13 07:31:46","How can I use Rx Swift PublishRelay with no type just for onCompleted() event?","<ios><swift><rx-swift>","2","1","","","","CC BY-SA 4.0"
"51243265","1","","","2018-07-09 10:23:04","","1","307","<p>during working on application hardly relying on RxSwift I encountered some(I'd to think) basic problem. I'm using RxDataSources sublibrary to manage section and items in my TableView. Everywhere I see a examples, how to achieve one way binging(I have a model, then I bind it to the TableView to show it), but I need also second way of binding - I need to modify my model during interacting with cell and refresh cell after that. I want to achieve that though using of observables during building a SectionModel, but I don't have a any idea, how can I achieve that. Maybe some encountered similar problem and now have some solution for that? </p>
","4463435","","","","","2018-07-12 13:24:51","RxDataSources and ability to mutate model","<ios><swift><uitableview><rx-swift><rxdatasources>","1","2","","","","CC BY-SA 4.0"
"51268740","1","","","2018-07-10 15:11:00","","0","220","<p>I have a view model that makes some updates to an array of todos.  I'm mapping a set of inputs to actions (modeled as cases in an enum) and merging them into a single </p>



<pre class=""lang-swift prettyprint-override""><code>let mergedActions = Observable&lt;TodosAction&gt;.merge([
    todosFromService.map { .fromService(todos: $0) },
    toggleFavoriteSubject.map { .toggleFavorite(identifier: $0) },
    toggleIsReadSubject.map { .toggleIsRead(identifier: $0) }
])
</code></pre>

<p>Then I'm using <code>scan</code> to ""remember"" the history of the updates.</p>

<pre class=""lang-swift prettyprint-override""><code>todos = mergedActions
    .scan([]) { (lastTodos, new) -&gt; [Todo] in
        switch new {
        case .fromService(let todos):
            return todos
        case .toggleFavorite(let identifier):
            return lastTodos.withFavoritedToggled(atId: identifier)
        case .toggleIsRead(let identifier):
            return lastTodos.withIsReadToggled(atId: identifier)
        }
    }
</code></pre>

<p>My problem is integrating the network requests into this approach.  E.g. I have the ""optimistic update"" where I'm assuming success and updating the todo in memory.  But I also want to update it on the server and 
""roll back"" that update if the request fails.  </p>

<p>I can't think of how to do this based on the current structure of my Observables.  E.g. the <code>scan</code> closure is no longer in the world of Observables as it just returns a <code>[Todo]</code> so I can't make api requests with <code>flatMap</code> or anything.</p>

<p>How could this be amended or augmented to support api integration and roll back the corresponding local updates if the remote updates fail?</p>
","5797668","","2369487","","2018-08-10 08:31:43","2018-08-10 08:31:43","Optimistic UI updates in RxSwift","<swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"51305904","1","51306695","","2018-07-12 12:38:22","","3","3545","<p>Im using <code>RxSwift</code> and <code>RxCocoa</code> in my project.</p>

<p>I have some <code>UITextField</code> named ""lastNameTF"", and there is a <code>UILabel</code> name ""lastNameTitle"".</p>

<p>I wanna know if there is any way to set the <code>isHidden</code> value of lastNameTitle always be equal to <code>isHidden</code> value of lastNameTF using <code>RxSwift</code>.</p>
","3481741","","","","","2018-07-23 12:00:01","RxSwift - make one UI element hidden/not hidden according to other element","<swift><rx-swift><rx-cocoa>","3","0","","","","CC BY-SA 4.0"
"51330906","1","51352816","","2018-07-13 18:22:31","","4","2461","<p>I have a <code>UITextField</code> called <strong>commentField</strong> and I create an <code>Observable&lt;Bool&gt;</code> like this:</p>

<pre><code>let isCommentFieldValid = self.commentField.rx.text.orEmpty.map({ !$0.isEmpty })
</code></pre>

<p>This observable determines whether a button is enabled or not.
The problem is that when I change the text property of <code>commentField</code> liked this:</p>

<pre><code>self.commentField.text = """"
</code></pre>

<p>The <strong>isCommentFieldValid</strong> doesn't trigger again and, thus, the button's state doesn't change. Any edition using the UI works: if I remove all text from the field through the keyboard, the <strong>isCommentFieldValid</strong> updates, but via code it doesn't.</p>

<p>Is there a reason this doesn't work?</p>
","9323816","","","","","2018-07-15 22:57:41","Changing the text of a UITextField does not trigger the rx.text binder","<swift><rx-swift><rx-cocoa>","1","0","1","","","CC BY-SA 4.0"
"51342997","1","","","2018-07-14 20:11:34","","0","39","<p>In my app I have a view that is dependent upon a value in persistent storage. The first time in a session (installing or opening after killing the app) the value is saved to persistent storage and rightfully displayed. However, if I sign out and sign back in (same session) the view does not include my value from persistent storage. </p>

<p>I have reason to believe that there's an issue with my subscription to the 'User' observable in the viewmodel but i'm unsure.</p>

<p>I inserted print statements and found that the closure to the .map function never even triggers in this case. Any thoughts?</p>

<p>MyViewController.swift</p>

<pre><code>let myView: MyView
private let viewModel: MyViewModel

override init() {
    ...
    viewModel = MyViewModel(...)
}

override func viewDidLoad(){
    ...
viewModel.potentialEarnings.drive(myView.rx.potentialEarnings).disposed(by: disposeBag)
}
</code></pre>

<p>MyViewModel.swift</p>

<pre><code>let potentialEarnings: Driver&lt;String&gt;

init() {
    ...
    potentialEarnings = User.currentUser(in: getBackgroundContext).map({
      user -&gt; String? in
      let earnings = user.potentialEarnings
      return earnings
    }).unwrap().asDriver(onErrorJustReturn: """")
}
</code></pre>

<p>MyView.swift</p>

<pre><code>extension Reactive where Base : MyView {
 var potentialEarnings: Binder&lt;String&gt; {
  return Binder(self.base) { myView, potentialEarnings in
    myView.topLabel.text = ""Some Text with: \(potentialEarnings)""
  }
 }
}
</code></pre>
","5725580","","1113632","","2018-08-02 15:34:28","2018-08-09 12:38:58","Observable not responding to .drive method","<ios><swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"51344309","1","51349884","","2018-07-15 00:05:30","","2","1415","<p>I have a textfield to validate, I want to disable a button whenever user is typing. After user stops typing (debounce by 1 second), the validation is carried out and the button is conditionally enabled based on the result. Notice the corner case when user typed only one character, validation should still happen.</p>

<pre><code>--""a""-""ab""-""abc""------------------""ab""--""a""------------------""ab""-----------------

--false---------validate(""abc"")---false----validate(""a"")-----false--validate(""ab"")
</code></pre>

<p>This SO (<a href=""https://stackoverflow.com/questions/30140044/deliver-the-first-item-immediately-debounce-following-items"">Deliver the first item immediately, &#39;debounce&#39; following items</a>) proposes the following solution in RxJava. But it seems only returns the very first element, not when user starts typing again after debounce? Correct me if I am wrong</p>

<pre><code>Observable.from(items).publish(publishedItems -&gt; 
    publishedItems.limit(1).concatWith(
        publishedItems.skip(1).debounce(1, TimeUnit.SECONDS)
    )
)
</code></pre>
","3808183","","9165148","","2018-07-15 04:08:15","2018-07-16 00:57:08","RxSwift: Deliver the first item immediately, debounce following items","<ios><swift><rx-swift><rx-cocoa>","2","2","1","","","CC BY-SA 4.0"
"51344397","1","51363928","","2018-07-15 00:30:14","","1","243","<p>Previously I had this question regarding the awesome rxAndroidBle - <a href=""https://stackoverflow.com/questions/50937923/writing-multiple-commands-to-characteristic/50946398#50946398"">Writing multiple commands to characteristic</a></p>

<p>The solution works great!</p>

<p>Now the time has come to port this app over to an iOS version and I am struggling to find a suitable way to achieve the same result.</p>

<p>Basically I need to send a series of commands, in sequence to the peripheral, the commands need to send in order and the next command should send when the previous has completed, ideally with a final event when all commands have been sent, just like in the android app snippet in the above link</p>

<p>The below code does the job but as you see it is not pretty and also can easily become unmanageable as the quantity of commands grows!</p>

<p>The android app uses Single.concat, what is the equivalent for RxSwift?</p>

<pre><code>self.writeCharacteristic?.writeValue(command1, type: .withResponse)
        .subscribe {
            print(""Command 1 complete "", $0 )
            self.writeCharacteristic?.writeValue(command2, type: .withResponse)
                .subscribe {
                    print(""command2 complete "", $0 )

            }
    }
</code></pre>

<p>Any pointers greatly appreciated!!!
thank you</p>
","5054817","","","","","2018-07-16 14:17:09","Chaining multiple commands in RxBluetoothKit","<swift><rx-swift><rxandroidble><rxbluetooth>","1","1","","","","CC BY-SA 4.0"
"51363282","1","52313166","","2018-07-16 13:42:16","","0","1502","<p>I'm trying to implement a MVVM login screen using RxSwift and encountered some difficulties.</p>

<p>My login screen (user, password, login button) transitions to a camera view screen, where the app checks for camera permissions, and if those are not approved, logs the user out and returns to the login screen.</p>

<p>I have a <code>loginAction</code> in my <code>LoginViewModel</code> that returns an <code>Action&lt;Void, LoginResult&gt;</code>, where <code>LoginResult</code> is a <a href=""https://github.com/antitypical/Result"" rel=""nofollow noreferrer""><code>Result&lt;Bool, Error&gt;</code></a> and my <code>loginProvider</code> service returns an <code>Observable&lt;LoginResult&gt;</code>:</p>

<pre><code>struct LoginViewModel {

let sceneCoordinator: SceneCoordinatorType
let loginProvider: LoginProviderType

var usernameText = Variable&lt;String&gt;("""")
var passwordText = Variable&lt;String&gt;("""")

var isValid: Observable&lt;Bool&gt; {
    return Observable.combineLatest(usernameText.asObservable(), passwordText.asObservable()) { username, password in
        username.count &gt; 0 &amp;&amp; password.count &gt; 0
    }
}

init(loginProvider: LoginProvider, coordinator: SceneCoordinatorType) {
    self.loginProvider = loginProvider
    self.sceneCoordinator = coordinator
}

lazy var loginAction: Action&lt;Void, LoginResult&gt; = { (coordinator: SceneCoordinatorType, service: LoginProviderType, username: String, password: String) in
    return Action&lt;Void, LoginResult&gt;(enabledIf: self.isValid) { _ in
        return service.login(username: username, password: password)
            .observeOn(MainScheduler.instance)
            .do(onNext: { result in
                guard let loggedIn = result.value else { return }
                if loggedIn {
                    let cameraViewModel = CameraViewModel(coordinator: coordinator)
                    coordinator.transition(to: Scene.camera(cameraViewModel), type: .modal)
    }
}(self.sceneCoordinator, self.loginProvider, self.companyText.value, self.usernameText.value, self.passwordText.value)
}
</code></pre>

<p>Everything works fine, valid input logs in successfully (<code>loginProvider</code> sends the request the my server, get the response and handles all additional steps accordingly).</p>

<p>In case that the user doesn't grant camera permissions, I have a <code>Observable</code> for that in my <code>CameraViewModel</code> which I bind to my <code>CameraViewController</code>, subscribe to and in case needed, log the user out and pop the view back to the login screen using <code>CocoaAction</code> that pops the current view (using a scene coordinator class).</p>

<p>Problem is, when I try to log in again after transitioning back to the Login screen, the subscription for the elements emitted by the <code>loginAction</code> doesn't receive any elements.</p>

<p>Here's the code for the <code>LoginViewController</code>:</p>

<pre><code>class LoginViewController: UIViewController, BindableType {

var viewModel: LoginViewModel!

private let disposeBag = DisposeBag()

private var loginAction: Action&lt;Void, LoginResult&gt;!

@IBOutlet weak var usernameTextField: UITextField!
@IBOutlet weak var passwordTextField: UITextField!
@IBOutlet weak var loginButton: UIButton!
@IBOutlet weak var loadingIndicator: UIActivityIndicatorView!


private var usernameObservable: Observable&lt;String&gt; {
    return usernameTextField.rx.text
        .throttle(0.5, scheduler: MainScheduler.instance)
        .map() { text in
            return text ?? """"
    }
}

private var passwordObservable: Observable&lt;String&gt; {
    return passwordTextField.rx.text
        .throttle(0.5, scheduler: MainScheduler.instance)
        .map() { text in
            return text ?? """"
    }
}

override func viewDidLoad() {
    super.viewDidLoad()

}

func bindViewModel() {

    usernameObservable
        .bind(to: viewModel.usernameText)
        .disposed(by: disposeBag)

    passwordObservable
        .debug()
        .bind(to: viewModel.passwordText)
        .disposed(by: disposeBag)

    loginAction = viewModel.loginAction

    loginAction.elements
        .subscribe(onNext: { [weak self] result in
            self?.loadingIndicator.stopAnimating()
            var message = """"
            switch result {
            case  .failure(.unknownError):
                message = ""unknown error""
            case .failure(.wrongCredentials):
                message = ""wrong credentials""
            case .failure(.serviceUnavailable):
                message = ""service unavailable""
            case let .success(loggedIn):
                return
            }
            self?.errorMessage(message: message)
    }).disposed(by: disposeBag)

    loginButton.rx.tap
        .subscribe(onNext: { [unowned self] in
                self.loadingIndicator.startAnimating()
                self.loginAction.execute(Void())
            })
    .disposed(by: disposeBag)

    viewModel.isValid
        .bind(to: loginButton.rx.isEnabled)
        .disposed(by: disposeBag)
}
</code></pre>

<p>I can see that tapping the login button produces the tap event, however the Action itself stops being called. Any idea what I'm missing?</p>
","6882203","","1113632","","2018-08-02 16:22:30","2018-09-13 12:22:09","RxSwift, binding Action to UIButton stops producing events after view transitions","<ios><swift><mvvm><action><rx-swift>","2","0","","","","CC BY-SA 4.0"
"51375543","1","","","2018-07-17 07:26:52","","1","527","<p>I've been running into this every now and then I'm always questioning myself whether I'm using RxSwift (or reactive means altogether) the wrong way.</p>

<p>The challenge is converting value types to something representable on the UI. </p>

<p>Usually on the lower level I'm storing data with simple types but I need something more stateful on the UI level. Just to give you an example, consider I have list of following types:</p>

<pre><code>struct Person {
    let firstName: String
    let lastName: String
}
</code></pre>

<p>On the UI, however, I'm binding view models created from these items into a <code>UITableView</code> instance. I could achieve this by simply mapping from one type to another:</p>

<pre><code>let displayedPersons = listOfPersons.map { PersonViewModel($0) }
</code></pre>

<p>This would make all items to be recreated on each update which I'm trying to avoid. I'm using MVVM and would like to keep the view model instances due to their transient state. Reloading table view on each update would also mess up animations.</p>

<p>I'm thinking if a custom binding could help here, binding one observable to another with cached mapping. Another solution that I've ended up doing is simply looping the observable so that when mapping, I get the previous value which I'll use as a cache.</p>

<p>Effectively I would need to map only the new items and keep the existing ones. Any ideas how would I achieve this?</p>
","194350","","1113632","","2018-08-02 17:53:18","2018-08-08 19:43:41","Map a list of one type to another in RxSwift but keep existing ones","<swift><rx-swift><reactivex>","2","0","1","","","CC BY-SA 4.0"
"51394725","1","","","2018-07-18 06:12:09","","5","2201","<p>I'm working on an iOS project with RxSwift and I use the MVVM with coordinators pattern.</p>

<p>Here my implementation:</p>

<p><em>ViewModel:</em></p>

<pre><code>// MARK: - Private

private let showNextViewSubject = PublishSubject&lt;Void&gt;()

// MARK: - Inputs

var showNextView: AnyObserver&lt;Void&gt; {
    return showNextViewSubject.asObserver()
}

// MARK: - Outputs

var didShowNextView: Observable&lt;Void&gt; {
    return showNextViewSubject.asObservable()
}
</code></pre>

<p><em>ViewController:</em></p>

<pre><code>private func bindButton() {
    _ = button.rx.tap
        .bind(to: viewModel.showNextView)
        .disposed(by: disposeBag)
}
</code></pre>

<p><em>Coordinator:</em></p>

<pre><code>self.viewModel.didShowNextView
        .subscribe(onNext: { [weak self] _ in
            self?.showNextView()
        })
        .disposed(by: disposeBag)
</code></pre>

<p>My problem is with the <code>[weak self] _</code> in the coordinator: when I add it, <code>self?.showNextView()</code> is never called, but this works well when I remove it.</p>

<p>Do you know why?</p>

<p>Thanks,
Romain</p>
","6748318","","","","","2018-11-30 12:09:14","MVVM-C with RxSwift: '[weak self]' in closure","<swift><mvvm><rx-swift>","4","0","1","","","CC BY-SA 4.0"
"51439213","1","","","2018-07-20 09:19:03","","0","91","<p>I use RxSwift. This func returns Observable</p>

<pre><code>func getDeviceInfo(_ deviceId: Int) -&gt; Observable&lt;DeviceInfo&gt; {
    return Observable.create { o in
        self.getInfo(deviceId, onSuccess: { data in
            o.onNext(data)
            o.onCompleted()
        }, onFail: { error in
            o.onError(error)
        })
        return Disposables.create()
    }
}
</code></pre>

<p>then I subscribe to it</p>

<pre><code>repository.getDeviceInfo(deviceId)
            .subscribe(onNext: { (info) in 
                print(""onNext"")
            }, onError: { (error) in
                print(""onError"")
            }, onCompleted: {
                print(""onCompleted"")
            }, onDisposed: {
                print(""onDisposed"")
            })
</code></pre>

<p>First time I get true result. But when I call subscribe() second time, third and etc. no subscribe's callbacks are called (onNext, onError, onCompleted, onDisposed).
After debug I found that o.onNext(data), o.onCompleted() in getDeviceInfo() are called but subscribe's callbacks don't receive any data. 
I debugged the next line in Create.swift file inside RxSwift</p>

<pre><code>let sink = AnonymousObservableSink(observer: observer, cancel: cancel)
</code></pre>

<p>AnonymousObservableSink class some code, it's not Singelton:</p>

<pre><code>final fileprivate class AnonymousObservableSink&lt;O: ObserverType&gt; : Sink&lt;O&gt;, ObserverType {

override init(observer: O, cancel: Cancelable) {
    super.init(observer: observer, cancel: cancel)
}
</code></pre>

<p>but each time the reference <code>let sink</code> was the same. So can init() func returns early created object sometimes?</p>
","10109758","","","","","2018-07-20 09:19:03","Can Swift init() returns previously created object?","<swift><initialization><rx-swift>","0","5","","","","CC BY-SA 4.0"
"51451219","1","51457358","","2018-07-20 22:39:48","","0","152","<p>I was using following code bind <code>statusBarStyle</code>.</p>

<pre><code>public extension Reactive where Base: UIApplication {

    public var statusBarStyle: Binder&lt;UIStatusBarStyle&gt; {
        return Binder(self.base) { view, attr in
            view.statusBarStyle = attr
        }
    }

}
</code></pre>

<p>However this property is deprecated with iOS 9. New document suggests to override <code>preferredStatusBarStyle</code> in view controllers. How can I bind this property?</p>
","4170419","","","","","2018-07-21 19:55:20","Is there a way yo bind preferredStatusBarStyle with RxCocoa?","<swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"51462312","1","","","2018-07-22 05:27:55","","0","425","<p>I have to use ReplaySubject in my project like that:</p>

<pre><code>let myVariable = ReplaySubject&lt;[MyItems]&gt;.create(bufferSize: myBufferSize)
</code></pre>

<p>How can I get the number of items in the array of ""MyItems""?</p>
","3794462","","1113632","","2018-08-02 19:58:10","2018-08-02 19:58:10","Get number of items in a ReplaySubject with Array Element","<swift><rx-swift><subject><replay>","1","0","","","","CC BY-SA 4.0"
"51463206","1","","","2018-07-22 08:12:58","","1","605","<p>I have this method return User observable</p>

<pre><code>  internal func getUser() -&gt; Observable&lt;User&gt; {
    let result = withRealm(""getting user"") { realm -&gt; Observable&lt;User&gt; in
      let realm = try Realm()
      let user = realm.objects(User.self).first
      return Observable.from(optional: user)
    }
    return result ?? .empty()
  }
</code></pre>

<p>Now i want to have another method that returns me if user is loggedin, how it will be done?</p>

<pre><code>  private var _isLoggedIn: Observable&lt;User&gt; {

    return getUser().count &gt; 0 //error

  }
</code></pre>
","1531657","","1113632","","2018-08-02 13:46:03","2018-08-02 13:46:03","How to check Observable count in rxswift?","<swift><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"51465089","1","51465238","","2018-07-22 12:21:17","","6","16712","<p>I'd like to achieve the following in code:</p>

<pre><code>class MyService {

    let mySubject = BehaviorSubject&lt;MyData&gt;(value: nil)

    //....

}
</code></pre>

<p>Unfortunately I get the ""nil requires a contextual type"" error. I want the subject to be ""empty"" till I actually put something in there. How can I pass nil as the argument then? Can I cast it to my own type to make it work?</p>
","2710256","","9223839","","2018-07-22 12:37:55","2018-07-23 12:04:33","Swift: nil requires a contextual type","<ios><swift><xcode><rx-swift>","2","1","","","","CC BY-SA 4.0"
"51503551","1","","","2018-07-24 16:29:54","","0","322","<p>Is there a form of <code>buffer</code> that doesn't continuously poll with a timer? Performance really takes a hit because of it. Ideally, <code>buffer</code> would wait <em>n</em> seconds before producing values and then not set a new timer until receiving a new event.</p>
","832831","","1113632","","2018-08-02 14:35:39","2018-08-04 16:21:09","RxSwift Buffer Performance","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"51518180","1","51519768","","2018-07-25 11:49:53","","2","8175","<p>I am fairly new to Rx and to Reactive Programming in general. I am simply trying to make things work. I'm trying to populate an object after a request to an API (Github's API for the matter):</p>

<p>The object to populate :</p>

<pre><code>class GithubUser {
    var login: String?
    var joinDate: Date?
    var email: String?
}
</code></pre>

<p>The way I try to feed it:</p>

<pre><code>class GithubUserRepository {
    static func getUser() -&gt; Observable&lt;GithubUser&gt; {
        let userObservable = BehaviorRelay&lt;GithubUser&gt;(value: GithubUser())
        let login = ""Thiryn""
        // GithubService.sharedInstance.getUser does whatever async call to the github API to get a user profile
        GithubService.sharedInstance.getUser(login, success: { (userProfile) in
            userObservable.value.login = login
            userObservable.value.email = userProfile.email
            userObservable.value.joinDate = userProfile.joinedDate
        }) { (error) in
            print(error.localizedDescription)
        }
        return userObservable.asObservable()
    }
}
</code></pre>

<p>And how I try to consume</p>

<pre><code>class ViewController: UIViewController {

    let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()
        GithubUserRepository.getUser().subscribe(onNext: { (user) in
            print(user.login ?? ""nope"")
        }).disposed(by: self.disposeBag)
    }
}
</code></pre>

<p>The result is that I a ""nope"" the first time, before the request get executed, then I successfully get a result from my request, change the value of the object, but I might do something wrong as the subscribed function is never executed after.
Any thoughts? Thanks!</p>

<p>Edit : I based my try on the <a href=""https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Examples.md#reactive-values"" rel=""nofollow noreferrer"">Reactive Values example from RxSwift</a></p>
","3738152","","3738152","","2018-07-25 11:57:12","2018-07-25 13:33:08","Rxswift change value of observed object","<swift><observable><rx-swift><subscribe>","3","0","1","","","CC BY-SA 4.0"
"51524767","1","","","2018-07-25 17:38:30","","1","226","<p>I am trying RxDataSources <a href=""https://github.com/RxSwiftCommunity/RxDataSources"" rel=""nofollow noreferrer"">https://github.com/RxSwiftCommunity/RxDataSources</a> for simple TableView</p>

<pre><code>class ViewController: UIViewController {

    @IBOutlet weak var tableView: UITableView!
    let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        let items = [
            CustomItem(id: 12, title: ""name""),
            CustomItem(id: 22, title: ""your age""),
            CustomItem(id: 77, title: ""style"")
        ]

        let data = Observable&lt;[CustomItem]&gt;.just(items)

        data.bind(to: tableView.rx.items(cellIdentifier: ""CustomCell"", cellType: CustomCell)) {
            index, model, cell in
            cell.questionLbl.text = model
            }
            .disposed(by: disposeBag)
    }

}

class CustomCell: UITableViewCell {
    @IBOutlet weak var questionLbl: UILabel!
}

struct CustomItem: Equatable {
    let id: Int
    let title: String

    static func == (lhs: CustomItem, rhs: CustomItem) -&gt; Bool {
        return lhs.id == rhs.id
    }
}
</code></pre>

<p>And I got this error:</p>

<blockquote>
  <p>Generic parameter 'Self' could not be inferred</p>
</blockquote>

<p>p.s. as you see - I added Equatable to my struct but it also not working. same time if I change array of custom object to array of Strings, everything starts to work fine.</p>
","1218405","","1218405","","2018-07-25 17:45:51","2018-07-25 17:45:51","Generic parameter 'Self' could not be inferred in RxDataSources","<ios><swift><rx-swift><rx-cocoa>","0","0","","2018-07-25 17:48:39","","CC BY-SA 4.0"
"51525379","1","","","2018-07-25 18:19:48","","0","241","<pre><code>// Transform a stream of [Int] where the chunks are received in bursts into a continuous stream of metric values
//
//   Example:
//
//      Original:      &lt;-----[Int32][Int32][Int32]------------------[Int32][Int32][Int32]----------------[Int32][Int32][Int32]-----------&gt;
//      Transformed:   &lt;-----Int32-Int32-Int32-Int32-Int32-Int32-Int32-Int32-Int32-Int32-Int32-Int32-Int32-Int32-Int32-Int32-Int32-Int32-&gt;
//
</code></pre>

<p>Notes: </p>

<ul>
<li>Observable receives and Array of 250 points every 1 second</li>
<li>Want to smoothen this to distribute the points over that 1 second</li>
<li>Send them out to be used by the UI for graphing</li>
</ul>

<hr>

<p>RectiveSwift implementation: </p>

<p>extension SignalProducerProtocol where Value == [Double], Error == BioDemoError {</p>

<pre><code>func startAndFlattenBurstIntervalChunks(periodInMs: UInt, minTimeDeltaBetweenBurstsInMs: UInt64 = 500) -&gt; (Signal&lt;Double, NoError&gt;, Disposable) {

    let (individualValueSignal, individualValueObserver) = Signal&lt;Double, NoError&gt;.pipe()
    let compositeDisposable = CompositeDisposable()
    let valueBuffer = MutableProperty&lt;[Double]&gt;([])
    var timeOfLastChunk = Date() //first one doesn't matter

    func addChunkToBuffer(chunk: [Double]) {
        let currentTime = Date()
        valueBuffer.modify { buffer in

            // Only flush current buffer if this is the first chunk of a burst
            let shouldFlushCurrentBuffer = currentTime.millisecondsSinceUnixEpoch - timeOfLastChunk.millisecondsSinceUnixEpoch &gt; minTimeDeltaBetweenBurstsInMs

            if(shouldFlushCurrentBuffer) {
                buffer.forEach(individualValueObserver.send)
                buffer = chunk
            } else {
                buffer = buffer + chunk
            }

        }
        timeOfLastChunk = currentTime
    }

    func sendFirstBufferValue() {
        valueBuffer.modify { buffer in
            if let firstValue = buffer.first {
                individualValueObserver.send(value: firstValue)
                buffer = buffer.tail()
            }
        }
    }

    let periodTime = DispatchTimeInterval.milliseconds(Int(periodInMs))

    compositeDisposable.add(
        timer(interval: periodTime, on: QueueScheduler())
            .map { _ in () }
            .startWithValues(sendFirstBufferValue)
    )

    compositeDisposable.add(
        self
            .flatMapError { _ in SignalProducer&lt;[Double], NoError&gt;.never }
            .startWithValues(addChunkToBuffer)
    )

    return (individualValueSignal, compositeDisposable)

}
</code></pre>

<p>}</p>
","4486884","","4486884","","2018-07-25 18:25:58","2018-07-30 13:16:47","RxSwift smoothen Observable values","<ios><swift><rx-swift>","3","0","","","","CC BY-SA 4.0"
"51531589","1","","","2018-07-26 05:27:37","","1","259","<p>I'm trying to call a function after a successful completion of a mapping.
The observable is created from an existing stream by mapping. Inside the mapping block, I subscribe to get the output which is mapped to the final type. With the updated stream, I'm looking at calling the function. But the function gets called before I subscribe &amp; map it to the updated stream.</p>

<p>Here is a sample code:</p>

<pre><code>let updatedDataStream = dataStream
            .observeOn(MainScheduler.instance)
            .map { (data) -&gt; ViewData? in

            guard var unknownData = data as? UnknownDataType,
                let location = unknownData.dataPoints.first?.location else  {
                    return data
                }

                let dataModel = DataModel(x: location.x, y: location.y)

                self.dataStore.localStore?
                    .entity(forID: DataModel.entityID)
                    .filter({$0?.status == .Success})
                    .take(1)
                    .unwrap()
                    .subscribe(onNext: { (localDataModel) in

                        guard let value = localDataModel.dataValue, value.count &gt; 0 else {
                            return
                        }

                        unknownData.value = value

                    }).disposed(by: self.disposeBag)
                return unknownData
        }

        self.attachUpdatedData(updatedDataStream)
</code></pre>

<p><code>attachUpdatedData(_:)</code> is expected to be called only after we retrieve the updatedDataStream. With the above implementation <code>attachUpdatedData(_:)</code> is called first before the data is mapped to a new value. Can someone point me in the right direction?</p>
","1253102","","","","","2018-07-26 13:03:35","RxSwift - call sequence of a function after Mapping","<swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"51560074","1","51799639","","2018-07-27 14:27:27","","0","3824","<p>I'm using Moya Rx swift and i want to catch the response if the status code is 401 or 403 then call refresh token request then recall/retry the original request again and to do so i followed this <a href=""https://stackoverflow.com/questions/38281760/using-retrywhen-to-update-tokens-based-on-http-error-code"">Link</a> but i tweaked it a bit to suit my needs</p>
<pre><code>public extension ObservableType where E == Response {

/// Tries to refresh auth token on 401 errors and retry the request.
/// If the refresh fails, the signal errors.
public func retryWithAuthIfNeeded(sessionServiceDelegate : SessionProtocol) -&gt; Observable&lt;E&gt; {
    return self.retryWhen { (e: Observable&lt;Error&gt;) in
        return Observable
                .zip(e, Observable.range(start: 1, count: 3),resultSelector: { $1 })
                .flatMap { i in
                           return sessionServiceDelegate
                                    .getTokenObservable()?
                                    .filterSuccessfulStatusAndRedirectCodes()
                                    .mapString()
                                    .catchError {
                                        error in
                                            log.debug(&quot;ReAuth error: \(error)&quot;)
                                            if case Error.StatusCode(let response) = error {
                                                if response.statusCode == 401 || response.statusCode == 403 {
                                                    // Force logout after failed attempt
                                                    sessionServiceDelegate.doLogOut()
                                                }
                                            }
                                            return Observable.error(error)
                                    }
                                    .flatMapLatest({ responseString in
                                        sessionServiceDelegate.refreshToken(responseString: responseString)
                                        return Observable.just(responseString)
                                    })
        }}
    }
}
</code></pre>
<p>And my Protocol :</p>
<pre><code>import RxSwift

public protocol SessionProtocol {
    func doLogOut()
    func refreshToken(responseString : String)
    func getTokenObservable() -&gt; Observable&lt;Response&gt;? 
}
</code></pre>
<p>But it is not working and the code is not compiling, i get the following :</p>
<blockquote>
<p>'Observable' is not convertible to 'Observable&lt;_&gt;'</p>
</blockquote>
<p>I'm just talking my first steps to RX-swift so it may be simple but i can not figure out what is wrong except that i have to return a type other than the one I'm returning but i do not know how and where to do so.</p>
<p>Your help is much appreciated and if you have a better idea to achieve what I'm trying to do, you are welcome to suggest it.</p>
<p>Thanks in advance for your help.</p>
","6927433","","-1","","2020-06-20 09:12:55","2019-11-12 10:06:24","Moya rxswift : Refresh token and restart request","<ios><swift><rx-swift><refresh-token><moya>","3","2","0","","","CC BY-SA 4.0"
"51567825","1","51590405","","2018-07-28 03:40:28","","0","1730","<p>I am writing a wrapper around Firebase authentication functions to return <code>Observable</code> and add additional <code>profileIncomplete</code> state. It basically first checks whether a user is logged in, if so, check whether the user's profile is complete. The following is my code, I wonder whether it is okay to subscribe to an observable in <code>Observable.create</code> and, if so, how do I properly dispose the disposable in this case? create a <code>DisposeBag</code> inside the closure?</p>

<pre><code>enum State {
    case loggedIn
    case profileIncomplete
    case notLoggedIn
}

func listenToAuthState() -&gt; Observable&lt;State&gt; {
    return Observable.create { observable in
        let authStateHandle = Auth.auth().addStateDidChangeListener() { [weak self] (_, user) in
            guard let user = user else {
                observable.onNext(.notLoggedIn)
                return
            }
            let disposable = self?.listenToProfileCompleted(uid: user.uid).subscribe(onNext: { (completed) in
                if completed {
                    observable.onNext(.loggedIn)
                    observable.onCompleted()
                } else {
                    observable.onNext(.profileIncomplete)
                }
            })
            // How to dispose the disposable???
        }
        return Disposables.create { 
            Auth.auth().removeStateDidChangeListener(authStateHandle) }
        }
}

func listenToProfileCompleted(uid: String) -&gt; Observable&lt;Bool&gt; { ... }
</code></pre>
","3808183","","","","","2018-07-30 09:03:58","RxSwift properly dispose subscription in closure","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"51620192","1","","","2018-07-31 18:51:26","","3","5568","<p>This is a tableView in RxSwift
I am not able to configure the dataSource. There seems to be parameters missing for RxTableViewSectionedReloadDataSource, although this is strange as I follow the exact same code source of the <a href=""https://github.com/RxSwiftCommunity/RxDataSources"" rel=""nofollow noreferrer"">official docs</a></p>

<p><a href=""https://i.stack.imgur.com/uO8Ko.png"" rel=""nofollow noreferrer"">Xcode error</a>
Whenever I hit enter to autocomplete the closure. The closure remains blank.</p>

<p><a href=""https://i.stack.imgur.com/MY8Z8.png"" rel=""nofollow noreferrer"">autocomplet not effectiv </a>
I really don't know how to resolve this one</p>

<pre><code>  let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&gt;() 



dataSource?.configureCell = { (ds: RxTableViewSectionedReloadDataSource&lt;SectionOfCustomData&gt;, tv: UITableView, ip: IndexPath, item: Article) -&gt; NewsFeedCell in
                let cell = tv.dequeueReusableCell(withIdentifier: ""Cell"", for: ip) as! NewsFeedCell
                cell.configure(news: item)
                return cell
            }
            dataSource?.titleForHeaderInSection = { ds, index in
                return ds.sectionModels[index].header
            }

    let sections = [
        SectionOfCustomData(header: ""First section"", items: self.articles),
        SectionOfCustomData(header: ""Second section"", items: self.articles)
        ]

            guard let dtSource = dataSource else {
                return
            }
            Observable.just(sections)
                .bind(to: tableView.rx.items(dataSource: dtSource))
                .disposed(by: bag)

        }
</code></pre>

<p>SectionModel.swift</p>

<pre><code>import Foundation
import RxSwift
import RxCocoa
import RxDataSources

struct SectionOfCustomData {
    var header: String
    var items: [Item]
}
extension SectionOfCustomData: SectionModelType {
    typealias Item = Article

    init(original: SectionOfCustomData, items: [Item]) {
        self = original
        self.items = items
    }
}
</code></pre>
","10162147","","1113632","","2018-08-02 14:18:27","2019-07-23 11:03:20","RxTableViewSectionedReloadDataSource","<swift><rx-swift><rxdatasources>","2","1","1","","","CC BY-SA 4.0"
"51624130","1","","","2018-08-01 01:25:43","","1","697","<p>I have two <code>UITextField</code> and one <code>UITableView</code> in one <code>UIViewController</code>. The ViewModel of this <code>UIViewController</code> exposes one Observable to be the table view datasouce. The two <code>UITextField</code> take the parameters from users and refresh the table view Observable. <code>UITextField</code> are using <code>UIPickerView</code> as InputView and those <code>UIPickerViews</code> are using a custom class as the adapter.</p>

<p>In UIViewController:</p>

<pre><code>//bind the adapter to the UIPickerView
self.viewModel.dateList.bind(to: self.datePickerView.rx.items(adapter: self.viewModel.pickerViewAdapter)).disposed(by: rx.disposeBag)
</code></pre>

<p>In ViewModel:</p>

<pre><code>let dateList = Observable.just([[Int](0...1), [Int](1...12)])

final class PickerViewViewAdapter
    : NSObject
    , UIPickerViewDataSource
    , UIPickerViewDelegate
    , RxPickerViewDataSourceType
, SectionedViewDataSourceType {
    typealias Element = [[Int]]
    private var items: [[Int]] = []

    var activeTextField:UITextField!

    func model(at indexPath: IndexPath) throws -&gt; Any {
        return items[indexPath.section][indexPath.row]
    }

    func numberOfComponents(in pickerView: UIPickerView) -&gt; Int {
        return items.count
    }

    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int {
        return items[component].count
    }

    func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -&gt; UIView {
        let label = UILabel()


        if component == 0{
            label.text = ""\(2018 - items[component][row])""
        }else{
            label.text = ""\(items[component][row])""
        }

        label.font = UIFont.preferredFont(forTextStyle: .title1)
        label.textAlignment = .center
        return label
    }

    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int){
///
/// Need to update the UITextField.text in a specific form
///
        }

    func pickerView(_ pickerView: UIPickerView, observedEvent: Event&lt;Element&gt;) {
        Binder(self) { (adapter, items) in
            adapter.items = items
            pickerView.reloadAllComponents()
            }.on(observedEvent)
    }
}
</code></pre>

<p>After the user select from <code>UIPickerView</code> I need to update the <code>UITextField.text</code> in a specific form, and then use those text as the parameters for the API.</p>

<p><strong>How should I do this in a Reactive way in MVVM?</strong></p>
","7821937","","8516782","","2018-08-01 04:52:45","2018-08-12 02:38:56","RxSwift MVVM implemention inquire","<ios><swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"51633300","1","51667819","","2018-08-01 12:26:50","","0","4215","<p>Setup: <code>RxSwift 4.2</code> <code>Swift 4.1</code> <code>Xcode 9.4.1</code></p>

<p>I'm currently using <code>distinctUntilChanged</code> to get unique values.
But in my case it's only working for ""sorted"" values.</p>

<p>Like for example here:</p>

<pre><code>func unique(source: Observable&lt;Int&gt;) -&gt; Observable&lt;Int&gt; {
    return source.distinctUntilChanged()
}
</code></pre>

<p>Here is the corresponding test:</p>

<pre><code>func testUnique() {
    let input = Observable.from([1,2,3,4,4,5,4])
    let expectation = [Recorded.next(0, 1),
                       Recorded.next(0, 2),
                       Recorded.next(0, 3),
                       Recorded.next(0, 4),
                       Recorded.next(0, 5),
                       Recorded.completed(0)]

    _ = Class().unique(source: input).subscribe(observer)

    XCTAssertEqual(observer.events, expectation)
}
</code></pre>

<p>And my test is failing with:</p>

<pre><code>XCTAssertEqual failed: (""[next(1) @ 0, next(2) @ 0, next(3) @ 0, next(4) @ 0, next(5) @ 0, next(4) @ 0, completed @ 0]"")
is not equal to (""[next(1) @ 0, next(2) @ 0, next(3) @ 0, next(4) @ 0, next(5) @ 0, completed @ 0]"") - 
</code></pre>

<p>So the last <code>4</code> is a duplicate.<br>
Is this behavior expected or a bug?</p>
","1501847","","","","","2018-08-06 07:22:07","Observable distinctUntilChanged returns duplicates","<ios><swift><rx-swift>","3","0","","","","CC BY-SA 4.0"
"51647456","1","","","2018-08-02 07:05:17","","4","1990","<p>I've started learning RxSwift, but can't understand some moments. I have to create a button after performing a request. Like this:</p>

<pre><code>textField.rx.text
    .flatMapLatest { text in
        return performURLRequest(text)
    }
    .subscribe(onNext: { request in

        // Create a button
        let button = UIButton()
        button.rx.tap
            .subscribe({ _ in

                // Action

            }).disposed(by: self.disposeBag)
        self.view.addSubview(button)
    })
    .disposed(by: disposeBag)
</code></pre>

<p>How can I avoid nesting subscribe calls? Because of this code smell.</p>
","4314758","","4149826","","2018-08-08 13:18:36","2018-08-09 08:52:53","Nesting subscribe calls in RxSwift","<ios><swift><nested><rx-swift>","2","0","1","","","CC BY-SA 4.0"
"51652030","1","55402319","","2018-08-02 11:03:14","","1","375","<p>This is how I subscribe for tap action on <code>UIButton</code>:</p>

<pre><code>_ = mainView.loginButton.rx.tap.subscribe { _ in
    //this is not called at all
}
</code></pre>

<p>and now I need to force that action to check if my dependencies work great, but subscribe handler is not called.</p>

<pre><code>func testRouterDidCallWithError() {
    let view = LoginView()
    let controller = LoginViewController(view: view)
    controller.loadView()
    view.loginButton.sendActions(for: .touchUpInside) //here is the point
}
</code></pre>
","2725435","","65694","","2019-03-28 16:14:31","2019-03-28 16:14:31","How to force tap on UIButton using RxSwift?","<ios><swift><testing><rx-swift>","1","0","","","","CC BY-SA 4.0"
"51666444","1","","","2018-08-03 06:23:09","","0","1309","<p>I have service method for login to facebook that have one parameter of type View Controller. I user RxSwift and MVVM. In View Controller I bind button tap to view model's observer and subscribe to it for invoke service inside. How I can send parameter view controller to view model for sending to my service? </p>

<p>Here is the problem exactly </p>

<p><strong><em>self.authService.signInWithFacebook(from: ???)</em></strong></p>

<pre><code>class AuthService: AuthServiceType {
 // ...

  func signInWithFacebook(from: UIViewController?) -&gt; Observable&lt;Result&lt;Void, FirebaseLoginError&gt;&gt; {
     // ...
    }

 // ...
}


class LoginViewModel {

    let facebookLoginDidTapObserver: AnyObserver&lt;Void&gt;

    let facebookLoginDidTapObservable: Observable&lt;Void&gt;

    private let authService: AuthServiceType

    init(authService: AuthServiceType = AuthService()) {

        self.authService = authService

        let facebookLoginDidTap = PublishSubject&lt;Void&gt;()
        facebookLoginDidTapObserver = facebookLoginDidTap.asObserver()
        facebookLoginDidTapObservable = facebookLoginDidTap.asObservable()

        facebookLoginDidTapObservable
            .throttle(0.5, scheduler: MainScheduler.instance)
            .subscribe(onNext: { tap in

                return self.authService.signInWithFacebook(from: ???)
            })
            .disposed(by: disposeBag)
    }

}


class LoginViewController: UIViewController {

    facebookLoginButton.rx
        .tap
        .bind(to: viewModel.facebookLoginDidTapObserver)
        .disposed(by: disposeBag) 


} 
</code></pre>
","6223191","","","","","2018-08-03 07:52:20","How send parameter to view model with RxSwift in MVVM architecture?","<swift><mvvm><facebook-ios-sdk><rx-swift><reactive>","1","0","","","","CC BY-SA 4.0"
"51668484","1","51668657","","2018-08-03 08:35:42","","3","1179","<p>This is what I simply try to achieve using:</p>

<pre><code>let observable = Observable.combineLatest(loginProperty.asObservable(), passwordProperty.asObservable()) { _,_ in
    self.viewModel.isValid
}
observable.bind(to: mainView.loginButton.rx.isEnabled).disposed(by: disposeBag)
//observable.bind(to: mainView.loginButton.rx.alpha).disposed(by: disposeBag)
</code></pre>

<p>But this can be bound only to <code>isEnabled</code> property. I would like to also change alpha of my <code>loginButton</code>. How can I do that?</p>
","2725435","","","","","2018-08-03 09:32:12","How to change isEnabled and alpha properties of UIButton base on validation using RXSwift?","<ios><swift><rx-swift>","1","4","","","","CC BY-SA 4.0"
"51678150","1","","","2018-08-03 18:21:48","","0","364","<p>I was looking for an easier way to pass function as parameter into Observable's <code>subscribe</code> method without causing retain cycle; I don't want to always have to use <code>[weak self]</code> every single time. I've just come across this <a href=""https://github.com/RxSwiftCommunity/RxSwiftExt/issues/14"" rel=""nofollow noreferrer"">answer</a>, and it's exactly what I want. Even better, it's already being merged into the framework itself. However, I don't seem to find a similar method for <code>Driver</code>.</p>

<p>Has it already been implemented, and I'm just looking at the wrong place? If not, can you guide me how to add it? ... As a side note, how do you normally deal with all the <code>[weak self]</code> everywhere?</p>
","617704","","","","","2018-08-12 01:00:59","RxSwift Driver weakly subscription?","<ios><swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"51681458","1","","","2018-08-04 00:26:02","","0","378","<p>how can I share one API call? For example, I have the following Model class. The properties will bind to different UI components.  I am implementing this in the ViewController. But, I think I should not expose the Model to the View layer. Instead, I should give the ViewController two Observable properties to bind. One is for UITextField, the other is for the UITableView. So, how should I create more than one Observable from an Observable?</p>

<pre><code>struct CustomerListJSON : Codable {
    var UserCount:Int?
    var TotalReward:Int?
    var CurMonthUserCount:Int?
    var CurMonthTotalReward:Int?
    var CurYearUserCount:Int?
    var CurYearTotalReward:Int?
    var UserList:[CustomerJSON]?
}

let getSummery = self.viewModel.getSummery()

getSummery.flatMap{ [weak self](summery) -&gt;  Observable&lt;[CustomerJSON]&gt; in

//Label datesource
            self?.summeryLabel.text = "" \(summery.UserCount ?? 0)\t \(summery.TotalReward ?? 0)\n \(summery.CurMonthUserCount ?? 0)\t \(summery.CurMonthTotalReward ?? 0)\n \(summery.CurYearUserCount ?? 0)\t\(summery.CurYearTotalReward ?? 0)""

            return Observable.of(summery.UserList ?? [])
//Table datasource
        }.bind(to: self.tableView.rx.items(cellIdentifier: ""customerCell"", cellType: UITableViewCell.self)){ (index, customer, cell) in
            cell.textLabel?.text = ""\(customer.UserName ?? """")\t\t\(customer.CreateTime ?? """")""
        }.disposed(by: rx.disposeBag)
</code></pre>
","7821937","","","","","2018-08-04 12:19:42","RxSwift create multiple Observable from One","<ios><swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"51691824","1","","","2018-08-05 06:08:53","","0","99","<p>[Sample code]</p>

<pre><code>let persons = Variable&lt;[[String: Any]]&gt; = Variable([
    [
        [
            ""name"": ""John Smith""
        ]
    ]
])

persons.first![""name""] = ""Joe Smith""
</code></pre>

<p>Can we observe changes to <strong>persons</strong>?</p>

<p>Or we need to set a value again? Just to emit, like this.</p>

<pre><code>persons.value = persons.value
</code></pre>

<p>By the way I'm new in RxSwift.</p>
","6378885","","","","","2018-08-06 18:51:35","Is there a way in RxSwift to observe changes inside an array w/o setting a new value?","<ios><rx-swift>","1","2","","","","CC BY-SA 4.0"
"51694778","1","51743877","","2018-08-05 13:32:53","","5","6482","<p>Now I need to change the app theme(colors) based on configuration API, So I am using RxCocoa, RxSwift frameworks to create observable on each view controller to apply a new theme on the app.</p>

<p>My question is what is the best practice for using DisposeBag:</p>

<ul>
<li>Create new DisposeBag object on each view controller?</li>
<li>Or use one global DisposeBag for all observables?</li>
</ul>

<p>Thanks in advance</p>
","8476915","","4149826","","2018-08-08 10:23:32","2019-01-22 11:27:09","RxSwift: What is the best practice to use DisposeBag?","<swift><rx-swift><rx-cocoa>","2","0","2","","","CC BY-SA 4.0"
"51722547","1","51737592","","2018-08-07 08:46:55","","3","4228","<p>I create a generic variable. This variable can be connected to a textField or an other interface element like a switch, for example. So the type of my variable will be Any so that I can store a bool, a string or something else.</p>

<pre><code>var test: BehaviorRelay&lt;Any?&gt; = BehaviorRelay&lt;Any?&gt;(value: nil)
</code></pre>

<p>Then I try to connect my interface elements to this variable </p>

<pre><code>(self.switch.rx.value &lt;-&gt; viewModel.test).disposed(by: self.disposeBag)
</code></pre>

<p>Or</p>

<pre><code>(self.textfield.rx.text &lt;-&gt; viewModel.test).disposed(by: self.disposeBag)
</code></pre>

<p>with this error <code>Cannot convert value of type 'BehaviorRelay&lt;Any?&gt;' to expected argument type 'BehaviorRelay&lt;Bool&gt;'</code> or <code>Cannot convert value of type 'BehaviorRelay&lt;Any?&gt;' to expected argument type 'BehaviorRelay&lt;String?&gt;'</code></p>

<p>How can I do this with RxSwift?</p>

<p>You can find here my &lt;-> func:</p>

<pre><code>infix operator &lt;-&gt;
func &lt;-&gt; &lt;T&gt;(property: ControlProperty&lt;T&gt;, variable: BehaviorRelay&lt;T&gt;) -&gt; Disposable {        
    let bindToUIDisposable = variable.asObservable()
        .bind(to: property)
    let bindToVariable = property
        .subscribe(onNext: { n in
            variable.accept(n)
        }, onCompleted:  {
            bindToUIDisposable.dispose()
        })

    return Disposables.create(bindToUIDisposable, bindToVariable)
}
</code></pre>
","1175120","","4149826","","2018-08-07 14:47:43","2018-08-08 01:55:26","RxSwift Two way binding with a BehaviorRelay<Any?>","<swift><binding><rx-swift>","1","3","","","","CC BY-SA 4.0"
"51755235","1","","","2018-08-08 20:34:08","","0","231","<p>Reactive BehaviorSubject has a modify method while exposes the values as inout and allows you to modify them. Any RxSwift property that allows similar behaviour? </p>
","4486884","","","","","2018-08-09 11:53:15","RxSwift equivalent BehaviorSubject's .modify() method","<swift><rx-swift><reactive>","1","1","","","","CC BY-SA 4.0"
"51771026","1","","","2018-08-09 15:37:00","","0","87","<p>I am new to RxSwift and MVVM pattern, I would like to ask how do I show validation on each UItextfield after tapping submit button using RxSwift.</p>
","3633680","","","","","2018-08-10 18:20:31","Show validation on each UItextfield after tapping submit button using RxSwift","<ios><iphone><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"51773918","1","","","2018-08-09 18:48:07","","1","1286","<p>In my Swift UIViewController, I'm attempting to subscribe to a class member of type Variable, run it through a flatMapLatest call, and then have the onCompleted() call in the flatMapLatest observable execute on all subscribers. However, while onNext() is called, onCompleted() never is and I'm not sure why.</p>

<p>My class member is defined as:</p>

<pre><code>private let privateVar = Variable&lt;String&gt;("""")
</code></pre>

<p>while in my viewDidLoad() method, I set up the observables:</p>

<pre><code>let localVar = self.privateVar.asObservable().distinctUntilChanged()

localVar.subscribe(onNext: { [weak self] sent in print(""first onNext called"") })
        .disposed(by: self.disposeBag)

let mappedVar = localVar.flatMapLatest { self.ajaxLoad(var1: $0) }.share()

mappedVar.subscribe(
  onNext: { [weak self] queryRes in
    print(""onNext called!"")
  },
  onCompleted: { [weak self] in
    print(""onCompleted called!"")
  }
)
.disposed(by: self.disposeBag)
</code></pre>

<p>and my ajaxLoad method:</p>

<pre><code>func ajaxLoad(var1 myVar: String) -&gt; Observable&lt;QueryResponse&gt; {
  return Observable.create { observable in
    apollo.fetch(query: MyQuery()) { (result, _) in
      observable.onNext(result?.data?.myQuery)
      observable.onCompleted()
    }

    return Disposables.create()
  }
}
</code></pre>

<p>I'm fairly new to ReactiveX so I may be a little hazy on what the Rx lifecycle actually looks like. Why might onNext be called in the flatMapLatest call, but not onCompleted? Any help would be appreciated. Thanks in advance!</p>
","2466941","","","","","2018-08-10 18:12:22","RxSwift: Why does flatMapLatest never execute onCompleted()?","<ios><swift><rx-swift><reactivex><rx-cocoa>","2","0","","","","CC BY-SA 4.0"
"51804044","1","51804745","","2018-08-11 21:52:35","","4","617","<p>I’m interested in the lifecycle of an observable defines within a regular swift function - as a local variable. </p>

<p><strong>Does the local variable observable get dealocated when the function returns?</strong> What are the conditions where I can count on my observable operating until it completes or errors out?</p>

<pre><code>func testObservable()
{
  let obs = Observable&lt;Int&gt;.interval( 2, MainScheduler.instance)
  .subscribe(onNext: {print($0)}) //omitting dispose bag
}
</code></pre>

<p>Would the observable keep firing as long as it has a subscriber and disposed when it is unsubscribed?</p>

<p>How about this case?
    let disposeBag = disposeBag()</p>

<pre><code>func testObservable()
    {
      let obs = Observable&lt;Int&gt;.interval( 2, MainScheduler.instance)
      .subscribe(onNext: {print($0)})
      .disposedBy(disposeBag)
    }
</code></pre>
","967484","","","","","2018-08-12 00:16:36","iOS RxSwift how to understand observable lifecycle when defined inside function","<memory-management><swift4><automatic-ref-counting><ios11><rx-swift>","1","2","","","","CC BY-SA 4.0"
"51809644","1","51813256","","2018-08-12 14:16:10","","1","448","<p>I have a button which sends network requests. I want to ignore double taps within this button. I tried <code>.throttle</code>, but that didn't seem to work. So I'm trying <code>.debounce</code> - this indeed ignores duplicate taps, but only lets through the last event. </p>

<p>What I want is: On first tap, send a network request, ignore subsequent taps within 0.33 seconds. </p>

<p><strong>Which RXSwift operator would help me put an event through and disable subsequent events within a time window?</strong></p>

<pre><code>let buttonPressObservable = button.rx.tap.asObservable()

buttonPressObservable.debounce(0.33, scheduler: MainScheduler.instance)
.map{/*do stuff*/}
</code></pre>
","967484","","","","","2018-08-12 22:10:34","iOS RXSwift What is the equivalent of debounce which lets through first event only?","<swift4><ios11><rx-swift><throttling><debounce>","1","0","","","","CC BY-SA 4.0"
"51815398","1","","","2018-08-13 04:52:44","","1","592","<p>I have a tableview containing forms so there are collection of textfields.
I am using RxSwift to bind data with tableview. When i try update dataSource with entered data in textfield, the whole tableview reloads and where the problem lies is instead of going on to next textfield, the keyboard dismisses.</p>

<p>Any suggestions would be of great help.
Here's a sample code </p>

<pre><code>struct TableData {
  var name, value: String?
}

class TableRxViewController: UIViewController {

 var data: [TableData] = []
 let dataSource = BehaviorRelay&lt;[TableData]&gt;(value: [])
 var disposeBag = DisposeBag()

@IBOutlet weak var tableView: UITableView! {
    didSet {
        tableView.register(UINib(nibName: ""RegisterCell"", bundle: nil), 
        forCellReuseIdentifier: ""RegisterCell"")
        tableView.rowHeight = UITableViewAutomaticDimension
    }
}

override func viewDidLoad() {
    super.viewDidLoad()
    self.addTableData()
    self.dataSource.accept(self.data)
    self.rxTableView()
}

func addTableData() {
    data.append(TableData(name: ""first"", value: """"))
    data.append(TableData(name: ""second"", value: """"))
    data.append(TableData(name: ""third"", value: """"))
    data.append(TableData(name: ""fourth"", value: """"))
    data.append(TableData(name: ""fifth"", value: """"))
}



func rxTableView() {
    self.dataSource.asObservable()
        .bind(to: tableView.rx.items) {
            (tableView: UITableView, index: Int, element: TableData) in
            let cell = tableView.dequeueReusableCell(withIdentifier: 
            ""RegisterCell"") as! RegisterCell
            cell.loadCell(data: element)
            cell.textfield.rx
                .controlEvent([.editingDidEndOnExit, .editingDidEnd])
                .subscribe({ text in
                    var data = self.dataSource.value
                    data[index].value = cell.textfield.text ?? """"
                    self.dataSource.accept(data)
                })
                .disposed(by: cell.disposeBag)

            return cell
        }
        .disposed(by: self.disposeBag)
 }
}
</code></pre>
","4994082","","4994082","","2018-08-14 04:38:24","2018-08-14 04:38:24","Using RxSwift with Tableview containing texfields dismisses keyboard on dataSource update","<ios><swift><keyboard><tableview><rx-swift>","1","3","","","","CC BY-SA 4.0"
"51816144","1","51824142","","2018-08-13 06:13:07","","6","6508","<p>I have delegate methods, which I need to wrap by Delegate Proxy in RxSwift. I have done it using Bond and Reactive, but here, in RxSwift, I am not able to find the proper way to convert it. </p>

<p>Follow is Protocols</p>

<pre><code>    import UIKit

/**
 A protocol for the delegate of a `DetailInputTextField`.
 */

    @objc
    public protocol CardInfoTextFieldDelegate {

        /**
         Called whenever valid information was entered into `textField`.

         - parameter textField:         The text field whose information was updated and is valid.
         - parameter didEnterValidInfo: The valid information that was entered into `textField`.
         */
        func textField(_ textField: UITextField, didEnterValidInfo: String)

        /**
         Called whenever partially valid information was entered into `textField`.

         - parameter textField:                  The text field whose information was updated and is partially valid.
         - parameter didEnterPartiallyValidInfo: The partially valid information that was entered.
         */
        func textField(_ textField: UITextField, didEnterPartiallyValidInfo: String)

        /**
         Called whenever more text was entered into `textField` than necessary. This can be used to provide this overflow as text in the next text field in the responder chain.

         - parameter textField:      The text field which received more information than required.
         - parameter overFlowDigits: The overflow of text which does not fit into `textField` and might be entered into the next receiver in the responder chain.
         */
        func textField(_ textField: UITextField, didEnterOverflowInfo overFlowDigits: String)
    }
</code></pre>

<p>What I did earlier is </p>

<pre><code>import Foundation
import Bond
import Caishen


extension DetailInputTextField {
    var bnd_cardInfoDelegate: ProtocolProxy {
        return protocolProxy(for: CardInfoTextFieldDelegate.self, setter: NSSelectorFromString(""setCardInfoTextFieldDelegate:""))
    }

    var bnd_didEnterValidInfo: StreamSignal&lt;NSString&gt; {
        return bnd_cardInfoDelegate.signal(for: #selector(CardInfoTextFieldDelegate.textField(_:didEnterValidInfo:)))
        { (s: PublishSignal&lt;NSString&gt;, _: UITextField, info: NSString) in
            s.next(info)
        }
    }

    var bnd_didEnterPartiallyValidInfo: StreamSignal&lt;NSString&gt; {
        return bnd_cardInfoDelegate.signal(for: #selector(CardInfoTextFieldDelegate.textField(_:didEnterPartiallyValidInfo:)))
        { (s: PublishSignal&lt;NSString&gt;, _: UITextField, info: NSString) in
            s.next(info)
        }
    }

    var bnd_didEnterOverflowInfo: StreamSignal&lt;NSString&gt; {
        return bnd_cardInfoDelegate.signal(for: #selector(CardInfoTextFieldDelegate.textField(_:didEnterOverflowInfo:)))
        { (s: PublishSignal&lt;NSString&gt;, _: UITextField, info: NSString) in
            s.next(info)
        }
    }
}
</code></pre>

<p>How can I do same exercise in RxSwift.
I tried DelegateProxy but its unclear how it properly wrap it.</p>
","3649855","","3649855","","2018-08-13 07:11:15","2021-07-23 12:06:37","How to convert Delegate to Observable RxSwift?","<swift><rx-swift><delegation>","2","3","5","","","CC BY-SA 4.0"
"51820262","1","","","2018-08-13 10:30:19","","0","1960","<p>This is what I do to setup <code>UIBarButtonItem</code>:</p>

<pre><code>mainView.userBarButtonItem.rx.tap.bind { _ in
    self.router.presentUserController(from: self)
}.disposed(by: bag)
</code></pre>

<p>but now I need to do something to call that closure. How?</p>
","2725435","","472495","","2019-02-24 18:34:08","2019-02-24 18:34:08","How to force tap on UIBarButtonItem using RxSwift?","<ios><swift><rx-swift>","3","0","","","","CC BY-SA 4.0"
"51828352","1","","","2018-08-13 18:18:41","","0","164","<p>Im working on RX swift problem to emulate 4 user taps. The requirement is to have them happen asynchronously in response to other events within RX. So I cannot use timers or intervals.</p>

<p>I’m thinking of a function that would “pull” from an  observable that can emit up to 4 values, then terminate. My question is :</p>

<p><strong>What operator allows me to “pull” or step through all elements of an observable from start to finish?</strong></p>

<pre><code>func recursive(duration: int) -&gt; Observable&lt;Int&gt;
{
// logic that may terminate recursion based on network conditions

//logic to terminate if number of taps exceeded
If I take from the taps array observable, and it completes - terminate recursion
}
</code></pre>

<p>The idea is to try to make a “pure” RX implementation, without relying on external variables. Im thinking of <code>Zip</code>, but am struggling to see how it is related to the recursive nature of the solution </p>
","967484","","967484","","2018-08-13 18:27:44","2018-08-13 20:14:18","iOS RxSwift how to “pull” from Observable.of(1,2,3)?","<recursion><ios11><rx-swift>","1","1","","","","CC BY-SA 4.0"
"51832149","1","","","2018-08-14 00:20:56","","0","187","<p>I have 2 stream which are being concatenated. If the first stream executes <code>onError</code> instead of <code>onComplete</code>, I shouldn't be concatenating the second stream.</p>

<p>example:</p>

<pre><code>func updateEntity(entities: [Member]) -&gt; Observable&lt;[Result&lt;Member&gt;]&gt; {
     let remoteUpdate = remoteStore.update(entities: entities)

     return remoteUpdate.concat(localStore.update(entities: entities))
}
</code></pre>

<p>I shouldn't be updating the <code>localStore</code> if <code>remoteUpdate</code> throws an error, onError is called in <code>remoteUpdate</code></p>

<p>Update:</p>

<pre><code>public override func update(entities: [PlaceAlert]) -&gt; Observable&lt;[Result&lt;PlaceAlert&gt;]&gt; { 
    let remoteUpdate = remoteStore.update(entities: entities) 
    var entityPlaceHolder: [PlaceAlert] = entities 

    return remoteUpdate.catchError { _ in 
      entityPlaceHolder = [] 
      return localStore.update(entities: entityPlaceHolder)
    }.concat(localStore.update(entities: entityPlaceHolder)) 
} 
</code></pre>

<p>Just tried improvising. would this make any difference? LocalUpdate with emptyArray does nothing if there is an error </p>
","1253102","","1253102","","2018-08-14 06:17:03","2018-08-14 06:17:03","RxSwift - Concat only on condition","<swift><rx-swift><reactive-cocoa>","1","0","1","","","CC BY-SA 4.0"
"51838842","1","51851734","","2018-08-14 10:03:24","","1","1357","<p>I have a tableView and a childController in a parent viewController, the tableView in the ParentViewController can have from 1 - 4 cells, each cell contains a UITextField.</p>

<p>The ChildController also have a TableView, that list results(autocomplete) based on what is inputted in any of the TextField in the ParentViewController tableView cell.</p>

<p>I want the childController to always listen to any of the UITextField and show the result on the tablView. This is what I have currently</p>

<pre><code>private var query = Variable&lt;String&gt;("""")
var queryDriver: Driver&lt;String&gt; {
    return query.asDriver()
}
</code></pre>

<p>TableView</p>

<pre><code>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {

    guard let cell = tableView
        .dequeueReusableCell(
            withIdentifier: ""StopCell"", for: indexPath) as? StopCell else {
                fatalError(""Cannot dequeue StopCell"")
    }
    cell.delegate = self

    cell.locationTextField.rx.text.map {$0 ?? """"}
        .bind(to: query)
        .disposed(by: disposeBag)

    cell.locationTextField.rx.controlEvent(.editingDidEnd)
        .asDriver(onErrorJustReturn: ())
        .drive(onNext: { [unowned self] in
            cell.locationTextField.resignFirstResponder()
        })
        .disposed(by: disposeBag)
    return cell
}
</code></pre>

<p>Add child controller</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    view.backgroundColor = .white
    let noteVC = NoteVc()
    addChildController(viewController: noteVC)
}
</code></pre>

<p>NoteVC</p>

<pre><code>class NoteVc: UIViewController {
  override func viewDidLoad() {
    super.viewDidLoad()
    view.backgroundColor = .white
    view.addSubview(tableView)
    viewModel = SearchLocationViewModel(query: &lt;#T##SharedSequence&lt;DriverSharingStrategy, String&gt;#&gt;)
}
</code></pre>

<p>ViewModel</p>

<pre><code>class SearchLocationViewModel {

let disposeBag = DisposeBag()
// MARK: - Properties

var querying: Driver&lt;Bool&gt; { return _querying.asDriver() }
var locations: Driver&lt;[Location]&gt; { return _locations.asDriver() }

// MARK: -

var hasLocations: Bool { return numberOfLocations &gt; 0 }
var numberOfLocations: Int { return _locations.value.count }

// MARK: -

private let _querying = BehaviorRelay&lt;Bool&gt;(value: false)
private let _locations = BehaviorRelay&lt;[Location]&gt;(value: [])

// MARK: -

private let disposeBag = DisposeBag()

// MARK: - Initializtion

init(query: Driver&lt;String&gt;) {
    Behave.shared.queryDriver
        .throttle(0.5)
        .distinctUntilChanged()
        .drive(onNext: { [weak self] (addressString) in
            self?.geocode(addressString: addressString)
        })
        .disposed(by: disposeBag)
}
</code></pre>

<p>Like it is implemented in the Uber app, users can add up to three destinations, the yellow rectangle box in the image below is my ChildViewController</p>

<p><a href=""https://i.stack.imgur.com/f8gpv.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/f8gpv.jpg"" alt=""enter image description here""></a></p>
","4218785","","4218785","","2018-08-16 20:49:40","2018-08-16 20:49:40","RxSwift: Observing UITextFields from TableViewCell inside a child view controller","<ios><swift><rx-swift>","1","2","1","","","CC BY-SA 4.0"
"51846904","1","","","2018-08-14 17:32:38","","0","147","<p>For this code</p>

<pre><code>  fileprivate let nameChangedProperty = MutableProperty("""")
  public func nameChanged(_ name: String) {
    self.nameChangedProperty.value = name
  }
</code></pre>

<p>What I did</p>

<pre><code>fileprivate let nameChangedProperty = BehaviorRelay&lt;String&gt;(value: """")
  public func nameChanged(_ name: String) {
    self.nameChangedProperty.accept(name)
}
</code></pre>

<p>But confused about </p>

<pre><code>    public init() {
    let initialText = self.viewDidLoadProperty.signal.mapConst("""")
    let name = Signal.merge(
      self.nameChangedProperty.signal,
      initialText
    )
}
</code></pre>

<p>here, for first line, I did </p>

<pre><code>let initialToken = self.viewDidLoadProperty.asObservable().map { _ in """" }
</code></pre>

<p>but no idea abut merge signal ....</p>

<p>If some theory concepts are given, is appreciated. </p>
","3649855","","","","","2018-08-14 18:21:27","Convert Reactive Cocoa Code to RxSwift?","<ios><swift><rx-swift><reactive-cocoa>","1","0","","","","CC BY-SA 4.0"
"51851248","1","51852251","","2018-08-15 00:06:01","","2","2309","<p>I have two network requests that I would like to combine the results in one array of Object.</p>

<pre><code>enum ResultType&lt;T&gt; {
  case success(T)
  case failure(Error)
}

static func requestPlaceSearch(query: String) -&gt; Observable&lt;ResultType&lt;SearchResult&gt;&gt; {
    let urlString = ""https://maps.googleapis.com/maps/api/place/autocomplete/json""
    let params = [""input"": query, ""types"": ""geocode"",
                ""key"": ""key""]
    return placeRequest(url: urlString, params: params)
}

static func requestPlace(with placeId: String) -&gt; Observable&lt;ResultType&lt;Place&gt;&gt; {
    let params = [""placeid"": placeId, ""key"": ""key""]
    let urlString = ""https://maps.googleapis.com/maps/api/place/details/json""
    return placeRequest(url: urlString, params: params)
}
</code></pre>

<p><code>requestPlaceSearch</code> returns and observable of <code>SearchResult</code>
I want to loop through <code>SearchResult.predictions</code>, get the id of each prediction make a request to <code>requestPlace</code> get the <code>Place</code> an append to array of <code>Places</code></p>

<p>I want my final array to be </p>

<pre><code>let places = Observable&lt;[Place]&gt; 
</code></pre>

<p>or</p>

<pre><code>let places = [Place]()
</code></pre>
","4218785","","","","","2018-08-15 02:43:41","RxSwift: Combine two network request to return one value","<ios><swift><rx-swift><googleplacesautocomplete>","1","0","5","","","CC BY-SA 4.0"
"51853395","1","","","2018-08-15 05:27:01","","3","5407","<p>I am getting error 
Cannot convert return expression of type 'PrimitiveSequence' to return type 'Observable'</p>

<p>a Single returns PrimitiveSequence, so how can I convert it to Observable of type String?</p>

<pre><code>return Single&lt;String&gt;.create(subscribe: { (single) in
    single(.success(""test""))            
    return Disposables.create { }
})
</code></pre>

<p>What is right way - I have an API which will return String - say Token.</p>
","3649855","","2463616","","2018-08-16 13:56:55","2018-08-16 13:56:55","Cannot convert return expression of type 'PrimitiveSequence<SingleTrait, String>' to return type 'Observable<String>'","<rx-swift>","2","0","","","","CC BY-SA 4.0"
"51853781","1","","","2018-08-15 06:14:24","","0","541","<p>""Generic parameter 'Element' could not be inferred"" - this error comes as I write guard statement - what is inside guard statement which causes error that element could not be inferred.</p>

<pre><code>static func makeTokenForCard(with cardinfo: CardInfo) -&gt; Single&lt;String&gt; {
        return Single.create { single in
            guard let ck = try CheckoutKit.getInstance(""pk_123456789876543234567, env: Environment.SANDBOX, debug: true) else {
                let descr = ""Unexpectedly Checkout got invalid private key. You may need to update the app.""
                single(.error(NSError.recreate(error: CheckoutError.invalidPK as NSError, description: descr)))
                return
            }

            single(.success(""123456""))
            return Disposables.create()
        }
    }
</code></pre>

<p>When I remove this Guard statement - it returns simple String and errors in Single. </p>

<p>Edit : </p>

<p>After getting more into error, I found that its due to throws. </p>

<pre><code>open class func getInstance(_ pk: String, env: Environment, debug: Bool) throws -&gt; CheckoutKit? {
</code></pre>

<p>In Simple Guard &amp; wrapping its fine. </p>

<p>So, How to call a method in Single when it has throws some expected error
?</p>
","3649855","","3649855","","2018-08-15 07:25:22","2018-08-15 08:55:04","Generic parameter 'Element' could not be inferred?","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"51856962","1","52918668","","2018-08-15 10:21:58","","0","1191","<p><strong>Reformed question</strong></p>

<p>I have reformed my question. To the common case.</p>

<p>I want to generate items with RxSwift in background thread (loading from disk, long-running calculations, etc.), and observe items in MainThread. And I want to be sure that no items will be delivered after dispose (from main thread).</p>

<p>According to documentation (<a href=""https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#disposing"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#disposing</a>):</p>

<blockquote>
  <p>So can this code print something after the dispose call is executed? The answer is: it depends.</p>
  
  <ul>
  <li><p>If the scheduler is a serial scheduler (ex. MainScheduler) and dispose is called on the same serial scheduler, the answer is no.</p></li>
  <li><p>Otherwise it is yes.</p></li>
  </ul>
</blockquote>

<p>But in case of using subscribeOn and observerOn with different schedulers - we cannot guarantee that nothing will be emitted after dispose (manual or by dispose bag, it does not matter).</p>

<p>How should I generate items (images, for example) in background and be sure that result will not be used after the dispose?</p>

<p>I made workaround in real project, but I want to solve this problem and to understand how should we avoid it in the same cases.</p>

<p>In my test project I have used small periods - they demonstrate the problem perfectly!</p>

<pre><code>import RxSwift

class TestClass {
    private var disposeBag = DisposeBag()

    private var isCancelled = false

    init(cancelAfter: TimeInterval, longRunningTaskDuration: TimeInterval) {
        assert(Thread.isMainThread)

        load(longRunningTaskDuration: longRunningTaskDuration)

        DispatchQueue.main.asyncAfter(deadline: .now() + cancelAfter) { [weak self] in
            self?.cancel()
        }
    }

    private func load(longRunningTaskDuration: TimeInterval) {
        assert(Thread.isMainThread)

        // We set task not cancelled
        isCancelled = false

        DataService
            .shared
            .longRunngingTaskEmulation(sleepFor: longRunningTaskDuration)
            // We want long running task to be executed in background thread
            .subscribeOn(ConcurrentDispatchQueueScheduler.init(queue: .global()))
            // We want to process result in Main thread
            .observeOn(MainScheduler.instance)
            .subscribe(onSuccess: { [weak self] (result) in
                assert(Thread.isMainThread)

                guard let strongSelf = self else {
                    return
                }

                if !strongSelf.isCancelled {
                    print(""Should not be called! Task is cancelled!"")
                } else {
                    // Do something with result, set image to UIImageView, for instance
                    // But if task was cancelled, this method will set invalid (old) data
                    print(result)
                }

                }, onError: nil)
            .disposed(by: disposeBag)
    }

    // Cancel all tasks. Can be called in PreapreForReuse.
    private func cancel() {
        assert(Thread.isMainThread)

        // For test purposes. After cancel, old task should not make any changes.
        isCancelled = true

        // Cancel all tasks by creating new DisposeBag (and disposing old)
        disposeBag = DisposeBag()
    }
}

class DataService {
    static let shared = DataService()

    private init() { }

    func longRunngingTaskEmulation(sleepFor: TimeInterval) -&gt; Single&lt;String&gt; {
        return Single
            .deferred {
                assert(!Thread.isMainThread)

                // Enulate long running task
                Thread.sleep(forTimeInterval: sleepFor)

                // Return dummy result for test purposes.
                return .just(""Success"")
        }
    }
}

class MainClass {
    static let shared = MainClass()

    private init() { }

    func main() {

        Timer.scheduledTimer(withTimeInterval: 0.150, repeats: true) { [weak self] (_) in
            assert(Thread.isMainThread)

            let longRunningTaskDuration: TimeInterval = 0.050

            let offset = TimeInterval(arc4random_uniform(20)) / 1000.0
            let cancelAfter = 0.040 + offset

            self?.executeTest(cancelAfter: cancelAfter, longRunningTaskDuration: longRunningTaskDuration)
        }
    }

    var items: [TestClass] = []
    func executeTest(cancelAfter: TimeInterval, longRunningTaskDuration: TimeInterval) {
        let item = TestClass(cancelAfter: cancelAfter, longRunningTaskDuration: longRunningTaskDuration)
        items.append(item)
    }
}
</code></pre>

<p>Call MainClass.shared.main() somewhere to start.</p>

<p>We call method to load some data and later we call cancel (all from Main Thread). After cancel we sometimes receive the result (in main thread too), but it is old already.</p>

<p>In real project TestClass is a UITableViewCell subclass and cancel method is called in prepareForReuse. Then cell is being reused and new data is set to the cell. And later we get the result of OLD task. And old image is set to the cell!</p>

<hr>

<p><strong>ORIGINAL QUESTION (OLD):</strong></p>

<p>I would like to load image with RxSwift in iOS. I want to load image in background, and to use it in main thread. So I subscribeOn background thread, and observeOn main thread. And function will look like this:</p>

<pre><code>func getImage(path: String) -&gt; Single&lt;UIImage&gt; {
    return Single
        .deferred {
            if let image = UIImage(contentsOfFile: path) {
                return Single.just(image)
            } else {
                return Single.error(SimpleError())
            }
        }
        .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))
        .observeOn(MainScheduler.instance)
}
</code></pre>

<p>But I get problems with cancelation. Because different schedulers are used to create items and to call dispose (disposing from main thread), subscription event can be raised after dispose is called. So in my case of using in UITableViewCell I receive invalid (old) image.</p>

<p>If I create item (load image) in the same scheduler that observes (Main thread), everything works fine!
But I would like to load images in background and I want it will be canceled after disposing (in prepareForReuse method or in new path set method). What is the common template for this?</p>

<p><strong>EDIT:</strong></p>

<p>I have created a test project, where I can emulate the problem when the event is received after dispose.</p>

<p>And I have one simple solution that works. We should emit items in the same scheduler. So we should capture scheduler and emit items there (after long running task completes).</p>

<pre><code>func getImage2(path: String) -&gt; Single&lt;UIImage&gt; {
    return Single
        .create(subscribe: { (single) -&gt; Disposable in
            // We captrure current queue to execute callback in
            // TODO: It can be nil if called from background thread
            let callbackQueue = OperationQueue.current

            // For async calculations
            OperationQueue().addOperation {
                // Perform any long-running task
                let image = UIImage(contentsOfFile: path)

                // Emit item in captured queue
                callbackQueue?.addOperation {
                    if let result = image {
                        single(.success(result))
                    } else {
                        single(.error(SimpleError()))
                    }
                }
            }

            return Disposables.create()
        })
        .observeOn(MainScheduler.instance)
}
</code></pre>

<p>But it is not in Rx way. And I think this is not the best solution.</p>

<p>May be I should use CurrentThreadScheduler to emit items, but I cannot understand how. Is there any tutorial or example of items generation with schedulers usage? I did not find any.</p>
","3449629","","3449629","","2018-10-03 14:54:31","2018-11-01 14:56:19","Dispose (cancel) observable. SubscribeOn and observeOn different schedulers","<ios><swift><rx-swift>","1","4","","","","CC BY-SA 4.0"
"51864508","1","51866879","","2018-08-15 18:35:01","","0","818","<p>I'm facing a weird problem when trying to navigate from <code>ViewA</code> to <code>ViewB</code> using RxSwift.</p>

<p>I have the follow code (it's just an example):</p>

<pre><code>    emailTextField.rx.text
        .map { $0 ?? """" }
        .bind(to: viewModel.email)
        .disposed(by: bag)


    viewModel.email
        .asObservable()
        .filter { $0.isValidEmail }
        .subscribe(onNext: { value in
            self.performSegue(withIdentifier: viewBSegue, sender: value)
        })
        .disposed(by: bag)
</code></pre>

<p>The problem is, after <code>ViewB</code> get presented, the <code>subscribe</code> in my <code>viewModel</code> is called again, which lead to pushing <code>ViewB</code> again.</p>

<p><code>email</code> variable in <code>viewModel</code> is a <code>PublishSubject&lt;String&gt;</code> and I'm using <code>RxSwift</code>|<code>RxCocoa 4.1</code></p>
","10230815","","503099","","2018-08-15 19:00:24","2018-08-16 04:44:50","RxSwift bind on textField sending next after pushing another view","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"51870030","1","51876094","","2018-08-16 05:17:32","","2","2800","<p>I have a <code>newBid</code> object, that contains some data and images array. I want to upload all images and data to the server and <code>zip</code> those upload observables. If I create separate <code>drivers</code> for <code>data</code>, <code>image1</code> and <code>image2</code>, I succeed. </p>

<p>But what I want to really do is to not hardcode images since array may contain from 0 to 10 images. I want to create observables array programmatically and <code>zip</code> them. </p>

<pre><code>let dataSaved = saveTaps.withLatestFrom(newBid)
    .flatMapLatest { bid in
        return CustomerManager.shared.bidCreate(bid: bid)
            .trackActivity(activityIndicator)
            .asDriver(onErrorJustReturn: false)
}

let photoSaved0 = saveTaps.withLatestFrom(newBid)
    .flatMapLatest { bid in
        return CustomerManager.shared.bidUploadFile(image: bid.images[0])
            .trackActivity(activityIndicator)
            .asDriver(onErrorJustReturn: false)
}

let photoSaved1 = saveTaps.withLatestFrom(newBid)
    .flatMapLatest { bid in
        return CustomerManager.shared.bidUploadFile(image: bid.images[1])
            .trackActivity(activityIndicator)
            .asDriver(onErrorJustReturn: false)
}

saveCompleted = Driver.zip(dataSaved, photoSaved0, photoSaved1){ return $0 &amp;&amp; $1 &amp;&amp; $2 }

/*
// 0. Getting array of images from newBid
let images = newBid.map { bid in
    return bid.images
}

// 1. Creating array of upload drivers from array of images
let imageUploads = images.map { (images: [UIImage]) -&gt; [Driver&lt;Bool&gt;] in
    var temp = [Driver&lt;Bool&gt;]()
    return temp
}

// 2. Zipping array of upload drivers to photoSaved driver
photoSaved = Driver
    .zip(imageUploads) // wait for all image requests to finish
    .subscribe(onNext: { results in
        // here you have every single image in the 'images' array
        results.forEach { print($0) }
    })
    .disposed(by: disposeBag)*/
</code></pre>

<p>In the commented section if I try to <code>zip</code> imageUploads, I get error: </p>

<pre><code>Argument type 'SharedSequence&lt;DriverSharingStrategy, [SharedSequence&lt;DriverSharingStrategy, Bool&gt;]&gt;' does not conform to expected type 'Collection'
</code></pre>
","751641","","751641","","2018-08-16 05:45:57","2018-08-19 17:48:45","Using zip operator in RxSwift after creating an array of observables","<ios><swift><rx-swift><rx-cocoa>","2","0","1","","","CC BY-SA 4.0"
"51886256","1","","","2018-08-16 22:44:50","","1","113","<p>I’m trying to get some more clarity around connectable Observables. </p>

<p><strong>Does connectable observable pass <code>onComplete</code> events to subscribers at the end of replay, if source has terminated?</strong></p>

<p>I have seen answer suggesting that it should, but it does not seem to do so in RxSwift. Is this my bug, or is this the correct behavior in swift?</p>

<pre><code>let source = Observable.just(“test”).replay()
let disposable = source.subscribe(onNext:{}, onComplete:{print(“would this print?”})
</code></pre>
","967484","","","","","2018-08-17 01:09:12","iOS RxSwift does connectable observable from .replay() pass completion events to subscribers?","<observable><swift4><ios11><rx-swift>","1","0","","","","CC BY-SA 4.0"
"51894540","1","","","2018-08-17 11:33:51","","3","298","<p>I'm trying some RXSwift code in a playground, and XCode keeps freezing every several minutes with the rainbow spinner. Then XCode stops responding and has to be force quit and restarted. This is happening across multiple projects and Macs. Regular RXSwift code in project files does not cause crashes. </p>

<p><strong>How can I fix XCode freezing when working with RXSwift in playground mode?</strong></p>

<pre><code>import RxSwift
import RxCocoa
import PlaygroundSupport
import Foundation

var str = ""Hello, playground""
print(str)

let subject = BehaviorSubject(value: ""seed"")

let replayed = subject.replay(1)

let sequence = Observable.of(""first"",""Second"") //random crashes as I type and the console outputs error messages.

replayed.connect()

replayed.subscribe(onNext: { value in
    print(value)
}, onError: { error in
    print(""Received Error"")
}, onCompleted: {
    print(""Received Completion"")
})
</code></pre>

<p>Here's my podfile: </p>

<pre><code>platform :ios, '11.0'

use_frameworks!

pod 'RxSwift'
pod 'RxCocoa'

target 'RxSwiftPlayground'



post_install do |installer|

    installer.pods_project.build_configurations.each do |config|
        config.build_settings.delete('CODE_SIGNING_ALLOWED')
        config.build_settings.delete('CODE_SIGNING_REQUIRED')
    end

    installer.pods_project.targets.each do |target|
        target.build_configurations.each do |config|
            config.build_settings['CONFIGURATION_BUILD_DIR'] = '$PODS_CONFIGURATION_BUILD_DIR'
        end
    end
end
</code></pre>

<p>I think the only symptom I have is that after force quit, I get this error in console until I rebuild the project (it was compiling and had code completion before the freeze)</p>

<pre><code>Playground execution failed:

    error: RxSwift.playground:3:8: error: no such module 'RxSwift'
    import RxSwift
</code></pre>
","967484","","967484","","2018-08-17 12:01:57","2018-08-17 12:01:57","iOS XCode - Swift playground with RXSwift keeps freezing with spinner","<swift4><ios11><rx-swift><swift-playground><xcode9.4>","0","0","2","","","CC BY-SA 4.0"
"51927218","1","51928352","","2018-08-20 08:53:25","","2","4451","<p>I have a simple array:</p>

<p><code>var similarObjects: [Objects] = []</code></p>

<p>How I can see his changes after:</p>

<p><code>similarObjects = someArray</code></p>

<p>I try: (result: next -> complete)</p>

<pre><code>_ = Observable.just(similarObjects)
     .subscribe({ event in
         return print(event.element)
     })
</code></pre>
","8904078","","2463616","","2018-08-20 08:54:11","2019-03-13 10:08:59","How to subscribe on array changes using RxSwift?","<swift><rx-swift>","4","1","","","","CC BY-SA 4.0"
"51932383","1","","","2018-08-20 13:59:00","","1","349","<p><strong>What is the correct syntax to get a value associated with .success Result in RXSwift?</strong></p>

<pre><code>.map{ (result : Result&lt;Double&gt;) -&gt; Double in
        //how to get duration from result? this does not work
        let duration : Double = result.success.value
        return duration
}
</code></pre>
","967484","","967484","","2018-08-20 17:45:35","2021-09-01 13:55:36","iOS RXSwift how to get value from .success Result?","<swift3><ios11><rx-swift><associated-types>","2","1","","","","CC BY-SA 4.0"
"51933595","1","51935466","","2018-08-20 15:04:03","","2","1703","<p>I would like to bind different actions for a button in RxSwift. 
I have binding </p>

<pre><code>registerButton.rx.tap
            .map { self.registerButton.isEnabled = false }
            .bind(to: viewModel.registrationPressed)
            .disposed(by: disposeBag)
</code></pre>

<p>and wanna switch to </p>

<pre><code>self.registerButton.rx.tap
        .map { self.registerButton.isEnabled = false }
        .bind(to: viewModel.registerPinPressed)
        .disposed(by: disposeBag)
</code></pre>

<p>with </p>

<pre><code>let registrationPressed = PublishSubject&lt;Void&gt;()
let registerPinPressed = PublishSubject&lt;Void&gt;()
</code></pre>

<p>Is there any way to unbind the first binding?</p>

<p>EDIT:
It seems that unbinding is not possible, but thanx to Daniel T. I found the solution that works.</p>

<pre><code>let tap = registerButton.rx.tap
            .map { _ in
                self.isFormProcessed
            }

        tap.filter { !$0 }
            .toVoid()
            .bind (to: viewModel.registrationPressed)
            .disposed(by: disposeBag)

        tap.filter { $0 }
            .toVoid()
            .bind(to: viewModel.registerPinPressed)
            .disposed(by: disposeBag)
</code></pre>
","385469","","385469","","2018-08-22 06:40:16","2018-08-22 06:40:16","UIButton action(rx.tap) responds to different PublishSubjects with RxSwift","<ios><iphone><data-binding><uibutton><rx-swift>","1","5","","","","CC BY-SA 4.0"
"51935467","1","51989541","","2018-08-20 17:02:57","","0","1529","<p>I'm trying to add an extension to Observable.
The code looks like this: </p>

<pre><code>extension Observable where Element == ApiResponse&lt;ItemsContainer&lt;T&gt;&gt;, T:Codable
</code></pre>

<p>I'm receiving the following exception: <code>Use of undeclared type T</code>.</p>

<p>So apparently this doesn't work.
The only thing missing is to constrain the generic inside <code>ItemsContainer</code> to conform to <code>Codable</code>.
Could be as simple as a syntactical issue or maybe I'm just not good enough with generics. Any help is appreciated!</p>

<p><strong>Edit</strong>: To give the idea - ApiResponse and ItemsContainer look like this</p>

<pre><code>public struct ApiResponse&lt;ApiModel&gt; {  
  public let data: ApiModel?  
}  

struct ItemsContainer&lt;Items&gt;: Codable  where Items: Codable {  
   let items: [Items]
}
</code></pre>
","5952116","","5952116","","2018-08-21 06:57:11","2018-08-24 13:56:37","Swift Extension to Observable with Generic Type Constraint","<swift><generics><observable><where-clause><rx-swift>","1","1","","","","CC BY-SA 4.0"
"51936959","1","","","2018-08-20 18:58:42","","0","867","<p>I have the following code using <a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow noreferrer"">RxSwift</a>: </p>

<pre><code> self.photos
                .bind(to: collectionView.rx.items(dataSource: self.dataSource))
                .disposed(by: disposeBag)
</code></pre>

<p>And it gives me <code>Type of expression is ambiguous without more context</code></p>

<p>What more context does it need? </p>

<p>The complete code is shown below: </p>

<pre><code>//
//  PhotosCollectionViewController.swift
//  TodoListRxSwift
//

//

import Foundation
import UIKit
import RxSwift
import RxCocoa
import RxDataSources

struct Photo  {
    var name :String
    var imageURL :String
}

struct SectionOfPhoto {
    var header: String
    var items: [Photo]
}
extension SectionOfPhoto: SectionModelType {

    init(original: SectionOfPhoto, items: [Photo]) {
        self = original
        self.items = items
    }
}

class PhotosCollectionViewController :UICollectionViewController {

    private let disposeBag = DisposeBag()

    private (set) var photos = BehaviorRelay(value: [Photo(name: ""Pic 1"", imageURL: ""1.png""),Photo(name: ""Pic 2"", imageURL: ""2.png""),Photo(name: ""Pic 3"", imageURL: ""3.png"")])

    let dataSource = RxCollectionViewSectionedReloadDataSource&lt;SectionOfPhoto&gt;(configureCell: { ds, cv, indexPath, photo in

        let cell = cv.dequeueReusableCell(withReuseIdentifier: ""PhotoCollectionViewCell"", for: indexPath)

        return cell

    })

    override func viewDidLoad() {

        super.viewDidLoad()

        self.collectionView?.delegate = nil
        self.collectionView?.dataSource = nil

        configureObservables()
    }

    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {

        prepareSegueForAddPhotoViewController(segue :segue)
    }

    override func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -&gt; UICollectionReusableView {

        switch kind {
            case UICollectionElementKindSectionHeader:

                let headerView = collectionView.dequeueReusableSupplementaryView(ofKind: UICollectionElementKindSectionHeader, withReuseIdentifier: ""PhotosHeaderView"", for: indexPath)
                return headerView

            default:
                return UICollectionReusableView()
        }

    }

    private func prepareSegueForAddPhotoViewController(segue :UIStoryboardSegue) {

        guard let nc = segue.destination as? UINavigationController else {
            fatalError(""NavigationController does not exist"")
        }

        guard let addPhotoVC = nc.topViewController as? AddPhotoViewController else {
            fatalError(""AddPhotoViewController does not exist"")
        }

        _ = addPhotoVC.selectedPhoto.subscribe(onNext: { (photo) in
           self.photos.accept(self.photos.value + [photo])
        })
    }


    private func configureObservables() {

        if let collectionView = self.collectionView {

            self.photos.bind(to: collectionView.rx.items(dataSource: self.dataSource))

            self.photos.bind(to: collectionView.rx.items(cellIdentifier: ""PhotoCollectionViewCell"", cellType: PhotoCollectionViewCell.self)) { row, model, cell in

                cell.photoImageView.image = UIImage(named: model.imageURL)

            }.disposed(by: disposeBag)

        }
    }
}
</code></pre>
","810815","","810815","","2018-08-20 20:27:30","2018-08-21 01:24:41","Type of expression is ambiguous in Swift","<ios><swift><rx-swift>","1","3","","","","CC BY-SA 4.0"
"51942679","1","","","2018-08-21 06:19:02","","0","2538","<p>I would like to post binary data through RxAlamofire, Alamofire or even without any library but after some days of research and tries, I'm not able to do it.</p>

<p>Here you can find the POSTMAN example of the request that I am trying to reproduce is:</p>

<p><img src=""https://user-images.githubusercontent.com/23025266/44338744-3b731600-a47f-11e8-8f50-4c1ef8f91202.png"" alt=""captura de pantalla 2018-08-20 a las 13 42 36"">
<img src=""https://user-images.githubusercontent.com/23025266/44338761-44fc7e00-a47f-11e8-865f-b5294a753c55.png"" alt=""captura de pantalla 2018-08-20 a las 13 42 48""></p>

<p>Is a post method with the Authorization and Content-Type headers and the binary data attached.</p>

<p>I have tried to find some example or something related but I couldn't find a solution. I could just find multipart form data examples but with multipart form data the server doesn't work (is a external API)</p>

<p>If someone could guide me or show me some example code.</p>

<p>Here the code used for login as example and to show you something that I want to achieve:</p>

<pre><code>public class APIClient: DataSource {

    public static var shared: APIClient = APIClient()

    private init(){}

    public func login(email:String, password:String) -&gt; Observable&lt;LoginResponse&gt; {
        return RxAlamofire.requestJSON(APIRouter.login(email:email, password:password))
            .subscribeOn(MainScheduler.asyncInstance)
            .debug()
            .mapObject(type: LoginResponse.self)
    }

}
</code></pre>

<p>Here the LoginResponse object:</p>

<pre><code>public struct LoginResponse: Mappable {
    var tokenId: String?
    var userId: String?

    public init?(map: Map) {}

    public mutating func mapping(map: Map) {
        tokenId &lt;- map[""id""]
        userId &lt;- map[""userId""]
    }

}
</code></pre>

<p>And finally the APIRouter extending URLRequestConvertible:</p>

<pre><code>enum APIRouter: URLRequestConvertible {

    case login(email: String, password: String)

    private var method: HTTPMethod {
        switch self {
        case .login:
            return .post
        }
    }

    private var path: String {
        switch self {
        case .login:
            return ""users/login""
        }
    }

    private var parameters: Parameters? {
        switch self {
        case .login(let email, let password):
            return [APIConstants.LoginParameterKey.email: email, APIConstants.LoginParameterKey.password: password]
        }
    }

    private var query: [URLQueryItem]? {
        var queryItems = [URLQueryItem]()
        switch self {
        case .login:
            return nil
        }
    }

    func asURLRequest() throws -&gt; URLRequest {
        var urlComponents = URLComponents(string: APIConstants.ProductionServer.baseURL)!
        if let query = query {
            urlComponents.queryItems = query
        }

        var urlRequest = URLRequest(url: urlComponents.url!.appendingPathComponent(path))

        // HTTP Method
        urlRequest.httpMethod = method.rawValue

        urlRequest.addValue(ContentType.json.rawValue, forHTTPHeaderField: HTTPHeaderField.acceptType.rawValue)
        urlRequest.addValue(ContentType.json.rawValue, forHTTPHeaderField: HTTPHeaderField.contentType.rawValue)

            if let parameters = parameters {
                do {
                    urlRequest.httpBody = try JSONSerialization.data(withJSONObject: parameters, options: [])
                } catch {
                    throw AFError.parameterEncodingFailed(reason: .jsonEncodingFailed(error: error))
                }
            }


        return urlRequest
    }
}
</code></pre>

<p>Thank you in advance!</p>

<p><strong>EDIT To convert into RxAlamofire</strong></p>

<p>With the code below I could solve the problem and convert it into RxSwift but I would like to use RxAlamofire to obtain the same result:</p>

<pre><code>public func upload(media: Data) -&gt; Observable&lt;ContentUri&gt; {
        let headers = [
            ""content-type"": ""image/png"",
            ""authorization"": ""token header""
        ]
        return Observable&lt;ContentUri&gt;.create({observer in
            Alamofire.upload(media, to: ""\(endPoint)/api/media/upload"", headers: headers)
                .validate()
                .responseJSON { response in
                    print(response)
            }
            return Disposables.create();
        })
    }
</code></pre>
","4669063","","4669063","","2018-08-21 07:06:01","2018-08-21 07:06:01","POST binary data using swift","<swift><alamofire><rx-swift><rxalamofire>","1","2","","","","CC BY-SA 4.0"
"51945597","1","51948115","","2018-08-21 09:27:15","","1","5116","<p>I am learning RxSwift and I have tried a basic login UI using it. My implementation is as follows.</p>

<p><strong><em>LoginViewController:</em></strong></p>

<pre><code>fileprivate let loginViewModel = LoginViewModel()

fileprivate var textFieldArray: [UITextField]!

override func viewDidLoad() {
    super.viewDidLoad()

    textFieldArray = [textFieldUserName, textFieldPassword, textFieldConfirmPassword]

    textFieldUserName.delegate = self
    textFieldPassword.delegate = self
    textFieldConfirmPassword.delegate = self

    loginViewModel.areValidFields.subscribe(
        onNext: { [weak self] validArray in
            for i in 0..&lt;validArray.count {
                if validArray[i] {
                    self?.showValidUI(index: i)
                } else {
                    self?.showInValidUI(index: i)
                }
            }
        },
        onCompleted: {
            print(""### COMPLETED ###"")
        },
        onDisposed: {
            print(""### DISPOSED ###"")
    }).disposed(by: loginViewModel.bag)

}

func showValidUI(index: Int) {
    textFieldArray[index].layer.borderColor = UIColor.clear.cgColor
}

func showInValidUI(index: Int) {
    textFieldArray[index].layer.borderColor = UIColor.red.cgColor
    textFieldArray[index].layer.borderWidth = 2.0
}

extension LoginViewController: UITextFieldDelegate {

    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool {

        let inputText = (textField.text! as NSString).replacingCharacters(in: range, with: string)

        switch textField {
        case textFieldUserName:
            loginViewModel.updateUserName(text: inputText)
        case textFieldPassword:
            loginViewModel.updatePassword(text: inputText)
        case textFieldConfirmPassword:
            loginViewModel.updateConfirmedPassword(text: inputText)
        default:
            return false
        }
        return true
    }  
}
</code></pre>

<p><strong><em>LoginViewModel:</em></strong></p>

<pre><code>class LoginViewModel {

    private var username: String!
    private var password: String!
    private var confirmedPassword: String!

    fileprivate let combinedSubject = PublishSubject&lt;[Bool]&gt;()

    let bag = DisposeBag()


    var areValidFields: Observable&lt;[Bool]&gt; {
        return combinedSubject.asObservable()
    }

    init() {
        self.username = """"
        self.password = """"
        self.confirmedPassword = """"
    }

    /*deinit {
        combinedSubject.onCompleted()
    }*/


    func updateUserName(text: String) {
        username = text
        if username.count &gt; 6 {
            combinedSubject.onNext([true, true, true])
        } else {
           combinedSubject.onNext([false, true, true])
        }
    }

    func updatePassword(text: String) {
        password = text
        if password.count &gt; 6 {
            combinedSubject.onNext([true, true, true])
        } else {
            combinedSubject.onNext([true, false, true])
        }
    }

    func updateConfirmedPassword(text: String) {
        confirmedPassword = text
        if confirmedPassword == password {
            combinedSubject.onNext([true, true, true])
        } else {
            combinedSubject.onNext([true, true, false])
        }
    }
}
</code></pre>

<p>With this code, the disposed message gets printed when i move back the navigation stack.</p>

<p>However, if I move forward, the disposed message is not printed. What is the proper way to dispose the observable?</p>
","6032312","","","","","2018-08-22 20:26:07","How to dispose RxSwift observable in viewmodel","<ios><dispose><rx-swift>","2","0","2","","","CC BY-SA 4.0"
"51950671","1","51955679","","2018-08-21 14:13:17","","1","649","<p>I'm new to RXswift and currently working in a project that requires rxswift with UITableView inside of UITableViewCell</p>

<p>Below are some of the codes I've done so far, but every time scroll up/down, it doesn't show the right value</p>

<pre><code>    var disposeBag = DisposeBag()

    viewModel.listExperience.asObservable().bind(to: tableView.rx.items(cellIdentifier: cellExperienceTableViewCell.getCellId(), cellType: ExperienceTableViewCell.self)){
            row , data, cell in

             cell.lblTitle.text = data.title ?? """"
             cell.lblDate.text = data.startDate ?? """"
             cell.lblDetails.text = data.body ?? """"

            let filtered = self.viewModel.getDataCommentInRow(row) /* returns Variable&lt;[Comments]&gt; */
             cell.setCommentTableView(row: row, filtered: filtered)
             cell.tableViewOffset = self.storedOffsets[row] ?? 0
             cell.tableViewComments.reloadData()

           }.disposed(by: disposeBag)
</code></pre>

<p>here's the code of the tableView inside of my tableView cell </p>

<pre><code>  func setCommentTableView(row : Int, filtered  : Variable&lt;[ExperienceComment]&gt;){

    tableViewComments.tag = row
    filtered.asObservable().bind(to: tableViewComments.rx.items(cellIdentifier: commentCell.getCellId(), cellType: CommentCell.self)){  indexPath , data, cell in
        cell.lblComment.text = data.body
      }.disposed(by: disposeBag)
}
</code></pre>

<p>Anyone knows how to achieve this? thanks</p>
","2276573","","2276573","","2018-08-22 00:43:55","2018-08-22 00:43:55","How to implement in RXswift and RXCocoa of UITableView Inside of tableview cell?","<rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"51962140","1","51962496","","2018-08-22 07:50:29","","2","102","<p>I'm confused about behavior of subscribe method in RxSwift.<br>
This is sample code.</p>

<pre><code>let observer1 = PublishSubject&lt;String&gt;()
let observer2 = PublishSubject&lt;String?&gt;()

let observable1 = Observable.just("""")
let observable2 = observable1.map { $0 }

_ = observable1.subscribe(observer1) // #1. OK
_ = observable1.subscribe(observer2) // #2. Error
_ = observable2.subscribe(observer2) // #3. Error
_ = observable1.map{ $0 }.subscribe(observer2) // #4. OK
</code></pre>

<p>I understand that #2 and #3 get an error.<br>
Because the observer is a nullable-string type, it is strictly different from the type that the observable holds.</p>

<p>But I can not understand #4.<br>
If directly subscribe of the mapped observable, it did not get an error.<br>
As shown in #3, the return value of the mapped observable1 was Observable.</p>

<p>I look forward to reply.</p>
","10257955","","2463616","","2018-08-22 07:51:49","2018-08-22 08:24:12","RxSwift - behavior of subscribe(observer:)","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"51965193","1","51969563","","2018-08-22 10:49:31","","4","494","<p>I am using RxMoya for the network layer of my app and I'm having a case where the server can either send the expected response (let's say a <code>User</code>), or an error object, both with status code 200. For example:</p>

<pre><code>{
  ""name"": ""john doe"",
  ""username"": ""john_doe""
}
</code></pre>

<p>could be the expected response and </p>

<pre><code>{
  ""error"": {
    ""code"": 100,
    ""message"": ""something went wrong™""
  }
}
</code></pre>

<p>could be the error.</p>

<p>The relevant part of the network adapter could look like this:</p>

<pre><code>    return provider
        .rx
        .request(MultiTarget.target(target))
        .map(User.self)
        // if above fails, try:
        // .map(UserError.self)
        .asObservable()
</code></pre>

<p>Is there a way to firstly try and <code>.map(User.self)</code> and if that fails, try to <code>.map(UserError.self)</code> in the same chain of operations? In other words, could I provide an alternative mapping model using Rx?</p>
","289501","","","","","2018-09-06 15:43:01","Is it possible to map to a ""fallback"" Decodable using RxSwift and Moya?","<ios><rx-swift><rx-cocoa><moya>","1","0","","","","CC BY-SA 4.0"
"51985484","1","51986593","","2018-08-23 12:08:14","","8","5381","<p>Let's say I have the following: </p>

<pre><code>let theSubject = PublishSubject&lt;String&gt;()
let theObservable = Observable.just(""Hello?"")
</code></pre>

<p>How do I set the <code>theSubject</code> to observer <code>theObservable</code>? </p>

<blockquote>
  <p>In RxSwift we say that a subject is an observer and can subscribe
  to one or more Observables...</p>
</blockquote>

<p>Can you show a simple code example of how I can connect <code>theSubject</code> as an observer of <code>theObservable</code> ? </p>
","834333","","2463616","","2018-08-23 12:09:08","2019-04-26 12:12:24","In RxSwift how can I set up a Subject to observe another Observable?","<ios><swift><rx-swift>","2","0","1","","","CC BY-SA 4.0"
"52002347","1","52005303","","2018-08-24 10:19:03","","0","197","<p>Im new to RxSwift and working on with one of the application.
I had come across an issue where in my viewModel i get a custom DriverType(because of my algorithms or function calls which i needed in my case), 
say : <code>Driver&lt;MyOwnObjectType&gt;</code>. Now i want to convert this to <code>MyOwnObjectType</code>. I know i can do this by having the binders in the respective viewcontroller, like  below ex:</p>

<pre><code>    fileprivate var testing: Binder&lt;MyOwnObjectType&gt; {
       return self.rx.selfBinder {_self, _value in
       // value is the actual MyOwnObjectType
       // Can i able to return this value?
      }
    }
</code></pre>

<p>But now i want to avoid the above , just wanted to retrieve the value <code>MyOwnObjectType</code>, or is there any way to bind using some method and return the value we bind?</p>

<p>Thanks in advance.</p>
","5068572","","2664437","","2018-08-27 09:37:00","2018-08-27 09:37:00","RxSwift Custom DataType Convertion without Binders","<swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"52025923","1","52036192","","2018-08-26 11:46:53","","1","3300","<p>I'm getting a cryptic message from the compiler, and am trying to debug it, since this code worked on one of teammate's machines. Are we using different versions of RXSwift? </p>

<p><strong>How can I bind a UIButton.rx to a PublishRelay of type Void ?</strong></p>

<pre><code>import SnapKit
import RxSwift
import RxCocoa


var startButton: UIButton
var tapStartButtonRelay: PublishRelay&lt;Void&gt;

startButton.rx.tap
           .bind(to: tapStartButtonRelay)
//get Cannot invoke 'bind' with an argument list of type '(to: PublishRelay&lt;Void&gt;)'
</code></pre>
","967484","","","","","2018-08-27 10:38:21","iOS RXSwift4 Cannot invoke 'bind' with an argument list of type '(to: PublishRelay<Void>)'","<swift4><ios11><rx-swift>","2","0","1","","","CC BY-SA 4.0"
"52040599","1","52045740","","2018-08-27 13:32:14","","0","229","<p>Hello i am quite newbie in RxSwift and Swift.</p>

<p>I am getting following error
""Cannot call value of non function type ((ResponseTestData) -> Swift.Void)?""</p>

<p>My first question is why i am getting this error when i call onResult(result!) ???</p>

<pre><code>func getTestList(perPage : String, pageNum : String, onResult: ((ResponseTestData) -&gt; Swift.Void)? = nil, onFail: ((Error) -&gt; Swift.Void)? = nil, disposeBag : DisposeBag)
{
    let tmpRx : RxManager
    tmpRx = RxManager()

    tmpRx.fetchTestData(perPage : perPage, pageNum : pageNum)
        .debug()
        .observeOn(MainScheduler.instance)
        .subscribeOn(MainScheduler.instance)
        .subscribe(
            onNext:
            {
                (result : ResponseTestData)-&gt;() in
                onResult(result!)
                print(result.result!)
            },
            onError:
            {
                _ in
                print("""")
            },
            onCompleted:
            {
                print("""")
            }

        )
        .disposed(by: disposeBag)
</code></pre>
","5343033","","5343033","","2018-08-27 15:37:55","2018-08-27 19:19:13","Cannot call value of non function type error in RxSwift?","<ios><swift><rx-swift><reactive>","1","0","","","","CC BY-SA 4.0"
"52050486","1","52078703","","2018-08-28 05:09:14","","3","4508","<p>I have just started working with RxSwift and facing some challenges. I have created tableview with multiple section and able to tap and get details. However if I try to delete any particular cell, its not working. I am not sure what I am doing wrong in RxSwift. Below is my code.</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    // Do any additional setup after loading the view, typically from a nib.

    let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;String, User&gt;&gt;(
      configureCell: { (_, tv, indexPath, element) in
        let cell = tv.dequeueReusableCell(withIdentifier: ""Cell"", for: indexPath)
        cell.textLabel?.text = string
        cell.textLabel?.numberOfLines = 0
        return cell
      },
      titleForHeaderInSection: { dataSource, sectionIndex in
        return dataSource[sectionIndex].model
      }
    )
    dataSource.canEditRowAtIndexPath = { dataSource, indexPath  in
      return true
    }

    viewModel.getUsers()
      .bind(to: tableView.rx.items(dataSource: dataSource))
      .disposed(by: disposeBag)

    tableView.rx
      .itemSelected
      .map { indexPath in
        return (indexPath, dataSource[indexPath])
      }
      .subscribe(onNext: { pair in
        print(""Tapped \(pair.1) @ \(pair.0)"")
      })
      .disposed(by: disposeBag)


    tableView.rx.itemDeleted
      .subscribe{
        print($0)
      }
      .disposed(by: disposeBag)

    tableView.rx
      .setDelegate(self)
      .disposed(by: disposeBag)
  }
</code></pre>
","833605","","833605","","2018-08-29 05:27:55","2018-08-29 13:41:15","iOS: How to delete cell in tableview using RxSwift","<ios><iphone><swift><rx-swift>","1","0","3","","","CC BY-SA 4.0"
"52079393","1","","","2018-08-29 14:05:57","","1","688","<p>I'm using RxSwift to observe the frame of one UIView. Here is my code in the view</p>

<pre><code>self.rx.observe(CGRect.self, #keyPath(UIView.frame))
    .subscribe(onNext: { frame in
        print(""Got new frame \(frame)"")
    })
    .debug()
    .disposed(by: disposeBag)
</code></pre>

<p>But it only prints once and won't run the second time when I change view frame. Does anyone know why this happen? Thanks in advance!</p>
","1684847","","4149826","","2018-08-30 12:24:06","2020-03-04 01:00:41","Why the observable on frame of UIView only trigger once after subscribing","<ios><swift><rx-swift><reactivex>","1","2","","","","CC BY-SA 4.0"
"52079769","1","","","2018-08-29 14:21:55","","0","149","<p>I'm writing logic for checking status of an object every t seconds until it's completed. I decided to use <code>retryWhen</code> operator.</p>

<pre><code>getObjectStatus(someObject: someObjectInstance)
    .flatMap { someObject -&gt; Observable&lt;SomeObject&gt; in
        if someObject.status == .notProcessed {
            return .error(SomeObjectNotProcessed())
        } else {
            return .just(someObject)
        }
    }
    .retryWhen { errors -&gt; Observable&lt;Void&gt; in
        let retry = errors.enumerated().flatMap { retryCount, error -&gt; Observable&lt;Void&gt; in
            guard retryCount &lt; statusRequestCount else {
                print(""The maximum number of request has been reached."")
                return .error(error)
            }

            if error is SomeObjectNotProcessed {
                return Observable.just(Void())
                        .delay(statusRequestDelay, scheduler: BackgroundScheduler.instance)
            } else {
                return .error(error)
            }
        }

        return retry
    }
    .subscribeOn(BackgroundScheduler.instance)
    .observeOn(MainScheduler.instance)
    .subscribe(onNext: { [weak self] someObject in
        self?.someObjectProcessingSucceeded()
    }, onError: { [weak self] error in
        self?.someObjectProcessingFailed(error: error)
    })
    .disposed(by: disposeBag)
</code></pre>

<p>Where the <code>getObjectStatus</code> method create request to the server. </p>

<p>Now the problem is that with this code every t seconds (<code>statusRequestDelay</code> actually) I'm not making a request to the server. Every t seconds it returns the same instance of <code>someObject</code>. If I replace <code>getObjectStatus</code> with:</p>

<pre><code>Observable.just(Void())
    .flatMap { _ in self.getObjectStatus(someObject: someObjectInstance) }
</code></pre>

<p>it works perfectly, which means that it makes server request every t seconds. It looks like the first, original <code>Observable</code> is not repeating.</p>
","4386668","","","","","2018-08-31 11:51:21","retryWhen is not resubscribing source as expected","<ios><swift><rx-swift>","1","3","","","","CC BY-SA 4.0"
"52103850","1","","","2018-08-30 19:07:05","","0","1126","<p>I tried a couple of variations in podfile to no avail...I assumed it was pod 'RxSwft', '-> 4.2' but get an error that is less than descriptive.</p>
","3208377","","","","","2018-08-31 17:07:29","Does anyone know where to get RxSwift Pod for xcode 10 and swift 4.2?","<xcode><rx-swift>","1","0","","","","CC BY-SA 4.0"
"52113899","1","","","2018-08-31 10:52:27","","2","1268","<p>I am using RxSwift for reactive programming and want to test my View Model.
I have debounce like this:</p>

<p>In View Model:</p>

<pre><code>let personNameMessage = input.personName.debounce(0.5).map { name -&gt; String in
    return ""Person Name = \(name)""
}
return Driver.just(personNameMessage)
</code></pre>

<p>and then in Test Case:</p>

<pre><code>let scheduler = TestScheduler(initialClock: 0)
let personNameInput = scheduler.createHotObservable([next(100, ""John Doe"")])
let personObserver = scheduler.createObserver(String.self)
output.personNameWelcome
    .asObservable()
    .subscribe(personObserver)
    .disposed(disposeBag)

scheduler.start()

print(observer.events)
</code></pre>

<p>But it did not emitting the event. I've try adding <code>scheduler.advanceBy(550)</code> after <code>scheduler.start()</code> but the results are the same.</p>

<p>Please help.</p>

<p>Thank you.</p>
","2601764","","","","","2020-09-26 13:16:04","How to unit test RxSwift which has debounce before output the next?","<ios><reactive-programming><rx-swift><debouncing><debounce>","3","1","","","","CC BY-SA 4.0"
"52115380","1","","","2018-08-31 12:21:40","","2","1265","<p>I am trying to consume an api with alamofire and rxswift. I have written the methods but the <strong>onNext</strong> of the observer is getting called only once. I am trying to do it with recursive call. What is wrong with this?
Api will return 10 object at a time based on the timestamp. So I am checking if just returned array contains 10 objects. If yes then there are more, if not then that's the end.</p>

<pre><code>func fetchPersonalization(fromList:[Personalization],timeStamp:Int) -&gt; Observable&lt;PersonalizationContainer&gt;
    {


        let dictHeader = [""Accept"":""application/json"",""regid"" :  pushtoken , ""os"" : ""ios"" , ""token"" : token , ""App-Version"" : ""1324"" ,  ""Content-Type"" :  ""application/json""]

        return fetchPersonalizationUtil(dictHeader: dictHeader, timeStamp: timeStamp)
            .flatMap { (perList) -&gt; Observable&lt;PersonalizationContainer&gt; in

                    let persoList:[Personalization] = perList.list
                    let finalList = fromList + persoList
                    if(persoList.count==10){
                        let newTimeStamp = persoList.last!.lastModifiedAt! - 1

                        return Observable.merge(Observable.just(PersonalizationContainer(l: finalList, d: perList.data)),
                            self.fetchPersonalization(fromList:finalList,timeStamp: newTimeStamp)
                        )
                            //self.fetchPersonalization(fromList:finalList,timeStamp: newTimeStamp)



                    }else {
                        return Observable.just(PersonalizationContainer(l: finalList, d: Data()))
                    }

        }
    }

    func fetchPersonalizationUtil(dictHeader:[String:String],timeStamp:Int) -&gt; Observable&lt;PersonalizationContainer&gt;
    {

        return Observable&lt;PersonalizationContainer&gt;.create({ (observer) -&gt; Disposable in
            Alamofire.request(""https://mranuran.com/api/hubs/personalization/laterthan/\(timeStamp)/limit/10/"" ,headers: dictHeader).responseData { response in
                if let json = response.result.value {
                    //print(""HUBs JSON: \(json)"")

                    do {
                        let list = try JSONDecoder().decode([Personalization].self, from: json)
                        let pContainer = PersonalizationContainer(l: list, d: json)
                        print(""ANURAN \(list[0].name)"")
                        observer.onNext(pContainer)
                        observer.onCompleted()
                    }catch {
                        print(error)
                        observer.onError(error)
                    }

                }
                else{
                    observer.onError(response.result.error!)
                }
            }

            return Disposables.create()
        })

    }
</code></pre>

<p>I put a break point on the onNext method and it seemed it's getting called only once. Stuck with this for hours and RxSwift's GithubRepo example in their official github repo, I can't figure it out what they are doing. What can be wrong with my process?</p>
","4728835","","","","","2020-01-21 19:29:11","How to use pagination using RxSwift and Alamofire?","<swift><alamofire><reactive-programming><rx-swift>","2","1","","","","CC BY-SA 4.0"
"52116884","1","","","2018-08-31 13:47:51","","10","4780","<p>I'm learning RxSwift and I've come across the following pattern when creating Observables:</p>

<pre><code>return Observable.create { observer in

    let disposable = Disposables.create()

    // Do some stuff with observer here

    return disposable
}
</code></pre>

<p>As far as I can tell the returned Disposable doesn't actually do anything, does it serve a purpose other than to meet the requirements of the API to return a Disposable?</p>

<p>Is there any scenario where you might need to return a configured Disposable?</p>

<p>I suppose the thing that's confusing me the most is that the returned Disposable seems separate from the implementation of the Observable being created, i.e. it's not assigned to any properties or passed anywhere it's just created and returned.</p>
","5165429","","5165429","","2019-05-29 10:36:03","2019-05-29 10:36:03","Purpose of Disposables.create() in RxSwift","<ios><swift><rx-swift>","2","1","","","","CC BY-SA 4.0"
"52123969","1","52127656","","2018-09-01 00:34:56","","1","883","<p>I'm using the logic below to check the state of my subject using RxBlocking. I'm getting a weird value of <code>Int??</code> out of <code>try? subject.verifier.toBlocking().first()</code>. </p>

<p>The syntax below pleases the compiler but makes my eyes bleed. </p>

<p><strong>How do I get an unwrapped value out of RXBlocking expectation?</strong></p>

<pre><code>func checkSubjectState() -&gt; Int
    {
      let updatedChecksum = try? subject.verifier.toBlocking().first() ?? 0
      return updatedChecksum ?? 0
    }

let expectedCheckSum = checkSubjectState()
expect(expectedCheckSum).to(equal(knownValue))
</code></pre>
","967484","","967484","","2018-09-08 11:51:42","2018-09-08 11:51:42","iOS RxSwift - How to unwrap an `Optional<Optional<T>>` or `T??`?","<swift><unit-testing><swift4><rx-swift><rx-blocking>","4","5","1","","","CC BY-SA 4.0"
"52128465","1","","","2018-09-01 13:15:36","","1","1230","<p>I'm trying to understand how to correctly use <code>TestScheduler</code> from <code>RxTest 4.2</code> for <code>RxSwift 4.2</code>.</p>

<p><strong>How do I correctly create TestScheduler and pass it events which would terminate the scheduler after all events are executed?</strong></p>

<p>The code below goes into infinite loop upon starting the test scheduler. Because it keeps looping synchronously, I have no opportunity to stop the scheduler from the test</p>

<pre><code>    var testScheduler: TestScheduler = TestScheduler(initialClock: 0)

    let stateObserver = testScheduler.createObserver(Bool.self)
    subject.outputRelay.bind(to: stateObserver).disposed(by: bag)

    let events = [next(1,true), next(10,false)]
    let hotObservable = testScheduler.createHotObservable(events)

    //direct events to the given relay
    hotObservable.bind(to: subject.inputRelay).disposed(by: bag)

    testScheduler.start() //infinite loop

//do not get called
    XCTAssertEqual(stateObserver.events, [next(0, InterfaceState.started)])
    testScheduler.stop()
</code></pre>

<p>I've narrowed the issued down to this method call within <code>TestScheduler</code>. It seems there's something wrong with the subscription disposal</p>

<pre><code> func findNext() -&gt; VirtualSchedulerItem&lt;VirtualTime&gt;? {
        while let front = _schedulerQueue.peek() {
            if front.isDisposed {
                //this never gets called
                _schedulerQueue.remove(front)
                continue
            }

            return front
        }

        return nil
    }
</code></pre>
","967484","","","","","2018-09-03 09:40:31","iOS RxSwift - testing with RxTest and TestScheduler does not end / terminate test case","<swift><unit-testing><rx-swift><swift4.2><rxtest>","1","1","","","","CC BY-SA 4.0"
"52136440","1","52136747","","2018-09-02 11:12:23","","1","730","<p>I'm looking for example of Amb() operator for RxSwift.</p>

<p>I have two observables - started and stopped and I want to create code which would execute if one of them emits, while ignoring emissions from the other one. </p>

<pre><code>let started = viewModel.networkAPI.filter { result in
            switch result {
            case .success:
                return true
            case .failure:
                return false
            }
        }

    let stopped = viewModel.networkAPI.filter { result in
        switch result {
        case .success:
            return true
        case .failure:
            return false
        }
    }
</code></pre>

<p>I tried:</p>

<pre><code>    Observable&lt;Bool&gt;.amb([started, stopped])
//error - Ambiguous reference to member 'amb'
//Found this candidate (RxSwift.ObservableType)
//Found this candidate (RxSwift.ObservableType)
</code></pre>

<p>and:</p>

<pre><code> started.amb(stopped)
//error - Generic parameter 'O2' could not be inferred
</code></pre>

<p><strong>How do I properly use RxSwift AMB operator to pick one of two observables to emit a value first?</strong> </p>
","967484","","","","","2018-09-02 13:18:25","iOS RxSwift - how to use Amb Operator?","<ios><swift3><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"52137376","1","52137397","","2018-09-02 13:13:14","","2","1402","<p>I'm only interested in results with <code>.success</code> type that come from my query. </p>

<p><strong>How can I set a filter to only pass through .success results from <code>Result&lt;Value&gt;</code> enum?</strong></p>

<pre><code>public enum Result&lt;Value&gt; {
    case success(Value)
    case failure(Error)
}


query.filter{ (result: Result&lt;Double&gt;) in
                switch result {
                case .success:
                    return true
                case .failure:
                    return false
                }
            }
</code></pre>

<p>I want to do shorthand check for success only, but compiler does not allow this. </p>

<pre><code>.filter{result in
    return result == .success
}
</code></pre>
","967484","","","","","2019-02-27 22:19:14","iOS RxSwift how to check if Result == .success?","<ios><swift><enums><reactive-programming><rx-swift>","1","1","1","","","CC BY-SA 4.0"
"52151767","1","","","2018-09-03 14:31:10","","2","1764","<p>I want to set a limit for characters in a textFiled using RxSwift, 
may be i can benefit from <code>Scan</code> operator but i don't know how to use it in this case ,</p>

<p>I want my resulting code to behave as same as implementing it in <code>shouldChangeCharacterInRage</code> method:</p>

<pre><code>   func textField(_ textField: UITextField,
                   shouldChangeCharactersIn range: NSRange,
                   replacementString string: String)
        -&gt; Bool {
            if textField == baseTextFiled{
                let enteredString = (textField.text! as NSString).replacingCharacters(in: range, with: string)
                if enteredString.count &gt; limit{ // limit defined previously
                    return false
                }
            }
            return true
    }
</code></pre>

<p>Any help?</p>
","4982152","","","","","2018-09-03 14:58:15","Set Limit for TextField characters in RxSwift","<rx-swift>","1","1","","2018-09-04 14:15:55","","CC BY-SA 4.0"
"52162086","1","52173819","","2018-09-04 08:33:42","","0","1792","<p>I made Observable of Bool type as below</p>

<pre><code>let allValid: Observable&lt;Bool&gt;

//All valid is combination of two more Observable&lt;Bool&gt;
allValid = Observable.combineLatest(checkBoxValid, reasonValid) { $0 &amp;&amp; $1 }
</code></pre>

<p>Now I want to check when Done button is pressed, call respective method based on value of AllValid.</p>

<pre><code>public func doneButtonPressed() {
//Here I have two methods, and to be called, when AllValid is true and false

//self.method1()
//self.method2()
}
</code></pre>

<p>Now how to make it. I cannot bind directly as it will trigger, and I want to trigger when Done is pressed. </p>
","3649855","","","","","2018-09-04 20:50:43","Observable<Bool> If else in RxSwift","<swift><observable><rx-swift>","1","1","","","","CC BY-SA 4.0"
"52164680","1","52174038","","2018-09-04 10:55:54","","2","1835","<p>I have been experimenting with some new swift architectures and patterns and I have noticed a strange issue with RxSwift where it seems if I am making a service call and an error occurs - e.g. user enters wrong password - then it seems to dispose of my subscriptions so I cannot make the service call again</p>

<p>I am unsure as to why this happening. I made a quick mini project demonstrating the issue with a sample login app. </p>

<p>My ViewModel looks like this</p>

<pre><code>import RxSwift
import RxCocoa
import RxCoordinator
import RxOptional
extension LoginModel : ViewModelType {
    struct Input {
        let loginTap : Observable&lt;Void&gt;
        let password : Observable&lt;String&gt;
    }

    struct Output {
        let validationPassed : Driver&lt;Bool&gt;
        let loginActivity : Driver&lt;Bool&gt;
        let loginServiceError : Driver&lt;Error&gt;
        let loginTransitionState : Observable&lt;TransitionObservables&gt;
    }

    func transform(input: LoginModel.Input) -&gt; LoginModel.Output {
        // check if email passes regex
        let isValid = input.password.map{(val) -&gt; Bool in
            UtilityMethods.isValidPassword(password: val)
        }

        // handle response
        let loginResponse = input.loginTap.withLatestFrom(input.password).flatMapLatest { password in
            return self.service.login(email: self.email, password: password)
        }.share()

        // handle loading
        let loginServiceStarted = input.loginTap.map{true}
        let loginServiceStopped = loginResponse.map{_ in false}
        let resendActivity = Observable.merge(loginServiceStarted, loginServiceStopped).materialize().map{$0.element}.filterNil()

        // handle any errors from service call
        let serviceError = loginResponse.materialize().map{$0.error}.asDriver(onErrorJustReturn: RxError.unknown).filterNil()

        let loginState = loginResponse.map { _ in
            return self.coordinator.transition(to: .verifyEmailController(email : self.email))
        }

        return Output(validationPassed : isValid.asDriver(onErrorJustReturn: false), loginActivity: resendActivity.asDriver(onErrorJustReturn: false), loginServiceError: serviceError, loginTransitionState : loginState)
    }
}

class LoginModel {
    private let coordinator: AnyCoordinator&lt;WalkthroughRoute&gt;
    let service : LoginService
    let email : String
    init(coordinator : AnyCoordinator&lt;WalkthroughRoute&gt;, service : LoginService, email : String) {
        self.service = service
        self.email = email
        self.coordinator = coordinator
    } 
}
</code></pre>

<p>And my ViewController looks like this</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa
class TestController: UIViewController, WalkthroughModuleController, ViewType {

    // password
    @IBOutlet var passwordField : UITextField!

    // login button
    @IBOutlet var loginButton : UIButton!

    // disposes of observables
    let disposeBag = DisposeBag()

    // view model to be injected
    var viewModel : LoginModel!

    // loader shown when request is being made
    var generalLoader : GeneralLoaderView?

    override func viewDidLoad() {
        super.viewDidLoad()

    }
    // bindViewModel is called from route class
    func bindViewModel() {
        let input = LoginModel.Input(loginTap: loginButton.rx.tap.asObservable(), password: passwordField.rx.text.orEmpty.asObservable())

        // transforms input into output
        let output = transform(input: input)

        // fetch activity
        let activity = output.loginActivity

        // enable/disable button based on validation
        output.validationPassed.drive(loginButton.rx.isEnabled).disposed(by: disposeBag)

        // on load
        activity.filter{$0}.drive(onNext: { [weak self] _ in
            guard let strongSelf = self else { return }
            strongSelf.generalLoader = UtilityMethods.showGeneralLoader(container: strongSelf.view, message: .Loading)
        }).disposed(by: disposeBag)

        // on finish loading
        activity.filter{!$0}.drive(onNext : { [weak self] _ in
            guard let strongSelf = self else { return }
            UtilityMethods.removeGeneralLoader(generalLoader: strongSelf.generalLoader)
        }).disposed(by: disposeBag)

        // if any error occurs
        output.loginServiceError.drive(onNext: { [weak self] errors in
            guard let strongSelf = self else { return }

            UtilityMethods.removeGeneralLoader(generalLoader: strongSelf.generalLoader)

            print(errors)
        }).disposed(by: disposeBag)

        // login successful
        output.loginTransitionState.subscribe().disposed(by: disposeBag)
    }
}
</code></pre>

<p>My service class</p>

<pre><code>import RxSwift
import RxCocoa

struct LoginResponseData : Decodable {
    let msg : String?
    let code : NSInteger
}

    class LoginService: NSObject {
        func login(email : String, password : String) -&gt; Observable&lt;LoginResponseData&gt; {
            let url = RequestURLs.loginURL

            let params = [""email"" : email,
                          ""password"": password]

            print(params)

            let request = AFManager.sharedInstance.setupPostDataRequest(url: url, parameters: params)
            return request.map{ data in
                return try JSONDecoder().decode(LoginResponseData.self, from: data)
            }.map{$0}
        }
    }
</code></pre>

<p>If I enter valid password, request works fine. If I remove the transition code for testing purposes, I could keep calling the login service over and over again as long as password is valid. But as soon as any error occurs, then the observables relating to the service call get disposed of so user can no longer attempt the service call again</p>

<p>So far the only way I have found to fix this is if any error occurs, call bindViewModel again so subscriptions are setup again. But this seems like very bad practice.</p>

<p>Any advice would be much appreciated!</p>
","1047978","","","","","2019-11-28 19:30:20","RxSwift errors dispose of subscriptions","<swift><rx-swift>","2","1","1","","","CC BY-SA 4.0"
"52182054","1","52183933","","2018-09-05 09:47:11","","0","647","<p>I need to make multiple calls. </p>

<p><strong>1. Delete Document Upload</strong> </p>

<p><strong>2. Image 1 &amp; server returns URL</strong></p>

<p><strong>3. Upload Image 2 &amp; server returns URL</strong></p>

<p><strong>4. Create Document API contains both URLs &amp; extra<br>
        parameters.</strong></p>

<p>The code which I tried to write is in RxSwift,&amp; MVVM.</p>

<pre><code>  let resultOfDocumentUpdateWithDelete =
            donepressed
                .filter{ $0 }
                .withLatestFrom(self.existingDocumentIDChangedProperty)
                .flatMapLatest {id in
                    let deleted_document = apiClient.deleteDocument(id).asObservable().materialize()
                    let upload_frontImage = deleted_document
                        .withLatestFrom(self.frontImageNameChangedProperty)
                        .flatMapLatest {image in
                            apiClient.uploadImage(image: image!).asObservable().materialize()
                    }
                    let upload_backImage = upload_frontImage
                        .withLatestFrom(self.backImageChangedProperty)
                        .flatMapLatest {image in
                            apiClient.uploadImage(image: image!).asObservable().materialize()
                    }

                    let upload_document = upload_backImage
                        .withLatestFrom(self.parametersChangedProperty)
                        .flatMapLatest {parameters in
                            apiClient.uploadDocument(parameters: parameters)
                    }

                    return upload_document.materialize()
                }
                .share(replay: 1)
</code></pre>

<p>Make sure, two responses of server are input in last API, so all of these will be called in a sequence. </p>

<p>how to do in RxSwift. </p>
","3649855","","","","","2018-09-06 11:41:28","Unable to infer complex closure return type; add explicit type to disambiguate in RxSwift","<swift><rx-swift><flatmap>","1","0","","","","CC BY-SA 4.0"
"52221974","1","","","2018-09-07 11:51:05","","0","604","<p>In my code I do it like this:</p>

<pre><code>let recognizer = UITapGestureRecognizer()
mainView.messagesView.addGestureRecognizer(recognizer)
_ = recognizer.rx.event.bind { _ in
    self.mainView.dismissKeyboard()
}.disposed(by: bag)
</code></pre>

<p>But now I need to test it:</p>

<pre><code>func testIfKeyboardIsDismissedAfterMessageViewWasTapped() {
    let view = ThreadView()
    let model = StubThreadViewModel()
    let controller = ThreadViewController(view: view, viewModel: model)
    controller.viewDidLoad()
    let window = UIWindow()
    window.addSubview(view)
    view.textView.becomeFirstResponder()
    XCTAssertTrue(view.textView.isFirstResponder) //TRUE, test passes
    view.messageView. //Here I dont know how to force tap manually
    XCTAssertFalse(view.textView.isFirstResponder) //FALSE, test fails
}
</code></pre>
","2725435","","2463616","","2018-09-10 14:06:31","2018-09-10 14:06:31","How to manually invoke gesture recognizer registered with RxSwift?","<ios><swift><rx-swift>","1","6","","","","CC BY-SA 4.0"
"52243856","1","52247241","","2018-09-09 11:04:58","","6","2842","<p>I want to prevent my UIButtons from emitting RX tap events until some control stream indicates that it is ready. I want buttons to be disabled again if the control stream reverts back to not ready. Control sequence is a <code>ReplaySubject</code> and always has value</p>

<p>I've tried <code>skipUntil</code>, but that's a one shot operation - once the control sequence emits, it cannot go back to disabled state - all button presses will go through, ignoring the control sequence</p>

<p><strong>How can I restrict a UIButton from sending tap events unless some other stream has a certain value?</strong></p>

<pre><code>let enableButtons = configStatusInputSequence
.filter { (configured, ready) -&gt; Bool in
    return configured &amp;&amp; ready
}

for button in controlButtons{
    button.rx.tap
        .skipUntil(enableButtons)
        .bind(to: commandOutputSequence)
        .disposed(by: bag)
}
</code></pre>
","967484","","","","","2020-06-06 11:19:01","RxSwift how to conditionally control when a button emits taps?","<ios><swift><reactive-programming><rx-swift><control-flow>","1","4","1","","","CC BY-SA 4.0"
"52256887","1","","","2018-09-10 11:30:49","","1","3078","<p>I need to style <code>UIButton</code> depends on values from two <code>textFields</code>:</p>

<pre><code>Observable.combineLatest(loginProperty.asObservable(), passwordProperty.asObservable()) { _, _ in
    self.viewModel.isValid
}.bind(to: mainView.loginButton.rx.isValid).disposed(by: bag)
</code></pre>

<p>Also I need to style UIButton depends on value from <strong>one text field</strong>, and above solution doesnt work. Why? What is the simple way to do that?</p>
","2725435","","","","","2018-09-12 10:39:20","RXSwift: How to bind value property to the button visibility?","<ios><swift><rx-swift>","2","4","1","","","CC BY-SA 4.0"
"52264303","1","52267688","","2018-09-10 19:30:05","","2","670","<p>I'm trying to create an observable sequence to indicate the status of Bluetooth on device. I'm using <code>ReplaySubject&lt;CBManagerState&gt;</code>, but am curious if there is something better, as I hear bad things about using <code>onNext()</code></p>

<p><strong>What is the appropriate way to connect callback delegates to the RxSwift observable domain?</strong></p>

<pre><code>class BluetoothStatusMonitor: NSObject, CBPeripheralManagerDelegate {
let bluetoothStatusSequence = ReplaySubject&lt;CBManagerState&gt;.create(bufferSize: 1)

var bluetoothPeripheralManager: CBPeripheralManager?

    func checkBluetoothStatus()
    {
        //silently check permissions, without alert

        let options = [CBCentralManagerOptionShowPowerAlertKey:0]
        bluetoothPeripheralManager = CBPeripheralManager(delegate: self, queue: nil, options: options)

    }
    func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager) {

        bluetoothStatusSequence.onNext(peripheral.state)
    }
}
</code></pre>
","967484","","","","","2018-09-11 02:07:08","iOS RxSwift how to connect Core bluetooth to Rx sequences?","<ios><swift><observable><core-bluetooth><rx-swift>","1","1","","","","CC BY-SA 4.0"
"52266381","1","52266668","","2018-09-10 22:35:58","","1","992","<p>I'm looking at <a href=""https://github.com/trilliwon/RxCoreBluetooth"" rel=""nofollow noreferrer"">this example of using reactive extensions with Core Bluetooth</a>. However, it is written in swift 3.0 and has a number of errors running in Swift 4.2. I'm interested in implementing a reactive extension of <code>CBCentralManager</code> to provide me with a RX stream of status events.</p>

<p>My understanding is that this allows the proxy to receive delegate events from the CBCentralManager and propagate them to observers using <code>_stateBehaviorSubject: BehaviorSubject&lt;CBManagerState&gt;?</code> However, the project has too many errors and I cannot figure out where do I cut to keep only the functionality I want. </p>

<p><strong>How do I implement the a reactive extension using DelegateProxy for CBCentralManager?</strong></p>

<pre><code>extension Reactive where Base: CBCentralManager {

  public var delegate: DelegateProxy {
    return RxCBCentralManagerDelegateProxy.proxyForObject(base)
  }

  public var state: Observable&lt;CBManagerState&gt; {
    let proxy = RxCBCentralManagerDelegateProxy.proxyForObject(base) //error here
    return proxy.stateBehaviorSubject.skip(1)
  }
}
</code></pre>
","967484","","","","","2018-09-11 01:23:12","iOS RxSwift 4.2 how to implement Reactive extension of CBCentralManager using DelegateProxy?","<ios><reactive-programming><core-bluetooth><rx-swift>","1","1","","","","CC BY-SA 4.0"
"52275006","1","","","2018-09-11 11:37:37","","0","153","<p>I'm working on a project using RxSwift + Swinject + Assembly but they are quite new to me.
I'm having a modal controller for filters selection. It uses FilterViewModel with all available filters.
I'm wondering how to pass selected filters to presenting view controller?
I now I could cast presenting view controller to expected type and set the filters as vc's property but I would like to make it proper way using DI and assembly.</p>
","507843","","1113632","","2018-09-12 20:27:14","2018-09-12 20:27:14","Passing data from modal to presenting vc using Swinject+Assembly","<dependency-injection><rx-swift><swinject>","0","3","","","","CC BY-SA 4.0"
"52293601","1","","","2018-09-12 11:03:04","","1","985","<p>I'm trying to observe the property ""isHighlighted"" on the object UIImageView, but seems like my code is not correct? Any idea?</p>

<pre><code>imageView.rx
.observe(Optional&lt;Bool&gt;.self, ""isHighlighted"")
.subscribe {

}
.disposed(by: disposeBag)
</code></pre>

<p>When I set the imageView highlighted, nothing subscribes.</p>
","385469","","385469","","2018-09-12 11:54:34","2019-04-25 12:43:53","RxSwift - UIImageView - observe property isHighlighted","<ios><iphone><swift><rx-swift>","3","1","","","","CC BY-SA 4.0"
"52311965","1","52313806","","2018-09-13 10:39:25","","3","3652","<p>I'm trying to periodically (every 10 seconds) call an API that returns a Json object of model :</p>

<pre><code>struct MyModel { 
   var messagesCount: Int?
   var likesCount: Int?
}
</code></pre>

<p>And update the UI if <code>messageCount</code> or <code>likesCount</code> value changes.
I tried the Timer solution but i find it a little bit messy and i want a cleaner solution with RxSwift and RxAlamofire.</p>

<p>Any help is highly appreciated as i'm new to Rx. </p>
","10285869","","","","","2018-09-15 09:35:37","Periodically call an API with RxSwift","<ios><swift><rx-swift><rxalamofire>","2","5","2","","","CC BY-SA 4.0"
"52324977","1","52325307","","2018-09-14 04:26:21","","3","3889","<p>I'm new in RXSwift and i defined an Observable interval timer sequence that calls a webservice method every second.
In that webservice response, i receive new retry time value that must replace with my current time.
How to reset this sequence with new time value?
This is my code :</p>

<pre><code>func mySequence() {

    /////////////////////////////////////// subscribe to Timer (time change)
    var time = try! self.timer.value()

    self.disposeTimer = timer.subscribe({  value in

        time = value.element!

        print(""=============================\(String(describing: time))======================================="")

    })
    /////////////////////////////////////// subscribe to Timer (time change)


    let   observable = Observable&lt;Int&gt;.interval(TIME I NEED TO CHANGE After response , scheduler: MainScheduler.instance).map { _ in ()
        self.myWebserviceMethod()
    }

    disposable =  observable.subscribe(onNext: {num in

    }, onError: { err in

    }, onCompleted: {

    }, onDisposed: {

    })

}
</code></pre>

<p>everything happens but interval timer time is still the old value :(</p>
","4516605","","","","","2018-09-14 05:09:45","How to reset the Observable interval operator in RXSwift?","<ios><swift><rx-swift>","1","3","","","","CC BY-SA 4.0"
"52332664","1","52336838","","2018-09-14 13:06:07","","2","525","<p>I have a big concern about how to manage object properties changes.</p>

<p>Imagine I have a ""car"" class, with some properties like ""name"", ""date"", ""price"" etc.</p>

<p>In my view ""A"", I'm displaying all cars I retrieve from a API. In a view B &amp; C, I can display and edit specific information about the car selected in the view A (let's say it's ""car AAA""). it's possible too, to refresh the car object with a API call to retrieve the last information about the car. </p>

<p>I want to be able to update the view A, if the user does something on the object car in another view. Or, if the user ""refreshed"" the car object to be sure to have the last data about this car. But if the user just changed the name of the car, I don't want to refresh all the UI in the view A just for that.. I want to know that just the name has changed.</p>

<p>What is the best way to catch any update for this car in the view A? Do I have to have a class which manage all properties of the car as ""PublishRelay"" or ""PublishSubject"", and play with this in my full app?</p>
","3307021","","","","","2018-09-14 20:06:44","RxSwift : manage object updates in the app","<swift><reactive-programming><rx-swift>","1","3","","","","CC BY-SA 4.0"
"52352542","1","","","2018-09-16 08:55:37","","1","2455","<p>I have an observable sequence which represent my displayed sessions as follow : </p>



<pre class=""lang-swift prettyprint-override""><code> private let displayedSessions =
 PublishSubject&lt;[ProgramDaySessionsModels.ViewModels.Session]&gt;()
</code></pre>

<p>And here is my ViewModel:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ViewModels {

        struct Session{
            let id : Int?
            let title : String?
            let location : String?
            var isAddedToCalendar : Bool?
            var isAddedToFavorite : Bool?
            let time : String?
        }
    }
</code></pre>

<p>The displayed sessions is being binded to a table view:</p>

<pre class=""lang-swift prettyprint-override""><code>func setupCellBinding(){
    displayedSessions
        .asObservable()
        .bind(to:
            tableView
                .rx
                .items(cellIdentifier:
                    R.reuseIdentifier.programDaySessionCell.identifier,
                       cellType: ProgramDaySessionCell.self)
        ){
            ( row, element, cell ) in

            cell.setup(withViewModel: element)
        }
        .disposed(by: disposeBag)
}
</code></pre>

<p>Now after i call the setup method in the cell, i want to subscribe to an image tap inside my cell, regardless what is the subscription logic will be ....</p>

<p>I want after that to update my displayed viewModel , for example i want to change the property <code>isAddedToCalendar</code> to false/true when the subscription logic end... </p>

<p><strong>My question is , How to update or change a value stored in the <code>Subject</code> <em>without calling</em> <code>onNext</code> operator</strong></p>
","4982152","","1113632","","2018-10-01 19:13:47","2018-10-01 19:13:47","Change the value of an object inside an Observable of sequence using RxSwift","<swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"52353925","1","","","2018-09-16 12:01:13","","0","229","<p>I am building an aggregator class that connects multiple observables and emits a single sequence of emissions from these observables:</p>

<p>5 inputs from sources go in, one input comes out from <code>ReplaySubject</code>. </p>

<p><strong>Is there a way to manage subscriptions within this aggregator to allow one of the sources to “disconnect” without breaking the whole chain?</strong></p>

<p>Would keeping a dictionary of <code>[Observable: Subscription</code>] help to be able to cancel a specific subscription?</p>
","967484","","","","","2018-09-16 18:12:48","iOS RxSwift - how to “disconnect” an observable?","<ios><swift><observable><rx-swift>","1","2","","","","CC BY-SA 4.0"
"52378364","1","52378538","","2018-09-18 03:15:36","","5","3431","<p>When I implement <code>UITextFieldDelegate</code> through RxSwift, I do this:</p>

<pre><code>self.textField_AddressType.rx.controlEvent(.editingDidBegin).subscribe { _ in
    // Code here...
}.disposed(by: self.disposeBag)
</code></pre>

<p>But when I apply it to <code>UITextView</code>, </p>

<pre><code>self.textView.rx.controlEvent(.editingDidBegin).subscribe { _ in
   // Code here...
}.disposed(by: self.disposeBag)
</code></pre>

<p>I get an error:</p>

<blockquote>
  <p>'UITextView' is not a subtype of 'UIControl'</p>
</blockquote>

<p>I couldn't find anything about this issue, is there another way to implement <code>UITextViewDelegate</code> in RxSwift?</p>
","3231194","","","","","2018-12-25 18:20:10","RxSwift Events of UITextView","<ios><swift><rx-swift>","2","0","2","","","CC BY-SA 4.0"
"52387657","1","","","2018-09-18 13:25:20","","0","320","<p>I have a UITableView that I set up to grow dynamically depending on the content, by setting:</p>

<pre><code>tableView.estimatedRowHeight = 100
tableView.rowHeight = UITableViewAutomaticDimension
</code></pre>

<p>My UITableView consists of a headerView and bodyView to which I insert other subviews after setting up.</p>

<p>I set up my cells with the follow rx:</p>

<pre><code>viewModel
   .map { $0.cellViewModels }
   .bind(to: tableView.rx.items(cellIdentifier: ""MyCell"", cellType: MyCell.self)) { [unowned self] (row, viewModel, cell) in
        cell.viewModel = viewModel
        // Tried adding the following with no luck:
        self.tableView.beginUpdates()
        self.tableView.endUpdates()
   }
   .disposed(by: disposeBag)
</code></pre>

<p>the cell's viewModel call's a setup() method with it's didSet, as follows:</p>

<pre><code>var viewModel: CellViewModel? {
    didSet { setup() }
}
</code></pre>

<p>In my setup, I add a subview to the bodyView of my cell depending on some other factors. ie I may add a picture, a bit of text, etc.</p>

<p>The problem is, when I add my subview to the bodyView of my cell, the cell's height is staying the original height that it was in the xib, and not resizing at that point to accommodate the new view. I've tried calling <code>self.layoutIfNeeded()</code> after adding the subview, but no luck. How can I resize my cell after adding a subview to it?</p>
","3356655","","3356655","","2018-09-18 13:45:15","2018-09-18 13:45:15","UITableViewCell wont resize after adding subview","<ios><swift><uitableview><rx-swift>","1","4","","","","CC BY-SA 4.0"
"52423475","1","52429745","","2018-09-20 10:53:16","","0","435","<p>Personally, I prefer extension methods with prefix in Swift. It makes easier to guess whether a function is from the original class or from the extension at first glance. Also, it makes frameworks more reusable in other projects. We don't need to search for the namespace in which the framework method belongs. However, adding prefix to all instance and static methods in extensions is a little bit exhaustive. For this reason, I want to create a module that contains all extension methods whether it is instance or static.</p>

<p>I have taken a look at <a href=""https://medium.com/@KaushElsewhere/better-way-to-manage-swift-extensions-in-ios-project-78dc34221bc8"" rel=""nofollow noreferrer"">this implementation</a>, and liked it but unfortunately it only works for instance methods:</p>

<pre><code>public protocol MyHelperCompatible {
    associatedtype someType
    var my: someType { get }
}

public extension MyHelperCompatible {
    public var my: MyHelper&lt;Self&gt; {
        get { return MyHelper(self) }
    }
}

public struct MyHelper&lt;Base&gt; {
    let base: Base
    init(_ base: Base) {
        self.base = base
    }
}

// All conformance here
extension UIColor: MyHelperCompatible { }
</code></pre>

<p>Using this, we're able to access instance methods as follows:</p>

<pre><code>let redImage = UIColor.red.my.toImage()
</code></pre>

<p>Do you know a way to apply a similar logic to add module to handle both instance and static methods? (e.g., <code>UIColor.my.staticMethod()</code>) What way do you advise to use for this issue?</p>
","4110172","","3212220","","2018-09-20 13:22:20","2018-09-20 16:45:47","A Swift module that contains all extension methods","<swift><extension-methods><rx-swift><swift-protocols>","1","5","1","","","CC BY-SA 4.0"
"52425810","1","","","2018-09-20 13:03:22","","8","5280","<p>I have a sequence made up of multiple operators. There are total of 7 places where errors can be generated during this sequence processing. I'm running into an issue where the sequence does not behave as I expected and I'm looking for an elegant solution around the problem:</p>

<pre><code>let inputRelay = PublishRelay&lt;Int&gt;()
let outputRelay = PublishRelay&lt;Result&lt;Int&gt;&gt;()

inputRelay
.map{ /*may throw multiple errors*/}
.flatmap{ /*may throw error*/ }
.map{}
.filter{}
.map{ _ -&gt; Result&lt;Int&gt; in ...}
.catchError{}
.bind(to: outputRelay)
</code></pre>

<p>I thought that <code>catchError</code> would simply catch the error, allow me to convert it to failure result, but prevent the sequence from being deallocated. However, I see that the first time an error is caught, the entire sequence is deallocated and no more events go through. </p>

<p>Without this behavior, I'm left with a fugly Results&lt;> all over the place, and have to branch my sequence multiple times to direct the <code>Result.failure(Error)</code> to the output. There are non-recoverable errors, so <code>retry(n)</code> is not an option:</p>

<pre><code>let firstOp = inputRelay
.map{ /*may throw multiple errors*/}
.share()

//--Handle first error results--
firstOp
.filter{/*errorResults only*/}
.bind(to: outputRelay)

let secondOp = firstOp
.flatmap{ /*may throw error*/ }
.share()

//--Handle second error results--
secondOp
.filter{/*errorResults only*/}
.bind(to: outputRelay)

secondOp
.map{}
.filter{}
.map{ _ -&gt; Result&lt;Int&gt; in ...}
.catchError{}
.bind(to: outputRelay)
</code></pre>

<p>^ Which is very bad, because there are around 7 places where errors can be thrown and I cannot just keep branching the sequence each time. </p>

<p><strong>How can RxSwift operators catch all errors and emit a failure result at the end, but NOT dispose the entire sequence on first error?</strong></p>
","967484","","967484","","2018-09-20 13:09:39","2018-09-22 21:56:41","iOS RxSwift how to prevent sequence from being disposed on (throw error)?","<ios><error-handling><observable><rx-swift><onerror>","2","1","5","","","CC BY-SA 4.0"
"52436734","1","52457361","","2018-09-21 04:43:50","","2","844","<p>I am trying to use MVVM without Rx in Objective C, basically something like MVP. I have some very basic doubts that I would like to clear</p>

<p>1.) How to load the initial view state in view, based on configuration. i.e. when the initial state of UI components can change based on some configuration values. For ex. A button in the view can initially be enabled/disabled/hidden based on the global configuration. How this initial view state should be rendered where there can be lots of UI components in a view?</p>

<ul>
<li>Should view model pass this config (or view state object) to view and view decides how to renders itself? or</li>
<li>Should View model pass the state of each UI element to the view?</li>
<li>In case of Rx should VM have one view state property or state properties of each UI component?</li>
</ul>

<p>2.) How to handle states of individual UI components?</p>

<ul>
<li>Should VM ever ask the view to update its view state via methods like enableButton1, hideTextView etc. or</li>
<li>It should just pass the ""events"" or data to the view and let the view decide how to react to these events.</li>
<li>In Rx world should view bind with individual state properties or to just event properties? </li>
</ul>

<p>3.) I am confused who should trigger certain operations, for instance, let's say ""validation"". For example in a login screen who should trigger the validation of email/password values?</p>

<ul>
<li>Should view ask VM to validate and then ask to execute login process or</li>
<li>Should view just pass the click action to VM with email/password values and VM decides whether to do validation or not and what to do if it passes or fails?</li>
</ul>
","792249","","","","","2018-09-22 13:57:40","iOS MVVM handling initial view state","<ios><mvvm><viewstate><rx-swift><reactive-cocoa>","1","0","","","","CC BY-SA 4.0"
"52464332","1","","","2018-09-23 08:24:05","","0","1492","<p>I am trying to implement a function that handles Network &amp; API errors, my problem is how to emit an observable again after filterSuccessfulStatusCodes(). 
The main issue I have is that I am not sure if this approach is correct, after the first subscribe.</p>

<p>The current error I have in this code is : Extra argument 'onError' in call</p>

<pre><code>func Request&lt;T: Decodable&gt;(_ request: APIManager) -&gt; 
Observable&lt;Result&lt;T&gt;&gt; {
    provider.rx
        .request(request)
        .subscribe(onSuccess: { (response) in
            try response.filterSuccessfulStatusCodes()
            return Observable.just(response)
                .subscribe { event in
                    switch event {
                    case .success:
                        .map(RequestResponse&lt;T&gt;.self)
                            .map { $0.result! }
                            .asObservable()
                            .map(Result.success)
                            .catchError { error in
                                return .just(.error(withMessage: ""Error \(error)""))
                        }
                    case .error:
                        print(""error"")
                    }
            }

        }, onError: { (error) in
            print(""network request error"")

        }, onCompleted: {
            print(""network request on completed"")
        }).disposed(by: disposeBag)
}

 struct RequestResponse&lt;T: Decodable&gt; {
    let statusCode: Int
    let statusMessage: String
    let success: Bool
    let result: T?
    let errorBag: String?
 }

 enum Result&lt;T: Decodable&gt; {
    case success(T)
    case error(withMessage: String)
 }
</code></pre>
","1273790","","","","","2018-09-24 13:12:21","RxMoya Network and Service Error handling in the same function","<ios><error-handling><observable><rx-swift><moya>","1","3","","","","CC BY-SA 4.0"
"52474940","1","52475699","","2018-09-24 08:00:29","","1","573","<p>I have a real specific problem. I usually got this and I couldn’t find why.</p>
<p>The main issue, even though I use disposeBag some of my “subscribe(onNext :” calls multiple times.
But I found something; the call count increase linear depend on another subscription.</p>
<p>For example; I have a two components, declared on a viewController. One if this a custom collection view and other is a custom refresh control manager.</p>
<pre><code>self.kpiesCollectionView.collectionHeaderButton.rx.tap
    . subscribe(onNext: { [weak self] _ in
           // Push to next ViewController
       }).disposed(by: self.kpiesCollectionView.disposeBag)


refreshControl.rx.controlEvent(UIControlEvents.valueChanged).asObservable().subscribe(onNext: { () in
            DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2) {
                completion()
            }
        }).disposed(by: disposeBag)
</code></pre>
<p>The refreshControl work handles in self. It just returns completion to viewController. So I call disposeBag in self.</p>
<p>And scenario goes like this;</p>
<blockquote>
<p>Click Button -&gt; Pushes to VC  (1 time)</p>
<p>Pull-To-Refresh <br/>
Click Button -&gt; Pushes to VC  (2 time)</p>
<p>Pull-To-Refresh <br/>
Click Button -&gt; Pushes to VC  (3 time)</p>
</blockquote>
<h1>Updated</h1>
<p>I have found the problem. That is why, I also updated title. The reason is I was using <code>self.kpiesCollectionView.collectionHeaderButton.rx.tap.subscribe(</code>
inside my request completion block but when I moved to outside of it, it worked well.</p>
<p>Maybe it wasn’t the correct place but, just want to learn. How can I avoid this.? How can I call subscribe() even inside a block?</p>
","2622013","","-1","","2020-06-20 09:12:55","2018-09-24 08:53:46","RxSwift subscribtion inside completion block issue","<ios><swift><callback><rx-swift>","1","3","","","","CC BY-SA 4.0"
"52510219","1","","","2018-09-26 04:59:10","","0","390","<p>I'm working on a iOS project require pagination (API call will have a <code>page</code> parameter to pull results). The ideal is when user scroll near the bottom of <code>collectionView</code>, a call to API will happen to fetch more results (increase <code>page</code> number) then add new result to existing array of model.</p>

<p>Here is my implementation that work when user search:</p>

<p>This is PhotoListViewReactor</p>

<pre><code>import RxSwift
import RxCocoa
import ReactorKit

class PhotoListViewReactor : Reactor {

  enum Action {
    case searchFlickr(_ keyword: String, _ page: Int)
  }

  enum Mutation {
    case flickrList([Photos])
  }

  struct State{
    var keyword : String?
    var photos : [Photos] = []
    var page: Int = 1
  }

  var initialState: State = State()

  init() { }

  func mutate(action: Action) -&gt; Observable&lt;Mutation&gt; {
    switch action {
    case let .searchFlickr(keyword,page):
      return AppService.request(keyword: keyword,page: page)
              .catchErrorJustReturn([])
              .map{[Photos(photos: $0)]}
              .map {Mutation.flickrList($0)}
    }
  }

  func reduce(state: State, mutation: Mutation) -&gt; State {
    var newState = state
    switch mutation {
        case let .flickrList(photos):
            newState.photos += photos
            newState.page += 1
    }


    return newState
  }

}
</code></pre>

<p>The function for get data from API is </p>

<pre><code>static func request(keyword: String, page: Int) -&gt; Observable&lt;[Photo]&gt;
</code></pre>

<p>I have added a page: <code>Int</code> to <code>State</code> struct but don't know how to implement <code>page</code> (increase page and call API when user scroll near the bottom)</p>
","5532616","","5329717","","2019-04-01 11:53:48","2019-04-01 11:53:48","iOS implement pagination with ReactorKit and RxSwift","<ios><swift><pagination><rx-swift>","1","0","","","","CC BY-SA 4.0"
"52513888","1","52519348","","2018-09-26 09:04:15","","0","412","<p>having a problem with combining to observables in flatMapLatest</p>

<p><strong>Logic</strong>: on every activity next event, I want to combine it together with the next <code>getCurrentLocation</code> event, which happens after activityEvent was triggered, join them together in a tuple and then do something with it.</p>

<p>Currently, it is like this</p>

<pre><code>ActivitiesController
    .start()
    .flatMapLatest { activity in 
        LocationController.shared.getCurrentLocation().map { ($0, activity) }
    }
    .subscribe(onNext: { (activity, currentLocation in
        print("""")
    })
    .disposed(by: disposeBag)
</code></pre>

<p>Location code:</p>

<pre><code>func getCurrentLocation() -&gt; Observable&lt;CLLocation&gt; {
    self.requestLocationUseAuthorizationIfNotDetermined(for: .always)
    self.locationManager.requestLocation()
    return self.publishSubject.take(1) // take next object from the publish subject (only one)
}

func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    guard let location = locations.last, location.horizontalAccuracy &gt; 0 else {
        return
    }
    self.publishSubject.onNext(location)
}
</code></pre>

<p>Since we know that <code>requestLocation()</code> triggers didUpdateLocations, we were thinking the logic should work, but it doesn't</p>

<p>the result is locationManager not always updating and returning old values instead of new ones</p>

<p>Do you guys have any idea?</p>
","1446139","","","","","2018-09-26 13:51:02","Merge two streams with flatMapLatest","<swift><rx-swift><reactive-cocoa><reactive>","1","1","","","","CC BY-SA 4.0"
"52553397","1","52564130","","2018-09-28 10:29:18","","3","3005","<p>I'm trying to achieve my Observables to execute only when previous Observable has completed. I can't use flatMap, because subscriptions can be called from different places, and this Observables is not connected with each other. To be specific: I have my CollectionView loading more content from server and 2 seconds after that user clicks ""Send comment"" button while CollectionView is still loading its batch. So I want to wait until CollectionView update completes and only then execute my comment's posting request. I created a class named ObservableQueue and it's working just fine. But I need to know if it has issues like memory leaks, dead locks or maybe I just missing something. Here it is:</p>

<pre><code>extension CompositeDisposable {

    @discardableResult
    func insert(disposeAction: @escaping () -&gt; ()) -&gt; DisposeKey? {
        return insert(Disposables.create(with: disposeAction))
    }

}

class ObservableQueue {

    private let lock = NSRecursiveLock()
    private let relay = BehaviorRelay(value: 0)
    private let scheduler = SerialDispatchQueueScheduler(internalSerialQueueName: ""ObservableQueue.scheduler"")

    func enqueue&lt;T&gt;(_ observable: Observable&lt;T&gt;) -&gt; Observable&lt;T&gt; {
        return Observable.create({ observer -&gt; Disposable in
            let disposable = CompositeDisposable()

            let relayDisposable = self
                .relay
                .observeOn(self.scheduler)
                .filter({ value -&gt; Bool in
                    if value &gt; 0 {
                        return false
                    }

                    self.lock.lock(); defer { self.lock.unlock() }

                    if self.relay.value &gt; 0 {
                        return false
                    }

                    self.relay.accept(self.relay.value + 1)

                    disposable.insert {
                        self.lock.lock(); defer { self.lock.unlock() }
                        self.relay.accept(self.relay.value - 1)
                    }

                    return true
                })
                .take(1)
                .flatMapLatest { _ in observable }
                .subscribe { observer.on($0) }

            _ = disposable.insert(relayDisposable)

            return disposable
        })
    }

}
</code></pre>

<p>And then I can use it like this:</p>

<pre><code>let queue = ObservableQueue()

...

// first observable
let observable1 = Observable
    .just(0)
    .delay(5, scheduler: MainScheduler.instance)

queue
    .enqueue(observable1)
    .subscribe(onNext: { _ in
        print(""here1"")
     })
    .disposed(by: rx.disposeBag)

// second observable
let observable2 = Observable
    .just(0)
    .delay(5, scheduler: MainScheduler.instance)

queue
    .enqueue(observable2)
    .subscribe(onNext: { _ in
        print(""here2"")
    })
    .disposed(by: rx.disposeBag)

// third observable
let observable3 = Observable
    .just(0)
    .delay(5, scheduler: MainScheduler.instance)

queue
    .enqueue(observable3)
    .subscribe(onNext: { _ in
        print(""here3"")
    })
    .disposed(by: rx.disposeBag)
</code></pre>
","5089731","","1731200","","2018-09-28 11:45:21","2020-07-24 10:59:54","RxSwift. Execute separate Observables sequently","<ios><swift><synchronization><rx-swift><reactive>","3","0","2","","","CC BY-SA 4.0"
"52574468","1","","","2018-09-30 03:53:39","","0","244","<p>I'm building a share feature using <code>uicollectionView</code>  and <code>ReactorKit</code></p>

<p>My setup is</p>

<p>PhotoListViewReactor.class</p>

<pre><code>class PhotoListViewReactor : Reactor {

    enum Action {
        case shareInit
        case select(photo: Photo)
        case deselect(photo: Photo)
        case shareConfirm
        case shareFinish
    }

    enum Mutation {
        case selectShare(_ photo: Photo)
        case deselectShare(_ photo: Photo)
        case setSharingState(Bool)
        case triggerShareAction
        case shareComplete
    }

    struct State {
        var sharePhotos: [Photo] = []
        var isSharing: Bool = false
        var shareAction: Bool = false
    }

    var initialState = State()

    //    init() { }

    func mutate(action: Action) -&gt; Observable&lt;Mutation&gt; {
        switch action {

        case .select(photo: let photo):
            return Observable.just(Mutation.selectShare(photo)).takeUntil(self.action.filter(isSharingAction))

        case .deselect(photo: let photo):
            return Observable.just(Mutation.deselectShare(photo)).takeUntil(self.action.filter(isSharingAction))

        case .shareInit:
            return Observable.just(Mutation.setSharingState(true))

        case .shareConfirm:
            return Observable.concat([Observable.just(Mutation.triggerShareAction), Observable.just(Mutation.setSharingState(false))])
        case .shareFinish:
            return Observable.concat([Observable.just(Mutation.shareComplete),Observable.just(Mutation.setSharingState(false))])
        }
    }

    func reduce(state: State, mutation: Mutation) -&gt; State {
        switch mutation {

        case let .selectShare(photo):
            var newState = state
            newState.sharePhotos.append(photo)
            return newState

        case let .deselectShare(photo):
            var newState = state
            newState.sharePhotos.removeAll(where: { $0.id == photo.id })
            return newState

        case let .setSharingState(isSharing):
            var newState = state
            newState.isSharing = isSharing
            return newState

        case .triggerShareAction:
            var newState = state
            newState.shareAction = true
            return newState

        case .shareComplete:
            var newState = state
            newState.shareAction = false
            newState.isSharing = false
            newState.sharePhotos = []
            return newState

        }
    }

    private func isSharingAction(_ action: Action) -&gt; Bool {
        if case .shareInit = action {
            return true
        } else {
            return false
        }
    }

}
</code></pre>

<p>and inside <code>PhotoListViewController</code></p>

<pre><code>    self.collectionView.rx.modelSelected(Photo.self).share()
        .filter(if: reactor.state.map{$0.isSharing})
        .map {Reactor.Action.select(photo: $0)}
        .bind(to: reactor.action)
        .disposed(by: disposeBag)


    self.collectionView.rx.modelDeselected(Photo.self).share()
        .filter(if: reactor.state.map{$0.isSharing})
        .map {Reactor.Action.deselect(photo: $0)}
        .bind(to: reactor.action)
        .disposed(by: disposeBag)
</code></pre>

<p>To be clear my filterIf Operator:</p>

<pre><code>extension ObservableType {

    /**
     Filters the source observable sequence using a trigger observable sequence producing Bool values.
     Elements only go through the filter when the trigger has not completed and its last element was true. If either source or trigger error's, then the source errors.
     - parameter trigger: Triggering event sequence.
     - returns: Filtered observable sequence.
     */
    func filter(if trigger: Observable&lt;Bool&gt;) -&gt; Observable&lt;E&gt; {
        return self.withLatestFrom(trigger) { ($0, $1) }
            .filter { $0.1 }
            .map { $0.0 }
    }
}
</code></pre>

<p>My problem is the selection and deselection does not work properly (once select, user can not deselect the cell by click again). I have enable multisection in uicollectionview.</p>
","5532616","","472495","","2018-10-04 00:09:05","2018-10-04 00:09:05","IOS ReactorKit cell selection not working properly","<uicollectionview><rx-swift><multipleselection><reactor>","1","0","","","","CC BY-SA 4.0"
"52583369","1","","","2018-10-01 00:50:19","","0","905","<p>I'm new to RXSwift and I try to use combineLatest to combine the latest results from two public subjects</p>

<p>What I tried to do:</p>

<pre><code>let sub1 = PublicSubject&lt;Type1&gt;()
let sub2 = PublicSubject&lt;Type2&gt;()

NetworkService1.fetch { sub1Value in 
   sub1.onNext(sub1Value)
}

NetworkService2.fetch { sub21Value in 
   sub2.onNext(sub2Value)
}

Observable.combineLatest(sub1.asObservable(), sub2.asObservable()) {
   val1, val2 in 
   // do something with val1 and val2
   // It seems it never hits this block
}
</code></pre>

<p>Not sure I'm doing the right thing.</p>
","3500129","","1113632","","2018-10-01 16:53:37","2018-10-01 16:53:37","How to use combineLatest for two public subjects in RXSwfit","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"52590326","1","52591711","","2018-10-01 11:41:33","","1","112","<p><strong>CONTEXT</strong></p>

<p>I would like to run 3 different operations sequentially using RxSwift:</p>

<ol>
<li>Fetch products</li>
<li>When products fetching is done, delete cache</li>
<li>When cache delete is done, save new cache with products from <em>step 1</em></li>
</ol>

<p>These are the function definitions in my services:</p>

<pre><code>struct MyService {

  static func fetchProducts() -&gt; Observable&lt;[Product]&gt; {...}
  static func deleteCache() -&gt; Observable&lt;Void&gt; {...}
  static func saveCache(_ products: [Product]) -&gt; Observable&lt;Void&gt; {...}

}
</code></pre>

<p>I implement that behavior usually with <code>flatMapLatest</code>. </p>

<p>However, I will lose the result of the 1st observable (<code>[Product]</code>) with that approach, because the operation in the middle (<code>deleteCache</code>) doesn't receive arguments and returns Void when completed.</p>

<pre><code>struct CacheViewModel {


  static func refreshCache() -&gt; Observable&lt;Void&gt; {
    return MyService.fetchProducts()
      .flatMapLatest { lostProducts in MyService.deleteCache() }
      .flatMapLatest { MyService.saveCache($0) } // Compile error*
  }
  // * Cannot convert value of type 'Void' to expected argument type '[Product]'

}
</code></pre>

<p>The compile error is absolutely fair, since the operation in the middle 'breaks' the passing chain for the first result. </p>

<p><strong>QUESTION</strong></p>

<p>What mechanism is out there to achieve this serial execution with RxSwift, accumulating results of previous operations?</p>
","5973853","","5973853","","2018-10-01 12:13:00","2018-10-01 12:58:28","Run 3 observables sequentially, using result from first in the last one","<ios><swift><rx-swift>","3","0","1","","","CC BY-SA 4.0"
"52598645","1","","","2018-10-01 20:44:55","","0","1927","<p>I get this error:</p>

<blockquote>
  <p>assert(proxy === DelegateProxy.currentDelegate(for: object), ""Proxy
  changed from the time it was first set.</p>
  
  <p>Original: (proxy)</p>
  
  <p>Existing:
  (String(describing: DelegateProxy.currentDelegate(for: object)))"")</p>
</blockquote>

<p>I have two observables that handles to xib storyboard on different states but once one of them has been loaded I receive the error above, I have tried to use the <code>self.tableView.delegate = nil &amp; self.tableView.dataSource = nil</code> but yet it causes this on the <code>.bind(to:)</code> function. My problem is I don't know how to handle it before this error: </p>

<blockquote>
  <p>Assertion failed: Proxy changed from the time it was first set.</p>
</blockquote>

<p>Original: 

<pre><code>.asObservable().bind(to:(tableView?.rx.items(cellIdentifier: 
      aTableViewCell.Identifier, cellType: HaTableViewCell.self))!


func initTableView() {

    // pull to refresh
    aViewModel
        .isLoading
        .asObservable()
        .subscribe({ (loading) in
            if loading.element == false { 
            } else {
                self.tableView!.delegate = self // loads a shimmering view
                self.tableView!.dataSource = self
            }
        })
        .disposed(by: disposeBag)

    aViewModel
        .datas
        .asObservable()
        .bind(to:(tableView?.rx.items(cellIdentifier: aTableViewCell.Identifier, cellType: HaTableViewCell.self))!) { (index, element, cell) in
         // when the data is fired load this tableview cell
        }.disposed(by: disposeBag)
}
</code></pre>

<p>How can set the the tableview to nil before the data Observables fires up?</p>

<blockquote>
  <p>This is a feature to warn you that there is already a delegate (or data 
  source) set somewhere previously. The action you are trying to perform ? 
  will clear that delegate (data source) and that means that some of your ?features that depend on that delegate (data source) being set will likely stop working. If you are ok with this, try to set delegate (data source) to <code>nil</code> in front of this operation.</p>
</blockquote>
","1273790","","1273790","","2018-10-02 07:27:04","2019-04-29 19:26:42","TableView error delegate, proxy changed from the time it was first set","<swift><uitableview><observable><rx-swift>","2","0","","","","CC BY-SA 4.0"
"52607372","1","","","2018-10-02 11:23:39","","1","2029","<p>I'm using <code>RxDataSources</code> to load and display a <code>UITableview</code>. I am trying to update the section header with the amount of items that it holds, however tough the cell and items update correctly, the title remains stale.</p>

<p>This is my code for the <code>DataSource</code> object:</p>

<pre><code>tableViewDataSource = RxTableViewSectionedAnimatedDataSource&lt;TableViewParticipationSection&gt;(
           configureCell: { (_, tableView, _, item) in
               return TableViewCellType.transformData(item).cell(inTableView: tableView)
       }, titleForHeaderInSection: { dataSource, index in
           let sectionModel = dataSource.sectionModels[index]
           return ""\(sectionModel.items.count)""
           })
</code></pre>

<p>The identity of the section header is just <code>{return 0}</code> since I only have a single section.</p>

<p>Furthermore I have confirmed that if I use this code:</p>

<pre><code>DispatchQueue.main.asyncAfter(deadline: .now()+3, execute: {
               self?.contentView.tableView.reloadData()
           })
</code></pre>

<p>It will actually update the section title, so it seems to be some problem with staleness but I can't seem to track it down.</p>

<p>Does anyone have experience with dynamic titles using <code>RxDataSources</code></p>

<p>Edit:
After further experiments, the title will update, if I scroll around in the tableview, the title changes at some point.</p>
","1818120","","1818120","","2018-10-02 11:32:59","2019-10-01 12:40:59","RxDataSources not updating section header title","<ios><swift><rx-swift><rxdatasources>","2","2","2","","","CC BY-SA 4.0"
"52621483","1","","","2018-10-03 07:04:37","","1","376","<p>I have a ControlProperty binding like this in my UIViewController:</p>

<pre><code>textView.rx.text.orEmpty.asObservable()
    .bind(to: viewModel.descriptions)
    .disposed(by: disposeBag)
</code></pre>

<p>, where <code>viewModel.descriptions</code> is of type <code>BehaviorRelay&lt;String&gt;</code>.</p>

<p>In a TDD approach, I would like to write an (initially failing) test (as the initial step of the red-green-refactor cycle) to see that this binding exists. I tried with a test code like this:</p>

<pre><code>sut.textView.insertText(""DESC"")
sut.textView.delegate?.textViewDidChange?(sut.textView)

expect(mockViewModel.lastDescriptions).to(equal(""DESC""))
</code></pre>

<p>, where <code>sut</code> is my ViewController and <code>mockViewModel</code> contains code to subscribe to the <code>descriptions</code> <code>BehaviorRelay</code>:</p>

<pre><code>class MockViewModel: MyViewModelProtocol {
    var descriptions = BehaviorRelay&lt;String&gt;(value: """")
    var lastDescriptions: String?
    private var disposeBag = DisposeBag()

    init() {            
        descriptions.asObservable()
            .skip(1)
            .subscribe(onNext: { [weak self] (title: String) in
                self?.lastDescriptions = title
            })
            .disposed(by: disposeBag)
    }
}
</code></pre>

<p>However, I cannot push the new value to the <code>textView</code> so that the <code>descriptions</code> <code>BehaviorRelay</code> gets it.</p>

<p>How can I achieve <code>descriptions.asObservable()</code> to fire when entering a value in the <code>textView</code>? If it were a <code>UITextField</code> then I would do:</p>

<pre><code>textField.text = ""DESC""
textField.sendActions((for: .editingChanged))
</code></pre>

<p>Thanks in advance for any help.</p>
","1828963","","1828963","","2018-10-05 05:24:22","2018-10-05 05:24:22","Unit testing Rx binding with UITextView","<ios><unit-testing><uitextview><rx-swift><rx-cocoa>","0","5","","","","CC BY-SA 4.0"
"52656378","1","52656720","","2018-10-04 23:23:13","","0","982","<p>So I have been researching RxSwift for a couple days, and am trying to create a simple app with it. I have bound the searchController of my table to the results, which feed into the <code>cellForRowAt</code> function. How do I bind the alamofire response to each cell?
Which of these do I need to do?</p>

<ul>
<li>Use RxAlamofire to create an searchResultsArray</li>
<li>Change searchResultsArray to a <code>Variable</code> and use <code>toObservable</code>?</li>
<li>Bind <code>response</code> or <code>searchResultsArray</code> to create each cell.</li>
</ul>

<p>The function I need to use is:</p>

<pre><code>.bind(to: self.tableView.rx.items(cellIdentifier: ""cell"", cellType: UITableViewCell.self)) {  row, element, cell in
    cell.textLabel?.text = ""something""
}
</code></pre>

<p>This is my current RxSwift code:</p>

<pre><code>let disposeBag = DisposeBag()
var searchResultsArray = [[String:String]]()  
searchController.searchBar.rx.text.orEmpty.filter { text in
        text.count &gt;= 3
    }.subscribe(onNext: { text in
        searchRequest(search: text, searchType: ""t:t"") { response in
        self.searchResultsArray = response
        self.tableView.reloadData()
        }
    }).disposed(by: disposeBag)
</code></pre>

<p>This is my current cell creation function. <code>showSearchResults</code> changes when the cancel button is clicked.</p>

<pre><code>override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
    let cell: UITableViewCell = {
        guard let cell = tableView.dequeueReusableCell(withIdentifier: ""cell"") else {
            return UITableViewCell(style: .subtitle, reuseIdentifier: ""cell"")
        }
        return cell
    }()
    if self.shouldShowSearchResults {
        cell.textLabel?.text = searchResultsArray[indexPath.row][""result""]!
        cell.detailTextLabel?.text = searchResultsArray[indexPath.row][""location""]!
    }

    return cell
}
</code></pre>

<p>This is my current api request:</p>

<pre><code>func searchRequest(search: String, searchType: String, completionHandler: @escaping ([[String: String]]) -&gt; ()) {
    let payload: [String: Any] = [
        ""q"": search,
        ""fq"": searchType,
        ""start"": 0
    ]

    let url = URL(string: ""https://www.athletic.net/Search.aspx/runSearch"")!
    Alamofire.request(url, method: .post, parameters: payload, encoding: JSONEncoding.default).responseJSON { response in
        let json = response.data
        do {
            var searchResults: [[String: String]] = []
            let parsedJson = JSON(json!)
            if let doc = try? Kanna.HTML(html: parsedJson[""d""][""results""].stringValue, encoding: .utf8) {
                for row in doc.css(""td:nth-child(2)"") {
                    let link = row.at_css(""a.result-title-tf"")!
                    let location = row.at_css(""a[target=_blank]"")!
                    let schoolID = link[""href""]!.components(separatedBy: ""="")[1]
                    searchResults.append([""location"": location.text!, ""result"": link.text!, ""id"":schoolID])
                }
            }
            completionHandler(searchResults)
        } catch let error {
            print(error)
        }
    }
}
</code></pre>

<p>I would like to replace the cellForRowAt with a RxSwift solution.</p>
","8761914","","","","","2018-10-05 00:31:55","Bind Alamofire request to table view using RxSwift","<swift><uitableview><rx-swift><rxalamofire>","1","0","2","","","CC BY-SA 4.0"
"52660014","1","52666143","","2018-10-05 07:01:49","","0","346","<p>I'm trying to create a generic results enum in swift, this is what I have so far:</p>

<pre><code>enum Result&lt;T: Codable&gt;: Error {
    //Indicates that it was a success, and data is the returned result
    case Success(data: T)

    //Indicates that there was an unrecognizable error
    case Failure(error: Error)

    //Some cases for specific status codes
    case Forbidden              //Status code: 403
    case NotAcceptable          //Status code: 406
    case Conflict               //Status code: 409
    case InternalServerError    //Status code: 500
}
</code></pre>

<p>And then I try to create an Observable out of it, like this:
(The T is specified in the function's call, this is shortened for brevity)</p>

<pre><code>Observable&lt;Result&lt;T&gt;&gt;.create { observer in 
    //Some code to go make an Http requests and return response....
    switch response.result {
        case .success(let value):
            //This works fine
            observer.onNext(Result.success(value))
            observer.onCompleted()
        case .failure(let error):
            //This is where things go wrong.
            observer.onError(Result.failure(error))
    }
}
</code></pre>

<p>The problem is when I try to return in the <code>.failure</code> case, it always says <code>Argument type 'Result&lt;_&gt;' does not conform to expected type 'Error'</code> even though Result is an Error type</p>

<p>Am I doing something wrong? </p>
","3049535","","","","","2018-10-05 12:56:09","Cannot put error with Generic Result enum in RxSwift","<swift><swift4><alamofire><rx-swift><swift4.2>","2","0","","","","CC BY-SA 4.0"
"52674427","1","52700480","","2018-10-05 23:34:48","","3","89","<p>I've got following code</p>

<pre><code>protocol NamedOption {
    var optionTitle: String { get }
}

struct DebugOption: NamedOption {
    let optionTitle: String
    let debugViewControllerType = UIViewController.self
}


func testFunk&lt;T: Sequence&gt;(d: Observable&lt;T&gt;) where T.Element == NamedOption {

}

func bindFullResultsRx() {
    let dd: Observable&lt;[DebugOption]&gt; = self.dataModel.debugOptions // this is defined and properly assigned earlier
    testFunk(d: dd)
}
</code></pre>

<p>and at the line where I call <code>testFunk</code> Xcode gives me following error:</p>

<blockquote>
  <p>Expression type '()' is ambiguous without more context</p>
</blockquote>

<p>I have no idea why this is happening :( So far I was able to make it working by changing constraints on <code>testFunk</code> into this:</p>

<pre><code>func funk&lt;T: NamedOption&gt;(d: Observable&lt;[T]&gt;) {

}
</code></pre>

<p>which seems to me more restrictive then version at the top. Does any one knows how to make it working with <code>T: Sequence</code> ?</p>

<p>Xcode version is 9.4, Swift version is 4.1.</p>
","6775034","","","","","2018-10-08 10:39:14","Swift generic sequence observable ambiguity","<swift><generics><rx-swift>","2","0","0","","","CC BY-SA 4.0"
"52678839","1","","","2018-10-06 11:59:59","","0","1459","<p>I've been trying to understand rxSwift. I faced with request problem and want to implement this in a good way. Currently, I'm using this code:</p>

<pre><code>enum RequestState&lt;T&gt; {
    case loading
    case loaded(T)
    case error(Error)
}

struct Response&lt;T: Decodable&gt;: Decodable {
    let data: T
    let error: ResponseError?
}

searchBar.rx.text.asObservable()
    .flatMap { self.provider.rx.request(Request(query: $0)) }
    .map({ RequestState&lt;Response&lt;Bool&gt;&gt;.loaded($0) })
    .asDriver(onErrorRecover: { error in
        return Driver.just(.error(error))
    })
    .startWith(.loading)
    .drive(onNext: { state in
        switch state {
        case .loading: ()
        case .loaded(let response): ()
        case .error(let error): ()
        }
    })
    .disposed(by: disposeBag)
</code></pre>

<p>This works good but not too convenient to work with data and request state. I saw in rxSwift demo project following code.</p>

<pre><code>struct RequestState&lt;T: Decodable&gt; {
    let isLoading: Bool
    let data: T
    let error: ResponseError?
}

let state = viewModel.requestMethod()

state
    .map { $0.isLoading }
    .drive(self.loaderView.isOffline)
    .disposed(by: disposeBag)

state
    .map { $0.data }
    .drive(tableView.rx.items(dataSource: dataSource))
    .disposed(by: disposeBag)

state
    .map { $0.error }
    .drive(onNext: { error in
        showAlert(error)
    })
    .disposed(by: disposeBag)
</code></pre>

<p>And my problem in the following method, I can't understand Rx magic here:</p>

<pre><code>func requestMethod() -&gt; Driver&lt;RequestState&gt; {
    // supper code
}
</code></pre>

<p>Can someone advise me what I have to do here?</p>
","4314758","","","","","2018-10-06 17:32:21","Networking with RxSwift","<swift><networking><request><rx-swift><moya>","1","1","","","","CC BY-SA 4.0"
"52683224","1","52685060","","2018-10-06 20:48:39","","0","709","<p>I have been experimenting with RxSwift and I am looking for some help with the correct way of dealing with observers. I have an observer with observing for a <em><strong>Publish Subject</strong></em>.</p>
<pre><code>authPublisherSubject.asObserver()

        .subscribe(onNext: { (status) in

        }, onError: { [unowned self] (error) in

        }, onCompleted: { [unowned self] in

  }).disposed(by: disposeBag)
</code></pre>
<p>Following are the responsibilities of this observer</p>
<ol>
<li>Display Activity Indicator</li>
<li>Hide Activity Indicator</li>
<li>Show Error if any</li>
<li>Proceed if login successful</li>
</ol>
<p><em><strong>I subscribe for this observer every time user hits Login Button. Is it approach correct?</strong></em></p>
<p>If I receive an error, <em><strong>next time when I subscribe to this observer i.e next time when the user hits login</strong></em> because of some reason the old error is retained and <em><strong>onError is automatically emitted with the old error.</strong></em> However, as far as I understand Publisher Subject only those events would be emitted which happened after observing.</p>
<p>I am not able to understand what is going on here.</p>
","3974260","","-1","","2020-06-20 09:12:55","2018-10-08 02:08:25","RxSwift - onError emitted twice","<ios><swift><reactive-programming><rx-swift>","2","0","","","","CC BY-SA 4.0"
"52697578","1","","","2018-10-08 07:43:21","","0","1491","<p>Hi anyone knows how to cancel the observable when an even happen and resubscribe (basically I want an observable to skip emitting when another event happens (Cancel button tap)</p>

<p>Detail scenario: Cancel button is clicked on a <code>UISearchBar</code> how to make observable to paused and stop emitting even when Cancel button is click</p>

<p>I'm thinking of something like this:</p>

<pre><code>Observable.of(searchClick,historyClick).merge().debounce(0.3, scheduler: scheduler)
                    .takeUntil(searchBar.rx.cancelButtonClicked)
                    .bind(to: viewModel.search)
                    .disposed(by: disposeBag)
</code></pre>

<p>but the subscription is stopped after that. How can we resubscribe or any other way to skip emitting when an even happen?</p>
","5532616","","1113632","","2018-10-08 11:24:52","2018-10-08 12:04:43","Rxswift cancel observer when an even happen and resubcribe","<ios><swift><observable><rx-swift>","1","1","","","","CC BY-SA 4.0"
"52711859","1","","","2018-10-09 00:46:26","","0","88","<p>I have a function that returns 2 observable events, the first one having a key, <code>athletes</code>, that i would like to create a table from. How can I achieve this?</p>

<p>Possible errors I get are:</p>

<ul>
<li><code>Cannot subscript a value of incorrect or ambiguous type</code></li>
<li><p><code>Value of type 'JSON' has no member 'asObservable'</code></p>

<pre><code>self.tableView.register(UITableViewCell.self, forCellReuseIdentifier: ""cell"")
teamRequest(schoolID: self.schoolID).debug(""val"").elementAt(1)
    .bind(to: self.tableView.rx.items(cellIdentifier: ""cell"", cellType: UITableViewCell.self)) { row, element, cell in
    cell.textLabel?.text = element[""Name""]
}.disposed(by: disposeBag)
</code></pre></li>
</ul>

<p>where teamRequest returns an observable of type JSON, emitting 2 values.</p>
","8761914","","1113632","","2018-10-10 12:13:50","2018-10-10 12:13:50","Bind event to key of Observable<JSON>","<swift><uitableview><observable><rx-swift><swifty-json>","2","1","","","","CC BY-SA 4.0"
"52718411","1","","","2018-10-09 10:06:47","","1","187","<pre><code>let loadNextPageTrigger = PublishSubject&lt;Void&gt;()

let loading = Variable&lt;Bool&gt;(false)


let nextPageRequest = loading.asObservable()

    .sample(loadNextPageTrigger)

    .flatMap { [unowned self] loading -&gt; Observable&lt;Int&gt; in

        if (loading || self.pageStatus != true || self.netStatus != true) {

            return Observable.empty()

        }
        else
        {

            return Observable&lt;Int&gt;.create
                { [unowned self] observer in

                    print(""self.pageIndex called"",self.offset)

                    self.offset += 20

                    observer.onNext(self.offset)

                    observer.onCompleted()

                    return Disposables.create()

            }

        }

}
</code></pre>

<p>on returning obervable.empty() it terminates the Observable.</p>
","1316176","","2713046","","2018-10-09 10:12:12","2018-10-09 17:56:33","How to prevent the observables from getting terminated","<swift><rx-swift>","4","0","","","","CC BY-SA 4.0"
"52721372","1","","","2018-10-09 12:43:21","","1","945","<p>Today I was migrating my code from ReactiveSwift to RxSwift and came to this weird scenario.</p>

<p>I have an <code>Observable</code> composed with <code>withLatestFrom</code> operator inside a <code>ViewModel</code> class, and it is emitting only on the test subscription I made inside the initializer of the<code>ViewModel</code> class at the time of composing it, but not in the subscription I made in the <code>ViewController</code>.</p>

<p>The <code>withLatestFrom</code> operator from this Observable is accepting another <code>Observable</code> that also has been composed with a <code>withLatestFrom</code> operator as its parameter.
</p>

<pre><code>// emit phrases when viewDidLoad emits
let thePhrases = self.viewDidLoadSubject.withLatestFrom(self.configureWithPhrasesSubject)

// This is the problematic Observable
let printThePhrases = self.buttonTappedSubject.withLatestFrom(thePhrases)
</code></pre>

<p>Here is the code I made to showcase this weird behavior, you can run it in XCode and set the debugger output filter to <code>[!]</code> to ignore the garbagge output made by Simulator:
</p>

<pre><code>import UIKit
import RxSwift

public final class RxTestViewModel {
    public init() {
        // emit configuredWithPhrases when viewDidLoad emits
        let configPhrases = self.viewDidLoadSubject
            .withLatestFrom(self.configureWithPhrasesSubject)
            .filter { $0 != nil }
            .map { $0! }

        // Show phrases to be printed on viewDidLoad
        self.toBePrinted = configPhrases.asObservable()

        _ = self.toBePrinted.subscribe(onNext: {
            print(""[!][\(Thread.current)] -- ViewModel.toBePrinted.onNext -&gt; \($0)"")
        })

        // Print first phrase whenever buttonTapped() is called
        self.printSomething = self.buttonTappedSubject
            .withLatestFrom(self.configureWithPhrasesSubject
            .filter { $0 != nil }
            .map { $0! })

        _ = self.printSomething.subscribe(onNext: {
            print(""[!][\(Thread.current)] -- ViewModel.printSomething.onNext -&gt; \($0)"")
        })
    }

    // MARK: Inputs
    private let configureWithPhrasesSubject = BehaviorSubject&lt;[String]?&gt;(value: nil)
    public func configureWith(phrases: [String]) {
        print(""[!][\(Thread.current)] -- ViewModel.configureWith"")
        self.configureWithPhrasesSubject.on(.next(phrases))
    }

    private let viewDidLoadSubject = PublishSubject&lt;Void&gt;()
    public func viewDidLoad() {
        print(""[!][\(Thread.current)] -- ViewModel.viewDidLoad"")
        self.viewDidLoadSubject.on(.next( () ))
    }

    private let buttonTappedSubject = PublishSubject&lt;Void&gt;()
    public func buttonTapped() {
        print(""[!][\(Thread.current)] -- ViewModel.buttonTapped"")
        self.buttonTappedSubject.on(.next( () ))
    }

    // MARK: Outputs
    public let printSomething: Observable&lt;[String]&gt;
    public let toBePrinted: Observable&lt;[String]&gt;
}

public final class RxTestViewController: UIViewController {

    private let button: UIButton = UIButton()
    private let viewModel: RxTestViewModel = RxTestViewModel()

    public static func instantiate() -&gt; RxTestViewController {
        let vc = RxTestViewController()
            vc.viewModel.configureWith(phrases: [""First phrase"", ""Second phrase"", ""Third phrase""])

        return vc
    }
}

extension RxTestViewController {
    public override func viewDidLoad() {
        super.viewDidLoad()

        self.setupButton()
        self.setupViewModel()

        self.viewModel.viewDidLoad()
    }
}

extension RxTestViewController {
    private func setupViewModel() {
        _ = self.viewModel.toBePrinted
            .subscribeOn(ConcurrentMainScheduler.instance)
            .subscribe(onNext: {
                print(""[!][\(Thread.current)] -- RxTestViewController.toBePrinted.onNext -&gt; \($0)"")
                self.viewModel.buttonTapped()
            })

        _ = self.viewModel.printSomething
            .subscribeOn(ConcurrentMainScheduler.instance)
            .subscribe(onNext: {
                print(""[!][\(Thread.current)] -- RxTestViewController.printSomething.onNext -&gt; \($0)"")
        })
    }
}

extension RxTestViewController {
    private func setupButton() {
        // Add to view
        self.view.addSubview(self.button)

        // Button config
        self.button.setTitle(""CLICK ME"", for: .normal)
        self.button.addTarget(self, action: #selector(buttonTapped), for: .touchUpInside)

        // Auto-layout
        self.button.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            self.button.centerXAnchor.constraint(equalTo: self.view.centerXAnchor),
            self.button.centerYAnchor.constraint(equalTo: self.view.centerYAnchor)])
    }

    @objc
    private func buttonTapped() {
        self.viewModel.buttonTapped()
    }
}
</code></pre>

<p>The expected results should be:</p>

<pre><code>[!][&lt;NSThread: 0x600001fee280&gt;{number = 1, name = main}] -- ViewModel.configureWith
[!][&lt;NSThread: 0x600001fee280&gt;{number = 1, name = main}] -- ViewModel.viewDidLoad
[!][&lt;NSThread: 0x600001fee280&gt;{number = 1, name = main}] -- ViewModel.toBePrinted.onNext -&gt; [""First phrase"", ""Second phrase"", ""Third phrase""]
[!][&lt;NSThread: 0x600001fee280&gt;{number = 1, name = main}] -- RxTestViewController.toBePrinted.onNext -&gt; [""First phrase"", ""Second phrase"", ""Third phrase""]
[!][&lt;NSThread: 0x600001fee280&gt;{number = 1, name = main}] -- ViewModel.buttonTapped
[!][&lt;NSThread: 0x600001fee280&gt;{number = 1, name = main}] -- ViewModel.printSomething.onNext -&gt; [""First phrase"", ""Second phrase"", ""Third phrase""]
[!][&lt;NSThread: 0x600001fee280&gt;{number = 1, name = main}] -- RxTestViewController.printSomething.onNext -&gt; [""First phrase"", ""Second phrase"", ""Third phrase""]
</code></pre>

<p>But instead I get:</p>

<pre><code>[!][&lt;NSThread: 0x600001fee280&gt;{number = 1, name = main}] -- ViewModel.configureWith
[!][&lt;NSThread: 0x600001fee280&gt;{number = 1, name = main}] -- ViewModel.viewDidLoad
[!][&lt;NSThread: 0x600001fee280&gt;{number = 1, name = main}] -- ViewModel.toBePrinted.onNext -&gt; [""First phrase"", ""Second phrase"", ""Third phrase""]
[!][&lt;NSThread: 0x600001fee280&gt;{number = 1, name = main}] -- RxTestViewController.toBePrinted.onNext -&gt; [""First phrase"", ""Second phrase"", ""Third phrase""]
[!][&lt;NSThread: 0x600001fee280&gt;{number = 1, name = main}] -- ViewModel.buttonTapped
[!][&lt;NSThread: 0x600001fee280&gt;{number = 1, name = main}] -- ViewModel.printSomething.onNext -&gt; [""First phrase"", ""Second phrase"", ""Third phrase""]
</code></pre>

<p>As you can see, the observer subscription is not called at the <code>ViewController</code>, only at the <code>ViewModel</code>.</p>

<p>Interestingly though, If I call the Observable's <code>latestFrom</code> trigger function again (<code>buttonTapped()</code>), both the ViewModel subscription and the ViewController subscription gets called as expected.</p>

<p>Also, if I remove the <code>withLatestFrom</code> operator from the <code>configPhrases</code> observable chain, and add it only to the <code>toBePrinted</code> Observable all works as expected.</p>

<p>This makes me think that applying <code>withLatestFrom</code> to an Observable that already has applied a <code>withLatestFrom</code> operator is bugged out.</p>
","1922268","","1922268","","2018-10-09 12:54:21","2018-10-09 18:15:11","RxSwift withLatestFrom weird behavior","<swift><reactive-programming><rx-swift><reactivex>","1","4","","","","CC BY-SA 4.0"
"52739366","1","52739573","","2018-10-10 11:37:28","","0","851","<p>I would like to have an Observable that while debounced (in the time frame where we are still not emitting the value) something else will happen, for example show a spinner.</p>

<p>So in my code example I only reference my view AFTER the value is emitted..</p>

<pre><code>observable.debounce(0.3, scheduler: MainScheduler.instance).do(onNext: { spinner in 
    spinner.stop() //here I set it to stop, I want to run spinner.start() while we are in the debounce area
}).subscribe().disposedBy(disposeBag)
</code></pre>

<p>I thought this question might fit my needs but not sure if it is exactly what I ask for:
<a href=""https://stackoverflow.com/questions/35438268/rxswift-debounce-throttle-inverse"">RxSwift - Debounce/Throttle &quot;inverse&quot;</a></p>
","5784052","","5784052","","2018-10-10 13:07:40","2018-10-11 01:03:47","RXSwift act while debounced","<rx-swift><debouncing>","2","0","1","","","CC BY-SA 4.0"
"52743367","1","52744090","","2018-10-10 15:08:27","","0","3407","<p>after binding some data to UITableView by this codes:</p>

<pre><code>struct CustomData {
    var anInt: Int
    var aString: String
    var aCGPoint: CGPoint
}

struct SectionOfCustomData {
    var header: String
    var items: [CustomData]
}
extension SectionOfCustomData: SectionModelType {

    init(original: SectionOfCustomData, items: [CustomData]) {
        self = original
        self.items = items
    }
}


class ViewController: UIViewController {

    @IBOutlet weak var tableView: UITableView!

    let disposeBag = DisposeBag()
    var data: RxTableViewSectionedReloadDataSource&lt;SectionOfCustomData&gt;?


override func viewDidLoad() {
        super.viewDidLoad()

        let x = status.asObservable()

        tableView.register(UINib(nibName: ""TableViewCell"", bundle: nil), forCellReuseIdentifier: ""Cell"")
        tableView.register(UINib(nibName: ""TableViewCellTwo"", bundle: nil), forCellReuseIdentifier: ""Cell2"")


data = RxTableViewSectionedReloadDataSource&lt;SectionOfCustomData&gt;(configureCell: { dataSource, tableView, indexPath, item in

            if indexPath.section &gt; 0 {

                let cell = tableView.dequeueReusableCell(withIdentifier: ""Cell2"", for: indexPath) as! TableViewCellTwo
                cell.age.text = ""\(item.anInt)""
                return cell
            }else {

                let cell = tableView.dequeueReusableCell(withIdentifier: ""Cell"", for: indexPath) as! TableViewCell
                cell.name.text = item.aString
                cell.age.text = ""\(item.anInt)""
                return cell
            }
        })

sections = [
            SectionOfCustomData(header: ""First section"", items: [CustomData(anInt: 0, aString: ""zero"", aCGPoint: CGPoint.zero), CustomData(anInt: 1, aString: ""one"", aCGPoint: CGPoint(x: 1, y: 1)) ]),
            SectionOfCustomData(header: ""Second section"", items: [CustomData(anInt: 2, aString: ""two"", aCGPoint: CGPoint(x: 2, y: 2)), CustomData(anInt: 3, aString: ""three"", aCGPoint: CGPoint(x: 3, y: 3)) ])
        ]

Observable.just(sections)
    .bind(to: tableView.rx.items(dataSource: data!))
    .disposed(by: disposeBag)
</code></pre>

<p>after pushing button and calling a function, I changing data inside sections var:</p>

<pre><code>@IBAction func change(_ sender: UIButton) {

sections = [
            SectionOfCustomData(header: ""third section"", items: [CustomData(anInt: 4, aString: ""four"", aCGPoint: CGPoint.zero), CustomData(anInt: 5, aString: ""five"", aCGPoint: CGPoint(x: 1, y: 1)) ]),
            SectionOfCustomData(header: ""fourth section"", items: [CustomData(anInt: 6, aString: ""six"", aCGPoint: CGPoint(x: 2, y: 2)), CustomData(anInt: 7, aString: ""seven"", aCGPoint: CGPoint(x: 3, y: 3)) ])
        ]
</code></pre>

<p>but after calling function UITableView data not changing, My question is why after binding section variable to UITableView and changing data inside of that(section), UITableView still showing that last data?</p>
","8425034","","","","","2018-10-10 15:50:20","RxSwift, RxDataSources: How to bind dynamic data to UITableView by using RxDataSources?","<rx-swift><rxdatasources>","1","0","2","","","CC BY-SA 4.0"
"52757121","1","52759113","","2018-10-11 09:50:54","","5","5320","<p>I have created a common action for an array of my button. I just want to get the which button is tapped.</p>

<p>I have array of buttons like <code>let buttons = [UIButton(), UIButton(), UIButton(),UIButton()]</code>.</p>

<pre><code>let observable = Observable.of(buttons[0].rx.tap, buttons[1].rx.tap, buttons[2].rx.tap, buttons[3].rx.tap).merge()
    observable.subscribe(onNext: {
      print(""I want to find which button is tapped."")
    }).disposed(by: disposeBag)
</code></pre>
","6369570","","","","","2018-10-22 09:37:54","How to get which button is clicked in RxSwift","<ios><swift><rx-swift>","4","0","3","","","CC BY-SA 4.0"
"52770842","1","","","2018-10-12 01:08:32","","1","614","<p>I am trying to set up a tableview that refreshes user data after a button is pressed. RXSwift is used for the entire chain of events. Moya is used for routing. </p>

<p>I am trying to use the standard error handling given by Moya, which is:</p>



<pre><code>provider.rx.request(.userProfile(""ashfurrow"")).subscribe { event in
    switch event {
    case let .success(response):
        image = UIImage(data: response.data)
    case let .error(error):
        print(error)
    }
}
</code></pre>

<p>The only way I have been able to get this to work, is to use an inner subscribe method. Please see code below. Can anyone think of a way that does not require an inner subscribe? It seems a bit clumsy as is.</p>



<pre><code>class ViewController: UIViewController {
    @IBOutlet weak var refreshBtn: UIButton!
    @IBOutlet weak var tableView: UITableView!

    let provider = MoyaProvider&lt;MyAPI&gt;()

    let disposeBag = DisposeBag()

    var latestUsers = Variable&lt;[User]&gt;([])

    override func viewDidLoad() {
        super.viewDidLoad()

        setupObservableBtnRefreshWithDataFetch()
        bindDataToTableView()
    }

    func setupObservableBtnRefreshWithDataFetch() {
        let refreshStream = refreshBtn.rx.tap.startWith(())

        let responseStream = refreshStream.flatMapLatest { _ -&gt; SharedSequence&lt;DriverSharingStrategy, [User]&gt; in
            let request = self.provider.rx.request(.showUsers)

            // Inner Subscribe here, to be able to use the standard Moya subscribe methods for error handling
            request.subscribe { event in
                switch event {
                case .success(let user):
                    print(""Success"")
                case .error(let error):
                    print(""Error occurred: \(error.localizedDescription)"")
                }
            }

            return request
                .filterSuccessfulStatusCodes()
                .map([User].self)
                .asDriver(onErrorJustReturn: [])
        }

        let nilOnRefreshTapStream: Observable&lt;[User]&gt; = refreshBtn.rx.tap.map { _ in return [] }
        let tableDisplayStream = Observable.of(responseStream, nilOnRefreshTapStream)
            .merge()
            .startWith([])

        tableDisplayStream
            .subscribe { event in
                switch event {
                case .next(let users):
                    print(""Users are:"")
                    print(users)
                    self.latestUsers.value = users
                    break
                case .completed:
                    break
                case .error(let error):
                    print(""Error occurred: \(error.localizedDescription)"")
                    break
                }
            }
            .disposed(by: self.disposeBag)
    }

    func bindDataToTableView() {
        latestUsers.asObservable()
            .bind(to: tableView.rx.items(cellIdentifier: ""cell"", cellType: UITableViewCell.self)) { (_, model: User, cell: UITableViewCell) in
                cell.textLabel?.text = model.login
            }
            .disposed(by: disposeBag)
    }
}      

class User: Decodable {
    var name: String?
    var mobile: Int?
    var userRequestedTime: String?
    var login: String?

    init(name: String, mobile: Int, login: String = """") {
        self.name = name
        self.mobile = mobile
        self.login = login
    }
}
</code></pre>
","5208205","","2369487","","2018-10-22 13:25:10","2018-10-23 09:41:46","RXSwift + Moya + Error Handling + Refresh Button","<swift><rx-swift><moya>","1","2","","","","CC BY-SA 4.0"
"52793150","1","52794945","","2018-10-13 12:53:29","","4","4764","<p>I'm new to RxSwift and reading about subjects, I tried <code>Variable</code> Subject. Which in turns giving Warning in console</p>

<pre><code>ℹ️ [DEPRECATED] `Variable` is planned for future deprecation. Please consider `BehaviorRelay` as a replacement. Read more at: https://git.io/vNqvx
</code></pre>

<p>Earlier I have declared <code>Variable</code> like this</p>

<pre><code>var searchItems = Variable&lt;[MyClass]&gt;([])
</code></pre>

<p>So i have done basic array operations from it's property called <code>value</code> as it was <code>get set</code> property like</p>

<pre><code> 1. self.searchItems.value.removeAll()
 2. self.searchItems.value.append(items)
 3. self.searchItems.value = items
</code></pre>

<p>Now After getting warning i changed it to <code>BehaviorRelay</code> like</p>

<pre><code>var searchItems = BehaviorRelay&lt;[MyClass]&gt;(value: [])
</code></pre>

<p>So I got error that <strong>value is get property only</strong>.</p>

<p>I googled alot but can't get suitable explanations for Array operations.</p>

<p>I only got a code <code>self.searchItems.accept(items)</code> which i really don't know what it exactly do add fresh items or append.</p>

<p>I needed how all 4 operations will be performed when using <code>BehaviorRelay</code>?</p>
","5589073","","5589073","","2018-10-13 13:13:13","2018-10-13 16:22:45","RxSwift : BehaviorRelay in place of Variable usage","<ios><arrays><swift><rx-swift>","2","0","2","","","CC BY-SA 4.0"
"52794894","1","52797218","","2018-10-13 16:15:44","","3","1782","<p>I'm trying to concatenate two observables of collection with <code>concat()</code> operator, however, it's not working as expected.</p>

<p>I've two observables:</p>

<pre><code>let first = Observable&lt;[Int]&gt;.create { observer in
    observer.onNext([1, 2])
    observer.onCompleted()
    return Disposables.create()
}

let second = PublishSubject&lt;[Int]&gt;()
</code></pre>

<p>Using <code>concat()</code>:</p>

<pre><code>let items = Observable.concat([first, second])

items.subscribe(onNext: {
    print($0)
})

second.onNext([3, 4, 5])
</code></pre>

<p>Output:</p>

<pre><code>[1, 2]
[3, 4, 5]
</code></pre>

<p>What I want:</p>

<pre><code>[1, 2]
[1, 2, 3, 4, 5]
</code></pre>
","10384998","","10384998","","2018-10-13 19:25:00","2018-10-13 21:44:17","RxSwift - How to concatenate observables of collection","<swift><reactive-programming><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"52795240","1","52797732","","2018-10-13 16:57:14","","0","559","<p>I'm experiencing a strange behavior with IOS Rxswift. The problem is with <code>CancelButtonClick</code> from <code>UISearchBar</code>. whenever <code>Cancel</code> is clicked the <code>searchbar.text</code> is immediately set to existing <code>text</code> and fire event <code>textDidEndEditing</code> which trigger a search (my search trigger condition is combine of <code>searchbar.text</code> and <code>textDidEndEditing</code>.</p>

<p>I have tried to set <code>searchbar.text = """"</code> when <code>Cancel</code> is clicked but seem <code>searchbar.text</code> is set to existing text and fire <code>textDidEndEditing</code> before any further action. Anyway to handle the Cancel button? I just want to disable any action whenever <code>Cancel</code> is clicked.</p>
","5532616","","472495","","2018-11-10 19:44:28","2018-11-10 19:44:28","iOS Rxswift handle CancelButton click in searchBar","<ios><uisearchbar><rx-swift><uisearchcontroller><searchbar>","1","0","","","","CC BY-SA 4.0"
"52795402","1","","","2018-10-13 17:16:25","","0","488","<p>This is simple version my Giphy.com client. I'm using Moya and Moya-ObjectMapper with Rxswift to make network requests. </p>

<p>Here's my code:</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa
import Moya
import Mapper
import Moya_ModelMapper

struct Gif: Mappable {

    let title: String

    init(map: Mapper) throws {
        try title = map.from(""source_post_url"")
    }
}

class ViewController: UIViewController {

    @IBOutlet weak var searchBar: UISearchBar!
    @IBOutlet weak var tableView: UITableView!

    let provider = MoyaProvider&lt;GiphyEndpoint&gt;()
    let disposeBag = DisposeBag()

    var text: Observable&lt;String&gt; {
        return searchBar.rx.text
            .orEmpty
            .debounce(0.5, scheduler: MainScheduler.instance)
            .distinctUntilChanged()
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        let data = getDataWithString()

        data.bind(to: tableView.rx.items(cellIdentifier: ""Cell"")) { row, model, cell in
            cell.textLabel?.text = model.title
            }
            .disposed(by: disposeBag)

    }

    func getDataWithString() -&gt; Observable&lt;[Gif]&gt; {
        return text
            .observeOn(MainScheduler.instance)
            .flatMapLatest({ text -&gt; Observable&lt;[Gif]&gt; in
                return self.request(text)
            })
    }

    func request(_ string: String) -&gt; Observable&lt;[Gif]&gt; {
        return provider.rx.request(.search(string))
            .map(to: [Gif].self)
            .asObservable()
    }
}
</code></pre>

<p>return an error message:</p>

<p><strong>Thread 1: Fatal error: Binding error: jsonMapping(Status Code: 200, Data Length: 137)</strong></p>

<p>This is the endpoint code: </p>

<pre><code>import Foundation
import Moya

private extension String {

    var URLEscapedSearchString: String {
        return self.lowercased().replacingOccurrences(of: "" "", with: ""+"")
    }
}

enum GiphyEndpoint {
    case trending
    case search(_ string: String)
}

extension GiphyEndpoint: TargetType {

    var baseURL: URL {
        return URL(string: ""https://api.giphy.com"")!
    }

    var path: String {
        switch self {
        case .trending: return ""/v1/gifs/trending""
        case .search: return ""/v1/gifs/search""
        }
    }

    var method: Moya.Method {
        return .get
    }

    var sampleData: Data {
        return Data()
    }

    var task: Task {
        switch self {
        case .search(let searchText):
            return .requestParameters(parameters: [""q"": searchText],
                                        encoding: URLEncoding.default)
        case .trending: return .requestPlain
        }
    }

    var headers: [String : String]? {
        return [""api_key"": ""YUAoFkF42JjpIRdLWmJu70IGDXilhltD""]
    }
}
</code></pre>

<p>Where is my code problem? Thank you!</p>
","9078847","","","","","2018-10-23 14:22:10","Rxswift + Moya + Moya-ObjectMapper Fatal error","<swift><rx-swift><mapper><moya>","1","0","","","","CC BY-SA 4.0"
"52803206","1","52803761","","2018-10-14 13:34:47","","1","1522","<p>I'm trying to implement <code>Kingfisher</code> prefetch feature inside an Rxswift project. The problem is with these 2 function </p>

<pre><code>collectionView.rx.prefetchItems
collectionView.rx.cancelPrefetchingForItems
</code></pre>

<p>The instruction at <code>Kingfisher</code> <code>github</code> is quite short</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    collectionView?.prefetchDataSource = self
}

extension ViewController: UICollectionViewDataSourcePrefetching {
    func collectionView(_ collectionView: UICollectionView, prefetchItemsAt indexPaths: [IndexPath]) {
        let urls = indexPaths.flatMap { URL(string: $0.urlString) }
        ImagePrefetcher(urls: urls).start()
    }
}
</code></pre>

<p>How can we implement with Rxswift? anyway to get the <code>models</code> and then the <code>urls</code> of <code>models</code> from array of <code>indexpath</code>. Thank.</p>
","5532616","","","","","2018-10-14 14:37:18","IOS Rxswift use Kingfisher to prefetch cell Image","<rx-swift><prefetch><kingfisher>","1","0","2","","","CC BY-SA 4.0"
"52815543","1","","","2018-10-15 11:16:54","","1","652","<p>I want to use catchError for getting back my error as custom type.
At first, I want my network layer return Observable and then in ViewModel I subscribed it for .OnNext, .OnError, .OnCompleted events, But I don't know how should I handle Errors such as 4xx, 5xx network status code and then, them return my Custom Error Object!</p>

<p>My Login ViewModel :</p>

<pre><code>func getAccessToken() {        
        let network = NetworkRequest()

        network.logInRequest(tokenType: .guest, token: ""cce577f6021608"", secondKey: ""09128147040"", client: ""cce577f6021608bc31424d209cbf5120c3683191"").subscribe(onNext: { loginData in
            self.token.onNext(loginData.access_token)
        }, onError: { error in
            print(""The Error is: \(error.localizedDescription)"")
        }, onCompleted: {
            print(""Its Completed"")
        }).disposed(by: bag)
    }
</code></pre>

<p>My network layer function:</p>

<pre><code>class NetworkRequest: NSObject {
    var rxProvider: MoyaProvider&lt;WebServiceAPIs&gt;

    override init() {
        rxProvider = MoyaProvider&lt;WebServiceAPIs&gt;( plugins: [ NetworkLoggerPlugin(verbose:true) ])
    }

    func logInRequest(tokenType: accessTokenTypeEnum, token: String, secondKey: String, client: String) -&gt; Observable&lt;LoginModel&gt; {
        return rxProvider.rx
              .request(WebServiceAPIs.getAccessToken(tokenType: tokenType.rawValue, token: token, secondKey: secondKey, client: client))
              .filterSuccessfulStatusCodes()
              .catchError({ error -&gt; Observable&lt;NetworkError&gt; in
                return //Observable.just() =&gt; I want to return a custom network error as obserable 
              })
              .map(LoginModel.self, atKeyPath: nil, using: JSONDecoder(), failsOnEmptyData: true).asObservable()
    }

}
</code></pre>

<p>thanks for any help</p>
","7114942","","","","","2018-10-15 13:10:28","can't return observable of customError in network call","<ios><swift><rx-swift><moya>","2","0","","","","CC BY-SA 4.0"
"52839611","1","","","2018-10-16 16:02:08","","0","111","<p>With <strong>RxBluetooth</strong> it never has been easier to connect to a CBPeripheral:</p>

<pre><code>disposable = peripheral.establishConnection()
        .flatMap { $0.discoverServices([serviceId]) }.asObservable()
        .flatMap { Observable.from($0) }
        .flatMap { $0.discoverCharacteristics(nil)}.asObservable()
        .flatMap { Observable.from($0) }
        .flatMap { $0.readValue() }
        .subscribe(onNext: { characteristic in
            // At this point we have connected to the peripheral
            // Discovered the service with the id 'serviceId'
            // Discovered all the characteristics of the service
            // and this print will be triggered after reading each value

            print(Value read: characteristic.value)

        })
</code></pre>

<p>I would like to concatenate actions to the Peripheral, so when the subscription triggers, I know I have a validated peripheral. </p>

<p>The disposable will have concatenated actions, and will return a <code>true</code> if the actions were set successfully or an error.</p>

<p>Something like this:</p>

<pre><code>disposable = peripheral.establishConnection()

        // Action 1: Let's validate the advertismentData, if it doesn't have the correct advertisement data, we trigger an error

        .flatMap { self.validateAdvertisementData($0) }
        // If there is no error we continue
        .flatMap { $0.discoverServices([serviceId]) }.asObservable()
        .flatMap { Observable.from($0) }
        .flatMap { $0.discoverCharacteristics(nil)}.asObservable()
        .flatMap { Observable.from($0) } 
        .flatMap { $0.readValue() }

        // Action 2: Let's validate the characteristics values, if a characteristic is missing a value we trigger an error

        .flatMap { self.validateInitialCharacteristics($0) }

        // If there is no error we continue by discovering the rest of the services of the peripheral

        // Action 3: We keep discovering services as this is a validated peripheral

        .flatMap { peripheral.discoverServices([healthServiceId, communicationServiceId]) }.asObservable()
        .flatMap { Observable.from(peripheral) }
        .flatMap { $0.discoverCharacteristics(nil)}.asObservable()
        .flatMap { Observable.from($0) } 
        .flatMap { $0.readValue() }

        //Action 4: Let's validate that we read the values and send an initialization packet to the peripheral   

        .flatMap { self.validateSubCharacteristics($0) }

        //Action 5: The values are valid, let's initialize the Peripheral

        .flatMap { self.initialize(peripheral) }

        //If we get a response, then it calls onNext.

        .subscribe(onNext: { Bool in
            // At this point we have connected to the peripheral
            // Discovered the service with the id 'serviceId'
            // Discover all the characteristics of the service
            // Read all values of these characteristics
            // Validated all the values
            // Made another discover for other services
            // Read the characteristics for those
            // Validated the values
            // Write to the peripheral
            // and this print will be triggered after the writing 

            print(""Peripheral ready"")

        }, onError: { Error in 

            print(""Peripheral initialization failed"")
        })
</code></pre>

<p>So the main idea is to <strong>concatenate</strong> different actions with RxSwift, and only get one response after all the actions have completed successfully, if not get one error. </p>

<p>Maybe I could use different subjects, or several subscriptions with only one disposable that I can dispose for disconnection, and concatenate them?  </p>
","821053","","","","","2018-10-16 16:02:08","How to concatenate several subscriptions to a Disposable in RxSwift with RxBluetooth?","<bluetooth-lowenergy><publish-subscribe><rx-swift><cbperipheral><rxbluetooth>","0","4","","","","CC BY-SA 4.0"
"52843198","1","","","2018-10-16 19:59:52","","1","1073","<p>I read about this from a blog post <a href=""http://adamborek.com/memory-managment-rxswift/"" rel=""nofollow noreferrer"">http://adamborek.com/memory-managment-rxswift/</a>:</p>

<blockquote>
  <p>When you subscribe for an <code>Observable</code> the <code>Disposable</code> keeps a reference to the <code>Observable</code> and the <code>Observable</code> keeps a strong reference to the <code>Disposable</code> (Rx creates some kind of a retain cycle here). Thanks to that if user navigates back in navigation stack the <code>Observable</code> won’t be deallocated unless you want it to be deallocated.</p>
</blockquote>

<p>So purely just for understanding this, I created this dummy project: where is there a view, and in the middle of the view, there is a giant button which will emit events about how many times the button is tapped on. Simple as that. </p>

<pre><code>import UIKit
import RxCocoa
import RxSwift

class Button: UIButton {
    private var number: Int = 0

    private let buttonPushedSubject: PublishSubject&lt;Int&gt; = PublishSubject.init()
    var buttonPushedObservable: Observable&lt;Int&gt; { return buttonPushedSubject }

    deinit {
        print(""Button was deallocated."")
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        self.addTarget(self, action: #selector(buttonTapped), for: .touchUpInside)
    }

    @objc final func buttonTapped() {
        number = number + 1
        buttonPushedSubject.onNext(number)
    }
}

class ViewController: UIViewController {
    @IBOutlet private weak var button: Button!

    deinit {
        print(""ViewController was deallocated."")
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        button.buttonPushedObservable.subscribe(onNext: { (number) in
            print(""Number is \(number)"")
        }, onError: nil, onCompleted: nil, onDisposed: nil)
    }
}
</code></pre>

<p>And surprisingly, after I close this view controller, the logs look like this: </p>

<pre><code>Number is 1
Number is 2
Number is 3
Number is 4
ViewController was deallocated.
Button was deallocated.
...
</code></pre>

<p>which means both <code>ViewController</code> and the <code>Button</code> have been released! In this case, I didn't call the <code>disposeBy(bag)</code> and the compiler giving warning. </p>

<p><a href=""https://i.stack.imgur.com/CM847.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CM847.png"" alt=""enter image description here""></a></p>

<p>Then I started looking at the implementation of <code>subscribe(onNext:...)</code> (c/p below):</p>

<pre><code>let disposable: Disposable

if let disposed = onDisposed {
    disposable = Disposables.create(with: disposed)
}
else {
    disposable = Disposables.create()
}

let callStack = Hooks.recordCallStackOnError ? Hooks.customCaptureSubscriptionCallstack() : []

let observer = AnonymousObserver&lt;E&gt; { event in

    switch event {
    case .next(let value):
        onNext?(value)
    case .error(let error):
        if let onError = onError {
            onError(error)
        }
        else {
            Hooks.defaultErrorHandler(callStack, error)
        }
        disposable.dispose()
    case .completed:
        onCompleted?()
        disposable.dispose()
    }
}
return Disposables.create(
    self.asObservable().subscribe(observer),
    disposable
)
</code></pre>

<p>In this block of code above, it is true that <code>observer</code> holds a strong reference to <code>disposable</code> through the lambda function. However, what I don't understand is that how does <code>disposable</code> holds a strong reference to <code>observer</code>? </p>
","1035008","","","","","2018-10-17 00:10:56","Why do we need to call ""disposeBy(bag)"" explicitly after ""subscribe"" in RxSwift","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"52852137","1","52854214","","2018-10-17 10:00:05","","0","432","<p>I am new to both RxSwift and RxCocoa.</p>

<p>I have a working REST service on local which returns a Movie object for given ""id"".</p>

<p>On my storyboard there is a tableView (UITableView) which has custom cells (MovieCell). Each movie cell has a UILabel named ""nameTextLabel"". I also have a textField to get requested movie.id from user.</p>

<p>I am trying to show movie.title on each row of my tableView.</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa
class ViewController: UIViewController {

@IBOutlet var textField: UITextField!
@IBOutlet var tableView: UITableView!
let bag = DisposeBag()

override func viewDidLoad() {
    super.viewDidLoad()
    configureReactiveBinding()
}
private func configureReactiveBinding() {
    textField.rx.text.asObservable()
        .map { ($0 == """" ? ""15"" : $0!).lowercased() }
        .map { GetMovieByIdRequest(id: $0) }
        .flatMap { request -&gt; Observable&lt;Movie&gt; in
            return ServiceManager.instance.send(apiRequest: request)
        }
    .debug(""movie"")
// output:
//2018-10-17 16:13:49.320: movie -&gt; subscribed
//2018-10-17 16:13:49.401: movie -&gt; Event next(MovieAdvisor.Movie)
//2018-10-17 16:13:52.021: movie -&gt; Event next(MovieAdvisor.Movie)
    .toArray()
    .debug(""tableView"")
// output:
//2018-10-17 16:13:49.318: tableView -&gt; subscribed

        .bind(to: tableView.rx.items(cellIdentifier: ""movie_cell"", cellType:MovieCell.self)) { index, model, cell in
            cell.nameTextLabel.text = model.title
        }
        .disposed(by: bag)
}

}
</code></pre>

<p>Each time textLabel is changed the new movie.id is printed, but tableView doesn't show any data-not even with initial value (when textField is """").</p>

<p>Any idea how can i fix this?</p>

<p>After adding debug() lines, i figured that tableView is subscribed just once and no next events triggered tableView. What should i do?
Code is uploaded on GitHub
<a href=""https://github.com/enginipek/movie-advisor"" rel=""nofollow noreferrer"">github</a></p>
","10480076","","10480076","","2018-10-17 13:22:29","2018-10-17 14:01:30","RxCocoa-observable is emitting new data from API but tableview.rx.items doesn't show new data","<ios><rx-swift><rx-cocoa>","2","2","1","","","CC BY-SA 4.0"
"52894838","1","52900826","","2018-10-19 14:49:40","","1","4222","<p>I want to use RxSwift to get the text from a UITextField after the UIControlEvent Editing Changed is triggered.</p>

<p>In Order to do that:</p>

<p>I connected the textfield outlet from storyboard to my view controller like that. </p>

<pre><code>@IBOutlet weak var currentPasswordTextField: UITextField!
</code></pre>

<p>and then on the didSet property of this textfield I tried this: </p>

<pre><code>@IBOutlet weak var currentPasswordTextField: UITextField!{
    didSet{
        currentPasswordTextField
            .rx
            .controlEvent(.editingChanged)
            .asObservable()
            .subscribe(onNext: { (text) in
            //I want here to print the text after the editing changed. 
               print(text)
            })
            .disposed(by: disposeBag)
    }
}
</code></pre>

<p>but the text is Void not a string..</p>

<p>if anyone can help Id be grateful.
thanks in advance.</p>

<p>P.S. I don't want to use IBActions.</p>
","8557882","","","","","2018-10-21 14:29:51","Subscribing On UITextfield (Control event, Editing changed)","<ios><swift><uitextfield><rx-swift><uicontrolevents>","3","0","3","","","CC BY-SA 4.0"
"52923149","1","","","2018-10-22 05:57:58","","-1","911","<p>Xcode:10
Swift:4.2</p>

<p>*******Use of undeclared type 'Observable'*******</p>

<p>I use this code, msg : Use of undeclared type 'Observable'
how to solve?</p>

<pre><code>func validateAccount(_ account: String) -&gt; Observable&lt;XDLoginRXModel&gt;
</code></pre>

<hr>

<p>this is my custom enum</p>

<pre><code>import Foundation

enum XDLoginRXModel {
    case empty
    case ok(message: String)
    case failed(message: String)
}

extension XDLoginRXModel: CustomStringConvertible {
    var description: String{
        switch self {
        case .empty:
            return ""Empty""
        case let .ok(message):
            return message
        case let .failed(message):
            return message
        }
    }
}

extension XDLoginRXModel {
    var isValid: Bool {
        switch self {
        case .ok:
            return true
        default:
            return false
        }
    }
}
</code></pre>
","6774202","","","","","2018-10-22 08:32:43","Use of undeclared type 'Observable'","<rx-swift>","1","1","","","","CC BY-SA 4.0"
"52931989","1","","","2018-10-22 14:42:09","","6","3621","<p>I’ve been learning Rxswift and applying it on a project since start. I would like your help to fell more assured about a concept.</p>

<p>I understand the changes in the UI should be performed  on the Mainscheduler, and you should explicitly use <code>.observeOn(MainSchedule…</code> in case you don’t use <code>Drivers</code>.</p>

<p>My doubt is: <strong>normally, should I explicitly switch to a background thread when performing  network requests?</strong>.</p>

<p>I haven’t found many literature talking about exactly this, but I’ve read some projects code and most of them don’t, but a few do. Those eventually use <code>Drivers</code> or <code>.observeOn(MainSchedule…</code> to make the changes on the UI.</p>

<p>In <a href=""https://www.thedroidsonroids.com/blog/rxswift-examples-4-multithreading"" rel=""noreferrer"">https://www.thedroidsonroids.com/blog/rxswift-examples-4-multithreading</a>, for instance, he says</p>

<p><code>So as you may guessed, in fact everything we did was done on a MainScheduler. Why? Because our chain starts from searchBar.rx_text and this one is guaranteed to be on MainScheduler. And because everything else is by default on current scheduler – well our UI thread may get overwhelmed. How to prevent that? Switch to the background thread before the request and before the mapping, so we will just update UI on the main thread</code></p>

<p>So what he does to solve the problem he mentions, is to explicitly declare
<code>.observeOn(ConcurrentDispatchQueueScheduler(globalConcurrentQueueQOS: .Background))</code></p>

<p>Assuming the API Request would be performed on background anyway, what this does is to perform all other computations in the background as well, right?</p>

<p>Is this a good practice? <strong>Should I, in every API request, explicitly change to background and then changes back to Main only when necessary?</strong></p>

<p><strong>If so, what would be best way?</strong> To observe on background and then on Main? Or to subscribe on background and observe on Main, as is done in this gist:
<a href=""https://gist.github.com/darrensapalo/711d33b3e7f59b712ea3b6d5406952a4"" rel=""noreferrer"">https://gist.github.com/darrensapalo/711d33b3e7f59b712ea3b6d5406952a4</a>
?</p>

<p>Or maybe another way?</p>

<p>P.S.: sorry for the old code, but among the links I found, these better fit my question.</p>
","6307644","","","","","2018-10-23 11:40:03","Schedulers for network requests in RxSwift","<ios><swift><multithreading><rx-swift>","2","0","1","","","CC BY-SA 4.0"
"52947904","1","52948546","","2018-10-23 11:27:52","","0","1002","<p>I have one problem and don't know, how to fix this.</p>

<p>In my ViewModel I have got Observable field with value.</p>

<pre><code>self.diseaseDetails = Observable&lt;Disease&gt;.create { (observer) -&gt; Disposable in

            _ = SAPI.get().diseases(diseases: 5, success: { (disease) in
                observer.on(.next(disease))
                observer.on(.completed)

            }) { (failedMessage) in
                observer.on(.completed)
            }

            return Disposables.create()
        }
</code></pre>

<p>And get data from observable like this:</p>

<pre><code>public func getSections() -&gt; Observable&lt;String?&gt; {
        return self.details().map { $0.sections }
    }

    public func getDiagnostics() -&gt; Observable&lt;String?&gt; {
        return self.details().map { $0.diagnostics }
    }

private func details() -&gt; Observable&lt;Disease&gt; {

        return Observable.of(
            self.disease.asObservable(),
            self.diseaseDetails.take(1)
        ).merge()
    }
</code></pre>

<p>But,
two request was made in this example. I need only one request for many subscriptions. Any idea?</p>
","1341175","","","","","2018-10-23 12:00:14","Async task and multiple observers with RxSwift","<rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"52967338","1","52968239","","2018-10-24 11:02:53","","0","188","<pre><code>let subject = PublishSubject&lt;()&gt;()
subject.subscribe {
  print(""Why?"") // onCompleted
}
.disposed(by: disposeBag)
</code></pre>

<p>This is the declaration of subscribe (from RxSwift)</p>

<pre><code>public func subscribe(onNext: ((Self.E) -&gt; Void)? = default, onError: ((Error) -&gt; Void)? = default, onCompleted: (() -&gt; Void)? = default, onDisposed: (() -&gt; Void)? = default) -&gt; Disposable
</code></pre>

<p>So, <code>Self.E</code> is also <code>Void</code> type. Why <code>onCompleted</code> is called instead of <code>onNext</code>? Their semantics are similar <code>(Void) -&gt; Void</code></p>

<p>I know, that i shouldn't write such code (as in example), i am just interested in this behaviour</p>
","9986462","","","","","2018-10-24 11:48:38","How does trailing closure syntax works with PublicSubject<Void>.subscribe?","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"52970714","1","53014840","","2018-10-24 13:48:57","","1","571","<p>How to fix following build error when building the code below:</p>

<blockquote>
  <p>Contextual closure type '(_, _) -> _' expects 2 arguments, but 1 was
  used in closure body Insert ',&lt;#arg#> '</p>
</blockquote>

<p><strong>Code</strong></p>

<pre><code>func getIncidentAndResolutionTree() -&gt; Observable&lt;([Incident],[Resolution])&gt;
{
    return Observable.zip(getIncidents(), getResolutionTree(), resultSelector: { results  -&gt; ([Incident], [Resolution]) in
        return results
    })
}
</code></pre>

<p><strong>Configuration</strong></p>

<p>Xcode 9.4.1, Swift 4.1 RxSwift 4.3.1</p>
","1180728","","","","","2018-10-26 18:59:50","Contextual closure type '(_, _) -> _' expects 2 arguments error when using RxSwift Observable.zip","<rx-swift>","1","2","0","","","CC BY-SA 4.0"
"52983303","1","","","2018-10-25 07:06:42","","1","3532","<p>Cannot convert value of type 'Observable' to expected argument type 'BehaviorRelay'</p>

<p>I am using RxSwift. 
I have</p>

<p>In VM.</p>

<pre><code>        let St: BehaviorRelay&lt;String&gt;
</code></pre>

<p>In VC as Input</p>

<pre><code>        St: self.searchbar.rx.text.orEmpty.asObservable()
</code></pre>

<p>How can I convert it? 
So, I can get </p>

<p>BehaviorRelay from searchbar. Make sure, its INPUT.</p>
","3649855","","","","","2018-10-25 09:03:40","Cannot convert value of type 'Observable<String>' to expected argument type 'BehaviorRelay<String>'","<swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"52992332","1","52994049","","2018-10-25 14:56:56","","1","1673","<p>We have a view controller <code>MainCollectionView</code> that contains a collection view with a number of cells <code>FooCell</code>. And inside each <code>FooCell</code>, there is a collection view and a list of cells <code>BarCell</code>. </p>

<p>How do I propagate a button tapped event in the <code>BarCell</code> to <code>MainCollectionView</code>?</p>

<p>This is what we have:</p>

<pre><code>class FooCell: ... {

    private let barCellButtonTappedSubject: PublishSubject&lt;Void&gt; = PublishSubject&lt;Void&gt;()
    var barCellButtonTappedObservable: Observable&lt;Void&gt; {
        return barCellButtonTappedSubject.asObserver()
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {
        let cell = collectionView.dequeue(...)

        if let cell = cell as BarCell {
            cell.button.rx.tap.bind { [weak self] in
                self?.barCellButtonTappedSubject.onNext(())
            }.disposed(by: cell.rx.reusableDisposeBag)
        }

        return cell
    }
}

class MainCollectionView: ... {

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {
        let cell = collectionView.dequeue(...)

        if let cell = cell as FooCell {
            cell.barCellButtonTappedObservable.subscribe { [weak self] in
                // Do other stuff when the button inside bar cell is tapped.
            }.disposed(by: cell.rx.reusableDisposeBag)
        }

        return cell
    }
}
</code></pre>

<p>This works until I read about <a href=""https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#controlevent"" rel=""nofollow noreferrer""><code>ControlEvent</code></a>:</p>

<ul>
<li>it never fails</li>
<li>it won't send any initial value on subscription</li>
<li>it will Complete sequence on control being deallocated</li>
<li>it never errors out</li>
<li>it delivers events on MainScheduler.instance</li>
</ul>

<p>It looks like it is more appropriate to use <code>ControlEvent</code> in the <code>FooCell</code>:</p>

<pre><code>private let barCellButtonTappedSubject: PublishSubject&lt;Void&gt; = PublishSubject&lt;Void&gt;()
var barCellButtonTappedObservable: Observable&lt;Void&gt; {
    return barCellButtonTappedSubject.asObserver()
}
</code></pre>

<p>What is the right way to convert this <code>barCellButtonTappedObservable</code> to a <code>ControlEvent</code>? Or is there other better idea to propagate the <code>ControlEvent</code> in the nested cell to the outer view controller?</p>
","1035008","","","","","2018-10-25 18:36:29","How to convert `Observable` to `ControlEvent`","<ios><swift><rx-swift>","3","1","1","","","CC BY-SA 4.0"
"53006711","1","","","2018-10-26 10:27:58","","2","2187","<p>I would like to create a Reactive extension to the UIButton which will take any object (value and reference type) and will enable the button based on the value. If it is nil I want to disable the button and enable if it there is value.</p>

<p>here is the code:</p>

<pre><code>extension Reactive where Base: UIButton {
    var isEnabledForModel: Binder&lt;Any?&gt; {
        return Binder(base, binding: { 
            $0.isEnabled = $1 != nil
        })
    }
}
</code></pre>

<p>When I try to bind the observable which contains optional struct I get an error: <code>Ambiguous reference to member 'bind(to: )</code>. Is there any way to pass <code>Any</code> to the Binder or achieve it in different way? Maybe I want to make it too generic.</p>
","4386014","","","","","2018-10-26 11:50:32","Binder in RxSwift which accepts optional Any","<swift><observable><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"53015654","1","53015765","","2018-10-26 20:07:31","","0","108","<pre><code>enum Input { case text(String); case page(Int) }
</code></pre>

<p>I am managing pagination with keyword search to API method.
Now I either can pass keywords or page number, but not both at same time in Rx. </p>

<p>I have written following code with help of some existing available gist</p>

<pre><code>    let start = Observable.merge(reload, loadNext)

    let stringObservable = keyword.asObservable().map { Input.text($0) }
    let intObservable = start.asObservable().map { Input.page($0) }

    let request_call = Observable.of(stringObservable, intObservable).merge()
    let page = request_call
        .flatMap { input in
            Observable.combineLatest(Observable.just($0), api.loadData(page: $0, keyword: ""breaking"")) { (pageNumber: $0, items: $1) }
                .materialize()
                .filter { $0.isCompleted == false }
        }
        .share()
</code></pre>

<p>start keep Page Number, &amp; keyword keeps search keywords. </p>

<p>I need to merge both, I did using ENUM &amp; Merge, </p>

<p>Now I have to call API, but showing as Input, </p>

<p>So How can I get both values in one flatMap</p>
","3649855","","","","","2018-10-26 20:36:09","How to merge String & Int to get in ONE flatMap","<swift><merge><rx-swift><flatmap>","1","0","","","","CC BY-SA 4.0"
"53017568","1","53018125","","2018-10-26 23:52:31","","1","56","<p>This is about an error encountered in <a href=""https://github.com/RxSwiftCommunity/RxStarscream/pull/23"" rel=""nofollow noreferrer"">https://github.com/RxSwiftCommunity/RxStarscream/pull/23</a>.</p>

<p>I am trying to generalize a type, so I can mock the class it is based on. This means I want to switch from a concrete implementation to a protocol.</p>

<p>The original class looks like this:</p>

<pre><code>open class WebSocket : NSObject, StreamDelegate, WebSocketClient, WSStreamDelegate { ... }
    ...
}
</code></pre>

<p>I want to replace this with this protocol, that <code>WebSocket</code> is already extending:</p>

<pre><code>public protocol WebSocketClient : AnyObject {
    ...
}
</code></pre>

<p>This means I am replacing</p>

<pre><code>public class RxWebSocketDelegateProxy: DelegateProxy&lt;WebSocket, NSObjectProtocol&gt;, ... {
    ...
}
</code></pre>

<p>with </p>

<pre><code>public class RxWebSocketDelegateProxy: DelegateProxy&lt;WebSocketClient, NSObjectProtocol&gt;, ... {
    ...
}
</code></pre>

<p>All of this seems easy enough — <code>WebSocketClient</code> provides all the functionality that is needed here. Surprisingly, I am receiving the error message</p>

<blockquote>
  <p>'DelegateProxy' requires that 'WebSocketClient' be a class type</p>
</blockquote>

<p>I am not sure what I am missing here and would appreciate pointers!</p>
","10565455","","","","","2018-10-27 02:01:23","Swift type checker rejects protocol that has a class requirement as a class type","<swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"53035733","1","","","2018-10-28 20:20:53","","3","3610","<p>I wrote small demo code as following. 
I made two PublishSubject of different types. 
as I change any, page triggers
I need to get page trigger only when one changes, which of <strong>observable_page</strong>. </p>

<pre><code>class ViewController: UIViewController {

    func loadData(page: Int, keyword: String) -&gt; Observable&lt;[Int]&gt; {
        let _result = Observable.of([1,2,3,4])
        return _result
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.

        let observable_keyword = PublishSubject&lt;String&gt;()
        let observable_page = PublishSubject&lt;Int&gt;()
        let trigger_tap = PublishSubject&lt;Void&gt;()

        let tapObservable = trigger_tap.debug(""trigger_tap"", trimOutput: true)
        let stringObservable = observable_keyword.debug(""stringObservable"", trimOutput: true)
        let pageObservable = observable_page.debug(""pageObservable"", trimOutput: true)

        let request_call_trigger = Observable.combineLatest(tapObservable, pageObservable)
            .debug(""request_call_trigger"", trimOutput: true)

        let page = request_call_trigger
            .withLatestFrom(stringObservable) { ($0, $1) }
            .flatMap { ((_, _, page), keyword) in
                Observable.combineLatest(Observable.just(page), self.loadData(page: page, keyword: keyword)) { (pageNumber: $0, movies: $1) }
                    .materialize()
                    .filter { $0.isCompleted == false }
            }
            .share()

        observable_keyword.onNext(""breaking bad"")
        observable_page.onNext(1)

        trigger_tap.onNext(())

        observable_keyword.onNext(""orange is new black"")
        observable_keyword.onNext(""orange"")

    }

    let bag = DisposeBag()
}
</code></pre>

<p>I read some option, felt filter or ignore may work here, but as I need their value in next, so confused, how to apply it properly. </p>
","3649855","","3649855","","2018-10-28 20:59:32","2018-10-29 12:09:51","How to filter combineLatest to be trigger only when One item changes?","<swift><filter><rx-swift><combinelatest>","2","0","2","","","CC BY-SA 4.0"
"53043322","1","","","2018-10-29 10:18:39","","0","196","<p>I have a web socket that can add or remove data to a <code>MutableProperty&lt;[Stuff]&gt;</code></p>

<p>But when I reload the <code>collectionView</code> with <code>collectionView.reloadData()</code>.
Web sockets add or remove data to the <code>MutableProperty&lt;[Stuff]&gt;</code>, so it will crash </p>

<p>for multiple causes here is some errors:</p>

<ul>
<li>Index out of range when collectionView methods use my list </li>
<li>Invalid number of items cause crash like: <code>Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Invalid update: invalid number of sections.  The number of sections contained in the collection view after the update (58) must be equal to the number of sections contained in the collection view before the update (59), plus or minus the number of sections inserted or deleted (0 inserted, 0 deleted).'</code></li>
</ul>

<p>Anyone has a good advice or best practice to do that ? 
I've see that MutableProperty is thread safe</p>

<p>I know why it crash. It crash because websockets add or remove values from the array during the <code>reloadData</code> of the <code>collectionView</code> but I do not know how to solve it.
I know we can use semaphore but I'm looking for something elegant</p>
","10550192","","10550192","","2018-10-29 10:27:35","2018-10-29 11:20:46","How to deal with reactive programming updates and CollectionView","<swift><uicollectionview><rx-swift><reactive-swift>","1","0","","","","CC BY-SA 4.0"
"53049310","1","53050432","","2018-10-29 15:55:25","","0","84","<p>This is an example of our use case: </p>

<p>We have a <code>selectedIndex</code> and a list of <code>items</code>.</p>

<pre><code>class FoosViewModel {
    let selectedIndex = Variable&lt;Int&gt;(0)
    let items: [Foo] = ... // assume that this is initialized properly
}
</code></pre>

<p>In reality, we often care about which item is selected instead of the index of the selected item. So we'll have code like this:</p>

<pre><code>selectedIndex.asObservable().subscribe(onNext: { [weak self] index in
    guard let self = self else { return }
    let selectedItem = items[index]

    // Do sth with `selectedItem` here
}
</code></pre>

<p>Notice that the value of <code>selectedItem</code> is always driven by <code>selectedIndex</code>. Therefore, we change the code to the following:</p>

<pre><code>class FoosViewModel {
    let selectedIndex = Variable&lt;Int&gt;(0)
    let selectedItem = Variable&lt;Int&gt;(items[0])
    let items: [Foo] = ... // assume that this is initialized properly

    init() {
       selectedIndex.asObservable().subscribe(onNext: { [weak self] index in
           guard let self = self else { return }
           self.selectedItem = items[index]
        }
    }
}
</code></pre>

<p>This seems to be a common enough use case. Do we have an existing operator in Rx that can map a <code>Variable</code> to another? Is there sth like this:</p>

<pre><code>class FoosViewModel {
    let selectedIndex = Variable&lt;Int&gt;(0)
    let selectedItem = selectedIndex.map{ items[$0] }
    let items: [Foo] = ... // assume that this is initialized properly
}
</code></pre>
","1035008","","","","","2018-10-29 17:29:52","Chain propagation of a RxSwift Variable to another Variable","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"53053990","1","","","2018-10-29 21:19:28","","0","818","<p>I want to globally prevent the user from double tapping a button.  As a proof of concept I started to override the addTarget method of UI button and replaced the original call with a throttled call using RxSwift:</p>

<pre><code>import Foundation
import RxSwift
import RxCocoa

public extension UIButton {

    override open func addTarget(_ target: Any?, action: Selector, for controlEvents: UIControlEvents) {

        guard controlEvents == UIControlEvents.touchUpInside,
              let viewController = target as? UIViewController
        else
        {
            super.addTarget(target, action: action, for: controlEvents)
            return
        }

        self.rx
            .tap
            .throttle(3,
                      latest: false,
                      scheduler: MainScheduler.instance)
            .subscribe({ _ in
                viewController.perform(action)
            })
    }
}
</code></pre>

<p>When calling this code I get a Bad Access error:</p>

<blockquote>
  <p>Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT)</p>
</blockquote>

<p>I'm pretty new to Swift, so any guidance on where to start troubleshooting or alternate suggestions would be appreciated.</p>
","472292","","","","","2018-10-30 10:27:26","Replacing All UIButton Touch Events With Throttle","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"53081526","1","","","2018-10-31 10:45:59","","0","35","<p>Actually i am new in RxSwift. Please help regarding this matter.
 At first i am showing data into an array into a picker like this </p>

<pre><code>func pharmacyList() -&gt; Observable&lt;[String]&gt; {
        return Observable.just(AppSessionManager.shared.consultant?.pharmaciesArray.map({$0.name}) ?? [])
    }
</code></pre>

<p>now i just want to filter the array like </p>

<pre><code>self.plannerSections.append(PlannerSection(header: pharmacy?.name ?? """", items: plannerData))
</code></pre>

<p>now i want to show this plannerSections array into a picker using rxswift?</p>
","9445704","","1570808","","2018-10-31 11:13:42","2018-11-01 13:01:58","How to show a array list into a picker?","<arrays><append><rx-swift>","1","6","","","","CC BY-SA 4.0"
"53088366","1","","","2018-10-31 16:45:42","","0","85","<p>How can I make this subscribe loop not be nested? I can't seem to figure out how you would go about doing this because I push the view controller in the main subscribe loop, and not just set a value.</p>

<pre><code>button.rx.tap.subscribe(onNext: { _ in
    let viewController = MyViewController()
    self.navigationController.pushViewController(viewController)
    viewController.myPublishRelay.asObservable().subscribe(onNext: { value in
        // do something with value

    })
})
</code></pre>
","8761914","","8761914","","2018-11-01 13:03:32","2019-01-02 15:48:08","Subscribe to view controller property without nested subscribe loop","<swift><rx-swift>","3","0","","","","CC BY-SA 4.0"
"53094829","1","53101642","","2018-11-01 03:24:27","","0","356","<p>I have three btns, select one, and unselect the rest two.</p>

<blockquote>
  <p><a href=""https://i.stack.imgur.com/exgKb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/exgKb.png"" alt=""one""></a></p>
</blockquote>

<p>The following RXSwift code is not very elegant.</p>

<pre><code>twoBtn.isSelected = true

// the btns
let buttons = [oneBtn, twoBtn, threeBtn]

// find the selected btn we need
let selectedBtn : Observable&lt;UIButton?&gt; = Observable.from(buttons.map({ (button)  in
    return button!.rx.tap.map({
        return button
    })  
})).merge()


//  every btn subscribe to the selectedButton
for buttonPiece in buttons{
    selectedBtn.map { (btn) in
        return btn == buttonPiece
        }.bind(to: buttonPiece!.rx.isSelected).disposed(by: disposeBag)
}
</code></pre>

<p>The BehaviorSubject starts with an initial value, and they will replay the latest value or the initial value.</p>

<p>I think BehaviorSubject is proper here.</p>

<p>new to RxSwift, How to do it better?</p>
","9820754","","9820754","","2018-11-01 04:41:41","2018-11-01 12:50:47","RxSwift: how to select one btn and unselect the rest?","<rx-swift><behaviorsubject>","1","1","1","2018-11-01 14:48:54","","CC BY-SA 4.0"
"53096834","1","53114037","","2018-11-01 07:26:49","","0","444","<p>I want to bind a picker from an array. The array contains values. But the picker is showing blank.</p>

<p>In view model i took a function in the protocol <code>func updatedPharmacyList() -&gt; Observable&lt;[String]&gt;</code> </p>

<p>append the data into an array. 
<code>self.newArray.append((pharmacy?.name)!)</code></p>

<p>the array contains the data. </p>

<pre><code>func updatedPharmacyList() -&gt; Observable&lt;[String]&gt; {
    return Observable.just(self.newArray)
}
</code></pre>

<p>and then in the viewcontroller bind the picker like this </p>

<pre><code>viewModel.updatedPharmacyList()
  .bind(to: pharmacyPicker.rx.itemTitles) { _, item in
    return item
  }
  .disposed(by: disposeBag)
</code></pre>

<p>but the picker is coming blank.</p>
","9445704","","1173513","","2018-11-01 08:53:54","2018-11-02 07:19:22","How to bind a picker from array in rxswift?","<arrays><rx-swift>","3","0","","","","CC BY-SA 4.0"
"53102023","1","53104080","","2018-11-01 13:12:41","","0","100","<p>I am using a library that allows me to poll for events (blocking), until there are no more events (in which case it returns <code>nil</code>).</p>

<p>I am tempted to implement the observable like so:</p>

<pre><code>private func createObservable() -&gt; Observable&lt;MyEvents&gt; {
    return Observable.create { observer in
        let myPollingObject = PollingObject()

        while let event = try myPollingObject.poll() {
            observer.onNext(event)
        }

        return Disposables.create()
    }
}
</code></pre>

<p>Where the <code>while</code> loop finishes when there are no more events (and <code>poll()</code> returns <code>nil</code>).</p>

<p>However, the <code>while</code> loop means that I never <code>return Disposables.create()</code>, which is an issue.</p>

<p>Is there a more reactive way to implement that? I don't really feel like putting the <code>while</code> loop in a thread...</p>
","1368342","","","","","2018-11-01 21:07:39","Infinite blocking polling in Observable","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"53114100","1","","","2018-11-02 07:12:37","","0","760","<pre><code>todoTableView.rx.itemDeleted.asObservable()
    .subscribe({ (event) in
        let indexpath = event.element
            self.viewModel.deleteToDo(index: (indexpath?.row)!, completion: {
                self.todoTableView.deleteRows(at: [indexpath!], with: .fade)
            })
        })
        .disposed(by: disposeBag)
</code></pre>

<p>when I delete a row from tableView, The table gets updated before the delete animation occurs, due to which i am receiving an internal inconsistency error. </p>
","10407064","","","","","2018-11-02 08:22:59","How to delete a row from UITableView with RxSwift without any inconsistency error?","<swift><uitableview><tableview><rx-swift>","1","0","","","","CC BY-SA 4.0"
"53140163","1","53140278","","2018-11-04 11:07:54","","1","496","<p>Why is the following RxSwift code not compiling and how do I solve the problem? This line <code>observer.onNext(""test123"")</code> is the problem.</p>

<pre><code>final class TestA&lt;String&gt;: ObservableType {

    typealias E = String

    private let _observable: Observable&lt;String&gt;

    init() {
        _observable = Observable&lt;String&gt;.create { observer -&gt; Disposable in
            print(""mark 1"")
            observer.onNext(""test123"")
            observer.onCompleted()
            return Disposables.create()
        }
    }

    func subscribe&lt;O&gt;(_ observer: O) -&gt; Disposable where O : ObserverType, O.E == E {
        return _observable.subscribe(observer)
    }
}

let observable = TestA&lt;String&gt;()
print(""mark 2"")
observable.subscribe(onNext: { element in
    print(element)
})
</code></pre>

<p>I am testing in the playground and get the following error:</p>

<blockquote>
  <p>Playground execution failed:</p>
  
  <p>error: Introduction.xcplaygroundpage:25:26: error: cannot invoke 'onNext' > with an argument list of type '(String)'
                  observer.onNext(""test123"")
                           ^</p>
  
  <p>Introduction.xcplaygroundpage:25:26: note: expected an argument list of > type '(String)'
                  observer.onNext(""test123"")
                           ^</p>
</blockquote>

<p>One of the reasons behind this setup with the class is that I want to pass in the dependencies with constructor injection and use them in the create closure in order to avoid having to capture self. I also want to avoid having all those <code>Observable.create</code>s in the wild and have a more OOP approach.</p>
","1113632","","","","","2018-11-04 11:22:50","error: cannot invoke 'onNext' with an argument list of type '(String)' RxSwift","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"53140849","1","53140953","","2018-11-04 12:30:48","","1","642","<p>I'm trying to bind a <code>UITextField</code> to a viewModel, however whatever i do i keep getting <code>Cannot invoke 'bind' with an argument list of type '(to: EmailViewModel)</code>. What am i doing wrong?</p>

<p><strong>SignUpViewModel</strong></p>

<pre><code>class SignUpViewModel {

    let model: SignUpModel
    private let disposeBag = DisposeBag()

    let emailFieldViewModel = EmailViewModel()

    init(model :SignUpModel) {
        self.model = model
    }


}
</code></pre>

<p><strong>EmailViewModel</strong></p>

<pre><code>struct EmailViewModel : FieldViewModel {

    var value: Variable&lt;String&gt; = Variable("""")
    var errorValue: Variable&lt;String?&gt; = Variable(nil)

    let title = ""Email""
    let errorMessage = ""Email is wrong""

    func validate() -&gt; Bool {
        let emailPattern = ""[A-Z0-9a-z._%+-]+@([A-Za-z0-9.-]{2,64})+\\.[A-Za-z]{2,64}""
        guard validateString(value.value, pattern:emailPattern) else {
            errorValue.value = errorMessage
            return false
        }
        errorValue.value = nil
        return true
    }
}
</code></pre>

<p><strong>viewcontroller</strong></p>

<pre><code>class SignUpViewController: UIViewController {

    @IBOutlet var emailField: UITextField!

    override func viewDidLoad() {
        super.viewDidLoad()

        configureBinding()

    }

    private func configureBinding() {

        // binding
        self.emailField.rx.text.bind(to: viewModel.emailFieldViewModel)

    }

}
</code></pre>
","4034437","","","","","2018-11-04 12:55:55","Bind uitextfield value to viewModel using mvvm","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"53142723","1","53143990","","2018-11-04 16:10:23","","2","177","<p>I write an extension for UICollectionView which will listen the  delegate's
shouldHighlightItemAt method,but it don't call. </p>

<pre><code>public var shouldHighlightItem: ControlEvent&lt;IndexPath&gt; {

    let source = self.delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:shouldHighlightItemAt:)))
        .map { a in
            return try self.castOrThrow(IndexPath.self, a[1])
    }

    return ControlEvent(events: source)
}
</code></pre>

<p>}</p>

<p>how to write an extension for UICollectionView of rx shouldHighlightItemAt?</p>
","5824755","","","","","2018-11-04 18:43:34","UICollectionViewDelegate in RxCocoa","<rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"53226238","1","","","2018-11-09 13:03:19","","0","1156","<p>How to append default request parameters, for example AppID, to each and every API call with (Rx) Moya ?</p>
","130412","","","","","2019-03-04 05:52:10","Append parameters to each network call with Moya","<swift><alamofire><rx-swift><moya>","2","1","","","","CC BY-SA 4.0"
"53269490","1","53278235","","2018-11-12 20:19:11","","0","100","<p>I can't work out how to pull one event from an observable when another fires (at least, I think that's the essence of the problem but I'm so confused I might be wrong).</p>

<p>I have a ViewModel which is passed an array of objects on initialisation. The corresponding ViewController shows one of those objects at a time for the user to accept or decline (two buttons), along with an option to apply the response to all remaining objects (a checkbox). A side-effect of accepting the object (and possibly all remaining ones) is a database insertion. When there are no more objects the ViewController will be dismissed.</p>

<p>How can I model this reactively (using RxSwift/Cocoa)?</p>

<p>I'd also like to be able to show the user how many objects are remaining but that seems like an additional complexity.</p>
","498916","","","","","2018-11-13 09:58:51","How to pull one event from an observable when another emits","<swift><rx-swift><reactivex>","1","1","","","","CC BY-SA 4.0"
"53295891","1","53296534","","2018-11-14 08:31:29","","0","171","<p>I have the following MVVM-C + RxSwift code.</p>

<p>The problem is that the TableView is not receiving any signals. When I 
debug the results I can see that the API call is returning what it should, the <code>objects</code> array is populated with objects but the tableview does not show any results. Here is the console output:</p>

<pre><code>2018-11-13 16:12:08.107: searchText -&gt; Event next(qwerty)
Search something: qwerty
2018-11-13 16:12:08.324: viewModel.data -&gt; Event next([])
</code></pre>

<p>Could it be the tableview itself? Maybe wrong custom cell setup?</p>

<p><strong>ViewController.swift:</strong></p>

<pre><code>    tableView = UITableView(frame: self.view.frame)
    tableView.delegate = nil
    tableView.dataSource = nil
    tableView.register(SearchResultCell.self, forCellReuseIdentifier: ""SearchResultCell"")

    viewModel.data
        .debug(""viewModel.data"", trimOutput: false)
        .drive(tableView.rx.items(cellIdentifier: ""SearchResultCell"")) { row, object, cell in

            cell.name.text = object.name
            cell.something.text = object.something
        }
        .disposed(by: disposeBag)
</code></pre>

<p><strong>ViewModel.swift:</strong></p>

<pre><code>let disposeBag = DisposeBag()
var searchText = BehaviorRelay(value: ""something to search for"")

lazy var data: Driver&lt;[Object]&gt; = {
    return self.searchText.asObservable()
        .debug(""searchText"", trimOutput: false)
        .throttle(0.3, scheduler: MainScheduler.instance)
        .distinctUntilChanged()
        .flatMapLatest(searchSomething)
        .asDriver(onErrorJustReturn: [])
}()

func searchSomething(query: String) -&gt; Observable&lt;[Object]&gt; {

    print(""Search something: \(query)"")

    let provider = MoyaProvider&lt;APIService&gt;()

    var objects = [Object]()

    provider.rx.request(.search(query: query)).subscribe { event in
        switch event {
        case let .success(response):
            do {
                let responseJSON: NSDictionary = try (response.mapJSON() as? NSDictionary)!
                objects = self.parse(json: responseJSON[""results""] as Any)

            } catch(let error) {
                print(error)
            }

            break
        case let .error(error):
            print(error)
            break
        }
    }
    .disposed(by: disposeBag)

    let result: Observable&lt;[Object]&gt; = Observable.from(optional: objects)

    return result
}
</code></pre>
","130412","","130412","","2018-11-14 10:45:44","2018-11-14 10:45:44","Tableview not receiving signals from Driver","<ios><swift><uitableview><rx-swift><frp>","1","2","","","","CC BY-SA 4.0"
"53334778","1","","","2018-11-16 09:19:18","","1","1900","<p>I have a model called <strong>Track</strong>. It has a set of basic and a set of extended properties. List of tracks and their basic properties are fetched with a <strong>search</strong> API call, then I need to make another API call with those <strong>track IDs</strong> to fetch their extended properties.</p>

<p><strong>The question is how to best combine the results</strong> of both API calls and populate the extended properties into the already created <strong>Track</strong> objects, and of course match them by ID (which unfortunately is a different property name in both calls' results). Note that there are many more keys returned in the real results sets - around 20-30 properties for each of the two calls.</p>

<p><strong>Track.swift</strong></p>

<pre><code>struct Track: Decodable {

// MARK: - Basic properties

let id: Int
let title: String

// MARK: - Extended properties

let playbackURL: String

enum CodingKeys: String, CodingKey {
    case id = ""id""

    case title = ""title""

    case playbackUrl = ""playbackUrl""
}

init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)

    let idString = try container.decode(String.self, forKey: CodingKeys.id)
    id = idString.int ?? 0

    title = try container.decode(String.self, forKey: CodingKeys.title)

    playbackURL = try container.decodeIfPresent(String.self, forKey: CodingKeys.playbackUrl) ?? """"
}
}
</code></pre>

<p><strong>ViewModel.swift</strong></p>

<pre><code>let disposeBag = DisposeBag()
var searchText = BehaviorRelay(value: """")
private let provider = MoyaProvider&lt;MyAPI&gt;()
let jsonResponseKeyPath = ""results""

public lazy var data: Driver&lt;[Track]&gt; = getData()

private func searchTracks(query: String) -&gt; Observable&lt;[Track]&gt; {
    let decoder = JSONDecoder()
    return provider.rx.request(.search(query: query))
        .filterSuccessfulStatusCodes()
        .map([Track].self, atKeyPath: jsonResponseKeyPath, using: decoder, failsOnEmptyData: false)
        .asObservable()
}

private func getTracksMetadata(tracks: Array&lt;Track&gt;) -&gt; Observable&lt;[Track]&gt; {
    let trackIds: String = tracks.map( { $0.id.description } ).joined(separator: "","")
    let decoder = JSONDecoder()
    return provider.rx.request(.getTracksMetadata(trackIds: trackIds))
        .filterSuccessfulStatusCodes()
        .map({ result -&gt; [Track] in

        })
        .asObservable()
}

private func getData() -&gt; Driver&lt;[Track]&gt; {
    return self.searchText.asObservable()
        .throttle(0.3, scheduler: MainScheduler.instance)
        .distinctUntilChanged()
        .flatMapLatest(searchTracks)
        .flatMapLatest(getTracksMetadata)
        .asDriver(onErrorJustReturn: [])
}
</code></pre>

<p><strong>The JSON result for .search API call is structured like this:</strong></p>

<pre><code>{
  ""results"": [
    {
      ""id"": ""4912"",
      ""trackid"": 4912,
      ""artistid"": 1,
      ""title"": ""Hello babe"",
      ""artistname"": ""Some artist name"",
      ""albumtitle"": ""The Best Of 1990-2000"",
      ""duration"": 113
    },
    { 
      ...
    }
  ]
}
</code></pre>

<p><strong>The JSON result for .getTracksMetadata API call is structured like this:</strong></p>

<pre><code>[
  {
    ""TrackID"": ""4912"",
    ""Title"": ""Hello babe"",
    ""Album"": ""The Best Of 1990-2000"",
    ""Artists"": [
      {
        ""ArtistID"": ""1"",
        ""ArtistName"": ""Some artist name""
      }
    ],
    ""SomeOtherImportantMetadata1"": ""Something something 1"",
    ""SomeOtherImportantMetadata2"": ""Something something 2"",
    ""SomeOtherImportantMetadata3"": ""Something something 3""
  },
  { 
    ...
  }
]
</code></pre>
","130412","","130412","","2018-11-19 10:17:00","2018-11-19 10:17:00","Combine the results of 2 API calls fetching different properties for the same objects with RxSwift","<ios><swift><rx-swift><moya>","1","3","","","","CC BY-SA 4.0"
"53352519","1","53356792","","2018-11-17 15:13:10","","-3","403","<pre><code>    searchBar.rx.textDidBeginEditing
        .subscribe { [unowned self] in
            print(""im begining diting"")
            self.searchBar.setShowsCancelButton(true, animated: true)
        }
        .disposed(by: disposeBag)
</code></pre>

<p>It does not working, maybe I have wrong method? but I have method </p>

<pre><code>    searchBar.rx.text
        .asObservable()
        .bind(to: directoryViewModel.searchTextObservable)
        .disposed(by: disposeBag)
</code></pre>

<p>Its working properly</p>
","7943297","","","","","2018-11-21 22:13:44","searchBar.rx.textDidBeginEditing does not working when im trying to edit text","<ios><swift><rx-swift><rx-cocoa>","1","6","1","","","CC BY-SA 4.0"
"53361150","1","53363012","","2018-11-18 13:01:44","","1","672","<p>I'm using RxCoCoa and RxSwift for UITableView Biding. 
the problem is when Connection lost or other connection errors except for Server Errors(I handled them) my app crash because of binding error that mentioned below. my question is how to handle Connection Errors?</p>

<pre><code>fileprivate func getNextState() {
        showFullPageState(State.LOADING)
        viewModel.getProductListByID(orderGroup: OrderGroup.SERVICES.rawValue)
                .do(onError: {
                    showStatusError(error: $0)
                    self.showFullPageState(State.CONTENT)
                })
                .filter {
                    $0.products != nil
                }
                .map {
                    $0.products!
                }
                .bind(to: (self.tableView?.rx.items(cellIdentifier: cellIdentifier, cellType: ProductCell.self))!) {
                    (row, element, cell) in
                    self.showFullPageState(State.CONTENT)
                    cell.product = element
                }

                .disposed(by: bag)
        self.tableView?.rx.setDelegate(self).disposed(by: bag)
    }
</code></pre>

<p>and this is my <strong>ViewModel</strong> :</p>

<pre><code>func getProductListByID(orderGroup: String, page: String = ""1"", limit: String = ""1000"") -&gt; Observable&lt;ProductRes&gt; {
        return orderRegApiClient.getProductsById(query: getProductQueryDic(stateKey: getNextStateID(product: nextProduct)
                , type: orderGroup, page: page, limit: limit)).map {
            try JSONDecoder().decode(ProductRes.self, from: $0.data)
        }.asObservable()
    }
</code></pre>

<p>and I use Moya for my Network layer like This:</p>

<pre><code>func getProductsById(query: [String: String]) -&gt; Single&lt;Response&gt; {
        return provider.rx.request(.getProductsById(query))
                .filterSuccessfulStatusCodes()
    }
</code></pre>

<p><a href=""https://i.stack.imgur.com/CyY0P.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CyY0P.png"" alt=""enter image description here""></a></p>
","5892896","","","","","2018-11-18 18:49:34","Handle Connection Error in UITableView Binding (Moya, RxSwift, RxCocoa)","<ios><swift><rx-swift><rx-cocoa><rx-binding>","1","0","1","","","CC BY-SA 4.0"
"53367089","1","","","2018-11-19 01:06:38","","0","547","<p>Is there any reason to emit an event on a subject with startWith</p>

<pre><code>let publishedSubject1 = PublishedSubject&lt;Void&gt;()
publishedSubject1
    .startWith(Void())
    .subscribe()
    .dispose(by: bag)
</code></pre>

<p>vs. just using .onNext</p>

<pre><code>let publishedSubject2 = PublishedSubject&lt;Void&gt;()
publisedSubject2
    .subscribe()
    .dispose(by: bag)
publishedSubject2.onNext(Void())
</code></pre>

<p>Is this just one of those Rx tricks to do the same thing just in different stylistic ways in the same vein that .map is used to hide nested subscribes by moving the subscribe inside the map operator?  I've looked at the code here: <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/StartWith.swift"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/StartWith.swift</a> and it just seems like another trick.  Is there a functional reason to use .startWith instead of just .onNext?</p>
","4005461","","","","","2018-11-20 02:33:35","The difference between using .startWith on a publishedSubject and just using .onNext on the publishedSubject","<rx-swift>","1","0","1","","","CC BY-SA 4.0"
"53376928","1","53377917","","2018-11-19 14:38:40","","0","372","<p>I have a boolean Variable which is switching true/false. I need to ignore any changes which settles less than 1 second. In other words, I need just values which stays more than 1 second. How to get such output from RxSwift?</p>

<p>Sample1: If value is true, and changes to false and then after 0.5 seconds become true again, I need my output sequence to show nothing.</p>

<p>Sample2: Above scenario with 1.2 seconds lag between false and true, makes a false event in my output sequence.</p>
","9792460","","9792460","","2018-11-19 14:55:25","2018-11-19 15:38:53","Ignoring fast changes on a Boolean variable with RxSwift","<boolean><rx-swift><ripple>","1","0","","","","CC BY-SA 4.0"
"53377393","1","53397594","","2018-11-19 15:03:51","","1","812","<p>I have relatively expensive operation so I am willing to perform that operation once and create 2 <code>Observables</code> from it.</p>

<p>Here is how it looks:</p>

<pre><code>let outputObservable1: Observable&lt;Bool&gt;
let outputObservable2: Observable&lt;Bool&gt;

(outputObservable1, outputObservable2) = inputObservable1.zip(inputObservable2).map { booleanCondition1, booleanCondition2 in
   // different condition combinations create different outputObservables
}
</code></pre>

<p>I am guessing <code>map</code> is not the right operator here as it will only yield one observable. How can I mix and match the conditions and return 2 <code>Observables</code> at once?</p>
","870011","","870011","","2018-11-20 16:34:41","2018-11-20 16:40:30","Create Multiple Observables from a Single one - RxSwift","<ios><observable><rx-swift>","1","6","","","","CC BY-SA 4.0"
"53381212","1","53388030","","2018-11-19 19:16:19","","7","11137","<p>I want to use <code>Rxswift</code> and not <code>IBActions</code> to solve my issue below,</p>

<p>I have a <code>UISwitch</code> and I want to subscribe to the value changed event in 
it,  </p>

<p>I usually subscribe on Buttons using this manner </p>

<pre><code>@IBOutlet weak var myButton: UIButton!


myButton
    .rx
    .tapGesture()
    .when(.recognized)
    .subscribe(onNext : {_ in /*do action here */})
</code></pre>

<p>Does anyone know how to subscribe to <code>UISwitch</code> control events?</p>
","8557882","","8330469","","2018-11-19 20:51:58","2019-07-04 04:56:19","How to subscribe on the value changed control event of a UISwitch Using Rxswift","<ios><swift><rx-swift>","4","2","5","","","CC BY-SA 4.0"
"53385630","1","53388980","","2018-11-20 03:06:20","","0","1231","<p>I'm having trouble understanding the way to early exit from an observable sequence if I don't have the necessary info. Here's a simplified example... </p>

<pre><code>@IBOutlet weak var myTextField: UITextField!
...
myButton.rx.tap. // stop here if textField is nil or empty
.flatMap { API.fetchMyList() }
.subscribe...
</code></pre>
","2066353","","2066353","","2018-11-20 03:22:01","2018-11-20 20:25:14","RxSwift exit from observable chain if text is empty","<swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"53391290","1","","","2018-11-20 10:45:48","","-2","225","<p>I have a photo view app which which I use <code>Alamofire</code> to get the data and use <code>RxSwift</code> to observer changes in the <code>API</code>. everything works well and I can print the total number of returned items and even print individual items but the app crashes when ever I set my <code>UIlabel</code> text to the title value got from the code. I do not know why this is any help would be appreciated. </p>

<p>the crash is <code>Thread 1: Fatal error: Unexpectedly found nil while unwrapping an Optional value</code></p>

<p><strong>Main cell</strong></p>

<pre><code>func configueCell(flickerPhotoModel: FlickrPhotoModel) -&gt; Void {

        self.layer.backgroundColor = UIColor.lightGray.cgColor
        print(""Cell \(String(describing: flickerPhotoModel.id))"")
        flikrTitle.text = flickerPhotoModel.title
    }
</code></pre>

<p><strong>PhotoViewModel</strong></p>

<pre><code>private func setupPageBinding() {
        currentState.asObservable()

            .subscribe(onNext: { currentState in
            if currentState == .initialLoading || currentState == .loadingNextPage {
                self.fetchNextPageOfPhotos()
            }
        }).disposed(by: disposeBag)
        photos.asObservable()
            .map { $0.count &gt; 0 ? self.currentPage.value + 1 : self.currentPage.value }
            .bind(to: currentPage)
            .disposed(by: disposeBag)
    }
</code></pre>

<p><strong>COntroller</strong></p>

<pre><code>private func setupCollectionViewBinding() {
        print(""JSONNN x \(self.viewModel.photos.value.count)"")
        viewModel.photos
            .asObservable()
            .bind(to: collectionView.rx.items(cellIdentifier: reuseIdentifier, cellType: MainCell.self))
            { _, photo, cell in
                cell.configueCell(flickerPhotoModel: photo)
                print(""JSONNN 5 \(self.viewModel.photos.value.count)"")
            }
            .disposed(by: disposeBag)
        viewModel.currentState
            .asObservable()
            .map { $0 == .initialLoading || $0 == .initialLoadingFailure }
            .bind(to: collectionView.rx.isHidden)
            .disposed(by: disposeBag)
        collectionView.rx.modelSelected(FlickrPhotoModel.self)
            .subscribe(onNext: {
                self.routingDelegate?.handlePhotoSelection($0)
            })
            .disposed(by: disposeBag)
    }
</code></pre>
","8310287","","","","","2018-11-20 13:54:45","Unexpectedly found nil while unwrapping an Optional value collectionview","<ios><swift><alamofire><rx-swift>","1","10","","2018-11-20 15:36:21","","CC BY-SA 4.0"
"53407609","1","53433059","","2018-11-21 08:04:51","","1","635","<pre><code>class A{

     func addTarget(target: Any, action: Selector)
}
</code></pre>

<p>Let's say I don't have class A source available (framework). How would I extend this class reactively to emit Rx events through an Observable?</p>

<p>I can create a class that just forwards the events through a PublishSubject, but in that case I wouldn't be creating a Reactive extension but doing it through a proxy class.</p>

<pre><code>let a = A()
let del = CustomClassThatAddsItselfAsATarget(a)
del.event.subscribe( ...
</code></pre>

<p>instead of</p>

<pre><code>let a = A()
a.rx.event.subscribe( ...
</code></pre>
","1304844","","","","","2018-11-22 14:34:52","Extending target-action methods with RxSwift","<swift><rx-swift><reactive>","2","4","1","","","CC BY-SA 4.0"
"53408664","1","","","2018-11-21 09:15:22","","0","35","<p>For example,</p>

<pre><code>let observable1 = Observable&lt;Void&gt;.of([1, 2, 3, 4, 5, 6, 7])
.take(1)
.flatMap{_ in 
 doSomething()
}

let observable2 = Observable&lt;Void&gt;.of([1, 2, 3, 4, 5, 6, 7])
.flatMap{_ in 
 doSomething()
}
.take(1)
</code></pre>

<p>my question is, what is the difference of this two Observable?
They looks same.</p>
","4512128","","","","","2018-11-21 14:42:01","What is the difference of ""take"" operator's sequence in a chain","<ios><rx-swift><reactivex>","1","0","","","","CC BY-SA 4.0"
"53418640","1","53419083","","2018-11-21 18:42:40","","0","278","<p>So far as I understand it, Swift does not support anonymous classes.</p>

<p>I am working with an RXSwift codebase and there is a block of code I cannot fully grasp what is going on.</p>

<p>Here is the block:</p>

<pre><code>    sections = Observable.combineLatest(observable1,
                                        observable2,
                                        observable3)
                                        {
                                            (arg1: $1,
                                            arg2: $0.0,
                                            arg3: $0.1,
                                            arg4: $2)
                                        }
                .map { arg1, arg2, arg3, arg4 -&gt; [Section] in
                    // Do Stuff
                 }
</code></pre>

<p>The issue I have is the block where it converts the combineLatest into this, what looks like, anonymous class.</p>

<p>When I look at the signature for combineLatest it shows:</p>

<pre><code>public static func combineLatest&lt;O1, O2, O3&gt;(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.E, O2.E, O3.E) throws -&gt; Self.E) -&gt; RxSwift.Observable&lt;Self.E&gt; where O1 : ObservableType, O2 : ObservableType, O3 : ObservableType
</code></pre>

<p>So as I read it, the @escaping closing takes in 3 arguments via the <code>@escaping (O1.E, O2.E, O3.E)</code></p>

<p>It seems like a new anonymous object is being created, and its one with 4 arguments instead of 3.</p>

<p>Could you perhaps explain how a new observable of a seemingly anonymous class (which I don't fully understand as being possible) is being created, and being created with 4 arguments instead of 3?</p>
","3324388","","","","","2018-11-21 19:15:06","How Does RXSwift combineLatest Use, What Looks Like, An Anonymous Class In A Closure And Handle Additional Parameters","<swift><observable><rx-swift><combinelatest>","1","2","","","","CC BY-SA 4.0"
"53430713","1","","","2018-11-22 12:09:37","","0","297","<p>Considering I have a array of items which might be updated on a different view controller and get notified update the change.
How can I update a <code>Observable&lt;[SomeObject]&gt;</code> with a single <code>SomeObject</code> modification so the change will then be propagated to the UITableViewController that presets these items?</p>

<p>P.S.
I can load the whole thing again with some hack, but it's obviously wrong for various reasons.</p>

<p>Thanks.</p>
","805138","","","","","2018-11-22 15:37:10","RXSwift Update single element","<swift><observable><rx-swift>","1","1","","","","CC BY-SA 4.0"
"53461349","1","","","2018-11-24 18:50:26","","0","555","<p>I'm trying to build a project that uses RxSwift module, XCode keeps complaining with the error ""no such module RxSwift""... </p>

<p>I've tried to install this module several times, in the terminal I got the following message after <code>pod install</code></p>

<pre><code>    Analyzing dependencies
Downloading dependencies
Using RxCocoa (4.3.1)
Using RxSwift (4.3.1)
Generating Pods project
Integrating client project
Sending stats
Pod installation complete! There are 2 dependencies from the Podfile and 2 total pods installed.

[!] Automatically assigning platform `ios` with version `11.4` on target `BTCPrice` because no platform was specified. Please specify a platform for this target in your Podfile. See `https://guides.cocoapods.org/syntax/podfile.html#platform`.

[!] Automatically assigning platform `watchos` with version `4.3` on target `WatchApp` because no platform was specified. Please specify a platform for this target in your Podfile. See `https://guides.cocoapods.org/syntax/podfile.html#platform`.

[!] Automatically assigning platform `watchos` with version `4.3` on target `WatchApp Extension` because no platform was specified. Please specify a platform for this target in your Podfile. See `https://guides.cocoapods.org/syntax/podfile.html#platform`.

[!] The `BTCPriceTests [Debug]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-BTCPriceTests/Pods-BTCPriceTests.debug.xcconfig'. This can lead to problems with the CocoaPods installation
    - Use the `$(inherited)` flag, or
    - Remove the build settings from the target.

[!] The `BTCPriceTests [Release]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-BTCPriceTests/Pods-BTCPriceTests.release.xcconfig'. This can lead to problems with the CocoaPods installation
    - Use the `$(inherited)` flag, or
    - Remove the build settings from the target.
</code></pre>

<p>as I could understand it RxSwift was installed, why does Xcode keep complaining about it?</p>

<p>I'm executing the .xcworkspace file..</p>

<p>thank you in advance for the answers!</p>
","9819649","","","","","2020-08-23 12:06:16","how to properly install ""RxSwift"" module?","<swift><xcode><rx-swift>","1","2","","","","CC BY-SA 4.0"
"53468918","1","53470402","","2018-11-25 15:18:44","","3","1148","<p>I have mock interactor and router for unit tests on presenter
presenter method: </p>

<p><i> </p>

<pre><code>private func presenterMethod(_ isOn: Bool) -&gt; Driver&lt;Bool&gt; {
    return interactor.interactorMethod(isOn)
        .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))
        .observeOn(MainScheduler.instance)
        .do(onError: { [weak self] error in
            self?.view.showError(error)
        })
        .asDriver(onErrorJustReturn: !isOn)
}
</code></pre>

<p></i></p>

<p>And test </p>

<p><i></p>

<pre><code>func testPresenterMethod() {
    let trigger = self.scheduler.createHotObservable([
        next(100, (false)),
        next(200, (true)),
        next(300, (false))
        ]).asDriverOnErrorJustComplete()

    let observer = scheduler.createObserver(Bool.self)
    let input = createInput(presenterTrigger: trigger)
    let output = presenter.transform(input)

    scheduler.scheduleAt(0, action: {
        output.presenterMethodOutput.asObservable()
            .subscribe(observer)
            .disposed(by: self.disposeBag)
    })

    scheduler.start()

    let results = observer.events.map {
        $0.value.element
    }

    XCTAssertEqual(results, [false, true, false])
}
</code></pre>

<p></i></p>

<p>And results are empty,</p>

<p>This test work correctly only when I remove these lines from presenterMethod</p>

<p><i></p>

<pre><code>    .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))
    .observeOn(MainScheduler.instance)
</code></pre>

<p></i></p>

<p>I tried with XCTestExpectation and fulfill in do(onNext:{}) block and get the same results, work only without subscribeOn background.
Method work correct on device and simulator, presenterMethod is treggered on switch and emit correct events. How this test should be written to work with SubscribeOn background?  </p>
","7339866","","","","","2018-11-25 20:02:07","RxSwift TestScheduler don't work if subscribeOn background","<ios><swift><rx-swift><reactivex><rxtest>","1","0","1","","","CC BY-SA 4.0"
"53479087","1","","","2018-11-26 10:25:35","","1","2022","<p><strong>How can I observe changes to <code>Variable&lt;...&gt;</code> value (<code>RxSwift</code> <code>Variable</code>) inside the <code>ViewModel</code> class from the <code>ViewController</code>?</strong></p>

<p>So in case the value of any of my <code>Variable&lt;..&gt;</code> that I have in the <code>ViewModel</code> changes within the things happening in the <code>ViewModel</code> then the <code>ViewController</code> will be noticed ""Hey! One or more Variable&lt;..> in the ViewModel changed! Ask the ViewModel for the data you need to update the UI and update the UI!""</p>

<p>And then the <code>ViewController</code> call a method <code>updateUI()</code> inside the ViewController and within it it asks the <code>ViewModel</code> for all the info like status/state to update the UI something like:</p>

<pre><code>func updateUI() {
  progressBar.hide = viewModel.getProgressBarVisibility()
  errorMessageLabel.hide = viewModel.getErrorMessageVisibility()
  errorMessageLabel.text = viewModel.getErrorMessageText()
  .....
  ...
}
</code></pre>
","3564632","","2395636","","2018-11-26 10:37:00","2019-02-19 11:17:16","How to make ViewController observe any changes to ViewModel variables (Variable<..>) with RxSwift?","<ios><swift><observer-pattern><rx-swift>","3","2","","","","CC BY-SA 4.0"
"53498878","1","53508197","","2018-11-27 11:41:51","","0","124","<p>I am refactoring an <code>UITableView</code> implementation in <strong>RxSwift</strong>. I have different view items and I want to switch them so that I am able to configure my dataSource accordingly. I need to know which cell class belongs to which view item.</p>

<p>To do so, I wrote a method that take an item which implement my <code>ViewItemProtocol</code> and returns <code>AnyClass?</code>.</p>

<pre><code>func getAssociatedtCellType&lt;T&gt;(for item: T) -&gt; AnyClass? where T: ViewItemProtocol {
    switch item  {
    case is TextFieldViewItem: return TextFieldCell.self
    case is FaqDetailViewItem: return FaqCell.self
    case is HeaderViewItem: return HeaderCell.self
    case is SubmitButtonViewItem: return SubmitButtonCell.self
    case is BankDetailViewItem: return BankDetailCell.self
    case is EmailViewItem: return EmailCell.self
    default: return nil
    }
}
</code></pre>

<p>The function method configured my cell:</p>

<pre><code>private func configCell&lt;T&gt;(for item: T, with identifier: String, at indexPath: IndexPath) -&gt; UITableViewCell where T: ViewItemProtocol {
    guard let cellType = getAssociatedtCellType(for: item.self) else { return UITableViewCell() }
    guard let cell = tableView.dequeueReusableCell(withIdentifier: identifier, for: indexPath) as? cellType else { fatalError() }
    cell.configureBindings(itemSource: item)
    return cell
}
</code></pre>

<p>The problem arises with <code>cellType</code>: </p>

<blockquote>
  <p>Use of undeclared type 'cellType'</p>
</blockquote>

<p>The objective behind is to refactor this method:</p>

<pre><code>private func dataSource() -&gt; RxTableViewSectionedReloadDataSource&lt;SectionedViewItem&gt; {

    let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionedViewItem&gt;(configureCell: { [unowned self] _, tableView, indexPath, item in

        switch item {
        case let item as TextFieldViewItem:
            guard let cell = tableView.dequeueReusableCell(withIdentifier: TextFieldCell.Key, for: indexPath) as? TextFieldCell else { fatalError() }
            cell.configureBindings(itemSource: item)
            cell.changeButton.isHidden = item.editable
            cell.changeButton.addTarget(self, action: #selector(self.showFieldNotEditableAlert), for: .touchUpInside)
            cell.textField.addTarget(self, action: #selector(self.textFieldDidChange), for: .editingChanged)
            return cell

        case let item as FaqDetailViewItem:
            guard let cell = tableView.dequeueReusableCell(withIdentifier: FaqDetailCell.Key, for: indexPath) as? FaqDetailCell else { fatalError() }
            cell.configureBindings(itemSource: item)
            return cell

        case let item as PasswordTextFieldViewItem:
            guard let cell = tableView.dequeueReusableCell(withIdentifier: PasswordTextFieldCell.Key, for: indexPath) as? PasswordTextFieldCell else { fatalError() }
            cell.configureBindings(itemSource: item)
            return cell

        case let item as HeaderViewItem:
            guard let cell = tableView.dequeueReusableCell(withIdentifier: HeaderCell.Key, for: indexPath) as? HeaderCell else { fatalError() }
            cell.configureBindings(itemSource: item)
            return cell

// ... My other cell types... :-(

    })

    dataSource.titleForHeaderInSection = { dataSource, index in
        let section = dataSource[index]
        return section.header
    }

    return dataSource
}
</code></pre>

<p>... into something like this:</p>

<pre><code>private func dataSource() -&gt; RxTableViewSectionedReloadDataSource&lt;SectionedViewItem&gt; {

    let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionedViewItem&gt;(configureCell: { [unowned self] _, tableView, indexPath, item in

        switch item {
        case let item as TextFieldViewItem:
            guard let cell = tableView.dequeueReusableCell(withIdentifier: TextFieldCell.Key, for: indexPath) as? TextFieldCell else { fatalError() }
            cell.configureBindings(itemSource: item)
            cell.changeButton.isHidden = item.editable
            cell.changeButton.addTarget(self, action: #selector(self.showFieldNotEditableAlert), for: .touchUpInside)
            cell.textField.addTarget(self, action: #selector(self.textFieldDidChange), for: .editingChanged)
            return cell

        case let item as FaqDetailViewItem, let item as PasswordTextFieldViewItem, let item as HeaderViewItem:
            return configCell(for: item, with: ""Cell.Key... still to implement)"", at: indexPath)


        default:
            return UITableViewCell()
        }

    })

    dataSource.titleForHeaderInSection = { dataSource, index in
        let section = dataSource[index]
        return section.header
    }

    return dataSource
}
</code></pre>
","4473187","","","","","2018-11-27 21:11:57","Swift (RxSwift): Using generics to link ViewItem and Cell classes","<ios><swift><generics><rx-swift>","1","0","","","","CC BY-SA 4.0"
"53516237","1","","","2018-11-28 09:33:39","","0","346","<p>A <code>UITableView</code> is fed with data from the <code>ViewModel</code> with a <code>RxSwift Driver</code>.</p>

<p>The use case is a simple text-based search - when the user types in a string in the <code>SearchBar</code>, the API returns results or no results. If no results, the driver returns empty array.</p>

<p>The problem is when there are no results, and then the search query is updated, so now there are results, the cells' frames in the table view are defaulted to (0, 0, 0, 44) - and thus not shown at all. I am setting an initial <code>backgroundView</code> to the <code>UITableView</code>, which is <code>nilled</code> when there are results from the query in the <code>.do {}</code> part. The cells are suddenly shown when I scroll down and then back up, but somehow initially they are covered by the background view, which is supposed to be <code>nil</code>.</p>

<p>This happens only when transitioning from an empty result to not-empty result. When there are results populated in cells, changing the query string and showing new results works fine.</p>

<p>What could cause the cells' frames to be nulled and how to properly clear the <code>UITableView</code> results (and show a No Results message in <code>UITableView.backgroundView</code> instead), if the <code>Driver</code> emits empty result set?</p>

<p><strong>ViewModel.swift</strong></p>

<pre><code>var searchText = PublishSubject&lt;String&gt;()

private func getData() -&gt; Driver&lt;[Item]&gt; {
    return self.searchText
        .filter({ (query) -&gt; Bool in
            return query.count &gt; 0
        })
        .asObservable()
        .throttle(0.2, scheduler: MainScheduler.instance)
        .distinctUntilChanged()
        .flatMapLatest(searchAPI)
        .asDriver(onErrorJustReturn: [])

}
</code></pre>

<p><strong>ViewController.swift</strong></p>

<pre><code>var viewModel: SearchViewModel!

var tableView: UITableView!
let searchController = UISearchController(searchResultsController: nil)
var searchBar: UISearchBar { return searchController.searchBar }


override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
}

required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
}

override func viewDidLoad() {
    super.viewDidLoad()

    setupUI()
    setupBindings()
}

private func setupUI() {
    tableView = UITableView(frame: self.view.frame)
    tableView.register(SearchResultCell.self, forCellReuseIdentifier: ""SearchResultCell"")
    tableView.rowHeight = 56
    tableView.tableHeaderView = searchBar
    tableView.separatorStyle = .none
    tableView.keyboardDismissMode = .onDrag

    tableView.delegate = nil
    tableView.dataSource = nil
    view.addSubview(tableView)

    showMessage(.initial)

    configureSearchController()
    searchController.searchBar.searchBarStyle = .minimal
}


private func showMessage(_ type: SearchMessage) {
    let rect = CGRect(origin: CGPoint(x: 0,y :0), size: CGSize(width: self.view.bounds.size.width, height: self.view.bounds.size.height))
    let emptyMessageLabel = UILabel(frame: rect)

    switch type {

    case .initial:
        emptyMessageLabel.text = ""Try searching bla bla""

    case .noResult:
        emptyMessageLabel.text = ""No results found.\nTry searching again""
    }

    tableView.backgroundView = emptyMessageLabel;
}


extension SearchViewController {
    private func setupBindings() {
        viewModel.data
           .do(onNext: { [weak self] items in
                guard let self = self else { return }
                self.tableView.backgroundView = nil
                if items.count == 0 {
                   self.showMessage(.noResult)
                }
            })
            .drive(tableView.rx.items(cellIdentifier: ""SearchResultCell"", cellType: SearchResultCell.self)) { row, item, cell in
                cell.label.text = item.title
                do {
                    try _ = cell.imageView.kf.rx.setImage(with: item.imageUrl.asURL()).subscribe()
                } catch(let error) {
                    cell.imageView.image = UIImage.init(named: ""DefaultImage"")
                }
            }
            .disposed(by: disposeBag)
    }
}
</code></pre>

<p><strong>SearchResultCell.swift</strong></p>

<pre><code>class SearchResultCell: UITableViewCell {

    var nameLabel: UILabel!
    var imageView: UIImageView!

    required init?(coder aDecoder: NSCoder) {
        fatalError(""init(coder:) has not been implemented"")
    }

    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)

        setupUI()
    }

    private func setupUI() {
        clipsToBounds = true
        autoresizesSubviews = false

        nameLabel = UILabel()
        imageView = UIImageView(image: nil)
        imageView.contentMode = .scaleAspectFit

        contentView.addSubview(nameLabel)
        contentView.addSubview(imageView)

        nameLabel.textColor = .darkGray
        nameLabel.font = UIFont.systemFont(ofSize: 15)
    }
</code></pre>
","130412","","130412","","2018-11-29 08:36:07","2018-11-29 08:36:07","RxSwift Driver - issues with nulled UITableView cell frames and background view","<ios><swift><uitableview><rx-swift>","0","5","","","","CC BY-SA 4.0"
"53518117","1","","","2018-11-28 11:12:18","","2","1933","<p>In my mobile application I would like to update the tableView datasource by a pull to refresh request, but I don't know how to insert the new items on top of the tableview datasource. </p>

<p>I see that there is a a method of insertRows such as : self.tableView?.insertRows(at: [indexPath], with: .top) but how do I add the newItems here according to my methods I have? </p>

<p>I have a function called initializedTableView() that initializes the tableView with PublishSubject observable items.</p>

<pre><code>func initializeTableView() {

    viewModel
        .items
        .subscribe(onNext: { items in

            self.tableView?.delegate = nil
            self.tableView?.dataSource = nil

            Observable.just(items)
                .bind(to:(self.tableView?.rx.items(cellIdentifier: 
                 itemCell.Identifier, cellType: itemCell.self))!) { 
                 (index, element, cell) in

                    cell.itemModel = element

                }.disposed(by: self.disposeBag)
        })
        .disposed(by: disposeBag)
}
</code></pre>

<p>This function is called once a pull to refresh is requested by user: </p>

<pre><code>func refreshTableView() {

    // get new items
    viewModel
        .newItems
        .subscribe(onNext: { newItems in

            //new
            let new = newItems.filter({ item in
                // items.new == true
            })

            //old
            var old = newItems.filter({ item -&gt; Bool in
                // items.new == false
            })

            new.forEach({item in
                // how to update tableView.rx.datasource here???

            })

 }).disposed(by: disposeBag)
 }
</code></pre>
","1273790","","","","","2018-12-04 07:14:35","Pull to refresh in a tableview rx datasource","<ios><swift><tableview><datasource><rx-swift>","3","2","","","","CC BY-SA 4.0"
"53540287","1","","","2018-11-29 13:35:24","","1","35","<p>I created an extension of <code>Observable</code>, <code>Single</code> and <code>Completable</code> to report a <strong>non-fatal</strong> issues to Crashlytics when an error occurs in the <code>do(onError:)</code> RxSwift method.</p>

<p>It works like that : <code>myObservable.handleError()</code>. This method is functional, but the report in Firebase dashboard doesn't show the real source of the error. </p>

<p>My <code>handleError</code> method call the log method of the Logger class, which is implemented this way :</p>

<pre><code>class Logger {

    static let shared = Logger()

    public func log(_ error: Error) {
        Crashlytics.sharedInstance().recordError(error)
    }

}
</code></pre>

<p>On the Firebase dashboard, the file that appears is the Logger.swift, not the file &amp; the line where error occurs.</p>

<p>Is there a way to have the right file in the dashboard ?</p>
","4529612","","","","","2018-11-29 13:35:24","Crashlytics Swift wrong error ""path"" on Firebase dashboard","<swift><error-handling><crashlytics><rx-swift>","0","0","","","","CC BY-SA 4.0"
"53540465","1","53550510","","2018-11-29 13:45:17","","2","2829","<p>Ultimately I need a way to catch RXSwift errors without emitting another item to the stream, this doesn't seem possible with the current RX operators.</p>

<p>Here's how my application works now:</p>

<p>I have 3 layers:</p>

<ul>
<li>Service layer</li>
<li>Local data layer</li>
<li>Remote data layer</li>
</ul>

<p>The service layer acts as a bridge between the local and remote layers and is called directly by UI code.</p>

<p>For each function provided in the service layer e.g. <code>getData() -&gt; Observable&lt;String&gt;</code> I need to do the following:</p>

<ul>
<li>Get the local data &amp; start a ticker counting from 0 upwards every second</li>
<li>Get the data from the remote service</li>
<li>The ticker should only complete when the remote service completes</li>
<li>If the local service returns an error, it must be ignored and not emitted</li>
<li>When the remote service completes, update the local data with the new data, if any</li>
</ul>

<p>I've gotten this far in a playground:</p>

<p>The local data service:</p>

<pre><code>let localService = Observable&lt;String&gt;.create { (observer) -&gt; Disposable in
    observer.onNext(""Local result"")
    observer.onCompleted()
    return Disposables.create()
}.observeOn(MainScheduler.instance)
</code></pre>

<p>The remote data service:</p>

<pre><code>let remoteService = Observable&lt;String&gt;.create { (observer) -&gt; Disposable in
    observer.onNext(""Remote result"")
    observer.onCompleted()
    return Disposables.create()
}.observeOn(MainScheduler.instance).delay(5, scheduler: MainScheduler.instance)
</code></pre>

<p>The database updater service:</p>

<pre><code>let databaseUpdaterService = Observable&lt;Void&gt;.empty().observeOn(MainScheduler.instance).delay(2, scheduler: MainScheduler.instance)
let remoteAndDatabaseService = remoteService.do(onNext: { (value) in
    print(""Database updating"")
    _ = databaseUpdaterService.subscribe(onCompleted: {
        print(""Database updated"")
    })
})
</code></pre>

<p>The time ticker:</p>

<pre><code>let ticker = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance).do(onNext: { (tick) in
    print(""Ticker event: \(tick) seconds"")
}).takeUntil(remoteService)
</code></pre>

<p>The merged service:</p>

<pre><code>let mergedService = Observable&lt;String&gt;.merge([localService, remoteAndDatabaseService])
</code></pre>

<p>Starting the ticker:</p>

<pre><code>print(""Ticker start"")
_ = ticker.subscribe(onError: { (error) in
    print(""Ticker error"")
}, onCompleted: {
    print(""Ticker completed"")
}, onDisposed: {
    print(""Ticker disposed"")
})
</code></pre>

<p>Starting the service:</p>

<pre><code>print(""Service start"")
_ = mergedService.subscribe(onNext: { (value) in
    print(""Service value: \(value)"")
}, onError: { (error) in
    print(error.localizedDescription)
}, onCompleted: {
    print(""Service completed"")
}, onDisposed: {
    print(""Service disposed"")
})
</code></pre>

<p>For the happy path, this works perfectly.</p>

<p>However, in the case where the localService calls an <code>onError</code> (if the local object doesn't exist for example) the merged stream terminates.</p>

<p>I would like for the error to be swallowed up and for nothing to be emmitted by the stream for the localService.</p>

<p>Currently the <code>catch</code> operators force you to emit another object instead of failing silently.</p>

<p>Thanks in advance for the help.</p>
","1852308","","","","","2021-07-08 02:39:09","RXSwift: Catch an error without emiting an element from the stream","<rx-swift>","2","0","","","","CC BY-SA 4.0"
"53564878","1","53566958","","2018-11-30 21:04:03","","1","807","<p>I have a function which takes two parameters related to RxSwift and bidirectionally bind them. </p>

<pre><code>import Foundation
import RxSwift
import RxCocoa
func bibind&lt;T&gt;(property: ControlProperty&lt;T&gt;, variable: Variable&lt;T&gt;) -&gt; Disposable {

    var updating = false

    let bindToUIDisposable = variable.asObservable().filter({ _ in
        updating = !updating
        return updating
    }).bind(to: property)
    let bindToVariable = property.filter({ _ in
        updating = !updating
        return updating
    }).subscribe(onNext: { n in
        variable.value = n
    }, onCompleted:  {
        bindToUIDisposable.dispose()
    })

    return CompositeDisposable(bindToUIDisposable, bindToVariable)
}
</code></pre>

<p>I am trying to call it like this </p>

<pre><code>bibind(property: self.userNameTextField.rx.text, variable: self.loginViewModel.userName.value )
</code></pre>

<p>Which is showing compiler error</p>

<pre><code>Expression type 'Variable&lt;String&gt;' is ambiguous without more context
</code></pre>

<p>The view model is this</p>

<pre><code>import Foundation
import RxSwift
import RxCocoa

class LoginViewModel {
    var userName = Variable&lt;String&gt;("""")
    var password = Variable&lt;String&gt;("""")

    init() {
        userName = Variable("""")
        password = Variable("""")
    }
}
</code></pre>
","4877605","","","","","2018-12-01 01:22:07","generic function parameter giving ""Expression type is ambiguous without more context""","<swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"53591149","1","53591448","","2018-12-03 09:50:29","","5","2063","<p>I'm trying to make a small reactive wrapper for ImageDownloader from AlamofireImage:</p>

<pre><code>import Foundation
import UIKit.UIImage
import AlamofireImage
import RxCocoa
import RxSwift


extension Reactive where Base: ImageDownloader {

    public func download(urlRequest: URLRequest, filter: ImageFilter?) -&gt; Observable&lt;UIImage&gt; {

        return Observable.create { observer in

            self.base.download(urlRequest, filter: filter) { response in

                if let error = response.error {
                    observer.onError(error)
                } else if let image = response.value {
                    observer.onNext(image)
                }
            }
            return Disposables.create()
        }
    }
}
</code></pre>

<p>It compiles without a problem. But when I try to call <code>rx.download</code> on an instance of ImageDownloader I get an error saying that there is no 'rx' extension there:</p>

<p><a href=""https://i.stack.imgur.com/uLwyt.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/uLwyt.png"" alt=""Value of type &#39;ImageDownloader&#39; has no member &#39;rx&#39; error""></a></p>

<p>Any guesses why this is happening?</p>
","10290254","","","","","2018-12-03 10:14:25","Value of type * has no member 'rx'","<ios><swift><rx-swift><reactive><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"53596156","1","53596478","","2018-12-03 14:48:42","","0","776","<p>How can we use the Swift 4.2 style of capturing self in closures in functions that returns a type?</p>

<p>For example:</p>

<pre><code>func checkEmailExists(_ email: String) -&gt; Observable&lt;Bool&gt; {
    return Observable.create { [weak self] observer in
        guard let self = self else { return }
        self.callAPI()
    }
}
</code></pre>

<p>This generates an error <code>Non-void function should return a value</code> but also it should not <code>return false</code> as this will influence the outcome of the function call.</p>

<p>EDIT: Another example, throws <code>Non-void function should return a value</code></p>

<pre><code>func loginWithCredentials() -&gt; Observable&lt;User&gt; {
    return Observable.create { [weak self] observer in
        guard let self = self else { return }

        let decoder = JSONDecoder()
        let json = [""id"": 1, ""name"": ""John Doe"", ""email"": ""john@doe.com""] as [String: Any]

        do {
            let user = try decoder.decode(User.self, from: json.jsonData()!)
            observer.onNext(user) // Simulation of successful user authentication.
        } catch {
            print(""error"")
        }

        return Disposables.create()
    }
}
</code></pre>
","130412","","130412","","2018-12-05 08:54:44","2018-12-05 08:54:44","""Non-void function should return a value"" when capturing Self in Swift 4.2 guard statement in closure in function","<swift><rx-swift><self>","2","3","1","","","CC BY-SA 4.0"
"53620508","1","53622134","","2018-12-04 19:56:08","","3","2370","<p>I'm having a real hard time trying to create an extension that converts a Single array to an Observable. So for example I have a <code>Single&lt;[Address]&gt;</code> and I want to convert it to an <code>Observable&lt;Address&gt;</code>.</p>

<p>The code I have to write each time I want to do this is</p>

<pre><code>mySingleVariable.asObservable().flatMap({ addresses in Observable.from(addresses) })
</code></pre>

<p>This operation is very common and the code is quite verbose. My attempt to create an extension looks like the following</p>

<pre><code>extension PrimitiveSequence where Trait == SingleTrait {
    func flatObservable&lt;R: Collection&gt;() -&gt; Observable&lt;R.Element&gt; {
        return asObservable().flatMap({ element in Observable.from(element) })
    }
}
</code></pre>

<p>The code above unfortunately does not work. The error I get is ""Generic parameter 'R' is not used in function signature"". This is because the function returns <code>Observable&lt;R.Element&gt;</code>. If it were to return <code>Observable&lt;R&gt;</code>, the error would go away, but it's not the result I'm trying to achieve.</p>
","4236109","","","","","2018-12-04 22:20:03","rxSwift extension for converting Single<[Element]> to Observable<Element>","<ios><arrays><swift><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"53669475","1","53670099","","2018-12-07 12:22:29","","0","603","<p>I made a simple Rx extension for <code>FloatRatingView</code> library for its <code>rating</code> property, like so:</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

public extension Reactive where Base: FloatRatingView {

    /// Bindable sink for `rating` property
    public var rating: Binder&lt;Double?&gt; {
        return Binder(self.base) { frv, attr in
            frv.rating = attr ?? 0
        }
    }
}
</code></pre>

<p>Question is, how do I make that extension support the <code>.distinctUntilChanged()</code>?</p>

<p>My idea is I need to have a throttle or debounce before passing the value of the rating to the controller, like so:</p>

<pre><code>    self.ratingView_Driver.rx.rating
        .distinctUntilChanged()
        .debounce(0.5, scheduler: MainScheduler.instance)
        .subscribe { _ in

        }.disposed(by: self.disposeBag)
</code></pre>

<p>Error is:</p>

<blockquote>
  <p>Value of type 'Binder' has no member 'distinctUntilChanged'</p>
</blockquote>
","3231194","","","","","2018-12-07 13:00:33","How to support distinctUntilChanged for Binder in RxSwift?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"53708356","1","53708861","","2018-12-10 15:04:31","","0","489","<p>I'm using RxSwift on a project, where I have a <code>DataSource</code> with different <code>ViewItems</code>. That's my <code>DataSource</code> configuration:</p>

<pre><code>let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionedViewItem&gt;(configureCell: { _, tableView, indexPath, item in

            if let viewItem = item as? BannerViewItem {
                guard let cell = tableView.dequeueReusableCell(withIdentifier: BannerCell.Key, for: indexPath) as? BannerCell else { fatalError() }
                cell.configureBindings(itemSource: viewItem)
                return cell
            } else if let viewItem = item as? CarSpecificationViewItem {
                guard let cell = tableView.dequeueReusableCell(withIdentifier: CarSpecificationCell.Key, for: indexPath) as? CarSpecificationCell else { fatalError() }
                cell.configureBindings(itemSource: viewItem)
                return cell
            } else if let viewItem = item as? CarBenefitViewItem {
                guard let cell = tableView.dequeueReusableCell(withIdentifier: CarBenefitCell.Key, for: indexPath) as? CarBenefitCell else { fatalError() }
                cell.configureBindings(itemSource: viewItem)
                return cell
            } else if let viewItem = item as? FavoriteHeaderViewItem {
                guard let cell = tableView.dequeueReusableCell(withIdentifier: CarFavoritesCell.Key, for: indexPath) as? CarFavoritesCell else { fatalError() }
                cell.configureBindings(itemSource: viewItem)
                return cell
            } else {
                return UITableViewCell()
            }
        })
</code></pre>

<p>Then I bind it to my <code>ViewModel</code>:</p>

<pre><code>viewModel.dataSource.bind(to: tableView.rx.items(dataSource: dataSource)).disposed(by: disposeBag)
</code></pre>

<p>I subscribe to the selection events in the following way:</p>

<pre><code>tableView.rx
    .modelSelected(CarSpecificationViewItem.self)
    .subscribe(tableViewRowSelected)
    .disposed(by: disposeBag)
</code></pre>

<p>This approach worked fine as long as I only reacted to <code>CarSpecificationViewItem</code>. Now I have activated <code>userInteraction</code> for <code>CarFavoritesCell</code> and subscribe to it's events as well:</p>

<pre><code>tableView.rx
    .modelSelected(FavoriteHeaderViewItem.self)
    .subscribe(test)
    .disposed(by: disposeBag)
</code></pre>

<p>But this started to produce errors. I get a crash when tapping on my FavoriteHeaderViewItem:</p>

<blockquote>
  <p>Thread 1: Fatal error: Failure converting from Optional(CLCarRentalCore.FavoriteHeaderViewItem) to CarSpecificationViewItem</p>
</blockquote>

<p>What could be the origin of the problem? Thanks in advance!</p>
","4473187","","","","","2018-12-11 07:08:31","RxSwift: Reacting to different cell types","<ios><swift><rx-swift>","2","1","","","","CC BY-SA 4.0"
"53717518","1","53724978","","2018-12-11 04:47:56","","1","1835","<p>I use RxSwift to show list of Persons in my tableview, and my tableview has two sections, the first one is old searches and the second one is all Persons. now I don't know how should I filter Persons when users type a name on UISearchBar's textfield.</p>

<p>This is my Person model:</p>

<pre><code>struct PersonModel {
    let name: String
    let family:String
    let isHistory:Bool
}
</code></pre>

<p>This is my ContactsViewModel</p>

<pre><code>struct SectionOfPersons {
    var header: String
    var items: [Item]
}

extension SectionOfPersons: SectionModelType {
    typealias Item = PersonModel

    init(original: SectionOfPersons, items: [SectionOfPersons.Item]) {
        self = original
        self.items = items
    }
}

class ContactsViewModel {

    let items = PublishSubject&lt;[SectionOfPersons]&gt;()

    func fetchData(){

        var subItems : [SectionOfPersons] = []

        subItems.append( SectionOfPersons(header: ""History"", items: [
            SectionOfPersons.Item(name:""Michelle"", family:""Obama"", isHistory:true ),
            SectionOfPersons.Item(name:""Joanna"", family:""Gaines"", isHistory:true )
        ]))
        subItems.append( SectionOfPersons(header: ""All"", items: [
            SectionOfPersons.Item(name:""Michelle"", family:""Obama"", isHistory:false ),
            SectionOfPersons.Item(name:""James"", family:""Patterson"", isHistory:false ),
            SectionOfPersons.Item(name:""Stephen"", family:""King"", isHistory:false ),
            SectionOfPersons.Item(name:""Joanna"", family:""Gaines"", isHistory:false )
        ]))

        self.items.onNext( subItems )
    }

}
</code></pre>

<p>and this is my ContactsViewController:</p>

<pre><code>class ContactsViewController: UIViewController {

    @IBOutlet weak var tableView: UITableView!
    @IBOutlet weak var searchBar: UISearchBar!

    private lazy var dataSource = RxTableViewSectionedReloadDataSource&lt;SectionOfPersons&gt;(configureCell: configureCell, titleForHeaderInSection: titleForHeaderInSection)

    private lazy var configureCell: RxTableViewSectionedReloadDataSource&lt;SectionOfPersons&gt;.ConfigureCell = { [weak self] (dataSource, tableView, indexPath, contact) in
        guard let cell = tableView.dequeueReusableCell(withIdentifier: ""ContactTableViewCell"", for: indexPath) as? ContactTableViewCell else { return UITableViewCell() }
        cell.contact = contact
        return cell
    }

    private lazy var titleForHeaderInSection: RxTableViewSectionedReloadDataSource&lt;SectionOfPersons&gt;.TitleForHeaderInSection = { [weak self] (dataSource, indexPath) in
        return dataSource.sectionModels[indexPath].header
    }

    private let viewModel = ContactsViewModel()
    private let disposeBag = DisposeBag()

    var showContacts = PublishSubject&lt;[SectionOfPersons]&gt;()
    var allContacts = PublishSubject&lt;[SectionOfPersons]&gt;()

    override func viewDidLoad() {
        super.viewDidLoad()

        bindViewModel()
        viewModel.fetchData()
    }

    func bindViewModel(){

        tableView.backgroundColor = .clear
        tableView.register(UINib(nibName: ""ContactTableViewCell"", bundle: nil), forCellReuseIdentifier: ""ContactTableViewCell"")
        tableView.rx.setDelegate(self).disposed(by: disposeBag)

        viewModel.items.bind(to: allContacts).disposed(by: disposeBag)
        viewModel.items.bind(to: showContacts).disposed(by: disposeBag)
        showContacts.bind(to: tableView.rx.items(dataSource: dataSource)).disposed(by: disposeBag)

        searchBar
            .rx.text
            .orEmpty
            .debounce(0.5, scheduler: MainScheduler.instance)
            .distinctUntilChanged()
            .filter { !$0.isEmpty }
            .subscribe(onNext: { [unowned self] query in

                ////// if my datasource was simple string I cand do this
                self.showContacts = self.allContacts.filter { $0.first?.hasPrefix(query) } // if datasource was simple array string, but what about complex custome object?!

            })
            .addDisposableTo(disposeBag)

    }
}
</code></pre>

<p>Thanks for your response.</p>
","1713906","","","","","2018-12-11 13:25:02","UISearchBar in UITableView by Rxswift","<swift><uitableview><uisearchbar><rx-swift><rxdatasources>","1","0","1","","","CC BY-SA 4.0"
"53731813","1","53732055","","2018-12-11 20:24:45","","0","564","<p>I have in a viewmodel a reactive closure to return and sort data from a network call based on type (shipping or billing).</p>

<pre><code>Observable.combineLatest(input.headerRefresh, type).flatMapLatest({ (header, type) -&gt; Observable&lt;[AddressItemViewModel]&gt; in
    var els : Observable&lt;[AddressItemViewModel]&gt;

     els = self.request()
        .trackActivity(self.loading)
        .trackActivity(self.headerLoading)
        .trackError(self.error)

    return els.map{
        $0.map {
            print(type)
            var item  : AddressItemViewModel!
            switch(type){
            case .shipping:
                if($0.address.isShipping){
                    item = AddressItemViewModel(with: $0.address)
                }

            case .billing:
                if($0.address.isBilling){
                    item = AddressItemViewModel(with: $0.address)
                }
            }

            return item // error
        }
    }

   }).subscribe(onNext: { (items) in
        elements.accept(items)
    }).disposed(by: rx.disposeBag)
</code></pre>

<p>When subscribed to <code>elements</code> in the view controller, the app crash at <code>return item</code>.</p>

<p>So my question is how to sort items without using nullable objects? Thanks.</p>

<p>The error : </p>

<blockquote>
  <p>Thread 1: Fatal error: Unexpectedly found nil while unwrapping an
  Optional value</p>
</blockquote>
","2187976","","3141234","","2018-12-11 20:27:58","2018-12-11 21:01:09","switch cases in Observable map Rxswift","<ios><swift><reactive-programming><rx-swift>","1","4","","","","CC BY-SA 4.0"
"53736909","1","53741972","","2018-12-12 05:59:14","","1","242","<p>I have a question abou RxSwift.</p>

<p>I have Observable&lt;[Array]> and I need to separate it with Observable</p>

<p>How could I divide the observable Observable&lt;[Array]> into observable ... N and do flatMap for each observable ?</p>
","1122517","","1113632","","2018-12-12 13:27:30","2018-12-12 13:27:30","RxSwift, Divide Observable<[array]> into Observable<a>, Observable<b>","<swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"53753738","1","","","2018-12-13 01:22:41","","0","335","<p>Does anyone know how RX button tap handling actually had been implemented?</p>
","3661014","","3661014","","2018-12-13 01:43:10","2018-12-14 06:37:02","How RX button tap handling actually had been implemented?","<ios><swift><rx-swift>","2","1","","","","CC BY-SA 4.0"
"53772589","1","","","2018-12-14 02:03:14","","0","183","<p>I have an object and its properties as following:</p>

<pre><code>class Section {

 var cards: [MemberCard]

 init(card: [MemberCard]) {

 }
}

class MemberCard {
  var name: String
  var address: String?
  init(name: String) {
     self.name = name
  }
}
</code></pre>

<p>I'm subscribing to a RxStream of type Observable&lt;[Section]>. Before I subscribe I would to want flat map this function.</p>

<p>where the flat map would perform the following actions:</p>

<pre><code>let sectionsStream : Observable&lt;[Section]&gt; = Observable.just([sections])
sectionsStream
.flatMap { [weak self] (sections) -&gt; Observable&lt;[Section]&gt; in
  for section in sections {

     for card in section.cards {

     }
   }
 }.subscribe(onNext: { [weak self] (sections) in

    self?.updateUI(memberSections: sections)

}).disposed(by: disposeBag)

func getAddressFromCache(card: MemberCard) -&gt; Observable&lt;MemberCard&gt; {
   return Cache(id: card.name).flatMap ({ (card) -&gt; Observable&lt;MemberCard&gt; in
      asyncCall{

         return Observable.just(card)   
      }

   }
}
</code></pre>

<p>How would the flatmap look like when it comes to converting <code>Observable&lt;[Section]&gt;</code> to array of <code>[Observable&lt;MemberCard&gt;]</code> and back to <code>Observable&lt;[Section]&gt;</code>?</p>
","1253102","","2227743","","2018-12-15 10:56:52","2018-12-15 10:56:52","Subscribing to fetch a nested array","<swift><rx-swift>","2","2","","","","CC BY-SA 4.0"
"53799567","1","","","2018-12-16 05:02:56","","1","144","<p>im breaking my mind around how to do this in RX.</p>

<p>T<strong>he actual usecase is mapping of LowerLevelEvent(val userId: String) to HigherLevelEvent(val user: User), where the User is provided by observable, so it can emit n times,</strong> so example output</p>

<pre><code>LowerLevelEvent1(abc) -&gt; HigherLevelEvent1(userAbc(nameVariation1)
LowerLevelEvent2(abc) -&gt; HigherLevelEvent2(userAbc(nameVariation1)
LowerLevelEvent3(abc) -&gt; HigherLevelEvent3(userAbc(nameVariation1)
LowerLevelEvent4(abc) -&gt; HigherLevelEvent4(userAbc(nameVariation1)
                         HigherLevelEvent4(userAbc(nameVariation2)
                         HigherLevelEvent4(userAbc(nameVariation3)
</code></pre>

<p>So my naive solution was to use combineLatest. So while userId is not changed user observable is subscribed, i.e. not resubscribed when new lowerLevelEmits &amp; its userId is not changed</p>

<pre><code>val _lowerLevelEventObservable: Observable&lt;LowerLevelEvent&gt; = lowerLevelEventObservable
                        .replayingShare()

val _higherLevelEventObservable: Observable&lt;HigherLevelEvent&gt; = Observables
                        .combineLatest(
                _lowerLevelEventObservable, 
                _lowerLevelEventObservable
                            .map { it.userId }
                            .distinctUntilChanged()
                            .switchMap { userRepository.findByIdObservable(it)
            ) { lowerLevelEvent, user -&gt; createHigherLevelInstance... }
</code></pre>

<p>However this has glitch issues, since both sources in combineLatest originate from same observable.</p>

<p>Then I thought about</p>

<pre><code>lowerLevelObservable.
   .switchMap { lowerLevelEvent -&gt;
      userRepository.findByIdObservable(lowerLevelEvent.userId)
          .map { user -&gt; createHigherLevelInstance... }
   }
</code></pre>

<p>This however can break if lowerLevelObservable emits fast, and since user observable can take some time, given lowerLevelX event can be skipped, which I cannot have. Also it resubscribes user observable each emit, which is wasteful since it wont change most likely</p>

<p>So, maybe concatMap? That has issue of that the user observable doesnt complete, so concatMap wouldnt work.</p>

<p>Anyone have a clue?</p>

<p>Thanks a lot</p>

<p>// Clarification:
basically its mapping of A variants (A1, A2..) to A' variants (A1', A2'..) while attaching a queried object to it, where the query is observable so it might reemit after the mapping was made, so AX' needs to be reemited with new query result. But the query is cold and doesnt complete</p>

<p>So example <code>A1(1) -&gt; A1'(user1), A2(1) -&gt; A2'(user1), A3(1) -&gt; A3'(user1)</code> -- now somebody changes user1 somewhere else in the app, so next emit is <code>A3'(user1')</code></p>
","1541188","","1541188","","2018-12-16 15:08:53","2018-12-16 20:12:56","Mapping of each emit -- SwitchMap guaranteeing atleast 1 emit / ConcatMap hybrid?","<rxjs><rx-java><reactive-programming><rx-swift><reactive>","1","5","","","","CC BY-SA 4.0"
"53811803","1","53815993","","2018-12-17 09:00:08","","0","587","<p>Coming from the RxJava background, I can not come up with a standard approach to implement sliding windows in RxSwift. E.g. I have the following sequence of events:</p>

<pre><code>1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, ...
</code></pre>

<p>Let's imagine event emission happens twice in a second. What I want to be able to do is to transform this sequence into a sequence of buffers, each buffer containing last three seconds of data. Plus, each buffer is to be emitted once in a second. So the result would look like that:</p>

<pre><code>[1,2,3,4,5,6], [3,4,5,6,7,8], [5,6,7,8,9,10], ...
</code></pre>

<p>What I would do in RxJava is I would use one of the overloads of the <code>buffer</code> method like so:</p>

<pre><code>stream.buffer(3000, 1000, TimeUnit.MILLISECONDS)
</code></pre>

<p>Which leads exactly to the result I need to accomplish: sequence of buffers, each buffer is emitted once in a second and contains last three seconds of data. </p>

<p>I checked RxSwift docs far and wide and I did not find any overloads of <code>buffer</code> operator which would allow me to do that. Am I missing some non-obvious (for RxJava user, ofc) operator?</p>
","885028","","885028","","2018-12-17 11:37:38","2018-12-18 12:55:05","Sliding windows in RxSwift","<ios><rx-swift><sliding-window>","1","2","1","","","CC BY-SA 4.0"
"53826963","1","","","2018-12-18 05:38:11","","0","932","<p>I am showing a <code>UITableView</code> which is driven by <a href=""https://github.com/RxSwiftCommunity/RxRealmDataSources"" rel=""nofollow noreferrer"">RxRealmDataSources</a>.</p>

<p>I need to perform some actions when a row in the table gets deleted.</p>

<p>Is there a way such that whenever a row gets deleted from the table, a function gets called with the indexpath of the deleted row?</p>

<p>Edit - </p>

<p>The UI of a cell of the <code>UITableView</code> in my app depends on 2 things -</p>

<ul>
<li>A data object that is fetched from the realm db ( <a href=""https://github.com/RxSwiftCommunity/RxRealmDataSources#binding-to-a-table-view"" rel=""nofollow noreferrer"">info</a> )</li>
<li>The index position of the row </li>
</ul>

<p>Whenever, a cell gets deleted, I need to update the UI of its next cell.</p>

<p>If the only way the db ever got updated was by the direct action of the user, then I could have used <a href=""https://developer.apple.com/documentation/uikit/uitableviewdatasource/1614871-tableview"" rel=""nofollow noreferrer""><code>func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath)</code></a> method to get the <code>indexPath</code> of the cell that should be deleted and update the UI of the next cell.</p>

<p>However, the db is synced to cloud and the db is binded to the table view so that I do not have control on when cells gets added or deleted. It is for this reason, I wanted to know if there is a way to know when a cell is removed from <code>UITableView</code></p>
","","user10461683","","user10461683","2018-12-18 17:03:18","2020-10-15 18:25:37","Is there a way to know when a UITableViewCell is removed from UITableView?","<ios><swift><uitableview><realm><rx-swift>","4","5","1","","","CC BY-SA 4.0"
"53833901","1","","","2018-12-18 13:17:33","","1","442","<p>I am using RxSwift and RxRealm and want to be able to observe changes of resources based on a predicate. The function would be like this</p>
<pre><code>func observe(type: String) -&gt; Observable&lt;[MyRealmObject]&gt; {
  let realm = configureRealm() // 1
  let predicate = NSPredicate(format: &quot;type = %@&quot;, type)
  let resources = realm
    .objects(MyRealmObject.self)
    .filter(predicate)
  return Observable.array(from: resources) // 2
}
</code></pre>
<p>However, Realm requires <code>// 2</code> to be run on a thread with a run loop AND <code>// 1</code> and <code>// 2</code> have to be called on the same thread.</p>
<p>I can't guarantee that the observe(type: String) function is already being called on a thread with run loop, so I probably have to switch to one within the function - but that way i wont be able to have a synchronous return value anymore.</p>
<p><strong>Any ideas on how to make sure realm observations are always guaranteed to be on a specific run loop?</strong></p>
<h1>Update: Using custom Thread with run-loop - but I'm still not satisfied</h1>
<p>I created a custom thread that has a run loop but getting the synchronous return value is just ugly - as you can see i used a DispatchGroup to synchronize and i'd really like to avoid that.</p>
<pre><code>func observe(type: String) -&gt; Observable&lt;[MyRealmObject]&gt; {
  let observableCalculation = {
    let realm = configureRealm() // 1
    let predicate = NSPredicate(format: &quot;type = %@&quot;, type)
    let resources = realm
      .objects(MyRealmObject.self)
      .filter(predicate)
    return Observable.array(from: resources) // 2
  }

  if Thread.current == self.realmObservationThread {
    return observableCalculation()
  }

  var o: Observable&lt;[MyRealmObject]&gt;!
  let g = DispatchGroup()
  g.enter()
  self.realmObservationThread.runloop?.perform {
    o = observableCalculation()
    g.leave()
  }
  g.wait()
  return o
}
</code></pre>
<p>Any suggestions would be appreciated!</p>
","2215126","","-1","","2020-06-20 09:12:55","2018-12-21 08:38:33","RxSwift Realm observe Array in RunLoop","<ios><swift><realm><grand-central-dispatch><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"53841004","1","53841104","","2018-12-18 21:02:25","","0","945","<p>I have the following ViewModel which I want to bind to the UITextField and UISegmentedControl. I was able to successfully bind to the UITextField but UISegmentedControl binding is not working since my recommend data type is an enum.  </p>

<pre><code>enum Recommend: Int  {
    case yes = 0
    case no = 1
}

struct FeedbackViewModel {

    var name = Variable&lt;String&gt;("""")
    var recommend = Variable&lt;Recommend&gt;(.yes) 

}
</code></pre>

<p>In my view controller I have the following bindings: </p>

<p>private func configureBindings() {</p>

<pre><code>self.nameTextField.rx.text
        .orEmpty
        .bind(to: self.feedbackViewModel.name)
        .disposed(by: disposeBag)

self.recommendSegmentedControl.rx.value
    .bind(to: self.feedbackViewModel.recommend.value.rawValue)
    .disposed(by: disposeBag)
</code></pre>

<p>}</p>

<p>For the recommendSegmentedControl bind I get the following error: </p>

<pre><code>Cannot invoke 'bind' with an argument list of type '(to: Int)'
</code></pre>
","810815","","","","","2018-12-18 21:10:03","RxSwift Binding to an Enum","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"53845811","1","","","2018-12-19 06:37:58","","0","248","<p>I am trying to create expand/ collapse tableView having multiple <code>labels</code>, <code>textViews</code> and <code>images</code>. The problem is when I expand a cell, the top most label (Black Text/ Blue background in image) disappears and then comes back when cell updates. Is there any proper solution to fix this type of problem? Is this related to <code>reloadRows</code>?</p>

<p><a href=""https://i.stack.imgur.com/LduKJ.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LduKJ.gif"" alt=""enter image description here""></a></p>

<pre><code>// ViewController Class:

private func bindTableView() {
    guard let tableView = self.planServicesTableView,
        let viewModel = self.viewModel else {
        return
    }

    tableView.estimatedRowHeight = 130
    tableView.rowHeight = UITableView.automaticDimension

    let dataSource =  RxTableViewSectionedReloadDataSource&lt;PlanServiceSection&gt;(configureCell:
    {(dataSource: TableViewSectionedDataSource&lt;PlanServiceSection&gt;,
        tableView: UITableView,
        indexPath: IndexPath,
        item: PlanServiceSection.Item) -&gt; UITableViewCell in

        let cell = tableView.dequeueReusableCell(withIdentifier: item.cellType.cellIdent, for: indexPath)

        if let planServiceCell = cell as? PlanServiceDescriptionTableViewCell {
            planServiceCell.setCollapsed(collapsed:(viewModel.cellIsExpanded(at: indexPath)) ? false : true)
            planServiceCell.configureCell(item: item)
            planServiceCell.upgradeTextView.sizeToFit()
            planServiceCell.featureDisclaimerTextView.sizeToFit()
        }

        if let disclaimerCell = cell as? PlanDisclaimerTableViewCell {
            disclaimerCell.setCollapsed(collapsed: (viewModel.cellIsExpanded(at: indexPath)) ? false : true)
            disclaimerCell.configureCell(item: item)
            disclaimerCell.disclaimerDescriptionTextView.sizeToFit()
        }

        return cell
    })

    viewModel.dataSource = dataSource
    tableView.tableFooterView = UIView()
    tableView.delegate = self

    viewModel.sections.bind(to: tableView.rx.items(dataSource: dataSource))
        .disposed(by: self.disposeBag)
}


func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {

    if let descriptionCell = tableView.cellForRow(at: indexPath) as? PlanServiceDescriptionTableViewCell {
        descriptionCell.setCollapsed(collapsed: shouldCollapseCell(indexPath: indexPath))
    }

    if let disclaimerCell = tableView.cellForRow(at: indexPath) as? PlanDisclaimerTableViewCell {
        disclaimerCell.setCollapsed(collapsed: shouldCollapseCell(indexPath: indexPath))
    }

    DispatchQueue.main.async {
        tableView.reloadRows(at: [indexPath], with: .automatic)
    }
}

private func shouldCollapseCell(indexPath: IndexPath) -&gt; Bool {
    if let isExpanded = viewModel?.cellIsExpanded(at: indexPath),
        isExpanded {
        self.viewModel?.removeExpandedIndexPath(indexPath)
        return true
    }

    self.viewModel?.addExpandedIndexPath(indexPath)
    return false
}

// TableViewCell Class:

func setCollapsed(collapsed: Bool) {
    self.toggleArrowImage.image = (collapsed ? expandImage : collapseImage)
    self.stackView.isHidden = collapsed
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/SZAmc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/SZAmc.png"" alt=""enter image description here""></a>
<a href=""https://i.stack.imgur.com/b4tz0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/b4tz0.png"" alt=""enter image description here""></a></p>
","3164770","","","","","2018-12-21 00:16:05","Labels in UITableViewCell Shifts/ Disappears while expanding the cell","<ios><swift><uitableview><swift4><rx-swift>","1","0","","","","CC BY-SA 4.0"
"53853555","1","53862212","","2018-12-19 14:41:27","","1","525","<p>I'm using RxSwift (RxCocoa) to populate my tableView cells</p>

<pre><code>viewModel.cellsDriver.drive(tableView.rx.items) { ... }
</code></pre>

<p>This way I have no access to tableView's dataSource's method</p>

<pre><code>func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -&gt; Bool
</code></pre>

<p>But I need to specify which rows are movable for </p>

<pre><code>tableView.rx.itemMoved
</code></pre>

<p>How can I restrict which rows should not be able to drag around? I would prefer avoid using RxDataSources</p>
","2235274","","","","","2018-12-20 04:10:20","RxSwift + canMoveRowAt","<swift><uitableview><rx-swift><rx-cocoa>","1","0","1","","","CC BY-SA 4.0"
"53863865","1","","","2018-12-20 07:03:01","","3","1614","<p>I'm working on iOS App that uses the IP Stack API for geolocation. I'd like to optimise the IP Stack Api usage by asking for external (public) IP address first and then re-use lat response for that IP if it hasn't changed.</p>

<p>So what I'm after is that I ask every time the <a href=""https://www.ipify.org"" rel=""nofollow noreferrer"">https://www.ipify.org</a> about external IP, then ask <a href=""https://ipstack.com"" rel=""nofollow noreferrer"">https://ipstack.com</a> with given IP address. If I ask the second time but IP doesn't changed then re-use last response (or actually cached dictionary with IP's as keys and responses as values).</p>

<p>I have a solution but I'm not happy with this cache property in my code. It is some state and some other part of code can mutate this. I was thinking about using some <code>scan()</code> operator in RxSwfit but I just can't figure out any new ideas.</p>

<pre><code>class ViewController: UIViewController {
    @IBOutlet var geoButton: UIButton!

    let disposeBag = DisposeBag()
    let API_KEY = ""my_private_API_KEY""

    let provider = PublicIPProvider()
    var cachedResponse: [String: Any] = [:] // &lt;-- THIS

    override func viewDidLoad() {
        super.viewDidLoad()
    }

    @IBAction func geoButtonTapped(_ sender: UIButton) {

        // my IP provider for ipify.org
        // .flatMap to ignore all nil values,
        // $0 - my structure to contains IP address as string
        let fetchedIP = provider.currentPublicIP()
            .timeout(3.0, scheduler: MainScheduler.instance)
            .flatMapLatest { Observable.from(optional: $0.ip) }
            .distinctUntilChanged()

        // excuse me my barbaric URL creation, it's just for demonstration
        let geoLocalization = fetchedIP
            .flatMapLatest { ip -&gt; Observable&lt;Any&gt; in
                // check if cache contains response for given IP address
                guard let lastResponse = self.cachedResponse[ip] else {
                    return URLSession.shared.rx.json(request: URLRequest(url: URL(string: ""http://api.ipstack.com/\(ip)?access_key=\(API_KEY)"")! ))
                        .do(onNext: { result in
                            // store cache as a ""side effect""
                            print(""My result 1: \(result)"")
                            self.cachedResponse[ip] = result
                        })
                }

                return Observable.just(lastResponse)
        }

        geoLocalization
            .subscribe(onNext: { result in
                print(""My result 2: \(result)"")
            })
            .disposed(by: disposeBag)
    }
}
</code></pre>

<p>Is it possible to achieve the same functionality but without <code>var cachedResponse: [String: Any] = [:]</code> property in my class?</p>
","10046426","","10046426","","2018-12-21 11:10:10","2018-12-21 11:10:10","RxSwift: How to create cache for last network response without creating class/struct property?","<ios><swift><caching><rx-swift><reactive>","2","0","","","","CC BY-SA 4.0"
"53867736","1","53881288","","2018-12-20 11:25:05","","0","521","<p>I'm new to RxSwift. I have a BackendProvider with handles the communication with my API. I want to have a config file sync so that I can retrieve some parameters dynamically. I have a fallback case with a local stored JSON file that I can to access in case my API is not reachable or my JSON parsing fails:</p>

<blockquote>
  <p><strong>ConfigFileBackendService</strong></p>
</blockquote>

<pre><code>open func getLatestConfig() -&gt; Observable&lt;ConfigFile?&gt; {            
        let urlString = IoC.urlProviderService.getConfigFileUrl()?.absoluteString ?? """"
        let configFileJSONData = IoC.backendCommunicationService.getJsonData(url: urlString)

        return configFileJSONData.map { data in
            if let configFile = try? JSONDecoder().decode(ConfigFile.self, from: data) {
                return configFile
            } else {
                return nil
            }
        }
    }
</code></pre>

<blockquote>
  <p><strong>ConfigFileProcessService</strong></p>
</blockquote>

<p>This is the one that falls back to the local stored file:</p>

<pre><code>func getConfigFile() -&gt; Observable&lt;ConfigFile&gt; {
        return IoC.configFileBackendService.getLatestConfig()
            .map { configFile in
                guard let configFile = configFile else { fatalError() }
                return configFile
            }
            .catchError { error in
                // Use default config
                let localURL = IoC.urlProviderService.getLocalConfigFileUrl()
                do {
                    let data = try Data(contentsOf: localURL)
                    let configFile = try JSONDecoder().decode(ConfigFile.self, from: data)
                    return Observable.just(configFile)
                } catch {
                    fatalError(""Error loading local config"")
                }
        }
    }
</code></pre>

<p>This approach works, but I'm having doubts with the <code>.map</code> / <code>.catchError</code> blocks. Is there a better way to handle the error case? Maybe should I go with, <code>onNext</code> and then <code>onError</code>? Thanks in advance!</p>
","4473187","","","","","2018-12-21 08:16:48","Parsing a JSON and handling error response from API in RxSwift","<ios><swift><rx-swift>","2","2","","","","CC BY-SA 4.0"
"53889567","1","53889843","","2018-12-21 18:57:15","","0","186","<p>How do you convert a string into an observable ? I have json that is returning as a string and I need to convert it into a Observable type and I make not sure how to do that. </p>
","9398617","","","","","2018-12-21 19:26:04","How do you convert a string into an Observable<Bool>?","<string><mvvm><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"53892522","1","53896469","","2018-12-22 02:07:59","","2","768","<p>I need to send http request in RxSwift &amp; Alamofire circumstance and send it synchronously which means ...</p>

<pre><code>send(1)...response(1)

-------------------- send(2)...response(2)

-----------------------------------------send(3)...response (3)
</code></pre>

<p>and This is my code</p>

<pre><code>            Observable.from(devicesArray)
            .concatMap { (device) in
                return HTTPRequest.deleteDevice(withDevice: device)
            }.subscribe({ (event) in
                log.debug(""Remove device successfully"")
            }).disposed(by: self.disposeBag)
</code></pre>

<p>and deleteDevice is</p>

<pre><code>func deleteDevice(withDevice device:Device) -&gt; Single&lt;String&gt; {

    return Alamofire.request(""http://example.com/\(device.deviceId)"", method: .delete, parameters: nil, headers: self.headers()).rx
        .responseJSON()
        .retry(self.retryMaxAttempCount)
        .asSingle()
        .observeOn(SerialDispatchQueueScheduler(qos: .default))
        .map({ (response) in
            guard let json = response.value as? [String: Any] else {
                throw HTTPManagerError.invalidResponse
            }

            guard let resultCode = json[""resultCode""] as? String else {
                throw HTTPManagerError.invalidResponse
            }

            if resultCode == ""0000"" || resultCode == ""0101"" {
                return resultCode
            } else {
                throw HTTPManagerError.invalidResponse
            }
        })
        .observeOn(MainScheduler.instance)
}
</code></pre>

<p>Now every single HTTPRequest.deleteDevice function requested in parallel. </p>

<p>So How could I make this request wait until a previous request get finished?</p>

<p>Thanks.</p>
","1122517","","","","","2018-12-22 14:26:30","RxSwift & alamofire, How to send http request after previous request arrived?","<alamofire><rx-swift>","1","0","","","","CC BY-SA 4.0"
"53909076","1","53916022","","2018-12-24 04:06:00","","0","137","<p>In rx code, .disposed get called without any doing job like flatmap, subscribe. This happens only when I build my app at first time.</p>

<p>Does anybody knows what happens here?</p>

<p>This is my code</p>

<pre><code>HTTP.getSomething()
        .flatMap { (list) -&gt; Single&lt;Void&gt; in

            return HTTP.getList(withList: list)
        }
        .subscribe(onSuccess: { (storeList) in
            log.debug(""Finish!!!"")
        }, onError: { [weak self] (error) in
            self?.presentAlert(error: error)
        })
        .disposed(by: self.disposeBag) 
</code></pre>
","1122517","","","","","2018-12-24 17:04:59","RxSwift, Sometimes .disposed get called without calling .subscribe","<dispose><rx-swift>","1","2","","","","CC BY-SA 4.0"
"53918032","1","","","2018-12-24 22:13:13","","0","56","<p>I have an app with 3 schemes : Debug, Beta and Release.</p>

<p>I have a TableView with multiple different table cell views, 3 of them are CollectionViews.</p>

<p>When building the Beta Scheme, the app works as expected s without any issues, rolling back to a different scheme (Debug) fails with this error :</p>

<blockquote>
  <p>thread 1: Assertion failed: This is a feature to warn you that there
  is already a delegate (or data source) set somewhere previously. The
  action you are trying to perform will clear that delegate (data
  source) and that means that some of your features that depend on that
  delegate (data source) being set will likely stop working. If you are
  ok with this, try to set delegate (data source) to <code>nil</code> in front of
  this operation.  This is the source object value: 
</blockquote>

<p>The error point to this part:</p>

<pre><code>func bindViewModel() {
       viewModel.transform().asDriver(onErrorJustReturn: [])
           .drive(self.collectionView.rx.items(cellIdentifier: reuseIdentifier, cellType: ProductImageItemCell.self)) { collectionView, viewModel, cell in
               cell.bind(to: viewModel)
           }.disposed(by: rx.disposeBag)

   } 
</code></pre>

<p>What is the issue behind this? Am I have a bad multiple target configuration done wrong? Thanks.</p>
","2187976","","","","","2018-12-24 22:22:39","App crashs on Debug scheme but works good on Beta scheme - multiple targets","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"53922565","1","53923744","","2018-12-25 12:53:57","","0","1118","<p>I have one observable (we will call it trigger) that can emit many times in a short period of time. When it emits I am doing a network Request and the I am storing the result with the scan Operator.</p>

<p>My problem is that I would like to wait until the request is finished to do it again. (But as it is now if trigger emits 2 observables it doesn't matter if fetchData has finished or not, it will do it again)</p>

<p>Bonus: I also would like to take only the first each X seconds (Debounce is not the solution because it can be emitting all the time and I want to get 1 each X seconds, it isn't throttle neither because if an observable emits 2 times really fast I will get the first and the second delayed X seconds)</p>

<p>The code:</p>

<pre><code>trigger.flatMap { [unowned self] _ in
        self.fetchData()
        }.scan([], accumulator: { lastValue, newValue in
        return lastValue + newValue
    })
</code></pre>

<p>and fetchData:</p>

<pre><code>func fetchData() -&gt; Observable&lt;[ReusableCellVMContainer]&gt;
</code></pre>

<p>trigger:</p>

<pre><code>let trigger = Observable.of(input.viewIsLoaded, handle(input.isNearBottomEdge)).merge() 
</code></pre>
","6594250","","","","","2018-12-25 20:12:16","RxSwift Skip Events Until Own Sequence has finished","<swift><rx-swift><reactivex>","1","0","","","","CC BY-SA 4.0"
"53944423","1","53945627","","2018-12-27 11:35:27","","0","684","<p>I have an observable (request from network) and dont want it to be disposed when I got an error</p>

<p>My custom error</p>

<pre><code>   enum MyError: Error {
        case notFound
        case unknown
    }
</code></pre>

<p>My network request using Moya</p>

<pre><code>let registerRequest = didTapJoinButton.withLatestFrom(text.asObservable())
            .flatMapLatest { text in
                provider.rx.request(API.register(text: text))
            }
            .flatMapLatest({ (response) -&gt; Observable&lt;Response&gt; in
                let statusCode = response.statusCode

                if statusCode.isSuccessStatus() {
                    return Observable.just(response)

                } else if statusCode.isNotFoundStatus() {
                    return Observable.error(MyError.notFound)

                } else {
                    return Observable.error(MyError.unknown)
                }
            })
            .materialize()
            .share(replay: 1)
</code></pre>

<p>Looks great. I use materialize() to prevent observable being disposed on error</p>

<p>Subscribe: (If status code 200)
Everything works just fine, I got response and the stream is not disposed</p>

<pre><code>   registerEventRequest.subscribe(onNext: { (next) in
            print(""NEXT: \(next)"")
        }, onError: { (error) in
            print(""ERRRRROR ME: \(error)"")
        }, onCompleted: {
            print(""Completed"")
        }) {
            print(""Disposed"")
        }
</code></pre>

<p>BUT if status code is something like 404. I got the error as I expected. However, hey look at the console log</p>

<pre><code>NEXT: error(notFound)
Completed
Disposed
</code></pre>

<p>It jumps to NEXT which I expected. But why it throw complete and dispose my sequence.</p>

<p>My question is Why did it dispose my sequence and how I can prevent this?</p>
","8737224","","","","","2018-12-28 12:46:46","Prevent Observabe.error complete and dispose swift","<swift><rx-swift><moya>","1","0","","","","CC BY-SA 4.0"
"53955398","1","53963577","","2018-12-28 08:04:12","","0","658","<p>I have to make a method which retry Observable while my condition is true. I pass condition in closure like this:</p>

<p>Observable.retrySource {$0 != 20}</p>

<p>My func have to work with generic parameters like map, flatMap...</p>

<p>extension ObservableType {</p>

<pre><code> func retrySource&lt;T: Error&gt;(closure: @escaping (T) -&gt; Bool) -&gt; Observable&lt;E&gt; {
    return retryWhen { (error: Observable&lt;T&gt;) in
        return error
            .flatMap { value -&gt; Observable&lt;Void&gt; in
                guard closure(value) else {
                    return .error(error as! Error)
                }

                return Observable.just(Void())
        }
    }
}
</code></pre>

<p>}
And, I don't have a idea, 
1) how check my condition?
2) how pass Observable in my closure into func?</p>

<p>My Observable: </p>

<pre><code>numberButton.rx.tap
            .flatMapLatest { return randomInt }
            .retrySource { $0 != 5 }
            .subscribe(onNext: { print($0) },
                       onError: { error in
                        print(error)
            }, onCompleted: {
                print(""finish"")
            })
            .disposed(by: disposeBag)

        }
</code></pre>
","10325152","","10325152","","2018-12-28 19:50:59","2018-12-28 21:40:48","Generic func with closure which pass Observable","<generics><closures><observable><rx-swift>","1","7","","","","CC BY-SA 4.0"
"53986616","1","53988062","","2018-12-31 10:55:14","","17","6632","<p>I'm new in RxSwift, I don't understand what is difference between <code>do(onNext:)</code> and <code>subscribe(onNext:)</code>.</p>

<p>I google it but did't found good resources to explain the difference.</p>
","8425034","","","","","2020-12-02 12:28:26","what is difference between do(onNext:) and subscribe(onNext:)?","<rx-swift>","2","0","3","","","CC BY-SA 4.0"
"53987750","1","53992613","","2018-12-31 12:52:03","","0","672","<p>I am trying to create sections for a tableview from an array of item on which each array item is a sections item. </p>

<blockquote>
  <p>My quesiton is how can I make <code>cart.map</code> return an array of<br>
  CartProductSection ([CartProductSection]) instead of assign it to a variable. Thanks.</p>
</blockquote>

<p>My code
    let cart: BehaviorRelay
 struct Output {
        let items: Observable&lt;[CartProductSection]>
    }</p>

<pre><code>           var sectionPerSupplierItems: [CartProductSection] = []

            _ = cart.map { (cart)  in 
                let cartItemsPerSupplier = self.sortModelItemPerSection(items: cart.items)

                print(cart.items.count)
                 _ = cartItemsPerSupplier.map {  (cartItemsPerSupplier) in

                    var items: [CartProductSectionItem] = []
                    for cartItem in cartItemsPerSupplier.cartItems {
                         items.append(CartProductSectionItem.cartItem(viewModel: CartItemViewModel(with: cartItem)))
                    }

                    sectionPerSupplierItems.append(CartProductSection.cartItemModel
(title: cartItemsPerSupplier.companyName, items: items))
                }
            }

            return Output(items: Observable.just(sectionPerSupplierItems))
</code></pre>
","2187976","","2187976","","2018-12-31 14:10:44","2019-01-01 02:03:23","multiple map with rxswift","<ios><swift><reactive-programming><rx-swift>","1","2","","","","CC BY-SA 4.0"
"54004860","1","54025029","","2019-01-02 10:40:37","","0","1909","<p>I need to decrease input value with every second, and print it. 
When value reaches 0, then it becomes 100, and decreasing process repeats, and again.</p>

<p><strong>For example:</strong></p>

<pre><code>Given value: 
-&gt; 234
Timer starts decreasing with every second
 -&gt; 233
 -&gt; 232 
...
 -&gt; 1
 -&gt; 0 and the whole process repeats,

but starts with value 100 
(and again decreasing, reaches 0, starting from 100)
</code></pre>

<p>I know how to use timer in Rx, but how to connect it with described case?</p>
","5601269","","9794079","","2019-01-02 10:47:45","2019-01-03 15:42:10","RxSwift emit starting value with time interval and modify it","<swift><timer><observable><rx-swift>","2","0","","","","CC BY-SA 4.0"
"54007149","1","54019267","","2019-01-02 13:21:43","","1","932","<p>I have a table view with RxDataSources on which cell items got a remove icon. when cells get dequeued and click on that remove icon, all the previous click events get triggered, thus duplicate tap.
Item cell : </p>

<pre><code> removeImageView.rx.tap().map { _ in indexPath } 
            .bind(to: viewModel.onRemoveItem).disposed(by: cellDisposeBag)
</code></pre>

<p>Cell viewmodel:</p>

<pre><code>let onRemoveItem = PublishSubject&lt;IndexPath&gt;()
</code></pre>

<p>View controller view model where the cell and ViewModel get bound:</p>

<pre><code> let vm = ItemViewModel(with: item)
            vm.onRemoveItem.bind(to: self.onRemoveItem).disposed(by: self.rx.disposeBag)

            return SectionItem.item(viewModel: vm)
</code></pre>

<p>View Controller:</p>

<pre><code>let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionItem&gt;(configureCell: { dataSource, tableView, indexPath, item in
    switch item {
    case .item(let viewModel):
        let cell = (tableView.dequeueReusableCell(withIdentifier: itemtIdentifier, for: indexPath) as? ItemCell)!
        cell.bind(to: viewModel, at: indexPath)
        return cell
    }
}, titleForHeaderInSection: { dataSource, index in
    let section = dataSource[index]
    return section.title
}  )

output?.items
    .bind(to: tableView.rx.items(dataSource: dataSource))
    .disposed(by: rx.disposeBag)

output?.onRemoveCartIemTapped.distinctUntilChanged() 
    .skip(1)
    .distinctUntilChanged().drive(onNext: { [weak self] (indexPath) in
    print(""onRemoveCartIemTapped"" + String(indexPath.item))
}).disposed(by: rx.disposeBag)
</code></pre>

<p>Console debug:</p>

<pre><code>onRemoveCartIemTapped0
onRemoveCartIemTapped3
onRemoveCartIemTapped1
onRemoveCartIemTapped4
</code></pre>
","2187976","","5175709","","2019-05-10 15:49:30","2019-05-10 15:50:18","How to avoid duplicate tap on button on Tableview with RxDataSources","<ios><swift><uitableview><rx-swift><rxdatasources>","1","4","","","","CC BY-SA 4.0"
"54027908","1","","","2019-01-03 18:33:16","","0","221","<p>This is my a simplified version of my code:</p>

<pre><code>var myObservable: Observable&lt;MyEnum&gt;

var modelObservable: Observable&lt;Model?&gt;

myObservable = myButton.rx.tap.asSignal()
 .asObservable()
 .flatMapLatest {
    getModel()
}.map { model in
    print(""this is called"")
    return model.prop == true ? MyEnum.first : MyEnum.second
}

 func getModel() -&gt; Observable&lt;Model?&gt; {
     if let model = self.model.value {           
         return Observable.just(model)               
     }
     createModel()
     return modelObservable
 }
  myObservable.subscribe(onNext: { (enum) in
         switch enum {
         case .first:
             self.presentFirst()
         case .second:
             self.presentSecond()
         }
     }).disposed(by: bag)
</code></pre>

<p>I was expecting this code to mean that whenever myButton is tapped, this code would run and print ""this is called"", however, ""this is called"" is printed also when myOtherObservable is triggered, even when myButton is not tapped. Why does this happen? This makes me think I don't understand Rx. Also, how would I make it behave so that it only runs when the myButton is tapped? </p>
","2066353","","2066353","","2019-01-04 02:32:26","2019-01-04 02:32:26","Understanding RxSwift Observable Chain","<swift><observable><reactive-programming><rx-swift>","0","21","","","","CC BY-SA 4.0"
"54030659","1","54032269","","2019-01-03 22:26:17","","0","181","<p>Evening, in my application I do not want to use RxCocoa and I'm trying to conforming to tableview data source and delegate but I'm having some issues.</p>

<p>I can't find any guide without using RxCocoa or RxDataSource.</p>

<p>In my ViewModel in have a <code>lazy computed var myData: Observable&lt;[MyData]&gt;</code> and I don't know how to get the number of rows.</p>

<p>I was thinking to convert the observable to a Bheaviour Subject and then get the value but I really don't know which is the best prating to do this</p>
","6747915","","6747915","","2019-01-03 22:40:34","2019-01-04 02:03:20","iOS Swift: TableView Data Source without using RxCocoa","<ios><swift><uitableview><datasource><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54034446","1","54034618","","2019-01-04 07:06:28","","3","595","<p>Is there a way to implement the <code>shouldChangeTextIn</code> <code>UITextView</code>'s delegate method in RxSwift way? My goal is to limit the text input of the user. I just have this:</p>

<pre><code>    self.textView.rx.text
        .orEmpty
        .scan("""") { (previous, new) -&gt; String in
            return new.count &gt; 254 ? previous : new
        }
        .bind(to: self.viewModel.notes)
        .disposed(by: self.disposeBag)
</code></pre>

<p>This is for data, but I don't know how to prevent the further input after 254 count.</p>

<p>I also found <code>RxTextViewDelegateProxy</code> but I'm not sure too how to use it.</p>

<pre><code>let rxTVDelegateProxy = RxTextViewDelegateProxy(textView: self.textView)
</code></pre>
","3231194","","","","","2019-08-22 18:39:40","How to implement shouldChangeTextIn the RxSwift way","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54037818","1","","","2019-01-04 11:09:32","","0","743","<p>I'm having trouble testing a BehaviorRelay. The following minimal code binds an observable to a BehaviorRelay, but when testing, the tests won't end and are hung - the observable keeps emitting events, because it starts with <code>Observable.timer</code>. When getting rid of the <code>bindRx</code> method and testing the observable only, it works without a problem. But I'd like to test the class properly - does that make sense?</p>

<p>How do I go about making this work?</p>

<pre><code>import XCTest
import RxSwift
import RxCocoa

struct TestObject: Codable {
    var a: Int?
    var b: Int?

    private enum CodingKeys: String, CodingKey {
        case a = ""test""
        case b
    }
}

extension TestObject: Equatable {
    static func == (lhs: TestObject, rhs: TestObject) -&gt; Bool {
        return lhs.a == rhs.a &amp;&amp; lhs.b == rhs.b
    }
}

class TestObjectFetcher {
    private let scheduler: SchedulerType
    private let disposeBag = DisposeBag()
    let testObject = BehaviorRelay&lt;TestObject?&gt;(value: nil)
    var syncInterval = 30.0

    init(scheduler: SchedulerType) {
        self.scheduler = scheduler
        self.bindRx()
    }

    var fetchTestObjectObservable: Observable&lt;TestObject?&gt; {
        return Observable&lt;Int&gt;.timer(0, period: self.syncInterval, scheduler: self.scheduler)
            .map { _ -&gt; TestObject? in
                TestObject(a: 1, b: 2)
            }
    }

    private func bindRx() {
        self.fetchTestObjectObservable
            .bind(to: self.testObject)
            .disposed(by: self.disposeBag)
    }
}

class TestObjectFetcherTests: XCTestCase {
    let testScheduler = TestScheduler(initialClock: 0)
    func testTestObjectFetcher() {

        let testObjectFetcher = TestObjectFetcher(scheduler: testScheduler)

        let events: [Recorded&lt;Event&lt;TestObject?&gt;&gt;] = [
            Recorded.next(1, TestObject(a: 1, b: 2)),
            Recorded.next(31, TestObject(a: 1, b: 2)),
            Recorded.next(61, TestObject(a: 1, b: 2))
        ]

        let res = testScheduler.start(created: 0, subscribed: 0, disposed: 90) { () -&gt; Observable&lt;TestObject?&gt; in
            return testObjectFetcher.testObject.asObservable()
        }

        XCTAssertEqual(res.events, events)
    }
}
</code></pre>
","414365","","","","","2019-01-05 22:56:42","Testing BehaviorSubject/Relay in RxSwift","<ios><swift><rx-swift><rxtest>","1","2","","","","CC BY-SA 4.0"
"54046919","1","54047902","","2019-01-04 22:18:34","","1","2655","<p>I am trying to understand how to implement MVVM with a list of objects and an UICollectionView. I am not understanding how to implement the User iteration -> Model flow.</p>

<p>I have setup a <a href=""https://github.com/rrodrigues/RxCollectionViewTester/blob/master/RxCollectionViewTester/ViewController.swift"" rel=""nofollow noreferrer"">test application</a>, the Model is just a class with an Int, and the View is an UICollectionViewCell which shows a text with the corresponding Int value and have plus, minus and delete buttons to increment, decrease and remove a element respectively.
Each entry looks like:
I would like to know the best way to use MVVM and RxSwift the update/remove a cell.</p>

<p>I have a list random generated Int values</p>

<pre><code>let items: [Model]
</code></pre>

<p>the Model which just have the Int value</p>

<pre><code>class Model {
    var number: Int

    init(_ n: Int = 0) {
        self.number = n
    }
}
</code></pre>

<p>The ViewModel class which just hold the Model and has an Observable</p>

<pre><code>class ViewModel {

    var value: Observable&lt;Model&gt;

    init(_ model: Model) {
        self.value = Observable.just(model)
    }
}
</code></pre>

<p>And the Cell</p>

<pre><code>class Cell : UICollectionViewCell {
    class var identifier: String { return ""\(self)"" }

    var bag = DisposeBag()

    let label: UILabel
    let plus: UIButton
    let minus: UIButton
    let delete: UIButton
....
    var viewModel: ViewModel? = nil {
        didSet {
        ....
            viewModel.value
                .map({ ""number is \($0.number)"" })
                .asDriver(onErrorJustReturn: """")
                .drive(self.label.rx.text)
                .disposed(by: self.bag)
        ....
        }
    }
}
</code></pre>

<p>What I don't understand clearly how to do is how to connect the buttons to the corresponding action, update the model and the view afterwards.</p>

<p>Is the Cell's ViewModel responsible for this? Should it be the one receiving the tap event, updating the Model and then the view?</p>

<p>In the remove case, the cell's delete button needs to remove the current Model from the data list. How can this be done without mixing everything all together?</p>
","4334526","","","","","2019-01-05 21:13:16","How edit/delete UICollectionView cells using MVVM and RxSwift","<ios><swift><mvvm><uicollectionview><rx-swift>","2","0","","","","CC BY-SA 4.0"
"54061931","1","","","2019-01-06 13:23:38","","0","867","<p>I use this in Kotlin to debounce based on condition:</p>

<pre><code>// variables
private val subject_isUpdating = PublishSubject.create&lt;Int&gt;()
var lastClickedItem = -1


// inside onCreate
adapter_cartProducts.setOnItemClickedListener { position -&gt;
     subject_isUpdating.onNext(position)
}


// subscribing 
        subject_isUpdating
            .debounce
            { position -&gt;
                // here if lastClickedItem changed, no debounce
                if(position != lastClickedItem) {
                    lastClickedItem = position
                    Observable.empty()
                }
                // else if same item clicked -&gt; debounce
                else Observable.timer(300, TimeUnit.MILLISECONDS) }
            .subscribe({ position -&gt;
                updateOnWS(position, adapter_cartProducts.items[position])
            }, { error -&gt;
                Timber.e(error) // printing the error
            })
</code></pre>

<p>This is the debounce selector function used from the RxJava:</p>

<pre><code>/**
 * Returns an Observable that mirrors the source ObservableSource, except that it drops items emitted by the
 * source ObservableSource that are followed by another item within a computed debounce duration.
 * &lt;p&gt;
 * &lt;img width=""640"" height=""425"" src=""https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.f.png"" alt=""""&gt;
 * &lt;dl&gt;
 *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
 *  &lt;dd&gt;This version of {@code debounce} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
 * &lt;/dl&gt;
 *
 * @param &lt;U&gt;
 *            the debounce value type (ignored)
 * @param debounceSelector
 *            function to retrieve a sequence that indicates the throttle duration for each item
 * @return an Observable that omits items emitted by the source ObservableSource that are followed by another item
 *         within a computed debounce duration
 * @see &lt;a href=""http://reactivex.io/documentation/operators/debounce.html""&gt;ReactiveX operators documentation: Debounce&lt;/a&gt;
 */
public final &lt;U&gt; Observable&lt;T&gt; debounce(Function&lt;? super T, ? extends ObservableSource&lt;U&gt;&gt; debounceSelector) {
    ObjectHelper.requireNonNull(debounceSelector, ""debounceSelector is null"");
    return RxJavaPlugins.onAssembly(new ObservableDebounce&lt;T, U&gt;(this, debounceSelector));
}
</code></pre>

<p>The idea of this code, user will click on item of list, and the item will be updated on webservice when user stops clicking for 400ms or clicks another item</p>

<p>Is that possible to be done in RxSwift ?</p>
","2296787","","2296787","","2019-01-06 20:10:09","2019-01-06 20:10:09","Debounce rx observable based on condition - RxSwift","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54077522","1","54077749","","2019-01-07 15:48:25","","0","476","<p>I have a tableview that looks something like this:</p>

<pre><code>data
    .drive(tableView.rx.items(cellIdentifier: ""cell"")) { index, model, cell in
        // update cell
    }
    .disposed(by: disposeBag)
</code></pre>

<p>When a user selects a cell and then the data changes rx-swift will reload the table view and the selection is lost.</p>

<p>I do have a reference to the selected indexPath but what is a nice way to set the selection?</p>

<p>For now my only idea would be something like this:</p>

<pre><code>data
    .delay(0.2) // make shure this happens after the reload
    .drive(onNext: { model in
        // select tableview cell
    })
</code></pre>

<p>Which obviously sucks :-(</p>

<p>Will <a href=""https://github.com/RxSwiftCommunity/RxDataSources"" rel=""nofollow noreferrer"">RxDataSources</a> solve this problem? If yes how?</p>

<p>Or are there any other ways to keep this selection?</p>
","3181404","","","","","2019-01-07 16:01:51","Keep selection in UITableView after rx-swift reloads the table","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54088191","1","54088289","","2019-01-08 08:51:13","","-1","143","<p>I need to request to some API, to get: user data, user following, user follower. They are 3 different APIs. I need to call them every 1 minute. I put this part of code in my app <em>delegate</em> and I don't have any problem with it. but I need to refresh the <code>ViewController</code> the user is already in it, whenever new information got from server. I need something like <em>RXSwift</em> to subscribe for new data and update the view whenever new data is available. But I don't know how to do it.because my API call is in app <em>delegate</em> and user can be in any <code>ViewController</code>.</p>
","2622287","","2915020","","2019-01-08 11:29:33","2019-01-09 05:57:36","Swift, How can I share API result in all over my app?","<ios><swift><rx-swift>","3","0","1","","","CC BY-SA 4.0"
"54107540","1","54107581","","2019-01-09 10:04:16","","3","856","<p>I created a new project and used pods to install <code>RxSwift</code>. Then I created a playground and wrote following code :  </p>

<pre><code>import UIKit
import RxSwift
import PlaygroundSupport

var name = ""hello""
let names = Variable([""Good""])  
</code></pre>

<p>But Console shows this error :  </p>

<blockquote>
  <p>Playground execution failed:</p>
  
  <p>error: Couldn't lookup symbols:   __T07RxSwift8VariableCACyxGxcfC<br>
  __T07RxSwift8VariableCMa</p>
</blockquote>
","541786","","4667835","","2019-01-09 10:30:02","2019-01-09 10:47:00","RxSwift - Playground execution failed: Couldn't lookup symbols","<ios><swift><cocoapods><rx-swift><swift-playground>","1","0","","","","CC BY-SA 4.0"
"54112395","1","54121297","","2019-01-09 14:30:29","","2","1714","<p>The case is following. 
I have a Single that I receive from a third-party API.
I want to transform this single to Observable, but the issue is Single transformed to Observable still completes my observable chain after emitting a value which I don't want to happen. I want that my observable never completes.</p>

<p>The question is is there any way easier than 'single.flatMap{ Observable.just($0)}' to do what I want?</p>
","928104","","","","","2019-01-10 02:46:37","How to convert RxSwift's Single to Observable and ignore `complete` event?","<swift><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54114068","1","54121413","","2019-01-09 16:06:15","","0","197","<p>Hello I am trying to do a project with RxSwift and I am stuck trying to do in a properly way the connection between the Coordinator and the ViewModel.</p>

<p><strong>Goal</strong> </p>

<p>Using observables, the <strong>Coordinator</strong> receives and <strong>event</strong> (in that case, when a row has been tapped) then <em>does whatever</em>.</p>

<p><strong>Scenario</strong></p>

<p>Giving a <strong>Post</strong> (String)</p>

<pre><code>typealias Post = String
</code></pre>

<p>I have the following <strong>Coordinator</strong>:</p>

<pre><code>class Coordinator {

    func start() {

        let selectedPostObservable = PublishSubject&lt;Post&gt;()

        let viewController = ViewController()
        let viewModel = ViewModel()
        viewController.viewModel = viewModel

        selectedPostObservable.subscribe { post in
            //Do whatever
        }
    }
}
</code></pre>

<p>The <strong>selectedPostObservable</strong> is what I don't know how to connect it in a ""clean"" way with the viewModel.</p>

<p>As <strong>ViewModel</strong>:</p>

<pre><code>class ViewModel {

    struct Input {
        let selectedIndexPath: Observable&lt;IndexPath&gt;
    }

    struct Output { 
        //UI Outputs
    }

    func transform(input: Input) -&gt; Output {
        let posts: [Post] = Observable.just([""1"", ""2"", ""3""])

        //Connect with selectedindex
        let result = input.selectedIndexPath
            .withLatestFrom(posts) { $1[$0.row] }
            .asDriver(onErrorJustReturn: nil)

        return Output()
    }
}
</code></pre>

<p>The <strong>result</strong> variable is what I should connect with  <strong>selectedPostObservable</strong>.</p>

<p>And the <strong>ViewController</strong> (although I think is not relevant for the question):</p>

<pre><code>class ViewController: UIViewController {

    //...
    var viewModel: ViewModel!
    var tableView: UITableView!
    //...

    func bindViewModel() {
        let input = ViewModel.Input(selectedIndexPath: tableView.rx.itemSelected.asObservable())
        viewModel.transform(input: input)
    }
}
</code></pre>

<p>Thank you so much.</p>
","5288983","","","","","2019-01-10 11:32:04","How to handle navigation with observables using Rx-MVVM-C","<swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"54119888","1","","","2019-01-09 23:22:30","","0","785","<p>I’m trying to schedule a series of downloads of images. I want to call <code>scheduleImagesDownload</code> as many times as I want, but wait to perform the code inside <code>downloadImages</code> only when the previous call is completed.</p>

<p>I’m trying to fetch and download images from camera for a specific ID, once all images are downloaded for that ID, I want to start downloading images for next ID, and so on.</p>

<p>I’m having a hard time because, even using a Serial Scheduler, all the subscriptions are called right away, before the previous download is completed. I was wondering if there’s a way to do this with pure Rx, without having to use semaphores, etc.</p>

<p>Thank you in advance!</p>

<pre><code>
    func scheduleImagesDownload(flightId: String) -&gt; Disposable {
        let subscription = donwloadImages(flightId)
            .subscribeOn(SerialDispatchQueueScheduler(qos: .background))
            .subscribe(onCompleted: {
                /// Finished downloading images for flight.
            }, onError: { error in
                /// Error downloading images for flight.
            })

        return subscription
    }

    func donwloadImages(_ flightId: String) -&gt; Completable {
        return Completable.create { completable in

            /// Simulate querying the drone for images to download async and start downloading them.
            DispatchQueue.global().async {
                sleep(5) // Sleep to simulate downloading time.
                completable(.completed) // Finished downloading.
            }
            return Disposables.create()
        }
    }

</code></pre>
","5647921","","","","","2019-01-10 10:22:03","Scheduling subscriptions in RxSwift","<ios><swift><xcode><rx-swift>","2","2","","","","CC BY-SA 4.0"
"54130564","1","","","2019-01-10 14:13:40","","0","638","<p>I'm trying to write a method on UIView extension, which will observe long press on a given view. I know it can be done using <code>UILongPressGestureRecognizer</code>, but I really want to figure out the question and do it this way.</p>

<p>I tried to use takeUntil operator, but it completes an observable, but I need to skip the value and receive further events.</p>

<p>The question can be also transformed to: <em>How to omit <code>completed</code> event and keep receiving further events?</em></p>

<pre><code>func observeLongPress(with minimumPressDuration: Double = 1) -&gt; 
  Observable&lt;Void&gt; {

    let touchesBeganEvent = rx.methodInvoked(#selector(touchesBegan))
    let touchesEndedEvents = [#selector(touchesEnded), #selector(touchesCancelled)]
        .map(rx.methodInvoked)
    let touchesEndedEvent = Observable.merge(touchesEndedEvents)
    return touchesBeganEvent
        .observeOn(MainScheduler.instance)
        .delay(minimumPressDuration, scheduler: MainScheduler.instance)
        .takeUntil(touchesEndedEvent)
        .map { _ in }
}
</code></pre>

<p>This will work, but will complete the whole sequence (as it intended to do).</p>

<p>The answer if floating around (as it always do), but after a few hours I decided to ask. :)</p>

<h2>Update</h2>

<p>The floating answer just flew inside (~15 mins for doing so), but I'm still interested in answer, because maybe there's something that I'm missing here.</p>

<pre><code>
    func observeLongPress(with minimumPressDuration: Double = 1) -&gt; Observable&lt;Void&gt; {
          let touchesBeganEvent = rx.methodInvoked(#selector(touchesBegan))
          let touchesEndedEvents = [#selector(touchesEnded), #selector(touchesCancelled)]
            .map(rx.methodInvoked)
          let touchesEndedEvent = Observable.merge(touchesEndedEvents)

          return touchesBeganEvent
            .observeOn(MainScheduler.instance)
            .flatMapLatest { _ -&gt; Observable&lt;Void&gt; in
              return Observable.just(())
                .delay(minimumPressDuration, scheduler: MainScheduler.instance)
                .takeUntil(touchesEndedEvent)
                .void()
          }
    }

</code></pre>
","4354002","","4354002","","2019-01-10 15:14:54","2019-01-11 01:23:48","Skip an event from source observable if a new event from a given observable was received in a given time interval","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54156384","1","","","2019-01-12 02:50:06","","4","2728","<p>I am using pattern <code>MVVM+Coordinator</code>. Every my controllers are created by <code>coordinators</code>. But what is the correct way to stop my coordinators when tapping on back button of <code>Navigation</code> Controller?</p>

<pre class=""lang-swift prettyprint-override""><code>class InStoreMainCoordinator: NavigationCoordinatorType, HasDisposeBag {

    let container: Container

    enum InStoreMainChildCoordinator: String {
        case menu = ""Menu""
        case locations = ""Locations""
    }

    var navigationController: UINavigationController
    var childCoordinators = [String: CoordinatorType]()

    init(navigationController: UINavigationController, container: Container) {
        self.navigationController = navigationController
        self.container = container
    }

    func start() {
        let inStoreMainViewModel = InStoreMainViewModel()
        let inStoreMainController = InStoreMainController()
        inStoreMainController.viewModel = inStoreMainViewModel

        navigationController.pushViewController(inStoreMainController, animated: true)
    }
}
</code></pre>
","6223191","","1503502","","2019-03-21 02:24:58","2021-07-03 13:10:21","iOS Swift Coordinator pattern and back button of Navigation Controller","<ios><swift><mvvm><rx-swift><coordinator-pattern>","5","1","","","","CC BY-SA 4.0"
"54156895","1","","","2019-01-12 04:58:35","","2","319","<p>I am using Google <code>Firestore</code> and <code>MVVM</code> pattern. As I know it is a good practice to avoid using singleton because of testing problems. But how should I work with <code>Firestore</code> correctly without it? </p>

<p>I am afraid that every time I create service instance in my View Model than new subscription to <code>Firestore</code> will be created. Also in case of <code>MVVM</code>, where is correct place to subscribe and unsubscribe to <code>Firestore</code> <code>database</code>? Should it happen in <code>ViewModel</code> or some service should handle this?</p>
","6223191","","8527224","","2019-01-12 06:58:05","2019-01-12 07:08:02","iOS Swift Firestore and how avoid singleton","<ios><swift><mvvm><google-cloud-firestore><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54163088","1","54163375","","2019-01-12 19:21:40","","1","1896","<p>I'm new to RxSwift and attempting to do as the title states with an MVVM input output approach. </p>

<p>I can't figure out the best approach to do the following.</p>

<ol>
<li>Validate the phoneNumberTextField values when submitButton is tapped</li>
<li>Stop the Alamofire Request from being submitted if phoneNumberTextField is invalid and throw a client side error</li>
<li>Show a display indicator when loading takes place. This is the least important right now</li>
</ol>

<p>A few things to note.</p>

<ul>
<li>There is nothing tracking the phone number text at the moment</li>
<li>I do not want to disable the submit button until the form is valid as seen in examples all over.</li>
</ul>

<p>Here is my view controller</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class SplashViewController: BaseViewController {

    // MARK: – View Variables

    @IBOutlet weak var phoneNumberTextField: UITextField!
    @IBOutlet weak var phoneNumberBackgroundView: UIView!
    @IBOutlet weak var submitButton: BaseButton!
    @IBOutlet weak var scrollView: UIScrollView!
    @IBOutlet weak var separatorView: UIView!
    @IBOutlet weak var countryCodeButton: UIButton!
    @IBOutlet weak var parentVerticalStackView: UIStackView!

    // MARK: – View Model &amp; RxSwift Setup

    private let disposeBag = DisposeBag()
    private let viewModel: SplashMVVM = SplashMVVM()

    // MARK: – View lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()

        // RxSwift handling
        setupViewModelBinding()
        setupCallbacks()

    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        navigationController?.setNavigationBarHidden(true, animated: true)
    }

    // MARK: – RxSwift Handling

    private func setupViewModelBinding() {

        submitButton.rx.controlEvent(.touchUpInside)
            .bind(to: viewModel.input.submit)
            .disposed(by: disposeBag)

    }

    private func setupCallbacks() {

        viewModel.output.success.asObservable()
            .filter { $0 != nil }
            .observeOn(MainScheduler())
            .subscribe({ _ in
                self.pushVerifyPhoneNumberViewController()
            })
            .disposed(by: disposeBag)

        viewModel.output.error.asObservable()
            .filter { $0 != nil }
            .observeOn(MainScheduler())
            .subscribe({ _ in
                SwiftMessages.show(.error, message: ""There was an error. Please try again."")
            })
            .disposed(by: disposeBag)

    }

    // MARK: – Navigation

    func pushVerifyPhoneNumberViewController() {

        let viewController = VerifyPhoneNumberViewController.fromStoryboard(""Authentication"")

        self.navigationController?.pushViewController(viewController, animated: true)

    }

}
</code></pre>

<p>Here is my view model.</p>

<pre><code>import Foundation
import RxSwift
import RxCocoa
import Alamofire

final class SplashMVVM: InputOutputModelType {


let input: SplashMVVM.Input
let output: SplashMVVM.Output

var submitSubject = PublishSubject&lt;Void&gt;()

struct Input {
    let submit: AnyObserver&lt;Void&gt;
}

struct Output {
    let success: Observable&lt;VerifyMobilePhone?&gt;
    let error: Observable&lt;Error?&gt;
}    

init() {

    input = Input(submit: submitSubject.asObserver())

    let request = Alamofire.request(VerifyMobileRouter.post(""+16306996540"")).responseDecodableRx(VerifyMobilePhone.self)

    let requestData = submitSubject.flatMapLatest {
        request
    }

    let success = requestData.map { $0.value ?? nil }

    let error = requestData.map { $0.error ?? nil }

    output = Output(
        success: success,
        error: error
    )

}
</code></pre>

<p>}</p>

<p>Here is what I came up with.</p>

<pre><code>final class SplashMVVM: InputOutputModelType {

let input: SplashMVVM.Input
let output: SplashMVVM.Output

var submitSubject = PublishSubject&lt;Void&gt;()
var phoneNumberSubject = PublishSubject&lt;String&gt;()

struct Input {
    let phoneNumber: AnyObserver&lt;String&gt;
    let submit: AnyObserver&lt;Void&gt;
}

struct Output {
    let validationError: Observable&lt;String&gt;
    let success: Observable&lt;VerifyMobilePhone&gt;
    let error: Observable&lt;Error&gt;
}

init() {

    input = Input(phoneNumber: phoneNumberSubject.asObserver(), submit: submitSubject.asObserver())

    let request = submitSubject.asObservable().withLatestFrom(phoneNumberSubject.asObservable()).filter {
        $0.isValidPhoneNumber(region: ""US"")
    }.flatMap { number in
        Alamofire.request(VerifyMobileRouter.post(number)).responseDecodableRx(VerifyMobilePhone.self)
    }.share()

    let validationError = submitSubject.asObservable().withLatestFrom(phoneNumberSubject.asObservable()).filter {
        !$0.isValidPhoneNumber(region: ""US"")
    }.map { _ in
        ""This phone number is invalid""
    }

    let success = request.filter { $0.isSuccess }.map { $0.value! }

    let error = request.filter { $0.isFailure }.map { $0.error! }

    output = Output(
        validationError: validationError,
        success: success,
        error: error
    )

}
</code></pre>

<p>}</p>

<p>View controller changes…</p>

<pre><code>   private func setupViewModelBinding() {
        submitButton.rx.controlEvent(.touchUpInside).bind(to: viewModel.input.submit).disposed(by: disposeBag)
        phoneNumberTextField.rx.text.orEmpty.bind(to: viewModel.input.phoneNumber).disposed(by: disposeBag)
    }

    private func setupCallbacks() {

        viewModel.output.validationError.bind { string in
            SwiftMessages.show(.error, message: string)
        }.disposed(by: disposeBag)

        viewModel.output.success.bind { verifyMobilePhone in
            self.pushVerifyPhoneNumberViewController()
        }.disposed(by: disposeBag)

        viewModel.output.error.bind { error in
            SwiftMessages.show(.error, message: ""There was an error. Please try again."")
        }.disposed(by: disposeBag)

    }
</code></pre>
","311686","","311686","","2019-01-12 23:53:57","2019-01-12 23:53:57","RxSwift MVVM Validate Form on Button Submit then Make API Request","<ios><swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"54165009","1","54182367","","2019-01-13 00:05:37","","0","1273","<p>I am starting out with unit testing <code>RxSwift Driver</code>. And I am having issues testing a <code>Driver</code>. </p>

<p>This is the code structure of my <code>ViewModel</code>:</p>

<pre><code>import Foundation
import RxSwift
import RxCocoa

class LoginViewViewModel {

    private let loginService: LoginService

    private let _loading = BehaviorRelay&lt;Bool&gt;(value: false)
    private let _loginResponse = BehaviorRelay&lt;LoginResponse?&gt;(value: nil)
    private let _phoneMessage = BehaviorRelay&lt;String&gt;(value: """")
    private let _pinMessage = BehaviorRelay&lt;String&gt;(value: """")
    private let _enableButton = BehaviorRelay&lt;Bool&gt;(value: false)

    var loginResponse: Driver&lt;LoginResponse?&gt; { return _loginResponse.asDriver() }
    var loading: Driver&lt;Bool&gt; { return _loading.asDriver() }
    var phoneMessage: Driver&lt;String&gt; { return _phoneMessage.asDriver() }
    var pinMessage: Driver&lt;String&gt; { return _pinMessage.asDriver() }
    var enableButton: Driver&lt;Bool&gt; { return _enableButton.asDriver() }

    private let phone = BehaviorRelay&lt;String&gt;(value: """")
    private let pin = BehaviorRelay&lt;String&gt;(value: """")

    private let disposeBag = DisposeBag()

    init(phone: Driver&lt;String&gt;, pin: Driver&lt;String&gt;, buttonTapped: Driver&lt;Void&gt;, loginService: LoginService) {
        self.loginService = loginService
        phone
            .throttle(0.5)
            .distinctUntilChanged()
            .drive(onNext: { [weak self] (phone) in
                self?.phone.accept(phone)
                self?.validateFields()
            }).disposed(by: disposeBag)

        pin
            .throttle(0.5)
            .distinctUntilChanged()
            .drive(onNext: { [weak self] (pin) in
                self?.pin.accept(pin)
                self?.validateFields()
            }).disposed(by: disposeBag)

        buttonTapped
            .drive(onNext: { [weak self] () in
                self?.loginUser(phone: self!.phone.value, pin: self!.pin.value)
            }).disposed(by: disposeBag)
    }

    private func validateFields() {
        guard phone.value.count &gt; 0 else {
            return
        }
        _enableButton.accept(false)

        guard pin.value.count &gt; 0 else {
            return
        }

        _enableButton.accept(true)
        _phoneMessage.accept("""")
        _pinMessage.accept("""")
    }

    private func loginUser(phone: String, pin: String) {
        _loading.accept(true)
        _phoneMessage.accept("""")
        _pinMessage.accept("""")

        loginService.loginUser(phone: phone, pin: pin) { [weak self] (response, error) in
            self?._loading.accept(false)
            if let error = error {
                if error.message! == ""Invalid credentials"" {
                    self?._phoneMessage.accept(""Invalid Phone Number"")
                    self?._pinMessage.accept(""Invalid Pin Provided"")
                }
            } else {
                response?.saveUserInfo()
                self?._loginResponse.accept(response)
            }
        }
    }
}
</code></pre>

<p>And my UnitTest looks like this:</p>

<pre><code>class LoginViewViewModelTest: XCTestCase {

    private class MockLoginService: LoginService {
        func loginUser(phone: String, pin: String, completion: @escaping LoginService.LoginDataCompletion) {
            guard phone == ""+17045674568"", pin == ""1234"" else {
                let loginresponse = LoginResponse(message: ""Login Successfully"", status: true, status_code: 200, data: LoginData(access_token: ""adadksdewffjfwe"", token_type: ""bearer"", expires_in: 3600, expiry_time: ""today"", user: User(id: ""1dsldsdsjkj"", name: ""RandomGuy"", phone: ""12345"", pin_set: true, custom_email: false, email: ""somerandom@email.com"")))
                completion(loginresponse, nil)
                return
            }
            let akuError = AKUError(status: false, message: ""Invalid Credential."", status_code: ""404"")
            completion(nil, akuError)
        }
    }

    var viewModel: LoginViewViewModel!

    var scheduler: SchedulerType!

    var phone: BehaviorRelay&lt;String&gt;!
    var pin: BehaviorRelay&lt;String&gt;!
    var buttonClicked: BehaviorRelay&lt;Void&gt;!

    override func setUp() {
        super.setUp()

        phone = BehaviorRelay&lt;String&gt;(value: """")
        pin = BehaviorRelay&lt;String&gt;(value: """")
        buttonClicked = BehaviorRelay&lt;Void&gt;(value: ())

        let loginService = MockLoginService()

        viewModel = LoginViewViewModel(phone: phone.asDriver(), pin: pin.asDriver(), buttonTapped: buttonClicked.asDriver(), loginService: loginService)

        scheduler = ConcurrentDispatchQueueScheduler(qos: .default)
    }

    override func tearDown() {
        super.tearDown()
    }

    func testLoginButtonClicked_Loading() {
        let loadingObservable = viewModel.loading.asObservable().subscribeOn(scheduler)

        phone.accept(""12345"")
        pin.accept(""12345"")
        buttonClicked.accept(())

        let loadingState = try! loadingObservable.skip(0).toBlocking().first()!
        XCTAssertNotNil(loadingState)
        XCTAssertEqual(loadingState, true)
    }
}
</code></pre>

<p><strong>My question:</strong></p>

<p>I am trying to track the state of the <code>loading</code> driver variable. But, it's always <code>false</code>. Even after writing a debugger for checking the states, it only prints out one value and, it's always <code>false</code>.</p>

<p>I decided to add a break point to the code, and I noticed 
<code>let loadingState = try! loadingObservable.skip(0).toBlocking().first()!</code> only gets called once the function is done executing.</p>

<p>Is there a way to test for the <code>loading</code> state?
Is it necessary to test for the <code>loading</code> state?</p>

<p>Thanks.</p>
","10906315","","10906315","","2019-01-14 03:56:25","2019-01-14 20:56:15","How to unit test RxCocoa BehaviorRelay","<ios><xctest><rx-swift><rx-cocoa>","1","6","","","","CC BY-SA 4.0"
"54198557","1","54200822","","2019-01-15 12:09:42","","1","1401","<p>I am trying to have notifications when a button changes his 'isSelected' state.
I have an UIButton setup with a target to change his <code>isSelected</code>:</p>

<pre><code>let button = UIButton()
button.addTarget(button, action: #selector(toggleSelected), for: .touchUpInside)
....
@objc func toggleSelected() {
    self.isSelected = !self.isSelected
}
</code></pre>

<p>and I want to have something like <code>button.rx.isSelectedChanged</code> to be able to subscribe events.</p>

<p>I tried to extend UIButton.rx with a ControlProperty:</p>

<pre><code>extension Reactive where Base: UIButton {

    public var isSelectedChanged: ControlProperty&lt;Bool&gt; {
        return base.rx.controlProperty(
            editingEvents:  [.allEditingEvents, .valueChanged],
            getter: { $0.isSelected },
            setter: { $0.isSelected = $1 })
    }

}
</code></pre>

<p>and something like:</p>

<pre><code>button.rx.observe(Bool.self, ""isSelected"")
    .takeUntil(button.rx.deallocated)
    .subscribe(onNext: { print(""selcted \($0)"") })
</code></pre>

<p>but in neither way I have button.isSelected updates.</p>

<p>What is a good way of doing this?</p>

<p>EDIT:
Following @daniel-t reply I implemented it <a href=""https://github.com/rrodrigues/RxCollectionViewTester/commit/4e31dd9d21dd043e548e8360ecad110fd02a3720"" rel=""nofollow noreferrer"">here</a>.</p>
","4334526","","4334526","","2019-01-15 23:29:26","2019-01-15 23:29:26","How can I subscribe to UIButton isSelected changes using RxSwift?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54206556","1","54212320","","2019-01-15 20:46:23","","1","1073","<p>So, i have this login function, where i want to return a Boolean to my .xib controller, where it has to make some modifications, according to the success of the login.</p>

<pre><code> func login(cpf: String) -&gt; Bool {
    let url = URL(string: AccessibilityDataAccessProvider.kLoginURL)
    let params = [""username"": String.init(describing: cpf)]

    var success = false

    dataAccessProvider.postSimpleResponse(url: url!, params: params)
        .subscribe(onNext: { (userToken) in
            let userData = UserDefaults.standard
            userData.set(userToken, forKey: AccessibilityDataAccessProvider.userTokenKey)
            userData.synchronize()
            success = true
    }, onError: { (error) in
        print(""Login Error: \(error)"")
    }).disposed(by: disposeBag)

    return success
}
</code></pre>

<p>The return from <em>postSimpleResponse()</em> method is an <em>Observable</em> of type <em>Any?</em>.</p>

<p>The thing is, that my <em>login()</em> method is returning before the <em>success</em> boolean variable is set true in the subscribe.</p>

<p>How could i resolve this ?</p>
","2705512","","7568116","","2019-01-16 08:59:46","2021-04-22 12:25:09","How to Synchronize or make an Observable wait on Swift?","<swift><observable><rx-swift><reactive-cocoa>","2","2","","","","CC BY-SA 4.0"
"54213183","1","54215871","","2019-01-16 08:44:28","","3","3267","<p>I have a layered architectured application where I am getting array of objects in ViewModel and binding it with tableview in ViewController. Following is my code:
ViewModel:</p>

<pre><code>func getManufacturerList() -&gt; Single&lt;[ManufacturerItem]&gt; {
    return self.fetchManufacturerInteractor.getManufacturerList()
        .map { $0.map { ManufacturerItem(
            manufacturerName: $0.manufacturerName,
            manufacturerID: $0.manufacturerID) } }
}
</code></pre>

<p>Above function receives array of objects from some other layer which again gets it from NetworkLayer.<br>
ViewController:</p>

<pre><code>private func setUpViewBinding() {
    manufacturerViewModel.getManufacturerList()
        .asObservable()
        .bind(to: tableView.rx.items(cellIdentifier: LanguageSelectionTableViewCell.Identifier,
                                     cellType: LanguageSelectionTableViewCell.self)) { row, manufacturer, cell in
            cell.textLabel?.text = manufacturer.manufacturerName
            cell.textLabel?.font = AppFonts.appBoldFont(size: 16).value
            cell.accessibilityIdentifier = ""rowLanguage\(row+1)""
            cell.textLabel?.accessibilityIdentifier = tblCellLabelAccessibilityIdentifier
    }.disposed(by: self.disposeBag)
}
</code></pre>

<p>Now where should I add the code for showing/hiding the activity indicator?</p>
","260056","","","","","2019-01-16 12:33:55","Display activity indicator with RxSwift and MVVM","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54227434","1","","","2019-01-17 00:35:34","","0","1704","<p>I use some <code>BehaviourRelay</code> for some variable. And I use <code>withLatestFrom</code> for one of them. But <code>withLatestFrom</code> didn't return the latest value I bind to it.</p>

<p>If I use <code>combineLatest</code>. It works but I want to know why the code with <code>withLatestFrom</code> not work</p>

<pre><code>let dueDate = BehaviorRelay&lt;Date?&gt;(value: nil)
let numberScheduleDays = BehaviorRelay&lt;Int&gt;(value: 1)
let selectedPaymentDate = BehaviorRelay&lt;Date?&gt;(value: nil)

dueDate.asObservable()
    .distinctUntilChanged()
    .flatMap { Observable.from(optional: $0) }
    .map { self.addDaysForDate(days: 1, date: $0) }
    .bind(to: selectedPaymentDate)
    .disposed(by: disposeBag)

selectedPaymentDate.asObservable()
    .distinctUntilChanged()
    .withLatestFrom(dueDate.asObservable()) { (selectedDate: $0, dueDate: $1) }
    .map { self.daysBetweenDates(startDate: $0.dueDate, endDate: $0.selectedDate) }
    .bind(to: numberScheduleDays)
    .disposed(by: disposeBag)

dueDate.accept(Date())
</code></pre>

<p>After block one <code>selectedPaymentDate.value = Date() + 1</code>
But in block two <code>dueDate</code> still emit <code>nil</code> value. I wonder why its value is not <code>Date()</code></p>
","3141876","","7568116","","2019-01-17 09:35:45","2019-01-17 09:35:45","Why withLatestFrom don't return latest value?","<swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"54252873","1","","","2019-01-18 11:18:26","","4","412","<p>Just started learning RxSwift. Why is the autocomplete not working, even though rx commands build fine?
<a href=""https://i.stack.imgur.com/7ebqb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7ebqb.png"" alt=""enter image description here""></a></p>

<p>EDIT: Temporary solution may be to add <code>asObservable</code> but I want the full experience!
<a href=""https://i.stack.imgur.com/B42kj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B42kj.png"" alt=""enter image description here""></a></p>
","1711809","","1711809","","2019-01-18 11:23:48","2019-03-15 04:34:36","How to get RxSwift autocomplete to work in Xcode 10.1?","<swift><xcode><rx-swift><xcode10><rx-cocoa>","1","0","1","","","CC BY-SA 4.0"
"54266227","1","54277152","","2019-01-19 10:42:20","","0","931","<p>I need some help with <code>DelegateProxy</code> implementation. Specifically, what is the proper way of implementing it when the delegate field has different name than simply <code>delegate</code>? Such as in <code>SKPhysicsContactDelegate</code> it is  called <code>contactDelegate</code>. I tried defining a computed value <code>delegate</code>, but it did not do the trick - <a href=""https://github.com/maxvol/RxSpriteKit/blob/master/Proxy/RxSKPhysicsContactDelegateProxy.swift"" rel=""nofollow noreferrer"">https://github.com/maxvol/RxSpriteKit/blob/master/Proxy/RxSKPhysicsContactDelegateProxy.swift</a></p>

<p>It fails with <code>""DelegateProxy has no factory of &lt;PKPhysicsWorld: 0x280b18990&gt;. Implement DelegateProxy subclass for &lt;PKPhysicsWorld: 0x280b18990&gt; first.""</code>
Perhaps it is not even related to the delegate field name, but this is the only difference with properly working proxies I could find.</p>

<p><strong>UPDATE:</strong> Ha! I just noticed that error message says <code>PKPhysicsWorld</code>, not <code>SKPhysicsWorld</code>. So my hypothesis is that it has something to do with the fact that <code>object</code> in <code>DelegateProxyFactory.createProxy</code> is a <code>PKPhysicsWorld</code> instead of <code>SKPhysicsWorld</code> and <code>_factories[ObjectIdentifier(mirror.subjectType)]</code> returns <code>nil</code>.</p>
","856588","","856588","","2019-01-21 06:15:55","2019-01-21 16:16:35","Implementing `DelegateProxy` (RxSwift/RxCocoa) when delegate field is not called `delegate`","<ios><swift><sprite-kit><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"54268797","1","","","2019-01-19 15:50:41","","2","1205","<p>Just started learning RxSwift. I feel like there should be a better way for me to do this:</p>

<p>ViewController:</p>

<pre><code>viewModel.orderDate.asObservable()
        .bind { [weak self] (date) in
            self?.orderButton.setTitle(viewModel.formattedOrderButtonText, for: UIControl.State.normal)
        }
        .disposed(by: disposeBag)
</code></pre>

<p>ViewModel:</p>

<pre><code>var orderDate = Variable&lt;Date?&gt;(nil)
var formattedOrderButtonText: String {
    get
    {
        let date = orderDate.value
        if(date == nil)
        {
            return ""String 1""
        }
        else
        {
            return ""String 2""
        }
    }
}
</code></pre>

<p>Is there any way to bind button's title to formatted variable?</p>
","1711809","","","","","2019-01-20 15:42:27","RxSwift bind to formatted value of variable","<ios><swift><viewmodel><rx-swift>","2","1","","","","CC BY-SA 4.0"
"54280774","1","","","2019-01-20 20:41:32","","-1","475","<p>I have a <code>UIViewController</code> subclass with 3 buttons. After 3 taps on button ""continue"", I pop this view controller from my navigation stack and push another instance of the same class. However, when I have this new view controller object pushed, I don't receive the <code>rx.tap</code> events. After putting <code>.debug()</code>on these subscriptions and a <code>print(#function)</code> on the <code>deinit()</code> of my view controller I get the following logs: </p>

<p><a href=""https://i.stack.imgur.com/t98X4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/t98X4.png"" alt=""Log""></a></p>

<p>I seems that the program is can't distinguish the buttons from the two instances of my view controller and thus subscribing for the second time before they are disposed.</p>

<p>Can someone help me fix this issue? 
Thanks in advance.</p>

<p><strong>Edit:</strong></p>

<p>Here is how I subscribe to the button taps:</p>

<pre><code>self.backButton.rx.tap
            .debug(""back button"")
            .bind(to: self.viewModel.backButtonPressed)
            .disposed(by: self.disposeBag)
</code></pre>
","7969193","","7969193","","2019-01-20 21:22:09","2019-01-21 22:42:29","Button Tap Event not recognized with RxSwift","<ios><swift><event-handling><rx-swift><reactive-swift>","1","1","","","","CC BY-SA 4.0"
"54281001","1","54281068","","2019-01-20 21:10:16","","-1","72","<p>Hello o created UICollectionView without storyboard and i used RxSwift for data binding.</p>

<p>I showing images on cells but they're not showing before scroll.</p>

<pre><code>   func first(_ image : String) {

    self.addSubview(firstView)
    firstView.snp.makeConstraints { (make) in
        make.right.equalToSuperview()
        make.left.equalToSuperview()
        make.top.equalToSuperview()
        make.height.equalTo(3 * self.bounds.height / 4)
    }
    firstView.layer.masksToBounds = true
    imageView.image = UIImage(named: ""kitaplar"")
    imageView.frame = CGRect(x: 0, y: 0, width: firstView.frame.width, height: firstView.frame.height)
    firstView.addSubview(imageView)
}
</code></pre>

<p>And my viewcontroller code is </p>

<pre><code>    self.kategoriArray
        .throttle(1, scheduler: MainScheduler.instance)
        .debug(""arraItem"", trimOutput: false)
        .bind(to: kategoriColl.rx.items(cellIdentifier: ""kategoriCell"", cellType: KategoriCollectionViewCell.self)){(index,model,cell) in

            cell.first(""https://www.gravatar.com/avatar/d2bba3700fd3a3e8cc12888edd980525?s=23&amp;d=identicon&amp;r=PG"")
                cell.second(model.title as! String)

        }.disposed(by: disposeBag)
</code></pre>
","9896496","","","","","2019-01-20 21:37:56","Collectionviewcell images not load before scroll","<ios><xcode><rx-swift><collectionview>","1","0","","","","CC BY-SA 4.0"
"54286196","1","54298528","","2019-01-21 08:48:37","","3","1308","<p>The problem I faced with is chaining 2 requests and handling errors.
Below an example of my code:</p>

<pre><code>func fbLogin() -&gt; Observable&lt;String&gt; { ... }

func userLogin(request: Request) -&gt; Observable&lt;User&gt; { ... }

let signedWithLogin = loginTaps
    .asDriver(onErrorJustReturn: ())
    .flatMapLatest { _ in
        return fbLogin()
        .map({ ReqestState&lt;String&gt;.loaded($0) })
        .asDriver(onErrorRecover: { error  in
            return Driver.just(.error(error))
        })
        .startWith(.loading)
     }
     .map({ UserEndpoint.socialLogin(token: $0) })
     .flatMapLatest { request in
         return userLogin(request: request)
         .map({ ReqestState&lt;User&gt;.loaded($0) })
         .asDriver(onErrorRecover: { error  in
              return Driver.just(.error(error))
         })
         .startWith(.loading)
     }

signedWithLogin
    .drive(onNext: { response in
        print(response)
     })
    .disposed(by: disposeBag)
</code></pre>

<p>Problem is when I cancel the facebook login popup I send <code>observer.onError(FBLoginManagerError.canceled)</code> error. This error catch first .<code>asDriver(onErrorRecover: { error</code> method but does't pass to the <code>.drive(onNext: { response</code>method.</p>

<p>How can I catch all errors in <code>.asDriver(onErrorRecover: { error</code> method?</p>
","4314758","","","","","2019-01-21 22:50:30","RxSwift Chaining requests","<swift><networking><observable><rx-swift><chaining>","1","0","1","","","CC BY-SA 4.0"
"54288554","1","","","2019-01-21 11:01:57","","0","400","<pre><code>var isCurrentlySearchingAddress = Variable&lt;Bool&gt;(false)
var currentSelectedPlace = Variable&lt;GeocodePlace?&gt;(nil)
</code></pre>

<p>when I make a subscription on</p>

<pre><code>Observable.combineLatest(viewModel.isCurrentlySearchingAddress.asObservable(), viewModel.currentSelectedPlace.asObservable())
</code></pre>

<p>How can I have readable variable names instead of <code>0</code> and <code>1</code>?</p>

<p><a href=""https://i.stack.imgur.com/i365P.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/i365P.png"" alt=""enter image description here""></a></p>
","1711809","","","","","2019-01-23 08:16:01","RxSwift - how to have readable combineLatest event element variable names?","<ios><swift><rx-swift>","3","2","","","","CC BY-SA 4.0"
"54302371","1","54313735","","2019-01-22 06:24:04","","2","479","<p>What I want to do are:</p>

<ol>
<li>Write value to a characteristic</li>
<li>If connection fails within a certain time, handle as a timeout error</li>
<li>If connection succeeds, extend or ignore timeout and keep connection</li>
</ol>

<p>I realized 1 and 2, but how can I realize 3?
Thank you very much for your help.</p>

<p>My source:</p>

<pre><code>manager = CentralManager(queue: .main, options: options)
manager!.observeState()
    .startWith(self.manager!.state)
    .filter { $0 == .poweredOn }
    .timeout(3.0, scheduler: MainScheduler.instance)
    .take(1)
    .flatMap { _ in self.manager!.retrievePeripherals(withIdentifiers: [peripheralUUID])[0].establishConnection() }
    .timeout(5.0, scheduler: MainScheduler.instance) // (A) Set connection timeout here
    .flatMap{ $0.writeValue(data, for: BLECharacteristic.char, type: .withResponse)}
    .subscribe(onNext: { char in
        // (B) I want to extend timeout here
        // Handle success
    }, onError: { (error) in
        // Handle error
    }, onCompleted: nil, onDisposed: nil)
</code></pre>
","10948440","","","","","2019-01-22 17:42:41","Extend Bluetooth connection timeout only when connection was successful using RxBluetoothKit","<ios><swift><bluetooth><rx-swift>","1","2","","","","CC BY-SA 4.0"
"54308137","1","54308785","","2019-01-22 12:16:10","","2","577","<p>I'm trying to build RxSwift for a Command Line Tool but it seams to be far more difficult then with an iOS App.</p>

<p>I created a new Command Line project and installed RxSwift with <code>pod</code></p>

<pre><code>$ cat Podfile
# Podfile
use_frameworks!

target 'HelloRx' do
    pod 'RxSwift',    '~&gt; 4.0'
end

</code></pre>

<pre><code>$ pod --version
1.5.3

</code></pre>

<p>XCode 10.1</p>

<p>After opening the workspace (.xcworkspace) and without adding any code the project builds fine but crash on run:</p>

<pre><code>dyld: Library not loaded: @rpath/RxAtomic.framework/Versions/A/RxAtomic
  Referenced from: /Users/luke/Library/Developer/Xcode/DerivedData/HelloRx-ftbkqquhoytidfesyxazbaovndbu/Build/Products/Debug/HelloRx
  Reason: image not found
</code></pre>

<p>Dynamic dependencies are not visible to the binary. </p>

<pre><code>$ otool -l HelloRx | grep -A 2 RPATH | grep path
         path @executable_path/../Frameworks (offset 12)
         path @loader_path/Frameworks (offset 12)
         path @executable_path/../Frameworks (offset 12)
         path @loader_path/Frameworks (offset 12)
</code></pre>

<p>XCode assumed that the binary can find frameworks in <code>Frameworks</code> directory relative to the binary. Unfortunatelly if I look into the build directory there is no <code>Frameworks</code> dir, hence the error.</p>

<pre><code>$ ls
HelloRx         Pods_HelloRx.framework  RxCocoa
HelloRx.swiftmodule RxAtomic        RxSwift

$ ls ..
Debug
</code></pre>

<p>To make it more confusing all frameworks were copied into own <code>Rx*</code> dir rather then one global <code>Frameworks</code> dir.</p>

<p>I can fix that by adding more paths into ""Build Settings"" >> ""Runpath Search Paths"".</p>

<pre><code>'@executable_path/RxAtomic'
'@executable_path/RxSwift'
</code></pre>

<p>I does the trick but binary still crashes.</p>

<pre><code>dyld: Library not loaded: @rpath/libswiftAppKit.dylib
  Referenced from: /Users/luke/Library/Developer/Xcode/DerivedData/HelloRx-ftbkqquhoytidfesyxazbaovndbu/Build/Products/Debug/RxSwift/RxSwift.framework/Versions/A/RxSwift
  Reason: image not found

</code></pre>

<p>Now it's the RxSwift which is missing <code>libswiftAppKit.dylib</code>.</p>

<p>This can be ""fixed"" by adding another Runpath path.</p>

<pre><code>'/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/macosx'
</code></pre>

<p>This finally stop crashes but my application throws lots of warnings:</p>

<pre><code>objc[64025]: Class _TtCE6AppKitVSo17NSAnimationEffectP33_9E6F1C1DB126EBCC5B18B8BAC8A387CC26_CompletionHandlerDelegate is implemented in both /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/macosx/libswiftAppKit.dylib (0x101360b98) and /Users/luke/Library/Developer/Xcode/DerivedData/HelloRx-ftbkqquhoytidfesyxazbaovndbu/Build/Products/Debug/HelloRx (0x10059a250). One of the two will be used. Which one is undefined.
objc[64025]: Class _TtC8Dispatch16DispatchWorkItem is implemented in both /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/macosx/libswiftDispatch.dylib (0x101a7c6d0) and /Users/luke/Library/Developer/Xcode/DerivedData/HelloRx-ftbkqquhoytidfesyxazbaovndbu/Build/Products/Debug/HelloRx (0x10059bd28). One of the two will be used. Which one is undefined.
objc[64025]: Class _TtC10FoundationP33_45BFD3D387700B862E3A7353B97EF7ED20_CharacterSetStorage is implemented in both /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/macosx/libswiftFoundation.dylib (0x101c34f00) and /Users/luke/Library/Developer/Xcode/DerivedData/HelloRx-ftbkqquhoytidfesyxazbaovndbu/Build/Products/Debug/HelloRx (0x10059d5e8). One of the two will be used. Which one is undefined.
objc[64025]: Class _TtC10Foundation12_DataStorage is implemented in both /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/macosx/libswiftFoundation.dylib (0x101c34fa8) and /Users/luke/Library/Developer/Xcode/DerivedData/HelloRx-ftbkqquhoytidfesyxazbaovndbu/Build/Products/Debug/HelloRx (0x10059d690). One of the two will be used. Which one is undefined.
...
</code></pre>

<p>I can live with warnings but it's clearly not the right solution. That makes me think, what's the right way to solve this problem?</p>

<p>(I'm new to XCode and Swift so perhaps I'm doing something crazy)</p>
","1680817","","","","","2019-01-22 12:56:07","The right way to link RxSwift into a Command Line Tool","<ios><swift><xcode><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"54331181","1","54333060","","2019-01-23 16:01:35","","1","244","<p>Im new to RXSwift and I've begun investigating how I can perform Promise like function chaining.</p>

<p>I think I'm on the right track by using flatmap but my implementation is very difficult to read so I suspect theres a better way to accomplish it.</p>

<p>What I have here seems to work but I'm getting a headache thinking about what It might looks like if I added another 3 or functions to the chain.</p>

<p><strong>Here Is where I declare my 'promise chain'(hard to read)</strong></p>

<pre><code>LOGIN().flatMap{ (stuff) -&gt; Observable&lt;Int&gt; in
    return API(webSiteData: stuff).flatMap
    { (username) -&gt; Observable&lt;ProfileResult&gt; in
    return accessProfile(userDisplayName: username) }
    }.subscribe(onNext: { event in
        print(""The Chain Completed"")
        print(event)
    }, onError:{ error in
         print(""An error in the chain occurred"")
    })
</code></pre>

<p><strong>These are the 3 sample functions I'm chaining</strong>  </p>

<pre><code>struct apicreds
{
    let websocket:String
    let token:String
}
typealias APIResult = String
typealias ProfileResult = Int

// FUNCTION 1
func LOGIN() -&gt; Observable&lt;apicreds&gt; {

    return Observable.create { observer in
        print(""IN LOGIn"")
        observer.onNext(apicreds(websocket: ""the web socket"", token: ""the token""))
        observer.on(.completed)
        return Disposables.create()
    }
}
// FUNCTION 2
func API(webSiteData: apicreds) -&gt; Observable&lt;APIResult&gt; {

    return Observable.create { observer in
        print(""IN API"")
        print (webSiteData)
       // observer.onError(myerror.anError)
        observer.on(.next(""This is the user name"")) // assiging ""1"" just as an example, you may ignore
        observer.on(.completed)
        return Disposables.create()
    }

}
//FUNCTION 3
func accessProfile(userDisplayName:String)  -&gt; Observable&lt;ProfileResult&gt;
{
    return Observable.create { observer in

        // Place your second server access code
        print(""IN Profile"")
        print (userDisplayName)

        observer.on(.next(200)) // 200 response from profile call
        observer.on(.completed)
        return Disposables.create()
    }
}
</code></pre>
","264273","","264273","","2019-01-23 20:48:29","2019-01-23 21:31:49","How do you sequentially chain observables in concise and readable way","<swift><promise><rx-swift>","3","0","","","","CC BY-SA 4.0"
"54342546","1","","","2019-01-24 08:46:27","","0","627","<p>I'm creating a networking layer where I inject API provider and call event to the initialize method.</p>

<pre><code>class NetworkingLayer&lt;T: Decodable, E: TargetType&gt; {

    var response: Driver&lt;T&gt;

    init(provider: MoyaProvider&lt;E&gt;, request: Singal&lt;E&gt;) {

        let requestState = request
            .flatMapLatest({
                provider.rx.request($0).map(Respose&lt;T&gt;.self)
                    .map { ReqestState.loaded($0) }
                    .asDriver(onErrorRecover: { error  in
                        return Driver.just(.error(error))
                    })
                    .startWith(.loading)
            })
            .asDriver(onErrorRecover: { fatalError($0.localizedDescription) })

        response = requestState
            .map({ $0.data?.data })
            .filterNil()

    }
}
</code></pre>

<p>Using them in the following way:</p>

<pre><code>class ViewModel {

    let networking: DataNetworkingResponse&lt;[TagItem], ScoutEnpoint&gt;

    init(provider: MoyaProvider&lt;Endpoint&gt;, event: Singal&lt;[Int]&gt;) {

        let request = event
            .map({ Endpoint.getNewItems(prevItemsIds: $0) })

        self.networking = NetworkingLayer(provider: provider, request: request)
    }
}
</code></pre>

<p>All working like charm. But now I have to implement refresh feature. Refresh my last request. I've added this <code>let refresh: Signal&lt;()&gt; = Signal.empty()</code> property to my network layer. But can't understand how to save my last request.</p>

<pre><code>class NetworkingLayer&lt;T: Decodable, E: TargetType&gt; {

    let refresh: BehaviorRelay&lt;()&gt; = BehaviorRelay.init(value: ())
    ...
}
</code></pre>

<p>How can I implement refreshing like this? </p>

<pre><code>viewModel.networking.refresh.accept(())
</code></pre>
","4314758","","","","","2019-01-24 12:22:16","Replay last request with RxSwift","<swift><networking><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54354596","1","","","2019-01-24 20:11:00","","0","552","<p>I have a UITableView populated with Product models. There are 2 challenges I'm having right now. The first is I have a quantityLabel on the cells which I want to update when the user presses an increment or decrement button on the cell. Currently to do this, I am updating the model and accepting an entirely new array, which triggers the tableView to reload, which isn't ideal. The second challenge is, when the quantity of a Product goes to 0, that cell should be removed from the tableView with an animation. Currently, I just find the index of the product within the dataSource, remove it and reload the table. I'd like to know the proper Rx way to do this. Here's a sample of my code. Thanks!  </p>

<pre><code>struct Product: Equatable {
  var i: String
  var quantity: Int
  init(i: Int, quantity: Int) {
    self.i = ""item: \(i)""
    self.quantity = quantity
  }
}
extension Product {
  static func ==(lhs: Product, rhs: Product) -&gt; Bool {
    return lhs.i == rhs.i
  }
}

class ProductSource {
  var items: BehaviorRelay&lt;[Product]&gt; = BehaviorRelay&lt;[Product]&gt;(value: [])
  var itemsObservable: Observable&lt;[Product]&gt;
  init() {
    itemsObservable = items.asObservable().share(replay: 1)
    items.accept((0..&lt;20).map { Product(i: $0, quantity: 2) })
  }

  func add(product: Product) {}

  func remove(product: Product) {
    guard let index = self.items.value.index(of: product) else {return}

  // decrement quantity, if quantity is 0, remove from the datasource and update the tableView
  }
}

class ViewController: UIViewController {

  @IBOutlet weak var tableView: UITableView!
  var disposeBag = DisposeBag()
  var data = ProductSource()

  override func viewDidLoad() {
    super.viewDidLoad()

    tableView.rx.setDelegate(self).disposed(by: disposeBag)
    data.itemsObservable
        .bind(to: tableView.rx.items(cellIdentifier: ""productCell"", cellType: ProductTableViewCell.self)) { row, element, cell in
            cell.nameLabel.text = element.i
            cell.quantityLabel.text = String(element.quantity)
    }.disposed(by: disposeBag)
  }
}

extension ViewController: UITableViewDelegate {
  func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {
    return 100
  }
}
</code></pre>
","2066353","","","","","2019-01-24 22:12:55","RxSwift tableView update based on property","<reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54380200","1","54380344","","2019-01-26 16:15:07","","0","3595","<p>I have viewModel:</p>

<pre><code>class EditFoodViewViewModel {
    private var food: Food

    var foodImage = Variable&lt;NSData&gt;(NSData())

    init(food: Food) {
        self.food = food
        self.foodImage.value = food.image!
    }
}
</code></pre>

<p>And ViewController:</p>

<pre><code>class EditFoodViewController: UIViewController {
    public var food: EditFoodViewViewModelType?
    @IBOutlet weak var foodThumbnailImageView: UIImageView!

    override func viewDidLoad() {
        super.viewDidLoad()

        guard let foodViewModel = food else { return }
        foodViewModel.foodImage.asObservable().bind(to: foodThumbnailImageView.rx.image).disposed(by: disposeBag)
  }
}
</code></pre>

<p>In the last line of viewController (where my UIImageView) a get error:</p>

<blockquote>
  <p>Generic parameter 'Self' could not be inferred</p>
</blockquote>

<p>How to solve my problem? How to set image to imageView with rxSwift?</p>
","5004769","","","","","2019-01-26 19:31:27","How to bind image to UIImageView with rxswift?","<ios><swift><mvvm><uiimageview><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"54394747","1","54394887","","2019-01-28 02:18:51","","1","93","<p>I'm studying RXSwift, and I'm a little confuse about Observables. I've understood the theory, that it can emit events ""over time"". But, I must initialize it with a value, subscribe, and user that value (which is pointless), but I cannot change the value of that observable later, so, whats the point of saying that it can emit values ""over time""??? Can someone clarify it to me? Thanks a lot!</p>
","4100075","","","","","2019-02-07 15:49:29","RX Observables - What's the point of ""over time"" if I can't change is value?","<observable><system.reactive><rx-swift>","2","1","","","","CC BY-SA 4.0"
"54398424","1","54402712","","2019-01-28 08:57:32","","0","262","<h3>Summary</h3>

<p>I create an Observable that emits events by calling <code>onNext</code> from a <code>DispatchQueue.async</code>, and my corresponding unit test needs to <code>sleep(...)</code> in order to actually receive the events, even though I use the <code>TestScheduler</code>.</p>

<h3>Detailed question</h3>

<p>I create the following <code>Observable</code>, which reads events from a gRPC stream. I believe that gRPC is not so important here: just note that I <code>call.receive()</code> in a <code>while</code> loop, and feed that to <code>onNext</code>.</p>

<pre class=""lang-swift prettyprint-override""><code>private func createPositionObservable() -&gt; Observable&lt;Position&gt; {
    return Observable.create { observer in
        let request = DronecodeSdk_Rpc_Telemetry_SubscribePositionRequest()

        do {
            let call = try self.service.subscribePosition(request, completion: { (callResult) in
                if callResult.statusCode == .ok || callResult.statusCode == .cancelled {
                    observer.onCompleted()
                } else {
                    observer.onError(RuntimeTelemetryError(callResult.statusMessage!))
                }   
            })  

            DispatchQueue.init(label: ""DronecodePositionReceiver"").async {
                while let responseOptional = try? call.receive(), let response = responseOptional {
                    observer.onNext(Position.translateFromRpc(response.position))
                }   
            }   

            return Disposables.create {
                call.cancel()
            }   
        } catch {
            observer.onError(error)
            return Disposables.create()
        }   
    }   
    .subscribeOn(scheduler)
}
</code></pre>

<p>I now try to test this code with the function below. Again, the first paragraph is only about setting the gRPC context. What I believe is important is that:</p>

<ol>
<li>I use a <code>TestScheduler</code></li>
<li>I pass this scheduler to gRPC (<code>scheduler</code> is passed to <code>Telemetry</code>, and is used as <code>subscribeOn(scheduler)</code> above)</li>
<li>I <code>sleep(2)</code> before the asserts</li>
</ol>

<pre class=""lang-swift prettyprint-override""><code>func checkPositionObservableReceivesEvents(positions: [DronecodeSdk_Rpc_Telemetry_Position]) {
    let fakeService = DronecodeSdk_Rpc_Telemetry_TelemetryServiceServiceTestStub()
    let fakeCall = DronecodeSdk_Rpc_Telemetry_TelemetryServiceSubscribePositionCallTestStub()
    fakeCall.outputs.append(contentsOf: positions.map{ position in createPositionResponse(position: position) })
    fakeService.subscribePositionCalls.append(fakeCall)
    let expectedEvents = positions.map{ position in next(1, translateRPCPosition(positionRPC: position)) }

    let scheduler = TestScheduler(initialClock: 0)
    let observer = scheduler.createObserver(Telemetry.Position.self)
    let telemetry = Telemetry(service: fakeService, scheduler: scheduler)

    let _ = telemetry.position.subscribe(observer)
    scheduler.start()

    sleep(2)

    XCTAssertEqual(expectedEvents.count, observer.events.count)
    XCTAssertTrue(observer.events.elementsEqual(expectedEvents, by: { (observed, expected) in
        observed.value == expected.value
    })) 
}
</code></pre>

<p>If I don't <code>sleep(...)</code>, my asserts fail and <code>observer.events.count</code> receives no event. It feels like the assert happens before the events are emitted.</p>

<p>How should I deal with that?</p>
","1368342","","1368342","","2019-01-28 09:49:16","2019-01-29 17:19:12","Need to sleep for TestScheduler to finish","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"54400502","1","54401485","","2019-01-28 10:59:54","","3","1853","<p>I was playing with RxSwift on playground and I'm confronted to a warning.
Here is the complete warning message :</p>

<pre><code>Synchronization anomaly was detected.
- Debugging: To debug this issue you can set a breakpoint in RxSwift/RxSwift/Rx.swift:113 and observe the call stack.
Problem: This behavior is breaking the observable sequence grammar. `next (error | completed)?`
- This behavior breaks the grammar because there is overlapping between sequence events.
Observable sequence is trying to send an event before sending of previous event has finished.
- Interpretation: Two different unsynchronized threads are trying to send some event simultaneously.
This is undefined behavior because the ordering of the effects caused by these events is nondeterministic and depends on the 
operating system thread scheduler. This will result in a random behavior of your program.
- Remedy: If this is the expected behavior this message can be suppressed by adding `.observeOn(MainScheduler.asyncInstance)`
or by synchronizing sequence events in some other way.
</code></pre>

<p>Here is the code on Playground.</p>

<pre><code>import RxSwift
import Foundation

example(""PublishSubject"") {
let disposeBag = DisposeBag()
let subject = PublishSubject&lt;String&gt;()


subject.onNext(""🐶"")
subject.subscribe(onNext: { (value) in
    print(value)
}).disposed(by: disposeBag)
subject.onNext(""🐱"")

subject.onNext(""🅰️"")
subject.onNext(""🅱️"")
DispatchQueue.global(qos: .utility).async {
    for index in 0...10 {
        subject.onNext(""1"")
    }
          subject.observeOn(MainScheduler.asyncInstance).subscribe(onNext: { (value) in
        print(value)
    }).disposed(by: disposeBag)
}
DispatchQueue.global(qos: .utility).async {
    for index in 0...10 {
        subject.onNext(""B"")
    }
    subject.observeOn(MainScheduler.asyncInstance).subscribe(onNext: { (value) in
        print(value)
    }).disposed(by: disposeBag)
}
}
</code></pre>

<p>How can I do to solve this warning problem?? thx</p>
","10025661","","5519329","","2019-01-28 11:08:19","2019-01-28 11:56:18","publishSubject Synchronization anomaly warning","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"54401647","1","","","2019-01-28 12:05:10","","0","400","<p>I'm trying to learn RxSwift concept and got stuck somewhere unfortunately. There is two different screen connected to my <code>TabBarController</code>. On my <code>SettingsViewController</code>, I'm getting two string values and creating a model, On <code>TransactionListViewController</code>, I need to observe changes on and make a new request to fill list.</p>

<p>On parent tab bar controller, I have a Variable and when didLoadCall I'm subscribing this model with <code>wallet.asObservable().subscribe</code></p>

<p>On <code>SettingViewController</code> when user presses the login button I'm trying to change UserModel with this code: </p>

<pre><code>if let tabBar = parent?.parent as? TransactionTabBarController{
   Observable.just(wallet).bind(to: tabBar.wallet)
}
</code></pre>

<p>I realized that onNext function for wallet.asObservable().subscribe is calling.</p>

<p>There is also another wallet model on my <code>TransactionListViewController</code>,
on viewDidLoad function I'm running this code:</p>

<pre><code>wallet.asObservable().subscribe(onNext: { (wallet) in
   APIClient.getTransaction(address: wallet.walletAddress)
      .observeOn(MainScheduler.instance)
      .subscribe(onNext: { (model) in
          self.changeModels(items: model.result)
          .bind(to: self.transactionTableView.rx.items(dataSource: self.dataSource))
          .disposed(by: self.disposeBag)
       })
   .disposed(by: self.disposeBag)}, onError: nil, onCompleted: nil, onDisposed: nil)
.disposed(by: disposeBag)
</code></pre>

<p>I tried to set wallet on TabBar's onNext function and I got crush couple of times on TransactionListViewController.</p>

<p>Can anyone help me with that?</p>
","3559801","","5329717","","2019-01-29 00:13:28","2019-01-29 02:03:50","RxSwift Observe changes on model and Make request","<swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"54417400","1","54417438","","2019-01-29 09:11:51","","0","73","<pre><code>enum ApiError: Swift.Error
{
    case SimpleErrorMessage(message: String)
}


// Observable ...
.map({ (response, json) -&gt; Bool in
            if(response.statusCode == 200)
            {
                return true
            }
            else if(response.statusCode == 404)
            {
                return false
            }
            else
            {
                throw ApiError.SimpleErrorMessage(message: ""test"")
            }
        })

// Observable
.subscribe(onError: { [weak self] (error) in
                // todo notify somehow?
                guard let err = error as? ApiError else { return }
                if case .SimpleErrorMessage == error
                {
                }
        })
</code></pre>

<p>How to obtain message variable in onError?</p>
","1711809","","","","","2019-01-29 09:14:23","Swift - how to obtain enum case argument from enum variable?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54424130","1","54472486","","2019-01-29 15:14:57","","3","781","<p>I am building an iOS app with RxSwift and RxDataSource using VIPER architecture. I want to change the content of the UICollectionView as the value of the presenter changes (as the user typed in some letters in the searchBar, the collectionView should show all users' profile that starts with the letters), but it doesn't work as I wanted it to.</p>

<p>By trying <code>debug()</code> function, the value of <code>presenter.section</code> in ViewController (which holds the content of the CollectionView) is changed after I typed in some letters in the searchBar. However, the collectionView is not reflecting the change. 
Here are the main parts of the code.</p>

<p>code of ViewController</p>

<pre><code>override func viewDidLoad() {

    super.viewDidLoad()
    self.view.backgroundColor = .white

    self.presenter.section
        .drive(self.searchedFriendsCollectionView.rx.items(dataSource: self.dataSource))
        .disposed(by: self.disposeBag)

    self.searchedFriendsCollectoinView.rx
        .setDelegate(self)
        .disposed(by: self.disposeBag)
}
</code></pre>

<p>code of Presenter</p>

<pre><code>init(view: SearchFriendsViewInterface, interactor: 
SearchFriendsInteractorInterface, wireframe: 
SearchFriendsWireframeInterface) {

    self.view = view
    self.interactor = interactor
    self.wireframe = wireframe

    let allUsers = self.interactor.allUsers().asObservable()

    self.view.searchText
        .debounce(0.5)
        .filterNil()
        .distinctUntilChanged()
        .filterEmpty()
        .asObservable()
        .flatMap { text -&gt; Observable&lt;[SearchFriendsSection]&gt; in
            // get all users starting with ""text""
            allUsers.mapSections(query: text)
        }
        .bind(to: self.section)
        .disposed(by: self.disposeBag)
} 

extension Observable where E == [User] {

fileprivate func mapSections(query: String) -&gt; Observable&lt;[SearchFriendsSection]&gt; {

    return self.map {
            $0.filter { $0.userDisplayName.hasPrefix(query) || $0.username.hasPrefix(query) }
        }
        .map { users -&gt; [SearchFriendsSection] in

            let items = users.map { user in
                SearchFriendsItem(icon: user.profileImageURL, displayName: user.userDisplayName)
            }
            return [SearchFriendsSection(items: items)]
        }
    }
}
</code></pre>

<p>How I defined <code>dataSource</code></p>

<pre><code>override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {

    self.searchedFriendsCollectoinView = UICollectionView(frame: .init(), collectionViewLayout: self.searchedFriendsCollectionViewFlowLayout)
    let dataSource = RxCollectionViewSectionedReloadDataSource&lt;SearchFriendsSection&gt; (configureCell: {(_, collectionView, indexPath, item) -&gt; UICollectionViewCell in
        collectionView.register(SearchFriendsCell.self, forCellWithReuseIdentifier: ""SearchFriendsCell"")
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ""SearchFriendsCell"", for: indexPath) as! SearchFriendsCell
        cell.item = item
        return cell
    })
    self.dataSource = dataSource
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
}
</code></pre>

<ul>
<li>ViewController has the instance of Presenter, and the presenter has an instance called <code>section</code>. This <code>section</code> holds the list of the users whose username is starting with specific letters. </li>
</ul>

<p>Could you please help me? If I have left anything unclear, please let me know in the comment. </p>

<p>Update: output of the <code>debug()</code></p>

<pre><code>2019-02-01 10:22:27.610: values -&gt; subscribed
2019-02-01 10:22:27.611: values -&gt; Event next([])
--after typed in some letters in the searchBar--
2019-02-01 10:22:41.494: values -&gt; Event 
next([AppScreen.SearchFriendsSection(items: 
[AppScreen.SearchFriendsItem(....), 
AppScreen.SearchFriendsItem(....), 
AppScreen.SearchFriendsItem(....)])])
</code></pre>
","10233761","","10233761","","2019-02-01 01:21:12","2019-02-01 03:29:23","How to reflect the new section to UICollectionView in RxDataSource?","<swift><uicollectionview><rx-swift><viper><rxdatasources>","3","8","","","","CC BY-SA 4.0"
"54426181","1","54431269","","2019-01-29 17:06:07","","7","3739","<p>On RxCocoa I was wondering why the PublishRelay doesn't have an asDriver() method like the BehaviorRelay ? Currently if I want to convert the publishRelay into a Driver, I have to specify what to return in case of error which seems weird given that the relays can't generate errors...</p>
","4614417","","","","","2020-04-09 16:18:04","RxCocoa - Why doesn't PublishRelay have an asDriver() method?","<ios><rx-swift><rx-cocoa>","2","0","3","","","CC BY-SA 4.0"
"54443295","1","","","2019-01-30 14:49:44","","1","1075","<p>I am currently diving into RxSwift and I am trying to use it to update a TableView on a ViewController(.xib) with data that I get from a JSON and is encoded into a struct with Codable.</p>

<p>Here's my VM atm:</p>

<pre><code>import Foundation
import RxCocoa
import RxSwift

protocol MenuViewModelProtocol {
    func viewDidLoad()
}

class MenuViewModel: MenuViewModelProtocol {

    private (set) var menu = MenuModel()
    private let menuIntermediary = MenuDataIntermediary()

    func viewDidLoad() {
        debugPrint(""MenuViewModel.viewDidLoad: Async request for menu was made"")
        requestAndSetMenuToIntermediary { (_ success) in
            switch success {
            case true:
                debugPrint(""MenuViewModel.requestAndSetMenuToIntermediary: Did get Menu successfully"")
                // print(self.menu) // -&gt; menu is here
            case false:
                debugPrint(""MenuViewModel.requestAndSetMenuToIntermediary: Did not get Menu successfully"")
            }
        }
    }

    private func requestAndSetMenuToIntermediary(completion: @escaping (_ success: Bool) -&gt; Void) {
        menuIntermediary.jsonDataToMenuConversion { [weak self] (success) in
            DispatchQueue.global().async {
                guard let strongSelf = self else {
                    debugPrint(""MenuViewModel.requestMenuToIntermediary: couldn't create a strong self reference"")
                    completion(false)
                    return
                }

                guard let menu = menu else {
                    debugPrint(""MenuViewModel.requestMenuToIntermediary: couldn't unwrap menu data"")
                    completion(false)
                    return
                }
                strongSelf.menu = menu

                // print(strongSelf.menu) // -&gt; menu is here
                completion(true)
            }
        }
    }
}
</code></pre>

<p>The flow behing <em>requestAndSetMenuToIntermediary</em> is in short:</p>

<p>-> DataManager requests JSON from URL and returns a Data? </p>

<p>-> Intermediary Layer parses the JSON onto a Struct (with nested structs) using Codable and returns a Struct? </p>

<p>-> ViewModel gets the Struct? and unwraps it, being it ready for UI setup. </p>

<p>-> ?? </p>

<p>My problem at '??' is to notify the VC that <strong>menu</strong> was updated in order to setup the TableView. Any suggestions? I've tried using PublishSubjects, BehaviorSubject combined with observables but I can't seem to make it work. I'm in doubt if it is syntax or something related to the background flow...</p>

<p>Thanks in advance! 
P.s - If more info is needed I can happily provide it, I was just trying to not make a very long post :p</p>
","10151021","","1226963","","2019-01-30 14:58:18","2019-01-30 17:07:15","RxSwift: MVVM Update Struct on View Model and Trigger Table Update on View Controller","<json><swift><asynchronous><tableview><rx-swift>","1","1","","","","CC BY-SA 4.0"
"54477181","1","","","2019-02-01 10:07:44","","0","103","<p>I have this piece of code in RxSwift that wraps UDPBroadcastConnection (<a href=""https://github.com/gunterhager/UDPBroadcastConnection"" rel=""nofollow noreferrer"">https://github.com/gunterhager/UDPBroadcastConnection</a>)
My question is, what do I have to do to call closeConnection() when the observable is disposed?</p>

<pre><code>struct UDPBroadcastResponse {
    let ip: String
    let port: Int
    let message: [UInt8]
}

final class RxBroadcaster: UDPBroadcastConnection {
    let response = PublishSubject&lt;UDPBroadcastResponse&gt;()
    private let disposeBag = DisposeBag()
}

extension RxBroadcaster: ReactiveCompatible {}

extension Reactive where Base: RxBroadcaster {
    func send(message: String) -&gt; Observable&lt;UDPBroadcastResponse&gt; {
        DDLogVerbose(""Sending UDP broadcast message: \(message)"")
        self.base.sendBroadcast(message)
        return self.base.response
    }
}

extension RxBroadcaster {
    convenience init(port: UInt16) {
        let rely = ReplaySubject&lt;UDPBroadcastResponse&gt;.createUnbounded()
        self.init(port: port) { ip, port, message in
            let response = UDPBroadcastResponse(ip: ip, port: port, message: message)
            // DDLogVerbose(""Receiving UDP message: IP: \(response.ip). Port: \(response.port). Message: \(response.message.map{ String(format: ""%02X"", $0) }.joined())"")
            DDLogVerbose(""Receiving UDP message: IP: \(response.ip). Port: \(response.port)"")
            rely.onNext(response)
        }
        rely.bind(to: self.response).disposed(by: disposeBag)
    }
}
</code></pre>

<p>Here I see an example: <a href=""http://adamborek.com/practical-introduction-rxswift/"" rel=""nofollow noreferrer"">http://adamborek.com/practical-introduction-rxswift/</a>
But I am not sure about the lifecycle of the objects involved.
Can you help me?
Thanks for suggestions.</p>
","917338","","","","","2019-02-03 17:29:40","How to call a method when disposing","<rx-swift>","2","0","","","","CC BY-SA 4.0"
"54482888","1","54489532","","2019-02-01 15:54:22","","1","934","<p>I load posts from the server and want to show them <strong>only</strong> when their images are <strong>all loaded</strong>.
Here's what I was trying to do:</p>

<pre><code>postsRepository
    .fetchPosts()
    .flatMap { posts -&gt; Observable&lt;[Post]&gt; in
        return Observable.merge(posts.map({ /* Code that returns Observable&lt;UIImage&gt; */ }))
            .takeLast(1)
            .map { _ in posts }
    }
</code></pre>

<p>However, this code above loads images twice: once all the posts are fetched and once I bind posts to the table view. How to deal with that?</p>
","1321917","","","","","2019-02-02 14:40:15","RxSwift: delay observable until another observable is finished?","<swift><reactive-programming><rx-swift>","1","4","","","","CC BY-SA 4.0"
"54497079","1","54498509","","2019-02-02 20:12:46","","1","86","<p>Please take a look at the following code snippet.</p>

<pre><code>
class ViewController: UIViewController {

    let disposeBag = DisposeBag()
    @IBOutlet weak var clickMe: UIButton!

    override func viewDidLoad() {
    super.viewDidLoad()

        onAction1()
        onAction2()
    }
    func onAction1(){
        Observable.just(4)
        .flatMapLatest{self.performTask(value: $0)}
        .subscribe(onNext:{ data in
            print(""data is"")
            print(data)
        }, onCompleted: {
            print(""task completed"")
        })
        .disposed(by: disposeBag)
    }
    func onAction2(){
        clickMe.rx.tap
        .map{4}
        .flatMapLatest{self.performTask(value: $0)}
        .subscribe(onNext:{ data in
            print(""data is"")
            print(data)
        }, onCompleted: {
            print(""task completed"")
        })
        .disposed(by: disposeBag)
    }

    func performTask(value:Int) -&gt; Observable&lt;Int&gt;{

        return self.skipObservable(value:value)
          // need to skip the following flatmap when value is 4 
        .flatMapLatest{self.multipierObservable(value: $0)} 


    }

    func multipierObservable(value:Int) -&gt; Observable&lt;Int&gt;{
        return Observable.just(value*value)
    }
    func skipObservable(value:Int) -&gt; Observable&lt;Int&gt;{

        return Observable.create { (observer:AnyObserver&lt;Int&gt;) -&gt; Disposable in
            print(""value is"", value)
            if value == 4{
                observer.onCompleted()
            }
            else {
                observer.onNext(value)
                observer.onCompleted()
            }


            return Disposables.create()

        }

    }


}
</code></pre>

<p>Sample Output</p>

<pre><code>value is 4
task completed

/// output on button tap. Not printing 'task completed'? Why? please advice
value is 4



</code></pre>

<p>i can see for action1, the observer.onComplete without observer.onNext of first <strong>skipObservable</strong> causes the observer to go completed state skipping the second flatmap.</p>

<p>but when same set of flatmap is being called using a button tap, the state of the observer is not getting completed.</p>

<p>Please help me to understand the difference between the two.</p>
","1201374","","1201374","","2019-02-02 20:17:55","2019-02-03 13:49:57","How observer.onComplete() without onNext, works in chain of flatmap?. - It has to skip all the following flatmaps Right?","<ios><swift><reactive-programming><rx-swift>","1","1","","","","CC BY-SA 4.0"
"54498199","1","54498658","","2019-02-02 22:38:50","","1","960","<p>I have two BehaviorRelay-s, one is binded to second one. What is the proper way to update values of both inside one function?
For example:</p>

<pre><code>class SetupProfileVM {
   let disposeBag = DisposeBag()
   let name= BehaviorRelay&lt;String?&gt;(value: nil)
   let username = BehaviorRelay&lt;String?&gt;(value: nil)

   name.bind(to: username).dispose(by: disposeBag)

   func setNewValues(name: String, username: String) {
       name.accept(name)
       username.accept(username)
   }
}
</code></pre>

<p>In this case i want username to be same as user when value is updated by textfield. But i also need this function to set new values to both name &amp; username. What is the proper way of doing that? Can i be sure that username will be updated firstly by it's binding and only after that by it's new value?</p>
","9380128","","9380128","","2019-02-02 22:44:08","2019-02-02 23:48:46","What is the proper way to update values of two Behavior Relays when one is subscribed to other?","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54500566","1","54500712","","2019-02-03 06:39:05","","1","155","<pre><code>  let s = ""Hello World""
  let string = BehaviorSubject(value: s)

  //Example 1
  string
    .map { _ in ""hhh"" }
    .subscribe(onNext: { element in
      print(element)
    }, onCompleted: {
      print(""completed"")
    }
  )

  //Example 2
  string
    .flatMap { s -&gt; Observable&lt;String&gt; in
      Observable.just(""lll"")
    }
    .subscribe(onNext: { element in
      print(element)
    }, onCompleted: {
      print(""completed"")
    }
  )

  //Example 3
  let aaa = string
    .map { _ in ""hhh"" }

  //Example 4    
  let bbb = string
    .flatMap { s -&gt; Observable&lt;String&gt; in
      Observable.just(""lll"")
  }
</code></pre>

<p>I'm pretty new to RX world, in example 1 &amp; 2, I use <code>map</code> and <code>flatMap</code> to test to test out this behaviour. one of the major difference between them is  <code>map</code> return normal value type whereas the <code>flatMap</code> returns Observable type.</p>

<p>In example 3 &amp; 4, it shows that the type of both <code>aaa</code> and <code>bbb</code> are <code>Observable&lt;String&gt;</code>..</p>

<p>Now, since at the end they become the same thing, why do you even need <code>flatMap</code> to return a specific <code>Observable</code> type? or why do you need <code>map</code> to return a <code>normal value</code> type? </p>

<p>(I know that <code>flatMap</code> can do other things, it's not part of this confusion)</p>
","7591205","","","","","2019-02-03 13:44:49","What difference does it make to subscribe to a normal type and a observable type in here?","<ios><swift><rx-swift>","2","1","","","","CC BY-SA 4.0"
"54507388","1","54508866","","2019-02-03 20:43:10","","1","2565","<p>How can <code>combineLatest</code> be used to return a <code>BehaviorSubject</code>? I'm trying to get the last value out of the observable.</p>

<pre><code>var things: Observable&lt;Thing&gt;

// driven by UI
var selectedThingIndex: PublishSubject&lt;Int&gt;

// this is a BehaviorSubject, because I need to get the latest value outside a subscriber
var currentThing: BehaviorSubject&lt;Thing&gt; = BehaviorSubject.combineLatest(things, selectedThingIndex) { things, index in
    things[index]
}

// Get the last value
let thing = currentThing.value()
</code></pre>

<p>I can't get this to compile, because <code>combineLatest</code> returns an <code>Observable</code>, which doesn't seem to be castable to a <code>BehaviorSubject</code>. I tried an explicit cast, e.g. <code>as? BehaviorSubject&lt;Thing?&gt;</code> but that returns nil.</p>
","62178","","","","","2019-02-04 00:13:36","Get last value from Observable","<rx-swift>","1","1","","","","CC BY-SA 4.0"
"54508602","1","54509546","","2019-02-03 23:23:42","","1","785","<p>I am willing to replay the last result of a <code>Completable</code>, I believe exactly like what the <a href=""http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html#cache--"" rel=""nofollow noreferrer""><code>.cache()</code> operator described here</a>.</p>

<p>The following RxSwift code outputs: ""completed""</p>

<pre class=""lang-swift prettyprint-override""><code>let connectable = Completable.empty().asObservable().replay(1)
connectable.subscribe(onCompleted: { print(""completed"") })
connectable.connect()
</code></pre>

<p>Now if I <code>.connect()</code> before I <code>.subscribe()</code>, I don't get anything:</p>

<pre class=""lang-swift prettyprint-override""><code>let connectable = Completable.empty().asObservable().replay(1)
connectable.connect()
connectable.subscribe(onCompleted: { print(""completed"") })
</code></pre>

<p>In my case, if I <code>.subscribe()</code> after <code>connectable</code> has completed, I want to know that it has completed...</p>

<p>Is there a way to do that?</p>
","1368342","","","","","2019-05-22 14:56:47","RxSwift cache operator for Completable","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"54513269","1","54516793","","2019-02-04 09:30:37","","2","619","<p>I have a simple struct <code>Foo</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>struct Foo {
    let bar: String
}
</code></pre>

<p>Now I create an unbounded <code>ReplaySubject</code> of <code>Foo</code>s:</p>

<pre class=""lang-swift prettyprint-override""><code>let subject = ReplaySubject&lt;Foo&gt;.createUnbounded()
</code></pre>

<p>How can I now understand whether the (unterminated) stream has a <code>Foo</code> whose <code>bar</code> was equal to <code>abc</code>? (This could be the 1st, 3rd, or 20th element.)</p>
","751268","","","","","2019-02-04 18:55:37","How can I check all historic values in a ReplaySubject in RxSwift?","<rx-swift>","1","2","","","","CC BY-SA 4.0"
"54528841","1","","","2019-02-05 06:31:29","","0","155","<p>I want to create an abstract method which can return an Observable or Relay.</p>

<p>It gives me below error i.e. <code>use of undeclared type 'type'</code></p>

<p><a href=""https://i.stack.imgur.com/ovzbW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ovzbW.png"" alt=""enter image description here""></a></p>
","5744323","","","","","2019-02-05 06:31:29","How can I create abstract method to create BehaviorRelay in Swift?","<abstract><rx-swift>","0","4","","","","CC BY-SA 4.0"
"54530142","1","54583512","","2019-02-05 08:15:42","","0","378","<p>I'm having array of Bool Observables in Rxswift.</p>

<pre><code>let rxBoolObservableArray: [Observable&lt;Bool&gt;] = [Observable&lt;Bool&gt;]()
</code></pre>

<p>Now, How to get If any of the element is false?</p>
","2852281","","2852281","","2019-02-05 09:27:10","2019-02-08 09:42:35","Search a value in Array of Observable","<swift><rx-swift><rx-cocoa>","2","0","","","","CC BY-SA 4.0"
"54538757","1","54539339","","2019-02-05 16:22:40","","0","26","<p>So I was wondering while writing a viewModel using RxSwift if there is a way to combine bind and fold so you a signature like this </p>

<pre><code>someObservable.bind(someCondition, firstObserver,secondObserver)
</code></pre>

<p>it will be replace code like</p>

<pre><code>someObservable
    .filter { continionIsTrue }
    .bind(to: firstObserver)
    .disposed(by: disposeBag)

someObservable
    .filter { conditionIsFalse }
    .bind(to: secondObserver)
    .disposed(by: disposeBag)
</code></pre>
","7254877","","7254877","","2019-02-05 21:53:57","2019-02-05 21:53:57","Is there a way to convine Observable.bind and something like fold?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54540152","1","54542642","","2019-02-05 17:40:46","","0","442","<p>This is my first time using rxSwift</p>

<p>I've been trying to use rxswift to observe a data collection and update the view according but i'm doing something wrong</p>

<p>I made a timer to add an item to the data collection, which starts with 1 item by default, but the collection view doesn't seem to update.</p>

<pre><code>import Foundation
import UIKit
import MaterialComponents
import RxSwift
import RxCocoa

class MainFeedViewController : BaseViewController
{
    var loveData: [FeedDataModel] = []
    var collectionData : Observable&lt;[FeedDataModel]&gt;? = nil

    var collectionView : UICollectionView? = nil
    var cellId = ""FeedCollectionViewCell""

    let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        loadDummyData()

        initCollectionView()

        self.view.addConstraint(NSLayoutConstraint(item: self.view, attribute: .height, relatedBy: .equal, toItem: collectionView, attribute: .height, multiplier: 1, constant: 0))
        self.view.addConstraint(NSLayoutConstraint(item: self.view, attribute: .width, relatedBy: .equal, toItem: collectionView, attribute: .width, multiplier: 1, constant: 0))

    }

    private func initCollectionView()
    {
        collectionView = UICollectionView(frame: CGRect.zero, collectionViewLayout: UICollectionViewFlowLayout.init())
        collectionView!.register(UINib(nibName: cellId, bundle: nil), forCellWithReuseIdentifier: cellId)
        collectionView!.delegate = self
    //collectionView!.dataSource = self
        collectionView!.backgroundColor = UIColor.groupTableViewBackground
        collectionView?.translatesAutoresizingMaskIntoConstraints = false

        collectionData!.bind(to: collectionView!.rx.items(cellIdentifier: cellId))
        {
            _, data, cell in
            let a = cell as! FeedCollectionViewCell
            a.imgMAIN.downloaded(link: (data.image?.absoluteString)! )
            a.lblTitle.text = data.title

        }.disposed(by: disposeBag)

        collectionView?.rx.modelSelected(FeedDataModel.self).subscribe {
            next in
            }.disposed(by: disposeBag)

        self.view.addSubview(collectionView!)
    }

    override func viewDidAppear(_ animated: Bool)
    {
//        DispatchQueue.main.async {
//            self.collectionView?.reloadData()
//        }

        Timer.scheduledTimer(timeInterval: 5, target: self, selector: #selector(addObj), userInfo: nil, repeats: true)
    }

    private func loadDummyData()
    {
        addObj()
        collectionData = Observable.just(loveData)
    }

    @objc func addObj()
    {
        let obj1 = FeedDataModel.init(image: ""https://via.placeholder.com/150"",title: ""Placeholder"")

        print(""adding object"")
        loveData.append(obj1)
    }

}
</code></pre>

<p>can you point me in the right direction?</p>

<p>thank you</p>
","1174359","","","","","2019-02-05 20:45:42","RxSwift using a data collection","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54547588","1","","","2019-02-06 06:10:05","","0","101","<p>I have setup RX for photos permission like </p>

<pre><code>extension PHPhotoLibrary {
    static var authorize : Observable&lt;Bool&gt; {
        return  Observable&lt;Bool&gt;.create { (observer) -&gt; Disposable in


            if authorizationStatus() == .authorized {
                observer.onNext(true)
                observer.onCompleted()
            } else {
                requestAuthorization({ (handler) in
                    observer.onNext(handler == .authorized)
                    observer.onCompleted()
                })
            }


            return Disposables.create()

        }
}
</code></pre>

<p>In App Delegate I am asking for permission </p>

<pre><code>    let authorized = PHPhotoLibrary.authorize.share()
    authorized.skipWhile{$0 == false}
        .take(1)
        .subscribe(onNext: {[weak self] (authorized) in
           // Nothing here
        })
</code></pre>

<p>Now When I start App permission dialogue appears which all working fine
But when I put app in <strong>background</strong> and from settings <strong>manually toggle permission</strong> and when I back to app again app <strong>crashes</strong>  :(</p>

<p>Any help appreciated </p>
","4601900","","","","","2019-02-06 06:10:05","RXSwift App crashes When permission change from settings","<ios><permissions><rx-swift>","0","2","","2019-02-16 09:28:43","","CC BY-SA 4.0"
"54550265","1","","","2019-02-06 09:27:43","","0","237","<p>I'm an android developer but quite new to <code>Swift/Rxswift</code>, I was trying to code an equivalent for <a href=""https://github.com/googlesamples/android-architecture-components/blob/master/GithubBrowserSample/app/src/main/java/com/android/example/github/repository/NetworkBoundResource.kt"" rel=""nofollow noreferrer"">NetworkBoundResource</a> but I'm not sure it's possible to do it using <code>Rxswift</code> as it lacks the equivalent to MediatorLiveData and the merge operator wouldn't let you assign a closure for each observable.</p>

<p>Any clue?</p>
","11020370","","9883858","","2019-02-06 09:56:05","2019-02-07 10:56:10","NetworkBoundResource in RxSwift","<android><ios><swift><reactjs><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"54597414","1","54599082","","2019-02-08 17:22:01","","1","1925","<p>I have a static function calling a network service.
When the 400 response code happens I would like to redo the network call.</p>

<p>The current code is working, except that the refreshToken in the header does not update between one try and another.</p>

<p>I think that the problem is because the Observable created but the <strong>request function</strong> does not update at the retry.</p>

<p>I rode on the web that I should use a deferred method on the Observable, but I don't know how.</p>

<p>I've tried moving the code: <code>headers = [HeaderKeys.refreshToken.rawValue: ""test test""]</code> anywhere but still it never makes a call with the ""test test"" refresh token. it always uses the old one.</p>

<p>How can I fix this?</p>

<pre><code> static func getAccessToken() -&gt; Observable&lt;GetAccessTokenResponse&gt; {
            var retryCounter = 0
        let maxRetryCounter = 3
        let delayRetry = 10.0

        guard let refreshToken = NetworkHelper.shared.refreshToken else {
            return Observable.error(AuthenticationError.networkError)
        }

        var headers = [HeaderKeys.refreshToken.rawValue: refreshToken]


        return NetworkHelper.shared
            .request(url: CoreAPI.accessToken.url, request: nil, headers: headers, responseType: GetAccessTokenResponse.self, method: .get, encoding: nil)
            .catchError({ (error) -&gt; Observable&lt;(GetAccessTokenResponse?, Int)&gt; in
                return Observable.error(AuthenticationError.networkError)
            })
            .flatMap({ (response) -&gt; Observable&lt;GetAccessTokenResponse&gt; in
                // check http status code
                switch response.1 {
                case 200:
                    guard response.0?.accessToken != nil else {
                        return Observable.error(AuthenticationError.genericError)
                    }
                    // success
                    return Observable.just(response.0!)
                case 400:
                    // invalid parameters, refresh token not existing
                    return Observable.error(AuthenticationError.invalidParameters)
                case 404:
                    // user not existing
                    return Observable.error(AuthenticationError.userDoesntExist)
                default:
                    // by default return network error
                    return Observable.error(AuthenticationError.networkError)
                }
            })
            .retryWhen({ (errors) -&gt; Observable&lt;Void&gt; in
                return errors
                    .do(onNext: { (error) in
                        headers = [HeaderKeys.refreshToken.rawValue: ""test test""]
                    })
                    .flatMap({error -&gt; Observable&lt;Int&gt; in
                        debugLog(""Retrying get refresh token"")
                        if retryCounter &gt;= maxRetryCounter {
                            let authError = error as? AuthenticationError ?? .genericError
                            if authError == AuthenticationError.invalidParameters {
                                // publish logged false on subject
                                VDAAuthenticationManager.shared.logged.onNext(false)
                            }
                            return Observable.error(error)
                        }
                        // increase the retry counter and retry
                        retryCounter += 1
                        return Observable&lt;Int&gt;.timer(delayRetry, scheduler: MainScheduler.instance)
                })
                .flatMap ({ (_) -&gt; Observable&lt;Void&gt; in
                    return Observable.just(())
                })
            })
    }
</code></pre>
","6747915","","6747915","","2019-02-08 19:15:06","2021-05-08 15:03:15","iOS rxSwift: retryWhen updating refresh token","<ios><swift><rx-swift>","1","0","2","","","CC BY-SA 4.0"
"54604265","1","","","2019-02-09 07:43:54","","1","1231","<p>I am using MVVM pattern with <a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow noreferrer"">RxSwift</a>, <a href=""https://github.com/ReactiveX/RxSwift/tree/master/RxCocoa"" rel=""nofollow noreferrer"">RxCocoa</a>, <a href=""https://github.com/RxSwiftCommunity/RxDataSources"" rel=""nofollow noreferrer"">RxDataSources</a>.</p>

<p><a href=""https://i.stack.imgur.com/3bJgP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3bJgP.png"" alt=""enter image description here""></a></p>

<p>I have successfully populated the <code>UITableView</code> with array of <code>PaletteViewModel</code> present in <code>ListViewModel</code> by using <code>RxDataSource</code> but it's one way binding.</p>

<p>I want to achieve what I have shown in the picture i.e. I want to bind the <code>UITextField</code> from <code>UITableViewCell</code> to the <code>Observable</code> which is present at some index in the array in <code>ListViewModel</code></p>

<p>I want to do <code>2 way binding</code> with the <code>UITextField</code> and <code>answer</code> property of the <code>PaletteViewModel</code>. If the user changes the text in the textField it should change the value in the answer property present at particular index and vice versa.</p>

<p>How Can I achieve something complex like this using <code>MVVM pattern</code> using <a href=""http://reactivex.io/"" rel=""nofollow noreferrer""><code>ReactiveX</code></a> frameworks? </p>

<p>What if the <code>UITableViewCell</code> at some <code>IndexPath</code> is removed from the memory as it's not visible and the observable's value is changed will it result in crash as the <code>UITextField</code> at that <code>IndexPath</code> will return nil?</p>
","5744323","","","","","2019-02-10 02:39:50","2 way binding in UITableView using RxSwift","<uitableview><rx-swift><2-way-object-databinding><rx-cocoa><rxdatasources>","1","4","","","","CC BY-SA 4.0"
"54606288","1","54607795","","2019-02-09 12:38:08","","1","1438","<p>I'm trying to fetch some data from the network whenever the location of my user changes. </p>

<pre><code>struct CityService {
  private init() {}

  static let shared = CityService()

  lazy var nearbyCities: Driver&lt;[City]&gt; = {
    return GeolocationService.instance.location
      .flatMapLatest({ coordinate in
        let location = CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude)
        return CityService.shared.fetchNearbyCitiesFor(location)
      }).asDriver(onErrorJustReturn: [])
  }()

  func fetchNearbyCitiesFor(_ location: CLLocation) -&gt; Observable&lt;[City]&gt; {
    return Observable.create { observer in
      let disposable = Disposables.create()

      // Mock a fetch from the network:
      let cities = [City(name: ""Amsterdam""), City(name: ""Berlin"")]
      observer.onNext(cities)
      observer.on(.completed)

      return disposable
    }
  }
}

class GeolocationService {
  static let instance = GeolocationService()
  private (set) var location: Driver&lt;CLLocationCoordinate2D&gt;
}
// from: https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Services/GeolocationService.swift

struct City {
  let name: String
}
</code></pre>

<p>However, this is not compiling, due to:</p>

<pre><code>Cannot convert value of type 'SharedSequence&lt;DriverSharingStrategy, [Any]&gt;' to specified type 'Driver&lt;[City]&gt;'
(aka 'SharedSequence&lt;DriverSharingStrategy, Array&lt;City&gt;&gt;')
</code></pre>

<p>I've also tried to add some Type hinting to get a better error:</p>

<pre><code>lazy var nearbyCities: Driver&lt;[City]&gt; = {
  return GeolocationService.shared.location
  .flatMapLatest({ coordinate -&gt; Observable&lt;[City]&gt; in
    let location = CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude)
    let nearbyCities: Observable&lt;[City]&gt; = CityService.shared.fetchNearbyCitiesFor(location)
    return nearbyCities.catch
  }).asDriver(onErrorJustReturn: [City]())
}()
</code></pre>

<p>But all that gives me is: </p>

<pre><code>Cannot convert value of type '(_) -&gt; Observable&lt;[City]&gt;' to expected argument type '(CLLocationCoordinate2D) -&gt; SharedSequence&lt;_, _&gt;'
</code></pre>

<p>What am I doing wrong here?</p>
","672989","","","","","2019-02-09 15:40:02","How to use flatMapLatest on a driver with RxSwift","<swift><reactive-programming><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"54616586","1","54620629","","2019-02-10 12:51:48","","2","656","<p>after presenting new UIViewController by code, every where(in viewModel or viewController) using .Drive, I get this error:
<code>drive* family of methods can be only called from MainThread</code></p>

<p>this is how I present new ViewController:</p>

<pre><code>func goToVerifyPage() {

    let verifyVC = VerifyViewController()
    verifyVC.modalTransitionStyle = .flipHorizontal
    self.present(verifyVC, animated: true, completion: nil)
}
</code></pre>

<p>and inside VerifyViewController:</p>

<pre><code>override func viewDidLoad() {
        super.viewDidLoad()

        confirmVerifyCodeBTN.rx.tap
            .asDriver()
            .debounce(1)
            .filter({
                self.viewModel.signupEnabled
            })
            .drive(onNext:{  [weak self] _ in
                guard let verifyCode = self?.verificationCodeTF.text  else { return }
                self?.verifyActivateCode(verifyCode)
            }).disposed(by: disposeBag)
}
</code></pre>

<p>the error showed after execute .filter line.</p>

<p>in the previos viewController(named loginViewController) I use the same codes but did not getting any error, the only thing that's different between verifyViewController and loginViewController is, using storyboard to presenting that ViewController(loginViewController).</p>

<p><strong>update:</strong> 
when I using this codes for presenting verifyViewController every things going fine:</p>

<pre><code>func goToVerifyPage() {
        DispatchQueue.main.async {
            let verifyVC = VerifyViewController()
            verifyVC.modalTransitionStyle = .flipHorizontal
            self.present(verifyVC, animated: true, completion: nil)
        }
}
</code></pre>
","8425034","","8425034","","2019-02-10 13:02:09","2019-02-10 20:19:55","drive can be only called from MainThread","<ios><rx-swift>","1","6","","","","CC BY-SA 4.0"
"54617344","1","54620660","","2019-02-10 14:26:46","","1","678","<p>I’m new to RxSwift and I’m looking for a basic example of how to print in console live data streaming from an backend. I have a backend which is streaming some dummy data every 1 second, I can see it with a curl request and I want to be able to observe and subscribe and print it out in console automatically, please help!</p>
","7272763","","","","","2019-02-11 16:20:28","Reactive Swift consume live data from API - need basic example","<rx-swift><rx-cocoa><reactive-swift>","2","0","","","","CC BY-SA 4.0"
"54672288","1","54675510","","2019-02-13 14:15:26","","0","90","<p>I have an application where I am using Firebase and RxSwift. I am getting snapshot from a ref and the issue I have now is the ref could be null i.e it does not exist. how do I still make my code run to by pass the null reason</p>

<p>if Null, I should call onCompleted.</p>

<pre><code>func refreshActiveTrip() -&gt; Observable&lt;Trip&gt; {

        guard let trip = getCurrentTrip()  else {
            return Observable.error(RxError.noElements)
        }

        tripRef = Database.database().reference(forTransportChampionId: (getChampion()?.id)!, tripId: trip.id!)
        return Observable&lt;Trip&gt;.create({ (observer) -&gt; Disposable in

            let disposable = Disposables.create {
                self.tripRef?.removeAllObservers()
            }

            self.tripRef?.observeSingleEvent(of: .value, with: { (snapshot) in
                if snapshot.exists(){

                    if let data = snapshot.value as? [String: AnyObject] {

                        let trip = Trip(dictionary: data as NSDictionary)
                        print(""SPLASH TRIP CURRENT \(data)"")

                        self.saveCurrentTrip(trip)
                        observer.onNext(trip)
                        observer.onCompleted()

                    }
                    print(""It exists!!"")
                }else{
                    let trip = Trip()
                    self.saveCurrentTrip(trip)
                    print(""Nope, doesn't exist!"")
                }
            })

            return disposable
        })

    }
</code></pre>

<p>the <code>tripRef</code> could be null</p>
","8310287","","209103","","2019-02-13 15:17:58","2019-02-13 19:00:43","Handling Null ref from firebase","<swift><firebase><firebase-realtime-database><rx-swift>","2","0","","","","CC BY-SA 4.0"
"54738064","1","54738870","","2019-02-17 21:55:01","","0","198","<p>I want to make a validated network request using Alamofire, through a 'generic' function. 
If I don't use RX at all or if I don't call validate() or anyCustomValidate() it works fine, but if I use it with the Observable.create and validate() as below, it does not work.
This is what it does instead:</p>

<pre><code>     1.makes tokenRefresh call
     2.receives the new token
     3.calls completion(true, 0.0) (as below)
</code></pre>

<p>but then nothing happens...</p>

<p>Here is my generic function:</p>

<pre><code>func sendRequest&lt;Response: Codable&gt;(endpoint: URLRequestConvertible) -&gt; Observable&lt;Response&gt; {
    return Observable&lt;Response&gt;.create { observer in
        let request = self.session.request(endpoint)
            .validate()
            .responseJSON { response in
                print(response)
                switch response.result {
                case .success:
                    do {
                        let model = try JSONDecoder().decode(Response.self, from: response.data!)
                        observer.onNext(model)
                    } catch {
                        print(""generic call function error: \(error)"")
                        observer.onError(RequestError.failedParsingError(ErrTypes.somethingWrong.rawValue))
                    }
                case .failure:
                observer.onError(RequestError.failedParsingError(ErrTypes.somethingWrong.rawValue))
                }
        }
        return Disposables.create {
            request.cancel()
        }
    }.observeOn(MainScheduler.instance)
}
</code></pre>

<p>This is how I use it to get a specific response:</p>

<pre><code>func getAddresses(clientId: Int) -&gt; Observable&lt;[AddressesResponse]&gt; {
    return sendRequest(endpoint: CustomerEndPoint.getAddresses(userID: clientId))
}
</code></pre>

<p>And this is how I call the function:</p>

<pre><code> @objc func buttonPressed() {
    getAddresses(clientId: 1111).subscribe(onNext: { addresses in
        print(addresses)
    }).disposed(by: disposeBag)
}
</code></pre>

<p>This is my Request retrier:</p>

<pre><code>extension AuthHandler: RequestRetrier {

func should(_ manager: SessionManager, retry request: Request, with error: Error, completion: @escaping RequestRetryCompletion) {
    guard let request = request as? DataRequest, request.delegate.data != nil else { fatalError() }
    guard let headerStatusCode = request.response?.statusCode else {
        completion(false, 0.0)
        return
    }
    if headerStatusCode == 401 || headerStatusCode == 403 {
        refreshToken(success: {
            completion(true, 0.0)
        }, failure: { message in
            print(message)
        })
    } else {
        if let json = String(data: request.delegate.data!, encoding: String.Encoding.utf8),
        let jsonObject = dictionaryWithJSONString(json) as? [String:Any],
        let statusMessage = jsonObject[""statusMessage""] as? [String: Any],
        let status = statusMessage[""status""] as? Int {
            if status == 401 || status == 403 {
                self.refreshToken(success: {
                    completion(true, 0.0)
                }, failure: { message in
                    completion(false, 0.0)
                    print(message)
                })
            }
        }
    }
}
</code></pre>

<p>After a while this gets printed on the console log:</p>

<pre><code>2019-02-17 22:25:13.368846+0100 AlamofireValidator[76262:1527976] [BoringSSL] nw_protocol_boringssl_get_output_frames(1301) [C1.1:2][0x7fc5cf50e020] get output frames failed, state 8196
</code></pre>
","7551405","","","","","2019-02-18 00:02:08","Observable.create inside generic Alamofire call function not working when calling validate()","<swift><alamofire><rx-swift><request-validation>","1","0","","","","CC BY-SA 4.0"
"54745255","1","54747422","","2019-02-18 10:33:19","","0","409","<pre><code>extension Observable {
    func dispatchAsyncMainScheduler() -&gt; Observable&lt;E&gt; {
        return self.observeOn(backgroundScheduler).observeOn(MainScheduler.instance)
    }
}
</code></pre>

<p>I found this snippet in <a href=""https://github.com/artsy/eidolon"" rel=""nofollow noreferrer"">https://github.com/artsy/eidolon</a></p>

<p>I am a <code>reactive</code> beginner here. From what I understand. <code>subscribeOn</code> applies to the whole chain whereas the <code>observeOn</code> applies operators below it.</p>

<p>My question is quite obvious, what exactly does this two consecutive <code>observeOn</code> do at all?</p>
","7591205","","","","","2019-02-18 12:34:29","Question about a custom RxSwift Observable extension","<ios><swift><rx-swift><reactivex>","2","0","","","","CC BY-SA 4.0"
"54757013","1","54763438","","2019-02-18 23:47:56","","0","288","<p>I'm very new to RxSwift. Very new. Normally to chain you without Rx, you put the next function inside a completion closure. My peers told me to use flatmap or our version of concatmap instead but never gave me an example. Can anybody convert this code with flatmap or the swift version of concatmap? Again I am very new, so please be gentle with the judgements. </p>

<pre><code> SVProgressHUD.show()
    params.address = address
    print(params)
    viewmodel
      .postSeekerAvatar(image: image).subscribe(onSuccess: {
//        SVProgressHUD.dismiss()
//        SVProgressHUD.show()
        self.viewmodel
          .updateSeeker(withFirstName: params.firstName, lastName: params.lastName, isBusiness: params.isBusiness, abn: ""none"", address: params.address)
          .subscribe(onSuccess: {
            SVProgressHUD.dismiss()

        self.performSegue(withIdentifier: SegueConstants.toProfileForm, sender: self)

      }) { (error) in
        SVProgressHUD.showDismissableError(with: error.message)
      }.disposed(by: self.disposeBag)
  }) { (error) in
    SVProgressHUD.showDismissableInfo(with: error.message)
  }.disposed(by: disposeBag)
</code></pre>
","5100250","","1226963","","2019-02-18 23:48:26","2019-02-19 10:00:15","RxSwift Chaining: What is a better way of writing this in Rxswift?","<swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"54757839","1","54764550","","2019-02-19 02:02:33","","0","459","<p>I am very new to RxSwift and trying to do the following:</p>

<p>My application needs to enable selection of ""Elements"" where the selection mode can be <code>single</code> selection (a new selection replaces an old selection) or <code>multiple</code>, where a selection is added to any old selection.</p>

<p>In <code>single</code> mode, if the new selection is the old selection, then my selection results must become empty (toggles the selection by selecting the same element).</p>

<p>In <code>multiple</code> mode, if the new selection is part of the old selection, the newly selected element is removed from the current selection.</p>

<p>I have three existing subjects: <code>selectionModeSubject</code> is a <code>BehaviorSubject</code> containing the <code>single</code> or <code>multiple</code> enumeration. <code>selectSubject</code> represents the new selection requested by the user, it is a <code>PublishSubject</code>. Finally, <code>currentSelectionSubject</code>, a <code>BehaviorSubject</code> containing the current Set of elements that are selected.</p>

<p>I'm trying to have <code>currentSelectionSubject</code> containing the resulting selection after <code>selectSubject</code> fires.</p>

<p>Here is what I have:</p>

<pre><code>Observable
        .combineLatest(selectionModeSubject, selectSubject, currentSelectionSubject) { (mode, newSelection, currentSelection) -&gt; Set&lt;Element&gt; in
            switch mode {
            case .single:
                if currentSelection.contains(newSelection) {
                    return Set([newSelection])
                } else {
                    return Set&lt;Element&gt;()
                }
            case .multiple:
                if currentSelection.contains(newSelection) {
                    return currentSelection.filter({ (element) -&gt; Bool in
                        return element != newSelection
                    })
                } else {
                    return currentSelection.union(Set([newSelection]))
                }
            }
        }
        .bind(to: currentSelectionSubject)
        .disposed(by: disposeBag)
</code></pre>

<p>The problem, amplified by my newbie RxSwift status, is that this observation code potentially fires whenever the <code>selectionModeSubject</code> or <code>currentSelectionSubject</code> fire. I would only want this to fire if <code>selectSubject</code> is changed.</p>

<p>I have tried to insert a <code>.distinctUntilChanged()</code> on the <code>selectSubject</code> but I cannot seem to come to grasp with it.</p>

<p>Any tips would be appreciated.</p>
","6929003","","","","","2019-02-19 10:54:07","How to combineLatest only when a particular Observable has changed","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54762921","1","54767254","","2019-02-19 09:35:08","","5","3470","<p>I read some post says that the best practice to deal with RxSwift is to only pass fatal error to the onError and pass Result to the onNext.</p>

<p>It makes sense to me until I realise that I can't deal with retry anymore since it only happen on onError. </p>

<p>How do I deal with this issue?</p>

<p>Another question is, how do I handle global and local retry mixes together?</p>

<p>A example would be, the iOS receipt validation flow.</p>

<p>1, try to fetch receipt locally</p>

<p>2, if failed, ask Apple server for the latest receipt.</p>

<p>3, send the receipt to our backend to validate.</p>

<p>4, if success, then whole flow complete</p>

<p>5, if failed, check the error code if it's retryable, then go back to 1.</p>

<p>and in the new 1, it will force to ask for new receipt from apple server. then when it reaches 5 again, the whole flow will stop since this is the second attempt already. meaning only retry once.</p>

<p>So in this example, if using state machine and without using rx, I will end up using state machine and shares some global state like <code>isSecondAttempt: Bool</code>, <code>shouldForceFetchReceipt: Bool</code>, etc. </p>

<p>How do I design this flow in rx? with these global shared state designed in the flow. </p>
","7591205","","474173","","2019-02-19 13:27:32","2019-02-19 13:27:32","What is the best practice to deal with RxSwift retry and error handling","<ios><swift><error-handling><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"54765125","1","54771843","","2019-02-19 11:21:20","","1","541","<p>I have a login screen, I was showing previously error input above textfield and disable button by combining email/password Bool Observable, however now the design is changed and I want to check if email/password are not empty before sending the request or show alert dialog </p>

<p>My issue is with how to validate inputs are valid before hitting the request:</p>

<p>LoginViewModel:</p>

<pre><code>  var emailValid: Observable&lt;Bool&gt; {
        return emailSubject.asObservable().map { $0.count &gt; 0 &amp;&amp; $0.isEmail}
    }

  signInDidTapSubject
       .withLatestFrom(credentialsObservable)
        .flatMapLatest { credentials -&gt; Observable&lt;Event&lt;Result&lt;UserResponse&gt;&gt;&gt; in
            self.loadInProgress.accept(true)
            return network.login(with: credentials).materialize()
        }
        .subscribe(onNext: { [weak self] event in
            self?.loadInProgress.accept(false)
            switch event {
            case .next(let result):
                switch result{
                case .Success(let user):
                    self?.loginResultSubject.onNext(user)
                case .Failure(let error):
                    self?.errorsSubject.onNext(error)
                }
            case .error( _):
                print(""error"")
            default:
                break
            }
        })
        .disposed(by: disposeBag)
</code></pre>

<p>VC:</p>

<pre><code>   loginButton.rx.tap.asObservable()
        .debounce(0.5, scheduler: MainScheduler.instance)
        .subscribe(viewModel.input.loginButtonTapped).disposed(by: disposeBag)
</code></pre>
","4700622","","","","","2019-02-19 17:27:58","Rxswift validate inputs before sending api request","<swift><mvvm><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54780416","1","54785612","","2019-02-20 06:49:14","","1","53","<p>Is there a way to return a transformed BehaviorSubject?</p>

<pre><code>class ViewModel {
    let username: BehaviorSubject&lt;String&gt;

    init() {
        // I want username to emit trimmed values...
        username = BehaviorSubject&lt;String&gt;(value: """")
            // ... but map returns an Observable&lt;&gt;, not BehaviorSubject
            .map { $0.trimmingCharacters(in: CharacterSet.whitespaces) 
    }
}
</code></pre>
","62178","","","","","2019-02-20 11:45:27","BehaviorSubject with transformation","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"54787134","1","","","2019-02-20 13:09:31","","0","189","<p>Use case:</p>

<p>I have a favorite button, when it's favorited I press it again it changes to unfavorite and removes the record. When I re-favorite it it should insert the object again but it accuses this error below</p>

<p>Crash with error:</p>

<pre><code>2019-02-20 09:58:44.348244-0300 Project[3851:768454] *** Terminating app due to uncaught exception 'RLMException', reason: 'Attempting to modify object outside of a write transaction - call beginWriteTransaction on an RLMRealm instance first.'
*** First throw call stack:
(0x1babecec4 0x1b9dbda40 0x101681788 0x101683208 0x100565728 0x1006aea94 0x1006aeae4 
libc++abi.dylib: terminating with uncaught exception of type NSException
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>struct FavoriteTool {
    private let disposeBag = DisposeBag()
    var didLoadFavorites: (([Tool]) -&gt; Void)?
private let disposeBag = DisposeBag()
    var didLoadFavorites: (([Tool]) -&gt; Void)?
    func isFavorite(favoriteTool: FavoriteTool) -&gt; Observable&lt;Results&lt;FavoriteTool&gt;&gt; {
        return favorites(filter: ""id == '\(favoriteTool.id)'"")
    }

    func favorite(favoriteTool: FavoriteTool) {
        Observable.just(favoriteTool)
            .subscribe(Realm.rx.add())
            .disposed(by: disposeBag)
    }

    func unfavorite(favoriteTool: FavoriteTool) {
        favorites(filter: ""id == '\(favoriteTool.id)'"")
            .subscribe(Realm.rx.delete())
            .dispose()
    }

    func favorites(filter predicateFormat: String? = nil) -&gt; Observable&lt;Results&lt;FavoriteTool&gt;&gt; {
        guard let realm = try? Realm() else {
            return Observable.empty()
        }
        var results: Results&lt;FavoriteTool&gt; = realm.objects(FavoriteTool.self)
        if let predicate = predicateFormat {
            results = results.filter(predicate)
        }

        return Observable.collection(from: results)
    }
}
</code></pre>
","9182446","","","","","2019-02-20 13:09:31","Realm.rx.delete() and Realm.rx.add() crash with same object","<swift><realm><rx-swift>","0","4","","","","CC BY-SA 4.0"
"54812142","1","","","2019-02-21 16:41:52","","0","130","<p>I try to implement the collapse/expand system for table view sections. When the user tapped on the section header, then it will inserts cells into section when tapped one more time on the same section header then it will deleting cells from section making ""collapse"" effect. </p>

<p>The problem is when I try to expand more than 2 sections starting from the bottom. Tapping section which has at least one cell shift whole content without animation to lower section position.</p>

<p>I use auto-layout from code and RxDataSource.</p>

<p>Here is how I bind data source:</p>

<pre><code>    let dataSourceForPurchasersList = RxTableViewSectionedAnimatedDataSource&lt;AnimatableSectionModel&lt;ExpandableSectionModel, CustomerCellModel&gt;&gt;(configureCell: { (dataSource, tableView, indexPath, cellModel) -&gt; UITableViewCell in
        let cell = tableView.dequeueReusableCell(withIdentifier: GuestTableViewCell.reuseIdentifier, for: indexPath) as? GuestTableViewCell
        cell?.setupCell(model: cellModel)
        return cell ?? UITableViewCell()
    })

    viewModel.dataSourceBehaviorPurchasersList
        .bind(to: self.ordersTableView.rx.items(dataSource: dataSourceForPurchasersList))
        .disposed(by: self.disposeBag)
</code></pre>

<p>Here is how I handle section expand:</p>

<pre><code>func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? {
    guard let viewModel = self.viewModel else { return nil }
    let header = tableView.dequeueReusableHeaderFooterView(withIdentifier: CustomersSectionHeader.reuseIdentifier) as? CustomersSectionHeader

...


    guard let models = try? modelsBehavior.value() else { return nil }

    let dataSourceSectionModel = models[section]
    header?.configView(model: dataSourceSectionModel)

    header?.tapClosure = { [weak modelsBehavior, weak header] in
        dataSourceSectionModel.expanded = !dataSourceSectionModel.expanded
        header?.updateSelectorImageView()
        modelsBehavior?.onNext(models)
    }

    return header
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/wvcyc.gif"" rel=""nofollow noreferrer"">Presenting the problem</a></p>

<p>@edit</p>

<p>Solution:</p>

<p>I observed that the shift of content is equal to the section header height by implementing <code>scrollViewDidScroll(_ scrollView: UIScrollView)</code> function  and it depends on the table view internal logic. I set headerHeight and estimatedHeight of the section header to equal value then I used this code:</p>

<pre><code>func scrollViewDidScroll(_ scrollView: UIScrollView) {
    let divValue: CGFloat
    if self.guestsTableView.delegate === scrollView.delegate {
        divValue = self.guestsTableView.estimatedSectionHeaderHeight
    } else {
        divValue = self.ordersTableView.estimatedSectionHeaderHeight
    }

    let diff = abs(self.scrollViewOffsetLastY - scrollView.contentOffset.y)
    let rest = diff.truncatingRemainder(dividingBy: divValue)
    if rest == 0 {
        scrollView.contentOffset.y = self.scrollViewOffsetLastY
    }
    self.scrollViewOffsetLastY = scrollView.contentOffset.y
}
</code></pre>
","4587754","","4587754","","2019-02-26 13:18:46","2019-02-26 13:18:46","TableView skipping when exapnded section cells","<ios><swift><uitableview><uikit><rx-swift>","0","3","","","","CC BY-SA 4.0"
"54815530","1","54817371","","2019-02-21 20:15:55","","2","1126","<p>I have a <code>BehaviorRelay</code> setup to store an array of addresses, and then I observe that <code>BehaviorRelay</code> so that I can create an <code>MKAnnotation</code> array and then display that on the map.</p>

<pre><code>let addresses = BehaviorRelay&lt;[Address]&gt;(value: [])
</code></pre>

<p>I make network requests when the user moves the map to a new area.
If the user moves the map very quickly, I can end up with several network requests</p>

<p>I only want the latest response.</p>

<p>This is where my problem begins.</p>

<pre><code>    addresses.asObservable().subscribe(onNext: { [unowned self] (value) in
        self.fetchAllAnnotationsAndAddToMap()
    }).disposed(by: disposebag)
</code></pre>

<p><code>fetchAllAnnotationsAndAddToMap</code>gets called every time addresses is set.</p>

<p><code>fetchAllAnnotationsAndAddToMap</code> can take a long time to complete. Requests to run <code>fetchAllAnnotationsAndAddToMap</code>get stacked up and all of them run to completion.</p>

<p>What I want to happen is once <code>addresses</code> is set again, I want for all former calls to be discarded and only use the latest.</p>

<p>I've heard this is what <code>flatMapLatest</code> is for.</p>

<p>However, flatMapLatest requires I return an observable and I'm confused by that.</p>

<p>How do I cancel the methods called after the <code>BehaviorRelay</code> is updated and only use the most recent?</p>
","3786510","","","","","2019-02-23 14:43:21","RxSwift BehaviorRelay cancel previous calls, only use the most recent","<swift><reactive-programming><rx-swift>","2","0","","","","CC BY-SA 4.0"
"54818076","1","54823913","","2019-02-21 23:59:20","","0","1252","<p>I am currently implementing a MVVM (using Rx) architecture for a new application written in Swift and I am struggling when writing a  ViewModel.</p>

<p>This is the beginning of it:</p>

<pre><code>class GameViewModel {
    public let input: Input
    public let output: Output

    public struct Input {
        let slider: AnyObserver&lt;Float&gt;
        let buttonCLicked: AnyObserver&lt;Void&gt;
    }

    public struct Output {
        let slider: Observable&lt;Float&gt;
        let target: Observable&lt;Int&gt;
        let score: Observable&lt;Int&gt;
        let round: Observable&lt;Int&gt;
        let buttonCLicked: Observable&lt;AlertProperties&gt;
    }

    private var slider = BehaviorSubject&lt;Float&gt;(value: 0)
    private var buttonCLicked = PublishSubject&lt;Void&gt;()
    private var target = BehaviorSubject&lt;Int&gt;(value: 0)
    private var score = BehaviorSubject&lt;Int&gt;(value: 0)
    private var round = BehaviorSubject&lt;Int&gt;(value: 0)

    private let disposebag: DisposeBag
    private var model: Game!

    init(game: Game?) {
        disposebag = DisposeBag()

        input = Input(slider: slider.asObserver(),
                      buttonCLicked: buttonCLicked.asObserver())

        output = Output(slider: slider.asObservable(),
                        target: target.asObservable(),
                        score: score.asObservable(),
                        round: round.asObservable(),
                        buttonCLicked: buttonCLicked.map { [weak self] _ in
                            guard let self = self else {
                                return AlertProperties(title: ""Fail"",
                                                       message: ""!!!"",
                                                       buttonTitle: ""Ok"",
                                                       handler: nil)
                            }
                            return self.getAlertProperties() })

        model = game ?? initDefaultGame()

        slider.onNext(Float(model.slider))
        target.onNext(model.target)
        score.onNext(model.score)
        round.onNext(model.round)
    }
</code></pre>

<p>and this is a basic function taking current values for creating an object to return:</p>

<pre><code>    func getAlertProperties() -&gt; AlertProperties {
        guard let targetValue = try? target.value(),
            let currentValue = try? slider.value() else {
            return AlertProperties(title: ""Fail"",
                                   message: ""!!!"",
                                   buttonTitle: ""Ok"",
                                   handler: nil)
        }

        // some code

        return AlertProperties(title: title,
                               message: ""\(points) points: \(castCurrentValue)"",
                               buttonTitle: ""Ok"",
                               handler: {
                                   self.target.onNext(self.getRandomValue())
                                   self.slider.onNext(50.0)
        })
    }
</code></pre>

<p>What I am trying to do here is register my inputs and outputs on my init function. And for the output part I would like to transmit the result of a function with some current values (<em>getAlertProperties</em>).
Basically I have a trigger on my ViewController which need these values to show in a AlertController when the user click on a simple button.</p>

<p>I get the error message <strong>Variable 'self.xxx' used before being initialized""</strong> for the buttonClicked declaration in my Output. I get that I need to initialize every non optional properties before using <em>self</em> but I thought that maybe using guards would do the trick. Apparently not...</p>

<p>How can I fix this without making my properties <em>input</em> and <em>output</em> optionals ?</p>

<p>Thank you</p>
","8718924","","8718924","","2019-02-22 08:56:28","2019-02-22 09:28:52","Get a ""Variable 'self.xxx' used before being initialized"" even after guard self and non optional properties","<swift><mvvm><rx-swift><coordinator-pattern>","1","3","","","","CC BY-SA 4.0"
"54834452","1","","","2019-02-22 20:09:03","","1","2851","<p>I need to call a sequences of function to get all the information I need for a notification. First subscribe which opens up the session, then <code>queryNotification</code> to listen on all the incoming notifications, and once a notification is received, need to call <code>getNotificationAttrs</code> with the <code>notificationId</code> returned in <code>queryNotification</code>, then call <code>getAppAttributes</code> with <code>appIdentifier</code> returned in <code>getNotificationAttrs</code> and I need the combined result of <code>queryNotification</code>, <code>getNotificationAttrs</code> and <code>getAppAttributes</code>. How the functions look like are below:</p>

<pre><code>func subscribeNotification() -&gt; Single&lt;Info&gt;
func queryNotification() -&gt; Observable&lt;Notification&gt;
func getNotificationAttrs(uid: UInt32, attributes: [Attribute]) -&gt; Single&lt;NotificationAttributes&gt;
func getAppAttributes(appIdentifier: String, attributes: [AppAttribute]) -&gt; Single&lt;NotificationAppAttributes&gt;
</code></pre>

<p>The tricky part is that <code>queryNotification</code> returns Observable and both <code>getNotificationAttrs</code> and <code>getAppAttributes</code> return Single. What I have in mind of chaining them together is like:</p>

<pre><code>subscribeNotification()
    .subscribe(onSuccess: { info in
        queryNotification()
            .flatMap({ notification in 
                return getNotificationAttributes(uid: notification.uid, attributes: [.appIdentifier, .content])
            })
            .flatMap({ notifAttrs
                return getAppAttributes(appIdentifier: notifAttrs.appIdentifier, attributes: [.displayName])
            })
            .subscribe {
                // have all the result from last two calls
            }
       })
</code></pre>

<p>Is this doable? Any direction is appreciated! Thanks!</p>
","1580594","","1580594","","2019-02-22 21:37:34","2019-02-25 18:46:40","RxSwift - Chaining Observables and Singles","<swift><reactive-programming><rx-swift><chaining><method-chaining>","1","1","1","","","CC BY-SA 4.0"
"54835769","1","","","2019-02-22 21:58:51","","3","270","<p>I have a tab coordinator that extends from a parent coordinator; i want to assign a delegate to the UITabViewController; but when i do it, it doesn't trigger anything; but if i have a breakpoint in the init function of my coordinator; it will work as expected. My brain is going to explode because i don't know where to search the bug, as it is working as expected when XCODE does have a breakpoint.</p>

<pre class=""lang-swift prettyprint-override""><code>  import RxSwift

enum HomeRoutes: Route{
  case explore
  case swaps
  case post
  case notifications
  case profile
}


class HomeCoordinator: ViewCoordinator&lt;HomeRoutes&gt; {

  typealias Dependencies =  HasUserManager &amp; HasItemService

  // MARK: - Stored properties
  private let viewDelegate = CrowdswapTabDelegate()
  private let disposeBag = DisposeBag()

  convenience init(dependencies: Dependencies) {

    //Create Tabs
    let exploreTab = ExploreCoordinator(dependencies: dependencies)
    exploreTab.rootViewController.navigationBar.isHidden = true
    exploreTab.rootViewController.tabBarItem = UITabBarItem(title: nil, image: #imageLiteral(resourceName: ""explore""), selectedImage: nil)
    exploreTab.rootViewController.tabBarItem.imageInsets = UIEdgeInsets(top: 6, left: 0, bottom: -6, right: 0)

    let swapsTab = SwapsCoordinator(dependencies:dependencies)
    swapsTab.rootViewController.navigationBar.isHidden = true
    swapsTab.rootViewController.tabBarItem = UITabBarItem(title: nil, image: #imageLiteral(resourceName: ""swaps""), selectedImage: nil)
    swapsTab.rootViewController.tabBarItem.imageInsets = UIEdgeInsets(top: 6, left: 0, bottom: -6, right: 0)

    let postTab = PostCoordinator(dependencies: dependencies)
    postTab.rootViewController.navigationBar.isHidden = true
    postTab.rootViewController.tabBarItem = UITabBarItem(title: nil, image: #imageLiteral(resourceName: ""upload""), selectedImage: nil)
    postTab.rootViewController.tabBarItem.imageInsets = UIEdgeInsets(top: 6, left: 0, bottom: -6, right: 0)


    let notificationTab = NotificationCoordinator()
    notificationTab.rootViewController.navigationBar.isHidden = true
    notificationTab.rootViewController.tabBarItem = UITabBarItem(title: nil, image: #imageLiteral(resourceName: ""notifications""), selectedImage: nil)
    notificationTab.rootViewController.tabBarItem.imageInsets = UIEdgeInsets(top: 6, left: 0, bottom: -6, right: 0)

    let profileTab = ProfileCoordinator(dependencies: dependencies)
    profileTab.rootViewController.navigationBar.isHidden = true
    profileTab.rootViewController.tabBarItem = UITabBarItem(title: nil, image: #imageLiteral(resourceName: ""profile""), selectedImage: nil)
    profileTab.rootViewController.tabBarItem.imageInsets = UIEdgeInsets(top: 6, left: 0, bottom: -6, right: 0)

    let tabBarController = UITabBarController()
    tabBarController.tabBar.tintColor = UIColor(red:0.21, green:0.17, blue:0.46, alpha:1.0)
    tabBarController.tabBar.backgroundColor = UIColor.white
    tabBarController.tabBar.isTranslucent = false
    tabBarController.tabBar.backgroundImage = UIImage()
    tabBarController.tabBar.layer.borderWidth = 0.0
    tabBarController.tabBar.clipsToBounds = true

    tabBarController.viewControllers = [exploreTab.rootViewController, swapsTab.rootViewController, postTab.rootViewController, notificationTab.rootViewController, profileTab.rootViewController]

    self.init(controller: tabBarController)

  }

  // MARK: - Init
  init(controller: UITabBarController) {
    controller.delegate = viewDelegate
    super.init(root: controller)
  }
}


And here is my viewDelegate:


class CrowdswapTabDelegate: NSObject, UITabBarControllerDelegate {

  func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -&gt; Bool {
    /// Prevent selection of the same tab twice (which would reset its navigation controller)
    if viewController.tabBarItem.image == #imageLiteral(resourceName: ""upload"") {
      return false
    }
    if let viewController = viewController.children[0] as? ExploreViewController{
      if tabBarController.selectedIndex == 0 {
        viewController.collectionView.scrollToItem(at: IndexPath(row: 0, section: 0), at: .top, animated: true)
      }
      return true
    }
    return true
  }
}


</code></pre>
","4374990","","4374990","","2019-02-23 02:44:35","2019-02-23 03:34:49","iOS Swift Code - Just working when i have a breakpoint on it","<ios><swift><rx-swift><coordinator-pattern>","1","8","1","","","CC BY-SA 4.0"
"54840062","1","","","2019-02-23 09:15:38","","0","942","<p>I have a video and play in ViewController.<br>
But when I enter to background and then back to foreground, the video sometimes pause.<br>
Have any idea let code add notification to know the user back to foreground and make the video auto playing.<br>
Thanks.<br></p>

<pre><code>extension UIViewController: AVPlayerViewControllerDelegate {

private func playVideo(url: URL, completeHandler: @escaping () -&gt; Void) -&gt; Void {
    let player = AVPlayer(url: url)

    let vc = AVPlayerViewController.init()
    vc.videoGravity = ""AVLayerVideoGravityResizeAspectFill""
    vc.showsPlaybackControls = false
    vc.player = player

    // add child view controller
    self.view.addSubview(vc.view)
    self.addChildViewController(vc)
    vc.didMove(toParentViewController: self)
    vc.view.backgroundColor = UIColor.clear

    // constraints
    vc.view.snp.makeConstraints { (make) in
        make.top.equalToSuperview()
        make.bottom.equalToSuperview()
        make.left.equalToSuperview()
        make.right.equalToSuperview()
    }
    // end play
    _ = NotificationCenter.default.rx
    .notification(NSNotification.Name.AVPlayerItemDidPlayToEndTime)
    .takeUntil(self.rx.deallocated)
        .subscribe(onNext: { [weak self] _ in
            for vc in self?.childViewControllers ?? [] {
                if vc is AVPlayerViewController {
                    vc.view.removeFromSuperview()
                    vc.removeFromParentViewController()
                }
            }
            completeHandler()
        })

    vc.player?.play()

}
}
</code></pre>
","7941494","","","","","2019-02-23 13:09:54","AVPlayer auto play when enter to foreground from background using RxSwift","<ios><swift><avplayer><rx-swift>","1","1","","","","CC BY-SA 4.0"
"54859977","1","54874058","","2019-02-25 05:27:03","","3","1440","<p>I have been trying to test on <code>retryWhen</code> operator on <code>RxSwift</code> and I have encountered the <code>Reentrancy Anomaly</code> issue, here's the code:</p>

<pre><code>Observable&lt;Int&gt;.create { observer in
    observer.onNext(1)
    observer.onNext(2)
    observer.onNext(3)
    observer.onNext(4)
    observer.onError(RequestError.dataError)
    return Disposables.create()
    }
    .retryWhen { error in
        return error.enumerated().flatMap { (index, error) -&gt; Observable&lt;Int&gt; in
        let maxRetry = 1
        print(""index: \(index)"")
        return index &lt; maxRetry ? Observable.timer(1, scheduler: MainScheduler.instance) : Observable.error(RequestError.tooMany)
        }
    }
    .subscribe(onNext: { value in
        print(""This: \(value)"")
    }, onError: { error in
        print(""ERRRRRRR: \(error)"")
    })
    .disposed(by: disposeBag)
</code></pre>

<p>With the code above it gives:</p>

<pre><code>This: 1
This: 2
This: 3
This: 4
index: 0
This: 1
This: 2
This: 3
This: 4
index: 1
⚠️ Reentrancy anomaly was detected.
  &gt; Debugging: To debug this issue you can set a breakpoint in /Users/tony.lin/Documents/Snippet/MaterialiseTest/Pods/RxSwift/RxSwift/Rx.swift:97 and observe the call stack.
  &gt; Problem: This behavior is breaking the observable sequence grammar. `next (error | completed)?`
    This behavior breaks the grammar because there is overlapping between sequence events.
    Observable sequence is trying to send an event before sending of previous event has finished.
  &gt; Interpretation: This could mean that there is some kind of unexpected cyclic dependency in your code,
    or that the system is not behaving in the expected way.
  &gt; Remedy: If this is the expected behavior this message can be suppressed by adding `.observeOn(MainScheduler.asyncInstance)`
    or by enqueing sequence events in some other way.

⚠️ Reentrancy anomaly was detected.
  &gt; Debugging: To debug this issue you can set a breakpoint in /Users/tony.lin/Documents/Snippet/MaterialiseTest/Pods/RxSwift/RxSwift/Rx.swift:97 and observe the call stack.
  &gt; Problem: This behavior is breaking the observable sequence grammar. `next (error | completed)?`
    This behavior breaks the grammar because there is overlapping between sequence events.
    Observable sequence is trying to send an event before sending of previous event has finished.
  &gt; Interpretation: This could mean that there is some kind of unexpected cyclic dependency in your code,
    or that the system is not behaving in the expected way.
  &gt; Remedy: If this is the expected behavior this message can be suppressed by adding `.observeOn(MainScheduler.asyncInstance)`
    or by enqueing sequence events in some other way.

ERRRRRRR: tooMany
</code></pre>

<p>Just wondering if anyone knows the cause of this issue?</p>
","7591205","","","","","2019-02-26 00:39:49","RxSwift RetryWhen causes Reentrancy Anomaly","<ios><swift><rx-swift><reactivex>","1","1","","","","CC BY-SA 4.0"
"54864933","1","","","2019-02-25 11:13:32","","0","956","<p>Below is the simplified version of my project I'm struggling now.  </p>

<p>I'd like to block the thread <strong>until first <code>Single</code> succeeds.</strong><br>
These observables should be <strong>two separated streams but sharing one thread</strong>.</p>

<p>Do you have any idea of fixing this code? Thanks!</p>

<pre class=""lang-swift prettyprint-override""><code>let disposeBag = DisposeBag()
var hasReturnedSingle = false

func returnSingle() -&gt; Single&lt;String&gt; {
    return Single&lt;String&gt;.create { single in
      print(""hasReturnedSingle: \(hasReturnedSingle)"")

      DispatchQueue.main.asyncAfter(deadline: .now()+3.0) {
        single(.success(()))
        hasReturnedSingle = true
      }
      return Disposables.create()
    }
}

returnSingle().asObservable()
    .subscribeOn(MainScheduler.instance)
    .asSingle()
    .subscribe()
    .disposed(by: disposeBag)

returnSingle().asObservable()
    .subscribeOn(MainScheduler.instance)
    .asSingle()
    .subscribe()
    .disposed(by: disposeBag)

</code></pre>

<p><strong>Result:</strong></p>

<pre><code>hasReturnedSingle: false
hasReturnedSingle: false
</code></pre>

<p><strong>Expectation:</strong></p>

<pre><code>hasReturnedSingle: false
hasReturnedSingle: true
</code></pre>
","11113147","","4608906","","2019-02-25 11:44:46","2019-02-28 01:23:09","Blocking Thread with RxSwift","<ios><swift><multithreading><rx-swift>","1","0","","","","CC BY-SA 4.0"
"54886945","1","","","2019-02-26 13:46:32","","0","533","<p>Im trying to implement a UIButton programmatically using RxSwift, I have searched a lot and did not find anything useful, as I am new to this topics, there are some questions in my mind</p>

<p>I have a View With Two Buttons, Register and Login, by tapping this button, the only action is pushing to a new ViewController, here is the code for LoginViewController (I know i should not implement any code unless for a failed test to pass, it's just for showing what exactly im trying to do):</p>

<pre><code>import UIKit
import RxCocoa
import RxSwift

class LoginViewController: UIViewController {

    let disposeBag = DisposeBag()
    var loginButton: UIButton?
    var registerButton: UIButton?

    override func viewDidLoad() {
        super.viewDidLoad()
        loginButton = UIButton()
        registerButton = UIButton()

        view.addSubview(loginButton!)

        loginButton?.rx.tap
          .subscribe(onNext:{ [weak self] in
                let enterPhoneNumberVC = EnterPhoneNumberViewController(nibName: ""EnterPhoneNumberViewController"", bundle: nil) as EnterPhoneNumberViewController
                self?.navigationController?.pushViewController(enterPhoneNumberVC, animated: true)
            })
          .disposed(by: disposeBag)
    }
}
</code></pre>

<p>Question 1: as I understood, there is no need to notify viewModel as there is no logic in button action, is that right? or I should handle it through view model anyway?</p>

<p>Question 2: as this is a TDD project, how should i test below mentioned functionalities:</p>

<p>Check if tap is handled in ViewController </p>

<p>Test if touching button really does what I want </p>

<p>Thanks.</p>
","3868228","","","","","2019-04-11 03:00:46","implementing UIButton programmatically using RxSwift, TDD and MVVM","<ios><swift><mvvm><tdd><rx-swift>","2","1","","","","CC BY-SA 4.0"
"54956275","1","54959324","","2019-03-02 07:35:13","","1","503","<p>Im trying to combine the inputs of all the textfield and check if it has an input but upon observing combine latest only subscribed once. </p>

<p>Is there any other way to check the textfields if they are empty using rxswift? those the OTP textfields</p>

<pre><code>let otp1Value: Observable&lt;Bool&gt; = self.otp1.rx.controlEvent(UIControlEvents.editingDidEnd)
            .withLatestFrom(self.otp1.rx.text)
            .map{ !$0!.isEmpty }
            .share()

        let otp2Value: Observable&lt;Bool&gt; = self.otp1.rx.controlEvent(UIControlEvents.editingDidEnd)
            .withLatestFrom(self.otp2.rx.text)
            .map{ !$0!.isEmpty }
            .share()

        let otp3Value: Observable&lt;Bool&gt; = self.otp1.rx.controlEvent(UIControlEvents.editingDidEnd)
            .withLatestFrom(self.otp3.rx.text)
            .map{ !$0!.isEmpty }
            .share()

        let otp4Value: Observable&lt;Bool&gt; = self.otp1.rx.controlEvent(UIControlEvents.editingDidEnd)
            .withLatestFrom(self.otp4.rx.text)
            .map{ !$0!.isEmpty }
            .share()

        let otp5Value: Observable&lt;Bool&gt; = self.otp1.rx.controlEvent(UIControlEvents.editingDidEnd)
            .withLatestFrom(self.otp5.rx.text)
            .map{ !$0!.isEmpty }
            .share()

        let otp6Value: Observable&lt;Bool&gt; = self.otp1.rx.controlEvent(UIControlEvents.editingDidEnd)
            .withLatestFrom(self.otp6.rx.text)
            .map{ !$0!.isEmpty }
            .share()

        Observable.combineLatest(
            otp1Value.asObservable(),
            otp2Value.asObservable(),
            otp3Value.asObservable(),
            otp4Value.asObservable(),
            otp5Value.asObservable(),
            otp6Value.asObservable())
            .asObservable().subscribe(onNext: { [weak self] (arg: (Bool, Bool, Bool, Bool, Bool, Bool)) -&gt; Void in

                guard let self = self else { return }

                print(""args \(arg)"")

                switch arg {
                case (true, true, true, true, true, true):
                    self.step2CellViewModel.otpIsValid.onNext(true)
                    print(""args \(arg)"")
                default:
                    self.step2CellViewModel.otpIsValid.onNext(false)
                    print(""args false"")
                }
            })
            .disposed(by: self.disposeBag) 
</code></pre>
","11070352","","","","","2019-03-02 14:01:17","combined textfields result if all are not empty RxSwift","<rx-swift><rx-cocoa>","2","1","","","","CC BY-SA 4.0"
"55012126","1","55012802","","2019-03-05 21:47:50","","3","849","<p>In the official RxSwift <a href=""https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md#driver"" rel=""nofollow noreferrer"">documentation</a>, it's described that traits <code>Driver</code> and <code>ControlProperty</code> share many similarities between them (can't error out, observe occurs on main scheduler, share and replay side effects), but at the same time in the example provided <code>ControlProperty</code> <code>rx.text</code> is being wrapped into a Driver.</p>

<p>So the questions would be:</p>

<ul>
<li>Is there any real advantage of wrapping a <code>ControlProperty</code> into a <code>Driver</code> trait?</li>
<li>If both <code>ControlProperty</code> and <code>Driver</code> are supposed to share and replay by default, why is <code>.share(replay: 1)</code> operator being called in the first code but not in the second?</li>
</ul>

<p>Here I attach the referenced code from the documentation:</p>

<p><strong>From:</strong></p>

<pre class=""lang-swift prettyprint-override""><code>let results = query.rx.text
    .throttle(0.3, scheduler: MainScheduler.instance)
    .flatMapLatest { query in
        fetchAutoCompleteItems(query)
            .observeOn(MainScheduler.instance)  // results are returned on MainScheduler
            .catchErrorJustReturn([])           // in the worst case, errors are handled
    }
    .share(replay: 1)                           // HTTP requests are shared and results replayed
                                                // to all UI elements

results
    .map { ""\($0.count)"" }
    .bind(to: resultCount.rx.text)
    .disposed(by: disposeBag)

results
    .bind(to: resultsTableView.rx.items(cellIdentifier: ""Cell"")) { (_, result, cell) in
        cell.textLabel?.text = ""\(result)""
    }
    .disposed(by: disposeBag)
</code></pre>

<p><strong>To:</strong></p>

<pre class=""lang-swift prettyprint-override""><code>let results = query.rx.text.asDriver()        // This converts a normal sequence into a `Driver` sequence.
    .throttle(0.3, scheduler: MainScheduler.instance)
    .flatMapLatest { query in
        fetchAutoCompleteItems(query)
            .asDriver(onErrorJustReturn: [])  // Builder just needs info about what to return in case of error.
    }

results
    .map { ""\($0.count)"" }
    .drive(resultCount.rx.text)               // If there is a `drive` method available instead of `bind(to:)`,
    .disposed(by: disposeBag)              // that means that the compiler has proven that all properties
                                              // are satisfied.
results
    .drive(resultsTableView.rx.items(cellIdentifier: ""Cell"")) { (_, result, cell) in
        cell.textLabel?.text = ""\(result)""
    }
    .disposed(by: disposeBag)
</code></pre>

<p>Thanks and best regards!</p>
","1655107","","","","","2019-03-05 22:51:47","RxSwift - Why wrap ControlProperty trait into a Driver?","<ios><swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"55017598","1","55017928","","2019-03-06 07:17:40","","0","1731","<p>I am trying to understand <code>RxSwift</code>. I have created a simple playground below that mocks out the behaviour I am attempting. This should run OK.</p>

<pre><code>import UIKit
import RxSwift

struct Universities: Codable {

    let author: Author
    let example: String
    let github: String

    enum CodingKeys: String, CodingKey {
        case author
        case example
        case github
    }

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        author = try values.decode(Author.self, forKey: .author)
        example = try values.decode(String.self, forKey: .example)
        github = try values.decode(String.self, forKey: .github)
    }

}

struct Author: Codable {

    let name: String
    let website: String

    enum CodingKeys: String, CodingKey {
        case name
        case website
    }

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        name = try values.decode(String.self, forKey: .name)
        website = try values.decode(String.self, forKey: .website)
    }

}


class HTTPClient&lt;T: Codable&gt; {

    private let baseURL = URL(string: ""http://universities.hipolabs.com/"")!

    func call() -&gt; Observable&lt;T&gt; {
        return Observable&lt;T&gt;.create { observer in
            let request = URLRequest(url: self.baseURL)
            let task: URLSessionDataTask = URLSession.shared.dataTask(with: request) { data, response, error in
                do {
                    let model: T = try JSONDecoder().decode(T.self, from: data!)
                    observer.onNext(model)
                } catch let error {
                    observer.onError(error)
                }
                observer.onCompleted()
            }

            task.resume()

            return Disposables.create {
                task.cancel()
            }
        }
    }
}

class SomeService {
    private let client = HTTPClient&lt;Universities&gt;()
    private let disposeBag = DisposeBag()



    func getValues() {
        client.call().subscribe(onNext: { print($0.example) }).disposed(by: disposeBag)
    }
}

let service = SomeService()

service.getValues()
</code></pre>

<p>As you can see <code>SomeService</code> calls my http client which makes a request and returns the response. I then print out a value. What I'm struggling to understand is how can I subscribe to <code>getValues</code> in another class, and make use of the response.</p>

<p>This was my current attempt</p>

<pre><code>class SomeService {
    private let client = HTTPClient&lt;Universities&gt;()
    private let disposeBag = DisposeBag()



    func getValues() -&gt; Observable&lt;String&gt; {
        return client.call().subscribe(onNext: { return $0.example }).disposed(by: disposeBag)
    }
}

let service = SomeService()

service.getValues().map { print($0) }
</code></pre>

<p>However I get an error </p>

<blockquote>
  <p>Cannot convert return expression of type '()' to return type
  'Observable'</p>
</blockquote>

<p>Should I be creating some sort of subject and subscribing to that from my controller and instead calling <code>onNext</code> with the returned value?</p>

<p>If so how would I structure those calls in my controller?</p>
","7579156","","","","","2019-03-06 07:41:45","How can I get the value from a service that returns an Observable using RxSwift","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"55028020","1","","","2019-03-06 16:37:06","","0","1680","<p>I am new to the <code>RxSwift</code> framework. I am using disposables in my <code>ViewController</code> and I am adding disposables in a <code>DisposeBag</code>.</p>

<p>Where should I deallocate the <code>DisposeBag</code> in order to dispose of all disposables? In the controller's <code>viewDidAppear</code> or <code>deinit</code>? Which method is safer?</p>
","5259634","","-1","","2019-03-25 11:29:10","2019-03-25 11:29:10","RxSwift DisposeBag usage in ViewController","<ios><mvvm><uiviewcontroller><rx-swift>","3","0","","","","CC BY-SA 4.0"
"55052135","1","","","2019-03-07 20:16:24","","0","722","<p>I have a method on a class that calls a service, it uses the response from that service to pass an ID into another service, making a second call.</p>

<p>If either of these fail or when the sequence is completed, I'd like to call another function <code>self.showHomeScene()</code></p>

<pre><code>   private func getPropsForHomeScene() {

        profileService.fetchCurrentUser()
            .map { $0.company }
            .flatMap(companyService.fetchCompany)
            .distinctUntilChanged()
            .subscribe(onNext: { company in
                 self.showHomeScene()
            }, onError: { err in
                print(err.localizedDescription)
            }).disposed(by: disposeBag)
    }
</code></pre>

<p>Currently I do it in the subscribe block, however this does not get called in the event of an error. It's important this action is called after the first 2 operations.</p>
","7579156","","","","","2019-03-07 22:04:45","How can I tell RxSwift to do something regardless of success or fail","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"55062002","1","","","2019-03-08 11:11:33","","-1","61","<p>I am looking into an old code where there have have RxCocoa framework, when I compile the code, I see the error <a href=""https://i.stack.imgur.com/CEhHY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CEhHY.png"" alt=""enter image description here""></a></p>
","1999186","","","","","2019-03-19 09:56:01","Unable to compile code because deprecated framework","<swift><rx-swift><rx-cocoa>","1","2","","","","CC BY-SA 4.0"
"55079248","1","55079310","","2019-03-09 16:07:39","","2","697","<p>I'm working on porting some of my View Models into (rough) Finite State Machines as my UI tends to fit that pattern rather well (Mealy/Moore, don't care for the purpose of this question). Additionally, when done well - state machines really clean up testing - as they prohibit certain test permutations from ever happening.</p>

<p>My current view models use RxSwift (and RxKotlin - depending on the app), and the underlying use cases (database calls, network calls, etc) also use Rx (hence why I need to stay in that ecosystem).</p>

<p>What I've discovered is that Rx is awesome, State Machines are awesome --> Rx + State Machines seem to be a bit of a hash to do anything non-trivial. For example, I know I can use the <code>.scan</code> operator to retain some state, IF my state machine was entirely synchronous (for example, something roughly like this in Swift):</p>

<pre><code>enum Event {
    case event1
    case event2
    case event3
}

enum State {
    case state1
    case state2
    case state3

    func on(event: Event) -&gt; State {
        switch (self, event) {
        case (.state1, .event1):
            // Do something
            return .state2

        case (.state2, .event2):
            // Do something
            return .state3

        default:
            return self // (or nil, or something)
        }
    }
}

func foo() -&gt; Observable&lt;State&gt; {
    let events = Observable&lt;Event&gt;.of(.event1, .event2, .event3)
    return events.scan(State.state1) { (currentState, event) -&gt; State in
        return currentState.on(event)
    }
}
</code></pre>

<p>But, what can I do if the return from my <code>State.on</code> function is an Observable (like a network call or something that takes a long time, which is already in Rx)?</p>

<pre><code>enum State {
    case notLoggedIn
    case loggingIn
    case loggedIn
    case error

    func on(event: Event) -&gt; Observable&lt;State&gt; {
        switch (self, event) {
        case (.notLoggedIn, .event1):
            return api.login(credentials)
                .map({ (isLoggedIn) -&gt; State in
                    if isLoggedIn {
                        return .loggedIn
                    }
                    return .error
                })
                .startWith(.loggingIn)

        ... other code ...

        default:
            return self
        }
    }
}
</code></pre>

<p>I've tried making the <code>.scan</code> operator take in an Observable accumulator, but the result of this code is that the state machine is subscribed to or run too many times. I guess because it runs on each state in the observable that is accumulating. </p>

<pre><code>return events.scan(Observable.just(State.state1)) { (currentState, event) -&gt; Observable&lt;State&gt; in
    currentState.flatMap({ (innerState) -&gt; Observable&lt;State&gt; in
        return innerState.on(event: event)
    })
}.flatMap { (states) -&gt; Observable&lt;State&gt; in
    return states
}
</code></pre>

<p>I think, if I could manage to cleanly pull the <code>state</code> variable back in, the simplest implementation could look like this:</p>

<pre><code>return events.flatMapLatest({ (event) -&gt; Observable&lt;State&gt; in
    return self.state.on(event: event)
        .do(onNext: { (state) in
            self.state = state
        })
})
</code></pre>

<p>But, pulling from a private state variable into an observable stream, and updating it - well, not only is it ugly, I feel like I'm just waiting to be hit by a concurrency bug.</p>

<hr>

<p>Edit: Based on feedback from Sereja Bogolubov - I've added a Relay and come up with this code - still not great, but getting there. </p>

<pre><code>let relay = BehaviorRelay&lt;State&gt;(value: .initial)
...

func transition(from state: State, on event: Event) -&gt; Observable&lt;State&gt; {
    switch (state, event) {
    case (.notLoggedIn, .event1):
        return api.login(credentials)
            .map({ (isLoggedIn) -&gt; State in
                if isLoggedIn {
                    return .loggedIn
                }
                return .error
            })
            .startWith(.loggingIn)

    ... other code ...

    default:
        return self
    }
}

return events.withLatestFrom(relay.asObservable(), resultSelector: { (event, state) -&gt; Observable&lt;State&gt; in
    return self.transition(from: state, on: event)
        .do(onNext: { (state) in
            self.relay.accept(state)
        })
}).flatMap({ (states) -&gt; Observable&lt;State&gt; in
    return states
})
</code></pre>

<p>The relay (or replay subject or whatever) is updated in a <code>doOnNext</code> from the result of the state transition... This still feels like it could cause a concurrency problem, but not sure what else would work.</p>
","992509","","992509","","2019-03-09 17:00:48","2019-03-10 02:23:53","How to retain state in Rx without the scan function","<swift><kotlin><rx-java><state-machine><rx-swift>","2","5","","","","CC BY-SA 4.0"
"55107812","1","55113898","","2019-03-11 18:01:44","","2","658","<p>Imagine I have a networking client, using <code>RxSwift</code> to wrap <code>URLSession</code>.</p>

<p>I'd like to use a <code>guard</code> statement and return an error, however I am getting an error that</p>

<blockquote>
  <p>Non-void function should return a value</p>
</blockquote>

<p>Which makes sense, however I am unsure how to handle this with <code>RxSwift</code>.</p>

<pre><code>class NetworkClient {
    var task: URLSessionDataTask = URLSessionDataTask()
    var session: SessionProtocol = URLSession.shared
    var request: URLRequest?

    func call&lt;T: Codable&gt;(_ request: URLRequest) -&gt; Single&lt;T&gt; {
        return Single&lt;T&gt;.create(subscribe: { [weak self] observer -&gt; Disposable in
            guard let `self` = self else { observer(.error(NSError(domain: """", code: 0, userInfo: [:]))); return }
            self.task = self.session.dataTask(with: request, completionHandler: { data, response, error in

            })


            return Disposables.create {
                self.task.cancel()
            }
        })
    }

}
</code></pre>
","10823240","","","","","2019-03-12 10:33:05","How should I use a guard statement correctly with RxSwift Singles?","<ios><swift><rx-swift>","1","3","1","","","CC BY-SA 4.0"
"55115407","1","","","2019-03-12 06:31:46","","0","695","<p>I want to bind my ImageView to viewModel for save my selected image to Core Data.</p>

<p><strong>My code look like this:</strong></p>

<pre><code>class FoodViewModel: FoodViewModelType {
    var foodImage: BehaviorRelay&lt;UIImage?&gt;
    //... another code
}
</code></pre>

<p><strong>My controller:</strong></p>

<pre><code>class NewFoodViewController: UIViewController {
    @IBOutlet weak var foodImageView: UIImageView!

    override func viewDidLoad() {
       //... another code
       self.foodImageView.rx.image.bind(to: foodViewModel.foodImage).disposed(by: self.disposeBag)
    }
}
</code></pre>

<p><strong>And i get error:</strong></p>

<blockquote>
  <p>Value of type Binder &lt; UIImage? > has no member 'bind'</p>
</blockquote>

<p>How to save my image to Core Data with good MVVM practice?</p>

<p><strong>Update</strong></p>

<p>I am choose photo in view controller:</p>

<pre><code>func chooseImagePickerAction(source: UIImagePickerController.SourceType) {
    if UIImagePickerController.isSourceTypeAvailable(source) {
        let imagePicker = UIImagePickerController()
        imagePicker.sourceType = source
        imagePicker.delegate = self
        self.present(imagePicker, animated: true, completion: nil)
    }
}

@objc func foodImageViewTapped(_ sender: AnyObject) {
    let alertController = UIAlertController(title: ""Photo path"", message: nil, preferredStyle: .actionSheet)

    let cameraAction = UIAlertAction(title: ""Camera"", style: .default) { (action) in
        self.chooseImagePickerAction(source: .camera)
    }

    let photoLibAction = UIAlertAction(title: ""Photo"", style: .default) { (action) in
        self.chooseImagePickerAction(source: .photoLibrary)
    }

    let cancelAction = UIAlertAction(title: ""Cancel"", style: .default)

    alertController.addAction(cameraAction)
    alertController.addAction(photoLibAction)
    alertController.addAction(cancelAction)

    self.present(alertController, animated: true, completion: nil)
}

extension NewFoodViewController: UIImagePickerControllerDelegate, UINavigationControllerDelegate {
    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {

        let info = convertFromUIImagePickerControllerInfoKeyDictionary(info)

        foodImageView.image = info[convertFromUIImagePickerControllerInfoKey(UIImagePickerController.InfoKey.originalImage)] as? UIImage
        foodImageView.contentMode = .scaleAspectFill

        dismiss(animated: true, completion: nil)
    }

    private func convertFromUIImagePickerControllerInfoKeyDictionary(_ input: [UIImagePickerController.InfoKey: Any]) -&gt; [String: Any] {
        return Dictionary(uniqueKeysWithValues: input.map {key, value in (key.rawValue, value)})
    }

    private func convertFromUIImagePickerControllerInfoKey(_ input: UIImagePickerController.InfoKey) -&gt; String {
        return input.rawValue
    }
}
</code></pre>

<p>And in viewDidLoad (without image):</p>

<pre><code>saveNewFoodBarButtonItem.rx.tap.subscribe(onNext: { [weak self] _ in
    guard let self = self else { return }

    let foodViewModel = FoodViewModel()

    self.foodQuantityTypeTextField.rx.text.bind(to: foodViewModel.foodQuantityType).disposed(by: self.disposeBag)
    self.foodShelfLifeTextField.rx.text.bind(to: foodViewModel.foodShelfLife).disposed(by: self.disposeBag)
    self.foodCategoryTextField.rx.text.bind(to: foodViewModel.foodCategoryId).disposed(by: self.disposeBag)
    self.foodQuantityTextField.rx.text.bind(to: foodViewModel.foodQuantity).disposed(by: self.disposeBag)
    self.foodNameTextField.rx.text.bind(to: foodViewModel.foodName).disposed(by: self.disposeBag)

    foodViewModel.saveNewFood(fridgeViewModel: self.fridgeViewModel!)

    self.dismiss(animated: true)
}).disposed(by: disposeBag)
</code></pre>
","5004769","","5004769","","2019-03-12 12:29:54","2019-03-12 12:29:54","Value of type 'Binder<UIImage?>' has no member 'bind'","<ios><swift><core-data><data-binding><rx-swift>","1","4","","","","CC BY-SA 4.0"
"55122804","1","55124365","","2019-03-12 13:35:59","","1","677","<p>I am new at rxswift framework.I have written a code below and I am not sure.Is there any retain cycle? Must I use weak reference to self?</p>

<pre><code>    loginButton.rx.tap.bind {
        print(self.nameText.value ??  """")
       self.nameText.accept(""ahmet vefa saruhan"")
    }.disposed(by: disposebag)
</code></pre>

<p>second case is : </p>

<pre><code>func myTestFunction(handler : () -&gt; Void) {
    handler()
}

myTestFunction {
        self.isVisible = false
    }
</code></pre>

<p>is here any retain cycle problem?</p>
","5259634","","5259634","","2019-03-12 14:54:35","2019-03-12 15:02:31","RxSwfit bind operation retain cycle","<ios><memory-management><rx-swift><swift4.2><retain-cycle>","1","0","","","","CC BY-SA 4.0"
"55138672","1","55139896","","2019-03-13 09:43:35","","4","687","<p>Trying to figure out how to make an app with RxSwift and exploring multiple open source projects (namely <a href=""https://github.com/sergdort/CleanArchitectureRxSwift"" rel=""nofollow noreferrer"">CleanArchitectureRxSwift</a> and <a href=""https://github.com/khoren93/SwiftHub"" rel=""nofollow noreferrer"">SwiftHub</a>) I often find usage of </p>

<pre><code>extension ObservableType {

    func asDriverOnErrorJustComplete() -&gt; Driver&lt;E&gt; {
        return asDriver { error in
            return Driver.empty()
        }
    }

}
</code></pre>

<p>Given that this method is useful in many situation and literally copied in mentioned projects I wonder why is it not a part of some utility library (like for example <a href=""https://github.com/RxSwiftCommunity/RxSwiftExt"" rel=""nofollow noreferrer"">RxSwiftExt</a>) or even RxSwift itself.</p>

<p>I find it really suspicious that given how many Rx pods there are in <a href=""https://github.com/khoren93/SwiftHub/blob/master/Podfile#L18"" rel=""nofollow noreferrer"">SwiftHub Podfile</a> none of them actually contain this function.</p>

<p>My question is that are there any real reasons behind that? Does <code>asDriverOnErrorJustComplete</code> somehow violates come Rx contracts or considered bad practice etc?</p>

<p>Am I biased in sense that those two projects are most likely copied architecture from each other and are not representative? If so, are there any good open source projects that demonstrate RxSwift+MVVM and maybe avoid <code>asDriverOnErrorJustComplete</code> or approach problems solved by <code>asDriverOnErrorJustComplete</code> differently?</p>
","2305175","","","","","2019-03-14 07:28:11","RxSwift .asDriverOnErrorJustComplete() not being part of core/utility library","<ios><mvvm><reactive-programming><rx-swift>","2","1","","","","CC BY-SA 4.0"
"55164917","1","55171486","","2019-03-14 14:21:32","","1","364","<p>Here's the function:</p>

<pre><code>func registerFor&lt;Element&gt;(relayId id: String) -&gt; Driver&lt;Element&gt;? {
    guard let relay = relays[id] as? BehaviorRelay&lt;Element&gt; else { return nil }
    return relay.asObservable()
        .distinctUntilChanged { a, b in
            return a != b
        }.flatMapLatest { value in
            return Observable.create { observer in
                observer.on(.next(value))
                return Disposables.create()
            }
        }.asDriver(onErrorJustReturn: Element())
}
</code></pre>

<p>The <code>distinctUntilChanged</code> line throws the following error:</p>

<pre><code>Contextual closure type '(Element) throws -&gt; _' expects 1 argument, 
but 2 were used in closure body
</code></pre>

<p>The <code>asDriver</code> line throws the following error (of course):</p>

<pre><code>Non-nominal type 'Element' does not support explicit initialization
</code></pre>

<p>Context: I have a class that ideally has a collection of <code>BehaviorRelay</code>s of various types (Strings, Ints, etc). <code>Element</code> stands in generically for these types, but that creates two problems:</p>

<ol>
<li><code>distinctUntilChanged</code> insists of having a closure (eg: if this method returned <code>Driver&lt;String&gt;</code> it would be content simply to use <code>distinctUntilChanged()</code> but the generic <code>Element</code> makes it complain about missing a closure);</li>
<li><code>onErrorJustReturn</code> requires a concrete value, but <code>Element</code> is generic.</li>
</ol>

<p>The following ""workaround"" might work but I suspect there are better solutions</p>

<pre><code>protocol Inii {
    init()
}

func registerFor(relayId id: String, def: Inii.Type) -&gt; Driver&lt;Inii&gt;? {
    return relays[id]?.asObservable()
        .distinctUntilChanged { _, _ in
            return true
        }.flatMapLatest { value in
            return Observable.create { observer in
                observer.on(.next(value))
                return Disposables.create()
            }
        }.asDriver(onErrorJustReturn: def.init())
}
</code></pre>

<p>Although I'm still unsure what to put in the <code>distinctUntilChanged</code> closure.</p>

<hr>

<p><strong>Appendix A</strong></p>

<p>I believe that the following is what is required if one is implementing the <code>distinctUntilChanged</code> closure for a non-generic type:</p>

<pre><code>.distinctUntilChanged { previousValue, currentValue in
    return previousValue == currentValue
}
</code></pre>

<p>However, when used with the generic <code>Element</code> the following error is still thrown:</p>

<pre><code>Contextual closure type '(Inii) throws -&gt; _' expects 1 argument, 
but 2 were used in closure body
</code></pre>

<hr>

<p><strong>Appendix B</strong></p>

<p>Here's another alternative with a slightly different problem:</p>

<pre><code>protocol Inii {
    init()
}

var relay = BehaviorRelay&lt;String&gt;(value: """")

func registerFor&lt;Element&gt;(def: Element.Type) -&gt; Driver&lt;Element&gt; where Element: Inii {
    return relay.asObservable()
        .distinctUntilChanged { previousValue, currentValue in
            return previousValue == currentValue
        }.flatMapLatest { value in
            return Observable.create { observer in
                observer.on(.next(value))
                return Disposables.create()
            }
        }.asDriver(onErrorJustReturn: def.init())
}
</code></pre>

<p>Error in this case being:</p>

<pre><code>Member 'next' in 'Event&lt;_&gt;' produces result of type 'Event&lt;Element&gt;', 
but context expects 'Event&lt;_&gt;'
</code></pre>

<p>at the <code>observer.on</code> line</p>
","3807380","","3807380","","2019-03-14 16:07:33","2019-03-14 20:31:41","Using Swift generics in a RxSwift getter function - various problems","<swift><generics><rx-swift>","1","0","","","","CC BY-SA 4.0"
"55165429","1","","","2019-03-14 14:44:47","","0","67","<p>I'm using the next states to handle my API state</p>

<pre><code>enum RequestState&lt;T: Decodable&gt; {
    case loading
    case loaded(T)
    case error(Error)
}
</code></pre>

<p>and the following code to change these states:</p>

<pre><code>let response = request
    .flatMapLatest {
        provider.rx.request($0)
        .map(T.self).map { RequestState.loaded($0) }
        .asDriver(onErrorRecover: { error in
            return Driver.just(.error(error))
        })
     .startWith(.loading)
}
</code></pre>

<p>all works awesome but except one issue. <code>case loading</code> works only when all fine with network and request in progress.</p>

<p><strong>Connection</strong> </p>

<p>Tap - Loading spinner - Response</p>

<p><strong>No connection</strong></p>

<p>Tap - network thining delay - No connection response</p>

<p>I would like to start loading on tap always. Maybe use the new state <code>case startedLoading</code>. And get this state when a new request pushed to the sequence (ex. after tap refresh button).</p>
","4314758","","1173513","","2019-03-15 08:48:35","2019-03-15 08:59:21","Networking start loading issue","<swift><networking><rx-swift>","1","1","","","","CC BY-SA 4.0"
"55166052","1","","","2019-03-14 15:14:18","","1","88","<p>I have to update the notification send by Batch. I have to :</p>

<ol>
<li>Take the content of the notification received by Batch</li>
<li>Send it to the back end</li>
<li>Receive the content updated</li>
<li>Show notification.</li>
</ol>

<p>My problem is : when I send it to the back end, the function didReceive complete and the notification is send before the update.</p>

<p>How can I wait for the response of the back end? 
Or have you an other idea?</p>

<pre><code>import BatchExtension
import Core
import Middleware
import RxSwift

class NotificationService: BAENotificationServiceExtension {
var alreadySend: Bool = false

let batchHelper = BAERichNotificationHelper()

var contentHandler: ((UNNotificationContent) -&gt; Void)?
var bestAttemptContent: UNMutableNotificationContent?

override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void) {
    let userInfo = request.content.userInfo

    self.contentHandler = contentHandler
    bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)

    if let defaultMessage = userInfo[""on_error""] as? String {
        let body = request.content.body
        if body.contains(""$"") {
            if let image = userInfo[""image""] as? String {
                renderPush(title: request.content.title, body: body, image: image, defaultMessage: defaultMessage)
            }
        }
    } else {
        super.didReceive(request, withContentHandler: contentHandler)
        return
    }
}

override func serviceExtensionTimeWillExpire() {
    if let contentHandler = contentHandler, let bestAttemptContent = bestAttemptContent {
        contentHandler(bestAttemptContent)
    }
}

private func renderPush(title: String, body: String, image: String?, defaultMessage: String) {
    let customPushNotification = CustomPushNotificationContent(body: body, image: image)

    let credentialsStore = DummyCredentialStore()
    let serviceProvider = ServiceProvider(
        networkProvider: NetworkProvider(
            endPoint: Server.endPoint,
            timeoutIntervalForResource: 10,
            timeoutIntervalForRequest: 10
        ),
        credentialsStore: credentialsStore
    )

    if let credentials = DummyCredentialStore.getCredentialsFromSharedContainer() {
        let service = serviceProvider.getPushNotificationService(credentials: credentials)

        _ = service.renderPush(pushNotificationContent: customPushNotification)
            .subscribe(onNext: { result in
                let content = UNMutableNotificationContent()
                content.title = title

                if result.result != ""ok"" {
                    content.body = defaultMessage
                } else {
                    content.body = result.body
                }
                if result.image != nil {
                    if let urlImage = URL(string: result.image ?? """") {
                        do {
                            let attachement = try UNNotificationAttachment(identifier: ""image"", url: urlImage, options: nil)
                            content.attachments.append(attachement)
                        } catch {}
                    }
                }

               self.bestAttemptContent = content
            })
    }
}
</code></pre>

<p>}</p>
","8165918","","8165918","","2019-04-02 09:50:20","2019-04-02 09:50:20","iOS Rich Notification and async request - RxSwift","<ios><swift><push-notification><rx-swift>","0","0","","","","CC BY-SA 4.0"
"55197144","1","55198362","","2019-03-16 13:05:46","","0","275","<p>I'm trying to use <code>NVActivityIndicatorView</code> with <code>RxSwift</code> and <code>MVVM</code>.
I'm extending <code>NVActivityIndicatorView</code> like below :</p>

<pre><code>extension Reactive where Base: NVActivityIndicatorView {

/// Bindable sink for `startAnimating()`, `stopAnimating()` methods.
public var isAnimating: Binder&lt;Bool&gt; {
    return Binder(self.base) { activityIndicator, active in
        if active {
            activityIndicator.startAnimating()
        } else {
            activityIndicator.stopAnimating()
        }
    }
}}
</code></pre>

<p>And binding data like this:</p>

<pre><code>splashVM.loading.bind(to: NVActivityIndicatorView.rx.isAnimating).disposed(by: disposeBag)
</code></pre>

<p>but i get tis error :</p>

<pre><code>Instance member 'isAnimating' cannot be used on type 'Reactive&lt;NVActivityIndicatorView&gt;'
</code></pre>

<p>if I set <code>isAnimation</code> static ,that error goes away but another error pops up :</p>

<pre><code>Instance member 'base' cannot be used on type 'Reactive&lt;Base&gt;'
</code></pre>

<p>what's the problem exactly? what should i change?</p>
","6772720","","","","","2019-03-16 15:21:19","How to use RxSwift with NVActivityIndicatorView?","<swift><rx-swift><uiactivityindicatorview><indicator>","1","0","1","","","CC BY-SA 4.0"
"55209838","1","55221362","","2019-03-17 17:23:24","","0","147","<p>I have a function which is supposed to return an Observable. When I call the function for the first time, everything goes fine and I receive the result I expected, but for the second time that I want to make the same request with different parameters the function automatically returns the same response as before and it does not fire the requests at all. There are multiple requests nested because each new depends on the results of the previous.</p>

<p>It looks something like this:</p>

<pre><code>func request1() -&gt; Observable&lt;String&gt; {
    return RxAlamofire
            .requestString(.get, url)
            .map { (response, html) -&gt; Result&lt;String&gt; in
                .....
                return newUrl
            }
}

private func request2(credentials: Credentials) -&gt; Observable&lt;String&gt; {
   return request1()
            .flatMapLatest { (newUrl)

                return RxAlamofire
                    .requestString(.get, newUrl)
                    .flatMapLatest { (response, _) -&gt; Observable&lt;String&gt; in

                        let params = [""username"": credentials.username, ""password"": credentials.password]

                        return RxAlamofire
                            .requestString(.post, (response.url?.absoluteString)!, parameters: params)
                            .flatMapLatest { (response2,str) -&gt; Observable&lt;String&gt; in

                                ... some code formating ...

                                return RxAlamofire
                                    .requestString(.post, actionUrl!, parameters: anotherParameters)
                                    .map { return result }
                        }
                }
        }
    }
</code></pre>

<p>when I am calling it it looks something like this :</p>

<pre><code>result = someObservable.flatMapLatest { return ScrapingService.request2(credentials: $0) }
</code></pre>

<p>when I trigger ""someObservable"" it runs the request2 as expected, but the actual request is not made.</p>

<p>In the end I do onNext on the result.</p>
","11216994","","11216994","","2019-03-17 17:31:04","2019-03-18 12:25:15","RxAlamofire request is not fired for the second time i call the function","<swift><networking><rx-swift><reactive><rxalamofire>","1","0","","","","CC BY-SA 4.0"
"55210232","1","55210480","","2019-03-17 18:02:17","","0","300","<p>I have an application written in the <code>MVVM-C</code> pattern, using <code>RxSwift</code></p>

<p>After adding a new view programmatically, the application crashes with a </p>

<blockquote>
  <p>Thread 1: Fatal error: Unexpectedly found nil while unwrapping an
  Optional value</p>
</blockquote>

<p>error. I am at a complete loss, the implementation is almost exactly the same, minus the fact one view controller is a storyboard and one is not.</p>

<p>This is my new <code>ViewController</code></p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

final class FeedViewController: TableViewController, ViewModelAttaching {

    var viewModel: Attachable&lt;FeedViewModel&gt;!
    var bindings: FeedViewModel.Bindings {
        let viewWillAppear = rx.sentMessage(#selector(UIViewController.viewWillAppear(_:)))
            .mapToVoid()
            .asDriverOnErrorJustComplete()

        let refresh = tableView.refreshControl!.rx
            .controlEvent(.valueChanged)
            .asDriver()

        return FeedViewModel.Bindings(
            fetchTrigger: Driver.merge(viewWillAppear, refresh),
            selection: tableView.rx.itemSelected.asDriver()
        )
    }

    override func viewDidLoad() {
        super.viewDidLoad()
    }

    func bind(viewModel: FeedViewModel) -&gt; FeedViewModel {
        viewModel.posts
            .drive(tableView.rx.items(cellIdentifier: FeedTableViewCell.reuseID, cellType: FeedTableViewCell.self)) { _, viewModel, cell in
                cell.bind(to: viewModel)
            }
            .disposed(by: disposeBag)

        viewModel.fetching
            .drive(tableView.refreshControl!.rx.isRefreshing)
            .disposed(by: disposeBag)

        viewModel.errors
            .delay(0.1)
            .map { $0.localizedDescription }
            .drive(errorAlert)
            .disposed(by: disposeBag)

        return viewModel
    }

}
</code></pre>

<p>This is an existing one, that works but uses storyboards</p>

<pre><code>final class PostsListViewController: TableViewController, ViewModelAttaching {

    var viewModel: Attachable&lt;PostsListViewModel&gt;!
    var bindings: PostsListViewModel.Bindings {
        let viewWillAppear = rx.sentMessage(#selector(UIViewController.viewWillAppear(_:)))
            .mapToVoid()
            .asDriverOnErrorJustComplete()
        let refresh = tableView.refreshControl!.rx
            .controlEvent(.valueChanged)
            .asDriver()

        return PostsListViewModel.Bindings(
            fetchTrigger: Driver.merge(viewWillAppear, refresh),
            selection: tableView.rx.itemSelected.asDriver()
        )
    }

    // MARK: - Lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()
        setupView()
    }

    // MARK: - View Methods

    private func setupView() {
        title = ""Posts""
    }

    func bind(viewModel: PostsListViewModel) -&gt; PostsListViewModel {
        viewModel.posts
            .drive(tableView.rx.items(cellIdentifier: PostTableViewCell.reuseID, cellType: PostTableViewCell.self)) { _, viewModel, cell in
                cell.bind(to: viewModel)
            }
            .disposed(by: disposeBag)

        viewModel.fetching
            .drive(tableView.refreshControl!.rx.isRefreshing)
            .disposed(by: disposeBag)

        viewModel.errors
            .delay(0.1)
            .map { $0.localizedDescription }
            .drive(errorAlert)
            .disposed(by: disposeBag)

        return viewModel
    }

}
</code></pre>

<p>They are basically exactly the same. The exception is thrown on the  <code>let refresh = tableView.refreshControl!.rx</code> line.</p>

<p>The working coordinator, using a Storyboard is </p>

<pre><code>import RxSwift

class PostsCoordinator: BaseCoordinator&lt;Void&gt; {
    typealias Dependencies = HasPostService

    private let navigationController: UINavigationController
    private let dependencies: Dependencies

    init(navigationController: UINavigationController, dependencies: Dependencies) {
        self.navigationController = navigationController
        self.dependencies = dependencies
    }

    override func start() -&gt; Observable&lt;Void&gt; {
        let viewController = PostsListViewController.instance()
        navigationController.viewControllers = [viewController]

        let avm: Attachable&lt;PostsListViewModel&gt; = .detached(dependencies)
        let viewModel = viewController.attach(wrapper: avm)

        viewModel.selectedPost
            .drive(onNext: { [weak self] selection in
                self?.showDetailView(with: selection)
            })
            .disposed(by: viewController.disposeBag)

        // View will never be dismissed
        return Observable.never()
    }

    private func showDetailView(with post: Post) {
        let viewController = PostDetailViewController.instance()
        viewController.viewModel = PostDetailViewModel(post: post)
        navigationController.showDetailViewController(viewController, sender: nil)
    }

}
</code></pre>

<p>I have an extension to allow me to instantiate it also</p>

<pre><code>protocol Reusable {
    static var reuseID: String { get }
}

extension Reusable {
    static var reuseID: String {
        return String(describing: self)
    }
}

// MARK: - View Controller

extension UIViewController: Reusable {
    class func instance() -&gt; Self {
        let storyboard = UIStoryboard(name: reuseID, bundle: nil)
        return storyboard.instantiateViewController()
    }
}

extension UIStoryboard {
    func instantiateViewController&lt;T: UIViewController&gt;() -&gt; T {
        guard let viewController = self.instantiateViewController(withIdentifier: T.reuseID) as? T else {
            fatalError(""Unable to instantiate view controller: \(T.self)"")
        }
        return viewController
    }
}
</code></pre>

<p>The 'broken' coordinator is exactly the same, except I swapped </p>

<pre><code> let viewController = PostsListViewController.instance()
</code></pre>

<p>for</p>

<pre><code>let viewController = FeedViewController()
</code></pre>

<p>I am at a complete loss at to why this is throwing. Print statements and breakpoints at various points haven't turned up a nil on any values.</p>

<p>Please let me know if it would be easier to share a sample app as I appreciate the code snippets may not be the most obvious.</p>
","10823240","","","","","2019-03-17 20:21:33","Unexpected nil after adding programmatic view instead of storyboard","<ios><swift><mvvm><tableview><rx-swift>","2","0","","","","CC BY-SA 4.0"
"55226161","1","55226754","","2019-03-18 16:42:28","","0","561","<p>I have an async function that currently looks something like this</p>

<pre><code>func startLoginFlow() {
    IdentityProvider.shared.login { success, error in
        // on success a user has completed authentication
        if success {
            delegate?.userIsAuthenticated()
        }


        // on error something wen't wrong
        ....
    }
}
</code></pre>

<p>Essentially on success a delegate method is called and some action takes place as a result.</p>

<p>I'd like to wrap this as an observable instead. I do not have the option refactoring <code>IdentityProvider.shared.login</code>.</p>

<p>I essentially just need the observable to emit so I can subscribe and take action elsewhere using <code>onNext</code>.</p>

<p>I am currently doing the following</p>

<pre><code>  func startLoginFlow() -&gt; Observable&lt;Void&gt; {
        return Observable.create { [weak self] observable in
            IdentityProvider.shared.login { success, error in
                if success {
                    observable.onNext(Void())
                }
            }
            return Disposables.create()
        }
    }
</code></pre>

<p>Is this the best way to do this? I wasn't sure if I should use <code>Observable.of</code> and subscribe to the result of  <code>IdentityProvider.shared.login</code></p>
","7579156","","","","","2019-03-18 17:17:43","How can I wrap an async function with an Observable","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"55237384","1","","","2019-03-19 09:20:47","","1","570","<p>I have a <code>UITableViewController</code> setup as below.</p>

<p><strong>View Controller</strong></p>

<pre><code>class FeedViewController: BaseTableViewController, ViewModelAttaching {

    var viewModel: Attachable&lt;FeedViewModel&gt;!
    var bindings: FeedViewModel.Bindings {
        let viewWillAppear = rx.sentMessage(#selector(UIViewController.viewWillAppear(_:)))
            .mapToVoid()
            .asDriverOnErrorJustComplete()

        let refresh = tableView.refreshControl!.rx
            .controlEvent(.valueChanged)
            .asDriver()

        return FeedViewModel.Bindings(
            fetchTrigger: Driver.merge(viewWillAppear, refresh),
            selection: tableView.rx.itemSelected.asDriver()
        )
    }

    override func viewDidLoad() {
        super.viewDidLoad()
    }

    func bind(viewModel: FeedViewModel) -&gt; FeedViewModel {
        viewModel.posts
            .drive(tableView.rx.items(cellIdentifier: FeedTableViewCell.reuseID, cellType: FeedTableViewCell.self)) { _, viewModel, cell in
                cell.bind(to: viewModel)
            }
            .disposed(by: disposeBag)

        viewModel.fetching
            .drive(tableView.refreshControl!.rx.isRefreshing)
            .disposed(by: disposeBag)

        viewModel.errors
            .delay(0.1)
            .map { $0.localizedDescription }
            .drive(errorAlert)
            .disposed(by: disposeBag)

        return viewModel
    }
}
</code></pre>

<p><strong>View Model</strong></p>

<pre><code>class FeedViewModel: ViewModelType {

    let fetching: Driver&lt;Bool&gt;
    let posts: Driver&lt;[FeedDetailViewModel]&gt;
    let selectedPost: Driver&lt;Post&gt;
    let errors: Driver&lt;Error&gt;

    required init(dependency: Dependency, bindings: Bindings) {

        let activityIndicator = ActivityIndicator()
        let errorTracker = ErrorTracker()

        posts = bindings.fetchTrigger
            .flatMapLatest {
                return dependency.feedService.getFeed()
                    .trackActivity(activityIndicator)
                    .trackError(errorTracker)
                    .asDriverOnErrorJustComplete()
                    .map { $0.map(FeedDetailViewModel.init) }
        }

        fetching = activityIndicator.asDriver()
        errors = errorTracker.asDriver()
        selectedPost = bindings.selection
            .withLatestFrom(self.posts) { (indexPath, posts: [FeedDetailViewModel]) -&gt; Post in
                return posts[indexPath.row].post
        }
    }

    typealias Dependency = HasFeedService

    struct Bindings {
        let fetchTrigger: Driver&lt;Void&gt;
        let selection: Driver&lt;IndexPath&gt;
    }
}
</code></pre>

<p>I have binding that detects when a row is selected, a method elsewhere is triggered by that binding and presents a view controller.</p>

<p>I am trying to assert that when a row is selected, a view is presented, however I cannot successfully simulate a row being selected.</p>

<p>My attempted test is something like</p>

<pre><code>   func test_ViewController_PresentsDetailView_On_Selection() {

        let indexPath = IndexPath(row: 0, section: 0)
        sut.start().subscribe().disposed(by: rx_disposeBag)
        let viewControllers = sut.navigationController.viewControllers

        let vc = viewControllers.first as! FeedViewController
        vc.tableView(tableView, didSelectRowAt: indexPath)

        XCTAssertNotNil(sut.navigationController.presentedViewController)
    }
</code></pre>

<p>But this fails with the exception </p>

<blockquote>
  <p>unrecognized selector sent to instance</p>
</blockquote>

<p>How can I simulate the row is selected in my unit test?</p>
","7579156","","","","","2019-03-19 10:46:46","How can I simulate a tableView row selection using RxSwift","<ios><swift><uitableview><xctest><rx-swift>","1","0","","","","CC BY-SA 4.0"
"55237803","1","55290214","","2019-03-19 09:41:06","","1","517","<p>I have a VC(A) that has a container view and changes the VC(B-C) it based on the segementControl value, Im sending a request and getting a response inside the A ViewController and i want to make sure both B and C view controllers observe the response from A and set the data</p>

<p>Im new to rxswift so bear with me please</p>

<p>initiating both child VCS inside A VC</p>

<pre><code>private lazy var profileVC: ProfileVC = {
    // Load Storyboard
    let storyboard = UIStoryboard(name: ""Profile"", bundle: Bundle.main)

    // Instantiate View Controller
    var viewController = storyboard.instantiateViewController(withIdentifier: ""ProfileVC"") as! ProfileVC

    // Add View Controller as Child View Controller
    self.add(asChildViewController: viewController)

    return viewController
}()

private lazy var socialMediaVC: SocialMediaVCViewController = {
    // Load Storyboard
    let storyboard = UIStoryboard(name: ""Profile"", bundle: Bundle.main)

    // Instantiate View Controller
    var viewController = storyboard.instantiateViewController(withIdentifier: ""SocialMediaVC"") as! SocialMediaVCViewController

    // Add View Controller as Child View Controller
    self.add(asChildViewController: viewController)

    return viewController
}()
</code></pre>

<p>adding and removing functions inside A ViewController</p>

<pre><code>func add(asChildViewController viewController: UIViewController) {
    // Add Child View as Subview
    containerView.addSubview(viewController.view)

    // Configure Child View
    viewController.view.frame = view.bounds
    viewController.view.autoresizingMask = [.flexibleWidth, .flexibleHeight]
}



private func remove(asChildViewController viewController: UIViewController) {
    // Notify Child View Controller
    viewController.willMove(toParent: nil)

    // Remove Child View From Superview
    viewController.view.removeFromSuperview()

    // Notify Child View Controller
    viewController.removeFromParent()
}
</code></pre>

<p>segemntController change </p>

<pre><code> @IBAction func segmentedControlClicked(_ sender: UISegmentedControl) {
        segmentedControl.changeUnderlinePosition()
        if segmentedControl.selectedSegmentIndex == 0 {
            remove(asChildViewController: socialMediaVC)
            add(asChildViewController: profileVC)
        } else {
            remove(asChildViewController: profileVC)
            add(asChildViewController: socialMediaVC)
        }
    }
</code></pre>

<p>sending request and getting response inside A ViewModel:</p>

<pre><code>    startedUp.accept(true)
    startedUp.filter({ $0})
        .flatMap{ [weak self] _ -&gt; Observable&lt;Event&lt;Result&lt;ProfileResponse&gt;&gt;&gt; in
            self?.loadInProgress.accept(true)
            return network.showProfile(startupId: 1).materialize()}
        .subscribe(onNext: { [weak self] event in
            self?.loadInProgress.accept(false)
            switch event {
            case .next(let result):
                switch result{
                case .Success(let response):
                    self?.startedUp.accept(false)
                    self?.sectionSubject.onNext(0)
                    self?.output.editProfileData = (self?.setProfileData(response:response))!
                    self?.tableViewcellsSubject.onNext((self?.createArray(response: response))!)
                    self?.userscellsSubject.onNext((self?.createUserArray(response: response.users!))!)
                case .Failure(let error):
                    self?.errorsSubject.onNext(error)
                }
            case .error( _):
                print(""error"")
            default:
                break
            }
        })
        .disposed(by: disposeBag)
</code></pre>
","4700622","","","","","2019-03-21 22:31:47","Passing data from parent VC to child VC after getting response using subjects","<ios><swift><rx-swift>","1","1","0","","","CC BY-SA 4.0"
"55244235","1","55259638","","2019-03-19 15:10:21","","2","243","<p>When using large titles in the navigation bar along with a UITableView that is bound to an Rx driver data source I’ve noticed that if the binding and initial data load happens while the view is offscreen, when you navigate to that view it will be scrolled such that the large title is shrunk to the “minimized” position.</p>

<p>Overall setup is a UITableViewController with <code>prefersLargeTitles = true</code> set. Tableview is setup and subsequently bound to the Rx datasource within <code>viewDidLoad</code>.</p>

<p>Example code:</p>

<pre class=""lang-swift prettyprint-override""><code>override func viewDidLoad() {
  super.viewDidLoad()
  setupTableView()
  bindToTableView()

  // ...
}

private func setupTableView() {
  tableView.register(cellType: Cell.self)
  tableView.tableFooterView = UIView()
  tableView.separatorStyle = .none

  // ...

  // We are required to first reset the data source and delegate to allow
  // for RxCocoa to take over control.
  tableView.dataSource = nil
  tableView.delegate = nil
  tableView.rx.setDelegate(self)
    .disposed(by: bag)

  // ...
}

private func bindToModel() {
  viewModel.modelDriver
    .drive(tableView.rx.items) { tableView, row, model in
      let indexPath = IndexPath(row: row, section: 0)
      let cell: Cell = tableView.dequeueReusableCell(for: indexPath)
      cell.prepare(with: model)
      return cell
    }.disposed(by: bag)
}
</code></pre>

<p>And by ""shrunk"" I mean the titles switch to this style:</p>

<p><a href=""https://i.stack.imgur.com/VfPOc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/VfPOc.png"" alt=""small nav title""></a></p>

<p>Has anyone else encountered this issue?</p>

<hr>

<p><strong>Solved:</strong> As @daniel-t mentions below the problem is not caused by Rx specifically, but by the timing of when <code>prefersLargeTitles = true</code>. If this property is not set <strong>before</strong> the call to <code>tableView.reloadData()</code> occurs then the table will load in the data and scroll appropriately <em>for non-large titles</em>. Then after large titles is set the tableview doesn't reset it's scroll position to compensate for the new, larger navigation bar area.</p>

<p>The reason this manifests somewhat weirdly, even when using something like <code>.skipUntil(...viewWillAppear)</code>, is because the act of binding triggers an initial Rx update which reloads the tableview.</p>
","3434244","","3434244","","2019-03-20 14:05:34","2019-03-20 14:05:34","Navigation bar Large Titles are shrunk if data is loaded off-screen through an Rx datasource binding","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"55256454","1","55264979","","2019-03-20 08:33:11","","0","286","<p>I am currently working a project with a requirement to refactor the <code>RxSwift</code> dependencies for introduce <code>PromiseKit</code>. </p>

<p>I am not hugely familiar with <code>RxSwift</code> or <code>PromiseKit</code> so please forgive me if this is an obvious one.</p>

<p>I am looking for a way to handle the Zip use case still</p>

<pre><code>override func start() -&gt; Observable&lt;CoordinationResult&gt; {

    let tabBarController = UITabBarController()
    let tabs: [SectionTab] = [.feed]
    let coordinationResults = Observable.from(configure(tabBarController: tabBarController, withTabs: tabs)).merge()

    window.rootViewController = tabBarController
    window.makeKeyAndVisible()

    return coordinationResults
        .take(1)
}

private func configure(tabBarController: UITabBarController, withTabs tabs: [SectionTab]) -&gt; [Observable&lt;Void&gt;] {
    let navControllers = tabs
        .map { tab -&gt; UINavigationController in
            let navController = BaseNavigationController()
            navController.tabBarItem = UITabBarItem(title: tab.title, image: nil, selectedImage: nil)
            return navController
    }

    tabBarController.viewControllers = navControllers
    tabBarController.view.backgroundColor = UIColor.white // Fix dark shadow in nav bar on segue

    return zip(tabs, navControllers)
        .map { (tab, navController) in
            switch tab {
            case .feed:
                let coordinator = FeedCoordinator(navigationController: navController, dependencies: dependencies)
                return coordinate(to: coordinator)
            }
    }
}
</code></pre>

<p>From what I understand, <code>Zip</code> combines 2 Observables and allows you to action on them, emitting a single observable, which is essentially the result of the 2 original observables and your action.</p>
","10823240","","","","","2019-03-20 16:07:25","Does PromiseKit have an RxSwift Zip alternative?","<ios><swift><rx-swift><promisekit>","1","0","","","","CC BY-SA 4.0"
"55289674","1","55355966","","2019-03-21 21:41:09","","1","82","<p>My code looks like this:</p>

<pre><code> private let myPublishSubject = PublishSubject&lt;Bool&gt;()

 func method(input: String) -&gt; String {
     if input == something {
         myPublishSubject.onNext(true)
         return update(input)
     }
     myPublishSubject.onNext(false)
     return input
 }

 // Output
 let driver: Driver&lt;String&gt;

 init() {
     let myObservable = Observable.just(""a"")
     driver = Observable.combineLatest(myObservable, myPublishSubject)
         .map { 
...
         }
         .asDriver()
 }
</code></pre>

<p>Now, in debug, I figured out that <code>driver</code> only subscribed and disposed of. when <code>method</code> called afterward, there isn't any subscriber to <code>myPublishSubject.onNext</code>.
How can I fix it?</p>
","860234","","","","","2019-03-26 11:23:37","Observable doesn't receives events","<ios><observable><rx-swift><object-lifetime><combinelatest>","1","1","","","","CC BY-SA 4.0"
"55294293","1","55303594","","2019-03-22 06:50:34","","12","9408","<p>I have 2 questions:</p>

<ol>
<li>What difference between 'bind(onNext:' and 'subscribe(onNext:'?</li>
</ol>

<pre class=""lang-swift prettyprint-override""><code>struct Info {
    var index: Int?
    var data: String?
}

let infoData: BehaviorRelay&lt;Info&gt; = BehaviorRelay&lt;Info&gt;(value: Info())
var osInfo: Observable&lt;String&gt; { return self.infoData.map({ return $0.data }).distinctUntilChanged() }

osInfo.bind { (target) in
    print(""bind!"")
    }.disposed(by: self.disposeBag)

osInfo.subscribe { (target) in
    print(""subscribe!"")
    }
    .disposed(by: self.disposeBag)
</code></pre>

<ol start=""2"">
<li>a has no asObservable(), but well executable. What is difference a and b?</li>
</ol>

<pre class=""lang-swift prettyprint-override""><code>a. var osInfo: Observable&lt;String&gt; { return self.infoData.map({ return $0.data }).distinctUntilChanged() }
b. var osInfo: Observable&lt;String&gt; { return self.infoData.asObservable().map({ return $0.data }).distinctUntilChanged() }

</code></pre>
","1095040","","4280337","","2019-03-22 12:50:17","2020-12-09 19:57:57","rxswift bind(onNext: VS subscribe(onNext:","<rx-swift><rx-cocoa>","1","0","5","","","CC BY-SA 4.0"
"55296667","1","55297106","","2019-03-22 09:36:31","","3","261","<p>I currently have a set of network requests to fire.
The problem is that I need to order the results of them to fit the order I fired them.</p>

<p>My current code is the following:</p>

<pre><code>for url in config.fieldImages.map ({ URL(string: $0)! }) {
    self.getWheelFieldImage(url: url)
        .takeUntil(.inclusive, predicate: { (_) -&gt; Bool in
            images.count == config.fieldImages.count - 1
        })
        .subscribe(onNext: { (anImage) in
            images.append(anImage)
        }, onError: { (error) in
            completion(nil, nil, error)
        }, onCompleted: {
            completion(images, false, nil)
            self.lastUpdate = Date()
        }, onDisposed: {
    })
    .disposed(by: self.disposeBag)
}
</code></pre>

<p><strong>I'm wondering if there is an easy way to order these results in the same order I fired them, using RxSwift</strong>.</p>

<p>EDIT:</p>

<p>I try to explain the problem better. I have this array with N URLs and I fire the requests one after the other (1,2,3,4...).</p>

<p>I need to have back the result from these requests in the same order (R1, R2, R3, R4, where R1 is the response from request 1 etc...) to store the images in the resulting array.</p>

<p>I can wait all to finish. No problem.</p>
","709811","","1331310","","2019-03-22 09:56:09","2019-03-22 10:16:43","Order network requests result with RxSwift","<swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"55344839","1","55347793","","2019-03-25 19:05:29","","0","435","<p>I'm looking for the optimal way to avoid defining </p>

<pre><code>protocol SomeTableviewCellDelegate: class {
    func didSelectTopic(topic: RTopic)
}
</code></pre>

<p>and use RxSwift instead.</p>

<p>I already have defined</p>

<pre><code>var didSelectTopic: Observable&lt;RTopic&gt; {
    return _didSelectTopic.asObservable()
}
private let _didSelectTopic = PublishSubject&lt;RTopic&gt;()

var didDeselectTopic: Observable&lt;RTopic&gt; {
     return _didDeselectTopic.asObservable()
}
private let _didDeselectTopic = PublishSubject&lt;RTopic&gt;()
</code></pre>

<p>I can't find the proper way to emit a topic (I am new to RxSwift).</p>
","1088288","","","","","2019-03-25 23:23:40","How to replace a simple delegate protocol with RxSwift?","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"55352478","1","","","2019-03-26 08:12:04","","1","270","<p>I have simple tableview. . When I want to delete cell from table view, I get that error.</p>

<p><strong>View controller code</strong>:</p>

<pre><code>class FoodCategoryDetailTableViewController: UITableViewController {
    var foodCategoryDetailViewModel: FoodCategoryDetailTableViewViewModelType?

    private let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        guard let foodCategoryDetailViewModel = foodCategoryDetailViewModel else { return }

        tableView.delegate = nil
        tableView.dataSource = nil

        foodCategoryDetailViewModel.foodsInSelectedCategory
            .bind(to: tableView.rx.items(cellIdentifier: FoodCategoryDetailTableViewCell.cellIdentifier, cellType: FoodCategoryDetailTableViewCell.self))
            { row, food, cell in
                cell.foodCategoryDetailCellViewModel = foodCategoryDetailViewModel.cellViewModel(forRow: row)
            }.disposed(by: disposeBag)

        tableView.rx.itemDeleted.subscribe({ [unowned self] indexPath in
            self.foodCategoryDetailViewModel?.removeFoodFromApplication(atRow: (indexPath.element?.row)!)
            self.tableView.reloadData()
        }).disposed(by: disposeBag)
    }
</code></pre>

<p><strong>View Model code</strong>:</p>

<pre><code>class FoodCategoryDetailTableViewViewModel: FoodCategoryDetailTableViewViewModelType {
    var foodsInSelectedCategory: BehaviorRelay&lt;[Food]&gt;
    private var foodCategoryId: Int16

    func cellViewModel(forRow row: Int) -&gt; FoodTableViewCellViewModelType? {
        if let food = getFood(atRow: row) {
            return FoodTableViewCellViewModel(foodModel: food)
        }
        return nil
    }

    func removeFoodFromApplication(atRow row: Int) {
        if let food = getFood(atRow: row) {
            var foods = foodsInSelectedCategory.value
            foods.remove(at: row)
            self.foodsInSelectedCategory = BehaviorRelay(value: foods)
            CoreDataHelper.sharedInstance.removeFoodFromApplication(foodName: food.name!)
        }
    }

    private func getFood(atRow row: Int) -&gt; Food? {
        let food = foodsInSelectedCategory.value[row]

        return food
    }

    init(foodCategoryId: Int16) {
        self.foodCategoryId = foodCategoryId
        self.foodsInSelectedCategory = BehaviorRelay(value: CoreDataHelper.sharedInstance.fetchFoodsFromSelectedCategory(foodCategoryId: self.foodCategoryId))
    }
}
</code></pre>

<p>I am using Core Data. I get error in function <code>getFood()</code>. It error exist because <code>row</code> in view controller have old count of items in tableview. It is not updating with new count of items (foods) after delete cell.</p>
","5004769","","","","","2019-03-26 08:12:04","Fatal error: Index out of range when delete cell from tableview rxswift","<ios><swift><uitableview><rx-swift>","0","11","","","","CC BY-SA 4.0"
"55356766","1","55357125","","2019-03-26 12:06:48","","0","412","<p>I know there are a lot of questions about this, I looked at all of them but it doesn't fix my problem. I also commented on one of them but the question doesn't seem to be active anymore so I don't expect an answer there.</p>

<p>I'm trying to implement RxDataSources. See my code below:</p>

<pre><code>struct ActiveOrdersSection: Equatable {
    static func == (lhs: ActiveOrdersSection, rhs: ActiveOrdersSection) -&gt; Bool {
        return true
    }

    var header: String
    var orders: [Order]
}

extension ActiveOrdersSection: SectionModelType {
    typealias Item = Order

    var items: [Item] {
        set {
            orders = items
        }
        get {
            return orders
        }
    }

    init(original: ActiveOrdersSection, items: [Order]) {
        self = original
        self.items = items
    }
}
</code></pre>

<p>And the ViewController:</p>

<pre><code>class MainViewController: UITableViewDelegate, UITableViewDataSource {

    var db: DisposeBag?
    var dataSource: RxTableViewSectionedReloadDataSource&lt;ActiveOrdersSection&gt;?
    private func setupOrderRx(_ shopId: Int64) {
        let dataSource = RxTableViewSectionedReloadDataSource&lt;ActiveOrdersSection&gt;(
            configureCell: { ds, tv, ip, item in
                let cell = tv.dequeueReusableCell(withIdentifier: ""Cell"", for: ip) as! UITableViewCell
                cell.textLabel?.text = ""Item \(item.id)""
                return cell
            },

            titleForHeaderInSection: { ds, ip in
                return ds.sectionModels[ip].header
            }
        )

        self.dataSource = dataSource
        db = DisposeBag()
        let ors = OrderRxService.listAsShop(shopId, status: .active)
            .map { Observable.just($0.items) } // Convert from Observable&lt;CollectionResponse&lt;Order&gt;&gt; to Observable&lt;Order&gt;
            .observeOn(MainScheduler.instance)
            .bind(to: self.rxTableView.rx.items(dataSource: dataSource))
    }

}
</code></pre>

<p>I get <code>Generic parameter 'Self' could not be inferred</code> on <code>.bind(to: self.rxTableView.rx.items(dataSource: dataSource))</code>. I looked at the RxDataSources examples and seem to have it the same now, but I can't seem to fix this error.</p>

<p>Any ideas?</p>
","2399348","","","","","2019-03-26 12:25:06","RxDataSources `Generic parameter 'Self' could not be inferred`","<ios><swift><rx-swift><rxdatasources>","1","0","","","","CC BY-SA 4.0"
"55377361","1","55388552","","2019-03-27 12:36:24","","3","1330","<p>When a user swipe a cell, it becomes possible to delete it. However, the deletion occurs without animation.</p>

<p><strong>Part of code in my ViewController:</strong></p>

<pre><code>override func viewDidLoad() {
        super.viewDidLoad()

        guard let foodCategoryDetailViewModel = foodCategoryDetailViewModel else { return }

        tableView.delegate = nil
        tableView.dataSource = nil

        foodCategoryDetailViewModel.foodsInSelectedCategory
            .bind(to: tableView.rx.items(cellIdentifier: FoodCategoryDetailTableViewCell.cellIdentifier, cellType: FoodCategoryDetailTableViewCell.self))
            { row, food, cell in
                cell.foodCategoryDetailCellViewModel = foodCategoryDetailViewModel.cellViewModel(forRow: row)
            }.disposed(by: disposeBag)

        tableView.rx.itemDeleted.subscribe(onNext: { indexPath in
            foodCategoryDetailViewModel.removeFoodFromApplication(atRow: indexPath.row)
        }).disposed(by: disposeBag)
    }
</code></pre>

<p><strong>Part of code in my ViewModel:</strong></p>

<pre><code>class FoodCategoryDetailTableViewViewModel: FoodCategoryDetailTableViewViewModelType {
    var foodsInSelectedCategory: BehaviorRelay&lt;[Food]&gt;

    func removeFoodFromApplication(atRow row: Int) {
        if let food = getFood(atRow: row) {
            foodsInSelectedCategory.remove(at: row)
            //remove from core data   
          CoreDataHelper.sharedInstance.removeFoodFromApplication(foodName: food.name!)
        }
    }
</code></pre>

<p>How to animating deleting process from tableView?</p>
","5004769","","","","","2019-03-28 00:42:03","How to animate deleting cell from tableview (rxswift)?","<ios><swift><uitableview><rx-swift>","1","0","","","","CC BY-SA 4.0"
"55378613","1","55379752","","2019-03-27 13:38:15","","1","3435","<p>Currently for our API requests we use Rx. An example of how we use it is:</p>

<pre><code>let orderRxService = OrderRxService.listAsShop(shopId, status: .active)
    .repeatRequest(delay: 4)
    .observeOn(MainScheduler.instance)
    .subscribe( onNext: { [weak self] orders in
        self?.orders = orders
        self?.tableView.reloadData()
    })
    .disposed(by: disposeBag)
</code></pre>

<p>This gets all orders for given <code>shopId</code> with the status <code>.active</code>. On every update the local <code>orders</code> object is replaced and the tableView is reloaded.</p>

<p>This reload the whole tableView, which we wanna avoid. I'm now looking into RxDataSources but can't really figure out what is the way to get this working.</p>

<p>An <code>Order</code> object has another property <code>currentStatus</code>, which can be 3 different values.
What we have is a tableView with 3 different sections, each section displaying all orders for a <code>currentStatus</code>.</p>

<p>How should this be implemented in RxDataSources? Ideally would be to bind it to the service I showed earlier (<code>OrderRxService.....subscribe()..</code>).</p>

<p>What I have now to setup the RxDataSources-types is:</p>

<pre><code>extension Order: IdentifiableType, Equatable {
    public typealias Identity = String

    public var identity: String {
        return String(id)
    }

    public static func == (lhs: Order, rhs: Order) -&gt; Bool {
        return (lhs.timeCreated ?? 0) &gt; (rhs.timeCreated ?? 0)
    }
}

struct OrdersSection {
    var header: String
    var orders: [Order]
}

extension OrdersSection: AnimatableSectionModelType {
    typealias Item = Order
    typealias Identity = String

    var identity: String {
        return header
    }

    var items: [Item] {
        set {
            orders = items
        }
        get {
            return orders
        }
    }

    init(original: OrdersSection, items: [Order]) {
        self = original
        self.items = items
    }
}
</code></pre>

<p>What I tried to make it work is:</p>

<pre><code>// I tried to make our local orders a Variable (I don't like this between-step and would like this to be just [Order]).
var orders: Variable&lt;[Order]&gt; = Variable([])


fun viewDidLoad() {
    super.viewDidLoad()

    // Then I set the local orders-variable's value to the new value coming from our Rx service.
    let orderRxDisposable: Disposable = OrderRxService.listAsShop(shopId, status: .active)
        .repeatRequest(delay: 4)
        .observeOn(MainScheduler.instance)
        .map { $0.items }.subscribe( onNext: { [weak self] orders in
            self?.orders.value = orders
        })

    // Here I setup the dataSource
    let dataSource = RxTableViewSectionedAnimatedDataSource&lt;OrdersSection&gt;(
        configureCell: { ds, tv, ip, item in
            let cell = tv.dequeueReusableCell(withIdentifier: ""OrderCell"", for: ip) as! OrderCell
            cell.addContent(item, tableView: tv, viewController: self, spotDelegate: self)
            return cell
        },

        titleForHeaderInSection: { ds, ip in
            return ds.sectionModels[ip].header
        }
    )

    // Here I set up the three different sections.
    self.orders.asObservable().observeOn(MainScheduler.instance)
        .map { o in
            o.filter { $0.currentStatus == .status_one }
        }
        .map { [OrdersSection(header: ""Status one"", orders: $0)] }
        .bind(to: self.tableView.rx.items(dataSource: dataSource))

    self.orders.asObservable().observeOn(MainScheduler.instance)
        .map { o in
            o.filter { $0.currentStatus == .status_two }
        }
        .map { [OrdersSection(header: ""Status two"", orders: $0)] }
        .bind(to: self.tableView.rx.items(dataSource: dataSource))

    self.orders.asObservable().observeOn(MainScheduler.instance)
        .map { o in
            o.filter { $0.currentStatus == .status_three }
        }
        .map { [OrdersSection(header: ""Status three"", orders: $0)] }
        .bind(to: self.tableView.rx.items(dataSource: dataSource))

}
</code></pre>

<p>There are probably different aspects that can be improved. For example the <code>Variable&lt;[Order]&gt;</code> I would like to be just <code>[Order]</code>.
And instead of making this observable, could that be skipped altogether and create the three different sections by observing our OrderRxService?</p>

<p>Would it be possible to have it something like:</p>

<pre><code>OrderRxService.listAsshop(shopId, status: .active).observeOn(MainScheduler.instance)
    // First section
    .map { o in
        o.filter { $0.status == .status_one }
    }
    .map { [OrdersSection(header: ""Status one"", orders: $0)] }
    .bind(to: self.tableView.rx.items(dataSource: dataSource))
    // Second section
    .map { o in
        o.filter { $0.status == .status_two }
    }
    .map { [OrdersSection(header: ""Status two"", orders: $0)] }
    .bind(to: self.tableView.rx.items(dataSource: dataSource))
    // Etc...
</code></pre>

<p>Thanks for any help!</p>
","2399348","","2399348","","2019-03-27 14:26:44","2019-08-27 07:06:29","RxDataSources tableView with multiple sections from one API source","<ios><swift><rx-swift><rxdatasources>","1","0","3","","","CC BY-SA 4.0"
"55393373","1","55393693","","2019-03-28 08:48:01","","3","1301","<p>I have a simple stream that has numbers. I want to do some mathematical operations and then collect results sequentially in an array. How can i do that ?</p>

<pre><code>func test (number : Int) -&gt; Observable&lt;Int&gt; {
        let obs2 = Observable&lt;Int&gt;.create { (obs) -&gt; Disposable in
            obs.onNext(number + 10)
            return Disposables.create()
        }

        return obs2
    }

let obs = Observable.from([1,2,3,4]).flatMap { (item) -&gt; Observable&lt;Int&gt; in
            self.test(number: item)
            }.map { (result) -&gt; Int in
                return result
            }

//I want this: 
obs.subscribe(onNext : {[Int] in 
     ...
     ...
}
</code></pre>

<p>I can't combine every int to an array.</p>
","2203593","","402366","","2019-03-31 21:06:54","2019-03-31 21:06:54","How do I combine observable loop results to array in RxSwift?","<rx-swift><reactive><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"55405648","1","","","2019-03-28 19:39:13","","2","922","<p>I am looking for solution for a problem I am facing. I have TableView which has multiple cell and each cell has a <strong>UISwitch</strong> and state of that switch (either on/off) is being set like this: </p>

<pre><code>viewModel.permissions
        .drive(tblMessageTypes.rx.items(cellIdentifier: ""PermissionCellIdentifier"", cellType: PermissionTableViewCell.self)) { [switchSubject] _, item, cell in
            cell.backgroundColor = .clear
            cell.lblTitle.text = item.permissionTitle
            cell.lblDetail.text = item.permissionDescirption
            cell.selectionStyle = .none
            cell.switchPermission.isOn = item.permissionValue
            cell.switchPermission.isEnabled = !item.isPermissionReadOnly

            cell.switchPermission.rx.controlEvent(.valueChanged)
                .withLatestFrom(cell.switchPermission.rx.value)
                .map { isOn in
                    var newPermission = item
                    newPermission.permissionValue = isOn
                    return newPermission
                }
                .bind(to: switchSubject)
                .disposed(by: cell.disposeBag)
        }
        .disposed(by: disposeBag)
</code></pre>

<p>So when Switch is toggled, I am passing an current cell value with update Switch state and based on that I am calling api in my VM like this:</p>

<pre><code>let serverReponse =  inputs.switchToggle
        .map { permission in
            let dicto = permission.toDictionary()
            let parameters = [""permissions"": [dicto]]
            return parameters
        } .flatMapLatest { parameters in
            userService.updateUserPermission(parameters: parameters)
                .trackActivity(inputs.indicator)
                .materialize()
        }
        .share()
</code></pre>

<p>Now the issue I have is, if api is failed due to any reason, How should that <strong><em>UISwitch</em></strong> should fallback to initial state, i.e if it was Off and user toggled it to On State and Api was failed it should fall back to <strong>Off</strong> State.</p>
","1419216","","","","","2019-03-29 01:57:36","RxSwift: UISwitch toggle back to initial State","<ios><swift><rx-swift><reactive><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"55416047","1","","","2019-03-29 11:03:51","","0","874","<p>I have been playing about with the PokeApi while doing some RxSwift practice. Pokeapi can be found here</p>

<p><a href=""https://pokeapi.co/"" rel=""nofollow noreferrer"">https://pokeapi.co/</a></p>

<p>Example of api I am working with</p>

<p>While searching through pokemon, you can set a limit of how many you want returned, then in the response, there is a next and previous param so you can continue going forward and backgrounds through the pokemon. Example of part of the response</p>

<p><a href=""https://pokeapi.co/api/v2/pokemon/?limit=20"" rel=""nofollow noreferrer"">https://pokeapi.co/api/v2/pokemon/?limit=20</a></p>

<blockquote>
  <p>{""count"":964,""next"":""<a href=""https://pokeapi.co/api/v2/pokemon/?offset=20&amp;limit=20"" rel=""nofollow noreferrer"">https://pokeapi.co/api/v2/pokemon/?offset=20&amp;limit=20</a>"",""previous"":null,""results"":....</p>
</blockquote>

<p>In my controller, there is text field where they can enter how many pokemon they want returned per page, and then when they hit search, results returned in table and they can hit next and previous to cycle through the pages. My Model looks like this</p>

<pre><code>struct PokemonSearchData: Codable {
    let next: String?
    let previous: String?
    let results: [PokemonResultsData]
}

struct PokemonResultsData: Codable {
    let name: String
    let url: String
}
</code></pre>

<p>Here is part of view model showing what I am doing atm</p>

<pre><code>extension PokeListViewModel: ViewModelType {
    struct Input {
        let limitText: Observable&lt;String&gt;
        let startRequest: PublishSubject&lt;Void&gt;
        let nextTap: Observable&lt;Void&gt;
        let previousTap: Observable&lt;Void&gt;
        let selectedPokemon: Observable&lt;PokemonResultsData&gt;
    }

    struct Output {
        let responseData: Observable&lt;PokemonSearchData&gt;
        let errors: Driver&lt;Error&gt;
    }

    func transform(input: PokeListViewModel.Input) -&gt; PokeListViewModel.Output {
        let request = input.startRequest
            .withLatestFrom(input.limitText)
            .flatMap { text in
            self.service.fetchPokemon(limit: text).materialize()
        }.share()

        let searchResponse = request.map{$0.element}.filterNil()
        let searchError = request.map{$0.error}.asDriver(onErrorJustReturn: RxError.unknown).filterNil()

        let nextURL = searchResponse.map{$0.next}.filterNil()

        // handle next request and errors
        let nextRequest = input.nextTap.withLatestFrom(nextURL).flatMap { nextURL in
            self.service.cyclePokemon(stringURL: nextURL).materialize()
            }.share()
        let nextResponse = nextRequest.map{$0.element}.filterNil()
        let nextError = nextRequest.map{$0.error}.asDriver(onErrorJustReturn: RxError.unknown).filterNil()

        let mergedResponses = Observable.merge(searchResponse, nextResponse)
        let mergedErrors = Driver.merge(searchError, nextError)

// do the same thing for previous response, just cut it out here so less code to paste, but the logic is the same

        return Output(responseData: mergedResponses,
                      errors: mergedErrors)
    }
</code></pre>

<p>The next request is dependent on the initial request, so when I hit next again, it is still based on the initial request so it just keeps returning the same data. I have seen other code samples doing pagination based on the api response having page numbers, but there is no page number here, it is all based on the previous request response. </p>

<p>Any help would be much appreciated</p>
","1047978","","","","","2019-03-29 13:15:59","RxSwift Pagination and APIs issue","<swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"55431462","1","","","2019-03-30 12:32:10","","2","235","<p>I have a json response body of messages that looks like this. For the purposes of my UI the top level message is just the first message in the list. </p>

<pre><code>{
    ""messageId"": ""1234-1234-1234"",
    ""jobId"": ""1234-1234-1234"",
    ""message"": ""This is the top level message"",
    ""createdDate"": ""2019-03-18T14:55:21.467"",
    ""user"": {},
    ""messages"": [{
            ""messageId"": ""1234-1234-1234"",
            ""jobId"": ""1234-1234-1234"",
            ""message"": ""This is the a child message"",
            ""createdDate"": ""2019-03-18T14:55:21.467"",
            ""user"": {},
            ""messages"": [],
            ""attachments"": []
        },
        {
            ""messageId"": ""1234-1234-1234"",
            ""jobId"": ""1234-1234-1234"",
            ""message"": ""This is the another child message"",
            ""createdDate"": ""2019-03-18T14:55:21.467"",
            ""user"": {},
            ""messages"": [],
            ""attachments"": []
        },
        {
            ""messageId"": ""1234-1234-1234"",
            ""jobId"": ""1234-1234-1234"",
            ""message"": ""This is the yet another child message"",
            ""createdDate"": ""2019-03-18T14:55:21.467"",
            ""user"": {},
            ""messages"": [],
            ""attachments"": []
        }
    ],
    ""attachments"": []
}
</code></pre>

<p>Server Entity</p>

<pre><code>struct MessageServer: Codable {
let messageId: String
let jobId: String
let message: String
let createdDate: Date
let user: User
let messages: [MessageServer]
let attachments: [FileServer]

init(messageId: String,
     jobId: String,
     message: String,
     createdDate: Date,
     user: User,
     messages: [MessageServer],
     attachments: [FileServer]
    ) {

    self.messageId = messageId
    self.jobId = jobId
    self.message = message
    self.createdDate = createdDate
    self.user = user
    self.messages = messages
    self.attachments = attachments
}
</code></pre>

<p>}</p>

<p>App Entity</p>

<pre><code>struct Message: Codable {
let message: String
let createdDate: Date
let displayName: String
let isMine: Bool
let attachments: [File]

init(message: String, createdDate: Date, displayName: String, isMine: Bool, attachments: [File]) {
    self.message = message
    self.createdDate = createdDate
    self.displayName = displayName
    self.isMine = isMine
    self.attachments = attachments
}
</code></pre>

<p>}</p>

<p>In my service call i would like to just return an Observable array of Messages. </p>

<pre><code>func getMessages(sectionID id: String) -&gt; Observable&lt;[Message]&gt; {
    return messageServiceEndpoints
        .getMessages(for: id)
        .map({
            $0.map({
                Message( /* init message here */ )
             })
         })
}
</code></pre>

<p>Is there a way to reduce or flatmap this down to a single array? </p>
","7231752","","7231752","","2019-03-31 15:47:35","2019-03-31 15:53:37","Reduce or Flatmap json Response to single array","<ios><swift><rx-swift>","2","1","","","","CC BY-SA 4.0"
"55436349","1","55457599","","2019-03-30 22:48:48","","1","510","<p>I wonder how to display progress for complex <code>Observable</code> when I use <code>flatMap</code> like this:</p>

<pre><code>Observable&lt;Int&gt;.from([1,2,3,4])
    .flatMap { queryApi($0) }
    .flatMap { queryApi2($0) }
    .flatMap { queryApi3($0) }
</code></pre>

<p>I was thinking to use <code>do</code> operator:</p>

<pre><code>func longOperation() -&gt; Observable&lt;Progress&gt; {

    return Observable.create { observer in
        observer.onNext(.step1)

        let operation = Observable&lt;Int&gt;.from([1,2,3,4])
            .flatMap { queryApi($0) }
            .do(onNext: { _ in observer.onNext(.step2) })
            .flatMap { queryApi2($0) }
            .do(onNext: { _ in observer.onNext(.step3) })
            .flatMap { queryApi3($0) }
            .do(onNext: { _ in observer.onNext(.finished) })
            .subscribe()

        return Disposables.create { operation.dispose() }
    }
}
</code></pre>

<p>However, I'm not sure if this is the best way to track progress. Is there any better way to handle this?</p>
","1080578","","1080578","","2019-03-30 22:56:39","2019-04-01 14:33:05","How to display progress for complex Observable?","<swift><reactive-programming><rx-swift>","1","3","1","","","CC BY-SA 4.0"
"55445316","1","","","2019-03-31 20:45:45","","2","423","<p>I'm implementing a BLE protocol between a central (iPhone) and peripheral (custom device). The protocol works as follows:</p>

<ol>
<li>central connects to peripheral and sets up notification</li>
<li>peripheral sends data on notification characteristic</li>
<li>central processes data and sends response on separate characteristic</li>
<li>peripheral sends addtnl data on notification characteristic</li>
<li>central process data and disconnects.</li>
</ol>

<p>I'm attempting to implement this in a clean way using RxBluetoothKit. It currently works, but I'd like to solve the following challenges:</p>

<ol>
<li><p>What is the best way to cleanly disconnect in step 5. I'm hoping to not have to dispose the overall observable, but rather just have it 'complete'. I'm currently using 'takeUntil', but not sure if that's the best way.</p></li>
<li><p>Allow for the notification to cleanup gracefully prior to disconnect. With my current code, I receive an 'API MISUSE can only accept commands while in the connected state' because I believe the notification is cleaning up while the disconnect is occurring.</p></li>
</ol>

<p>Thanks.</p>

<pre class=""lang-swift prettyprint-override""><code>enum TestPeripheralService: String, ServiceIdentifier {

    case main = ""CED916FA-6692-4A12-87D5-6F2764762B23""

    var uuid: CBUUID { return CBUUID(string: self.rawValue) }
}

enum TestPeripheralCharacteristic: String, CharacteristicIdentifier {

    case writer = ""CED927B4-6692-4A12-87D5-6F2764762B2A""
    case reader = ""CED9D5D8-6692-4A12-87D5-6F2764762B2A""

    var uuid: CBUUID { return CBUUID(string: self.rawValue) }

    var service: ServiceIdentifier { return TestPeripheralService.main }
}

fileprivate lazy var centralManager: CentralManager = {
    RxBluetoothKitLog.setLogLevel(.verbose)
    return CentralManager(queue: .main)
}()

func executeConnectionAndHandshake() {

    let disconnectSubject = PublishSubject&lt;Bool&gt;.init()
    var peripheral: Peripheral?
    var packetNum = 0
    _ = centralManager
        .observeState()
        .startWith(centralManager.state)
        .filter { $0 == .poweredOn }
        .flatMap { _ in self.centralManager.scanForPeripherals(withServices: [TestPeripheralService.main.uuid]) }
        .flatMap { $0.peripheral.establishConnection().takeUntil(disconnectSubject) }
        .do(onNext: { peripheral = $0 })
        .flatMap { $0.discoverServices([TestPeripheralService.main.uuid])}
        .flatMap { $0[0].discoverCharacteristics(nil)}
        .flatMap { _ in

            Observable&lt;Bool&gt;.create { event in

                let disposables = CompositeDisposable()
                let readSubject = PublishSubject&lt;Data&gt;.init()
                _ = disposables.insert(peripheral!.observeValueUpdateAndSetNotification(for: TestPeripheralCharacteristic.reader)
                    .subscribe(onNext: {
                        packetNum += 1
                        let packet = $0.value!
                        if (packetNum &lt;= 1) {
                            readSubject.onNext(packet)
                        } else {
                            event.onNext(true)
                            event.onCompleted()
                        }

                    }, onError: { event.onError($0) })
                )

                _ = disposables.insert(readSubject
                    .flatMapLatest { data -&gt; Single&lt;Characteristic&gt; in
                        var writeData = Data(capacity: 300)
                        for _ in 0..&lt;300 {
                            writeData.append(0xFF)
                        }
                        return peripheral!.writeValue(writeData, for: TestPeripheralCharacteristic.writer, type: .withResponse)
                    }
                    .subscribe(onError: { event.onError($0) })
                )

                return Disposables.create {
                    disposables.dispose()
                }
            }
            .do(onCompleted: { disconnectSubject.onNext(true) })
        }
        .subscribe(onError: { print($0) },
                   onCompleted: { print(""Connection and handshake completed"") })
}
</code></pre>
","686607","","686607","","2019-03-31 21:20:25","2019-03-31 21:20:25","RxBluetoothKit - implement read and write protocol and automatically disconnect","<core-bluetooth><rx-swift><rxiosble>","0","0","1","","","CC BY-SA 4.0"
"55452225","1","","","2019-04-01 09:47:34","","0","513","<p>I'm trying to follow <a href=""https://github.com/sergdort/CleanArchitectureRxSwift"" rel=""nofollow noreferrer"">https://github.com/sergdort/CleanArchitectureRxSwift</a> building an app with RxSwift and MVVM.</p>

<p>I can't wrap my head around how to communicate with a child view controller in this scenario.</p>

<p>I have one trigger from the <code>ParentViewController</code> that is needed in the <code>ChildViewModel</code> and a second one from the <code>ChildViewModel</code> that should trigger some UI changes in the <code>ParentViewController</code>:</p>

<pre><code>trigger1: ParentViewController (input)&gt; ... (no idea)&gt; ChildViewModel
trigger2: ChildViewModel (output)&gt; ... (no idea)&gt; ParentViewController
</code></pre>

<p>My code currently looks something like this:</p>

<pre><code>final class ParentViewController: UIViewController {
    var viewModel: ParentViewModel?
    private let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()
        bindViewModel()
    }

    private func bindViewModel() {
        guard let viewModel = self.viewModel else {
            fatalError(""View Model not set!"")
        }

        let triggerToChild = rx.someTrigger

        let input = ParentViewModel.Input(triggerToChild: triggerToChild)

        let output = viewModel.transform(input: input)

        output.triggerFromChild
            .drive(rx.someProperty)
            .disposed(by: disposeBag)
    }
}

final class ParentViewModel: ViewModelType {
    struct Input {
       let triggerToChild: Driver&lt;Void&gt;
    }
    struct Output {
       let triggerFromChild: Driver&lt;Void&gt;
    }

    func transform(input: Input) -&gt; Output {
        let triggerFromChild = ??? &lt;===================

        return Output(triggerFromChild: triggerFromChild)
    }
}

final class ChildViewController: UIViewController {
    var viewModel: ChildViewModel?
    private let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()
        bindViewModel()
    }

    private func bindViewModel() {
        guard let viewModel = self.viewModel else {
            fatalError(""View Model not set!"")
        }

        let triggerFromParent = ??? &lt;===================

        let input = ChildViewModel.Input(triggerFromParent: triggerFromParent)

        let output = viewModel.transform(input: input)

        output.triggerFromParent
            .drive(rx.someProperty)
            .disposed(by: disposeBag)
    }
}

final class ChildViewModel: ViewModelType {
    struct Input {
        let triggerFromParent: Driver&lt;Void&gt;
    }
    struct Output {
        let triggerToParent: Driver&lt;Void&gt;
    }

    func transform(input: Input) -&gt; Output {
        let triggerToParent = rx.someTrigger
        return Output(triggerToParent: triggerToParent)
    }
}
</code></pre>

<p>Maybe someone could point me in the right direction? Thank You!</p>
","676613","","","","","2019-04-01 09:47:34","RxSwift, MVVM: Communication with child view controller","<ios><mvvm><rx-swift><clean-architecture>","0","2","","","","CC BY-SA 4.0"
"55459969","1","","","2019-04-01 16:47:09","","1","306","<p>I'm trying to make code that will perform some kind of failable long-running request on particular user action, but ignore sad action while request is active. The goal is allow tapping on button as long as there is no successful emission from request. All errors are skipped. So far I came to code like this, but can't figure out what to do next:</p>

<pre><code>struct ErrorError: Error {}
var emitSuccess: Bool = false

// should be something like button.rx.tap
let buttonTap = PublishSubject&lt;Void&gt;()

let requestDuration: RxTimeInterval = 5
let tapInterval: RxTimeInterval = 3


let requestTrigger = buttonTap
    // ???
    .flatMapLatest { (_) -&gt; Observable&lt;Bool&gt; in
        // imitation of http request/parsing etc.
        if emitSuccess {
            return Observable.just(true)
                .delay(requestDuration, scheduler: MainScheduler.instance)
                .debug(""response success"", trimOutput: false)
        } else {
            emitSuccess = true
            return Observable.error(ErrorError())
                .materialize()
                .delay(requestDuration, scheduler: MainScheduler.instance)
                .dematerialize()
                .debug(""response failure"", trimOutput: false)
                .catchErrorJustComplete()
        }
    }
    .take(1) //supposed to dispose observation of taps
    .share(replay: 1, scope: .forever)

let requestResponse = requestTrigger
    .debug(""response"", trimOutput: false)
    .subscribe()

// imitate button tap
Observable&lt;Int&gt;.interval(tapInterval, scheduler: MainScheduler.instance)
    .takeUntil(Observable.just(true).delay(20, scheduler: MainScheduler.instance))
    .debug(""button tap imitation"", trimOutput: false)
    .subscribe(onNext: { (value) in
        buttonTap.onNext(())
        return
    })
</code></pre>

<p>In its current form every tap disposes uncompleted observable and starts a new one, which is undesirable. ""???"" is the place where I believe should be some clever throttling/skipping operator. </p>

<p>Things which comes to mind: </p>

<ul>
<li>replace ""???"" with <code>takeUntil(requestResponse)</code> which will lead to kind of weird recursive subscription (it is even allowed/good/bad practice?)</li>
<li>use <code>concatMap</code> instead of <code>flatMapLatest</code> but it kind of queues taps and in this case if some error occurs (no internet connection for example) it probably would occur for all queued taps->requests, meaning I need to <em>skip</em> taps</li>
<li>create my own Observable (using <code>create</code>, <code>deferred</code> etc.)</li>
</ul>
","2305175","","","","","2019-04-01 17:17:55","FlatMapLatest skip trigger until latest observable completes","<swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"55463717","1","","","2019-04-01 21:18:24","","1","1540","<p>I have a UICollectionView bound to an array of entities using BehaviorSubject and all is fine, data is loaded from the network and displayed correctly. </p>

<p>The problem is, based on user action, I'd like to change the CellType used by the UICollectionView and force the collection to re-create all cells, how do I do that?</p>

<p>My bind code looks like:</p>

<pre><code>self.dataSource.bind(to: self.collectionView!.rx.items) {
   view, row, data in

   let indexPath = IndexPath(row: row, section: 0)

   var ret: UICollectionViewCell? = nil
   if (self.currentReuseIdentifier == reuseIdentifierA) {
      // Dequeue cell type A and bind it to model
      ret = cell
   } else {
      // Dequeue cell type B and bind it to model
      ret = cell
   }

   return ret!
}.disposed(by: disposeBag)
</code></pre>
","11295421","","","","","2019-08-05 11:49:09","Is there a way to force reloadData on a UICollectionView using RxSwift?","<rx-swift>","3","0","","","","CC BY-SA 4.0"
"55469694","1","55490212","","2019-04-02 08:01:40","","2","925","<p>I am using RxSwift for the first time.
It will load Post List from my server.
The first time only need to run loadPostList
but
Just by initializing the model, nextPage is called.</p>

<p>Please let me know what I'm doing wrong.</p>

<pre><code>class PostNetworkModel {
    var nextPage:BehaviorSubject&lt;Void&gt; = BehaviorSubject(value: ())
    var reFresh:BehaviorSubject&lt;Void&gt; = BehaviorSubject(value: ())
    var raiseError:BehaviorSubject&lt;Void&gt; = BehaviorSubject(value: ())
    var isLoadingComplete = false
    private var pageNo = BehaviorRelay(value: 1)
    var postList : BehaviorRelay&lt;[Post]&gt; = BehaviorRelay(value: [])
    let disposeBag = DisposeBag()
    init() {
        loadPostList()
            .bind(to: postList)
            .disposed(by: disposeBag)

        postList
            .asObservable()
            .subscribe({ ( _) in
                self.isLoadingComplete = true
            })
            .disposed(by: disposeBag)

        nextPage
            .asObservable()
            .subscribe(onNext: { [weak self] ( _) in
                print(""nextPage"")
                if (self?.isLoadingComplete)!{
                    self?.isLoadingComplete = false
                    self?.pageNo.accept(self!.pageNo.value + 1)
                }
            })
            .disposed(by: disposeBag)
     }
}
</code></pre>
","10753916","","","","","2019-04-03 08:15:28","RxSwift subscribe will work when initiated","<ios><swift><rx-swift>","1","3","","","","CC BY-SA 4.0"
"55506806","1","55508766","","2019-04-04 02:03:37","","5","2502","<p>detect when reached tableview bottom
if not bottom <code>return Observable.empty()</code>
if tableview is bottom <code>return Observable.just(())</code></p>

<p>as i Know is <code>Observable.empty()</code> is not calling onNext</p>

<p>but <code>empty()</code> or <code>just()</code> calling onNext</p>

<pre><code>tableView.rx.contentOffset
            .map {
                self.isNearTheBottomEdge(contentOffset: $0, self.tableView) &amp;&amp; self.postModel.isLoadingComplete.value
                    ? Observable.just(())
                    : Observable.empty()
            }
            .throttle(3, scheduler: MainScheduler.instance)

            .subscribe(onNext: {
                print(""reached bottom"")
                self.postModel.nextPage.onNext(())
            },onCompleted: {
                print(""complete"")
            }
            )
            .disposed(by: disposeBag)
</code></pre>

<p><code>return Observable.empty()</code> in debug but  always <code>print(""reached bottom"")</code></p>
","10753916","","","","","2019-04-04 05:53:44","RxSwift Observable.empty() is calling onNext","<ios><swift><rx-swift>","1","0","2","","","CC BY-SA 4.0"
"55516536","1","","","2019-04-04 12:54:54","","0","547","<p>I try to use <code>retryOnBecomesReachable</code> method from the RX example files in my networking layer</p>

<pre><code>extension ObservableConvertibleType {
    func retryOnBecomesReachable(_ valueOnFailure:E, reachabilityService: ReachabilityService?) -&gt; Observable&lt;E&gt; {
        return self.asObservable()
            .catchError { (e) -&gt; Observable&lt;E&gt; in
                return reachabilityService.reachability
                    .skip(1)
                    .filter { $0.reachable }
                    .flatMap({ _ -&gt; Observable&lt;E&gt; in
                        return Observable.error(e)
                    })
                    .startWith(valueOnFailure)
            }
            .retry()
    }
}

// My layer

request
    .flatMapLatest{ request  in
        provider.rx.request(request)
            .map{ User.self }
            .map{ RequestState.loaded($0) }
            .retryOnBecomesReachable(.error(.notConnectedToInternet), reachabilityService: reachabilityService)
            .catchError({ .just(.error($0)) })
            .startWith(.startLoading)
}
</code></pre>

<p>Without this method, all works awesome. All error catching and returning <code>.just(.error($0))</code> sequence. </p>

<p>With this method, the retry feature works awesome. But when something happens (mapping, decoding or other error) I get <code>.notConnectedToInternet</code>. I think the reason in <code>.startWith(valueOnFailure)</code> method. I tried to move, remove, change position but nothing helps. I'm stuck. </p>

<p>What should I do to use retry feature and catch errors correct?</p>
","4314758","","","","","2019-04-05 19:03:21","RxSwift catch networking and reachability errors","<swift><networking><mapping><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"55531407","1","","","2019-04-05 08:38:17","","5","939","<p>i want know end of reloadTableView
Then I want to scroll down to the bottom of the table view.</p>

<p>Before I used <code>RxSwift</code>
Just after <code>reloadData</code>
It was possible using <code>setContentOffSet</code> or <code>ScrollToRow</code>.</p>

<p>I tried it with the code I found.
never called <code>endUpdates</code>.</p>

<pre><code>var replyList : BehaviorRelay&lt;[Reply]&gt;!

func bind(){

    replyViewModel.replyList
       .asDriver()
       .drive(replyTableView.rx.items){ [weak self] (tableView,row,item) in
           return self?.makeReplyCell(tableView: tableView, replyInfo: item) ?? UITableViewCell()

                }
       .disposed(by: disposeBag)

    replyTableView.endUpdatesEvent
        .asObservable()
        .subscribe({ _ in
            print(""Scroll To Bottom"")
        })
        .disposed(by: disposeBag)
}

import Foundation
import RxCocoa
import RxSwift

extension UITableView {

    /// Reactive wrapper for `UITableView.insertRows(at:with:)`
    var insertRowsEvent: ControlEvent&lt;[IndexPath]&gt; {
        let source = rx.methodInvoked(#selector(UITableView.insertRows(at:with:)))
                .map { a in
                    return a[0] as! [IndexPath]
                }
        return ControlEvent(events: source)
    }

    /// Reactive wrapper for `UITableView.endUpdates()`
    var endUpdatesEvent: ControlEvent&lt;Bool&gt; {
        let source = rx.methodInvoked(#selector(UITableView.endUpdates))
                .map { _ in
                    return true
                }
        return ControlEvent(events: source)
    }

    /// Reactive wrapper for when the `UITableView` inserted rows and ended its updates.
    var insertedItems: ControlEvent&lt;[IndexPath]&gt; {
        let insertEnded = Observable.combineLatest(
                insertRowsEvent.asObservable(),
                endUpdatesEvent.asObservable(),
                resultSelector: { (insertedRows: $0, endUpdates: $1) }
        )
        let source = insertEnded.map { $0.insertedRows }
        return ControlEvent(events: source)
    }
}
</code></pre>
","10753916","","","","","2019-04-05 08:38:17","RxSwift how to know end of TableView reload","<ios><swift><rx-swift><rxdatasources>","0","1","1","","","CC BY-SA 4.0"
"55636505","1","55681000","","2019-04-11 15:48:24","","1","1465","<p>I extended Observable of RxSwift and I am using it with Moya so I wrote it out like this</p>

<pre><code>/// JSON map to object
    /// - returns: Observable&lt;T&gt;
    func jsonMapObject&lt;T: EVReflectable&gt;(type: T.Type, forKeyPath: String? = nil) -&gt; Observable&lt;Result&lt;T, ORMError&gt;&gt;  {

        return self.map { rawResult in

            guard let result = rawResult as? Result&lt;JSON, ORMError&gt; else {
                return .failure(ORMError.ORMParseJSONError)
            }

            switch result {
            case let .success(json):

                guard json != JSON.null,
                    let dict = json.dictionaryObject else {
                        return .failure(ORMError.ORMParseJSONError)
                }

                guard let object: T = self.dictMap(from: dict) as T else {
                    return .failure(ORMError.ORMCouldNotMakeObjectError)
                }

                return .success(object)

            case let .failure(error):
                return .failure(error)
            }

        }
    }
</code></pre>

<p>after writing this code as such, I get an error in the editor saying </p>

<blockquote>
  <p>Instance method 'dictMap(from:forKeyPath:)' requires that 'NSObject' conform to 'EVReflectable'</p>
</blockquote>

<p>I do not know how to proceed again as this error does not go away</p>

<p>my dictMap is written as </p>

<p>/// </p>

<pre><code>Create the object from the dictionary
    internal func dictMap&lt;T: NSObject&gt;(from: NSDictionary?, forKeyPath: String? = nil) -&gt; T where T: EVReflectable{
        let instance: T = T()
        let parsedObject: T = ((instance.getSpecificType(from ?? NSDictionary()) as? T) ?? instance)
        let _ = EVReflection.setPropertiesfromDictionary(from ?? NSDictionary(), anyObject: parsedObject, forKeyPath: forKeyPath)
//        if self.statusCode &gt; 300  {
//            instance.addStatusMessage(DeserializationStatus.Custom, message: ""HTTP status code: \(self.statusCode)"")
//        }
        return parsedObject
    }
</code></pre>
","8310287","","","","","2019-04-14 23:38:48","Instance method requires that 'NSObject' conform","<swift><rx-swift><moya>","1","0","","","","CC BY-SA 4.0"
"55695680","1","55718767","","2019-04-15 18:58:19","","2","1190","<p>I ran into a situation where I would fetch an API which will generate json data of registered users. I would then have to loop through each user and fetch their avatar from remote url and save it to disk. I can perform this second task inside <code>subscribe</code> but this is not a best practice. I am trying to implement it with <code>map</code>, <code>flatMap</code> etc.</p>

<p>Here is my sample code:</p>

<pre><code>self.dataManager.getUsers()
            .observeOn(MainScheduler.instance)
            .subscribeOn(globalScheduler)
            .map{ [unowned self] (data) -&gt; Users in
                var users = data
// other code for manipulating users goes here
// then below I am trying to use another loop to fetch their avatars

                if let cats = users.categories {
                    for cat in cats  {
                        if let profiles = cat.profiles {
                            for profile in profiles {
                                if let thumbnail = profile.thumbnail,
                                    let url = URL(string: thumbnail) {
                                    URLSession.shared.rx.response(request: URLRequest(url: url))
                                        .subscribeOn(MainScheduler.instance)
                                        .subscribe(onNext: { response in
                                            // Update Image
                                            if let img = UIImage(data: response.data) {
                                                try? Disk.save(img, to: .caches, as: url.lastPathComponent)
                                            }
                                        }, onError: { (error) in

                                        }).disposed(by: self.disposeBag)
                                }
                            }
                        }
                    }
                }

                return users
            }
            .subscribe(onSuccess: { [weak self] (users) in

            }).disposed(by: disposeBag)
</code></pre>

<p>There are 2 problems in this code. First is with the <code>rx</code> on <code>URLSession</code> which execute the task in background on another thread and there is no way to acknowledge the main <code>subscribe</code> back when this operation will finish. Second is with the loop and rx which is not efficient as it should generate multiple observables and then process it.</p>

<p>Any idea to improve this logic is welcome.</p>
","851747","","","","","2019-04-17 10:13:32","RxSwift multiple observable in map","<rx-swift><reactivex>","1","3","1","","","CC BY-SA 4.0"
"55733968","1","","","2019-04-17 18:33:14","","3","668","<p>Hy I'm trying to come up with a solution using Moya and RxSwift that renews an Authentication token and retries the requests. </p>

<p>The problem is I have multiple requests going on at the same time, so lets say 10 requests fire while the Authentication token has expired, I will try to renew the token on all of them, and as soon as the first one renews the other ones will fail because they use a wrong token to renew.</p>

<p>What I would like to do is just build a queue (maybe) of requests and then retry those. Not sure if this is the best scenario for this.</p>

<p>This is what I have so far:</p>

<pre><code>final class NetworkOnlineProvider {

    fileprivate let database = DatabaseClient(database: DatabaseRealm()).database
    fileprivate let provider: MoyaProvider&lt;NetworkAPI&gt;

    init(endpointClosure: @escaping MoyaProvider&lt;NetworkAPI&gt;.EndpointClosure = MoyaProvider&lt;NetworkAPI&gt;.defaultEndpointMapping,
         requestClosure: @escaping MoyaProvider&lt;NetworkAPI&gt;.RequestClosure = MoyaProvider&lt;NetworkAPI&gt;.defaultRequestMapping,
         stubClosure: @escaping MoyaProvider&lt;NetworkAPI&gt;.StubClosure = MoyaProvider.neverStub,
         manager: Manager = MoyaProvider&lt;NetworkAPI&gt;.defaultAlamofireManager(),
         plugins: [PluginType] = [],
         trackInflights: Bool = false) {

        self.provider = MoyaProvider(endpointClosure: endpointClosure, requestClosure: requestClosure, stubClosure: stubClosure, manager: manager, plugins: plugins, trackInflights: trackInflights)
    }

    fileprivate func getJWTRenewRequest() -&gt; Single&lt;Response&gt;? {
        if let token = JWTManager.sharedInstance.token {

            return provider.rx.request(.renew(token: token))
        }

        return nil
    }

    func tokenRequest() -&gt; Single&lt;String&gt; {
        let errorSingle = Single&lt;String&gt;.create { single in
            single(.error(APIError.failure))

            return Disposables.create()
        }

        let emptyJWTSingle = Single&lt;String&gt;.create { single in
            single(.success(""""))

            return Disposables.create()
        }

        // Return if no token found
        guard let appToken = JWTManager.sharedInstance.getJWT() else {
            return refreshToken() ?? emptyJWTSingle
        }

        // If we have a valid token, just return it
        if !appToken.hasTokenExpired {
            return Single&lt;String&gt;.create { single in
                single(.success(appToken.token))

                return Disposables.create()
            }
        }

        // Token has expired
        let newTokenRequest = refreshToken()
        return newTokenRequest ?? errorSingle
    }

    func refreshToken() -&gt; Single&lt;String&gt;? {
        return getJWTRenewRequest()?
            .debug(""Renewing JWT"")
            .filterSuccessfulStatusCodes()
            .map { (response: Response) -&gt; (token: String, expiration: Double) in
                guard let json = try? JSON(data: response.data) else { throw RxError.unknown }

                let success = json[""success""]

                guard
                    let jwt = success[""jwt""].string,
                    let jwt_expiration = success[""jwt_expiration""].double,
                    let valid_login = success[""valid_login""].bool, valid_login
                    else { throw RxError.unknown }

                return (token: jwt, expiration: jwt_expiration)
            }
            .do(onSuccess: { (token: String, expiration: Double) in
                JWTManager.sharedInstance.save(token: JWT(token: token, expiration: String(expiration)))
            })
            .map { (token: String, expiration: Double) in
                return token
            }
            .catchError { e -&gt; Single&lt;String&gt; in
                print(""Failed to Renew JWT"")
                JWTManager.sharedInstance.delete()

                UIApplication.shared.appDelegate.cleanPreviousContext(jwt: true)
                let loginVC = UIStoryboard(storyboard: .login).instantiateViewController(vc: LoginViewController.self)
                UIApplication.shared.appDelegate.window?.setRootViewController(UINavigationController(rootViewController: loginVC))

                throw e
            }
    }

    func request(_ target: NetworkAPI) -&gt; Single&lt;Response&gt; {
        let actualRequest = provider.rx.request(target)

        if target.isAuthenticatedCall {
            return tokenRequest().flatMap { _ in
                actualRequest
            }
        }


        return actualRequest
    }
}
</code></pre>
","2694525","","2694525","","2019-04-17 18:39:47","2019-04-17 21:25:17","RxSwift renew Authentication Token","<swift><oauth><rx-swift><moya>","1","0","1","","","CC BY-SA 4.0"
"55758695","1","55760371","","2019-04-19 08:12:54","","0","2576","<p>I have such code as below. How can I achieve it in one chain, without using subscribe on timer? I would like to attach 'timerInterval' to 'timer' and then call subscribe.</p>

<pre><code>var timerInterval: BehaviorRelay&lt;String&gt; = BehaviorRelay(value: """")

...

func doLogic() {
    let timer = Observable&lt;Int&gt;.interval(0.05, scheduler: MainScheduler.instance)

    timer.subscribe({ [weak self] value in
            let doubleValue = Double(value.element ?? 0)
            let dividedValue = doubleValue / 20.0
            let text = String(format: ""%.2f"", dividedValue)
            self?.timerInterval.accept(text)
        }).disposed(by: disposeBag)
}
</code></pre>
","7516911","","","","","2019-04-19 11:24:36","Binding BehaviorRelay with Observable - RxSwift","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"55759896","1","","","2019-04-19 09:48:46","","2","545","<p>I want to check text validate when tap button. If validate failure, it will show error text on UILabel and do not send request. Else if validate success, it will send request. </p>

<p>I see many demo about login, but they control button enabled to avoid validate data when tap button. I am puzzled with it.</p>

<p>I have write some code.</p>

<pre><code>class LoginViewModel: BaseViewModel, ViewModelType {
    struct Input {
        let loginTaps: Driver&lt;Void&gt;
    }
    struct Output {
        let validatedUsername: Driver&lt;Bool&gt;
        let validatedPassword: Driver&lt;Bool&gt;
    }

    let username = BehaviorRelay(value: """")
    let password = BehaviorRelay(value: """")
    let loginTapped = PublishSubject&lt;Void&gt;()

    func transform(input: Input) -&gt; Output {

        let validatedUsername = username.asDriver(onErrorJustReturn: """").map { username in
            return username.isPhoneNumber
        }

        let validatedPassword = password.asDriver(onErrorJustReturn: """").map { password in
            return password.count &gt; 7
        }

        input.loginTaps.map { () -&gt; Void in
            &lt;#code#&gt;
            // I want do check and then do network request
        }

        input.loginTaps.drive(onNext: { [weak self] () in
                self?.loginTapped.onNext(())
            }).disposed(by: rx.disposeBag)

        loginTapped.flatMapLatest { _  -&gt; Observable&lt;RxSwift.Event&lt;Token&gt;&gt; in

           // and if I want to return Bool not Token, how should I do????????????

            return self.provider.login(username: self.username.value, password: self.password.value)
                .asObservable()
                .materialize()
            }.subscribe(onNext: { (event) in
                switch event {
                case .next(let token):
                    AuthManager.setToken(token: token)
                case .error(let error):
                    log.error(error.localizedDescription)
                default: break
                }
            }).disposed(by: rx.disposeBag)

        return Output(validatedUsername: validatedUsername,
                      validatedPassword: validatedPassword)
    }
}

</code></pre>
","5347067","","","","","2019-04-20 02:09:07","I want to check text validate when tap button","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"55777104","1","55777554","","2019-04-20 19:41:36","","1","627","<p>I am trying to make a regex string for date like <a href=""https://www.regextester.com/97612"" rel=""nofollow noreferrer"">this</a>. My code (Swift 5 example):</p>

<pre><code>let dateValidator = TextValidator(input: dateTextField.rx.text.asObservable(), regex: try! NSRegularExpression(pattern:
    #""^\s*(3[01]|[12][0-9]|0?[1-9])\.(1[012]|0?[1-9])\.((?:19|20)\d{2})\s*$""#))

let v = Observable.combineLatest(dateValidator.validate(), anotherValidator.validate()) {
    (date, another) in
    return date &amp;&amp; another
}
//another code

class TextValidator {
    var input: Observable&lt;String?&gt;
    var regex: NSRegularExpression

    init(input: Observable&lt;String?&gt;, regex: NSRegularExpression) {
        self.input = input
        self.regex = regex
    }

    func validate() -&gt; Observable&lt;Bool&gt; {
        return input.map { text in
            let range = NSRange(location: 0, length: text!.utf8.count)
            return self.regex.firstMatch(in: text!, options: [], range: range) != nil
        }
    }
}
</code></pre>

<p>And I get error: </p>

<blockquote>
  <p>Terminating app due to uncaught exception 'NSRangeException', reason:
  '*** -[NSRegularExpression
  enumerateMatchesInString:options:range:usingBlock:]: Range or index
  out of bounds'</p>
</blockquote>

<p>Another regex works correctly. I think that error for backslash in regex.</p>
","5004769","","","","","2019-04-20 20:40:18","How to create date regex with Swift?","<ios><swift><regex><rx-swift>","1","5","","","","CC BY-SA 4.0"
"55786232","1","55793821","","2019-04-21 19:54:24","","1","1557","<p>I have a list of observables that are requests for google distance and duration info from an specific point. I'm trying to load my screen only when all this information is fetched, but my subscribe on next for those observables are never called (the line ""observer.onNext(viewModel)"" is called and has the information already fetched, only the subscribe(onNext) is not being called). How can I wait til those observables complete? </p>

<pre><code>func stationInfoObservable(userLocation: CLLocationCoordinate2D, stations: [Station]) -&gt; [Observable&lt;GasStationTableCellViewModel&gt;] {

    var observables: [Observable&lt;GasStationTableCellViewModel&gt;] = []

    for station in stations {
        observables.append(Observable.create({ observer in
            guard let toCoordinate = station.coordinate() else { return Disposables.create() }

            self.mapDirections.routes(from: userLocation.asPlace(), to: toCoordinate.asPlace()) { routes, error in
                if let error = error {
                    logger.error(error)
                } else {
                    guard let leg = routes.first?.legs?.first else {
                        return
                    }

                    guard let distance = leg.distance?.text, let duration = leg.duration?.text else { return }
                    station.distanceInKMFromUserLocation = distance
                    station.distanceInMinutesFromUserLocation = duration

                    let viewModel = GasStationTableCellViewModel(station: station)

                    observer.onNext(viewModel)
                    observer.onCompleted()
                }
            }
            return Disposables.create()
        }))
    }

    return observables
}
</code></pre>

<p>I'm trying to subscribe this way (EDIT: I'm now trying to use zip, but the the drive / subscribe continues not being called): </p>

<pre><code>Observable.zip(observables)
            .asDriver(onErrorJustReturn: [])
            .drive(onNext: { test in
                print(test)
            }, onCompleted: {
                print(""aa"")
            }).disposed(by: DisposeBag())
</code></pre>
","985979","","985979","","2019-04-21 20:13:06","2019-04-22 11:40:07","Wait multiple observable requests to finish using RXSwift","<swift><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"55809179","1","","","2019-04-23 10:27:44","","-1","511","<p>I'm facing a problem when selecting the table view row on RxSwift. For details, the code on the do(onNext:) function is called twice, thus lead to the navigation pushed twice too. Here is my code in the viewModel, please help me resolve it. Thanks so much.</p>

<pre><code>struct Input {
    let loadTrigger: Driver&lt;String&gt;
    let searchTrigger: Driver&lt;String&gt;
    let selectMealTrigger: Driver&lt;IndexPath&gt;
}

struct Output {
    let mealList: Driver&lt;[Meal]&gt;
    let selectedMeal: Driver&lt;Meal&gt;
}

func transform(_ input: HomeViewModel.Input) -&gt; HomeViewModel.Output {
    let popularMeals = input.loadTrigger
        .flatMap { _ in
            return self.useCase.getMealList()
            .asDriver(onErrorJustReturn: [])
    }

    let mealSearchList = input.searchTrigger
        .flatMap { text in
            return self.useCase.getMealSearchList(mealName: text)
            .asDriver(onErrorJustReturn: [])
    }

    let mealList = Observable.of(mealSearchList.asObservable(), popularMeals.asObservable()).merge().asDriver(onErrorJustReturn: [])

    let selectedMeal = input.selectMealTrigger
        .withLatestFrom(mealList) { $1[$0.row] }
        .do(onNext: { meal in
            self.navigator.toMealDetail(meal: meal)
        })

    return Output(mealList: mealList, selectedMeal: selectedMeal)
}
</code></pre>

<p>Edit: Here's the implemetation on the ViewController:</p>

<pre><code>func bindViewModel() {
    self.tableView.delegate = nil
    self.tableView.dataSource = nil
    let emptyTrigger = searchBar
    .rx.text.orEmpty
    .filter { $0.isEmpty }
    .throttle(0.1, scheduler: MainScheduler.instance)
    .asDriver(onErrorJustReturn: """")

    let loadMealTrigger = Observable
    .of(emptyTrigger.asObservable(), Observable.just(("""")))
    .merge()
    .asDriver(onErrorJustReturn: """")

    let searchTrigger = searchBar.rx.text.orEmpty.asDriver()
    .distinctUntilChanged()
    .filter {!$0.isEmpty }
    .throttle(0.1)

    let selectMealTrigger = tableView.rx.itemSelected.asDriver()

    let input = HomeViewModel.Input(
        loadTrigger: loadMealTrigger,
        searchTrigger: searchTrigger,
        selectMealTrigger: selectMealTrigger
    )

    let output = viewModel.transform(input)

        output.mealList
            .drive(tableView.rx.items(cellIdentifier: MealCell.cellIdentifier)) { index, meal, cell in
                let mealCell = cell as! MealCell
                mealCell.meal = meal
    }
    .disposed(by: bag)

    output.selectedMeal
    .drive()
    .disposed(by: bag)
    }
</code></pre>
","9166913","","9166913","","2019-04-23 14:23:54","2019-04-23 14:23:54","do(onNext:) called twice when table view row is selected","<ios><swift><uitableview><uinavigationcontroller><rx-swift>","1","0","","","","CC BY-SA 4.0"
"55816934","1","55817032","","2019-04-23 17:59:03","","1","112","<p>I'm getting a very weird error using RXSwift. I'm calling a service that is a Single trait and when I just print the error my code compile without problem, but if I try to do something else in ""onError"", the code doens't compile. Someone had the same problem? </p>

<p>The piece of code that doesn't compile: </p>

<pre><code>NetworkManager.shared.authorizeService(with: parameters)
            .subscribe(onSuccess: { [weak self] status in

                }, onError: { [weak self] error in
                    paymentAuthorizationFinishedWithError.onNext(APIResponseError.paymentAlreadyInProgress)
            }).disposed(by: bag)
</code></pre>

<p>The code that compiles:</p>

<pre><code>NetworkManager.shared.authorizeService(with: parameters)
            .subscribe(onSuccess: { [weak self] status in

                }, onError: { [weak self] error in
                    print(error)
            }).disposed(by: bag)
</code></pre>

<p><a href=""https://i.stack.imgur.com/ZZx88.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZZx88.png"" alt=""enter image description here""></a></p>

<p><a href=""https://i.stack.imgur.com/l4fNV.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/l4fNV.png"" alt=""enter image description here""></a></p>
","985979","","","","","2019-04-23 18:06:03","Extra argument 'onError' in call using RXSwift Single Trait","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"55843575","1","55846854","","2019-04-25 07:02:50","","1","139","<p>For example in the following code the default ObserverType has an event onError where Swift.Error object can be passed. How can I create custom ObserverType / Event so that I'll be able to supply an object of a custom class.</p>

<pre><code>class LoginService: LoginServiceProtocol {
func signIn(with credentials: Credentials) -&gt; Observable&lt;User&gt; {
    return Observable.create { observer in
        /*
         Networking logic here.
        */
        observer.onNext(User()) // Simulation of successful user authentication.
        observer.onError(&lt;#T##error: Error##Error#&gt;) // want to user custom class object instead of Swift.Error object here
        return Disposables.create()
    }
}
}
</code></pre>
","2881549","","","","","2019-04-25 10:12:10","How to create customer Observer Event using EventConvertible in RxSwift?","<rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"55847632","1","","","2019-04-25 10:53:50","","0","1011","<p>I am bamboozled by the following code that works if I uncomment the commented code below. If I comment it, it doesn't work. I have no idea about what the issue is :</p>

<pre class=""lang-swift prettyprint-override""><code>func getMostPopularRepositories(byLanguage language: String) -&gt; Observable&lt;[Repository]&gt; {
  let encodedLanguage = language.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)!

  let provider = MoyaProvider&lt;Github&gt;(plugins: [NetworkLoggerPlugin(verbose: true)])
  let parameters = [“q”: “language:\(encodedLanguage)“,“sort”: “stars”]

  /*
  provider.rx
    .request(.repositories(parameters))
    .map([Repository].self, atKeyPath: “items”)
    .subscribe { event in
  }.dispose()
  */

  let request = provider.rx.request(.repositories(parameters)).asObservable()
  // RxSwift.(unknown context at $101ccc3e8).AnonymousObservable&lt;Moya.Response&gt;
  print(request)
  let pRepos = request.map([Repository].self, atKeyPath: “items”)
  // RxSwift.(unknown context at $101ccf26c).FlatMap&lt;Moya.Response, RxSwift.Observable&lt;Swift.Array&lt;RepoSearcher.Repository&gt;&gt;&gt;
  print(pRepos)
  return pRepos
}
</code></pre>
","3972195","","4834335","","2019-04-25 11:04:12","2019-04-26 07:31:22","RxSwift API response","<swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"55863905","1","","","2019-04-26 08:43:09","","1","236","<p><code>iOS</code> - RxRealm - Is it possible to get updated event even if the dataset is not changed</p>

<p>Is it possible in RxRealm to get a notification even if my dataset is the same?
When I subscribe to the collection (no items at app launch) I get back an empty array. (it's fine at this point)
My problem is that my API request may return with an empty array as well, and in this case, I didn’t get any notification from the <strong>RxRealm.collection</strong>, So I don't know if my request is finished or I was just reading the database.</p>

<p>I tried to call <code>realm.refresh()</code> but it didn't help</p>

<p>This is what I'm observing:</p>

<pre class=""lang-swift prettyprint-override""><code>func findAll() -&gt; Results&lt;T&gt; {
    return realm.objects(T.self)
}
    .
    .
    .

Observable.collection(from: findAll()).map(Array.init) 
</code></pre>

<p>This is how I rebuild my database after API request is finished:</p>

<pre class=""lang-swift prettyprint-override""><code>func rebuildDatabase(objects: [T], with update: Bool = false) {
        realm.refresh() // trying to force refresh event
        do {
            realm.beginWrite()
            realm.delete(self.findAll())
            realm.add(objects, update: update)
            try realm.commitWrite()
        } catch {
            Log.error(error.localizedDescription)
        }
    }

</code></pre>

<p>Is it possible to archive this behavior with some configuration or is there any line of code that will force the notification? Thank for all the answers</p>
","4058105","","1968952","","2019-04-29 09:25:28","2019-04-29 09:25:28","iOS - RxRealm - Is it possible to get updated event even if dataset is not changed","<ios><swift><realm><rx-swift>","0","4","","","","CC BY-SA 4.0"
"55865017","1","","","2019-04-26 09:50:11","","1","293","<p>I have an app where I used RxSwift for my networking by extending ObservableType this works well but the issue I am having now is when I make an API request and there is an error, I am unable to show the particular error message sent from the server. Now how can I get the particular error response sent from the server</p>

<pre><code>extension ObservableType {

    func convert&lt;T: EVObject&gt;(to observableType: T.Type) -&gt; Observable&lt;T&gt; where E: DataRequest {

        return self.flatMap({(request) -&gt; Observable&lt;T&gt; in

            let disposable = Disposables.create {
                request.cancel()
            }

            return Observable&lt;T&gt;.create({observer -&gt; Disposable in

                request.validate().responseObject { (response: DataResponse&lt;T&gt;) in
                                        switch response.result {
                    case .success(let value):

                        if !disposable.isDisposed {
                            observer.onNext(value)
                            observer.onCompleted()
                        }
                    case .failure(let error):

                        if !disposable.isDisposed {
                            observer.onError(NetworkingError(httpResponse: response.response,
                                                             networkData: response.data, baseError: error))
                            observer.onCompleted()
                        }

                    }
                }

                return disposable
            })

        })
    }

}

let networkRetryPredicate: RetryPredicate = { error in
    if let err = error as? NetworkingError, let response = err.httpResponse {
        let code = response.statusCode
        if code &gt;= 400 &amp;&amp; code &lt; 600 {
            return false
        }
    }

    return true
}

// Use this struct to pass the response and data along with 
// the error as alamofire does not do this automatically
public struct NetworkingError: Error {
    let httpResponse: HTTPURLResponse?
    let networkData: Data?
    let baseError: Error
}
</code></pre>

<p>response from the server could be </p>

<pre><code>{
  ""status"" : ""error"",
  ""message"" : "" INSUFFICIENT_FUNDS""
}
</code></pre>

<p>or </p>

<pre><code>{
  ""status"" : ""success"",
  ""data"" : "" gghfgdgchf""
}
</code></pre>

<p>my response is handled like this</p>

<pre><code>class MaxResponse&lt;T: NSObject&gt;: MaxResponseBase, EVGenericsKVC {
    var data: T?

    public func setGenericValue(_ value: AnyObject!, forUndefinedKey key: String) {
        switch key {
        case ""data"":
            data = value as? T
        default:
            print(""---&gt; setGenericValue '\(value)' forUndefinedKey '\(key)' should be handled."")
        }
    }

    public func getGenericType() -&gt; NSObject {
        return T()
    }
}
</code></pre>

<p>the error is</p>

<pre><code>return ApiClient.session.rx.request(urlRequest: MaxApiRouter.topupWall(userId: getUser()!.id!, data: body))
            .convert(to: MaxResponse&lt;Wall&gt;.self)
</code></pre>
","8310287","","8310287","","2019-04-30 11:45:07","2019-05-15 09:24:56","getting error message from server during API call","<swift><generics><alamofire><rx-swift>","1","11","","","","CC BY-SA 4.0"
"55886840","1","","","2019-04-28 03:45:42","","0","402","<p>RxSwift: how to get rid of callback hells of subscribe events and network request?</p>

<p>I am a new Swifter, Here is the code of my new company.</p>

<p>The following code is very wired. </p>

<p>The logic is easy . BoutiqueOutput has a requestCommand,which is PublishSubject. It is  used to do some refresh thing (request the network initailly and again ).</p>

<p>The callback hell is in it. The network layer Moya was used in a RxSwift way.</p>

<p>New to RxSwift , I do not know the pattern to refactor it nicely.</p>

<p>How to use filter/ map / combine operators in the right way?</p>

<p>This is the model encapulated with RxSwift</p>

<pre><code>
import RxSwift
import RxCocoa
import RxDataSources
import MJRefresh
import Moya
import MoyaMapper


// this is the Moya Network Provider
let Provider = MoyaProvider&lt;Router&gt;(endpointClosure: EndpointClosure, requestClosure: requestClosure, plugins: [networkPlugin, MoyaMapperPlugin(NetParameter())], trackInflights: false)


struct BoutiqueOutput: OutputRefreshProtocol {

    var refreshStatus = Variable&lt;RefreshStatus&gt;(.none)

    let sections: Driver&lt;[CategoryLeftSection]&gt;

    let requestCommand = PublishSubject&lt;Bool&gt;()
    init(sections: Driver&lt;[CategoryLeftSection]&gt;) {
        self.sections = sections
    }
}


class CategoryViewModel: NSObject {

    let vmDatas = Variable&lt;[ParentItem]&gt;([])

    func transform() -&gt; BoutiqueOutput {

        let tempSections = vmDatas.asObservable().map({ (sections) -&gt; [CategoryLeftSection] in
            return [CategoryLeftSection(items: sections)]
        }).asDriver(onErrorJustReturn: [])

        let output = BoutiqueOutput(sections: tempSections)
        output.requestCommand.subscribe(onNext:{[weak self] _ in
            guard let self = self else { return }
            Provider.rx.cacheRequest(.baseUIData).subscribe( onNext:{ result in
                // do some UI 
                if result.statusCode == 200 || result.statusCode == 230 {
                    // do something business
                } 

            }).disposed(by: self.rx.disposeBag)
        }).disposed(by: rx.disposeBag)
        return output
    }
}


</code></pre>

<p>This is how the model applied</p>

<pre><code>private var vmOutput: BoutiqueOutput?


override func viewDidLoad() {
        super.viewDidLoad()
        self.vmOutput = viewModel.transform()
        boundTableViewData()
    // ...
}


private func boundTableViewData() {

    let dataSource = RxTableViewSectionedReloadDataSource&lt;CategoryLeftSection&gt;( configureCell: { [weak self] ds, tv, ip, item in
     // ...
     }


  vmOutput!.sections.asDriver().drive(self.leftMenuTableView.rx.items(dataSource: dataSource)).disposed(by: rx.disposeBag)

     // ...

    vmOutput!.requestCommand.onNext(true)

}



private func requestErrorRefresh() {
     // ...
     if isNetworkConnect {
           boundTableViewData()
           vmOutput!.requestCommand.onNext(true)
     }
}


private func noNetworkRefresh() {
     // ...
     if isNetworkConnect {
           boundTableViewData()
           vmOutput!.requestCommand.onNext(true)
     }
}

</code></pre>
","10332481","","","","","2019-04-28 05:26:03","RxSwift: how to get rid of callback hells of subscribe events and network request?","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"55889255","1","55991682","","2019-04-28 10:18:12","","1","472","<p>I am a new Swifter, Here is the code of my new company.</p>

<p>Use RxSwift，use RxDataSource, how to handle two table view association?</p>

<p>The left tableView's cell clicked , the right tableView's data changed along.</p>

<p>Organize the right table view's data via the variables of middle state.</p>

<p>Bad code's smell。</p>

<p>Here is the image</p>

<p><a href=""https://i.stack.imgur.com/kXgus.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kXgus.png"" alt=""one""></a></p>

<p>Here is the code：</p>

<pre><code>private let viewModel = CategoryViewModel()
private var currentListData :[SubItems]?
private var lastIndex : NSInteger = 0
private var currentSelectIndexPath : IndexPath?
private var currentIndex : NSInteger = 0

private func boundTableViewData() {

    var loadCount = 0
    // data source of left table view
    let dataSource = RxTableViewSectionedReloadDataSource&lt;CategoryLeftSection&gt;( configureCell: { ds, tv, ip, item in
    let cell = tv.dequeueReusableCell(withIdentifier: ""Cell1"", for: ip) as! CategoryLeftCell
    cell.model = item
     if ip.row == 0, !cell.isSelected {
          // in order to give the right table view a start show
             tv.selectRow(at: ip, animated: false, scrollPosition: .top)
             tv.delegate?.tableView!(tv, didSelectRowAt: ip)

        }
       return cell
    })

    vmOutput!.sections.asDriver().drive(leftMenuTableView.rx.items(dataSource: dataSource)).disposed(by: rx.disposeBag)

   // organize the right table view's data via the variables of middle state.

  // bad code's smell
    let listData = leftMenuTableView.rx.itemSelected.distinctUntilChanged().flatMapLatest {
        [weak self](indexPath) -&gt;  Observable&lt;[SubItems]&gt; in
            guard let self = self else { return Observable.just([]) }
            // ...
            self.currentIndex = indexPath.row
            if indexPath.row == self.viewModel.vmDatas.value.count - 1 {
                // ...
           // the self.currentSelectIndexPath was used, because when the left tableView's final cell got clicked, the  UI logic is different.
                self.leftMenuTableView.selectRow(at: self.currentSelectIndexPath, animated: false, scrollPosition: .top)
                return Observable.just((self.currentListData)!)
            }
            if let subItems = self.viewModel.vmDatas.value[indexPath.row].subnav {
                var fisrtSubItem = SubItems()
                fisrtSubItem.url = self.viewModel.vmDatas.value[indexPath.row].url
                fisrtSubItem.name = self.viewModel.vmDatas.value[indexPath.row].banner
                var reult:[SubItems] = subItems
                reult.insert(fisrtSubItem, at: 0)
                self.currentListData = reult
              //  self.currentListData is used to capture the current data of the right table view.
                self.currentSelectIndexPath = indexPath
                return Observable.just(reult)
            }
            return Observable.just([])
    }.share(replay: 1)

    // data source of right table view    
     let listDataSource =  RxTableViewSectionedReloadDataSource&lt;CategoryRightSection&gt;( configureCell: { [weak self]ds, tv, ip, item in
            guard let self = self else { return UITableViewCell() }
            if self.lastIndex != self.currentIndex {
           // to compare the old and new selected index of the left table View ,give a new start to the right table view if changed
                tv.scrollToRow(at: ip, at: .top, animated: false)
                self.lastIndex = self.currentIndex
            }
            if ip.row == 0 {
                let cell = CategoryListBannerCell()
                cell.model = item
                return cell
            } else {
                let cell = tv.dequeueReusableCell(withIdentifier: ""Cell2"", for: ip) as! CategoryListSectionCell
                cell.model = item
                return cell
            }
     })


     listData.map{ [CategoryRightSection(items:$0)] }.bind(to: rightListTableView.rx.items(dataSource: listDataSource))
            .disposed(by: rx.disposeBag)   
 }     
</code></pre>

<p><code>private var lastIndex : NSInteger = 0</code>, used to compare the old and new selected index of the left table View ,let the right table view start , with <code>currentIndex</code>, if different</p>

<p>the <code>self.currentSelectIndexPath</code> was used, because when the left tableView's final cell got clicked, the  UI logic is different.</p>

<p><code>self.currentListData</code> is used to capture the current data of the right table view, when the left tableView clicked with different row.</p>

<p><code>self.currentListData</code> is also used in the <code>UITableViewDelegate</code>.</p>

<pre><code>// MARK:- UITableViewDelegate
extension CategoryViewController : UITableViewDelegate {
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {
        switch indexPath.row {
        case 0 :
            return (mScreenW - 120)/240 * 100;
        default :
            let subItems:SubItems = self.currentListData![indexPath.row]
            if subItems.children.count &gt; 0{
                let lines: NSInteger = (subItems.children.count - 1)/3 + 1
                let buttonHeight = (mScreenW - 136 - 108)/3
                let allButtonHeight = buttonHeight/44 * 63 * CGFloat(lines)
                let other =  (lines - 1)*42 + 56
                let height = allButtonHeight  + CGFloat(other) + 33
                return height
            }
            return 250
        }
    }
}
</code></pre>

<p>How to improve the code?</p>

<p>How to eliminate the variables of middle state.</p>

<p>The corresponding model is</p>

<pre><code>class CategoryViewModel: NSObject {

    let vmDatas = Variable&lt;[ParentItem]&gt;([])

    func transform() -&gt; MCBoutiqueOutput {

        let temp_sections = vmDatas.asObservable().map({ (sections) -&gt; [CategoryLeftSection] in
            let count = sections.count
            if count &gt; 0{
                let items = sections[0..&lt;(count-1)]
                return [CategoryLeftSection(items: Array(items))]
            }
            return []
        }).asDriver(onErrorJustReturn: [])

        let output = MCBoutiqueOutput(sections: temp_sections)
        Observable.combineLatest(output.requestCommand, Provider.rx.cacheRequest(.baseUIData)).subscribe({  [weak self]  ( result: Event&lt;(Bool, Response)&gt;) in
            guard let self = self else { return }
            switch result{
            case .next(let response):
                let resultReal = response.1
                // ...
                if resultReal.statusCode == 200 || resultReal.statusCode == 230 {

                    if resultReal.fetchJSONString(keys:[""code""]) == ""0"" {
                        mUserDefaults.set(false, forKey: ""categoryVCShowTry"")
                        self.vmDatas.value = ParentItem.mapModels(from:
                            resultReal.fetchJSONString(keys:[""data"",""data""]))
                    } 
                }
            default:
                break
            }
        }).disposed(by: rx.disposeBag)
        return output
    }
}
</code></pre>
","10332481","","10332481","","2019-05-05 11:51:35","2019-05-05 11:58:51","How to handle two table view association?","<swift><rx-swift><rxdatasources>","2","2","","","","CC BY-SA 4.0"
"55914681","1","55954057","","2019-04-30 05:51:47","","0","163","<p>How come this works, which was written before Swift 5?</p>

<pre><code>viewmodel
      .postSeekerAvatar(data: data)    
      .flatMap {
        self.viewmodel.updateSeeker(withFirstName: params.firstName, lastName: params.lastName, isBusiness: params.isBusiness, abn: ""none"", address: params.address)
      }
      .subscribe(onSuccess: { (_) in
        SVProgressHUD.dismiss()
        self.performSegue(withIdentifier: SegueConstants.toProfileForm, sender: self)
      }) { (error) in
        SVProgressHUD.showDismissableInfo(with: error.message)
    }.disposed(by: disposeBag)
</code></pre>

<p>But once I updated to Swift 5, the code does not throw an error but when I use the <code>.flatMap {}</code> closure it throws an error stating</p>

<p><a href=""https://i.stack.imgur.com/BwZi1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BwZi1.png"" alt=""enter image description here""></a></p>

<p><a href=""https://i.stack.imgur.com/cap1Z.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/cap1Z.png"" alt=""enter image description here""></a></p>
","5100250","","1226963","","2019-04-30 06:05:34","2019-05-02 13:55:07","Flatmap in RxSwift Swift 5","<swift><rx-swift><swift5>","1","2","","","","CC BY-SA 4.0"
"55915894","1","","","2019-04-30 07:29:21","","1","2609","<p>Im trying to create an observable from a simple Int so I can subscribe to it upon changing, but it only listens on the first load, what am I missing? </p>

<pre><code>private func startObserving() {

    getRating().subscribe(onNext: { (rating: Int) in
        print(""NAKO \(rating)"")
    })

}

private func getRating() -&gt; Observable&lt;Int&gt; {
    return Observable.create{ observer in
        observer.on(.next(self.ratingView.rating()))
        observer.on(.completed)
        return Disposables.create()
    }
}
</code></pre>
","11070352","","6296561","","2019-07-10 13:42:46","2019-07-10 13:42:46","Simple swift variable to rxswift observable","<ios><swift><rx-swift>","3","4","","","","CC BY-SA 4.0"
"55920257","1","","","2019-04-30 11:46:12","","3","834","<p>Writing a project on <strong>MVVM</strong> and trying to bind everything with <strong>RxSwift</strong>.
Unfortunately I did not manage to find a proper way how to bind an actions.</p>

<p>For example, I have a table and a simple cells with one button - ""Select"".</p>

<p>For this purposes I will have two view models: <code>ListViewModel</code> &amp; <code>CellViewModel</code></p>

<p><code>ListViewModel</code> will be creating an array of <code>CellViewModel</code> and need to subscribe on selection event(custom event). </p>

<p>Now I'm using BehaviorSubject for this purposes, but it looks ugly. Who can point me how it need to be implemented with <strong>RxSwift</strong>?</p>

<pre><code>class CellViewModel {

    private let selectionSubject = BehaviorSubject&lt;Void&gt;(value: ())

    // Will be used by ListViewModel
    var selectionObservable: Observable&lt;Void&gt; {
        return selectionSubject.asObservable()
    }

    func subscribeOnSelection(_ observable: Observable&lt;Void&gt;, disposeBag: DisposeBag) {
        observable
            .bind(to: selectionSubject)
            .disposed(by: disposeBag)
    }

    private func autoSelect() {
        selectionSubject.on(next: ())
    }
}

class Cell: UITableViewCell {
    @IBOutlet private var selectionButton: UIButton!

    private let disposeBag = DisposeBag()

    func bind(to viewModel: CellViewModel) {
        viewModel.subscribeOnSelection(selectionButton.rx.tap.asObservable(), disposeBag: disposeBag)
    }
}
</code></pre>
","3417231","","3417231","","2019-04-30 13:07:27","2019-04-30 14:56:05","RxSwift. What to use for Observable<Void>?","<swift><mvvm><observable><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"55927846","1","","","2019-04-30 19:52:08","","1","221","<p>I want to have this delete to be reactive with RxCcocoa and RxSwift using DelegateProxy. I am getting this error:</p>

<blockquote>
  <p>Argument of '#selector' refers to instance method
  'rangeSeekSlider(_:didChange:maxValue:)' that is not exposed to
  Objective-C</p>
</blockquote>

<p>The delegate I am converting from this library: <a href=""https://github.com/WorldDownTown/RangeSeekSlider/blob/master/Sources/RangeSeekSliderDelegate.swift"" rel=""nofollow noreferrer"">https://github.com/WorldDownTown/RangeSeekSlider/blob/master/Sources/RangeSeekSliderDelegate.swift</a></p>

<pre><code>import CoreGraphics

public protocol RangeSeekSliderDelegate: class {

/// Called when the RangeSeekSlider values are changed
///
/// - Parameters:
///   - slider: RangeSeekSlider
///   - minValue: minimum value
///   - maxValue: maximum value
func rangeSeekSlider(_ slider: RangeSeekSlider, didChange minValue: CGFloat, maxValue: CGFloat)

...
}
</code></pre>

<p>And here is the the delegate proxy</p>

<pre><code>import RxSwift
import RxCocoa
import RangeSeekSlider

final class RxRangeSeekSliderDelegateProxy:
DelegateProxy&lt;RangeSeekSlider, RangeSeekSliderDelegate&gt;,
RangeSeekSliderDelegate,
DelegateProxyType {

init(rangeSeekSlider: RangeSeekSlider) {
    super.init(parentObject: rangeSeekSlider, delegateProxy: RxRangeSeekSliderDelegateProxy.self)
}

static func registerKnownImplementations() {
    register { RxRangeSeekSliderDelegateProxy(rangeSeekSlider: $0) }
}

static func currentDelegate(for object: RangeSeekSlider) -&gt; RangeSeekSliderDelegate? {
    return object.delegate
}

static func setCurrentDelegate(_ delegate: RangeSeekSliderDelegate?, to object: RangeSeekSlider) {
    object.delegate = delegate
}
}
</code></pre>

<p>The reactive extension of the slider, this is where I get the error:</p>

<pre><code>import RxSwift
import RxCocoa
import RangeSeekSlider


extension Reactive where Base: RangeSeekSlider {
var delegate: DelegateProxy&lt;RangeSeekSlider, RangeSeekSliderDelegate&gt; {
    return RxRangeSeekSliderDelegateProxy.proxy(for: base)
}

var didChange: Observable&lt;(Bool, Bool)&gt; {
    let source = delegate.methodInvoked(#selector(RangeSeekSliderDelegate.rangeSeekSlider(_:didChange:maxValue:)))
        .map{ (parameters) in
            return (parameters[0] as? Bool ?? false, parameters[1] as? Bool ?? false)
    }
    return source
}
</code></pre>

<p>}</p>
","2187976","","2187976","","2019-04-30 20:08:37","2019-05-01 01:08:22","Using delegates and RxCocoa shows Argument of '#selector' refers to instance that is not exposed to Objective-C","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"55950081","1","","","2019-05-02 10:06:03","","0","229","<p>I have a delegate method that I want to execute when  button in a cell is tapped. I configured my cell using RxTableViewSectionedReloadDataSource and when I set the delegate here it it says they are unrelated types which I don't understand because my viewController inherits the delegate and implements its method. </p>

<pre><code>let notificationsDataSource = RxTableViewSectionedReloadDataSource&lt;SectionOfCustomData&gt;(
        configureCell: {dataSource, tableView, indexPath, item in
            guard let cell = tableView.dequeueReusableCell(withIdentifier: ""NewNotificationTableViewCell"", for: indexPath) as? NewNotificationTableViewCell else { return UITableViewCell() }
            cell.configureCell(item: item, indePath: indexPath)
            cell.notificationDeleteDelegate = self
            return cell
    })
</code></pre>

<blockquote>
  <p>I get this error ""Cannot assign value of type
  '(NotificationViewController) -> () -> NotificationViewController' to
  type 'TableViewCellDeleteDelegate?'""</p>
</blockquote>
","11441050","","8079610","","2019-05-02 10:13:47","2019-05-20 09:21:40","How to set a cell delegate when configuring a cell with RxTableViewSectionedReloadDataSource","<rx-swift>","2","0","","","","CC BY-SA 4.0"
"55950322","1","55951016","","2019-05-02 10:21:25","","1","377","<p>The question is very simple. Is it guaranteed that, without calling <code>observeOn()</code> - i.e. using <code>CurrentThreadScheduler</code> - the closure of <code>subscribe()</code> is executed in the same <strong>thread</strong> (not queue) of the call?</p>

<p>In the example <em>starting thread</em> == <em>observer thread</em></p>

<pre><code>// &lt;starting thread&gt;
let observable = ... // an observable
observable.subscribe(onNext: { _ in
    // &lt;observer thread&gt;
})
</code></pre>
","1999766","","","","","2019-05-02 11:02:18","RxSwift: ensuring current thread in subscribe closure","<swift><multithreading><rx-swift>","1","0","","","","CC BY-SA 4.0"
"55955387","1","55961947","","2019-05-02 15:09:59","","1","630","<p>I have an application which uses SwiftyJSON and works. How ever, I now want to expand the project and refactor the codes but I am having a bit of issue as I am now switching to Codable and I need to be able to mapJSON from any path and not a hard coded path. Currently my jsonResponse looks like this</p>

<pre><code>/// handle the network response and map to JSON
    /// - returns: Observable&lt;JSON&gt;
    func handleResponseMapJSON() -&gt; Observable&lt;Result&lt;JSON, ORMError&gt;&gt; {

        return self.map { representor in

            guard let response = representor as? Moya.Response else {
                return .failure(ORMError.ORMNoRepresentor)
            }

            guard ((200...299) ~= response.statusCode) else {
                return .failure(ORMError.ORMNotSuccessfulHTTP)
            }

            guard let json = JSON.init(rawValue: response.data),
                json != JSON.null,
                let code = json[""code""].int else {
                    return .failure(ORMError.ORMParseJSONError)
            }

            guard code == BizStatus.BizSuccess.rawValue else {
                let message: String = {
                    let json = JSON.init(data: response.data)
                    guard let msg = json[""status""].string else { return """" }
                    return msg
                }()
                log(message, .error)
                return .failure(ORMError.ORMBizError(resultCode: ""\(code)"", resultMsg: message))
            }

            return .success(json[""result""])

        }
    }
</code></pre>

<p>how do I eliminate the passage of hardcoded <code>json[""""]</code> value. Any help is appreciated </p>
","8310287","","","","","2019-05-03 09:10:55","handling json response Observable swift","<swift><rx-swift><swifty-json><codable><moya>","2","0","","","","CC BY-SA 4.0"
"55978176","1","","","2019-05-03 23:28:04","","1","179","<p>I'm trying to observe my variable user. When I set a new value to it that is not nil my drive(onNext) is called, but when I set the user variable as nil the drive(onNext) is not called. It's suppose to happen? What's the explanation for that?</p>

<pre><code>  static var userObservable: Observable&lt;User?&gt; = {
        Observable&lt;User?&gt;.create() { observer in
            observer.onNext(UserDefaults.user)

            return Disposables.create()
        }
    }()

UserDefaults.userObservable
            .asDriver(onErrorJustReturn: nil)
            .drive(onNext: {[weak self] user in
                print(user) // when UserDefaults.user receives a new value that is not nil this line of code is called. But when that value is nil it's not called.
            }).disposed(by: disposeBag)
</code></pre>
","985979","","","","","2019-05-04 00:55:23","Why Observer does not emit events when the observed values becomes nil?","<swift><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"55989564","1","","","2019-05-05 06:54:27","","0","151","<p>iOS Crash, I think it is caused by memory management error when using third party library NSObject+Rx and Then?</p>

<p>Firebase crashlytics reports,</p>

<blockquote>
  <p>已崩溃：com.apple.main-thread
  EXC_BREAKPOINT 0x0000000104a5be14</p>
  
  <p>0
  IOS
  LoginRegisterInputView.swift - 第 328 行
  closure #5 in LoginRegisterInputView.initRegisterUI()</p>
  
  <p>1
  Then
  $S4ThenAAPAARlzCrlE4thenyxyxKXEKF + 32</p>
  
  <p>2
  IOS
  LoginRegisterInputView.swift - 第 314 行
  LoginRegisterInputView.initRegisterUI()</p>
  
  <p>3
  IOS
  LoginRegisterInputView.swift - 第 225 行
  LoginRegisterInputView.initUI(style:)</p>
  
  <p>4
  IOS
  LoginRegisterInputView.swift - 第 42 行
  specialized LoginRegisterInputView.init(style:rootVC:)</p>
</blockquote>

<p>Here is the code:</p>

<pre><code>let registerProtocolLabel = UILabel().then {
            let string = ""RegisterIterm"".localized().replacingOccurrences(of: ""&lt;a&gt;"", with: ""+"").replacingOccurrences(of: ""&lt;/a&gt;"", with: ""+"")
            let array:[String] = string.components(separatedBy: ""+"")
            $0.font = mThemeMinFont
            if array.count &gt; 0 {
                $0.attributedText = (array[0].color(mRGBA(120, 120, 120, 1)) + array[1].color(mThemePinkColor).underline + array[2].color(mRGBA(120, 120, 120, 1))).attributedText
            }
            $0.textAlignment = .left
            $0.numberOfLines = 0
            $0.lineBreakMode = .byWordWrapping
            $0.rx.tapGesture().when(.recognized)
                .subscribe(onNext:{ _ in
                 AppUtils.jumpToWebView(route: AppUtils.getFunctionUrl(.term))
                }).disposed(by: rx.disposeBag)
        }
</code></pre>

<p>The code is of bugs and nasty. It is not written by me, not by my colleague.</p>

<p>Now I am in charge of the bugs.</p>

<p>Reading from <a href=""https://github.com/devxoul/Then"" rel=""nofollow noreferrer"">then</a>, it is very easy.</p>

<p>The object just set its properties in the closure. It does not visit other properties. So it is very ARC, it will not interfere other objects' memory management.</p>

<p>While my colleague's code is not of Then, it did two much.</p>

<p>I think the crash is caused by NSObject+Rx.</p>

<p><a href=""https://github.com/RxSwiftCommunity/NSObject-Rx"" rel=""nofollow noreferrer"">NSObject+Rx</a>'s code is easy, just code sugar.</p>

<pre><code>/// a unique DisposeBag that is related to the Reactive.Base instance only for Reference type
    public var disposeBag: DisposeBag {
        get {
            return synchronizedBag {
                if let disposeObject = objc_getAssociatedObject(base, &amp;disposeBagContext) as? DisposeBag {
                    return disposeObject
                }
                let disposeObject = DisposeBag()
                objc_setAssociatedObject(base, &amp;disposeBagContext, disposeObject, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
                return disposeObject
            }
        }
</code></pre>

<p>Reading from the source code of NSObject+Rx, in the scene above ,I think 
 <code>rx.disposeBag</code> is equal to <code>label.rx.disposeBag</code>.</p>

<p>It may cause bugs.</p>

<p>RxSwift's source code is a little hard to read.</p>

<p>So what is the crash reason?</p>
","10332481","","","","","2019-05-08 02:15:21","iOS Crash, memory management error when using NSObject+Rx and Then?","<ios><swift><firebase><crash><rx-swift>","1","6","","","","CC BY-SA 4.0"
"56005094","1","","","2019-05-06 12:19:15","","1","378","<p>I'm using MoyaRx networking for the search field and would like to cancel the request when the field is empty. </p>

<pre><code>let response = request
    .flatMapLatest {
        provider.rx.request($0)
        .map(T.self)
        .asDriver(onErrorRecover: { error in
            return Driver.just(.error(error))
        })
    }
</code></pre>

<p>But Moya manuals don't have code for my purpose. Can you suggest something?</p>
","4314758","","","","","2019-05-06 13:45:12","RxSwift Canceling RxMoya networking request","<swift><networking><request><rx-swift><moya>","1","0","","","","CC BY-SA 4.0"
"56018360","1","","","2019-05-07 08:20:37","","0","312","<p>I'm wanting to utilise a architectural design that enables me to clearly designate input and outputs in my view model (<a href=""https://medium.com/blablacar-tech/rxswift-mvvm-66827b8b3f10"" rel=""nofollow noreferrer"">How To Feed ViewModels</a>) but am curious as to how I can best integrate the ""working"" part of the view model into this structure.</p>

<p>I have tended to use Actions (perhaps not very elegantly) to bind UI elements to the work they need to perform. The problem of course is that some of these Actions rely on view model properties so I can't create them in init() in the same was as Input and Outputs as the properties are not yet initialised. It's possible to work around this by defining them as private lazy vars and then exposing them via a struct that essentially presents a public interface to Action. It doesn't seem to flow very well though and I'm learning that if you're expending a lot of effort to get structure to bend to your will, it's probably a code smell. Code example below - suggestions welcome :-)</p>

<pre><code>protocol PatientListViewModelType: ViewModelType { }

final class PatientListViewModel: PatientListViewModelType {
    // MARK:- Protocol conformance
    typealias Dependencies =  HasPatientService

    struct Input {
        let patient: AnyObserver&lt;Patient&gt;
    }
    struct Output {
        let sectionedPatients: Observable&lt;[PatientSection]&gt;
        let patient: Observable&lt;Patient&gt;
    }
    let input: Input
    let output: Output

    struct Actions {
        let deletePatient: Action&lt;Patient, Void&gt;
        let togglePatient: (Patient) -&gt; CocoaAction
        let updatePatient: (Patient) -&gt; Action&lt;String, Void&gt;
    }

    lazy var action: Actions = Actions(deletePatient: self.deletePatient,
                                       togglePatient: self.togglePatient,
                                       updatePatient: self.updatePatient)

    // MARK: Setup
    private let dependencies: Dependencies
    private let patientSubject = ReplaySubject&lt;Patient&gt;.create(bufferSize: 1)

    // MARK:- Init
    init(dependencies: Dependencies) {
        self.dependencies = dependencies

        let sectionedPatients =
            dependencies.patientService.patients()
                .map { results -&gt; [PatientSection] in
                    let scheduledPatients = results
                        .filter(""checked == nil"")
                        .sorted(byKeyPath: ""created"", ascending: false)

                    let admittedPatients = results
                        .filter(""checked != nil"")
                        .sorted(byKeyPath: ""checked"", ascending: false)

                    return [
                        PatientSection(model: ""Scheduled Patients"", items: scheduledPatients.toArray()),
                        PatientSection(model: ""Admitted Patients"", items: admittedPatients.toArray())
                    ]
        }

        self.output = Output(sectionedPatients: sectionedPatients,
                             patient: patientSubject.asObservable() )
        // this is immediately overriden during binding to VC - it just allows us to exit the init without errors
        self.input = Input(patient: patientSubject.asObserver())


    }

    // MARK:- Actions        
    private lazy var deletePatient: Action&lt;Patient, Void&gt; = { (service: PatientServiceType) in
        return Action { patient in
            return service.delete(realmObject: patient)
        }
    }(self.dependencies.patientService)

    lazy var togglePatient: (Patient) -&gt; CocoaAction = { [unowned self] (patient: Patient) -&gt; CocoaAction in
        return CocoaAction {
            return self.dependencies.patientService.toggle(patient: patient).map { _ in }
        }
    }

    private lazy var updatePatient: (Patient) -&gt; Action&lt;String, Void&gt; = { [unowned self] (patient: Patient) in
        return Action { newName in
            return self.dependencies.patientService.update(patient: patient, name: newName).map { _ in }
        }
    }
}
</code></pre>
","2733214","","","","","2019-05-07 20:01:58","Best architecture for ViewModels (RxSwift)","<mvvm><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"56039725","1","56042586","","2019-05-08 11:27:01","","1","413","<p>I'm learning MVVM + RxSwift.
I would like to save a value to reuse it at the next flow.
But I encountered the error above.</p>

<p>I assume I initialised the value which is ""translatedText"" but the error still comes up.</p>

<p>I have tried some ways that were to initialise with the declaration and so on...</p>

<pre class=""lang-swift prettyprint-override""><code>
import UIKit
import RxSwift

final class ViewModel {


    private let api: apiProtocol
    let validationText: Observable&lt;String&gt;
    let getObservable: Observable&lt;String&gt;
    var translatedText: String
    // var translatedText: String = """" //this case also dosn't work

    init(inputObservable: Observable&lt;String?&gt;, changeButtonClicked: Observable&lt;Void&gt;, model: ModelProtocol, api: apiProtocol = APICntl()) {

        self.api = api
        self.translatedText = """" //I guess I initialised this here

        let event = inputObservable
            .flatMap { input -&gt; Observable&lt;Event&lt;Void&gt;&gt; in
                if let text = input {
                    self.translatedText = text // error. i want to save ""input"" to use at ""let tapEvent""
                }
                return model
                    .validate(text: input)
                    .materialize()
            }
            .share()

        self.validationText = event
            .flatMap { event -&gt; Observable&lt;String&gt; in
                switch event {
                case .next:
                    return .just("""")
                case let .error(error as ModelError):
                    return .just(error.errorLabel)
                case .error, .completed:
                    return .empty()
                }
            }
            .startWith(ModelError.invalidBlank.errorLabel)

        let tapEvent = changeButtonClicked
            .flatMap { (result) -&gt; Observable&lt;Event&lt;String&gt;&gt; in
                return api
                    .fetch(text: self.translatedText) // I want use it here
                    .materialize()
        }
        .share()

        self.getObservable = tapEvent
            .flatMap { event -&gt; Observable&lt;String&gt; in
                switch event {
                case .next:
                    return .just(event.element!)
                case let .error(error as ModelError):
                    return .just(error.errorLabel)
                case .error, .completed:
                    return .empty()
                }
            }
    }

}

</code></pre>

<p>Do you guys have any better solutions?</p>

<p>----- self solution -----</p>

<p>I just simply created a temp variable before let event and it works as I want.</p>

<pre class=""lang-swift prettyprint-override""><code>final class ViewModel {


    private let api: apiProtocol
    let validationText: Observable&lt;String&gt;
    let getObservable: Observable&lt;String&gt;

    init(inputObservable: Observable&lt;String?&gt;, changeButtonClicked: Observable&lt;Void&gt;, model: ModelProtocol, api: apiProtocol = APICntl()) {

        self.api = api
        var temp = """"

        let event = inputObservable
            .flatMap { input -&gt; Observable&lt;Event&lt;Void&gt;&gt; in
                if let text = input {
                    temp = text
                }
                return model
                    .validate(text: input)
                    .materialize()
            }
            .share()
</code></pre>
","11408253","","11408253","","2019-05-08 12:35:01","2019-05-08 14:07:29","Swift5(+RxSwift) 'self' captured by a closure before all members were initialized","<swift><xcode><rx-swift>","3","0","","","","CC BY-SA 4.0"
"56048618","1","","","2019-05-08 20:31:05","","0","830","<p>I have a project which uses ObjectMapper for JSON serialization &amp; deserialization and Realm to cache data locally. I get data from Rest API and save them into realm database properly I have checked with RealmStudio. The problem is when I retrieve data from database a property which is Object type returns nil! This is my class and foodFact is Object type which is nil when get FoodRecipe data from database.Any Ideas? </p>

<pre><code> import RealmSwift
 import ObjectMapper


 typealias Syncable = Object &amp; Mappable


class FoodFact: Syncable {
  @objc dynamic var objectId :String = """"
  @objc dynamic var calcium: String = """"
  @objc dynamic var iron: String = """"
  @objc dynamic var fiber: String = """"
  @objc dynamic var fattyTransAcide: String = """"


 override static func primaryKey() -&gt; String? {
    return ""objectId""
 }

 required convenience init?(map: Map) { self.init() }


 func mapping(map: Map) {
    self.objectId &lt;- map[""objectId""]
    self.calcium &lt;- map[""calcium""]
    self.iron &lt;- map[""iron""]
    self.fiber &lt;- map[""fiber""]
    self.fattyTransAcide &lt;- map[""fattyTransAcide""]
  }
}


class FoodRecipe: Syncable {
  @objc dynamic var objectId :String = """"
  @objc dynamic var title :String = """"
  var ingredient = List&lt;FoodRecipeIngredient&gt;()
  @objc dynamic var foodFact :FoodFact? //returns nil when retrieving    data


override static func primaryKey() -&gt; String? {
    return ""objectId""
}

required convenience init?(map: Map) { self.init() }

func mapping(map: Map) {
    objectId &lt;- map[""objectId""]
    title &lt;- map[""title""]
    ingredient &lt;- (map[""ingredients""],ArrayTransform&lt;FoodRecipeIngredient&gt;())
    foodFact &lt;- map[""foodFact""]
   }
 }
</code></pre>

<p>This is code I use for save &amp; retrieve data :</p>

<pre><code>import Foundation
import RealmSwift

protocol BaseDao {
  associatedtype T: Object

  func save(list:[T])
  func save(object:T)
  func get() -&gt; [T]?
  func delete(list:[T])
  func deleteAll()
}

extension BaseDao {
  func deleteAll(){
    PersistenceManager().deleteDatabase()
  }
}


class PersistenceManager {

  let realm = try! Realm()
  var notificationToken = NotificationToken()


  func deleteObjects(objs:[Object]) {
    do {
        try realm.write({
            realm.delete(objs)
        })
    } catch let error {
        assertionFailure(error.localizedDescription)
    }
}

func saveObjects(objs: [Object]) {
    print(""path for realm \(String(describing: realm.configuration.fileURL))"")
    do {
        try realm.write({
            realm.add(objs, update: true)
        })
    } catch let error {
        assertionFailure(error.localizedDescription)
    }

}

func saveObject(obj: Object) {
    print(""path for realm \(String(describing: realm.configuration.fileURL))"")
    do {
        try realm.write({
            realm.add(obj, update: true)
        })
    } catch let error {
        assertionFailure(error.localizedDescription)
    }

}

func getObjects(type: Object.Type) -&gt; Results&lt;Object&gt;? {
    return realm.objects(type)
}

func deleteDatabase() {
    do {
        try realm.write({
        realm.deleteAll()
        })
    } catch let error {
        assertionFailure(error.localizedDescription)
    }
  }
 }


class FoodRecipeLocalPersistence :BaseDao {
typealias T = FoodRecipe

let persistenceManager :PersistenceManager

init(persistenceManager :PersistenceManager = PersistenceManager()) {
    self.persistenceManager = persistenceManager
}

func save(list: [T]) {
    self.persistenceManager.saveObjects(objs: list)
}

func save(object: T) {
    self.persistenceManager.saveObject(obj: object)
}

func get() -&gt; [T]? {
    guard let data = persistenceManager.getObjects(type: T.self) else {
        return nil
    }
    return Array(data) as? [T]
}

  func delete(list: [T]) {
    self.persistenceManager.deleteObjects(objs: list)
  }
}
</code></pre>

<p>Update 1: 
After Further review I have realized I can retrieve FoodRecipe with all properties in FoodRecipePersistence but in my ViewModel FoodFact is nil! 
I am using RxSwift in my ViewModel below is code snippet:</p>

<pre><code>   Observable.combineLatest(selectedCategory, currentCategory, resultSelector: { (selectedCategory, currentCategory) in
        switch currentCategory {
        case .Food:
            let category = selectedCategory as? FoodRecipeCategory

            return foodRecipeLocalPersistence.get()?.filter{ $0.categoryId == category?.objectId }.map{$0} ?? []
        case .Sport:
            let category = selectedCategory as? ExerciseInstructionCategory
            return exerciseInstructionLocalPersistence.get()?.filter{ $0.categoryId == category?.objectId }.map{$0} ?? []
        }
    }).asObservable().bind(to: self.shownList).disposed(by: disposeBag)
</code></pre>

<p>update 2:
When I use</p>

<blockquote>
  <p>po foodRecipe.foodFact</p>
</blockquote>

<p>foodFact is printed on console with all data and properties but when I put mouse on foodRecipe.foodFact inside the editor it shows nil!!!</p>
","2613978","","2613978","","2019-05-11 12:34:36","2019-07-06 07:44:55","How to fix nil value from realm object property?","<realm><rx-swift><xcode10><objectmapper><combinelatest>","2","3","","","","CC BY-SA 4.0"
"56052249","1","56053557","","2019-05-09 04:33:20","","0","1641","<p>So, I have a button and will make an API request upon tapping it. When the API request returns an error, if my understanding is correct, the sequence will be terminated and no subsequent action will be recorded. How do I handle this properly so that I can still make another API request when tapping the button. </p>

<p>My thoughts are to have two observables that I can subscribe to in <strong>ViewController</strong> and on button pressed, one of it will print the success response and one of it will print the error. Just not quite sure how I can achieve that.</p>

<p>PS: In Post.swift, I have purposely set <em>id</em> as <em>String</em> type to fail the response. It should have be an <em>Int</em> type.</p>

<p><strong>Post.swift</strong></p>

<pre><code>import Foundation
struct Post: Codable {
    let id: String
    let title: String
    let body: String
    let userId: Int
}
</code></pre>

<p><strong>APIClient.swift</strong></p>

<pre><code>class APIClient {

    static func request&lt;T: Codable&gt; (_ urlConvertible: URLRequestConvertible, decoder: JSONDecoder = JSONDecoder()) -&gt; Observable&lt;T&gt; {

        return Observable&lt;T&gt;.create { observer in

            URLCache.shared.removeAllCachedResponses()

            let request = AF.request(urlConvertible)
                .responseDecodable (decoder: decoder) { (response: DataResponse&lt;T&gt;) in

                switch response.result {
                case .success(let value):
                    observer.onNext(value)
                    observer.onCompleted()
                case .failure(let error):
                    switch response.response?.statusCode {
                    default:
                        observer.onError(error)
                    }
                }
            }

            return Disposables.create {
                request.cancel()
            }
        }
    }

}
</code></pre>

<p><strong>PostService.swift</strong></p>

<pre><code>class PostService {
    static func getPosts(userId: Int) -&gt; Observable&lt;[Post]&gt; {
        return APIClient.request(PostRouter.getPosts(userId: userId))
    } 
}
</code></pre>

<p><strong>ViewModel.swift</strong></p>

<pre><code>class LoginLandingViewModel {

    struct Input {
        let username: AnyObserver&lt;String&gt;
        let nextButtonDidTap: AnyObserver&lt;Void&gt;
    }

    struct Output {
        let apiOutput: Observable&lt;Post&gt;
        let invalidUsername: Observable&lt;String&gt;
    }

    // MARK: - Public properties

    let input: Input
    let output: Output

    // Inputs

    private let usernameSubject = BehaviorSubject(value: """")
    private let nextButtonDidTapSubject = PublishSubject&lt;Void&gt;()

    // MARK: - Init

    init() {

        let minUsernameLength = 4

        let usernameEntered = nextButtonDidTapSubject
            .withLatestFrom(usernameSubject.asObservable())

        let apiOutput = usernameEntered
            .filter { text in
                text.count &gt;= minUsernameLength
            }
            .flatMapLatest { _ -&gt; Observable&lt;Post&gt; in
                PostService.getPosts(userId: 1)
                    .map({ posts -&gt; Post in
                        return posts[0]
                    })

            }

        let invalidUsername = usernameEntered
            .filter { text in
                text.count &lt; minUsernameLength
            }
            .map { _ in ""Please enter a valid username"" }


        input = Input(username: usernameSubject.asObserver(),
                      nextButtonDidTap: nextButtonDidTapSubject.asObserver())

        output = Output(apiOutput: apiOutput,
                        invalidUsername: invalidUsername)

    }

    deinit {
        print(""\(self) dellocated"")
    }


}
</code></pre>

<p><strong>ViewController</strong></p>

<pre><code>private func configureBinding() {

        loginLandingView.usernameTextField.rx.text.orEmpty
            .bind(to: viewModel.input.username)
            .disposed(by: disposeBag)

        loginLandingView.nextButton.rx.tap
            .debounce(0.3, scheduler: MainScheduler.instance)
            .bind(to: viewModel.input.nextButtonDidTap)
            .disposed(by: disposeBag)

        viewModel.output.apiOutput
            .subscribe(onNext: { [unowned self] post in
                print(""Valid username - Navigate with post: \(post)"")
                })
            .disposed(by: disposeBag)


        viewModel.output.invalidUsername
            .subscribe(onNext: { [unowned self] message in
                self.showAlert(with: message)
            })
            .disposed(by: disposeBag)

    }
</code></pre>
","11315473","","11315473","","2019-05-09 07:04:41","2019-05-10 06:28:37","How to handle error from api request properly with RxSwift in MVVM?","<swift><mvvm><error-handling><rx-swift>","2","0","","","","CC BY-SA 4.0"
"56056846","1","","","2019-05-09 09:55:35","","1","422","<p>I have one request for any of you. I want to create collectionview/tableview which will have user inputs in cells. Mixture of values from those inputs would represent state. I want to observe that state and if some conditions are met, I want to recreate all cells. I have created very simple app, where I demonstrate how i tried to implement it, but I’m getting reentrancy warning and I would love to find out your ideas/best practicies for this. Here is the repo you can checkout.</p>

<p><a href=""https://github.com/beretis/CollectionViewTest"" rel=""nofollow noreferrer"">https://github.com/beretis/CollectionViewTest</a></p>

<p>PS: Im using RxData sources, and I would love to know exactly what is causing this reentrancy (I have my idea)</p>
","1762099","","","","","2019-05-14 11:45:20","RxSwift MVVM tableview/collectionview with user input cells representing state","<rx-swift><rx-cocoa><rxdatasources>","1","0","","","","CC BY-SA 4.0"
"56072629","1","56073064","","2019-05-10 07:20:12","","3","643","<p>I have a <code>Driver</code> of type <code>Bool</code> and a <code>BehaviorRelay</code> of type <code>Page</code> (which is a custom enum).</p>

<pre class=""lang-swift prettyprint-override""><code>enum Page {
    case option1(CustomClass1, CustomClass2)
    case option2(CustomClass3)
    case option3(CustomClass4)

    var property1: CustomClass2? {
        switch self {
        case .option1(_, let custom):
            return custom
        case .option2, .option3:
            return nil
        }
    }
}
</code></pre>

<p>I have the <code>Driver&lt;Bool&gt;</code> in another ViewModel.</p>

<pre><code>class ViewModel1 {
    struct Output {
        let hasItems: Driver&lt;Bool&gt;
    }

    let output: Output

    init() {
        let hasItemsRelay: BehaviorRelay&lt;Bool&gt; = BehaviorRelay&lt;Bool&gt;(value: false)

        self.output = Output(
            hasItems: hasItemsRelay.asDriver()
        )
    }
}
</code></pre>

<p>And I have a <code>BehaviorRelay&lt;Page?&gt;</code> in my base class.</p>

<pre><code>class ViewModel2 {
    let currentPageRelay: BehaviorRelay&lt;Page?&gt; = BehaviorRelay&lt;Page?&gt;(value: nil)

    init() {
        self.currentPageRelay = BehaviorRelay&lt;Page?&gt;(value: nil)
    }
}
</code></pre>

<p>In <code>ViewModel2</code> class I'm trying to catch an event on the <code>hasItems</code> driver of <code>ViewModel1.Input</code> and when I get an event, I need the current value of <code>currentPageRelay</code> and later on do stuff with it. So basically <code>withLatestFrom</code> is the thing I need to use.</p>

<pre><code>class ViewModel2 {

   private func test() {
       let customViewModel: ViewModel1 = ViewModel1()

       customViewModel
           .output
           .hasItems
           .withLatestFrom(currentPageRelay) { ($0, $1) }
           .map { (hasItems, page) -&gt; (CustomClass2, Bool)? in 
               guard let property1 = page?.property1 else { return nil }
               return (property1, hasItems)
           }
           .unwrap()
           .drive(onNext: { (property1, hasItems) in 
               // do stuff
           }
           .disposed(by: disposeBag)
   }
}
</code></pre>

<p>Xcode completely loses it on the <code>withLatestFrom</code>. No code completion and it gives the following compile error:
<code>Expression type '(Bool, _)' is ambiguous without more context</code></p>

<p>I'm completely in the dark about this one. I've already tried everything, providing the correct classes in the parameter list below it, so that it knows what to expect etc, but no luck so far.</p>
","4347007","","","","","2020-01-28 09:23:58","RxSwift withLatestFrom with resultSelector doesn't compile","<swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"56073843","1","56081441","","2019-05-10 08:44:14","","1","157","<p>What am I doing wrong? How do I get the Single from the closure?
How can I get value from Alamofire.request?</p>

<pre><code> func loadImageName(url: URL) -&gt; Single&lt;String&gt; {
    let data = try? Data(contentsOf: url)
    guard let query = data else {
        return .error(Error.notFound)
    }

        ...

    return Single.deferred {
        Alamofire.request(request).responseJSON {
            if let error = $0.error {
                return Single&lt;String&gt;.error(error)
            }

            return Single&lt;String&gt;.just(result)
        }
    }
}
</code></pre>
","5452718","","5452718","","2019-05-10 09:11:54","2019-05-10 16:22:01","How to return single.deferred in closure","<closures><rx-swift><deferred>","1","0","","","","CC BY-SA 4.0"
"56171030","1","56173973","","2019-05-16 14:36:22","","0","169","<p>Following is method provided by <strong>RxAlamofire</strong> for making requestJSON request there is no method to pass parameters [String : String]</p>

<pre><code>RxAlamofire.requestJSON(.get, url)
        .subscribe(onNext: { [weak self] (r, json) in
            if let jsonResult = JSON(json) as? JSON {
                if let foodMenuResult = MenuResult(jsonResult) as? MenuResult {
                    self?.delegate?.showMenu(menuResult: foodMenuResult)
                }
            }

            }, onError: {  [weak self] (error) in
                self?.delegate?.onError()
            },onCompleted: {})
        .disposed(by: disposeBag)
</code></pre>

<p>How to pass parameters to <strong>RxAlamofire</strong> requestJSON method</p>
","4153589","","","","","2019-05-16 17:43:46","RxAlmofire pass parameters to requestJSON [:]","<ios><swift4><rx-swift><reactive><rxalamofire>","1","2","","","","CC BY-SA 4.0"
"56186268","1","56189374","","2019-05-17 12:17:35","","1","325","<p>I have an Observable of Objects array of the same class = Observable&lt;[MyClass]>. MyClass contains an Observable attribute sortAttribute = Observable. 
I want to sort my array depending on the observable sort attribute.</p>

<pre class=""lang-swift prettyprint-override""><code>class MyClass {

    let title:String
    let sortAttribute:Observable&lt;Int&gt;

    init(withTitle title:String, andSortValue sortValue: Int) {
        self.title = title
        self.sortAttribute = Observable.just(sortValue)
    }

}

let arrayToSort:Observable&lt;[MyClass]&gt; = Observable.just([
    MyClass(withTitle: ""A"", andSortValue: 4),
    MyClass(withTitle: ""B"", andSortValue: 2),
    MyClass(withTitle: ""C"", andSortValue: 42),
    MyClass(withTitle: ""D"", andSortValue: 1337),
    MyClass(withTitle: ""E"", andSortValue: 24)
])

arrayToSort
    .subscribe(onNext: { ar in
        for element in ar {
            print(element.title)
        }
    })

</code></pre>

<p>Actual result :</p>

<pre><code>A //4
B //2
C //42 
D //1337 
E //24
</code></pre>

<p>Expected result :</p>

<pre><code>B //2
A //4
E //24
C //42
D //1337
</code></pre>
","769575","","769575","","2019-05-17 12:48:30","2019-05-17 15:20:49","How to sort an array of items by an Observable attribute?","<ios><swift><observable><rx-swift>","2","0","","","","CC BY-SA 4.0"
"56189546","1","56200024","","2019-05-17 15:31:42","","0","1024","<p>I have an observable </p>

<pre><code>lazy var user = _user.share(replay: 1)
private let _user = PublishRelay&lt;User&gt;()
</code></pre>

<p>in a <code>UserState.swift</code> singleton. My <code>user</code> observable gets an event as soon as the app loads and I receive a User from the backend.</p>

<p>Later on, in one of my ViewModels, I try to </p>

<pre><code>func profileViewModel(
    viewAppeared: Observable&lt;Void&gt;
) -&gt; (
    title: Observable&lt;String&gt;
) {

    let title = viewAppeared.withLatestFrom(UserState.shared.user) { _, user in
        user.username
    }

    return title

}
</code></pre>

<p>Except this event never fires (dont get inside the closure) because <code>user</code> already fired before it was subscribed to.</p>

<p>How can I accomplish this behavior where on <code>viewDidLoad</code> event, I grab the latest <code>user</code> value from my observable?</p>

<p>EDIT:</p>

<p>In my singleton init, if I throw in a random <code>user.subscribe()...</code>, then this all works. I'm so confused...</p>
","3356655","","3356655","","2019-05-18 19:09:24","2019-05-19 21:38:48","RxSwift simple withLatestFrom not firing","<ios><swift><rx-swift><reactivex><rx-cocoa>","1","2","","","","CC BY-SA 4.0"
"56227364","1","","","2019-05-20 19:55:31","","1","243","<p>I want to make a post call using <strong>RxAlamofire</strong> it provides <strong>function</strong> <strong>requestJson</strong> which requires <strong>two parameters</strong> <strong>type get or post and url</strong> but there is <strong>no parameter to pass post json body</strong> how to do that following is my code</p>

<pre><code> var components = URLComponents(string: url)!
    components.setQueryItems(with: param)
    let url = components.url!
    print(""\(url)"")

    RxAlamofire.requestJSON(.post, url)
        .subscribe(onNext: { [weak self] (r, json) in
            if let jsonResult = JSON(json) as? JSON {
                if let cartResult = FoodCartResult(jsonResult) as? FoodCartResult {
                    self?.delegate?.showCart(cartresult: cartResult)
                }
            }

            }, onError: {  [weak self] (error) in
                print(error.localizedDescription)
                self?.delegate?.onError()
            },onCompleted: {})
        .disposed(by: disposeBag)
</code></pre>
","4153589","","","","","2019-05-31 15:55:35","How to make Post call using RxAlamofire pass json in post body","<ios><swift><swift4><rx-swift><rxalamofire>","1","0","","","","CC BY-SA 4.0"
"56227626","1","56244610","","2019-05-20 20:18:09","","0","169","<p>I'm wondering if there is a way in RxSwift to observe value of stored variable property. Eg. in following example:</p>

<pre><code>    var updatedValue: Int = 0

    var observedValue: Observable&lt;Int&gt; {
            return Observable.create({ (observer) -&gt; Disposable in
                observer.onNext(updatedValue)
                return Disposables.create()
            })
        }

    Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { timer in
        updatedValue = updatedValue + 1;
    }

    let myObservable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)
        .publish()

    myObservable.connect()

    myObservable
        .withLatestFrom(observedValue)
        .subscribe { (event) in
            print(event)
    }
</code></pre>

<p>We have variable property <strong>updatedValue</strong> and hot observable <strong>myObservable</strong>. We also increment value of updatedValue in <em>Timer.scheduledTimer...</em>.</p>

<p>Flow here is pretty straight forward. When we subscribe, observedValue gets called, we get onNext from observedValue and then Disposables.create(). Then we print event onNext(0). </p>

<p>As <strong>myObservable</strong> is based on <em>Observable.interval</em>, same withLatestFrom value gets printed in onNext every second. </p>

<p>Question: Is there a way to print last value of updatedValue every time myObservable emits new event? So instead of 0,0,0... we get 0,1,2...</p>

<p>I'm aware that updatedValue could be declared as BehaviorRelay.
I'm also aware that we could use .map { } to capture self.updatedValue.</p>

<p>But I'm wondering if there is any way to create a Observable wrapper around standard variable property so it calls onNext with most recent value every time trigger sequence sends an event? Without capturing self or changing declaration on updatedValue.</p>

<p>Thanks for any comments and ideas!</p>
","3677394","","","","","2019-05-21 18:44:47","Collecting stored variable property using withLatestFrom","<ios><rx-swift><reactive>","2","3","","","","CC BY-SA 4.0"
"56232506","1","56312094","","2019-05-21 06:43:24","","0","1544","<p>I want to make post call using RxAlamofire not able to find any method to do so</p>

<p>tried using requestJSON method but there is no paramter to pass post json in</p>

<pre><code> RxAlamofire.requestJSON(.post, url)
</code></pre>

<p>how to make post call and pass json data to post call in RxAlamofire</p>
","5450254","","","","","2021-05-21 20:13:28","RxAlamofire make post call with json body","<swift><swift4><rx-swift><rxalamofire>","3","3","","","","CC BY-SA 4.0"
"56235031","1","","","2019-05-21 09:15:29","","0","1053","<p>how to covert URLRequest to Alamofire URLConvertible I am getting error while trying to convert following is my code</p>

<pre><code>var request = URLRequest(url: URL(string: ""some url"")!)
request.httpBody = json
RxAlamofire.request(.post, request as! URLConvertible, parameters: param, encoding: JSONEncoding.default, headers: [""Content-Type"" : ""application/json""])
    .subscribe(onNext:{ [weak self] (json) in
        print(json)
        if let jsonResult = JSON(json) as? JSON {
            if let cartResult = FoodCartResult(jsonResult) as? FoodCartResult {
                self?.delegate?.showCart(cartresult: cartResult)
            }
        }

        }, onError: {
            [weak self] (error) in
            print(error.localizedDescription)
            self?.delegate?.onError()
        },onCompleted: {})
    .disposed(by: disposeBag)
</code></pre>

<p>code is crashing my app saying </p>

<blockquote>
  <p>Could not cast value of type 'Foundation.URLRequest' (0x10c23a3c8) to 'Alamofire.URLConvertible'</p>
</blockquote>

<p>Already referred following but not working for me
<a href=""https://stackoverflow.com/questions/41114689/could-not-cast-value-of-type-nsmutableurlrequest-0x11beb7040-to-alamofire-u"">Could not cast value of type &#39;NSMutableURLRequest&#39; (0x11beb7040) to &#39;Alamofire.URLRequestConvertible&#39; (0x11beb9040)</a></p>
","5450254","","1226963","","2019-05-21 17:57:23","2019-05-21 17:57:23","How to convert URLRequest to Alamofire.URLConvertible","<swift><rx-swift><rxalamofire>","0","2","","2019-05-21 09:17:42","","CC BY-SA 4.0"
"56236262","1","","","2019-05-21 10:26:32","","0","548","<p>I'm quite new in RxSwift world and apparently I'm not using it correctly... I have a button that I would like to connect to an observer like this </p>

<pre><code>button.rx.tap.bind(to: viewModel.someObserver).disposed(by: disposeBag)
</code></pre>

<p>where <code>someObserver</code> in viewModel is initialized as follows:</p>

<pre><code>let publishSubject = PublishSubject&lt;Void&gt;()
someObserver = publishSubject.asObserver()
someObservable = publishSubject.asObservable() 
</code></pre>

<p>However, when <code>Disposable</code> created with binding is disposed, <code>PublishSubject</code> which is used both as <code>Observer</code> and <code>Observable</code> gets invalidated and all new subscriptions are immediately disposed.</p>

<p>I would like to use my <code>PublishSubject</code> for a longer time and be able to subscribe to it after the binding is disposed. How to achieve that?</p>
","2494952","","2494952","","2019-05-21 16:31:19","2019-05-21 21:50:32","How to not invalidate observer when binding is disposed in RxSwift?","<ios><swift><binding><dispose><rx-swift>","1","2","1","","","CC BY-SA 4.0"
"56242275","1","","","2019-05-21 16:03:29","","0","564","<p>I'll keep this as short as possible: we started the app full RxSwift but our coordinators started to get overwhelmed to maintain and extend so we are reworking them to not use RxSwift and now we can't figure out how to use them and where to keep them.</p>

<p>Simplest example: view controller with 1 button, view model, coordinator.
Where do I call <code>coordinator.navigate(to: .mySection)</code> and how? Should the coordinator be kept in the view controller? I thought they should be kept in the view model but subscribing in the view model is not the recommended usage.</p>

<p>I don't want to over-engineer this but I hope to get some insightful help.</p>
","6498011","","","","","2019-10-03 16:07:33","Where does the coordinator go in a RxSwift + MVVM + Coordinator situation if coordinators aren't in RxSwift?","<ios><swift><mvvm><rx-swift><coordinator-pattern>","3","0","","","","CC BY-SA 4.0"
"56251285","1","","","2019-05-22 07:17:42","","0","63","<p>Xcode has started displaying a compiler error as soon as I open my project (i.e. a build is not required) but it's all a bit odd. One error is shown in the build time tab but when I open the compiler message window there are three identical errors spread across multiple files. The errors are not highlighted in the editor window so I can't trace them but as they're flagged in files I haven't touched recently I suspected the problem was with Xcode rather than my code.</p>

<p>The error is shown in the build time window as: </p>

<pre><code>Swift Compiler Error - cannot convert value of type '()' to closure result type 'Observable&lt;Void&gt;'
</code></pre>

<p>In the messages window:</p>

<pre><code>&lt;unknown&gt;:0: error: cannot convert value of type '()' to closure result type 'Observable&lt;Void&gt;'
</code></pre>

<p>These errors are spread across three files in the messages window, all of which use at least one RxSwift dependency (RxDataSources, RxSwift, and RxCocoa) and, as noted above, I haven't touched a couple of them for a week or two and my dependencies have not been recently amended so I can be reasonably certain they are not the issue.</p>

<p>I've done all the usual (clean, clear cache, reboot, checked error display settings, roll back to an earlier version, update dependencies, reinstall Xcode) but the error persists and I'm effectively locked out of further development until I can resolve it. To say that I'm frustrated would be an understatement!</p>

<p>I'm running Xcode 10.2.1 (10E1001)
Help!!</p>
","2733214","","4608906","","2019-05-22 07:25:08","2019-05-24 20:32:53","Xcode compiler error not highlighted in editor","<swift><xcode><compiler-errors><rx-swift><xcode10.2>","1","2","","","","CC BY-SA 4.0"
"56253610","1","56253812","","2019-05-22 09:30:40","","1","82","<p>In Swift I have created BaseObserver, in subscribe method I pass this class.
I am trying to do the same in RxJS using TypeScript.</p>

<p>This comes handy when you want to do something before and after any events occur.</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import RxSwift

class BaseObserver&lt;Element&gt;: ObserverType {

    public typealias E = Element

    var beforeClosure: (() -&gt; Void)?
    var completeClosure: ((E) -&gt; Void)?
    var errorClosure: ((Error) -&gt; Void)?
    var completedClosure: (() -&gt; Void)?
    var alwaysClosure: (()-&gt;())?
    var onCompleteOrError: ((Error?) -&gt; Void)?

    init(beforeComplete: (() -&gt; Void)? = nil, onComplete: ((E) -&gt; Void)? = nil, onError: ((Error) -&gt; Void)? = nil, onCompleted: (() -&gt; Void)? = nil, always: (()-&gt;())? = nil, onCompleteOrError: ((Error?) -&gt; Void)? = nil) {
        self.alwaysClosure = always
        self.completeClosure = onComplete
        self.errorClosure = onError
        self.completedClosure = onCompleted
        self.beforeClosure = beforeComplete
        self.onCompleteOrError = onCompleteOrError
    }

    func on(_ event: Event&lt;Element&gt;) {
        switch event {
        case .next(let element):
            beforeClosure?()
            completeClosure?(element)
        case .error(let error):
            beforeClosure?()
            errorClosure?(error)
            onCompleteOrError?(error)
        case .completed:
            completedClosure?()
            onCompleteOrError?(nil)
        }
        alwaysClosure?()
    }
}
</code></pre>
","5744323","","4554116","","2019-05-22 13:26:01","2019-05-22 13:26:01","Create BaseObserver in TypeScript using RxJS","<typescript><rxjs><rx-swift><reactivex>","1","0","","","","CC BY-SA 4.0"
"56278023","1","56284896","","2019-05-23 14:58:50","","0","226","<p>I'm learning RxSwift and RxCocoa.
I've run into this problem:</p>

<p>I have UITextField and UIPickerView and UIButton.
UIButton should become enabled once UITextField is valid. There is different validation regex for each item selected from UIPickerView.</p>

<p>This is my code so far:</p>

<pre><code>        textField.rx.text
            .map({ (text) -&gt; Bool in
                return self.validate(text!, self.regex)})
            .subscribe(onNext: { (valid) in
                self.button.alpha = valid ? 1 : 0.5
                self.button.isEnabled = valid
            })
            .disposed(by: disposeBag)

        pickerView.rx.itemSelected.subscribe(onNext: { row, value in
            self.regex = getRegex(row)
        }).disposed(by: disposeBag)
</code></pre>

<p>So I'm picking regex first from pickerView then I'm observing text change. The problem appears when I want to input text first and then pick some different regex from pickerView - the button doesn't update, cause no changes to text were made!</p>

<p>So I'm guessing I should somehow zip or merge these two sources (observables?), so that button can observe any change from each of them at once.</p>

<p>How should I approach this problem?</p>
","3554626","","","","","2019-05-24 07:13:31","Observe two sources of data at once","<swift><rx-swift><rx-cocoa>","2","0","","","","CC BY-SA 4.0"
"56288284","1","56288618","","2019-05-24 08:02:52","","0","348","<p>I have BehaviourSubject and I want to refresh items with last emitted value. I can do it example below,</p>

<pre><code> func refreshCurrent() {
    do {
        let items = try currentMatchList.value()
        if !(items.first?.items ?? []).isEmpty {
            refreshItems(sportId: try currentSport.value())
        }
    } catch {
        LOG.error(error.localizedDescription)
        return
    }
}
</code></pre>

<p>But I was wondering is there any built in RxSwift functionality I might use for same task?</p>

<p>I've found there was a <code>Variable()</code> type once upon a time but now it's gone and it's recommended to use BehaviourSubject it seems. </p>

<p>Thanks in advance.</p>
","2103088","","2103088","","2019-05-24 08:10:27","2019-05-24 08:25:32","RxSwift how to refresh BehaviourSubject better way?","<swift><system.reactive><rx-swift><behaviorsubject>","2","0","","","","CC BY-SA 4.0"
"56291300","1","56297385","","2019-05-24 11:00:26","","0","42","<p>ViewModel:</p>

<pre><code>        searchButtonInDidTapSubject.withLatestFrom(retailIdSubject.map { text in return text}).flatMapLatest { [unowned self] retailId in
        return service.searchRetailPayCashBack(retailId: retailId, createdAt: self.createdDates, sig: self.sig).materialize();
        }.subscribe(onNext: { [weak self] event in
            switch (event) {
            case .next(_):
                self?.checkResultSubject.onNext(true)
                break;
            case .error(let error):
                self?.errorSubject.onNext(error as! ErrorResponse);
                break;
            default:
                break;
            }
        }).disposed(by: disposeBag);
</code></pre>

<p>// here i need to convert retailId , currentTime and accessToken
after that i send request api </p>

<pre><code> private var sig: String{
get {
    let accessToken = self.keychain.get(Constants.accessToken)
    // ???
    let newAccessToken = String((accessToken?.substring(with: 11..&lt;21))!)
    let retailid = ???
    let newSig = ""\(newAccessToken)\(self.createdDates)\(retailid)""
    let md5Base64 = newSig.base64Encoded()
    let md5Data = self.MD5(md5Base64!)
    return String(md5Data!)

}
}
</code></pre>

<p>retailId needs to be equal to retailid</p>
","","user10319455","","","","2019-05-24 17:47:51","how i can use retailId(from flatMapLatest) in another func","<swift><xcode><api><rx-swift><moya>","1","0","","","","CC BY-SA 4.0"
"56311684","1","56312194","","2019-05-26 07:51:27","","0","136","<p>Hoe i can save orderId and retrieve from Disk and send second Request
answer from base:</p>

<pre><code>{""orderId"" : 241,""fullName"" : ""Поесть""}
</code></pre>

<p>SearchResponse.swift</p>

<pre><code>struct SearchResponse: Codable {

    var orderId: Int
    var fullName: String
    var retailId: Int

    private enum CodingKeys: String, CodingKey {
        case orderId
        case fullName
        case retailId
    }
}
</code></pre>

<p>after search request i  try to save orderId in disk like this in status == 200(service.swift):</p>

<pre><code>if let value = result.value {
    var code = 0;
    do {
        if let responseDictionary = try JSONSerialization.jsonObject(with: value.data, options: .allowFragments) as? [String:Any] {
            code = responseDictionary[""status""] as? Int ?? 0;
        }

    } catch {
        if let e = try? JSONDecoder().decode(ErrorResponse.self, from: value.data) {
            observer.onError(e);
        }
    }
    if (value.response?.statusCode == 200) {
        do{

            let response = try JSONDecoder().decode(SearchResponse.self, from: value.data);
            try Disk.save(response.retailId, to: .caches, as: FileName.retailName);
            try Disk.save(response.orderId, to: .caches, as: FileName.orderId);


        } catch {
            if let e = try? JSONDecoder().decode(ErrorResponse.self, from: value.data) {
                observer.onError(e);
            }
        }
        observer.onNext(true)
    } else {
        if let e = try? JSONDecoder().decode(ErrorResponse.self, from: value.data) {
            observer.onError(e);
        }
    }
}
</code></pre>

<p>viewmodel.swift</p>

<pre><code>private var orderId: String {
    let orderId = try? Disk.retrieve(FileName.orderId, from: .caches, as: SearchResponse.self).orderId
    return String(orderId!) &lt;-- there error ""Thread 1: Fatal error: Unexpectedly found nil while unwrapping an Optional value""
}
</code></pre>
","","user10319455","1226963","","2019-05-26 16:27:06","2019-05-26 16:27:06","How i can send orderId received after answering from api?Swift","<swift><rx-swift><moya>","1","1","","","","CC BY-SA 4.0"
"56315104","1","","","2019-05-26 15:54:41","","0","153","<blockquote>
  <p>Single.flatMapObservable</p>
</blockquote>

<p>in RxSwift is it called differently or it just doesn't exist?</p>
","2543013","","2543013","","2019-05-26 16:02:49","2019-05-27 14:26:58","RxSwift can't find flatMapObservable","<swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"56318876","1","","","2019-05-27 02:08:13","","0","467","<p>After some API calls, I have a check to either navigate to another screen or show an alert on the same screen. Currently, I am doing this by creating an observable that returns a <strong>UIViewController</strong> type but pushing a UIAlertController causes problem. </p>

<p>Any suggestions/ideas on how this should be done?</p>

<p><strong>ViewModel.swift</strong></p>

<pre><code>let nextAction = Observable.combineLatest(appVersionOutput, serviceAvailabilityOutput, getLanguagePackOutput,
                                              resultSelector:
        { appVersion, _, _ -&gt; UIViewController in
            if appVersion.currentAppVersion == ""1.0.0"" {
                let appServiceAvailability = Availability.shared.getAppStatus()
                if appServiceAvailability {
                    return LoginLandingViewController()
                } else {
                    return ServiceMaintenanceViewController()
                }
            } else {
                return UIAlertController()
            }
        })
</code></pre>

<p><strong>ViewController.swift</strong></p>

<pre><code>viewModel.output.nextAction
        .subscribe(onNext: { [weak self] screen in
            self?.navigationController?.pushViewController(screen, animated: true) 
        }) // PROBLEM FACED: Pushing a UIAlertController
        .disposed(by: disposeBag)
</code></pre>
","11315473","","","","","2019-05-27 06:26:46","How do I perform either a push UIViewController or a present of UIAlertController?","<swift><mvvm><uiviewcontroller><uialertcontroller><rx-swift>","3","1","","","","CC BY-SA 4.0"
"56328559","1","","","2019-05-27 15:06:48","","0","36","<p>I have more of a opinions question, asi if this, what many people do, should be a Rx use case.</p>

<p>In apps there is usually sql database, which is queried by UI as a observable, which emits after the query is loaded + anytime data changes (Room / SqlDelight etc)</p>

<p>Reads sound okay, however, is it possible to have ""pure"" writes to the database?</p>

<p>Writing to the database might look like this</p>

<pre><code>fun sync() = Completable.fromCallable {
   //  do something
   database.writeSomethingSynchronously()
}

SomeUi {
  init {
     database.someQueryObservable()
       .subscribe { show list }
   }
}
</code></pre>

<p>Imagine you want to display progressbar while this Completable is in flight.
What is effectively happening here is sideffecting to the database. Which means the opened database observable will re-emit when the data is written, but still before the sync() returns (assuming single threaded for simplicity)</p>

<p>Now there is point in time where there is new data in the UI and the progressbar is shown. (and worse with multithreading timings) This is invalid state.</p>

<p>In imperative world, sync would provide a completion callback, in which one would reload the query manually + show/hide progressbar synchronously. (And somehow block the database change listener for duration of the sync writes?)</p>

<p>Is there a way around this at all?</p>
","1541188","","","","","2019-05-27 15:06:48","Are hot non completing database observables a Rx usecase? Side-effect writing issue","<rxjs><rx-java><reactive-programming><rx-swift>","0","2","","","","CC BY-SA 4.0"
"56340660","1","","","2019-05-28 10:56:00","","0","334","<p>I have some textfileds in my viewcontroller. And use rx-swift to observer the .editingDidBegin event.</p>

<p>I want to judge which textfield sends event. </p>

<pre><code>let tags = txtFieldArray.map{($0.rx.controlEvent(.editingDidBegin), $0.tag)}
            .map{obs, tag in obs.map{tag}}
let value = Observable.merge(tags)
        value.bind {[weak self] (tags) in
            guard let strongSelf = self else { return }
            if let view = strongSelf.ipEnteryView.viewWithTag(tags) as? UITextField {
                strongSelf.viewMode.changeTextFiledBottomColor(view, true)
            }
            }.disposed(by: disposedBag)
</code></pre>

<p>The txtFieldArray's first map return a array, element is tuples(as my understand),first is controlEvent, second is a int value. What i don't understand is the second map function. Obs is contrlEvent type. Why obs.map{tag} return a observable. And how to understand map{obs, tag in obs.map{tag}}?
Thank you very much!</p>
","8720668","","","","","2019-05-28 11:23:38","How to understand this rx-swift map function","<swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"56344330","1","56345841","","2019-05-28 14:21:00","","1","927","<p>I am trying to achieve a subscription of 3 different BehaviorRelay using RxSwift. The idea is following:</p>

<pre><code>let disposeBag = DisposeBag()

class ClassA{

    var br1 = BehaviorRelay(value: ""BR1_1"")
    var br2 = BehaviorRelay(value: ""BR2_1"")
    var br3 = BehaviorRelay(value: ""BR3_1"")

    /* Some other variables */

}
let classA = ClassA()


class ClassB:CustomStringConvertible{
    let classA:ClassA

    var description: String{
        return ""\(br1.value), \(br2.value), \(br3.value)""
    }

    var br1:BehaviorRelay&lt;String&gt;{
        return classA.br1
    }
    var br2:BehaviorRelay&lt;String&gt;{
        return classA.br2
    }
    var br3:BehaviorRelay&lt;String&gt;{
        return classA.br3
    }

    init(classA:ClassA) {
        self.classA = classA
    }

}
let classB = ClassB(classA: classA)

classB.br1.asObservable().subscribe { (value) in
    print(value)
}

classA.br1.accept(""BR1_2"")
</code></pre>

<p>It prints:</p>

<pre><code>next(BR1_1)
next(BR1_2)
</code></pre>

<p>By doing that I am ""populating"" my ClassB with objects from ClassA and by setting a subscription to the objects in ClassB i can react to the next events.</p>

<p>However, I would like to create a function such as:</p>

<pre><code>func reactingFunction(br1:BehaviorRelay&lt;String&gt;, br2:BehaviorRelay&lt;String&gt;, br3:BehaviorRelay&lt;String&gt;){
    /**/
}
</code></pre>

<p>to be called every time any of the br produces onNext event. Can I create a mix subscription for all of them?</p>

<p>Thank you</p>
","1824565","","","","","2019-05-28 15:45:58","Observable from more than one BehaviorRelay RxSwift","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"56359520","1","56370967","","2019-05-29 11:26:30","","1","866","<p>I have a view A, click on a button to make it show or hide the way through RxSwift: <code>.bind(to: nearbyVc.view.rx.isHidden)</code> 
Now I want to monitor view A property<code>isHidden</code> and do something Other things, how can I make it?</p>
","8197559","","","","","2019-05-30 02:38:51","When a 'view.rx.isHidden' has changed, how can i emit a single to let annother view know, can i observe 'view.rx.isHidden'?","<ios><rx-swift>","1","0","","","","CC BY-SA 4.0"
"56389766","1","56389904","","2019-05-31 06:28:20","","0","186","<p>I want to add my ViewController into the ContainerView of my ViewCtrl2. I do not really know how to add the subview to my ContainerView so that I can navigate forward and backwards. I hope someone can help me out!</p>

<p>I face some difficulties . I do not know how to go on from there. I instantiated my Views in my ""actions""-Array but can´t go any further from there. </p>
","","user11080824","","user11080824","2020-04-23 06:31:34","2020-04-23 06:31:34","How can I add the second View Controller into my ContainerView as well?","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"56395348","1","56395805","","2019-05-31 12:43:22","","0","80","<p>I'm using <code>Swift 5</code>, <code>Xcode 10.2</code><br>
I support iOS versions 10 and up  </p>

<p>I have a notification model I can initialise with some data (title, body, actions, etc) and a static class with a function that takes in a notification model and shows a local notification based on its contents. It's all <code>RX</code> and the caller of the function can subscribe to the return value and it will fire an event when the user interacted with the notification (tap, dismiss, custom action, etc).  </p>

<p>Now I want to test this class, I'm very new to both writing tests and <code>RX</code> so I'm having some trouble wrapping my head around this. From outside the class all I have is that one function.<br>
I was thinking of what I actually want to test, and it comes down to showing the notification at all and if the mapping mechanism to a strong typed user interaction goes alright.<br>
Another problem is that I don't always know if the permission for showing local notifications was granted, and if it's not been granted how to test if everything works.  </p>

<p><strong>How can I grant the permission to show notifications in a test?</strong>  </p>

<p><strong>How can I test wether the notification was shown?</strong>  </p>

<p><strong>How do I interact with the notification in a test?</strong>  </p>

<p>Sorry for asking three questions for the price of one, but they are so related I figured it's better for everyone not to clutter the site with three very similar questions.</p>
","11312049","","6783598","","2019-05-31 12:45:43","2019-05-31 13:13:49","How can I write proper tests for a local notification interface?","<ios><swift><unit-testing><rx-swift>","1","0","","","","CC BY-SA 4.0"
"56395793","1","56397543","","2019-05-31 13:13:06","","0","676","<p>I'm trying to get to grips with <code>RxCocoa</code> and have experienced an unusual bug relating to some dynamic UI behaviour I'm trying to implement.</p>

<p>I have a <code>UITextField</code> that's used for user input. The button which adds the input to a Realm database is bound to an <code>RxSwift</code> Action. This works absolutely fine.</p>

<p>Initially, I disabled the button until there was text of at least 1 character in length in the <code>UITextField</code> - the code of this works fine. The bug in my code arose when I then added a subscription to the Action's executionObservables parameter that should clear the UITextField after the button is pressed. </p>

<p>Expected behaviour:</p>

<ul>
<li>No text (initial state) > button disabled </li>
<li>Text entered > button enabled</li>
<li>Text entered and button pressed > text field cleared and button disabled</li>
</ul>

<p>Actual behaviour:</p>

<ul>
<li>No text  (initial state) > button disabled</li>
<li>Text entered > button enabled</li>
<li>Text entered and button pressed > text field cleared BUT button remains enabled</li>
</ul>

<p>Adding debug() indicates that the binding to the UITextField that disables the button is disposed but I can't figure out why as the UIViewController and its associated view model should still be in scope. Can anyone point me in the right direction?</p>

<p>Code snippet:</p>

<pre><code>func bindViewModel() {
    // populate table
    viewModel.output.sectionedObservations
        .drive(tableView.rx.items(dataSource: dataSource))
        .disposed(by: disposeBag)

    // only allow enable button when there is text in the textfield
    observationTextField.rx.text
        .debug()
        .map { $0!.count &gt; 0 }
        .bind(to: addObservationButton.rx.isEnabled)
        .disposed(by: disposeBag)

// clear textfield once Action triggered by button press has completed
viewModel.addObservation.executionObservables
    .subscribe({ [unowned self] _ in
        self.observationTextField.rx.text.onNext("""")
})
.disposed(by: disposeBag)

// add Observation to Realm using Action provided by the view model
addObservationButton.rx.tap
    .withLatestFrom(observationTextField.rx.text.orEmpty)
    .take(1)
    .bind(to: viewModel.addObservation.inputs)
    .disposed(by: disposeBag)
}
</code></pre>
","2733214","","6783598","","2019-05-31 15:15:20","2019-05-31 15:15:20","Disabling a button based on value in a UITextField only works once (RxSwift)","<swift><rx-swift><rx-cocoa>","1","4","","","","CC BY-SA 4.0"
"56400581","1","56494445","","2019-05-31 19:11:16","","0","757","<p>I am trying to learn RxSwift. I had been using Moya and now want to try my hand at RxSwift. Totally confused.</p>

<pre><code> let popServiceProvider = MoyaProvider&lt;PopRESTService&gt;()
    let o1 = popServiceProvider.rx.request(.getPopByCity(city: ""London"")).asObservable()
    let o2 = popServiceProvider.rx.request(.getPopByCity(city: ""Tokyo"")).asObservable()

    let pObservables:[Observable&lt;Response&gt;] = [o1, o2]
    let stats: Observable&lt;Response&gt; = Observable.combineLatest(pObservables)
    let m = stats.map({ a in
        print(a)
    })  
</code></pre>

<p>First I get an error on let stats:</p>

<p>Cannot convert value of type 'Observable&lt;[Response]>' to specified type 'Observable'</p>

<p>am I even going in the right direction?</p>

<p>EDIT:</p>

<p>Even this doesn't work. Never first the subscribe:</p>

<pre><code>   wServiceProvider.rx.request(.getWeatherByCity(city: ""Chicago""))
    .debug()
    .map(Weather.self)
    .subscribe({ (event) in
        switch event {
        case let .success(response):
            print(response)

        case let .error(response):
            print(response)
        }
    })
    .disposed(by: self.disposeBag)
</code></pre>
","810300","","810300","","2019-06-03 20:04:58","2019-06-07 12:34:20","how to use Moya RxSwift to get an array of REST merged","<swift><rx-swift><moya>","2","0","","","","CC BY-SA 4.0"
"56425073","1","56506817","","2019-06-03 10:04:41","","1","397","<p>I'm trying to test the main functionality of my ViewModel. The important step is to test te loaded state completed. But for sure, for a better test it could be interesting to test al states.</p>

<p>I was reading a lot of post and information about RxTest and RxBlocking but I'm not able to test this module. If someone can help me, it would be great!</p>

<pre><code>struct Product: Equatable { }
struct Promotion { }

protocol ProductsRepository {
    func fetchProducts() -&gt; Observable&lt;Products&gt;
    func fetchPromotions()  -&gt; Observable&lt;[Promotion]&gt;
}

struct ProductCellViewModel: Equatable {
    let product: Product
}

struct Products {
    let products: [Product]
}

enum ProductsViewState: Equatable {
    case loading
    case empty
    case error
    case loaded ([ProductCellViewModel])
}

class ProductsViewModel {

    var repository: ProductsRepository

    let disposeBag = DisposeBag()
    private var productCellViewModel: [ProductCellViewModel]
    private var promotions: [Promotion]

    // MARK: Input

    init(repository: ProductsRepository) {
        self.repository = repository
        productCellViewModel = [ProductCellViewModel]()
        promotions = [Promotion]()
    }

    func requestData(scheduler: SchedulerType) {
        state.onNext(.loading)
        resetCalculate()
        repository.fetchProducts()
            .observeOn(scheduler)
            .flatMap({ (products) -&gt; Observable&lt;[ProductCellViewModel]&gt; in
                return self.buildCellViewModels(data: products)
            }).subscribe(onNext: { (cellViewModels) in
                self.productCellViewModel = cellViewModels
            }, onError: { (error) in
                self.state.onNext(.error)
            }, onCompleted: {
                self.repository.fetchPromotions()
                    .flatMap({ (promotions) -&gt; Observable&lt;[Promotion]&gt; in
                        self.promotions = promotions
                        return Observable.just(promotions)
                    }).subscribe(onNext: { (_) in
                        self.state.onNext(.loaded(self.productCellViewModel))
                    }, onError: { (error) in
                        self.state.onNext(.error)
                    }).disposed(by: self.disposeBag)
            }).disposed(by: disposeBag)
    }

    // MARK: Output

    var state = PublishSubject&lt;ProductsViewState&gt;()

    // MARK: ViewModel Map Methods

    private func buildCellViewModels(data: Products) -&gt; Observable &lt;[ProductCellViewModel]&gt; {
        var viewModels = [ProductCellViewModel]()
        for product in data.products {
            viewModels.append(ProductCellViewModel.init(product: product))
        }
        return Observable.just(viewModels)
    }

    func resetCalculate() {
        productCellViewModel = [ProductCellViewModel]()
    }
}
</code></pre>

<p>The goal is to be able to test all of ProductsViewState after viewmodel.requestData() is being called</p>
","2468765","","506441","","2019-06-08 13:33:56","2019-06-08 13:33:56","Test PublishSubject for ViewState","<mvvm><rx-swift><rxtest><rx-blocking>","1","11","","","","CC BY-SA 4.0"
"56426678","1","","","2019-06-03 11:45:47","","0","257","<p>I want to make click animations on every button and cell inside my app, basically all the views with actions. On every click I want a grayish blink.</p>

<p>The problem is the following: I made a custom class for button and the buttons across the app are working just fine. The problem is with cells as I try to make the animations rx-like. I have UITableView cells as well as UICollectionView cells and some views here and there, so I tried to do UIView extension which recognizes taps and if there is one - animation is played. I tried to do this with extension:</p>

<pre><code>import UIKit
import RxSwift

extension UIView {
    func makeSelectionIndicatable(forInitialBackgroundColor color: UIColor) {
        let tapGesture = UILongPressGestureRecognizer()
        tapGesture.minimumPressDuration = 0
        tapGesture.cancelsTouchesInView = false
        addGestureRecognizer(tapGesture)

        tapGesture.rx.event.bind(onNext: { [weak self] recognizer in
            if recognizer.state == .began {
                self?.backgroundColor = .global(color: .athens_gray)
            }
            if recognizer.state == .ended {
                self?.backgroundColor = color
            }
            if recognizer.state == .cancelled {
                self?.backgroundColor = color
            }
        })
    }
}
</code></pre>

<p>Obviously there is a dispose missing, but if I add one in extension - nothing will work. My question is: how to make animations rx-like, so that they'll be visible across app? Maybe I'm overthinking it and there are easier ways? Thx in advance</p>
","5594757","","","","","2019-06-03 14:19:15","How to animate cells and buttons throughout the app in RxSwift?","<swift><animation><uicollectionviewcell><rx-swift>","1","0","","","","CC BY-SA 4.0"
"56429256","1","","","2019-06-03 14:20:36","","1","1510","<p>I receive from my backend a accessToken and a refreshToken. When I receive a respons with statusCode 401 I need to replace the accessToken with the refreshToken (accessToken = refreshToken) and try the request again. If the request fail for the third time I need to request the user to log in again. I'm trying to apply this logic using the code described bellow, but it isn't working. The request is not being called again. How can I do this?</p>

<pre><code>// example of usage:
public func login(with parameters: LoginParameters) -&gt; Single&lt;User&gt; {
        return provider.rx.request(MultiTarget(UserTarget.login(parameters))).handleResponse(User.self, using: jsonDecoder)
    }

func handleResponse&lt;D: Decodable&gt;(_ type: D.Type, atKeyPath keyPath: String? = nil, using decoder: JSONDecoder = JSONDecoder(), failsOnEmptyData: Bool = true) -&gt; Single&lt;D&gt; {
        return self.flatMap({ (response) -&gt; Single&lt;D&gt; in

            switch response.statusCode {
            case 200...299:
                RequestsFailedCount.count = 0
                return Single.just(try response.map(type, atKeyPath: keyPath, using: decoder, failsOnEmptyData: failsOnEmptyData))
            case 500:
                return Single.error(try response.map(ResponseError.self))
            default:
                if response.statusCode == 401, let urlResponse = response.response {

                    guard RequestsFailedCount.count &lt;= 3 else {
                        RequestsFailedCount.count = 0
                        return Single.error(InvalidChallengeError())
                    }

                    RequestsFailedCount.count += 1
                    if let challenge = urlResponse.allHeaderFields[HeaderType.authenticate.rawValue] as? String, challenge.contains(self.challenge) {
                        var keychain = KeychainManager()
                        keychain.accessToken = keychain.refreshToken

                        return self.retry(1).map(type, atKeyPath: keyPath, using: decoder, failsOnEmptyData: failsOnEmptyData)
                    } else {
                        return Single.error(try response.map(ResponseError.self))
                    }

                } else {
                    return Single.error(try response.map(ResponseError.self))
                }
            }
        })
    }
</code></pre>
","985979","","","","","2019-06-04 14:38:06","Refresh token and retry the request using RxSwift","<swift><rx-swift><moya>","1","0","","","","CC BY-SA 4.0"
"56442874","1","","","2019-06-04 11:22:18","","1","583","<p>Is there anyway we can filter button tap event based on button title like below..!!</p>

<pre><code>button.rx.tap
 .filter { ($0.titleLabel.text.count)!&gt; 0 }
</code></pre>
","1077457","","","","","2019-06-06 08:31:35","How to filter button tap with button title in RxSwift?","<rx-swift><reactive-extensions-js>","2","2","","","","CC BY-SA 4.0"
"56459392","1","56459661","","2019-06-05 11:15:20","","1","40","<p>Like:</p>

<pre><code>btn.rx.tap
   .bind(to: ViewA.rx.isHidden &amp;&amp; ViewB.rx.isHidden)
   .disposed(by: disposeBag)
</code></pre>

<p>so once i tap the btn,ViewA and ViewB both hidden at once!
is it possible ?</p>
","8197559","","","","","2019-06-06 00:53:41","is it possible to bind two observer at once?","<ios><rx-swift>","3","0","","","","CC BY-SA 4.0"
"56465693","1","","","2019-06-05 17:54:43","","0","388","<p>I am trying to create buttons after getting response from a network request. How do I do this and position them after creating them, <strong>after the view is loaded</strong>. I am also creating my views programmatically and using AutoLayout.</p>

<p><strong>CustomView.swift</strong></p>

<pre><code>class CustomView: UIView {

    override init(frame: CGRect) {
        super.init(frame: UIScreen.main.bounds)
        backgroundColor = .red
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError(""init(coder:) has not been implemented"")
    }

}
</code></pre>

<p><strong>ViewController.swift</strong></p>

<pre><code>// Load custom view
override func loadView() {
    view = CustomView()
}

override func viewDidLoad() {
    super.viewDidLoad()

    // Create buttons after getting response
    viewModel.output.apiOutput
        .subscribe(onNext: { posts in
            for post in posts {
                // create buttons
            }
        })
        .dispose(by: disposeBag)

}
</code></pre>
","11315473","","11315473","","2019-06-05 18:34:33","2019-06-05 22:56:18","How do I create/add UIView after viewDidLoad?","<ios><swift><uiview><rx-swift><ios-autolayout>","2","2","","","","CC BY-SA 4.0"
"56493035","1","56505489","","2019-06-07 10:58:58","","0","1180","<p>So I have a button inside my <code>ViewController</code> which is connected to <code>ViewModel</code> and than whenever the button is tapped, in my coordinator I navigate to another screen. The code is like this:</p>

<p><code>VC</code></p>

<pre><code>btnShowShopsMap.rx.tap
            .bind(to: viewModel.selectShowMap)
</code></pre>

<p><code>VM</code></p>

<pre><code>let selectShowMap: AnyObserver&lt;Void&gt;
    let showShopMap: Observable&lt;Void&gt;
//Inside init
 let _selectShowMap = PublishSubject&lt;Void&gt;()
        selectShowMap = _selectShowMap.asObserver()
        showShopMap = _selectShowMap.asObservable()
</code></pre>

<p><code>Coordinator</code></p>

<pre><code>viewModel.showShopMap
            .subscribe(onNext: { _ in self.showShopMap()})
            .disposed(by: userShopVC.disposeBag)
</code></pre>

<p>Is it possible to refactor above code? rather than using <code>PublishSubject</code> is there any other way to do what i am doing using <code>PublishSubject</code>  </p>

<p>My VC, VM &amp; Coordinator Flow</p>

<p><code>Coordinator</code></p>

<pre><code>func showLoginScreen(logout: Bool = false) {

    guard let viewController = LoginViewController.instantiate(storyboard: .main) else { return }

    viewController.viewModelFactory = { inputs in
        let viewModel = LoginViewModel(inputs: inputs)
        viewModel.showHome
            .subscribe(onNext: {  isLogged in
                if isLogged {
                    self.showHomeScreen()
                }
            })
            .disposed(by: viewController.disposeBag)

        inputs.showOnboarding
            .subscribe(onNext: { _ in
                self.showOnboardingScreen()
            })
            .disposed(by: viewController.disposeBag)
        return viewModel
    }
navController.pushViewController(viewController, animated: true)
</code></pre>

<p><code>VC</code></p>

<pre><code>var viewModelFactory: (LoginViewModel.UIInputs) -&gt; LoginViewModel = { _ in fatalError(""factory not set"")}

let inputs = LoginViewModel.UIInputs(userNumber: txtUserNumber.rx.text.orEmpty.asDriver(),
                                             password: txtPassword.rx.text.orEmpty.asDriver(),
                                             loginTapped: btnLogin.rx.tap.asSignal(),
                                             userNumberLostFocus: txtUserNumber.rx.controlEvent(.editingDidEnd).asSignal(),
                                             passwordLostFocus: txtPassword.rx.controlEvent(.editingDidEnd).asSignal(),
                                             indicator: indicator,
                                             showOnboarding: btnShowOnboarding.rx.tap.asObservable())
</code></pre>

<p><code>VM</code></p>

<pre><code>struct  UIInputs {
    let userNumber: Driver&lt;String&gt;
    let password: Driver&lt;String&gt;
    let loginTapped: Signal&lt;Void&gt;
    let userNumberLostFocus: Signal&lt;Void&gt;
    let passwordLostFocus: Signal&lt;Void&gt;
    let indicator: ActivityIndicator
    let showOnboarding: Observable&lt;Void&gt;
}
 init(inputs: UIInputs) {}
</code></pre>
","1419216","","1419216","","2019-06-07 12:22:27","2019-06-08 10:24:01","RxSwift - Button Tap using Publish Subject","<rx-swift>","2","0","","","","CC BY-SA 4.0"
"56501341","1","56503204","","2019-06-07 21:20:24","","0","173","<p>I'm looking reading from <a href=""https://store.raywenderlich.com/products/rxswift"" rel=""nofollow noreferrer"">RW book</a>. </p>

<pre><code>.retryWhen { errors in
    return errors.enumerated().flatMap { (attempt, error) -&gt; Observable&lt;Int&gt; in
        if attempt &gt;= maxAttempts - 1 {
            return Observable.error(error)
        }
        return Observable&lt;Int&gt;.timer(Double(attempt + 1), scheduler:
            MainScheduler.instance).take(1)
    }
}
</code></pre>

<p>The timer isn’t taking a <code>period</code> Variable so it’s firing once and is not repeating. So why is it doing <code>take(1)</code>. I see that happening over a few times in the course of the book.</p>
","5175709","","5175709","","2019-06-08 14:06:03","2019-06-08 18:06:06","Why is take(1) used at the end of a retryWhen timer?","<swift><timer><rx-swift><retry-logic>","1","0","","","","CC BY-SA 4.0"
"56503814","1","","","2019-06-08 05:42:50","","0","362","<p>I am trying to store an API response data which will be used by other network request, in my case, an access token to be included in the header for any subsequent API call. I <strong>do not</strong> need it to be stored persistently (which deemed UserDefaults, Keychain, CoreData etc. <strong>not necessary</strong>) because a new one will be provided upon logging in. </p>

<p>How do I store the token so that it can be accessed by other ViewModels and passed it in as an argument when making a service call? Please correct me if I got my understanding wrong.</p>

<p><strong>Model</strong></p>

<pre><code>// Response data object
struct Login: Codable {
    let accessToken: String
    let type: String
}
</code></pre>

<p><strong>ViewModel</strong></p>

<pre><code>// Call login service upon button tap
let loginOutput = loginTapped
    .filter { username, password in
        username.count &gt;= 4 &amp;&amp; password.count &gt;= 4
    }
    .flatMapLatest { username, password in
        PostLoginService.build(User(username: username,
                                    password: password))
            .materialize()
    }
    .share()

let loginSuccess = loginOutput
    .elements() // Return Observable&lt;Login&gt;
</code></pre>

<p><strong>ViewController</strong></p>

<pre><code>// Subscribe to response output
viewModel.output.loginSuccess
    .subscribe(onNext: { [weak self] response in
        // Question:
        // Call a method in ViewModel to store the response?
        // How do I store this response object?
        // Store in Model's Login struct?
    })
    .disposed(by: disposeBag)
</code></pre>
","11315473","","","","","2019-06-08 20:26:21","How do I store api response data (non-persistent) in MVVM?","<ios><swift><mvvm><model><rx-swift>","1","0","","","","CC BY-SA 4.0"
"56506808","1","56509821","","2019-06-08 13:21:47","","12","7144","<p>Unable to set Rxtimeinterval for debounce in rxswift. My code is below. I got this error message ""Cannot convert value of type 'Double' to expected argument type 'RxTimeInterval' (aka 'DispatchTimeInterval')""</p>

<pre><code>searchBar
    .rx.text // Observable property thanks to RxCocoa
    .orEmpty // Make it non-optional
    .debounce(0.5, scheduler: MainScheduler.instance) // Wait 0.5 for changes.
    .distinctUntilChanged() // If they didn't occur, check if the new value is the same as old.
    .filter { !$0.isEmpty }
</code></pre>

<p>error message:</p>

<blockquote>
  <p>""Cannot convert value of type 'Double' to expected argument type 'RxTimeInterval' (aka 'DispatchTimeInterval')""</p>
</blockquote>
","8810031","","1292099","","2019-06-13 08:23:32","2019-12-24 07:14:52","How to set RxTimeInterval for debounce in RxSwift?","<ios><swift><xcode><rx-swift>","3","0","1","","","CC BY-SA 4.0"
"56524324","1","56525347","","2019-06-10 10:09:34","","1","321","<p>I am trying to get deeper on RxSwift and I was wondering If there is a way to ""private accept"" value on a BehaviorRelay object in RxSwift. So my ClassA has a BehaviorRelay that only ClassA can set but, for instance, ClassB can subscribe.</p>

<p>Thank you</p>
","1824565","","","","","2019-06-10 11:16:56","Private accept for a BehaviorRelay RxSwift","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"56529946","1","","","2019-06-10 16:13:54","","1","285","<p>I writing Network Layer with Moya and <code>RxSwift</code>, server response JSON like this:</p>

<pre><code>{ ""code"": 200, ""msg"": """", data: {}}
</code></pre>

<p>I want return data only on success with code eques 200, return error if code not equal 200, what should I do?</p>

<p>I try to write code like this</p>

<pre><code>extension PrimitiveSequence where TraitType == SingleTrait, ElementType == BaseBean&lt;T: Codable&gt; 
</code></pre>

<p>this is code of response object:</p>

<pre><code>struct BaseBean&lt;T: Codable&gt; : Codable {
    let code: Int
    let msg: String
    let data: T?

    func map() throws -&gt; T {
        if code != 200 {
            throw ApiError(reason: msg)
        }
        if data == nil {
            throw ApiError(reason: ""Empty Data"")
        }
        return data!
    }
}
</code></pre>

<p>I expect the call method like this</p>

<pre><code>  static func userInfo(params: UserInfoParams) -&gt; Single&lt;UserInfo&gt; {
        return provider.rx.request(.userInfo(params: params)).map(BaseBean&lt;UserInfo&gt;).map()
    }
</code></pre>
","6759477","","8160252","","2019-06-10 17:56:23","2019-06-12 11:27:16","How can I write a PrimitiveSequence extension include <T: Codable>","<ios><swift><rx-swift><moya>","1","0","","","","CC BY-SA 4.0"
"56541855","1","56543768","","2019-06-11 10:38:21","","2","441","<p>I would like to perform a test in one of my ViewModels that contains a BehaviorRelay object called ""nearByCity"" that it is bind to BehaviorRelay called ""isNearBy"". That's how my view model looks like.</p>

<pre><code>class SearchViewViewModel: NSObject {

    //MARK:- Properties
    //MARK: Constants
    let disposeBag = DisposeBag()


    //MARK: Vars
    var nearByCity:BehaviorRelay&lt;String?&gt; = BehaviorRelay(value: nil)
    var isNearBy = BehaviorRelay(value: true)        

    //MARK:- Constructor
    init() {

        super.init()
        setupBinders()

    }

}


//MARK:- Private methods
private extension SearchViewViewModel{

    func setupBinders(){

        nearByCity
            .asObservable()
            .distinctUntilChanged()
            .map({$0 ?? """"})
            .map({$0 == """"})
            .bind(to: isNearBy)
            .disposed(by: disposeBag)

    }

}
</code></pre>

<p>The test that i want to perform is to actually verify that when the string is accepted, the bool value also changes according to the function setupBinders().</p>

<p>Any Idea?</p>

<p>Thank you</p>
","1824565","","1824565","","2019-06-12 07:03:54","2019-06-12 07:03:54","Testing ViewModel in RxSwift","<unit-testing><rx-swift><rxtest>","1","1","","","","CC BY-SA 4.0"
"56575093","1","56575201","","2019-06-13 07:08:29","","1","801","<p>How do I add an .tap method to a custom button, ie. <code>&lt;myCustomButton&gt;.rx.tap</code> in RxSwift/RxCocoa, so that I can bind the tap of the button to an observable.</p>

<p><strong>CircularButton.swift</strong></p>

<pre><code>class UICircularButton: UIButton {
    override func layoutSubviews() {
        super.layoutSubviews()

        clipsToBounds = true
        subviews.first?.contentMode = .center

        let layer: CALayer = self.layer
        layer.cornerRadius = self.frame.size.width / 2
        layer.masksToBounds = true
    }
}
</code></pre>

<p><strong>ViewController.swift</strong></p>

<pre><code>let transferButton: UIActionButton = {
        let button = UICircularButton(type: .system)
        button.setBackgroundImage(#imageLiteral(resourceName: ""transfer""), for: .normal)
        button.backgroundColor = Colors.trueGreen
        return UIActionButton(button: button, actionLabel: ""Transfer"")
    }()

// Question
func configureBinding() {
        // How do I do this
        transferButton.rx.tap
            .bind(to: ...)
            .dispose(by: ...)
    }
</code></pre>
","11315473","","","","","2019-06-13 07:29:45","How do I add a control event to a custom button in RxCocoa?","<ios><swift><uibutton><rx-swift><rx-cocoa>","3","0","","","","CC BY-SA 4.0"
"56580668","1","56586603","","2019-06-13 12:37:24","","1","1276","<p>I have a scene in an app I have been asked to make changes in.</p>

<p>I am not really familiar with <code>RxSwift</code> so please forgive me if this is obvious.</p>

<p>My view controller renders a <code>WKWebView</code> which contains a login form. When the user completes the form, a property is sent back which I am currently printing out in the <code>WKNavigationDelegate</code>.</p>

<p>What I would like to do is pass that property to my <code>oauthService</code> which exists as a dependancy within my <code>ViewModel</code>.</p>

<p>I could create a method in the model like</p>

<pre><code>  func passPropToServie(_ prop: String) {
        // do something
    }
</code></pre>

<p>and just call this from the view controller, but I am not sure if this is correct, or what the 'rxswift' way of doing this is.</p>

<p>Sorry again, this is an app I am picking up so the original code is something I still coming to terms with.</p>

<p><strong>LoginCoordinator</strong></p>

<pre><code>import UIKit
import RxCocoa
import RxSwift

class LoginCoordinator: BaseCoordinator&lt;()&gt; {
    typealias Dependencies = HasOAuthService

    private let window: UIWindow
    private let dependencies: Dependencies

    init(window: UIWindow, dependencies: Dependencies) {
        self.window = window
        self.dependencies = dependencies
    }

    override func start() -&gt; Observable&lt;()&gt; {
        let viewController = LoginViewController()
        let avm: Attachable&lt;LoginViewModel&gt; = .detached(dependencies)
        let viewModel = viewController.attach(wrapper: avm)

        viewModel.loginURL.drive(onNext: { login in
            viewController.handle(login?.url)
        }).disposed(by: viewController.disposeBag)

        window.rootViewController = viewController
        window.makeKeyAndVisible()

        return viewModel.isLoggedIn
            .asObservable()
            .filter { $0 }
            .map { _ in return }
    }
}
</code></pre>

<p><strong>LoginViewController</strong></p>

<pre><code>import UIKit
import WebKit
import RxCocoa
import RxSwift

class LoginViewController: UIViewController, ViewModelAttaching {

    let disposeBag = DisposeBag()

    var viewModel: Attachable&lt;LoginViewModel&gt;!
    var bindings: LoginViewModel.Bindings {
        return LoginViewModel.Bindings()
    }

    private var requestURL: URL?

    lazy var webView: WKWebView = {
        let webConfiguration = WKWebViewConfiguration()
        webConfiguration.dataDetectorTypes = [.all]
        let webView = WKWebView(frame: .zero, configuration: webConfiguration)
        webView.navigationDelegate = self
        webView.allowsBackForwardNavigationGestures = false
        return webView
    }()

    override func viewDidLoad() {
        super.viewDidLoad()
    }

    override func loadView() {
        view = webView
    }

    func bind(viewModel: LoginViewModel) -&gt; LoginViewModel {

        return viewModel
    }

    func handle(_ url: URL?) {
        guard let url = url else { return }
        requestURL = url
        webView.load(URLRequest(url: url))
    }
}

extension LoginViewController: WKNavigationDelegate {
    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) {
        if let url = navigationAction.request.url, url.scheme == ""homedev"", url.valueOf(""code"") != nil {
            print(url)
        }
        decisionHandler(.allow)
    }
}
</code></pre>

<p><strong>LoginViewModel</strong></p>

<pre><code>import RxSwift
import RxCocoa

final class LoginViewModel: ViewModelType {

    typealias Dependency = HasOAuthService

    let isLoggedIn: Driver&lt;Bool&gt;
    let loginURL: Driver&lt;URLComponents?&gt;

    struct Bindings { }

    init(dependency: Dependency, bindings: Bindings) {

        isLoggedIn = dependency.oauthService.currentUser
            .map { user in return user == true }
            .asDriver(onErrorJustReturn: false)

        loginURL = dependency.oauthService.loginURL
            .map { $0 }
            .asDriver(onErrorJustReturn: nil)
    }
}
</code></pre>
","7579156","","","","","2019-06-13 18:29:26","Passing value to ViewModel from ViewController w/ RxSwift","<swift><mvvm><rx-swift>","1","2","","","","CC BY-SA 4.0"
"56588884","1","56597217","","2019-06-13 21:38:55","","1","75","<p>When binding two specific operations to a button tap, does execution order follow binding order?</p>

<p>For example, in the following code, is there a way to tell what gets executed first?</p>

<pre><code>self.resetButton.rx.tap.bind(to: viewModel!.resetPasswordButtonObserver).disposed(by: disposeBag)

self.resetButton.rx.tap.bind {[weak self] in
    self?.loader.lock()
}.disposed(by: disposeBag)
</code></pre>

<p>In my code, the viewModel calls an API and executes the reset operation before the <code>self?.loader.lock()</code> block is executed, which may cause problems for really fast connections.</p>
","3512313","","","","","2019-06-14 11:25:43","Does binding order matter when binding multiple operations to a single control event?","<ios><bind><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"56595499","1","56598645","","2019-06-14 09:41:32","","0","164","<p>We have an application that has huge code base written in Objective C following MVC pattern.
Now we are planning to use RxSwift(with MVVM pattern) for adding new features/screens to the existing app. Is this recommended approach to do this? How good is the interoperability between these two?</p>

<p>Also we are thinking of migrating the entire code base in a phased manner to RxSwift. I am new to RxSwift. I couldn't get any help regarding this if someone else have achieved this without any issue. Just wanted to know what kind of issues we might encounter in this process and what kind of effort is needed here.</p>

<p>Is it possible to call obj c functions in RxSwift and vice versa?</p>
","3640951","","3640951","","2019-06-14 10:13:12","2019-06-17 08:16:45","Does Legacy Objective C code with MVC pattern co-exist with RxSwift?","<ios><objective-c><swift><rx-swift>","1","4","","","","CC BY-SA 4.0"
"56601224","1","","","2019-06-14 15:28:35","","0","614","<p>I am trying to navigate to a specific screen depending on the subview clicked in a UIStackView. How do I set tap gesture to the view and know which subview I actually tapped on?</p>

<p><strong>ViewModel.swift</strong></p>

<pre><code>    let currentAccount = UIAccountCardView(accountType: ""Account 1"",
                                           accountNumber: """",
                                           accountBalance: """")

    let savingsAccount = UIAccountCardView(accountType: ""Account 2"",
                                           accountNumber: """",
                                           accountBalance: """")

    let basicSavingsAccount = UIAccountCardView(accountType: ""Account 3"",
                                                accountNumber: """",
                                                accountBalance: """")

    let accounts = [currentAccount, savingsAccount, basicSavingsAccount]

    let accountCards = Observable.just(accounts)
</code></pre>

<p><strong>ViewController.swift</strong></p>

<pre><code>viewModel.output.accountCards
            .subscribe(onNext: { accounts in
                accounts.forEach({ [weak self] cardView in
                    // Set tap gesture recognizer here?
                    // How do I know which cardView did I tap on?
                    self?.dashboardView.accountStackView.addArrangedSubview(cardView)
                })
            })
            .disposed(by: disposeBag)
</code></pre>
","11315473","","","","","2019-06-14 18:57:16","How to determine which subview clicked and set action to it in UIStackview?","<ios><swift><uiview><rx-swift><uistackview>","1","0","","","","CC BY-SA 4.0"
"56612227","1","56614365","","2019-06-15 16:35:36","","2","136","<p>I have a network request called <code>login</code> that returns an <code>Observable&lt;UserInfo&gt;</code>.  I need to make another API call from that result based on whether the data returned from <code>login</code> has a count > 1, otherwise, I just need to go to a different view controller.  I’m trying to use <code>flatMapLatest</code> to do the check for the first request <code>login</code> and make the next network call <code>jobStates</code> (which returns an <code>Observable&lt;JobState&gt;</code>, but I don’t think I’m arranging them correctly.   Any ideas?  Is there a better / easier way to do this?</p>

<p>Here's what it looks like:
<a href=""https://i.stack.imgur.com/OFdON.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/OFdON.png"" alt=""enter image description here""></a></p>
","5380266","","","","","2019-06-16 02:03:22","Chaining observables (that are network requests)","<swift><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"56623583","1","56632300","","2019-06-17 00:36:40","","2","2715","<p>I have a pretty hefty chunk of chained Rx observables that are fired when a tableviews row is selected via <code>table.rx.modelSelected</code>.  </p>

<p>I'd like to be able to break this logic up, because I'm currently having to execute business logic in <code>flatMapLatest</code>, because it's ""Step 1"" to the process (which feels wrong), and I have to execute more business logic in the subsequent <code>subscribe</code> (""Step 2"").  Here's the code I'm using:</p>

<pre class=""lang-swift prettyprint-override""><code>locationsTable.rx.modelSelected(Location.self)
    .flatMapLatest { [weak self] location -&gt; Observable&lt;[JobState]?&gt; in
        guard let hubs = self?.viewModel.userInfo.authorizedHubLocations else { return .empty() }
        guard let hub = hubs.first(where: { $0.locationId == location.id }) else { return .empty() }
        guard let hubToken = hub.hubToken else { return .empty() }

        // save data in db
        self?.databaseService.persistHub(hubResult: hub, location: location)

        // make network call for the 2nd step (the subscribe)
        let networkService = NetworkService(plugins: [AuthPlugin(token: hubToken)])
        return networkService.jobStates(locationId: location.id)
    }
    .subscribe(onNext: { [weak self] jobState in
        if let jobState = jobState {
            self?.databaseService.persistJobStates(jobStates: jobState)
        }
        NavigationService.renderScreenB()
    }, onError: { error in
        Banner.showBanner(type: .error, title: ""Whoops"", message: ""Something went wrong."")
    }).disposed(by: disposeBag)
</code></pre>

<p>This code currently works, but it feels dirty.  Any advice on how to clean this up would be greatly appreciated.</p>
","5380266","","","","","2019-06-17 13:34:22","Re-organizing chained observables","<swift><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"56623771","1","","","2019-06-17 01:27:32","","0","68","<p>I have this vc
<a href=""https://github.com/vlainvaldez/kwizapp/blob/master/kwizapp/Quiz/QuizCreator/QuizCreatorVC.swift"" rel=""nofollow noreferrer"">https://github.com/vlainvaldez/kwizapp/blob/master/kwizapp/Quiz/QuizCreator/QuizCreatorVC.swift</a></p>

<p>that generates a cells same cells for each horizontal scroll
<a href=""https://github.com/vlainvaldez/kwizapp/blob/master/kwizapp/Quiz/QuizCreator/QuizCreatorCell.swift"" rel=""nofollow noreferrer"">https://github.com/vlainvaldez/kwizapp/blob/master/kwizapp/Quiz/QuizCreator/QuizCreatorCell.swift</a></p>

<p>Im passing a model for each cell called Quiz</p>

<pre><code>cell.configure(with: self.quizes[indexPath.row])
</code></pre>

<p><a href=""https://github.com/vlainvaldez/kwizapp/blob/master/kwizapp/Models/Quiz.swift"" rel=""nofollow noreferrer"">https://github.com/vlainvaldez/kwizapp/blob/master/kwizapp/Models/Quiz.swift</a></p>

<p>inside the Quiz model ihave</p>

<pre><code>public let questionBehavior: BehaviorRelay&lt;String&gt; = BehaviorRelay&lt;String&gt;(value: """")
public let answerBehavior: BehaviorRelay&lt;String&gt; = BehaviorRelay&lt;String&gt;(value: """")
</code></pre>

<p>which are about to have an input upon text change in the cell: QuizCreatorCell.swift</p>

<p>but then when I try to scroll next then go back the Im setting the textviews to</p>

<pre><code>self.questionTextView.text = quiz.questionBehavior.value
self.answerTextView.text = quiz.answerBehavior.value
</code></pre>

<p>Im expecting the values will still be there but it is not even I used a class which a reference type</p>
","11070352","","","","","2019-06-17 01:27:32","textview value does not save to model using rxswift behaviorrelay","<swift><textview><rx-swift>","0","3","","","","CC BY-SA 4.0"
"56632636","1","56666756","","2019-06-17 13:45:43","","1","2146","<p>I am working on an app that uses an API that have some inconsistencies, I have achieved a result with these 2 observables that perform some shared actions but the first one '<strong>servers</strong>' is an array that binds to the UITableView.</p>

<pre><code>    serversViewModel.servers
        .asObservable()
        .observeOn(MainScheduler.instance)
        .bind(to: serversTableView.rx.items(cellIdentifier: ServersTableViewCell.identifier, cellType: ServersTableViewCell.self)) { [weak self] (row, element, cell) in

            guard let strongSelf = self else { return }
            cell.serverProxy.accept(element)
            if let currentServer = strongSelf.serversViewModel.currentServer.value,
                element == currentServer,
                let index = strongSelf.serversViewModel.servers.value.firstIndex(where: { $0 == currentServer }){

                strongSelf.serversTableView.selectRow(at: IndexPath(row: index, section: 0), animated: true, scrollPosition: .top)

            }

        }
        .disposed(by: disposeBag)

    serversViewModel.currentServer
        .asObservable()
        .observeOn(MainScheduler.instance)
        .subscribe(onNext: { [weak self] (server) in

            guard let strongSelf = self else { return }
            if let server = server, let index = strongSelf.serversViewModel.servers.value.firstIndex(where: { $0 == server }){
                strongSelf.serversTableView.selectRow(at: IndexPath(row: index, section: 0), animated: true, scrollPosition: .top)
            }
            else{
                strongSelf.serversTableView.deselectAllItems(animated: false)
            }

        })
        .disposed(by: disposeBag)
</code></pre>

<p>Is it possible to create a combined observable for both and use it for binding the UITableView?</p>

<p>Thank you</p>
","1824565","","1824565","","2019-06-17 13:54:09","2019-06-21 00:44:35","Observable.CombineLatest bind and subscribe RxSwift","<rx-swift>","3","0","","","","CC BY-SA 4.0"
"56657789","1","","","2019-06-18 22:22:20","","1","97","<p>Can so help to resolve this error
<a href=""https://i.stack.imgur.com/vkAyn.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vkAyn.jpg"" alt=""enter image description here""></a></p>

<p>ViewController.swift
this is my code in the viewDidLoad.</p>

<pre><code>class ViewController: UITableViewController {
    let dataManager = DataManager()
    let disposeBag = DisposeBag()
    override func viewDidLoad() {
        super.viewDidLoad()
        let viewModel = ViewModel()
        viewModel.fetch(dataManager)
        _ = viewModel.items.subscribe({ books in
            print(books)


        })
    }
}
</code></pre>

<p>this is the way I implemented items in the viewModel.
<strong>ViewModel.swift</strong></p>

<pre><code>import Foundation
import RxSwift

class ViewModel: ViewModelProtocol {
    var isError: Bool = false
    var message: String?
    typealias T = Book
    var items:Observable&lt;[Book]&gt; = Observable&lt;[Book]&gt;()
    func fetch(_ dataManager: DataManager) {
        dataManager.get(for: .book) { [weak self] results in
            self?.items = Observable&lt;[Book]&gt;.create({ subscriber -&gt; Disposable in
                switch results {
                case .success(let books):
                    subscriber.onNext(books as! [Book])
                    subscriber.onCompleted()
                case .failure(let error):
                    subscriber.onError(error)
                }
                return Disposables.create()
            })

        }
    }
}
</code></pre>
","10248640","","10248640","","2019-06-22 12:13:54","2019-06-23 20:35:35","RxSwift - Fatal error: Abstract method error","<observable><rx-swift>","1","4","","","","CC BY-SA 4.0"
"56724018","1","","","2019-06-23 12:45:47","","1","256","<p>I am observing for value change in userDefaults </p>

<p><code>userDefaults.rx.observe(Int.self, option.userDefaultsKey)</code></p>

<p>For unit testing I did userDefaultsMock, I am not getting how to emit when value is updated or set for those particular keys</p>

<pre><code> override func setValue(_ value: Any?, forKey key: String) {
        tempArray[key] = value
    }
</code></pre>
","2949304","","2949304","","2019-06-23 13:22:15","2019-06-25 15:11:15","RxSwift Observing test cases on mocked UserDefaults","<ios><swift><unit-testing><mocking><rx-swift>","2","0","","","","CC BY-SA 4.0"
"56747818","1","56757988","","2019-06-25 06:11:11","","1","927","<p>It's my first time using <strong>RxTest</strong> and I am struggling how to do the following approach:</p>

<pre class=""lang-swift prettyprint-override""><code>protocol ViewModelType {
    func transform(input: ViewModel.Input) -&gt; ViewModel.Output
}

struct ViewModel: ViewModelType {
    private let isLoading = PublishSubject&lt;Bool&gt;()

    struct Input {
        let trigger: PublishSubject&lt;Void&gt;
    }

    struct Output {
        let someAction: Observable&lt;Void&gt;
        let isLoading: Observable&lt;Bool&gt;
    }

    func transform(input: Input) -&gt; Output {
        let someAction = input
            .trigger
            .do(onNext: { _ in
                self.isLoading.onNext(true)
                //do some async task
                self.isLoading.onNext(false)
            })
        return Output(someAction: someAction, isLoading: isLoading)
    }
}
</code></pre>

<p>I have created a Publish Subject inside the viewModel to notify the view when it should show the loader or not.</p>

<p>Everything works fine, excepts I don't know how to test it with the RxTest framework.</p>

<p>I was trying to use the scheduler and cold observables but couldn't manage to make it work.</p>

<p>What I would like to have:</p>

<ol>
<li>With the scheduler send the .next(10, ()) to the trigger. </li>
<li>Somehow record the events of the isLoading and assert equal that goes first true and then false. Like that: [.next(10, true), .next(20, false)].</li>
</ol>

<p>Maybe, the isLoading the way I did it, it's not testable. But seems it's going out through the Output I think maybe there is some way.</p>

<p>Thank you so much, if something is unclear, please feel free to edit or guide me to a better question. Much appreciated.</p>
","5288983","","5288983","","2019-06-25 15:34:28","2019-06-25 15:59:49","Trigger an event and wait for multiple events RxTest","<swift><rx-swift><rxtest>","1","0","1","","","CC BY-SA 4.0"
"56753662","1","","","2019-06-25 12:04:28","","0","47","<p>I'm new to rx and curious about a question: What's the replacement of override in Rx?</p>

<p>For codes I have read about rx, a button is configured like:</p>

<pre class=""lang-swift prettyprint-override""><code>override func viewDidLoad() {
    super.viewDidLoad()

    updateConversation()

    self.naviAvatar.rx.tap
        .debug(""naviAvatar tap"")
        .subscribe(onNext: { _ in
            print(""didTapNaviAvatar"")
        })
        .disposed(by: disposeBag)
}
</code></pre>

<p>and it works perfect.</p>

<p>However I meet a question that in a subclass I want to silent the button and I don't know how to achieve in rx.</p>

<p>In my previous code, I have following codes:</p>

<pre class=""lang-swift prettyprint-override""><code>class A: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()

        let tapRecognizer = UITapGestureRecognizer(target: self, action: #selector(didTapNaviAvatar(_:)))
        self.naviAvatar.addGestureRecognizer(tapRecognizer)
    }

    @objc func didTapNaviAvatar(_ sender: Any) {
            print(""didTapNaviAvatar"")
        }
    //...
}

class B: A {
    // Silent the method, do nothing.
    override func didTapNaviAvatar(_ sender: Any) {}
    //...
}
</code></pre>

<p>I came up with an idea that I can reconfigure the <code>naviAvatar</code> in <code>B</code>'s <code>viewDidLoad</code> method. But what if I have number of codes(like 20 lines, including mapping, filtering, configuring) about the button's behavior but I just want to change only one line(like just override the button title on touch down)?</p>

<p>Any helps would be appreciated.</p>
","6802734","","6802734","","2019-06-26 10:03:11","2019-06-26 10:03:11","What's the replacements of override in Rx?","<swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"56765993","1","56767546","","2019-06-26 05:47:14","","0","83","<p>1)When notification comes,i need to save data from AnyHashable(""data"") ""amount"" and ""inBalance""?</p>

<p>2)From server comes two pushes first push with ""message"",second ""nil message body"".There when nil message comes i need to silent it? 
How i can save it?
I'm using xCode 10.2.1 </p>

<p>my code for pushNotification.swift looks like:</p>

<pre><code>enum PillikanRemoteNotification:Int {
    case empty
    case notification = 2
    case news = 3
}

class PushManagerNotification {
    func convert(with value: [AnyHashable: Any], and state: PushNotificationAction) {
        guard let json = value as? [String: AnyObject], !json.isEmpty else { return }
        guard let jsonString = value[""data""] as? String, !jsonString.isEmpty else { return }
        guard let jsonData = jsonString.data(using: .utf8) else { return }
        guard let rawDictionary = try? JSONSerialization.jsonObject(with: jsonData, options: .mutableLeaves) else { return }
        guard let dictionary = rawDictionary as? [String: AnyObject] else { return }
        guard let actionType = dictionary[""action""] as? String, let action = Int(actionType) else { return }
        guard let notificationType = PillikanRemoteNotification(rawValue: action) else { return }
        guard let messageBody = dictionary[""msg""] as? [String: AnyObject] else { return }

        if state == .show {
            showBadges(dictionary: messageBody)
            return
        }

        switch notificationType {
        case .notification:
            showNotification(dictionary: messageBody)
            break
        default:
            break;
        }
    }

    private func showBadges(dictionary: [String: AnyObject]) {
        guard let badgeMessage = dictionary[""badges""] as? [String: AnyObject] else { return }
        guard let badges = Badges(JSON: badgeMessage) else { return }
        UIApplication.shared.notificationBadgesForNotification = badges.notifications
        UIApplication.shared.notificationBadgesForNews = badges.news
        UIApplication.shared.applicationIconBadgeNumber = badges.news + badges.notifications
        NotificationCenter.default.post(name: .badges, object: badges)
    }

    private func showNotification(dictionary: [String:AnyObject]) {
        if let message = NotificationEntity(JSON: dictionary) {
            NotificationCenter.default.post(name: .notification, object: message);
        }
    }

extension Notification.Name {
    static let empty = Notification.Name(""empty"");
    static let notification = Notification.Name(""notification"");
    static let news = Notification.Name(""news"");
    static let badges = Notification.Name(""badges"")
}
</code></pre>
","","user10319455","","user10319455","2019-06-26 14:38:05","2019-06-26 14:38:05","How to save two items which comes with pushNotification","<ios><swift><xcode><rx-swift>","3","0","","","","CC BY-SA 4.0"
"56772596","1","56772886","","2019-06-26 12:15:49","","1","926","<p>I am making an api call which requires me to pass JSON as paramter. when I do that, it crashes the application. I am using Moya for my networking so I decided to use SwiftyJSON to get JSON directly to the body but the app crashes saying <code>Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'Invalid type in JSON write (__SwiftValue)</code></p>

<pre><code>public var task: Task {
        switch self {
        case .postCheckout(let cart): return .requestParameters(parameters: [""cart"": cart], encoding: JSONEncoding.default)
        }
    }
</code></pre>

<p>my moya</p>

<pre><code>func postCheckout(cart: JSON) -&gt; Observable&lt;BaseResponseModel&gt; {

        return provider.rx.request(.postCheckout(cart: cart))
            .mapObject(BaseResponseModel.self)
            .asObservable()
    }
</code></pre>

<p>when I printed the JSON this is what gets printed</p>

<pre><code>{
  ""total"" : 6000,
  ""subscription"" : {
    ""id"" : 4,
    ""quantity"" : 3
  },
  ""vas"" : [
    4,
    6,
    2
  ]
}
</code></pre>
","8310287","","","","","2019-06-26 12:30:37","Passing JSON as a parameter swift","<swift><rx-swift><swifty-json><moya>","1","5","","","","CC BY-SA 4.0"
"56791758","1","","","2019-06-27 13:08:29","","1","271","<p>Currently I'm having a <code>Observable</code> created using <code>scan</code> to update underlying model using a <code>PublishSubject</code> like this:</p>

<pre class=""lang-swift prettyprint-override""><code>class ViewModel {

    private enum Action {
        case updateName(String)
    }

    private let product: Observable&lt;Product&gt;
    private let actions = PublishSubject&lt;Action&gt;()

    init(initialProduct: Product) {
        product = actions
            .scan(initialProduct, accumulator: { (oldProduct, action) -&gt; Product in
                var newProduct = oldProduct

                switch action {
                case .updateName(let name):
                    newProduct.name = name
                }

                return newProduct
            })
            .startWith(initialProduct)
            .share()
    }

    func updateProductName(_ name: String) {
        actions.onNext(.updateName(name))
    }

    private func getProductDetail() {
        /// This will call a network request
    }
}

</code></pre>

<p>Every ""local"" actions like update product's name, prices... is done by using method like <code>updateProductName(_ name: String)</code> above. But what if I want to have a network request that also update the product, and can be called every time I want, for example after a button tap, or after calling <code>updateProductName</code>?</p>

<p>// UPDATE: After read iWheelBuy's comment and Daniel's answer, I ended up using 2 more actions</p>

<pre class=""lang-swift prettyprint-override""><code>class ViewModel {

    private enum Action {
        case getDetail
        case updateProduct(Product)
    }

    ///....

    init(initialProduct: Product) {
        product = actions
            .scan(initialProduct, accumulator: { (oldProduct, action) -&gt; Product in
                var newProduct = oldProduct

                switch action {
                case .updateName(let name):
                    newProduct.name = name

                case .getDetail:
                    self.getProductDetail()

                case .updateProduct(let p):
                    return p
                }

                return newProduct
            })
            .startWith(initialProduct)
            .share()
    }

    func getProductDetail() {
        actions.onNext(.getDetail)
    }

    private func getProductDetail(id: Int) {
        ProductService.getProductDetail(id) { product in
            self.actions.onNext(.updateProduct(product))
        }
    }
}

</code></pre>

<p>But I feel that, I trigger side effect (call network request) inside <code>scan</code>, without updating the model, is that something wrong?</p>

<p>Also how can I use a ""rx"" network request?</p>

<pre class=""lang-swift prettyprint-override""><code>    // What if I want to use this method instead of the one above,
    // without subscribe inside viewmodel?
    private func rxGetProductDetail(id: Int) -&gt; Observable&lt;Product&gt; {
        return ProductService.rxGetProductDetail(id: Int)
    }
</code></pre>
","4405051","","4405051","","2019-06-28 04:01:46","2019-06-28 10:41:02","Combine scan with network request to update model in RxSwift","<reactive-programming><rx-swift>","1","1","1","","","CC BY-SA 4.0"
"56798982","1","","","2019-06-27 22:07:37","","1","38","<p>Cannot hook into another RxSwift Stream based on the check that was added before the network request. </p>

<p>I am constructing a UserProfile object but I want to make sure that the userProfile object has been completely created. I have a stream that is creating the userProfile object but now I have a check. I want to hook into the previous stream so that upon a complete UserProfile I can perform a network request. I'm unsure about how to hook into the previous stream. The updateUserProfile($0) is where I am passing the UserProfile object to make the network request but I want to make sure that I stop right there. </p>

<pre><code>let userInfoResponse = latestLocallySavedUserProfileDictionary
            .map { (dictionary: [String: String?]) in
               return UserProfile(
                    firstName: dictionary[""firstName""] ?? """",
                    lastName: dictionary[""lastName""] ?? """",
                    phone: dictionary[""phone""] ?? """",
                    company: dictionary[""company""] ?? """",
                    organizationType: dictionary[""organizationType""] ?? """",
                    jobFunction: dictionary[""jobFunction""] ?? """",
                    addressLine1: dictionary[""addressLine1""] ?? """",
                    addressLine2: dictionary[""addressLine2""] ?? """",
                    city: dictionary[""city""] ?? """",
                    state: dictionary[""state""] ?? nil,
                    zipCode: dictionary[""zipCode""] ?? """",
                    country: dictionary[""country""] ??  """",
                    languageCode: dictionary[""languageCode""] ?? """",
                    merrillDisclaimerAccepted: false, // ignore for now
                    merrillDisclaimerAcceptedDate: """" // ignore for now
                )
            }

            .flatMapLatest { updateUserProfile($0) }
            .share()

        isUserProfileDictionaryComplete = Observable.merge([
            initialUserProfileCall,
            userInfoResponse
                .map{$0.createDictionary()},
            userProfileLocal
            ])
                .asObservable()
                .map{(profileDictionary) -&gt; Bool in
                    return profileDictionary.values.contains(nil) || profileDictionary.values.contains("""")
                }
                .ignore(true)
</code></pre>
","9398617","","","","","2019-06-28 03:06:02","Cannot hook into another RxSwift stream based on a check","<swift><io><rx-swift>","1","0","","","","CC BY-SA 4.0"
"56804308","1","56806106","","2019-06-28 09:26:40","","2","761","<p>So, I want to keep the observable keep alive (not disposhed) even after input <code>onError()</code>, so I can input <code>onNext()</code></p>

<p>I already follow <a href=""https://stackoverflow.com/questions/33885108/rxswift-error-handle-issue"">this answer</a> </p>

<p>by adding <code>.catchError()</code> or <code>.catchErrorReturn()</code> but it didn't work like I expected </p>

<p>(nb: I run this code on playground)</p>

<pre><code>    let bag = DisposeBag()
    let data = PublishSubject&lt;Observable&lt;Int&gt;&gt;()
    data.debug(""debug"").flatMap({
        $0.map({data in
            return data
        }).catchError({err in
            return Observable.empty()
        })
    }).subscribe(onNext:{
        print($0)
    },onCompleted:{
        print(""end"")
    }).disposed(by: bag)
    let inputData = PublishSubject&lt;Int&gt;()
    data.onNext(inputData)
    inputData.onNext(1)
    inputData.onNext(2)
    inputData.onError(MyError.anError)
    inputData.onNext(2)

</code></pre>

<p>actual result I get</p>

<pre><code>1
2
</code></pre>

<p>expected result I want</p>

<pre><code>1
2
2
</code></pre>
","6734130","","1173806","","2019-06-28 09:58:01","2019-06-28 17:03:52","why I can't keep observable alive after .onError() even I already use error handling like .catchError() onRxSwift?","<swift><rx-swift>","1","5","1","","","CC BY-SA 4.0"
"56808864","1","56835587","","2019-06-28 14:38:33","","0","411","<p>I have a CollectionView in a ViewController and I'm trying to get a list of objects from Realm and bind it to the CollectionView using RxSwift. </p>

<p>The problem is that i'm getting the error: </p>

<blockquote>
  <p>""Ambiguous reference to member 'items(cellIdentifier:celltype:)'""</p>
</blockquote>

<p>in the line:
 .bind(to: collection.rx.items(cellIdentifier ...)</p>

<p>This is the code:</p>

<pre><code>import UIKit
import RxRealm
import RxSwift
import RxCocoa

class MyListViewController: UIViewController {

    var myList: MyList?

    private var collection: UICollectionView?

    {...}

    private func loadMyList() {
        let myList = retrieveMyListFromDb()
        guard
            let list = myList,
            let collection = collection
        else { return }

        let disposeBag = DisposeBag()

        Observable.from(list)
            .bind(
               to: collection.rx.items(
                cellIdentifier: HomeMovieCollectionViewCell.identifier, 
                cellType: HomeMovieCollectionViewCell.self)
             ) { (row, element, cell) in

         }
        .disposed(by: disposeBag)
    }

    private func retrieveMyListFromDb() -&gt; MyList? {
        return RealmManager().objects(MyList.self)?.filter {
            $0.userId == 0
        }.first
    }
</code></pre>

<p>And this is MyList code:</p>

<pre><code>import Foundation
import Realm
import RealmSwift

@objcMembers
class MyList: Object {
    dynamic var userId: Int = 0
    var movies = List&lt;Movie&gt;()

    public override static func primaryKey() -&gt; String? { return ""userId"" }
}
</code></pre>
","4687709","","4687709","","2019-06-28 15:34:27","2019-07-01 12:19:12","Ambiguous reference to member 'items(cellIdentifier:celltype:)' using RxSwift and RxRealm","<swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"56808888","1","","","2019-06-28 14:40:00","","0","106","<p>I have an output that lives in my VM and based on some change I want my textfield that resides in my custom tableviewCell to change in some way. I am unsure about how to have my UItextfield that lives in the tableviewcell bind to my output. </p>
","9398617","","9398617","","2019-06-29 21:23:26","2019-06-29 21:23:26","Trying to bind an output to my tableviewCell UI Element in RxSwift","<swift><uitableview><textfield><rx-swift><rxdatasources>","2","1","","","","CC BY-SA 4.0"
"56815107","1","56816020","","2019-06-29 04:40:15","","0","1913","<p>I'm new to RxSwift. This is quite tricky.</p>

<p>I'm creating like ToDoList that views which are tableView and add-item view are separated by TabBarController.
I have successfully displayed the list array and added a new item into tableView.</p>

<p>I also wanted to display the number of array's count and favourite count in the view that has tableView so that I have displayed it by throwing a value with <code>.just</code>.</p>

<p><strong>But displaying a value based on the result of the array displayed by SearchBar, the value is not reflected as I expected.</strong></p>

<p>In MainViewModel, I made sure if I could get the number of array's count properly by <code>print</code>, but apparently the value was fine. 
It is just not reflected in the View.</p>

<p>// Model</p>

<pre class=""lang-swift prettyprint-override""><code>struct Item: Codable {
    var name = String()
    var detail = String()
    var tag = String()
    var memo = String()
    var fav = Bool()
    var cellNo = Int()

    init(name: String, detail: String, tag: String, memo: String, fav: Bool, celllNo: Int) {
        self.name = name
        self.detail = detail
        self.tag = tag
        self.memo = memo
        self.fav = fav
        self.cellNo = celllNo
    }

    init() {
        self.init(
            name: ""Apple"",
            detail: ""ringo"",
            tag: ""noun"",
            memo: """",
            fav: false,
            celllNo: 0
        )
    }
}




struct SectionModel: Codable {
    var list: [Item]
}
extension SectionModel: SectionModelType {
    var items: [Item] {
        return list
    }

    init(original: SectionModel, items: [Item]) {
        self = original
        self.list = items
    }

}
</code></pre>

<p>Singleton share class</p>

<pre class=""lang-swift prettyprint-override""><code>final class Sharing {

    static let shared = Sharing()

    var items: [Item] = [Item()]

    var list: [SectionModel] = [SectionModel(list: [Item()])] {
        didSet {
            UserDefault.shared.saveList(list: list)
        }
    }

    let listItems = BehaviorRelay&lt;[SectionModel]&gt;(value: [])

}

extension Sharing {
    func calcFavCount(array: [Item]) -&gt; Int {
        var count = 0
        if array.count &gt; 0 {
            for i in 0...array.count - 1 {
                if array[i].fav {
                    count += 1
                }
            }
        }
        return count
    }
}
</code></pre>

<p>// MainTabViewController</p>

<pre class=""lang-swift prettyprint-override""><code>class MainTabViewController: UIViewController {

    @IBOutlet weak var listTextField: UITextField!
    @IBOutlet weak var tagTextField: UITextField!
    @IBOutlet weak var itemCountLabel: UILabel!
    @IBOutlet weak var favCountLabel: UILabel!
    @IBOutlet weak var favIcon: UIImageView!
    @IBOutlet weak var infoButton: UIButton!
    @IBOutlet weak var searchBar: UISearchBar!
    @IBOutlet weak var tableView: UITableView!

    private lazy var viewModel = MainTabViewModel(
        searchTextObservable: searchTextObservable
    )

    private let disposeBag = DisposeBag()
    private var dataSource: RxTableViewSectionedReloadDataSource&lt;SectionModel&gt;!

    override func viewDidLoad() {
        super.viewDidLoad()
        setupTableViewDataSource()
        tableViewSetup()
        listDetailSetup()
    }

    // create Observable searchBar.text to pass to ViewModel
    var searchTextObservable: Observable&lt;String&gt; {

        let debounceValue = 200

        // observable to get the incremental search text
        let incrementalTextObservable = rx
            .methodInvoked(#selector(UISearchBarDelegate.searchBar(_:shouldChangeTextIn:replacementText:)))
            .debounce(.milliseconds(debounceValue), scheduler: MainScheduler.instance)
            .flatMap { [unowned self] _ in Observable.just(self.searchBar.text ?? """") }

        // observable to get the text when the clear button or enter are tapped
        let textObservable = searchBar.rx.text.orEmpty.asObservable()

        // merge these two above
        let searchTextObservable = Observable.merge(incrementalTextObservable, textObservable)
            .skip(1)
            .debounce(.milliseconds(debounceValue), scheduler: MainScheduler.instance)
            .distinctUntilChanged()

        return searchTextObservable
    }

    func setupTableViewDataSource() {
        dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&gt;(configureCell: {(_, tableView, indexPath, item) in
            let cell = tableView.dequeueReusableCell(withIdentifier: ""ListCell"") as! ListCell
            cell.selectionStyle = .none
            cell.backgroundColor = .clear
            cell.configure(item: item)
            return cell
        })
    }

    func tableViewSetup() {

        tableView.rx.itemDeleted
            .subscribe {
                print(""delete"")
            }
            .disposed(by: disposeBag)

        viewModel.dispItems.asObservable()
            .bind(to: tableView.rx.items(dataSource: dataSource))
            .disposed(by: disposeBag)
    }

    func listDetailSetup() {

        viewModel.itemCountObservable
            .bind(to: itemCountLabel.rx.text)
            .disposed(by: disposeBag)

        viewModel.favCountObservable
            .bind(to: favCountLabel.rx.text)
            .disposed(by: disposeBag)
    }
}
</code></pre>

<p>MainTabViewModel</p>

<pre class=""lang-swift prettyprint-override""><code>final class MainTabViewModel {

    private let disposeBag = DisposeBag()
    private let userDefault: UserDefaultManager
    var dispItems = BehaviorRelay&lt;[SectionModel]&gt;(value: [])
    private let shared = Sharing.shared

//    lazy var itemCount = shared.list[0].list.count
//    lazy var favCount = shared.calcFavCount

    var itemCountObservable: Observable&lt;String&gt;
    var favCountObservable: Observable&lt;String&gt;

    init(searchTextObservable: Observable&lt;String&gt;,
         userDefault: UserDefaultManager = UserDefault()) {

        self.userDefault = userDefault

        let initialValue = shared.list
        shared.listItems.accept(initialValue)
        dispItems = shared.listItems

       // this part is to display the initil number -&gt; success
        var itemCount = shared.list[0].list.count
        itemCountObservable = .just(itemCount.description + "" items"")

        var favCount = shared.calcFavCount(array: shared.list[0].list)
        favCountObservable = .just(favCount.description)


        // this part is based on the searching result -&gt; failure
        searchTextObservable.subscribe(onNext: { text in
            if text.isEmpty {
                let initialValue = self.shared.list
                self.shared.listItems.accept(initialValue)
                self.dispItems = self.shared.listItems
            }else{
                let filteredItems: [Item] = self.shared.list[0].list.filter {
                    $0.name.contains(text)
                }
                let filteredList = [SectionModel(list: filteredItems)]
                self.shared.listItems.accept(filteredList)
                self.dispItems = self.shared.listItems

                itemCount = filteredItems.count
                self.itemCountObservable = .just(itemCount.description + "" items"")
                favCount = self.shared.calcFavCount(array: filteredItems)
                self.favCountObservable = .just(favCount.description)

                print(""\(itemCount) items"") // the ideal number is in but not shown in the view
            }
        })
        .disposed(by: disposeBag)

    }

}
</code></pre>

<p>I removed unnecessary code but I mostly pasted a whole code for your understanding.</p>

<p>Hope you could help me.</p>

<p>Thank you.</p>
","11408253","","","","","2019-06-29 08:06:30","RxSwift - How to reflect the number of item's count to TableView","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"56816733","1","56817465","","2019-06-29 10:18:24","","1","934","<p>In my app, I have a table view that has a bunch of rows. The table view is populated by an observable. I am doing this using RxDataSources using a <code>RxTableViewSectionedAnimatedDataSource</code>.</p>

<p>The rows of the table view represent some kind of items that the user can perform actions on. This means that I want to some buttons to appear when a row is selected, and I want those buttons to disappear when no rows are selected. Those buttons are the actions that the user can perform on the items.</p>

<p>I figured that I can observe the <code>indexPathForSelectedRow</code> property and bind that to <code>button.rx.isHidden</code>, like so:</p>

<pre><code>[actionButton1, actionButton2, actionButton3].forEach { (button) in
    button?.isHidden = true // they are always hidden initially
    self.tableView.rx.observe(IndexPath?.self, ""indexPathForSelectedRow"")
        .map { ($0 as? IndexPath) == nil } // $0 is a double optional, so I unwrap it like this
        .bind(to: button!.rx.isHidden)
        .disposed(by: disposeBag)
}
</code></pre>

<p>However, when I select an item, the action buttons do not appear at all.</p>

<p>I also tried to observe <code>indexPathsForSelectedRows</code>, but it yields the same result.</p>

<p>Then I tried to subscribe to <code>itemSelected</code> and <code>itemDeselected</code> individually:</p>

<pre><code>[actionButton1, actionButton2, actionButton3].forEach { (button) in
    button?.isHidden = true

    self.tableView.rx.itemSelected.subscribe(onNext: {
        _ in
        button?.isHidden = false
    }).disposed(by: disposeBag)
    self.tableView.rx.itemDeselected.subscribe(onNext: {
        [weak self] _ in
        button?.isHidden = (self?.tableView.indexPathForSelectedRow ?? nil) == nil
    }).disposed(by: disposeBag)
}
</code></pre>

<p>This time, when I select a row, the buttons appear properly.</p>

<p>However, when the observable data source changes, such that the selected row is removed, causing the table view to not have any selected rows anymore, the action buttons <em>do not disappear</em>.</p>

<p>How do I make it so that my action buttons will disappear when the table view does not have any selected rows?</p>

<p>Note that I don't care <em>which</em> row is selected. I just want to know <em>whether</em> any row is selected. In other words, an <code>Observable&lt;Bool&gt;</code> that emits a new value whenever the statement ""the table view has at least one selected row"" changes from true to false, or from false to true.</p>
","5133585","","5133585","","2019-06-29 12:30:20","2019-06-29 12:49:40","How can I get whether a table view is selected as an Observable<Bool>?","<ios><swift><uitableview><rx-swift>","1","3","","","","CC BY-SA 4.0"
"56819102","1","56836337","","2019-06-29 16:27:05","","1","1210","<p>I have a project where Users select Images from their gallery or snap and it is supposed to be uploaded to a remote server.</p>

<p>Now if I try to upload with a static image that I put in my <code>xcode</code>, The image gets uploaded but the moment I use my <code>ImagePicker</code> and select the Image and pass it to the <code>ImageView</code>, the photo shows but fails to upload to the server. The app does not crash, the image upload just does not go. Any reason why? and any help would be appreciated</p>

<pre><code>NetworkAdapter.instance.uploadImage(status: ""user"", image: Img.image).subscribe(onNext: { check in
            print(""CHECKOUT NOW \(check)"")
        }, onError: { error in
            print(""CHECKOUT NOW \(error.localizedDescription)"")
        }).disposed(by: disposeBag) 
</code></pre>

<p>I am using <code>Moya</code> for API call</p>

<pre><code>case .uploadImage(let data):
            let imageData = data.image.jpegData(compressionQuality: 1.0)
            let memberIdData = ""\(data.status)"".data(using: String.Encoding.utf8) ?? Data()
            var formData: [Moya.MultipartFormData] = [Moya.MultipartFormData(provider: .data(imageData!), name: ""image"", fileName: ""user.jpeg"", mimeType: ""image/jpeg"")]
</code></pre>
","8310287","","10151808","","2019-07-01 15:29:18","2019-07-01 15:29:18","How to upload image in Swift using Moya?","<ios><swift><uiimagepickercontroller><rx-swift><moya>","1","7","2","","","CC BY-SA 4.0"
"56832692","1","56833150","","2019-07-01 08:54:19","","2","1579","<p>I'm learning to use RxSwift and I'm stuck using this simple code. My intention is to take an APIRequest type, as simple as this:</p>

<pre><code>public protocol APIRequest: Encodable {
    associatedtype Response: Decodable

    var path: String { get }
}
</code></pre>

<p>Pass it to the API Client and finally return an Observable of type <code>T.Response</code>, however, I'm constantly seeing <code>cancelled</code> status in my console:</p>

<pre><code>2019-07-01 10:46:04.847: test api request -&gt; subscribed
2019-07-01 10:46:04.855: test api request -&gt; isDisposed
</code></pre>

<p>This is my APIClient's code: </p>

<pre><code>func send&lt;T: APIRequest&gt;(_ request: T) -&gt; Observable&lt;T.Response&gt; {
    guard let fullURL = endpoint(for: request) else {
        return Observable.error(APIError.invalidBaseURL)
    }

    return Observable&lt;T.Response&gt;.create { observer in
        let request = URLRequest(url: fullURL)
        let response = URLSession.shared.rx.response(request: request)
                              .debug(""test api request"")

        return response.subscribe(onNext: { response, data in
            if 200..&lt;300 ~= response.statusCode {
                guard let responseItems = try? self.jsonDecoder.decode(T.Response.self, from: data) else {
                    return observer.onError(APIError.decodingFailed)
                }

                observer.onNext(responseItems)
                observer.onCompleted()
            }
        }, onError: { error in
            observer.onError(APIError.other(error))
        }, onCompleted: nil,
           onDisposed: nil)
    }
}
</code></pre>

<p>I've been trying to get the results printed to the console with:</p>

<pre><code>apiClient.send(countriesRequest)
            .subscribe(onNext: {
                print(""Success"", $0)
            }, onError: {
                print(""Error: "", $0)
            }, onCompleted: {
                print(""Completed!"")
            })
            .disposed(by: disposeBag)
</code></pre>

<p>What am I doing wrong and why?</p>
","4444642","","4444642","","2019-07-01 09:03:42","2019-07-01 09:31:07","RxSwift URLSession request is disposed","<swift><rx-swift>","1","6","","","","CC BY-SA 4.0"
"56833473","1","56834314","","2019-07-01 09:50:04","","0","620","<p>Changes after 0.3 seconds when user stop typing should be displayed in label but subscribe onNext is not calling</p>

<pre class=""lang-swift prettyprint-override""><code>override func viewDidLoad() {
    ...
    let disposeBag = DisposeBag()
    textfield.rx.text.orEmpty
        .debounce(.milliseconds(300), scheduler: MainScheduler.instance)
        .subscribe(onNext: { [unowned self] (text) in
            self.label.text = text
        }).disposed(by: disposebag)
    ...
}

</code></pre>

<p>Using <strong>Swift 5</strong></p>

<pre><code>pod 'RxSwift', '~&gt; 5'
pod 'RxCocoa', '~&gt; 5'
</code></pre>
","7941229","","7718634","","2019-07-04 11:07:28","2019-07-04 11:07:28","RxSwift Textfield debounce subscribe is not calling","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"56890173","1","","","2019-07-04 14:37:16","","2","1462","<p>I am facing issue on debug as well as release mode,</p>

<p>Xcode 10.2.1</p>

<p>macOS Mojave 10.14 .5</p>

<p>swift5.09</p>

<blockquote>
  <blockquote>
    <p>Fatal error: Binding error to behavior relay: objectDeleted: file /Users/webwerks/Desktop/Monster/iOS/monstar_mukesh/project_name/Pods/RxCocoa/RxCocoa/Common/Observable+Bind.swift, line 90
    2019-07-04 15:42:33.074374+0530 target_name[2731:1953909] Fatal error: Binding error to behavior relay: objectDeleted: file</p>
  </blockquote>
</blockquote>

<p><a href=""https://i.stack.imgur.com/INpZu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/INpZu.png"" alt=""enter image description here""></a></p>

<p><strong>Note</strong></p>

<p>There was not any issue &amp; crash on existing code on macOS High Sierra 10.13.6 , Xcode 10.1 (swift4.2)</p>

<p><strong>What I suspect is, there is issue in the following code,</strong></p>

<pre><code>private func logoutAction() -&gt; CocoaAction {
    return CocoaAction { [weak self] in
      guard let `self` = self else { return .empty() }

      let subject = PublishSubject&lt;Void&gt;()

      func changeRootView() {
        let authScene = AuthScene.signin(coordinator: self.sceneCoordinator)
        self.sceneCoordinator.transition(to: authScene, type: .root(animationType: .present))
          .asObservable()
          .mapTo(())
          .bind(to: subject)
          .disposed(by: self.disposeBag)
      }

      self.logoutRequestAction.execute(())
        .subscribe { changeRootView() }
        .disposed(by: self.disposeBag)

      subject
        .subscribe{
          APITokenManager.shared.removeToken()
          RealmDBManager.shared.deleteAllData()
          OneSignalManager.shared.unsubscribe()
        }
        .disposed(by: self.disposeBag)

      return subject
    }
  }
</code></pre>
","4294543","","4294543","","2019-07-04 14:55:07","2019-07-05 09:35:09","Fatal error: Binding error to behavior relay: objectDeleted: file #2025","<rx-swift><rx-cocoa><xcode10.2>","1","0","","","","CC BY-SA 4.0"
"56918965","1","","","2019-07-07 02:34:51","","1","537","<p>I'm learning RxSwift.</p>

<p>I added a border as CALayer to TextField. I would like to make this border reactively auto-resized as the textField is expanded (inputView changed to pickerView so I wish it could be resized by selecting titles)</p>

<p>I tried <code>.rx.observe(CGRect.self, ""frame"")</code> but it doesn't work properly.</p>

<pre class=""lang-swift prettyprint-override""><code>extension UITextField {

    func addBorderBottom(height: CGFloat, color: UIColor, width: CGFloat){
        let border = CALayer()
        border.frame = CGRect(x: 0, y: self.frame.height - height, width: width, height: height)
        border.backgroundColor = color.cgColor
        self.layer.addSublayer(border)
    }

}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>// viewContrller

func listDetailUISetup() {
        let yellowColor = UIColor.hex(string: ""FFB500"", alpha: 1)
        tagTextField.addBorderBottom(height: 1.0, color: yellowColor, width: tagTextField.frame.width)
}

//
picker.rx.modelSelected(String.self)
            .subscribe(onNext: { tags in
                self.tagTextField.text = tags[0]
            })
            .disposed(by: disposeBag)

tagTextField.rx.observe(CGRect.self, ""frame"")
            .subscribe(onNext: { frame in
                print(""field frame changed"")
                let layer = self.tagTextField.layer.sublayers![0]
                layer.frame = frame!
            })
            .disposed(by: disposeBag)
</code></pre>

<p>In a second way, I also tried to manually re-set a border after removing the previous one when a title in the pickerView is selected. But apparently, the width of the item selected at the previous time is reflected.</p>

<p>initial width</p>

<p><a href=""https://i.stack.imgur.com/UbtBw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UbtBw.png"" alt=""enter image description here""></a></p>

<p>All's width</p>

<p><a href=""https://i.stack.imgur.com/ytUx0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ytUx0.png"" alt=""enter image description here""></a></p>

<p>Favourite's width</p>

<p><a href=""https://i.stack.imgur.com/w9Q7X.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/w9Q7X.png"" alt=""enter image description here""></a></p>

<pre class=""lang-swift prettyprint-override""><code>icker.rx.modelSelected(String.self)
            .subscribe(onNext: { tags in
                self.tagTextField.text = tags[0]
                self.tagTextField.layer.sublayers = nil
                self.listDetailUISetup()
            })
            .disposed(by: disposeBag)

</code></pre>

<p>Hopefully, you could help to resolve this issue.</p>

<p>Thank you.</p>
","11408253","","11408253","","2019-07-07 03:05:21","2019-07-07 16:06:57","RxSwift : How to autoresize sublayer with view's resizing","<swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"56928627","1","56929407","","2019-07-08 04:57:49","","1","708","<p>Have an issue with a <code>Driver</code> on RxSwift. Have a view model who is listening to an initTrigger in a ViewController as follow.</p>

<pre><code>    let initTrigger = rx.viewWillAppear
                .mapToVoid()
                .asDriverOnErrorJustComplete()
</code></pre>

<p>This <code>initTrigger</code> is used to bind to another <code>Driver</code> on the view model</p>

<pre><code>
    let shoppingCart: Driver&lt;ShoppingCart&gt;

    let shoppingCart = input.initTrigger
                .flatMapLatest {
                    self.getShoppingCartUseCase
                        .execute()
                        .asDriver(onErrorJustReturn: ShoppingCart())
                }
</code></pre>

<p><code>getShoppingCartUseCase.execute()</code> returns <code>Observable&lt;ShoppingCart&gt;</code> and is using RxRealm lo listen to changes to a database.</p>

<p>back on the view controller, I have subscribed to that <code>shoppingCart</code> like this</p>

<pre><code>        output?.shoppingCart
            .map {
                print(""Mapping"")
                return $0.lines.count == 0
            }
            .asObservable()
            .bind(to: goToCartButton.rx.isHidden)
            .disposed(by: bag)
</code></pre>

<p>I placed the <code>print(""Mapping"")</code> to realize that this last Driver is being triggered constantly after making an action that modifies my model and triggers the <code>Observable&lt;ShoppingCart&gt;</code> I mentioned before.</p>

<p>What I'm doing wrong here?</p>

<p>Thanks for your help.</p>
","580175","","7718634","","2019-07-08 06:40:59","2019-07-08 06:40:59","Driver is being triggered constantly between View Model and View Controller","<swift><realm><rx-swift><rx-cocoa>","2","0","","","","CC BY-SA 4.0"
"56979110","1","","","2019-07-10 21:51:22","","1","35","<p>I have a stream, say streamA, which updates the UI.</p>

<p>I also subscribe to the changes in the UI, like a switch toggle. For every toggle, I make a network call. The result of the network call may be success, failure or pending. I want to be able to reflect this on the UI appropriately.
Is it possible to map these values onto the streamA so that the UI updates.</p>

<pre class=""lang-swift prettyprint-override""><code>streamA
    .subscribe(onNext: { [weak self] (value) in
          self?.updateUI(value)
     })
    .disposed(by: disposeBag)

uiChangeStream
    .withLatestFrom(streamA, resultSelector: { (uiChange, value) -&gt; Setting? in)
       // some mapping code
    })
    .flatMapLatest {
          return self?.networkCall()
    }
</code></pre>

<p>What I am trying to figure is, a way to combine the response from network call, the ui-change-trigger and the streamA value at the time of the trigger and bind that to <code>streamA</code> so that UI would update.</p>
","4881371","","","","","2019-07-11 11:43:15","How do I post different variants of values onto Rx stream?","<rx-swift>","1","2","","","","CC BY-SA 4.0"
"57014215","1","57015440","","2019-07-12 21:28:18","","1","135","<p>I have a observable that emits data which looks something like this:</p>

<pre class=""lang-swift prettyprint-override""><code>struct AlertData {
    let name: String
    let actionStream: PublishSubject&lt;Void&gt;
}
</code></pre>

<p>So when I receive AlertData from observable I directly bind it to another observer, which works fine. But before binding it to another observer, I wanted to get the '<strong>actionStream</strong>' and get events from it.</p>

<p>So, this is how I emitting the AlertData:</p>

<pre class=""lang-swift prettyprint-override""><code>let alertStream = PublishSubject&lt;AlertData&gt;()
alertStream.onNext(***)
</code></pre>

<p>This is the receiving part:</p>

<pre class=""lang-swift prettyprint-override""><code>alertStream.bind(to: anotherObserver).disposed(by: disposeBag)
</code></pre>

<p>But before binding alertStream to anotherObserver, I wanted the actionStream which is inside the AlertData and receive any events emitted from it. What is the proper way of doing it?</p>
","6223683","","","","","2019-07-13 01:08:56","Intercept data from observable before binding it to another observer","<rx-swift><swift5>","1","0","","","","CC BY-SA 4.0"
"57016257","1","","","2019-07-13 04:53:53","","0","334","<p>Datasource is updating, but the changes are not being displayed in the Tableview.</p>

<p>I am experimenting with Friends, Users, &amp; Users Request tableview with 3 sections. When a user has a request from a user, he or she appears under the request section. However, when the user clicks ""accept"" the console is reading it's hitting the firebase server, but the changes that that request was actually made is not registering and the request remains in the section until you reload the view. I have tried forcing a tableview to reload, but to no avail.</p>

<pre><code>struct SectionOfuserRxx {
    var header: String
    var items: [Item]        
}

extension SectionOfuserRxx: IdentifiableType {    

}

extension SectionOfuserRxx: AnimatableSectionModelType {

   // typealias Item = user

    typealias Identity = String

    ////

    typealias Item = user

    init(original: SectionOfuserRxx, items: [Item]) {
        self = original
        self.items = items
    }

    var identity: String {
        return header
    }

}
// Above viewDidLoad
    let disposeBag = DisposeBag()
// 

//Inside viewDidLoad

   let dataSource =  RxTableViewSectionedAnimatedDataSource&lt;SectionOfuserRxx&gt;(
            configureCell: { dataSource, tableView, indexPath, item in

                       switch (indexPath.section) {

                            case 2:

                                let cell = tableView.dequeueReusableCell(withIdentifier: ""userCell"", for: indexPath) as? userCell
                                let userProfileImageURLFirebaseReturn = item.userImageURL

                                            let userNameTagFirebaseReturn = item.nametag
                                            let userNameFirebaseReturn = item.username

                                            let imageURL = userProfileImageURLFirebaseReturn

                                            let resource = ImageResource(downloadURL: URL(string: imageURL!)!, cacheKey: userProfileImageURLFirebaseReturn)

                                            cell?.userProfileImage.kf.setImage(with: resource)
                                  cell?.usernameLbl.text = userNameFirebaseReturn
                                            cell?.userNameTagLbl.text = ""| "" + userNameTagFirebaseReturn!
                                 cell!.setFunction {

                                            cell!.button.isEnabled = true
                                            let id =  item.userUID

                                            FriendSystem.system.sendRequestToUser(id!)

                        }
                                return cell!
                            case 1:
                                let cell = tableView.dequeueReusableCell(withIdentifier: ""friendsCell"", for: indexPath) as? friendsCell
 cell!.buttons.isEnabled = true
                                            cell!.buttons.setTitle(""Remove"", for: UIControl.State())

                                         //   print(""Friend Count: \(item.count)"");



                                                print("" INDEXING ROW FOR FRIENDS: \(indexPath.row)"")
                                            let userProfileImageURLFirebaseReturn = item.userImageURL ?? """"

                                            let userNameTagFirebaseReturn = item.nametag ?? """"
                                            let userNameFirebaseReturn = item.username ?? """"


                                            let imageURL = userProfileImageURLFirebaseReturn

                                         //   self.urlContentArray.append(imageURL)


                                            if imageURL != """" {
                                                let resource = ImageResource(downloadURL: URL(string: imageURL)!, cacheKey: userProfileImageURLFirebaseReturn)

                                                cell?.userProfileImage.kf.setImage(with: resource)


                                            } else {


                                                cell?.userProfileImage.image = UIImage(named: ""heartfilled"")
                                            }

                                 cell?.usernameLbl.text = userNameFirebaseReturn

                                cell?.userNameTagLbl.text = userNameTagFirebaseReturn;
                                 cell!.setFunction {
                                                cell!.buttons.isEnabled = true
                                                let id = item.userUID
                                               // FriendSystem.system.friendList.remove(at: indexPath.row)

                                                FriendSystem.system.removeFriend(id!)

                }
                                return cell!
                            case 0:
                                let cell = tableView.dequeueReusableCell(withIdentifier: ""requestCell"", for: indexPath) as? requestCell
                                    cell!.button.isEnabled = true
                                           // cell!.button.setTitle(""Accept"", for: UIControl.State())


                                            let userProfileImageURLFirebaseReturn = item.userImageURL

                                            let userNameTagFirebaseReturn = item.nametag
                                            let userNameFirebaseReturn = item.username

                                            let imageURL = userProfileImageURLFirebaseReturn

                                           // self.urlContentArray.append(imageURL)



                                             //   guard imageURL != nil &amp;&amp; imageURL != """" else {return}


                                                if imageURL != nil &amp;&amp; userProfileImageURLFirebaseReturn != nil &amp;&amp; userProfileImageURLFirebaseReturn != """" &amp;&amp; imageURL != """" {
                                             let resource = ImageResource(downloadURL: URL(string: imageURL!)!, cacheKey: userProfileImageURLFirebaseReturn)


                                                    cell?.userProfileImage.kf.setImage(with: resource)
                                                    cell?.usernameLbl.text = userNameFirebaseReturn
                                                    cell?.userNameTagLbl.text = userNameTagFirebaseReturn

                                                };
                                           // cell?.userProfileImage.kf.setImage(with: resource)
                                            cell?.usernameLbl.text = userNameFirebaseReturn
                                            cell?.userNameTagLbl.text = userNameTagFirebaseReturn

                                            //cell?.button.backgroundColor = #colorLiteral(red: 1, green: 0.3354814752, blue: 0.289293822, alpha: 1)


                                            cell!.setFunction {

                                                cell!.button.isEnabled = true


                                                let id = item.userUID
                                                    FriendSystem.system.acceptFriendRequest(id!)
                                            }
                                return cell!
                            default:
                                return UITableViewCell();

                }},
            titleForHeaderInSection: { dataSource, index in
                return dataSource.sectionModels[index].header
        });

        dataSource.animationConfiguration = AnimationConfiguration(insertAnimation: .fade, reloadAnimation: .fade, deleteAnimation: .fade);
</code></pre>

<p>******* THIS IS HOW THE ARRAY IS BEING UPDATED AND BEING PULLED IN WITH A FIREBASE OBSERVER IN THE VIEWDIDLOAD *******</p>

<p>var requestList = user</p>

<pre><code>var requestListUser = [String]()
/** Adds a friend request observer. The completion function will run every time this list changes, allowing you
 to update your UI. */
func addRequestObserver(_ update: @escaping () -&gt; Void) {




    let ref =  USER_REF.child((Auth.auth().currentUser?.uid)!).child(""requests"");

    ref.keepSynced(true);

    ref.observe(DataEventType.value, with: { (snapshot) in

        guard (Auth.auth().currentUser?.uid) != nil else { return }
        self.requestList.removeAll()
        self.requestListUser.removeAll()
        for child in snapshot.children.allObjects as! [DataSnapshot] {

            let id = child.key

            FriendSystem.system.getCurrentUser({ (userDataReturned) in

                if userDataReturned.email != nil &amp;&amp; userDataReturned.userImageURL != nil &amp;&amp;
                    userDataReturned.nametag != nil &amp;&amp;
                    userDataReturned.username != nil &amp;&amp;
                    userDataReturned.userUID != nil {

                    self.requestListUser.append(id);
                    self.getUser(id, completion: { (user) in
                        self.requestList.append(user)
                        update()
                    });

                } else {
                    print(""User request account had an account not completely populated"")
                }

            })
            // self.requestListUser.append(id)
            //                self.getUser(id, completion: { (user) in
            //                    self.requestList.append(user)
            //                    update()
            //                })
        }
        // If there are no children, run completion here instead
        if snapshot.childrenCount == 0 {
            update()
        }
    })
}
</code></pre>

<p>**** IN VIEWDIDLOAD. ****</p>

<p>//THIS adds an observer and fills the userList array
FriendSystem.system.addUserObserver { </p>

<p>}</p>
","10616510","","10616510","","2019-07-14 23:51:02","2019-07-14 23:51:02","How can I update my datasource and animate the changes with RxSwift in my tableview?","<uitableview><reload><rx-swift>","0","2","1","","","CC BY-SA 4.0"
"57026449","1","","","2019-07-14 10:15:26","","3","473","<p>I have an issue with observing the contentOffset property of UITableView with RxCocoa. </p>

<p>I've tried RxCocoa property:</p>

<pre><code>view.tableView.rx.contentOffset
                .mapAt(\.y)
                .subscribe(onNext: { print($0) })
</code></pre>

<p>And in console I see <strong>(0, 0)</strong> once and nothing else.</p>

<p>I've tried to replace it with code from RxCocoa:</p>

<pre><code>ControlProperty(
                values: BehaviorSubject&lt;CGPoint&gt;(value: RxScrollViewDelegateProxy.proxy(for: view.tableView).scrollView?.contentOffset ?? CGPoint.zero),
                valueSink: Binder(view.tableView) { scrollView, contentOffset in
                        scrollView.contentOffset = contentOffset
                    }
                )
                .subscribe(onNext: { print(""myOffset"", $0) })
</code></pre>

<p>And got the same result: <strong>myOffset (0, 0)</strong> once and nothing else.</p>

<p>I've tried to observe other property and haven't got anything:</p>

<pre><code>view.tableView.rx.didScroll
                .subscribe(onNext: { print(view.tableView.contentOffset) })
</code></pre>

<p>BUT. I've tried to add Observable interval:</p>

<pre><code>Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)
                .subscribe(onNext: { _ in print(view.tableView.contentOffset) })
</code></pre>

<p>And each second I've got different points: <strong>(0, 0), (0, 38), (0, 64)</strong>.</p>

<p>I'm using:
RxCocoa (5.0.0);
RxSwift (5.0.0)</p>
","8880649","","","","","2019-07-14 12:00:06","UITableView with RxCocoa is not observing correctly to contentOffset property","<ios><swift><uitableview><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"57058894","1","57059032","","2019-07-16 13:52:26","","0","239","<p>I have a reactive method who should return <code>((Void) throws -&gt; Void)?</code> to be used into <code>.on(onNext: myUIComponent.rx.function)</code> but no matters what I do I never get what is expected.</p>

<p>I was tries</p>

<p><code>func name() throws -&gt; Void?</code></p>

<p><code>func name(xpto: ((Void) throws -&gt; Void?) = nil)</code></p>

<p>Someone have some idea?</p>
","657509","","","","","2019-07-16 14:00:12","Cannot convert value of type '(() throws -> Void?) -> ()' to expected argument type '((Void) throws -> Void)?'","<swift><rx-swift><throws>","2","0","1","","","CC BY-SA 4.0"
"57080262","1","","","2019-07-17 16:14:14","","0","1368","<p>I need to take the string contents of an observable and use them elsewhere in the code </p>

<p>Converting the observable to String </p>

<pre><code>let email = userEmail.map{userEmail return userEmail}
</code></pre>

<p>Cannot convert value of type 'Observable' to expected argument type 'String'</p>
","9398617","","405865","","2019-07-17 20:15:40","2019-07-17 20:15:40","Converting an Observable<String> to String","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"57081454","1","57126112","","2019-07-17 17:36:21","","1","472","<p>I have a table that is being populated from a <code>shiftCells</code> array in my view model.  There are ~8 different types of cells that are rendered, and I need to perform a different action for each of them depending on which cell is clicked.  I'm trying to figure out the best way to handle this in the view model, so that the view controller only cares about the end result (so it can navigate to a new view controller, etc...), but I'm struggling to figure out a way to organize it properly.  Here's what my current tableview click binding looks like in the VC:</p>

<pre class=""lang-swift prettyprint-override""><code>    shiftsTableViewController
                .cellSelection
                .subscribe(onNext: { [weak self] (cellType: ShiftSelectionsTableViewCellType) in
                    guard let sSelf = self else { return }
                    switch cellType {
                      case .cellTypeA(let viewModel):
                          self.performSomeAction(viewModel: viewModel)
                      ...etc...
                    }
                }).disposed(by: disposeBag)
</code></pre>

<p>Based on the type of cell, I perform a custom action (it might be a network request, to which the result would go into a new VC that is navigated to, or it may be something else).  Here's what <code>performSomeAction</code> could look like:</p>

<pre class=""lang-swift prettyprint-override""><code>    func performSomeAction(viewModel: ShiftTypeCellViewModel) {
            self.networkService
                .perform(
                    shiftId: viewModel.shiftId, // notice i need data from cell vm
                    pin: self.viewModel.pin, // i also need data from root vm
                    photoURL: self.viewModel.imageURL)
                .subscribe(onNext: { result in
                    self.navigateToPage(result: result)
                }, onError: { error in
                    // show error banner
                }).disposed(by: disposeBag)
        }
</code></pre>

<p>So with ~8 different types of cells, I have 8 methods that all do something a little bit differently.  Should I move these methods into the VM?  Should I move this methods into the cells VM and handle the click event directly in the cell view?  Advice / an example would be appreciated.</p>
","5380266","","10326296","","2019-07-17 22:11:04","2019-07-20 15:28:17","Making table cell click events align more with ""MVVM""","<ios><swift><uitableview><rx-swift>","2","0","","","","CC BY-SA 4.0"
"57084311","1","57103024","","2019-07-17 21:32:20","","0","64","<p>As it will become quickly apparent, I have never seriously written a webserver before</p>

<p>Here is the current scenario:</p>

<ol>
<li>Clients make requests to webserver, asking to save some data  </li>
<li>Server looks at payload, and makes 2 checks<br>
a. Is this client banned from saving data?<br>
b. Does the payload of this data pass a language filter?  </li>
<li>Server responds with success, or one of those 2 errors</li>
</ol>

<p>My endpoint is written with Express in TypeScript</p>

<pre><code>class ChatRequest {
  public uid: string;
  public message: string;
}


export const register = (app: express.Application, deps: dependencies.IDependencies) =&gt; {
  app.post(""/sendChat"", (req: express.Request, res: express.Response) =&gt; {
    transformAndValidate(ChatRequest, req.body)
      .then((sendGlobalChatRequest: SendGlobalChatRequest) =&gt; {
        const payload = {
          message: sendGlobalChatRequest.message,
          uid: sendGlobalChatRequest.uid
        };

        //Check if uid is banned here

        //Check if payload passes language filter here

        //Save Payload here

        res.sendStatus(200);
      }, (err) =&gt; {
        deps.logger.error(err);
        res.sendStatus(503);
      });
  });
</code></pre>

<p>I have been using this article for reference: 
<a href=""https://hackernoon.com/the-request-sent-bad-data-whats-the-response-94088bd290a"" rel=""nofollow noreferrer"">https://hackernoon.com/the-request-sent-bad-data-whats-the-response-94088bd290a</a></p>

<p>But I think my conclusion is that they are discussing something slightly different.</p>

<p>So from my understanding, I can just make up HTTP codes...
so I could just do <code>res.sendStatus(499);</code> if the uid is banned, and maybe <code>res.sendStatus(498);</code> if the payload doesn't pass language filter</p>

<p>Then my client can just read the <code>Int</code> <code>statusCode</code> and quickly determine the failure.</p>

<p>But even though I think I can do that, and it would work, it doesn't seem right?</p>

<p>Should I instead be using a standard HTTP Response Code? <a href=""https://developer.mozilla.org/en-US/docs/Web/HTTP/Status"" rel=""nofollow noreferrer"">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</a></p>

<p>And then add in the body of the response, a <code>String</code> or something that my client can parse to determine the error?</p>

<p>The String parsing seems way harder to maintain, but technically seems more ""legal"" if that makes sense?</p>

<p>What is the best way for me to have a client determine the type of server-side error?</p>
","2415178","","2415178","","2019-07-18 21:48:48","2019-07-18 21:48:48","Need my server to return a response that includes a data error. Need client to see what was wrong with data in request","<express><webserver><httpresponse><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"57087544","1","57087595","","2019-07-18 05:14:42","","3","113","<p>In the first example, my terminal outputs</p>

<pre><code>next(1)
next(2)
next(3)
next(4)
next(5)
next(6)
next(7)
next(8)
next(9)
next(10)
completed
</code></pre>

<p>In the second example it will output</p>

<pre><code>next(3)
next(6)
next(8)
next(9)
completed
</code></pre>

<p>I know the values are different in each, but I would expect the first example to have had filtering applied so it follows the logic within my <code>.skipWhile { $0 % 2 == 0 }</code> block</p>

<pre><code>func skipWhile() {
    let bag = DisposeBag()

    Observable
        .from(Array(1...10))
        .skipWhile { $0 % 2 == 0 }
        .subscribe { print($0) }
        .disposed(by: bag)

    Observable
        .from([2,3,6,8,9])
        .skipWhile { $0 % 2 == 0 }
        .subscribe { print($0) }
        .disposed(by: bag)

}
skipWhile()
</code></pre>
","10823240","","2260675","","2019-07-18 05:18:14","2021-07-26 19:58:56","Why does skipWhile behave differently in these examples?","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57091787","1","57115386","","2019-07-18 09:53:21","","0","208","<p>I have just simply added the RxSwift and RxCocoa pods to my project. When I try to run , it ends up with segmentation fault 11</p>

<p>I tried to delete the project and recreate it, it is still happening.</p>

<p>This is the error block</p>

<pre><code>RxSwift/RxSwift/ViewController.swift:10:8: warning: file 'ViewController.swift' is part of module 'RxSwift'; ignoring import
import RxSwift
       ^
&lt;unknown&gt;:0: error: circular dependency between modules 'RxSwift' and 'RxRelay'
Stack dump:
0.  Program arguments: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file /Users/myMAC/Documents/Debanjan_iOS/RxSwift/RxSwift/ViewController.swift /Users/myMAC/Documents/Debanjan_iOS/RxSwift/RxSwift/AppDelegate.swift -emit-module-path /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/Objects-normal/x86_64/ViewController~partial.swiftmodule -emit-module-doc-path /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/Objects-normal/x86_64/ViewController~partial.swiftdoc -serialize-diagnostics-path /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/Objects-normal/x86_64/ViewController.dia -emit-dependencies-path /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/Objects-normal/x86_64/ViewController.d -emit-reference-dependencies-path /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/Objects-normal/x86_64/ViewController.swiftdeps -target x86_64-apple-ios12.0-simulator -enable-objc-interop -sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator12.2.sdk -I /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Products/Debug-iphonesimulator -F /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Products/Debug-iphonesimulator -F /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Products/Debug-iphonesimulator/RxCocoa -F /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Products/Debug-iphonesimulator/RxRelay -F /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Products/Debug-iphonesimulator/RxSwift -enable-testing -g -module-cache-path /Users/myMAC/Library/Developer/Xcode/DerivedData/ModuleCache.noindex -swift-version 5 -enforce-exclusivity=checked -Onone -D DEBUG -D COCOAPODS -serialize-debugging-options -Xcc -working-directory -Xcc /Users/myMAC/Documents/Debanjan_iOS/RxSwift -enable-anonymous-context-mangled-names -Xcc -I/Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/swift-overrides.hmap -Xcc -iquote -Xcc /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/RxSwift-generated-files.hmap -Xcc -I/Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/RxSwift-own-target-headers.hmap -Xcc -I/Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/RxSwift-all-non-framework-target-headers.hmap -Xcc -ivfsoverlay -Xcc /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/all-product-headers.yaml -Xcc -iquote -Xcc /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/RxSwift-project-headers.hmap -Xcc -I/Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Products/Debug-iphonesimulator/include -Xcc -I/Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Products/Debug-iphonesimulator/RxCocoa/RxCocoa.framework/Headers -Xcc -I/Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Products/Debug-iphonesimulator/RxRelay/RxRelay.framework/Headers -Xcc -I/Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Products/Debug-iphonesimulator/RxSwift/RxSwift.framework/Headers -Xcc -I/Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/DerivedSources-normal/x86_64 -Xcc -I/Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/DerivedSources/x86_64 -Xcc -I/Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/DerivedSources -Xcc -DDEBUG=1 -Xcc -DCOCOAPODS=1 -module-name RxSwift -o /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Build/Intermediates.noindex/RxSwift.build/Debug-iphonesimulator/RxSwift.build/Objects-normal/x86_64/ViewController.o -index-store-path /Users/myMAC/Library/Developer/Xcode/DerivedData/RxSwift-gjewryzxztmluifpnkaqwnrbconi/Index/DataStore -index-system-modules 
0  swift                    0x000000010cbf4ee3 PrintStackTraceSignalHandler(void*) + 51
1  swift                    0x000000010cbf46bc SignalHandler(int) + 348
2  libsystem_platform.dylib 0x00007fff5ad89b5d _sigtramp + 29
3  libsystem_platform.dylib 0x00000001108c9384 _sigtramp + 3048470596
4  swift                    0x0000000109e21f85 swift::SerializedModuleLoaderBase::loadModule(swift::SourceLoc, llvm::ArrayRef&lt;std::__1::pair&lt;swift::Identifier, swift::SourceLoc&gt; &gt;) + 629
5  swift                    0x0000000109f82de5 swift::ASTContext::getModule(llvm::ArrayRef&lt;std::__1::pair&lt;swift::Identifier, swift::SourceLoc&gt; &gt;) + 245
6  swift                    0x0000000109c655ff swift::performNameBinding(swift::SourceFile&amp;, unsigned int) + 1695
7  swift                    0x000000010954ec1a swift::CompilerInstance::performSemaUpTo(swift::SourceFile::ASTStage_t) + 3562
8  swift                    0x0000000108a4d2f6 performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*, swift::UnifiedStatsReporter*) + 838
9  swift                    0x0000000108a496de swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 6862
10 swift                    0x00000001089e77be main + 1246
11 libdyld.dylib            0x00007fff5aba43d5 start + 1
12 libdyld.dylib            0x000000000000005c start + 2772810888
error: Segmentation fault: 11
</code></pre>

<p>This is my sample project code</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class ViewController: UIViewController {
    @IBOutlet weak var resetBtn: UIButton!
    @IBOutlet weak var validateBtn: UIButton!
    @IBOutlet weak var secondErrorLabel: UILabel!
    @IBOutlet weak var firstErrorLabel: UILabel!
    @IBOutlet weak var secTxtField: UITextField!
    @IBOutlet weak var firstTxtField: UITextField!


    override func viewDidLoad() {
        super.viewDidLoad()

        setUpObservables()
        // Do any additional setup after loading the view.
    }

    func setUpObservables() {

    }

}
</code></pre>

<p>This is the podfile of the project</p>

<pre><code>target 'RxSwift' do
  # Comment the next line if you're not using Swift and don't want to use dynamic frameworks
  use_frameworks!

  # Pods for RxSwift
  pod 'RxSwift', '~&gt; 5.0.0'
  pod 'RxCocoa', '~&gt; 5.0.0'

end
</code></pre>
","2693698","","2693698","","2019-07-19 09:25:27","2019-07-19 15:18:11","Segmentation Fault when running the project","<xcode><rx-swift>","1","2","","","","CC BY-SA 4.0"
"57162195","1","57163182","","2019-07-23 10:36:53","","1","70","<p>I have two objects Chat and messages both in Realm database. I am fetching from db and getting two observables. Message object have chatId through which I can get chat object. 
chats() - gives Observable&lt;[Chat>
messages() - gives Observable&lt;[Messages></p>

<p>The problem is when I use map function on messages(), I get chatId, now I need chat array to filter the chatId and get chat object.</p>

<p>How can I do that? Can I combine both observables and get emitted both array in single closure. If yes, then how?</p>
","2644723","","","","","2019-07-23 11:28:54","RxSwift Combining heterogeneous observables","<rx-swift><combinelatest>","1","0","","","","CC BY-SA 4.0"
"57171378","1","","","2019-07-23 20:00:23","","2","274","<p>I am in need of a debounce functionality in RxSwift which if certain time expires emits the even regardless of debounce condition.</p>

<p>e.g.
SETUP: debounce = 0.2 secs &amp; periodic = 5 secs.</p>

<p>Case 1 (Needed) > If a user continuously pressing a button, i would like to receive an even if he doesn't stops continuous taps but only after a certain interval. This will give throttle like behaviour with periodic limit.</p>

<p>Case 2 (Works) > If user presses button every 0.5 sec, debounce limit won't be an issue and user will get his events every 0.5 secs.</p>

<p>Case 3 (Works) > User doesn't press anything, no event fired.</p>

<p>While debounce provides Case 2 &amp; 3. Achieving case 1 is tricky.</p>

<hr>

<p>Posting some clarification > My use case is not special panic button clicks. I know that throttle should be enough for it. Use case is more of a continuous stream of data. If data comes continuously in debounce limit (say 200ms), i want to have a throttle behaviour giving response say every 2 seconds but if data is not coming very frequently say every 0.5 secs, i want data to be sent immediately by observable for UI to be more responsive.</p>
","659972","","659972","","2019-07-24 19:03:05","2019-07-24 19:03:05","RxSwift limited Debounce to fire periodic events using additional time flag","<swift><rx-swift><throttling><debounce>","1","0","","","","CC BY-SA 4.0"
"57189755","1","57197239","","2019-07-24 19:11:09","","3","1141","<p>I'd like to subscribe to a BehaviorRelay&lt;[object]>, and I'd like to execute some functions whenever we append or remove elements.</p>

<p>I've used the distinctUntilChange method</p>

<pre><code>BehaviorRelay&lt;[object]&gt;.asObservable().distinctUntilChanged{ $0.count != $1.count}.subscribe{....}
</code></pre>

<p>But didn't work. What should I try?  Should I try using other Subjects or Relays to achieve this purpose?</p>

<pre><code>var objects = BehaviorRelay&lt;[Object]&gt;(value: [])
let disposeBag = DisposeBag()

objects.asObservable()
.subscribe(onNext: { (objects) in
//Do something only when appending or removing elements.
}).disposed(by: disposeBag)

//For example
let tempObj = objects.value

tempObj.append(newObj)
objects.accept(tempObj)//this will be called

tempObj.removeAll()
objects.accept(tempObj)//this will be called

tempObj.property = ""Change Property""
objects.accept(tempObj)//this will NOT be called
</code></pre>
","11832315","","1292099","","2019-07-25 08:12:48","2019-07-25 08:12:48","In RxCocoa/RxSwift, how to observe BehaviorRelay<[object]> array size changed","<ios><swift><xcode><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"57215695","1","57231570","","2019-07-26 08:04:23","","1","258","<p>I am inheriting <code>SLComposeServiceViewController</code>. It has a <code>contentText</code> String that contains the text entered in one of its views. I want to write an extension like <code>extension Reactive where Base: SLComposeServiceViewController</code> to be able to observe any changes in the value of this variable.</p>

<p>I can't find proper syntax examples for achieving this</p>

<p>I tried something like </p>

<pre><code>extension Reactive where Base: SLComposeServiceViewController {
  public func controlProperty&lt;T&gt;(
    editingEvents: ControlProperty&lt;String&gt; ,
    getter: @escaping (Base) -&gt; T,
    setter: @escaping (Base, T) -&gt; Void
  ) -&gt; ControlProperty&lt;T&gt; {

  }
}
</code></pre>
","8018988","","","","","2019-07-27 11:15:18","How to write a Reactive extension to observe the change in a string property or parent class, provided by iOS","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"57217425","1","57218932","","2019-07-26 09:48:02","","0","192","<p>I have two streams of Observable, one with tuple of element <code>Observable&lt;(E1, E2)&gt;</code> and one with single element <code>Observable&lt;E3&gt;</code>. How do I combine these two streams of observable into <code>Observable&lt;(E1, E2, E3)&gt;</code>?</p>
","11315473","","","","","2019-07-26 11:15:17","How do I combine observable of tuple elements with observable of single element?","<ios><swift><observable><rx-swift>","1","1","","","","CC BY-SA 4.0"
"57240367","1","57240701","","2019-07-28 11:22:36","","1","878","<p>I created custom collectionViewCell to binding data from an obsersable to custom CollectionViewCell. I successfully bind data to a custom TableViewCell but I can't show the contents of data to custom collection view cell. Is there a problem with Rx binding with custom collection view data source?</p>

<p>It's my custom collection view cell:</p>

<pre class=""lang-swift prettyprint-override""><code>class MovieItemCollectionViewCell: UICollectionViewCell {
    @IBOutlet weak var titleLabel: UILabel!

    override func awakeFromNib() {
        super.awakeFromNib()
    }

    func bind(_ viewModel: MovieItemViewModel) {
        debugPrint(""bind"")
        titleLabel.text = viewModel.title
    }
}
</code></pre>

<p>Here's how I binding: (The following code worked completely for a tableViewCell but it does not work for collectionViewCell. By the way, the debugger do not enter to bind methods in collectionViewCell)</p>

<pre class=""lang-swift prettyprint-override""><code>output.movies.drive(
    topRatedMoviesCollectionView
    .rx.items(cellIdentifier: MovieItemCollectionViewCell.reuseID,
                    cellType: MovieItemCollectionViewCell.self)) {_, viewModel, cell in
                        cell.bind(viewModel)
}.disposed(by: disposeBag)
</code></pre>

<p><a href=""https://i.stack.imgur.com/ifEL6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ifEL6.png"" alt=""enter image description here""></a></p>
","3594181","","","","","2019-07-28 12:01:33","RxSwift do not bind data to custom collection view cell","<uicollectionview><uicollectionviewcell><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"57267925","1","57270890","","2019-07-30 08:58:43","","1","21","<p>I have an Entity called 'CartItem' (<code>NSManagedObject</code> class) in my coredata datamodelid. Wanted to change Variable to BehaviorRelay in RxSwift, but I get a compile time error stating ""<code>[Any] is not convertible to CartItem</code>"". How do I change Variable to BehaviorRelay?</p>

<pre><code>var cartItemsArray = BehaviorRelay&lt;CartItem&gt;(value: []) //get error here

//var cartItemsArray: Variable&lt;[CartItem]&gt; = Variable([])
</code></pre>
","2033377","","","","","2019-07-30 11:45:04","How to typecast NSManagedObject class to Any to create a BehaviorRelay object in RxSwift?","<rx-swift><behaviorrelay>","1","0","","","","CC BY-SA 4.0"
"57273190","1","57295079","","2019-07-30 13:43:03","","1","157","<p>(I'm quite new to Reactive programming here, and I'm aware I'm not quite thinking in the ""Reactive"" way yet so I'm not sure I'm quite doing this right...)</p>

<p>I have a dataset that comes from a REST API to drive a UICollectionView of <code>Photo</code>s, with filtering of the collection done with switches in the UI. My current binding graph looks like</p>

<pre><code>[API DataSet] -&gt; unfilteredData: BehaviorRelay&lt;Photo&gt; -map-&gt; collectionView.items
</code></pre>

<p>and in my last <code>map</code> stage I'm reading the state of the UI directly (<code>switch.isOn</code>) to apply filtering. </p>

<p>But then I want to drive the filtration with my <code>switch.rx.isOn</code> observable too. I'm doing this by getting <code>unfilteredData</code> to accept its own current value, and thereby re-drive the whole filtering mechanism and redisplay the collection view.</p>

<p>So there are 2 things I'm not super happy with here, as I feel like I'm still stuck in an imperative programming mindset.</p>

<ol>
<li>I'm reading the state of the UI instead of purely reacting to that state's changes</li>
<li>I'm getting a BehaviorRelay to accept its own value in order to trigger its chain of events.</li>
</ol>

<p>But since I don't want to reload the data set from the API each time the UI state changes (server calls are expensive) I feel like maybe I can't be purely reactive here?</p>

<p>Here's my simplified code to illustrate (with problem 1 and 2 noted).</p>

<pre><code>private let unfilteredDataSource = BehaviorRelay&lt;[Photo]&gt;(value: [])

/// Refresh data from API
private func refreshData() {
    let photoResponse: Observable&lt;[Photo]&gt; = APICall(method: .GET, path: ""photos.json"")
    photoResponse
        .bind(to: unfilteredDataSource)
        .disposed(by: disposeBag)
}

/// Setup reactive bindings (on viewDidLoad)
private func setupRx() {
    // unfiltered becomes filtered via map before it's sent to collection items
    unfilteredDataSource
        .observeOn(MainScheduler.asyncInstance)
        .map {
            // filtering by hasLocation if includeAllSwitch is off
            $0.filter{ $0.hasLocation() || self.includeAllSwitch.isOn } //1
        }
        .bind(to: photoCollection.rx.items(cellIdentifier: ""MyCell"", cellType: PhotoCell.self)) { (row, element, cell) in
            // here I set up the cell...
        }
        .disposed(by: disposeBag)

    // filteringSwitch.isOn changes need to drive filtering too
    filteringSwitch.rx
        .isOn
        .asDriver(onErrorJustReturn: true) // Driver ensures main thread, and no errors (always returns true here)
        .drive(onNext: { [unowned self] switchValue in
            // triggering events using A = A; seems clumsy? And switchValue unused.
            self.unfilteredDataSource.accept(self.unfilteredDataSource.value) //2
        })
        .disposed(by: disposeBag)
}
</code></pre>

<p>What's the most ""reactive"" way of approaching a problem like this?</p>

<p><strong>EDIT</strong>
As I mention in the comment below ""There's just one switch. There's the input JSON data from the server that goes to a collection view, and one switch which changes which photos are shown (toggle between showing all photos, or only a subset of photos that has a location attached in this instance)""</p>
","1602875","","1602875","","2019-08-06 09:49:34","2019-08-06 09:49:34","Filtering reactive dataset in RxSwift/RxCocoa with UI controls","<reactive-programming><rx-swift>","1","2","1","","","CC BY-SA 4.0"
"57280287","1","57317714","","2019-07-30 21:30:52","","1","1587","<p>I'm wrapping some legacy completion-block code in an Observable. It will emit one event (next or error), and then complete. The problem is that calling <code>onNext(), onCompleted()</code> only sends the completed event to the observer. Why doesn't the <code>next</code> event get delivered?</p>

<p>UPDATE: The people stream actually works as expected. The issue turns out to be in the next stream, filteredPeople. The inner completed event is passed along to it, and I'm just returning it, which terminates the stream.</p>

<p>I need to filter out <code>completed</code> events from inner streams.</p>

<pre><code>let people = Observable&lt;Event&lt;[Person]&gt;&gt;()
    .flatMapLatest {
        return fetchPeople().asObservable().materialize()
    }
    .share()

// this is bound to a search field
let filterText = PublishSubject&lt;String&gt;()

let filteredPeople = Observable.combineLatest(people, filterText) { peopleEvent, filter in

    // this is the problem. the completed event from people is being returned, and it terminates the stream
    guard let people = peopleEvent.element else { return peopleEvent }

    if filterText.isEmpty { return .next(people) }

    return .next(people.filter { ... })
}

func fetchPeople() -&gt; Single&lt;[Person]&gt; {
    return Single&lt;[Person]&gt;.create { observer in
        PeopleService.fetch { result in
            switch result {
            case .success(let people):
                observer(.success(people))
            case .failure(let error):
                observer(.error(error))
            }
        }

        return Disposables.create()
    }
}

filteredPeople.subscribe(
    onNext: { event in
        // ?! doesn't get called
    },
    onCompleted: {
        //  we get here, but why?
    },
    onError: {event in
        ...
    }).disposed(by: disposeBag)
</code></pre>
","62178","","62178","","2019-07-31 20:27:54","2019-08-01 22:26:28","RxSwift: Calling onCompleted after onNext delivers only the completed event","<rx-swift>","2","2","","","","CC BY-SA 4.0"
"57286750","1","","","2019-07-31 08:49:24","","1","918","<p>I'm starting out with RxSwift and trying to get a simple example of filtering a data source with a UISearchController working.</p>

<p>I have the basic setup of a UISearchController wired into a UITableViewController. Using MVVM I also have a basic view model setup that will drive the table.</p>

<pre><code>self.viewModel.searchText.accept(searchController.searchBar.text ?? """")
</code></pre>

<pre><code>viewModel.listItems.bind(to: tableView.rx.items(cellIdentifier: ""ItemCell"")) { row, item, cell in
    cell.textLabel!.text = item.name
}
.disposed(by: disposeBag)
</code></pre>

<p>View Model</p>

<pre><code>class ListViewModel {

    private let sourceItems: BehaviorRelay&lt;[ListItem]&gt; = BehaviorRelay(value: [
            ListItem(name: ""abc""),
            ListItem(name: ""def""),
            ListItem(name: ""ghi""),
            ListItem(name: ""jkl""),
            ListItem(name: ""mno"")
        ])

    let searchText = BehaviorRelay&lt;String&gt;(value: """")
    var listItems: Observable&lt;[ListItem]&gt; = Observable.just([])

    init() {
        listItems = sourceItems.asObservable()
    }

}
</code></pre>

<p>I can add in the search filtering and this works such that only the values matching the filter string will show</p>

<pre><code>let searchObservable = searchText
    .throttle(.milliseconds(300), scheduler: MainScheduler.instance)
    .distinctUntilChanged()
    .filter { query in
        return query.count &gt; 2
    }
    .share(replay: 1)

listItems = Observable.combineLatest(sourceItems.asObservable(), searchObservable) { items, query in
        return items.filter({ item in
            item.name.lowercased().contains(query.lowercased())
        })
    }
</code></pre>

<p>However, this will not show any values until the filter is matched. What I am trying to do is initially show all the values and then only show the filtered values.  I'm not quite sure how to populate the <code>listItems</code> when the <code>searchText</code> changes but is empty or events are filtered out.</p>
","357734","","357734","","2019-07-31 10:24:06","2019-07-31 22:11:55","Viewing initial data source and filtering with RxSwift using MVVM","<swift><mvvm><rx-swift>","3","2","","","","CC BY-SA 4.0"
"57297515","1","57298695","","2019-07-31 19:14:12","","0","135","<p>I am learning <code>RxSwift</code>. </p>

<p>I have setup a view model that responds to bindings in my <code>ViewController</code>.</p>

<p><code>isValid</code> checks both a username and password exist and then enables my login button.</p>

<p><code>didTapLoginSubject</code> fires on login press, using the latest value from <code>credentialsObservable</code> will call a service.</p>

<p>This all works as I'd like, however I feel something is not quite optimised around how <code>isValid</code> and <code>credentialsObservable</code> work.</p>

<p>I see repeated code and sense this can be better written, but I am not sure how yet.</p>

<p>I thought perhaps something like this:</p>

<pre class=""lang-swift prettyprint-override""><code>    private(set) lazy var isValid: Observable&lt;Bool&gt; = {
        return Observable.withLatestFrom(self.credentialsObservable).map { $0.count &gt; 0 &amp;&amp; $1.count &gt; 0 }
    }()

</code></pre>

<p>But this obviously did not work.</p>

<pre class=""lang-swift prettyprint-override""><code>
import Foundation
import RxSwift
import RxCocoa

class LoginViewModel: NSObject {
    private(set) lazy var username = PublishSubject&lt;String&gt;()
    private(set) lazy var password = PublishSubject&lt;String&gt;()
    private(set) lazy var didTapLoginSubject = PublishSubject&lt;Void&gt;()

    private(set) lazy var isValid: Observable&lt;Bool&gt; = {
        return Observable.combineLatest(self.username, self.password, resultSelector: { $0.count &gt; 0 &amp;&amp; $1.count &gt; 0 })
    }()

    private var credentialsObservable: Observable&lt;(String, String)&gt; {
        return Observable.combineLatest(self.username, self.password, resultSelector: { ($0, $1) })
    }

    private let disposeBag = DisposeBag()

    override init() {
        super.init()

        didTapLoginSubject
            .withLatestFrom(credentialsObservable)
            .subscribe(
                onNext: login,
                onError: onError
        ).disposed(by: disposeBag)
    }

    private func login(_ username: String, _ password: String) {
        print(username, password)
    }

    private func onError(_ error: Error) {
        print(error.localizedDescription)
    }
}

</code></pre>
","10823240","","","","","2019-07-31 20:53:11","How can I better combine this 2 values that consume the same Publish Subjects","<swift><rx-swift><reactive-cocoa>","1","0","","","","CC BY-SA 4.0"
"57299322","1","57300100","","2019-07-31 21:54:26","","1","1296","<p>I am trying to achieve something similar in rxswift example project from RxSwift <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample/Examples/GitHubSignup/UsingDriver/GithubSignupViewModel2.swift"" rel=""nofollow noreferrer"">repo</a>. But in my case there are dependent observables. I couldn't find any solution without using binding in viewmodel</p>

<p>Here is the structure of my viewmodel:</p>

<p>First the definitions of input, output and viewmodel</p>

<pre><code>typealias UserListViewModelInput = (
    viewAppearAction: Observable&lt;Void&gt;,
    deleteAction: Observable&lt;Int&gt;
)

typealias UserListViewModelOutput = Driver&lt;[User]&gt;

typealias UserListViewModel = (UserListViewModelInput, @escaping UserApi) -&gt; UserListViewModelOutput
</code></pre>

<p>Then there is actual implementation which doesn't compile.</p>

<pre><code>let userListViewModel: UserListViewModel = { input, loadUsers in

    let loadedUserList = input.viewAppearAction
        .flatMapLatest { loadUsers().materialize() }
        .elements()
        .asDriver(onErrorDriveWith: .never())

    let userListAfterDelete = input.deleteAction
        .withLatestFrom(userList) { index, users in
            users.enumerated().compactMap { $0.offset != index ? $0.element : nil }
        }
        .asDriver(onErrorJustReturn: [])

    let userList = Driver.merge([loadedUserList, userListAfterDelete])

    return userList
}
</code></pre>

<p>Viewmodel has two job. First load the user list. Second is delete a user at index. The final output is the user list which is downloaded with <code>UserApi</code> minus deleted users. </p>

<p>The problem in here in order the define <code>userList</code> I need to define <code>userListAfterDelete</code>. And in order to define <code>userListAfterDelete</code> I need to define <code>userList</code>.</p>

<p>So is there a way to break this cycle without using binding inside view model? Like a placeholder observable or operator that keeps state?</p>
","3068061","","","","","2019-07-31 23:45:13","rxswift viewmodel with input output","<ios><swift><mvvm><rx-swift><frp>","1","0","","","","CC BY-SA 4.0"
"57322725","1","","","2019-08-02 08:35:09","","1","863","<p>I am new to RXSwift, please help to find best solution.
I have view model with instance variable:</p>

<pre><code>var capturedImageData: Data?
</code></pre>

<p>I need to unhide UIImageView view and set image after capturedImageData receives data, for example on capture image from camera.</p>
","377760","","","","","2019-08-02 09:44:41","RXSwift bind view model data to view controller uiimageview","<ios><swift><iphone><rx-swift>","2","0","","","","CC BY-SA 4.0"
"57329407","1","57334111","","2019-08-02 15:21:45","","1","1266","<p>I am using RxSwift(<a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxSwift</a>).</p>

<p>I wrote the following code:</p>

<pre><code>let m1 = Maybe&lt;String&gt;.empty()
let m2 = Maybe&lt;String&gt;.just(""AA"")

let s1 = m1.asObservable().asSingle()
let s2 = m2.asObservable().asSingle()


Single.zip(s1, s2).subscribe(onSuccess: { a, b in
    print(""=================="")
    print(a)
    print(b)
    print(""=================="")
}, onError: { e in
    print(""EEEEE"")
    print(e) // Sequence doesn't contain any elements.
}).disposed(by: disposeBag)
</code></pre>

<p>An Error <code>""Sequence doesn't contain any elements""</code> occurred because <code>m1</code> is <code>Maybe#empty</code>.</p>

<p>How to covert <code>Maybe&lt;String&gt;</code> to <code>Single&lt;String?&gt;</code>?</p>

<p>If <code>Maybe</code> is <code>empty</code>, I'd like to make it <code>nil.</code></p>

<p>In this case, I want the <code>a</code> variable to be <code>nil</code>.</p>
","1979953","","1979953","","2020-06-01 08:46:39","2020-06-01 08:46:39","How to convert Maybe to Single without ""Sequence doesn't contain any elements""","<swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57351641","1","","","2019-08-05 02:39:50","","0","217","<p>I'm facing a problem with RxSwift schedulers.</p>

<p>Production code like below,</p>

<pre class=""lang-swift prettyprint-override""><code>class SomePresenter {

    let repository: SomeRepository
    let subscribeScheduler: ImmediateSchedulerType

    var list: [SomeEntity] = []

    let bag = DisposeBag()

    init(repository: SomeRepository,
         subscribeScheduler: ImmediateSchedulerType) {
        self.repository = repository
        self.subscribeScheduler = subscribeScheduler
    }

    func some() {
        repository
            .getSome()
            .subscribeOn(subscribeScheduler)
            .observeOn(MainScheduler.instance)
            .subscribe(onSuccess: { [weak self] list in
                guard let self = self else {
                    return
                }
                self.list = list
            }) { error in
                fatalError()
            }.disposed(by: bag)
    }
}
</code></pre>

<p>and test code for that like below.</p>

<pre class=""lang-swift prettyprint-override""><code>class researchRxTestFailedTests: XCTestCase {

    func testExample1() {
        let presenter1 = SomePresenter(repository: MockedSomeRepository(),
                                      subscribeScheduler: ConcurrentMainScheduler.instance)
        presenter1.some()
        XCTAssertEqual(presenter1.list.count, 2)
    }

    func testExample2() {
        let presenter2 = SomePresenter(repository: MockedSomeRepository(),
                                      subscribeScheduler: ConcurrentMainScheduler.instance)
        presenter2.some()
        XCTAssertEqual(presenter2.list.count, 2)
    }

    func testExample3() {
        let presenter3 = SomePresenter(repository: MockedSomeRepository(),
                                      subscribeScheduler: SerialDispatchQueueScheduler.init(qos: .default)) // Here is key!!
        presenter3.some()
        XCTAssertEqual(presenter3.list.count, 2)
    }

    func testExample4() {
        let presenter4 = SomePresenter(repository: MockedSomeRepository(),
                                      subscribeScheduler: ConcurrentMainScheduler.instance)
        presenter4.some()
        XCTAssertEqual(presenter4.list.count, 2)
    }

    func testExample5() {
        let presenter5 = SomePresenter(repository: MockedSomeRepository(),
                                      subscribeScheduler: ConcurrentMainScheduler.instance)
        presenter5.some()
        XCTAssertEqual(presenter5.list.count, 2)
    }

    class MockedSomeRepository: SomeRepository {
        func getSome() -&gt; Single&lt;[SomeEntity]&gt; {
            return Single.just(
                [
                    SomeEntity(id: 100, name: ""hoge""),
                    SomeEntity(id: 101, name: ""fuga"")
                ]
            )
        }
    }
}
</code></pre>

<p>And when I run this test code (not <code>randomize execution order</code>), I got failure like below.</p>

<p><a href=""https://i.stack.imgur.com/tjREA.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tjREA.png"" alt=""enter image description here""></a></p>

<p>So why this happens? 
I can understand <code>testExample3</code> fails, because its scheduler is background scheduler. 
But I couldn't understand why following test examples(<code>testExample4</code> and <code>testExample5</code>) fail even if those schedulers are main thread scheduler.</p>

<p><strong>NOTE</strong>: If I switch to <code>ConcurrentMainScheduler</code> in <code>testExample3</code>, all tests passes.</p>
","3487610","","","","","2019-08-05 02:39:50","RxSwift's scheduler is strange after switching","<rx-swift>","0","3","","","","CC BY-SA 4.0"
"57357853","1","","","2019-08-05 11:39:14","","0","250","<p>I have some configuration based on the type of data I receive ( the insets to add in the cell.configure(with item: item) {}, however the cells are not re-used properly. I am using RxSwift for binding, though I don't see the issue in there.</p>

<p>tried setting <code>image.layoutMargins = UIEdgeInsets.zero</code> in <code>prepareForReuse()</code>, in the <code>cell.configure(with: item)</code> etc. Doesn't seem to work.</p>

<pre><code>    brandsGroup
        .bind(to: rx.items(cellIdentifier: StudioCellConstants.brandReuseIdentifier,
                           cellType: BrandCollectionViewXibCell.self)) { (_, item, cell) in
                            cell.configure(with: item)
        }.disposed(by: disposeBag)

override func prepareForReuse() {
    super.prepareForReuse()
    image.layoutMargins = UIEdgeInsets.zero
}
</code></pre>

<p>Update:</p>

<p>Eventually I ended up setting back the frame like this, but it feels like a hacky solution.
   A better way would be much appreciated.</p>

<pre><code>                image.frame = CGRect(origin: CGPoint(x: 0, y: 0), size: CGSize(width: imageContainerView.frame.width, height: imageContainerView.frame.height)
</code></pre>
","8901722","","8901722","","2019-08-06 09:27:48","2019-08-06 09:27:48","imageView.layoutMargins = UIEdgeInsets.zero has no effect in UICollectionViewCell","<ios><swift><rx-swift><ios12>","1","12","","","","CC BY-SA 4.0"
"57361031","1","57361167","","2019-08-05 14:49:26","","0","55","<p>I am working on a project based on the following app:</p>

<p><a href=""https://github.com/mgacy/MVVMC-SplitViewController"" rel=""nofollow noreferrer"">MVVMC-SplitViewController</a></p>

<p>I am trying to write a unit test around the <code>BaseCoordinator</code> class.</p>

<p>I would like to assert that this method within the class</p>

<pre><code>private func free&lt;T: CoordinatorType&gt;(coordinator: T) {
    childCoordinators[coordinator.identifier] = nil
}
</code></pre>

<p>does in fact free the coordinator from the <code>childCoordinators</code> dictionary.</p>

<p>I am unsure how I can do this though. I thought I could simply create a mock coordinator and have the <code>start</code> method return something, but I believe I am doing this wrong</p>

<p><strong>My Test</strong></p>

<pre class=""lang-swift prettyprint-override""><code>func test_releases_coordinator_from_child_coordinator_dict() {
    class MockCoordinator: BaseCoordinator&lt;Void&gt; {
        override func start() -&gt; Observable&lt;Void&gt; {
            return .empty()
        }
    }

    let mockCoordinator = MockCoordinator()
    let sut = BaseCoordinator&lt;Void&gt;()

    sut.coordinate(to: mockCoordinator).subscribe().disposed(by: disposeBag)

    XCTAssertEqual(sut.childCoordinators.count, 0)
}

</code></pre>

<p><strong>My base coordinator</strong></p>

<pre class=""lang-swift prettyprint-override""><code>   import RxSwift

    /// Base abstract coordinator generic over the return type of the `start` method.
    class BaseCoordinator&lt;ResultType&gt;: CoordinatorType {

        /// Typealias which allows to access a ResultType of the Coordainator by `CoordinatorName.CoordinationResult`.
        typealias CoordinationResult = ResultType

        /// Utility `DisposeBag` used by the subclasses.
        let disposeBag = DisposeBag()

        /// Unique identifier.
        internal let identifier = UUID()

        /// Dictionary of the child coordinators. Every child coordinator should be added
        /// to that dictionary in order to keep it in memory.
        /// Key is an `identifier` of the child coordinator and value is the coordinator itself.
        /// Value type is `Any` because Swift doesn't allow to store generic types in the array.
        private(set) var childCoordinators = [UUID: Any]()

        /// Stores coordinator to the `childCoordinators` dictionary.
        ///
        /// - Parameter coordinator: Child coordinator to store.
        private func store&lt;T: CoordinatorType&gt;(coordinator: T) {
            childCoordinators[coordinator.identifier] = coordinator
        }

        /// Release coordinator from the `childCoordinators` dictionary.
        ///
        /// - Parameter coordinator: Coordinator to release.
        private func free&lt;T: CoordinatorType&gt;(coordinator: T) {
            childCoordinators[coordinator.identifier] = nil
        }

        /// 1. Stores coordinator in a dictionary of child coordinators.
        /// 2. Calls method `start()` on that coordinator.
        /// 3. On the `onNext:` of returning observable of method `start()` removes coordinator from the dictionary.
        ///
        /// - Parameter coordinator: Coordinator to start.
        /// - Returns: Result of `start()` method.
        func coordinate&lt;T: CoordinatorType, U&gt;(to coordinator: T) -&gt; Observable&lt;U&gt; where U == T.CoordinationResult {
            store(coordinator: coordinator)
            return coordinator.start()
                .do(onNext: { [weak self] _ in self?.free(coordinator: coordinator) })
        }

        /// Starts job of the coordinator.
        ///
        /// - Returns: Result of coordinator job.
        func start() -&gt; Observable&lt;ResultType&gt; {
            fatalError(""Start method should be implemented."")
        }
    }
</code></pre>
","10823240","","","","","2019-08-05 14:56:15","How can I return the next value of an observable in this test?","<swift><observable><xctest><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57363994","1","","","2019-08-05 18:11:13","","0","100","<p>I have isolated a value of userId and then I am trying to make a network request and trying to gain access to the email property by matching up the userId from the returned JSON and I am having a problem with that. </p>

<p>I made the network request, I have the property of userId and now from the network request I am iterating over the JSON and based on the userId I just trying to find the email. </p>

<pre><code>Let emailRecipient = Observable&lt;String&gt;
var givenUserId = ""8975949584358490""
networkRequest
.asObservable() 
.map{projectUsers in if projectUsers.filter{$0.userId == givenUserId}.first{
 //Here I want to set the emailRecipient property to .email Property of the projectUser 
}}
</code></pre>
","9398617","","","","","2019-08-07 05:00:39","Trying to get access to a property using filter in RxSwift","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"57369077","1","","","2019-08-06 04:43:58","","1","518","<p>I am trying to add remove cells from a <code>UITableView</code> depending on the value changes in a <code>UISegmentedControl</code> which is inside one of <code>UITableViewCell</code>.</p>

<p>The problem is there is a cyclic dependency and the tableView keeps reloading. I avoided this infinite reload by using <code>distinctUntilChanged</code> but still sometimes the reload is called twice.</p>

<p>My objective is to change the number of rows depending on the selection made in the segment control.</p>

<blockquote>
  <p>Code in UITableViewCell  </p>
</blockquote>

<hr>

<pre><code>extension CardTableViewCell {

    /// This function is called every time in `cellForRowAtIndexPath` for the tableView.

    func bind(viewModel: TableViewViewModel?) {
        self.viewModel = viewModel
        if let viewModel = viewModel {
            segment.rx.selectedSegmentIndex
                .asDriver()
                .flatMap { Driver.just($0 == 0)}
                .distinctUntilChanged()
                .drive(onNext: { value in

                    print(""&gt;&gt;&gt;&gt; VALUE CHANGED \(value)"")
                    viewModel.reloadTableView()}

                // Here when I reload the table view this is called again and a cyclic dependency is created

                ) &gt;&gt;&gt; disposeBag
        }
    }
}
</code></pre>

<blockquote>
  <p>The console returns this </p>
</blockquote>

<pre><code>⚠️ Reentrancy anomaly was detected.
  &gt; Debugging: To debug this issue you can set a breakpoint in /Users/harshvishwakarma/Documents/GitHub/banking-app-ios/Pods/RxSwift/RxSwift/Rx.swift:97 and observe the call stack.
  &gt; Problem: This behavior is breaking the observable sequence grammar. `next (error | completed)?`
    This behavior breaks the grammar because there is overlapping between sequence events.
    Observable sequence is trying to send an event before sending of previous event has finished.
  &gt; Interpretation: This could mean that there is some kind of unexpected cyclic dependency in your code,
    or that the system is not behaving in the expected way.
  &gt; Remedy: If this is the expected behavior this message can be suppressed by adding `.observeOn(MainScheduler.asyncInstance)`
    or by enqueing sequence events in some other way.
</code></pre>
","3600738","","","","","2019-08-07 01:19:20","Reactive<UISegmentedControl> in UITableViewCell","<ios><swift><uitableview><rx-swift>","1","2","","","","CC BY-SA 4.0"
"57370348","1","57429193","","2019-08-06 06:46:10","","1","78","<p>I have a property on my view model:</p>

<pre class=""lang-swift prettyprint-override""><code>    let isValid: Driver&lt;Bool&gt;
    let credentials: Driver&lt;(String, String)&gt;
......
        credentials = .combineLatest(bindings.username, bindings.password, resultSelector: { (username, password) -&gt; (String, String) in (username, password) })

        isValid = credentials.map { username, password in username.count &gt; 0 &amp;&amp; password.count &gt; 7 }
</code></pre>

<p>I'd like to assert that the correct state is set on <code>isValid</code> when valid inputs are set.</p>

<p>My test is passing below, however this doesn't feel like the correct way to test this scenario. </p>

<p>Ideally I'd like to start with my strings as <code>""""</code> and then pass in values as if they had been typed so I can assert the default state is set and then changes.</p>

<p>I also find these lines:</p>

<pre><code>   .do(onNext: { state in
            if state {
                exp.fulfill()
            }
        })
</code></pre>

<p>a little ""hacky"".</p>

<pre class=""lang-swift prettyprint-override""><code>   func test_is_valid_state_changes_when_inputs_correct_length() {

        let username: Driver&lt;String&gt; = .of(""some_user_name"")
        let password: Driver&lt;String&gt; = .of(""some_user_password"")

        let bindings = LoginViewModel.Bindings(username: username, password: password, loginTap: .empty(), doneTap: .empty())
        let sut = LoginViewModel(dependency: """", bindings: bindings)

        let scheduler = TestScheduler(initialClock: 0)
        let observer = scheduler.createObserver(Bool.self)

        let exp = expectation(description: ""isValid Event"")

        sut.isValid
            .asObservable()
            .do(onNext: { state in
                if state {
                    exp.fulfill()
                }
            })
            .subscribe(observer)
            .disposed(by: disposeBag)

        scheduler.start()

        waitForExpectations(timeout: 0.5) { error in
            XCTAssertNil(error)
            XCTAssertEqual(observer.events.count, 1)
            XCTAssertTrue(observer.events[0].value.element!) // swiftlint:disable:this force_unwrapping
        }
    }
</code></pre>
","11709138","","","","","2019-08-09 11:33:40","How can I assert the output of an observable that uses latest from text inputs","<swift><reactive-programming><xctest><rx-swift><rxtest>","1","3","","","","CC BY-SA 4.0"
"57390542","1","57394893","","2019-08-07 08:55:12","","2","951","<p>We would like to use a dictionary as observable to notify any subscribers upon changes. So far this is implemented as BehaviorRelay&lt;[KeyType: ValueObjectType]></p>

<p>Now we need to add/remove/change values of the dictionary inside the observable. We tried the following (in simplified terms), but it did not work:</p>

<pre class=""lang-swift prettyprint-override""><code>let list = BehaviorRelay&lt;[String: MyClassType]&gt;.init([:])
let newElem = MyClassType()
list.value.updateValue(newElem, forKey: ""anykey"")
</code></pre>

<p>The compiler complains: Cannot use mutating member on immutable value: 'value' is a get-only property</p>

<p>The following works, but I find it cumbersome and probably inefficient performance wise:</p>

<pre class=""lang-swift prettyprint-override""><code>let list = BehaviorRelay&lt;[String: MyClassType]&gt;.init([:])
let newElem = MyClassType()
let newList = list.value
newList.updateValue(newElem, forKey: ""anykey"")
list.accept(newList)
</code></pre>

<p>Typical subscribers for the list on the UI side would be e.g. a UITableView or UICollectionView.</p>

<p>Is there a better way to handle this?</p>
","6399867","","","","","2019-08-07 15:25:01","How can a mutable dictionary be made observable in RxSwift","<arrays><swift><dictionary><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57402742","1","57422886","","2019-08-07 21:53:36","","1","131","<p>I have an observable that emits a list of CNContacts, and I want to reload the list when there is a change to the Contacts database (<code>.CNContactStoreDidChange</code>).</p>

<p>So the observable should emit a value on subscription, and whenever the other observable (the notification) emits a value. That sounds like combining them with <code>withLatestFrom</code>, but it doesn't emit anything.</p>

<pre><code>let myContactKeys = [
    CNContactIdentifierKey as CNKeyDescriptor,
    CNContactFormatter.descriptorForRequiredKeys(for: .fullName)
]

func fetchContacts(by identifiers: [String],
                 contactKeys: [CNKeyDescriptor]) -&gt; Observable&lt;Event&lt;[CNContact]&gt;&gt; {

    return Observable&lt;[String]&gt;.just(identifiers)
        .withLatestFrom(NotificationCenter.default.rx.notification(Notification.Name.CNContactStoreDidChange)) { ids, _ in ids}
        .flatMap { ids in
            Observable&lt;[CNContact]&gt;.create { observer in
                let predicate = CNContact.predicateForContacts(withIdentifiers: ids)
                do {
                    let contacts = try CNContactStore().unifiedContacts(matching: predicate, keysToFetch: contactKeys)
                    observer.onNext(contacts)
                } catch {
                    observer.onError(error)
                }

                return Disposables.create()
            }
            .materialize()
        }
        .observeOn(MainScheduler.instance)
        .share(replay: 1)
        .debug()
}

fetchContacts(by: [""123""], contactKeys: myContactKeys)
    .subscribe(
        onNext: { contacts in
            contacts.forEach { print($0.fullName) }
        },
        onError: { error in
            print(error.localizedDescription)
        })
    .dispose(by: disposeBag)
</code></pre>
","62178","","62178","","2019-08-08 00:02:40","2019-08-09 02:41:57","Refresh Observable in response to another","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57418380","1","57423088","","2019-08-08 18:02:29","","1","585","<p>I need have some worker task in my observable which I want to cancel when there are no any subscriptions to my observable. But even when my observable have no subscriptions and even I got onDisposed event. The worker task in my observable continue it's execution while it must not because it depends on isDisposed property of my disposable but it is always false.</p>

<p>Here my code:</p>

<pre><code>Observable&lt;Void&gt;.create { observer -&gt; Disposable in
        let disposable = BooleanDisposable(isDisposed: false)

        Thread(block: {
            while (!disposable.isDisposed) {
                print(""Next"")
                observer.onNext(())
                sleep(1)

            }

            observer.onCompleted()
            print(""Done"")

        }).start()

        return disposable
        }.subscribe(onNext: { _ in
            print(""onNext"")
        }, onCompleted: {
            print(""onCompleted"")
        }) {
            print(""onDisposed"")
    }.disposed(by: self.disposeBag)
</code></pre>

<p>And output:</p>

<pre><code>Next
onNext
Next
onNext
Next
onNext
Next
onNext
Next
onNext
Next
onNext
Next
onNext 
onDisposed
Completed
Next
Next
Next
... and so on
</code></pre>

<p>While I am expecting something like that:</p>

<pre><code>Next
onNext
Next
onNext
Next
onNext
Next
onNext
Next
onNext 
onDisposed
Completed
Done
</code></pre>

<p>What am I doing wrong or I just don't understand Disposables and Observables properly?</p>

<p>I'am using RxSwift 4.5.0.</p>

<p>Thanks in advance.</p>
","1677835","","1677835","","2019-08-09 08:48:04","2019-08-09 08:48:04","RxSwift Disposable property isDisposed always false or Disposable closure newer called to cancel worker task","<ios><swift><iphone><cocoa-touch><rx-swift>","1","2","","","","CC BY-SA 4.0"
"57419782","1","57478651","","2019-08-08 19:58:05","","0","261","<p>I am making a network request from which I am getting a bunch of users, I am also given a emailDetails object that holds the userId property as well. I am trying to iterate over the users coming from the network request to match up all of the userIds from the emailDetails </p>

<p>I am not sure how to iterate, I know enumerated exists in RxSwift. </p>

<pre><code>self.emailRecipients = networkRequestToGetUser
            .asObservable()
            .map { users in users.filter {$0.userId == 
             emailDetails.userIds }.first }
            .map {correctUsers in return correctUsers?.email}
            .unwrap()
</code></pre>

<p>Error I'm getting: Binary operator '==' cannot be applied to operands of type 'String' and '[String]'</p>
","9398617","","","","","2019-08-13 13:31:44","Iterating over and adding to an array in RxSwift","<for-loop><iteration><rx-swift>","1","1","","","","CC BY-SA 4.0"
"57445533","1","57446118","","2019-08-10 20:38:36","","1","289","<p>On my application I have to download several files from Amazon S3, for that purpose I have created a function that download a single files and return and observable. I have also created a second function that I have called downloadAll. The purpose of this function is to download each S3 files sequentially. </p>

<p>As some of the files are big and there are a lot of files (more than 50) If I just merge all the observables I end up with a lot of timeouts from amazon because of concurrency.</p>

<p>What I have tried:</p>

<p><strong>Merge with concurrency</strong></p>

<pre><code>    let observables = self.syncItem!.files.map { (f) in
        return Observable.of(f)
    }
    let o = Observable.from(observables).merge(maxConcurrent: 2)
</code></pre>

<p><strong>Result:</strong> I get the two first files downloaded but the others are not been downloaded.</p>

<p><strong>ConcatMap</strong></p>

<pre><code>    return Observable.from(self.syncItem?.files).concatMap({ (file) in
        return self.downloadS3File(file: file)
    }) 
</code></pre>

<p><strong>Result:</strong> Only the first file been downloaded</p>

<p>**DownloadS3FileFunction is ommitted ... it is working ok for a single file download and its emit a File object upon download completion **</p>

<p>I have searched a LOT before asking the question. Can someone please help?</p>
","4379503","","","","","2019-08-10 22:30:57","RxSwift Sequence of observables from array","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57472261","1","","","2019-08-13 06:31:47","","1","589","<p>I'm trying to validate text and merge it with UITextField typing event. Here is validation sequence:</p>

<pre><code>let validation = textField.rx.text.map {ValidationService.validate($0)}
</code></pre>

<p>I tested all combining methods but without result:</p>

<pre><code>Observable.zip(textField.rx.controlEvent(.editingChanged), validation)

// Select
// No event

// Typing: ""A""
// zip failed(message: ""Field cannot be empty"") () &lt;- wrong

// Typing: ""Aa""
// zip failed(message: ""Field cannot be empty"") () &lt;- wrong

// Typing: ""Aaa""
// zip failed(message: ""Email is wrong"") () &lt;- correct

// UnSelect
// No event

Observable.combineLatest(textField.rx.controlEvent(.editingChanged), validation)

// Select
// No event

// Typing: ""A""
// combineLatest combineLatest failed(message: ""Email is wrong"") () &lt;- correct

// Typing: ""Aa""
// combineLatest failed(message: ""Field cannot be empty"") () &lt;- correct
// combineLatest failed(message: ""Field cannot be empty"") () &lt;- correct

// UnSelect
// combineLatest failed(message: ""Email is wrong"") () &lt;- wrong

validation
.withLatestFrom(textField.rx.controlEvent(.editingChanged))

// Select
// No event

// Typing: ""A""
// No event

// Typing: ""Aa""
// withLatestFrom () failed(message: ""Email is wrong"") &lt;- correct

// UnSelect
// withLatestFrom () failed(message: ""Email is wrong"") &lt;- wrong
</code></pre>

<p>Do you know any other approach to solve my problem?</p>
","4314758","","","","","2019-08-13 11:51:00","How to observe typing change in UITextField using RxSwift?","<swift><validation><uitextfield><rx-swift>","1","1","","","","CC BY-SA 4.0"
"57479165","1","","","2019-08-13 13:47:27","","1","88","<p>Add the Japanese - Romaji keyboard to your device.
Settings > Keyboards > Add New Keyboard</p>

<p>When typing on that textfield if you try to type <strong>tada</strong> you won't get the correct input <strong>ただ</strong> but <strong>たdあ</strong>.</p>

<p>Any ideas on how to tackle this?</p>

<pre class=""lang-swift prettyprint-override""><code>let value: BehaviorRelay&lt;String&gt; = .init(value: """")

self.textField.textField?.rx.text.orEmpty
            .bind(to: self.value)
            .disposed(by: self.disposeBag)

//same for this
self.textField.textField?.rx.text.orEmpty.asDriver()
    .drive(onNext: { (value) in
                self.value.accept(value)
     })
    .disposed(by: disposeBag)
</code></pre>
","2729171","","","","","2020-05-14 12:08:11","RxSwift breaks Japanese - Romaji input","<ios><swift><uitextfield><rx-swift><cjk>","1","0","","","","CC BY-SA 4.0"
"57479378","1","57487351","","2019-08-13 13:58:27","","2","525","<p>Currently I have services that manages retrieving data from the local storage, but also checks the remote network for any modified data. It is using a completion handler with <code>Result</code> pattern and protocol type, but would like to convert this to an observable approach.</p>

<p>Here is the current logic:</p>

<pre><code>struct AuthorWorker: AuthorWorkerType, Loggable {
    private let store: AuthorStore
    private let remote: AuthorRemote

    init(store: AuthorStore, remote: AuthorRemote) {
        self.store = store
        self.remote = remote
    }
}

extension AuthorWorker {

    func fetch(id: Int, completion: @escaping (Result&lt;AuthorType, DataError&gt;) -&gt; Void) {
        store.fetch(id: id) {
            // Immediately return local response
            completion($0)

            guard case .success(let cacheElement) = $0 else { return }

            // Sync remote updates to cache if applicable
            remote.fetch(id: id) {
                // Validate if any updates occurred and return
                guard case .success(let element) = $0,
                    element.modifiedAt &gt; cacheElement.modifiedAt else {
                        return
                }

                // Update local storage with updated data
                self.store.createOrUpdate(element) {
                    guard case .success = $0 else { return }

                    // Callback handler again if updated
                    completion($0)
                }
            }
        }
    }
}
</code></pre>

<p>I'm always instantly returning the local data to the UI so the user doesn't wait. In the background, it is checking the remote network for modified data and updates the UI again only if necessary. I use it like this:</p>

<pre><code>authorWorker.fetch(1) { [weak self] in
    guard case .success(let value) = $0 else {
        // alert error
    }

    self?.myLabel.text = value.name
}
</code></pre>

<p>How can this be converted to RxSwift or an observable concept? This is what I got started, but I don't see the code on the walls like Neo yet when it comes to Rx, so I need help seeing the light.</p>

<pre><code>extension AuthorWorker {

    func fetch(id: Int) -&gt; Observable&lt;AuthorType&gt; {
        return Observable&lt;AuthorType&gt;.create { observer in
            store.fetch(id: id) {
                // Immediately return local response
                observer.on(.next($0))

                guard case .success(let cacheElement) = $0 else {
                    observer.on(.completed)
                    return
                }

                // Sync remote updates to cache if applicable
                remote.fetch(id: id) {
                    // Validate if any updates occurred and return
                    guard case .success(let element) = $0,
                        element.modifiedAt &gt; cacheElement.modifiedAt else {
                            observer.on(.completed)
                            return
                    }

                    // Update local storage with updated data
                    self.store.createOrUpdate(element) {
                        guard case .success = $0 else {
                            observer.on(.completed)
                            return
                        }

                        // Callback handler again if updated
                        observer.on(.next($0))
                        observer.on(.completed)
                    }
                }
            }
        }
    }
}
</code></pre>

<p>Then I would use it like this?</p>

<pre><code>authorWorker.fetch(1).subscribe { [weak self] in
    guard let element = $0.element else {
        // Handle error how?
        return
    }

    self?.myLabel.text = element.name
}
</code></pre>

<p>Is this the right approach or is there a more recommended way to do this? Is it also worth converting the underlying remote and local stores to observable as well, or does it make sense not to convert all things to observable all the time?</p>
","235334","","235334","","2019-08-13 15:00:22","2019-08-15 02:17:41","RxSwift to juggle local database and remote network?","<swift><observable><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57503849","1","","","2019-08-15 01:27:16","","1","26","<p>I 'm practicing SwiftRx with MVVM and TableView where i wrote down simple program to download data from remote api <a href=""https://jsonplaceholder.typicode.com/photos"" rel=""nofollow noreferrer"">https://jsonplaceholder.typicode.com/photos</a> .Now i want to group rows with data from api i-e  albumId but stuck in it.Please help me</p>

<p>i tried with seperate datasource but i am completely new and have not much understanding.</p>

<pre><code>    viewModel.photoCells.bind(to: self.tableView.rx.items) {

        tableView, index, element in

        let indexPath = IndexPath(item: index, section: 0)
         switch element {

        case .normal(let viewModel):

            guard let cell = tableView.dequeueReusableCell(withIdentifier: ""photoCell"", for: indexPath) as? PhotosViewCell

                else {

                return UITableViewCell()
            }

            cell.viewModel = viewModel
            return cell
        case .error(let message):
            let cell = UITableViewCell()
            cell.isUserInteractionEnabled = false
            cell.textLabel?.text = message
            return cell
        case .empty:
            let cell = UITableViewCell()
            cell.isUserInteractionEnabled = false
            cell.textLabel?.text = ""No data available""
            return cell
        }
        }.disposed(by: disposeBag)
</code></pre>
","11709255","","","","","2019-08-15 10:40:09","Cannot Add Sections to Table View with Rx Swift and MVVM","<mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57522280","1","57522379","","2019-08-16 09:37:44","","0","457","<p>I've having a problem in RxSwift in converting a Observable into a String.</p>

<p>I understand that an observable is a sequence, I just want the last change in the username.</p>

<p>I'm storing username and password as:</p>

<pre><code>let username = BehaviorRelay&lt;String&gt;(value: """")
let password = BehaviorRelay&lt;String&gt;(value: """")
</code></pre>

<p>And previously have used combineLatest</p>

<pre><code>func loginButtonValid(username: Observable&lt;String&gt;, password: Observable&lt;String&gt;) -&gt; Observable&lt;Bool&gt; {
    return Observable.combineLatest(username, password)
    { (username, password) in
        return username.count &gt; 0
            &amp;&amp; password.count &gt; 0
            &amp;&amp; self.validateEmail(enteredEmail: username)
    }
}
</code></pre>

<p>But how can I just take the latest from the username?</p>

<p>I've tried takelast and use combineLatest with just one argument, but neither seems to work.</p>

<p>I want to do this to validate whether an email is valid, and the validate email function I'm using is the following (for reference only):</p>

<pre><code>func validateEmail(enteredEmail:String) -&gt; Bool {
    let emailFormat = ""[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}""
    let emailPredicate = NSPredicate(format:""SELF MATCHES %@"", emailFormat)
    return emailPredicate.evaluate(with: enteredEmail)
}
</code></pre>

<p>My attempts are around the following ideas</p>

<pre><code>func emailValid(username: Observable&lt;String&gt;) -&gt; Observable&lt;Bool&gt; {
        return username.takeLast()
        { (lastusername) in
            return self.validateEmail(enteredEmail: (lastusername) )
        }
}
</code></pre>
","11076699","","","","","2019-08-16 09:43:48","RxSwift convert Observable<String> into String","<swift><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57522455","1","57532833","","2019-08-16 09:48:31","","-1","154","<p>Imagine the following chain where a user wants to save a list of some sort:</p>

<pre><code>var saveChain = userTappedSaveListSubject
        .doOnNext { list -&gt; Void in // create pdf version
            let pdfFactory = ArticleListPDFFactory()
            list.pdf = try pdfFactory.buildPDF(list)
            try database.save(list)
        }
        .flatMap { list in
              AuthorizedNetworking.shared.request(.createList(try ListRequestModel(list)))
                    .filter(statusCode: 201)
                    .map { _ in list }
        }
        .doOnNext { list in
            list.uploaded = true
            try database.save(list)
            try Printer().print(list)
    }
    .materialize()
    .share()
</code></pre>

<p>On every operator in the chain errors can occur, which would terminate the stream and the user would be unable to retry saving and printing the list (the whole chain gets disposed).</p>

<p>In the end the user should see either a ""success"" or ""failure"" screen by binding the observable to a textField:</p>

<pre><code>Observable.of(
        saveChain.elements().map { _ in
            (""List saved!"", subtitle: ""Saving successfull"")
        }, 
        saveChain.errors().map { error in
            (""Error!"", subtitle: error.localizedDescription)
        })
        .merge()
</code></pre>

<p><strong>How should the error be handled?</strong></p>
","5376091","","5376091","","2019-08-16 09:58:45","2019-08-17 02:19:22","How to handle Errors on never ending chain with materialize?","<swift><error-handling><uikit><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57539462","1","57540517","","2019-08-17 19:49:30","","1","841","<p>I have a bunch of functions with Result completion handlers that I’d like to convert to RxSwift.</p>

<p>They follow this convention:</p>

<pre><code>func fetch(id: Int, completion: @escaping (Result&lt;AuthorType, DataError&gt;) -&gt; Void) {...}
</code></pre>

<p>I could use the typical:</p>

<pre><code>return Observable&lt;AuthorType&gt;.create { on(.next... }
</code></pre>

<p>Is there a more considerate generic way <a href=""https://github.com/mxcl/PromiseKit/blob/master/Documentation/GettingStarted.md#making-promises"" rel=""nofollow noreferrer"">like PromiseKit does</a>:</p>

<pre><code>func fetch() -&gt; Promise&lt;AuthorType&gt; {
return Promise { fetch(completion: $0.resolve) }
</code></pre>

<p>}</p>

<p>Anything like this possible in RxSwift?</p>
","235334","","","","","2019-08-18 13:01:26","Convert closure Result to Rx generically?","<swift><asynchronous><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57544950","1","57603726","","2019-08-18 13:17:26","","1","447","<pre><code>func showImageForUrl(url: String) -&gt; Observable&lt;Async&lt;Any&gt;&gt; {
    let result = RxAlamofire
        .requestJSON(.get,
                     url,
                     parameters: nil)
        .flatMap { (response, json) -&gt; Observable&lt;Any&gt; in
            return Observable.just(json)
        }.async()
    return result
}
</code></pre>

<p>url String  ""<a href=""http://1.bp.blogspot.com/-KhiJ6WYQn8Q/T7ZXxb_KHxI/AAAAAAAABvM/_l134PCuEcA/s1600/dog+photos+3.jpg"" rel=""nofollow noreferrer"">http://1.bp.blogspot.com/-KhiJ6WYQn8Q/T7ZXxb_KHxI/AAAAAAAABvM/_l134PCuEcA/s1600/dog+photos+3.jpg</a>""  </p>

<p>I'm trying this but the end result is an error.<a href=""https://i.stack.imgur.com/ET8U3.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ET8U3.png"" alt=""enter image description here""></a></p>
","1898829","","","","","2019-08-22 07:03:20","How to download image using RxAlamofire","<swift><rx-swift><rxalamofire>","1","0","","","","CC BY-SA 4.0"
"57555764","1","57562151","","2019-08-19 11:23:48","","1","599","<p>Learning RxSwift - Here's my Problem:</p>

<p>i have a webservice that fetches data using an active access token, whenever the token expired , then first call the token generate api and then call the current request to run again. so that it will have an active access token to valid results.</p>

<p>but i have problem in getting the response for token and then call the prev. request?</p>

<p>so i tried adding an observable request , then in response check if the token is invalid, then call another observable to return an active token, once token is received , call the older request again.</p>

<pre><code>func apirequest(_ urlConvertible:URLRequestConvertible) -&gt; Observable&lt;[String:AnyObject]&gt; {
  return Observable.create({ observer  -&gt; Disposable in
         let _ = Alamofire.request(urlConvertible).responseJSON  
                      { response in 
         if isTokenExpired() {
             self.generateToken().subscribe(onNext: response {
               self.apirequest(oldRequest)
          })
        }
      }
      return Disposables.create()
   })
}

</code></pre>

<p>i was expecting like any Rx operators or any ideas to try?</p>

<p>Thanks</p>
","11755473","","11755473","","2019-08-19 14:04:42","2019-08-19 18:29:10","RxSwift - Recursive Observables?","<ios><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57562396","1","","","2019-08-19 18:48:55","","1","182","<p>I have a way to work around this, but would like to know generally if this is just an inappropriate pattern for Realm and RxSwift or if it reflects a bug in the underlying framework interaction. Here's what I'm doing. I have set up a change listener on one Realm entity (call that entity A; this is only ever a single instance or record of this type of Realm object) looking for changes, except for a few special fields in entity A. I use:</p>

<pre><code>extension Observable where Element: Object {
    /// Observe changes to object *except* for specific fields.
    static func from(object: Element, emitInitialValue: Bool = true,
                     exceptForProperties: [String]) -&gt; Observable&lt;Element&gt; {
        return Observable&lt;Element&gt;.create { observer in
            if emitInitialValue {
                observer.onNext(object)
            }

            let token = object.observe { change in
                switch change {
                case .change(let changedProperties):
                    if changedProperties.contains(where: {
                        return exceptForProperties.contains($0.name)
                    }) {
                        // if change property is an excepted one, just return
                        return
                    }
                    observer.onNext(object)
                case .deleted:
                    observer.onError(RxRealmError.objectDeleted)
                case .error(let error):
                    observer.onError(error)
                }
            }

            return Disposables.create {
                token.invalidate()
            }
        }
    }
}
</code></pre>

<p>When I detect a change in one of the non-special fields in entity A, I update the special fields in entity A (e.g., this includes a ""dirty"" flag indicating I need to upload the Realm entity).</p>

<p>What I'm finding is that when I follow this sequence:
1) Change one of the non-special fields in the Realm entity A 
2) Do a Realm write with some other Realm entity, entity B (a different type of Realm object)
3) At exactly the point where that Realm write in 2) starts, that triggers the change listener for entity A. And tries do another (nested) Realm write, which of course fails with a Realm exception.</p>

<p>Is this just an inappropriate pattern to use (having a field change listener update that same entity) or is something else going on? Thanks.</p>
","1675875","","","","","2019-08-20 10:49:09","Realm and RxSwift: A field change listener updating a field in the same object fails","<ios><swift><realm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57581981","1","57601211","","2019-08-20 21:53:25","","1","1065","<p>Everything I've read says that <code>bind(to:)</code> calls <code>subscribe(onNext:)</code> within it. So I assume I should be able to swap out some stuff, but when I use `bind(to:) the thing it's binding to fires immediately. Here's my example:</p>

<h2>ButtonCollectionViewCell</h2>

<pre><code>class ButtonCollectionViewCell: UICollectionViewCell {

    lazy var buttonTapped: Observable&lt;Void&gt; = { _buttonTapped.asObservable() }()
    private var _buttonTapped = PublishSubject&lt;Void&gt;()
    private var disposeBag = DisposeBag()

    @IBOutlet private weak var textLabel: UILabel!
    @IBOutlet private weak var actionButton: UIButton!

    // MARK: - Lifecycle

    override func awakeFromNib() {
        super.awakeFromNib()

        actionButton.rx.tap.bind(to: _buttonTapped).disposed(by: disposeBag)
    }

    override func prepareForReuse() {
        disposeBag = DisposeBag()
    }

}
</code></pre>

<p>Now when I do the following below everything works as expected and it prints to the console when I tap the button</p>

<h2>ViewController with a collection view</h2>

<pre><code>func createButtonCell() {
    let buttonCell = ButtonCollectionViewCell() // there's more code to create it, this is just for simplicity
    buttonCell.buttonTapped.subscribe { _ in
        print(""tapped"")
    }.disposed(by: disposeBag)
    return buttonCell
}
</code></pre>

<p>However, if I change the above to:</p>

<pre><code>func createButtonCell() {
    let buttonCell = ButtonCollectionViewCell()
    buttonCell.buttonTapped.bind(to: buttonTapped)
    return buttonCell
}

private func buttonTapped(_ sender: Observable&lt;Void&gt;) {
    print(""tapped"")
}
</code></pre>

<p>The <code>""tapped""</code> is printed out right before I get to the cell when scrolling which I assume is when it's being created.</p>

<p>I don't understand this. I thought I could almost swap out the implementations? I would like to use the second example above there as I think it's neater but can't figure out how.</p>
","3320342","","","","","2019-08-23 01:07:34","RxSwift calling bind fires immediately vs subscribe(onNext: )","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57605851","1","57605938","","2019-08-22 09:12:31","","3","953","<p>I'm trying to combine two network requests with the <code>zip</code> function. These two requests rely on another one (getInfoA).</p>

<p>This is the code I'm working with:</p>

<pre><code>IoC.networkProcessService.getInfoA(with: identifier)
            .map { infoA -&gt; Observable&lt;(InfoB, InfoC)&gt; in

                return Observable.zip(
                    IoC.networkProcessService.getInfoB(with: infoA),
                    IoC.networkProcessService.getInfoC(with: infoA) 
                { return ($0, $1) }

            }
            .subscribe(onNext: { result in
                print(result)

               // result is of type Observable&lt;(InfoB, InfoC)&gt;...

            }, onError: { error in
                Logger.main.log(category: [.network, .error], arguments: error.localizedDescription)

            })
            .disposed(by: disposeBag)
</code></pre>

<p>I would expect that <code>result</code> (in the <code>subscribe</code> block) is a tuple and that I'm able to access <code>infoB</code> and <code>infoC</code>.</p>

<p>But it's not. Is <code>subscribe</code> the right operator to access the tuple from <code>zip</code>?</p>
","4473187","","","","","2020-05-03 04:16:35","RxSwift: Subscribe to Observable.zip. Handle result as tuple?","<ios><swift><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"57623181","1","57642421","","2019-08-23 09:14:21","","1","318","<p>My understanding is the SubscribeOn tells Rx what queue the sequence should begin on and that observeOn switches the scheduler.</p>

<p>This doesn't seem to be the case and it seems I'm lacking some basic understanding.</p>

<p>Please consider the example below.</p>

<pre><code>override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
        operation1().observeOn(realmReadScheduler)
            .observeOn(realmWriteScheduler)
            .flatMap(self.operation2)
            .observeOn(realmReadScheduler)
            .flatMap(operation3)
            .observeOn(realmSignalScheduler)
            .flatMap(operation4)
            .observeOn(realmConvertScheduler)
            .flatMap(operation5).subscribeOn(realmConvertScheduler)
            .subscribe(onNext: {success in
                print(success)
            })


    }
</code></pre>

<p>Which prints out:</p>

<pre><code>&gt; Operation 1 com.apple.main-thread Operation 2 com.jci.xaap.realm.write
&gt; Operation 3 com.jci.xaap.realm.read Operation 4
&gt; rxswift.queue.DispatchQoS(qosClass:
&gt; Dispatch.DispatchQoS.QoSClass.background, relativePriority: 0)
&gt; Operation 5 com.jci.xaap.realm.convert
</code></pre>

<p>I had expected Operation1 to execute on 'realmConvertScheduler' not main thread..</p>

<p>How can I make sure that the very first  observable in my chain executes on the queue that I want?</p>
","264273","","264273","","2019-08-23 10:39:15","2019-08-25 00:37:18","How do I kick off a chain of observable on a particular queue?","<observable><swift4><grand-central-dispatch><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57624344","1","57634619","","2019-08-23 10:24:14","","0","481","<p>I have an array of object which I used to create a checkbox. The model has an id, name. I created a stackView to handle checkbox with id now I want to append items of selected checkbox to an array and be able to remove them when deselected. I am able to present all the views and it works well </p>

<p>below is my code</p>

<pre><code>NetworkAdapter.instance.getFeaturesAmeneities()
            .subscribe(onNext: {feat in
                guard let data  = feat.data else {return}
                self.features.append(contentsOf: data)

                self.stackFeature.axis = .vertical
                self.stackFeature.distribution = .fill
                self.stackFeature.spacing = 8

                data.forEach {
                    print($0.id)
                    self.stv = CheckboxStackView()
                    self.stv?.label.text = $0.name
                    self.stv?.checkBox.tag = $0.id ?? 0
                    self.stackFeature.addArrangedSubview(self.stv!)
                }

            }).disposed(by: disposeBag)
</code></pre>

<p>Any help is appreciated </p>
","8310287","","","","","2019-08-25 17:36:56","setting ids on item in Stackview","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57646682","1","57647160","","2019-08-25 13:59:07","","3","261","<p>I am currently new to RxSwift and I am a little bit confused about the flatMap and merge operator. I know the merge operator merges more than one observable into a single observable. I feel that flatMap is doing the same thing.Am I wrong? If so what is the difference between both</p>
","7438106","","","","","2019-08-25 15:01:34","What is the difference between merge and flatmap operator in RxSwift","<merge><rx-swift><reactive><flatmap>","1","0","","","","CC BY-SA 4.0"
"57650927","1","57653152","","2019-08-26 01:32:11","","1","985","<p>I am building a table view backed by RxDataSources. I want to enable editing for this table view, such that the user can delete items.</p>

<p>I currently have this code:</p>

<pre><code>var strings = [String]() {
    didSet {
        observable.accept(strings)
    }
}

let observable = BehaviorRelay(value: [String]())
let disposeBag = DisposeBag()

override func viewDidLoad() {
    tableView.dataSource = nil
    let dataSource = RxTableViewSectionedAnimatedDataSource&lt;StringSection&gt;(configureCell:  {
        (dataSource, collectionView, indexPath, string) -&gt; UITableViewCell in
        let cell = collectionView.dequeueReusableCell(withIdentifier: ""cell"", for: indexPath)
        cell.textLabel?.text = string
        return cell
    })

    observable.asObservable()
        .map {
            [StringSection(items: $0)]
        }
        .bind(to: self.tableView.rx.items(dataSource: dataSource))
        .disposed(by: disposeBag)

    // X

    strings = [""Item 1"", ""Item 2"", ""Item 3""]
}
</code></pre>

<p>To make this editable, I added this in the place marked X:</p>

<pre><code>tableView.rx.itemDeleted
    .subscribe(onNext: { _ = self.strings.remove(at: $0.row) })
    .disposed(by: disposeBag)
navigationItem.rightBarButtonItem = editButtonItem
</code></pre>

<p>And also overrode this method:</p>

<pre><code>override func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -&gt; UITableViewCell.EditingStyle {
    return .delete
}
</code></pre>

<p>However, when I press the edit button, nothing changes for the table view cells. I see no red ""-"" button on the left. I cannot swipe the cell to the left to reveal the delete button either.</p>

<p>What else do I need to do to enable editing?</p>
","5133585","","","","","2019-08-26 07:01:53","How to allow editing of a table view backed by RxDataSources?","<ios><swift><uitableview><rx-swift><rxdatasources>","1","0","1","","","CC BY-SA 4.0"
"57652703","1","","","2019-08-26 06:21:30","","0","27","<p>I have a viewmode for login. And have a variable for sign result. I have another views will update there UI dependents on the result, like succes or fail.</p>

<p>At the begining, i wanna use the singleton mode for viewmode. But it's not recommanded. So how can i subscribe the same dirve varibale for many views.</p>

<pre><code>var signupResult: Driver&lt;LoginRepository&gt; = Driver.empty()

signupResult = AladdinProvider.rx.request(.login(username: username, password: pwd)).filterSuccessfulStatusCodes().asObservable().mapObject(type: LoginRepository.self).asDriver(onErrorDriveWith: Driver.empty()).

</code></pre>
","8720668","","","","","2019-08-26 09:58:19","How to share a viewMode Driver property for server views?","<ios><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57655773","1","57657505","","2019-08-26 10:04:57","","0","300","<p>I am trying to make a UIStackview reactive and declarative as answered in my question here <a href=""https://stackoverflow.com/questions/57624344/setting-ids-on-item-in-stackview"">setting ids on item in Stackview</a> but the issue I am having now is when I try to bind to the stackView, I get this error <code>Cannot convert value of type '(_) -&gt; (@escaping (Int, _.Element, UIView?) -&gt; UIView) -&gt; Disposable' to expected argument type '(Observable&lt;[LandMarkData]?&gt;) -&gt; (_) -&gt; _'</code></p>

<p>bellow is the code I used </p>

<pre><code>extension Reactive where Base: UIStackView {

    func items&lt;Sequence: Swift.Sequence, Source: ObservableType&gt;(_ source: Source) -&gt; (_ viewForRow: @escaping (Int, Sequence.Element, UIView?) -&gt; UIView) -&gt; Disposable where Source.E == Sequence {
        return { viewForRow in
            return source.subscribe { event in
                switch event {
                case .next(let values):
                    let views = self.base.arrangedSubviews
                    let viewsCount = views.count
                    var valuesCount = 0
                    for (index, value) in values.enumerated() {
                        if index &lt; viewsCount {
                            // update views that already exist
                            _ = viewForRow(index, value, views[index])
                        }
                        else {
                            // add new views if needed
                            let view = viewForRow(index, value, nil)
                            self.base.addArrangedSubview(view)
                        }
                        valuesCount = index
                    }
                    if valuesCount + 1 &lt; viewsCount {
                        for index in valuesCount + 1 ..&lt; viewsCount {
                            // remove extra views if necessary
                            self.base.removeArrangedSubview(views[index])
                            views[index].removeFromSuperview()
                        }
                    }
                case .error(let error):
                    fatalError(""Errors can't be allowed: \(error)"")
                case .completed:
                    break
                }
            }
        }
    }
}
</code></pre>

<p>in my Viewcontroller</p>

<pre><code>var features: [LandMarkData] = [LandMarkData]()
var selectedFeatures: [LandMarkData] = [LandMarkData]()

    let stackFeature = UIStackView()
    var stv: CheckboxStackView?
    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = .white
        hideKeyboardWhenTappedAround()
        layout()
        logic()
        tableViewInit()

        self.stackFeature.axis = .vertical
        self.stackFeature.distribution = .fill
        self.stackFeature.spacing = 8

        let featured = NetworkAdapter.instance.getFeaturesAmeneities()
            .map { $0.data }
            .share(replay: 1)

        featured
            .bind(onNext: { [weak self] in self?.features.append(contentsOf: $0!) })
            .disposed(by: disposeBag)


        featured
            .bind(to: stackFeature.rx.items) { (row, element, view) in
                let myView = (view as? CheckboxStackView) ?? CheckboxStackView()

                myView.label.text = element.name
                myView.checkBox.tag = element.id ?? 0
                return myView
            }
            .disposed(by: disposeBag)

    }
</code></pre>

<p>any help why I am getting the error and a fix is appreciated </p>
","8310287","","","","","2019-08-26 11:56:45","Cannot convert value of type in UIStackview reactive and declarative swift","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"57662303","1","57671948","","2019-08-26 17:23:36","","2","255","<p>I'm studying RxSwift and RxCocoa.
There are these explanations in the official document.</p>

<ol>
<li>Share side effect</li>
<li>Share resource</li>
</ol>

<p>Are they the same?
If there is a difference, what difference is there?
I don't understand just the explanations in the official document.</p>

<p>Thank you in advance for your answer.</p>
","11979815","","","","","2019-08-27 09:46:58","Differences between ""Share Side effect"" and ""Share Resources""","<rx-swift><rx-cocoa>","1","4","1","","","CC BY-SA 4.0"
"57668983","1","57725107","","2019-08-27 06:44:19","","1","173","<p>Now I'm working on <strong>iOS</strong> using <strong>RxSwift</strong> framework. In my app I have to user user location, but I don't need it to be updated in real time. It's enough if location updated every time user opens app or does some defined action. Therefore, how about implementing singleton class where the last result is cached. Each update by action changes cached result and accepts it to the stream. Stream's default value is cached value. Then, views where user location is needed would subscribe on this stream.</p>

<p><strong>Example implementation</strong> using <a href=""https://github.com/hyperoslo/Cache"" rel=""nofollow noreferrer"">Cache</a> and <a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow noreferrer"">RxSwift</a></p>

<pre><code>import Foundation
import Cache
import CoreLocation
import RxSwift
import RxCocoa

class UserLocationManager: NSObject {
    private enum Keys: String {
        case diskConfig = ""Disk Config""
        case lastLocation = ""User Last Location""
    }

    // MARK: - Variables
    private func cache&lt;T: Codable&gt;(model: T.Type) -&gt; Cache.Storage&lt;T&gt; {
        let storage = try! Cache.Storage(diskConfig: DiskConfig(name: Keys.diskConfig.rawValue), memoryConfig: MemoryConfig(expiry: .never), transformer: TransformerFactory.forCodable(ofType: model))
        return storage
    }
    private let locationManager = CLLocationManager()
    private var lastPosition: MapLocation? {
        get {
            do {
                return try cache(model: MapLocation.self).object(forKey: Keys.lastLocation.rawValue)
            }
            catch { return nil }
        }
        set {
            do {
                guard let location = newValue else { return }
                try cache(model: MapLocation.self).setObject(location, forKey: Keys.lastLocation.rawValue)
            }
            catch { }
        }
    }
    private let disposeBag = DisposeBag()
    static let shared = UserLocationManager()
    var locationStream = BehaviorRelay&lt;CLLocationCoordinate2D?&gt;(value: nil)

    // MARK: - Methods
    func updateLocation() {
        if CLLocationManager.locationServicesEnabled() {
            locationManager.requestLocation()
        }
    }

    func subscribe() {
        locationStream.accept(lastPosition?.clCoordinate2D)
        locationStream.subscribe(onNext: { [weak self] location in
            guard let `self` = self else { return }
            guard let location = location else { return }

            self.lastPosition = MapLocation(latitude: location.latitude, longitude: location.longitude)
        }).disposed(by: disposeBag)
        locationManager.delegate = self
    }

    // MARK: - Lifecycle
    override init() {
        super.init()

        defer {
            self.subscribe()
        }
    }
}

// MARK: - CLLocationManagerDelegate
extension UserLocationManager: CLLocationManagerDelegate {
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.first else { return }
        UserLocationManager.shared.locationStream.accept(location.coordinate)
    }

    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {

    }
}
</code></pre>
","4950794","","4950794","","2019-08-27 06:50:24","2019-08-30 10:33:26","Is it bad idea to create static stream in reactive programming?","<ios><swift><static><rx-swift><reactive>","1","0","","","","CC BY-SA 4.0"
"57674504","1","","","2019-08-27 12:17:01","","2","635","<p>I have a ViewController (called <code>MainViewController</code>) which is backed by a ViewModel (called <code>MainViewModel</code>).</p>

<p>The ViewModel has a variable that defines which child ViewController <code>MainViewController</code> should present as its child.</p>

<p>My problem is that, when <strong>a child is removed in favor of another child, it never gets <code>deinit</code>'ed.</strong></p>

<p>Here's the code:</p>

<p><strong>MainViewController:</strong></p>

<pre><code>class MainViewController: UIViewController {

    var viewModel: MainViewModel!
    private let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        viewModel.viewController
            .subscribe(onNext: { [weak self] vc in
                self?.newVc(vc)
            })
            .disposed(by: disposeBag)
    }

    static func instantiate(viewModel: MainViewModel) -&gt; MainViewController {
        let vc = MainViewController()
        vc.viewModel = viewModel
        return vc
    }

    private func newVc(_ vc: UIViewController) {
        remove(childViewController: children.first)
        addFullScreen(childViewController: vc)
    }
}
</code></pre>

<p><strong>MainViewModel:</strong></p>

<pre><code>class MainViewModel {

    lazy var viewController: Observable&lt;UIViewController&gt; = {
        return Observable.just(ColorViewController(.green))
            .delay(RxTimeInterval.seconds(3), scheduler: MainScheduler.instance)
            .startWith(ColorViewController(.yellow))
    }()

}
</code></pre>

<p>You see in <code>MainViewModel</code>s <code>viewController</code> variable, that it first emits a yellow ColorViewController, and 3 seconds later a green one.
<code>ColorViewController</code> is a basic subclass of UIViewController, with a colored view, and a the <code>deinit</code>-method overwritten. This methods isn't called, when the yellow ColorViewController is removed..</p>

<p><strong>Who holds the reference to that yellow ColorViewController, and how to fix it?</strong></p>

<p><strong>Bonus code:</strong></p>

<pre><code>extension UIViewController {

    public func addFullScreen(childViewController child: UIViewController) {
        guard child.parent == nil else { return }

        addChild(child)
        view.addSubview(child.view)

        child.view.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            view.leadingAnchor.constraint(equalTo: child.view.leadingAnchor),
            view.trailingAnchor.constraint(equalTo: child.view.trailingAnchor),
            view.topAnchor.constraint(equalTo: child.view.topAnchor),
            view.bottomAnchor.constraint(equalTo: child.view.bottomAnchor)
        ])

        child.didMove(toParent: self)
    }

    public func remove(childViewController child: UIViewController?) {
        guard let child = child else { return }
        guard child.parent != nil else { return }

        child.willMove(toParent: nil)
        child.view.removeFromSuperview()
        child.removeFromParent()
    }
}
</code></pre>

<p><strong>UPDATE:</strong></p>

<p>So I changed the <code>viewController</code>-variable to this:</p>

<pre><code>lazy var viewController: Observable&lt;UIViewController&gt; = {
        return Observable&lt;Int&gt;.interval(RxTimeInterval.seconds(3), scheduler: MainScheduler.instance)
            .scan(0, accumulator: { (prev, next) -&gt; Int in return prev + 1 })
            .map { index -&gt; UIViewController in
                let modul = index % 3
                print(""Index: \(index): \(modul)"")
                switch modul {
                case 0: return ColorViewController(.yellow, tag: ""Yellow"")
                case 1: return ColorViewController(.blue, tag: ""Blue"")
                case 2: return ColorViewController(.green, tag: ""Green"")
                default: return ColorViewController(.red, tag: ""Red"")
                }
            }.startWith(ColorViewController(.cyan, tag: ""Initial 1""),
                        ColorViewController(.purple, tag: ""Initial 2""))
            .take(10)
    }()
</code></pre>

<p>Now I see that all the <code>ColorViewController</code>'s generated in the <code>.map</code> are deinitialized as expected. But the two passed into <code>.startWith</code>, are never deinitialized, not even after <code>.take(10)</code> causes the Observable to complete. Does that make sense to anyone?</p>
","2299801","","2299801","","2019-08-27 12:51:54","2019-08-28 00:28:32","RxSwift; ViewController never deinitialized","<ios><swift><rx-swift><deinit>","1","1","","","","CC BY-SA 4.0"
"57708870","1","","","2019-08-29 11:09:42","","-1","121","<p>I have a viewmode class like this :</p>

<pre><code>class ViewMode {
 let validateCountResult: Driver&lt;Bool&gt;
 init(username: Driver&lt;String&gt;) {
     validateCountResult = username
            .flatMapLatest { username in
                return // validate username
    }
}
</code></pre>

<p>And I have a subclass  of <code>UIViewController</code> as follow :</p>

<pre><code>class ViewController : UIViewController{
  override func viewDidLoad() {
        super.viewDidLoad()
        let viewmode = 
        ViewMode(textfiled.rx.texttext.orEmpty.asDriver())
        viewmode.validateCountResult.drive(onNext:{
          // TODO Something
           FuncA()
         })
   }
}
</code></pre>

<p>When viewDidload finishes, I believe the viewmode should deinits as well. But I see the binding still exists and FuncA still get called!</p>

<p>Why is it so?</p>
","8720668","","3554832","","2019-09-05 09:58:21","2019-09-05 09:58:21","rxswift block life cycle","<ios><rx-swift>","2","0","","","","CC BY-SA 4.0"
"57713871","1","","","2019-08-29 15:55:40","","1","107","<p>I am trying to have an Rx listener detect changes to properties in various Realm entities (call them E1, E2, ...) using <code>Observable.from</code> cause a change in another (different) Realm entity (call that T). Often this works just fine, but in some causes I get nested Realm writes and a crash. This crash is happening because some of our code is of the form (pseudo code)</p>

<pre><code>for e in E1, E2, ... {
    try realm.write {
        e.property = value
    }
}
</code></pre>

<p>Consistently, the write on the <code>second</code> entity in the list appears to trigger the <code>Observable.from</code> listener, and this leads to a nested write.</p>

<p>My use case is a dirty flag (e.g., <a href=""https://stackoverflow.com/questions/41603676/dirty-flags-on-realm-objects"">Dirty flags on Realm objects</a>) but I need that flag persisted, plus several other related fields (e.g., an update date/time) that have to be changed in T on each E1, E2, ... change.</p>

<p>Thoughts? Thanks.</p>

<h2>Update1</h2>

<p>I'm using <code>Observable.from</code> from <a href=""https://github.com/RxSwiftCommunity/RxRealm"" rel=""nofollow noreferrer"">https://github.com/RxSwiftCommunity/RxRealm</a></p>
","1675875","","1675875","","2019-09-03 15:40:10","2019-09-03 15:40:10","Problems updating Realm based on Rx listener on Realm objects","<ios><swift><realm><rx-swift>","0","3","","","","CC BY-SA 4.0"
"57724910","1","57802909","","2019-08-30 10:19:52","","0","1002","<p>I am using RxMoya for my networking calls and extending PremitiveSequence and Response so as to handle the error coming back. I declared a struct of Networking error which I could use to get all the error details and as such Pass the error message via the BaseResponse Model. Here is my NetwokingError struct </p>

<pre><code>public struct NetworkingError: Error {
    let httpResponse: HTTPURLResponse?
    let networkData: Data?
    let baseError: Error
}
</code></pre>

<p>For my coding, I have extended the primitive sequence as follows</p>

<p>public extension PrimitiveSequence where TraitType == SingleTrait, </p>

<pre><code>ElementType == Response {

    func mapObject&lt;T: Codable&gt;(_ type: T.Type, path: String? = nil) -&gt; Single&lt;T&gt; {
        return flatMap { response -&gt; Single&lt;T&gt; in
            return Single.just(try response.mapObject(type, path: path))
        }
    }

    func mapArray&lt;T: Codable&gt;(_ type: T.Type, path: String? = nil) -&gt; Single&lt;[T]&gt; {
        return flatMap { response -&gt; Single&lt;[T]&gt; in
            return Single.just(try response.mapArray(type, path: path))
        }
    }

    func filterSuccess() -&gt; Single&lt;E&gt; {
        return flatMap { (response) -&gt; Single&lt;E&gt; in
            if 200 ... 299 ~= response.statusCode {
                return Single.just(response)
            }

            print(""THIS ERROR JSON jsonObject2 xx mm \(response.data)"")

            do {
                let jsonObject2 = try JSONSerialization.jsonObject(with: response.getJsonData(), options: .allowFragments)
                print(""THIS ERROR JSON jsonObject2 xx \(jsonObject2)"")
                let jsonObject = try JSONSerialization.jsonObject(with: response.getJsonData(), options: .allowFragments) as? NetworkingError

                print(""THIS ERROR JSON  xx \(jsonObject)"")
                return Single.error(jsonObject ?? NetworkingError.self as! Error)
            }
        }
    }
}
</code></pre>

<p>if I run this code here, The app crashes <code>return Single.error(jsonObject ?? NetworkingError.self as! Error)</code></p>

<p>in my code, I am passing data like </p>

<pre><code>func postVerifyApp(challenge: Int, identifier: String) -&gt; Observable&lt;AuthResponse&gt; {

        return provider.rx.request(.postVerifyApp(challenge: challenge, identifier: identifier))

            .filterSuccess()
            .mapObject(AuthResponse.self)
            .asObservable()
            .flatMap({ authResponse -&gt; Observable&lt;AuthResponse&gt; in
                return self.sendTokenToServer(authResponse)
            })
    }
</code></pre>

<p>then I am working with this in my presenter class like this</p>

<pre><code>func postVerifyApp(challenge: Int, identifier: String) {
        view?.setProgress(enabled: true)
        source.postVerifyApp(challenge: challenge, identifier: identifier)
            .retry(.delayed(maxCount: 2, time: 2.5), shouldRetry: networkRetryPredicate)
            .asSingle()
            .subscribe(onSuccess: { [weak self] response in
                guard let presenter = self, let view = presenter.view else {return}
                view.setProgress(enabled: false)
                log(response, .json)
                guard let data = response.data else {
                    return }

                view.showVerifySuccess()
                }, onError: { [weak self] error in
                    guard let presenter = self, let view = presenter.view else {return}
                    print(""MESSAGE X \(error.localizedDescription)"")
                    if let error = error as? NetworkingError {
                        print(""MESSAGE X httpResponse \(error.httpResponse)"")
                    }
                    view.setProgress(enabled: false)

            }).disposed(by: disposeBag)
    }
</code></pre>

<p>I want to be able to pass this Error and extract the error message and passing it to the console.</p>

<p>This is what my base Model looks like</p>

<pre><code>struct ResponseBase&lt;T: Codable&gt;: Codable {
    var error: Bool?
    var message: String?
    var data: T

    var isSucessful: Bool {
        return error == false
    }

}
</code></pre>
","8310287","","","","","2019-09-05 12:32:57","Casting Moya Response error to defined type","<swift><rx-swift><moya>","1","0","","","","CC BY-SA 4.0"
"57744784","1","57745415","","2019-09-01 09:27:29","","3","99","<p>I have a function in ViewModel which is getting some data from network file as Single. In viewModel I am using map to convert it to different model and return it to ViewController. Once this map/conversion is complete I want to update a BehaviorRelay object in ViewModel to tell its subscribers that downloading is complete. I am not able to update this BehaviorRelay object.</p>

<p>I tried to add some code in the function but I get error in return statement.</p>

<pre><code>var showLoading = BehaviorRelay&lt;Bool&gt;(value: true)
func getPropertyList(city cityID: String) -&gt; Single&lt;[Property]&gt; {
        return propertyListApi.getPropertyList(city: cityID).map({ [weak self] propertInfo -&gt; [Property] in
            propertInfo.map({
                return Property(name: $0.name, type: ""Property Type: "" + $0.type, lowestPricePerNight: """", overallRatingPercentage: ""Rating: "" + String($0.overallRating.overall ?? 0), image: self?.getImageURL(images: $0.images))
            })
        })
    }
</code></pre>

<p>I want to update showLoading in getPropertyList function to let ViewController know that loading is complete.</p>
","9692737","","","","","2019-09-01 11:01:06","How to know completion of map on a Single in ViewModel?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"57745877","1","57746565","","2019-09-01 12:09:31","","0","430","<p>Here's my implementation. </p>

<p>I have <code>favCitiesID = Observable&lt;[Int]&gt;</code> that will be flatMap and map. Each city id will be used in API call that will return <code>Observable&lt;CityMappable&gt;</code>. I have reached to the point where I can get <code>[Observable&lt;CityMappable&gt;]</code> but I want to transform it into <code>Observable&lt;[CityMappable]&gt;</code> so I can bind it to tableview datasource.</p>

<pre><code>let favCitiesID: Observable&lt;[Int]&gt; = Observable.of([0,1,2])

let observableCities = favCitiesID.flatMap { cityIds -&gt; Observable&lt;[CityMappable]&gt; in
        return cityIds.map{ return self.apiManager.getCurrentWeatherData(for: $0)}
}
</code></pre>

<p>This is APIManager function definition</p>

<pre><code>func getCurrentWeatherData(for cityID: Int)-&gt;Observable&lt;CityMappable&gt;
</code></pre>
","4078959","","4078959","","2019-09-03 16:03:43","2019-09-03 16:03:43","Convert [Observable<T>] to Observable<[T]> in RxSwift","<ios><swift><rx-swift><rx-cocoa>","1","0","1","","","CC BY-SA 4.0"
"57776236","1","","","2019-09-03 17:22:22","","0","300","<p>I am trying to write test cases and trying to access a method which returns Single object. For this I want to use toBlocking but I am not able to access it and getting following error:    </p>

<blockquote>
  <p>Value of type 'Single&lt;[Property]>' (aka
  'PrimitiveSequence>') has no member
  'toBlocking'</p>
</blockquote>

<p>Following is my code</p>

<pre><code> do {
        let property = try viewModel.getPropertyList(city: ""1530"")
            .toBlocking()
            .single()
        XCTAssertNotNil(property)
    } catch {
        XCTFail(""Get user settings failed"")
    }
</code></pre>

<p>Already imported following frameworks:    </p>

<pre><code>import RxCocoa   
import RxSwift  
import XCTest
</code></pre>
","9692737","","9692737","","2019-09-03 17:36:48","2019-09-05 09:14:34","Unable to access toBlocking() in xctest","<swift><rx-swift><rxtest>","1","0","","","","CC BY-SA 4.0"
"57815613","1","57830213","","2019-09-06 04:10:52","","0","147","<p>I want to use RxSwift but alwo don't want to force-unwrap.</p>

<p>When I use [weak self] I get the error that self must be unwrapped - ie. self can't be optional in this case</p>

<pre><code>public func getPages() -&gt; Observable&lt;[(String, String)]&gt; {
    return Observable.create {
        [weak self] observer -&gt; Disposable in
        if let pages = self?.pages {
            observer.onNext(pages)
        } else {
            self?.allPages()
                .debug()
                .subscribe({ event in
                    switch event {
                    case .next(let dta):
                        observer.onNext(dta)
                    case .error(let error):
                        observer.onError(error)
                    case .completed:
                        break
                    }
                }).disposed(by: self.disposeBag)
        }
        return Disposables.create()
    }
}
</code></pre>

<p>my solution has been to force-unwrap self at that point, however this is not right.</p>

<p>i.e.</p>

<pre><code>}).disposed(by: self!.disposeBag)
</code></pre>

<p>So how can I avoid force-unwrapping in this case?</p>
","11076699","","","","","2019-09-07 12:23:08","Force-unwrapping dispose bag while using RxSwift","<swift><rx-swift>","3","2","","","","CC BY-SA 4.0"
"57819091","1","57829999","","2019-09-06 09:14:58","","1","531","<p>I am studying RxSwift.
But it's very difficult, so I post a question.</p>

<p>Situation :
I want to display the information of the character in tableView.
The character has item information and avatar information. (There are two APIs.)</p>

<p>Problem :
I succeeded in displaying one data model (item information) in tableView.
But I don't know how to bind two or more models to tableView.</p>

<p>This is the code when I bind one model to tableView.</p>

<p>ViewModel :</p>

<pre><code>let characterDetail = PublishSubject&lt;CharacterDetailResp&gt;()
var characterDetailInfo : CharacterDetailResp = CharacterDetailResp()
let error : PublishSubject&lt;CharacterDetailError&gt; = PublishSubject()

func requestData() {
        let URL : String = ""\(baseUrl)/servers/characterName/""

        AF.request(URL, method: .get, parameters:nil, encoding: JSONEncoding.default).responseObject {
        (response : DataResponse&lt;CharacterDetailResp&gt;) in

        switch response.result {
        case .success:
            self.characterDetailInfo = response.value!
            self.characterDetail.onNext(self.characterDetailInfo)

        case .failure(let err):
            if err.localizedDescription == ""The Internet connection appears to be offline."" {
                self.error.onNext(.internetError(""Please Check Internet""))
            }
            else {
                self.error.onNext(.serverMessage(err.localizedDescription))
            }
        }
    }
}

</code></pre>

<p>ViewController :</p>

<pre><code>var characterDetailViewModel = ViewModel()
let characterDetail = PublishSubject&lt;CharacterDetailResp&gt;()
let disposeBag = DisposeBag()

func setupBindings() {
        characterDetailViewModel
            .error
            .observeOn(MainScheduler.instance)
            .subscribe(onNext: { (error) in
                switch error {
                case .internetError(let message):
                    print(""Error : \(message)"")
                case .serverMessage(let message):
                    print(""Warning : \(message)"")
                }
            })
            .disposed(by: disposeBag)

        tableView.register(UINib(nibName: ""CharacterCell"", bundle: nil), forCellReuseIdentifier: String(describing: CharacterCell.self))

        characterDetailViewModel
            .characterDetail
            .observeOn(MainScheduler.instance)
            .bind(to: tableView.rx.items(cellIdentifier: ""CharacterCell"", cellType: CharacterCell.self)) {
                (row, characterDetail, cell) in
                cell.character = characterDetail
            }
            .disposed(by: disposeBag)
    }
</code></pre>

<p>I want to know how to bind two or more API models to TableView</p>

<p>Plz help me....</p>
","10545337","","","","","2019-09-07 01:23:18","How to bind multiple data models to TableView in RxSwift","<swift><alamofire><rx-swift><swift5>","1","1","","","","CC BY-SA 4.0"
"57819977","1","","","2019-09-06 10:08:38","","1","129","<p>I have a LoginViewModel and LoginViewController class. In LoginViewController there is 2 textfield userName, password, and a Login Button, when user click Login button username and password field is validated in LoginViewModel class, if it is empty then a respective message is passed to LoginViewController class and message in displayed in respective textfield.</p>

<pre><code>class LoginViewModel : LoginViewModelProtocol {

    var errorObservable: PublishSubject&lt;String&gt; = PublishSubject&lt;String&gt;()

    var userName: BehaviorRelay&lt;String&gt; = BehaviorRelay(value: """")
    var password: BehaviorRelay&lt;String&gt; = BehaviorRelay(value: """")
    let disposeBag = DisposeBag()
    var apiClient : ApiClientProtocol
    public init(fetcher : ApiClientProtocol) {
        apiClient = fetcher
    }

    func validateUserName(_ value: String) -&gt; Bool {
        if value.count == 0 {
            errorObservable.onNext(""This field is required"")
            return false
        }
        return true
    }

    func validatePassword(_ value: String) -&gt; Bool {
        if value.count == 0 {
            errorObservable.onNext(""This field is required"")
            return false
        }
        return true
    }




    func onLoginButtonClick(){
        if self.validateUserName(userName.value) &amp;&amp;  self.validatePassword(password.value) {
//        apiClient.performLogin(userName: userName.value, password: password.value)
        }

    }

}
</code></pre>

<p>//validateUserName and validatePassword should notify username and password field respectively.</p>

<pre><code>class LoginViewController: UIViewController {


    @IBOutlet weak var usernameTextField: UITextField!
    @IBOutlet weak var passwordTextField: UITextField!
    @IBOutlet weak var loginButton: UIButton!

    let disposeBag = DisposeBag()

  var viewModel: LoginViewModelProtocol!

   override func viewDidLoad() {
        super.viewDidLoad()
        initialiseUI()
        configureBinding()
  }

  func configureBinding() {
        usernameTextField.rx.text
            .orEmpty
            .bind(to: viewModel.userName)
            .disposed(by: disposeBag)

        passwordTextField.rx.text
            .orEmpty
            .bind(to: viewModel.password)
            .disposed(by: disposeBag)



  viewModel.errorObservable.asObserver().subscribe(onNext: { (error) in

            self.updateUI(error)

        }, onDisposed: {})

    }

    func updateUI(_ error : String){

        let fontS = UIFont.systemFont(ofSize: 12)
        let attributes = [
            NSAttributedString.Key.foregroundColor: UIColor.red,
            NSAttributedString.Key.font : fontS
            ] as [NSAttributedString.Key : Any]


        self.passwordTextField.attributedPlaceholder = NSAttributedString(string: error, attributes: attributes)
    }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/cVQln.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/cVQln.png"" alt=""enter image description here""></a></p>

<p>I want to show error message in both textfield when both are empty
How will I pass value with errorObserver for both textField and password when they are empty with RxSwift?</p>
","4571399","","","","","2019-09-06 11:52:09","Differentiate errorObserver with appropriate value in iOS RxSwift","<ios><swift><observable><rx-swift><rx-cocoa>","1","0","1","","","CC BY-SA 4.0"
"57833458","1","57833824","","2019-09-07 11:57:02","","2","545","<p>I need to make a long async calculation based on a <code>String</code> input and return a big <code>Data</code> instance.
I use <code>Single</code> trait to achieve this:</p>

<pre><code>func calculateData(from: String) -&gt; Single&lt;Data&gt;
</code></pre>

<p>This example is simple and works. But I also need to track progress — a number between 0 and 1. I'm doing something like this:</p>

<pre><code>func calculateData(from: String) -&gt; Observable&lt;(Float, Data?)&gt;
</code></pre>

<p>where I get the following sequence:</p>

<pre><code>next: (0, nil)
next: (0.25, nil)
next: (0.5, nil)
next: (0.75, nil)
next: (1, result data)
complete
</code></pre>

<p>I check for progress and data to understand if I have a result, it works, but I feel some strong smell here. I want to separate streams: <code>Observable</code> with progress and <code>Single</code> with a result. I know I can return a tuple or structure with two observables, but I don't like this as well.</p>

<p>How can I achieve this? Is it possible?</p>
","3574762","","","","","2019-09-07 12:46:21","RxSwift How to split progress and result observables?","<reactive-programming><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"57840328","1","57852932","","2019-09-08 08:31:17","","2","478","<p>I master RxSwift and when using RxDataSource, the SearchBar delegates do not work for me and he, 
I can’t see the error. Without RxDataSource everything works, on other screens I have no problems. 
Tell me, with a fresh look, what is the mistake? why doesn't the filter happen?</p>

<pre><code>private var defaultCategories: [Groups]!
var groupsCoreData = BehaviorRelay&lt;[Groups]&gt;(value: [])

override func viewDidLoad() {
    super.viewDidLoad()
    searchBarRx()
    tableViewRx()
}

let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;String, Groups&gt;&gt;(
    configureCell: { (_, tv, indexPath, element) in
        let cell = tv.dequeueReusableCell(withIdentifier: ""addNewWordsToGroup"")!
        cell.textLabel?.text = element.title
        return cell
},
    titleForHeaderInSection: { dataSource, sectionIndex in
        return dataSource[sectionIndex].model
}
)

 private func tableViewRx() {
    let dataSource = self.dataSource

    let items = [
        SectionModel(model: ""Пример"", items: self.defaultCategories
            .filter { $0.titleCategories == ""Тест1""}),
        SectionModel(model: ""Пример2"", items: self.defaultCategories
            .filter { $0.titleCategories == ""Тест2"" })
        ]

    Observable.just(items)
        .bind(to: tableView.rx.items(dataSource: dataSource))
        .disposed(by: disposeBag)

    tableView
        .rx
        .modelSelected(Groups.self)
        .subscribe(onNext: { [weak self] data in
         }
        .disposed(by: disposeBag)
}

private func searchBarRx() {
    searchBar
        .rx
        .text
        .orEmpty
        .debounce(.microseconds(200), scheduler: MainScheduler.instance)
        .distinctUntilChanged()
        .subscribe { [unowned self] query in
            self.searchBar.showsCancelButton = query.element!.isEmpty
            self.defaultCategories = query.element!.isEmpty ? 
            self.defaultCategories : 
            self.defaultCategories
            .filter({ $0.title?.range(of: query.element!, options: .anchored) != nil
            })
        }
        .disposed(by: disposeBag)
}
</code></pre>

<p>query - displays the input characters, but no result. 
P.S. the arrays are not empty</p>
","5489635","","","","","2019-09-09 11:17:56","How to use RxDataSource with SearchBar?","<swift><rx-swift>","1","1","1","","","CC BY-SA 4.0"
"57842609","1","","","2019-09-08 13:58:18","","26","10754","<p>In RxSwift it's pretty easy to bind a <code>Driver</code> or an <code>Observable</code> in a <code>View Model</code> to some observer in a <code>ViewController</code> (i.e. a <code>UILabel</code>).</p>

<p>I usually prefer to build a pipeline, with observables <strong>created from other observables</strong>, instead of ""imperatively"" pushing values, say via a <code>PublishSubject</code>).</p>

<p>Let's use this example: <strong>update a <code>UILabel</code> after fetching some data from the network</strong></p>

<hr>

<h2>RxSwift + RxCocoa example</h2>

<pre class=""lang-swift prettyprint-override""><code>final class RxViewModel {
    private var dataObservable: Observable&lt;Data&gt;

    let stringDriver: Driver&lt;String&gt;

    init() {
        let request = URLRequest(url: URL(string:""https://www.google.com"")!)

        self.dataObservable = URLSession.shared
            .rx.data(request: request).asObservable()

        self.stringDriver = dataObservable
            .asDriver(onErrorJustReturn: Data())
            .map { _ in return ""Network data received!"" }
    }
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>final class RxViewController: UIViewController {
    private let disposeBag = DisposeBag()
    let rxViewModel = RxViewModel()

    @IBOutlet weak var rxLabel: UILabel!

    override func viewDidLoad() {
        super.viewDidLoad()

        rxViewModel.stringDriver.drive(rxLabel.rx.text).disposed(by: disposeBag)
    }
}
</code></pre>

<hr>

<h2>Combine + UIKit example</h2>

<p>In a UIKit-based project it seems like you can keep the same pattern:</p>

<ul>
<li>view model exposes publishers</li>
<li>view controller binds its UI elements to those publishers</li>
</ul>

<pre class=""lang-swift prettyprint-override""><code>final class CombineViewModel: ObservableObject {
    private var dataPublisher: AnyPublisher&lt;URLSession.DataTaskPublisher.Output, URLSession.DataTaskPublisher.Failure&gt;
    var stringPublisher: AnyPublisher&lt;String, Never&gt;

    init() {
        self.dataPublisher = URLSession.shared
            .dataTaskPublisher(for: URL(string: ""https://www.google.it"")!)
            .eraseToAnyPublisher()

        self.stringPublisher = dataPublisher
            .map { (_, _) in return ""Network data received!"" }
            .replaceError(with: ""Oh no, error!"")
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>final class CombineViewController: UIViewController {
    private var cancellableBag = Set&lt;AnyCancellable&gt;()
    let combineViewModel = CombineViewModel()

    @IBOutlet weak var label: UILabel!

    override func viewDidLoad() {
        super.viewDidLoad()

        combineViewModel.stringPublisher
            .flatMap { Just($0) }
            .assign(to: \.text, on: self.label)
            .store(in: &amp;cancellableBag)
    }
}
</code></pre>

<hr>

<h2>What about SwiftUI?</h2>

<p>SwiftUI relies on property wrappers like <code>@Published</code> and protocols like <code>ObservableObject</code>, <code>ObservedObject</code> to automagically take care of bindings (As of <em>Xcode 11b7</em>).</p>

<p>Since (AFAIK) property wrappers cannot be ""created on the fly"", there's no way you can re-create the example above using to the same pattern.
The following <strong>does not compile</strong></p>

<pre class=""lang-swift prettyprint-override""><code>final class WrongViewModel: ObservableObject {
    private var dataPublisher: AnyPublisher&lt;URLSession.DataTaskPublisher.Output, URLSession.DataTaskPublisher.Failure&gt;
    @Published var stringValue: String

    init() {
        self.dataPublisher = URLSession.shared
            .dataTaskPublisher(for: URL(string: ""https://www.google.it"")!)
            .eraseToAnyPublisher()

        self.stringValue = dataPublisher.map { ... }. ??? &lt;--- WRONG!
    }
}
</code></pre>

<p>The closest I could come up with is <strong>subscribing in your view model (UGH!)</strong> and <strong>imperatively update your property</strong>, which does not feel right and reactive at all.</p>

<pre class=""lang-swift prettyprint-override""><code>final class SwiftUIViewModel: ObservableObject {
    private var cancellableBag = Set&lt;AnyCancellable&gt;()
    private var dataPublisher: AnyPublisher&lt;URLSession.DataTaskPublisher.Output, URLSession.DataTaskPublisher.Failure&gt;

    @Published var stringValue: String = """"

    init() {
        self.dataPublisher = URLSession.shared
            .dataTaskPublisher(for: URL(string: ""https://www.google.it"")!)
            .eraseToAnyPublisher()

        dataPublisher
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: {_ in }) { (_, _) in
            self.stringValue = ""Network data received!""
        }.store(in: &amp;cancellableBag)
    }
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
    @ObservedObject var viewModel = SwiftUIViewModel()

    var body: some View {
        Text(viewModel.stringValue)
    }
}
</code></pre>

<p>Is the ""old way of doing bindings"" to be forgotten and replaced, in this new <strong>UIViewController-less</strong> world?</p>
","184899","","","","","2020-02-21 16:42:12","Best data-binding practice in Combine + SwiftUI?","<ios><swift><swiftui><rx-swift><combine>","4","2","4","","","CC BY-SA 4.0"
"57893606","1","57898542","","2019-09-11 16:47:44","","4","174","<p>I am learning <code>Viper</code> w/ <code>RxSwift</code>.</p>

<p>I would like to notify my <code>Presenter</code> that <code>viewDidLoad</code> was called in my <code>ViewController</code>.</p>

<p>To do this I have the following:</p>

<pre class=""lang-swift prettyprint-override""><code>class LoginPresenter {

    weak var view: LoginView?
    var interactor: LoginUseCase?
    var router: LoginRouter?

    private(set) var viewDidLoad = PublishSubject&lt;Void&gt;()

    private lazy var disposeBag = DisposeBag()

    required init(view: LoginView?, interactor: LoginUseCase?, router: LoginRouter?) {
        self.view = view
        self.interactor = interactor
        self.router = router

        viewDidLoad
            .subscribe(onNext: { _ in
                // do something on viewDidLoad
            }).disposed(by: disposeBag)
    }
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>class LoginViewController: UIViewController {

    var presenter: LoginPresenter?

    override func viewDidLoad() {
        super.viewDidLoad()

        presenter?.viewDidLoad.onNext(())
    }
}
</code></pre>

<p>Once my view is loaded I am calling <code>presenter?.viewDidLoad.onNext(())</code></p>

<p>I am then able to trigger any actions within my presenter, such as calling out to my <code>router</code> to ensure navigation is configured or my <code>interactor</code>.</p>

<p>Should I be using a <code>PublishSubject</code> for this? Or does <code>RxSwift</code> have a better suited type?</p>

<p>I feel like this approach means I will end up with something like</p>

<pre class=""lang-swift prettyprint-override""><code>        viewDidLoad
            .subscribe(onNext: { _ in
                self.router?.viewDidLoad.onNext(())
            }).disposed(by: disposeBag)
</code></pre>
","10823240","","","","","2021-04-26 11:24:00","Should I use a PublishSubject if I am notifying an action is complete?","<ios><swift><rx-swift><viper>","1","0","","","","CC BY-SA 4.0"
"57917211","1","57923074","","2019-09-13 04:14:00","","5","1406","<p>I have a UITableViewCell in which I have customContentView on tap of that I want to send a callback to the viewController. For this I am using RxSwift.</p>

<pre class=""lang-swift prettyprint-override""><code>class GISThemeFormTableCell: UITableViewCell {

    @IBOutlet weak var customContentView: UIView!

    var index = -1

    var cellSelected: Observable&lt;(Int, Bool)&gt;?
    private var observer: AnyObserver&lt;(Int, Bool)&gt;?

    override func awakeFromNib() {
        super.awakeFromNib()

        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(self.didSelectCell))
        customContentView.addGestureRecognizer(tapGesture)

        cellSelected = Observable&lt;(Int, Bool)&gt;.create { (observer) -&gt; Disposable in
            self.observer = observer
            return Disposables.create()
        }
    }

    @objc private func didSelectCell() {
        let newImage = selectionImageView.image! == Images.uncheckedRound ? Images.checkedRound : Images.uncheckedRound
        selectionImageView.image = newImage
        observer?.onNext((index, selectionImageView.image! == Images.checkedRound))
    }
}

class GISFormListView: UIView {

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
        switch indexPath.section {
        case 0:
            let cell = tableView.dequeueReusableCell(withIdentifier: ""GISThemeFormTableCell"", for: indexPath) as! GISThemeFormTableCell
            cell.index = indexPath.row
            cell.formTitle.text = presenter.getFormName(indexPath.row)

            cell.cellSelected?.subscribe { (event) in
                let index = event.element!.0
                let isSelected = event.element!.1

                print(index, isSelected)

            }.disposed(by: disposeBag)

            return cell

        case 1:
            let cell = tableView.dequeueReusableCell(withIdentifier: ""LoadingTableViewCell"", for: indexPath) as! LoadingTableViewCell
            return cell

        default:
            return UITableViewCell()
        }
    }
}

</code></pre>

<p>In above code I have created Observable in awakeFromNib method and I have initialised observer over there. Once the didSelectCell method is called I am passing the index of the cell and bool in the observer.</p>

<p>I just wanted to know if this is a correct to way to achive this if I don't want to use closures and delegates.</p>
","5744323","","4950794","","2019-09-13 05:12:54","2019-09-13 21:58:22","Sending callback using RxSwift from UITableViewCell to UIViewController","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"57951454","1","57953068","","2019-09-16 06:31:06","","2","1212","<p>I have 3 buttons </p>

<pre class=""lang-swift prettyprint-override""><code>@IBOutlet weak var editGeomButton: UIButton! // 1
@IBOutlet weak var editDataButton: UIButton! // 2
@IBOutlet weak var deleteDataButton: UIButton! // 3
</code></pre>

<p>On click of any of this buttons I want below method to be called. With the proper numbers.</p>

<pre class=""lang-swift prettyprint-override""><code>func didTap() -&gt; Observable&lt;Int&gt; {

}

didTap().subscribe(onNext: { (tag) in
    switch tag {
    case 1:
        print(""Did tap Edit Geom"")
    case 2:
        print(""Did tap Edit Data"")
    case 3:
        print(""Did tap Delete geom"")
    default:
        print(""Invalid tap"")
    }
}).disposed(by: disposeBag)
</code></pre>

<p>Please help with the code to write in didTap method using Observable? I think this can be achieved using combine operator. But I don't understand how to code this.</p>
","5744323","","","","","2019-09-16 08:30:34","combining tap event of 3 buttons with rxSwift","<swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"57964876","1","57965014","","2019-09-16 21:56:16","","2","755","<p>I want to give my textfield a Currency format so when I type it looks like:</p>
<p>$0.00 <br>
$0.09 <br>
$0.98 <br>
$9.87 <br>
$98.76 <br></p>
","5004503","","5004503","","2021-04-22 09:54:50","2021-04-22 09:54:50","Change format of a textfield on the fly using RxSwift","<ios><swift><rx-swift><rx-cocoa>","1","4","","2019-09-17 01:40:48","","CC BY-SA 4.0"
"57971119","1","57972503","","2019-09-17 09:17:25","","1","720","<p>I need to bind a tuple(String, Int) to view model</p>

<pre><code>class ViewModel {

var firstAttempt = PublishSubject&lt;(password: String, count: Int)&gt;()
var isValidFirstAttempt: Observable&lt;Bool&gt; {
    return firstAttempt.asObservable().map{
        if $0.count &lt; 4 {
            self.onShowError.onNext(""error"")
            return false
        }
        return true
    }
}
let onShowError = PublishSubject&lt;String&gt;()
</code></pre>

<p>View controller</p>

<pre><code>class ViewController: UIViewController {

var viewModel =  ViewModel()
var firstAttempt = BehaviorRelay&lt;(value:String, count: Int)&gt;(value: ("""", 0))

func bindControllerComponent() {
    firstAttempt.bind(to: viewModel.firstAttempt).disposed(by: disposeBag)
    viewModel.firstAttempt.bind(to: firstAttempt).disposed(by: disposeBag)
}
</code></pre>

<p>with executing <code>self.firstAttempt.accept((""password"", 4))</code> in view controller I want to get changes in view model
is it possible?</p>
","5391914","","","","","2019-09-17 11:53:07","Bind a tuple or string in view controller to view model with RXSwift","<ios><swift><mvvm><binding><rx-swift>","1","1","","","","CC BY-SA 4.0"
"57991839","1","","","2019-09-18 11:35:22","","0","1610","<p>i have initialized an empty observable like this:</p>

<pre class=""lang-swift prettyprint-override""><code>var subCategories = Observable&lt;[String]&gt;.empty()
</code></pre>

<p>How can i check if the observable is empty or not? I would like to show a ""empty view"" to the user if the observable is empty else show the data in tableview.</p>
","5753078","","4149826","","2019-09-18 13:10:06","2020-08-14 08:11:33","How to check if an observable is empty in RXSwift?","<swift><uitableview><observable><rx-swift><rx-cocoa>","2","1","","","","CC BY-SA 4.0"
"58025264","1","58040151","","2019-09-20 09:08:33","","1","465","<p>I am passing API response with Moya and getting this value. I am able to get the object but I extented a base response to handle extra parameters but the extended value does not seem to work. The data expected could be an array of objects and it could just be a regular object. After passing this values, It stopped working and data is not got but every other parameter like <code>status</code> , <code>message</code> are passed except <code>data</code>. Here is my Base response and how I used it</p>

<pre><code>class MaxResponseBase: Codable {
    var status: String?
    var message: String?
    var pagination: Pagination?

    var isSucessful: Bool {
        return status == ""success""
    }

    struct ErrorMessage {
        static let passwordInvalid = "" Current password is invalid.""
        static let loginErrorIncorrectInfo = "" Incorrect username/password.""
        static let loginErrorAccountNotExist = "" Invalid request""
    }
}

class MaxResponse&lt;T: Codable&gt;: MaxResponseBase {
    var data: T?
}

class MaxArrayResponse&lt;T: Codable&gt;: MaxResponseBase {
    var data = [T]()
}
</code></pre>

<p>Here is my API call for signin for example</p>

<pre><code>func signin(email: String, password: String) -&gt; Observable&lt;MaxResponse&lt;AuthResponse&gt;&gt; {
        return provider.rx.request(.signin(username: email, password: password))
            .filterSuccess()
            .mapObject(MaxResponse&lt;AuthResponse&gt;.self)
            .asObservable()
    }
</code></pre>

<p>how can I tweak this to get data object also</p>

<p>JSON</p>

<pre><code>{
  ""status"" : ""success"",
  ""data"" : {
    ""is_locked"" : false,
    ""__v"" : 0,
    ""created_at"" : ""2019-04-15T11:57:12.551Z""
  }
}
</code></pre>

<p>It could also be an array of data</p>
","8310287","","8310287","","2019-09-20 11:07:25","2019-09-21 13:38:04","Extending a class model for generic type Swift","<swift><rx-swift><moya>","1","5","","","","CC BY-SA 4.0"
"58035329","1","58037574","","2019-09-20 21:21:49","","0","80","<p>In <code>rxswift</code> I can't send one parameter to <code>CombineLatest</code>. What should I use for one parameter?</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import RxSwift

struct RegisterPhoneViewModel {

    var phoneNumberText = Variable&lt;String&gt;("""")

    var isValid: Observable&lt;Bool&gt; {
        return Observable.combineLatest(phoneNumberText.asObservable()) {phoneNum in
            phoneNum.count &gt;= 11
        }
    }
}
</code></pre>
","11237305","","","","","2019-09-21 05:37:21","In rxswift I can't send one parameter to CombineLatest. What should I use for one parameter?","<swift><mvvm><rx-swift>","1","2","","","","CC BY-SA 4.0"
"58047235","1","59527929","","2019-09-22 08:01:51","","3","3192","<p>I need a thirty-second time counter with <code>RxSwift</code>.
This is a duplicate question but there is no clear answer to the questions</p>
","11237305","","","","","2020-09-24 13:39:18","countdown timer by `RxSwift`","<swift><rx-swift>","3","1","","","","CC BY-SA 4.0"
"58050998","1","58051483","","2019-09-22 16:05:06","","0","249","<p>I have manager class which will connect and manage the data and state of the Bluetooth device.</p>

<p>The manager class conforms to IWDeviceManagerDelegate and has a method which gives the weight data <code>func onReceiveWeightData(_ device: IWDevice!, data: IWWeightData!)</code>.</p>

<p>Once I call <code>listenToWeight()</code> from any controller I want to give the data using Observable. </p>

<p>How I fire an onNext event with the data of <code>onReceiveWeightData</code> method to <code>listenToWeight</code> observable?</p>

<p>Below is the code.</p>

<pre class=""lang-swift prettyprint-override""><code>class WeightMachineManager: NSObject {

    func setup() {
        IWDeviceManager.shared()?.delegate = self
        IWDeviceManager.shared()?.initMgr()
    }

    func listenToWeight() -&gt; Observable&lt;IWWeightData&gt; {
        let tag = WeightMachineManager.tag
        if let connectedDevice = connectedDevice {
            IWDeviceManager.shared()?.add(connectedDevice, callback: { (device, code) in
                if code == .success {
                    print(""\(tag)[SUCCESS] Device added successfully."")
                } else {
                    print(""\(tag)[FAILURE] Failed to add device."")
                }
            })
        } else {
            print(""\(tag)[FAILURE] Couldn't find any device to connect."")
        }
    }
}

extension WeightMachineManager: IWDeviceManagerDelegate {
    func onReceiveWeightData(_ device: IWDevice!, data: IWWeightData!) {
        // TODO:- Pass this data in the onNext event of listenToWeight's observable.
    }
}
</code></pre>
","5744323","","5744323","","2019-09-22 16:26:21","2019-09-22 17:00:20","How to pass data from delegate method to the observable's onNext method in RxSwift?","<swift><observable><rx-swift><reactive>","1","4","","","","CC BY-SA 4.0"
"58076617","1","58077665","","2019-09-24 08:58:34","","0","19","<p>I get a HTML page from my NodeJS instance with the signature:</p>

<pre><code>public func requestHTMLPage(_ page: String) -&gt; Observable&lt;String?&gt; 
</code></pre>

<p>but I've got some cached HTML pages so want to return them.</p>

<p>I'd like to return my cached page</p>

<pre><code>if let cachedPage = cachedPage {
    return BehaviorSubject&lt;String?&gt;(value: data)
}
</code></pre>

<p>but unfortunately it does not tell my subscribers that the data is returned.</p>

<p>I've used the following awful solution:</p>

<pre><code>if let cachedPage = cachedPage {
    observer.onNext(data)
    return BehaviorSubject&lt;String?&gt;(value: data)
}
</code></pre>

<p>as I want to tell my observer we have the data, but also I want to return as we are at the end of this path of execution.</p>

<p>How can I return and give the type Observable after I have made my observer.onNext, or how can I return with just observer.onNext? </p>
","11076699","","","","","2019-09-24 09:55:47","Return BehaviourSubject in RXSwift","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"58098162","1","58116213","","2019-09-25 12:15:47","","1","202","<p>I am implementing <code>HasDelegate</code> protocol to the <code>IWDeviceManager</code>.</p>

<p>In all the posts which I have read, no one has wrote getter &amp; setter for this <code>public var delegate</code> property. </p>

<p>The compiler is explicitly asking me to write getter &amp; setter for <code>public var delegate</code>. Why it's required in my case?</p>

<p>I tried writing but my code crashes when I try to get or set the delegate.</p>

<p>How do I solve this issue?</p>

<p>I have shared the code below</p>

<pre class=""lang-swift prettyprint-override""><code>extension IWDeviceManager: HasDelegate {

    public typealias Delegate = IWDeviceManagerDelegate

    // Compiler explicitly asks to write getter and setter for this.
    public var delegate: IWDeviceManagerDelegate? { 
        get { // Crashes here
            return IWDeviceManager.shared()?.delegate 
        } 
        set(newValue) { // crashes here
            IWDeviceManager.shared()?.delegate = newValue 
        } 
    }
}
</code></pre>

<p>Below is interface for IWDeviceManager</p>

<pre class=""lang-swift prettyprint-override""><code>open class IWDeviceManager : NSObject {

    weak open var delegate: IWDeviceManagerDelegate!

    open class func shared() -&gt; Self!

    open func initMgr()

    open func initMgr(with config: IWDeviceManagerConfig!)

}
</code></pre>
","5744323","","5744323","","2019-09-26 11:48:16","2019-09-26 11:49:59","How to write getter and setter for HasDelegate protocol in RxSwift?","<rx-swift><rx-cocoa>","1","5","","","","CC BY-SA 4.0"
"58105595","1","","","2019-09-25 19:47:07","","8","3255","<p>I have two frameworks in my project, each of which depend on the same Swift package (in this case RxSwift, but I don't think that's important).</p>

<p>To get the project to build I've had to include the same package in both targets (via the ""Frameworks and Libraries"" list in the target's General settings) - otherwise when I try to import the package it can't find it.</p>

<p>When I run my app I see warnings in the console like:</p>

<pre><code>objc[79287]: Class _TtC9Alamofire18UploadTaskDelegate is implemented in both

/Users/deanWombourne/Desktop/PackageManagerTest/DerivedData/PackageManagerTest/
Build/Products/Debug-iphonesimulator/Framework1.framework/Framework1 (0x110877e00)

and

/Users/deanWombourne/Library/Developer/CoreSimulator/Devices/2319A320-1A01-4784-B85E-272FF0F999CB/
data/Containers/Bundle/Application/D40DE3EA-DD78-4241-B307-070CDAF8BFA1/PackageManagerTest.app/PackageManagerTest (0x10f9858c8).

One of the two will be used. Which one is undefined.
</code></pre>

<p>and, sometimes, the app crashes in the package which is duplicated.</p>

<p>I've tested the app by building a version without the duplicate package issue (copy/paste all code into the same target!) and it runs fine then, so this is something to do with the duplicate package issue.</p>

<p>So, what's my question?</p>

<p>Is there any way in Xcode to specify that a single package will be included in two targets, but not to just copy it twice into the executable? </p>

<p>I'd ideally like to specify it as a dynamic library of some sort so it's not baked into the executable at all but is loaded on demand - but any solution is welcome at this point!</p>

<hr>

<p>EDIT</p>

<p>I also get this issue if I have only one framework but it shares the RxSwift package dependency with the main app target.</p>
","13000","","13000","","2019-09-26 10:16:31","2019-10-10 00:27:55","swift package in two targets in Xcode causes duplicate symbols","<ios><swift><xcode><rx-swift><swift-package-manager>","1","2","6","","","CC BY-SA 4.0"
"58120075","1","58126527","","2019-09-26 15:24:41","","2","775","<p>I currently have a network client that looks like the below:</p>

<pre><code>class Client&lt;R: ResourceType&gt; {

    let engine: ClientEngineType
    var session: URLSession

    init(engine: ClientEngineType = ClientEngine()) {
        self.engine = engine
        self.session = URLSession.shared
    }

    func request&lt;T: Codable&gt;(_ resource: R) -&gt; Single&lt;T&gt; {
        let request = URLRequest(resource: resource)

        return Single&lt;T&gt;.create { [weak self] single in
            guard let self = self else { return Disposables.create() }
            let response = self.session.rx.response(request: request)

            return response.subscribe(
                onNext: { response, data in

                    if let error = self.error(from: response) {
                        single(.error(error))
                        return
                    }

                    do {
                        let decoder = JSONDecoder()
                        let value = try decoder.decode(T.self, from: data)
                        single(.success(value))
                    } catch let error {
                        single(.error(error))
                    }
            },
                onError: { error in
                    single(.error(error))
            })
        }
    }

    struct StatusCodeError: LocalizedError {
        let code: Int

        var errorDescription: String? {
            return ""An error occurred communicating with the server. Please try again.""
        }
    }

    private func error(from response: URLResponse?) -&gt; Error? {
        guard let response = response as? HTTPURLResponse else { return nil }

        let statusCode = response.statusCode

        if 200..&lt;300 ~= statusCode {
            return nil
        } else {
            return StatusCodeError(code: statusCode)
        }
    }
}
</code></pre>

<p>Which I can then invoke something like</p>

<pre><code>let client = Client&lt;MyRoutes&gt;()
client.request(.companyProps(params: [""collections"": ""settings""]))
    .map { props -&gt; CompanyModel in return props }
    .subscribe(onSuccess: { props in
      // do something with props
    }) { error in
        print(error.localizedDescription)
}.disposed(by: disposeBag)
</code></pre>

<p>I'd like to start handling <code>401</code> responses and refreshing my token and retrying the request.</p>

<p>I'm struggling to find a nice way to do this.</p>

<p>I found <a href=""https://gist.github.com/danielt1263/68097ac187cd43c23945bc6c15f5cc0b"" rel=""nofollow noreferrer"">this excellent gist</a> that outlines a way to achieve this, however I am struggling to implement this in my current client.</p>

<p>Any tips or pointers would be very much appreciated.</p>
","11709138","","","","","2019-09-27 01:36:45","Handling 401 status w/ RxSwift & URLSession","<swift><rx-swift><urlsession><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"58164818","1","","","2019-09-30 09:15:48","","0","650","<p>I do not know RxSwift well enough, and could not figure out my problem on my own. I would be very grateful for the help. Sorry for my English.</p>

<pre><code>//declare variables    

var loadedImage = BehaviorRelay&lt;UIImage?&gt;(value: nil)

//Subscribe when creating a cell

loadedImage
            .do(onNext: { (_) in
                cell.activityIndicator.startAnimating()
                cell.activityIndicator.isHidden = false
            })
            .flatMap { (image) -&gt; Observable&lt;String&gt; in
                guard let image = image else { return Observable.just("""") }
                return service.uploadPhoto(image: image)
            }
            .observeOn(MainScheduler.instance)
            .subscribeNext { (imageName) in
                vc.createEventData.imageName = imageName

                cell.activityIndicator.stopAnimating()
                cell.activityIndicator.isHidden = true

                let currentPhoto = self.object?.placeholderPhoto
                let image = self.loadedImage.value

                cell.photoEventImageView.image = image == nil ? currentPhoto : image

                if let photoPath = self.object?.photoPath, image == nil {
                    if photoPath != ""uploads/photos/.png"" {
                        let url = URL(string: ""http://test-around.profsoft.online/"" + photoPath)
                        cell.photoEventImageView.kf.setImage(with: url)

                        if let r = photoPath.range(of: ""/"", options: .backwards) {
                            let imageName = photoPath.substring(from: r.upperBound)
                            vc.createEventData.imageName = imageName
                        }
                    }
                }

            }
            .disposed(by: disposeBag)

//I throw a signal when choosing a photo

   func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
        guard let image = info[.originalImage] as? UIImage else { return }
        loadedImage.accept(image)
        self.viewController?.dismiss(animated: true, completion: nil)
    }
</code></pre>

<p>I can’t understand why the subscription occurs 2 times. That is, I go to service.uploadPhoto (image: image) twice.</p>
","11930520","","11112788","","2019-09-30 09:19:27","2020-01-20 12:52:47","RxSwift. Subscription occurs twice","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"58176871","1","58199394","","2019-10-01 00:57:17","","1","741","<p>I need to combine chat message in section when items send in one minutes.</p>

<p>ViewModel</p>

<p>.....</p>

<pre><code>.scan([MessageSectionModel]()) { sectionModels, messageItem in
        var models = sectionModels

        if let lastSectionModel = sectionModels.last {
            switch lastSectionModel {
            case .incomingSection(var items):
                if messageItem.0.isIncoming {
                    items.append(messageItem.0)
                    models[models.count-1] = .incomingSection(items: items)
                } else {
                    models.append(.outcomingSection(items: [messageItem.0]))
                }

            case .outcomingSection(var items):
                if messageItem.0.isIncoming {
                    models.append(.incomingSection(items: [messageItem.0]))
                } else {
                    items.append(messageItem.0)
                    models[models.count-1] = .outcomingSection(items: items)
                }
            }
            return models
        }

        if messageItem.0.isIncoming {
            models.append(.incomingSection(items: [messageItem.0]))
        } else {
            models.append(.outcomingSection(items: [messageItem.0]))
        }
        return models
    }
</code></pre>

<p>.....</p>

<p>ViewController</p>

<p>....</p>

<pre><code>@IBOutlet private weak var messagesTableView: UITableView!

private let disposeBag = DisposeBag()
private var dataSource: RxTableViewSectionedAnimatedDataSource&lt;MessageSectionModel&gt;!

private let messageHeaderReuseIdentifier = String(describing: MessageHeaderView.self)
private let messageFooterReuseIdentifier = String(describing: MessageFooterView.self)

dataSource = RxTableViewSectionedAnimatedDataSource&lt;MessageSectionModel&gt;(
        animationConfiguration: .init(insertAnimation: .none, reloadAnimation: .none, deleteAnimation: .none),
        configureCell: { dataSource, tableView, indexPath, item in

            switch dataSource.sectionModels[indexPath.section] {
            case .incomingSection:
                guard let cell = tableView.dequeueReusableCell(
                    withIdentifier: R.reuseIdentifier.incomingMessageTableViewCell,
                    for: indexPath
                ) else {
                    return UITableViewCell()
                }

                let isFirst = indexPath.row == dataSource[indexPath.section].items.count - 1

                cell.bind(
                    messageText: item.text,
                    isFirstInSection: isFirst
                )

                return cell
            case .userSection:
                guard let cell = tableView.dequeueReusableCell(
                    withIdentifier: R.reuseIdentifier.outcomingMessageTableViewCell,
                    for: indexPath
                ) else {
                     return UITableViewCell()
                }

                cell.bind(
                    messageText: item.text,
                    isFirstInSection: indexPath.row == dataSource[indexPath.section].items.count - 1
                )

                return cell
            }
    })
</code></pre>

<p>....</p>

<p>Message items</p>

<p>....</p>

<pre><code> import Foundation
 import RxDataSources

 enum MessageSectionModel {
    case incomingSection(items: [MessageSectionItem])
    case outcomingSection(items: [MessageSectionItem])

 var lastMessageDate: Date {
    switch self {
    case .incomingSection(let items):
        return items.last?.sentDate ?? Date()
    case .outcomingSection(let items):
        return items.last?.sentDate ?? Date()
    }
   }
 }

struct MessageSectionItem {
   let userId: String
   let id: String = UUID().uuidString
   let text: String
   let sentDate: Date
  let isIncoming: Bool
}

extension MessageSectionItem: IdentifiableType {
   var identity : String {
       return id
  }
}

extension MessageSectionItem: Equatable {
   static func == (lhs: MessageSectionItem, rhs: MessageSectionItem) -&gt; Bool {
     return lhs.identity == rhs.identity
   }
  }

extension MessageSectionModel: AnimatableSectionModelType {
   init(original: MessageSectionModel, items: [MessageSectionItem]) {
     switch original {
    case .incomingSection(let items):
        self = .incomingSection(items: items)
    case .outcomingSection(let items):
        self = .outcomingSection(items: items)
    }
 }

typealias Item = MessageSectionItem

var items: [MessageSectionItem] {
    switch self {
    case .incomingSection(let items):
        return items.map { $0 }
    case .outcomingSection(let items):
        return items.map { $0 }
    }
}

var identity: Date {
    return lastMessageDate
 }
}
</code></pre>

<p>....</p>

<p>My table view is rotated because i fetch messages is reverted. I understand it`s my mistake in scan, because when i comments this code, my cells sorted in correct way, but not combined in sections. </p>

<pre><code>   if let lastSectionModel = sectionModels.last {
         switch lastSectionModel {
         case .incomingSection(var items):
            if messageItem.0.isIncoming {
                items.append(messageItem.0)
                models[models.count-1] = .incomingSection(items: items)
            } else {
                models.append(.outcomingSection(items: [messageItem.0]))
            }

        case .outcomingSection(var items):
            if messageItem.0.isIncoming {
                models.append(.incomingSection(items: [messageItem.0]))
            } else {
                items.append(messageItem.0)
                models[models.count-1] = .outcomingSection(items: items)
            }
        }
        return models
</code></pre>
","10325152","","1839439","","2019-10-06 14:56:24","2019-10-06 14:56:24","How I can correctly combine items in section with RxDataSource swift?","<swift><rx-swift><rxdatasources>","1","0","","","","CC BY-SA 4.0"
"58229726","1","","","2019-10-04 03:58:59","","-1","101","<p>I recently started working using RxSwift. I do have some basic knowledge now. I have a view controller for which I have created corresponding View model and I have some properties defined and are bound to some labels on the view in view controller. This binding works fine.</p>

<p>I also have some custom controls which are added dynamically into a scrollview in the view controller based on certain conditions in the api response. Since the API call is made through view model, view model would have the complete response and is straight forward to set the properties which are bound with the labels controls on the view. Here is the scenario for which I need some idea or hints</p>

<p>Based on some flags in the API response I need to tell view to dynamically add custom control A, B, C into the scroll view and pass the required data to the custom controls to populate. And the data to be passed to custom controls is with view model.</p>

<p>Is it recommended to create view model even for custom controls? If yes, how can I manage to handle the above scenario and comply with MVVM pattern using RxSwift. Basically since the complete data is with view model of the view controller, how to share this data with custom controls in the best possible way and at the same time comply with MVVM pattern and keep the code structured.</p>
","10360782","","","","","2019-10-04 05:17:02","Adding Dynamic custom controls into view with RxSwift from View model","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58231036","1","","","2019-10-04 06:31:30","","1","739","<p>I have a Model class like below:</p>

<pre><code>class Model{
    var currentTemparature:String?
    var minTemparature:String?
    var maxTemparature:String?

    init(currentTemparature:String,minTemparature:String,maxTemparature:String) {
        self.currentTemparature = currentTemparature
        self.maxTemparature = maxTemparature
        self.minTemparature = minTemparature
    }
}
</code></pre>

<p>I want to bind each of these properties to an UILabel in the ViewController using RXSwift.</p>

<p>For Example:</p>

<pre><code>class ViewController:UIViewController{
    @IBOutlet var currentTemparatureLabel: UILabel!
    @IBOutlet var minTemparatureLabel: UILabel!
    @IBOutlet var maxTemparatureLabel: UILabel!

    func UpdateLabels(){
        let model = Model.init(currentTemparature: ""25"", minTemparature: ""20"", maxTemparature: ""30"")
        currentTemparatureLabel.text = model.currentTemparature
        minTemparatureLabel.text = model.minTemparature
        maxTemparatureLabel.text = model.maxTemparature
    }
}
</code></pre>

<p>When ever the value of the model's properties changes, i want to update the label. How can i achieve that?</p>
","7720650","","1226963","","2019-10-04 15:38:52","2019-10-04 15:38:52","How to bind Object's property to an UIlabel using RXSwift?","<swift><rx-swift>","1","3","","","","CC BY-SA 4.0"
"58233023","1","58244473","","2019-10-04 08:54:02","","2","52","<p>I have MainViewController that contains ContainerView.
and ContainerView have embeded segue that indicate ThirdViewController </p>

<p>In ThirdViewController, I create PublishSubject, If I select something in PickerView then emit the value into PublishSubject.
<a href=""https://i.stack.imgur.com/rMh9d.jpg"" rel=""nofollow noreferrer"">enter image description here</a></p>

<p>then MainViewController subscribe PublishSubject from ThirdViewController.</p>

<p>so if this success , in MainViewController I will get value from PickerView. </p>

<p>But my problem is I can't get anything, even maybe can't subscribe.</p>

<p>what is problem??? what can I do ???</p>

<p>MainViewController </p>

<pre><code>if  let thirdVC = self.storyboard?.instantiateViewController(withIdentifier:""ThirdViewController"") as? ThirdViewController {
                    print(""third segue success"")

                    thirdVC.selectFeelingSubject.subscribe(onNext : {
                        print($0)

                    }).disposed(by: self.disposeBag)
</code></pre>

<p>ThirdViewController </p>

<pre><code>var selectFeelingSubject = PublishSubject&lt;String&gt;()



 func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {

    selectFeelingSubject.onNext(feelingArray[row])

}
</code></pre>
","11191573","","","","","2019-10-05 00:34:31","I can't subscribe publishSubject from embed view controller in swift","<rx-swift>","1","0","1","","","CC BY-SA 4.0"
"58244561","1","58244735","","2019-10-05 00:57:43","","2","101","<p>I have a custom control which holds UICollectionView. This custom control has its own view model. I am using RXswift for MVVM design. </p>

<p>The view model class looks as below</p>

<pre><code>class CalendarViewModel {

    public var calendarNDays = PublishSubject&lt;[CalendarControlDayModel]&gt;()

    struct CalendarControlDayModel {
        var date: String = """"
        var day: Int = 0
        var name: String = """"
    }

}
</code></pre>

<p>The custom control is called calendarView in which I am creating an instance of the above view model and setting up the binding to populate data in the collection view.</p>

<p>The method to set up binding in the custom control looks as below.</p>

<pre><code>func setUpBinding() {

        calendarViewModel.calendarNDays.bind(to: collectionView.rx.items(cellIdentifier: cellReuseIdentifier, cellType: CalendarViewCell.self)) {  (row,calendarDay,cell) in
            cell.calendarDay = calendarDay
            }.disposed(by: disposeBag)

    }
</code></pre>

<p>But I am getting a compilation error for the above method that reads ""items' produces '(Source) -> Disposable', not the expected contextual result type '(_) -> _""</p>

<p>If I define calendarNDays as a publishSubject within the custom control, it does not complain. Any hints on what is wrong here. I want to setup the binding with a property defined in view model inorder to display collection view items and inorder to conform with MVVM design pattern.</p>
","12166985","","","","","2019-10-05 01:44:37","items' produces '(Source) -> Disposable', not the expected contextual result type '(_) -> _' error with UICollectionLayout","<ios><rx-swift>","1","2","","","","CC BY-SA 4.0"
"58246679","1","58247756","","2019-10-05 08:38:36","","1","681","<p>Well i am pretty much new to reactive programming. problem is, I have a function(A) which returns an object , now I have another function(B) which subscribes returning object from function A and I make function B also as returning an other object in that subscribe, now this whole return this is not work. I have no idea why is happening.
Any help would be appreciated. Thanks
<strong>Function A</strong></p>

<pre><code>func getClassById(classId: Int) -&gt; Observable&lt;Bool&gt; {
    return Observable.create{[weak self] observer -&gt; Disposable in            Alamofire.request(""URL"", method:.get, parameters: nil, encoding: JSONEncoding.default, headers: self!.getRequestHeader())
            .validate()
            .responseJSON{ response in
                switch response.result {
                    do {
                        let assingnedClass = try JSONDecoder().decode(AssignedClassModel.self, from: data)
                        observer.onNext(true)
                    } catch {
                        observer.onError(error)
                    }
                case .failure(let error):
                    observer.onError(error)
                }
        }
        return Disposables.create()
    }
}
</code></pre>

<p><strong>Function B</strong></p>

<pre><code>func getAssignedClassData(classId: Int) -&gt; Observable&lt;[StudentModel]&gt;  { 
    return Observable.create{[weak self] observer -&gt; Disposable in // from here code is not going further.
    APIService.singelton
        .getClassById(classId: classId)
        .asObservable()
        .subscribe(onNext: { [weak self] assingnedClass in
            let studentsData = Array(Database.singleton.fetchStudents(byCLassId: classId))
            print(studentsData)
            observer.onNext(studentsData)
            }, onError: { error in
                print(error)
        }).disposed(by: self!.disposeBag)
        return Disposables.create()
        }
}
</code></pre>

<p><strong>Function B2</strong></p>

<pre><code>    func getAssignedClassData(classId: Int) -&gt; Observable&lt;[StudentModel]&gt;  {
        return APIService.singelton
            .getClassById(classId: classId)
            .do(onError: { error in
                print(error)
            })
            .map({ [weak self] assingnedClass in
                return Array(Database.singleton.fetchStudents(byCLassId: classId))
// this code will not be triggered as it is after return. 
                let vc = UIStoryboard.init(name: ""Main"", bundle: Bundle.main).instantiateViewController(withIdentifier: ""tabBarVC"") as? TabBarViewController
                let transition = CATransition()
                transition.duration = 0.5
                transition.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.default)
                transition.type = CATransitionType.fade
                self?.navigationController?.view.layer.add(transition, forKey: nil)
                self?.navigationController?.pushViewController(vc!, animated: true)

            })
    }
</code></pre>
","12139340","","12139340","","2019-10-05 16:20:40","2019-10-07 21:02:55","Return Observer.create Not returning and code next to it not working using RxSwift","<ios><swift><reactive-programming><rx-swift>","1","1","","","","CC BY-SA 4.0"
"58292631","1","","","2019-10-08 19:09:16","","0","476","<p>I attempted to set <code>modalPresentationStyle</code> to .fullscreen following the Apple Documentation.</p>

<p>After setting the <code>modalPresentationStyle</code> to <code>.fullscreen</code> shown in the code below, the system still presents the viewControllers in <code>UIModalPresentationStyle.automatic</code> ""the system default"" </p>

<pre><code>//Presentation Style
let homeVC = HomeController(viewModel: viewModel)
homeVC.modalPresentationStyle = UIModalPresentationStyle.fullScreen
</code></pre>

<p>A framework called XCoordinator controls navigation within this application, here is an example on how it is done.</p>

<pre><code>switch route { 
case .home: 

let viewModel = HomeViewModelImpl(router: anyRouter) 
let viewController = HomeController(viewModel: viewModel) 

return .push(viewController)

}
</code></pre>
","11243557","","11243557","","2019-10-08 21:53:04","2019-10-11 15:59:50","How to: Change UIModalPresentationStyle from .automatic to .fullscreen for a UIViewController","<ios><swift><rx-swift><ios13><uimodalpresentationstyle>","1","10","","","","CC BY-SA 4.0"
"58295322","1","58310847","","2019-10-08 23:51:21","","-1","262","<p>Building an App which is using <code>Alamofire</code> and <code>Realm</code> for Network call and data storage respectively with help of <code>RxSwift</code>. Every thing is working fine but the need of the day is to prevent always refresh views on network call. For now app's behaviour is like I replicate JSON response to DB and then update views from DB. But to always get latest response app needs to call Network API on every <code>viewWillAppear</code>. But I don't want to get all DB data and search if there is something changed from new response and then display it. So is there any thing in <code>Swift</code> or <code>Alamofire</code> or <code>Realm</code> that I can observe on if the data is different from previously loaded in database and then only app will update its view.</p>

<pre><code>                self?.notificationToken = Database.singleton.fetchStudentsForAttendence(byCLassId: classId).observe { [weak self] change in
                switch change {
                case .initial(let initial):
                    TestDebug.debugInfo(fileName: """", message: ""INIT: \(initial)"")
                    self!.viewModel.getStudentsData(id: classId)
                case .update(_, let deletions, let insertions, let modifications):
                    print(modifications)
                    TestDebug.debugInfo(fileName: """", message: ""MODIFY: \(modifications)"")
                    TestDebug.debugInfo(fileName: """", message: ""MODIFY: \(insertions)"")
                case .error(let error):
                    TestDebug.debugInfo(fileName: """", message: ""ERROR:\(error)"")
                }
            }
</code></pre>

<p>this is how I am observing data now, but As I every time save response into database when I call the API, and I am using <code>case .initial</code> to monitor that and as database always have been refreshed and this block calls every time. I need something that monitors that data value changed in DB. Is there something in Realm for that ?</p>

<p><a href=""https://i.stack.imgur.com/VcUFF.gif"" rel=""nofollow noreferrer"">Link to GIF</a></p>

<p>Okay I am doing it like this, there is a viewController in which i have a container view which has Collection view as a child View. </p>

<pre><code>private lazy var studentsViewController: AttandenceView = {
    let storyboard = UIStoryboard(name: ""Main"", bundle: Bundle.main)
    var viewController = storyboard.instantiateViewController(withIdentifier: ""attendenceCV"") as! AttandenceView
    self.add(asChildViewController: viewController, to: studentsView)
    return viewController
}()  //this way I am adding collectionView's container view.
</code></pre>

<p>here is the ViewModel code from where I am geting my data and creating an observable for CollectionView.</p>

<pre><code>class AttendenceVM {

    //MARK: Properties
    let disposeBag = DisposeBag()
    let studentCells = BehaviorRelay&lt;[StudentModel]&gt;(value: [])

    var studentCell : Observable&lt;[StudentModel]&gt; {
        return studentCells.asObservable().debug(""CELL"")
    }

    var notificationToken : NotificationToken? = nil

    deinit {
        notificationToken?.invalidate()
    }
    func getStudentsData(id: Int) {
        let studentsData = (Database.singleton.fetchStudentsForAttendence(byCLassId: id))
        self.notificationToken = studentsData.observe{[weak self] change in
            TestDebug.debugInfo(fileName: """", message: ""Switch:::: change"")
            switch change {
            case .initial(let initial):
                TestDebug.debugInfo(fileName: """", message: ""INIT: \(initial)"")
                self!.studentCells.accept(Array(studentsData))
            case .update(_, let deletions, let insertions, let modifications):
                TestDebug.debugInfo(fileName: """", message: ""MODIF::: \(modifications)"")
                self!.studentCells.accept(Array(studentsData))
            case .error(let error):
                print(error)
            }
        }
        //self.studentCells.accept(studentsData)
    }
}
</code></pre>

<p>then I am population collectionView in its class separately, by doing this.</p>

<pre><code>class AttandenceView: UIViewController, UICollectionViewDelegateFlowLayout {

    //MARK: - Outlets
    @IBOutlet weak var studentsView: UICollectionView!

    let studentCells = BehaviorRelay&lt;[StudentModel]&gt;(value: [])
    let scanStudentCells = BehaviorRelay&lt;[ClassStudent]&gt;(value: [])



    private let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        let flowLayout = UICollectionViewFlowLayout()
        let size = CGSize(width: 105, height: 135)
        flowLayout.itemSize = size
        studentsView.setCollectionViewLayout(flowLayout, animated: true)
        studentsView.rx.setDelegate(self).disposed(by: disposeBag)
        setupBinding()
    }

    func setupBinding() {

        studentsView.register(UINib(nibName: ""StudentCVCell"", bundle: nil), forCellWithReuseIdentifier: ""studentCV"")


            //Cell creation
            scanStudentCells.asObservable().debug(""Cell Creation"").bind(to: studentsView.rx.items(cellIdentifier: ""studentCV"", cellType: StudentCVCell.self)) {
                (row , element, cell) in
                if (element.attandance == 1 ) {
                    // update view accordingly
                } else if (element.attandance == 0) {
                    // update view accordingly
                } else if (element.attandance == 2) {
                     // update view accordingly  

                }
                cell.viewModel2 = element
                }.disposed(by: disposeBag)

            //Item Display
            studentsView.rx
                .willDisplayCell
                .subscribe(onNext: ({ (cell,indexPath) in
                    cell.alpha = 0
                    let transform = CATransform3DTranslate(CATransform3DIdentity, -250, 0, 0)
                    cell.layer.transform = transform
                    UIView.animate(withDuration: 1, delay: 0, usingSpringWithDamping: 0.7, initialSpringVelocity: 0.5, options: .curveEaseOut, animations: {
                        cell.alpha = 1
                        cell.layer.transform = CATransform3DIdentity
                    }, completion: nil)
                })).disposed(by: disposeBag)

            // item selection with model details.
            Observable
                .zip(
                    studentsView
                        .rx
                        .itemSelected,
                    studentsView
                        .rx
                        .modelSelected(StudentModel.self))
                .bind { [weak self] indexPath, model in

                    let cell = self?.studentsView.cellForItem(at: indexPath) as? StudentCVCell
                    if (model.attandance == 0) {
                       // update view accordingly  

                    } else if (model.attandance == 1) {
                        // update view accordingly  

                    } else if (model.attandance == 2) {
                        // update view accordingly  
                    }

                }.disposed(by: disposeBag)

        } 
</code></pre>

<p><strong>Following is the whole code for Main Viewcontroller</strong></p>

<pre><code>class AttendanceViewController: MainViewController {
    let viewModel: AttendenceVM = AttendenceVM()
    private let disposeBag = DisposeBag()
    let appDelegate = (UIApplication.shared.delegate as! AppDelegate)
    let notificationCenter = NotificationCenter.default
    var students : Results&lt;StudentModel&gt;? = nil
    var notificationToken: NotificationToken? = nil

    private lazy var studentsViewController: AttandenceView = {
        let storyboard = UIStoryboard(name: ""Main"", bundle: Bundle.main)
        var viewController = storyboard.instantiateViewController(withIdentifier: ""attendenceCV"") as! AttandenceView
        self.add(asChildViewController: viewController, to: studentsView)
        return viewController
    }()
     override func viewDidLoad() {
        super.viewDidLoad()

        if AppFunctions.getAssignedClassId(forKey: ""assignedClassId"") != 0 { // &amp;&amp; pref id isAssigned == true
            let id = AppFunctions.getAssignedClassId(forKey: ""assignedClassId"")
            self.viewModel.getStudentsData(id: id)
        }

        bindViewModel()

    }
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        classNameLbl.text = ""Attandence: Class \(AppFunctions.getAssignedClassName(forKey: ""assignedClassName""))""
        students = Database.singleton.fetchStudents(byAttandence: 0, byclassId: AppFunctions.getAssignedClassId(forKey: ""assignedClassId""))
        notificationToken = students?.observe {[weak self] change in
            self!.studentAbsentLbl.text = ""Students Absent (\(String(describing: self!.students!.count)))""
        }
        if AppFunctions.getAssignedClassId(forKey: ""assignedClassId"") != 0 { // &amp;&amp; pref id isAssigned == true
            let id = AppFunctions.getAssignedClassId(forKey: ""assignedClassId"")
            getAssignedClassData(classId: id)
        }
    }
    deinit {
        notificationToken?.invalidate()
    }
    func getAssignedClassData(classId: Int) {
        return APIService.singelton
            .getClassById(classId: classId)
            .subscribe({ [weak self] _ in
                TestDebug.debugInfo(fileName: """", message: ""\(classId)"")
//                self?.notificationToken = Database.singleton.fetchStudentsForAttendence(byCLassId: classId).observe { [weak self] change in
//                    switch change {
//                    case .initial(let initial):
//                        TestDebug.debugInfo(fileName: """", message: ""INIT: \(initial)"")
//                        //self!.viewModel.getStudentsData(id: classId)
//                    case .update(_, let deletions, let insertions, let modifications):
//                        print(modifications)
//                        TestDebug.debugInfo(fileName: """", message: ""MODIFY: \(modifications)"")
//                        TestDebug.debugInfo(fileName: """", message: ""MODIFY: \(insertions)"")
//                    case .error(let error):
//                        TestDebug.debugInfo(fileName: """", message: ""ERROR:\(error)"")
//                    }
//                }
            })
            .disposed(by: self.disposeBag)
    }

    func bindViewModel() {
        viewModel
            .studentCell
            .asObservable()
            .observeOn(MainScheduler.instance)
            .bind(to: studentsViewController.studentCells)
            .disposed(by: disposeBag)

    }
}
</code></pre>
","12139340","","12139340","","2019-10-10 18:18:18","2019-10-10 18:18:18","Observe JSON response if changed from already saved in Database(Realm)","<swift><realm><alamofire><rx-swift>","1","18","0","","","CC BY-SA 4.0"
"58295463","1","58295908","","2019-10-09 00:10:12","","0","632","<p>I have an array defined using RxSwift as </p>

<pre><code>public var calendarNDays = BehaviorRelay&lt;[CalendarControlDayModel]&gt;(value: [])
</code></pre>

<p>CalendarControlDayModel is a structure as below.</p>

<pre class=""lang-swift prettyprint-override""><code>struct CalendarControlDayModel {
        var date: String = """"
        var day: Int = 0
        var name: String = """" 
}
</code></pre>

<p>Once the <code>calendarNDays</code> is updated with elements at some point of time I want to modify the name property of i-th element in the array.</p>

<p>Like <code>self.calendarNDays.value[i].name = ""Nancy""</code>. However, I get the compilation error ""Cannot assign to property: 'value' is a get-only property"".</p>

<p>What is the way to modify a particular property of an element in a behaviour relay array?</p>
","12166985","","5464805","","2019-10-09 00:50:23","2019-10-09 01:30:40","Modify property inside of a behaviourRelay array in RxSwift","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58296553","1","","","2019-10-09 03:13:29","","0","73","<p>I'm using moya to upload many images by using OperationQueue to control maxConcurrentOperationCount. Supposing i have 100 images, uploading 5 images everytime. Alamorefire timeout sets to 10 seconds. </p>

<p>Uploading one image is very fast, nerver triggering timeout. But when i uploading 100 images using the method below, even using multithread, it triggering timeout. Why? 
Thank you!</p>

<pre><code>queue = OperationQueue()
            queue.maxConcurrentOperationCount = 5
            var i = 0
            for image in photos {
                autoreleasepool {
                    let operation:BlockOperation = BlockOperation(block: {
                        [weak self] in
                        guard let strongSelf = self else {return}
                        print(""hyl cur thread %@"", Thread.current)
                        strongSelf.uploadImage(image)
                        return
                    })
                    i += 1
                    queue.addOperation(operation)
                }
            }
</code></pre>

<pre><code>private func uploadImage(_ image: UIImage) {
        AladdinProvider.rx.request(.upload(access_token: UserInfo.instance.access_token!, file_name: ""file_name"", data: image)).asObservable().mapJSON().mapObject(type: AlbumDatas.self).subscribe(onNext: {
            [weak self] result in
            guard let strongSelf = self else {return}
            // TODO success

            }, onError: {
                 error in
                print(\(error))

        }).disposed(by: disposeBag)
    }
</code></pre>
","8720668","","","","","2019-10-09 17:49:02","Alamorefile upload images timeout when using many threads","<alamofire><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58302772","1","","","2019-10-09 11:06:08","","-1","57","<p>I have two clicks of gesture recognizer in my tableview cell to access different storyboards.
My second click is in the extreme right of my cell and I want when I click on it to just highlight that button and not the whole cell which includes the other button</p>

<p><strong>So my question is :</strong> how to separate highlights of different clicks in a tableview cell ?</p>
","5821221","","10214713","","2019-10-09 11:49:35","2019-10-09 12:04:33","How to highlight one part of a tableview cell in swift?","<swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"58304843","1","58450695","","2019-10-09 13:04:54","","0","146","<p>I am getting a push notification and displaying a viewcontroller based on the content of the notification.When the notification is triggered manually from postman, I get the following <code>userInfo</code></p>

<pre><code>    [AnyHashable(""google.c.a.e""): 1, AnyHashable(""gcm.notification.type""): new_property, AnyHashable(""gcm.notification.meta""): {""property_id"":""3""}, AnyHashable(""gcm.message_id""): 1570614460795417, AnyHashable(""aps""): {
        alert =     {
            body = ""A new property has been published is in your area"";
            title = ""New Property"";
        };
    }]
// CASTING AS [String: Any]
    [""google.c.a.e"": 1, ""gcm.notification.meta"": {""property_id"":""3""}, ""gcm.notification.type"": new_property, ""aps"": {
        alert =     {
            body = ""A new property has been published is in your area"";
            title = ""New Property"";
        };
    }, ""gcm.message_id"": 1570614460795417]
</code></pre>

<p>This in turn works and displays the required screen. But when ever a user action triggers the same notification, I get this <code>userInfo</code></p>

<pre><code>    [AnyHashable(""gcm.notification.meta""): {""property_id"":46}, AnyHashable(""gcm.notification.type""): new_property, AnyHashable(""body""): A new property has just been listed in your area by Ebenezer Kilani, AnyHashable(""title""): New property Listing, AnyHashable(""type""): new_property, AnyHashable(""meta""): {""property_id"":46}, AnyHashable(""aps""): {
        alert =     {
            body = ""A new property has just been listed in your area by Ebenezer Kilani"";
            title = ""New property Listing"";
        };
    }, AnyHashable(""gcm.message_id""): 1570550088749025, AnyHashable(""google.c.a.e""): 1]
// CASTING AS [String: Any]
    [""meta"": {""property_id"":46}, ""type"": new_property, ""title"": New property Listing, ""gcm.message_id"": 1570550088749025, ""gcm.notification.meta"": {""property_id"":46}, ""body"": A new property has just been listed in your area by Ebenezer Kilani, ""aps"": {
        alert =     {
            body = ""A new property has just been listed in your area by Ebenezer Kilani"";
            title = ""New property Listing"";
        };
    }, ""google.c.a.e"": 1, ""gcm.notification.type"": new_property]
</code></pre>

<p>the second payload just opens the application but never goes into the view controller I need it to. That is, it opens the home page only.</p>

<p>How I am getting the userInfo</p>

<pre><code>func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {

        let userInfo = response.notification.request.content.userInfo
        if let usrInfo = userInfo as? [String: Any] {
            extractUserInfo(userInfo: usrInfo, completion: completionHandler)
        }
        completionHandler()
    }

func extractUserInfo(userInfo: [String: Any], completion: @escaping () -&gt; Void) {

        if let type = userInfo[""gcm.notification.type""] as? String {
                    Storage.instance.savePush(type)
                    if type == ""new_property"" {
                        if let meta = userInfo[""gcm.notification.meta""] as? String {

                            if let data = meta.data(using: .utf8) {

                                do {
                                    if let json = try JSONSerialization.jsonObject(with: data, options: .allowFragments) as? [String: Any] {
                                        guard let propertyId = json[""property_id""] as? String, let id = Int(propertyId) else {return}
                                        NotificationEvent.isFromNotification.accept(true)
                                        NotificationEvent.id.accept(id)

                                    } else {
                                        print(""JSON is invalid"")
                                    }
                                } catch {
                                    print(""Exception converting: \(error)"")
                                }
                            }
                        }

                    } 
       }
 }
</code></pre>

<p>how I handle the push to display required Viewcontroller</p>

<pre><code>class Remote {

    var navigationController: UINavigationController?
    let disposeBag = DisposeBag()

    @discardableResult
    init(navigationController: UINavigationController?) {
        self.navigationController = navigationController
        rxEvent()
    }

    func rxEvent() {

        NotificationEvent.isFromNotification.asObservable().subscribe(onNext: { bool in
            print(""Exception converting: bool \(bool)"")
            if bool {
                NotificationEvent.id.asObservable()
                    .delay(1, scheduler: MainScheduler.instance)
                    .subscribe(onNext: { int in
                    if int &gt; 0 {
                        if Storage.instance.getPush() == ""new_property"" {
                            self.presentPropertyDetailVC(int)
                        } else if Storage.instance.getPush() == ""new_rating"" || Storage.instance.getPush() == ""coverage_area"" {
                            print(int)
                        }
                    }
                }).disposed(by: self.disposeBag)
                NotificationEvent.isFromNotification.accept(false)
            }
        }).disposed(by: disposeBag)
    }

    func presentPropertyDetailVC(_ uid: Int) {
        //        navigationVC.modalPresentationStyle = .formSheet
        let controller = PropertyDetailVC()
        controller.propertyId = uid
        print(""Exception converting: 11 \(controller)"")
        navigationController?.pushViewController(controller, animated: true)
    }
}
</code></pre>

<p>then I instantiate <code>Remote</code> in my home VC</p>

<p>Any reason why the first payload work and the second does not and anything I could do to correct that.</p>
","8310287","","","","","2019-10-18 12:12:20","Displaying Viewcontroller based on Notification payload swift","<ios><swift><apple-push-notifications><rx-swift>","1","6","","","","CC BY-SA 4.0"
"58305775","1","58354109","","2019-10-09 13:52:26","","0","224","<p>I have a UITabBarController with 2 controllers.</p>

<ol>
<li>In the first VC user have a list of articles. A user can add some article to favourite (realm database) </li>
<li>The second VC it is a list with realm query (favourite article).
When 2 controllers created (user tap to both of them), and in the first VC add article to favourite in the second collectionView does not show new item.</li>
</ol>

<p>My favouriteVC collectionView binding </p>

<pre><code> private func setupBinds(){
    self.favArticleCollectionView.register(UINib(nibName: ""PreviewItemVCell"", bundle: nil), forCellWithReuseIdentifier: PreviewItemVCell.identifier)

    viewModel
        .articlesSubject
        .observeOn(MainScheduler.instance)
        .bind(to:
        self.favArticleCollectionView.rx.items(cellIdentifier: PreviewItemVCell.identifier, cellType: PreviewItemVCell.self)) { (item, article,cell) in
            cell.article =  article
    }.disposed(by: disposeBag)
</code></pre>

<p>and my favouriteViewModel which make a query from db</p>

<pre><code>class FavouriteViewModel {
let articlesSubject: PublishSubject&lt;[ArticleModel]&gt; = PublishSubject()



func fetchDateFromDb(){
    print(Realm.Configuration.defaultConfiguration.fileURL!)
    let articleList = DatabaseManager.shared.getAllArticle().toArray()

    articlesSubject.onNext(articleList)
}}
</code></pre>

<p>Problem: When the controller has created, he does not update. How I can update it?</p>
","12164851","","","","","2019-10-12 12:21:13","RxSwift - UICollectionView does not update after updating","<ios><swift><uicollectionview><rx-swift><rx-cocoa>","1","2","","","","CC BY-SA 4.0"
"58312043","1","","","2019-10-09 20:46:05","","2","481","<p>I'm using RxSwift with something like the following</p>

<pre><code>extension Reactive where Base: UIViewController {

    public var showError: Binder&lt;Error&gt; {
        return Binder(self.base) { element, error in
            let alertVC = // create UIAlertController with error
            element.present(alertVC, animated: true)
        }
    }
</code></pre>

<p>What's the best way to build something like this with Swift Combine?</p>
","27404","","1000551","","2019-12-07 09:59:32","2019-12-07 09:59:32","Swift Combine: how to create custom sink?","<swift><rx-swift><combine>","1","0","","","","CC BY-SA 4.0"
"58329578","1","58335754","","2019-10-10 19:05:53","","1","1553","<p>Before Anyone makes it duplicate I have scene all the RxDatasource tags on SO and other sites also. But anyone didn't worked for me.</p>

<p>So my question is totally related to <a href=""https://stackoverflow.com/questions/55378613/rxdatasources-tableview-with-multiple-sections-from-one-api-source"">this</a> one that I followed for my case also. But also I have no idea what's going on in here. And its been two weeks of struggling. I have checked gitHub code sample also but was unable to understand. 
I have created an app using <code>RxSwift</code> and <code>Realm</code> on <em>MVVM</em> architecture pattern, things are working fine but now I need to create two sections in my view using <code>UICollectioView</code> for that I read about <code>RxdataSource</code> and tried to apply it but i didn't get at all whats it actually doing. I tried creating other projects for learning also those also didn't worked. Still I tried and make this code but it gives me error.</p>

<p>What I did is from the link provided above is in the code below. I also do not know how to give my data source the data or lists from one array after spliting it. below is my whole code. </p>

<p>I don't have idea what is this block doing.</p>

<pre><code>//Changed
struct SectionViewModel {
    var header: String!
    var items: [StudentModel]
}

extension SectionViewModel: SectionModelType {
    typealias Item  = StudentModel
    init(original: SectionViewModel, items: [StudentModel]) {
        self = original
        self.items = items
    }
}
</code></pre>

<p>then my CollectionView class is like </p>

<pre><code>class StudentCV: UIViewController, UICollectionViewDelegateFlowLayout {

    //MARK: - Outlets

    @IBOutlet weak var studentsView: UICollectionView!

    let studentCells = BehaviorRelay&lt;[StudentModel]&gt;(value: [])
    var notificationToken: NotificationToken? = nil

    private let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        let flowLayout = UICollectionViewFlowLayout()
        let size = CGSize(width: 105, height: 135)
        flowLayout.itemSize = size
        studentsView.setCollectionViewLayout(flowLayout, animated: true)
        studentsView.rx.setDelegate(self).disposed(by: disposeBag)

        setupBinding()
    }

    func studentLeft(value: Int, id: Int) {
        SignalRService.sharedClass.chatHub.invoke(method: ""StudentLeft"", withArgs: [id, value]){ (result, error) in
            if let e = error {
                print(""Error: \(e)"")
            } else {
                print(""Done!"")
                let vale = Database.singleton.updatePickupStatus(studentId: id, pickupValue: value)
                TestDebug.debugInfo(fileName: """", message: ""STUDENT LEFTTT:: \(vale)"")
                if let r = result {
                    print(""Result: \(r)"")
                }
            }
        }
    }

    deinit {
        notificationToken?.invalidate()
    }
    func setupBinding() {
        studentsView.register(UINib(nibName: ""StudentCVCell"", bundle: nil), forCellWithReuseIdentifier: ""studentCV"")

        //Cell creation Changed here..............................

           dataSource.configureCell = { (ds, cv, ip, item) in
            let cell = cv.dequeueReusableCell(withReuseIdentifier: ""studentCV"", for: ip) as! StudentCVCell
            cell.viewModel = item
            return cell
        }


            studentCells
                .asObservable()
                .debug(""STudent View: "")
                .map({ SectionViewModel(header: ""Pickups Arrived"", items: $0 ) })
                .bind(to: studentsView.rx.items(dataSource: dataSource)) // now here it is giving me this error (Instance method 'items(dataSource:)' requires the types '[SectionViewModel]' and 'SectionViewModel' be equivalent)
                .disposed(by: disposeBag)


        // item selection with model details.
        Observable
        .zip(
            studentsView
            .rx
            .itemSelected,
            studentsView
            .rx
            .modelSelected(StudentModel.self))
            .bind { [weak self] indexPath, model in

                let cell = self?.studentsView.cellForItem(at: indexPath) as? StudentCVCell
                if (model.pickupStatus == 2) {
                    // updating view accordingly
                }

        }.disposed(by: disposeBag)
    }
</code></pre>

<p>and ViewModels looks like this. from where I am populating.</p>

<pre><code>class StudentCollectionViewViewModel {


    //MARK: Outlets
    let disposeBag = DisposeBag()
    var notificationToken : NotificationToken? = nil
    let studentCells = BehaviorRelay&lt;[StudentModel]&gt;(value: [])

    var studentCell : Observable&lt;[StudentModel]&gt; {
        return studentCells.asObservable()
    }


    deinit {
        notificationToken?.invalidate()
    }

    func getStudentsData(id: Int) {

        let studentsData = Database.singleton.fetchStudents(byCLassId: id)
        self.notificationToken = studentsData.observe{[weak self] change in
            TestDebug.debugInfo(fileName: """", message: ""Switch:::: change"")
            switch change {
            case .initial(let initial):
                TestDebug.debugInfo(fileName: """", message: ""INIT: \(initial)"")
                self!.studentCells.accept(Array(studentsData))
            case .update(_, let deletions, let insertions, let modifications):
                TestDebug.debugInfo(fileName: """", message: ""MODIF::: \(modifications)"")
                self!.studentCells.accept(Array(studentsData))
            case .error(let error):
                print(error)
            }
        }


    }

}
</code></pre>

<p>I am populating data from DB but I need to make two lists , I also don't get where i have to send two lists of data to populate. plus when I tried to use it in my code to see how things works but it gives my following error.
<strong><em>Instance method 'items(dataSource:)' requires the types '[SectionModel]' and '[StudentModel]' be equivalent</em></strong>.
any advise or help will be appreciated. thanks in advance</p>
","12139340","","12139340","","2019-10-13 12:13:36","2019-10-13 19:42:25","How to create multiple Sections in UICollectionView with multiple Headers using RxDatasource","<ios><swift><iphone><rx-swift><rxdatasources>","1","0","","","","CC BY-SA 4.0"
"58332584","1","58349277","","2019-10-11 00:07:18","","7","2939","<p>What is the difference between using RxSwift's <strong>MainSchedule.instance</strong> and <strong>MainSchedule.asyncInstance</strong> within the context of <strong>observeOn</strong>? </p>
","9410757","","","","","2019-10-11 22:44:59","RxSwift -- MainScheduler.instance vs MainScheduler.asyncInstance","<ios><swift><reactive-programming><rx-swift><reactive-cocoa>","1","6","2","","","CC BY-SA 4.0"
"58355951","1","58358985","","2019-10-12 16:03:18","","8","5428","<p>I am trying to make several API calls and populate a Realm Database.
Everything works fine. However when I try to run <code>performSegue()</code> on <code>subscribe()</code> method an exception is raised, informing that I can't do this on a background thread, which is perfectly reasonable.</p>

<p>But since I am subscribing to <code>MainScheduler.instance</code> shouldn't the <code>subscribe()</code> method run on UI Thread?</p>

<pre><code>Single.zip(APIClient.shared.getSchools(), APIClient.shared.getPointsOfInterest())
        .observeOn(SerialDispatchQueueScheduler(qos: .background))
        .flatMap { zip in return Single.zip(SchoolDao.shared.insertSchools(schoolsJson: zip.0), PointOfInterestDao.shared.insertPointsOfInterest(poisJson: zip.1))}
        .flatMap{ _ in Single.zip(SchoolDao.shared.countSchools(), PointOfInterestDao.shared.countPointsOfInterest())}
        .subscribeOn(MainScheduler.instance)
        .subscribe(onSuccess: { tableCounts in
            let (schoolsCount, poisCount) = tableCounts
            if(schoolsCount != 0 &amp;&amp; poisCount != 0){
                print(Thread.isMainThread) //Prints False
                self.performSegue(withIdentifier: ""splashToLogin"", sender: nil)
            }
        }, onError: {
            error in return
        }).disposed(by: disposeBag)
</code></pre>

<p>Am I making a wrong assumption on how does RXSwift works?</p>

<p><strong>Edit:</strong> If I add this line <code>.observeOn(MainScheduler.instance)</code> after <code>.subscribeOn(MainScheduler.instance)</code> the subscribe method runs on Main thread. Is this correct behavior? What is <code>.subscribeOn(MainScheduler.instance)</code> even doing?</p>
","4712672","","4712672","","2019-10-12 16:14:52","2019-10-12 22:09:20","RXSwift Not subscribing on Main Thread","<ios><swift><rx-swift>","1","0","2","","","CC BY-SA 4.0"
"58360092","1","58411225","","2019-10-13 02:23:36","","1","609","<p>I am new to RxSwift and I want to achieve this:</p>

<p>A titleTextField,a descTextField,a confirmButton and a submitButton.</p>

<p>The submitButton is unEnable until titleTextField and descTextField's text.count >= 5 and confirmButton is selected, so I write these code:</p>

<pre><code>let titleValid = titleTextField.rx.text.orEmpty.map { (text) -&gt; Bool in
    return text.count &gt;= 5
}

let descValid = descTextField.rx.text.orEmpty.map { (text) -&gt; Bool in
    return text.count &gt;= 5
}

let isConfirm = confirmButton.rx.isSelected.asObserver().mapObserver { (selected) -&gt; Bool in
    return selected
}

Observable.combineLatest(titleValid, descValid, isConfirm) { $0 &amp;&amp; $1 &amp;&amp; $2 }.bind(to: submitButton.rx.isEnabled).disposed(by: disposeBag)
</code></pre>

<p>It's work good with <code>titleValid</code> and <code>descValid</code>,however,there is an error with <code>isConfirm</code>:</p>

<pre><code>Argument type 'AnyObserver&lt;Bool&gt;' does not conform to expected type 'ObservableType'
</code></pre>

<p>How can I change <code>isConfirm</code> to <code>ObservableType</code>? How to Correct it?</p>

<p>Note the RxSwift's version is 5.0.0</p>
","6144118","","","","","2019-10-16 11:28:47","RxSwift: How can I change Bool to ObservableType?","<rx-swift>","1","4","","","","CC BY-SA 4.0"
"58362836","1","","","2019-10-13 10:48:33","","0","15","<p>In the below example, how do I wait until the success callback is called to start asserting in my view controller tests?</p>

<pre><code>class VC : NSViewController {
    let observable: Observable&lt;Int&gt;
    let compositeDisposable = CompositeDisposable()
    override viewDidLoad() {
        self.compositeDisposable.insert(
            self.observable.toArray()
            .observeOn(MainScheduler.instance)
            .subscribe(
                // draw onto the VC
            )
        )
    }
}
</code></pre>
","10390454","","","","","2019-10-13 10:48:33","How do I test a view controller after subscription to an Observable is done?","<macos><cocoa><rx-swift>","0","2","","","","CC BY-SA 4.0"
"58364345","1","59198850","","2019-10-13 14:10:08","","1","1076","<p>In RxSwift we can check if a <code>*Subject</code> has any observer, using <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Subjects/PublishSubject.swift#L24-L29"" rel=""nofollow noreferrer""><code>hasObserver</code></a>, how can I do this in Combine on e.g. a <code>PassthroughSubject</code>?</p>
","1311272","","","","","2019-12-05 15:54:56","Swift Combine: Check if Subject has observer?","<swift><rx-swift><combine>","2","0","","","","CC BY-SA 4.0"
"58364436","1","58368290","","2019-10-13 14:20:30","","3","1433","<p>How can I convert a publisher of array a certain element, to just a publisher of said element (but with more events)?</p>

<p>e.g. how can I convert</p>

<p><code>AnyPublisher&lt;[Int], Never&gt;</code> to <code>AnyPublisher&lt;Int, Never&gt;</code>?</p>

<p>I think maybe what RxSwift offers with its <a href=""https://github.com/ReactiveX/RxSwift/blob/c6c0c540109678b96639c25e9c0ebe4a6d7a69a9/RxSwift/Observables/Sequence.swift#L34-L36"" rel=""nofollow noreferrer""><code>from</code> operator</a> is similar to what I want to do.</p>

<p>I guess I want the inverse of Combine <a href=""https://developer.apple.com/documentation/combine/publisher/3204692-collect"" rel=""nofollow noreferrer""><code>collect</code></a>?</p>
","1311272","","1311272","","2019-10-13 14:27:33","2021-03-19 09:56:19","Swift Combine: How can I convert `AnyPublisher<[Foo], *>` to `AnyPublisher<Foo, *>`?","<swift><rx-swift><combine>","2","0","1","","","CC BY-SA 4.0"
"58369078","1","58370609","","2019-10-14 01:26:59","","0","321","<p>RxSwift one more question about error handling:</p>

<p>I'm using Alamofire+RxAlamofire this way:</p>

<pre><code>SessionManager.default.rx.responseJSON(.post, url, parameters:params)
</code></pre>

<p>example:</p>

<pre><code>func login() -&gt; Observable&lt;Int&gt; {
    let urlString = ...
    let params = ...
    return SessionManager.default.rx.responseJSON(.post, url, parameters:params)
        .rxJsonDefaultResponse()
        .map({ (data) in
            data[""clientId""] as! Int
        })
}
....

extension ObservableType where Element == (HTTPURLResponse, Any) {

    func rxJsonDefaultResponse() -&gt; Observable&lt;Dictionary&lt;String, Any&gt;&gt; {

        return self.asObservable().map { data -&gt; Dictionary&lt;String, Any&gt; in

            if... //error chechings
                    throw NSError(domain: ..,
                                  code: ...,
                                  userInfo: ...)
            }
            ...
            return json
        }
    }
}
</code></pre>

<p>using:</p>

<pre><code>loginBtn.rx.tap
.flatMap{ _ in
    provider.login()
}.subscribe(onNext: { id in
       ... 
    }, onError: { (er) in
        ErrorPresentationHelper.showErrorAlert(for: er)
    })
.disposed(by: bag)
</code></pre>

<p>So if error occurred everything works as intended: error alert shows and 'loginBtn.rx.tap' disposed, but I need it to be still alive, what's my strategy here if I want to use onError block?</p>
","1140941","","1140941","","2019-10-14 02:04:52","2019-10-14 05:43:34","RxSwift+Alamofire custom mapper error handling","<swift><alamofire><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58380406","1","58414506","","2019-10-14 16:07:51","","1","1149","<p>New to rxSwift and trying to learn a somewhat simple function. When <code>.timeout</code> is used on an observable sequence it will return an error message <code>Unhandled error happened: Sequence timeout.</code> if one of the observables in the sequence didn't emit an event.</p>

<p>This is my attempt at handling an observable no longer receiving events, if there is a better way to achieve this please suggest it!</p>

<p>How can I fire off an alert if the <code>.timeout</code> operator returns an error message.</p>

<p><code>.timeout</code> information:
Summary</p>

<p>Applies a timeout policy for each element in the observable sequence. If the next element isn’t received within the specified timeout duration starting from its predecessor, a TimeoutError is propagated to the observer.
Declaration</p>

<p><code>dueTime</code><br>
Maximum duration between values before a timeout occurs.</p>

<p><code>scheduler</code> 
Scheduler to run the timeout timer on.</p>

<p><code>Returns</code></p>

<p>An observable sequence with a RxError.timeout in case of a timeout.</p>

<p>Code :</p>

<pre><code>    Observable.combineLatest(currentUser, opponent, game)
      .timeout(3, scheduler: MainScheduler.instance)


      .subscribe(onNext: { (arg) -&gt; Void in

        let (currentUser, opponent, game) = arg

        if game.isPlayersTurn(currentUser) {
          self._turnState.onNext(.yourTurn)
        } else if game.isPlayersTurn(opponent) {
          self._turnState.onNext(.theirTurn)
        } else if game.isTie() {
          self._turnState.onNext(.tie)
        } else if game.gameData.winner == currentUser.userId {
          self._turnState.onNext(.win(opponentWon: false))
        } else if game.gameData.winner == opponent.userId {
          self._turnState.onNext(.win(opponentWon: true))
        }
      })
      .disposed(by: disposeBag)
  }
</code></pre>
","11243557","","11243557","","2019-10-15 15:32:25","2019-10-16 13:26:43","How to : Detect if a observable has not emitted any events for specific time in RxSwift","<swift><error-handling><timeout><reactive-programming><rx-swift>","2","3","","","","CC BY-SA 4.0"
"58399322","1","58407897","","2019-10-15 16:48:20","","0","87","<p>I wanted to create a pop up for one of my <strong><em>UIViewController</em></strong> and found this <a href=""https://github.com/SteveBarnegren/SBCardPopup"" rel=""nofollow noreferrer"">repo</a> on GitHub.</p>

<p>It is working fine with my <strong><em>InfoViewController</em></strong> which only has 4 <strong><em>UILabels</em></strong> (I think this might be the problem that it is not showing up when you use reusable cells)
But somehow it is not working with my <strong><em>StructureNavigationListViewController</em></strong> and I do not know why.</p>

<p>I call the <strong><em>didTapCategory</em></strong> method in my <strong><em>MainViewController</em></strong> where the StructureNavigationController should pop up but I only see the dimming view (which is weird cause the tap recognizer and pan gestures are working fine but no content is showing up) </p>

<hr>

<p>In my <strong><em>MainViewController</em></strong> I set up the popup like before:</p>

<pre><code>    @IBAction func didTapCategory(_ sender: UIBarButtonItem) {
        let popupContent = StructureNavigationListViewController.create()
        let cardpopUp = SBCardPopupViewController(contentViewController: popupContent)
        cardpopUp.show(onViewController: self)
    }
</code></pre>

<hr>

<p>In my <strong><em>StructureNavigationListViewController</em></strong> I set up the table view and the pop up:</p>

<pre><code>public var popupViewController: SBCardPopupViewController?

    public var allowsTapToDismissPopupCard: Bool = true

    public var allowsSwipeToDismissPopupCard: Bool = true

    static func create() -&gt; UIViewController {
        let sb = UIStoryboard(name: ""Main"", bundle: nil)
        let vc = sb.instantiateViewController(withIdentifier: ""StructureNavigationListViewController"") as! StructureNavigationListViewController
        return vc
    }

    @IBOutlet var tableView: UITableView!
    var structures = Variable&lt;[Structure]&gt;([])
    public var treeSource: StructureTreeSource?
    let disposeBag = DisposeBag()

    var depthDictionary : [String : Int] = [:]

    public override func viewDidLoad() {
        structures.asObservable()
            .bind(to:tableView.rx.items) {(tableView, row, structure) in
                let cell = tableView.dequeueReusableCell(withIdentifier: ""StructureNavigationCell"", for: IndexPath(row: row, section: 0)) as! StructureNavigationCell
                cell.structureLabel.text = structure.name
                cell.spacingViewWidthConstraint.constant = 20 * CGFloat(self.depthDictionary[structure.id]!)
                return cell
            }.disposed(by:disposeBag)

        _ = tableView.rx.modelSelected(Structure.self).subscribe(onNext: { structure in
            let storyBoard = UIStoryboard(name:""Main"", bundle:nil)
            let plansViewCtrl = storyBoard.instantiateViewController(withIdentifier: ""PlansViewController2"") as! PlansViewController2
            self.treeSource?.select(structure)
            plansViewCtrl.treeSource = self.treeSource
            plansViewCtrl.navigationItem.title = structure.name
            self.show(plansViewCtrl, sender: self)
            if let mainVC = self.parent as? ProjectOverViewTabController2 {
                mainVC.addChildView(viewController: plansViewCtrl, in: mainVC.scrollView)
            }
        })
        showList()
    }
func showList() {
        if treeSource == nil {
            treeSource = StructureTreeSource(projectId:GlobalState.selectedProjectId!)
        }

        //The following piece of code achieves the correct order of structures and their substructures.
        //It is extremely bad designed and rather expensive with lots of structures and should
        //therefore be refactored!
        if let strctrs = getStructures() {
            var sortedStructures : [Structure] = []
            while(sortedStructures.count != strctrs.count) {
                for strct in strctrs {
                    if let _ = sortedStructures.index(of: strct) {
                        continue
                    } else {
                        depthDictionary[strct.id] = getDepthOfNode(structure: strct, depth: 1)
                        if let structures = getStructures() {
                            if let parent = structures.first(where: {$0.id == strct.parentId}) {
                                if let index = sortedStructures.index(of: parent) {
                                    sortedStructures.insert(strct, at: index+1)
                                }
                            } else {
                                sortedStructures.insert(strct, at: 0)
                            }
                        }
                    }
                }
            }
            structures.value = sortedStructures

            tableView.reloadData()
        }
    }

    func getDepthOfNode(structure: Structure, depth: Int) -&gt; Int {
        if(structure.parentId == nil || structure.parentId == """") {
            return depth
        } else {
            if let structures = getStructures() {
                if let parent = structures.first(where: {$0.id == structure.parentId}) {
                    return getDepthOfNode(structure: parent, depth: depth + 1)
                }
            }
        }
        return -1
    }

    private func getStructures() -&gt; Results&lt;Structure&gt;? {
        do {
            if let projectId = GlobalState.selectedProjectId {
                return try Structure.db.by(projectId: projectId)
            }
        } catch { Log.db.error(error: error) }

        return nil
    }
}

</code></pre>

<hr>

<p>Lot of code here. Sorry..</p>

<p>Is it because I call the <strong><em>create()</em></strong> method after the <strong><em>viewDidLoad()</em></strong> dequeues the cells?</p>
","","user11080824","4099593","","2020-04-23 08:37:21","2020-04-23 08:37:21","Why is my UIViewController not showing up in my popup card?","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58402224","1","","","2019-10-15 20:29:02","","1","227","<p>say I have a <code>UIViewController</code> in which I have 2 other view which are actually <code>UICollectionViews</code> embedded in two different container views. Say CV1 = <code>class_Numbers</code> and CV2 = <code>students_Data</code>. Now I want to perform an action on <code>students_Data</code> and change Student class data on <code>itemSelected</code> click from the class_Numbers. <code>BehaviorRelay</code> to update on runtime. And I have bind them in <code>MainViewController</code>. Have a look on code for better understanding.</p>

<p><strong>student_data CV Class</strong></p>

<pre><code>dataSource.configureCell = { (ds, cv, ip, item) in
            let cell = cv.dequeueReusableCell(withReuseIdentifier: ""studentCV"", for: ip) as! StudentCVCell
            cell.viewModel = item
            classIdd = item.classId
            return cell
        }
            studentCells
                .asObservable()
                .debug(""STudent View: "")
                .map({ [SectionViewModel(header: """", items: $0.filter({$0.pickupStatus == 2}) ), SectionViewModel(header: """", items: $0.filter({$0.pickupStatus == 3}) )] })
                .bind(to: studentsView.rx.items(dataSource: dataSource))
                .disposed(by: disposeBag)
</code></pre>

<p><strong>class_number CollectionView</strong></p>

<pre><code>  let studentCells = BehaviorRelay&lt;[StudentModel]&gt;(value: [])
    let classCells = BehaviorRelay&lt;[ClassModel]&gt;(value: [])
func setupBind{
// other functions
        // item selection with model details.
Observable
            .zip(
                classTab
                    .rx
                    .itemSelected,
                classTab
                    .rx
                    .modelSelected(ClassModel.self))
            .bind { [weak self] indexPath, model in
                AppFunctions.setSelectedTab(value: indexPath.row)
                self!.tab.onNext(self!.tabStatus(index: indexPath.row))
                self!.studentCells.accept(Array(Database.singleton.fetchStudents(byCLassId: model.classId))) // here I am trying to update view by passing value to the observable. 
            }.disposed(by: disposeBag)
}
</code></pre>

<p><strong>StudentViewModel</strong></p>

<pre><code>
 let studentCells = BehaviorRelay&lt;[StudentModel]&gt;(value: [])
    let classCells = BehaviorRelay&lt;[ClassModel]&gt;(value: [])
    var studentCell : Observable&lt;[StudentModel]&gt; {
        return studentCells.asObservable()
    }
    var classCell : Observable&lt;[ClassModel]&gt; {
        return classCells.asObservable()
    }
 func getStudentsData(id: Int) { // this function is being called on the mainViewController which have both collection views.
        let studentsData = Database.singleton.fetchStudents(byCLassId: id)
        self.notificationToken = studentsData.observe{[weak self] change in
            switch change {
            case .initial(_):
                self!.studentCells.accept(Array(studentsData))
                self!.classCells.accept(Array(Database.singleton.fetchClass()))
                break
            case .update(_, _, _, _):
                self!.studentCells.accept(Array(studentsData))
                self!.classCells.accept(Array(Database.singleton.fetchClass()))
                break
            case .error(let error):
                print(error)
                break
            }
        }
    }
</code></pre>

<p><strong>MainViewController</strong></p>

<pre><code>    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
            getAssignedClassData(classId: id)
                self!.viewModel.getStudentsData(id: id)
    }
    func getAssignedClassData(classId: Int) {
        return APIService.singelton
            .getClassById(classId: classId)
            .subscribe({ [weak self] _ in
                // something happening
            })
            .disposed(by: self.disposeBag)
    }
 func bindViewModel() {
        viewModel
            .studentCell
            .asObservable()
            .debug(""BIND: "")
            .observeOn(MainScheduler.instance)
            .bind(to: studentsViewController.studentCells)
            .disposed(by: disposeBag)

            viewModel
            .classCell
            .asObservable()
            .debug(""CELL BIND: "")
            .observeOn(MainScheduler.instance)
            .bind(to: classViewController.classCells)
            .disposed(by: disposeBag)
    }
</code></pre>
","12139340","","","","","2019-10-15 20:29:02","BehaviorRelay not updating the view in Collection view on call. Swift","<ios><swift><uicollectionview><rx-swift>","0","5","","","","CC BY-SA 4.0"
"58434322","1","","","2019-10-17 13:52:47","","1","1127","<p>I have an application where I want to make an API call once the screen is awaken in the ViewController. Basically, I am using Universal Link to activate the ViewCOntroller and when it displays the UIViewController, I want to make an API call based on the Data got. I am currently using the MVVM Architecture and I have added my code below</p>

<p><strong>My ViewModel</strong></p>

<pre><code>    class EmailVerificationViewModel: ViewModel, ViewModelType {

        struct Input {
            let editEmailTrigger: Driver&lt;Void&gt;
        }

        struct Output {

        }

        let routeManager: BehaviorRelay&lt;RouteMatchResult?&gt;
        let currentEmail: BehaviorRelay&lt;String?&gt;

        init(routeManager: RouteMatchResult?, provider: Api, currentEmail: String?) {
            self.routeManager = BehaviorRelay(value: routeManager)
            self.currentEmail = BehaviorRelay(value: currentEmail)
            super.init(provider: provider)
        }

        func transform(input: Input) -&gt; Output {

         // THE CALL I WANT TO MAKE
            routeManager.errorOnNil().asObservable()

            .flatMapLatest { (code) -&gt; Observable&lt;RxSwift.Event&lt;User&gt;&gt; in
            log(""=========++++++++++++=========="")
//            guard let code = code else {return}
            let params = code.values
                let challengeId = Int(params[""xxx""] as? String ?? ""0"")
                let login = LoginResponseModel(identifier: params[""xxxx""] as? String, key: params[""xxxxxx""] as? String, oth: params[""xxxxx""] as? String, id: 0, challengeId: challengeId)

            return self.provider.postVerifyApp(challengeId: login.challengeId!, oth: login.oth!, identifier: login.identifier!)
            .trackActivity(self.loading)
            .trackError(self.error)
            .materialize()
        }.subscribe(onNext: { [weak self] (event) in
            switch event {
            case .next(let token):
                log(token)
                AuthManager.setToken(token: token)
//                self?.tokenSaved.onNext(())
            case .error(let error):
                log(error.localizedDescription)
            default: break
            }
        }).disposed(by: rx.disposeBag)

            return Output()
        }
    }
</code></pre>

<p><strong>My Viewcontroller</strong></p>

<pre><code>override func bindViewModel() {
        super.bindViewModel()
        guard let viewModel = viewModel as? EmailVerificationViewModel else { return }

        let input = EmailVerificationViewModel.Input(editEmailTrigger: editEmailBtn.rx.tap.asDriver())
        let output = viewModel.transform(input: input)

        viewModel.loading.asObservable().bind(to: isLoading).disposed(by: rx.disposeBag)
        viewModel.parsedError.asObservable().bind(to: error).disposed(by: rx.disposeBag)

        isLoading.asDriver().drive(onNext: { [weak self] (isLoading) in
            isLoading ? self?.startAnimating() : self?.stopAnimating()
        }).disposed(by: rx.disposeBag)


        error.subscribe(onNext: { [weak self] (error) in
            var title = """"
            var description = """"
            let image = R.image.icon_toast_warning()
            switch error {
            case .serverError(let response):
                title = response.message ?? """"
            }
            self?.view.makeToast(description, title: title, image: image)
        }).disposed(by: rx.disposeBag)
    }
</code></pre>

<p>so how can I make the call on the commented like <code>THE CALL I WANT TO MAKE</code> once the application catches the universal link and loads up. Basically making an API call on viewDidLoad</p>
","8310287","","8310287","","2019-10-17 14:29:41","2019-10-18 01:26:34","Making Api call on View DidLoad with MVVM swift","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"58452003","1","","","2019-10-18 13:34:55","","0","2292","<p>In RxSwift, a flatMap operator can easily return a non-completing Observable. Let's say we have this (contrived and silly) Observable chain:</p>

<pre><code>let repo = DataRepository()

Observable
    .just(Int.random(in: 0 ..&lt; 1000))
    .flatMap { num -&gt; Observable&lt;String&gt; in
        if num == 42 {
            return .never()
        }

        return repo
            .fetchData()
            .filter { $0.statusCode == 200 }
            .map { $0.data.title }
    }
</code></pre>

<p>With Combine, the closest I can get is something like this (haven't tried to compile, but you get the idea):</p>

<pre><code>Just(Int.random(in: 0 ..&lt; 1000))
    .flatMap { num -&gt; AnyPublisher&lt;String, Never&gt; in
        if num == 42 {
            return Empty&lt;String, Never&gt;(completeImmediately: false).eraseToAnyPublisher()
        }

        return repo
            .fetchData()
            .filter { $0.statusCode == 200 }
            .map { $0.data.title }
            .eraseToAnyPublisher()
    }
</code></pre>

<p>I'm okay-ish with this solution, but I see two problems that I would like to avoid:</p>

<p>1) The Combine solution is somewhat more verbose to achieve the same thing.</p>

<p>2) I have to call <code>eraseToAnyPublisher()</code> on both returned Publishers, else the return types don't match. I believe calling <code>eraseToAnyPublisher()</code> prevents Swift from applying some internal optimizations (I can't find the article I read about this optimization anymore; the information is scarce around this)</p>

<p>Does anyone have a better approach to handling this example scenario?</p>
","6900003","","","","","2019-10-18 21:26:06","Never return in a Flatmap with Swift's Combine","<swift><rx-swift><combine>","1","2","","","","CC BY-SA 4.0"
"58453138","1","58770899","","2019-10-18 14:43:09","","0","596","<p>When executed the code below will print ""subscribe"" twice. Why? RxSwift 5.0</p>

<pre><code>import UIKit
import RxSwift

class ViewController: UIViewController {

    let data = Data(repeating: 100, count: 1_000_000_000_0)

    override func viewDidLoad() {
        super.viewDidLoad()


        let disposeBag = DisposeBag()
        Observable&lt;Data&gt;
            .from(data)
            .subscribe( { _ in print(""subscribe"") } )
            .disposed(by: disposeBag)

    }

}
</code></pre>
","1180728","","","","","2019-11-08 17:01:13","Observable.from subscribe closure called twice","<rx-swift>","2","0","","","","CC BY-SA 4.0"
"58463126","1","","","2019-10-19 11:18:56","","2","850","<p>I have A <code>parentView</code> which holds two different <code>CollectionViwes</code>. Each view is getting populated from dataBase by passing data to <code>Observable</code> using <code>BehaviorRelay</code>. Everything is working fine until I have to update Views in <code>collection_view_2</code> from <code>collection_view_1</code>. What I am doing is passing <code>BehaviorRelay</code> fetched data as I am doing previously in same <code>ParentView</code>. But what I see is this time on tap of <code>collection_view_1's</code> cell the <code>Observable</code> of <code>StudentCell</code> does not get called. I am unable to figure out why its doing like that. I have seen other SO questions but no one have answer to fix this. Have a look on the code down below for better understanding.</p>

<p><strong>Collection_view_1</strong></p>

<pre><code>class ClassTabCV: UIViewController, UICollectionViewDelegateFlowLayout {
    let classCells = BehaviorRelay&lt;[ClassModel]&gt;(value: [])
    let pickupVC = PickUpViewController()

    override func viewDidLoad() {
        super.viewDidLoad()
        classTab.rx.setDelegate(self).disposed(by: disposeBag)
        setupBinding()
    }

    func setupBinding() {
        classTab.register(UINib(nibName: ""ClassTabCVCell"", bundle: nil), forCellWithReuseIdentifier: ""classTabCV"")
        //Cell creation
        classCells.asObservable().debug(""Class View: "").bind(to: classTab.rx.items(cellIdentifier: ""classTabCV"", cellType: ClassTabCVCell.self)) {[weak self]
            (row , element, cell) in
            cell.viewModel = element
            }.disposed(by: disposeBag)

        // item selection with model details.
        Observable
            .zip(
                classTab
                    .rx
                    .itemSelected,
                classTab
                    .rx
                    .modelSelected(ClassModel.self))
            .bind { [weak self] indexPath, model in
                self?.pickupVC.getStudentsData2(id: model.classId) // here I am trying to pass reference to update Collection_view_2 views.

            }.disposed(by: disposeBag)
    }
}

</code></pre>

<p><strong>Collection_view_2</strong></p>

<pre><code>class StudentCV: UIViewController, UICollectionViewDelegateFlowLayout {


    let studentCells = BehaviorRelay&lt;[StudentModel]&gt;(value: [])
    var dataSource = RxCollectionViewSectionedAnimatedDataSource&lt;SectionViewModel&gt;(configureCell: {( _,_,_,_ ) in
        fatalError()
    })
    private let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        studentsView.rx.setDelegate(self).disposed(by: disposeBag)
        setupBinding()
    }

    func setupBinding() {

        dataSource.configureCell = { (ds, cv, ip, item) in

            let cell = cv.dequeueReusableCell(withReuseIdentifier: ""studentCV"", for: ip) as! StudentCVCell
            cell.viewModel = item
            return cell
        }
            studentCells
                .asObservable()
                .debug(""Student View: "")
                .map({ [SectionViewModel(header: """", items: $0.filter({$0.pickupStatus == 2}) ), SectionViewModel(header: """", items: $0.filter({$0.pickupStatus == 3}) )] })
                .bind(to: studentsView.rx.items(dataSource: dataSource))
                .disposed(by: disposeBag)
    }
}

</code></pre>

<p><strong>ParentView_Controller</strong></p>

<pre><code>    let studentCells = BehaviorRelay&lt;[StudentModel]&gt;(value: [])
    let classCells = BehaviorRelay&lt;[ClassModel]&gt;(value: [])

    var studentCell : Observable&lt;[StudentModel]&gt; {
        return studentCells.asObservable().debug(""IS DATA IN: "")
    } // this observable is not calling the time I pass reference from Collection_View_1 on tap.
    var classCell : Observable&lt;[ClassModel]&gt; {
        return classCells.asObservable()
    }
    override func viewDidLoad() {
        super.viewDidLoad()
        getAssignedClassData(classId: id)
        self.getStudentsData(id: id)
        bindViewModel()
    }

    func getStudentsData(id: Int) {


    let studentsData = Database.singleton.fetchStudents(byCLassId: id)
                self!.studentCells.accept(Array(studentsData))

        let classData = Database.singleton.fetchClass()
                self!.classCells.accept(Array(classData))

    }
    func getStudentsData2(id: Int) {

        let studentsData = Database.singleton.fetchStudents(byCLassId: id)
                self!.studentCells.accept(Array(studentsData)) // when this calls, observer is not emitting anything. 

    }

    func bindViewModel() {
        self
            .studentCell
            .asObservable()
            .debug(""BIND: "")
            .observeOn(MainScheduler.instance)
            .bind(to: studentsViewController.studentCells)
            .disposed(by: disposeBag)

        self
            .classCell
            .asObservable()
            .debug(""CELL BIND: "")
            .observeOn(MainScheduler.instance)
            .bind(to: classViewController.classCells)
            .disposed(by: disposeBag)
    }
</code></pre>

<p>On tap of <code>collection_view_1</code>. <code>Collection_view_2</code> should update data. and change views accordingly. 
I am doing same thing in another of my view, but the difference is. that <code>collectionView</code> is getting change reference from a <code>buttonClick</code> not from any other CollectionView. Any help regrading my issue will be appreciated. Thanks</p>
","12139340","","","","","2019-10-19 11:18:56","Observable which is Observing BehaviorRelay Only calling for once. RxSwift","<ios><swift><observable><rx-swift><behaviorrelay>","0","0","","","","CC BY-SA 4.0"
"58488482","1","58488666","","2019-10-21 14:29:21","","0","1061","<p>I have 2 separate collections of data in my service.</p>

<p><code>Featured</code> and <code>Standard</code> content.</p>

<p>I have 2 api's calls I make to return these items. They can be consumed separately, however I also have use case when I would like to take both sets of data, provide some enrichment based on a condition and then return them to a consumer.</p>

<p>I was hoping I could do something like this:</p>

<pre class=""lang-swift prettyprint-override""><code>
class ContentService: ContentServiceType {

    let featured = PublishSubject&lt;[Content]&gt;()
    let standard = PublishSubject&lt;[Content]&gt;()

    let content: Observable&lt;(featured: [Content], standard: [Content])&gt;

    private let client: Client&lt;ContentAPI&gt;
    private let disposeBag = DisposeBag()

    init(client: Client&lt;ContentAPI&gt;) {
        self.client = client

        content = Observable
            .combineLatest(featured, standard)
            .map { (featured, standard) -&gt; (featured: [Content], standard: [Content]) in

        /*
            Do some enrichment and create then return new, updated versions
        */

                return (featured: updatedFeatured, standard: updatedStandard)
        }.share()
    }

    func fetchStandardContent(page: Int = 0, size: Int = 100) -&gt; Single&lt;Void&gt; {

        let params = [""page"": page, ""size"": size]
        let request: Single&lt;Content&gt; = client.request(.getStandardContent(params))

        return request.map { [unowned self] launchers in
            self.standard.onNext(content.props)
            return ()
        }
    }

    func fetchFeaturedContent(page: Int = 0, size: Int = 100) -&gt; Single&lt;Void&gt; {

        let params = [""page"": page, ""size"": size]
        let request: Single&lt;Content&gt; = client.request(.getFeaturedContent(params))

        return request.map { [unowned self] content in
            self.featured.onNext(content.props)
            return ()
        }
    }
 }   

</code></pre>

<p>Elsewhere in my apps I was then hoping I could do something like</p>

<pre class=""lang-swift prettyprint-override""><code>        contentSvc.content
            .observeOn(MainScheduler.instance)
            .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))
            .subscribe(onNext: { content in
               /* do something w/ content */
            }).disposed(by: disposeBag)

</code></pre>

<p>And then whenever <code>contentSvc.fetchFeaturedContent</code> or <code>contentSvc.fetchStandardContent</code> is called, the <code>contentSvc.content</code> subscriber above gets new data.</p>

<p>Instead <code>content</code> does not appear to be emitting any values.</p>
","11709138","","","","","2019-10-24 10:23:26","Combine 2 PublishSubject's and emit with Observable.combineLatest","<swift><rx-swift><reactive-swift>","2","0","","","","CC BY-SA 4.0"
"58496745","1","","","2019-10-22 03:38:10","","0","263","<p>I have a <code>UICollectionViewCell</code> that contains a <code>UIButton</code>.</p>

<p>When tapping the button in a cell, I want to toggle the <code>selected</code> state.</p>

<p>This works to an extent, the bug I am seeing is, clicking in 1 cell toggles the state in another cell also.</p>

<pre class=""lang-swift prettyprint-override""><code>
import UIKit
import RxSwift

class PersonaliseYourAppsListCell: BaseCollectionViewCell&lt;Launcher&gt; {

    let toggleSelectedTrigger = PublishSubject&lt;String&gt;()

    private let disposeBag = DisposeBag()

    override init(frame: CGRect) {
        super.init(frame: frame)

        configureSubviews()
    }

    required init?(coder: NSCoder) {
        return nil
    }

    override func render(with model: Launcher?) {
        guard let model = model else { return }

        title.text = model.name
        icon.image = model.icon

        toggleButton.rx.tap.bind { [weak self] in
            self?.toggleButton.isSelected.toggle()
            self?.toggleSelectedTrigger.onNext(model.id)
        }.disposed(by: disposeBag)

        if let status = model.status {
            toggleButton.isSelected = model.selected ?? false
            toggleButton.isUserInteractionEnabled = status != .forced

            [title, icon, toggleButton].forEach {
                $0.alpha = status == .forced ? 0.6 : 1
            }

            if status == .forced {
                addSubviews(enforcedLabel)
                enforcedLabel.position(top: title.bottomAnchor, leading: title.leadingAnchor, withPadding: .zero)
            }
        }
    }

    override func prepareForReuse() {
        super.prepareForReuse()
        enforcedLabel.removeFromSuperview()
    }

    // MARK:- UI Elements

    private func configureSubviews() {
        addSubviews(icon, title, toggleButton, separatorView)

        icon
            .isCenteredY()
            .position(
                leading: leadingAnchor,
                withPadding: .init(top: 0, left: 16, bottom: 0, right: 4)
        )

        title
            .isCenteredY()
            .position(
                leading: icon.trailingAnchor, trailing: toggleButton.leadingAnchor,
                withPadding: .init(top: 0, left: 8, bottom: 0, right: 8)
        )

        toggleButton
            .isCenteredY()
            .withSize(.init(width: 44, height: 44))
            .position(trailing: trailingAnchor, withPadding: .init(top: 0, left: 0, bottom: 0, right: 16))

        separatorView
            .isCenteredX()
            .withSize(.init(width: frame.width - 48, height: 1))
            .position(bottom: bottomAnchor)
    }

    private lazy var icon: UIImageView = {
        let iv = UIImageView(frame: .zero)
        iv.contentMode = .scaleAspectFit
        [iv.widthAnchor, iv.heightAnchor].forEach { $0.constraint(equalToConstant: 64).isActive = true }
        return iv
    }()

    private lazy var title: UILabel = {
        let label = UILabel(frame: .zero)
        label.font = .systemFont(ofSize: 20)
        label.textAlignment = .left
        label.numberOfLines = 2
        label.textColor = .usingHex(""444444"")
        return label
    }()

    private lazy var toggleButton: CheckBoxButton = {
        let button = CheckBoxButton(type: .custom)
        return button
    }()

    private lazy var enforcedLabel: UILabel = {
        let label = UILabel(frame: .zero)
        label.text = ""This app cannot be removed""
        label.font = .systemFont(ofSize: 12)
        label.textColor = .lightGray
        return label
    }()

    private lazy var separatorView: UIView = {
        let view = UIView()
        view.backgroundColor = UIColor(white: 0.3, alpha: 0.1)
        return view
    }()
}
</code></pre>

<p>My CollectionView is setup as follows:</p>

<pre class=""lang-swift prettyprint-override""><code>    override func viewDidLoad() {
        super.viewDidLoad()

        presenter?.viewIsReady.onNext(())

        presenter?.data.bind(to: customView.collectionView.rx.items) { [weak self] (cv, row, item) -&gt; UICollectionViewCell in

            let cell = cv.dequeueReusableCell(withClass: PersonaliseYourAppsListCell.self, for: .init(row: row, section: 0))
            cell.render(with: item)

            if let self = self, let presenter = self.presenter {
                cell.toggleSelectedTrigger.bind(to: presenter.updateUserAppsTrigger).disposed(by: self.disposeBag)
            }

            return cell

        }.disposed(by: disposeBag)

        customView.configureLayout()
    }
</code></pre>

<p><strong>EDIT</strong></p>

<p>I've noticed if I do not make the api call and just let the buttons state toggle, the bug does not exist. I wonder if the response is reloading the collection view and due to re use the wrong button state is being updated.</p>

<p><strong>EDIT 2</strong></p>

<p>If I trigger the API call by selecting the cell instead of the button everything works, However I would like this to happen on button click.</p>

<p>I suspect still this is something todo with button state.</p>

<p><a href=""https://i.stack.imgur.com/L0oOt.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/L0oOt.gif"" alt=""enter image description here""></a></p>
","11709138","","11709138","","2019-10-22 05:51:52","2019-10-22 11:31:32","Button tap in UICollectionViewCell toggles state in another cell also","<ios><swift><uicollectionview><uicollectionviewcell><rx-swift>","1","9","","","","CC BY-SA 4.0"
"58506785","1","","","2019-10-22 14:41:52","","0","808","<p>I'm building an iOS app, using RxSwift and SwiftUI. I'm completely new to these frameworks so I was following a few tutorials, but I'm having a hard time figuring how to setup a Observer coupled with SwiftUI whereas I'd like to keep updating my UI as long as my <code>BehaviorRelay</code> list of events is updated, here's what I've got in my UI:</p>

<pre><code>import SwiftUI
import RxSwift

struct EventsTableView: View {

    private let observer: EventsTableObserver = EventsTableObserver()

    init() {
        observer.setObserver()
        EventViewModel.getAllEvents()
    }

    var body: some View {
            List{
                ForEach(observer.events_view,id: \.id) { event in
                    HStack {
                      Text(event.title)
                    }
                }
            }
    }
}

class EventsTableObserver {

    private let disposeBag = DisposeBag()
    var events_view = [Event]()

    func setObserver(){
        EventGroup.shared.events.asObservable()
        .subscribe(onNext: {
            [unowned self] events in
            self.events_view = events
        })
        .disposed(by: disposeBag)
    }
}
</code></pre>

<p>The problem is that apparently after my closure ends, <code>self.events_view</code> is not keeping the stored events values as I'd like to, even though the events are being updated. Can someone give me a direction here?</p>
","2712469","","","","","2019-10-22 14:41:52","SwiftUI and RxSwift Observer Closure Behavior","<swift><swiftui><rx-swift>","0","2","","","","CC BY-SA 4.0"
"58510460","1","","","2019-10-22 18:37:43","","0","71","<p>I've formulated a previous question on a subject related to this, but more specifically now: I'm curious about the behavior of a <code>@State</code> variable when inside a closure, apparently from what I've tested the variable can't be updated, I've looked around a few articles but couldn't find the answer. Specifically, this is what I've been dealing with:</p>

<pre><code>private let disposeBag = DisposeBag()
@State var eventsView = [Event]()

func setObserver(){
    EventGroup.shared.events.asObservable()
    .subscribe(onNext: {
        [unowned self] events in
        print(""Events Resp: ""+String(events.count))
        self.eventsView = events
        print(""Events Count: ""+String(self.eventsView.count))
    })
    .disposed(by: disposeBag)
}
</code></pre>

<p>The result of the prints above is:</p>

<pre><code>Events Resp: 3
Events Count: 0
</code></pre>

<p>How come, the <code>eventsView</code> variable is not updated?</p>
","2712469","","","","","2019-10-22 21:07:08","SwiftUI State PropertyWrapper Behavior","<swift><swiftui><rx-swift>","1","1","","","","CC BY-SA 4.0"
"58517228","1","58518862","","2019-10-23 07:05:34","","1","619","<p>I have an observable sequence of <code>Int</code>s:</p>

<pre><code>-1-2-3-4-5-6-3-4-5-1-
</code></pre>

<p>For example, I need to detect when the previous element was bigger than the last one.</p>

<p>In this sequence it's <code>(6, 3)</code> and <code>(5, 1)</code>:</p>

<pre><code>-1-2-3-4-5-6-3-4-5-1-
-------------ˆ-----ˆ-
</code></pre>

<p>Which operator I can use in this case?</p>
","3574762","","","","","2019-10-23 08:46:15","Operator with two last elements from Observable in RxSwift","<observable><reactive-programming><rx-swift><reactive>","1","1","","","","CC BY-SA 4.0"
"58520265","1","58520425","","2019-10-23 09:59:41","","1","392","<p>I simply added two observables:</p>

<pre><code>    mainView.textField.rx.text.orEmpty.bind(to: viewModel.searchPhrase).disposed(by: bag)
    mainView.textField.rx.controlEvent(.editingChanged).asObservable().subscribe(onNext: { [weak self] in
       print(""voilala"")
    }).disposed(by: bag)
</code></pre>

<p>Now I would like to call actions from code to perform subscriptions and binding. Is it possible?</p>
","2725435","","","","","2019-10-23 21:09:31","How to manually perform action for UITextField editing changed observed with rx?","<ios><swift><rx-swift>","3","0","","","","CC BY-SA 4.0"
"58587566","1","","","2019-10-28 08:20:22","","1","247","<p>I am trying to use <code>Diffing</code> with <code>RxSwift</code> in a basic example for now. I am using the <a href=""https://github.com/tonyarnold/Differ"" rel=""nofollow noreferrer"">Differ</a> library.</p>

<p>Here is my <code>Interactor</code> + <code>ViewModel</code>s associated:</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import RxSwift
import RxCocoa

class Interactor {

    var items = [
            [1,5,6,7,4,6,7,1,5],
            [1,5,2,1,0,6,7],
    ]

    let viewModel: BehaviorRelay&lt;ViewModel&gt;

    var currentObjects: Int = 0 {
        didSet {
            viewModel.accept(.init(with: .loaded(items[currentObjects])))
        }
    }

    init() {
        viewModel = BehaviorRelay(value: .init(with: .initialized))
    }

    func fetchValue() {
        currentObjects = currentObjects == 0 ? 1 : 0
    }


}

struct ViewModel {

    enum ViewModelType: Equatable {
        case cell(CellViewModel)
    }

    enum State {
        case initialized
        case loaded([Int])
    }

    let state: State
    let viewModels: [ViewModelType]

    init(with state: State) {
        self.state = state
        switch state {
        case .initialized: viewModels = []
        case .loaded(let values):
            viewModels = CellViewModel.from(values).map(ViewModelType.cell)
        }
    }
}

extension ViewModel: Equatable {

    static func ==(left: ViewModel, right: ViewModel) -&gt; Bool {
        return left.state == left.state
    }
}

extension ViewModel.State: Equatable {

    static func ==(left: ViewModel.State, right: ViewModel.State) -&gt; Bool {
        switch (left, right) {
        case (.initialized, .initialized): return true
        case let (.loaded(l), .loaded(r)): return l == r
        default: return false
        }
    }
}

struct CellViewModel {
    let description: String
}

extension CellViewModel {

    static func from(_ values: [Int]) -&gt; [CellViewModel] {
        return values.map { CellViewModel(description: String($0)) }
    }
}

extension CellViewModel: Equatable {

    static func ==(left: CellViewModel, right: CellViewModel) -&gt; Bool {
        return left.description == right.description
    }
}
</code></pre>

<p>Now for the view I am using a simple `UITableView</p>

<pre class=""lang-swift prettyprint-override""><code>import UIKit
import Differ
import RxSwift

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        ...

        interactor
            .viewModel
            .asObservable()
            .scan([], accumulator: { (previous, current) in
              Array(previous + [current]).suffix(2)
            })
            .map({ (arr) -&gt; (previous: ViewModel?, current: ViewModel) in
              (arr.count &gt; 1 ? arr.first : nil, arr.last!)
            }).subscribe(onNext: { [weak self] (previous, current) in
                if let prev = previous {
                    print(""Previous =&gt; State: \(prev.state) | ViewModelType.count: \(prev.viewModels.count)"")
                } else {
                    print(""Previous =&gt; State: nil | ViewModelType.count: nil"")
                }
                print(""Current =&gt; State: \(current.state) | ViewModelType.count: \(current.viewModels.count)"")
                guard let strongSelf = self else { return }
                DispatchQueue.main.async {
                    strongSelf.tableView.animateRowChanges(oldData: previous?.viewModels ?? [], newData: current.viewModels)
                }
            }).disposed(by: disposeBag)

        interactor.fetchValue()
    }

    @objc
    func onRefresh() {
        interactor.fetchValue()
    }
}

extension ViewController: UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        return interactor.viewModel.value.viewModels.count
    }

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
        let cellViewModel = interactor.viewModel.value.viewModels[indexPath.row]
        switch cellViewModel {
        case .cell(let viewModel):
            let cell = tableView.dequeueReusableCell(withIdentifier: ""cell"", for: indexPath)
            cell.textLabel?.text = viewModel.description
            return cell
        }
    }
}
</code></pre>

<p>With everything conforming to Equatable, I thought the job would be done but I got an <code>NSInternalInconsistencyException</code> exception.</p>

<p><code>*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Invalid update: invalid number of rows in section 0. The number of rows contained in an existing section after the update (7) must be equal to the number of rows contained in that section before the update (7), plus or minus the number of rows inserted or deleted from that section (7 inserted, 0 deleted) and plus or minus the number of rows moved into or out of that section (0 moved in, 0 moved out).'</code></p>

<p>The prints I put to check what came from Rx before the crash show:</p>

<pre class=""lang-none prettyprint-override""><code>Previous =&gt; State: nil | ViewModelType.count: nil
Current =&gt; State: initialized | ViewModelType.count: 0
Previous =&gt; State: initialized | ViewModelType.count: 0
Current =&gt; State: loaded([1, 5, 2, 1, 0, 6, 7]) | ViewModelType.count: 7
</code></pre>

<p>The flow looks good to me in a logic stand point. Am I missing something?</p>

<hr>

<h1>Edit 2019/10/29</h1>

<p>I have made another version without using <code>RxSwift</code> to know if the problem was du to <code>RxSwift</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>protocol InteractorDelegate: class {
    func viewModelDidChange(_ old: ViewModel?, _ new: ViewModel)
}

class Interactor {

    weak var delegate: InteractorDelegate?

    var items = [
            [1,5,6,7,4,6,7,1,5],
            [1,5,2,1,0,6,7],
    ]

    var viewModel: ViewModel? {
        didSet {
            delegate?.viewModelDidChange(oldValue, viewModel!)
        }
    }

    var currentObjects: Int = 0 {
        didSet {
            viewModel = .init(with: .loaded(items[currentObjects]))
        }
    }

    init() {
        viewModel = .init(with: .initialized)
    }

    func fetchValue() {
        currentObjects = currentObjects == 0 ? 1 : 0
    }
}
</code></pre>

<p>For the <code>ViewController</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>extension ViewController: InteractorDelegate {

    func viewModelDidChange(_ old: ViewModel?, _ new: ViewModel) {

        if let prev = old {
            print(""Previous =&gt; State: \(prev.state) | ViewModelType.count: \(prev.viewModels.count)"")
        } else {
            print(""Previous =&gt; State: nil | ViewModelType.count: nil"")
        }
        print(""Current =&gt; State: \(new.state) | ViewModelType.count: \(new.viewModels.count)"")
        DispatchQueue.main.async {
            self.tableView.animateRowChanges(oldData: old?.viewModels ?? [], newData: new.viewModels)
        }
    }
}
</code></pre>

<p>Seems that the issue is still same without <code>RxSwift</code>:</p>

<pre class=""lang-none prettyprint-override""><code>Previous =&gt; State: initialized | ViewModelType.count: 0
Current =&gt; State: loaded([1, 5, 2, 1, 0, 6, 7]) | ViewModelType.count: 7
2019-10-29 13:45:56.636678+0900 TestDiffer[93631:21379549] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Invalid update: invalid number of rows in section 0. The number of rows contained in an existing section after the update (7) must be equal to the number of rows contained in that section before the update (7), plus or minus the number of rows inserted or deleted from that section (7 inserted, 0 deleted) and plus or minus the number of rows moved into or out of that section (0 moved in, 0 moved out).'
</code></pre>

<p>Is there a problem with my <code>Equatable</code>s conformance?</p>

<hr>

<h1>Edit 2019/10/29 #2</h1>

<p>After new tests, I saw that the crash occurred only when the previous value is empty.</p>

<p>Everything is working fine with with changing the code like this:</p>

<pre class=""lang-swift prettyprint-override""><code>extension ViewController: InteractorDelegate {

    func viewModelDidChange(_ old: ViewModel?, _ new: ViewModel) {

        DispatchQueue.main.async {
            guard old != nil &amp;&amp; !old!.viewModels.isEmpty else {
                self.tableView.reloadData()
                return
            }
            self.tableView.animateRowChanges(oldData: old!.viewModels, newData: new.viewModels)
        }
    }
}
</code></pre>

<p>Same success when putting back RxSwift instead of the delegate.</p>

<p>Even if it is working as expected now. I am still questioning why the diffing isn't working when the array is empty. Having an previous value empty and a new value with 2 elements should be analyzed as 2 inserts no? What is going on here?</p>
","5127193","","5127193","","2019-10-29 14:07:44","2020-05-31 13:33:15","RxSwift Differ library crash `NSInternalInconsistencyException`","<ios><swift><uitableview><rx-swift>","2","0","","","","CC BY-SA 4.0"
"58597531","1","58608608","","2019-10-28 19:52:04","","5","4040","<p>I'm in the process of migrating an existing app using MVC that makes heavy use of the delegation pattern to MVVM using RxSwift and RxCocoa for data binding.</p>

<p>In general each View Controller owns an instance of a dedicated View Model object. Let's call the View Model <code>MainViewModel</code> for discussion purposes. When I need a View Model that drives a UITableView, I generally create a <code>CellViewModel</code> as a <code>struct</code> and then create an observable sequence that is converted to a driver that I can use to drive the table view.</p>

<p>Now, let's say that the UITableViewCell contains a button that I would like to bind to the <code>MainViewModel</code> so I can then cause something to occur in my interactor layer (e.g. trigger a network request). I'm not sure what is the best pattern to use in this situation.</p>

<p>Here is a simplified example of what I've started out with (see 2 specific question below code example):</p>

<p><strong>Main View Model:</strong></p>

<pre><code>class MainViewModel {

   private let buttonClickSubject = PublishSubject&lt;String&gt;()   //Used to detect when a cell button was clicked.

   var buttonClicked: AnyObserver&lt;String&gt; {
      return buttonClickSubject.asObserver()
   }

   let dataDriver: Driver&lt;[CellViewModel]&gt;

   let disposeBag = DisposeBag()

   init(interactor: Interactor) {
      //Prepare the data that will drive the table view:
      dataDriver = interactor.data
                      .map { data in
                         return data.map { MyCellViewModel(model: $0, parent: self) }
                      }
                      .asDriver(onErrorJustReturn: [])

      //Forward button clicks to the interactor:
      buttonClickSubject
         .bind(to: interactor.doSomethingForId)
         .disposed(by: disposeBag)
   }
}
</code></pre>

<p><strong>Cell View Model:</strong></p>

<pre><code>struct CellViewModel {
   let id: String
   // Various fields to populate cell

   weak var parent: MainViewModel?

   init(model: Model, parent: MainViewModel) {
      self.id = model.id
      //map the model object to CellViewModel

      self.parent = parent
   }
}
</code></pre>

<p><strong>View Controller:</strong></p>

<pre><code>class MyViewController: UIViewController {
    let viewModel: MainViewModel
    //Many things omitted for brevity

    func bindViewModel() {
        viewModel.dataDriver.drive(tableView.rx.items) { tableView, index, element in
            let cell = tableView.dequeueReusableCell(...) as! TableViewCell
            cell.bindViewModel(viewModel: element)
            return cell
        }
        .disposed(by: disposeBag)
    }
}
</code></pre>

<p><strong>Cell:</strong></p>

<pre><code>class TableViewCell: UITableViewCell {
    func bindViewModel(viewModel: MyCellViewModel) {
        button.rx.tap
            .map { viewModel.id }       //emit the cell's viewModel id when the button is clicked for identification purposes.
            .bind(to: viewModel.parent?.buttonClicked)   //problem binding because of optional.
            .disposed(by: cellDisposeBag)
    }
}
</code></pre>

<p><strong>Questions:</strong></p>

<ol>
<li>Is there a better way of doing what I want to achieve using these technologies?</li>
<li>I declared the reference to parent in <code>CellViewModel</code> as weak to avoid a retain cycle between the Cell VM and Main VM. However, this causes a problem when setting up the binding because of the optional value (see line <code>.bind(to: viewModel.parent?.buttonClicked)</code> in TableViewCell implemenation above.</li>
</ol>
","3785179","","3785179","","2019-10-29 00:15:31","2020-03-03 02:18:49","Best practice for binding controls in UITableViewCell to ViewModel using RxSwift","<ios><mvvm><rx-swift>","2","0","2","","","CC BY-SA 4.0"
"58630696","1","","","2019-10-30 17:20:57","","0","134","<p>I've written module based on RxSwift with Viewcontroller and ViewModel. ViewModel contains gesture's observers and images observables. Everything works well, except situation when application <code>didBecameActive</code> directly to mentioned module. Subscriptions of gestures don't work and <code>imageView</code> become blank. </p>

<p>They are set inside subscription to observable based on <code>BehaviorSubjects</code>, inside view:</p>

<pre><code>    func subscribePhotos(observerable: Observable&lt;[(Int, UIImage?)]&gt;) {
        disposeBag = DisposeBag()
        observerable.subscribeOnNext { [weak self] array in
            array.forEach { identifier, image in
                if let pictureView = self?.subviews.first(where: { view -&gt; Bool in
                    guard let view = view as? PictureView else {
                        return false
                    }
                    return view.identifier == identifier
                }) as? PictureView {
                    pictureView.set(image)
                }
            }
        }.disposed(by: disposeBag)
     }
</code></pre>

<p>In viewModel I set <code>Observable</code>:</p>

<pre><code>var imagesObservable: Observable&lt;[(Int, UIImage?)]&gt; {
    do {
        let collection = try photosSubject.value()
        if let photosObservables = collectionCreator?.getPhotosDetailsObservables(identifiers: collection.photoIdentifiers) {
            let photosObservable = Observable.combineLatest(photosObservables)
            return Observable.combineLatest(photosSubject, photosObservable,
                                            resultSelector: { collection, currentArray -&gt; [(Int, UIImage?)] in
                var newArray = [(Int, UIImage?)]()
                currentArray.forEach { stringIdentifier, image in
                    if let picture = grid.pictures.first(where: { $0. stringIdentifier == stringIdentifier }) {
                        newArray.append((picture.identifier, image))
                    }
                }
                return newArray
            })
        }
    } catch { }
    return Observable&lt;[(Int, UIImage?)]&gt;.never()
}
</code></pre>

<p>}</p>

<p><code>photosSubject</code> is initialized in viewModel's init </p>

<pre><code>        photosSubject = BehaviorSubject&lt;PictureCollection&gt;(value: collection)
</code></pre>

<p>photosObservale</p>

<pre><code>    func createImageObservableForAsset(asset: PHAsset, size: CGSize) -&gt; Observable&lt;UIImage?&gt; {
        return Observable.create { obs in

            PHImageManager.default().requestImage(for: asset,
                                                  targetSize: size,
                                                  contentMode: .aspectFit,
                                                  options: nil,
                                                  resultHandler: { image, _ in
                                                    obs.onNext(image)
            })

            return Disposables.create()
        }
    }
</code></pre>

<p>And in ViewController I connect them by calling method of view:</p>

<pre><code>        myView.pictureView.subscribePhotos(observerable: viewModel.imagesObservable)
</code></pre>

<p>After <code>didBecameActive</code> <code>pictureView</code>'s property image of type <code>UIImage</code> isn't nil, but they disappear. I could listen notification <code>didBecameActive</code> and invoke <code>onNext</code> on observer, but I’m not sure is it correct way to figure out problem.  Any idea what's reason of that? </p>
","9623723","","4856564","","2019-10-31 09:50:47","2019-10-31 11:14:32","RxSwift subscriptions after didBecomeActive","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58642594","1","","","2019-10-31 11:41:05","","1","488","<p>Whenever there's an event on my items <code>Observable</code>, selection and contentOffset on <code>UICollectionView</code> is gone. Here's my binding code:</p>

<pre><code>items.bind(to: collectionView.rx.items) { [weak self] collectionView, item, model in
            guard let `self` = self else { return UICollectionViewCell() }
            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: MyCollectionViewCell.reuseIdentifier, for: IndexPath(item: item, section: 0)) as! MyCollectionViewCell
            cell.configure(with: model)
            return cell
            }.disposed(by: disposeBag)
</code></pre>

<p>I want items to be appended and keep the contentOffset and selection as is.</p>
","10384998","","","","","2019-10-31 12:52:54","RxSwift - How to keep UICollectionView's contentOffSet and selection when data source changes","<ios><uicollectionview><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58643150","1","58643680","","2019-10-31 12:14:52","","0","264","<p>I use RxCocoa, I have code like this,</p>

<pre><code>func debug(){
        isUserInteractionEnabled = true
        let tap = UITapGestureRecognizer()
        tap.numberOfTapsRequired = 2
        addGestureRecognizer(tap)


        tap.rx.event.bind { (event) in

            if self.phone.text == Phone.one{
                self.phone.text = Phone.two
            }
            else{
                self.phone.text = Phone.one
            }
            self.verification.text = """"
        }.disposed(by: rx.disposeBag)

    }
</code></pre>

<p>I want to do some encapsulation, turn the above to this:</p>

<pre><code>func debug( _ event: (UITapGestureRecognizer) -&gt; Void){


        isUserInteractionEnabled = true
        let tap = UITapGestureRecognizer()
        tap.numberOfTapsRequired = 2
        addGestureRecognizer(tap)
        tap.rx.event.bind(to: event).disposed(by: rx.disposeBag)

    }
</code></pre>

<p>Xcode reports:</p>

<blockquote>
  <p>Cannot invoke 'bind' with an argument list of type '(to: (UITapGestureRecognizer) -> Void)'</p>
</blockquote>

<p>I try </p>

<pre><code> func debug( _ event: @escaping (UITapGestureRecognizer) -&gt; Void){
</code></pre>

<p>Xcode reports:</p>

<pre><code> Cannot invoke 'bind' with an argument list of type '(to: @escaping (UITapGestureRecognizer) -&gt; Void)'
</code></pre>

<hr>

<p><strong>What matters?  Rx name space?</strong></p>

<p>When I type <code>event</code>in the former, Xcode tips <code>event</code> is <code>UITapGestureRecognizer</code></p>

<p><a href=""https://i.stack.imgur.com/YScBE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YScBE.png"" alt=""111""></a></p>
","10332481","","","","","2019-10-31 12:46:23","RxCocoa: Cannot invoke 'bind' with an argument list of type '(to: (UITapGestureRecognizer) -> Void)'","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58654281","1","","","2019-11-01 04:56:23","","3","496","<p>I have create a class called notification Item and parsing the data from model class RTVNotification</p>

<p>import Foundation
import RTVModel</p>

<p>public class NotificationItem: NSObject {</p>

<pre><code>public var id: String
public var title: String
public var comment: String
public var publishStartDateString: String

init(id: String,
     title: String,
     comment: String,
     publishStartDateString: String) {
    self.id = id
    self.title = title
    self.comment = comment
    self.publishStartDateString = publishStartDateString

    super.init()
}
</code></pre>

<p>}</p>

<p>extension NotificationItem {
    static func instantiate(with notification: RTVNotification) -> NotificationItem? {</p>

<pre><code>    return NotificationItem(
        id: notification.id,
        title: notification.title,
        comment: notification.comment,
        publishStartDateString: notification.publishStartDateString)

}
</code></pre>

<p>}</p>

<p>ViewModel</p>

<p>public class SettingsViewModel: ViewModel {</p>

<pre><code>var item = [NotificationItem]()

public var fetchedNotifications: Driver&lt;NotificationItem&gt; = .empty()

public var apiErrorEvents: Driver&lt;RTVAPIError&gt; = .empty()

public var notificationCount: Driver&lt;Int&gt; = .empty()

public func bindNotificationEvents(with trigger: Driver&lt;Void&gt;) {

    let webService: Driver&lt;RTVInformationListWebService&gt; = trigger
        .map { RTVInformationListParameters() }
        .webService()

    let result = webService.request()
    apiErrorEvents = Driver.merge(apiErrorEvents, result.error())
    notificationCount = result.success().map {$0.informationList.maxCount }
    fetchedNotifications =
         result.success()
        .map {$0.informationList.notifications}
</code></pre>

<p>----->      .map {NotificationItem.instantiate(with: $0)}</p>

<pre><code>}
</code></pre>

<p>}</p>

<p>Getting an Error saying that Cannot convert value of type '[RTVNotification]' to expected argument type 'RTVNotification'
What can i do to solve this.</p>
","12302627","","","","","2019-11-02 11:30:05","Instance method 'drive' requires the types 'NotificationItem' and '[NotificationItem]' be equivalent","<swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"58673477","1","58676792","","2019-11-02 17:26:02","","0","144","<p>I am new to ios and rxswift. Trying create mvvm architecture for new app.</p>

<p>If I set observable isSuccess  value before calling appStartNetwork.fetchApp() I can observe value. But when I set isSuccess value in fetchApp() on next, Observer in viewcontroller cant be triggered</p>

<p>Whats wrong?</p>

<p>ViewModel</p>

<pre><code>class SplashViewModel {
var isSuccess = PublishSubject&lt;Bool&gt;()
var isLoading = PublishSubject&lt;Bool&gt;()

private let bag = DisposeBag()
func fetchAppStart() {
    self.isLoading.onNext(true)

    let appStartNetwork=NetworkProvider.shared.makeAppStartNetwork()
    appStartNetwork.fetchApp().subscribe(onNext: { [weak self] apiResult in
        switch apiResult{
        case let .success(response):
            //some codes
            self?.isLoading.onNext(false)
            self?.isSuccess.onNext(true)
            break
        case let .failure(errorContent):
            break
        }
        },onError:{ err in
            self.isLoading.onNext(false)
            self.isSuccess.onNext(false)
    }).disposed(by: bag)
}   }
</code></pre>

<p>View Controller </p>

<pre><code>func getAppStart(){
    let splashVm=SplashViewModel()
    let disposeBag = DisposeBag()
    splashVm.isSuccess.subscribe(onNext: { (ok) in
        if(ok){
            print(""splash success"")
            self.navigateMain()
        }else{
            self.showAlert(""splash fail"")
        }

    },onError:{ err in
        self.showAlert(err.localizedDescription)
    }).disposed(by: disposeBag)
    splashVm.fetchAppStart()
 }
</code></pre>
","1503083","","","","","2019-11-03 01:45:54","RxSwift set observable value in another observable next , not working","<ios><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58678260","1","","","2019-11-03 07:35:41","","0","113","<p>I am <code>Rx-Swift</code> beginner. I am trying to get <code>UIButton</code> action which is present inside <code>UITableViewCell</code>.</p>

<p><strong>Attempt:</strong></p>

<ol>
<li>I have tried with <code>UITableViewCell's</code> instance that I can get from <code>UIViewController</code>. Thats working fine.</li>
</ol>

<p><strong>Need:</strong></p>

<ul>
<li>How can I transfer that clicked tag value from <code>awakeFromNib()</code> to <code>UIViewController</code> ?</li>
</ul>

<p><strong>Code:</strong></p>

<pre><code>// UITableViewCell

class TripInfoCell: UITableViewCell {

    @IBOutlet weak var btnMore: UIButton!
    var cellbag = DisposeBag()

    override func prepareForReuse() {
        super.prepareForReuse()

        cellbag = DisposeBag()
    }

    override func awakeFromNib() {
        super.awakeFromNib()


        btnMore.rx.tap.asObservable()
           .subscribe { _ in

            print(""Tapping_   "", self.tag)

        }.disposed(by: cellbag)

    }

}


// UIViewController
override func viewDidLoad() {
    super.viewDidLoad()

    Observable.of(visitsModel).bind(to: tblView.rx.items(cellIdentifier: ""cell"", cellType: TripInfoCell.self)) { (row, element, cell) in

       cell.tag = row

    }
    .disposed(by: disposeBag)
}
</code></pre>

<p><strong>Attempt:</strong></p>

<p>Here, <code>UIButton</code> action I have used inside <code>UIViewController</code>. So I can transfer data. </p>

<pre><code>Observable.of(visitsModel).bind(to: tblView.rx.items(cellIdentifier: ""cell"", cellType: TripInfoCell.self)) { (row, element, cell) in

      cell.tag = row

      cell.btnMore.rx.tap.asObservable()
           .subscribe { _ in

           print(""Inside_Tapping_   "", cell.tag)

      }.disposed(by: cell.cellbag)


}
</code></pre>
","4384775","","4384775","","2019-11-03 12:35:34","2019-11-03 12:35:34","RxSwift: button click action from awakeFromNib to UIViewController","<ios><swift><rx-swift>","0","4","","","","CC BY-SA 4.0"
"58680640","1","","","2019-11-03 13:31:07","","0","38","<p>---------RTV Notification------------------</p>

<pre><code>import Foundation
///Notification Info
public class RTVNotification: Codable {
    public let id: String
    public let title: String
    public let comment: String
    public let urlString: String
    public let supportedDevice: String
    public let publishStartDateString: String
    required public init(from decoder: Decoder) throws {
        id = try decoder.decode(CodingKeys.id)
        title = try decoder.decode(CodingKeys.title)
        comment = try decoder.decode(CodingKeys.comment)
        urlString = try decoder.decode(CodingKeys.urlString)
        supportedDevice = try decoder.decode(CodingKeys.supportedDevice)
        publishStartDateString = try decoder.decode(CodingKeys.publishStartDateString)
    }
    public func encode(to encoder: Encoder) throws {}
}
// MARK: - CodingKeys
private extension RTVNotification {
    enum CodingKeys: String, CodingKey {
        case id = ""id""
        case title = ""name""
        case comment = ""comment""
        case urlString = ""url""
        case supportedDevice = ""supported_device""
        case publishStartDateString = ""show_started_at""
    }
}
</code></pre>

<p>----------    RTV InformationList-----------------------------</p>

<pre><code>   import Foundation
    // MARK: InformationList
    public class RTVInformationList: Codable {
        public let offset: Int
        public let count: Int
        public let maxCount: Int
        public let notifications: [RTVNotification]
        required public init(from decoder: Decoder) throws {
            offset = try decoder.decodeInt(CodingKeys.offset)
            count = try decoder.decodeInt(CodingKeys.count)
            maxCount = try decoder.decodeInt(CodingKeys.maxCount)
            notifications = (try? decoder.decode(CodingKeys.notifications)) ?? []
        }
        public func encode(to encoder: Encoder) throws {}
    }
    // MARK: - CodingKeys
    private extension RTVInformationList {
        enum CodingKeys: String, CodingKey {
            case offset = ""offset""
            case count = ""count""
            case maxCount = ""max_count""
            case notifications = ""information_list""
        }
    }
</code></pre>

<p>--------------- NotificationItem----------------------</p>

<pre><code>public class NotificationItem: Codable {
    public let id: String
    public let title: String
    public let comment: String
    public let urlString: String
    public let supportedDevice: String
    public var publishStartDateString: String
    init(id: String,
         title: String,
         comment: String,
         urlString: String,
         supportedDevice: String,
         publishStartDateString: String) {
        self.id = id
        self.title = title
        self.comment = comment
        self.urlString = urlString
        self.supportedDevice = supportedDevice
        self.publishStartDateString = publishStartDateString
    }
}
extension NotificationItem {
    static func instantiate(with notification: RTVNotification) -&gt; NotificationItem {
            NotificationItem(
            id: notification.id,
            title: notification.title,
            comment: notification.comment,
            urlString: notification.urlString,
            supportedDevice: notification.supportedDevice,
            publishStartDateString: notification.publishStartDateString)
    }
}
</code></pre>

<p>----------------   Settings View Model--------------------</p>

<pre><code>public class SettingsViewModel: ViewModel {
    var item = [NotificationItem]()
    public var fetchedNotifications: Driver&lt;[RTVNotification]&gt; = .empty()
    public var apiErrorEvents: Driver&lt;RTVAPIError&gt; = .empty()
    public var notificationCount: Driver&lt;Int&gt; = .empty()
    public func bindNotificationEvents(with trigger: Driver&lt;Void&gt;) {
        let webService: Driver&lt;RTVInformationListWebService&gt; = trigger
            .map { RTVInformationListParameters() }
            .webService()
        let result = webService.request()
        apiErrorEvents = Driver.merge(apiErrorEvents, result.error())
        notificationCount = result.success().map {$0.informationList.maxCount }
        fetchedNotifications = result.success()
            .map {$0.informationList.notifications}
----&gt;       .map {$0.map {NotificationItem.instantiate(with: $0)}}
    }
}
</code></pre>

<p>Getting Error :- Cannot convert value of type 'NotificationItem' to closure result type 'RTVNotification' Im not understanding how to convert the types.Im new to Programming</p>
","12302627","","","","","2019-11-03 15:28:17","Getting Error:-Cannot convert value of type 'NotificationItem' to closure result type 'RTVNotification'","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58691470","1","58725204","","2019-11-04 10:26:13","","1","6570","<p>I have an Observable to perform some task and I want it to give me result after 5 seconds but it gives me before that and sometimes after 5 seconds depending upon the complexity.</p>

<p>For example: </p>

<p>If my code completed the task in 2 seconds and is about to emit the computed value. I want it to wait for more 3 remaining seconds and then emit the computed value.</p>

<p>How can I achieve this? I have heard about debounce and throttle.</p>
","5744323","","","","","2020-01-26 18:52:01","How to put delay in RxSwift?","<delay><rx-swift>","2","0","1","","","CC BY-SA 4.0"
"58698552","1","58702898","","2019-11-04 17:41:27","","3","246","<p>I have a <code>ContentService</code> that makes a request for an article. That article response contains an <code>authorId</code> property. </p>

<p>I have a <code>ProfileService</code> that allows me to request a user profile by an <code>userId</code>.</p>

<p>I am trying to request an article from the <code>ContentService</code>, chain on a request once that completes to the <code>ProfileService</code> using the <code>authorId</code> property, I would then like to return a <code>ContentArticleViewModel</code> that contains both the article and profile information.</p>

<p>My <code>ArticleInteractor</code> looks something like this -</p>

<pre class=""lang-swift prettyprint-override""><code>final class ArticleInteractor: ArticleInteractorInputProtocol {

    let fetchArticleTrigger = PublishSubject&lt;String&gt;()

    private lazy var disposeBag = DisposeBag()

    weak var output: ArticleInteractorOutputProtocol? {
        didSet {
            configureSubscriptions()
        }
    }

    private func configureSubscriptions() {
        guard let output = output else { return }

        fetchArticleTrigger
            .bind(to: dependencies.contentSvc.fetchContentByIdTrigger)
            .disposed(by: disposeBag)

        dependencies.contentSvc.fetchContentByIdResponse
            .bind(to: output.fetchArticleResponse)
            .disposed(by: disposeBag)
    }
}

</code></pre>

<p>Quite simply <code>fetchArticleTrigger</code> starts a request, I then <code>bind</code> on <code>dependencies.contentSvc.fetchContentByIdResponse</code> and pick up the response.</p>

<p>The method on my <code>ContentService</code> is -</p>

<pre class=""lang-swift prettyprint-override""><code>    // MARK:- FetchContentById
    // @params: id - String
    // return: PublishSubject&lt;ContentArticle&gt;

        fetchContentByIdTrigger
            .flatMapLatest { [unowned self] in self.client.request(.getContentById(id: $0)) }
            .map { (resp: Result&lt;ContentArticle&gt;) in
                guard case .success(let props) = resp else { return ContentArticle() }
                return props
        }
        .bind(to: fetchContentByIdResponse)
        .disposed(by: disposeBag)

</code></pre>

<p>I have a very similair setup on my <code>ProfileService</code> -</p>

<pre class=""lang-swift prettyprint-override""><code>    // MARK:- FetchUserProfileById
    // @params: id - String
    // return: PublishSubject&lt;User&gt;
        fetchUserProfileByIdTrigger
            .flatMapLatest { [unowned self] in self.client.request(.getProfileByUserId(id: $0)) }
            .map { (resp: Result&lt;User&gt;) in
                guard case .success(let props) = resp else { return User() }
                return props
        }
        .bind(to: fetchUserProfileByIdResponse)
        .disposed(by: disposeBag)
</code></pre>

<p>I imagine I will create a model for the article, something like -</p>

<pre class=""lang-swift prettyprint-override""><code>struct ContentArticleViewModel {
    var post: ContentArticle
    var user: User
}
</code></pre>

<p>I was imaging something like this pseudo code within my <code>ArticleInteractor</code>-</p>

<pre class=""lang-swift prettyprint-override""><code>    dependencies.contentSvc.fetchContentByIdResponse
        .flatMapLatest { article in
             /* fetch profile using `article.authorId */
        }.map { article, profile in
            return ContentArticleViewModel(post: article, user: profile)
        }
        .bind(to: output.fetchArticleResponse)
        .disposed(by: disposeBag)
</code></pre>

<p>But I am completely lost how best to handle this. I have seen a number of articles on chaining requests but am struggling to apply anything successfully.</p>

<p><strong>EDIT</strong></p>

<p>I have something working currently - </p>

<pre class=""lang-swift prettyprint-override""><code>    private func configureSubscriptions() {
        guard let output = output else { return }

        fetchArticleTrigger
            .bind(to: dependencies.contentSvc.fetchContentByIdTrigger)
            .disposed(by: disposeBag)

        dependencies.contentSvc.fetchContentByIdResponse
            .do(onNext: { [unowned self] article in self.dependencies.profileSvc.fetchUserProfileByIdTrigger.onNext(article.creator.userId)})
            .bind(to: fetchArticleResponse)
            .disposed(by: disposeBag)

        let resp = Observable.combineLatest(fetchArticleResponse, dependencies.profileSvc.fetchUserProfileByIdResponse)

        resp
            .map { [unowned self] in self.enrichArticleAuthorProps(article: $0, user: $1) }
            .bind(to: output.fetchArticleResponse)
            .disposed(by: disposeBag)
    }

    private func enrichArticleAuthorProps(article: ContentArticle, user: User) -&gt; ContentArticle {
        var updatedArticle = article
        updatedArticle.creator = user
        return updatedArticle
    }
</code></pre>

<p>I am not sure this is correct however.</p>
","11709138","","11709138","","2019-11-04 19:35:29","2019-11-05 00:35:53","Chain requests and return both results with RxSwift","<swift><rx-swift><chaining>","1","0","","","","CC BY-SA 4.0"
"58703792","1","58710556","","2019-11-05 02:50:42","","2","2576","<p>Got a IAP purchased notification, then I request the transaction from my server.</p>

<p>To download a song and play , if transaction OK.</p>

<p>I use RxSwift, The following code works, I want to improve it.</p>

<pre><code>NotificationCenter.default.rx.notification( .purchase )
        .takeUntil(self.rx.deallocated)
        .map { (noti) -&gt; String in
                return ""Not care""
              // I want to optimize this step
        }.concat(self.transactionRequest())
        .flatMap{ self.downloadSong($0) }.subscribe(onNext: { downloaded in
            if downloaded{
                self.playMusic()
            }
        })
        .disposed(by: rx.disposeBag)


  func transactionRequest()  -&gt; Observable&lt;String&gt; { // ... }

  func downloadSong(_ src: String) -&gt; Observable&lt;Bool&gt; { // ...  }
</code></pre>

<p>I can not use like this </p>

<pre><code>NotificationCenter.default.rx.notification( .purchase )
                   .takeUntil(self.rx.deallocated)
            .concat(self.transactionRequest())
</code></pre>

<p>because </p>

<blockquote>
  <p>Instance method 'concat' requires the types 'Notification' and
  'String' be equivalent</p>
</blockquote>

<p>So I add a boilerplate <code>map</code></p>

<p>Any more proper operator, or custom operator?</p>
","9820754","","","","","2019-11-05 11:36:40","RxSwift, how to use NotificationCenter more gently?","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58719893","1","","","2019-11-05 21:41:41","","2","86","<p>I am trying to add tests to an existing code base.</p>

<p>The app uses RxSwift w/ a coordinator pattern.</p>

<p>The <code>AppCoordinator</code> looks like -</p>

<pre class=""lang-swift prettyprint-override""><code>import UIKit
import RxSwift

enum AuthenticationState {
    case unknown, signedIn, signedOut
}

final class AppCoordinator: BaseCoordinator&lt;Void&gt; {
    private let window: UIWindow

    init(window: UIWindow) {
        self.window = window
    }

    override func start() -&gt; Observable&lt;Void&gt; {
        coordinateToRoot(basedOn: .unknown)
        return .never()
    }

    /// Recursive method that will restart a child coordinator after completion.
    /// Based on:
    /// https://github.com/uptechteam/Coordinator-MVVM-Rx-Example/issues/3
    private func coordinateToRoot(basedOn state: AuthenticationState) {

        switch state {

        case .unknown:
            return showStartScene()
                .subscribe(onNext: { [weak self] authState in
                    self?.window.rootViewController = nil
                    self?.coordinateToRoot(basedOn: authState)
                })
                .disposed(by: disposeBag)

        case .signedOut:
            return showAuthenticationFlow()
                .subscribe(onNext: { [weak self] authState in
                    self?.window.rootViewController = nil
                    self?.coordinateToRoot(basedOn: authState)
                })
                .disposed(by: disposeBag)

        case .signedIn:
            return startHomeFlow()
                .subscribe(onNext: { [weak self] authState in
                    self?.window.rootViewController = nil
                    self?.coordinateToRoot(basedOn: authState)
                })
                .disposed(by: disposeBag)
        }

    }

    private func showStartScene() -&gt; Observable&lt;AuthenticationState&gt; {
        let coordinator = StartCoordinator(window: window)
        return coordinate(to: coordinator).map { _ in return dependencies.authSvc.authState }
    }

    private func showAuthenticationFlow() -&gt; Observable&lt;AuthenticationState&gt; {
        let coordinator = AuthCoordinator(window: window)
        return coordinate(to: coordinator).map { _ in return dependencies.authSvc.authState }
    }

    private func startHomeFlow() -&gt; Observable&lt;AuthenticationState&gt; {
        let coordinator = HomeCoordinator(window: window)
        return coordinate(to: coordinator).map { _ in return dependencies.authSvc.authState }
    }
}

</code></pre>

<p>The flow is as follows -
<code>start</code> invokes the <code>showStartScene</code> method. This will check if a token exists and if the user should see the onboarding screen. Once everthing is complete it emits an event that causes <code>coordinateToRoot</code> to be called, using the latest auth state to direct the user to the correct <code>Coordinator</code></p>

<p>I have been able to add an initial test to assert that <code>window.rootViewController</code> is set on start, however I would like assert on the behaviour around <code>coordinateToRoot</code> </p>

<pre class=""lang-swift prettyprint-override""><code>class AppCoordinatorTests: XCTestCase {
    var sut: AppCoordinator!
    var window: UIWindow!
    var disposeBag: DisposeBag!

    override func setUp() {
        super.setUp()
        window = UIWindow(frame: .zero)
        sut = AppCoordinator(window: window)
        disposeBag = DisposeBag()
    }

    override func tearDown() {
        super.tearDown()
        window = nil
        sut = nil
        disposeBag = nil
    }

    func test_on_start_root_view_is_not_nil() {
        sut.start()
        .subscribe()
        .disposed(by: disposeBag)

        XCTAssertNotNil(window.rootViewController)
    }
}

</code></pre>

<p>Each coordinator emits <code>Void</code> and then uses a map on the current auth service to call a recursive method and invoke the next, valid coordinator.</p>

<p>I was thinking perhaps I emit an event on the current coordinator, having preset the result of <code>dependencies.authSvc.authState</code> I could then assert on the type of <code>UIViewController</code> set as <code>window.rootViewController</code></p>

<p>eg -</p>

<p><code>XCTAssertTrue((window.rootViewController as Any) is SomeTypeOfViewController)</code></p>

<p>What I would like to know is what would make this a more testable class without simply making everything <code>public</code>.</p>

<p>I have considered using dependency injection to setup the child coordinators and then using a stub to mock events, I am unsure if this is the best option in the context of something like <code>RxSwift</code></p>
","10823240","","10823240","","2019-11-05 21:47:05","2019-11-05 21:47:05","How can make this RxSwift based Coordinator more testable","<xctest><rx-swift><xctestcase><coordinator-pattern>","0","0","1","","","CC BY-SA 4.0"
"58740178","1","","","2019-11-07 00:09:27","","1","72","<p>Preface: this is a design question about reactive programming. It's intended to be language agnostic, so it's all psuedo-codey. I suspect whatever the right answer is, would be equally applicable between Rx/ReactiveCocoa/Combine.</p>

<p>I see 3 different ways in which I can design an object to observed. Each one surely has pros/cons, but it's not entirely clear to be what they are.</p>

<ol>
<li><p>Your object could have a <code>didChange: Publisher&lt;()&gt;</code> property. When you subscribe, you receive notificaitons about when your pubished object changes, but you don't actually learn anything about the changes, or the new value of the model object. This is simple enough to fix with a <code>map</code>:</p>

<pre><code>class Point: BindableObject {
    var x, y: Int
    var didChange: Publisher&lt;()&gt; { ... }
}
let object: Point = ...
let streamOfPoints = object.didChange //  Publisher&lt;()&gt;
                            .map { _ in object }  // Publisher&lt;Point&gt;
</code></pre>

<p>You simply get the values of the object for yourself, by accessing the object directly by some other reference, at the time you get notified that it changes. If you need to access a stream of <code>x</code> or <code>y</code> values, those are also just one <code>map</code> call away.</p>

<p>However, this seems like it have some issues.</p>

<ol>
<li>It's an extra step</li>
<li>It requires you to have access to the original object, so passing the publisher around isn't enough. You have to pass around a <code>(Point, Publisher&lt;Point&gt;)</code> pair, which seems cumbersome.</li>
<li><p>It might have correctness issues. For example, any delay between the time the <code>didChange</code> event was fired, and you access the object, isn't it possible that you'll read a newer value of the object than that which was present when the change was fired off?</p>

<p>This approach is my least favorite, but interestingly, this is the approach Apple takes in its Combine framework, with the <code>BindableObject</code> protocol. I suspect it might have to do with some sort of performance gain, from not having to pipe around the object in situations when it might not be wanted. Is that the case?</p></li>
</ol></li>
<li><p>The most obvious approach is to stream the object itself. <code>var didChange: Publisher&lt;Point&gt; { /* a publisher that emits self over time */ }</code>. This seems to achieve the same as apporach #1, whilst solving the 3 issues I listed. I don't see any value that approach #1 offers over this.</p></li>
<li><p>You could make publishers for each of the fields of the object:</p>

<pre><code>class Point: BindableObject {
    let x = PublishSubject&lt;Int&gt;
    let y = PublishSubject&lt;Int&gt;
}
</code></pre>

<p>This is more granular, so people could subsribe themselves to only those fields which they care about. I don't know how heavy-weight subscriptions are, but there could be some performance wins by subscribing more specifically to only those things which you care about. It's a bit of a contrived example here, because it's hard to think of a case in which it's desireable to know only the x values or y values of a point. But the principle is still generally applicable.</p>

<p>Accessing xs and ys is also possible using one of the first 2 approaches, by mapping the stream to xs and deduplicating (<code>.map { $0.x }.distinct</code>). But this is calling a lot more mapping closures than a direct subscription like this, which could have performance implications.</p>

<p>This approach could also be combined with approach 1 or 2, to add a <code>var didChange</code> property of type <code>Publisher&lt;()&gt;</code> or <code>Publisher&lt;Point&gt;</code>, for when you need to observe the entire point object.</p>

<p>This used to cause a lot of API bloat. In Rx, either:</p>

<ol>
<li>Either you could have <code>x: Value&lt;Int&gt;</code>, and use <code>x.value</code> all over the place to access the current value</li>
<li><p>Or, you have <code>var xObservable: Value&lt;Int&gt;</code> and <code>var x: Int { xObservable.value }</code>, but this adds a lot of API bloat.</p>

<p>Luckily, these two issues are solved by property wrappers, by basically implementing the latter design, but without needing to explictly add all the computed properties (they're generated for you).</p></li>
</ol></li>
</ol>

<p>Can you please give some guidance on which pattern to use? I suspect that's one of those things that's ""obvious with experience"", but I'm just not there yet when it comes to reactive programming. Thanks!</p>
","3141234","","","","","2019-11-08 07:58:22","Designing observable objects","<swift><reactive-programming><rx-swift><reactive-cocoa><combine>","1","0","","","","CC BY-SA 4.0"
"58743433","1","58762627","","2019-11-07 06:57:48","","1","570","<p>I am willing to use RxSwift for MVVM binding between model values &amp; view controllers. I want to bind my form fields to my class properties. For example:</p>

<pre><code>struct UserDetail {

    var firstName: String?
    var lastName: String?
    var nickName: String?
    var email: String?
    var nationalId: String?
    var birthday: String?


    init?() {}
}
</code></pre>

<p>and now I want to bind an instance of this class to my UITextFields and I define it in my ViewModel like this:</p>

<pre><code>var userData = UserDetail()
userData.firstName = ""myFirstName""

var userDetail = BehaviorSubject&lt;UserDetail?&gt;(value: userData)
</code></pre>

<p>and at this moment i dont have no idea to how should implement my ViewController.</p>
","4260326","","","","","2019-11-08 08:00:07","Binding multiple UITextField to a class props with RxSwift","<ios><swift><mvvm><rx-swift>","1","2","1","","","CC BY-SA 4.0"
"58747187","1","58748066","","2019-11-07 10:53:15","","0","324","<p>I'm in trouble because I have a TableView with inside a CollectionView and I don't know how I can pass the current data that are inside my CollectionViewCell once the user clicked on it (didSelectItemAt). </p>

<p>So I would wish to know if there is a way for observe the value that changed inside a variable. </p>

<p>For example. When user is clicking the cell, a variable is updated with the current data contained in that cell and then I'm receiving the update in my ViewController that once that has been observed the value change, will call a function for update some values in it.</p>

<p>Thanks! </p>
","7150493","","","","","2019-11-07 11:42:50","Observe value change from Cell to ViewController Swift","<swift><observable><rx-swift>","1","6","","","","CC BY-SA 4.0"
"58753365","1","","","2019-11-07 16:41:56","","0","45","<p>I am working with the following variable <code>gameTimeout</code> its a newly created observable from <code>game</code> with a timeout operator attached. I am looking for a solution to this <code>.timeout</code> operator running continuously.. </p>

<pre><code> let gameTimeout = game.timeout(3, scheduler: MainScheduler.instance)
</code></pre>

<pre><code>Observable.amb([gameTimeout, game])
        .subscribe(onNext: { (error) in
            print(""pass"")
        },
                   onError: {err in self._alertMessage.onNext(""There was an error loading the game.""); print(""error \(err)"")}
            )
        .disposed(by: disposeBag)
</code></pre>

<p>I need it to only run once per (presenting a view controller). The code above currently will continue to run over and over again.. what should be changed to limit how many times the code gets executed?</p>
","11243557","","11243557","","2019-11-07 16:57:53","2019-11-07 18:44:12","How to: Run the .timeout operator only one time per presenting a view controller","<swift><observable><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58758524","1","","","2019-11-07 23:52:40","","2","385","<p>I would like to enable a button when the keyboard is hidden. How can I do this using rxSwift? I tried this code but the closure is never called:</p>

<pre><code>NotificationCenter.default.rx.notification(UIResponder.keyboardWillHideNotification)
    .map { _ in if let cancelButton = self.searchBar.value(forKey: ""cancelButton"") as? UIButton {
    cancelButton.isEnabled = true
} }
</code></pre>
","682355","","","","","2019-11-08 12:53:47","Use RxSwift to handle the keyboardWillHide","<swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"58764341","1","","","2019-11-08 10:02:38","","5","965","<p>I have an app using <code>MVP</code> with the <code>Coordinator</code> pattern.</p>

<p>When a child coordinator sends and event, I would expect my <code>AppCoordinator</code> to recursively call a method that selects the next coordinator based on some <code>SessionState</code>.</p>

<p>The basic flow of the app is as follows -</p>

<p><code>AppCoordinator</code></p>

<ol>
<li><code>start()</code> invokes <code>coordinateToRoot</code> with an initial state</li>
<li>Subscribes to <code>showStartScene()</code> which starts the child coordinator</li>
</ol>

<p><code>StartCoordinator</code></p>

<ol>
<li><code>start()</code> creates <code>MVP</code> module which is now visible to the user</li>
<li><code>MVP</code> module invokes <code>AuthSvc</code> which makes async call to iDP and confirms auth state</li>
<li>On completion of this task, publishes an event which is picked up by the subscription in the <code>AppCoordinator</code>'s <code>coordinateToRoot</code> method and the cycle repeats using the appropriate coordinator for the view state.</li>
</ol>

<p>The issue however is that on the publish of that event, nothing is happening. <code>start()</code> is not showing it received the event and <code>coordinateToRoot</code> is not called again.</p>

<p>I have created the most basic version I can below to demonstrate this. I have also hardcoded <code>showStartScene</code> to return <code>.signedIn</code> rather than a look up of the auth state.</p>

<p>In the below example, I would expect once the view is loaded, <code>presenter.signal</code> should immediately emit an event that causes a print statement to show.</p>

<p><strong>SessionState</strong></p>

<pre class=""lang-swift prettyprint-override""><code>enum SessionState: String {
    case unknown, signedIn, signedOut
}
</code></pre>

<p><strong>AppCoordinator</strong></p>

<pre class=""lang-swift prettyprint-override""><code>final class AppCoordinator: BaseCoordinator&lt;Void&gt; {

    private let window: UIWindow

    init(window: UIWindow) {
        self.window = window
    }

    override func start() -&gt; Observable&lt;Void&gt; {
        coordinateToRoot(basedOn: .unknown)
        return .never()
    }

    /// Recursive method that will restart a child coordinator after completion.
    /// Based on:
    /// https://github.com/uptechteam/Coordinator-MVVM-Rx-Example/issues/3
    private func coordinateToRoot(basedOn state: SessionState) {

        switch state {
        case .unknown:
            return showStartScene()
                .subscribe(onNext: { [unowned self] state in
                    self.window.rootViewController = nil
                    self.coordinateToRoot(basedOn: state)
                })
                .disposed(by: disposeBag)

        case .signedIn:
            print(""I am signed in"")

        case .signedOut:
            print(""I am signed out"")
        }
    }

    private func showStartScene() -&gt; Observable&lt;SessionState&gt; {
        let coordinator = StartCoordinator(window: window)
        return coordinate(to: coordinator).map { return .signedIn }
    }
}
</code></pre>

<p><strong>StartCoordinator</strong></p>

<pre class=""lang-swift prettyprint-override""><code>final class StartCoordinator: BaseCoordinator&lt;Void&gt; {

    private(set) var window: UIWindow

    init(window: UIWindow) {
        self.window = window
    }

    override func start() -&gt; Observable&lt;CoordinationResult&gt; {

        let viewController = StartViewController()
        let presenter = StartPresenter(view: viewController)

        viewController.configurePresenter(as: presenter)

        window.rootViewController = viewController
        window.makeKeyAndVisible()

        return presenter.signal
    }
}
</code></pre>

<p><strong>Start MVP Module</strong></p>

<pre class=""lang-swift prettyprint-override""><code>protocol StartViewInterface: class {
    func configurePresenter(as presenter: StartPresentation)
}

protocol StartPresentation: class {
    var viewIsReady: PublishSubject&lt;Void&gt; { get }
    var signal: PublishSubject&lt;Void&gt; { get }
}
// MARK:- StartPresenter
final class StartPresenter {

    // Input
    let viewIsReady = PublishSubject&lt;Void&gt;()

    // Output
    let signal = PublishSubject&lt;Void&gt;()

    weak private var view: StartViewInterface?

    private lazy var disposeBag = DisposeBag()

    init(view: StartViewInterface?) {
        self.view = view

        viewIsReady.bind(to: signal).disposed(by: disposeBag)
    }

}

extension StartPresenter: StartPresentation { }

// MARK:- StartViewController
final class StartViewController: UIViewController {

    private var presenter: StartPresentation?

    override func viewDidLoad() {
        super.viewDidLoad()

        if let presenter = presenter {
            presenter.viewIsReady.onNext(())
        }

    }
}

extension StartViewController: StartViewInterface {
    func configurePresenter(as presenter: StartPresentation) {
        self.presenter = presenter
    }
}


</code></pre>

<p>Interestingly if I do something like this in <code>StartCoordinator</code> the process does work, it has however not what I am trying to achieve.</p>

<pre class=""lang-swift prettyprint-override""><code>    override func start() -&gt; Observable&lt;CoordinationResult&gt; {

        let viewController = StartViewController()
        let presenter = StartPresenter(view: viewController)

        viewController.configurePresenter(as: presenter)

        window.rootViewController = viewController
        window.makeKeyAndVisible()


        let subject = PublishSubject&lt;Void&gt;()


        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            subject.onNext(())
        }

        return subject
    }
</code></pre>

<p>For reference my <code>BaseCoordinator</code> looks like - </p>

<pre class=""lang-swift prettyprint-override""><code>/// Base abstract coordinator generic over the return type of the `start` method.
class BaseCoordinator&lt;ResultType&gt;: CoordinatorType {

    /// Typealias which allows to access a ResultType of the Coordainator by `CoordinatorName.CoordinationResult`.
    typealias CoordinationResult = ResultType

    /// Utility `DisposeBag` used by the subclasses.
    let disposeBag = DisposeBag()

    /// Unique identifier.
    internal let identifier = UUID()

    /// 1. Stores coordinator in a dictionary of child coordinators.
     /// 2. Calls method `start()` on that coordinator.
     /// 3. On the `onNext:` of returning observable of method `start()` removes coordinator from the dictionary.
     ///
     /// - Parameter coordinator: Coordinator to start.
     /// - Returns: Result of `start()` method.
     func coordinate&lt;T: CoordinatorType, U&gt;(to coordinator: T) -&gt; Observable&lt;U&gt; where U == T.CoordinationResult {
         store(coordinator: coordinator)
         return coordinator.start()
             .do(onNext: { [weak self] _ in self?.free(coordinator: coordinator) })
     }

     /// Starts job of the coordinator.
     ///
     /// - Returns: Result of coordinator job.
     func start() -&gt; Observable&lt;ResultType&gt; {
         fatalError(message: ""Start method should be implemented."")
     }

    /// Dictionary of the child coordinators. Every child coordinator should be added
    /// to that dictionary in order to keep it in memory.
    /// Key is an `identifier` of the child coordinator and value is the coordinator itself.
    /// Value type is `Any` because Swift doesn't allow to store generic types in the array.
    private(set) var childCoordinators: [UUID: Any] = [:]

    /// Stores coordinator to the `childCoordinators` dictionary.
    ///
    /// - Parameter coordinator: Child coordinator to store.
    private func store&lt;T: CoordinatorType&gt;(coordinator: T) {
        childCoordinators[coordinator.identifier] = coordinator
    }

    /// Release coordinator from the `childCoordinators` dictionary.
    ///
    /// - Parameter coordinator: Coordinator to release.
    private func free&lt;T: CoordinatorType&gt;(coordinator: T) {
        childCoordinators[coordinator.identifier] = nil
    }
}

</code></pre>

<p><strong>EDIT</strong>
I added some <code>debug</code> operators and I can see the order appears off for the next event and the subscription</p>

<pre><code>2019-11-08 10:26:19.289: StartPresenter -&gt; subscribed
2019-11-08 10:26:19.340: StartPresenter -&gt; Event next(())
2019-11-08 10:26:19.350: coordinateToRoot -&gt; subscribed
</code></pre>

<p>Why is <code>coordinateToRoot</code> subscribing after <code>StartPresenter</code> is created?</p>
","10823240","","10823240","","2019-11-08 10:28:17","2021-06-17 22:58:27","RxSwift Subject not firing event when called","<swift><rx-swift><coordinator-pattern><publishsubject>","1","1","","","","CC BY-SA 4.0"
"58765403","1","58766147","","2019-11-08 11:09:17","","2","1090","<p>I have two Single values that contain an array of the same object. I want to merge them and apply the map and return them as a Single. Is it possible?</p>

<p>So I have this:</p>

<pre class=""lang-swift prettyprint-override""><code>func fetchTripList(type: TripType) -&gt; Single&lt;[Trip]&gt; {
    let response: Single&lt;APITripListResponse&gt; = request(target: TripsAPI.fetchUpcomingTripList)
    return response.map { $0.toModel() }
}
</code></pre>

<p>And I need something like this:</p>

<pre class=""lang-swift prettyprint-override""><code>func fetchTripList(type: TripType) -&gt; Single&lt;[Trip]&gt; {
    let responseUpcoming: Single&lt;APITripListResponse&gt; = request(target: TripsAPI.fetchUpcomingTripList)
    let responsePast: Single&lt;APITripListResponse&gt; = request(target: TripsAPI.fetchPastTripList)
    //'Declare a Singe variable &lt;[Trip]&gt; called X merge both responseUpcoming and responsePast, apply to them map { $0.toModel() } and return it'

    return X
}
</code></pre>

<p>Many thanks for the help.</p>
","1216107","","1797194","","2019-11-08 16:45:24","2019-11-08 16:45:24","Combine two single responses RXSwift","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"58768804","1","58774926","","2019-11-08 14:49:43","","0","638","<p>I have a the following code - </p>

<pre class=""lang-swift prettyprint-override""><code>        viewIsReady
            .flatMapLatest { [unowned self] _ in self.dependencies.authSvc.checkSession().asDriver(onErrorJustReturn: false) }
            .distinctUntilChanged()
            .delay(.seconds(2), scheduler: MainScheduler.instance) &lt;-- without this test passes
            .bind(to: checkSessionComplete)
            .disposed(by: disposeBag)
</code></pre>

<p>We have a splash view that is presented and want to show this for a minimum time each time. As this view is dismissed by emiting to <code>checkSessionComplete</code> I have added a delay, to allow the async operation to complete and prevent the sequence moving along.</p>

<p>However the test for this is now failing, but the behaviour is correct.</p>

<p>How Should I test an operation that includes the <code>delay</code> operator?</p>

<pre><code>   func test_on_check_session_response_emits() {
        let deps = TestDependencies()
        deps.authSvcSpy.stubbedCheckSessionResult = .just(true)

        DependencyInjector.dependencies = deps

        scheduler.scheduleAt(0) {
            self.sut.viewIsReady.onNext(())
        }

        let observer = scheduler.createObserver(AuthState.self)

        sut.checkSessionComplete
        .asObservable()
        .bind(to: observer)
        .disposed(by: disposeBag)

        scheduler.start()

        XCTAssertEqual(observer.events.count, 1)
    }
</code></pre>

<p><strong>EDIT</strong></p>

<p>Based on the answer below I have updated my <code>Presenter</code> -</p>

<pre class=""lang-swift prettyprint-override""><code>final class StartPresenter {

    // Input
    let viewIsReady = PublishSubject&lt;Void&gt;()

    // Output
    let checkSessionComplete = PublishSubject&lt;Void&gt;()

    var scheduler: SchedulerType = MainScheduler.instance

    weak private var view: StartViewInterface?

    private lazy var disposeBag = DisposeBag()

    init(view: StartViewInterface?) {
        self.view = view

        viewIsReady
            .flatMapLatest { [unowned self] _ in self.dependencies.authSvc.checkSession().asDriver(onErrorJustReturn: false) }
            .distinctUntilChanged()
            .mapToVoid()
            .delay(.seconds(2), scheduler: scheduler)
            .bind(to: checkSessionComplete)
            .disposed(by: disposeBag)
    }
}
</code></pre>

<p>and my test case</p>

<pre><code>    func test_on_check_session_response_emits() {
         let deps = TestDependencies()
         deps.authSvcSpy.stubbedCheckSessionResult = .just(true)
         DependencyInjector.dependencies = deps

        sut.scheduler = testScheduler

        testScheduler.scheduleAt(0) {
            self.sut.viewIsReady.onNext(())
        }

        let observer = testScheduler.createObserver(Void.self)

        sut.checkSessionComplete
        .asObservable()
        .delay(.seconds(2), scheduler: testScheduler)
        .bind(to: observer)
        .disposed(by: disposeBag)

        testScheduler.start()

        XCTAssertEqual(observer.events.count, 1)
    }

}
</code></pre>

<p>And the test is still failing if the <code>.delay</code> is in the chain.</p>
","10823240","","10823240","","2019-11-09 06:13:01","2019-11-09 06:13:01","RxSwift Test fails now .delay has been introduced","<swift><unit-testing><delay><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58781051","1","","","2019-11-09 16:05:33","","2","604","<p>I am seeking for alternative way to handle errors thrown through Observable sequence. </p>

<p>I have database request that frequently just throws DaoError.notFound (meaning data has not been found). </p>

<p>Then I am doing Remote API request that saves new data to database, and it should cause CoreData to emit new data through first Observable sequence. But it doesn't happen in spite of using RxCoreData. And the reason is that first Observable is terminated with Error. </p>

<p>I can use: </p>

<p><strong>catchErrorJustReturn([])</strong> but it emits empty array of elements and completes Observable sequence, no more elements will be emitted via this sequence. </p>

<p><strong>retry()</strong> but it hangs retrying which is also not perfect solution as when there is no elements I just want to display empty table view with no items. </p>

<p>The perfect solution will be just somehow mapping or errors to empty arrays but keep Observable stream alive. But it doesn't happen.</p>

<p>The simplest solution will be replacing DaoError.notFound with returning empty array, but it is odd that I cannot keep error and in some usage create infinite stream and ignore errors. </p>
","4415642","","","","","2019-11-12 11:56:50","RxSwift Observable that throws Error alternative to catchErrorJustReturn","<rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"58787266","1","58788519","","2019-11-10 09:21:18","","3","1509","<p>I want to bind <code>UIButton</code> title to a <code>BehaviorSubject&lt;String&gt;</code> in my ViewModel. I do it in <code>Label</code> like below:</p>

<pre class=""lang-cs prettyprint-override""><code>//ViewModel
var fullName = BehaviorSubject&lt;String?&gt;(value: """")

//ViewController
vm.fullName.bind(to: fullNameLabel.rx.text).disposed(by: bag)
</code></pre>

<p>is there any way to do this?</p>
","4260326","","12067560","","2019-11-10 10:02:03","2020-05-29 17:32:46","How to bind my UIButton title to my ViewModel","<ios><swift><mvvm><rx-swift>","2","0","","","","CC BY-SA 4.0"
"58787928","1","58788794","","2019-11-10 10:54:30","","2","152","<p>Hi have a tableview with sections and I am making API call to populate the tableView. I am also using the MVVm architecture. Now users are able to delete items but I try reloading the sections or tableView but nothing happens as the deleted item still remains in the tableView. Below is my code. Any help is appreciated</p>

<p><strong>My ViewModel</strong></p>

<pre><code>Observable.zip(identiferElements, deviceElements).map {(identifers, devices, _) -&gt; [MyInfoSection] in
            var items: [MyInfoSection] = []
            let identiferRepository = identifers.map({ (repository) -&gt; MyInfoSectionItem in
                let cellViewModel = IdentifiersCellViewModel(with: repository)
                return MyInfoSectionItem.identifiersItem(viewModel: cellViewModel)
            })
            if identiferRepository.isNotEmpty {
                items.append(MyInfoSection.setting(title: ""Identifier"", items: identiferRepository))
            }

            let deviceRepository = devices.map({ (repository) -&gt; MyInfoSectionItem in
                let cellViewModel = DevicesCellViewModel(with: repository)
                return MyInfoSectionItem.devicesItem(viewModel: cellViewModel)
            })
            if deviceRepository.isNotEmpty {
                items.append(MyInfoSection.setting(title: ""Active Devices"", items: deviceRepository))
            }
            return items
        }.bind(to: elements).disposed(by: rx.disposeBag) 

deletedEvent.drive(onNext: { (item) in

            switch item {
            case .identifiersItem(let viewModel):
                identiferDeleted.onNext(viewModel.repository)
            case .devicesItem(let viewModel):
                deviceDeleted.onNext(viewModel.repository)
            }
        }).disposed(by: rx.disposeBag)

        identiferDeleted.asObservable().flatMapLatest({ [weak self] (value) -&gt; Observable&lt;ResponseBase&gt; in
            log(value)
            guard let self = self, let id = value.id else { return Observable.just(ResponseBase()) }
            return self.provider.deleteAddress(id: id)
                .trackActivity(self.loading)
                .trackError(self.error)
        }).subscribe(onNext: { (res) in
            log(res)

        }).disposed(by: rx.disposeBag) 
</code></pre>

<p><strong>ViewController</strong></p>

<pre><code>//viewDidLoad

let input = MyInfoViewModel.Input(trigger: refresh, segmentSelection: segmentSelected, selection: tableView.rx.modelSelected(MyInfoSectionItem.self).asDriver(), deleted: tableView.rx.modelDeleted(MyInfoSectionItem.self).asDriver())
        let output = viewModel.transform(input: input)
</code></pre>

<p>More code would be added based on request. Thanks</p>
","8310287","","","","","2019-11-10 12:43:35","Deleting item RxSwift MVVM pattern","<ios><swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58797756","1","58800514","","2019-11-11 08:21:18","","2","902","<p>I have an observable that manages an object called Profile:</p>

<pre class=""lang-swift prettyprint-override""><code>class Profile {
    let name. : String
    let surname : String
    let avatar: String?
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>Observable&lt;Profile&gt;
</code></pre>

<p>This observable is binded to view model, who has a at the same time an observable property called </p>

<pre class=""lang-swift prettyprint-override""><code>var initialMarks:Observable&lt;String&gt;
</code></pre>

<p>That are the initial letters of name and surname properties. This initial letters are shown in case avatar property is nil.</p>

<p>I have a function that returns initial letters in a string:</p>

<pre class=""lang-swift prettyprint-override""><code>func initialLetters(first:String, second: String) -&gt; String
</code></pre>

<p>How can I achieve this by using RxSwift any operators, to:</p>

<ol>
<li>Access avatar property.</li>
<li>Check if it is nil.</li>
<li>if it is nil, call function initialLetters.</li>
<li>Bind function initialLetters to observable initialLetters.</li>
</ol>

<p>Many thanks.</p>
","1216107","","1878594","","2019-11-11 13:33:46","2019-11-11 13:33:46","Bind RxSwift observable result to another observables","<ios><rx-swift>","2","0","","","","CC BY-SA 4.0"
"58814962","1","","","2019-11-12 08:45:25","","-3","58","<pre><code>import MVVMC
import RxSwift
import RxCocoa
import RTVModel
import RTVWebAPI

public class SettingsViewModel: ViewModel {

    public var fetchedNotifications: Driver&lt;[NotificationItem]&gt; = .empty()

    public var fetchedNotificationsFailed: Driver&lt;String&gt; = .empty()

    public var notificationCount: Driver&lt;Int&gt; = .empty()
'''''''''''''''
    public var userLoginName: Driver&lt;String&gt; = .empty()
///// userLoginName getting is a optional String.

'''''''''''''''''

    public var fetchedUserLoginNameFailed: Driver&lt;String&gt; = .empty()

    public func bindNotificationEvents(with trigger: Driver&lt;Void&gt;) {

        let webService: Driver&lt;RTVInformationListWebService&gt; = trigger
            .map { RTVInformationListParameters() }
            .webService()

        let result = webService.request()

        notificationCount = result.success().map { $0.informationList.maxCount }
        fetchedNotifications = result.success()
            .map {$0.informationList.notifications}
-------&gt;    .map {$0.map {NotificationItem.init(notification: $0)}}
///////////////////////////////////////////////////////////////
Error (Value of optional type 'String?' must be unwrapped to a value of type 'String')
///////////////////////////////////////////////////////////////

        fetchedNotificationsFailed = Driver.merge(fetchedNotificationsFailed, result.error().map { $0.message })
    }

    public func bindUserInfoEvents(with trigger: Driver&lt;Void&gt;) {

        let webService: Driver&lt;RTVMobileMenuWebService&gt; = trigger
            .map { RTVMobileMenuParameters() }
            .webService()

        let result = webService.request()
        userLoginName = result.success().map { ($0.mobileMenuInfo.username) }
        fetchedUserLoginNameFailed = Driver.merge(fetchedUserLoginNameFailed, result.error().map { $0.message })

    }
}

    extension RTVAPIError {
        fileprivate var message: String {
            var message = ""\(self.localizedDescription)""
            if let codeNumber = self.codeNumber {
                message += ""\n(\(codeNumber))""
            }
            return message
        }
    }
</code></pre>
","12302627","","169346","","2019-11-12 08:57:11","2019-11-13 08:30:16","How to merge nil cases to Failing case","<swift><rx-swift>","2","1","","","","CC BY-SA 4.0"
"58825713","1","58826305","","2019-11-12 19:49:44","","0","402","<p>I'm using RxDataSources and trying to make a ""toggle"" function for cell selection — i.e., to allow cells (in a single-selection tableView) to be selected and deselected by tapping. I'm using 
<code>tableView.rx.itemSelected</code> to get the selection, and <code>self?.tableView.deselectRow(at: indexPath, animated: false)</code> to deselect the cell, if it is currently in the selected state. This seems to basically work, but I want to respond to the deselection. I was assuming that <code>self?.tableView.deselectRow(at: indexPath, animated: false)</code> would result in <code>tableView.rx.itemDeselected</code> being called, but that never happens. I'm obviously missing something. </p>

<p>Any thoughts appreciated.</p>
","4321521","","","","","2019-11-12 20:38:02","RxDataSources itemDeselected not getting called","<ios><swift><uitableview><rx-swift><rxdatasources>","1","0","1","","","CC BY-SA 4.0"
"58834262","1","58837414","","2019-11-13 09:48:06","","3","378","<p>I have some UI rx button tap, I want to connect it to the network rx part.</p>
<p>Here is Rx btn tap part:</p>
<pre><code>btn.rx.tap.take(1).flatMap {  [unowned self]  () -&gt; Observable&lt;Bool&gt;  in
            // ...
            return NetManager.standard.request()
        }.debug().do(onNext: { _ in
                print(&quot;The data flows here&quot;)
            }).flatMapLatest { (echo: Bool) -&gt; Observable&lt;Bool&gt; in
            if echo{
                if let app = UIApplication.shared.delegate as? AppDelegate{
                    app.goHome()
                }
                return Observable.of(true)
            }
            else{
                return Observable.of(false)
            }
        }.subscribe(onNext: { (result) in
            // ... , do sth with result
        }).disposed(by: rx.disposeBag)
</code></pre>
<p>Here is net request part with Alamofire:</p>
<pre><code>class NetManager: NSObject {
    
    static let standard = NetManager()
    var dataRequest: DataRequest?
    
    func request() -&gt; Observable&lt;Bool&gt; {
           return Observable&lt;Bool&gt;.create{ (observer) -&gt; Disposable in
                    let data = // ...
                    // ...
                    self.dataRequest = AF.request(aURL, method: HTTPMethod.post, parameters: data, encoder: JSONParameterEncoder.prettyPrinted, headers: aHead).response { (response: DataResponse&lt;Data?&gt;) in
                            self.hud?.hide()
                           if let data = response.data{
                               observer.onNext(true)
                                // ....
                           }
                           else{
                               observer.onNext(false)
                           }
                       }
                    observer.onCompleted()
                    return Disposables.create{}
           }
       }
    
}
</code></pre>
<p>Here is the debug info:</p>
<blockquote>
<p>Controller.swift:141 (viewDidLoad()) -&gt; subscribed</p>
<p>Controller.swift:141 (viewDidLoad()) -&gt; Event completed</p>
<p>Controller.swift:141 (viewDidLoad()) -&gt; isDisposed</p>
</blockquote>
<p>The result is , the <code>do( next )</code> part seems like that it has not been called. Because no <code>print</code> in console.</p>
<hr />
<p>The question is, <strong>how to make the rx logic work?</strong></p>
<hr />
<p>Here is what I tried:</p>
<p>turn <code>btn.rx.tap.flatMap </code> to <code>btn.rx.tap.take(1).flatMap </code></p>
<p>because from <a href=""https://github.com/ReactiveX/RxSwift/issues/1939"" rel=""nofollow noreferrer"">this issue</a></p>
<blockquote>
<p>if a flatMap completion would terminate the outer stream, it would mean that no more button taps would be registered in your stream, which don't really make sense.</p>
</blockquote>
<hr />
<p>Seen from <a href=""https://stackoverflow.com/questions/33968378/how-to-transform-rx-tap-of-uibutton-to-a-network-request-directly-without-sendin"">this question</a></p>
<pre><code>  btn.rx.tap.map { () -&gt; Observable&lt;Bool&gt; in

    return NetManager.standard.request()
  }.flatMapLatest { (observer: Observable&lt;Bool&gt;) -&gt; Observable&lt;Bool&gt; in
  
    // of cource, I can subscribe to observer
    /*
     observer.subscribe(onNext: { (echo) in
         
     })
     */
    
    
    // how to get the event element elegantly.
    
    return Observable.of(false)
}.subscribe(onNext: { (_) in
    
}).disposed(by: rx.disposeBag)
</code></pre>
<p>how to do this more elegantly.</p>
","10332481","","-1","","2020-06-20 09:12:55","2019-11-13 13:07:11","RxSwift: tap a button to do a request with Alamofire, how to make it work?","<ios><swift><rx-swift>","1","0","0","","","CC BY-SA 4.0"
"58858050","1","58858305","","2019-11-14 13:35:15","","0","698","<p>I have an app using <code>RxSwift</code> following <code>MVVM</code>.</p>

<p><strong>ViewController</strong></p>

<pre class=""lang-swift prettyprint-override""><code>
import UIKit
import RxSwift
import RxCocoa

final class ProfileViewController: BaseViewController&lt;ProfileView&gt; {

    var viewModel: Attachable&lt;ProfileViewModel&gt;!
    var bindings: ProfileViewModel.Bindings {

        let viewDidLoad = rx.sentMessage(#selector(UIViewController.viewDidLoad))
            .mapToVoid()
            .asDriverOnErrorJustComplete()

        let viewWillAppear = rx.sentMessage(#selector(UIViewController.viewWillAppear))
            .mapToVoid()
            .asDriverOnErrorJustComplete()

        let viewWillDisappear = rx.sentMessage(#selector(UIViewController.viewWillDisappear))
            .mapToVoid()
            .asDriverOnErrorJustComplete()

        let logout = navigationItem.rightBarButtonItem?.rx.tap
            .mapToVoid()
            .asDriverOnErrorJustComplete()

        return ProfileViewModel.Bindings(
            connectStore: viewWillAppear.asDriver(),
            disconnectStore: viewWillDisappear.asDriver(),
            fetchProfileByUserId: viewDidLoad.asDriver()
        )
    }

    private lazy var disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        configureView()
    }


    private func configureView() {
        navigationItem.title = ""Your account""
    }
}

extension ProfileViewController: ViewModelAttaching {
    func bind(viewModel: ProfileViewModel) -&gt; ProfileViewModel {

        return viewModel
    }
}
</code></pre>

<p><strong>ViewModel</strong></p>

<pre class=""lang-swift prettyprint-override""><code>
import RxSwift
import RxCocoa
import ReSwift

final class ProfileViewModel: ViewModelType {

    typealias Dependency = HasReduxStore &amp; HasImagePicker

    lazy var userID: String = __user__.id

    let data = PublishSubject&lt;ProfileHeaderViewModel&gt;()
    let endSession = PublishSubject&lt;Void&gt;()

    private let dependency: Dependency

    struct Bindings {
        let connectStore: Driver&lt;Void&gt;
        let disconnectStore: Driver&lt;Void&gt;
        let fetchProfileByUserId: Driver&lt;Void&gt;
    }

    private lazy var disposeBag = DisposeBag()

    init(dependency: Dependency, bindings: Bindings) {
        self.dependency = dependency

        bindings.connectStore
            .asObservable()
            .map { self }
            .bind(onNext: dependency.store.subscribe)
            .disposed(by: disposeBag)

        bindings.disconnectStore
            .asObservable()
            .map { self }
            .bind(onNext: dependency.store.unsubscribe)
            .disposed(by: disposeBag)

        bindings.fetchProfileByUserId
            .asObservable()
            .bind(onNext: dispatchFetchForProfileById)
            .disposed(by: disposeBag)
    }

    private func dispatchFetchForProfileById() {
        dependency.store.dispatch(FetchProfileByUserId(payload: userID))
    }
}

extension ProfileViewModel: StoreSubscriber {
    func newState(state: AppState) {

    }
}
</code></pre>

<p>When my view is loaded I would expect <code>bindings.fetchProfileByUserId</code> to be invoked. However nothing is happening. I updated my binding to trigger on <code>viewWillAppear</code> instead and everything worked as expected.</p>

<p>I do not know why <code>viewDidLoad</code> is not working in this case.</p>
","10823240","","","","","2019-11-14 13:48:25","rx.sentMessage(#selector(UIViewController.viewDidLoad)) is not firing","<ios><swift><mvvm><rx-swift><reactive-cocoa>","1","0","1","","","CC BY-SA 4.0"
"58892197","1","58892652","","2019-11-16 15:22:17","","0","135","<p>Following <a href=""http://www.thomasvisser.me/2017/02/09/mvvm-rx/"" rel=""nofollow noreferrer"">this blog post</a> I have create an MVVM pattern in my app.</p>

<p>I have the following -</p>

<pre class=""lang-swift prettyprint-override""><code>protocol ViewModelType {
    associatedtype Dependency
    associatedtype Bindings

    init(dependency: Dependency, bindings: Bindings)
}

enum Attachable&lt;VM: ViewModelType&gt; {

    case detached(VM.Dependency)
    case attached(VM.Dependency, VM)

    mutating func bind(_ bindings: VM.Bindings) -&gt; VM {
        switch self {
        case let .detached(dependency):
            let vm = VM(dependency: dependency, bindings: bindings)
            self = .attached(dependency, vm)
            return vm
        case let .attached(dependency, _):
            let vm = VM(dependency: dependency, bindings: bindings)
            self = .attached(dependency, vm)
            return vm
        }
    }
}

</code></pre>

<p><strong>ViewController</strong></p>

<pre class=""lang-swift prettyprint-override""><code>final class StartViewController: BaseViewController&lt;StartView&gt; {

    var viewModel: Attachable&lt;StartViewModel&gt;!
    var bindings: StartViewModel.Bindings {

        let viewWillAppear = rx.sentMessage(#selector(UIViewController.viewWillAppear))
            .mapToVoid()
            .asDriverOnErrorJustComplete()

        return StartViewModel.Bindings(
            checkAuthState: viewWillAppear
        )
    }
}

extension StartViewController: ViewModelAttaching {
    func bind(viewModel: StartViewModel) -&gt; StartViewModel {
        return viewModel
    }
}
</code></pre>

<p><strong>ViewModel</strong></p>

<pre class=""lang-swift prettyprint-override""><code>final class StartViewModel: ViewModelType {

    typealias Dependency = HasAuthService

    let authCheck: Driver&lt;Void&gt;

    struct Bindings {
        let checkAuthState: Driver&lt;Void&gt;
    }

    private let disposeBag = DisposeBag()

    init(dependency: Dependency, bindings: Bindings) {

        authCheck = bindings.checkAuthState
            .flatMap {
                return dependency.authSvc.checkSession()
                .mapToVoid()
                .asDriver(onErrorJustReturn: ())
        }
    }
}
</code></pre>

<p>This allows me to setup my views as follows -</p>

<pre class=""lang-swift prettyprint-override""><code>        let viewController = StartViewController()
        let avm: Attachable&lt;StartViewModel&gt; = .detached(dependencies)
        let viewModel = viewController.attach(wrapper: avm)

        navigationController.setViewControllers([viewController], animated: false)
</code></pre>

<p>This works great, is very testable and I happy with how it works. I however have a scenario in which I need to pass some additional props into my <code>ViewModel</code>. </p>

<p>For example, a <code>userId</code> in the case of a profile scene.</p>

<p>This pattern keeps the <code>init</code> method away so I need a way to inject additional props via <code>.detached(dependencies)</code></p>

<p>Something like <code>.detached(dependencies, userId)</code> however I am unsure how to do this in a generic fashion.</p>

<p>I have tried this - <strong>notice the addition of <code>Props</code> and <code>props</code></strong></p>

<pre class=""lang-swift prettyprint-override""><code>
protocol ViewModelType {
    associatedtype Dependency
    associatedtype Bindings
    associatedtype Props

    init(dependency: Dependency, bindings: Bindings, props: Props?)
}

enum Attachable&lt;VM: ViewModelType&gt; {

    case detached(VM.Dependency, VM.Props)
    case attached(VM.Dependency, VM, VM.Props)

    mutating func bind(_ bindings: VM.Bindings) -&gt; VM {
        switch self {
        case let .detached(dependency, props):
            let vm = VM(dependency: dependency, bindings: bindings, props: props)
            self = .attached(dependency, vm, props)
            return vm
        case let .attached(dependency, _, props):
            let vm = VM(dependency: dependency, bindings: bindings, props: props)
            self = .attached(dependency, vm, props)
            return vm
        }
    }
}

</code></pre>

<p>This however requires me to update my <code>ViewModel</code> with the following -</p>

<pre class=""lang-swift prettyprint-override""><code>**ViewModel**
```swift
typealias Props = &lt;Some Prop Type&gt;
init(dependency: Dependency, bindings: Bindings, props: Props?)
</code></pre>

<p>This works great, except in the case my I don't need to inject any props. I'm then stuck needing to specify a type for something that is not used.</p>

<p>I have tried this -</p>

<pre class=""lang-swift prettyprint-override""><code>typealias Props = Void?
init(dependency: Dependency, bindings: Bindings, props: Props?)
</code></pre>

<p>and then setting up my view with -</p>

<p><code>let avm: Attachable&lt;StartViewModel&gt; = .detached(dependencies, nil)</code></p>

<p>But having to add <code>typealias Props = Void?</code> in all my models that don't accept anything feels off</p>

<p>How can I achieve this in the most scalable, generic way?</p>
","10823240","","","","","2019-11-16 16:09:59","Injecting additional props into a viewmodel using generics","<swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58901805","1","58902605","","2019-11-17 15:01:38","","1","373","<p>I got problem with zip operator. I plan to use timer observable</p>

<pre><code>var timer = Observable&lt;Int&gt;
        .interval(0.1, scheduler: MainScheduler.instance)
        .do(onNext:
            { num in
                if(num == 20)
                {
                    //Purpose of this timer is to show progress if second request takes too long
                    MessagesManager.show_progress()
                }
        })

let source = Observable .... //my observable of networking request

return Observable.zip(source, timer,
               resultSelector: { value1, value2 in

                // Here i want to cancel/dispose/stop timer observable
                return value1
           })
    .do(onNext:
        { item in
            MessagesManager.dismiss_progress()
    }, onError:
        { error in
            MessagesManager.dismiss_progress()
    })
</code></pre>

<p>I expected zip operator to close second observable when first call onComplete, but timer continues to work after network request is completed. How can i solve this issue and dispose timer observable in/after zip block?</p>
","9509136","","","","","2019-11-17 16:26:21","RxSwift dispose observable in Zip operator","<ios><swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58912312","1","58912516","","2019-11-18 10:19:11","","1","309","<p>When using if/else to return a or b base on the condition, i got this error: <code>Cannot convert value of type 'Observable&lt;_.Element&gt;' to specified type 'Observable&lt;Int&gt;'</code></p>

<pre class=""lang-swift prettyprint-override""><code>let a = Observable.of(1)
let b = Observable.of(2)
var test = true
let c: Observable&lt;Int&gt; = Observable.of(3).flatMap { _ in
    if test {
        return a
    } else {
        return b
    }
}
</code></pre>

<p>But when i changed to conditional operator, it worked fine:</p>

<pre class=""lang-swift prettyprint-override""><code>let a = Observable.of(1)
let b = Observable.of(2)
var test = true
let c: Observable&lt;Int&gt; = Observable.of(3).flatMap { _ in
    return test ? a : b
}
</code></pre>

<p>Why does the first one not work? What is the different between to cases?</p>
","8419894","","","","","2019-11-18 10:30:21","Returning observable using if/else statement is not working with RxSwift flatMap","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58932895","1","","","2019-11-19 11:20:15","","1","259","<p>I am trying to do a recursive call using RxSwift Observables. </p>

<pre><code>import RxSwift

func observeUntil(initialValue: Int) -&gt; Observable&lt;Int&gt; {

    return Observable.deferred {
        .just(initialValue)
    }
    .do(onNext: {
        print(""current item is"", $0)
    })
        .flatMapLatest{ (item) -&gt; Observable&lt;Int&gt; in
            if item &lt; 5 {
                return Observable.just(item)
                    //                    .delay(.seconds(1), scheduler: MainScheduler.instance)
                    .flatMapLatest{observeUntil(initialValue: $0 + 1)}
            } else {
                return .just(item)
            }
    }
}
_ = observeUntil(initialValue: 0)
    .subscribe()
</code></pre>

<p>When I <strong>comment the delay</strong> in above code, the output comes correctly like below</p>

<pre><code>current item is 0
current item is 1
current item is 2
current item is 3
current item is 4
current item is 5
Program ended with exit code: 0
</code></pre>

<p>with <strong>delay</strong> the code only outputs </p>

<pre><code>current item is 0
Program ended with exit code: 0
</code></pre>

<p>Please help me to understand what happens when the delay is added.</p>
","1201374","","6154972","","2019-11-25 13:48:40","2019-11-25 13:48:40","Recursive calls using RxSwift Observables","<ios><swift><rx-swift>","2","2","","","","CC BY-SA 4.0"
"58937977","1","","","2019-11-19 15:50:51","","0","610","<p>I want to pass expandable tableView from default to Rx, but i found trouble that i can't use properly <strong>numberOfRownInSection</strong>. </p>

<p>Now the logic is... when you struct has flag <strong>isExpandable = false</strong>, row count is <strong>0</strong> </p>

<p>What i have is <strong>tableView</strong> with static data (struct will provide below). HeaderView as title and cells as expandable content. </p>

<p><strong>Toggle func:</strong></p>

<pre><code>func toggleCell(_ section: Int) {

    var indexPaths = [IndexPath]()

    for row in data[section].items.indices {
        let indexPath = IndexPath(row: row, section: section)
        indexPaths.append(indexPath)
    }

    let isExpanded = data[section].isExpanded
    data[section].isExpanded = !isExpanded

    if isExpanded {
        categoriesTableView.deleteRows(at: indexPaths, with: .none)
    } else {
        categoriesTableView.insertRows(at: indexPaths, with: .none)
    }

}
</code></pre>

<p><strong>Default tableView delegate:</strong></p>

<pre><code>    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
    let cell: HomeViewCell = tableView.dequeueReusableCell(forIndexPath: indexPath)
    cell.categoryLabel.text = data[indexPath.section].items[indexPath.row].title ?? """"
    return cell
}

func numberOfSections(in tableView: UITableView) -&gt; Int {
    return data.count
}

func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
    if !data[section].isExpanded {
        return 0
    }

    return data[section].items.count
}
</code></pre>

<p><strong>Struct</strong></p>

<pre><code>var data: [CategoriesSectionData] = [CategoriesSectionData(header: ""Elektro"",            items: [CategoriesCellData(price: 12.99, title: ""Gärtner 1""),
                                                                                                 CategoriesCellData(price: 15.30, title: ""Gärtner 2""),
                                                                                                 CategoriesCellData(price: 25.99, title: ""Gärtner 3"")], isExpanded: false, icon: ""home_menu_1""),
                                     CategoriesSectionData(header: ""Gartenpflege"",       items: [CategoriesCellData(price: 14.0, title: ""Gärtner 1"")], isExpanded: false, icon: ""home_menu_2""),
                                     CategoriesSectionData(header: ""Sanitär"",            items: [], isExpanded: false, icon: ""home_menu_3""),
                                     CategoriesSectionData(header: ""Hausmeisterdienste"", items: [], isExpanded: false, icon: ""home_menu_4""),
                                     CategoriesSectionData(header: ""Meisterprüfung"",     items: [], isExpanded: false, icon: ""home_menu_3""),
                                     CategoriesSectionData(header: ""Gartenpflege"",       items: [], isExpanded: false, icon: ""home_menu_2""),
                                     CategoriesSectionData(header: ""Sanitär"",            items: [], isExpanded: false, icon: ""home_menu_1""),
                                     CategoriesSectionData(header: ""Hausmeisterdienste"", items: [], isExpanded: false, icon: ""home_menu_4"")]
</code></pre>

<p><strong>To pass this to Rx i used following code</strong> but i have error when insert/delete rows because i don't want to clear my dataSource and can't set <strong>numberOfRownInSection</strong> to not display cells with expandable flag.</p>

<pre><code>let dataSource = RxTableViewSectionedReloadDataSource&lt;CategoriesSectionData&gt;(
        configureCell: { ds, tv, indexPath, item in

            let cell: HomeViewCell = tv.dequeueReusableCell(forIndexPath: indexPath)
            cell.categoryLabel.text = item.title ?? """"
            return cell
        },

        titleForHeaderInSection: { ds, index in
            return ds.sectionModels[index].header
        }
    )

    self.dataSource = dataSource

    Observable.just(data)
        .bind(to: categoriesTableView.rx.items(dataSource: dataSource))
        .disposed(by: disposeBag)

    categoriesTableView.rx
        .setDelegate(self)
        .disposed(by: disposeBag)
</code></pre>
","9506836","","","","","2019-12-18 13:54:06","Swift 5 RxDataSource expandable cells","<swift><rx-swift><rxdatasources>","1","0","","","","CC BY-SA 4.0"
"58940198","1","58940299","","2019-11-19 17:59:50","","1","1424","<p>In RxJS you can use the value from a observable for a new observable. For example:</p>

<pre><code>this.authService.login(username, password).pipe(
  switchMap((success: boolean) =&gt; {
    if(success) {
      return this.contactService.getLoggedInContact()
    } else {
      return of(null)
    }
  })
).subscribe(contact =&gt; {
  this.contact = contact
})
</code></pre>

<p>But now I have to do a project in Swift and I want to achieve the same thing. I can get the two methods working, but using the result of the first observable for the second observable is something i can't get working. The <code>switchMap</code> pipe is something that does not exist in RxSwift and I cannot find the equivalent. </p>

<p>I've tried mapping the result of the login function to the observable and then flatmapping it, but unfortunately that didn't work.</p>

<p>What is the best way to do this in Swift without using a subscribe in a subscribe?</p>

<p>EDIT I've tried flat map:</p>

<pre><code>APIService.login(email: ""username"", password: ""password"")
  .flatMapLatest { result -&gt; Observable&lt;Contact&gt; in
    if result {
      return APIService.getLoggedInContact()
    } else {
      return .of()
    }
  }.subscribe(onNext: {result in
    print(""Logged in contact: \(result)"")
  }, onError: {Error in
    print(Error)
  }).disposed(by: disposeBag)
</code></pre>

<p>But unfortunately that didn't work, I get an error <code>Thread 1: EXC_BAD_ACCESS (code=1, address=0x13eff328c)</code></p>

<p>EDIT2:</p>

<p>This is the login function</p>

<pre class=""lang-swift prettyprint-override""><code>static func login(email: String, password: String) -&gt; Observable&lt;Bool&gt; {
        return Observable&lt;String&gt;.create { (observer) -&gt; Disposable in
            Alamofire.request(self.APIBASEURL + ""/contact/login"", method: .post, parameters: [
                ""email"": email,
                ""password"": password
            ], encoding: JSONEncoding.default).validate().responseJSON(completionHandler: {response in
                if (response.result.isSuccess) {
                    guard let jsonData = response.data else {

                        return observer.onError(CustomError.api)
                    }
                    let decoder = JSONDecoder()

                    let apiResult = try? decoder.decode(ApiLogin.self, from: jsonData)
                    return observer.onNext(apiResult!.jwt)
                } else {
                    return self.returnError(response: response, observer: observer)
                }
            })

            return Disposables.create()
        }.map{token in
            return KeychainWrapper.standard.set(token, forKey: ""authToken"")
        }
    }
</code></pre>

<p>This is the getLoggedInContact function</p>

<pre class=""lang-swift prettyprint-override""><code>static func getLoggedInContact() -&gt; Observable&lt;Contact&gt; {
        return Observable.create { observer -&gt; Disposable in
            Alamofire.request(self.APIBASEURL + ""/contact/me"", method: .get, headers: self.getAuthHeader())
              .validate().responseJSON(completionHandler: {response in
                if (response.result.isSuccess) {
                    guard let jsonData = response.data else {

                        return observer.onError(CustomError.api)
                    }

                    let decoder = JSONDecoder()
                    decoder.dateDecodingStrategy = .formatted(.apiNewsDateResult)

                    let apiResult = try? decoder.decode(Contact.self, from: jsonData)
                    return observer.onNext(apiResult!)
                } else {
                    return self.returnError(response: response, observer: observer)
                }
            })

            return Disposables.create()
        }
    }
</code></pre>
","8849564","","8849564","","2019-11-23 11:03:39","2019-11-23 11:03:39","RxSwift equivalent for switchmap","<swift><rxjs><reactive-programming><rx-swift><reactivex>","1","8","","","","CC BY-SA 4.0"
"58940235","1","58953617","","2019-11-19 18:02:11","","1","532","<p>I have a requirement to request an <code>Article</code>.</p>

<p>Each <code>Article</code> contains an array of <code>ArticleAsset</code> which has various props on I need when rendering an entire article.</p>

<p>I do not know ahead of time how many assets exist on an article, so I must request the article and then using the <code>assets</code> prop dispatch X amount of request to return the value of each <code>ArticleAsset</code>.</p>

<p>At that point I should then return both the article and the array of results for my asset fetches.</p>

<p>For simplicity imagine in this case each asset returns an <code>Int</code>. So I start with this -</p>

<p><code>Article</code> > <code>[Article]</code></p>

<p>I would expect to end up with an tuple of the following shape <code>(article: Article, assets: [Int])</code></p>

<p>I have attempted to recreate this as the below playground, but have been completely unsuccessful and am a little stuck.</p>

<p>I understand how to chain a fixed number of requests, using <code>flatMapLatest</code> etc but in this case I do not know the number of requests. I'm thinking I should map each <code>ArticleAsset</code> and return an array of <code>Observables</code> however I start to get very fuzzy on where to go next.</p>

<p>Any help would be much appreciated please and thank you.</p>

<pre><code>import UIKit
import RxSwift

private let disposeBag = DisposeBag()

struct Article {
       let id: UUID = UUID()
       var assets: [ArticleAsset]
   }

   struct ArticleAsset {
       let number: Int
   }

   let assets: [ArticleAsset] = Array(0...4).map { ArticleAsset(number: $0) }
   let article = Article(assets: assets)

   func fetchArticle() -&gt; Observable&lt;Article&gt; {
       return Observable.of(article)
   }

   func getArticleAsset(asset: ArticleAsset) -&gt; Observable&lt;Int&gt; {
       return .of(asset.number)
   }

   fetchArticle()
       .map { art in
           let assets = art.assets.map { getArticleAsset(asset: $0) }
           let resp = (article: art, assets: Observable.of(assets))
           return resp
   }.subscribe(onNext: { resp in

     // I would like my subscriber to receive (article: Article, assets: [Int])

   }).disposed(by: disposeBag)
</code></pre>
","7579156","","","","","2019-11-20 11:46:00","Chain requests in RxSwift using first request to setup further requests then return all when complete","<swift><reactive-programming><rx-swift><chaining>","2","0","","","","CC BY-SA 4.0"
"58964048","1","58967441","","2019-11-20 22:00:56","","1","226","<p>I have a viewModel where I am performing a check based on bool. True / False. This value is passed into a <code>PublishSubject&lt;Bool&gt;()</code> now I want to get the latestValue with flatMapLatest and navigate using another different ViewModel based on the value of True/False</p>

<pre><code>routeManager.errorOnNil().asObservable()

            .flatMapLatest { (code) -&gt; Observable&lt;RxSwift.Event&lt;User&gt;&gt; in
            let params = code.values
                let challengeId = Int(params[""challengeId""] as? String ?? ""0"")

            return self.provider.postVerifyApp(challengeId: login.challengeId!)
            .trackActivity(self.loading)
            .trackError(self.error)
            .materialize()
        }.subscribe(onNext: { [weak self] (event) in
            switch event {
            case .next(let token):
                log(token)
                if token.data != nil {
                    self?.dataStatus.onNext(true)
                } else {
                    self?.dataStatus.onNext(false)
                }
            case .error(let error):
                log(error.localizedDescription)
            default: break
            }
        }).disposed(by: rx.disposeBag)
</code></pre>

<p>Where to switch</p>

<pre><code>dataStatus.flatMapLatest { (status) -&gt; ViewModel in
            if status {
                let viewModel = XXXViewModel(provider: self.provider)
                return viewModel
            } else {
                let viewModel = YYYYViewModel(provider: self.provider)
                return viewModel
            }
        }.subscribe()
            .disposed(by: rx.disposeBag)
</code></pre>

<p>this gives error <code>Instance method 'flatMapLatest' requires that 'ViewModel' conform to 'ObservableConvertibleType'</code></p>
","8310287","","","","","2019-11-21 04:43:09","Switching viewModels with flatMap swift","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58974971","1","","","2019-11-21 12:23:15","","0","127","<p>I am using deeplink to open my application so if the a button is tapped, the user gets an email in turn clicks the link and is directed to the same page he/she is currently. I am using the MVVM architecture and I want to be able to make changes based on result got from an api call which occurs when the user gets back to the App but I am unable to get my Observables to react from the Api response</p>

<pre><code>init(routeManager: RouteMatchResult?, provider: Api, currentEmail: String?) {
        self.routeManager = BehaviorRelay(value: routeManager)
        self.currentEmail = BehaviorRelay(value: currentEmail)
        nightModeEnabled = BehaviorRelay(value: ThemeType.currentTheme().isDark)
        super.init(provider: provider)
        self.dataXXX.accept(())
//        loadInvite()
    }

    func transform(input: Input) -&gt; Output {

dataXXX.asObservable().subscribe({_ in
            print(""DDDD=========++++++++++++==========DDDDD"")
        }).disposed(by: rx.disposeBag)
       return Output()
}
</code></pre>

<p>However, if I uncomment <code>loadInvite()</code> the code runs in that function and trying to get <code>dataXXX</code> to subscribe to does not work</p>

<pre><code>func loadInvite() {

        routeManager.errorOnNil().asObservable()

            .flatMapLatest { (code) -&gt; Observable&lt;RxSwift.Event&lt;User&gt;&gt; in
            log(""=========++++++++++++=========="")
//            guard let code = code else {return}
            let params = code.values

            return self.provider.postVerifyApp(challengeId: code)
            .trackActivity(self.loading)
            .trackError(self.error)
            .materialize()
        }.subscribe(onNext: { [weak self] (event) in
            log(""=========++++++++++++==========+++++++++++"", .fuck)
            switch event {
            case .next(let token):
                log(token)
                if token.data != nil {
                    self?.dataStatuBool.accept(true)
                    self?.dataStatus.onNext(true)
                    log(""=========++++++++++ TRUE ========+++++++++++"", .fuck)
                    self?.homeData.onNext(())
                } else {
                    self?.nilData.onNext(())
                    self?.dataStatuBool.accept(false)
                    self?.dataStatus.onNext(false)
                    log(""=========+++++++++ FALSE ======+++++++++++"", .fuck)
                }
            case .error(let error):
                log(error.localizedDescription)
            default: break
            }
        }).disposed(by: rx.disposeBag)

        nilData.asObservable().flatMapLatest { () -&gt; Observable&lt;EmailSharingViewModel&gt; in
            print(""SUBBBBBBB XXX"")
            let viewModel = EmailSharingViewModel(provider: self.provider)
            return Observable.just(viewModel)
        }.subscribe()
        .disposed(by: rx.disposeBag)
    }
}
</code></pre>
","8310287","","","","","2019-11-22 08:56:45","Listen for changes rxswift","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"58977169","1","58980021","","2019-11-21 14:23:51","","1","95","<p>I have a problem with <strong>IGListKit</strong> sections deallocating. Trying to debug the issue with Xcode memory graph.</p>

<p>My setup is <strong>AuthController</strong> -> <strong>AuthViewModel</strong> -> <strong>AuthSocialSectionController</strong> -> <strong>AuthSocialViewModel</strong> and some other sections.</p>

<p><strong>AuthController</strong> gets presented from several parts of the app if user is not logged in. When I tap close, <strong>AuthViewModel</strong> and AuthController gets deallocated, but it's underlying sections does not. Memory graph shows nothing leaked in this case, but <code>deinit</code> methods doesn't get called.</p>

<p>But when I'm trying to authorize with social account (successfully) and then look at the memory graph, it shows that sections, that doesn't get deallocated like this:</p>

<p><a href=""https://i.stack.imgur.com/CPDvp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CPDvp.png"" alt=""Memory graph""></a>
<a href=""https://i.stack.imgur.com/dhhZ3.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dhhZ3.png"" alt=""Memory graph""></a>
<a href=""https://i.stack.imgur.com/T0CxK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/T0CxK.png"" alt=""Memory graph""></a></p>

<p>In this case AuthViewModel doesn't get deallocated either, but after some time it does, but it can happen or not.</p>

<p>I checked every closure and delegate for weak reference, but still no luck.</p>

<p>My code, that I think makes most sense:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>class AuthViewController: UIViewController {
	fileprivate let collectionView: UICollectionView = UICollectionView(frame: .zero,
	                                                                    collectionViewLayout: UICollectionViewFlowLayout())
	lazy var adapter: ListAdapter
		= ListAdapter(updater: ListAdapterUpdater(), viewController: self, workingRangeSize: 0)

	fileprivate lazy var previewProxy: SJListPreviewProxy = {
		SJListPreviewProxy(adapter: adapter)
	}()

	fileprivate let viewModel: AuthViewModel

	fileprivate let disposeBag = DisposeBag()

	init(with viewModel: AuthViewModel) {
		self.viewModel = viewModel

		super.init(nibName: nil, bundle: nil)

		hidesBottomBarWhenPushed = true
		setupObservers()
	}

	private func setupObservers() {
		NotificationCenter.default.rx.notification(.SJAProfileDidAutoLogin)
			.subscribe(
				onNext: { [weak self] _ in
					self?.viewModel.didSuccessConfirmationEmail()
					self?.viewModel.recoverPasswordSuccess()
			})
			.disposed(by: disposeBag)
	}

	required init?(coder _: NSCoder) {
		fatalError(""init(coder:) has not been implemented"")
	}

	// MARK: - View Controller Lifecycle

	override func viewDidLoad() {
		super.viewDidLoad()
		setup()
	}

	// MARK: - Private

	@objc private func close() {
		dismiss(animated: true, completion: nil)
	}

	/// Метод настройки экрана
	private func setup() {
		if isForceTouchEnabled() {
			registerForPreviewing(with: previewProxy, sourceView: collectionView)
		}

		view.backgroundColor = AppColor.instance.gray
		title = viewModel.screenName
		let item = UIBarButtonItem(image: #imageLiteral(resourceName: ""close.pdf""), style: .plain, target: self, action: #selector(AuthViewController.close))
		item.accessibilityIdentifier = ""auth_close_btn""
		asViewController.navigationItem.leftBarButtonItem = item
		navigationItem.titleView = UIImageView(image: #imageLiteral(resourceName: ""logo_superjob.pdf""))

		collectionViewSetup()
	}

	// Настройка collectionView
	private func collectionViewSetup() {
		collectionView.keyboardDismissMode = .onDrag
		collectionView.backgroundColor = AppColor.instance.gray
		view.addSubview(collectionView)
		adapter.collectionView = collectionView
		adapter.dataSource = self
		collectionView.snp.remakeConstraints { make in
			make.edges.equalToSuperview()
		}
	}
}

// MARK: - DataSource CollectionView

extension AuthViewController: ListAdapterDataSource {

	func objects(for listAdapter: ListAdapter) -&gt; [ListDiffable] {
		return viewModel.sections(for: listAdapter)
	}

	func listAdapter(_: ListAdapter, sectionControllerFor object: Any) -&gt; ListSectionController {
		return viewModel.createListSectionController(for: object)
	}

	func emptyView(for _: ListAdapter) -&gt; UIView? {
		return nil
	}
}

// MARK: - AuthViewModelDelegate

extension AuthViewController: AuthViewModelDelegate {
	func hideAuth(authSuccessBlock: AuthSuccessAction?) {
		dismiss(animated: true, completion: {
			authSuccessBlock?()
		})
	}

	func reload(animated: Bool, completion: ((Bool) -&gt; Void)? = nil) {
		adapter.performUpdates(animated: animated, completion: completion)
	}

	func showErrorPopover(with item: CommonAlertPopoverController.Item,
	                      and anchors: (sourceView: UIView, sourceRect: CGRect)) {
		let popover = CommonAlertPopoverController(with: item,
		                                           preferredContentWidth: view.size.width - 32.0,
		                                           sourceView: anchors.sourceView,
		                                           sourceRect: anchors.sourceRect,
		                                           arrowDirection: .up)
		present(popover, animated: true, completion: nil)
	}
}</code></pre>
</div>
</div>
</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>class AuthViewModel {

	fileprivate let assembler: AuthSectionsAssembler

	fileprivate let router: AuthRouter

	fileprivate let profileFacade: SJAProfileFacade

	fileprivate let api3ProfileFacade: API3ProfileFacade

	fileprivate let analytics: AnalyticsProtocol

	fileprivate var sections: [Section] = []

	weak var authDelegate: AuthDelegate?
	weak var vmDelegate: AuthViewModelDelegate?
  
  var authSuccessBlock: AuthSuccessAction?
  
  private lazy var socialSection: AuthSocialSectionViewModel = { [unowned self] in
		self.assembler.socialSection(delegate: self)
	}()

  init(assembler: AuthSectionsAssembler,
	     router: AuthRouter,
	     profileFacade: SJAProfileFacade,
	     api3ProfileFacade: API3ProfileFacade,
	     analytics: AnalyticsProtocol,
	     delegate: AuthDelegate? = nil,
	     purpose: Purpose) {
		self.purpose = purpose
		authDelegate = delegate
		self.assembler = assembler
		self.router = router
		self.profileFacade = profileFacade
		self.api3ProfileFacade = api3ProfileFacade
		self.analytics = analytics
		sections = displaySections()
	}
  
  private func authDisplaySections() -&gt; [Section] {
		let sections: [Section?] = [vacancySection,
		                            authHeaderSection,
		                            socialSection,
		                            authLoginPasswordSection,
		                            signInButtonSection,
		                            switchToSignUpButtonSection,
		                            recoverPasswordSection]
		return sections.compactMap { $0 }
	}
}</code></pre>
</div>
</div>
</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>class AuthSocialSectionController: SJListSectionController, SJUpdateCellsLayoutProtocol {
	fileprivate let viewModel: AuthSocialSectionViewModel

	init(viewModel: AuthSocialSectionViewModel) {
		self.viewModel = viewModel
		super.init()
		minimumInteritemSpacing = 4
		viewModel.vmDelegate = self
	}

	override func cellType(at _: Int) -&gt; UICollectionViewCell.Type {
		return AuthSocialCell.self
	}

	override func cellInitializationType(at _: Int) -&gt; SJListSectionCellInitializationType {
		return .code
	}

	override func configureCell(_ cell: UICollectionViewCell, at index: Int) {
		guard let itemCell = cell as? AuthSocialCell else {
			return
		}
		let item = viewModel.item(at: index)
		itemCell.imageView.image = item.image
	}

	override func separationStyle(at _: Int) -&gt; SJCollectionViewCellSeparatorStyle {
		return .none
	}
}

extension AuthSocialSectionController {
	override func numberOfItems() -&gt; Int {
		return viewModel.numberOfItems
	}
  
	override func didSelectItem(at index: Int) {
		viewModel.didSelectItem(at: index)
	}

}

// MARK: - AuthSocialSectionViewModelDelegate

extension AuthSocialSectionController: AuthSocialSectionViewModelDelegate {
	func sourceViewController() -&gt; UIViewController {
		return viewController ?? UIViewController()
	}
}</code></pre>
</div>
</div>
</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>protocol AuthSocialSectionDelegate: class {

	func successfullyAuthorized(type: SJASocialAuthorizationType)

	func showError(with error: Error)
}

protocol AuthSocialSectionViewModelDelegate: SJListSectionControllerOperationsProtocol, ViewControllerProtocol {
	func sourceViewController() -&gt; UIViewController
}

class AuthSocialSectionViewModel: NSObject {
	struct Item {
		let image: UIImage
		let type: SJASocialAuthorizationType
	}

	weak var delegate: AuthSocialSectionDelegate?
	weak var vmDelegate: AuthSocialSectionViewModelDelegate?

	fileprivate var items: [Item]

	fileprivate let api3ProfileFacade: API3ProfileFacade
	fileprivate let analyticsFacade: SJAAnalyticsFacade
	fileprivate var socialButtonsDisposeBag = DisposeBag()

	init(api3ProfileFacade: API3ProfileFacade,
	     analyticsFacade: SJAAnalyticsFacade) {
		self.api3ProfileFacade = api3ProfileFacade
		self.analyticsFacade = analyticsFacade
		items = [
			Item(image: #imageLiteral(resourceName: ""ok_icon.pdf""), type: .OK),
			Item(image: #imageLiteral(resourceName: ""vk_icon.pdf""), type: .VK),
			Item(image: #imageLiteral(resourceName: ""facebook_icon.pdf""), type: .facebook),
			Item(image: #imageLiteral(resourceName: ""mail_icon.pdf""), type: .mail),
			Item(image: #imageLiteral(resourceName: ""google_icon.pdf""), type: .google),
			Item(image: #imageLiteral(resourceName: ""yandex_icon.pdf""), type: .yandex)
		]

		if analyticsFacade.isHHAuthAvailable() {
			items.append(Item(image: #imageLiteral(resourceName: ""hh_icon""), type: .HH))
		}
	}

	// MARK: - actions

	func didSelectItem(at index: Int) {
		guard let vc = vmDelegate?.sourceViewController() else {
			return
		}

		let itemType: SJASocialAuthorizationType = items[index].type

		socialButtonsDisposeBag = DisposeBag()
		
		api3ProfileFacade.authorize(with: itemType, sourceViewController: vc)
			.subscribe(
				onNext: { [weak self] _ in
					self?.delegate?.successfullyAuthorized(type: itemType)
				},
				onError: { [weak self] error in
					if case let .detailed(errorModel)? = error as? ApplicantError {
						self?.vmDelegate?.asViewController.showError(with: errorModel.errors.first?.detail ?? """")
					} else {
						self?.vmDelegate?.asViewController.showError(with: ""Неизвестная ошибка"")
					}
			})
			.disposed(by: socialButtonsDisposeBag)
	}
}

// MARK: - DataSource

extension AuthSocialSectionViewModel {
	var numberOfItems: Int {
		return items.count
	}

	func item(at index: Int) -&gt; Item {
		return items[index]
	}
}

// MARK: - ListDiffable

extension AuthSocialSectionViewModel: ListDiffable {
	func diffIdentifier() -&gt; NSObjectProtocol {
		return ObjectIdentifier(self).hashValue as NSObjectProtocol
	}

	func isEqual(toDiffableObject object: ListDiffable?) -&gt; Bool {
		return object is AuthSocialSectionViewModel
	}
}</code></pre>
</div>
</div>
</p>

<p>Where assembler is responsible for creating everyting, for example AuthSocialSection:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>func socialSection(delegate: AuthSocialSectionDelegate?) -&gt; AuthSocialSectionViewModel {
		let vm = AuthSocialSectionViewModel(api3ProfileFacade: api3ProfileFacade,
		                                    analyticsFacade: analyticsFacade)
		vm.delegate = delegate
		return vm
	}</code></pre>
</div>
</div>
</p>

<p>How can I properly debug this issue? Any advice or help is really appreciated</p>
","9505639","","","","","2019-12-23 12:11:47","IGListKitSections doesn't get deallocated","<swift><rx-swift><iglistkit>","2","8","","","","CC BY-SA 4.0"
"59030466","1","","","2019-11-25 11:12:14","","0","135","<p><strong>I have one filter type enum</strong></p>

<p>import RxSwift
import RxCocoa</p>

<pre><code>enum FilterType {
    case all
    case rental
    case purchased
}

var currentCategory: Driver&lt;FilterType&gt; = Driver.just(.all)
</code></pre>

<p><strong>whenever I am updating the currentCategory on segment click. like below</strong> 
currentCategory = Driver.just(.purchased).</p>

<p><strong>I am always getting the same value all every time. I am new to RXSwift and RXCocoa. Please help me to get out of this situation. Thanks in advance.</strong></p>
","12242095","","","","","2019-11-25 13:27:21","Driver is not updation with latest value","<ios><swift><rx-swift><rx-cocoa><xcode11.1>","1","0","","","","CC BY-SA 4.0"
"59035797","1","59053006","","2019-11-25 16:06:23","","2","35","<p>I have an <code>Observable&lt;Foo&gt;</code> that emits some values but never completes.  Let’s call that <code>source</code>.  I want to create an <code>Observable&lt;[Foo]&gt;</code> that emits all of the items that <code>source</code> has emitted so far, whenever <code>source</code> emits.</p>

<p>For example, if <code>source</code> emits a then b then c, the result must emit [a] then [a, b] then [a, b, c].</p>

<p>How can this be accomplished?</p>

<p>Any help much appreciated!</p>
","64239","","","","","2019-11-26 14:21:16","Create an observable that emits all values so far","<swift><reactive-programming><rx-swift>","1","4","","","","CC BY-SA 4.0"
"59043469","1","","","2019-11-26 03:48:00","","-1","512","<p>I'm new to RxSwift and MVVM , my old project used to pass data between VC via ""prepare for segue"" . Currently I'm successfully integrated RxSwift and MVVM to the project . </p>

<p>What is the best practice to pass data between VCs ?</p>

<p>A) Inside VC1 , -GoToAnotherVC(). 
  Simple create Model2 object , pass data     </p>

<pre><code>  Model.valueA = Model2.valueA.  
</code></pre>

<p>then </p>

<pre><code>   DestinationVC.model = Model2 
</code></pre>

<p>B) Create Model2 within VC1 immediately , Use Rx Magic to bind Model1.value and Model2.value </p>

<p>C) Any better approach ?</p>
","12078712","","","","","2019-12-05 17:32:37","Best way to pass data while navigate to another VC with MVVM RxSwift?","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"59062353","1","","","2019-11-27 02:57:05","","0","73","<p>This is my code here:</p>

<pre><code>class MapManager: NSObject {

    let removeFenceTask = BehaviorRelay&lt;String?&gt;(value: nil)

    override init() {
        super.init()

        removeFenceTask
            .filter({ $0 != nil })
            .debug(""removeFenceTask"", trimOutput: true)
            .flatMap { (taskId: String?) -&gt; Observable&lt;TaskModel&gt; in
                guard let `taskId` = taskId, let provider = Application.shared.provider else { return Observable.just(TaskModel()) }
                return provider.queryTaskDetail(taskId: taskId).asObservable()
        }
        .asObservable()
        .subscribe(onNext: { [weak self] (taskModel) in
            self?.removeFence(taskModel: taskModel)
        }).disposed(by: rx.disposeBag)

    }
}
</code></pre>

<pre><code>    func queryTasks(_ currentPage: Int, status: TaskStatus) -&gt; Single&lt;([TaskModel], Bool)&gt; {
        return requestObject(
            .queryTasks(currentPage: currentPage, pageSize: 10, status: status), type: TaskModelWrapper.self)
            .map({ (taskModelWrapper) -&gt; ([TaskModel], Bool) in
                let tasks = taskModelWrapper.data?.data ?? []
                tasks.filter({ $0.taskStatus == .canceled || $0.taskStatus == .deliveryCompleted || $0.taskStatus == .taskCompleted || $0.taskStatus == .terminated })
                    .forEach { (taskModel) in
                        MapManager.shared.removeFenceTask.accept(taskModel.taskId)
                }
                return (tasks, taskModelWrapper.data?.isNoMoreDataShow ?? false)
            })
    }
</code></pre>

<p>Finally I got <strong>isDisposed</strong> after 2 event successfully</p>

<p><em>Console:</em></p>

<p><em>2019-11-27 10:46:27.203: newFenceTask -> subscribed</em></p>

<p><em>2019-11-27 10:46:27.203: removeFenceTask -> subscribed</em></p>

<p><em>2019-11-27 10:46:27.204: removeFenceTask -> Event next(Optional(""123""))</em></p>

<p><em>2019-11-27 10:46:27.207: removeFenceTask -> Event next(Optional(""1908157SRZTT2DGF""))</em></p>

<p><em>2019-11-27 10:46:27.295: removeFenceTask -> isDisposed</em></p>

<p><strong>Question:</strong> Why this <code>isDisposed</code> happened?</p>
","7329400","","","","","2019-11-27 07:02:55","RxSwift BehaviorRelay auto isDisposed","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"59078855","1","59078915","","2019-11-27 21:43:02","","1","408","<p>I'm trying to implement <code>RxSwift</code> single observable:</p>

<pre><code>class Doctor {
    var disposeBag = DisposeBag()

    func sanityCheck() -&gt; Single&lt;String&gt; {
        return Single&lt;String&gt;.create {[weak self] observer in
            if self?.amICrazy() == true {
                observer(.success(""Yes, you are crazy""))
            }else {
                observer(.error(someError.notCrazy))
            }
            return Disposables.create()
        }
    }

    func amICrazy() -&gt; Bool {
        return arc4random_uniform(2) == 0
    }
}
</code></pre>

<p>But the problem the <code>self</code> is always nil.</p>

<p>Any of you knows why <code>self</code> is nil or how can fix it?</p>

<p>I'll really appreciate your help.</p>
","2924482","","","","","2019-11-28 12:19:00","RxSwift: single observable self is nil","<ios><rx-swift><xcode11.2><swift5.2>","2","1","","","","CC BY-SA 4.0"
"59118403","1","59120663","","2019-11-30 17:08:03","","0","323","<p>Im reading this blog about the input output ViewModel approach:
<a href=""https://medium.com/blablacar-tech/rxswift-mvvm-66827b8b3f10"" rel=""nofollow noreferrer"">https://medium.com/blablacar-tech/rxswift-mvvm-66827b8b3f10</a></p>

<p>full code: <a href=""https://gist.github.com/MartinMoizard"" rel=""nofollow noreferrer"">https://gist.github.com/MartinMoizard</a></p>

<p>Im just puzzled on how did the</p>

<pre><code>let greeting = validateSubject
        .withLatestFrom(nameSubject)
        .map { name in
            return ""Hello \(name)!""
        }
        .asDriver(onErrorJustReturn: "":-("")
</code></pre>

<p><a href=""https://gist.github.com/MartinMoizard/4d66528a9959cbbdefa6d50394d2bfb1"" rel=""nofollow noreferrer"">https://gist.github.com/MartinMoizard/4d66528a9959cbbdefa6d50394d2bfb1</a></p>

<p>is being triggered if the <strong>validateSubject</strong> is private upon tapped in 
<a href=""https://gist.github.com/MartinMoizard/449be0d30920010210988f1773a2ca90"" rel=""nofollow noreferrer"">https://gist.github.com/MartinMoizard/449be0d30920010210988f1773a2ca90</a></p>

<pre><code>final class ButtonCell: UITableViewCell, SayHelloViewModelBindable {
    @IBOutlet weak var validateButton: UIButton!
    var disposeBag: DisposeBag?

    override func prepareForReuse() {
        super.prepareForReuse()
        disposeBag = nil
    }

    func bind(to viewModel: SayHelloViewModel) {
        let bag = DisposeBag()
        validateButton.rx
            .tap
            .bind(to: viewModel.input.validate)
            .disposed(by: bag)
        disposeBag = bag
    }
}
</code></pre>

<p>TIA</p>
","11070352","","","","","2019-11-30 22:03:01","RxSwift Input Output, private subject but being triggered outside the class","<ios><swift><rx-swift><kickstarter>","1","0","","","","CC BY-SA 4.0"
"59130647","1","","","2019-12-01 22:41:16","","0","1203","<p>I'm trying to add delay into UITextField but I'm getting the following error:</p>

<pre><code>Property 'text' requires that 'UITextField' inherit from 'UILabel'
Value of type 'Binder&lt;String?&gt;' has no member 'debounce'
</code></pre>

<p>Here is my implementation:</p>

<pre><code>   func bind() {
        (myTextField.rx.text.debounce(0.5, scheduler: MainScheduler.instance) as AnyObject)
            .map {
                if  $0 == """"{
                    return ""Type your name bellow""
                }else {
                    return ""Hello, \($0 ?? """").""
                }
        }
        .bind(to: myLbl.rx.text)
        .disposed(by: disposeBag)
    }
</code></pre>

<p>Any of you knows why I'm getting this error?</p>

<p>I'll really appreciate your help.</p>
","2924482","","","","","2019-12-02 10:48:48","RxSwift: Error adding RX bind to UITextField: Value of type 'Binder<String?>' has no member 'debounce'","<ios><rx-swift><rx-cocoa><xcode11.2><swift5.2>","1","0","","","","CC BY-SA 4.0"
"59146283","1","","","2019-12-02 20:33:59","","0","229","<p>I'm trying to use <code>concatMap</code> on <code>BehaviorRelay</code> but I'm getting this error:</p>

<pre><code>Instance method 'concatMap' requires that '[Int]' conform to 'ObservableConvertibleType'
</code></pre>

<p>This is my implementation:</p>

<pre><code>class MyClass{

    var disposeBag = DisposeBag()
    var subject: BehaviorRelay&lt;[Int]&gt; = BehaviorRelay(value: [1,2,3,4,5])


    func doSomething() {
        subject.asObservable().concatMap { $0 }
            .subscribe { print($0) }
            .disposed(by: disposeBag)

    }
}
</code></pre>

<p>I'm getting the error on this line:</p>

<pre><code>subject.asObservable().concatMap { $0 }
</code></pre>

<p>Any of you knows why I'm getting this error or how can fix this error on my implementation ?</p>

<p>I'll really appreciate your help.</p>
","2924482","","","","","2019-12-03 11:15:25","RxSwift: Using BehaviorRelay I get this error: Instance method 'concatMap' requires that '[Int]' conform to 'ObservableConvertibleType'","<rx-swift><xcode11.2><ios13.2><swift5.2>","1","0","","","","CC BY-SA 4.0"
"59148807","1","","","2019-12-03 01:01:26","","0","372","<p>I'm trying to implement <code>compactMap</code> on <code>RxSwift</code> but it seems like is never executed.</p>

<p>Here is my code:</p>

<pre><code>class MyClass{

    var disposeBag = DisposeBag()
    let subject = BehaviorRelay(value: 1)

    func doSomething() {
        Observable.from(optional: subject).compactMap{  $0

        }.subscribe( onNext:{
            print($0)
        }).disposed(by: disposeBag)
        subject.accept(2)
        subject.accept(4)
        subject.accept(5)
        subject.accept(8)
    }
}
</code></pre>

<p>When I change the value on <code>subject</code> the <code>compactMap</code> never gets called. Why not?</p>
","2924482","","1032372","","2019-12-04 05:32:10","2019-12-05 00:17:32","RxSwift: compactMap never executed","<swift><rx-swift><behaviorrelay>","1","1","","","","CC BY-SA 4.0"
"59161388","1","","","2019-12-03 16:26:05","","0","75","<p>I have implemented <code>compactMap</code> over <code>BehaviorRelay</code> and it works just fine:</p>

<pre><code>class MyClass{

    let subject = BehaviorRelay(value: 1)

    func doSomething() {
        subject.compactMap{ $0 }.subscribe(onNext:{
            print($0)
        }).disposed(by: disposeBag)
    }
</code></pre>

<p>My question is if for some reason I want to cancel/stop the <code>BehaviorRelay</code>. There is a way to cancel/stop <code>compactMap</code>?</p>
","2924482","","3345375","","2019-12-04 06:07:55","2019-12-04 06:07:55","RxSwift: Stop compactMap to continue executing","<ios13><rx-swift><xcode11.2><swift5.2><behaviorrelay>","1","0","","","","CC BY-SA 4.0"
"59181529","1","59209129","","2019-12-04 17:18:05","","1","473","<p>I just started to study about RxBluetoothKit as easy solution to interact with BLE devices and I have very basic knowledge of Rx programing.</p>

<p>As i can see from examples, every time i have to write some characteristic i have to scan + establishConnection to Peripheral + discover Services and only then write and subscribe for confirmation of this specific Characteristic.</p>

<p>Same happen for read Characteristic.</p>

<p>If I understand correctly,  this way I can subscribe only to one sequence/ connection at same time.</p>

<p>But what i need is to subscribe to Bluetooth state and to Peripheral connection state and to notify Characteristic, in addition i have send write commands to same Peripheral sometimes.</p>

<p>Need help to understand how should i handle this scenario by using RXBluetoothKit library?
Links to similar approachment on GitHub are welcomed.
Thank you!</p>
","232727","","474398","","2019-12-06 09:57:06","2019-12-06 09:57:06","RxBluetoothKit: How to subscribe to Bluetooth state + Peripheral connection state and Write/Notify characteristics at same time?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"59188451","1","","","2019-12-05 04:52:13","","0","99","<p>I need to modify the headers of the request when the request fails but the request doesn't change when I modify the request in <code>retryWhen</code></p>

<p>Here is my implementation:</p>

<pre><code>func makeRequest(serviceRequest: URLRequest) {
    let maxRetry = 2
    var localRequest = serviceRequest
    request(request: localRequest).retryWhen { errors in
        return errors.enumerated().flatMap { (arg) -&gt; Observable&lt;Int64&gt; in
            localRequest.setValue(""someValue"", forHTTPHeaderField: ""someKey"")

            let (index, error) = arg
            return index &lt;= maxRetry ? Observable&lt;Int64&gt;.timer(DispatchTimeInterval.microseconds(4),
                                                               scheduler: MainScheduler.instance) : Observable.error(error)
        }
    }.subscribe(onNext:{ result in
        print(result)

        }).disposed(by: disposeBag)
}
</code></pre>

<p>If I <code>po localRequest</code> after set headers <code>someKey</code> it would show my changes but if I <code>po request</code> in the request function the request remains the same with no changes. Any of you knows what can I do to changes the request in the <code>retryWhen</code> ?</p>

<p>I'll really appreciate your help.</p>
","2924482","","","","","2019-12-06 12:11:54","RXSwift: Modifying URLRequest if request fails in `retryWhen`","<observable><ios13><rx-swift><urlrequest><xcode11.2>","1","0","","","","CC BY-SA 4.0"
"59190408","1","59197785","","2019-12-05 07:45:11","","-2","347","<p>where should I put UITableView Data Sources (I am using RxDataSources) when using MVVM-C architecture?</p>
","12484280","","","","","2019-12-05 14:55:11","Table View Data Source in MVVM-C","<swift><mvvm><rx-swift><rxdatasources>","1","4","","2019-12-05 16:10:50","","CC BY-SA 4.0"
"59214836","1","59218689","","2019-12-06 14:14:04","","1","147","<p>I have an observable which regularly emits elements. On those elements, I perform one fast and one slow operation. What I want is to drop new elements for slow observer while it is busy. Is there any way to achieve this with Rx instead of keeping a flag in slow operation?</p>

<p>I am very new at Reactive extensions, please correct me if anything is wrong with my assumptions. </p>

<pre class=""lang-swift prettyprint-override""><code>let tick = Observable&lt;Int&gt;.interval(.seconds(1), 
            scheduler: SerialDispatchQueueScheduler(qos: .background)).share()

tick.subscribe {
    print(""fast observer \($0)"")
}.disposed(by: disposeBag)

// observing in another queue so that it does not block the source
tick.observeOn(SerialDispatchQueueScheduler(qos: .background))
    .subscribe {
        print(""slow observer \($0)"")
        sleep(3) // cpu-intensive task
    }.disposed(by: disposeBag)

</code></pre>
","6641096","","","","","2019-12-07 22:01:50","How to drop new elements if an observer is busy?","<swift><reactive-programming><rx-swift>","2","0","","","","CC BY-SA 4.0"
"59229749","1","","","2019-12-07 20:09:00","","-1","136","<p>I'm trying to implement <code>concatMap</code> within <code>RxSwift</code> but when I tried to set a new value to the observable within the <code>concatMap</code> I'm getting this error:</p>

<pre><code>Reentrancy anomaly was detected.
  &gt; Debugging: To debug this issue you can set a breakpoint in /Users/SuperUser/repos/RxObserver/Pods/RxSwift/RxSwift/Rx.swift:96 and observe the call stack.
  &gt; Problem: This behavior is breaking the observable sequence grammar. `next (error | completed)?`
    This behavior breaks the grammar because there is overlapping between sequence events.
    Observable sequence is trying to send an event before sending of previous event has finished.
  &gt; Interpretation: This could mean that there is some kind of unexpected cyclic dependency in your code,
    or that the system is not behaving in the expected way.
  &gt; Remedy: If this is the expected behavior this message can be suppressed by adding `.observeOn(MainScheduler.asyncInstance)`
    or by enqueuing sequence events in some other way.
</code></pre>

<p>Here is my code:</p>

<pre><code>public let myNumbers = BehaviorRelay&lt;String&gt;(value: """")

override func viewDidLoad() {
    super.viewDidLoad()
    processNumbers()
    myNumbers.accept(""one"")
    myNumbers.accept(""two"")
}

func processNumbers() {
    Observable.of(myNumbers).concatMap{ $0
    }.subscribe(onNext:{
        print($0)
        if $0 == ""one"" || $0 == ""two""{
            self.myNumbers.accept(""YEAH!"")
        }
        }).disposed(by: disposeBag)

}
</code></pre>

<p>Any of you know why I am getting this error or how can I change my implementation to avoid getting this error/warning?</p>

<p>I'll really appreciate your help.</p>
","2924482","","6154972","","2019-12-10 07:26:47","2019-12-10 07:26:47","RxSwift: implementing concatMap generating Reentrancy anomaly was detected error","<rx-swift><xcode11.2><concatmap><ios13.2><swift5.2>","2","0","","","","CC BY-SA 4.0"
"59259953","1","59262231","","2019-12-10 03:51:59","","1","430","<p>I have a view controller that needs to know about a boolean variable headerCollapsed that is set from another view controller. In vc1 I have:</p>

<pre><code>headerCollapsed = ReplaySubject&lt;Bool&gt;.create(bufferSize: 1)
collapsedObservable = headerCollapsed.asObservable()
</code></pre>

<p>and a function that sets the boolean to true:</p>

<pre><code>func updateHeader() {
    self.headerCollapsed.onNext(true)
}
</code></pre>

<p>Then, to avoid creating further dependencies and calling vc1 directly, I am trying to pass collapsedObservable, not headerCollapsed, all the way to vc2 through dependency injection and a router. I am trying to simplify the issue, but there are actually several layers between vc1 and vc2.</p>

<p>What is happening though is that inside my router class collapsedObservable is nil no matter what, and I am not able to set it to a default value to be updated later when I call it from inside vc2. So, is passing the actual observable like this even possible?</p>
","11004345","","6154972","","2019-12-10 08:02:05","2019-12-10 20:48:54","RxSwift: Pass actual observable to another view controller?","<swift><observer-pattern><rx-swift><swinject>","2","0","","","","CC BY-SA 4.0"
"59276069","1","","","2019-12-10 22:06:44","","0","119","<p>I'm trying to learn MVVM and RxSwift by making a messaging app, but can't figure out the best way to style cells based on details of the previous cell and if it is the latest cell in the table view. These are used to determine if it has a tail and shows the date above the message.</p>

<p>Currently the <code>messageHasTail()</code> and <code>messageShowsDate()</code> functions get an array with all the messages on it.</p>

<p>Also what improvements can be made to the structure.</p>

<p>TableViewControl</p>

<pre><code>let appServerClient = AppServerClient()
let conversationVM:ConversationViewModel
let messages = [Message]()

init( ) {
    self.inputBar = InputBarAccessoryView()
    conversationVM = ConversationViewModel(appServerClient)
    super.init(nibName: nil, bundle: nil)
}

override func viewDidLoad() {
    super.viewDidLoad()
...
bindViewModel()
conversationVM.getMessages()
}

func bindViewModel(){

    conversationVM.text.asObservable()
        .bind(to: inputBar.inputTextView.rx.text)
    .disposed(by: disposeBag)


    inputBar.inputTextView.rx.text.compactMap { $0 }
    .bind(to: conversationVM.text)
    .disposed(by: disposeBag)

    inputBar.sendButton.rx.tap.asObservable()
        .bind(to: conversationVM.submitButtonTapped)
        .disposed(by: disposeBag)


    conversationVM.conversationOb.bind(to: self.tableView.rx.items) { tableView, index, message in

        let indexPath = IndexPath(item: index, section: 0)
        guard let cell = tableView.dequeueReusableCell(withIdentifier: ""messageCell"", for: indexPath) as? MessageCell else {
                       return UITableViewCell()
                   }
        cell.isOutgoing = self.appServerClient.currentUser.id == message.user.id
        cell.hasTail = self.messageHasTail(i: index)
        cell.hasDate = self.messageShowsDate(i: index)
        cell.message = message
      //  self.animateSendMessage()

        return cell

           }.disposed(by: disposeBag)

}
</code></pre>

<p>ConversationViewModel</p>

<pre><code>class ConversationViewModel {

    let appServerClient:AppServerClient
  //  var conversation: Conversation

    var conversationOb:  Observable&lt;[Message]&gt;{
        return cells.asObservable()
    }
    var text = BehaviorRelay&lt;String&gt;(value:"""")
    let submitButtonTapped = PublishSubject&lt;Void&gt;()

     let cells : BehaviorRelay&lt;[Message]&gt;
    let disposeBag = DisposeBag()

    init(_ appServerClient: AppServerClient) {

        cells = BehaviorRelay&lt;[Message]&gt;(value:[])

        self.appServerClient = appServerClient


        submitButtonTapped
        .subscribe(
            onNext: { [weak self] in
                self?.postMessage()
            }
        )
        .disposed(by: disposeBag)
    }

    func getMessages() {
        appServerClient
            .getMessages()
            .subscribe(
                onNext: { [weak self] messages in
                    //empty and error removed
                    self?.cells.accept(messages)
                }
            )
            .disposed(by: disposeBag)
    }

    func postMessage(){
        appServerClient.postMessage(text: text.value)
        getMessages()
    }

}
</code></pre>

<p>MessageCell</p>

<pre><code>class MessageCell: UITableViewCell {

    var hasTail = true {
        didSet {
            messageBubble.hasTail  = self.hasTail
            bottomConstraint.constant = (hasTail ? vertGapPad : 0)
        }
    }

    var hasDate = true {
        didSet {
            self.dateLabel.text = Date.dateMessageString(date: message.date)
            hideDateConstraint.isActive = !hasDate
            topConstraint.constant = (hasDate ? vertGapPad : 0)
        }
    }

    var message = Message() {
        didSet {
            messageLabel.text = message.text
        }
    }
    var isOutgoing = true {
        didSet {...
</code></pre>
","1822577","","6154972","","2019-12-11 06:27:56","2019-12-12 06:41:50","How should I access data about the array used to populate a tableview with RxSwift and MVVM","<swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"59280594","1","59322503","","2019-12-11 07:18:24","","0","50","<p>I don't know how to map custom types. I have two variables with custom types - </p>

<p>var viewModel: PurchaseList.Fetch.ViewModel?
var response: PurchaseList.Fetch.Response?</p>

<pre><code>    struct Response: Mappable {
        var shoppingList : [ShoppingList]?
    }

    struct ShoppingList: Mappable {
    var name: String?
    var offers: [Offers]?
    }

    struct Offers {
    var fullPrice: String?
    }
</code></pre>

<p>and</p>

<pre><code>struct ViewModel {
var name: String?
var offers: [ViewModelOffers]?
}

struct ViewModelOffers {
var fullPrice: String?
}
</code></pre>

<p>how I can create  <code>var viewModel: PurchaseList.Fetch.ViewModel?</code> from <code>var response: PurchaseList.Fetch.Response?</code> using RxSwift?</p>
","10170322","","10170322","","2019-12-11 07:28:08","2019-12-13 12:21:00","Different types RxSwift","<rx-swift>","1","3","","","","CC BY-SA 4.0"
"59292278","1","59322080","","2019-12-11 18:53:22","","1","86","<p>After reading a large number of posts on stack overflow, I am still very confused about the difference between Observable and Subject in Rx.</p>

<p>Basically, most people point out that the key difference between the two is that ""<strong>The Subject class inherits both Observable and Observer, in the sense that it is both an observer and an observable</strong>"", and it can be demonstrated by the following code snippet:</p>

<pre><code>var subject = new Rx.Subject();

var subscription = subject.subscribe(
function (x) { console.log('onNext: ' + x); },
function (e) { console.log('onError: ' + e.message); },
function () { console.log('onCompleted'); }
);

subject.onNext(1);
// =&gt; onNext: 1

subject.onNext(2);
// =&gt; onNext: 2

subject.onCompleted();
// =&gt; onCompleted
</code></pre>

<p>I understand that in the following part of the code, subject is being the role of an observable that can be subscribed to:</p>

<pre><code>var subscription = subject.subscribe(
function (x) { console.log('onNext: ' + x); },
function (e) { console.log('onError: ' + e.message); },
function () { console.log('onCompleted'); }
);
</code></pre>

<p>What really confuses me is this part:</p>

<pre><code>subject.onNext(1);
// =&gt; onNext: 1

subject.onNext(2);
// =&gt; onNext: 2

subject.onCompleted();
// =&gt; onCompleted
</code></pre>

<p>It looks like here it demonstrates that subject can be the role of an observer as well, but my understanding is that here subject is also feeding values/events (sending 1, 2 and complete event). <strong>So why is the subject considered the role of an observer in the code above</strong>?</p>

<p>Thanks a lot.</p>
","9712336","","9712336","","2019-12-11 19:48:01","2019-12-13 11:51:59","Confusion around understanding the difference between Observable and Subject in RX","<rxjs><rx-swift><reactivex><frp>","1","5","","","","CC BY-SA 4.0"
"59299556","1","","","2019-12-12 07:23:08","","0","99","<p>I have a pseudo RxSwift implementation of a repository pattern that supports offline and remote operations. I'm trying to migrate it from using our homegrown implementation of <code>Dynamic&lt;T&gt;</code> to using promises from the <code>PromiseKit</code> library; the code I'm trying to migrate looks like the following:</p>

<pre class=""lang-swift prettyprint-override""><code>class Repository {
   private var realmRepo: RealmRepo!
   private var httpRepo: HTTPRepo!
   private var offlineCache: OfflineCache!

   func complete(step: Entity, options: Options) -&gt; Dynamic&lt;Entity&gt; {
       let result = Dynamic&lt;Entity&gt;()

       realmRepo.complete(step: step, options: options).do(onNext: {[result] value in
            guard let realmStep = value else {
                return result.complete(with: Error.unknown(""realm result was `nil`""))
            }

            self.httpRepo.complete(step: realmStep, options: options).do(onNext: { value in

                result.complete(with: value)

            }).do(onError: { error in
                switch error {
                case HTTPRepo.Error.noNetworkConnection(let request):
                    try? self.offlineCache.add(object: createOfflineObject(request as! URLRequest))
                    result.complete(with: realmStep)
                default:
                    result.complete(with: error)
                }
            })
        }).do(onError: {[result] error in
            result.complete(with: error)
        })

        return result
}
</code></pre>

<p>The <code>Dynamic&lt;T&gt;</code> class looks like the following (implementation omitted): </p>

<pre class=""lang-swift prettyprint-override""><code>class Dynamic&lt;T&gt; {
    func `do`(onNext: (T?) -&gt; Void) -&gt; Dynamic&lt;T&gt; // returns `self`
    func `do`(onError: (Error) -&gt; Void) -&gt; Dynamic&lt;T&gt; // returns `self`
    func complete(with: Error)
    func complete(with: T?)
}
</code></pre>

<p>I'm trying to rewrite the return values for the repository from <code>Dynamic&lt;Entity&gt;</code> to <code>Promise&lt;Entity&gt;</code>, using the <a href=""https://github.com/mxcl/PromiseKit"" rel=""nofollow noreferrer"">PromiseKit</a> library, I'm not sure how to replicate the following chain of events using promises:</p>

<ol>
<li>Attempt the Realm call, if it fails send an error to the returned dynamic object (or fail the promise)</li>
<li>If the <code>RealmRepo.complete</code> call succeeded, then attempt the <code>HTTPRepo.complete</code> call.</li>
<li>If the <code>HTTPRepo.complete</code> call succeeds then emit a ""next"" value to the dynamic (promise succeeds)</li>
<li>If the <code>HTTPRepo.complete</code> call fails then catch the error which will have the failure reason and if it was a lack of network connection then perform another call to the <code>OfflineCache.add</code> method and resolve the Dynamic value with the result from the <code>RealmRepo.complete</code> call.</li>
</ol>

<p>So far I've managed the following:</p>

<pre><code>import PromiseKit 

// ... other code ...

class Repository {
   // ... repository fields ...

   func complete(step: Entity, options: Options) -&gt; Promise&lt;Entity&gt; {
      return self.realmRepo.complete(step: step, options).then { 
          return self.httpRepo.complete(step: $0, options: options)
      }.catch { error in 
         switch error {
         case HTTPRepo.Error.noNetworkConnection(let request):
             try? self.offlineCache.add(object: createOfflineObject(request as! URLRequest))
         default:
             result.complete(with: error)
         }
      }
   }
}
</code></pre>

<p>Such code gives me a compile error in the <code>catch</code> block, I'm not even sure of how I'd handle or recover from the error that <code>httpRepo</code> would return if no connection is present.</p>

<p>Any help is really appreciated!</p>
","496351","","","","","2019-12-12 07:23:08","How could I rewrite this using PromiseKit?","<ios><realm><rx-swift><swift4.2><promisekit>","0","2","","","","CC BY-SA 4.0"
"59312605","1","","","2019-12-12 20:59:03","","2","330","<p>I have two sequences and I'd like to combine them so that any results coming into the second sequence would be cumulatively combined with the latest result from the first sequence.</p>

<pre><code>A---------------B----------------------C------------- ...
-------1-2-----------3-------------------------------- ...
</code></pre>

<p>So that the result would be:</p>

<pre><code>A-----A+1--A+1+2---B----B+3--------------C-------------
</code></pre>

<p>How might I do that in Rx? (I'm using RxSwift)</p>
","2719866","","2398593","","2019-12-13 09:55:45","2019-12-13 09:55:45","How to combine two sequences cumulatively in RxSwift?","<swift><reactive-programming><rx-swift>","2","3","1","","","CC BY-SA 4.0"
"59324736","1","59326415","","2019-12-13 14:41:08","","1","110","<p>I've just started learning <code>RxSwift</code>. I've added a <code>UIButton</code> with an observable in and a suscribe method that should trigger everytime data changes, but I don't get it to work. What am I missing?</p>

<pre><code>@IBAction func buttonAction(_ sender: Any) {
    publishableSubject.onNext(""GURKA"")
}

override func viewDidLoad() {
    super.viewDidLoad()

    let bag = DisposeBag()
    _ = publishableSubject.subscribe(onNext: {
        print($0)
    }).disposed(by: bag)
}
</code></pre>
","8591381","","","","","2019-12-14 12:55:28","How does RxSwift work if you click a UIButton?","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"59337420","1","59345832","","2019-12-14 17:18:29","","2","557","<p>I have the following code in RxSwift 4.0-based project:</p>

<pre><code>private var _myRelay = PublishRelay&lt;MyData&gt;()

var myRelay: Observable&lt;MyData&gt; {

    return _myRelay.asObservable()
}
</code></pre>

<p>Now I need to keep the last value (if any) in <code>_myRelay</code>, so I decided to convert it to <code>BehaviorRelay</code>:</p>

<pre><code>private var _myRelay = BehaviorRelay&lt;MyData?&gt;(value: nil)
</code></pre>

<p>I want to keep public interface intact</p>

<pre><code>var myRelay: Observable&lt;MyData&gt;
</code></pre>

<p>I mean I do not want to convert it to</p>

<pre><code>var myRelay: Observable&lt;MyData?&gt;
</code></pre>

<p>The idea is not to ""publish"" initial value == <code>nil</code> to subscribers of <code>myRelay</code>, and start publishing only after some data appears. How can I do it? I am completely beginner in Rx, but I am sure there should be some elegant solution.</p>
","674548","","674548","","2019-12-14 17:52:46","2019-12-15 16:30:35","Convert PublishRelay to BehaviorRelay of optional Element","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"59385820","1","","","2019-12-18 05:07:34","","0","165","<p>With map in RxSwift, for every character inserted in search bar, I call an API to get json and parse data to table view. But since I changed every character inserted into a constant API instead just for demo purpose, I've got this error 
fail at line: <code>let model: T = try JSONDecoder().decode(T.self, from: data ?? Data())</code></p>

<p>please help me, thank you very much</p>

<blockquote>
  <p>Binding error: typeMismatch(Swift.Array, Swift.DecodingError.Context(codingPath: [], debugDescription: ""Expected to decode Array but found a dictionary instead."", underlyingError: nil))</p>
</blockquote>

<p><a href=""https://i.stack.imgur.com/hPU1W.png"" rel=""nofollow noreferrer"">This's my codable struct for mapping with json given below</a></p>

<pre><code>struct Result: Codable {
let shopName: String
let shopImage: String
let maintenanceDate: String
let maintenanceContent: String
let shopDetailUrl: String

private enum CodingKeys: String, CodingKey {
    case shopName = ""shop_name""
    case shopImage = ""shop_image""
    case maintenanceDate = ""maintenance_date""
    case maintenanceContent = ""maintenance_content""
    case shopDetailUrl = ""shop_detail_url""
}
</code></pre>

<p>}</p>

<pre><code>struct ShopModel: Codable {
let status: Bool
let code: Int
let message: String?
let result: Result

private enum CodingKeys: String, CodingKey {
    case status
    case code
    case message
    case result = ""result""
}
</code></pre>

<p>}</p>

<p><a href=""https://i.stack.imgur.com/V5coE.png"" rel=""nofollow noreferrer"">json data</a></p>

<pre><code>{
""status"": true,
""code"": 200,
""message"": null,
""result"": {
    ""shop_name"": ""AAAAAA"",
    ""shop_image"": ""https://......"",
    ""maintenance_date"": """",
    ""maintenance_content"": """",
    ""shop_detail_url"": ""/store/detail/111113/42""
}
</code></pre>

<p>}</p>

<p><a href=""https://i.stack.imgur.com/bzXXn.png"" rel=""nofollow noreferrer"">This is where events triggered to call api everytime a character inserted in searchbar</a></p>

<pre><code>    private func configureReactiveBinding() {
    searchController.searchBar.rx.text.asObservable()
        .map { _ in CarRequest(token: ""6aa86866d95414a9e469f4323b1da139f96d22d8"") }
        .flatMap { request -&gt; Observable&lt;[ShopModel]&gt; in
            return self.apiClient.send(apiRequest: request)
        }
        .bind(to: tableView.rx.items(cellIdentifier: cellIdentifier)) { index, model, cell in
            cell.textLabel?.text = model.result.shopImage
            cell.detailTextLabel?.text = model.result.shopName
            cell.textLabel?.adjustsFontSizeToFitWidth = true
        }
        .disposed(by: disposeBag)
}
</code></pre>

<p>}</p>

<p><a href=""https://i.stack.imgur.com/Pgt3K.png"" rel=""nofollow noreferrer"">send api request, and decode json</a></p>

<pre><code>    private let baseURL = URL(string: ""https://stg.api.link-collabo.jp/api/user/myshop.json"")!

func send&lt;T: Codable&gt;(apiRequest: APIRequest) -&gt; Observable&lt;T&gt; {
    return Observable&lt;T&gt;.create { [unowned self] observer in
        let request = apiRequest.request(with: self.baseURL)
        let task = URLSession.shared.dataTask(with: request) { (data, response, error) in
            do {
                let model: T = try JSONDecoder().decode(T.self, from: data ?? Data())
                print(model)
                observer.onNext(model)
            } catch let error {

                observer.onError(error)
            }
            observer.onCompleted()
        }
        task.resume()

        return Disposables.create {
            task.cancel()
        }
    }
}
</code></pre>
","12556190","","12556190","","2019-12-24 05:03:54","2019-12-24 05:03:54","typeMismatch: generic unknown type jsondecoder / codable / RxSwift","<ios><swift><rx-swift><codable><jsondecoder>","0","3","","","","CC BY-SA 4.0"
"59388628","1","","","2019-12-18 09:06:05","","-1","393","<pre><code>var readIndicatorNeedsDisplay: Driver&lt;Bool&gt; = .empty()
public func bindcellEvents(readNotificationID: String) {
        if let unreadNotificationIDs = UserDefaults.main?.unreadNotificationIDs, unreadNotificationIDs.contains(readNotificationID) {
            readIndicatorNeedsDisplay = true

        } else {
            UserDefaults.main?.unreadNotificationIDs.append(readNotificationID)
            readIndicatorNeedsDisplay = false

// Cannot assign value of type 'Bool' to type 'Driver&lt;Bool&gt;' (aka 'SharedSequence&lt;DriverSharingStrategy, Bool&gt;')

        }
    }
</code></pre>

<p>when i assign bool to driver Giving error: Cannot assign value of type 'Bool' to type 'Driver' (aka 'SharedSequence')</p>
","12302627","","12302627","","2019-12-18 11:00:35","2019-12-18 16:40:42","How to set a bool value to drive<Bool>","<rx-swift><rx-cocoa>","1","1","0","","","CC BY-SA 4.0"
"59407221","1","","","2019-12-19 09:57:52","","2","84","<p>I wanted to create takeWhileInclusive operator in RxSwift by composing new sink and producer similar to the way the original takeUntil is created. But I cannot import Sink and Producer classes. What is the proper way of this?</p>
","6641096","","","","","2019-12-19 09:57:52","How to create custom sink and producer in RxSwift?","<swift><rx-swift>","0","0","","","","CC BY-SA 4.0"
"59410275","1","","","2019-12-19 12:58:04","","0","1594","<p>I'm trying to learn <code>RxSwift</code> and currently I'm trying to use it in relation to <code>AlamoFire</code> and <code>SwiftyJSON</code>, that is, to observe when <code>JSON</code> has been downloaded so that I can <code>parse</code> it. I have working code for getting <code>JSON</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>guard let myURL = URL(string: ""https://api.myjson.com/bins/e5gjk"") else { return }

var myArray = [People]()
let myObserver = Observable.from(myArray)

Alamofire.request(myURL, method: .get)
    .validate()
    .responseJSON{ response in
        guard response.result.isSuccess else {
            print(""Error"")
            return
        }

        let json = JSON(response.result.value)

        for i in 0...json[""employees""].count {
            let people = People()
            people.name = json[""employees""][i][""firstName""].stringValue
            people.job = json[""employees""][i][""job""].stringValue

            myArray.append(people)
        }

        for i in myArray {
            print(i.name)
            print(i.job)
        }
}

myObserver.subscribe(onNext: {
    print($0)
}, onError: { error in
    print(error)
}, onCompleted: {
    print(""completed"")
}, onDisposed: {
    print(""disposed"")
}).disposed(by: DisposeBag())
</code></pre>

<p>As you can see, I have parsed the <code>JSON</code> as well. I guess that the point of <code>RX</code> here would be to use the data in <code>onNext</code> once it has been parsed, correct? Or have I misunderstood its purpose? </p>

<p>Anyway, I have an observer on <code>myArray</code>: <code>let myObserver = Observable.from(myArray)</code>. In my head, <code>subscribe</code> <code>onNext</code> should be triggered as soon as myArray gets data, but that's not happening. What happens is that <code>completed</code> is run immediately, then the <code>JSON</code> networking and parsing takes place. The subscription is not triggered when <code>myArray</code> gets new data. Have I missed something or misunderstood <code>RX</code>'s purpose?</p>

<p><strong><em>EDIT</em></strong>
Or wait, should the whole <code>JSON</code> handling and parsing be in the <code>onNext</code>? </p>
","12297975","","5130481","","2019-12-20 08:23:18","2019-12-30 11:01:59","How do I use RxSwift with AlamoFire and SwiftyJSON?","<swift><alamofire><rx-swift><swifty-json>","1","0","","","","CC BY-SA 4.0"
"59415161","1","59415264","","2019-12-19 18:30:23","","0","90","<p>For context, I am using swift &amp; MVVM architecture to manage a list of data, and a table view that displays it. Reactive patterns (RxSwift or Combine) work well for letting me reload my entire table view when the view model's list data changes. </p>

<p>ViewModel (using RxSwift):</p>

<pre><code>var tableData = BehaviorRelay&lt;[String]&gt;(value: [""First Item"", ""Second Item""])
</code></pre>

<p>ViewController:</p>

<pre><code>var tableView = UITableView()
var disposeBag = DisposeBag()
var viewModel = ViewModel()

init() {
    ...
    viewModel.tableData.subscribe(onNext: { _ in 
       self.tableView.reloadData()
    }).disposed(by: disposeBag)
}
</code></pre>

<p>But what if only one item has been inserted or deleted from <code>tableData</code>? In this case, I don't want to call <code>tableView.reloadData()</code>, instead I'd like to use <code>tableView.insertRows(at: &lt;[IndexPath]&gt;, with: &lt;UITableView.RowAnimation&gt;)</code> or <code>tableView.deleteRows(at: &lt;[IndexPath]&gt;, with: &lt;UITableView.RowAnimation&gt;)</code>. In order to do this, I need to be able to subscribe to the index paths that have been inserted or removed, instead of the list data as a whole. Does any one know what the most efficient way to do this? </p>
","3707524","","","","","2019-12-19 18:39:32","How to use reactive programming to subscribe to single-item changes (insertions or deletions) in an array of data?","<ios><swift><reactive-programming><rx-swift><combine>","1","0","","","","CC BY-SA 4.0"
"59423384","1","59423963","","2019-12-20 10:06:35","","2","128","<p>I have <code>parsed</code> <code>JSON</code> data from an <code>URL</code> and the <code>subscriber</code> on the <code>array</code> trigger accordingly as the <code>array</code> is populated. But the data that I get from <code>onNext</code> look like this: <code>MyProject.People</code>. How do I get the actual values? Here's my code:</p>

<pre><code>guard let myURL = URL(string: ""https://api.myjson.com/bins/e5gjk"") else { return }
var myArray: Variable&lt;[People]&gt; = Variable([])

myArray.asObservable().subscribe(onNext: { arrayData in
    print(""TRIGGERED"", arrayData)

    }).disposed(by: bag)

Alamofire.request(myURL, method: .get)
    .validate()
    .responseJSON{ response in

    guard response.result.isSuccess else {
       print(""Error"")
       return
    }

    let json = JSON(response.result.value)

    for i in 0...json[""employees""].count {
        let people = People()
        people.name = json[""employees""][i][""firstName""].stringValue
         people.job = json[""employees""][i][""job""].stringValue

         myArray.value.append(people)
    }

    for i in myArray.value {
        print(i.name)
        print(i.job)
    }
}
</code></pre>

<p>So, <code>arrayData</code> returns <code>MyProject.People</code> but should give strings. I have tried <code>arrayData.name</code> and <code>arrayData.value.name</code> but it doesn't show anything. <code>People</code> look like this:</p>

<pre><code>class People {
    var name = """"
    var job = """"
}
</code></pre>
","12297975","","","","","2019-12-20 15:23:41","How do I get the correct value from onNext in RxSwift?","<json><swift><alamofire><rx-swift><swifty-json>","2","2","","","","CC BY-SA 4.0"
"59425271","1","","","2019-12-20 12:28:35","","0","1266","<p>I need to update a SwiftUI List after making a network request. For requests, I use Moya approach with combination of triggers(Input&amp;Output - ""Kickstarter"").
I cant use Combine framework due to the structure of the project, while they have a lot of helpful advises(not sure about my case).</p>

<p>Simple ContactList:</p>

<pre><code>struct ContactList: View {
    var viewModel: UserViewModel
    var body: some View {
        NavigationView {
            List(viewModel.users) { contact in
                NavigationLink(destination: ContactDetail(user: contact)) {
                    ContactRow(user: contact)
                }
            }
            .navigationBarTitle(Text(""Team Members""))
        }
    }
}
</code></pre>

<p>Then ViewModel</p>

<pre><code>class UserViewModel {
    let disposeBag = DisposeBag()
    var users: [TeamMember] = []

    init(users: [TeamMember] = []) {
        let networkModel = UserNetworkModel()
        networkModel.output.teamMembers.subscribe { (event) in
            self.users.append(contentsOf: event.element.orEmpty)
        }.disposed(by: disposeBag)

        networkModel.output.error.subscribe(onNext: { error in
            print(error.localizedDescription)
        }).disposed(by: disposeBag)
        networkModel.input.loadTrigger.onNext(Void())
        self.users = users
    }
}
</code></pre>

<p>And NetworkModel</p>

<pre><code>class UserNetworkModel {
    let disposeBag = DisposeBag()
    let input: Input
    let output: Output

    struct Input {
        let loadTrigger: AnyObserver&lt;Void&gt;
        let searchTrigger: AnyObserver&lt;String&gt;
    }

    struct Output {
        let teamMembers: Observable&lt;[TeamMember]&gt;
        let error: Observable&lt;Error&gt;
    }


    internal let loadSubject = PublishSubject&lt;Void&gt;()
    internal let searchSubject = BehaviorSubject&lt;String&gt;(value: """")

    internal let errorSubject = PublishSubject&lt;Error&gt;()
    internal let teamMembersSubject = BehaviorSubject&lt;[TeamMember]&gt;(value: [])

    init() {
        let service = MoyaProvider&lt;TeamTarget&gt;()
        self.input = Input(loadTrigger: loadSubject.asObserver(), searchTrigger: searchSubject.asObserver())
        self.output = Output(teamMembers: teamMembersSubject.asObservable(), error: errorSubject.asObservable())

        let result = loadSubject.flatMapLatest { _ -&gt; Observable&lt;[TeamMember]&gt; in
            service.rx.request(.get).debug().mapArray(TeamMember.self).asObservable()
        }.share(replay: 1)

        Observable.combineLatest(result, searchSubject).map { (arg) in
            let (members, filter) = arg
            if filter.isEmpty {
                return members
            } else {
                let searchText = try! self.searchSubject.value()
                return members.filter({
                    return [$0.firstName, $0.lastName]
                        .compactMap({ $0 })
                        .first(where: { $0.hasPrefix(searchText) }) != nil
                })
            }
        }.bind(to: teamMembersSubject).disposed(by: disposeBag)

        result.subscribe(onError: { error in
            self.errorSubject.onNext(error)
        }).disposed(by: self.disposeBag)

    }
}
</code></pre>

<p>Is it possible to update users array in this way? Or only Combine can do it for me easily?
Thanks for your time.</p>
","5942995","","","","","2019-12-20 15:14:44","Update SwiftUI List after network request using RxSwift","<rx-swift><moya><swiftui-list>","1","0","","","","CC BY-SA 4.0"
"59442736","1","","","2019-12-22 08:35:55","","1","158","<p>How to initialize <code>BehaviorRelay</code> inside of protocol</p>

<pre class=""lang-swift prettyprint-override""><code>protocol ArticlePresentable: Presentable {
  var listener: ArticlePresentableListener? { get set }

  var searchResult: BehaviorRelay&lt;[NewsModel]&gt; =
    BehaviorRelay(value: []) { get set }
}
</code></pre>
","10936207","","1033581","","2019-12-22 15:08:18","2019-12-22 16:29:50","How to initialize BehaviorRelay inside of protocol","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"59455176","1","","","2019-12-23 12:12:55","","0","245","<p>Whenever I run this code the init() of the VCModel gets called but Swinject is not Injecting the VCModel instance to my ViewController. Can Someone Please tell me what am I doing wrong?
Error I get is: </p>

<blockquote>
  <p>Unexpectedly Found nil while unwrapping an optional value in
  ViewController viewModel.cellModels</p>
</blockquote>

<p><strong>AppDelegate</strong></p>

<pre><code>func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
    // Override point for customization after application launch.

    container = Container() { con in
        con.register(VCModeling.self) { _ in
            VCModel()
        }

        con.storyboardInitCompleted(ViewController.self) { r, c in
            c.viewModel = r.resolve(VCModeling.self)!
        }
    }

    let window = UIWindow(frame: UIScreen.main.bounds)
    window.backgroundColor = UIColor.white
    window.makeKeyAndVisible()
    self.window = window
    let bundle = Bundle(for: ViewController.self)
    let storyboard = SwinjectStoryboard.create(name: ""Main"", bundle: bundle, container: container)
    window.rootViewController = storyboard.instantiateInitialViewController()

    return true
}
</code></pre>

<p><strong>ViewController</strong></p>

<pre><code>private let disposeBag = DisposeBag()
var viewModel: VCModeling!

override func viewDidLoad() {
    super.viewDidLoad()
    // Do any additional setup after loading the view.
    viewModel.cellModels
     .bind(to: tableView.rx.items(cellIdentifier: ""myCell"", cellType: MyCellClass.self)) {
         i, cellModel, cell in
       cell.viewModel = cellModel
     }.disposed(by: disposeBag)
}
</code></pre>
","10591091","","4377671","","2019-12-23 12:20:57","2019-12-25 06:51:59","What am I Doing wrong in Swinject?","<ios><swift><rx-swift><swinject>","2","0","","","","CC BY-SA 4.0"
"59467791","1","59468477","","2019-12-24 11:01:00","","0","651","<p>A ViewModel has an input (an observer) which is bound to <code>tap</code> event of <code>UIButton</code> in <code>UIViewController</code>. This observer is of type <code>AnyObserver&lt;Void&gt;</code>.</p>

<p>In my unit test, this is what I'm expecting:</p>

<pre><code>let correctValues: [Recorded&lt;Event&lt;Void&gt;&gt;] = Recorded.events(
       .next(0, ()),
       .completed(0)
   )
</code></pre>

<p>My test observer definition is:</p>

<pre><code>private var voidEventsObserver: TestableObserver&lt;Void&gt;!

let scheduler = TestScheduler(initialClock: 0)
voidEventsObserver = scheduler.createObserver(Void.self)
</code></pre>

<p>Assert statement:</p>

<pre><code>XCTAssertEqual(voidEventsObserver.events, correctValues)
</code></pre>

<p>I'm getting following error:</p>

<blockquote>
  <p>Expression type '()' is ambiguous without more context</p>
</blockquote>

<p>In Rx, <code>Void</code> events are normal and to properly test ViewModel, one needs to compare them. e.g. <code>.next(0, ())</code>, <code>.completed(0)</code> etc. <code>Void</code> is not <code>Equatable</code> and it doesn't make sense to make it <code>Equatable</code>. However, I need to assert if the event is <code>.next</code> or <code>.error</code> or <code>.completed</code>. How do I assert that part?</p>
","10384998","","","","","2019-12-24 11:56:05","RxTest - How to compare Event<Void> as Void is not Equatable","<swift><rx-swift><rxtest>","1","0","","","","CC BY-SA 4.0"
"59495784","1","","","2019-12-27 03:52:33","","0","79","<pre><code>// View controller call

viewModel.bindNotificationReadEvents(readNotificationID: readNotificationIDPublisher.asDriver(onErrorDriveWith: .empty()))
   viewModel.reloadDataSourceForNotificationReadEvent.drive(reloadDataSourceForNotificationReadEventBinder).disposed(by: rx.disposeBag)

// View model

var reloadDataSourceForNotificationReadEvent: Driver&lt;[NotificationItem]&gt; = .empty()
fileprivate let dataSourceRelay = BehaviorRelay&lt;[NotificationItem]&gt;(value: [])

    public func bindNotificationReadEvents(readNotificationID: Driver&lt;String&gt;) {
            readNotificationID.drive(onNext: { [weak self] notificationID in
                // read notification IDs on User Defaults
                UserDefaults.main?.unreadNotificationIDs.append(notificationID)
                // Update data source relay
                self?.reloadDataSourceForNotificationReadEvent = readNotificationID.withLatestFrom(self?.dataSourceRelay.asDriver() ?? .empty())
            }).disposed(by: rx.disposeBag)
        }
</code></pre>

<p>when this method is called from the viewcontroller in the viewmodel it just skips both the lines and nothing executes when i checked it while debugging neither is the userdefaults updated nor is data source relay can someone please help me out.</p>
","12302627","","405865","","2019-12-27 08:43:34","2019-12-27 08:43:34","Not understanding how to implement .drive(onNext: rxcocoa","<rx-swift><rx-cocoa>","0","2","","","","CC BY-SA 4.0"
"59533373","1","59533822","","2019-12-30 15:45:34","","0","36","<p>I have two subscriptions: <code>a</code> and <code>b</code>. As soon as <code>b</code> ""fires"", I need to cancel (unsubscribe) <code>a</code>.</p>

<p>The subscriptions are defined in different parts of the code and currently it looks like this:</p>

<pre><code>private let _bag = DisposeBag()

func fA() {
    // ....

    observableA.bind(to: mapView.rx.animate).disposed(by: _bag)

    // ....
}

func fB() {
    // ....

    observableB.subscribe(onNext: { [unowned self] data in
        self.process(data)
        // I need to unsubscribe from observableA now 
    }).disposed(by: _bag)

    // ....
}
</code></pre>

<p>What would be a best way to accomplish it? I can think of two ways:</p>

<p>1) Use special bag:</p>

<pre><code>private let _bag = DisposeBag()
private var _ABAG = DisposeBag()

func fA() {
    // ....

    observableA.bind(to: mapView.rx.animate).disposed(by: _ABAG)

    // ....
}

func fB() {
    // ....

    observableB.subscribe(onNext: { [unowned self] data in
        self.process(data)
        self._ABAG = DisposeBag()
    }).disposed(by: _bag)

    // ....
}
</code></pre>

<p>2) Manually unsubscribe:</p>

<pre><code>private let _bag = DisposeBag()
private var _disposableA: Disposable?

func fA() {
    // ....

    _disposableA = observableA.bind(to: mapView.rx.animate)

    // ....
}

func fB() {
    // ....

    observableB.subscribe(onNext: { [unowned self] data in
        self.process(data)
        self._disposableA?.dispose()
    }).disposed(by: _bag)

    // ....
}
</code></pre>

<p>Which way is better in terms of robustness, elegancy, etc.? Or is there better way?</p>
","674548","","1364007","","2019-12-31 00:12:58","2019-12-31 00:12:58","Best practice to cancel subscription as soon as another subscription fires","<ios><swift><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"59573018","1","","","2020-01-03 03:59:29","","0","209","<p>what I need to do is, I have a lot network requests, and at a time backend will return a token expire error, all the requests will receive this error and they all should be hang up, at this time I need send a refresh token request. after refresh token request finish, all paused network request should relaunch with the new token.</p>

<p>now I use <code>retryWhen</code> operator to handle token expire error, and hang up network. I use <code>share replay</code> operator to send refresh token request only once.</p>

<pre><code>networkReqeust.retryWhen({ (error: Observable&lt;TokenError&gt;)  in

                           error.flatMap{ error -&gt; Observable&lt;()&gt; in
                               switch error {
                               case .TokenExpired:

                                return RefreshTokenObservable.share(replay: 1).flatMap({ (result) -&gt; Observable&lt;()&gt; in
                                       switch result {

                                       case .RefreshSuccess:

                                           return Observable.empty()
                                       case .RefreshFailure:      
                                           throw error
                                       }
                                   })
                               }
                           }
                       })



let RefreshTokenObservable: Observable&lt;TokenRefresh&gt; = {

    let config = URLSessionConfiguration.default
    let session = URLSession.init(configuration: config)
    let refreshTokenrequest = URLRequest(url: url!)

    return  session.rx.response(request: refreshTokenrequest).share(replay: 1).observeOn(MainScheduler.instance).flatMapLatest{ (data, response) -&gt; Observable&lt;TokenRefresh&gt; in

        let responseModel = ResponseModel(data:response)
            if responseModel.status {
                return Observable.just(TokenRefresh.RefreshSuccess)
            } else {
                return Observable.just(TokenRefresh.RefreshFailure)
            }
        }.observeOn(MainScheduler.instance)
}()

</code></pre>

<p>now refresh token request still launch many times, where I did wrong. why <code>share replay</code>operator not work</p>
","5814921","","","","","2020-04-07 09:53:54","Rxswift operator share replay can not work?","<ios><swift><system.reactive><rx-swift>","0","3","","","","CC BY-SA 4.0"
"59575636","1","59578339","","2020-01-03 08:59:16","","0","578","<p>Trying to grasp <code>RxSwift</code> and get stuck on a few things.</p>

<pre><code>var observedData = BehaviorSubject.from([2, 3, 4, 5, 6])
    .map({$0*3}).subscribe(onNext: {
        print(""HELLO"", $0)
    })
</code></pre>

<p>How do I <code>append</code> an extra value to the array, so that the <code>subscription</code> is triggered again?</p>

<p>I tried <code>observedData.onNext</code> and <code>observedData.accept</code> but they don't work.</p>

<p>I also would like to know the difference between </p>

<pre><code>var observedData = BehaviorSubject.from([2, 3, 4, 5, 6])
</code></pre>

<p>and</p>

<pre><code>var observedData2 = BehaviorSubject&lt;[Int]&gt;(value: [2, 3, 4, 5, 6])
</code></pre>

<p>I first assumed it was different ways of writing the same thing, but I can't use <code>.map</code> on <code>observedData2</code></p>
","12297975","","","","","2020-01-05 13:03:35","How do I append values fo an observed array in RxSwift","<arrays><swift><rx-swift><behaviorsubject>","2","1","","","","CC BY-SA 4.0"
"59577276","1","","","2020-01-03 10:53:28","","1","227","<p>If I have </p>

<pre><code>let myValue = BehaviorSubject(value: 30)

myValue.subscribe(onNext: {
    print($0)
}, onError: { error in
    print(error)
}, onCompleted: {
    print(""Completed"")
}, onDisposed: {
    print(""Disposed"")
    }).disposed(by: bag)

myValue.onNext(33)
myValue.onNext(200)
</code></pre>

<p>I can add more values with <code>onNext</code> as seen above. But if I instead use </p>

<pre><code>let myValue2 = BehaviorSubject.of(1, 2, 3, 4, 5)
</code></pre>

<p>then then <code>onNext</code> doesn't work anymore. Why? Is it because <code>onNext</code> only works on <code>observables</code> with single values?</p>
","12297975","","","","","2020-01-05 12:49:56","When can I use onNext in RxSwift","<swift><rx-swift><behaviorsubject>","1","3","","","","CC BY-SA 4.0"
"59607005","1","59607376","","2020-01-06 05:18:41","","-2","219","<p>What is the difference between <code>do</code> operator and <code>map</code> operator?
<strong>It seems the same. I'm learning RxSwift.</strong></p>

<p><strong>Please check the marble diagram of do and map.</strong></p>

<p>do : <a href=""http://reactivex.io/documentation/operators/do.html"" rel=""nofollow noreferrer"">http://reactivex.io/documentation/operators/do.html</a></p>

<p>map : <a href=""http://reactivex.io/documentation/operators/map.html"" rel=""nofollow noreferrer"">http://reactivex.io/documentation/operators/map.html</a></p>
","3688956","","10584330","","2020-01-06 05:35:24","2020-01-06 06:03:39","What is the difference between Do and Map?","<ios><swift><reactive-programming><rx-swift><reactive>","2","0","","","","CC BY-SA 4.0"
"59646910","1","59656436","","2020-01-08 13:27:00","","1","130","<p>Playing around with <code>Rx Swift</code> I have run into a situation where my <code>subscription</code> doesn't trigger. </p>

<p>I have two <code>viewControllers</code>. The first has a <code>label</code> that the <code>subscriber</code> should update, like this:</p>

<pre><code>func listen() {
   print(""In func"")
   let sec = storyboard?.instantiateViewController(withIdentifier: ""secondvc"") as! SecondViewController

   sec.myRx.subscribe(onNext: {
    print(""SUBSCRIBED"", $0)
       self.rxLabel.text = $0
   })
}

</code></pre>

<p>If you go to the sencond <code>viewController</code> there is a button that sets off an <code>onNext</code> event. Like this:</p>

<pre><code>    var myRx = PublishSubject&lt;String&gt;()

    @IBAction func myButton(_ sender: Any) {
        myRx.asObserver().onNext(""Hello"")
    }
</code></pre>

<p>So, in my head, when <code>myButton</code> is pressed in the second <code>viewController</code> the <code>label</code> in the first <code>viewController</code> should update when going back to that <code>viewController</code>. But from what I can tell, the function is triggered, but the <code>subscription</code> isn't triggered at all. </p>
","8591381","","8591381","","2020-01-08 14:27:45","2020-01-09 02:32:40","Why isn't my rx subscription triggered on my onNext?","<ios><swift><rx-swift><publishsubject>","1","3","","","","CC BY-SA 4.0"
"59649779","1","59656239","","2020-01-08 16:10:26","","0","253","<p>I'm trying to figure out how to achieve the following result:</p>

<pre><code>A: -a--b--c-d--e-f-|
B: --1-2-3-|
=: --a-b--c-d--e-f-|
 : --1-2--3-1--2-3
</code></pre>

<p>where A, B are the input streams and '=' represents the output stream (as a tuple A,B)</p>

<p>Plus the vice-versa:</p>

<pre><code>A: -a-b-|
B: --1--2-3-4--5--6-7-|
=: --a--b-a-b--a--b-a-|
 : --1--2-3-4--5--6-7
</code></pre>

<p>So in plain text - I'm looking for something that behaves like a zip operator but with ability of 'replaying' the shorter of sequences to match the longer one.</p>

<p>Any idea how to tackle this problem?</p>

<hr>

<h1>Solution 1</h1>

<p>Solution provided by @<a href=""https://stackoverflow.com/users/506441/daniel-t"">DanielT</a> (with some problems)</p>

<pre><code>extension ObservableType {
    public static func zipRepeat&lt;A, B&gt;(_ a: Observable&lt;A&gt;, _ b: Observable&lt;B&gt;) -&gt; Observable&lt;(A, B)&gt; {
        return Observable.create { observer in
            var aa: [A] = []
            var aComplete = false
            var bb: [B] = []
            var bComplete = false
            let lock = NSRecursiveLock()
            let disposableA = a.subscribe { event in
                lock.lock(); defer { lock.unlock() }
                switch event {
                case .next(let ae):
                    aa.append(ae)
                    if bComplete {
                        observer.onNext((ae, bb[(aa.count - 1) % bb.count]))
                    }
                    else if bb.count == aa.count {
                        observer.onNext((aa.last!, bb.last!))
                    }
                case .error(let error):
                    observer.onError(error)
                case .completed:
                    aComplete = true
                    if bComplete {
                        observer.onCompleted()
                    }
                }
            }
            let disposableB = b.subscribe { event in
                lock.lock(); defer { lock.unlock() }
                switch event {
                case .next(let be):
                    bb.append(be)
                    if aComplete {
                        observer.onNext((aa[(bb.count - 1) % aa.count], be))
                    }
                    else if bb.count == aa.count {
                        observer.onNext((aa.last!, bb.last!))
                    }
                case .error(let error):
                    observer.onError(error)
                case .completed:
                    bComplete = true
                    if aComplete {
                        observer.onCompleted()
                    }
                }
            }
            return Disposables.create(disposableA, disposableB)
        }
    }
}
</code></pre>

<h1>Solution 2</h1>

<p>My own solution inspired by answers below - own operator (HT @DanielT) but with more imperative approach (HT @iamtimmo):</p>

<pre><code>extension ObservableType {
    public static func zipRepeatCollected&lt;A, B&gt;(_ a: Observable&lt;A&gt;, _ b: Observable&lt;B&gt;) -&gt; Observable&lt;(A?, B?)&gt; {
        return Observable.create { observer in

            var bufferA: [A] = []
            let aComplete = PublishSubject&lt;Bool&gt;()
            aComplete.onNext(false);

            var bufferB: [B] = []
            let bComplete = PublishSubject&lt;Bool&gt;()
            bComplete.onNext(false);

            let disposableA = a.subscribe { event in
                switch event {
                case .next(let valueA):
                    bufferA.append(valueA)
                case .error(let error):
                    observer.onError(error)
                case .completed:
                    aComplete.onNext(true)
                    aComplete.onCompleted()
                }
            }

            let disposableB = b.subscribe { event in
                switch event {
                case .next(let value):
                    bufferB.append(value)
                case .error(let error):
                    observer.onError(error)
                case .completed:
                    bComplete.onNext(true)
                    bComplete.onCompleted()
                }
            }

            let disposableZip = Observable.zip(aComplete, bComplete)
                .filter { $0 == $1 &amp;&amp; $0 == true }
                .subscribe { event in
                    switch event {
                    case .next(_, _):
                        var zippedList = Array&lt;(A?, B?)&gt;()

                        let lengthA = bufferA.count
                        let lengthB = bufferB.count

                        if lengthA &gt; 0 &amp;&amp; lengthB &gt; 0 {
                            for i in 0 ..&lt; max(lengthA, lengthB) {
                                let aVal = bufferA[i % lengthA]
                                let bVal = bufferB[i % lengthB]
                                zippedList.append((aVal, bVal))
                            }
                        } else if lengthA == 0 {
                            zippedList = bufferB.map { (nil, $0) }
                        } else {
                            zippedList = bufferA.map { ($0, nil) }
                        }

                        zippedList.forEach { observer.onNext($0) }
                    case .completed:
                        observer.onCompleted()
                    case .error(let e):
                        observer.onError(e)
                    }
            }

            return Disposables.create(disposableA, disposableB, disposableZip)
        }
    }
}

class ZipRepeatTests: XCTestCase {
    func testALongerThanB() {
        assertAopBEqualsE(
            a: ""-a--b--c-d--e-f-|"",
            b: ""--1-2-3-|"",
            e: ""a1,b2,c3,d1,e2,f3,|"")
    }

    func testAShorterThanB() {
        assertAopBEqualsE(
            a: ""-a--b|"",
            b: ""--1-2-3-|"",
            e: ""a1,b2,a3,|"")
    }
    func testBStartsLater() {
        assertAopBEqualsE(
            a: ""-a--b|"",
            b: ""----1---2|"",
            e: ""a1,b2,|"")

    }
    func testABWithConstOffset() {
        assertAopBEqualsE(
            a: ""-a--b--c|"",
            b: ""----1--2--3--|"",
            e: ""a1,b2,c3,|"")
    }

    func testAEndsBeforeBStarts() {
        assertAopBEqualsE(
            a: ""ab|"",
            b: ""---1-2-3-4-|"",
            e: ""a1,b2,a3,b4,|"")
    }

    func testACompletesWithoutValue() {
        assertAopBEqualsE(
            a: ""-|"",
            b: ""--1-2-3-|"",
            e: ""1,2,3,|"")
    }
    func testBCompletesWithoutValue() {
        assertAopBEqualsE(
            a: ""-a--b|"",
            b: ""|"",
            e: ""a,b,|"")
    }
    func testNoData() {
        assertAopBEqualsE(
            a: ""-|"",
            b: ""|"",
            e: ""|"")
    }

    func assertAopBEqualsE(_ scheduler: TestScheduler = TestScheduler(initialClock: 0), a: String, b: String, e: String, file: StaticString = #file, line: UInt = #line) {

        let aStream = scheduler.createColdObservable(events(a))
        let bStream = scheduler.createColdObservable(events(b))
        let eStream = expected(e)

        let bResults = scheduler.start {
            Observable&lt;(String)&gt;.zipRepeatCollected(aStream.asObservable(), bStream.asObservable()).map { ""\($0 ?? """")\($1 ?? """")"" }
        }
        XCTAssertEqual(eStream, bResults.events.map { $0.value }, file: file, line: line)
    }
    func expected(_ stream: String) -&gt; [Event&lt;String&gt;] {
        stream.split(separator: "","").map { String($0) == ""|"" ? .completed : .next(String($0)) }
    }
    func events(_ stream: String, step: Int = 10) -&gt; [Recorded&lt;Event&lt;String&gt;&gt;] {
        var time = 0
        var events = [Recorded&lt;Event&lt;String&gt;&gt;]()
        stream.forEach { c in
            if c == ""|"" {
                events.append(.completed(time))
            } else if c != ""-"" {
                events.append(.next(time, String(c)))
            }
            time += step
        }
        return events
    }
}
</code></pre>
","12675559","","12675559","","2020-01-09 22:32:18","2020-03-17 00:53:30","How to zip observables with repeating the shorter sequence","<swift><rx-swift>","3","4","","","","CC BY-SA 4.0"
"59661260","1","59662786","","2020-01-09 09:51:07","","1","49","<p>There are two observables: <code>a</code> and <code>b</code>. I want to subscribe to the second observable (<code>b</code>) after first observable (<code>a</code>) has fired (i.e. has generated very first <code>onNext</code> event).</p>

<p>I tried </p>

<pre><code>    b.skipUntil(a).subscribe(onNext:{
        print(""B: \($0)"")
    }).disposed(by: _bag)
</code></pre>

<p>but with no luck because <code>b</code> is a cold observable. As I understand, it starts immediately and gets blocked by <code>skipUntil(a)</code>.</p>

<p>This approach seems to work:</p>

<pre><code>    a.subscribe(onNext:{_ in
        // ... handle a ...

        b.subscribe(onNext:{
            print(""B: \($0)"")
        }).disposed(by: self._bag)
    }).disposed(by: _bag)
</code></pre>

<p>but I realise this is a bad practise and not a way to go.</p>
","674548","","","","","2020-01-09 11:17:11","Start subscription after another subscription fires","<rx-swift>","1","1","","","","CC BY-SA 4.0"
"59680603","1","59683293","","2020-01-10 11:15:50","","1","261","<p>Following is my code to do RxAlamofire requests</p>

<pre><code> RxAlamofire.request(request as URLRequestConvertible).validate(statusCode: 200..&lt;300).responseJSON().asObservable()
        .subscribe(onNext: { [weak self] (response) in
                if let json = response.data {
                    let jsonResult = JSON(json)
                    let foodMenuResult = MenuResult(jsonResult)
                    self?.delegate?.showMenu(menuResult: foodMenuResult)

                }

            }, onError: {  [weak self] (error) in
               // print(error.localizedDescription)
                 UIViewController().logAPIError(error: error)
                self?.delegate?.onError(MenuViewController.REQUEST_MENU)
            },onCompleted: {})
        .disposed(by: disposeBag)
</code></pre>

<p>I want to write extension related to Observable so that I can handle error at one place instead of writing same code on every  onError </p>

<p><strong>How can I do this?</strong></p>
","4153589","","","","","2020-01-10 14:04:41","RxAlamofire extension to hanlde error at one place","<ios><swift><alamofire><rx-swift><rxalamofire>","1","2","","","","CC BY-SA 4.0"
"59684362","1","59686443","","2020-01-10 15:12:50","","1","511","<p>I have a collectionview populated with data models. I am trying to update the bool property of the nested model when user taps on collectionview cell. In turn, the collectionview should reload and cell should be updated w.r.t to bool property. But the property changes in the model is not updating the collectionview.</p>

<p>//Model</p>

<pre><code>struct MultiSelectionQuestionModel {
  var header: String
  var items: [Item]
}

extension MultiSelectionQuestionModel: SectionModelType {
  typealias Item = MultiSelectionAnswerModel

   init(original: MultiSelectionQuestionModel, items: [Item]) {
        self = original
        self.items = items
  }
}

struct MultiSelectionAnswerModel {
    var text: String
    var isSelected: Bool = false //property to be updated
    var cellType: CellType = .CustomType
}
</code></pre>

<p>//CollectionView methods</p>

<pre><code>func populateCells() {
     let dataSource = RxCollectionViewSectionedReloadDataSource
                    &lt;MultiSelectionQuestionModel&gt;(
                configureCell: { (_, collectionView, indexPath, item) in
                    guard let cell = collectionView
                        .dequeueReusableCell(withReuseIdentifier: item.cellType.rawValue, for: indexPath) as? MultiSelectionBaseCell else {
                        return MultiSelectionBaseCell()
                    }
                    cell.configure(item: item)
                    return cell
                })

    //handle collectionview cell tap

    collectionView.rx.itemSelected.asObservable().map { (indexPath) -&gt; Result in
        //This method is called to update `isSelected` property. Once `isSelected` is updated. I am expecting the collectionview to reload and update the cell.
        self.viewModel.toggleItemSelected(indexPath: indexPath)
    }
    collectionView.rx.setDelegate(self).disposed(by: disposeBag)

    viewModel.items
            .bind(to: collectionView.rx.items(dataSource: dataSource))
                  .disposed(by: disposeBag)
}
</code></pre>

<p>//ViewModel</p>

<pre><code>struct MultiSelectionCollectionViewModel {
    var items: BehaviorRelay&lt;[MultiSelectionQuestionModel]&gt; = BehaviorRelay(value: [])
    var delegate:
    init(questions: BehaviorRelay&lt;[MultiSelectionQuestionModel]&gt;) {
        self.items = questions
    }

    //This method is called to update `isSelected` property. Once `isSelected` is updated. I am expecting the collectionview to reload and update the cell.
    func toggleItemSelected(indexPath: IndexPath) {
        let item = self.items.value[indexPath.section]
        if let options = item.items as? [MultiSelectionAnswerModel] {
            var optionItem = options[indexPath.row]
            optionItem.isSelected = true // Collectionview reload Not working. 
        } 
    }
}
</code></pre>

<p>I just started learning RxSwift. Any help is appreciated. Thanks</p>
","696465","","696465","","2020-01-10 15:27:32","2020-01-10 17:32:31","UICollectionView databinding using RxSwift - iOS","<ios><swift><uicollectionview><rx-swift>","1","0","","","","CC BY-SA 4.0"
"59685575","1","59686695","","2020-01-10 16:34:07","","2","48","<p>I have a hot observable <code>C</code> which I want to listen to until another observable <code>B</code> fires (i.e. generates <code>onNext</code> event). <code>B</code> is a cold observable and I do not want to ""wake up"" it until yet another observable <code>A</code> fires.</p>

<p>In another words:</p>

<ul>
<li>I am listening to <code>C</code>.</li>
<li>I am listening to <code>A</code> and as soon as it fires, I start listening to (thus waking up) <code>B</code></li>
<li>As soon as <code>B</code> fires, I stop listening to <code>C</code></li>
</ul>

<p>This is my code:</p>

<pre><code>    let b = Observable&lt;Int&gt;.create { s in
        print(""b got awoken"") // I want to see this line only after A fires
        s.onNext(666)
        s.onCompleted()
        return Disposables.create()
    }

    let c = Observable&lt;Int&gt;.interval(.seconds(1), scheduler: MainScheduler.instance)
    c
        .takeUntil(b) // I do not want to listen to C after B has fired
        .subscribe(onNext: { print(""C: \($0)"") })
        .disposed(by: _bag)

    let a = PublishSubject&lt;Int&gt;()
    a
        .do(onNext:{ print(""A: \($0)"") })
        .flatMap {_ in return b } // After A fires, I ""wake up"" (or subsribe to) B
        .subscribe(onNext:{ print(""B: \($0)"") })
        .disposed(by: _bag)

    // Some delay to let C generate some events and listen to them
    DispatchQueue.main.asyncAfter(deadline: .now() + 4.0) {
        print(""anext 1"")
        a.onNext(1)
    }
</code></pre>

<p>and this is the output:</p>

<pre><code>b got awoken
anext 1
A: 1
b got awoken
B: 666
</code></pre>

<p>this is the desired output:</p>

<pre><code>C: 0
C: 1
C: 2
C: 3
anext 1
A: 1
b got awoken
B: 666
</code></pre>

<p>How shall I manage these three observables to achieve the desired behaviour?</p>
","674548","","","","","2020-01-10 17:51:41","Listening to observable until or till another observable fires","<observable><rx-swift>","1","1","","","","CC BY-SA 4.0"
"59690848","1","59690956","","2020-01-11 01:16:04","","1","221","<p>I have a textfield that has 2 rules for validation: minimum amount of chars and alphanumerical chars. </p>

<p>I want to be able to represent to the user what he's doing wrong in an error label but the problem is that if I bind the textfield to both rules it can be creepy because once one rule gets approved the ui does a little flickering from the color of the separator for example changing from red to green to red because of the other validation failing. </p>

<p>I'd like to know if there's a way to prioritize one bind over the other. For example, this is what I currently have:</p>

<pre><code>let minimumValidator 
    = inputField.textField
      .rx.text.orEmpty.map { $0.count &gt;= 8 } // Min amount of chars is 8

minimumValidator.bind(to: inputField.rx.minimumChars)
    .disposed(by: bag)

let regexValidator 
    = inputField.textField
      .rx.text.orEmpty.map { $0.matches(regex) }

regexValidator.bind(to: inputField.rx.regex)
    .disposed(by: bag)
</code></pre>

<p>rx.minimumChars and rx.regex are custom binders</p>

<pre><code>    var minimumChars: Binder&lt;Bool&gt; {
        return Binder(self.base) { control, value in
            UIView.animate(withDuration: 0.1) {
                if value {
                    control.separator.backgroundColor = .white
                    control.errorLabel.isHidden = true
                } else {
                    let error = ""Needs more characters""
                    control.separator.backgroundColor = .red
                    control.errorLabel.text = error
                    control.errorLabel.isHidden = false
                }
            }
        }
    }
</code></pre>

<p>So my idea is to prioritize idk... let's say alphanumerical validation - so it would show error from minimum char till alphanumerical error came up, so till the user resolved the alphanumerical validation it would ignore the other stream from minimum amount of chars. I'm pretty sure i'm missing some combination of combineLatest with merge or idk. </p>
","5596875","","","","","2020-01-11 01:46:34","Is there some sort of Priority operator on RxSwift?","<ios><swift><cocoa><rxjs><rx-swift>","1","0","","","","CC BY-SA 4.0"
"59691355","1","59695120","","2020-01-11 03:19:54","","0","168","<p>I have two input fields, one for password and another one to confirm the password. I want to create a custom binder that will allow me to compare the value of both input fields but also validate minimum amount of chars. I had a pretty similar question but not regarding comparing two different fields (<a href=""https://stackoverflow.com/questions/59690848/is-there-some-sort-of-priority-operator-on-rxswift/59690956#59690956"">Is there some sort of Priority operator on RxSwift?</a>) and based on the answer for that previous question I've been trying to do something like this:</p>

<pre><code>enum PasswordCreateValidation {
    case valid
    case lessThanMinimum
    case confirmationLessThanMinimum
    case differentInputs
}

extension Reactive where Base: [InputField] {
    var rxPassword: Binder&lt;PasswordCreateValidation&gt; {
        return Binder&lt;[InputField]&gt;(self.base) { control, value in
            switch value {
            case .valid :
                control[0].errorLabel.isHidden = true
                control[1].errorLabel.isHidden = true
                control[0].separator.backgroundColor = .white
                control[1].separator.backgroundColor = .white
            case .lessThanMinimum:
                control[0].errorLabel.isHidden = false
                control[0].separator.backgroundColor = .red
                control[0].errorLabel.text = ""Needs more chars""
            case .confirmationLessThanMinimum:
                control[1].errorLabel.isHidden = false
                control[1].separator.backgroundColor = .red
                control[1].errorLabel.text = ""Needs more chars""
            case .differentInputs:
                control[0].errorLabel.isHidden = false
                control[0].separator.backgroundColor = .red
                control[0].errorLabel.text = ""Inputs are not the same""
                control[1].errorLabel.isHidden = false
                control[1].separator.backgroundColor = .red
                control[1].errorLabel.text = ""Inputs are not the same""
            }
        }
    }
}

...

private func bind() {
    let codeMinimum = codeInputField.textField.rx.text.orEmpty.map { $0.count &gt;= 1 }.skip(2)
    codeMinimum.bind(to: codeInputField.rx.nonEmpty).disposed(by: bag)

    let minimumAmountPassword = 8
    pwdInputField.minimumAmountOfChars = minimumAmountPassword
    confirmPwdInputField.minimumAmountOfChars = minimumAmountPassword

    let pwdMinimum = pwdInputField.textField
        .rx.text.orEmpty.map { $0.count &gt;= minimumAmountPassword }.skip(2)
    let confPwdMinimum = confirmPwdInputField.textField
        .rx.text.orEmpty.map { $0.count &gt;= minimumAmountPassword }.skip(2)

    pwdMinimum.bind(to: pwdInputField.rx.minimumChars).disposed(by: bag)
    confPwdMinimum.bind(to: confirmPwdInputField.rx.minimumChars).disposed(by: bag)

    let pwdEqualA = pwdInputField.textField.rx.text.orEmpty
        .map { $0 == self.confirmPwdInputField.value }.skip(2)

    let pwdEqualB = confirmPwdInputField.textField.rx.text.orEmpty
        .map { $0 == self.pwdInputField.value }.skip(2)

    let equality = Observable.combineLatest(pwdEqualA, pwdEqualB) { $0 &amp;&amp; $1 }
    let minimum = Observable.combineLatest(pwdMinimum, confPwdMinimum) { $0 &amp;&amp; $1 }
    let pwdValidation = Observable.combineLatest(equality, minimum) { $0 &amp;&amp; $1 }

    Observable.combineLatest(pwdValidation, codeMinimum) { $0 &amp;&amp; $1 }
        .startWith(false)
        .bind(to: signInButton.rx.isActive)
        .disposed(by: bag)
}
</code></pre>

<p>Seems my custom binder is wrong. isn't it allowed to have an array as Base?</p>
","5596875","","5596875","","2020-01-11 06:09:37","2020-01-11 14:02:37","Is possible to do a custom binder on an array of input fields using RxSwift?","<ios><swift><cocoa><rxjs><rx-swift>","1","0","","","","CC BY-SA 4.0"
"59715153","1","59716978","","2020-01-13 10:50:28","","0","1845","<p>I am having some issues with the <code>RxDataSources</code> cell reload animations for <code>RxSwift</code>. I have a simple table setup like so:</p>

<pre><code>import UIKit
import RxDataSources
import RxCocoa
import RxSwift
import Fakery

class ViewController1: UIViewController {


    @IBOutlet weak var tableView: UITableView!
    let bag = DisposeBag()



    override func viewDidLoad() {
        super.viewDidLoad()
        setupTableView()
    }

    private func setupTableView() {
        tableView.register(UINib(nibName: ""TestTableViewCell"", bundle: nil), forCellReuseIdentifier: ""cell"")

        let dataSource = RxTableViewSectionedAnimatedDataSource&lt;SectionOfTestData&gt;(
            animationConfiguration: AnimationConfiguration(insertAnimation: .none, reloadAnimation: .none, deleteAnimation: .none),
            configureCell: { dataSource, tableView, indexPath, element in
                let cell = tableView.dequeueReusableCell(withIdentifier: ""cell"", for: indexPath) as! TestTableViewCell
                cell.testData = element
                return cell
            })

        someData
            .bind(to: tableView.rx.items(dataSource: dataSource))
            .disposed(by: bag)
    }

    let someData = BehaviorRelay&lt;[SectionOfTestData]&gt;(value: [SectionOfTestData(items: [
        TestData(color: .red, name: ""Henry""),
        TestData(color: .blue, name: ""Josh"")
    ])])

    @IBAction func didTapUpdateButton(_ sender: Any) {
        let colors: [UIColor] = [.blue, .purple, .orange, .red, .brown]


        let items = someData.value.first!.items

        // Add random data when button is tapped
        someData.accept([SectionOfTestData(items: items + [TestData(color: colors.randomElement()!, name: Faker().name.firstName())])])
    }

}
</code></pre>

<p>The models:</p>

<pre><code>struct TestData {
    let color: UIColor
    let name: String
}

extension TestData: IdentifiableType, Equatable {
    typealias Identity = Int

    var identity: Identity {
           return Int.random(in: 0..&lt;20000)
    }
}

struct SectionOfTestData {
    var items: [Item]

    var identity: Int {
        return 0
    }
}

extension SectionOfTestData: AnimatableSectionModelType {
    typealias Identity = Int
    typealias Item = TestData

    // Implement default init
    init(original: SectionOfTestData, items: [Item]) {
        self = original
        self.items = items
    }
}

class TestTableViewCell: UITableViewCell {

    @IBOutlet weak var colorView: UIView!
    @IBOutlet weak var nameLabel: UILabel!

    var testData: TestData! {
        didSet {
            colorView.backgroundColor = testData.color
            nameLabel.text = testData.name
        }
    }

}
</code></pre>

<p>When the button is tapped the <code>BehaviorRelay</code> is updated and the table seems to refresh however the ""animations"" are always the same. In the supplied code I have actually set all animation types to <code>.none</code> yet it is still performing an animation. If I try to change the animation type to another type such as <code>.bottom</code> again the animation is the same. What am I doing wrong here?</p>

<p><a href=""https://i.stack.imgur.com/Zweji.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Zweji.gif"" alt=""enter image description here""></a></p>

<p>Is this a <em>reload</em> animation or <em>insert</em> animation? I have no idea if the table reloads or inserts when the data is updated, I can't find any information in the documents. Any pointers on this would be greatly appreciated!</p>
","4083744","","","","","2021-07-23 22:14:06","RxDataSources cell reload animations not working properly","<ios><swift><rx-swift><rxdatasources>","2","0","1","","","CC BY-SA 4.0"
"59727464","1","59733505","","2020-01-14 04:19:10","","0","1038","<p>I am having an issue with cell animations using <code>RxSwift</code> on a <code>UICollectionView</code>, my simple setup is as follows:</p>

<pre><code>collectionView.register(UINib(nibName: ""CustomCollectionCell"", bundle: nil), forCellWithReuseIdentifier: ""cell"")

let dataSource = RxCollectionViewSectionedAnimatedDataSource&lt;SectionOfCustomDataAnimated&gt;(
    animationConfiguration: AnimationConfiguration(insertAnimation: .bottom, reloadAnimation: .bottom, deleteAnimation: .bottom),
    configureCell: { dataSource, cv, indexPath, element in
        let cell = cv.dequeueReusableCell(withReuseIdentifier: ""cell"", for: indexPath) as! CustomCollectionCell
        cell.colorView.backgroundColor = element.color
        return cell
    })
</code></pre>

<p>With the cell and data models like so:</p>

<pre><code>struct CustomDataAnimated {
    let id: Int
    let color: UIColor
}

extension CustomDataAnimated: IdentifiableType, Equatable {
    typealias Identity = Int

    var identity: Identity {
        return id
    }
}

struct SectionOfCustomDataAnimated {
    var items: [Item]

    // Need to provide a unique id, only one section in our model
    var identity: Int {
        return 0
    }
}

extension SectionOfCustomDataAnimated: AnimatableSectionModelType {
    typealias Identity = Int
    typealias Item = CustomDataAnimated

    init(original: SectionOfCustomDataAnimated, items: [Item]) {
        self = original
        self.items = items
    }
}
</code></pre>

<p>I am using a <code>BehaviourRelay</code> that updates when the <code>update</code> button is pressed:</p>

<pre><code> private let sections = BehaviorRelay&lt;[SectionOfCustomDataAnimated]&gt;(
        value: [SectionOfCustomDataAnimated(items: [
            CustomDataAnimated(id: 0, color: .red),
            CustomDataAnimated(id: 1, color: .yellow)
    ])])

 @IBAction func didTapUpdate(_ sender: Any) {
        let colors: [UIColor] = [.red, .blue, .green, .purple, .orange]
        let originalColors = sections.value.first!.items
        self.sections.accept([SectionOfCustomDataAnimated(items: originalColors + [CustomDataAnimated(id: originalColors.count ,color: colors.randomElement()!)])])
    }
</code></pre>

<p><a href=""https://i.stack.imgur.com/K50UX.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/K50UX.gif"" alt=""enter image description here""></a></p>

<p>The problem is that the collection view <em>does</em> animate however it seems it <em>always</em> uses a fade style animation. Choosing a different option such as <code>.bottom</code> in the example above still results in the same fade animation. I have used similar logic on a table view before and there was no issue, I only seem to have the issue in collection views. How can I get the different style of animations to work?</p>
","4083744","","","","","2020-01-14 12:09:08","RxDataSources collection view cell always uses fade for insert cell animation, can't change to a different animation","<ios><swift><uicollectionview><rx-swift><rxdatasources>","1","0","","","","CC BY-SA 4.0"
"59751728","1","59755746","","2020-01-15 12:44:29","","0","427","<p>I have successfully <code>parsed</code> <code>json</code> data using <code>URLSession</code> and now I want to add the <code>parsed</code> data to an <code>array</code>. Doing this using an ordinary <code>array</code> works fine, but I'm learning <code>Rx</code> and thus want to use a <code>subject</code>. </p>

<p>So, this works: </p>

<pre><code>var parsedJson = [Employees]()
self.parsedJson = decodedJson.people
</code></pre>

<p>But this gives an error:</p>

<pre><code>var parsedJson: PublishSubject&lt;[Employees]&gt; = PublishSubject&lt;[Employees]&gt;()
self.parsedJson = decodedJson.people
</code></pre>

<blockquote>
  <p>Cannot assign value of type '[Employees]' to type 'PublishSubject&lt;[Employees]>'</p>
</blockquote>

<p>Here is the <code>URLSession</code> code:</p>

<pre><code>//    var parsedJson = [Employees]()
    var parsedJson: PublishSubject&lt;[Employees]&gt; = PublishSubject&lt;[Employees]&gt;()


    func getJSON(completion: @escaping () -&gt; Void) {
        guard let url = URL(string:""https://api.myjson.com/bins/jmos6"") else { return }

        URLSession.shared.dataTask(with: url) { data, response, error in
            guard let data = data else { return }

            do {
                let jsonDecoder = JSONDecoder()
                jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase
                jsonDecoder.dateDecodingStrategy = .iso8601

                let decodedJson = try jsonDecoder.decode(People.self, from: data)
                self.parsedJson = decodedJson.people
                completion()
            } catch {
                print(error)
            }
        }.resume()
    }
</code></pre>

<p>Anyone know how to do this and why there is an error in the first place? Doesn't the <code>&lt;&gt;</code> simply indicate which <code>type</code> should be <code>observed</code>? Didn't get <code>.accept()</code> to work either.</p>

<p><strong><em>EDIT</em></strong></p>

<pre><code>let parsedJson: BehaviorRelay&lt;[Employees]&gt; = BehaviorRelay(value: [])
self.parsedJson.accept(decodedJson.people)
</code></pre>

<p>This worked, but what is the equivalent to <code>BehaviorSubject</code> and <code>PublishSubjuct</code>?</p>
","8591381","","8591381","","2020-01-15 15:36:07","2020-01-15 16:30:27","Cannot assign value of type [Employees] to type 'PublishSubject<[Employees]>","<arrays><swift><rx-swift><urlsession>","2","0","","","","CC BY-SA 4.0"
"59766220","1","59766483","","2020-01-16 09:09:26","","0","65","<p>I have successfully parsed <code>JSON</code> data using <code>URLSession</code>. The data is then passed to an <code>Rx</code> sequence and finally the data is bound to a <code>tableView</code>. Now, my question is, is the <code>JSON</code> data itself observed? I mean, if there are changes in the remote <code>JSON</code> data, will my <code>subscriber</code> trigger? I'm guessing no, and that you need to somehow wrap the <code>URLSession</code> in an observer as well. But how would I go about doing that? Anyway, here's the code:</p>

<pre><code>func getJSON() {
        guard let url = URL(string:""https://api.myjson.com/bins/sbmzi"") else { return }

        URLSession.shared.dataTask(with: url) { data, response, error in
            guard let data = data else { return }
            do {
                let jsonDecoder = JSONDecoder()
                jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase
                jsonDecoder.dateDecodingStrategy = .iso8601

                let decodedJson = try jsonDecoder.decode(People.self, from: data)
                self.parsedJson.accept(decodedJson.people)

            } catch {
                print(error)
            }
        }.resume()
    }
</code></pre>

<p>And in <code>viewDidLoad</code>:</p>

<pre><code>getJSON()

        self.parsedJson.subscribe(onNext: {
            print(""👀Observing👀"")
            print($0.description)
        }).disposed(by: disposer)

        self.parsedJson.bind(to: myTableView.rx.items(cellIdentifier: ""cell"")) { row, data, cell in
            cell.textLabel?.text = ""\(data.name), \(data.job), \(data.bestBook.title), \(data.bestBook.author.name)""
        }.disposed(by: disposer)
</code></pre>

<p>There's the <code>structs</code> for the parsed data as well, but no need to show them I guess.</p>
","8591381","","1180728","","2020-01-16 09:59:57","2020-01-16 09:59:57","Does this Rx code subscribe to the changes of the JSON itself?","<ios><json><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"59787109","1","59797226","","2020-01-17 12:10:51","","2","1708","<p>I use the following piece of code to generate a cold <code>RxSwift Observable</code>:</p>

<pre><code>func doRequest&lt;T :Mappable&gt;(request:URLRequestConvertible) -&gt; Observable&lt;T&gt; {
        let observable = Observable&lt;T&gt;.create { [weak self] observer in
        guard let self = self else { return Disposables.create() }
        self.session.request(request).validate().responseObject { (response: AFDataResponse&lt;T&gt;) in
            switch response.result {
                case .success(let obj):
                    observer.onNext(obj)
                    observer.onCompleted()
                case .failure(let error):
                    let theError = error as Error
                    observer.onError(theError)
            }
        }
         return Disposables.create()
    }
    return observable
}
</code></pre>

<p>where <code>Mappable</code> is an <a href=""https://github.com/tristanhimmelman/ObjectMapper"" rel=""nofollow noreferrer"">ObjectMapper</a> based type, and <code>self.session</code> is an Alamofire's <code>Session</code> object.</p>

<p>I can't find an equivalent to <code>Observable.create {...}</code> in Apple's <code>Combine</code> framework. What I only found is <code>URLSession.shared.dataTaskPublisher(for:)</code> which creates a publisher using Apple's <code>URLSession</code> class.</p>

<p>How can I convert the above observable to an Alamofire Combine's publisher ?</p>

<p><strong>EDIT</strong>:
using the solution provided by rob, I ended up with the following:</p>

<pre><code> private let apiQueue = DispatchQueue(label: ""API"", qos: .default, attributes: .concurrent)

  func doRequest&lt;T&gt;(request: URLRequestConvertible) -&gt; AnyPublisher&lt;T, AFError&gt; where T : Mappable {

       Deferred { [weak self] () -&gt; Future&lt;T, AFError&gt; in

          guard let self = self else {
              return Future&lt;T, AFError&gt; { promise in  
promise(.failure(.explicitlyCancelled))  }
        }

          return Future { promise in
            self.session
            .request(request)
            .validate()
            .responseObject { (response: AFDataResponse&lt;T&gt;) in
                promise(response.result)
            }
        }
    }
    .handleEvents(receiveCompletion: { completion in
        if case .failure (let error) = completion {
                //handle the error
        }
    })
    .receive(on: self.apiQueue)
    .eraseToAnyPublisher()
}
</code></pre>

<p><strong>EDIT2:</strong> I have to remove the private queue since it's not needed, Alamofire does the parsing the decoding on its own, so remove the queue and its usages (<code>.receive(on: self.apiQueue)</code>)</p>
","1056118","","1056118","","2020-01-22 05:06:09","2020-01-22 05:06:09","Creating a Combine's publisher like RxSwift's Observable.Create for an Alamofire request","<ios><swift><alamofire><rx-swift><combine>","1","1","","","","CC BY-SA 4.0"
"59798140","1","","","2020-01-18 06:36:16","","1","308","<p>Here is code i am using, i am new to rxswift. My question is simple when i tap on textfield date picker opens and it freezes my ViewController. I don't know what is the problem with UI in rxswift, this works well in only swift project. Your help is appreaciated pls help.</p>

<pre><code>class ViewController: UIViewController {
     //Text Field Connection
   @IBOutlet weak var txtDatePicker: UITextField!
   //Uidate picker
   let datePicker = UIDatePicker()

    override func viewDidLoad() {
    super.viewDidLoad()
   //show date picker
     showDatePicker()
  }


   func showDatePicker(){
   //Formate Date
    datePicker.datePickerMode = .date

    //ToolBar
   let toolbar = UIToolbar();
   toolbar.sizeToFit()

   //done button &amp; cancel button
    let doneButton = UIBarButtonItem(title: ""Done"", style: UIBarButtonItemStyle.bordered, target: self, action: ""donedatePicker"")
    let spaceButton = UIBarButtonItem(barButtonSystemItem: UIBarButtonSystemItem.flexibleSpace, target: nil, action: nil)
   let cancelButton = UIBarButtonItem(title: ""Cancel"", style: UIBarButtonItemStyle.bordered, target: self, action: ""cancelDatePicker"")
   toolbar.setItems([doneButton,spaceButton,cancelButton], animated: false)

// add toolbar to textField
txtDatePicker.inputAccessoryView = toolbar
 // add datepicker to textField
txtDatePicker.inputView = datePicker

   }

 func donedatePicker(){
  //For date formate
   let formatter = DateFormatter()
   formatter.dateFormat = ""dd/MM/yyyy""
   txtDatePicker.text = formatter.string(from: datePicker.date)
   //dismiss date picker dialog
   self.view.endEditing(true)
    }

      func cancelDatePicker(){
       //cancel button dismiss datepicker dialog
        self.view.endEditing(true)
      }
   }
a
</code></pre>
","12735769","","","","","2020-01-18 06:36:16","Rx swift - Date picker freezes Rx swift View controller","<ios><swift><rx-swift>","0","4","","","","CC BY-SA 4.0"
"59813484","1","59816678","","2020-01-19 19:12:06","","1","980","<p>I have just started learning RxSwift and trying to build a sample application to practice these concepts. </p>

<p>I have written a QuestionViewModel that loads list of questions from QuestionOps class. QuestionOps has a function getQuestions that returns Single&lt;[Question]>.</p>

<p>Problem that I am facing is, how to mock the behavior of QuestionOps class while testing QuestionViewModel.</p>

<pre><code>public class QuestionsListViewModel {

    public var questionOps: QuestionOps!

    private let disposeBag = DisposeBag()
    private let items = BehaviorRelay&lt;[QuestionItemViewModel]&gt;(value: [])
    public let loadNextPage = PublishSubject&lt;Void&gt;()
    public var listItems: Driver&lt;[QuestionItemViewModel]&gt;
    public init() {
        listItems = items.asDriver(onErrorJustReturn: [])

        loadNextPage
            .flatMapFirst { self.questionOps.getQuestions() }
            .map { $0.map { QuestionItemViewModel($0) } }
            .bind(to: items)
            .disposed(by: disposeBag)
    }
}
</code></pre>

<pre><code>public class QuestionOps {

    public func getQuestions() -&gt; Single&lt;[Question]&gt; {

        return Single.create { event -&gt; Disposable in

            event(.success([]))
            return Disposables.create()
        }
    }
}
</code></pre>

<p>I have created this MockQuestionOps for test purpose:</p>

<pre><code>public class MockQuestionOps : QuestionOps {

    //MARK: -
    //MARK: Responses
    public var getQuestionsResponse: Single&lt;[Question]&gt;?

    public func getQuestions() -&gt; Single&lt;[Question]&gt; {
        self.getQuestionsResponse = Single.create { event -&gt; Disposable in

            return Disposables.create()
        }
        return self.getQuestionsResponse!
    }
}
</code></pre>

<p>In my test case I am doing the following:</p>

<pre><code>/// My idea here is to test in following maner:
/// - at some point user initates loading
/// - after some time got network response with status true
func testLoadedDataIsDisplayedCorrectly() {

    scheduler = TestScheduler(initialClock: 0)
    let questionsLoadedObserver = scheduler.createObserver([QuestionItemViewModel].self)

    let qOps = MockQuestionOps()
    vm = QuestionsListViewModel()
    vm.questionOps = qOps
    vm.listItems
        .drive(questionsLoadedObserver)
        .disposed(by: disposebag)

    // User initiates load questions
    scheduler.createColdObservable([.next(2, ())])
        .bind(to: vm.loadNextPage)
        .disposed(by: disposebag)

    // Simulating question ops behaviour of responding
    // to get question request

    /// HERE: -----------    
    /// This is where I am stuck
    /// How should I tell qOps to send particular response with delay

    scheduler.start()

    /// HERE: -----------
    /// How can I test list is initialy empty
    /// and after loading, data is correctly loaded
}
</code></pre>
","4160530","","","","","2020-01-20 03:32:20","Mocking and Validating Results in RxSwift Unit Testing","<ios><rx-swift><rxtest>","1","0","1","","","CC BY-SA 4.0"
"59815298","1","59822772","","2020-01-19 23:19:45","","1","424","<p>I'm observing a BehaviorRelay and I want to subscribe only when the number of items increase. I tried <strong>distinct/dinstinctUntilChanged</strong> but it does not suit my needs because it will skip too much or too few times.</p>

<pre><code>behaviorRelay
  .compactMap { $0?.items }
  .subscribe(onNext: { elements in
      print(""items has one more element."")
  }).disposed(by: bag)
</code></pre>

<p><code>var behaviorRelay = BehaviorRelay&lt;[Car]?&gt;(value: [])</code></p>

<pre><code>class Car {
  var items: [Any] // whatever... just an example.
}
</code></pre>
","5596875","","","","","2020-01-20 11:55:52","How to ignore behaviorRelay element removal on RxSwift?","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"59824916","1","","","2020-01-20 14:03:55","","1","1425","<p>I'm trying to create an app to get some news from an API and i'm using Moya, RxSwift and MVVM. 
This is my ViewModel:</p>

<pre><code>import Foundation
import RxSwift
import RxCocoa

public enum NewsListError {
    case internetError(String)
    case serverMessage(String)
}

enum ViewModelState {
    case success
    case failure
}

protocol NewsListViewModelInput {
    func viewDidLoad()
    func didLoadNextPage()
}

protocol MoviesListViewModelOutput {
    var newsList: PublishSubject&lt;NewsList&gt; { get }
    var error: PublishSubject&lt;String&gt; { get }
    var loading: PublishSubject&lt;Bool&gt; { get }
    var isEmpty: PublishSubject&lt;Bool&gt; { get }
}

protocol NewsListViewModel: NewsListViewModelInput, MoviesListViewModelOutput {}

class DefaultNewsListViewModel: NewsListViewModel{

    func viewDidLoad() {

    }

    func didLoadNextPage() {

    }


    private(set) var currentPage: Int = 0
    private var totalPageCount: Int = 1

    var hasMorePages: Bool {
        return currentPage &lt; totalPageCount
    }
    var nextPage: Int {
        guard hasMorePages else { return currentPage }
        return currentPage + 1
    }

    private var newsLoadTask: Cancellable? { willSet { newsLoadTask?.cancel() } }

    private let disposable = DisposeBag()

    // MARK: - OUTPUT
    let newsList: PublishSubject&lt;NewsList&gt; = PublishSubject()
    let error: PublishSubject&lt;String&gt; = PublishSubject()
    let loading: PublishSubject&lt;Bool&gt; = PublishSubject()
    let isEmpty: PublishSubject&lt;Bool&gt; = PublishSubject()

    func getNewsList() -&gt; Void{
        print(""sono dentro il viewModel!"")
        NewsDataService.shared.getNewsList()
            .subscribe { event in
                switch event {
                case .next(let progressResponse):
                    if progressResponse.response != nil {
                        do{
                            let json = try progressResponse.response?.map(NewsList.self)
                            print(json!)
                            self.newsList.onNext(json!)
                        }
                        catch _ {
                            print(""error try"")
                        }
                    } else {
                        print(""Progress: \(progressResponse.progress)"")
                    }
                case .error( _): break
                // handle the error
                default:
                    break
                }
        }
    }

}
</code></pre>

<p>This is my ViewController, where xCode give me the following error when i try to bind to tableNews:</p>

<pre><code>Expression type 'Reactive&lt;_&gt;' is ambiguous without more context
</code></pre>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class ViewController: UIViewController {

    @IBOutlet weak var tableNews: UITableView!

    let viewModel = DefaultNewsListViewModel()

    var disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

    }

    private func setupBindings() {

        viewModel.newsList.bind(to: tableNews.rx.items(cellIdentifier: ""Cell"")) {
            (index, repository: NewsList, cell) in
            cell.textLabel?.text = repository.name
            cell.detailTextLabel?.text = repository.url
        }
        .disposed(by: disposeBag)
    }
}
</code></pre>

<p>This is the service that get data from API:</p>

<pre><code>
import Moya
import RxSwift
struct NewsDataService {
    static let shared = NewsDataService()

    private let disposable = DisposeBag()

    private init() {}

    fileprivate let newsListProvider = MoyaProvider&lt;NewsService&gt;()

    func getNewsList() -&gt; Observable&lt;ProgressResponse&gt; {
        self.newsListProvider.rx.requestWithProgress(.readNewsList)
        }
    }

</code></pre>

<p>I'm new at rxSwift, I followed some documentation but i'd like to know if i'm approaching in the right way. Another point i'd like to know is how correctly bind my tableView to viewModel.
Thanks for the support.</p>
","7089089","","","","","2020-01-23 03:34:31","How to bind data from viewModel in view with rxSwift and Moya?","<ios><swift><rx-swift><rx-cocoa><moya>","1","1","","","","CC BY-SA 4.0"
"59848687","1","","","2020-01-21 20:23:31","","4","3380","<p>I use the following <code>UIViewController</code> and <code>RxSwift/RxCocoa</code> based piece of code to write a very simply MVVM pattern to bind a <code>UIButton</code> tap event to trigger some <code>Observable</code> work and listen for the result:</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class ViewController: UIViewController {

    @IBOutlet weak var someButton: UIButton!

    var viewModel: ViewModel!
    private var disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()
        viewModel = ViewModel()
        setupBindings()
    }

    private func setupBindings() {
        someButton.rx.tap
        .bind(to: self.viewModel.input.trigger)
        .disposed(by: disposeBag)

        viewModel.output.result
            .subscribe(onNext: { element in
            print(""element is \(element)"")
            }).disposed(by: disposeBag)
    }
}

class ViewModel {

    struct Input {
        let trigger: AnyObserver&lt;Void&gt;
    }

    struct Output {
        let result: Observable&lt;String&gt;
    }

    let input: Input
    let output: Output

    private let triggerSubject = PublishSubject&lt;Void&gt;()

    init() {
        self.input = Input(trigger: triggerSubject.asObserver())
        let resultObservable = triggerSubject.flatMap { Observable.just(""TEST"") }
        self.output = Output(result: resultObservable)
    }
}
</code></pre>

<p>It compiles and runs well. However, I need to <code>Combin</code>ify this pattern with <code>SwiftUI</code>, so I converted that code into the following:</p>

<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    var viewModel: ViewModel
    var subscriptions = Set&lt;AnyCancellable&gt;()

    init(viewModel: ViewModel) {
        self.viewModel = viewModel
        setupBindings()
    }

    var body: some View {

        Button(action: {
            // &lt;---- how to trigger viewModel's trigger from here
        }, label: {
            Text(""Click Me"")
        })
    }

    private func setupBindings() {
        self.viewModel.output.result.sink(receiveValue: { value in
            print(""value is \(value)"")
            })
            .store(in: &amp;subscriptions) // &lt;--- doesn't compile due to immutability of ContentView
    }
}

class ViewModel {

    struct Input {
        let trigger: AnySubscriber&lt;Void, Never&gt;
    }

    struct Output {
        let result: AnyPublisher&lt;String, Never&gt;
    }

    let input: Input
    let output: Output

    private let triggerSubject = PassthroughSubject&lt;Void, Never&gt;()

    init() {
        self.input = Input(trigger: AnySubscriber(triggerSubject))

        let resultPublisher = triggerSubject
            .flatMap { Just(""TEST"") }
            .eraseToAnyPublisher()

        self.output = Output(result: resultPublisher)
    }
}

</code></pre>

<p>This sample doesn't compile due to two errors (commented in code):</p>

<p><strong>(1) Problem 1</strong>: How to trigger the publisher's work from the button's action closure like the case of <code>RxSwift</code> above ? </p>

<p><strong>(2) Problem 2</strong> is related somehow to architectural design rather than a compile error: 
the error says: <code>... Cannot pass immutable value as inout argument: 'self' is immutable ...</code>, that's because <code>SwiftUI</code> views are structs, they are designed to be changed only through sorts of bindings (<code>@State</code>, <code>@ObservedObject</code>, etc ...), I have two sub-questions related to problem 2:</p>

<p>[A]: is it considered a bad practice to <code>sink</code> a publisher in a <code>SwiftUI</code> View ? which may need some workaround to store the <code>cancellable</code> at the <code>View</code>'s struct scope ?</p>

<p>[B]: which one is better for <code>SwiftUI/Combine</code> projects in terms of MVVM architectural pattern: using a ViewModel with [ Input[Subscribers], Output[AnyPublishers] ] pattern, or a 
<code>ObservableObject</code> ViewModel with [ <code>@Published</code> properties] ?</p>
","1056118","","","","","2020-11-24 17:59:46","Binding a SwiftUI Button to AnySubscriber like RxCocoa's button tap","<ios><swiftui><rx-swift><combine><rx-cocoa>","2","1","1","","","CC BY-SA 4.0"
"59868953","1","","","2020-01-22 22:07:46","","1","293","<p>I have an BehaviorSubject array. i want to remove a photo from this array by id.</p>

<p>i tried; </p>

<pre><code>photosViewModel.favoritePhotos
            .observeOn(MainScheduler.instance)
            .map { photoList in
                photoList.filter { $0.id! != self.currentPhoto.id! } //remove currentPhoto
        }.bind(to: photosViewModel.favoritePhotos)
        .disposed(by: disposeBag)
</code></pre>
","11319379","","","","","2020-01-23 02:47:58","RxSwift Remove an element BehaviorSubject","<swift><rx-swift><behaviorsubject>","1","0","","","","CC BY-SA 4.0"
"59874084","1","","","2020-01-23 08:17:11","","1","190","<p>I have existing and working code, which looks like this (unnecessary stuff removed):</p>

<pre><code>queryTextField.rx.text.orEmpty
            .throttle(.milliseconds(300), scheduler: MainScheduler.instance)
            .distinctUntilChanged()
            .flatMapLatest { query in
                return try AddFriendViewController.getSearchResults(query)
                    .retry(3)
                    .startWith([])
                    .catchErrorJustReturn([])
            }
            .bind(to: tableView.rx.items(cellIdentifier: ""cell"", cellType: AddFriendTableViewCell.self)) { (row, item, cell) in                
                cell.nameLabel.text = ""\(item.firstName) \(item.lastName)""
            }
            .disposed(by: disposeBag)
</code></pre>

<p>When you type a name in a text field it automatically searches (through an API) for friends matching this query.</p>

<p>But I also want to add another feature - import from contacts, invoked by additional button. I have a list of local contacts and using them I ask API for search results. I want to display these results in the same place. But I don't know how to <em>send</em> these results into tableView. I thought of creating a varabiable:</p>

<pre><code>var items: Observable&lt;[FriendSearchResult]&gt; = Observable.just([])
</code></pre>

<p>But I don't know how to send/receive data. Any clues?</p>

<p><strong>edit:</strong></p>

<p>Thanks to @andromedainative now code looks like this:</p>

<pre><code>var items: BehaviorRelay&lt;[FriendSearchResult]&gt; = BehaviorRelay(value: [])

items.asObservable()
        .bind(to: tableView.rx.items(cellIdentifier: ""cell"", cellType: AddFriendTableViewCell.self)) { (row, item, cell) in                
            cell.nameLabel.text = ""\(item.firstName) \(item.lastName)""
        }
        .disposed(by: disposeBag)

queryTextField.rx.text.orEmpty
        .throttle(.milliseconds(300), scheduler: MainScheduler.instance)
        .distinctUntilChanged()
        .flatMapLatest { query in
            return try AddFriendViewController.getSearchResults(query)
                .retry(3)
                .startWith([])
                .catchErrorJustReturn([])
        }
        .bind(to: items) //this was a missing piece
        .disposed(by: disposeBag)
</code></pre>

<p>And passing results from getContacts is simple:</p>

<pre><code>items.accept(data)
</code></pre>

<p>But, I have a special case where I have to refresh data. How can I invoke queryTextField to call API with the same query?</p>

<p>I've only found a hacky way:</p>

<pre><code>let query = queryTextField.text ?? """"
queryTextField.text = """"
queryTextField.sendActions(for: .valueChanged)
queryTextField.text = query
queryTextField.sendActions(for: .valueChanged)
</code></pre>

<p>I have to change to some other value and change it back. Is there any more clean solution?</p>
","1264375","","1264375","","2020-01-23 13:34:39","2020-01-23 13:34:39","Receive and send observable in RxSwift","<ios><swift><reactive-programming><rx-swift>","2","0","","","","CC BY-SA 4.0"
"59882050","1","","","2020-01-23 15:30:55","","1","126","<p>I am trying to filter out something from two streams I'm trying to combine. Both values that I am trying to are of the same type so I can't seem to understand why I am getting this issue. </p>

<pre><code> let currentUserEmail = Observable.just(currentUserEmail)
            .unwrap()
</code></pre>

<p>//Using some internal way to get access to the email </p>

<pre><code>let listOfAllUsers = Observable.combineLatest(getUsersList(), currentUserEmail) { allUsers, currentUserEmailAddress in
        return allUsers.filter { $0.emailAddress != currentUserEmailAddress } }
    .asObservable()
    .share(replay: 1, scope: .whileConnected)
</code></pre>
","9398617","","9398617","","2020-01-23 17:46:30","2020-01-26 03:17:24","Cannot invoke 'filter' with an argument list of type '(@escaping (_) -> _)' within combineLatest in RxSwift","<swift><filter><rx-swift><combinelatest>","1","4","","","","CC BY-SA 4.0"
"59886357","1","59895663","","2020-01-23 20:09:14","","1","45","<p>Say I have a Login button that's bound to an observer in my VM.  </p>

<p>When the user taps the button it triggers an async API call. The VC listens for the results of the call on an Observable exposed by the VM.  </p>

<p>I show a Cancel button, in case the async activity gets stuck or the user realizes they typed their password wrong and want to try again. If the user cancels I'd like to effectively cancel or ignore events emitted as a result of the first tap, and allow the user to tap Login again when they're ready.</p>

<p>setup is something like this:</p>

<pre class=""lang-swift prettyprint-override""><code>class SimpleVM {

  struct Output {
    let loginResponse: Observable&lt;LoginResponse&gt;
  }
  struct Input {
    let loginDidTap: AnyObserver&lt;Void&gt;
    let cancelDidTap: AnyObserver&lt;Void&gt;
  }

  let output: Output
  let input: Input

  private let loginSubject = PublishSubject&lt;Void&gt;()
  private let cancelSubject = PublishSubject&lt;Void&gt;()

  init() {
    let response = loginSubject
      .flatMapLatest { _ in
        loginService.login(username, password)
      }

    cancelSubject
      .flatMapLatest { _ in 
         // do something here?
    }

    input = Input(loginDidTap: loginSubject.asObserver(), cancelDidTap: cancelSubject.asObserver())
    output = Output(loginResponse: response)
  }
}

class SimpleVC: UIViewController {
  var loginButton: UIButton!
  var cancelButton: UIButton!
  let disposeBag = DisposeBag()

  func bind(vm: SimpleVM) {
    loginButton.rx.tap
      .bind(to: vm.input.loginDidTap)
      .disposed(by: disposeBag)

    cancelButton.rx.tap
      .bind(to: vm.input.cancelDidTap)
      .disposed(by: disposeBag)

    vm.output.loginResponse
      .subscribe(onNext: { response in
        print(""Got token \(response.info.token)"")
      }).disposed(by: disposeBag)
  }
}
</code></pre>

<p>How do I handle the cancel button tap such that it effectively ""resets"" things so the user can attempt to login again?</p>
","415219","","","","","2020-01-24 11:35:28","Allow user to cancel Login attempt and retry manually without destroying Observables","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"59888160","1","","","2020-01-23 22:50:38","","2","794","<p>I'm very new to RxSwift and RxCocoa and I've recently made heavy use of <code>Variable</code> because of how convenient it is to just push mutations into the <code>Variable</code> through its value. Now that it is deprecated I'm trying to understand how best to use <code>BehaviorRelay</code> instead. There's an Rx-y way of doing what I want to do, but I'm having a hard time landing on it.</p>

<p>What I want is to put an instance of struct-based model behind a ViewModel and observe changes to it and bind UI elements in such a way that I can mutate that model through the <code>BehaviorRelay</code>. </p>

<p>The model is simple:</p>

<pre><code>struct Pizza {
    var name: String
    var price: Float
}
</code></pre>

<p>So is the View Model:</p>

<pre><code>final class PizzaViewModel {
    let pizzaRelay =  BehaviorRelay&lt;Pizza&gt;(value: Pizza(name: ""Sausage"", price: 5.00))

    init(pizza: Pizza) {
        pizzaRelay.accept(pizza)

        // I feel like I'm missing something Rx-like here... 
    }
}
</code></pre>

<p>Then somewhere you would maybe bind a UITextField to the BehaviorRelay like so:</p>

<pre><code>viewModel
    .pizzaRelay
    .asObservable()
    .map { $0.name }
    .bind(to: nameTextField.rx.text)
    .disposed(by: disposeBag)
</code></pre>

<p>The question becomes: if you need to push values from the text field back into the BehaviorRelay how should that work?</p>

<pre><code>nameTextField
    .rx
    .controlEvent([.editingChanged])
    .asObservable()
    .subscribe(onNext: { [weak self] in
        guard let self = self else { return }
        if let text = self.nameTextField.text {
            self.viewModel.pizzaRelay.value.name = text  // does not compile because value is a let
        }
    }).disposed(by: disposeBag)
</code></pre>

<p>I'm probably not using the correct types here or I'm not thinking in the correct Rx-fashion in-terms of streams of inputs/outputs, but I'm curious how others might approach this problem?</p>

<p>Other things I've considered:</p>

<ul>
<li>Just reconstructing a new <code>Pizza</code> in the <code>.subscribe</code> using current value in the <code>BehaviorRelay</code>, mutating the name and then <code>.accept</code>-ing that back into the relay. That doesn't feel exactly right, though.</li>
<li>Creating individual <code>BehaviorRelay</code>'s for each property I want to mutate on my <code>Pizza</code>, then <code>.accept</code>-ing values for each property and then using <code>combineLatest</code> on all those relays and returning a <code>Observable&lt;Pizza&gt;</code>. But that feels clunky also.</li>
</ul>

<p>How should this work in an ideal world? Am I thinking about this incorrectly? Help! My head hurts.</p>
","1396884","","","","","2020-01-24 01:52:12","How do you edit a property of the current value inside a BehaviorRelay?","<swift><reactive-programming><rx-swift><behaviorrelay>","1","0","","","","CC BY-SA 4.0"
"59939788","1","59940194","","2020-01-27 22:25:54","","4","2454","<p>I'm trying to subscribe to an observable generated by a <code>combineLatest</code>, after <code>flatMap</code>. If I'm running this code in a struct I get this error:</p>

<p><code>Escaping closure captures mutating 'self' parameter</code></p>

<p>If I change to a class the error does not occurs. I understand that with struct I cannot asynchronously mutate the state of the struct, but, in this case I'm actually not mutating it, or am I?</p>

<p>There's another way to fix it without using a class?</p>

<pre><code>public struct ViewModel {

    let disposeBag = DisposeBag()
    var relay1: PublishRelay&lt;()&gt;
    var relay2: PublishRelay&lt;()&gt;

    init() {
        relay1 = PublishRelay&lt;()&gt;()
        relay2 = PublishRelay&lt;()&gt;()

        Observable.combineLatest(relay1, relay2)
            .filter { tuple in 1 == 1 } // some boolean logic here
            .flatMap { _ in return Observable&lt;Void&gt;.just(()) } // some map filter here
            .subscribe(onNext: { _ in
                self.doCoolStuff()
            }).disposed(by: disposeBag)
    }

    func doCoolStuff() {
        // Do cool Stuff here
    }
}
</code></pre>
","985979","","","","","2020-01-27 23:10:27","Escaping closure captures mutating 'self' parameter","<swift><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"59950365","1","","","2020-01-28 13:54:13","","1","213","<p>Observing a UITextfield's text value with RxSwift as in code example below does not get updated when programmatically setting the textfield's value like this <code>customTextField.text = ""Hello World""</code></p>

<pre><code>customTextField.rx.text
            .bind(onNext: { textValue in
                print( textValue )
            }).disposed(by: disposeBag)
</code></pre>

<p>I have realized that this is due to setting the value programmatically does not fire the <code>valueChanged</code> control property event.</p>

<p>How would I go about ensuring that the <code>valueChanged</code> event gets fired when setting the value programmatically?</p>
","10263618","","","","","2020-01-29 06:26:00","Observing UITextField.rx.text doesn't get notified of programmatic changes to the value of the textfield","<ios><swift><uitextfield><rx-swift>","1","2","","","","CC BY-SA 4.0"
"59955967","1","","","2020-01-28 19:44:44","","1","62","<p>I have this function:</p>

<pre><code>    func makeRepoRequest() -&gt; Single&lt;[String: Any]&gt; {
        return Single&lt;[String: Any]&gt;.create {[weak self] observer in
            guard let something = self?.temp else {
                let disposeBag = DisposeBag()
                self?.getRepo(""364"").subscribe(onSuccess: { content in
                    observer(.success(content))
                }, onError: { error in
                    observer(.error(error))
                }).disposed(by: disposeBag)
                return Disposables.create()
            }
            observer(.success(something))
            return Disposables.create()

        }
    }
</code></pre>

<p>is subscribe to this function:</p>

<pre><code>    func getRepo(_ repo: String) -&gt; Single&lt;[String: Any]&gt; {
        return Single&lt;[String: Any]&gt;.create { single in
            print(repo)
            let url = ""https://api.github.com/repositories?since=\(repo)""
            print(url)
            let task = URLSession.shared.dataTask(with: URL(string:url)!) { data, _, error in
                if let error = error {
                    single(.error(error))
                    return
                }
                guard let data = data,
                    let json = try? JSONSerialization.jsonObject(with: data, options: []),
                    let result = json as? [String: Any] else {
                        let error = NSError(domain: ""Decoding"", code: 0, userInfo: nil)
                        single(.error(error))
                        return
                }

                single(.success(result))
            }
            task.resume()
            return Disposables.create()
        }
    }
</code></pre>

<p>but for some reason the subscription it never gets a call back. Any of you knows why the subscription never gets a call back?</p>

<p>I'll really appreciate your help.</p>
","2924482","","","","","2020-01-30 21:44:45","RXSwift: Subscriber never gets call back","<ios><rx-swift><xcode11><swift5.2>","1","1","","","","CC BY-SA 4.0"
"59960014","1","59966228","","2020-01-29 03:11:04","","1","407","<p>I'm a begginer with RxSwift and this is my issue, my app must do a 3 requests, the 3 are <code>gets</code>, my work team suggests me use a <code>flatmap</code> to do this a three request in row, but I don't know how I should use flatmap.</p>

<p>these are my requests</p>

<pre><code>public func login(param: [String:String]) -&gt; Observable&lt;messageModel&gt;{
        return Observable.create { observer -&gt; Disposable in
            self.alamoFireManager!.request(self.urlServer!+endPoints.login.login, method: .post, parameters: param, encoding: URLEncoding.default, headers: nil, interceptor: nil).responseDecodable { (res: DataResponse&lt;messageModel,AFError&gt;) in
                if let error = res.error {
                    observer.onError(error)
                } else if let valueEntitie = res.value {
                    observer.onNext(valueEntitie)
                }
                observer.onCompleted()
            }
            return Disposables.create()
        }
    }


public func me()  -&gt; Observable&lt;meModel&gt;{
        return Observable.create { observer -&gt; Disposable in
            self.alamoFireManager!.request(self.urlServer!+endPoints.login.me, method: .get, parameters: nil, encoding: URLEncoding.default, headers: nil, interceptor: nil).responseDecodable { (res: DataResponse&lt;meModel,AFError&gt;) in
                if let error = res.error {
                    observer.onError(error)
                } else if let valueEntitie = res.value {
                    observer.onNext(valueEntitie)
                }
                observer.onCompleted()
            }
            return Disposables.create()
        }
    }


public func entitie(entityId: String) -&gt; Observable&lt;entitieModel&gt;{
        return Observable.create { observer -&gt; Disposable in
            self.alamoFireManager!.request(self.urlServer!+endPoints.login.entities+""/""+entityId, method: .get, parameters: nil, encoding: URLEncoding.default, headers: nil, interceptor: nil).responseDecodable { (res: DataResponse&lt;entitieModel,AFError&gt;) in
                if let error = res.error {
                    observer.onError(error)
                } else if let valueEntitie = res.value {
                    observer.onNext(valueEntitie)
                }
                observer.onCompleted()
            }
            return Disposables.create()
        }
    }
</code></pre>

<p>the first endpoint is <code>login</code> with its parameters, then <code>me</code>, function <code>me</code> response a id, this id its necessary for the third request, that is <code>entitie</code>.</p>

<p>I'm doing the flatmap as this way.</p>

<pre><code>networkManagerShareCore.share.login(param: param)
                .flatMap { resMessageModel in
                    //saveData(resMessageModel)
                    networkManagerShareCore.share.me()
                        .flatMap { resMeModel in
                         //saveData(resMessageModel)
                         networkManagerShareCore.share.entitie(entityId: ""\(resModelMe.data.personId!)"")
                    }
            }.subscribe(onNext: { (model) in
                print(model)
            }, onError: { (error) in
                self.errorMsg.accept(error.localizedDescription)
                self.isSuccess.accept(false)
            }, onCompleted: nil) {
                print(""Disposed"")
            }
</code></pre>

<p>the code works, but in the line <code>//saveData(resMessageModel)</code> I can't call it the function, I want to save the model, but if I try a call a function, Xcode show me this error: <code>Unable to infer complex closure return type; add explicit type to disambiguate</code>
so, how can I resolve this? </p>
","12770205","","12770205","","2020-01-29 04:22:25","2020-01-29 11:34:05","call func in Asynchronous requests chaining RxSwift and Alamofire","<swift><alamofire><rx-swift>","2","1","","","","CC BY-SA 4.0"
"59967722","1","","","2020-01-29 13:02:30","","1","95","<p>I'm having problems with deallocating an observable, even using a disposedBag. <strong>It only occurs in iOS 10.</strong></p>

<p>I have to associate a TextField (SwiftMaskField) value to a variable at viewModel, so I'm doing:</p>

<pre><code>class BaseViewController: UIViewController, Storyboarded {

    @IBOutlet weak var txtField: SwiftMaskField!

    var viewModel: BaseViewModel!

    override func viewDidLoad() {
        super.viewDidLoad()

        bindUI()
    }

    private func bindUI() {
        txtField.rx.text.orEmpty.bind(to: viewModel.myString).disposed(by: viewModel.bag)

        viewModel.showLoading.asObservable().skip(1).subscribe(onNext: { [unowned self] in
            self.showLoading()
        }).disposed(by: viewModel.bag)
    }

    ...
}

</code></pre>

<pre><code>class BaseViewModel {
    var showLoading = BehaviorRelay&lt;Void&gt;(value: ())
    var myString = BehaviorRelay&lt;String&gt;(value:"""")

    let bag = DisposeBag()

    func foo() {
        showLoading.accept(())
    }

    func foo2() {
        print(myString.value)
    }

    ...
}
</code></pre>

<h3>When I do a <strong><em>popViewController</em></strong>, my app crashes with the following error:</h3>

<blockquote>
  <p>*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'An instance
  0x7fbaafe45a20 of class SwiftMaskText.SwiftMaskField was deallocated
  while key value observers were still registered with it. Current
  observation info:  (
   Context: 0x0,
  Property: 0x6000002596e0> )'</p>
  
  <hr>
</blockquote>

<p>It only occurs in iOS 10 (haven't tested previous versions), further versions don't crash.</p>

<p>Also, I'm using RxSwift 5.0.</p>
","12070365","","12299030","","2020-01-29 13:29:24","2020-01-30 12:59:23","popViewController throwing ""deallocated while key value observers were still registered"" error","<ios><swift><rx-swift><swift5>","1","0","","","","CC BY-SA 4.0"
"59980167","1","","","2020-01-30 06:23:11","","2","898","<p>I'm new to RxSwift and RxCocoa. In my project, UIButton tap event is handled with <code>rx.tap.asDriver()</code> in many places but I wander that <code>Signal</code> is better in that case.</p>

<p>My recognition is:</p>

<ul>
<li>Driver is for state or variable</li>
<li>Signal is for event</li>
</ul>

<p>Please give me advice. Thanks</p>
","2010036","","","","","2020-01-31 02:08:29","Which is better Driver and Signal for UIButton tap event?","<rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"60003144","1","60017280","","2020-01-31 11:35:26","","1","52","<p>I am designing a call manager with the help of <strong>RXSwift</strong> (ReactiveX) that continuously interacts with an API. The call manager comprises several objects that itself comprises an <code>indicator</code> (indicating status information loaded from the API) and <code>control</code> (requests to be sent to the API).</p>

<pre><code>class CallManagerObjectA() {
  var control = PublishSubject&lt;String&gt;()
  var indicator = BehaviorSubject&lt;String&gt;(value: ""string status"")
}
</code></pre>

<p>Within the call manager, a scheduler regularly provides new values to the indicator observable:</p>

<pre><code>&lt;... API response ...&gt;
indicator.onNext(newValue)
</code></pre>

<p>Somewhere else in a view controller, the indicator will be observed for a label:</p>

<pre><code>indicator.subscribe(onNext: { label.stringValue = $0 })
</code></pre>

<p>Within the same view controller, the user can control the object status via GUI elements continuously:</p>

<pre><code>control.onNext(commandValue)
</code></pre>

<p>Within the call manager, the control will be observed for an API call:</p>

<pre><code>control.subscribe(onNext: { (command) in
  // API request call 
})
</code></pre>

<p>So far so good, this is working very well with reactive patterns. 
Now, I am looking for a good solution to handle errors, if the call manager recognizes errors during the API interaction and show these errors to the user in the view controller. I was immediately thinking of something like this:</p>

<pre><code>// Call manager recognizes the error
control.onError(error)

...

// Call manager ignores errors for the subscriber
control.retry().ignoreErrors().subscribe(onNext: { (command) in
  // API request call 
})

...

// View controller shows the errors
indicator.subscribe(onNext: { label.stringValue = $0 })
control.subscribe(onError: { print(""error"", $0) })
</code></pre>

<p>This however ends up in an infinite loop.
I fear that I have a fundamental understanding issue with reactive programming, or I miss something very important, but I am not able to understand how the handle errors in this reactive pattern environment. </p>
","873072","","873072","","2020-01-31 22:26:14","2020-02-01 13:23:34","Reactive asynchronous feedback system with RxSwift","<swift><reactive-programming><rx-swift><reactive><reactivex>","1","2","","","","CC BY-SA 4.0"
"60020711","1","60027857","","2020-02-01 20:10:21","","1","578","<p>I have a collection view in my app, and it would refresh with animation when there is new content or deletion. However, I don't want it to refresh while user is scrolling because it would cause jerking. I want to refresh the collection view only when user has finished scrolling / when it's not scrolling.</p>

<p>So I have a data source driver, and I tried to use <code>filter</code> to make it wait till it becomes true but no luck.</p>

<p>This is my scrolling driver that I pass to the <code>ViewModel</code></p>

<pre><code>let isScrollViewScrollingDriver = Observable.merge(
            gridCollectionView.rx.willBeginDragging.map { _ in true },
            gridCollectionView.rx.didEndDragging.map { _ in false }
        ).asDriver(onErrorJustReturn: false).startWith(false).distinctUntilChanged()
</code></pre>

<p>my ViewModel init in view controller</p>

<pre><code>viewModel = ViewModel(
            photoLibraryService: PhotoLibraryService.shared,
            isGridViewScrolling: isScrollViewScrollingDriver,
            disposeBag: disposeBag
        )
</code></pre>

<p>My ViewModel</p>

<pre><code>let assetDriver = photoLibraryService.albumDriver.asObservable()
                .withLatestFrom(
                    isGridViewScrolling.asObservable().filter { $0 == false }
                ) { (arg0, arg1) in
                    return arg0
                }.flatMapLatest { libraryAlbum -&gt; Observable&lt;[LibraryAsset]&gt; in
                    return photoLibraryService.convert(album: libraryAlbum)
                }.asDriver(onErrorJustReturn: []).startWith([]).distinctUntilChanged()
</code></pre>

<p>And then I map assetDriver to a dataSourceDriver that drive my collection view.</p>

<p>What changes can I make to the assetDriver to make it wait for <code>isGridViewScrolling</code> to become <code>false</code>? Thanks.</p>
","2577123","","","","","2020-02-05 19:44:49","How to throttle observable until a condition becomes true","<ios><swift><system.reactive><rx-swift><rx-cocoa>","2","2","1","","","CC BY-SA 4.0"
"60026659","1","","","2020-02-02 13:40:15","","1","183","<p>I have a case where I would like to validate form and then if everything is ok go to api request.</p>

<p>I've written some code and it works fine but errors dispose my stream. I know I could add .catch error at the end of flat map but then next flat map would be executed. </p>

<p>Can I add catch error at the end of stream without disposing it? Or the only way to deal with it is separate it to two streams validation and server responses?</p>

<pre><code>        enum Response {
            case error(message: String)
            case success
        }

        let start = input.validate
            .withLatestFrom(input.textFields)
            .flatMap { [unowned self] fields -&gt; Observable&lt;String&gt; in
                return self.validate(characters: fields)
            }
        .flatMapLatest { [unowned self] code -&gt; Observable&lt;String&gt; in
            return self.apiClient.rxSendData(code)
                .retry(1)
        }
        .map { _ in return Response.success }
        .asDriver { Driver.just(Response.error(message: $0.localizedDescription)) }
</code></pre>
","2493555","","2493555","","2020-02-03 07:10:09","2020-02-06 03:57:29","RxSwift form validation and sending request in one stream","<rx-swift>","2","2","","","","CC BY-SA 4.0"
"60030921","1","","","2020-02-02 21:47:31","","1","541","<p>Can anybody tell me if it is possible to create a deferred completable in a concat operator. </p>

<p>I want to fetch a session, and after this load a user with the corresponding session id. </p>

<pre><code>SessionAPI.post(email: email, password: password)
UserAPI.get(id: Session.load()!.userId)
</code></pre>

<p>Until now I used observables with the flatMap operator.</p>

<p>I will now try to reproduce the same behaviour with the completables, which doesn't have flatMap operator. </p>

<p>Working code with observables:</p>

<pre><code>SessionAPI.post(email: email, password: password)
          .flatMap { (_) -&gt; Single&lt;Any&gt; in
              return UserAPI.get(id: Session.load()!.userId)
          }
</code></pre>

<p>New working code with completables</p>

<pre><code>SessionAPI.post(email: email, password: password)
          .concat(Completable.deferred { UserAPI.get(id: Session.load()!.userId) } )
</code></pre>

<p>I now want to create an extension for this deferred completable, like:</p>

<pre><code>SessionAPI.post(email: email, password: password)
          .concatDeferred(UserAPI.get(id: Session.load()!.userId))
</code></pre>

<p>Current extension:</p>

<pre><code>extension PrimitiveSequenceType where Self.Element == Never, Self.Trait == RxSwift.CompletableTrait {

    func concatDeferred(_ second: RxSwift.Completable) -&gt; RxSwift.Completable {
        return Completable.deferred { () -&gt; PrimitiveSequence&lt;CompletableTrait, Never&gt; in
            return second
        }
    }
}
</code></pre>

<p><strong>Issue:</strong> The Session.load()! in UserAPI.get is loaded and crashing before SessionAPI.post finished.</p>

<p>Does someone got an idea to get this extension up running?</p>

<p>Thanks!</p>
","7766093","","","","","2020-02-03 11:55:09","RxSwift: Completable concat in a deferred way","<swift><rx-swift><swift-extensions>","1","0","","","","CC BY-SA 4.0"
"60034705","1","","","2020-02-03 07:19:28","","0","87","<p>I am trying to bind a delegate this is what was done</p>

<pre><code>/** Delegate Proxy **/
func castOrThrow&lt;T&gt;(_ resultType: T.Type, _ object:Any) throws -&gt; T {
    guard let returnValue = object as? T else {
        throw RxCocoaError.castingError(object: object, targetType: resultType)
    }
    return returnValue
}
@objc
public protocol TestEventGeneratorDelegate:class {
    @objc optional func asyncEventResult(int:Int)
}
open class TestEventGenerator {
    public var delegate: TestEventGeneratorDelegate?
    func asyncCall() {
        DispatchQueue.global().asyncAfter(deadline: .now() + .seconds(1)) { [weak self] in
            guard let self = self else  { return }
            self.delegate?.asyncEventResult!(int: 0)
        }
    }
}
extension TestEventGenerator: HasDelegate {
    public typealias Delegate = TestEventGeneratorDelegate
}
open class RxTestDelegateProxy : DelegateProxy&lt;TestEventGenerator,TestEventGeneratorDelegate&gt;,
                                DelegateProxyType,
                                TestEventGeneratorDelegate {
    public weak private(set) var testGenerator: TestEventGenerator?
    public init(testEventGenerator: ParentObject) {
        self.testGenerator = testEventGenerator
        super.init(parentObject: testEventGenerator, delegateProxy: RxTestDelegateProxy.self)
    }
    public static func registerKnownImplementations() {
        self.register { RxTestDelegateProxy(testEventGenerator: $0) }
    }
}
extension Reactive where Base: TestEventGenerator {
    public var delegate: DelegateProxy&lt;TestEventGenerator, TestEventGeneratorDelegate&gt; {
        return RxTestDelegateProxy.proxy(for: base)
    }
    public var asyncEventResult: Observable&lt;Int&gt; {
        let source =  delegate.methodInvoked(#selector(TestEventGeneratorDelegate.asyncEventResult(int:)))
        .map { (a) in
            return try castOrThrow(Int.self,a[0])
        }
        return source
    }
}
/**  Delegate Proxy **/
</code></pre>

<p>Then when I use it</p>

<pre><code>let testEventGenerator = TestEventGenerator()
textEventGenerator.rx.asyncEventResult.subscribe.... // subscribe here no rx found? 
testEventGenerator.asyncCall() // call and wait for the observable to return to the delegate 
</code></pre>

<p>It doesn't compile and says there is no such rx</p>

<p>I have to bind it because the person who wrote the API didn't use a callback to return the value but rather a delegate.</p>

<p>This is example of how he wrote the code and how I want to wrap it.</p>

<p>Is there a way to bind a delegate that requires a kick off from asyncCall()? </p>

<p>so I can chain it using flatmapLatest in a promiseLike way?</p>

<p>Thanks let me know!</p>

<p>I followed these tutorial:
<a href=""https://stackoverflow.com/questions/51816144/how-to-convert-delegate-to-observable-rxswift"">How to convert Delegate to Observable RxSwift?</a>
and
<a href=""https://blog.ippon.fr/2018/11/13/rxswift-how-to-make-your-favorite-delegate-based-apis-reactive/"" rel=""nofollow noreferrer"">https://blog.ippon.fr/2018/11/13/rxswift-how-to-make-your-favorite-delegate-based-apis-reactive/</a></p>
","895550","","","","","2020-02-03 08:06:06","RxSwift Delegate Binding isn't Generated?","<rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"60049470","1","60057225","","2020-02-04 01:44:20","","2","159","<p>Here's my code snippet:</p>

<pre><code>open class SomeClass {
  let driver: Driver&lt;Bool&gt;
  init(input: Observable&lt;String&gt;) {
    driver = input
      .map( { s -&gt; Bool in self.convert(text: s) }) // error 'self' captured by a closure before all members were initialized
    .asDriver(onErrorJustReturn: false)
  }

  func convert(text: String) -&gt; Bool {
    // Do some complex calculation
    return true
  }
}
</code></pre>

<p>Explanation: In my SomeClass, I have a <code>driver</code> object of type <code>Driver&lt;Bool&gt;</code>, then inside my <code>init</code>, I'll take an <code>Observable&lt;String&gt;</code> and map it to a <code>Observable&lt;Bool&gt;</code>. 
However in order to do the conversion I need to call the func <code>convert()</code> inside the mapping closure, thus I'm getting the error </p>

<blockquote>
  <p>'self' captured by a closure before all members were initialized</p>
</blockquote>

<p>Can someone please show me how to get through this?</p>
","1941968","","","","","2020-02-04 12:24:01","RxSwift - Construct the Observable using function inside transform function","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"60051420","1","60079627","","2020-02-04 05:59:01","","0","831","<p>I have just created my first project in <code>RxSwift</code>. The sample project named is <code>RxSwift</code> and added below pods in <code>Podfile</code> following the <a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow noreferrer"">guidelines here</a>.</p>
<h3>Podfile:</h3>
<pre><code># Podfile
use_frameworks!

target 'RxSwift' do
    pod 'RxSwift', '~&gt; 5'
    pod 'RxCocoa', '~&gt; 5'
end

# RxTest and RxBlocking make the most sense in the context of unit/integration tests
target 'RxSwiftTests' do
    pod 'RxBlocking', '~&gt; 5'
    pod 'RxTest', '~&gt; 5'
end
</code></pre>
<h3>RxSwift - Host App:</h3>
<p>I have just added <code>import RxCocoa</code> in my <code>ViewController</code> (of default sample template) and tried to build. Result is a build error. <strong>What am I missing?</strong></p>
<h3>Build Error:</h3>
<blockquote>
<p>error: Segmentation fault: 11 (in target 'RxSwift' from project 'RxSwift')</p>
</blockquote>
<p><strong>Details</strong>:</p>
<pre><code>0  swift                    0x0000000104e4eeb3 PrintStackTraceSignalHandler(void*) + 51
1  swift                    0x0000000104e4e686 SignalHandler(int) + 358
2  libsystem_platform.dylib 0x00007fff75877b5d _sigtramp + 29
3  libsystem_platform.dylib 000000000000000000 _sigtramp + 2323154112
4  swift                    0x00000001017645ff swift::SerializedModuleLoaderBase::loadModule(swift::SourceLoc, llvm::ArrayRef&lt;std::__1::pair&lt;swift::Identifier, swift::SourceLoc&gt; &gt;) + 463
5  swift                    0x000000010158a340 swift::performNameBinding(swift::SourceFile&amp;, unsigned int) + 3136
6  swift                    0x0000000100da7c08 swift::CompilerInstance::performSemaUpTo(swift::SourceFile::ASTStage_t) + 3608
7  swift                    0x0000000100a9db6f performCompile(swift::CompilerInstance&amp;, swift::CompilerInvocation&amp;, llvm::ArrayRef&lt;char const*&gt;, int&amp;, swift::FrontendObserver*, swift::UnifiedStatsReporter*) + 815
8  swift                    0x0000000100a9a034 swift::performFrontend(llvm::ArrayRef&lt;char const*&gt;, char const*, void*, swift::FrontendObserver*) + 6820
9  swift                    0x0000000100a275a3 main + 1219
10 libdyld.dylib            0x00007fff7568c3d5 start + 1
11 libdyld.dylib            0x000000000000005d start + 2325167241
error: Segmentation fault: 11 (in target 'RxSwift' from project 'RxSwift')
</code></pre>
<hr />
<p><strong>Note:</strong> I have not modified anything in host app side. I just imported <code>RxCocoa</code> in my <code>ViewController</code>. Also when I delete the import statement from the ViewController class, build is succeeding.</p>
","1084174","","-1","","2020-06-20 09:12:55","2020-02-06 05:58:06","error: Segmentation fault: 11 (in target 'RxSwift' from project 'RxSwift')","<ios><xcode><build><rx-swift><reactive>","1","2","","","","CC BY-SA 4.0"
"60057184","1","60057349","","2020-02-04 12:12:47","","1","1677","<p>I am getting below build error for <code>RxSwift</code>,</p>

<pre><code>func testFlatMap() {

    let bag = DisposeBag()
    let subject = PublishSubject&lt;String&gt;.init()

    subject.flatMap({ (value) -&gt; String in
            PublishSubject.just(value)
        }).subscribe(

        onNext: { value in
            print(value)
        }

    ).disposed(by: bag)

    subject.on(.next(""Test""))
}
</code></pre>

<blockquote>
  <p>Instance method 'flatMap' requires that 'String' conform to 'ObservableConvertibleType'</p>
</blockquote>

<p><strong>What am I missing?</strong></p>
","1084174","","","","","2020-02-04 12:21:59","Instance method 'flatMap' requires that 'String' conform to 'ObservableConvertibleType'","<ios><build><rx-swift><flatmap><map-api>","1","0","","","","CC BY-SA 4.0"
"60067645","1","60068278","","2020-02-05 00:59:48","","0","71","<p>Given the design pattern as described by <a href=""https://medium.com/blablacar-tech/rxswift-mvvm-66827b8b3f10"" rel=""nofollow noreferrer"">this post</a>, here is an <a href=""https://gist.github.com/MartinMoizard/4d66528a9959cbbdefa6d50394d2bfb1#file-sayhelloviewmodel-swift"" rel=""nofollow noreferrer"">example view model:</a></p>

<pre class=""lang-swift prettyprint-override""><code>final class SayHelloViewModel: ViewModelType {
    let input: Input
    let output: Output

    struct Input {
        let name: AnyObserver&lt;String&gt;
        let validate: AnyObserver&lt;Void&gt;
    }

    struct Output {
        let greeting: Driver&lt;String&gt;
    }

    private let nameSubject = ReplaySubject&lt;String&gt;.create(bufferSize: 1)
    private let validateSubject = PublishSubject&lt;Void&gt;()

    init() {
        let greeting = validateSubject
            .withLatestFrom(nameSubject)
            .map { name in
                return ""Hello \(name)!""
            }
            .asDriver(onErrorJustReturn: "":-("")

        self.output = Output(greeting: greeting)
        self.input = Input(name: nameSubject.asObserver(), validate: validateSubject.asObserver())
    }
}
</code></pre>

<p>The above seems like a perfectly good design pattern.  My only issue is, what happens when your mapping function from <code>nameSubject</code> -> <code>greeting</code> is more complex than what is shown here and instead needs to be abstracted into it's own function?  </p>

<p>In the below scenario, i've abstracted the mapping functionality into its own function called <code>sayHello.</code> Of course, the issue now is that we're referencing self before self is initialised. How is it possible to maintain this design pattern across non-trivial examples?</p>

<pre class=""lang-swift prettyprint-override""><code>final class SayHelloViewModel {
    let input: Input
    let output: Output

    struct Input {
        let name: AnyObserver&lt;String&gt;
        let validate: AnyObserver&lt;Void&gt;
    }

    struct Output {
        let greeting: Driver&lt;String&gt;
    }

    private let nameSubject = ReplaySubject&lt;String&gt;.create(bufferSize: 1)
    private let validateSubject = PublishSubject&lt;Void&gt;()

    init() {
        let greeting = validateSubject
            .withLatestFrom(nameSubject)
            .map(sayHello)
            .asDriver(onErrorJustReturn: "":-("")
        self.output = Output(greeting: greeting)
        self.input = Input(name: nameSubject.asObserver(), validate: validateSubject.asObserver())
    }

    private func sayHello(name: String) -&gt; String {
        return ""Hello \(name)!""
    }
}
</code></pre>
","2990789","","","","","2020-02-05 02:54:33","RxMVVM using Inputs / Outputs and issues with complex mapping","<swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"60089331","1","60095215","","2020-02-06 06:59:32","","1","310","<p>Differences between <code>map</code> and <code>flatMap</code> of <code>RxSwift</code> has been explained <a href=""https://stackoverflow.com/a/49779175/1084174"">here</a>. Now I want to observe the upper observable instance when the changes happen to it's inner observable. <strong>How can I do so?</strong> </p>

<p>Let's see the example,</p>

<pre><code>func testFlatMap() {

    let bag = DisposeBag()

    struct Player {
        var age: Int
        var score: BehaviorSubject&lt;Int&gt;
    }

    let male = Player(age: 28, score: BehaviorSubject(value: 80))

    let player = PublishSubject&lt;Player&gt;()

    player.asObservable()
        .flatMap { $0.score.asObservable() }
        .subscribe(onNext: { print($0) })
        .disposed(by: bag)

    player.on(.next(male))
    male.score.on(.next(100))
}
</code></pre>

<p>In this above example the output is,</p>

<pre><code>80
100
</code></pre>

<p>as expected. But I want to know the the full Player object status (i.e. <code>age</code> of the player) inside subscribe block <code>.subscribe(onNext: { print($0) })</code> but it's only getting the <code>score</code>. <strong>How can I do so?</strong></p>

<p>My expected output is,</p>

<pre><code>Player (where I can access both age:28 and score:80)
Player (where I can access both age:28 and score:100)
</code></pre>
","1084174","","1084174","","2020-02-06 07:28:48","2020-02-06 12:38:26","How to observe upper Observables with flatMap in RxSwift?","<ios><swift><reactive-programming><rx-swift><flatmap>","2","0","","","","CC BY-SA 4.0"
"60095172","1","","","2020-02-06 12:35:39","","2","95","<p>Let me show a simplified example of the problem I'm struggling with:</p>

<pre><code>class CarService {

    func getCars() -&gt; Single&lt;[Car]&gt; {
        return Single.create { observer in
            // Here we're using a thread that was defined in subscribeOn().
            someCallbackToAPI { cars in
                // Here we're using main thread, because of the someCallbackToAPI implementation.
                observer(.success(cars))
            }
        }
    }
}

class CarRepository {

    func syncCars() -&gt; Completable {
        return CarService().getCars()
            .flatMapCompletable { cars in
                // Here we're using main thread, but we want some background thread.
                saveCars(cars)
            }
    }
}

class CarViewController {

    func loadCar() {
        CarRepository().syncCars()
            .subscribeOn(someBackgroundScheduler)
            .observeOn(MainThread)
            .subscribe()
    }
}
</code></pre>

<p>From the bottom: <code>CarViewController</code> wants to sync all the cars from some external API. It defines what thread should be used for the sync with <code>subscribeOn</code> - we don't want to block the UI thread. Unfortunately, underneath, the <code>CarService</code> has to use some external library methods (<code>someCallbackToAPI</code>) that always returns the result in a main thread. The problem is that after receiving the result, all methods below like e.g. <code>saveCars</code> are called in the same main thread. <code>saveCars</code> may block the UI thread because it saves data to database. Of course I could add <code>observeOn</code> between threads between <code>CarService().getCars()</code> and <code>flatMapCompletable</code>, but I want the <code>CarRepository</code> to be dump and know nothing about the threads. It is the <code>CarViewController</code> responsibility to define working thread.</p>

<p>So my question is, is it a way I could get the scheduler passed in <code>subscribeOn</code> method and switch back to the scheduler after receiving the result from <code>someCallbackToApi</code>?</p>
","4386668","","","","","2020-02-06 15:08:29","Get scheduler passed to subscribeOn() while creating Observable/Single","<ios><swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"60095458","1","60098248","","2020-02-06 12:52:22","","2","160","<p>My <code>RxSwift</code> code is,</p>

<pre><code>func testOperators(){

    let bag = DisposeBag()

    let observable1 = PublishSubject&lt;String&gt;()
    let observable2 = PublishSubject&lt;String&gt;()

    Observable.concat([observable1, observable2])
        .subscribe(onNext: { (value) in
            print(value)
        }).disposed(by: bag)

    observable1.on(.next(""1""))
    observable1.on(.next(""2""))

    observable2.on(.next(""3""))
    observable2.on(.next(""4""))

    observable1.on(.completed)
    observable2.on(.completed)
}
</code></pre>

<p>Current output is,</p>

<pre><code>1
2
</code></pre>

<p>My expected output is,</p>

<pre><code>1
2
3
4
</code></pre>

<p><strong>What am I missing &amp; what I can add/edit to get the expected output?</strong></p>
","1084174","","9863222","","2020-02-15 12:10:17","2020-02-15 12:10:17","Why RxSwift concat with multiple observables does not seem to work?","<ios><swift><observable><concat><rx-swift>","2","0","","","","CC BY-SA 4.0"
"60102449","1","60105597","","2020-02-06 19:46:32","","3","296","<p>I'm trying to figure out if I'm creating a retain cycle here. I want to bind the current offset of the collection view to a <code>UIPageControl</code> with the following:</p>

<pre><code>collectionView
    .rx
    .contentOffset
    .asDriver()
    .map { Int($0.x) / Int(self.collectionView.frame.width) }
    .drive(pageControl.rx.currentPage)
    .disposed(by: disposeBag)
</code></pre>

<p>Just wondering if this is ok, or if that self will create a retain cycle?</p>
","3320342","","","","","2020-02-07 11:39:50","RxSwift asDriver map and strong self","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"60144158","1","","","2020-02-10 04:39:09","","0","129","<p>I am trying to bind single <code>UITableView</code> with 2 data sources.
My code is like this</p>

<pre><code>viewModel?.dataSource?.currentYear?.bind(to: tableViewMonths, cellType: StatementExportMonthTableViewCell.self) { (cell, name) in
            cell.updateWith(month: name)
        }

viewModel?.dataSource?.previousYear?.bind(to: tableViewMonths, cellType: StatementExportMonthTableViewCell.self) { (cell, name) in
            cell.updateWith(month: name)
        }
</code></pre>

<p>I cant figure out how to show correct data into table view based on selected segment index.
I know i can define one main data source and based on segment selection I should assign respective data source to that instance and reload tableview from that.</p>

<p>But I am trying to simplify it if Bond already has that functionality in-built.</p>

<p>Any help here would be much appreciated.</p>

<p>Thanks</p>
","2768604","","","","","2020-02-10 04:39:09","Bind single tableview for 2 data sources and update based on selected segment with Bond","<swift><xcode><reactive-programming><rx-swift><swiftbond>","0","3","1","","","CC BY-SA 4.0"
"60168873","1","60175443","","2020-02-11 12:32:21","","0","1454","<p>I'm trying to detect a double tap with RxSwift</p>

<p>Without RxSwift I would something like this: </p>

<pre><code>private func setupFakePanView() {
    let singleTapGesture = UITapGestureRecognizer()
    let doubleTapGesture = UITapGestureRecognizer()

    singleTapGesture.numberOfTapsRequired = 1
    doubleTapGesture.numberOfTapsRequired = 2

    singleTapGesture.addTarget(self, action: #selector(self.tapped))
    doubleTapGesture.addTarget(self, action: #selector(self.doubleTapped))

    someView.addGestureRecognizer(singleTapGesture)
    someView.addGestureRecognizer(doubleTapGesture)

    singleTapGesture.require(toFail: doubleTapGesture)
}

@objc private func tapped() {
    // Do something
}

@objc private func doubleTapped() {
    // Do something else
}
</code></pre>

<p>Is there a way I could achieve the same with RxSwift, RxCocoa and <a href=""https://github.com/RxSwiftCommunity/RxGesture"" rel=""nofollow noreferrer"">RxGesture</a>? I've tried the following but of course it doesn't work:</p>

<pre><code>someView.rx
    .tapGesture(numberOfTouchesRequired: 1, numberOfTapsRequired: 1)
    .when(.recognized)
    .subscribe(onNext: { _ in
        // Do something
    })
    .disposed(by: bag)

someView.rx
    .tapGesture(numberOfTouchesRequired: 1, numberOfTapsRequired: 2)
    .when(.recognized)
    .subscribe(onNext: { _ in
        // Do something else
    })
    .disposed(by: bag)
</code></pre>

<p>Is there way to let the first tapGesture know the second has to fail?</p>
","672989","","672989","","2020-02-11 16:15:33","2020-02-12 02:07:33","How to detect double tap with RxSwift","<ios><swift><rx-swift><rx-cocoa>","2","6","","","","CC BY-SA 4.0"
"60180775","1","60207482","","2020-02-12 03:42:39","","1","39","<p>I'm trying to add a feature to show loading screen to this code:</p>

<pre><code>func connect(with code: String) {
    interactor.connect(with: code)
        .subscribe(onNext: { displaySuccessScreenRelay.accept(()) },
                   onError: { displayErrorScreenRelay.accept(()) } )
        .disposed(by: disposeBag)
}
</code></pre>

<p>I've made a behavior relay called <code>loadingScreenShownRelay</code> ad I know the proper way to do this is like this:</p>

<pre><code>func connect(with code: String) {
    loadingScreenShownRelay.accept(true)
    interactor.connect(with: code)
        .subscribe(onNext: { 
                       displaySuccessScreenRelay.accept(())
                       loadingScreenShownRelay.accept(false)
                   },
                   onError: { 
                       displayErrorScreenRelay.accept(()) 
                       loadingScreenShownRelay.accept(false)
        })
        .disposed(by: disposeBag)
}
</code></pre>

<p>Now the question is how do I rearrange the test so that I can test not only the logic but the order of showLoading -> success -> hideLoading?</p>

<p>I can probably test the displays and loadingScreenShown observables separately into 2 tests (ie. one to test the logic of <code>input-&gt; emit display success / error</code> and one more to test the <code>loadingScreenShown</code>). But how do I know that the order was indeed <code>showLoading -&gt; success -&gt; hideLoading</code> ? If I do the tests without regards to the order, I can also do this and the tests will still go green.</p>

<pre><code>func connect(with code: String) {
    loadingScreenShownRelay.accept(true)
    loadingScreenShownRelay.accept(false)
    interactor.connect(with: code)
        .subscribe(onNext: { displaySuccessScreenRelay.accept(()) },
                   onError: { displayErrorScreenRelay.accept(()) } )
        .disposed(by: disposeBag)
}
</code></pre>

<p>Thanks in advance.</p>
","4124849","","","","","2020-02-13 12:07:21","How do I test for flow / order of execution?","<swift><unit-testing><tdd><rx-swift>","1","0","","","","CC BY-SA 4.0"
"60182325","1","60187685","","2020-02-12 06:26:28","","2","450","<p><strong>Context:</strong> My team is starting a new medium size Swift project (<em>of around 20 MM</em>) and I am thinking to develop it in <code>RxSwift</code>. One of my managers suspects that once he had a bad experience about debugging on <strong>Reactive Programming</strong> so he suggests to avoid RxSwift and go with classical Swift. I am trying to find out the disadvantages of RxSwift and I found none of <a href=""https://stackoverflow.com/a/45938616/1084174"">them</a>, mentioned about the debuggability issues. </p>

<p><strong>Question:</strong> What are the factual technical limitations of RxSwift for debuggability?</p>
","1084174","","1084174","","2020-03-14 14:18:34","2020-03-14 14:52:14","What are the technical limitations of RxSwift for debuggability?","<swift><debugging><reactive-programming><rx-swift>","1","3","1","","","CC BY-SA 4.0"
"60228021","1","60228236","","2020-02-14 14:13:18","","0","2170","<p>I am trying to create function which return Observable&lt;(HTTPURLResponse, Any)> using RxAlamofire:</p>

<pre><code>func getResponse(credentialData: Credentials, ulr: String)-&gt;Observable&lt;(HTTPURLResponse, Any)&gt;{
        let credentialData = ""\(credentialData.username):\(credentialData.password)"".data(using: String.Encoding(rawValue: String.Encoding.utf8.rawValue))!
        let base64Credentials = credentialData.base64EncodedString()
        let headers = (""Authorization"", ""Basic \(base64Credentials)"")
        let header = HTTPHeaders.init(dictionaryLiteral: headers)

        return Observable.create{ observer in
            requestJSON(.get, ulr, parameters: nil, encoding: JSONEncoding.default, headers: header)
            .subscribe(onNext: { response in
                observer.onNext(response)
                } ,
        onError: { error in
            observer.onError(error)
            })
        return Disposables.create()
        }
    }    
}
</code></pre>

<p>but I get this below warning:-</p>

<blockquote>
  <p>Result of call to 'subscribe(onNext:onError:onCompleted:onDisposed:)'
  is unused</p>
</blockquote>

<p>How to fix it? After adding <code>.disposed(by: disposeBag)</code> my function isn't working.</p>
","12738240","","9863222","","2020-02-15 09:36:22","2020-02-15 09:36:22","Result of call to 'subscribe(onNext:onError:onCompleted:onDisposed:)' is unused","<swift><rx-swift><rxalamofire>","1","0","","","","CC BY-SA 4.0"
"60229451","1","60229573","","2020-02-14 15:44:54","","0","49","<p>I'm trying to create a function which returns <code>Observable&lt;(HTTPURLResponse, Any)&gt;</code> using <code>RxAlamofire</code>:</p>

<pre><code>class APIManager {
    let disposeBag = DisposeBag()
    func getResponse(credentialData: Credentials, ulr: String)-&gt;Observable&lt;(HTTPURLResponse, Any)&gt;{
    let credentialData = ""\(credentialData.username):\(credentialData.password)"".data(using: String.Encoding(rawValue: String.Encoding.utf8.rawValue))!
    let base64Credentials = credentialData.base64EncodedString()
    let headers = (""Authorization"", ""Basic \(base64Credentials)"")
    let header = HTTPHeaders.init(dictionaryLiteral: headers)
    return Observable.create{ observer in
        requestJSON(.get, ulr, parameters: nil, encoding: JSONEncoding.default, headers: header)
        .subscribe(onNext: { response in
            observer.onNext(response)
            } ,


    onError: { error in
        observer.onError(error)
        },
    onCompleted: {},
    onDisposed: {}).disposed(by: self.disposeBag)
    return Disposables.create()
    }
}    
</code></pre>

<p>}</p>

<p>The code into <code>onNext</code> is not executed; it's going through <code>onDisposed</code> only. </p>

<p>How can I fix it?</p>
","12738240","","4577897","","2020-02-14 16:13:38","2020-02-14 16:13:38","Created observable doesn't emit anything","<swift><rx-swift><rxalamofire>","1","1","","","","CC BY-SA 4.0"
"60233788","1","","","2020-02-14 21:31:20","","0","221","<p>I have an endpoint that returns the items of the current page. Also, if you want to get next page's items, you have to construct a URL with the next page's hash. This hash returns as property in the response of the previous request. As you understand, we need a recursive network call.</p>

<p>When a request finishes, a new request will begin until hash returns null through the response.</p>

<p>Then, I need to bind all collected data into an array.</p>

<p>How can I build something like that in RxSwift? I would appreciate if you describe that concept.</p>
","12900757","","9863222","","2020-02-20 08:05:15","2020-02-20 08:05:15","How to implement Recursive Paginated Network Call using RxSwift","<swift><pagination><rx-swift><reactive>","1","1","","","","CC BY-SA 4.0"
"60245723","1","","","2020-02-16 05:39:20","","1","779","<p>I am implementing a screen which is having a multi-section tableview and a submit button. </p>

<p>1.<strong>TableView</strong></p>

<p>a. First Section  -  Static Data ( Single Row with amount text input)</p>

<p>b. Second Section -  Dynamic Data (Multiple Rows with banks and radio buttons associate to each bank for selection)</p>

<p>2.<strong>Submit Button</strong> </p>

<p>Button is  enabled when amount text and bank selection by a radio button is done.</p>

<p>Here is the the code for Tableview DataSource, ViewModel and ViewController.</p>

<pre><code>       enum PaymentDetailsSections {
            case amountDetailsSection(items: [RowItems])
            case vpaListSection(title: String,items: [RowItems])
        }

        enum RowItems {
            case linkedVPAs(info:String)
            case paymentInfo


        }

        extension PaymentDetailsSections: SectionModelType {
            typealias Item = RowItems
            var items: [RowItems] {
                switch  self {
                case .amountDetailsSection(items: let items):
                    return items.map { $0 }
                case .vpaListSection(title: _, items: let items):
                    return items.map { $0 }

                }
            }
             init(original: PaymentDetailsSections, items: [Item]) {
                switch original {
                case .amountDetailsSection(items: _):
                    self = .amountDetailsSection(items: items)
                case let .vpaListSection(title, _):
                    self = .vpaListSection(title: title, items: items)
                }
            }
        }
        extension PaymentDetailsSections {
            var title: String {
                switch self {
                case .vpaListSection(title: let title, items: _):
                    return title
                case .amountDetailsSection:
                    return  """"
                }
            }
        }


 class PaymentViewModel {

        Struct Input{
          let tableviewFirstSectionTextFieldInput: Observable&lt;String&gt;
          let tableviewSecondSectionSelectAnyBank: Observable&lt;BankSelection&gt;
          let submitButtonOutSideTableView: Observable&lt;Void&gt;
          }

        Struct Output{
          let results: Observable&lt;Any&gt;        
        }

      let sections:[PaymentDetailsSections]
      var likedAccountsRowItems = [RowItems]()


      init(_service:Service) {

               let vpas = service.linkedVPAs()

                 for  account  in vpas {
                        self.likedAccountsRowItems.append(RowItems.linkedVPAs(info:account))
                  }


                self.sections = [.amountDetailsSection(items: [.paymentInfo]), 
               .vpaListSection(title:""Transfer From"", items:likedAccountsRowItems)]
        } 

  }      

        class PaymentController{

          override func viewDidLoad() {
                super.viewDidLoad()
                viewModel = PaymentViewModel()
                paymentListView.register(UINib(nibName:String(describing: SendMoneyAmountsDetailsCell.self), bundle:nil), forCellReuseIdentifier:String(describing: SendMoneyAmountsDetailsCell.self))
                paymentListView.register(UINib(nibName:String(describing: SendMoneyVPAListCell.self), bundle:nil), forCellReuseIdentifier:String(describing: SendMoneyVPAListCell.self))

                Observable.just(viewModel.sections)
                    .bind(to: paymentListView.rx.items(dataSource: self.datasource())).disposed(by: rx.disposeBag)
                paymentListView.rx.setDelegate(self).disposed(by: rx.disposeBag)
            }
             func datasource() -&gt; RxTableViewSectionedReloadDataSource&lt;PaymentDetailsSections&gt; {
               return RxTableViewSectionedReloadDataSource&lt;PaymentDetailsSections&gt;(
                    configureCell: { dataSource, table, idxPath, _ in
                        switch dataSource[idxPath] {
                        case  .paymentInfo:
                        if let cell = table.dequeueReusableCell(withIdentifier:String(describing:SendMoneyAmountsDetailsCell.self), for: idxPath) as? SendMoneyAmountsDetailsCell {
                            return cell
                            }
                        case .linkedVPAs(_):
                            if let cell =  table.dequeueReusableCell(withIdentifier:String(describing: SendMoneyVPAListCell.self), for: idxPath) as? SendMoneyVPAListCell {
                                return cell
                            }

                        }
                        return UITableViewCell()
                },
                    titleForHeaderInSection: { dataSource, index in
                        let section = dataSource[index]
                        return section.title
                }
                )
                }

        }
</code></pre>

<p>I couldn't find any solution using binding in ViewModel for input from the ViewController and make Ouput transformation. I would really appreciate any help, and thanks to anyone who contributes in advance!</p>
","6767616","","6767616","","2020-02-16 14:20:54","2020-02-16 14:20:54","ViewModel Inputs and Output for a multi-section tableview in RxSwift","<swift><mvvm><transformation><rx-swift>","1","1","0","","","CC BY-SA 4.0"
"60257051","1","60262593","","2020-02-17 06:35:21","","1","72","<p>I'm new to RxSwift and trying to implement this framework <a href=""https://github.com/rubygarage/collection-view-layouts"" rel=""nofollow noreferrer"">https://github.com/rubygarage/collection-view-layouts</a> into my project.</p>

<p>So far I've got this:</p>

<pre><code>extension BaseLayout: HasDelegate {
    public typealias Delegate = LayoutDelegate
}

class RxLayoutDelegateDelegateProxy: DelegateProxy&lt;BaseLayout, LayoutDelegate&gt;, DelegateProxyType, LayoutDelegate {
    public weak private(set) var baseLayout: BaseLayout?

    public init(baseLayout: ParentObject) {
        self.baseLayout = baseLayout
        super.init(parentObject: baseLayout,
                   delegateProxy: RxLayoutDelegateDelegateProxy.self)
    }

    static func registerKnownImplementations() {
        self.register { RxLayoutDelegateDelegateProxy(baseLayout: $0) }
    }
}

extension Reactive where Base: BaseLayout {

    public var delegate: DelegateProxy&lt;BaseLayout, LayoutDelegate&gt; {
        return RxLayoutDelegateDelegateProxy.proxy(for: base)
    }

    var cellSize: ControlEvent&lt;CGSize&gt; {

    }
}
</code></pre>

<p>But still can't figure out how I can pass image size once I've got pics. Can anyone help, please?
Thanks!</p>
","4156708","","","","","2020-02-17 12:33:41","Regular delegate and ProxyDelegate RxSwift","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"60273121","1","60279044","","2020-02-18 02:56:09","","0","755","<p>I did with below code for passing single parameter.</p>

<pre><code>lazy var priceListData: Observable&lt;FoodPrice&gt; = {
        return self.foodNamesparams1.asObservable()
                   .flatMapLatest(ApiCallViewModel.foodList(_:))
}
</code></pre>

<p>But I don't know how to pass multiple parameters..<br>
If I need to pass <code>foodNamesparams1</code>, <code>foodNamesparams2</code> to <code>ApiCallViewModel.foodList</code><br>
How can I do it with RxSwift? <br></p>

<p><code>foodNamesparams1</code> and <code>foodNamesparams2</code> both are <code>BehaviorRelay</code></p>
","10503150","","3359906","","2020-02-18 05:57:35","2020-02-18 10:44:25","How to pass multiple parameters with using RxSwift?","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"60327387","1","60355675","","2020-02-20 19:39:16","","0","264","<p>I want to modify the output by always adding <code>""+1""</code> at the end of each change. It works perfectly for <code>UITextField</code> but for the <code>UITextView</code> it's emitting infinite amount of times.</p>

<p>Can somebody explain how can I make UITextView behave the same as the UITextField in this example?</p>

<pre class=""lang-swift prettyprint-override""><code>import UIKit
import RxSwift
import RxCocoa

class ViewController: UIViewController {
    @IBOutlet private weak var textField: UITextField!
    @IBOutlet private weak var textView: UITextView!

    private let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()
        problem()
        noproblem()
    }

    //This will write infinite number of 111111111 after typing anything
    private func problem() {
        textView.rx.text.map { text in
                    return text! + ""1""
        }.asDriver(onErrorJustReturn: ""-"").drive(textView.rx.text).disposed(by: disposeBag)
    }

    //This will write 1 once per change, as expected!
    private func noproblem() {
        textField.rx.text.map { text in
                    return text! + ""1""
        }.asDriver(onErrorJustReturn: ""-"").drive(textField.rx.text).disposed(by: disposeBag)
    }

}
</code></pre>

<p>When I debug I see that <code>UITextView+Rx.swift</code> have a condition for that but debugger lies or it doesn't work:</p>

<p><a href=""https://i.stack.imgur.com/IeN0w.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/IeN0w.png"" alt=""enter image description here""></a>
<a href=""https://i.stack.imgur.com/00bpD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/00bpD.png"" alt=""enter image description here""></a></p>
","9763761","","","","","2020-02-22 18:59:05","RxSwift text ControlProperty have a different behaviour for UITextView and for UITextField","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"60327503","1","","","2020-02-20 19:48:46","","1","361","<p>I am trying to get the element of 2 observables produced asynchronously and pass them as parameters to a function once both are received.</p>

<p>However my map operator in my ViewModel below is not executed and the breakpoint just skips over it.</p>

<pre><code>ViewModel.swift

init(api: ApiService) {
        self.api = api
    }

func getData1() -&gt; Observable&lt;Data1&gt; {
        return api.getData1()
    }

    func getData2()  -&gt; Observable&lt;NewViewModel&gt; {
        return Observable.create { observer in

            let disposable = Disposables.create()
            self.api.getData2()
            .map {
                $0.arrayOfStuff.forEach { (stuff) in
                    let background = stuff.background

                let newViewModel = NewViewModel( background: self.spotlightBackground)
                observor.onNext(newViewModel)
                }
            return disposable
            }
        }
</code></pre>

<p>In my ViewController i am creating the <strong>Zip</strong> of the observables because newViewModel[getData2] may return later and i want to call the function when both observables emit a value</p>

<p>in my viewDidLoad() i setup zip by subscribing and adding observables</p>

<pre><code>let zippy = Observable.zip(viewModel.getData1(), viewModel.getData2()).subscribe(onNext: { (data1, newViewModel) in
            self.layoutSetUp(data1: data1, newViewModel: newViewModel)
            })
        zippy.disposed(by: disposeBag)
</code></pre>

<pre><code>
private func layoutSetUp(data1: Data1, newViewModel: NewViewModel) {


        DispatchQueue.main.async {
                self.view = SwiftUIHostingView(rootView: SwiftUIContentView(data1: data1, newViewModel: newViewModel))
        }
    }
</code></pre>

<p>This is not executing and no values are passed to function either and im not sure why</p>
","6891253","","","","","2020-02-21 00:35:16","Rxswift Map and Zip not Called","<swift><swiftui><rx-swift>","1","0","","","","CC BY-SA 4.0"
"60419374","1","60424567","","2020-02-26 17:28:17","","10","5429","<p>I am new to RxSwift programming.
I am confused between the two while coding. Which one should be used to store datasource of table and how to decide that ?</p>
","5944913","","4667835","","2020-02-27 14:28:40","2020-02-27 14:28:40","What is the difference between PublishSubject and PublishRelay in RxSwift?","<reactive-programming><rx-swift>","1","1","0","","","CC BY-SA 4.0"
"60467561","1","60470571","","2020-02-29 17:02:07","","1","301","<p>I have a function that creates and returns Observable that downloads and decodes data using URLSession. I wanted to write unit test for this function but have no idea how to tackle it.</p>

<p>function: </p>

<pre><code>func getRecipes(query: String, _ needsMoreData: Bool) -&gt; Observable&lt;[Recipes]&gt; {

        guard let url = URL(string: ""https://api.spoonacular.com/recipes/search?\(query)&amp;apiKey=myApiKey"") else {
            return Observable.just([])
        }

        return Observable.create { observer in
            let task = URLSession.shared.dataTask(with: url) { (data, response, error) in

                guard let data = data else {
                    return
                }

                do {
                    if self.recipes == nil {
                        self.recipes = try self.decoder.decode(Recipes.self, from: data)
                        self.dataList = self.recipes.results
                        self.baseUrl = self.recipes.baseUrl
                    } else {
                        if needsMoreData {
                            self.recipes = try self.decoder.decode(Recipes.self, from: data)
                            self.dataList.append(contentsOf: self.recipes.results.suffix(50))
                        } else {
                            self.dataList = try self.decoder.decode(Recipes.self, from: data).results
                        }
                    }
                    observer.onCompleted()
                } catch let error {
                    observer.onError(error)
                }
            }
            task.resume()

            return Disposables.create {
                task.cancel()
            }
        }
        .trackActivity(activityIndicator)
    }
</code></pre>
","7367227","","","","","2020-03-01 13:13:09","Write unit test for function that uses URLSession and RxSwift","<swift><unit-testing><rx-swift><urlsession>","1","1","","","","CC BY-SA 4.0"
"60489244","1","60510635","","2020-03-02 12:50:29","","0","325","<p>I have a method that returns a <code>Single&lt;(HTTPURLResponse, Any)&gt;</code> doing a call to a webservice.</p>

<p>This call returns an 409 for multiple reasons and this reason is passed as a JSON in the response.
I know the JSON is in the data attribute of the DataResponse object but I would like to have it in the AFError that I pass when an error occurs. I want to display the specific 409 error message related to the JSON response to the user to allow him understand what happened. </p>

<p>How could I do that ? </p>

<p>I searched for that in Stackoverflow and also on the github of Alamofire but couldn't find any help to my case.</p>

<pre><code>return Single&lt;(HTTPURLResponse, Any)&gt;.create(subscribe: { single in
    let request = self.sessionManager.request(completeURL, method: httpMethod, parameters: params, encoding: encoding, headers: headers)
    request.validate().responseJSON(completionHandler: { (response) in
        let result = response.result
        switch result {

        case let .success(value): single(.success((response.response!, value)))
        case let .failure(error): single(.error(error))
        }
    })

    return Disposables.create { request.cancel() }
})
</code></pre>

<p>I'm working with Alamofire 4.9.1</p>
","","user10901205","","user10901205","2020-03-02 17:32:38","2020-03-03 15:33:47","how to determine the specific 409 error from an AFError?","<ios><swift><alamofire><rx-swift>","1","1","","","","CC BY-SA 4.0"
"60549112","1","","","2020-03-05 15:42:45","","1","121","<p>Currently I'm having a problem with starting the app on device. After installing rxcocoa and rxswift through cocoapods - on emulator everything is good but not on device. The error says that rxcocoa cannot be found</p>

<p>Here is the error log:</p>

<blockquote>
  <p>dyld: Library not loaded: @rpath/RxCocoa.framework/RxCocoa  Referenced
  from:
  /private/var/containers/Bundle/Application/542D3903-715B-4FB9-9418-D25860F6F5AA/rx_goodslist.app/rx_goodslist
  Reason: no suitable image found. Did find: 
  /private/var/containers/Bundle/Application/542D3903-715B-4FB9-9418-D25860F6F5AA/rx_goodslist.app/Frameworks/RxCocoa.framework/RxCocoa:
  code signature invalid for
  '/private/var/containers/Bundle/Application/542D3903-715B-4FB9-9418-D25860F6F5AA/rx_goodslist.app/Frameworks/RxCocoa.framework/RxCocoa'</p>
  
  <p>/private/var/containers/Bundle/Application/542D3903-715B-4FB9-9418-D25860F6F5AA/rx_goodslist.app/Frameworks/RxCocoa.framework/RxCocoa:
  stat() failed with errno=25 
  /private/var/containers/Bundle/Application/542D3903-715B-4FB9-9418-D25860F6F5AA/rx_goodslist.app/Frameworks/RxCocoa.framework/RxCocoa:
  code signature invalid for
  '/private/var/containers/Bundle/Application/542D3903-715B-4FB9-9418-D25860F6F5AA/rx_goodslist.app/Frameworks/RxCocoa.framework/RxCocoa'</p>
  
  <p>/private/var/containers/Bundle/Application/542D3903-715B-4FB9-9418-D25860F6F5AA/rx_goodslist.app/Frameworks/RxCocoa.framework/RxCocoa:
  stat() failed with errno=1 
  /private/var/containers/Bundle/Application/542D3903-715B-4FB9-9418-D25860F6F5AA/rx_goodslist.app/Frameworks/RxCocoa.framework/RxCocoa:
  code signature invalid for
  '/private/var/containers/Bundle/Application/542D3903-715B-4FB9-9418-D25860F6F5AA/rx_goodslist.app/Frameworks/RxCocoa.framework/RxCocoa'</p>
  
  <p>/private/var/containers/Bundle/Application/542D3903-715B-4FB9-9418-D25860F6F5AA/rx_goodslist.app/Frameworks/RxCocoa.framework/RxCocoa:
  stat() failed with errno=1 (lldb)</p>
</blockquote>

<p>UPDATE: SOLVED
I just commented “use_fraemworks” in pod file and everything worked well</p>
","12957062","","12957062","","2020-03-05 18:39:18","2020-03-05 18:39:18","RxCocoa error while starting the app on device","<ios><xcode><rx-swift>","0","3","","","","CC BY-SA 4.0"
"60618079","1","","","2020-03-10 12:53:19","","0","52","<p>I have a Switch, which is an <code>Observable</code> called <code>switchChanged</code> I can listen to.</p>

<pre class=""lang-swift prettyprint-override""><code>extension Reactive where ... {
   lazy var toggleSwitch: UISwitch = {...}
   var switchChanged: Observable&lt;Bool&gt; {
      return toggleSwitch.rx
      .controlEvent(.valueChanged)
      .withLatestFrom(toggleSwitch.rx.value)
   }
</code></pre>

<p>I have the case that I would like to listen to <code>..rx.switchChanged</code> or <code>..rx.toggleSwitch.isOn</code>, but <strong>before</strong> they actually change their value (as <code>willSet</code> does). </p>

<p>The scenario would be :</p>

<ol>
<li><p>Clicking the switch</p></li>
<li><p>Listening to clicking</p></li>
<li><p>Calculating if toggling the switch is possible and showing a spinner</p></li>
<li><p>a. if yes, toggling the switch and ending spinner</p>

<p>b. if no, not toggling the switch, showing error popup and ending spinner</p></li>
</ol>

<p>Does anyone know if this is possible? </p>
","8937312","","7814052","","2020-03-10 15:39:30","2020-03-12 01:14:38","How to react on a value changed in swiftrx before it is actual set? (Like willSet only on Observable)","<swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"60669173","1","60679066","","2020-03-13 10:55:04","","1","577","<p>I'm currently learning MVVM and RxSwift. I have an image I want to passed in, in my main view controller. I was successful using mvc and RxSwift, but since MVVM is new to me. I don't know how implemented in MVVM. This is my code.</p>

<pre><code>// This is the work version MVC RxSwift
    class GProfilePickAlertVC: UIViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate {

    private let selectedSubjectPhoto = PublishSubject&lt;UIImage&gt;()
    var selectedPhoto: Observable&lt;UIImage&gt; {
        return selectedSubjectPhoto.asObservable()
    }

    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
        if let editedImage     = info[.editedImage] as? UIImage {
            self.selectedSubjectPhoto.onNext(editedImage)
            dismiss(animated: true, completion: nil)
        }
        dismiss(animated: true, completion: nil)
    }
}

    class BasicInfoViewController: UITableViewController {
    let profileImageView    = GProfileImage(img: #imageLiteral(resourceName: ""ic-tab-profile""), renderingMode: .alwaysTemplate)

    @objc private func handlePickPhoto() {
        let pickPhotoVC = GProfilePickAlertVC()
        pickPhotoVC.selectedPhoto.subscribe(onNext: { image in
            self.profileImageView.clipsToBounds = true
            self.profileImageView.image = image
            }).disposed(by: disposeBag)
        pickPhotoVC.modalPresentationStyle = .overFullScreen
        pickPhotoVC.modalTransitionStyle = .crossDissolve
        present(pickPhotoVC, animated: true)
    }
}

// This is my MVVM setup
    struct BasicInfoViewModel {

    let selectedImage: BehaviorRelay&lt;UIImage&gt;
}

    class BasicInfoViewController: UITableViewController {

    let disposeBag          = DisposeBag()

    var BasicInfoViewModel: BasicInfoViewModel!
}
</code></pre>
","8907890","","","","","2020-03-14 01:56:48","Passing data MVVM and RxSwift","<mvvm><uiimage><rx-swift>","1","0","","","","CC BY-SA 4.0"
"60669459","1","","","2020-03-13 11:13:59","","1","249","<p>I am using RxSwift for a project. I am using the control events to handle the textfield events such as follows.</p>

<pre><code>textField.rx.controlEvent([.editingDidEndOnExit]).subscribe {  _ in }.disposed(by: disposeBag)
</code></pre>

<p>Now I need to handle a delegate method</p>

<pre><code>textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool
</code></pre>

<p>If I add the delegate to the textField, the controlEvents stop working.</p>

<p>Does anybody have a suggestion about how can I handle this case where I can use both the control events and delegate methods? </p>

<p>Or should I just remove either of these handling.</p>

<p>Thanks.</p>
","4595813","","","","","2020-03-14 02:45:20","RxSwift Control Event with UITextFieldDelegate","<ios><swift><rx-swift><uitextfielddelegate>","1","1","","","","CC BY-SA 4.0"
"60672441","1","","","2020-03-13 14:40:05","","1","561","<p>I'm using <strong>RxSwift, RxCocoa</strong> for my app and implemented a tableView.<br>
When It got priceData from viewModel for tableView, it showed full list of priceData.<br></p>

<p>But I want to show only 50 counts at the first time and show more when I scroll it.<br>
Without RxSwift/RxCocoa, I used numberOfRowsInSection for <strong>paging of tableView</strong>. </p>

<p>But I don't know how I can use this with RxSwift<br></p>

<p>Here is my code. what should I do with my code for making to pageable tableView?</p>

<pre><code>viewModel.priceData         
            .drive(tableView.rx.items(cellIdentifier: ""Cell"")) { (index: Int, list, cell: Cell) in
...
}.disposed(by: disposeBag)
</code></pre>
","10503150","","","","","2020-03-14 02:49:01","How to use tableView's datasource (numberOfRowsInSection) wirh RxSwift?","<ios><tableview><rx-swift><rx-cocoa>","1","2","","","","CC BY-SA 4.0"
"60716021","1","","","2020-03-17 03:50:21","","1","53","<p>I'm learning MVVM and RxSwift and I want to bind all the object from the UI. I try to create a viewModel but the compiler pop up an error, am I create the view model wrong? this is my code and UI I want to bind.</p>

<p><a href=""https://i.stack.imgur.com/gqyiv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gqyiv.png"" alt=""setting""></a></p>

<blockquote>
  <p>Cannot use instance member 'BasicInfoViewModel' within property initializer; property initializers run before 'self' is available</p>
</blockquote>

<pre><code>    struct BasicInfoViewModel {

    let infos = PublishSubject&lt;InfoResult&gt;()

    let selectedImage: Observable&lt;UIImage&gt;
    let fullname: Observable&lt;String&gt;
    let phoneNumber: Observable&lt;String&gt;
    let email: Observable&lt;String&gt;
    let placeOfBirth: Observable&lt;String&gt;
    let dateOfBirth: Observable&lt;String&gt;
    let religion: Observable&lt;String&gt;

    var isValid: Observable&lt;Bool&gt; {
        return Observable.combineLatest(fullname.asObservable(), phoneNumber.asObservable(), email.asObservable(), placeOfBirth.asObservable(), dateOfBirth.asObservable(), religion.asObservable()).map { $0.0.count &gt; 0 }
    }
}

    class BasicInfoViewController: UITableViewController {

        var viewModel = BasicInfoViewModel()
    }
</code></pre>
","8907890","","","","","2020-03-17 12:31:21","structure viewModel for RxSwift","<ios><swift><mvvm><rx-swift>","1","1","","","","CC BY-SA 4.0"
"60727663","1","60730644","","2020-03-17 17:49:00","","1","714","<p>I have been using MVC since my first app on iOS... now i want to try MVVM.</p>
<p>My approach is that a Model can contain the remote URL and the ViewModel makes the request to download the image. (pushing then to binded view)... I think this is suitable so as to avoid making a network request in Views (or even worse, cells!)</p>
<pre class=""lang-swift prettyprint-override""><code>class Person: NSObject {
    var firstName: String?
    var lastName: String?
    var avatarURL: URL?
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>class PersonEntryViewModel {
    var name:String?
    var avatarImage:UIImage?

    init(person: Person?) {
        super.init()
        // omitted: binding self.name based on person.firstName &amp; person.lastName
        var request: URLRequest? = nil
        if let avatarURL = person?.avatarURL {
            request = URLRequest(url: avatarURL)
        }
        fetchImageFromNetwork({ response, data in
            if let data = data {
                avatarImage = UIImage(data: data)
            }
        })
    }
}
</code></pre>
<p>What do you think?</p>
<p>My doubts are about memory. I could have a big array of viewmodels filled with UIImages...</p>
","829543","","885189","","2021-04-26 15:41:44","2021-04-26 15:41:44","MVVM Async UIImage loading from network on iOS Swift","<ios><swift><design-patterns><mvvm><rx-swift>","1","11","","","","CC BY-SA 4.0"
"60735774","1","","","2020-03-18 08:22:22","","3","175","<p>I am updating a menu (adding, deleting item) from within a RxSwift subscriber. This is how the menu supposed to look like:</p>
<p><a href=""https://i.stack.imgur.com/JAiWo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JAiWo.png"" alt=""enter image description here"" /></a></p>
<p>The &quot;Item A&quot; will be continuously added and removed, depending on changes of the model, like the following:</p>
<pre><code>// Using ObservableArray (https://github.com/safx/ObservableArray-RxSwift)
model.changeset.rx()
        .observeOn(MainScheduler.instance)
        .subscribe(onNext: { (changes) in

            // Inserts
            for change in changes.insertedElements {
                guard let item = self.newItem(item: change) else { continue }
                let index = (self.view?.indexPlaceholder(at: .specialItem) ?? 0) + 1
                // self.view is a NSMenu Object, so menu item will be added here
                self.view?.insertItem(bridgeItem, at: index)
            }

            // Deletes
            for change in changes.deletedElements {
                guard let menuItems = self.view?.getItems(withIdentifier: .specialItem) else { continue }
                guard let newIndex = menuBridgeObjects.firstIndex(where: {
                    ...
                }
                
                let index = (self.view?.indexPlaceholder(at: .specialItem) ?? 0) + 1 + index
                // self.view is a NSMenu Object, so menu item will be removed here
                self.view?.removeItem(safe: index, onlyIf: .specialItem)
            }

        }).disposed(by: disposeBag)
}
</code></pre>
<p>The <code>model.changeset</code> will be populated or altered based on several network activities running in the background.</p>
<p>However, I have realized that while the menu is open, any modifications to the <code>model.changeset</code> and the menu changes through the subscriber, the menu looks like this (missing the separator item below &quot;Item A&quot;):</p>
<p><a href=""https://i.stack.imgur.com/1SL1h.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/1SL1h.png"" alt=""enter image description here"" /></a></p>
<p>After closing the menu (tracking lost) and re-open again (no changes on the model this time, so code snippet above will not be triggered), the menu looks as it was supposed to be like this:</p>
<p><a href=""https://i.stack.imgur.com/JAiWo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JAiWo.png"" alt=""enter image description here"" /></a></p>
<p>I already tried something like <code>NSMenu.update()</code>, but this is somehow not helping to draw the NSMenu properly while open. Do you know if I have overseen something very important here?</p>
","873072","","873072","","2020-08-31 10:12:53","2020-08-31 10:12:53","Update menu from within RxSwift subscribe","<swift><macos><cocoa><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"60753203","1","60753910","","2020-03-19 08:14:52","","0","162","<p>First of all, here is my code</p>

<pre><code>viewModel.price
            .drive(collectionView.rx.items(cellIdentifier: ""Cell"")) { (index: Int, Info, cell: Cell) in 
                 ....
          }.disposed(by: disposeBag)
</code></pre>

<p>viewModel.price's data type is <strong>Driver&lt;[Info]></strong></p>

<p>In this code, I want to add a flag which is for pausing collectionView. <br>
When the flag from viewModel is ""true"" then keep drawing collectionView but if it's ""false"" then stop it. <br></p>

<p>I think I need to use <strong>combineLatest</strong> and <strong>takeWhile</strong> but not sure how to use this.</p>

<p>how can I use <strong>combineLatest</strong> and <strong>takeWhile</strong> for my code?</p>
","10503150","","","","","2020-03-19 09:16:13","Can I pause data stream by a flag with RxSwift?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"60764306","1","60766279","","2020-03-19 20:06:32","","0","118","<p>Binding a sectioned table with <a href=""https://github.com/RxSwiftCommunity/RxDataSources"" rel=""nofollow noreferrer"">RxDataSources</a> using a <a href=""https://github.com/RxSwiftCommunity/RxDataSources/blob/master/Sources/RxDataSources/TableViewSectionedDataSource.swift"" rel=""nofollow noreferrer"">TableViewSectionedDataSource</a>, requires sections which conform to <a href=""https://github.com/RxSwiftCommunity/RxDataSources/blob/master/Sources/Differentiator/SectionModelType.swift"" rel=""nofollow noreferrer"">SectionModelType</a>.</p>

<p>This <a href=""https://github.com/RxSwiftCommunity/RxDataSources/blob/master/Sources/Differentiator/SectionModelType.swift"" rel=""nofollow noreferrer"">SectionModelType</a> protocol has the following initializer as one of it's requirements: </p>

<pre><code>    init(original: Self, items: [Item])
</code></pre>

<p>In addition, the same protocol enforces <code>var items: [Item] { get }</code>. We can now initialize the items array backing variable (in above mentioned <code>init</code>) with either from <code>original.items</code>, or <code>items</code> passed as init parameter. This is very confusing. The SectionModelType code has no comments. </p>

<p><a href=""https://github.com/RxSwiftCommunity/RxDataSources#how"" rel=""nofollow noreferrer"">How</a> section of README which explains creation of sections for this very case, talks about creating typealias (for associated value), and the items array, but not a word about following implementation of <code>init</code> with <code>original: Self</code> :</p>

<pre><code>init(original: SectionOfCustomData, items: [Item]) {
    self = original
    self.items = items
}
</code></pre>

<p>While this can work in a struct, doing the same in a class shouts: </p>

<blockquote>
  <p>Cannot assign to value: 'self' is immutable</p>
</blockquote>

<p>Can anyone here explain what is happening here and why do we NEED to init with <code>Self</code></p>

<p>Lastly, is there another (cleaner) way to reactively (in RXSwift / RxCocoa only) bind a sectioned table view to an observable datasource. 
e.g. 
* my cells, and sections have their own data model, which need to be mutable (hence classes)
* there are multiple screens with this requirement for different entities, so i would be interesetd in achieving this with protocols instead, and slap the corresponding data model with the protocol ans have a common implementation for RXBinding</p>

<p>Any pointers to either get clarity more on existing implementation, or achieving above points would be really helpful.
P.S.: I am already working in a huge code base which uses Rx, so not using Rx, or moving to SwiftUI etc is not what I am looking for.</p>
","219971","","219971","","2020-03-19 20:17:25","2020-03-19 23:02:03","Clarity on init with `Self` requirement of SectionModelType in RxDataSources","<swift><rx-swift><rxdatasources>","1","0","","","","CC BY-SA 4.0"
"60786212","1","60786238","","2020-03-21 09:20:15","","0","238","<p>I've got an adapter class called ServiceHealthApi that has this function: </p>

<pre><code>final class ServiceHealthApi {
    let mockApi = ""https://staging.myapp.com/health""

    func getHealth() -&gt; Single&lt;ServiceHealthResponseModel&gt; {
        let url = URL(string: mockApi)
        guard let validUrl = url else { return .never() }

        var urlRequest = URLRequest(url: validUrl)
        urlRequest.httpMethod = ""GET""
        let headers = [
            ""Content-Type"" : ""application/json; charset=utf-8""
        ]
        urlRequest.allHTTPHeaderFields = headers
        return URLSession.shared.rx.data(request: urlRequest)
            .take(1)
            .map {
                let decoder = JSONDecoder()
                decoder.keyDecodingStrategy = .convertFromSnakeCase
                return try JSONDecoder().decode(ServiceHealthResponseModel.self, from: $0) }
            .asSingle()

    }
}

struct HealthResponseModel: Decodable {
    struct DataResponse: Decodable {
        let serviceName: String
        let serviceStatus: String
        let serviceOperational: Bool
    }

    struct Meta: Decodable {
        let statusCode: Int
        let statusMessage: String
    }

    let data: [DataResponse]
    let meta: Meta
}
</code></pre>

<p>The <code>JSON</code> string that is supposed to be parsed is like so:</p>

<pre><code>{
    ""data"": [
        {
            ""service_name"": ""web"",
            ""service_status"": ""UP"",
            ""service_operational"": true
        },
        {
            ""service_name"": ""orm"",
            ""service_status"": ""UP"",
            ""service_operational"": true
        }
    ],
    ""meta"": {
        ""status_code"": 200,
        ""status_message"": ""OK""
    }
}
</code></pre>

<p>Now, when I tried to run my integration test, it failed with this error from the <code>JSONDecoder</code>:</p>

<blockquote>
  <p>error keyNotFound(CodingKeys(stringValue: ""serviceName"", intValue:
  nil), Swift.DecodingError.Context(codingPath: [CodingKeys(stringValue:
  ""data"", intValue: nil), _JSONKey(stringValue: ""Index 0"", intValue:
  0)], debugDescription: ""No value associated with key
  CodingKeys(stringValue: \""serviceName\"", intValue: nil)
  (\""serviceName\"")."", underlyingError: nil))</p>
</blockquote>

<p>The funny thing is, if I disabled .convertFromSnakeCase, and just use camelcase for the variable names in the response model, it worked just fine. I know I can probably use coding keys, but I am just wondering, why didn't my implementation work?</p>

<p>Thanks in advance.</p>

<p>PS: I've tried parsing the <code>JSON</code> string directly without calling the <code>API</code> and it did work.</p>
","4124849","","","","","2020-03-21 09:23:53","KeyDecodingStrategy .convertFromSnakeCase doesn't work","<ios><json><swift><rx-swift><decodable>","1","0","","","","CC BY-SA 4.0"
"60828123","1","60828210","","2020-03-24 09:23:19","","0","311","<p>Just inherited this code base and I'm not quite familiar with <strong>RxSwift</strong>. I've done some reading but cannot find a solution to my problem. </p>

<p>We have a variable declared. This saves information from a network call, and then is being used to load information to a collection view. Therefore the collection view is showing multiple similar items</p>

<pre><code>var allPhotos = BehaviorRelay&lt;[Photo]&gt;.init(value: [])
</code></pre>

<p>How do I convert it to a set to remove duplicates?</p>
","8239252","","6310865","","2020-03-24 09:55:54","2020-03-24 10:16:31","BehaviourRelay variable remove duplicates","<ios><swift><rx-swift><iglistkit>","2","0","","","","CC BY-SA 4.0"
"60848836","1","60859816","","2020-03-25 12:27:07","","2","496","<p>I'm trying to implement a MVVM-C rx swift app.</p>

<p>I have a VM for my sign up view controller with the username and password as behaviour subjects. I also have a firebase handler injected into the VM. What is the best way to pass the sign up result back to the VC? </p>

<p>my VM code: </p>

<pre><code>class CreateVM {

    let firebase: FirebaseHandler
    let email: String

    var password = BehaviorSubject&lt;String&gt;(value: """")
    var confirmPassword = BehaviorSubject&lt;String&gt;(value: """")

    var shouldHideButton: Observable&lt;Bool&gt; {
        return Observable.combineLatest(password.asObservable(), confirmPassword.asObservable()) { pass, confPass in
            !(pass.count &gt;= 5 &amp;&amp; pass == confPass)
        }
    }

    init(firebase: FirebaseHandler, email: String) {
        self.firebase = firebase
        self.email = email
    }

    func submit() {
        let pass = try! password.value()
        firebase.createWithEmail(email: email, password: pass) { (result) in
            switch result {
            case .success(let uid):
                print(uid, ""created"")
                //handle successful creation
            case .failure(let err):
                print(""failed with error:"", err)
                //handler error
            }
        }
    }
}
</code></pre>

<p>My VC code:</p>

<pre><code>class CreateVC: UIViewController, Storyboarded {

    @IBOutlet weak var createButton: Rounded!
    @IBOutlet weak var passwordEntry: UITextField!
    @IBOutlet weak var confirmPasswordEntry: UITextField!

    weak var coordinator: AuthCoordinator?

    var displayName: String!
    var viewModel: CreateVM!
    let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        bindUI()
    }

    func bindUI() {
        passwordEntry.rx.text.orEmpty.bind(to: viewModel.password).disposed(by: disposeBag)
        confirmPasswordEntry.rx.text.orEmpty.bind(to: viewModel.confirmPassword).disposed(by: disposeBag)
        viewModel.shouldHideButton.bind(to: createButton.rx.isHidden).disposed(by: disposeBag)

        createButton.rx.tap.bind { [unowned self] _ in
                self.viewModel.submit()
        }.disposed(by: disposeBag)

    }
}
</code></pre>
","9179069","","7167839","","2020-06-08 04:16:23","2020-06-08 04:16:23","How to implement firebase auth into MVVM-C RxSwift","<ios><swift><mvvm><firebase-authentication><rx-swift>","1","1","","","","CC BY-SA 4.0"
"60862522","1","60863247","","2020-03-26 07:20:36","","0","57","<p>It is my first app in swift. I am using Alamofire for my HTTP request. Coming from Android, I know it is possible to attach serialized object to navcontroller action while navigating from one screen to another. </p>

<p>I want to be able to perform segue after from the viewmodel subscription and attach the resultant token to the segue as I will be using it for verification at the next screen.</p>

<p>I have tried <code>didSet</code> but to no avail.</p>

<p>How can I do this in swift.</p>

<pre><code>
    //MARK: Register user
    @IBAction func registerUser(_ sender: Any) {

        let fullName = firstNameTF.text! + "" "" + lastNameTF.text!
        let email = emailTF.text
        let password = passwordTF.text
        let phone = phoneNumberTF.text
        let country = countryDropDown.text

        let user = User(name: fullName, email: email, password: password, country: country, phone: phone, token: nil)

        var tk = """"{
            didSet{
                token = tk
            }
        }
      authViewModel.registerUser(user: user).subscribe(onNext: { (AuthResponse) in
            print(""messaage \(String(describing: AuthResponse.message))"")
            self.tokens = AuthResponse.token
            self.performSegue(withIdentifier: ""gotoVerification"", sender: self)
        }, onError: { (Error) in
            print(""Error: \(Error.localizedDescription)"")
        }, onCompleted: nil) {

        }.disposed(by: disposeBag)

        print(""token \(token)"")
//        AF.request(url, method: .post, parameters: user, encoder: JSONParameterEncoder.default).responseDecodable(of:AuthResponse.self){response in
//
//            response.map { (AuthResponse) in
//                print(""messaage \(String(describing: AuthResponse.message))"")
//            }
//
//            print(""user: \(user)"")
//            print(""response \(String(describing: response))"")
//        }
    }

    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let vc = segue.destination as? UserVerification{
//
            vc.tokens = token
            print(""token \(token)"")
        }
    }

</code></pre>
","7358866","","","","","2020-03-26 08:20:06","How to pass data in a closure to another scene","<ios><objective-c><swift><alamofire><rx-swift>","1","2","","","","CC BY-SA 4.0"
"60888844","1","","","2020-03-27 15:15:15","","2","204","<p>i works with MVVM-C (Rxswift) i have to create homeVC , HomeViewModel and HomeCoordinator 
when i try to connect HomeCoordinator with HomeViewModel  to push new VC to Coordinator it's not take any action 
Can any one help me with example or explain how to solve this problem?</p>
","10839312","","","","","2020-03-27 20:52:34","How i can push new view when i use coordinator with mvvm-c Rxswift?","<swift><xcode><mvvm><viewmodel><rx-swift>","1","0","","","","CC BY-SA 4.0"
"60917286","1","","","2020-03-29 16:23:42","","1","215","<p>Is there an alternative to ReactiveSwift Action in Swift Combine? If not, how could it be implemented?</p>

<p>I am not very familiar with Swift Combine yet and could't find it anywhere.</p>
","11216994","","","","","2020-03-29 16:42:56","ReactiveSwift Action in Swift Combine","<swift><rx-swift><combine><reactive-swift>","1","0","","","","CC BY-SA 4.0"
"60935369","1","60949510","","2020-03-30 16:46:07","","2","294","<p>How can i append array data in Subject type Behavior Relay RxSwift Without replace data before.
I try to append data to UICollectionViewCell with binding it. It always Flashing white display, because data is replace not append but use the old data.</p>

<p>My code to append new data:</p>

<pre><code>var photoCollectionView = BehaviorRelay&lt;[PhotoList?]&gt;(value: [])
let photoData = try? JSONDecoder().decode(SearchPhoto.self, from: RESPONSE_DATA)
photoCollectionView.accept(photoCollectionView.value + (photoData ?? []))
</code></pre>

<p>Or do you have another way to i do</p>

<p>Thanks for your solution :D</p>
","12959269","","","","","2020-03-31 11:28:42","How to Append data in array using Behavior Relay/Subject in RxSwift?","<swift><uicollectionviewcell><rx-swift>","1","0","","","","CC BY-SA 4.0"
"60975261","1","60975529","","2020-04-01 16:03:41","","0","146","<p>I want to observe <code>speed</code> property of CLLocation updates and trigger an event if the speed doesn't change for 10 seconds and if the speed changes reset the timer. Could only come up with this much code till now.</p>

<pre><code>let location: Observable&lt;CLLocation&gt;

location.subscribe(onNext: { (coordinates) in
    print(coordinates)
})
.disposed(by: disposeBag)
</code></pre>

<p>I assume we could use <code>debounce</code> or <code>throttle</code> but not sure how.</p>
","3490203","","","","","2020-04-01 17:02:25","How to observe if a property doesn't change for a specific interval in RxSwift","<ios><swift><core-location><rx-swift>","1","0","","","","CC BY-SA 4.0"
"60995018","1","60995810","","2020-04-02 15:19:45","","0","58","<pre><code>location.filter({$0.speed &lt; 25})
.debounce(.seconds(20), scheduler: MainScheduler.instance)
.subscribe(onNext: { (location) in
    print(location)
}).disposed(by: disposeBag)
</code></pre>

<p><strong>Goals:</strong></p>

<ol>
<li>If the speed property remains below <code>25 for 20 seconds</code> then print location</li>
<li>If <code>within 20</code> seconds speed goes <code>above 25</code> cancel the emitted event</li>
<li>If the speed remains <code>below 25</code> for 40 seconds, location should be printed twice once at 20 seconds and again at 40 seconds.</li>
</ol>

<p>Current problem is : If the speed goes below 25 and within 20 seconds observable receives a second event with speed below 25 it cancels out the previous event because of <code>debounce</code>.</p>
","3490203","","3490203","","2020-04-02 16:16:38","2020-04-02 17:19:14","Which RxSwift operator to use for uniquely emitted elements and how to?","<ios><swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61008813","1","61012897","","2020-04-03 09:28:17","","0","51","<p>Trying to scan for <code>Bluetooth</code> <code>peripherals</code> using <code>RxBluetoothKit</code> I get an <code>error</code> called </p>

<blockquote>
  <p>""Ambiguous reference to member '=='
  using this code:</p>
</blockquote>

<pre><code>func observeState() -&gt; Observable&lt;[BluetoothState]&gt; {
    return manager.observeState()
           .startWith(manager.state)
           .do(onNext: { print(""CHECK POWER"", $0) })
           .filter{ $0 == .poweredOn }
           .take(1)
           .do(onNext:{
               print(""🐦POWERED ON"", $0)
           })
           .flatMap { _ in
               self.manager
                   .scanForPeripherals(withServices: nil)
                   .map { BlePeripheral(peripheral: $0.peripheral) }
                   .do(onNext: {
                       print($0.peripheral.name)
                       print($0.peripheral.identifier)
                       print($0.peripheral.connected)
                    })
           }
    }
</code></pre>

<p>The error is on <code>.filter{ $0 == .poweredOn }</code></p>

<p>If I remove everything from <code>flatMap</code> and onwards, the error disappear but obviously I need to have that part at some point. Not sure I understand the <code>error</code>. I have looked at question/answers on the same error but I'm still not sure how it applies to my case or what the <code>compiler</code> wants me to do. Appreciate any pointers to how to fix this.</p>
","12297975","","12297975","","2020-04-03 09:37:38","2020-04-03 13:22:44","How do I deal with ""Ambiguous reference to member '=='"" in RxBluetoothKit?","<ios><compiler-errors><bluetooth><rx-swift><rxbluetooth>","1","0","","","","CC BY-SA 4.0"
"61024298","1","61028601","","2020-04-04 05:51:53","","1","32","<p>I have a <code>variable</code> that gets me the type <code>Observable&lt;BleHandler.BlePeripheral&gt;</code> after using <code>flatMap</code> on the <code>array</code>.</p>

<pre><code>let scannedPeripheral: Observable&lt;BleHandler.BlePeripheral&gt; = instance.bleScan()
            .flatMap{ Observable.from($0)}
</code></pre>

<p>But now I need to use that <code>variable</code> in another <code>function</code> that takes <code>BleHandler.BlePeripheral</code>:</p>

<pre><code>instance.bleEstablishConnection(scannedPeripheral: scannedPeripheral)
</code></pre>

<p>Obviously it doesn't work. Is there a way to get my <code>Observable&lt;BleHandler.BlePeripheral&gt;</code> to just <code>BleHandler.BlePeripheral</code></p>
","12297975","","","","","2020-04-04 13:11:02","How do I get from Observable<BleHandler.BlePeripheral> to BleHandler.BlePeripheral?","<ios><swift><rx-swift><rxbluetooth>","1","2","","","","CC BY-SA 4.0"
"61028715","1","","","2020-04-04 13:20:26","","1","982","<p>RxDatasource in RxSwift [RxTableViewSectionedAnimatedDataSource] Reload Animation don't update data source. What mistake I am doing? I am even unable to bind my action with button properly.</p>

<p>TableDataSource and Table editing commands</p>

<pre><code>struct TableDataSource {
    var header: String
    var items: [Item]
    var SectionViewModel: SectionViewModel
}

extension TableDataSource: AnimatableSectionModelType {
    var identity: String {
        return header
    }

type alias Item = Data

    init(original: TableDataSource, items: [Item]) {
        self = original
        self.items = items
        self.sectionViewModel = original.sectionViewModel
    }
}

enum TableViewEditingCommand {    
    case deleteSingle(IndexPath)
    case clearAll(IndexPath)
    case readAll(IndexPath)
}

struct SectionedTableViewState {

    var sections: [TableDataSource]

    init(sections: [TableDataSource]) {
        self.sections = sections
    }

    func execute(command: TableViewEditingCommand) -&gt; SectionedTableViewState {
        var sections = self.sections
        switch command {

        // Delete single item from datasource
        case .deleteSingle(let indexPath):
            var items = sections[indexPath.section].items
            items.remove(at: indexPath.row)
            if items.count &lt;= 0 {
                sections.remove(at: indexPath.section)
            } else {
                sections[indexPath.section] = TableDataSource(
                    original: sections[indexPath.section],
                    items: items) }

        // Clear all item from datasource with isUnread = false
        case .clearAll(let indexPath):
            sections.remove(at: indexPath.section)

        // Mark all item as read in datasource with isUnread = true
        case .readAll(let indexPath):
            var items = sections[indexPath.section].items
            items = items.map { var unread = $0
                if $0.isUnRead == true { unreadData.isUnRead = false }
                return unreadData
            }
            sections.remove(at: indexPath.section)
            if sections.count &gt; 0 {
            let allReadItems = sections[indexPath.section].items + items
                sections[indexPath.section] = TableDataSource(
                    original: sections[indexPath.section],
                    items: allReadItems)
            }
        }
         return SectionedTableViewState(sections: sections)
    }
}
</code></pre>

<p>This is my controller and its extensions</p>

<pre><code>
class ViewController: UIViewController, Storyboardable {

    @IBOutlet weak var tableView: UITableView!
    @IBOutlet weak var closeButton: UIButton!
    @IBOutlet weak var titleText: UILabel!

    var viewModel: ViewModel!
    let disposeBag = DisposeBag()

    let sectionHeight: CGFloat = 70
    let dataSource = ViewController.dataSource()

    override func viewDidLoad() {
        super.viewDidLoad()
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        bindInitials()
        bindDataSource()
        bindDelete()
    }

    private func bindInitials() {
        tableView.delegate = nil
        tableView.rx.setDelegate(self)
            .disposed(by: disposeBag)
        registerNibs()
    }

    private func registerNibs() {
        let headerNib = UINib.init(
            nibName: TableViewSection.identifier,
            bundle: nil)
        tableView.register(
            headerNib,
            forHeaderFooterViewReuseIdentifier: TableViewSection.identifier)
    }
}

extension ViewController: Bindable {

    func bindViewModel() {
        bindActions()
    }

    private func bindDataSource() {

        bindDelete()


        //        tableView.dataSource = nil
        //        Observable.just(sections)
        //            .bind(to: tableView.rx.items(dataSource: dataSource))
        //            .disposed(by: disposeBag)
    }

    private func bindDelete() {
        /// TODO: to check and update delete code to work properly to sink with clear all and mark all as read
        guard let sections = self.viewModel?.getSections() else {
            return
        }
        let deleteState = SectionedTableViewState(sections: sections)
        let deleteCommand = tableView.rx.itemDeleted.asObservable()
            .map(TableViewEditingCommand.deleteSingle)

        tableView.dataSource = nil
        Observable.of(deleteCommand)
            .merge()
            .scan(deleteState) {
                (state: SectionedTableViewState,
                command: TableViewEditingCommand) -&gt; SectionedTableViewState in
                return state.execute(command: command) }
            .startWith(deleteState) .map { $0.sections }
            .bind(to: tableView.rx.items(dataSource: dataSource))
            .disposed(by: disposeBag)
    }

    private func bindActions() {

        guard let openDetailsObserver = self.viewModel?.input.openDetailsObserver,
            let closeObserver = self.viewModel?.input.closeObserver else {
                return
        }
        viewModel.output.titleTextDriver
            .drive(titleText.rx.text)
            .disposed(by: disposeBag)

//        viewModel.input.dataSourceObserver
//            .mapObserver({ (result) -&gt; [Data] in
//                return result
//            })
//            .disposed(by: disposeBag)

        /// Close button binding with closeObserver
        closeButton.rx.tap
            .bind(to: (closeObserver))
            .disposed(by: disposeBag)

        /// Tableview item selected binding with openDetailsObserver
        tableView.rx.itemSelected
            .map { indexPath in
                return (self.dataSource[indexPath.section].items[indexPath.row])
        }.subscribe(openDetailsObserver).disposed(by: disposeBag)
    }
}

extension ViewController: UITableViewDelegate {

    static func dataSource() -&gt; RxTableViewSectionedAnimatedDataSource&lt;TableDataSource&gt; {
        return RxTableViewSectionedAnimatedDataSource(
            animationConfiguration: AnimationConfiguration(insertAnimation: .fade,
                                                           reloadAnimation: .fade,
                                                           deleteAnimation: .fade),
            configureCell: { (dataSource, table, idxPath, item) in
                var cell = table.dequeueReusableCell(withIdentifier: TableViewCell.identifier) as? TableViewCell
                let cellViewModel = TableCellViewModel(withItem: item)
                cell?.setViewModel(to: cellViewModel)
                return cell ?? UITableViewCell()
        }, canEditRowAtIndexPath: { _, _ in return true })
    }

    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? {

        guard var headerView = tableView.dequeueReusableHeaderFooterView(
            withIdentifier: TableViewSection.identifier)
            as? TableViewSection
            else { return UITableViewHeaderFooterView() }
        let viewModel = self.dataSource[section].sectionViewModel
        headerView.setViewModel(to: viewModel)
        headerView.dividerLine.isHidden = section == 0 ? true : false
        headerView.section = section

        let data = TableViewEditingCommand.clearAll(IndexPath(row: 0, section: section ?? 0))
//        /// Section button binding with closeObserver
//        headerView.sectionButton.rx.tap
//            .map(verseNum -&gt; TableViewEditingCommand in (TableViewEditingCommand.deleteSingle))
//            .disposed(by: disposeBag)

        headerView.sectionButtonTappedClosure = { [weak self] (section, buttonType) in
            if buttonType == ButtonType.clearAll {
                self?.showClearAllConfirmationAlert(section: section, buttonType: buttonType)
            } else {
                self?.editAction(section: section, buttonType: buttonType)
            }
        }
        return headerView
    }

    func editAction(section: Int, buttonType: ButtonType) {

        var sections = self.dataSource.sectionModels
        let updateSection = (sections.count == 1 ? 0 : section)

        switch buttonType {
        /// Clear all
        case .clearAll:
            sections.remove(at: updateSection)
            let data = SectionedTableViewState(sections: sections)
            self.tableView.dataSource = nil
            Observable.of(data)
                .startWith(data) .map { $0.sections }
                .bind(to: tableView.rx.items(dataSource: dataSource))
                .disposed(by: disposeBag)
        /// Mark all as read
        case .markAllAsRead:
            if updateSection == 0 { sections = self.viewModel.getSections() }
            var items = sections[updateSection].items
            items = items.map { var unread = $0
                if $0.isUnRead == true { unread.isUnRead = false }
                return unread
            }
            sections.remove(at: updateSection)
            let allReadItems = sections[updateSection].items + items
            sections[updateSection] = TableDataSource(
                original: sections[updateSection],
                items: allReadItems)

            let data = SectionedTableViewState(sections: sections)
            self.tableView.dataSource = nil
            Observable.of(data)
                .startWith(data) .map { $0.sections }
                .bind(to: tableView.rx.items(dataSource: dataSource))
                .disposed(by: disposeBag)
        }
    }

    func showClearAllConfirmationAlert(section: Int, buttonType: ButtonType) {

        let alert = UIAlertController(title: ""Clear All"",
                                      message: ""Are you sure, you want to clear all Items?"",
                                      preferredStyle: .alert)

        alert.addAction(UIAlertAction(title: ""OK"", style: .default, handler: { action in
            switch action.style{
            case .default:
                self.editAction(section: section, buttonType: buttonType)
            case .cancel: break
            case .destructive: break
            default:break
            }}))
        let cancel = UIAlertAction(title: ""Cancel"", style: .default, handler: { action in
        })
        alert.addAction(cancel)
        self.present(alert, animated: true, completion: nil)
    }

    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat {
        return sectionHeight
    }
}

</code></pre>

<p>View model for controller</p>

<pre><code>
class ViewModel {

    private enum Constants {
        static let titleText = ""Test"".localized
        static let testHistoryHeaderText = ""test"".localized
        static let unreadHeaderText = ""Unread"".localized
    }

    struct Input {
        let dataSourceObserver: AnyObserver&lt;[Data]&gt;
        let openDetailsObserver: AnyObserver&lt;Data&gt;
        let closeObserver: AnyObserver&lt;Void&gt;
        let sectionButtonTappedObserver: AnyObserver&lt;IndexPath&gt;
    }

    struct Output {
        let titleTextDriver: Driver&lt;String&gt;
        let dataSourceDriver: Driver&lt;[Data]&gt;
        let viewComplete: Observable&lt;DataCoordinator.Event&gt;
    }

    let input: Input
    let output: Output

    private let dataSourceSubject =  PublishSubject&lt;[Data]&gt;()
    private let closeSubject = PublishSubject&lt;Void&gt;()
    private let openDetailsSubject = BehaviorSubject&lt;Data&gt;(value:Data())
    private let sectionButtonTappedSubject = PublishSubject&lt;IndexPath&gt;()
    private let disposeBag = DisposeBag()

    init(withRepository repository: Repository) {
        input = Input(
            dataSourceObserver: dataSourceSubject.asObserver(),
            openDetailsObserver: openDetailsSubject.asObserver(),
            closeObserver: closeSubject.asObserver(), sectionButtonTappedObserver: sectionButtonTappedSubject.asObserver()
        )
        let closeEventObservable = closeSubject.asObservable().map { _ in
            return Coordinator.Event.goBack
        }
        let openDetailsEventObservable = openDetailsSubject.asObservable().map { _ in
            return Coordinator.Event.goToDetails
        }

        let viewCompleteObservable = Observable.merge(closeEventObservable, openDetailsEventObservable)

        let list = ViewModel.getData(repository: repository)

        output = Output(
            titleTextDriver: Observable.just(Constants.titleText).asDriver(onErrorJustReturn: Constants.titleText),
            dataSourceDriver: Observable.just(list).asDriver(onErrorJustReturn: list),
            viewComplete: viewCompleteObservable)


    }


    ///TODO: To be updated as per response after API integration
    static func getData(repository: Repository) -&gt; [Data] {
        return repository.getData()
    }

    func getSections() -&gt; [TableDataSource] {

        let List = ViewModel.getData(repository: Repository())

        let unread = list.filter { $0.isUnRead == true }
        let read = list.filter { $0.isUnRead == false }

        let headerText = String(format:Constants.unreadHeaderText, unread.count)

        let sections = [TableDataSource(
            header: headerText,
            items: unread,
            sectionViewModel: SectionViewModel(
                withHeader: headerText,
                buttonType: ButtonType.markAllAsRead.rawValue,
                items: unread)),
                        TableDataSource(
                            header: Constants.historyHeaderText,
                            items: read,
                            SectionViewModel: SectionViewModel(
                                withHeader: Constants.historyHeaderText,
                                buttonType: ButtonType.clearAll.rawValue,
                                items: read))]
        return sections
    }
}

</code></pre>
","2343287","","4420967","","2020-04-04 14:13:53","2021-07-23 22:11:52","RxDatasource in RxSwift reload animation don't update data source","<swift><uitableview><rx-swift><rxdatasources>","1","0","","","","CC BY-SA 4.0"
"61045518","1","","","2020-04-05 16:09:23","","0","192","<p>Got quite a big problem - have a form with a couple of input fields and would like to validate those using RxSwift.
Everything works fine when I edit the text, but it simply doesn't work when I want to validate those fields after the button has been tapped or even simply bind those fields to button.rx.isEnabled, any help would be appreciated. Code below (mixed with some comments):</p>

<pre><code>ViewController:
func setupBindings() {
        self.emailInputField.inputTf
            .rx.text.orEmpty
            .bind(to: self.presenter.emailInputFieldPublishSubject)
            .disposed(by: self.disposeBag)
        self.messageInputField.inputTv
            .rx.text.orEmpty
            .bind(to: self.presenter.messageInputFieldPublishSubject)
            .disposed(by: self.disposeBag)
        self.presenter.validateEmail()
            .subscribe(onNext: { [weak self] errorMessage in
                self?.emailInputField.error = errorMessage
            })
            .disposed(by: self.disposeBag)
        self.presenter.validateMessage()
            .subscribe(onNext: { [weak self] errorMessage in
                self?.messageInputField.error = errorMessage
            })
            .disposed(by: self.disposeBag)

// Everything above works fine, error message is set properly as soon as the user taps the input field - that's correct

// rx.tap action is called, flatMap is called, but then subscribe(onNext) is not called, looks like onNext is not emitted or so

        self.submitButton.rx.tap.flatMap { [weak self] (_) -&gt; Observable&lt;String?&gt; in
            guard let context = self else { return Observable.just(nil) }
            return context.presenter.validateEmail()
        }
        .subscribe(onNext: { (value) in
            SwiftyBeaver.debug(""onNext \(value ?? """")"")
        }, onError: { (error) in
            SwiftyBeaver.debug(""onError \(error)"")
        }, onCompleted: {
            SwiftyBeaver.debug(""onCompleted"")
        }, onDisposed: {
            SwiftyBeaver.debug(""onDisposed"")
        })
        .disposed(by: self.disposeBag)
}
</code></pre>

<pre><code>ViewModel:
    let emailInputFieldPublishSubject = PublishSubject&lt;String&gt;()
    let messageInputFieldPublishSubject = PublishSubject&lt;String&gt;()
    func validateEmail() -&gt; Observable&lt;String?&gt; {
        return emailInputFieldPublishSubject.debug().map { $0.validateEmail() }
    }
    func validateMessage() -&gt; Observable&lt;String?&gt; {
        return messageInputFieldPublishSubject.map { $0.validate(minLength: 3, maxLength: 1024) }
    }


// Also have ""validateForm"" method to validate the whole form after tapping ""submitButton"", but it doesn't work from the same reason. Don't worry about consent validation, it works just the same.

    func validateForm() -&gt; Observable&lt;Bool&gt; {
        return Observable.combineLatest(self.validateConsent(),
                                        self.validateEmail(),
                                        self.validateMessage())
            .map { (consentError, emailError, messageError) in
                return consentError.isBlank &amp;&amp; emailError.isBlank &amp;&amp; messageError.isBlank
            }
    }
</code></pre>

<p>Losing my mind, any help is very appreciated.</p>
","5847071","","","","","2020-04-06 06:41:16","RxSwift - onNext not called when validating UITextField after button was tapped","<ios><swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61050351","1","61050369","","2020-04-05 22:24:44","","0","63","<p>I am new to RxSwift. How can I exclude default value for BehaviorRelay.
My code:</p>

<pre><code>  idObservable.subscribe(onNext: { [weak self] id in
        self?.fetchData(id)
  }).disposed(by: self.disposeBag)
</code></pre>
","","user12482007","","","","2020-04-05 22:27:04","RxSwift: BheaviorRelay exclude default value","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61068947","1","61071517","","2020-04-06 21:04:21","","0","331","<p>What I want to do is:</p>

<ul>
<li>Observe the <code>location</code> observable every 60 seconds and compare if the distance has passed a threshold compared to the event which was emitted ~60 seconds ago</li>
</ul>

<p>What happening is in <code>$0</code> I'm always getting the very first emitted event, it's not updating every 60 seconds. $1 has the latest emitted event though.</p>

<p>Here's the code:</p>

<pre><code>Observable&lt;Int&gt;.timer(.seconds(0), period: .seconds(60), scheduler: MainScheduler.instance)
            .withLatestFrom(location)
            .distinctUntilChanged { $0.distance(from: $1).magnitude &lt; 10.0 }
            .subscribe(onNext: { (location) in
                print(location)
            })
            .disposed(by: disposeBag)
</code></pre>
","3490203","","","","","2020-04-07 11:02:00","Observe an observable every 60 second and compare to its previous value in RxSwift","<ios><swift><reactive-programming><core-location><rx-swift>","1","3","","","","CC BY-SA 4.0"
"61072167","1","61077567","","2020-04-07 03:05:50","","0","397","<p>I'm trying to fetch data from Firebase using RxSwift. I'm using <a href=""https://github.com/RxSwiftCommunity/RxFirebase"" rel=""nofollow noreferrer"">this</a> to perform API calls.</p>

<p>So my db looks like this:
Collection <strong>Category</strong> (it has properties: title, about etc) has inside of it another collection called <strong>Manifests</strong>. To get <strong>Manifests</strong> I need to use <code>documentId</code> of <strong>Category</strong> collection. So it's two different API calls but I want to combine results</p>

<p>That is what I have so far:</p>

<pre><code>    func fetchCategories() -&gt; Observable&lt;[ManifestCategory]&gt; {
        let ref = self.db.collection(FirebaseCollection.manifestCategories.collectionPath)

        return ref.rx.getDocuments().map({ snapshot in
            return snapshot.documents.map({ doc in
                var category = ManifestCategory.init(JSON: doc.data())

                category?.documentId = doc.documentID

                return category
                }).compactMap({ $0 })
        })
    }

    func fetchManifests(categoryId: String) -&gt; Observable&lt;[Manifest]&gt; {
        let ref = self.db.collection(FirebaseCollection.manifests(categoryId: categoryId).collectionPath)

        return ref.rx.getDocuments().map({ snapshot in
            return snapshot.documents.map({ doc in
                var manifest = Manifest.init(JSON: doc.data())

                manifest?.documentId = doc.documentID

                return manifest
            }).compactMap({ $0 })
        })
    }
</code></pre>

<p>Is there any way I can put <strong>Manifests</strong> array into <strong>Category</strong> object?</p>

<p>Thank you!</p>
","4156708","","","","","2020-04-07 10:10:04","RxSwift Combine Array of observables with array of objects","<swift><firebase><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61076147","1","","","2020-04-07 08:48:47","","0","131","<p>I can use <a href=""https://github.com/RxSwiftCommunity/RxBiBinding"" rel=""nofollow noreferrer"">RxBiBinding</a> to bind between two BehaviorRelay like this:</p>

<pre><code>let disposeBag = DisposeBag()

var textFirst = BehaviorRelay&lt;String?&gt;(value: """")
var textSecond = BehaviorRelay&lt;String?&gt;(value: """")

(textFirst &lt;-&gt; textSecond).disposed(by: disposeBag)
</code></pre>

<p>What I can't figure out is how to transform the string traveling between the relays?
Transformation of course is symmetric between first and second and back.</p>
","12675559","","","","","2020-04-13 09:22:25","Binding between two BehaviorRelays with value transformation","<swift><binding><rx-swift>","1","4","","","","CC BY-SA 4.0"
"61178081","1","","","2020-04-12 20:58:06","","0","97","<pre><code>observable.subscribe(onNext: { _ in
    somePrivateFunction()
})
</code></pre>

<p>What is the RxSwift way to test that when <code>observable</code> receives an event the <code>somePrivateFunction</code> actually gets called or not? Since the subscription and the function are in the same class I can't mock it.</p>
","3490203","","","","","2020-04-13 09:10:50","How to test a private function inside an RxSwift observer?","<ios><swift><rx-swift><quick-nimble><rxtest>","1","1","","","","CC BY-SA 4.0"
"61210641","1","","","2020-04-14 14:52:09","","0","223","<p>I have an observable Array and I bind it to a TableView. In that array I have different kind of categories and I want to sort the Array like that the items with the same category are grouped. </p>

<pre class=""lang-swift prettyprint-override""><code>let observableItems = viewModel.getShoppingList().asObservable()
observableItems.bind(to: tableViewShoppingList.rx.items(cellIdentifier: ""shoppingListCell"", cellType: ShoppingListTableViewCell.self)) { row, element, cell in

    print(row)
}
</code></pre>
","13035074","","4667835","","2020-04-14 14:54:50","2020-04-14 15:23:13","Sort an observable array rxswift","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"61234056","1","","","2020-04-15 16:42:23","","2","306","<p>I am new to RxSwift and I apologise how badly the question is framed but I couldn't find the proper terminology.</p>

<p>So basically I have a <code>let infoIconTapped: Driver&lt;Void&gt;</code> in one struct, and I have <code>let shouldShowInfoPopup: Driver&lt;Bool&gt;</code> in another struct.</p>

<p>What I want to do is I want to change the value of (or drive it) <code>shouldShowInfoPopup</code> to <code>true</code> or <code>false</code> using <code>infoIconTapped</code>. This should be done using <code>Driver</code> only which is my requirement.</p>

<p>Any idea on how to do this?</p>
","6805145","","1233251","","2020-04-15 16:44:05","2020-04-16 01:31:24","How do I change value of a property of type Driver<Bool> using a property of type Driver<Void>?","<ios><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61239260","1","","","2020-04-15 21:51:20","","1","26","<p>I have a situation where I have three observables that map to a result stream. </p>

<p>The first observable tells me which of two other observables I should take values from. On every emission of the first observable, the result stream switches to emitting the flatmap of the appropriate observable.</p>

<p>This is a situation that normally can be accomplished via <code>flatMapLatest</code>.</p>

<p>However, on every switch of the flatMap, I also happen to want to replay the latest stale value. This is an issue, because <code>flatMapLatest</code> does not provide for an ability for a replay on old values of existing observables.</p>

<p>See below for an RxMarbles of what I want to accomplish:</p>

<p><a href=""https://i.stack.imgur.com/UsEKk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UsEKk.png"" alt=""RxMarbles""></a></p>

<p>I tried using <code>shareReplay(N)</code>, as in the code below, but that does not seem to solve the issue.</p>

<pre><code>    let Observable1Replay = Observable1.share(replay: 1, scope: .forever)

    let Observable2Replay = Observable2.share(replay: 1, scope: .forever)

    let resultObservable = Observable3
        .flatMapLatest { boolValue in
            if boolValue == true {
               return Observable1Replay
            } else {
               return Observable2Replay
            }
        }
</code></pre>
","7612797","","","","","2020-04-16 02:29:39","FlatMapLatest with Replay","<rx-swift>","1","1","","","","CC BY-SA 4.0"
"61247903","1","61250273","","2020-04-16 10:22:21","","1","32","<p>I want to subscribe to an <code>Observable</code>, but I do not care about events emitted before I subscribed.</p>

<p>There is a hacky way I found using <code>skipUntil</code> operator:</p>

<pre><code>let a: Observable&lt;Int&gt;
// ...
a.skipUntil(Observable.of(0)) // ...
</code></pre>

<p>It uses a new <code>Observable.of(0)</code> to start noticing events from now. But it is kind of hacky, and I want a better way. Ideally:</p>

<pre><code>a.skipUntilNow() // ...
</code></pre>
","3992237","","","","","2020-04-16 17:45:56","Receive events of an Observable from a point of time in Rx","<swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61251026","1","61251027","","2020-04-16 13:09:03","","0","190","<p>I'm using <code>RxSwift</code> in a project and I found that when I bind directly to a selector it captures a strong reference from self and <code>deinit</code> wasn't called.</p>

<p>I was wondering how to make selector/func to deal with only a <code>weak</code> reference of self.</p>

<pre class=""lang-swift prettyprint-override""><code>viewModel.title
  .drive(onNext: updateTitle)
  .disposed(by: disposeBag)

func updateTitle(_ title: String) {
  navigationItem.title = title
}
</code></pre>

<p>What I've tried is</p>

<pre class=""lang-swift prettyprint-override""><code>func updateTitle(_ title: String) {
  weak var weakSelf = self
  weakSelf?.navigationItem.title = title
}
</code></pre>

<p>But still <code>deinit</code> is not getting called.</p>

<hr>

<p>Of course one solution would be to remove the <code>function</code> entirely</p>

<pre class=""lang-swift prettyprint-override""><code>viewModel.title
  .drive(onNext: { [weak self] title in 
    self?.updateTitle(title)
  )
  .disposed(by: disposeBag)
</code></pre>

<p>but I don't to lose the concise binding code.</p>
","7060190","","","","","2020-08-05 18:37:11","Create weak selectors/functions in swift","<swift><binding><selector><rx-swift>","2","0","","","","CC BY-SA 4.0"
"61252876","1","61254383","","2020-04-16 14:34:11","","0","27","<p>I have an <code>Observable</code> and would like it to <code>filter</code> <code>elements</code> that exists in an external <code>array</code>. The problem is that an <code>element</code> obviously can't be compared directly to an <code>array</code>, so I <code>loop</code> the <code>array</code> and then make the comparison. This doesn't work because the return statement needs to be outside of the <code>for</code> loop. </p>

<pre><code>    func scanAndFilterCoreData() -&gt; Observable&lt;BleHandler.BlePeripheral&gt; {

        let request = NSFetchRequest&lt;LocalDoorCoreDataObject&gt;(entityName: ""LocalDoorCoreDataObject"")
        let result = self.coreDataHandler.fetchAll(fetchRequest: request)

        return bleHandler.scan(serviceId: AppSettings.discoverServiceId)
            .flatMap{ Observable.from($0) }
            .filter { value in
                for coreData in result {
                    return value.peripheral.identifier.uuidString == coreData.dPeripheralId
                }
        }
    }
</code></pre>

<p>Being new to <code>Rx</code> I'm thinking there has to be some way to include the external <code>array</code> into the <code>Observable</code> as a second <code>parameter</code>, or how is this done?</p>
","12297975","","","","","2020-04-16 15:44:41","How do I add an external array into my Rx Observable?","<ios><swift><filter><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61259742","1","","","2020-04-16 20:44:40","","1","61","<p>I would like my <code>subject</code> to <code>observe</code> changes on <code>myArray</code> so every time a new element is appended to <code>myArray</code> the <code>subscription</code> fires. </p>

<pre><code>var subject = PublishSubject&lt;[String]&gt;()
var myArray = [""One"", ""Two""]

subject.flatMap{Observable.from($0)}.subscribe(onNext: {
    print($0)
}).disposed(by: disposeBag)

subject.onNext(myArray)

myArray.append(""Three"")

subject.onNext(myArray)
</code></pre>

<p>it works by adding <code>myArray</code> to <code>onNext</code> every time it changes, but is there a way for the <code>subscription</code> to trigger automatically when <code>myArray</code> gets a new <code>element</code> without using <code>onNext</code>? Perhaps by making <code>myArray</code> into an <code>observable</code>?</p>
","12297975","","","","","2020-04-17 12:33:37","How do I make an Rx subject react to new elements added to the array?","<ios><swift><observable><rx-swift>","1","1","","","","CC BY-SA 4.0"
"61287894","1","61307198","","2020-04-18 10:50:06","","3","1265","<p>I do have following structure:</p>

<pre><code>- TableView
-- Custom Table View Cell
--- CollectionView
---- Custom CollectionView Cell
</code></pre>

<p>I want to understand that how can I pass the data from / using view model in this structure with RxSwift - MVVM Structure.</p>

<p>Whenever I do get response from API it should update the data in table view rows and associated collection view cell respectively.</p>
","3122406","","","","","2020-04-22 20:45:17","RxSwift: How to populate the data in collection view cell inside the table view using ViewModel?","<ios><swift><mvvm><rx-swift>","2","0","2","","","CC BY-SA 4.0"
"61315169","1","61315677","","2020-04-20 04:33:45","","0","476","<p>I'm trying to share the result from mapping observables produced by <code>just()</code> operator.</p>

<pre><code>let observable = Observable.just(())
  .map { _ -&gt; String in
    print(""block is called"")
    return ""some transformation""
  }
  .share()

observable
  .subscribe()
  .disposed(by: disposeBag)

observable
  .subscribe()
  .disposed(by: disposeBag)
</code></pre>

<p>But the code produces result twice:</p>

<pre><code>block is called
block is called
</code></pre>

<p>I want the <code>map()</code> to be called once only so I thought <code>share()</code> would be enough. Is there a way to share the result produced by the sample code?</p>
","2809616","","","","","2020-04-20 05:30:00","Is there a way to share RxSwift's observable operator like just, from, of, etc?","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"61366339","1","","","2020-04-22 13:27:57","","0","279","<p>I need to select a specific item in my table view when using the <strong>modelSelected()</strong> method.</p>

<p>When I implemented the <strong>itemSelected()</strong> method I was able to select the item using <strong><em>index.row</em></strong></p>

<pre><code>self.quickLookController.currentPreviewItemIndex = index.row
</code></pre>

<p>I don´t know now how to get the <strong><em>currentPreviewItemIndex</em></strong> of my table view. When I select it it shows a message that no data is available.</p>

<pre><code>        _ = documentTableView.rx.modelSelected(Structured.self).subscribe(onNext: { structured in
            if structured is Document {

//            self.quickLookController.currentPreviewItemIndex = ...

            self.parent?.navigationController?.show(self.quickLookController, sender: self)
            }
            if structured is Structure {
                let structure = structured as! Structure
                let sb = UIStoryboard(name: ""Main"", bundle: nil)
                let documentViewCtrl = sb.instantiateViewController(withIdentifier: ""DocumentListViewController"") as! DocumentListViewController
                self.treeSource?.select(structure)
                documentViewCtrl.treeSource = self.treeSource
                documentViewCtrl.navigationItem.title = structure.name
                self.navigationController?.pushViewController(documentViewCtrl, animated: true)
            }
        })
</code></pre>
","","user12372692","4099593","user12372692","2020-04-23 08:41:35","2020-04-23 08:41:35","How can I select the current index path in RxSwift?","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61370725","1","","","2020-04-22 16:56:46","","0","185","<p>Using RxSwift, is there an equivalent to numberOfRowsInSection? It seems like Rx automatically sets the amount of rows based on the data, but I need to add an additional unique cell at the end of the tableview that doesn't relate to the data. Since the tableView returns automatically once it's gone through all the data, I can't set that cell. Thanks!</p>
","13374458","","","","","2020-04-22 17:45:17","RxSwift TableView - How to set numberOfRowsInSection?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61401030","1","61407079","","2020-04-24 04:12:40","","1","671","<p>I am new to Swift, so maybe the question is a little bit stupid. I don't know why I got the error here:</p>

<pre><code>htmlHelper.fetchHtmlObservable(url) // this one is an Observable&lt;String&gt; function
            .subscribeOn(ConcurrentDispatchQueueScheduler.init(qos: .background))
            .map { //Generic parameter 'Result' could not be inferred
                let parsingHelper = ParsingTypeFactory.getParsingType(parsingType: self.parsingType)
                return parsingHelper.parseActionItems(document: $0)
            }
</code></pre>

<p>To resolve it, I had to add</p>

<pre><code>.map { doc -&gt; [MyItem] in
     let parsingHelper = ParsingTypeFactory.getParsingType(parsingType: self.parsingType)
     return parsingHelper.parseActionItems(document: doc)
}
</code></pre>

<p>When can I omit the <code>params</code> and the <code>return</code> type?</p>
","972671","","","","","2020-04-25 02:00:38","Generic parameter 'Result' could not be inferred with RxSwift","<swift><closures><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61404540","1","","","2020-04-24 08:51:35","","1","201","<p>I have this Observable :</p>

<pre><code>func getCategories() -&gt; Observable&lt;[LKCategory]&gt;{
    return Observable&lt;[LKCategory]&gt;.create { observer -&gt; Disposable in
        self.storeHandler.fetchRegions(forStoreID: self.storeID) { (regions, error) in
            if let uwError = error {
                observer.on(.error(uwError))
            }else {
                observer.on(.next(regions?.map{ self.regionToCategory(region: $0) } ?? [LKCategory]()))
                observer.on(.completed)
            }
        }
        return Disposables.create()
    }
}
</code></pre>

<p>and I subscribe like this :</p>

<pre><code>    self.getCategories()
        .subscribe(onNext: { (cat) in
            print(""print"")
        }, onError: { (error) in
            print(""print"")
        }, onCompleted: {
            print(""print"")
        }, onDisposed: {
            print(""print"")
        }).disposed(by: self.disposeBag)
</code></pre>

<p>I pass into my observable, especially in <code>.next</code> and <code>.completed</code> lines</p>

<p>But in my subscribe, i have no prints...</p>
","2611161","","2611161","","2020-04-24 09:03:00","2020-04-24 09:27:11","RxSwift Observable does not emit value","<ios><swift><observable><rx-swift>","1","2","","","","CC BY-SA 4.0"
"61406672","1","61406880","","2020-04-24 10:52:16","","1","134","<p>I'm having trouble with a <code>BehaviorRelay</code> that has a protocol type and using it on concrete types. Here's my code:</p>

<pre><code>protocol Item {

    var title: { get }

}

struct Can: Item {

    let title = ""Can""

}

let canRelay = BehaviorRelay&lt;Can?&gt;(value: nil)

func handle(item: BehaviorRelay&lt;Item?&gt;) {
    // do something with item here
}

handle(item: canRelay) // can't do this?
</code></pre>

<p>I assumed I would be able to call <code>handle(item:)</code> but it's not the case because the arguments don't match. I get that they don't match, but <code>Can</code> is a type of <code>Item</code> so shouldn't this be possible?</p>
","3320342","","","","","2020-04-24 11:03:16","RxSwift protocol and concrete types","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61429879","1","61435292","","2020-04-25 17:38:17","","7","462","<p>I'm trying to build a countdown timer app. Naturally, I need an <code>Observable&lt;Int&gt;</code> sequence that gives me an element each second. The twist is that I need this sequence to respond to changes to two other sequences:</p>

<ul>
<li>Paused: <code>Observable&lt;Bool&gt;</code>. This models the user pressing the pause/resume button</li>
<li>Reset: <code>Observable&lt;Void&gt;</code>. This models the user pressing the reset button.</li>
</ul>

<p>The reset button will reset the timer back to its starting value (<code>resetState</code>), <em>and also pause the timer</em>.</p>

<p>The user can press the reset button at any time:</p>

<ol>
<li>reset when the timer has not been started</li>
<li>reset when the timer is running, not paused, not ended</li>
<li>reset when the timer is paused, not ended</li>
<li>reset when the timer has ended</li>
</ol>

<p>Combining the answers to <a href=""https://stackoverflow.com/questions/41184162/simple-timer-with-rxswift"">this question</a> and <a href=""https://stackoverflow.com/questions/58047235/countdown-timer-by-rxswift"">this question</a>, I was able to came up with a <code>Timer</code> class like this:</p>

<pre><code>class Timer {
    var paused = true
    {
        didSet {
            rxPaused.accept(paused)
        }
    }
    var ended = false

    let rxPaused = BehaviorRelay(value: true)
    let disposeBag = DisposeBag()

    // timerEvents is the observable that client code should subscribe to
    var timerEvents: Observable&lt;Int&gt;!

    var currentState: Int
    let resetState: Int

    init(resetState: Int) {
        self.currentState = resetState
        self.resetState = resetState
        reset()
    }

    func start() {
        if !ended {
            paused = false
        }
    }

    func pause() {
        paused = true
    }

    func reset() {
        ended = false
        currentState = resetState
        pause()
        timerEvents = rxPaused.asObservable()
            .flatMapLatest {  isRunning in
                isRunning ? .empty() : Observable&lt;Int&gt;.interval(.seconds(1), scheduler: MainScheduler.instance)
            }
            .enumerated().flatMap { (index, int) in Observable.just(index) }
        .map { [weak self] x in (self?.resetState ?? x) - x }
            .take(self.resetState)
        timerEvents.subscribe(onNext: { [weak self]
            timerEvent in
            self?.currentState -= 1
            }, onCompleted: {
                [weak self] in
                self?.ended = true
        }).disposed(by: disposeBag)
    }
}
</code></pre>

<p>Usage:</p>

<pre><code>let timer = Timer(resetState: 20)
timer.timerEvents.subscribe(
    onNext: { [unowned self] (timerEvent) in
        print(timerEvent.state)
        self.updateTimerLabelText()
}).disposed(by: disposeBag)
</code></pre>

<p>This only works as expected in situation 4 mentioned above. </p>

<p>If you try to reset this timer before it ends, things get funny. For example, in situation 1 (resetting before even starting), <code>timerEvents</code> produces two identical elements each seconds. Not only is this incorrect, it also causes <code>currentState</code> to decrease twice as quickly. I suspect that this is because <code>timerEvents</code> is assigned to a second time, before its previous value is completed, but I don't think there is a way to just ""complete"" an uncompleted observable, is there?</p>

<p>And I can't even put in words what happens in situations 2 and 3.</p>

<p>How can I make this resetting timer work?</p>
","5133585","","","","","2020-06-27 01:06:25","How do I make a resettable RxSwift Timer?","<swift><timer><rx-swift>","1","1","1","","","CC BY-SA 4.0"
"61460693","1","61461737","","2020-04-27 14:04:04","","1","571","<p>I fetch <code>core data</code> like this:</p>

<pre><code>var persistingData: [MyDataObject] = coreData.fetchAll(fetchRequest: NSFetchRequest&lt;MyDataObject&gt;(entityName: ""MyDataObject""))
</code></pre>

<p>Now how do I go about using this data for an <code>Observable</code> that can <code>bind</code> the data to an <code>rx</code> <code>tableView</code>?</p>

<p>Do I create an <code>observable</code> like this:</p>

<pre><code>func fetchAllData() -&gt; Observable&lt;[MyDataObject]&gt; {
    var persistingData: [MyDataObject] = coreData.fetchAll(fetchRequest: NSFetchRequest&lt;MyDataObject&gt;(entityName: ""MyDataObject""))

    return Observable.create({ observable in
        observable.onNext(persistingData)
        observable.onCompleted()
        return Disposables.create()
    })
}
</code></pre>

<p>But then how I use <code>bind()</code> on the <code>observable</code> if I pass the data to <code>onNext</code>? <code>bind</code> is used directly on the <code>method</code> like so:</p>

<pre><code>fetchAllData().bind()
</code></pre>

<p>How do I actually get the <code>data</code> into the <code>observable</code> so that it can be used in <code>bind()</code>? </p>

<p><strong><em>EDIT</em></strong></p>

<p>I tried like this as well. Is this a valid way of doing it?</p>

<pre><code>func fetchAllData() -&gt; PublishRelay&lt;[MyDataObject]&gt; {
    var persistingData: [MyDataObject] = coreData.fetchAll(fetchRequest: NSFetchRequest&lt;MyDataObject&gt;(entityName: ""MyDataObject""))

    let relay = PublishRelay&lt;[LocalDoorCoreDataObject]&gt;()
    relay.accept(persistingDoors)
    return relay
}
</code></pre>

<p>Then you can <code>bind</code> to it like this:</p>

<pre><code>viewModel.fetchAllData().bind(to: tableView.rx.items(cellIdentifier: Cell.identifier, cellType: Cell.self)) { row, data, cell in

    cell.viewModel = data

}.disposed(by: disposeBag)
</code></pre>

<p>Does this seem reasonable, or is there some other way?</p>
","8591381","","8591381","","2020-04-27 14:23:07","2020-04-28 01:12:53","How do I create an observable on core data and bind it to tableView","<uitableview><observable><bind><rx-swift>","2","0","","","","CC BY-SA 4.0"
"61479548","1","61481405","","2020-04-28 11:51:40","","1","166","<p>I have a <code>ble</code> scanner that works and looks like this:</p>

<pre><code>func scan(serviceId: String) -&gt; Observable&lt;[BleHandler.BlePeripheral]&gt; {
    knownDevices = []
    return waitForBluetooth()
        .flatMap { _ in self.scanForPeripheral(serviceId: serviceId) }
        .map { _ in self.knownDevices }
}

private func waitForBluetooth() -&gt; Observable&lt;BluetoothState&gt; {
    return self.manager
        .observeState()
        .startWith(self.manager.state)
        .filter { $0 == .poweredOn }
        .take(1)
}
</code></pre>

<p>Then in the <code>viewModel</code> <code>class</code> it filters matches from <code>core data</code>:</p>

<pre><code>func scanAndFilter() -&gt; Observable&lt;[LocalDoorCoreDataObject]&gt; {
        let persistingDoors: [LocalDoorCoreDataObject] = coreDataHandler.fetchAll(fetchRequest: NSFetchRequest&lt;LocalDoorCoreDataObject&gt;(entityName: ""LocalDoorCoreDataObject""))

    return communicationService
        .scanForDevices(register: false)
        .map{ peripherals in
            print(""🐶 THIS WILL GO ON FOR ETERNITY"", peripherals.count)
            self.knownDevices = peripherals
            return persistingDoors
                .filter { door in peripherals.contains(where: { $0.identifier.uuidString == door.dPeripheralId }) }
        }
}
</code></pre>

<p>And in the <code>view</code> I want to connect when the scan is completed:</p>

<pre><code>private func scanAndConnect(data: LocalDoorCoreDataObject) {
    viewModel.scanRelay().subscribe(
        onNext: {
            print(""🐶SCANNED NAME"", $0.first?.dName)},
        onCompleted: {
            print(""🐶COMPLETED SCAN"")
            self.connectToFilteredPeripheral(localDoor: data)
    }).disposed(by: disposeBag)
}
</code></pre>

<p>It never reaches <code>onCompleted</code> as it will just scan for eternity even after having found and <code>filtered</code> the <code>core data</code> match. In Apple's framework <code>coreBluetooth</code> I could simply call <code>manager.stopScan()</code> after it has found what I want, but that doesn't seem to be available on the <code>Rx</code> counterpart. How does it work for <code>RxSwift</code></p>
","8591381","","","","","2020-04-29 12:37:34","How do I stop RxSwift ble scanner once it has found a match?","<ios><swift><bluetooth-lowenergy><rx-swift><rxbluetooth>","2","0","","","","CC BY-SA 4.0"
"61505092","1","61505600","","2020-04-29 15:08:07","","-2","25","<p>Here is my scenario. I have one Subject that is being used together with another Subject in a combineLatest. So far so good. Now i push onCompleted on one of the Subjects but the CombineLatest is still working when the other subject pushes some event.</p>

<p>What i want is that as soon as either of the subjects has completed i want the combineLatest to stop working. Is CombineLatest the right Operator to use here ? Or is there any other operator available ?</p>
","11975968","","","","","2020-04-29 15:32:12","Which rxSwift operator to use in this scenario?","<swift><reactive-programming><rx-swift><rx-cocoa><combinelatest>","1","1","","","","CC BY-SA 4.0"
"61518897","1","","","2020-04-30 08:17:43","","0","133","<p>I am trying to push back data from SecondViewController to FirstViewController. 
I am trying to do this using RxSwift's PublishSubject type.
When I move to FirstViewController I get only information about what I pushed in the console. 
I just want to get this data in testArray object, that will be shown in UITableView. 
There is no error showing data in UITableView, I checked.
Any ideas? ;)</p>

<p>FirstViewController.swift</p>

<pre><code>let disposeBag = DisposeBag()

@objc func addCryptoButtonPressed() {
    DispatchQueue.main.async {
        let viewController = SecondViewController()
        viewController.subject
            .subscribe(onNext: { [weak self] pushedData in
                print(pushedData)                         // &lt;----- it is working
                self?.testArray.append(pushedData)        // &lt;----- it is not
            }).disposed(by: self.disposeBag)
        DispatchQueue.main.async {
            self.mainTableView.reloadData()
        }
        self.navigationController?.pushViewController(viewController, animated: true)
    }
}
</code></pre>

<p>SecondViewController.swift</p>

<pre><code>let subject = PublishSubject&lt;String&gt;()

func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
    DispatchQueue.main.async {
        let name = self.names[indexPath.row]
        self.subject.onNext(name)
        let viewController = FirstViewController()
        self.navigationController?.pushViewController(viewController, animated: true)
    }
}
</code></pre>
","3918906","","","","","2020-04-30 08:31:21","RxSwift doesn't push back data from one ViewController to another","<ios><uitableview><uiviewcontroller><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61520752","1","","","2020-04-30 09:59:47","","2","59","<p>I'm starting my adventure with RxSwift, having small experience with React in js already. I think that my problem is common, but I'm not sure how to describe it in concise abstract way, so instead I will describe it on the example.</p>

<p>I'm building iOS app showing some charts. The part of interest consist of ChartAreaController, ChartInfoController, both embedded in ChartController. First controller is the area showing some graph(based on rx chartData property), and the second one among others will have a slider for user to restrict show x-value (rx selectedXRange property) which is restricted to be between some min and max. The min/max value is defined by the current chart data. </p>

<p>Behavior when slider change updates chart is defined in ChartController: </p>

<pre><code>override func viewDidLoad() {
   super.viewDidLoad()
   (...)
   chartInfoController.selectedXRange.asObservable()
                .subscribe(onNext: { [unowned self] selectedXRange in
                    (...)
                    let chartData = self.filterChartData(from: self.rawChartData, in: selectedXRange)
                    self.chartAreaController.chartData.accept(chartData)
                }).disposed(by: disposeBag)

</code></pre>

<p>The filterChartData() method just filters out data that is not in the range, but for the sake of the argument we can assume it is very costly and I don't want it to run twice when it is not necessary.</p>

<p>When user changes the chart he or she wants to show, the new data arrives from server (again ChartController):</p>

<pre><code>private func handleNewData(_ rawChartData: ChartData) {
        self.rawChartData = rawChartData

        guard let allowedXRange = rawChartData.xRange() else { return }
        let selectedXRange = chartInfoController.selectedXRange.value
        let newSelectedXRange = calculateSelectedXRange(currentSelectedDays: selectedDaysRange, availableDaysRange: daysRange)
        let chartData = filterChartData(from: rawChartData, in: selectedXRange)

        self.chartInfoController.allowedXRange = allowedXRange //this line is not crucial
        self.chartInfoController.selectedXRange.accept(newSelectedXRange)

        self.chartAreaController.chartData.accept(rawChartData)
    }
</code></pre>

<p>So upon new chart data arrival it may be the case that the currently selected xRange must be trimmed because of the new min/max values of the data. So the side effect of the method will be changing the selectedXRange and in turn running the subscription I pasted earlier. So when new data arrives the chartData is updated twice and I don't want it to happen.</p>

<p>Of course I can comment out last line of the handleNewData() method, but I don't like it very much, since main reason for existence of the handleNewData() is to set chartData, and with the line commented out it's goal would be achieved because of the side effect of the method (which is updating the slider). Not acceptable.</p>

<p>To chartData I added throttle anyways, because fast moving slider will result in many updates and this solves my problem partially(chartData updated only once). But as you may remember the filterChartData() method is costly, and this part will still be running twice.</p>

<p>So the one question is, if my general layout of tackling the problem is OK, or should it be handled way different? At this point I came to conclusion that I'm looking for some way of temporary disabling particular subscription on selectedXRange (without damaging other subscriptions to that variable). Temporary meaning:</p>

<pre><code>(...)
//disable subscription
self.chartInfoController.selectedXRange.accept(newSelectedXRange)
self.chartAreaController.chartData.accept(rawChartData)
//enable subscription
(...)
</code></pre>

<p>This seem legit to me, since ChartController as an owner of the subscription and changer of the values may want to disable the subscription whenever it suits him(it?).</p>

<p>Does RxSwift support something like this? If not, then I think I can achieve it myself e.g. via bool property in ChartController, or via adding the subscription to separate disposeBag, which I would dispose and then recreate the subscription. But if it's good thing to do? For example bool solution may be prone to be ill handled when there is some error, and dispose/recreate may be somehow costly, and it may be the case that disposal was not intended to be used like that.</p>

<p>Is there a better practice to handle such situations? As I said I think the problem is common so I hope there is a canonical solution to it :) Thanks for any answer, sorry for the lengthy post.</p>
","11693027","","","","","2020-05-04 07:59:37","Prevent redundant operations in RxSwift","<ios><swift><reactive-programming><rx-swift><rx-cocoa>","2","1","","","","CC BY-SA 4.0"
"61521691","1","61523557","","2020-04-30 10:50:16","","0","192","<p>I am trying to create a NetworkLayer where the requests will return Observable objects.</p>

<p>My idea is to abstract the models with a Protocol/Interface, so the app only knows about the data itself, something like this:</p>

<pre><code>public protocol User {

    var id: String? { get }
    var type: String?  { get }
    var firstName: String?  { get }
    var lastName: String? { get }
}
struct UserDTO: User, Codable {

    var id: String?
    var type: String?
    var firstName: String?
    var lastName: String?

    var username: String?
    var address: String?
    ...
}
</code></pre>

<p>The problem occurred when I try to ""cast"" the Model to the Interface.</p>

<pre><code>class Repository{

    ...
    func getUser(userId: String) -&gt; Observable&lt;User&gt; {

        return networkManager.getUser(userId: userId)
    }
}

class NewtworkManager{

      ...
      func getUser(userId: String) -&gt; Observable&lt;UserDTO&gt; {
        ...
      }
}
</code></pre>

<p>Due to that I receive this error:</p>

<pre><code>Cannot convert return expression of type Observable&lt; UserDTO &gt; to return type Observable&lt; User &gt;
</code></pre>

<p>Do you have any idea how to resolve this? Do I need to map the observable before returning it from the Repository class?</p>
","745459","","745459","","2020-04-30 13:12:09","2020-04-30 13:12:09","How to cast Observable's Value to Protocol Type","<ios><swift><observable><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"61588265","1","61684105","","2020-05-04 08:43:14","","1","134","<p>I am following the <a href=""https://aws-amplify.github.io/docs/ios/authentication"" rel=""nofollow noreferrer"">docs</a> for implementing the login by API, </p>

<pre><code>class AWSUserPool {

    var userAuthenticationError: Error?

    AWSMobileClient.default().signIn(username: &lt;param username&gt;, password: &lt;param password&gt;) { (signInResult, error) in
        if let error = error  {
            print(""\(error.localizedDescription)"")
            self.userAuthenticationError = error
        } else if let signInResult = signInResult {
            switch (signInResult.signInState) {
            case .signedIn:
                print(""User is signed in."")
            case .smsMFA:
                print(""SMS message sent to \(signInResult.codeDetails!.destination!)"")
            default:
                print(""Sign In needs info which is not yet supported."")
            }
        }
    }
}
</code></pre>

<p>I have instantiated the class and the login works when the correct credentials are supplied, I want to show the error message to an alert but I can print the error which is an optional (user not found....) but I am unable to assign it to a class variable.</p>

<pre><code>import RxSwift

        let observable: Observable&lt;Error?&gt; = Observable&lt;Error?&gt;.just(self.awsUserPool?.userAuthenticationError)
        let disposeBag = DisposeBag()


        observable.subscribe { event in
           print(event)
        }
        .disposed(by: disposeBag)
</code></pre>
","6635453","","6635453","","2020-05-08 14:23:26","2020-05-08 16:57:58","AWS Amplify Swift API login iOS Mobile App","<ios><rx-swift><aws-amplify><swift5.1>","1","0","","","","CC BY-SA 4.0"
"61684787","1","","","2020-05-08 17:36:11","","0","563","<p>I want to assign a  value to an BehaviorRelay in RxSwift - RxCocoa. But I get this error message: ""Cannot assign to property: 'value' is a get-only property"". </p>

<p>Thats my code: 
private var todos = BehaviorRelay&lt;[MainToDoData]>(value: [])
todos.value = todosVM.data</p>
","13035074","","","","","2020-05-14 07:09:34","Cannot assign to property: 'value' is a get-only property RxSwift -","<ios><swift><xcode><rx-swift><rx-cocoa>","2","1","","","","CC BY-SA 4.0"
"61717223","1","61741283","","2020-05-10 18:56:40","","3","1387","<p>I have a cold observable that may get called multiple times. This observable does an expensive task (a network request) and then completes. I would like this observable to only ever make a single network call and if I need to call it again in the future I would like to get the last emitted value.</p>

<p>If an observable doesn't complete (i.e. just sends a next value without a completed event) I can use the <strong>.share(replay: 1, scope: .whileConnected)</strong> function to always get the last value. Unfortunately, this doesn't work with observables that completes at the end of the request. Bellow is an example:</p>

<pre><code>let disposeBag = DisposeBag()
let refreshSubject = PublishSubject&lt;Void&gt;()

override func viewDidLoad() {
    super.viewDidLoad()

    let observable = Observable&lt;String&gt;.create { observer in
        let seconds = 2.0
        DispatchQueue.main.asyncAfter(deadline: .now() + seconds) {
            observer.onNext(""Hello, World"")
            observer.onCompleted() // &lt;-- Works when commented out
        }

        return Disposables.create()
    }
    .share(replay: 1, scope: .whileConnected)

    refreshSubject
        .flatMap { _ in observable }
        .subscribe(onNext: { response in
            print(""response: "", response)
        })
        .disposed(by: disposeBag)
}

@IBAction func refreshButtonHandler(_ sender: Any) {
    refreshSubject.onNext(())
}
</code></pre>

<p>Every time the <strong>refreshSubject</strong> is triggered it takes 2 seconds for the <strong>Hello, World</strong> to be printed. If I remove the <strong>observer.onCompleted()</strong> line however, it only takes 2 seconds the first time and subsequently returns a cached response.</p>

<p>Obviously this is just an example, in the real world I would not have any control if the observable completes or not but I would like to always just replay the last value regardless.</p>
","1625364","","","","","2020-05-12 02:48:11","RxSwift replay the last value of a completed observable","<swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"61754667","1","62150866","","2020-05-12 14:42:31","","0","266","<p>I have an <code>Observable</code> that returns a <code>dictionary</code>: </p>

<pre><code>func myFunc() -&gt; Observable&lt;[String : MyClass]&gt; {
    return service.getDictionary()
}
</code></pre>

<p>How do I get ahold of the <code>keys</code> and <code>values</code>?</p>

<pre><code>viewModel.myFunc().subscribe(onNext: {
    print(""🐱"", $0 )
}).disposed(by: disposeBag)
</code></pre>

<p>There's no property like <code>.key</code> or <code>.value</code>. Do I use <code>map</code> or <code>flatMap</code> or how does it work?</p>
","8591381","","","","","2020-06-02 11:21:58","How do I print subscribed dictinary value in RxSwift?","<ios><swift><dictionary><rx-swift>","1","3","","","","CC BY-SA 4.0"
"61776230","1","61784839","","2020-05-13 13:41:02","","0","43","<p>I do have the following view model objects in my Swift code:</p>

<pre><code>class AssetModel {    
  var assetOrder: Observable&lt;Int&gt;
  var title: Observable&lt;String?&gt;
  var thumbnailImageName: Observable&lt;String?&gt;
}

class SectionModel {    
  var assets: Observable&lt;[AssetModel]&gt;
}
</code></pre>

<p>At the UI level, I am willing to subscribe to the assets variable and execute some custom logic for each asset. That is where I get stuck because the asset object has <code>Observable</code> fields and I am not sure how to deal with these nested fields. Here is what I am doing:</p>

<pre><code>sectionModel.assets.subscribe(onNext: { assets in 
    assets.forEach { asset in
        asset.assetOrder.subscribe(onNext: { order in }) // another subscribe here looks very odd
    }
})
</code></pre>

<p>The custom logic I will execute needs the <code>order</code>, <code>title</code> and <code>thumbnailImageName</code> fields at the same time. How do I get all of those 3 fields? I can <code>flatMap</code> them separately but also is defeating the purpose of an object.</p>
","870011","","","","","2020-05-13 21:06:23","How to deal with nested Observable fields?","<ios><swift><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61784945","1","61785080","","2020-05-13 21:12:42","","0","250","<p>I have a view model property defined as following in view model in iOS.</p>

<pre><code>var isIndividualActivity = BehaviorRelay&lt;Bool&gt;(value: false)
</code></pre>

<p>In the view controller, I want to set up below bindings based on the above property.</p>

<ol>
<li>When <code>isIndividualActivity</code> property in view model is set to true, hide team <code>UIView</code> and show individual <code>UIView</code>. When <code>isIndividualActivity</code> is set to false, hide individual <code>UIView</code> and show team <code>UIView</code>. I want to achieve this through binding something like as below.</li>
</ol>

<pre><code>    viewModel.isIndividualActivity
                .bind(to: individualView.rx.isHidden)
            .disposed(by: self.disposeBag)

    viewModel.isIndividualActivity
                .bind(to: teamView.rx.isHidden)
            .disposed(by: self.disposeBag)
</code></pre>

<p>How can use the same property and invert the boolean binding while binding to those two <code>UIView</code>s?</p>

<ol start=""2"">
<li><p>I also want the same property to set the top constraint of a <code>UIView</code> as below. I am looking for an option to transform the boolean data to a <code>CGFloat</code> number while setting up the binding. How can I achieve this?</p>

<pre><code>    viewModel.isIndividualActivity
        .bind(to: pointViewTopConstraint.rx.constant)
    .disposed(by: self.disposeBag)
</code></pre></li>
</ol>

<p>PS: I know that I can use subscribe function on <code>isIndividualActivity</code> and do true/false check and set the view's visibility and top constraint. However, I want to know if there is a way to achieve using inverse boolean binding and converting bool to value while binding.</p>
","12663913","","988260","","2020-05-13 21:20:16","2020-05-13 23:04:01","Transforming property values while setting up binding in RX Swift iOS","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61789977","1","","","2020-05-14 05:31:54","","2","311","<p>I am using Quick, Nimble, and RxSwift. </p>

<p>My goal is to write unit test that test some function with Timer on it which will be executed repeatedly after some time interval.</p>

<p>My pseudo class</p>

<pre><code>final class TestingTimerClass {
    let counter: BehaviorRelay&lt;Int&gt; = BehaviorRelay&lt;Int&gt;(value: 0)
    private var timer: Timer?

    ....

    func startTimer() {

        timer = Timer.scheduledTimer(
            timeInterval: 8,
            target: self as Any,
            selector: #selector(self.executeFunction),
            userInfo: nil,
            repeats: true
        )
    }

    @objc private func executeFunction() {
        let currentValue = counter.value
        counter.accept(currentValue + 1)
    }
}
</code></pre>

<p>My testing class</p>

<pre><code>class TestingTimerClass: QuickSpec {

    override func spec() {
        var testingClass: TestingTimerClass!

        describe(""executing"") {

            context(""startTimer()"") {

                beforeEach {
                    testingClass = TestingTimerClass()
                }

                afterEach {
                    testingClass = nil
                }

                it(""should update counter value after a period of time"") {

                    testingClass.startTimer()
                    expect(testingClass.counter.value).toEventually(equal(1), timeout: TimeInterval(9), pollInterval: TimeInterval(2), description: nil)
                }
            }
        }
    }
}
</code></pre>

<p>I expect that <code>executeFunction()</code> will be called after 8 second, however it is never called and my test suite is failed.</p>

<p>Any idea what went wrong?</p>
","5553151","","","","","2020-06-06 12:25:04","Unit testing swift timer function using nimble","<ios><swift><rx-swift><quick-nimble>","1","1","","","","CC BY-SA 4.0"
"61800865","1","61808393","","2020-05-14 15:11:03","","1","159","<p>I have a <code>cell</code> structure that looks like this: </p>

<p><a href=""https://i.stack.imgur.com/rbZet.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/rbZet.png"" alt=""enter image description here""></a></p>

<p>The <code>contentView</code> has the same <code>backgroundColor</code> as the <code>tableView</code> <code>background</code> (blue) and the nested <code>view</code> has a white color with <code>cornerRadius</code> and 5p <code>autoLayout</code> margin all around, resulting in what looks like separated <code>cells</code>, sort of like separated <code>buttons</code> in a row (let me know if you need an image).</p>

<p>Whenever I click a <code>cell</code> I would like that <code>cell</code> to be highlighted with another color. Normally this would be done in the <code>storyBoard</code> under the <code>attribute inspector</code> <code>selection</code>. But this is strictly connected to the <code>cell</code> and doesn't effect the nested <code>views</code>. I can make the <code>views</code> transparent or remove them altogether and it works, but then I miss out on the illusion of separated <code>cells</code>.</p>

<p>I read here 
<a href=""https://stackoverflow.com/questions/6216839/how-to-add-spacing-between-uitableviewcell"">How to add spacing between UITableViewCell</a> 
that you can use <code>sections</code> to separate the <code>cells</code>. Nice, but the thing is I'm using <code>RxSwift</code> and if I want the <code>numberOfSections</code> <code>delegate</code>, then I also need <code>cellForRowAt</code> and <code>numberOfRows</code> and those sort of conflict with my <code>Rx</code> <code>tableView</code>.</p>

<p>I tried doing it programmatically by adding a <code>tag</code> to my nested <code>view</code>, fetching it like this:</p>

<pre><code>var myView = self.contentView.viewWithTag(1) //self is cell
</code></pre>

<p>and then set the <code>color</code> in the <code>Rx</code> <code>subscription</code>: </p>

<pre><code>    cell?.layer.backgroundColor = UIColor.green.cgColor
</code></pre>

<p>But this just didn't work. Any ideas how to solve this?</p>
","12297975","","","","","2020-05-15 10:59:50","How do I highlight tableView cells using Rx and nested cell views?","<ios><swift><uitableview><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61893406","1","61897022","","2020-05-19 14:21:38","","1","223","<p>I have set up a <code>tableView</code> using <code>Rx</code> and enabled the user to move the <code>cells</code> up and down using <code>rx.itemMoved</code>:</p>

<pre><code>let testData = BehaviorRelay&lt;[String]&gt;(value: [""hello"", ""hello again"", ""hello a third time""])

tableView.isEditing = true

testData.bind(to: tableView.rx.items(cellIdentifier:""cell"")) { row, data, cell in
    cell.textLabel?.text = data
}.disposed(by: disposeBag)

tableView.rx.itemMoved
    .subscribe(onNext: { indexPaths in
        //...
    }).disposed(by:disposeBag)

</code></pre>

<p>It works, and later I will save the indexPaths to <code>coreData</code> and use that data to set up the <code>tableView</code> <code>cells</code> in the order that the user arranged them in. But that's a problem for later. First, I would like to test to rearrange the <code>cells</code> with some dummy <code>data</code> to see if I can change the <code>cell</code> <code>row</code> order as soon as the <code>tableView</code> is <code>populated</code>. Imagine that this dummy <code>data</code> is coming from <code>coreData</code>.</p>

<p>I have no idea how to do this, but I found something here: <a href=""https://github.com/ReactiveX/RxSwift/blob/master/Tests/RxCocoaTests/UITableView%2BRxTests.swift"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxSwift/blob/master/Tests/RxCocoaTests/UITableView%2BRxTests.swift</a>
that I at least think looks like what I need. I tried it below, but it doesn't do anything:</p>

<pre><code>let testRow = IndexPath(row: 0, section: 0)
let testRow2 = IndexPath(row: 2, section: 0)

tableView.dataSource!.tableView!(tableView, moveRowAt: testRow, to: testRow2)
</code></pre>

<p>I also tried</p>

<pre><code>self.tableView.moveRow(at: testRow, to: testRow2)
</code></pre>

<p>The logic seems to be what I want to do, but nothing... so how do I do this?</p>
","12297975","","12297975","","2020-05-19 14:40:18","2020-05-19 17:19:50","How do I arrange the tableView cells to a different order when the tableView is shown?","<ios><swift><uitableview><rx-swift>","1","0","","","","CC BY-SA 4.0"
"61909705","1","61910316","","2020-05-20 09:33:22","","8","1586","<p>I am learning RxSwift at the moment.</p>

<p>When would you use <code>.drive(something)</code> and when <code>.bind(to: something)</code>?</p>

<p>Example:</p>

<pre class=""lang-swift prettyprint-override""><code>let disposeBag = DisposeBag()
let isEnabled = BehaviorRelay(value: true)
let button = UIButton()
// what is the benefit of this:
isEnabled.asDriver().drive(button.rx.isEnabled).disposed(by: disposeBag)
// over this:
isEnabled.bind(to: button.rx.isEnabled).disposed(by: disposeBag)
// or is the above better?
</code></pre>

<p>The answer in <a href=""https://stackoverflow.com/questions/43097102/use-rxswift-driver-and-bind-to"">use RxSwift, driver and bind to</a> doesn’t really help. I do not get why adding <code>asDriver()</code> is even necessary to make it to a thing that can’t fail.</p>
","13580950","","13580950","","2020-05-20 10:24:27","2020-05-20 10:41:12","Difference between `.drive()` and `.bind(to:)`","<ios><swift><rx-swift><rx-cocoa>","1","3","3","","","CC BY-SA 4.0"
"61916448","1","","","2020-05-20 15:05:04","","1","316","<pre><code>struct Contact : Codable, Hashable {
    var id : String
...
}
</code></pre>

<p>I use <code>PublishSubject</code> to feed the data to the <code>UITableView</code></p>

<pre><code>let contacts : PublishSubject&lt;[Contact]&gt; = PublishSubject()
</code></pre>

<p>And when the value is changed on the other view controller, I want to change the specific value in the array.</p>

<p>I want to change the <code>Contact</code> object with the specific id.</p>

<pre><code>contacts.filter {$0.id == contactId}[0].someKey = someValue
</code></pre>

<p>How can I do this with RxSwift?</p>
","1282896","","","","","2020-05-21 01:17:11","RxSwift - change specific object in PublishSubject on event","<swift><rx-swift><reactive>","1","0","","","","CC BY-SA 4.0"
"61926020","1","","","2020-05-21 02:08:12","","0","505","<h3>Issue Description</h3>

<p>I have bigger images pulled from the server that I want to process in the app memory consumption to be smaller as the app consumes a lot o memory in order to show the images in its original form. I  am using Kingfihser and Rxswift, using the snippet below, in all my project. once I added the built-in processor DownsamplingImageProcessor, the images don't get shown until I scroll up or down.</p>

<p>When removing the processor the images get shown without any problem.</p>

<p>the error</p>

<blockquote>
  <p>Kingfisher - Job failed: Processing image failed. Processor: DownsamplingImageProcessor(size: (0.0, 0.0), identifier: ""com.onevcat.Kingfisher.DownsamplingImageProcessor((0.0, 0.0))""). Processing item: image(, {250, 250}).</p>
</blockquote>

<p>Code</p>

<pre><code>
//Setup
   func setupKingfisher() {
        // Set maximum disk cache size for default cache. Default value is 0, which means no limit.
        ImageCache.default.diskStorage.config.sizeLimit = UInt(500 * 1024 * 1024) // 500 MB

        //cache.memoryStorage.config.totalCostLimit = 300 * 1024 * 1024

        // Set longest time duration of the cache being stored in disk. Default value is 1 week
        ImageCache.default.diskStorage.config.expiration = .days(7)

        // Set timeout duration for default image downloader. Default value is 15 sec.
        ImageDownloader.default.downloadTimeout = 10.0
    }
</code></pre>

<pre><code>extension Reactive where Base: UIImageView {

    public var imageURL: Binder&lt;URL?&gt; {
        return self.imageURL(withPlaceholder: R.image.image_logo_cs_big())
    }

    public func imageURL(withPlaceholder placeholderImage: UIImage?) -&gt; Binder&lt;URL?&gt; {

        return Binder(self.base, binding: { (imageView, url) in
            imageView.kf.setImage(
                with: url,
                placeholder: placeholderImage,
                options: [
                    .processor(DownsamplingImageProcessor(size: imageView.bounds.size)),
                    .cacheOriginalImage,
                    .scaleFactor(UIScreen.main.scale),
                    .transition(.fade(1)),
                ])
            {
                result in
                switch result {
                case .success(let value):
                    print(""Kingfisher - Task done for: \(value.source.url?.absoluteString ?? """")"")
                case .failure(let error):
                    print(""Kingfisher - Job failed: \(error.localizedDescription)"")
                }
            }
        })
    }
}

</code></pre>
","2187976","","","","","2020-05-21 02:08:12","Kingfisher + RxSwift DownsamplingImageProcessor image failed","<ios><swift><rx-swift><kingfisher>","0","2","","","","CC BY-SA 4.0"
"61936958","1","","","2020-05-21 14:36:25","","2","201","<p>I have a table view cell with a collection view. both bonded through rxdatasource, I am getting the leak using instruments when the view is loaded. Any thoughts on what could be the reason for this? Thanks.</p>

<p>the leak</p>

<p><img src=""https://user-images.githubusercontent.com/7117097/82472943-6527f980-9ab8-11ea-9d0a-4019b7566aa0.png"" alt=""image""></p>

<p>HomeViewcontroller </p>

<pre><code> let dataSource = RxTableViewSectionedReloadDataSource&lt;HomeSection&gt;(configureCell:  { [weak self] dataSource, tableView, indexPath, item in
            guard let self = self else { return UITableViewCell() }

            switch item {
       ....
            case .homeTrendingItem(let viewModel):
                let cell = (tableView.dequeueReusableCell(withIdentifier: trendingIdentifier, for: indexPath) as? ModelProductsCell)!
                cell.delegate = self
                cell.bind(to: viewModel)
                return cell

            }
        }, titleForHeaderInSection: { dataSource, index in
            let section = dataSource[index]
            return section.title
        })

        output.items
            .bind(to: tableView.rx.items(dataSource: dataSource))
            .disposed(by: rx.disposeBag)
</code></pre>

<blockquote>
  <p>ModelProductsCell</p>
</blockquote>

<pre><code>
func bind(to viewModel: ModelProductsViewModel) {
       let input = ModelProductsViewModel.Input()
       let output = viewModel.transform(input: input)

       output.items
       .bind(to: collectionView.rx.items(cellIdentifier: mainReuseIdentifier, cellType: ProductItemCell.self)) { collectionView, viewModel, cell in
               cell.bind(to: viewModel)
       }.disposed(by: cellDisposeBag)

       collectionView.rx.modelSelected(ProductCellViewModel.self)
           .bind {[weak self] vm in
               self?.delegate?.didTapOnItem(p: vm.product)
       }.disposed(by: cellDisposeBag)

       viewModel.loading.asObservable().bind(to: isLoading).disposed(by: rx.disposeBag)

       viewModel.loading.asDriver().drive(onNext: { [weak self] (isLoading) in
           isLoading ? self?.activityIndicator.startAnimating() : self?.activityIndicator.stopAnimating()
       }).disposed(by: cellDisposeBag)
   }

</code></pre>
","2187976","","2187976","","2020-05-21 15:45:43","2020-05-21 15:45:43","leak in CollectionView using RxDataSources and RxSwift","<ios><swift><rx-swift><rxdatasources>","0","2","","","","CC BY-SA 4.0"
"61977910","1","","","2020-05-23 20:02:28","","0","771","<p>I'm pretty new to RxSwift and, I am using Moya with RxSwift for networking in my app. I have the following function which is used for every request, for a given ProviderType.</p>

<pre class=""lang-swift prettyprint-override""><code>open func request(for target: ProviderType) -&gt; Observable&lt;Response&gt; {

    return provider.rx.request(target)
        .filterSuccessfulStatusCodes()
        .asObservable()
        .catchError { [weak self] error in
          guard let self = self else {
            return Observable.error(error)
          }
          return Observable.error(self.handleError(with: error))
    }
}

</code></pre>

<p>This works pretty well, but now I want to retry the request when the request fails with a status code of 401, after fetching the refresh token. I found <a href=""https://github.com/Moya/Moya/issues/1177#issuecomment-345132374"" rel=""nofollow noreferrer"">this</a> comment on a GitHub issue which tells how it can be achieved but I am still confused how it will work in my case (the comment does not provide context related to how the refresh token mechanism works).</p>
","8252081","","","","","2020-05-23 20:55:45","How to retry a request in Moya with RxSwift?","<ios><swift><reactive-programming><rx-swift><moya>","1","0","","","","CC BY-SA 4.0"
"61983241","1","62017045","","2020-05-24 08:10:02","","0","115","<p>I have been struggling a long time with moving <code>cells</code> in a <code>tableView</code> and getting them in the correct order. I want to be able to drag the <code>cells</code> from one place to another using <code>rx.itemMoved</code>. The order also has to persist over time so I save it to <code>coreData</code> and then <code>sort</code> it according to <code>Date</code> as suggested here: </p>

<p><a href=""https://stackoverflow.com/questions/61955435/is-there-a-way-to-keep-the-sorting-in-core-data-in-the-time-order-the-objects-ar/61957498#61957498"">Is there a way to keep the sorting in core data in the time order the objects are added?</a></p>

<p>But I just can't seem to get it right with the sorting. I don't think I fully understand how to sort it based on date. </p>

<p>I mock data like this: </p>

<pre><code>func mockData() {
    let entity = NSEntityDescription.entity(forEntityName: ""LocalDoorCoreDataObject"", in: context)
    var data: [LocalDoorCoreDataObject] = []
    for i in 1...3 {
        let myEntity = LocalDoorCoreDataObject(entity: entity!, insertInto: context)
        myEntity.dCount = Int16(i)
        myEntity.dName = ""M \(i)""
        data.append(myEntity)
    }
    viewModel.mockedRelay.accept(data.compactMap{ RemoteTableViewCellViewModel(localDoor: $0)})
}
</code></pre>

<p>And this triggers the <code>bind</code> on my <code>tableView</code>:</p>

<pre><code>func setBindings() {
    viewModel.mockedRelay.bind(to: tableView.rx.items(cellIdentifier: RemoteTableViewCell.identifier, cellType: RemoteTableViewCell.self)) { row, data, cell in
        cell.viewModel = data
    }.disposed(by: disposeBag)
}
</code></pre>

<p>Now when I drag a <code>cell</code> from one place to another: </p>

<pre><code>tableView.rx.itemMoved.subscribe(onNext: { [weak self] indexPaths in
    let delete = self?.viewModel.mockedRelay.value[indexPaths.sourceIndex.row]
    self?.deleteOne(position: indexPaths.sourceIndex.row) //deletes object in core data 

    self?.setData2(data: delete!) //add the moved object to cd. A new date is added to it
    self?.completionRelay?.accept(""DATA SAVED"") //Saves data for core data
}).disposed(by: disposeBag)
</code></pre>

<p>When I add a new object to <code>coreData</code> a new date is set: </p>

<pre><code>extension LocalDoorCoreDataObject {
    public override func awakeFromInsert() {
        setPrimitiveValue(Date(), forKey: ""dModifiedDate"")
    }
}
</code></pre>

<p>Now, the thing I don't get is how <code>date</code> should help me sort it in the way I left it when leaving the <code>view</code>. If I have three <code>cells</code> and move one of them, the moved <code>cell</code> gets a higher <code>date</code> and the other two have lower <code>dates</code>. What if I left the moved <code>cell</code> in the middle? Then how would its higher date help me at all? Here's the <code>fetch</code> code:</p>

<pre><code>func fetchMyData2() {
        let request = NSFetchRequest&lt;LocalDoorCoreDataObject&gt;(entityName: ""LocalDoorCoreDataObject"")
        do {
            Observable.of(try context?.fetch(request))
                .map { item in
                    item?.sorted(by: {(item1, item2) -&gt; Bool in
                        let ordered = item1.dModifiedDate?.compare(item2.dModifiedDate!) == .orderedAscending
                        return ordered
                    })
                }
                .subscribe(onNext: { value in
                    self.viewModel.mockedRelay.accept(value!.compactMap {
                        return RemoteTableViewCellViewModel(localDoor: $0)})
                })
                .disposed(by: disposeBag)

        } catch {
            print(""🙊error"", error.localizedDescription) }
    }
</code></pre>

<p>Let me know if there is something I haven't explained clearly enough or if there is additional code I need to post. I'm aware that a lot of this is bad code, but I really just want to get it to work for now.</p>
","12297975","","","","","2020-05-26 07:47:36","How do I sort core data objects by date modified and list it in the right order in a tableView?","<ios><swift><sorting><uitableview><rx-swift>","1","2","","","","CC BY-SA 4.0"
"61987642","1","61994868","","2020-05-24 14:47:30","","1","311","<p>I have a <code>BehaviorSubject</code> where my tableview is bound to through RxDataSources.</p>

<p>Besides that, I have a pull to refresh which creates an observable that updates the data and updates the data in the <code>BehaviorSubject</code> so that my UITableView updates correctly.</p>

<p>Now the question is, how do I handle the error handling for whenever my API call fails?</p>

<p>Few options that I have thought of was:</p>

<ol>
<li>Subscribe to the observer's <code>onError</code> and call the <code>onError</code> of my <code>BehaviorSubject</code>\</li>
<li>Somehow try to <code>concat</code>? or <code>bind(to: ..)</code></li>
<li>Let another subscriber in my <code>ViewController</code> subscribe besides that my tableview subscribes to the <code>BehaviorSubject</code>. </li>
</ol>

<p>Any suggestions? </p>
","1677940","","","","","2020-05-25 02:27:52","RxSwift Make Observable trigger a subject","<ios><swift><observable><rx-swift><reactivex>","1","0","","","","CC BY-SA 4.0"
"62016565","1","","","2020-05-26 07:16:08","","0","49","<p>I would like to emit two different signals for two different sources, but I get crash 
<code>Thread 1: EXC_BAD_ACCESS (code=1, address=0x0)</code> in <code>RxSwift/Event.swift</code> in line 29: <code>return ""next(\(value))""</code> </p>

<p>this is my simplified code:</p>

<pre><code>        let scheduler = TestScheduler(initialClock: 0)

        locationsFactory = TestableLocationsFactory()
        locationsFactory.didReceiveRegion = scheduler.createColdObservable([
        .next(100, regionEvents[0]),
        .next(200, regionEvents[1])
        ]).asObservable()

        locationsFactory.location = scheduler.createColdObservable([
        .next(120, locations[0]),
        .next(220, locations[1])
        ]).asObservable()

        let result = scheduler.createObserver(LocationChange.self)
        let dispatcher = BestAccuracyLocationsDispatcher(persistenceService: persistenceService, apiClient: api, locationManager: locationsFactory)

        subscription = dispatcher.dispatcher.subscribe(result)
        scheduler.start()

        let events = result.events

        XCTAssertEqual(events, [
            .next(120, LocationChange(location: locations[0], trigger: .updateLocations)),
            .next(220, LocationChange(location: locations[1], trigger: .updateLocations)),
        ])
</code></pre>

<p>When I remove <code>locationsFactory.didReceiveRegion</code> or <code>locationsFactory.location</code> it works.</p>

<p>Can I create two different scheduler's observables?</p>
","2493555","","","","","2020-05-26 10:55:39","RxSwift TestScheduler for two sources","<swift><rx-swift><rxtest>","1","0","","","","CC BY-SA 4.0"
"62018821","1","62020479","","2020-05-26 09:26:26","","1","50","<p>I have a view model that's being used in two flows and has gotten to the stage where it should really be split out into a super class and two subclasses. However, I'm getting confused as the best way to go about performing some subclassing.</p>

<p>On creation of the view model, I pass in all the interactions that could happen from the view like so:</p>

<h2>View</h2>

<pre><code>class SomeViewController: UIViewController {

    @IBOutlet private weak var nextButton: UIButton!

    private var presenter: SomeViewModel!

    override func viewDidLoad() {
        super.viewDidLoad()
        presenter.configure(nextButtonTapped: nextButton.rx.tap.asDriver())
    }

}
</code></pre>

<p>Then I can handle these actions within my view model like so:</p>

<h2>ViewModel</h2>

<pre><code>class SomeViewModel {

    private let normalFlow: Bool
    private let diposeBag = DisposeBag()

    init(normalFlow: Bool) {
        self.normalFlow = normalFlow
    }

    func configure(nextButtonTapped: Driver&lt;Void&gt;) {
        handle(nextButtonTapped: nextButtonTapped)
        // call to any other input handlers here...    
    }

    func handle(nextButtonTapped: Driver&lt;Void&gt;) {
        nextButtonTapped.drive(onNext: { [unowned self] in
            guard self.safetyCheckOnePasses(), safetyCheckTwoPasses() else {
                return
            }
            if normalFlow {
                // do some set of actions
            } else {
                // do another set of actions
            }
        }).disposed(by: disposeBag)
    }

    func safetyCheckOnePasses() -&gt; Bool {
        // perform some sanity check...
        return true
    }

    func safetyCheckTwoPasses() -&gt; Bool {
        // perform another sanity check...
        return true
    }

}
</code></pre>

<p>I'm getting confused as to what the best way to override the <code>handle(nextButtonTapped: Driver&lt;Void&gt;)</code> is because I still want those sanity checks to happen at the start of the <code>onNext</code> for every subclass, but I want the body after that to be different for the different subclasses. What would be the best way to go about this without duplicating code?</p>
","3320342","","","","","2020-05-26 10:51:17","RxSwift subclassing best practices","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"62040303","1","","","2020-05-27 09:54:04","","2","79","<p>I have an observable inside a function. 
The function happens in a certain queue, queueA, and the observable is subscribed to with observeOn(schedulerB). In onNext, I'm changing a class variable.</p>

<p>In another function, I'm changing the same class variable, from a different queue.</p>

<p>Here is some code to demonstrate my situation:</p>

<pre><code>class SomeClass {

    var commonResource: [String: String] = [:]
    var queueA = DispatchQueue(label: ""A"")
    var queueB = DispatchQueue(label: ""B"")
    var schedulerB = ConcurrentDispatchQueueScheduler(queue: QueueB)       

    func writeToResourceInOnNext() {
        let obs: PublishSubject&lt;String&gt; = OtherClass.GetObservable()
        obs.observeOn(schedulerB)
           .subscribe(onNext: { [weak self] res in
            // this happens on queue B
            self.commonResource[""key""] = res
        }
    }

    func writeToResource() {
        // this happens on queue A
        commonResource[""key""] = ""otherValue""
    }
}
</code></pre>

<p>My question is, is it likely to have concurrency issues, if commonResource is modified in both places at the same time?</p>

<p>What is the common practice for writing/reading from class/global variables inside onNext in an observable with observeOn?</p>

<p>Thanks all!</p>
","10092068","","10092068","","2020-05-27 10:21:06","2020-05-27 10:59:35","Concurrency issues with observable.observeOn() and common resources","<swift><concurrency><rx-swift><reactivex>","1","0","","","","CC BY-SA 4.0"
"62045079","1","","","2020-05-27 14:05:50","","2","239","<p>I have a custom View, and in this custom View I declared <code>var isSelected: false</code> that is gonna be toggle when taping on the view.</p>

<p>After I add two of those custom Views in my ViewController.</p>

<p><strong>What I need is</strong>: When I select one of view, the other one is immediately deselected, so only one can be selected at the same time.</p>

<p>I don't have much knowledge about it, but I assume that with RxCocoa (or ideally RxSwift) it might be possible to set this <code>isSelected</code> variable of each view as an observable, and then in the subscription, set the other one to false once it turns true.</p>

<p>Help will be much appreciated, thank you in advance.</p>
","9898011","","","","","2020-05-28 00:55:34","Subscribe to a variable of a custom UIView","<ios><swift><reactive-programming><rx-swift><rx-cocoa>","1","2","","","","CC BY-SA 4.0"
"62082443","1","62084625","","2020-05-29 09:12:05","","2","92","<pre><code>func bindSearchTextField() {
        searchTextField.rx.text.asObservable().skip(3)
            .debounce(0.3, scheduler: MainScheduler.instance)
            .subscribe(onNext: { [weak self] searchText in
                guard let strongSelf = self else {
                    return
                }
                if let text = searchText {
                    if text == """" {
                        self?.hideLoader()
                        self?.clearButton.isHidden = true
                    } else {
                        self?.clearButton.isHidden = false
                    }
                    strongSelf.presenter?.getAreaCodeList(text: text)
                }
            }).disposed(by: disposeBag)
    }
</code></pre>

<p>I'm getting this error after i updated my RxSwift to latest version (from 4.4.0 to 5.1.1).
Can anyone help me here?</p>
","11669037","","","","","2020-05-29 11:13:38","RxSwift Error: Property 'text' requires that 'UITextField' inherit from 'UILabel'","<ios><xcode><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"62131257","1","62141356","","2020-06-01 11:36:09","","0","1052","<p>I may be going about this the wrong way, but I have a function with which I want to emit multiple values over time. But I don’t want it to start emitting until something is subscribed to that object. I’m coming to combine from RxSwift, so I’m basically trying to duplicated Observable.create() in the RxSwift world. The closest I have found is returning a Future, but futures only succeed or fail (so they are basically like a Single in RxSwift.) </p>

<p>Is there some fundamental thing I am missing here? My end goal is to make a function that processes a video file and emits progress events until it completes, then emits a URL for the completed file. </p>
","11017643","","","","","2020-06-01 21:34:52","Swift Combine Future with multiple values?","<swift><rx-swift><combine>","1","1","","","","CC BY-SA 4.0"
"62146513","1","","","2020-06-02 07:00:52","","0","211","<p>Suppose I have two notifications coming one after another. I need to wait for work to complete from 1st notification and only then fire the work from 2nd notification. For now, I tried to schedule sequences to a serial scheduler, but it doesn't work as expected, it seems that I'm missing something.</p>

<pre><code>NotificationCenter.default.rx.notification(.notification1)
  .observeOn(MainScheduler.instance)
  .subscribe(onNext: { [weak self] in
     self?.doSomeAsynchWork() //Fires another subscription, kind of ugly
  })
  .disposed(by: disposeBag)


NotificationCenter.default.rx.notification(.notification2)
  .observeOn(MainScheduler.instance)
  .subscribe(onNext: { [weak self] in
     self?.doSomeWork() //This should only be executed after doSomeAsynchWork() is done
  })
  .disposed(by: disposeBag)
</code></pre>

<p>I was expecting work to be done in a serial manner, but that's not the case, my guess is that <code>doSomeAsynchWork()</code> is, well, asynchronous and <code>doSomeWork()</code> fires right after. But can I somehow wait for asynchronous work to complete? Any help is appreciated</p>

<p>UPD: notification2 may or may not arrive, so they are kind of independent of each other. Also, notification1 may or may not arrive, it's just different use cases in the app. But when both notification1 and notification2 are present, I need to wait for <code>doSomeAsynchWork()</code> to finish</p>

<p>The flow is as follows:</p>

<ol>
<li>User taps to block some element in the list, which is only allowed for a signed-in user</li>
<li>User gets redirected to a sign-in screen </li>
<li>User sings in and then, notification1 fires</li>
<li>We continue to block that element now that we're signed in</li>
<li>Notification2 fires</li>
</ol>

<p>The problem is when notification1 fired, we need to reload the screen, so that logic comes to doSomeAsynchWork(). On top of that, we're getting the ""delete element"" notification and we're trying to locate the element which is not there yet, so we're kind of stuck with an inconsistent state, where the element's blocked, but still present on a screen</p>

<p>The difficulty is that we can sign-in without blocking element and we can block element without the need of signing-in in (because we are already signed-in for example)</p>
","9505639","","9505639","","2020-06-02 13:04:12","2020-06-02 13:56:02","RxSwift: How to respond to a series of notifications?","<swift><rx-swift>","1","3","","","","CC BY-SA 4.0"
"62171223","1","","","2020-06-03 10:59:30","","-1","682","<p>I am trying to create a simple timer with RxSwift and I inspired from this answer (). It works fine when the application is in foreground. The problem is that if the application state goes to the background, it stops and then starts to count from where it stays if the app state is foreground again.</p>

<p><a href=""https://stackoverflow.com/a/41198811/3950721"">https://stackoverflow.com/a/41198811/3950721</a></p>

<p>To quick look;
<a href=""https://i.stack.imgur.com/M9Di7.png"" rel=""nofollow noreferrer"">Simple Timer with RxSwift</a></p>
","3950721","","","","","2020-06-08 09:53:45","Observable.interval not working in background state","<ios><swift><background><rx-swift>","2","0","","","","CC BY-SA 4.0"
"62184822","1","","","2020-06-04 00:15:24","","2","96","<p><strong>TL;DR;</strong></p>

<p>I need to find out a way to setup <code>combineLatest</code> that processes events only after particular <code>self.myMethod()</code> is called <strong>without subscribing in that method</strong>.</p>

<p><strong>Description</strong></p>

<p>My component <code>A</code> has a <code>subscribe()</code> routin in <code>init()</code>, where all Rx subscriptions are set up.</p>

<pre><code>import RxSwift

final class A {

    let bag = DisposeBag()

    init() {
        //...
        subscribe()
    }

    //...

    private func subscribe() {
        // Setup all Rx subscriptions here
    }
</code></pre>

<p>There are two other dependencies <code>B</code> and <code>C</code>, each having their statuses that <code>A</code> needs to <code>combineLatest</code> and yield some UI Event upon that combination.</p>

<pre><code>Observable.combineLatest(b.status,
                         c.status)
        .filter { $0.0 == .connecting &amp;&amp; $0.1 == .notReachable }
        .map { _ -&gt; Error in
            return AError.noInternet
        }
        .debounce(RxTimeInterval.seconds(5), scheduler: MainScheduler.instance)
        .subscribe(onNext: { [weak self] error in
            self?.didFail(with: error)
        })
        .disposed(by: bag)
</code></pre>

<p><code>A</code> is not a UI component and basically handles business logic, thus it should wait until UI ""says"" it is ready to handle that business logic. E.g., after <code>myMethod()</code> is called on <code>A</code> by UI layer.</p>

<p><strong>Problem</strong></p>

<p>I do want to have the <code>Observable.combineLatest</code> in <code>subscribe()</code> being setup in a way that waits until <code>myMethod()</code> is called and then immediately receives latest events from <code>B</code>'s <code>status</code> and <code>C</code>'s <code>status</code>.</p>

<p>Currently I do it this way in <code>A</code>:</p>

<pre><code>public func myMethod()
    // ... 
    Observable.combineLatest(...
}
</code></pre>

<p>, which breaks the clean code I am striving to. </p>
","1492173","","1492173","","2020-06-10 21:10:26","2020-06-10 21:10:26","Wait combineLatest until #selector is called","<swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"62190804","1","62193047","","2020-06-04 09:05:06","","2","409","<p>If I have the following code</p>

<pre><code>func handle(showEmptyView: Driver&lt;Bool&gt;) {
    showEmptyView
        .drive(onNext: setEmptyViewShown)
        .disposed(by: disposeBag)
}

func setEmptyViewShown(_ show: Bool) {
    tableView.isHidden = !show
    emptyView.isHidden = show
}
</code></pre>

<p>Is this a retain cycle when I call <code>setEmptyViewShown</code> because I don't use <code>weak</code> or <code>unowned</code> self?</p>
","3320342","","4667835","","2020-06-04 09:08:32","2020-06-04 11:03:44","Understanding retain cycles in RxSwift","<ios><swift><memory-management><rx-swift>","1","2","","","","CC BY-SA 4.0"
"62207229","1","62213762","","2020-06-05 02:39:17","","1","97","<p>I've got an observable that I need to retry a few times if it failed. And I'm currently trying to unit test it. So far I have done this and it failed and always returned 1 instead of 11 times:</p>

<pre><code>func testSetCreated_ShouldRetry10Times_BeforeStopping() throws {
    let setCreatedProvider: (String, String) -&gt; Single&lt;ResponseData&gt; = { (_, _) in
        return .error(RxCocoaURLError.unknown)
    }
    let statusHandler = createConsultationHandler(setCreatedProvider: setCreatedProvider)

    var setCreatedEmitCount = 0
    statusHandler.setCreated(consultationId: .random(length: 24))
        .subscribe(onError: { _ in
            setCreatedEmitCount += 1
        })
        .disposed(by: disposeBag)

    sleep(10)
    XCTAssertEqual(11, setCreatedEmitCount)
}
</code></pre>

<p>So, how exactly can I test that this will be called max 11 times if failing? Thanks.</p>
","4124849","","","","","2020-06-05 10:57:58","How do you test if an observable is retried X times when failing?","<swift><rx-swift><xctest>","1","0","","","","CC BY-SA 4.0"
"62212793","1","62213883","","2020-06-05 10:03:03","","2","113","<p>I have a <code>method</code> that returns a <code>Single</code>: </p>

<pre><code>func getEventStatus() throws -&gt; Single&lt;EventModel?&gt; {
    return try mainService.getEventStatus()
}
</code></pre>

<p>And I tried to <code>bind</code> it to a <code>tableView</code> but got an <code>error</code> saying that it doesn't work on <code>Singles</code>, so I tried adding <code>.asObservable()</code> but now I get the <code>error</code> </p>

<blockquote>
  <p>Expression type 'Reactive&lt;_>' is ambiguous without more context</p>
</blockquote>

<p>I have tried to look up what it means but there doesn't seem to be any consistency to what the <code>error</code> means, or I can't seem to apply it to my case. This is what the <code>bind</code> looks like: </p>

<pre><code>viewModel.getEventStatus().asObservable().bind(to: tableView.rx.items(cellIdentifier: EventLogTableViewCell.identifier, cellType: EventLogTableViewCell.self)) { row, data, cell in
    cell.viewModel = data
}.disposed(by:disposeBag)
</code></pre>

<p>As the <code>method</code> <code>throws</code> I added <code>do { try catch{} }</code> but that doesn't seem to make a difference.</p>

<p>What am I missing here?</p>
","8591381","","","","","2020-06-05 11:04:30","How do I solve ""Reactive<_>' is ambiguous"" error in tableView context","<ios><swift><uitableview><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"62249416","1","","","2020-06-07 17:51:17","","0","92","<p>I have a token response with expiry time and I want to be able to present a view once the expiry time is reached. The expiry passed as a date String from the server but I am currently converting it to int with the purpose of using timeInterval to compare it with current time and if it equal to or less than the current time, the view should be presented.</p>

<p>I planned on using an Observables to listen on login so I pass the time int into a <code>BehaviorRelay</code> then I have a <code>BaseviewController</code> which all view controllers inherit from. Once I do this, I subscribe to the <code>Behavior</code>.</p>

<p>I created a SessionMonitor Protocol</p>

<pre><code>protocol SessionMonitor {
    var isTokenExpired: BehaviorRelay&lt;Int?&gt; { get }
}
</code></pre>

<p>I then extended my LoginPresenter</p>

<pre><code>    class LoginPresenter: LoginProtocol.Presenter, SessionMonitor {
        var isTokenExpired = BehaviorRelay&lt;Int?&gt;(value: 0)

         ....

 // In my login function

     func login(....) {
       //http response
       guard let interval = resp.tokens?.first?.getExpires()?.timeIntervalSinceReferenceDate.int else { return
                }
                self.isTokenExpired.accept(interval)
       }
    }
</code></pre>

<p>so in my Parent view controller I have this </p>

<pre><code>private var presenter: SessionMonitor?
</code></pre>

<p>in the viewDidload</p>

<pre><code>override func viewDidLoad() {
        super.viewDidLoad()
        isTokenExpired.observeOn(MainScheduler.instance).subscribe(onNext: { time in
            log(time, .happy)
        }).disposed(by: rx.disposeBag)
}
</code></pre>

<p>But I do not get anything in my log on Login successful despite seeing that the expiry time is present in my response.</p>

<p>Also I just decided to try this approach to solve my problem and if anyone with a better way to go about this, I would be glad.</p>

<p>More code would be supplied on request.</p>
","8310287","","","","","2020-06-07 17:51:17","Creating a session manager to know timeout swift","<swift><rx-swift>","0","2","","","","CC BY-SA 4.0"
"62260402","1","62261461","","2020-06-08 10:52:13","","1","115","<p>I'm struggle with following challenge. I created table view with custom cell that contains switch. I wanna only one switch can be on i.e, for instance after launch I switched on 3rd switched and then I switched on 7th switch and thus the 3rd one is switched off and so on. I use rx + protocols for cell and don't understand all the way how to determine which switch was toggled. Previously I was going to use filter or map to look up in dataSource array which switch is on and somehow handle this, but now I messed up with it. I'm not sure it's possible without using table view delegate methods. Thanks a lot, hope someone could explain where I am wrong. </p>

<p>//My cell looks like this: <a href=""https://i.stack.imgur.com/bH0ws.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bH0ws.png"" alt=""enter image description here""></a></p>

<p>// CellViewModel implementation </p>

<pre><code>    import Foundation
    import RxSwift

protocol ViewModelProtocol {
    var bag:DisposeBag {get set}

    func dispose()
}

class ViewModel:ViewModelProtocol {
    var bag = DisposeBag()

    func dispose() {
        self.bag = DisposeBag()
    }
}


protocol CellViewModelProtocol:ViewModelProtocol {
    var isSwitchOn:BehaviorSubject&lt;Bool&gt; {get set}
}

class CellVM:ViewModel, CellViewModelProtocol {
    var isSwitchOn: BehaviorSubject&lt;BooleanLiteralType&gt; = BehaviorSubject(value: false)

    let internalBag = DisposeBag()

    override init() {

    }

}
</code></pre>

<p>//My Cell implementation </p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class Cell:UITableViewCell {

    static let identifier = ""cell""

    @IBOutlet weak var stateSwitch:UISwitch!

    var vm:CellViewModelProtocol? {
        didSet {
            oldValue?.dispose()
            self.bindUI()
        }
    }

    var currentTag:Int?

    var bag = DisposeBag()

    override func awakeFromNib() {
        super.awakeFromNib()
        self.bindUI()
    }

    override func prepareForReuse() {
        super.prepareForReuse()
        self.bag = DisposeBag()
    }


    private func bindUI() {
        guard let vm = self.vm else { return }

        self.stateSwitch.rx.controlEvent(.valueChanged).withLatestFrom(self.stateSwitch.rx.value).observeOn(MainScheduler.asyncInstance).bind(to: vm.isSwitchOn).disposed(by: vm.bag)

    }
}
</code></pre>

<p>//TableViewController implementation </p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class TableViewController: UITableViewController {

    private var dataSource:[CellViewModelProtocol] = []

    var vm = TableViewControllerVM()

    override func viewDidLoad() {
        super.viewDidLoad()
        self.tableView.estimatedRowHeight = 70
        self.tableView.rowHeight = UITableView.automaticDimension
        self.bindUI()
    }

    private func bindUI() {
        vm.dataSource.observeOn(MainScheduler.asyncInstance).bind { [weak self] (dataSource) in
            self?.dataSource = dataSource
            self?.tableView.reloadData()
        }.disposed(by: vm.bag)
    }


    // MARK: - Table view data source

    override func numberOfSections(in tableView: UITableView) -&gt; Int {
        return 1
    }

    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        return self.dataSource.count
    }

    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: Cell.identifier, for: indexPath) as! Cell

        if cell.vm == nil {
            cell.vm = CellVM()
        }

        return cell
    }

}

class TableViewControllerVM:ViewModel {

    var dataSource:BehaviorSubject&lt;[CellViewModelProtocol]&gt; = BehaviorSubject(value: [])

    let internalBag = DisposeBag()

    override init() {
        super.init()
        dataSource.onNext(createDataSourceOf(size: 7))
        self.handleState()
    }

    private func createDataSourceOf(size:Int) -&gt; [CellViewModelProtocol] {
        var arr:[CellViewModelProtocol] = []
        for _ in 0..&lt;size {
            let cell = CellVM()
            arr.append(cell)
        }
        return arr
    }

    private func handleState() {

    }
}
</code></pre>
","8919108","","","","","2020-06-09 13:09:02","Only one switch is on","<ios><swift><functional-programming><switch-statement><rx-swift>","2","2","","","","CC BY-SA 4.0"
"62305210","1","","","2020-06-10 13:46:32","","0","31","<p>I have an <code>RxTableView</code> that is binding data from a <code>relay</code>. When I check the data before <code>binding</code> it, I get around 10 data objects, but the <code>tableView</code> <code>cell</code> only display the last one. </p>

<p>In my <code>viewModel</code> I have a reload <code>method</code>:</p>

<pre><code>var bufferEvent = ReplaySubject&lt;EventModel&gt;.create(bufferSize: 99)
let content = BehaviorRelay&lt;[EventStatusTableViewCellViewModel]&gt;(value: [])


func reloadTableViewContent() -&gt; Observable&lt;EventModel&gt; {
    return eventService.bufferEvent.do(onNext: { event in
        print(""THIS RETURNS 8 OBJECTS"", event.id)
        self.content.accept([EventStatusTableViewCellViewModel(eventStatus: event)])
    })
}
</code></pre>

<p>The print returns 8 objects.
In my <code>viewController</code> I call <code>viewModel.reloadTableViewContent().subscribe().disposed(by: diposeBag)</code> </p>

<p>and set the <code>bindings</code>: </p>

<pre><code>private func setBindings() {
    print(""THIS IS ZERO"", viewModel.content.value.count)

    viewModel.content.bind(to: tableView.rx.items(cellIdentifier: EventLogTableViewCell.identifier, cellType: EventLogTableViewCell.self)) { row, data, cell in
        cell.viewModel = data
    }.disposed(by: disposeBag)
}
</code></pre>

<p>The <code>tableView</code> only shows the very last object, but ignores the rest for some reason.</p>

<p>Why doesn't this work? Let me know if there is additional code I need to show, like the <code>cell</code> for instance. </p>
","8591381","","8591381","","2020-06-10 13:58:27","2020-06-10 14:15:27","Rx tableView only gives me last value in cell despite there being numerous data objects","<ios><swift><tableview><rx-swift>","1","0","","","","CC BY-SA 4.0"
"62378497","1","","","2020-06-14 21:33:43","","4","887","<p>I have a view structured like a form that creates a model object. I am trying to bind the form elements (<code>UIControl</code>) to the model properties, so that the views auto-update when their corresponding model property is changed, and the model update when the controls are changed (two way binding). The model can change without the view knowing because multiple views can be linked to one same model property.</p>

<h3>Approach 1: Plain Swift</h3>

<p>My problem is the following: to observe changes to the model properties, I tried to use <a href=""https://developer.apple.com/documentation/swift/cocoa_design_patterns/using_key-value_observing_in_swift"" rel=""nofollow noreferrer"">KVO in Swift</a>, and specifically the <code>observe(_:changeHandler:)</code> method.</p>

<pre><code>class Binding&lt;View: NSObject, Object: NSObject, ValueType&gt; {
    weak var object: Object?
    weak var view: View?

    var objectToViewObservation: NSKeyValueObservation?
    var viewToObjectObservation: NSKeyValueObservation?

    private var objectKeyPath: WritableKeyPath&lt;Object, ValueType&gt;
    private var viewKeyPath: WritableKeyPath&lt;View, ValueType&gt;

    init(betweenObject objectKeyPath: WritableKeyPath&lt;Object, ValueType&gt;,
         andView viewKeyPath: WritableKeyPath&lt;View, ValueType&gt;) {
        self.objectKeyPath = objectKeyPath
        self.viewKeyPath = viewKeyPath
    }

    override func bind(_ object: Object, with view: View) {
        super.bind(object, with: view)
        self.object = object
        self.view = view

        // initial value from object to view
        self.view![keyPath: viewKeyPath] = self.object![keyPath: objectKeyPath]

        // object --&gt; view
        objectToViewObservation = object.observe(objectKeyPath) { _, change in
            guard var view = self.view else {
                // view doesn't exist anymore
                self.objectToViewObservation = nil
                return
            }

            guard let value = change.newValue else { return }
            view[keyPath: self.viewKeyPath] = value
        }

        // view --&gt; object
        viewToObjectObservation = view.observe(viewKeyPath) { _, change in
            guard var object = self.object else {
                // object doesn't exist anymore
                self.viewToObjectObservation = nil
                return
            }

            guard let value = change.newValue else { return }
            object[keyPath: self.objectKeyPath] = value
        }
    }
}
</code></pre>

<p>However some of the properties of my model have types <code>CustomEnum</code>, <code>CustomClass</code>, <code>Bool?</code>, and <code>ClosedRange&lt;Int&gt;</code>, and to use observe I had to mark them as <code>@objc dynamic</code>, which yielded the error:</p>

<p><code>Property cannot be marked @objc because its type cannot be represented in Objective-C</code></p>

<h3>Approach 2: Using RxSwift <code>rx.observe</code></h3>

<p>I turned to RxSwift and the <code>rx.observe</code> method thinking I could work around this problem, but the same thing happened (at runtime this time). </p>

<pre><code>// In some generic bridge class between the view and the model
func bind(to object: SomeObjectType) {
    object.rx
        .observe(SomeType.self, ""someProperty"")
        .flatMap { Observable.from(optional: $0) }
        .bind(to: self.controlProperty)
        .disposed(by: disposeBag)
}
</code></pre>

<h3>Approach 3: Using RxSwift BehaviorRelays?</h3>

<p>This is my first experience with RxSwift, and I know I should be using BehaviorRelay for my model, however I don't want to change all my model properties as my model object is working with other framework. I could try to implement a bridge then, to transform model properties into BehaviorRelay, but I would come across the same problem: <strong>how to listen for model changes</strong>. </p>

<p><a href=""https://stackoverflow.com/questions/51004283/how-to-observe-objects-property-in-rxswift"">In this question</a>, there were no answer as to how to listen for property changes without refactoring all model properties to RxSwift's <code>Variable</code> (currently deprecated).</p>

<h3>Approach 4: Using <code>didSet</code> Swift property observer?</h3>

<p>The <code>didSet</code> and <code>willSet</code> property observers in plain Swift would allow listening for changes, however this would require to mark all the properties in the model with these observers, which I find quite inconvenient, since my model object has a lot of properties. If there is a way to add these observers at runtime, this would solve my problem. </p>

<hr>

<p>I believe that what I am trying to achieve is quite common, having a set of views that modify a model object, however I can't find a way to properly link the model to the view, so that both auto-update when needed. </p>

<p>Basically, I'm looking for an answer to one of the following questions:</p>

<ul>
<li>Is there something I overlooked, is there a better way to achieve what I want?</li>
<li><em>or</em> How to overcome the ""Property cannot be marked @objc"" problem?</li>
<li><em>or</em> How to bridge my model object to BehaviorRelay without changing my model?</li>
<li><em>or</em> How to add <code>didSet</code> observers at runtime?</li>
</ul>
","3780788","","","","","2020-06-15 11:35:40","Binding model and view: how to observe object properties","<ios><swift><architecture><rx-swift><observer-pattern>","1","0","","","","CC BY-SA 4.0"
"62436596","1","62440711","","2020-06-17 19:09:19","","2","38","<p>I have some code that should listen for when some observable operations is finished, but i'am having trouble writing it in the most optimal way.</p>

<p>It's important that the final subscribed result is event, and that the updateEvent is run last.</p>

<p>Here is my code:</p>

<pre><code>/// Update Event
///
/// Updates an event and invites or removes any members from the event before updating the actual event information. This ensures newly updated event to contain the updated list of attendes
///
/// - Parameters:
///   - event: The event to update
///   - group: The group that the event belongs to
///   - newMembers: A list of new group members that should be invited to the invited
///   - removeMembers: A list of event attendees that should be removed from the event
func updateEvent(_ event: EventModel, _ group: GroupModel, newMembers: [MemberModel], removeMembers: [AttendanceModel]) {

    let updateEventObserver = self.repository.updateEvent(group, event)
    var memberObservers: [Observable&lt;AttendanceModel&gt;] = []

    if newMembers.count &gt; 0 {
        memberObservers.append(contentsOf: newMembers.map { (member) in
            return self.repository.inviteToEvent(member: member, event: event, group: group)
        })
    }

    if removeMembers.count &gt; 0 {
        memberObservers.append(contentsOf: removeMembers.map { (member) in
            return self.repository.removeFromEvent(member: member, event: event, group: group)
        })
    }

    if memberObservers.count &gt; 0 {

        Observable
            .zip(memberObservers)
            .subscribe(onNext: { (_) in
                updateEventObserver
                    .subscribe(onNext: { event in
                        self.presenter.eventSuccessfullyUpdated(event)
                    }, onError: { error in
                        self.presenter.failedWithError(error)
                    }).disposed(by: self.disposeBag)
            }, onError: { (error) in
                self.presenter.failedWithError(error)
            }).disposed(by: self.disposeBag)
    } else {
        updateEventObserver
            .subscribe(onNext: { event in
                self.presenter.eventSuccessfullyUpdated(event)
            }, onError: { error in
                self.presenter.failedWithError(error)
            }).disposed(by: self.disposeBag)
    }

}
</code></pre>

<p>I think my code is ""ugly"" and i feel there is a better way. Thank you!</p>
","579808","","579808","","2020-06-17 19:23:15","2020-06-18 01:02:32","RXSwift chaining observers and catch errors","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"62445849","1","","","2020-06-18 08:40:58","","0","436","<p>I need to handle UITextField statuses.</p>

<p>So I bind my emailTextField with this way</p>

<pre><code>Observable.combineLatest(
            emailTxf.rx.controlEvent(.editingDidBegin),
            emailTxf.rx.controlEvent(.editingChanged),
            emailTxf.rx.controlEvent(.editingDidEnd))
            .asObservable()
            .subscribe(onNext: { [weak self] _ in
                // DoSomething()
            }).disposed(by: disposeBag)
</code></pre>

<p>This code can't cover the clear button on UITextField. <br>
So If I press the <strong>clear button</strong> after writing something on UITextField, It doesn't detect the textField status. <br></p>

<p>I know there is <strong>allEditingEvents</strong> control event. <br>
But not sure it's okay to use <strong>allEditingEvents</strong> for detecting <strong>clear button</strong> <br>
Is this okay to use <strong>allEditingEvents</strong>? or is there better way to handle it?</p>
","4963520","","","","","2020-06-18 09:04:31","How to bind UITextField clear button with RxSwift","<ios><swift><uitextfield><rx-swift><uitextfielddelegate>","1","1","","","","CC BY-SA 4.0"
"62452048","1","62461722","","2020-06-18 14:15:11","","0","764","<p>I have 3 observables namely source, source1 and source2. What I want is whenever source emits distinct event get the value of source1 and source2. This is the code I've come up with, obviously it won't compile since withLatestFrom expects only one observable.</p>

<pre><code>source.distinctUntilChanged()
        .withLatestFrom(source1, source2) { ($0, $1.0, $1.1) }
        .subscribe(onNext: { (A, B, C) in
            print(""OnNext called"")
        })
        .disposed(by: bag)
</code></pre>
","3490203","","","","","2020-06-19 01:02:19","RxSwift Use withLatestFrom operator with multiple sources","<ios><swift><rx-swift><reactive><combine>","2","0","","","","CC BY-SA 4.0"
"62458371","1","62461693","","2020-06-18 19:55:35","","1","40","<p>im new in RxSwift, and this is what i want to achieve, hope you guys can help me out.</p>

<p>I have an observable that syncs my info with the server and caches the response and returns an Observable (succeded or failed), what i want to do is once i have this succeed code... go and get the information that is in the cache, but the error i keep getting is </p>

<blockquote>
  <p>Cannot convert value of type '(_) -> Observable' to expected argument type '((Bool) throws -> Void</p>
</blockquote>

<p>I know that is because of my sync method returns a bool, but i dont know how can i trigger the cache pull info after the sync has happened.</p>

<p>Here is the code that im using...</p>

<pre><code>private func fetchAndCacheMonthActivity(forDate date: Date) -&gt; Observable&lt;ActivityMonthInfo&gt; {
        _activity.sync()
            .do(onNext: {[weak self] _ -&gt; Observable&lt;ActivityMonthInfo&gt; in
                var cachedObs = self?._cacheMonthInfoObs[date.yearMonthString]

                guard cachedObs == nil else { return cachedObs! }

                cachedObs = _myActivitiesRepo.getMonthActivity(forMonthInDate: date)
                    .share(replay: 1, scope: SubjectLifetimeScope.forever)

                self?._cacheMonthInfoObs[date.yearMonthString] = cachedObs!

                return cachedObs!
            })
}

</code></pre>

<p>Thanks for reading... I hope you guys can help me out.</p>
","5822759","","5822759","","2020-06-18 22:04:39","2020-06-19 00:58:39","How do I change observable type on my return method","<ios><swift><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"62476119","1","62480319","","2020-06-19 18:03:48","","1","154","<p>I am trying to map a <code>Single&lt;Response&gt;</code> to a an <code>Observable&lt;Result&lt;CustomObject, MoyaError&gt;&gt;</code> however I am unsure about how to do it. </p>

<p>My current function is as follows:</p>

<pre><code>    func accountInfo() -&gt; Observable&lt;AccountInfo&gt; {
        return provider
                .rx
                .request(.accountInfo)
                .map(AccountInfo.self)
                .asObservable()
    }
</code></pre>

<p>However, I would like something as follows: </p>

<pre><code>    func accountInfo() -&gt; Observable&lt;Result&lt;AccountInfo, MoyaError&gt;&gt; {
        return provider
                .rx
                .request(.accountInfo)
                .mapResult(AccountInfo.self)
                .asObservable()
    }
</code></pre>

<p>Any help creating a <code>mapResult</code> extension would be great.</p>

<p>Thank you</p>
","2037909","","","","","2020-06-20 00:35:22","map RxMoya Single Response to RxSwift Observable Result","<swift><rx-swift><moya>","1","0","","","","CC BY-SA 4.0"
"62524172","1","","","2020-06-22 22:00:41","","0","118","<p>I'm new to Rxswift Here is my View Model code:</p>
<pre><code>    let test = reloadRelay
        .asObservable()
        //2
        .flatMapLatest({ apiClient.requestData(type: rankingType) })
        .map({ $0.results })
        .asDriver { (error) -&gt; Driver&lt;[ArticleResult]&gt; in
            errorRelay.accept((error as? ErrorResult)?.localizedDescription ?? error.localizedDescription)
            return Driver.just([])
    }
</code></pre>
<p>This is very typical and simple ViewModel with logics to get data and send the View layer.
However, when I initialise the ViewModel. The networking call (2) never happened.</p>
<p>Here is my networking code:</p>
<pre><code>    func requestData(type: ArticlesRankingType) -&gt; Observable&lt;Articles&gt; {
    let urlString = &quot;https://api.nytimes.com/svc/mostpopular/v2/\(type.rawValue)/7.json?api-key=dylOnQnYUzEF1B9MTYYHM0MyffMPBZRi&quot;
    let urlRequest = URLRequest(url: URL(string: urlString)!, cachePolicy: .useProtocolCachePolicy, timeoutInterval: 10)
    
    return Observable.create { observer in
        let task = URLSession.shared.dataTask(with: urlRequest) { data, response, error in
            if let error = error {
                observer.onError(error)
                return
            }
            
            if let data = data ,let responseCode = response as? HTTPURLResponse {
                do {
                    let decoder = JSONDecoder()
                    
                    if responseCode.statusCode == 200 {
                        let value = try decoder.decode(Articles.self, from: data)
                        return observer.onNext(value)
                    }
                }
                catch let parseJSONError {
                    observer.onError(error!)
                    print(&quot;error on parsing request to JSON : \(parseJSONError)&quot;)
                }
            }
        }
        task.resume()
        return Disposables.create {
            task.cancel()
        }
    }
}
</code></pre>
<p>Here is how I call my output in View:</p>
<pre><code> articlesViewModel.output
        .articles.asDriver(onErrorJustReturn: [])
        .drive(tableView.rx.items(cellIdentifier: &quot;aCell&quot;, cellType: ArticlesCell.self))
 articlesViewModel
 .input
 .reload
 .asDriver(onErrorJustReturn: ())
 .drive()
</code></pre>
<p>Can someone tell what's wrong with my code? Thanks</p>
","9721797","","9721797","","2020-06-23 08:50:46","2020-06-23 08:50:46","Rxswift PublishRelay.flatMapLatest with networking call, but no response","<ios><swift><mvvm><rx-swift>","0","5","","","","CC BY-SA 4.0"
"62536437","1","","","2020-06-23 13:55:48","","2","453","<p>I am calling an API before switching app or going into background but when I switch to foreground within 5-10 seconds that API request gets timedout. I am using Moya+Alaomofile with RxSwift. I have tried increasing the SessionConfiguration timeout but it is not helping and the API is working fine for Android and Web. Below is the code I am using:</p>
<pre><code>APIOrder.provider.rx.request(.placeOrder(orderDetails: orderDetails))
            .map { any -&gt; SROrderData in
                do {
                    let decoder = JSONDecoder()
                    guard let paymentDataModel = try decoder.decode(Safe&lt;SRPaymentDataResponse&gt;.self, from: any.data).value else {
                        throw ApiError.parseError
                    }
                    return paymentDataModel.data
                } catch {
                    throw try throwAPIError(data: any.data)
                }
        }
</code></pre>
<p><code>static var provider = MoyaProvider&lt;MoyaOrder&gt;(manager: DefaultAlamofireManager.sharedManager)</code></p>
<pre><code>class DefaultAlamofireManager: Alamofire.SessionManager {
    static let sharedManager: DefaultAlamofireManager = {
        let configuration = URLSessionConfiguration.default
        configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders
        configuration.timeoutIntervalForRequest = 120 // as seconds, you can set your request timeout
        configuration.timeoutIntervalForResource = 120 // as seconds, you can set your resource timeout
        configuration.requestCachePolicy = .reloadIgnoringLocalAndRemoteCacheData
        configuration.shouldUseExtendedBackgroundIdleMode = true
        if #available(iOS 13.0, *) {
            configuration.allowsExpensiveNetworkAccess = true
        }
        configuration.networkServiceType = .background
        configuration.waitsForConnectivity = true
        return DefaultAlamofireManager(configuration: configuration)
    }()
}
</code></pre>
","1206646","","","","","2020-07-24 09:12:14","Moya+Alamofire POST request is getting timeout when switching between apps or going into background","<ios><swift><alamofire><rx-swift><moya>","1","0","","","","CC BY-SA 4.0"
"62552329","1","","","2020-06-24 09:54:40","","0","413","<p>When the cancel button of the search bar is tapped I want to resign the keyboard but the current issue is that my function to handle the cancel button is not working.. You can see my code here:</p>
<pre><code>searchBar.rx.cancelButtonClicked
                .asDriver(onErrorJustReturn: ())
                .drive(onNext: { [searchBar] in
                    searchBar?.searchTextField.resignFirstResponder()
                    
                    
                }).disposed(by: disposeBag)
</code></pre>
","13035074","","","","","2020-06-30 12:33:00","Search Bar Cancel Button with RxSwift","<swift><iphone><xcode><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"62593519","1","","","2020-06-26 11:11:29","","0","564","<p>With my app, when I launch to iOS 11 (iPhone 6) all is OK.</p>
<p>But on iOS 13 (iPhone SE) I get this error message:</p>
<p><a href=""https://i.imgur.com/63CoqSh.jpg"" rel=""nofollow noreferrer""><img src=""https://i.imgur.com/63CoqSh.jpg"" alt=""Capture on iOS 13"" /></a></p>
<p>In English:</p>
<blockquote>
<p>The resource exceeds the maximum size</p>
</blockquote>
<p>Here the content of my Podfile</p>
<pre><code>pod 'Alamofire'
pod 'SwiftyJSON'
pod 'Stripe'
pod 'GoogleSignIn', '~&gt; 5.0'
pod 'AWSS3'
pod 'Firebase/Core'
pod 'MQTTClient'
pod 'GooglePlaces', '= 3.0.3'
pod 'GoogleMaps', '= 3.0.3'
pod 'libPhoneNumber-iOS'
pod 'CocoaLumberjack/Swift'
pod 'RxAlamofire/RxCocoa'
pod 'FBSDKCoreKit'
pod 'FBSDKShareKit'
pod 'FBSDKLoginKit'
pod 'FBSDKPlacesKit'
pod 'OneSkyOTAPlugin'
</code></pre>
","6311099","","3001761","","2020-06-26 11:14:48","2020-06-26 18:05:38","The resource exceeds the maximum size on iOS 13","<ios><swift><alamofire><rx-swift>","1","2","","","","CC BY-SA 4.0"
"62636529","1","","","2020-06-29 10:51:54","","1","51","<p>I have an observable that is of type bool and I need this observable to never stop emitting events, a forever emitting event observable. I know I could not call the dispose bag but that would create a memory leak so what would not be the best way to create this observable. I looked into using .interval but it seems like it only works on an observable type.</p>
<pre><code>    viewModel.outputs.isAgentAvailable
    .subscribe(
        onNext: { [unowned self] isAgentAvailable in
            if isAgentAvailable {
                self.liveChatButton.isEnabled = true
                self.isAgentAvailableLabel.text = agentAvailableText
            } else {
                self.liveChatButton.isEnabled = false
                self.isAgentAvailableLabel.text = agentUnavailableText
                self.liveChatButton.alpha = 0.5
            }
        }
    ).disposed(by: self.disposeBag)
</code></pre>
","9398617","","","","","2020-06-29 12:55:06","How do I create a forever emitting event observable?","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"62676313","1","62699432","","2020-07-01 11:57:52","","-1","74","<p>Recently I'm giving a hand to my iOs team(coming from Android) and I'm trying to use Appcode to keep all my IntelliJ keybinds and shortcuts. However, even if I can work with Appcode and everything compiles and works well. Some of the libraries that I use on the application doesn't work with AppCode autocomplete. I can't access the base code or do nothing. However if I write the code without any kind of autocomple/helper the code compiles and works well.</p>
<p>For example using RxSwift:</p>
<p><a href=""https://i.stack.imgur.com/skRtt.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/skRtt.png"" alt=""enter image description here"" /></a></p>
<p>I have been reading and Jetbrains says that this issue was <a href=""https://blog.jetbrains.com/objc/2018/01/appcode-2018-1-eap/"" rel=""nofollow noreferrer"">fixed on 2018 edition</a>. But I'm using 2020 edition and I keep having this troubles.</p>
<p>So, my question is: how can I make Appcode show third party libraries methods and classes on the autocomplete?</p>
","5631145","","472495","","2020-07-08 12:13:58","2020-07-08 12:13:58","Appcode doesn't autocomplete third party libraries","<ios><swift><intellij-idea><rx-swift><appcode>","1","1","","","","CC BY-SA 4.0"
"62736445","1","","","2020-07-05 03:12:41","","1","790","<p>In RxSwift I can ignore errors like
<code>.catchError { _ in Observable.never() }</code></p>
<p>Why does this not work in combine (eg. it still completes)
<code>.catch { _ in Empty(completeImmediately: false) }</code></p>
<pre><code>struct SimpleError: Error {}
let numbers = [5, 4, 3, 2, 1, 0, 9, 8, 7, 6]
let cancellable = numbers.publisher
    .tryFilter { int -&gt; Bool in
        guard int != 0 else {throw SimpleError()}
        return true
    }
    .catch { _ in Empty(completeImmediately: false) }
    .sink {
        print(&quot;\($0)&quot;)
    }
</code></pre>
<p>finishes on the throw. The output is:</p>
<pre><code>5
4
3
2
1
</code></pre>
","5528004","","5528004","","2020-07-05 05:23:15","2021-03-16 18:55:38","Ignoring errors in Combine","<ios><swift><rx-swift><combine>","2","10","","","","CC BY-SA 4.0"
"62825950","1","62857030","","2020-07-10 01:14:58","","8","1151","<p>When I work with Realm or RxSwift and there's an exception, I get these giant call stacks that I don't care about, and have to find the one or two lines that are my code.  I'd like to only show symbols on the call stack that are from within the target running, not linked libraries.  How can I hide these?</p>
<p><a href=""https://i.stack.imgur.com/IGfUV.jpg"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/IGfUV.jpg"" alt=""enter image description here"" /></a></p>
","437247","","","","","2020-07-14 13:51:27","How to hide the third-party calls in the call stack in Xcode","<xcode><realm><rx-swift><lldb>","1","0","5","","","CC BY-SA 4.0"
"62853103","1","62865775","","2020-07-11 18:35:20","","1","151","<p>I'm a beginner to RxSwift so I'll try to explain my scenario... I'm using a <code>UITableView</code> together with <code>RxTableViewSectionedReloadDataSource</code>.</p>
<p>In one of my cells which displays a <code>UITextField</code> I have this:</p>
<pre><code>var observer: BehaviorRelay&lt;String?&gt;! {
    didSet {
        observerDisposable = textField.rx.text.bind(to: observer)
    }
}
</code></pre>
<p>Now whenever that cell is selected I display a popup view (not in the cell) where the user can select a date from a <code>UIDatePicker</code> which has a <code>BehaviorRelay&lt;Date?&gt;</code>. So what I want to do is that when the user selects a date I want to update that textfield cell with the selected date.</p>
<p>How would I do this with RxSwift?</p>
","294661","","","","","2020-07-12 19:44:14","BehaviorRelay in tableviewcell","<uitableview><rx-swift><uidatepicker>","1","0","","","","CC BY-SA 4.0"
"62942222","1","62996649","","2020-07-16 19:31:06","","1","123","<p>usually I organize my code (in a simplified way) like that :</p>
<p>Presenter Subscribe to my Model (via Managers)</p>
<pre><code>myManager.getItems(...).subscribe { .... }.disposed()
</code></pre>
<p>The Manager call getItems from a Provider and transform DTO -&gt; BO :</p>
<pre><code>func getItems(...) -&gt; Single&lt;myObectBO&gt; {
    myProvider.getItems(...).map { myDTO in
        return MyObjectBO(withDTO: myDTO)
    }
}
</code></pre>
<p>The Provider return a Single of DTO:</p>
<pre><code>func getItems(...) -&gt; Single&lt;myObectDTO&gt; {
    ...
    return Single.just(myObectDTO)
}
</code></pre>
<p>I tried different thing but for the moment I've found nothing to implement that in Combine, is there a simple way to do this?
Thank you for your help.</p>
<hr />
<p>To be more clear I want to do something like that :</p>
<pre><code>func getSomething() {
    getManagerFuture()
        .sink { result in
            print(result)
        }
}

func getManagerFuture() -&gt; Future&lt;[MyBO], ManagerError&gt; {
    
    Future { promise in
    getProviderFuture()
        .flatMap { dtoList -&gt; ([MyBO], ManagerError) in
            
            let boList = dtoList.map { dto in
                return MyBO(id: dto.id, name: dto.name)
            }
            
            return promise(.success(boList))
        }
    }
}

func getProviderFuture() -&gt; Future&lt;[MyDTO], ProviderError&gt; {

    // should be a webservice call
    
    let dto1 = MyDTO(id: 1, name: &quot;one&quot;)
    let dto2 = MyDTO(id: 2, name: &quot;two&quot;)
    
    return Future { promise in promise(.success([dto1, dto2])) }
}
</code></pre>
<p>I have this errors on getManagerProvider :</p>
<blockquote>
<p>Instance method 'flatMap(maxPublishers:_:)' requires the types
'([MyBO], ManagerError).Failure' and 'Never' be equivalent</p>
<p>Type '([MyBO], ManagerError)' cannot conform to 'Publisher'; only
struct/enum/class types can conform to protocols</p>
</blockquote>
","8247388","","8247388","","2020-07-17 08:58:26","2020-07-20 13:39:02","How to implement my MVP / Rxswift with Combine","<swift><rx-swift><combine>","1","1","","","","CC BY-SA 4.0"
"62945759","1","","","2020-07-17 01:30:39","","5","3933","<p>I am aware that <code>BehaviorRelay</code> is replacing <code>Variable</code>, and both <code>BehaviorSubject</code> and <code>BehaviorRelay</code> starts with an initial value, and replays it or the latest value to the subscribers.</p>
<p>What are the differences then? in which case you would use one over the other?</p>
","3224710","","","","","2020-07-17 09:31:50","RxSwift: What is the usage difference between BehaviorSubject and BehaviorRelay?","<swift><rx-swift><behaviorsubject><behaviorrelay>","2","1","2","","","CC BY-SA 4.0"
"62952137","1","62953476","","2020-07-17 10:30:01","","1","304","<p>i try to filter data from my table View. When i select one value from picker View, The data suppose to filter based on the category and the table view should reload with filtered data.
here i attach the code</p>
<pre><code>struct RecipeList {

let id: Int
let catid: String
let name: String
let description: String
let ingredient: String
let step: String
let image: String
let img: NSData
//static var dataSource = BehaviorRelay(value: [RecipeList]())
static var items = [RecipeList]()
}
</code></pre>
<p>here how i fetch data to table View</p>
<pre><code>func setupCellConfiguration() {
    
  let recipeList = Observable.just(RecipeList.items)
    recipeList
        .bind(to: tableView
            .rx
            .items(cellIdentifier: RecipeListCell.Identifier,
                   cellType: RecipeListCell.self)) { row, recipe, cell in
                    cell.configureWithRecipe(recipe: recipe)
    }
    .disposed(by: disposeBag)
}
</code></pre>
<p>Here how pick event on picker view</p>
<pre><code>func setupRecipeTypePickerView(textField: UITextField) {
    
    let pickerView = UIPickerView()
    pickerView.selectRow(Int(self.selectedRecipeType) ?? 0, inComponent: 0, animated: false)
    textField.inputView = pickerView
    let recipeType = Observable.of(RecipeType.items)
    recipeType.bind(to: pickerView.rx.itemTitles) { (row, element) in
        return &quot;\(element.name)&quot;
    }
    .disposed(by: disposeBag)
    pickerView.rx.itemSelected
        .subscribe { (event) in
            switch event {
            case .next(let selected):
                
                selected.row == 0 ? (self.isFilter = false) : (self.isFilter = true)
                let recipeType = RecipeType.items[selected.row]
                textField.text = recipeType.name
                self.selectedRecipeType = recipeType.id
                RecipeList.items.append(contentsOf: RecipeList.items.filter({$0.catid == recipeType.id}))

            default:
                break
            }
    }
    .disposed(by: disposeBag)
    
}
</code></pre>
<p>Here how append data from Core data to Model</p>
<pre><code>    func getRecipeList() {
    RecipeList.items.removeAll()
    
    guard let appDelegate = UIApplication.shared.delegate as? AppDelegate else { return }
    
    let managedContext = appDelegate.persistentContainer.viewContext
    
    let fetchRequest = NSFetchRequest&lt;NSFetchRequestResult&gt;(entityName: Common.ENTITYNAME)

    do {
        let result = try managedContext.fetch(fetchRequest)
        for data in result as! [NSManagedObject] {
            let id = data.value(forKey: &quot;id&quot;) as! Int
            let catid = data.value(forKey: &quot;catid&quot;) as? String ?? &quot;1&quot;
            let name = data.value(forKey: &quot;name&quot;) as! String
            let description = data.value(forKey: &quot;rdescription&quot;) as! String
            let ingredient = data.value(forKey: &quot;ingredient&quot;) as! String
            let step = data.value(forKey: &quot;step&quot;) as! String
            let image = data.value(forKey: &quot;image&quot;) as! String
            let img = data.value(forKey: &quot;img&quot;) as! NSData

            let recipe = RecipeList(id: id, catid: catid, name: name, description: description, ingredient: ingredient, step: step, image: image, img: img)
            RecipeList.items.append(recipe)
        }
       // RecipeList.dataSource.accept(RecipeList.items)
    } catch {
        
        print(&quot;Failed&quot;)
    }
}
</code></pre>
<p>I try alot solution from multiple sources, seems does not work. This is my first day learning RXSwift. Usually i didnt use RXSwift, i just simply, create variable for filtered data, then rereload the tableView</p>
","7789586","","7789586","","2020-07-17 10:43:55","2020-07-17 11:56:57","RxSwift - Filter data from tableview from UIPickerView","<swift><uitableview><uipickerview><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"62991419","1","","","2020-07-20 08:27:16","","0","61","<p>Let's say I have an array of Ints</p>
<pre><code>let array = [1, 2, 3, 4, 5]
</code></pre>
<p>And let's say I also have a publish Relay that accepts Int elements</p>
<pre><code>let relay = PublishRelay&lt;Int&gt;()
</code></pre>
<p>Is there a better way than to for loop over my array to stuff them into the relay?</p>
<pre><code>for num in array {
   relay.accept(num)
}
</code></pre>
","7612797","","","","","2020-07-20 11:57:43","RxSwift: have a relay accept items in succession from an array","<ios><swift><rx-swift><rx-cocoa>","1","1","","","","CC BY-SA 4.0"
"63016739","1","","","2020-07-21 14:26:10","","-1","77","<p>I'm trying to write some tests for my application, that uses rxSwift. In particular, I'd like to test, writing unit tests, a webview. I'm using RxWebKit to get observables over some properties like navigationCompleted or NavigationFailed and so on.
For example: <code>webView.rx.didFailNavigation.asDriver()</code>. These observables are given as input to my viewModel.
But i'm not sure how to write these tests to simulate, for example, a failed navigation and so an emission of this kind of observable.
In the specific case, i want to simulate a <code>Driver&lt;(webView: WKWebView, navigation: WKNavigation, error: Error)&gt;</code> (that is the same type of the one associated to <code>webView.rx.didFailNavigation.asDriver()</code>).
I understood that to simulate the emission i need to create a scheduler and call the <code>createHotObservable</code> method, but what have I to pass to <code>Recorderd.next(150, element)</code> as element in the specific case to simulate the fail of the webview?
can someone give me a simple example?</p>
","7089089","","7089089","","2020-07-21 15:48:59","2020-07-21 15:48:59","How to test a WKWebView using RxWebKit?","<ios><swift><rx-swift><rxtest>","1","0","","","","CC BY-SA 4.0"
"63028282","1","63028385","","2020-07-22 06:35:43","","3","460","<p>I want to give an alpha effect when closing the button's visibility with the code below. However, in the code below, the alpha effect works correctly, but instantly becomes , without waiting for 0.5 seconds of visibility.</p>
<p>Do you have alternative suggestions to solve this? Especially if you have a solution with RxSwift, RxCoca, it would be nice. Thanks.</p>
<pre><code>self.button.alpha = 1.0
UIView.animate(withDuration: 0.5) {
          self.button.alpha = 0
          self.button.isHidden = true
  }
</code></pre>
","12103664","","1780632","","2020-07-24 21:03:15","2020-07-24 21:03:15","Hide view and apply hide effect - Swift","<ios><swift><visibility><rx-swift><rx-cocoa>","3","0","","","","CC BY-SA 4.0"
"63048132","1","","","2020-07-23 06:25:18","","0","163","<p>I use SnapKit and RxSwift in my project.
in some pages, I use RxSwift tableView binding for bind data and tableView.</p>
<pre><code>friends.compactMap{$0}.asObservable().bind(to: tableView.rx.items(cellIdentifier: WalletTableViewCell.reuseIdentifier,
                                                                      cellType: FriendWalletTableViewCell.self))
    { (row,item,cell) in
        
    cell.wallet = item
                                                                        
}.disposed(by: disposeBag)
</code></pre>
<p>when I go to these pages (when viewDidLoad) everything works fine without any &quot;Will attempt to recover by breaking constraint&quot; warning, but when view dismiss or pop to last view controller, this warning shows in the console:
&quot;Will attempt to recover by breaking constraint&quot;.</p>
<p>cell's constraints in cells init:</p>
<pre><code>backView.snp.remakeConstraints { (make) in
     make.width.equalToSuperview().inset(Helper.deviceCheck().isPad ? 0 : 22)
     make.centerX.equalToSuperview()
     make.top.equalToSuperview()
     make.bottom.equalToSuperview().offset(-22)
}

icon.snp.makeConstraints { (make) in
     make.width.equalTo(53)
     make.height.equalTo(47)
     make.top.equalToSuperview().offset(10)
     make.left.equalToSuperview().offset(10)
}

currencyBadge.snp.makeConstraints { (make) in
     make.top.equalToSuperview().offset(16)
     make.height.equalTo(30)
     make.width.lessThanOrEqualTo(50)
     make.right.equalToSuperview().inset(16)
}

titleLabel.snp.makeConstraints { (make) in
     make.right.equalTo(currencyBadge.snp.left).offset(-10)
     make.centerY.equalTo(currencyBadge.snp.centerY)
}

separator.snp.makeConstraints { (make) in
     make.width.equalToSuperview()
     make.centerX.equalToSuperview()
     make.height.equalTo(1)
     make.top.equalTo(icon.snp.bottom).offset(10)
}

sendButton.snp.makeConstraints { (make) in
     make.width.greaterThanOrEqualTo(85)
     make.height.equalTo(35)
     make.top.equalTo(separator.snp.bottom).offset(10)
     make.right.equalToSuperview().inset(10)
     make.bottom.equalToSuperview().offset(-10)
}
</code></pre>
<p>honestly, it's odd for me, because if auto-layout have an issue, the warning must show in viewDidLoad() or viewWillAppear().</p>
<p>P.S: if I implement tableView normally (with delegate and dataSource) it works without any warning.</p>
<p>can you please what is my mistake?
thanks</p>
","5238456","","5238456","","2020-07-23 06:55:00","2020-10-01 02:27:01","TableView RxSwift binding cause Unable to simultaneously satisfy constraints warning","<swift><uitableview><rx-swift><snapkit>","1","2","","","","CC BY-SA 4.0"
"63052379","1","","","2020-07-23 10:41:17","","0","92","<p>In View Controller</p>
<pre><code>viewModel.frequentDate = Date() // This changes frequently
</code></pre>
<p>In ViewModel</p>
<pre><code>struct ViewModel {
   var frequentDate = Date()
   mutating func validateSomeTime(startDatePicker: Observable&lt;Date&gt;) {
      self.validdate = startDatePicker.map(someValid)
   }
    
   func someValid(_ date: Date) -&gt; String {
      if date = self.frequentDate {
         return &quot;Done&quot;
      }
   }
}
</code></pre>
<p><code>frequentDate</code> doesn't change frequently it always give first initial date. When I call observable <code>validate</code> the date value is initial one not updates the latest.</p>
<p>this <code>self.frequentDate</code> will never change of the VC lift cycle.</p>
<p><em>But if I changed ViewModel struct to class. It works fine</em></p>
","","user4468952","","","","2020-07-23 10:41:17","Global variable in Struct using mutating function/map doesn't changing value when updating","<ios><swift><struct><rx-swift>","0","2","","","","CC BY-SA 4.0"
"63062137","1","","","2020-07-23 19:53:22","","1","23","<p>On a screen i have multiple WS called with a token, when token is expired, a function called refreshTokens is called :</p>
<pre><code>  func postItemImpersonation(parameters: [String: Any]?) -&gt; Observable&lt;(HTTPURLResponse, T)&gt; {
    let absolutePath = Constants.URL.Impersonation.url
    let impersonationHeader: [String: String] = [
    &quot;Content-Type&quot;: &quot;application/json&quot;,
    &quot;X-Api-Key&quot;: &quot;xxxxxxx&quot;
    ]
    return self.manager.rx.request(.post, absolutePath, parameters: parameters, encoding: JSONEncoding.default, headers: impersonationHeader)
        .responseJSON()
        .timeout(RxTimeInterval.seconds(self.timeOutValue), scheduler: scheduler)
        .observeOn(self.scheduler)
        .map({ response -&gt; (HTTPURLResponse, T) in
            if response.response?.statusCode == 500 {
                throw Error_Code_Network.REST_KO_TECHNIQUE_ERROR
            }
            else if response.response?.statusCode == 204 {
                throw Error_Code_Network.REST_NO_CONTENT
            }else if response.response?.statusCode == 401 {
               
                throw TokenError.unauthorized
            }
            
            let object = Mapper&lt;T&gt;().map(JSONObject: response.value)
            if let object = object, let response = response.response {
                return (response, object)
            }
            throw Error_Code_Network.REST_KO_TECHNIQUE_ERROR
        })
        .retryWhen({ errorObservable in
            errorObservable.enumerated().flatMap({ ( index , error ) -&gt; Observable&lt;Void&gt; in
                if let e = error as? TokenError, e == TokenError.unauthorized, index &lt; self.maxRequestRetry {
                    return self.refreshTokens().asObservable()
                        .map({ succeded -&gt; Void in
                            if succeded {
                                return Void()
                            } else {
                                SessionManager.GetInstance().forceDeconnexion.accept(true)
                                throw TokenError.expired
                            }
                        })
                }
                throw error
            })
        })
}
</code></pre>
<p>}</p>
<p>but when two ws or more are called and token expired, refreshTokens is called several times, i want it to be called only once</p>
<p>how can i do that please ?</p>
","3270417","","","","","2020-07-25 02:02:13","Call refreshtoken WS only once with RX","<swift><xcode><token><rx-swift>","1","0","","","","CC BY-SA 4.0"
"63084787","1","","","2020-07-25 05:38:06","","0","167","<p>I am using <a href=""https://github.com/ReactorKit/ReactorKit"" rel=""nofollow noreferrer"">ReactorKit</a></p>
<p>I have a cell <code>HCheckBoxTableViewCell</code> which has a <code>UILabel</code> for showing title and a <code>UIImageView</code> to show checked or unchecked state.</p>
<pre class=""lang-swift prettyprint-override""><code>class HCheckBoxTableViewCell: TableViewCell {

  @IBOutlet weak var titleLabel: UILabel!
  @IBOutlet weak var checkImageView: UIImageView!
  
  func bind(reactor: MedicineCellReactor) {
    reactor.state.map({ $0.message })
      .bind(to: titleLabel.rx.text)
      .disposed(by: disposeBag)
    
    reactor.state.map({ $0.isSelected })
      .subscribe(onNext: { [weak self] isSelected in
        self?.checkImageView.image = isSelected == true ? Images.checked : Images.unchecked
      }).disposed(by: disposeBag)
  }
}
</code></pre>
<p>I have <code>MedicineCellReactor</code> which stores the state of the above cell.</p>
<pre class=""lang-swift prettyprint-override""><code>final class MedicineCellReactor: Reactor {
  
  typealias Action = NoAction
  
  struct State {
    var id: String
    var message: String?
    var isSelected: Bool
  }

  let initialState: State

  init(id: String, title: String, isSelected: Bool) {
    self.initialState = State(id: id, message: title, isSelected: isSelected)
  }
}
</code></pre>
<p>I have <code>MedicalConditionSelectionReactor</code> which maintains the state of MedicalListViewController who populates the UITableView with the above cell.
When any row is tapped <code>Action.toggleCondition</code> is called with the respected row index. So I just want to toggle the value of <code>isSelected</code> property &amp; then change the image of the cell to checked or unchecked based on the property value. Since the <code>currentState</code> and <code>initialState</code> of <code>MedicineCellReactor</code> are both immutable. How do I achieve this? I don't want to reload the whole tableView.</p>
<pre class=""lang-swift prettyprint-override""><code>class MedicalConditionSelectionReactor: Reactor {
  
  // represent user actions
  enum Action {
    case loadConditions
    case addNewCondition
    case removeCondition
    case toggleCondition(index: Int)
    case save
  }

  // represent state changes
  enum Mutation {
    case loadedMedicalConditions([MedicalConditionSelectionSectionItem])
    case reloadList
  }

  // represents the current view state
  struct State {
    var sections: [MedicalConditionSelectionSection] = [MedicalConditionSelectionSection(items: [])]
  }

  let initialState: State = State()
  
  func mutate(action: Action) -&gt; Observable&lt;Mutation&gt; {
    switch action {
    case .loadConditions:
      let medicalConditions = OptionsModelDBProvider&lt;RealmMedicalConditionModel&gt;().fetch()
      let conditions = medicalConditions.toArray().map { item -&gt; MedicalConditionSelectionSectionItem in
        // let isSelected = arrayOfMedicalConditionID.contains(&quot;\(item.ID)&quot;)
        let medicalCell = MedicineCellReactor(id: &quot;\(item.ID)&quot;, title: item.name, isSelected: false)
        return MedicalConditionSelectionSectionItem.medicalCondition(medicalCell)
      }
      return Observable.of(Mutation.loadedMedicalConditions(conditions))
      
    case let .toggleCondition(indexOfCell):
      let state = currentState.sections[0].items[indexOfCell]
      switch state {
      case let .medicalCondition(reactor):
        // TODO:- How to toggle the isSelected bool property of MedicineCellReactor.State. Since this is immutable.
        // reactor.currentState.isSelected = false
        break
      default: break
      }
      return Observable.of(Mutation.reloadList)
      
      
    default:
      return Observable.of(Mutation.reloadList)
    }
  }
  
  func reduce(state: State, mutation: Mutation) -&gt; State {
    var state = state
    switch mutation {
    case let .loadedMedicalConditions(conditions):
      state.sections[0].items = conditions
    default:
      break
    }
    return state
  }

}
</code></pre>
","5744323","","","","","2020-07-25 05:38:06","How to Mutate State of UITableViewCell using ReactorKit?","<rx-swift>","0","5","","","","CC BY-SA 4.0"
"63101837","1","63105495","","2020-07-26 15:00:54","","1","88","<p>so I can't really wrap my head around the concept of <code>retry()</code> and <code>share()</code> function in an <code>RxSwift.Observable</code>. Well, I think I may have some ideas about what they are but a certain cases got me questioning my understanding about them. So I have this test case:</p>
<pre><code>func testOnViewDidLoad_WhenError_ShouldRetry3Times() throws {
    var actualRetryCount = 0
    let creditCardInfoProvider: CreditCardInfoProviderBlock = {
        actualRetryCount += 1
        return .error(RxCocoaURLError.unknown)
    }
    
    let viewModel = createViewModel(creditCardInfoProvider: creditCardInfoProvider)
    
    viewModel.onViewDidLoad()
    
    XCTAssertEqual(3, actualRetryCount)
}
</code></pre>
<p>The class is:</p>
<pre><code>final class PaymentInfoViewModel {
    private(set) lazy var populateData = creditCardsRelay.asDriver()
    private let creditCardsRelay = BehaviorRelay&lt;[CreditCardInfo]&gt;(value: [])

    private let creditCardInfoProvider: () -&gt; Observable&lt;[CreditCardInfo]&gt;
    init(creditCardInfoProvider: @escaping () -&gt; Observable&lt;[CreditCardInfo]&gt;) {
        self.creditCardInfoProvider = creditCardInfoProvider
    }

    func onViewDidLoad() {
        .....
    }
}
</code></pre>
<p>My first question is: How come this works?</p>
<pre><code>func onViewDidLoad() {
    Observable.just(())
        .flatMapLatest { [weak self] () -&gt; Observable&lt;[CreditCardInfo]&gt; in
            guard let `self` = self else { return .empty() }
            return self.creditCardInfoProvider() }
        .retry(3)
        .do(onError: { [weak self] in
            self?.handleErrors(error: $0)
        })
        .bind(to: creditCardsRelay)
        .disposed(by: disposeBag)
}
</code></pre>
<p>But this doesn't (the result was one. Meaning it didn't get retried.)?</p>
<pre><code>func onViewDidLoad(){
    creditCardInfoProvider()
        .retry(3)
        .do(onError: { [weak self] in
            self?.handleErrors(error: $0)
        })
        .bind(to: creditCardsRelay)
        .disposed(by: disposeBag)
}
</code></pre>
<p>My second question is: I have another relay that will be triggered by the same function. So I refactored it to be a shared observable like this:</p>
<pre><code>func onViewDidLoad() {
    let sharedCardProvider = Observable.just(())
        .flatMapLatest { [weak self] () -&gt; Observable&lt;[CreditCardInfo]&gt; in
            guard let `self` = self else { return .empty() }
            return self.creditCardInfoProvider() }
        .retry(3)
        .do(onError: { [weak self] in
            self?.handleErrors(error: $0)
        }).share()
        
    sharedCardProvider
        .bind(to: creditCardsRelay)
        .disposed(by: disposeBag)
    
    sharedCardProvider
        .map { !$0.isEmpty }
        .bind(to: addCreditCardButtonHiddenRelay)
        .disposed(by: disposeBag)
}
</code></pre>
<p>The thing is, the test becomes red with the result of <code>actualRetryCount</code> is 6. Deleting the <code>share()</code> function returned the same value (ie. 6 retries). So, that means it got called twice like a normal observable, not a shared one. Why does that happen?</p>
<p>For now, what I did was putting the emitting of the second relay in a <code>.do(onNext:)</code> block so that's not really the problem here. I am just confused about the behavior.</p>
<p>Thanks in advance.</p>
","4124849","","","","","2020-07-30 14:18:02","Need help to wrap my head around the concept of retry and share in RxSwift","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"63112389","1","","","2020-07-27 09:26:43","","1","279","<p>As i know on Alamofire, we have timeline object where we can extract the response time.
However, how do i get the response time from a Moya Request?</p>
<pre><code>public final class Response: CustomDebugStringConvertible, Equatable {

    /// The status code of the response.
    public let statusCode: Int

    /// The response data.
    public let data: Data

    /// The original URLRequest for the response.
    public let request: URLRequest?

    /// The HTTPURLResponse object.
    public let response: HTTPURLResponse? //this does not return response time
}
</code></pre>
","5167733","","","","","2020-12-16 08:03:31","How to measure response time with Swift Moya?","<swift><rx-swift><moya>","1","0","","","","CC BY-SA 4.0"
"63178285","1","","","2020-07-30 17:23:13","","2","226","<p>I want to have a method to intercept links tap in a <code>UITextView</code> through <code>RxSwift</code> something similar to:</p>
<pre><code>textView.rx.didTapLink
        .subscribe(onNext: { link, characterRange, interaction in
            // handle link tap
        })
</code></pre>
<p>I saw there is no implementation for <a href=""https://github.com/ReactiveX/RxSwift/blob/53cd723d40d05177e790c8c34c36cec7092a6106/RxCocoa/iOS/Proxies/RxTextViewDelegateProxy.swift"" rel=""nofollow noreferrer"">delegate forwarding</a> for the <a href=""https://developer.apple.com/documentation/uikit/uitextviewdelegate/1649337-textview?language=objc"" rel=""nofollow noreferrer"">textView:shouldInteractWithURL:inRange:interaction:</a> method so I presume I must add an extension for the <code>RxTextViewDelegateProxy</code> to implement the missing delegate method but don't know how to continue from there or if what I want is event possible without forking <code>RxSwift</code> but it should be possible I presume. I really appreciate any help.</p>
","1310984","","","","","2020-07-31 13:05:38","RxSwift wrapper for textView:shouldInteractWithURL:inRange:interaction:","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"63210751","1","","","2020-08-01 22:45:04","","0","53","<p>i am using mvvm pattern in my app here my example of code :</p>
<pre><code>    let userVM = UserViewModel()

    userVM.getUser()
        .subscribeOn(SerialDispatchQueueScheduler.init(qos: .background))
        .observeOn(MainScheduler.instance)
        .subscribe(onNext: { user in
            self.user = user
        }, onError: { error in
            
        }, onCompleted: {
            
        }, onDisposed: {
            
        }).disposed(by: self.disposeBag)
</code></pre>
<p>i want to access the user emitted onNext outside the onSubscribe function any help with that ?</p>
","5015038","","","","","2020-08-03 11:47:28","How to get the value inside the onNext to access it outside in my code","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"63224597","1","63229105","","2020-08-03 06:17:28","","2","298","<p>I have a ViewModelType to bind UIViewController &amp; ViewModel.</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation

protocol ViewModelType {
    associatedtype Input
    associatedtype Output
    
    func transform(input: Input) -&gt; Output
}
</code></pre>
<p>The HomeViewModel conforms to ViewModelType and defines the Input and Output required, then it does the job returning the outputs based on the inputs.</p>
<p>For simplicity I have removed the repository and always returning failure for syncData task.</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import RxSwift
import RxCocoa

class HomeViewModel: ViewModelType {

  struct Input {
    let syncData: Driver&lt;Void&gt;
  }
  
  struct Output {
    let message: Driver&lt;String&gt;
  }
  
  func transform(input: Input) -&gt; Output {
    let fetching = input.syncData.flatMapLatest { _ -&gt; Driver&lt;String&gt; in
      return Observable&lt;String&gt;.from(optional: &quot;Choose below options to proceed&quot;) // This message will be returned by server.
        .delay(.seconds(1), scheduler: MainScheduler.instance)
        .asDriverOnErrorJustComplete()
    }
    return Output(message: fetching)
  }
}
</code></pre>
<p>I have a alert binder which takes a String.</p>
<p>The <code>UIAlertController</code> have a retry button on click of retry button I want to call <code>syncData</code> from <code>Input</code> of <code>HomeViewModel</code> How do I do that?</p>
<pre class=""lang-swift prettyprint-override""><code>import UIKit
import RxSwift
import RxCocoa

class HomeViewController: UIViewController {

  private let disposeBag = DisposeBag()
  
  var viewModel = HomeViewModel()
  
  override func viewDidLoad() {
    super.viewDidLoad()
    
    let viewDidAppear = rx.sentMessage(#selector(UIViewController.viewDidAppear(_:)))
    .mapToVoid()
    .asDriverOnErrorJustComplete()
    
    // How to merge viewWillAppear &amp; alert for callback of retry button?
    let input = HomeViewModel.Input(syncData: viewDidAppear)
    let output = viewModel.transform(input: input)
    
    output.message.drive(alert)
      .disposed(by: disposeBag)
  }

  var alert: Binder&lt;String&gt; {
    return Binder(self) { (vc, message) in
      let alert = UIAlertController(title: &quot;Sync failed!&quot;,
                                    message: message,
                                    preferredStyle: .alert)
      let okay = UIAlertAction(title: &quot;Retry&quot;, style: .default, handler: { _ in
        // how to call syncData of Input?
      })
      let dismiss = UIAlertAction(title: &quot;Dismiss&quot;,
                                 style: UIAlertAction.Style.cancel,
                                 handler: nil)

      alert.addAction(okay)
      alert.addAction(dismiss)
      vc.present(alert, animated: true, completion: nil)
    }
  } 
}
</code></pre>
","5744323","","","","","2020-08-03 12:05:55","How to set properties and get callback from UIAlertController in RxSwift?","<rx-swift><uialertcontroller>","2","0","","","","CC BY-SA 4.0"
"63226673","1","","","2020-08-03 09:11:39","","-3","170","<p>I have a bit problem with a nature of Rx. As I understand correctly every value that is pushed to a sequence is holding and not released.
I'd like to ask if there is a way how to push this values from sequence away or release them.</p>
<p>Edit:</p>
<p>let progressSessionValue = PublishSubject() is called 10 times per second, which create a significant memory consumption. How to release the memory in this case?</p>
<pre><code>selectedValue = Driver
        .merge(
            // you either use slider
            sliderChangedValue
                .withLatestFrom(progressTypePressed){ ($0, $1) }
                .map{ Double($0).stringUnitValue(from: $1) }
                .asDriver(),
            // or take value from the picker
            mainPickerValue
                .withLatestFrom(progressTypePressed){ ($0, $1) }
                .map{ Double($0.value).stringUnitValue(from: $1) }
                .asDriver(),
            // or use stored/calculated values
             progressSessionValue.asDriver()
                .withLatestFrom(mainPressCombined)
                .map{ type, gen, segment in audio.retrieveValue(gen, type: type, segment: segment) }
        )
        .distinctUntilChanged()
</code></pre>
<p>edit2:</p>
<pre><code>class BMMain_VM {
/// in
let didAppear = PublishSubject&lt;Void&gt;()
let didLoad = PublishSubject&lt;Void&gt;()
// pick up all generators
let genButtonPressed = PublishSubject&lt;AudioGenerator.ItemEnum&gt;()
let progressionType = PublishSubject&lt;BM.ProgressionType&gt;()
let selectedGeneratorType = PublishSubject&lt;BM.GeneratorType&gt;()

let manageSoundAction = PublishSubject&lt;BMMain.SoundAction&gt;()
//
let sessionType = PublishSubject&lt;AudioGenerator.SessionType&gt;()
//
let switchControlPanel = PublishSubject&lt;Void&gt;()
// slider changes
let sliderChangedValue = PublishSubject&lt;Float&gt;()
// picker changes
let pickerSelectedValues = PublishSubject&lt;[Int]&gt;()
// navigation
let infoButtonPressed = PublishSubject&lt;Void&gt;()
let toneButtonPressed = PublishSubject&lt;Void&gt;()
let menuButtonPressed = PublishSubject&lt;Void&gt;()
let navigateRoute = PublishSubject&lt;BM.ProgressionType&gt;()
//
let storeIsochronicType = PublishSubject&lt;BM.IsoGeneratorType&gt;()
/////////////////////////////////////////////////////////////////////
/// out
// selected value to be presented
let selectedValue: Driver&lt;String&gt;
// values to be displayed in the main picker
let pickerValues: Driver&lt;PickerViewAdapter.Element&gt;
// select main picker
let selectPickerValue: Driver&lt;[(row:Int, component:Int)]&gt;
// select .static or .dynamic
let selectSessionType: Driver&lt;Int&gt;
// slider value
let selectSliderValue: Driver&lt;Float&gt;
// set slider dimensions
let sliderValues: Driver&lt;ClosedRange&lt;Float&gt;&gt;
//
let depthButtonHidden: Driver&lt;Bool&gt;
//
let manageButtonState: Driver&lt;(AudioGenerator.ItemEnum, Bool)&gt;
let manageTimerMaxLabel: Driver&lt;String&gt;
let manageTimerMinLabel: Driver&lt;String&gt;
let manageTimerProgress: Driver&lt;Float&gt;
//
let changeLayout: Driver&lt;AudioGenerator.ItemEnum&gt;
// let initAnimations: Driver&lt;(BM.ProgressionType, Float)&gt;
let updateButtonsState: Driver&lt;Void&gt;
//
let mainPressCombined: Driver&lt;(BM.ProgressionType, AudioGenerator.ItemEnum, AudioGenerator.SessionType)&gt;
//
private let disposeBag = DisposeBag()
/////////////////////////////////////////////////////////////////////
//
init(context: BMMain.Context, audio: AudioGenerator, dataService: BMDBService) {
    
    let isRunning = audio.rx.isSessionPlaying.distinctUntilChanged()
    
    let sessionTimerValue = BehaviorRelay(value: dataService.getTimer())
    
    let progressTypePressed = progressionType.startWith(.amplitude).asDriver()
    let generatorPressed = genButtonPressed.startWith(.A).asDriver()
    let sessionTypeChange = sessionType.startWith(.static).asDriver()
    //
    mainPressCombined = Driver
        .combineLatest(progressTypePressed, generatorPressed, sessionTypeChange)
    
    // manage notifications
    NotificationCenter.default.rx
        .notification(NSNotification.Name(rawValue: &quot;changeGenerator&quot;))
        .filter{ $0.object is AudioGenerator.ItemEnum }
        .map{ $0.object as! AudioGenerator.ItemEnum }
        .bind(to: genButtonPressed)
        .disposed(by: disposeBag)
    // set note value
    let updateProgressValueAction = NotificationCenter.default.rx
        .notification(NSNotification.Name(rawValue: &quot;updateMain&quot;))
    //
    changeLayout = generatorPressed.asDriver()
    //
    toneButtonPressed
        .withLatestFrom(generatorPressed)
        .bind(to: context.navigateNoteView)
        .disposed(by: disposeBag)
    // auto switch
    toneButtonPressed
        .map{ _ in .frequency }
        .bind(to: progressionType)
        .disposed(by: disposeBag)
    //
    infoButtonPressed
        .bind(to: context.navigateInfoView)
        .disposed(by: disposeBag)
    
    menuButtonPressed
        .withLatestFrom(generatorPressed)
        .bind(to: context.navigateMenuView)
        .disposed(by: disposeBag)
    
    navigateRoute
        .withLatestFrom(generatorPressed){ ($0, $1) }
        .bind { (arg) in let (route, gen) = arg
            switch route {
            case .binaural:
                context.navigateBinauralView.onNext(gen)
            case .frequency:
                context.navigateFrequencyView.onNext(gen)
            case .amplitude:
                context.navigateVolumeView.onNext(gen)
            case .depth:
                context.navigateDepthView.onNext(gen)
            }
        }.disposed(by: disposeBag)
    //
    pickerValues = progressTypePressed.map{ $0.pickerTitles }
    sliderValues = progressTypePressed.map{ $0.interval }
    //
    sessionTypeChange
        .drive(onNext: { type in
            audio.reset(type)
            audio.manageGeneral(type) })
        .disposed(by: disposeBag)
    //
    let mainPickerValue = pickerSelectedValues
        .withLatestFrom(progressTypePressed){ ($0, $1) }
        .map{ selection, type in type.consolidate(value: selection) }
    //
    let progressSessionValue = PublishSubject&lt;Void&gt;()
    //
    let changeValueAction = Driver
        .merge(updateProgressValueAction.map { _ in }.asDriver(),
               didLoad.map{ _ in }.asDriver(),
               progressSessionValue.map{ _ in }.asDriver(),
               generatorPressed.map{ _ in },
               progressTypePressed.map{ _ in },
               sessionTypeChange.map{ _ in }.asDriver(),
               switchControlPanel.map{ _ in }.asDriver()
        )
    //
    selectedValue = Driver
        .merge(
            // you either use slider
            sliderChangedValue
                .withLatestFrom(progressTypePressed){ ($0, $1) }
                .map{ Double($0).stringUnitValue(from: $1) }
                .asDriver(),
            // or take value from the picker
            mainPickerValue
                .withLatestFrom(progressTypePressed){ ($0, $1) }
                .map{ Double($0.value).stringUnitValue(from: $1) }
                .asDriver(),
            // or use stored/calculated values
            changeValueAction
                .withLatestFrom(mainPressCombined)
                .map{ type, gen, segment in audio.retrieveValue(gen, type: type, segment: segment) }
        )
        .distinctUntilChanged()
        .debug()
    // two ways how to manage values
    Observable.merge(sliderChangedValue,
                     mainPickerValue.map{ $0.value })
        .withLatestFrom(mainPressCombined){ ($0, $1) }
        .bind{ (arg) in let (value, type) = arg
            dataService.store(value, type: type.0, generator: type.1)
            audio.manage(value, gen: type.1, type: type.0) }
        .disposed(by: disposeBag)
    // assign picker
    selectPickerValue = Driver
        .merge(
            changeValueAction
                .withLatestFrom(mainPressCombined)
                .map{ (type, gen, session) in type
                    .select(value: audio.retrieve(gen, type: type, segment: session)) },
            mainPickerValue
                .map{ selection, value in selection }
                .unwrap()
                .asDriver()
        )
    // assign slider - do not know, why it needs to be twice when type pressed
    selectSliderValue = Driver
        .merge(
            changeValueAction.map{ _ in return () },
            progressTypePressed.map{ _ in return () }
        )
        .withLatestFrom(mainPressCombined)
        .map{ (type, gen, session) in audio.retrieveValue(gen, type: type, segment: session) }
         //.debug(&quot;Slider value: &quot;)
    // assign audio type
    selectSessionType = Driver
        .merge(updateProgressValueAction.map{ _ in return () }.asDriver(),
               generatorPressed.map{ _ in return () },
               sessionTypeChange.map{ _ in return () },
               context.showPurchaseAlert.map{ _ in return () }.as🚗())
        .withLatestFrom(mainPressCombined)
        .map{ _, gen, session in gen.getStoredType(session).rawValue }
        // .distinctUntilChanged()
        .debug(&quot;generator type: &quot;)
    // update audio type
    selectedGeneratorType
        .withLatestFrom(sessionTypeChange){ ($0, $1) }
        //.filter{ isPurchased || $0.1 == .dynamic }
        .withLatestFrom(generatorPressed){ ($0, $1) }
        .bind{ type, gen in
            dataService.change(type.0, gen: gen)
            audio.manageAudioType(type.0, gen: gen) }
        .disposed(by: disposeBag)
    //
    depthButtonHidden = Driver.merge(updateProgressValueAction.map{ _ in }.asDriver(),
                                     generatorPressed.map{ _ in },
                                     sessionTypeChange.map{ _ in },
                                     selectedGeneratorType.map{ _ in }.asDriver())
        .withLatestFrom(mainPressCombined)
        .map{ $1.getStoredType($2) }.debug()
        .map{ type in type != .isochronic }
        .distinctUntilChanged()
        .asDriver()
    // autoswitch to amplitude when depth is not visible
    depthButtonHidden
        .withLatestFrom(mainPressCombined){ ($0, $1) }
        .filter{ $0 &amp;&amp; $1.0 == .depth }
        .map{ _ in  BM.ProgressionType.amplitude }
        .drive(progressionType)
        .disposed(by: disposeBag)
    // audio
    storeIsochronicType
        .withLatestFrom(generatorPressed){ ($0, $1) }
        .map(audio.changeIsochronic)
        .subscribe()
        .disposed(by: disposeBag)
    // db
    storeIsochronicType
        .withLatestFrom(mainPressCombined){ ($0, $1) }
        .map{ ($0, $1.1, $1.2) }
        .map(dataService.updateIsochronic)
        .subscribe()
        .disposed(by: disposeBag)
    ////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Timers
    let sessionTimerStopAction = PublishSubject&lt;BMMain.SoundAction&gt;()
    // start session
    let progressTimerValue = isRunning
        .debug(&quot;isRunning&quot;)
        .flatMapLatest { isRunning  in
            isRunning
                ? Observable&lt;Int&gt;.interval(.seconds(1), scheduler: MainScheduler.instance)
                : .empty() }
        .enumerated()
        .flatMap { (arg) -&gt; Observable&lt;Int&gt; in let ( _, int ) = arg
            return Observable.just(int + 1) }
        .debug(&quot;timer&quot;)
        .startWith(0)
        .share()
    // stop session
    progressTimerValue
        .withLatestFrom(sessionTimerValue){ ($0, $1) }
        .filter{ $0 == $1 }
        .map{ _ in .stop }
        .bind(to: sessionTimerStopAction)
        .disposed(by: disposeBag)
    
    updateButtonsState = Observable.merge(sessionTimerStopAction.map{_ in },
                                          sessionType.map{_ in }).as🚗()
    //
    let switchSegment = PublishSubject&lt;Bool&gt;()
    switchSegment.onNext(true)
    let timerAction = Observable.combineLatest(switchSegment, sessionType)
    //
    isRunning
        .withLatestFrom(timerAction){ ($0, $1) }
        .filter{ state, type in type.1 == .dynamic || type.0 }
        .flatMapLatest{ data -&gt; Observable&lt;Int&gt; in
            if !data.0 &amp;&amp; data.1.1 == .dynamic {
                audio.reset(.dynamic)
            }
            return data.0
                ? Observable&lt;Int&gt;.interval(.milliseconds(100), scheduler: MainScheduler.instance)
                : .empty() }
        //.debug(&quot;Progressive timer: &quot;)
        .map{ _ in audio.calculateFrequency() }
        .bind(to: progressSessionValue)
        .disposed(by: disposeBag)
    
    // Progressive session recalculation timer
    isRunning
        .debug(&quot;Start recalculate&quot;)
        .withLatestFrom(timerAction){ ($0, $1) }
        .filter{ state, type in (type.1 == .dynamic || type.0) &amp;&amp; state }
        .bind{ _ in audio.recalculateStep() }
        .disposed(by: disposeBag)
    //
    isRunning
        .withLatestFrom(timerAction){ ($0, $1) }
        .filter{ state, type in type.1 == .dynamic || type.0 }
        .flatMapLatest { object in
            object.0
                ? Observable&lt;Int&gt;.interval(.seconds(Timer.stageTime), scheduler: MainScheduler.instance)
                : .empty() }
        .map{ _ in audio.recalculateStep() }.debug(&quot;Recalculate&quot;)
        .subscribe()
        .disposed(by: disposeBag)
    //
    sessionType
        .bind {
            sessionTimerStopAction.onNext(.stop)
            switchSegment.onNext($0 == .dynamic)
            dataService.updateType($0) }
        .disposed(by: disposeBag)
    
    dataService.timerChanged()
        .bind(to: sessionTimerValue)
        .disposed(by: disposeBag)
    //
    let setTimer = Observable.merge(sessionTimerValue.asObservable(), progressTimerValue)
    //
    manageTimerMinLabel = setTimer
        .map{ $0.timeString }
        .asDriver()
    
    manageTimerMaxLabel = setTimer
        .withLatestFrom(sessionTimerValue){ ($0, $1) }
        .map{ ($1 - Int($0)).timeString }
        .asDriver()
    //
    manageTimerProgress = setTimer
        .withLatestFrom(sessionTimerValue){ ($0, $1) }
        .map{ Float($0)/Float($1) }
        .asDriver()
    //
    manageButtonState = Driver
        .merge(Driver
            .combineLatest(manageSoundAction.asDriver(), generatorPressed)
            .map{ _ in .manage },
               sessionTimerStopAction.asDriver())
        .withLatestFrom(generatorPressed){ ($0, $1) }
        .map{ ($1, audio.buttonState($1)) }
    //
    Observable.merge(sessionTimerStopAction, manageSoundAction)
        .withLatestFrom(generatorPressed){ ($0, $1) }
        .bind{ reason, gen in
            switch reason {
            case .manage: audio.manageGenerators()
            case .switched: audio.switchGenerator(gen)
            case .stop: audio.stopAllGenerators()
            }
    }.disposed(by: disposeBag)
}
</code></pre>
<p>}</p>
","385469","","385469","","2020-08-03 13:01:47","2020-08-03 13:01:47","RxSwift cleaning a sequence","<swift><rx-swift><rx-cocoa>","1","11","","","","CC BY-SA 4.0"
"63357574","1","63395439","","2020-08-11 11:53:10","","2","997","<p>How to convert deprecated debounce code to use DispatchTimeInterval?</p>
<p>Here is the deprecated code:</p>
<pre><code>self.myObservable.asDriver().debounce(2).drive(onNext: {(v) in
            doSomething()
        }).disposed(by: self.disposeBag)
</code></pre>
","10814688","","","","","2020-08-13 12:43:16","RxCocoa RxSwift 'debounce' is deprecated: Use DispatchTimeInterval overload instead","<rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"63388108","1","","","2020-08-13 04:24:29","","-1","292","<p>I'm seeing an endless stream of identical events being sent to combineLatest, even though the individual observables only print two values: the initials, and the ones I set. I need to explicitly do <code>distinctUntilChanged()</code> to stop the cycle, but I don't understand why.</p>
<pre><code>let one = BehaviorSubject&lt;String?&gt;(value: nil).debug()
let two = BehaviorSubject&lt;Int&gt;(value: 0).debug()

// endless stream of events with identical values
Observable.combineLatest(one, two)
    .debounce(.milliseconds(10), scheduler: MainScheduler.instance)
    .subscribe(onNext: { ... })
    .disposed(by: disposeBag)

// distinctUntilChanged breaks the cycle, but why?
Observable.combineLatest(one.distinctUntilChanged(), two.distinctUntilChanged())
    .debounce(.milliseconds(10), scheduler: MainScheduler.instance)
    .subscribe(onNext: { ... })
    .disposed(by: disposeBag)

one.onNext(&quot;a&quot;)
two.onNext(1)
</code></pre>
","62178","","","","","2020-08-13 23:06:20","RxSwift: CombineLatest endless stream of identical values","<swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"63457741","1","","","2020-08-17 19:54:53","","1","405","<p>I want to get data from server and update my DB after that I'll show received data to the user. For this goal I have a method(<code>getData()</code>) in my view model that returns a <code>Single</code> I call and subscribe this method in the view controller(<code>myVC.getData.subscribe({single in ...})</code>) in this method at first I call and subscribe(#1)(<code>getUnread()-&gt;Single</code>) the method run but I can not get the single event, I can not understand why I can't get the event(#3) in call back(#4)</p>
<p>after that I want to save data with calling(#2)(save([Moddel])-&gt;single)</p>
<pre><code>//I removed some part of this code it was to big
//This method is View Model
func getData() -&gt; Single&lt;[Model]&gt; {
    return Single&lt;[Model]&gt;.create {[weak self] single in
        //#1
        self!.restRepo.getUnread().subscribe({ [weak self] event in
            //#4
            switch event {
            case .success(let response):
                let models = response
                //#2
                self!.dbRepo.save(issues!).subscribe({ event in
                    switch event {
                    case .success(let response):
                        let models = response
                        single(.success(models))
                    case .error(let error):
                        single(.error(error))
                    }
                }).disposed(by: self!.disposeBag)
            case .error(let error):
                single(.error(error))
            }
        }).disposed(by: self!.disposeBag)
        return Disposables.create()
    }
}
</code></pre>
<p>.
.</p>
<pre><code> //I removed some part of this code it was to big
 //This method is in RestRepo class
 func getUnread() -&gt; Single&lt;[Model]&gt; {
    
    return Single&lt;[Model]&gt;.create { single in
        let urlComponent = ApiHelper.instance.dolphinURLComponents(for: ApiHelper.ISSUES_PATH)
        var urlRequest = URLRequest(url: urlComponent.url!)

        ApiHelper.instance.alamofire.request(urlRequest).intercept().responseJSON { response in
            debugPrint(response)
            let statusCode = response.response?.statusCode
            switch statusCode {
            case 200:
                do {
                    let models = try JSONDecoder().decode([Model].self, from: response.data!)
                    //#3
                    single(.success(models))
                }catch{
                    print(error)
                }
            case 304:
                debugPrint(response)
            default:
                single(.error(IssueResponseStatusCodeError(code: statusCode ?? 0)))
            }
        }
    return Disposables.create()
    }
</code></pre>
","5391914","","5391914","","2020-08-17 20:09:38","2020-08-18 10:40:14","Subscribe a single observable inside another single creation rxswift","<ios><swift><rx-swift><observers><subscribe>","1","0","","","","CC BY-SA 4.0"
"63465265","1","63467664","","2020-08-18 09:01:59","","1","84","<p>I have a <code>PublishSubject&lt;InfoData&gt;</code> in a ViewController. And I subscribe to it, so when it emits an event - I show the UIAlertViewController.</p>
<pre><code>let infoData = PublishSubject&lt;InfoData&gt;()
private func bindInfoData() {
     infoData.subscribe(onNext: { [weak self] (title, message) in
         self?.presentInfoSheetController(with: title, message: message)
     }).disposed(by: disposeBag)
}
</code></pre>
<p>In a ViewController I have a tableView with section headers. Section header view has a <code>infoMessageAction: PublishSubject&lt;InfoData?&gt;</code>. When initiating a view for <code>viewForHeaderInSection</code> I make a subscription between the <code>infoMessageAction</code> and <code>infoData</code>.</p>
<pre><code>func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? {
      let view = FutureSpendingsHeaderView(frame: frame)
      view.infoMessageAction
            .compactMap { $0 }
            .bind(to: infoData)
            .disposed(by: view.disposeBag)
      return view
}
</code></pre>
<p>When the header view initiated for the first time all works good - <code>infoMessageAction</code> triggers the <code>infoData</code> which in turn triggers presentation of AlertViewController.
When I scroll header view beyond the screen the subscription between <code>view.infoMessageAction</code> and <code>infoData</code> disposes (which is expected behavior as the view was deinited).</p>
<p>But I get disposed the subscription between <code>infoData</code> and ViewController as well. I receive <code>event completed</code> and <code>dispose</code> for <code>view.infoMessageAction</code> &lt;-&gt; <code>infoData</code> subscription and also <code>event completed</code> and <code>dispose</code> for <code>infoData</code> &lt;-&gt; ViewController subscription.</p>
<p>I expect that only <code>view.infoMessageAction</code> &lt;-&gt; <code>infoData</code> subscription should break. Also both subscriptions disposed by different disposeBag. Why is <code>infoData</code> &lt;-&gt; ViewController subscription get disposed and how to prevent it?</p>
<p>Thanks in advance!</p>
","6066758","","","","","2020-08-18 11:28:15","RxSwift Disposing one subscription invokes dispose of another subscription","<rx-swift><subscription>","2","0","","","","CC BY-SA 4.0"
"63502758","1","","","2020-08-20 10:04:59","","0","126","<p>I have an <code>observable</code> that will get disposed after some time. What i want is to get the last element before the observable is disposed. I have been trying but i am unable to find an operator for this purpose.</p>
<p>The <code>onDisposed</code> completion handler doesn't have anything as a parameter and going through the docs i cannot find any other operator for this purpose.</p>
<pre><code>selectedObservable
            .subscribe(onNext: { isSelected in
                //Do something
            }onDisposed:{
               //Somehow get the last emitted element
            })
            .disposed(by: disposeBag)
</code></pre>
","11975968","","","","","2020-08-20 10:54:24","rxswift receiving last element before disposing","<swift><observable><reactive-programming><rx-swift>","1","1","","","","CC BY-SA 4.0"
"63523616","1","63542696","","2020-08-21 13:14:39","","3","342","<p>I'm facing an issue of &quot;<code>Disallowed framework</code>&quot; when submitting to App Store. The issue is as follows</p>
<p>&quot;<code>ITMS-90726: Disallowed frameworks - Your app submission contains usages of the restricted framework libswiftXCTest.dylib. Remove these, rebuild and resubmit.</code>&quot;</p>
<p>Upon my research, I found that RxTest framework is still using restricted framework <code>libswiftXCTest.dylib</code></p>
<p><strong>Xcode Version</strong> : 11.6</p>
<p><strong>RxSwift Version</strong> : 5.1.1</p>
<ol>
<li>How do I solve this issue ?</li>
<li>Has RxTest resolved this issue ?</li>
</ol>
","1927625","","12336305","","2020-08-22 08:41:57","2020-08-27 15:39:09","RxTest is still using libswiftXCTest.dylib","<ios><rx-swift><rxtest>","2","0","","","","CC BY-SA 4.0"
"63545326","1","","","2020-08-23 09:19:17","","0","472","<p>I have updated my app replacing UIWebView with WKWebView.
It includes a framework that requires <em>RXSwift</em> framework version 4.5.0, that uses UIWebView (this have been fixed in a newer version).</p>
<p>I have updated my app and I'm not receiving the warning about UIWebView usage, even if RxSwift is using them, why is that?</p>
<p>is it safe to assume that the app won't be rejected after December 2020?</p>
","1913208","","","","","2020-08-30 04:38:38","ITMS-90809: Deprecated API Usage - UIWebView in RxSwift.framework","<ios><uiwebview><wkwebview><deprecated><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"63550102","1","63550497","","2020-08-23 17:36:20","","2","282","<p>I'm trying to build a timer that starts at 15 seconds and count down until 0.</p>
<p>The thing is that I'll want to update that timer by 2 seconds more based on an event.</p>
<p>This is what I've tried to do so far:</p>
<pre><code>struct ViewModel {
    struct Input {
        let add_time: Observable&lt;Void&gt;
    }
    struct Output {
        let current_time: Observable&lt;String&gt;
        let timer_over: Observable&lt;Void&gt;
    }

    private let current_time = BehaviorRelay(value: 15)
    private let timer_over = PublishSubject&lt;Void&gt;()
    
    func transform(input: Input) -&gt; Output {
        let current_time = self.current_time
            .flatMapLatest { time in
                Observable&lt;Int&gt;
                    .timer(.seconds(0), period: .seconds(1), scheduler: MainScheduler.instance)
                    .take(self.current_time.value + 1)
                    .map { &quot;\(self.current_time.value - $0)&quot; }
                    .do(onCompleted: { self.timer_over.onNext(()) })
            }
        return Output(
            current_time: current_time,
            timer_over: timer_over
        )
    }
}

let disposeBag = DisposeBag()

let add_time_subject = PublishSubject&lt;Void&gt;()
let input = ViewModel.Input(
    add_time: add_time_subject.asObservable()
)
let output = ViewModel().transform(input: input)
output.current_time
    .subscribe(onNext: { (time) in
        print(time)
    })
    .disposed(by: disposeBag)
output.timer_over
    .subscribe(onNext: {
        print(&quot;timer_over&quot;)
    })
    .disposed(by: disposeBag)
</code></pre>
<p>The thing is when I run <code>add_time_subject.onNext(()) </code> I'd want to update the timer by 2 seconds more only if the timer hasn't reached 0 seconds.</p>
<p>How should I do that?</p>
","3023098","","","","","2020-08-23 18:15:05","RxSwift - start and update count down timer","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"63560799","1","63561106","","2020-08-24 12:11:26","","0","494","<p>I want to fetch a data from three different APIs, and then save it in a database. Therefore, data from each query should be separated after the operation.
How to do it with RxSwift? Zip? In my example I'm using only two URLs, but it's just example.</p>
<p>QueryService:</p>
<pre><code>import Foundation
import RxSwift

class QueryService {

    let albumsURL = URL(string: &quot;https://jsonplaceholder.typicode.com/albums&quot;)!


    func fetchAlbums() -&gt; Observable&lt;[Album]&gt; {
        
        return Observable.create { observer -&gt; Disposable in
            
            let task = URLSession.shared.dataTask(with: self.albumsURL) { data, _, _ in
        
                guard let data = data else {
                    observer.onError(NSError(domain: &quot;&quot;, code: -1, userInfo: nil))
                    return
                }
        
                do {
                    let albums = try JSONDecoder().decode([Album].self, from: data)
                    observer.onNext(albums)
                } catch {
                    observer.onError(error)
                }
            }
            task.resume()
            return Disposables.create{
                task.cancel()
            }
        }
    }

    func fetchUsers() -&gt; Observable&lt;[User]&gt; {
        
        return Observable.create { observer -&gt; Disposable in
            
            let task = URLSession.shared.dataTask(with: URL(string: &quot;https://jsonplaceholder.typicode.com/users&quot;)!) { data, _, _ in
        
                guard let data = data else {
                    observer.onError(NSError(domain: &quot;&quot;, code: -1, userInfo: nil))
                    return
                }
                
                do {
                    let users = try JSONDecoder().decode([User].self, from: data)
                    observer.onNext(users)
                } catch {
                    observer.onError(error)
                }
            }
            task.resume()
            return Disposables.create{
                task.cancel()
            }
        }
    }


}
</code></pre>
","11056400","","6791677","","2020-08-24 12:23:45","2020-08-24 12:30:43","RxSwift and three API requests","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"63562641","1","","","2020-08-24 14:03:12","","0","177","<p>I added a UITextField and I want to restrict it to only alphabets and spaces. So with the following;</p>
<pre><code>let set = CharacterSet (charactersIn: &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLKMNOPQRSTUVWXYZ&quot;)
</code></pre>
<p>How can I do this without using delegates if possible and if possible using a method like RxSwift, RxCocoa etc .. Does anyone have a brilliant idea?</p>
","10018819","","","","","2020-08-25 13:01:17","Limit UITextField to letters and spaces only","<swift><xcode><rx-swift><rx-cocoa><rx-binding>","3","1","","","","CC BY-SA 4.0"
"63677105","1","63678210","","2020-08-31 19:35:38","","1","53","<p>I'm quite new to reactive programming so it's still hard to me to comprehend how it works.</p>
<p><strong>What I'm trying to do:</strong> when user taps on signUpButton (signUpTrigger), multiple observables are fired. I'm combining their results and producing new observable (signUp).</p>
<p><strong>What happens</strong>: when user taps on signUpButton (signUpTrigger), I'm getting data from putProfileImage and createUser observables, but nothing from signUp observable. I assume it's possible to write logic to make it work, but I'm struggling to come up with it myself.</p>
<pre><code>020-08-31 22:28:36.457: signUp -&gt; subscribed
2020-08-31 22:28:36.458: createUser -&gt; subscribed
2020-08-31 22:28:36.459: createProfileImage -&gt; subscribed
2020-08-31 22:28:48.843: createUser -&gt; Event next(&lt;FIRAuthDataResult: 0x6000036fd860&gt;)
2020-08-31 22:28:48.988: createProfileImage -&gt; Event next(https://firebasestorage.googleapis.com/v0/b/primeval-gear-236918.appspot.com/o/profile_images%2F8173E542-93DD-4594-BAA8-705A17227F1B?alt=media&amp;token=85c68612-bea4-41a5-a680-88a61c2e8989)
</code></pre>
<p>All the Viewmodel and VC code below:</p>
<pre><code>final class SignUpViewModel: ViewModelType {
    
    func transform(input: Input) -&gt; Output {
        
        let auth = Auth.auth()
        let filename = NSUUID().uuidString
  
        
        let storageRef = Storage
            .storage()
            .reference()
            .child(&quot;profile_images&quot;)
            .child(filename)
            .rx
        
        let databaseRef = Database
            .database()
            .reference()
            .child(&quot;users&quot;)
            .rx
        
        let putProfileImage = input.signUpTrigger
            .withLatestFrom(input.profileImage)
            .flatMap { data in
                storageRef.putData(data)
            }.flatMap { _ in
            storageRef.downloadURL()
        }.debug(&quot;createProfileImage&quot;)
        
        let createUser = input.signUpTrigger
            .withLatestFrom(Observable.combineLatest(input.email, input.password))
            .flatMap { (email,password) in
                auth.rx.createUser(withEmail: email, password: password)
        }.debug(&quot;createUser&quot;)
        
        let signUp = input.signUpTrigger
            .withLatestFrom(Observable.combineLatest(createUser, putProfileImage, input.username))
            .flatMap { createUserResult, url, username -&gt; Observable&lt;DatabaseReference&gt; in
                let profileImageUrl = url.absoluteString
                let uid = createUserResult.user.uid
                let dictionary = [&quot;username&quot;: username, &quot;profileImageUrl&quot;: profileImageUrl]
                let values = [uid: dictionary]
                return databaseRef.updateChildValues(values)
                    .asObservable()
        }.debug(&quot;signUp&quot;)
        
    
        let canSignUp = Observable.combineLatest(input.username, input.password, input.email)
        { username, password, email in
            return !username.isEmpty &amp;&amp; !password.isEmpty &amp;&amp; !email.isEmpty
        }
        
        return Output(canSignUp: canSignUp, isLoading: isLoading, signUp: signUp)
    }
    
}

</code></pre>
<pre><code>class SignUpViewController : UIViewController {
    
    var disposeBag = DisposeBag()
    
    @Injected var signUpView : SignUpView
    @Injected var viewModel : SignUpViewModel
    
    lazy var plusPhotoButton = signUpView.plusPhotoButton
    lazy var signUpButton = signUpView.signUpButton
    lazy var emailTextField = signUpView.emailTextField
    lazy var usernameTextField = signUpView.usernameTextField
    lazy var passwordTextField = signUpView.passwordTextField
    
    override func loadView() {
        view = signUpView
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupBindings()
    }
    
    func setupBindings() {
  
        let input = SignUpViewModel.Input(
            username: usernameTextField.rx.text.orEmpty.asObservable(),
            password: passwordTextField.rx.text.orEmpty.asObservable(),
            email: emailTextField.rx.text.orEmpty.asObservable(),
            signUpTrigger: signUpButton.rx.tap.asObservable(),
        )
        
        let output = viewModel.transform(input: input)
        
        output.canSignUp
            .bind(to:signUpButton.rx.signUpEnabled)
            .disposed(by: disposeBag)
        
        output.signUp
            .bind(onNext: { result in
                print(result)
            }).disposed(by:disposeBag)
     
        
    }
}
</code></pre>
","6740231","","","","","2020-08-31 21:08:15","Rxswift strange behaviour combining multiple observables","<ios><swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"63684007","1","","","2020-09-01 08:28:02","","1","79","<p>I have a <code>tableView</code> with two <code>cells</code>: <code>StaticSupportTableViewCell</code> and <code>SupportTableViewCell</code>. As the name suggests the first <code>cell</code> is a single static cell on top of the <code>tableView</code>. <code>SupportTableViewCell</code> can be any number and should be displayed underneath the static <code>cell</code>.</p>
<p>I have code that <code>binds</code> and returns the correct <code>cell</code>:</p>
<pre><code>viewModel.multiContent.bind(to: tableView.rx.items) { tableView, index, item in
    if let cellViewModel = item as? StaticSupportTableViewCellViewModel {
        let cell = tableView.dequeueReusableCell(withIdentifier: StaticSupportTableViewCell.identifier) as? StaticSupportTableViewCell
        cell?.viewModel = cellViewModel
        guard let guardedCell = cell else { return UITableViewCell()}
        return guardedCell
}
    if let cellViewModel = item as? SupportTableViewCellViewModel {
        let cell = tableView.dequeueReusableCell(withIdentifier: SupportTableViewCell.identifier) as? SupportTableViewCell
        cell?.viewModel = cellViewModel
        guard let guardedCell = cell else { return UITableViewCell()}
        return guardedCell
    }
    else { return UITableViewCell() }
}.disposed(by: disposeBag)
</code></pre>
<p>In the <code>viewModel</code> I have the <code>multiContent</code> variable:</p>
<pre><code>var multiContent = BehaviorRelay&lt;[Any]&gt;(value: [])
</code></pre>
<p>Now if I accept the <code>cell</code> <code>viewModels</code> onto that relay one by one it works:</p>
<p>This works:
<code>multiContent.accept([StaticSupportTableViewCellViewModel(myString: &quot;TESTING&quot;)])</code></p>
<p>Or doing this instead:
<code>multiContent.accept(mainService.serviceProviders.compactMap { SupportTableViewCellViewModel(serviceProvider: $0, emailRelay: emailRelay)})</code></p>
<p>But if I try both at the same time...</p>
<pre><code>multiContent.accept([StaticSupportTableViewCellViewModel(myString: &quot;TESTING&quot;)])
        multiContent.accept(mainService.serviceProviders.compactMap { SupportTableViewCellViewModel(serviceProvider: $0, emailRelay: emailRelay)})
</code></pre>
<p>...only the last cell is shown. It's like the last one replaces the first one instead of being an addition to it.</p>
<p>So how do I accept both <code>cell</code> <code>viewModels</code> to the relay so that both are displayed in the <code>tableView</code>?</p>
<p><em><strong>EDIT</strong></em>
I sort of got it right by adding the two <code>cell</code> <code>viewModels</code> into one <code>array</code>:</p>
<pre><code>let contents: [Any] = [StaticSupportTableViewCellViewModel(brand: name, url: web.localized(), phoneNumber: phone.localized()), mainService.serviceProviders.compactMap { SupportTableViewCellViewModel(serviceProvider: $0, emailRelay: emailRelay)}]
</code></pre>
<p>And changed the <code>binding</code>:</p>
<pre><code>if let cellViewModels = item as? [SupportTableViewCellViewModel] {...
</code></pre>
<p>This is problematic though as I'm stuck with and <code>array</code> of <code>[SupportTableViewCellViewModel]</code>. It doesn't work looping them and returning the <code>cells</code> as they overwrite one another.</p>
<p>The solution is to send in the <code>cell</code> <code>viewModel</code> <code>SupportTableViewCellViewModel</code> instead of <code>[SupportTableViewCellViewModel]</code>, but how do I do that?</p>
","8591381","","8591381","","2020-09-01 14:30:25","2020-09-01 14:30:25","How do I use multiple cells in a tableView using Rx?","<ios><swift><uitableview><tableview><rx-swift>","1","0","","","","CC BY-SA 4.0"
"63711698","1","","","2020-09-02 18:37:59","","1","64","<p>I'm trying to remove my dependency on RxAlamofire.</p>
<p>I currently have this function:</p>
<pre><code>  func requestData(_ urlRequest: URLRequestConvertible) -&gt; Observable&lt;(HTTPURLResponse, Data)&gt; {

    RxAlamofire.request(urlRequest).responseData()

  }
</code></pre>
<p>How can I refactor this and use Alamofire directly to build and return an RxSwift Observable?</p>
","699002","","","","","2020-09-02 21:47:19","Removing Swift RxAlamofire dependency","<swift><rx-swift><rxalamofire>","1","0","","","","CC BY-SA 4.0"
"63715446","1","63740568","","2020-09-03 01:14:43","","1","27","<p>I am using the realm as backend. And using RxSwift I have an observable to DB table for some column (it tracks pending state). After I get the event I switch to another Serial schedular to set the value of the column to Progress state in flatMap block (which returns completable). Now my problem is in case of too many events in DB my observable triggers multiple times and doesn't wait for my flatMap block to finish completely.</p>
<p>This results that the code process the same entity multiple times because before values are updated to DB again event gets triggered.</p>
<pre><code>Realm func

func downloadIconForUsers() -&gt; Observable&lt;[Person]&gt; {

// here I do fetch on the main thread and return for a filter for PENDING STATE
}



realmDB.downloadIconForUsers()
.observeOn(differentSchedular)
.filter { !$0.isEmpty}
.flatMap {
   //map over all entity and change state to progress
   let allProgress = 0.map { //map over all entity and change state to progress }
    userDB.updatePerson($0).do {
    //onCompleted
    Download all pending state icons
}

}
</code></pre>
","2644723","","","","","2020-09-04 11:46:24","RxSwift: Problem with DB events and different Schedular","<ios><realm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"63722542","1","63740385","","2020-09-03 11:18:46","","1","172","<p>As the title, is it necessary to call <code>disposed(by:)</code> in any case? If yes, why?</p>
<p>Consider a simple example like this:</p>
<pre><code>class ViewController: UIViewController {
  let button = UIButton()

  override func viewDidLoad() {
    button.rx.tap.bind(onNext: { _ in
      print(&quot;Button tapped!&quot;)
    })
    // Does this make any retain cycle here?
  }
}
</code></pre>
","3867033","","3867033","","2020-09-03 13:33:13","2020-09-04 11:34:46","Is calling `disposed(by:)` necessary in any case?","<swift><rx-swift>","1","5","","","","CC BY-SA 4.0"
"63776621","1","","","2020-09-07 11:21:07","","2","436","<p>I'm using <code>RxSwift</code> with <code>RxDataSources</code> framework to setup a tableview:</p>
<pre><code>let dataSource = RxTableViewSectionedAnimatedDataSource&lt;AnimatableSectionModel&lt;String, String&gt;&gt;(configureCell: { _, tableView, indexPath, item -&gt; UITableViewCell in
       let cell = tableView.dequeueReusableCellwithIdentifier: &quot;TestCell&quot;, for: indexPath)
       cell.configure()
       return cell
})

vm.cellViewModels
     .map({ [AnimatableSectionModel(model: &quot;&quot;, items: $0)] })
     .bind(to: _view.tableView.rx.items(dataSource: dataSource))
     .disposed(by: bag)
</code></pre>
<p>I'm trying to get my <code>UISwipeActionsConfiguration</code> to work in <code>UITableViewDelegate</code>, and setting the delegate as:</p>
<p><code>tableView.rx.setDelegate(self).disposed(by: bag)</code></p>
<p>At the same time setting the delegate methods as:</p>
<pre><code>extension UIViewController: UITableViewDelegate {
    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {
        let action = UIContextualAction(style: .normal, title: nil) { action, view, completion in
            
        }

        action.image = Images.shared.logo.resized(to: CGSize(width: 24, height: 24)).tintWithColor(.darkGray).withRenderingMode(.alwaysOriginal)
        action.backgroundColor = .clear

        let configuration = UISwipeActionsConfiguration(actions: [action])
        configuration.performsFirstActionWithFullSwipe = false

        return configuration
    }

    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -&gt; UIView? {
        let headerView = UIView(frame: CGRect(x: 0, y: 0, width: tableView.bounds.size.width, height: 20))
        headerView.backgroundColor = UIColor.red
        return headerView
    }
}
</code></pre>
<p>The header is called and works as expected, meaning the delegate should be set correct.</p>
<hr />
<p>Doing it without RxSwift, works for swipe actions.</p>
<p>Does anyone know how to get <code>trailingSwipeActionsConfigurationForRowAt</code> to work with RxDatasources, as I can only get <code>viewForHeaderInSection</code> to work?</p>
","7766093","","","","","2020-09-07 11:21:07","RxSwift TableView with swipe actions","<ios><swift><uitableview><rx-swift><rxdatasources>","0","1","","","","CC BY-SA 4.0"
"63800707","1","63804999","","2020-09-08 19:51:20","","3","198","<p>I would like to know the best possible way to handle the following situation, I have tried an approach as it will be described but I have encountered an issue of events calling each other repeatedly in a circular way hence it causes stackoverflow 😂</p>
<p>I have 4 observables as follows: -</p>
<pre class=""lang-swift prettyprint-override""><code>    let agreeToPrivacyPolicyObservable = BehaviorRelay&lt;Bool&gt;(value: false)
    let agreeToTermsObservable = BehaviorRelay&lt;Bool&gt;(value: false)
    let agreeToMarketingEmailObservable = BehaviorRelay&lt;Bool&gt;(value: false)
    let agreeToAllOptionsObservable = BehaviorRelay&lt;Bool&gt;(value: false)
</code></pre>
<p><strong>Goal:</strong>
Sync agree to all button with individual options. ie if agree to all is true/checked then force other options to be checked as well and vice-versa. Additionally if the previous state of all items were checked and either of them emit unchecked then remove a checkmark on Agree to all button.</p>
<p>The image below visualizes my goal above.
<a href=""https://i.stack.imgur.com/cHku7.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/cHku7.jpg"" alt=""Observables"" /></a></p>
<p><strong>What I have tried:</strong></p>
<pre class=""lang-swift prettyprint-override""><code>Observable.combineLatest(
agreeToPrivacyPolicyObservable,
agreeToTermsObservable,
agreeToMarketingEmailObservable,
agreeToAllOptionsObservable
, resultSelector:{(termsChecked,privacyChecked,marketingChecked,agreeToAllChecked) in 
  switch (termsChecked,privacyChecked,marketingChecked,agreeToAllChecked) {
        case (true, true, true,true):
         //All boxes are checked nothing to change.
             break
        case (false,false,false,false):
          //All boxes are unchecked nothing to change.
           break
       case (true,true,true,false):
     // I omitted the `triggeredByAgreeToAll` flag implementation details for clarity
         if triggeredByAgreeToAll {
              updateIndividualObservables(checked: false)
            }else {
               agreeToAllOptionsObservable.accept(true)
           }
    case (false,false,false,true):
         if triggeredByAgreeToAll {
             updateIndividualObservables(checked: true)
           }else {
               agreeToAllOptionsObservable.accept(false)
          }
  default:
     if triggeredByAgreeToAll &amp;&amp; agreeToAllChecked {
        updateIndividualObservables(checked: true)               
       }else if triggeredByAgreeToAll &amp;&amp; agreeToAllChecked == false {
            updateIndividualObservables(checked: false)
      } else if (termsChecked == false || privacyChecked == false || marketingChecked == false ) {
       agreeToAllOptionsObservable.accept(false)
        }
     }
                    
  }

})
.observeOn(MainScheduler.instance)
.subscribe()
.disposed(by: rx.disposeBag)
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>// Helper function
  func updateIndividualObservables(checked: Bool) {
      agreeToPrivacyPolicyObservable.accept(checked)
      agreeToTermsObservable.accept(checked)
      agreeToMarketingEmailObservable.accept(checked)
     }
</code></pre>
<p><strong>Explanation:</strong>
My attempt gives me <strong>Reentracy anomaly was detected error</strong> , which according to my observations is caused by events being triggered repeatedly. This seems to occurs in the default switch case (on my solution above). I think this solution is not good as I have to check which event triggered the function execution.</p>
<p>Is there any better approach or is it possible to refactor this solution into something easily manageable? Btw Feel free to ignore my implementation and suggest a different better approach if any. Thanks!</p>
<p><strong>UPDATES (WORKING SOLUTION)</strong></p>
<p>I successfully implemented a working solution by using <em>@Rugmangathan</em> idea (Found on the accepted answer). So I leave my solution here to help anyone in the future facing the same issue.
Here is the working solution: -</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import RxSwift
import RxRelay


/// This does all the magic of selecting checkboxes.
/// It is shared across any view which uses the license Agreement component.
class LicenseAgreemmentState {
    
      static let shared = LicenseAgreemmentState()
     let terms = BehaviorRelay&lt;Bool&gt;(value: false)
     let privacy = BehaviorRelay&lt;Bool&gt;(value: false)
     let marketing = BehaviorRelay&lt;Bool&gt;(value: false)
     let acceptAll = BehaviorRelay&lt;Bool&gt;(value: false)
    
    private let disposeBag = DisposeBag()
    
     func update(termsChecked: Bool? = nil, privacyChecked: Bool? = nil, marketingChecked: Bool? = nil, acceptAllChecked: Bool? = nil) {
        if let acceptAllChecked = acceptAllChecked {
            // User toggled acceptAll button so change everything to it's value.
            acceptAll.accept(acceptAllChecked)
            updateIndividualObservables(termsChecked: acceptAllChecked, privacyChecked: acceptAllChecked, marketingChecked: acceptAllChecked)
        } else {
            // If either of the individual item is missing change acceptAll to false
            if termsChecked == nil || privacyChecked == nil || marketingChecked == nil {
                acceptAll.accept(false)
            }
            updateIndividualObservables(termsChecked: termsChecked, privacyChecked: privacyChecked, marketingChecked: marketingChecked)
        }
        
       // Deal with the case user triggered select All from individual items and vice-versa.
        Observable.combineLatest(terms, privacy, marketing,resultSelector: {(termsChecked,privacyChecked, marketingChecked) in
            switch (termsChecked,privacyChecked, marketingChecked) {
            case (true, true, true):
                self.acceptAll.accept(true)
            case (false,false,false):
                self.acceptAll.accept(false)
            default:
                break
            }
        })
            .observeOn(MainScheduler.instance)
            .subscribe()
            .disposed(by: disposeBag)
    }
    
    // MARK: - Helpers
    private func updateIndividualObservables(termsChecked: Bool?,privacyChecked: Bool?, marketingChecked:Bool?) {
        if let termsChecked = termsChecked {
            terms.accept(termsChecked)
        }
        if let privacyChecked = privacyChecked {
            privacy.accept(privacyChecked)
        }
        if let marketingChecked = marketingChecked {
            marketing.accept(marketingChecked)
        }
    }
}

</code></pre>
","7551807","","7551807","","2020-09-09 07:55:18","2020-09-09 10:57:07","Handling circular style events on observable sequence RxSwift","<ios><swift><reactive-programming><rx-swift><rx-cocoa>","2","0","","","","CC BY-SA 4.0"
"63812886","1","","","2020-09-09 13:36:49","","1","41","<p>each time there is an error, I'm getting into the dispose  bag and can't enter even with a good password</p>
<p>need your help</p>
<pre><code>self.loginViewModel.performLogin(email: email, password: password)
            .observeOn(MainScheduler.instance)
            .subscribe(onNext: { _ in
                self.loginSucceeded()
            }, onError: { error in
                self.loginFailed(withError: error as? ApiError)
            }).disposed(by: disposeBag)
</code></pre>
","5838321","","","","","2020-09-14 10:55:39","rxswift- getting into the dispose bag after the first time error","<swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"63819634","1","63893761","","2020-09-09 21:15:20","","0","173","<p>I have a query that provides 'feed' data to a collection view using RxSwift and RxFirebase.
This feed data now has a 'Privacy' field (possible values: &quot;Public&quot;, &quot;Sub&quot;, and &quot;Private&quot;) and I need to filter out the 'Private' entities.</p>
<p>However when I add a 'Where' clause to do this, the listener no longer adds newly posted entities from this collection. The first call to this function always has the 'listens' bool set to true, because it wants to listen for new entities posted/deleted by a user.
I do not know why the events do not trigger the query.</p>
<p>Here is the current query code:</p>
<pre><code> func fetchGlobalFeed(limit: Int, startAfter: Timestamp?, listens: Bool) -&gt; Observable&lt;[Entity.Fragment]&gt; {
     var query = db.collection(k.mCollection)
         .limit(to: limit)
         .order(by: &quot;PublishedAt&quot;, descending: true)

    if let timestamp = startAfter {
         query = query.start(after: [timestamp])
    }

    let observable = listens ? query.rx.listen() : query.rx.getDocuments()
    return observable
          .catchErrorJustComplete()
          .map(FirestoreHelpers.dataFromQuerySnapshot)
          .map { data in
               data.compactMap {
                   try? FirestoreDecoder()
                       .decode(Entity.Fragment.self, from: $0)
               }
          }
 }
</code></pre>
<p>And changing the query to:</p>
<pre><code> var query = db.collection( k.mCollection ) 
               .limit( to: limit ) 
               .whereField( &quot;Privacy&quot;, in: [&quot;Public&quot;, &quot;Sub&quot;] ) // &lt;- this causes issue with listener 
               .order( by: &quot;PublishedAt&quot;, descending: true )
</code></pre>
<p>Maybe an explanation of how listeners work and any suggestions would be appreciated.
Thanks.</p>
<pre><code> RxFirebase version: 0.3.8
</code></pre>
<p>*Edit:
I don't have enough Rep to post pictures which is weird because I used to be able to. (says it requires 10 rep pts)</p>
<p>Here is the debug output:</p>
<blockquote>
<p>2020-09-10 11:37:03.101: MagmaFirestoreProvider.swift:165
(fetchGlobalFeed(limit:startAfter:listens:)) -&gt; subscribed</p>
<p>2020-09-10 11:37:03.324: MagmaFirestoreProvider.swift:165
(fetchGlobalFeed(limit:startAfter:listens:)) -&gt; Event
next([Entity.Fragment(ref: &lt;FIRDocumentReference: 0x60000109ef40&gt;,
publisher: Optional(UserEntity.Fragment(ref: &lt;FIRDocumentReference:
0x60000109ee80&gt;, username: &quot;Art_Collective&quot;, name: nil .........
privacy: Optional(magma.MagmaMagPrivacy.Public))])</p>
<p>2020-09-10 11:37:03.458: MagmaFirestoreProvider.swift:165
(fetchGlobalFeed(limit:startAfter:listens:)) -&gt; Event completed</p>
<p>2020-09-10 11:37:03.458: MagmaFirestoreProvider.swift:165
(fetchGlobalFeed(limit:startAfter:listens:)) -&gt; isDisposed</p>
</blockquote>
<p>When a new item is posted to the feed with a privacy of &quot;Sub&quot;, the item does not appear and there is zero debug output.
I have to refresh the collection view to get the above output and the new item in the feed.</p>
<p>I assume that's because the observable is being disposed?</p>
","13724086","","13724086","","2020-09-10 19:18:37","2020-09-15 01:21:20","Query listener does not work when 'Where' clause is added","<swift><firebase><google-cloud-firestore><rx-swift>","1","4","","","","CC BY-SA 4.0"
"63820054","1","63829029","","2020-09-09 21:54:25","","1","67","<p>A famous layout you can find in most apps is having several horizontal lists in a table view cell where each list gets its data from the server. can be found in Airbnb.  example below:</p>
<p>Each list has a loading view and an empty state to show when something is wrong.</p>
<p>Each list triggers the network request only when its first time created, so when displayed again by scrolling the table view, it should NOT make another network request to get data.</p>
<p>I tried several approaches and but not yet satisfied. some of which run into memory leaks and performance issues when having several collectionview. currently, I do the network requests in the View controller that holds the table view and passes the data to each cell.</p>
<p>Can anyone share their approach on how to do this? Appreciated!
Example:</p>
<p><a href=""https://i.stack.imgur.com/Rv8TY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Rv8TY.png"" alt=""enter image description here"" /></a></p>
","2187976","","","","","2020-09-10 11:47:22","high performance several horizontal collection views in table view cells with RxSwift/RxDataSources","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"63831314","1","63839010","","2020-09-10 13:58:21","","0","50","<p>I am building what I hope to be a simple macOS application that will locally stored videos selected from a popUP button.</p>
<p>The application is two windows 1) the AVPlayerView and 2) a simple control panel that allows the user to select and play the flagged videos on the other window.</p>
<p>All of this works very well in XCode. When the saved URL is selected, it is made into an AVAsset which is it turn made into an AVPlayerItem. The next process I have tried successfully(in Xcode) two ways: create a 1) PublishSubect or a 2) PublishSubject. In the view controller for the AVPlayerview window, I subscribe to the control panel's publish subject and either update the AVplayerView's player with the AVPlayerItem</p>
<pre><code> destinationVC.videoSubject.subscribe(
                onNext: { [weak self] item in
                   self?.player.replaceCurrentItem(with: item)
                }
            ).disposed(by: bag)
</code></pre>
<p>or I inject the player in a similar fashion. Either of these options works flawlessly when I run the application in XCode. The issue that I have is when I archive it to run the app on my computer, when I select the video to be played, the app crashes.</p>
<p>I isolated this task to a background thread with the hopes of better sniffing out an error but the resulting crash report does not make much sense to me:</p>
<pre><code>Thread 2 Crashed:: Dispatch queue: Background
0   [myinfo].STSVideoPlayer 0x000000010e655476 closure #1 in closure #1 in VideoViewController.prepare(for:sender:) + 134 (VideoViewController.swift:40)
1   [myinfo].STSVideoPlayer 0x000000010e655499 thunk for @escaping @callee_guaranteed () -&gt; () + 25
2   libdispatch.dylib               0x00007fff6e6d56c4 _dispatch_call_block_and_release + 12
3   libdispatch.dylib               0x00007fff6e6d6658 _dispatch_client_callout + 8
4   libdispatch.dylib               0x00007fff6e6dbc44 _dispatch_lane_serial_drain + 597
5   libdispatch.dylib               0x00007fff6e6dc5d6 _dispatch_lane_invoke + 363
6   libdispatch.dylib               0x00007fff6e6e5c09 _dispatch_workloop_worker_thread + 596
7   libsystem_pthread.dylib         0x00007fff6e930a3d _pthread_wqthread + 290
8   libsystem_pthread.dylib         0x00007fff6e92fb77 start_wqthread + 15
</code></pre>
<p>I am, obviously, over my head here. Any insight that you may have would be much appreciated!</p>
","14005027","","14005027","","2020-09-10 14:08:47","2020-09-10 23:45:47","Issues with RxSwift and AVKit","<swift><macos><video><rx-swift><avkit>","1","0","","","","CC BY-SA 4.0"
"63832224","1","63845501","","2020-09-10 14:46:22","","2","144","<p>I have a code similar to this:</p>
<pre><code>func fetchBalances() -&gt; Observable&lt;Result&lt;[User], Error&gt;&gt; {

    Observable.create { observer in
        
        var dataChangeDisposable: Disposable?
        DispatchQueue.main.async {

            let realm = try! Realm()
            let user = realm.objects(UserData.self)
            dataChangeDisposable = Observable.collection(from: user)
                .map { $0.map { UserData.convert($0) } }
                .subscribe(onNext: {
                    observer.onNext(.success($0))
                })
        }

        return Disposables.create {
            dataChangeDisposable?.dispose()
        }
    }
}
</code></pre>
<p>I need to use some thread with run loop in order to maintain subscription to Realm database (Realm's restriction). For now I'm using DispatchQueue.main.async {} method and I noticed that subscription remains active all the time, how does DispatchQueue.main stores it's submitted blocks and if Observable destroys does it mean that I'm leaking blocks in memory?</p>
","11999390","","11999390","","2020-09-10 15:02:37","2020-09-11 10:43:31","How does DispatchQueue.main.async store it's blocks","<ios><swift><realm><rx-swift>","1","3","","","","CC BY-SA 4.0"
"63836693","1","","","2020-09-10 19:44:54","","1","107","<p>I have the following code to set up binding.</p>
<pre><code>viewModel.searchTerm
            .bind(to: searchBar.rx.text)
        .disposed(by: self.disposeBag)
</code></pre>
<p>Basically I am looking at setting up two way binding between view model property &quot;searchTerm&quot; and the text property of UISearchBar.</p>
<p>The view model property has been defined as below in the viewModel:</p>
<pre><code>var searchTerm = BehaviorRelay&lt;String&gt;(value: &quot;&quot;)
</code></pre>
<p>This seems to be a one way binding and I do not see the view model property getting updated when user enters a text in the UISearchBar.</p>
<p>How should I modify this to set up two way binding?</p>
","12663913","","","","","2020-09-11 10:35:09","Two way binding between UISearch bar text and view model property in IOS RxSwift","<ios><rx-swift>","1","0","","","","CC BY-SA 4.0"
"63850101","1","","","2020-09-11 15:33:02","","1","463","<p>I have always placed the DisposeBag in ViewController in MVVM with RxSwift like it said in this topic:</p>
<p><a href=""https://stackoverflow.com/questions/50382711/on-ios-for-the-disposebag-in-mvvm-can-it-be-placed-in-viewmodel"">On iOS, for the DisposeBag in MVVM, can it be placed in ViewModel?</a></p>
<p>But with combine, since the View is a struct and cancelable can't be placed in this, I am stuck with solution.</p>
<p>How to manage subscription between View and VM in Combine without add cancelable in ViewModel</p>
<p>Or maybe, in SwiftUI / Combine, there is no choice to place cancelables in VM.</p>
<p>There is an example of implementation in SiwftUI / Combine :</p>
<p>The ViewModel</p>
<pre><code>
class EquityViewModel: ObservableObject {
    
    @Injected private var api: AlphaVantageAPI
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    private let code: String
    @Published private var result: Quote?
    @Published var price: String = &quot;&quot;
    
    init(code: String) {
        self.code = code
        self.$result
            .map {
                return &quot;\($0?.price ?? 0) €&quot;
            }.assign(to: &amp;$price)
    }
    
    
    func addToPortfolio(){
        
    }
    
    func onAppear() {
        self.api.quote(symbol: self.code).share()
            .sink { completion in }
                receiveValue: { quote in
                    self.result = quote.quote
                }
            .store(in: &amp;cancellables)
    }
    
}
</code></pre>
<p>The View</p>
<pre><code>struct EquityView: View {
    
    @ObservedObject  var viewModel: EquityViewModel
    
    init(viewModel: EquityViewModel) {
        self.viewModel = viewModel
    }
    
    var body: some View {
        ZStack {
            Color(&quot;primary&quot;).edgesIgnoringSafeArea(.all)
            VStack {
                Text(&quot;Stock Price&quot;)
                    .foregroundColor(.white)
                    .frame(minWidth: 0,
                           maxWidth: .infinity,
                           alignment: .topLeading)
                    .padding()
                HStack {
                    Text(self.viewModel.price)
                        .foregroundColor(.white)
                    Text(&quot;+4.75 %&quot;)
                        .foregroundColor(.white)
                        .padding(.leading, 20)
                }.frame(minWidth: 0,
                        maxWidth: .infinity,
                        alignment: .topLeading)
                .padding()
                Button(action: self.viewModel.addToPortfolio, label: {
                    Text(&quot;Add to portfolio&quot;)
                        .foregroundColor(.white)
                        .frame(minWidth: 0,
                                maxWidth: .infinity,
                                maxHeight: 30,
                                alignment: .center)
                        .background(Color.blue)
                        .cornerRadius(5)
                }).padding()
                Spacer()
            }
        }.frame(alignment: .leading)
        .onAppear(perform: self.viewModel.onAppear)
    }
}
</code></pre>
","2611161","","","","","2020-09-26 16:46:18","With SwiftUI / Combine, How to avoid to put cancellables in ViewModel","<mvvm><swiftui><reactive-programming><rx-swift><combine>","1","2","1","","","CC BY-SA 4.0"
"63874815","1","63876720","","2020-09-13 19:35:23","","1","134","<p>I'm using RxSwift and currently, I have a list of addresses that could be edited inline</p>
<p>I.E: The user clicks on a button and the cell is transformed into editing mode essentially displaying a few UITextFields</p>
<p>Now the problem is that when I bind the input of my TextField to my model the TableView gets reloaded and therefore keyboard dismisses, I've also tried RxAnimatableDataSource but no avail it still dismisses the keyboard on each keystroke.</p>
<p>ViewModel:</p>
<pre><code>class UpdateAddressViewModel: ViewModel, ViewModelType {
    
    struct Input {
        let viewDidLoad: AnyObserver&lt;Void&gt;
        let selectItemTrigger: AnyObserver&lt;Int&gt;
        let editButtonTrigger: AnyObserver&lt;Int&gt;
        let editTrigger: AnyObserver&lt;Int&gt;
        let firstNameIndexed: AnyObserver&lt;(String, Int)&gt;
        let lastNameIndexed: AnyObserver&lt;(String, Int)&gt;
        let address1Indexed: AnyObserver&lt;(String, Int)&gt;
        let address2Indexed: AnyObserver&lt;(String, Int)&gt;
        let zipIndexed: AnyObserver&lt;(String, Int)&gt;
        let cityIndexed: AnyObserver&lt;(String, Int)&gt;
        let stateIndexed: AnyObserver&lt;(String, Int)&gt;
        let phoneIndexed: AnyObserver&lt;(String, Int)&gt;
    }
    
    struct Output {
        let addresses: Driver&lt;[AddressViewModel]&gt;
        let reloadAndScroll: Driver&lt;(Int, Bool)&gt;
        let showMenu: Driver&lt;Int&gt;
        let error: Driver&lt;Error&gt;
    }
    
    private(set) var input: Input!
    private(set) var output: Output!
    
    //Input
    private let viewDidLoad = PublishSubject&lt;Void&gt;()
    private let editButtonTrigger = PublishSubject&lt;Int&gt;()
    private let editTrigger = PublishSubject&lt;Int&gt;()
    private let firstNameIndexed = ReplaySubject&lt;(String, Int)&gt;.create(bufferSize: 1)
    private let lastNameIndexed = ReplaySubject&lt;(String, Int)&gt;.create(bufferSize: 1)
    private let address1Indexed = ReplaySubject&lt;(String, Int)&gt;.create(bufferSize: 1)
    private let address2Indexed = ReplaySubject&lt;(String, Int)&gt;.create(bufferSize: 1)
    private let zipIndexed = ReplaySubject&lt;(String, Int)&gt;.create(bufferSize: 1)
    private let cityIndexed = ReplaySubject&lt;(String, Int)&gt;.create(bufferSize: 1)
    private let stateIndexed = ReplaySubject&lt;(String, Int)&gt;.create(bufferSize: 1)
    private let phoneIndexed = ReplaySubject&lt;(String, Int)&gt;.create(bufferSize: 1)
    
    //Output
    private let addresses = BehaviorRelay&lt;[AddressViewModel]&gt;(value: [AddressViewModel()])
    
    override init() {
        super.init()
        
        observeViewDidLoad()
        
        observeEditAddress()
            .bind(to: addresses)
            .disposed(by: disposeBag)
        
        firstNameIndexed
            .withLatestFrom(addresses) { firstNameIndexed, viewModels -&gt; (String, Int, [AddressViewModel]) in
                let (firstName, index) = firstNameIndexed
                return (firstName, index, viewModels)
            }
            .map { firstName, index, viewModels in
                var viewModels = viewModels
                viewModels[index].address.firstName = firstName
                return viewModels
            }
            .bind(to: addresses)
            .disposed(by: disposeBag)
        
        input = Input(
            viewDidLoad: viewDidLoad.asObserver(),
            selectItemTrigger: selectItemTrigger.asObserver(),
            editButtonTrigger: editButtonTrigger.asObserver(),
            editTrigger: editTrigger.asObserver(),
            firstNameIndexed: firstNameIndexed.asObserver(),
            lastNameIndexed: lastNameIndexed.asObserver(),
            address1Indexed: address1Indexed.asObserver(),
            address2Indexed: address2Indexed.asObserver(),
            zipIndexed: zipIndexed.asObserver(),
            cityIndexed: cityIndexed.asObserver(),
            stateIndexed: stateIndexed.asObserver(),
            phoneIndexed: phoneIndexed.asObserver()
        )
        
        output = Output(
            addresses: addresses.asDriver(onErrorJustReturn: []),
            reloadAndScroll: reloadAndScroll,
            showMenu: editButtonTrigger.asDriverOnErrorJustComplete(),
            error: errorTracker.asDriver()
        )
    }
    
    private func observeViewDidLoad() {
         //Loading work here
    }
    
    private func observeEditAddress() -&gt; Observable&lt;[AddressViewModel]&gt; {
        editTrigger
            .withLatestFrom(addresses) { index, viewModels in
                return (index, viewModels)
            }
            .map { index, viewModels in
                var viewModels = viewModels
                
                for currentIndex in viewModels.indices {
                    viewModels[currentIndex].isSelected = currentIndex == index
                    viewModels[currentIndex].isEditing = currentIndex == index
                    
                    if currentIndex == index {
                        viewModels[currentIndex].copyAddress()
                    }
                }
                
                return viewModels
            }
    }
}
</code></pre>
<p>And here's my ViewController binding of data source to tableview</p>
<pre><code>viewModel
    .output
    .addresses
    .drive(tableView.rx.items) { [weak self] tableView, row, viewModel in
        guard let self = self else { return UITableViewCell() }
        let indexPath = IndexPath(row: row, section: 0)
        
        if viewModel.address.rechargeId == nil &amp;&amp; viewModel.address.shopifyId == nil {
            let cell: NewAddressCell = tableView.dequeueCell(for: indexPath)
            
            cell.configure(viewModel: viewModel)
            
            return cell
        } else if viewModel.isEditing {
            let cell: UpdateAddressCell = tableView.dequeueCell(for: indexPath)
            
            cell.configure(viewModel: viewModel)
            
            cell
                .rx
                .firstName
                .map { ($0, row) }
                .bind(to: self.viewModel.input.firstNameIndexed)
                .disposed(by: cell.disposeBag)
            
            return cell
        } else {
            let cell: AddressCell = tableView.dequeueCell(for: indexPath)
            
            cell.configure(viewModel: viewModel)
            
            cell
                .rx
                .editButtonTapped
                .map { _ in return row }
                .bind(to: self.viewModel.input.editButtonTrigger)
                .disposed(by: cell.disposeBag)
            
            return cell
        }
    }
    .disposed(by: disposeBag)
</code></pre>
","9071240","","","user14219868","2020-09-13 19:39:16","2020-09-14 00:17:09","Preventing first responder to resign on tableview reload","<ios><swift><rx-swift><rxdatasources>","1","0","","","","CC BY-SA 4.0"
"63881250","1","","","2020-09-14 09:04:35","","0","39","<p>I want to preview some items in a list with <strong>QLPreviewController</strong>. The preview controller gets a list of my objects:</p>
<pre><code>func numberOfPreviewItems(in controller: QLPreviewController) -&gt; Int {
        return objects.value.count
    }
    
    func previewController(_ controller: QLPreviewController, previewItemAt index: Int) -&gt; QLPreviewItem {
        // returns path
    }
</code></pre>
<p>To differ between my two models and still get the index path in my table view I have to zip my observables:</p>
<pre><code>_ = Observable.zip(tableView.rx.itemSelected, tableView.rx.modelSelected(Structured.self)).subscribe(onNext: { [weak self] indexPath, model in
            guard let self = self else { return }
            if model is File {
                    self.quickLookController.currentPreviewItemIndex = indexPath.row
                    self.parent?.navigationController?.show(self.quickLookController, sender: self)
            }
            if model is FileStructure {
                let structure = model as! Structure
                let sb = UIStoryboard(name: &quot;Main&quot;, bundle: nil)
                let fileListViewCtrl = sb.instantiateViewController(withIdentifier: &quot;FileListViewController&quot;) as! FileListViewController
                self.navigationController?.pushViewController(fileListViewCtrl, animated: true)
            }
        })
</code></pre>
<p>Every time I select a file in my list I get <strong>No item to preview</strong> in the preview itself.</p>
<p>I think the main problem is that I give the <strong>QLPreviewController</strong> a list of objects, but then pass the index over objects and file structures and they are not the same at all.</p>
<p>Any recommendations on how get the index path for my <strong>File</strong> model?</p>
","13834457","","13834457","","2020-09-14 10:44:40","2020-09-14 10:44:40","How can I set the index for one model only?","<ios><swift><rx-swift><rx-cocoa>","0","0","","","","CC BY-SA 4.0"
"63928714","1","","","2020-09-16 22:25:21","","2","121","<p>I have a ViewController with a UICollectionView and its elements are bound and cells created via:</p>
<pre><code> self.viewModel.profileItems.bind(to: self.collectionView.rx.items){ (cv, row, item) ...
</code></pre>
<p>I also react to the user taps via:</p>
<pre><code>self.collectionView.rx.modelSelected(ProfileItem.self).subscribe(onNext: { (item) in
        if(/*special item*/) {
            let xVC = self.storyboard?.instantiateViewController(identifier: &quot;x&quot;) as! XViewController
            xVC.item = item
            self.navigationController?.pushViewController(xVC, animated: true)
        } else {
            // other generic view controller
        }
    }).disposed(by: bag)
</code></pre>
<p>The property in the xViewController for item is of Type <code>ProfileItem?</code>. How can changes to item in the XViewController be bound to the collectionView cell?</p>
<p>Thanks in advance</p>
","5301040","","","","","2020-09-17 11:46:12","Observe object change in other ViewController in RxSwift","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"63951828","1","","","2020-09-18 08:15:41","","0","270","<p>i want to convert this function to write in Combine framework. I tried a couple way but it didnt work . Can anyone have an idea about this ?</p>
<pre><code>func requestAuth(serviceParams: AuthServiceParams) -&gt; Observable&lt;AuthResponse&gt; {
    
    return Observable.create{observer -&gt; Disposable in
        // buradaki işlemler rx 'te yapılacak.
        
        AlamofireService.auth(serviceParams: serviceParams).responseObject {
            (response:DataResponse&lt;AuthResponse&gt;) in
            if(response.error != nil ){
                print(&quot;❌⭕️❌ Auth login hatalı bir dönüş aldı sorun var.&quot;)
                observer.onError(response.error!)
                observer.onCompleted()
                return
            } else {
                if let data = response.result.value {
                    guard let token = data.data?.token else {
                        print(&quot;TOKEN BULUNAMADI&quot;)
                        let authResponse = AuthResponse(
                            result: &quot;fault&quot;,
                            success: false,
                            data: nil,
                            message: &quot;Kullanıcı adı veya şifre hatalı&quot;,
                            errCode: &quot;E0000&quot;
                        )
                        observer.onNext(authResponse)
                        return
                    }
                    print(&quot;AuthLogin Token -------&gt;   \(token)&quot;)
                    ApplicationVariables.token = token
                    ApplicationVariables.customer = data.data?.customer
                    ApplicationVariables.config = data.data?.store?.config
                    ApplicationVariables.logo = data.data?.store?.logo
                    observer.onNext(data)
                }else {
                    let error = NSError(domain: &quot;Bir sorun oluştu. Lütfen yöneticinize başvurunuz.&quot;, code: 1001, userInfo: nil)
                    observer.onError(error)
                }
                observer.onCompleted()
            }
        }
        return Disposables.create()
    }
}
</code></pre>
","9923824","","77567","","2020-09-18 16:07:50","2020-09-18 20:55:36","How can ı convert RxSwift to Combine Framework","<swift><rx-swift><combine>","1","0","","","","CC BY-SA 4.0"
"63967156","1","64954635","","2020-09-19 09:17:52","","4","6996","<p>I just updated Xcode to the latest version, and the project is no longer compiling. I removed everything and tried to rebuild pods but ended up having the same issue this issue:</p>
<blockquote>
<p>[x]
/Users/alouanemed/Projects/App-iOS/Pods/_Prebuild/Moya/Sources/RxMoya/MoyaProvider+Rx.swift:2:8:
compiling for iOS 10.0, but module 'RxSwift' has a minimum deployment
target of iOS 12.0:
/Users/alouanemed/Projects/App-iOS/Pods/build/Release-iphoneos/RxSwift/RxSwift.framework/Modules/RxSwift.swiftmodule/arm64-apple-ios.swiftmodule</p>
<p>import RxSwift
^</p>
</blockquote>
","2187976","","2187976","","2020-09-19 09:24:49","2021-01-26 15:05:01","Xcode 12: Compiling for iOS 10.0, but module 'RxSwift' has a minimum deployment target of iOS 12.0","<ios><xcode><cocoapods><rx-swift>","3","0","1","","","CC BY-SA 4.0"
"64008011","1","","","2020-09-22 10:39:25","","1","43","<p>I'm trying to put three types of cells in one tableView,</p>
<p>by using rxSwift, the fist section have two items, the second 43 item and the the last section has 16 item,</p>
<p>but the tableView shows only one item per section</p>
<p>you can see the error in the image below</p>
<p><a href=""https://i.stack.imgur.com/JV4eU.png"" rel=""nofollow noreferrer"">EXAMPLE OF THE ERROR</a></p>
<p>okay, this is the code</p>
<pre><code>class OrdersVC: BaseViewController {

   @IBOutlet weak var ordersTabel: UITableView!

    public let orders : PublishSubject&lt;OrdersTypeModel&gt; = PublishSubject()
    var ordersDecoded = OrdersTypeModel()

    var delivery = Array&lt;DetailsModel&gt;()

    var takeAway = Array&lt;DetailsModel&gt;()

    var history = Array&lt;OrderModel&gt;()

    let disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        ordersTabel.allowsSelection = false
        setupBindings()

   }

   private func setupBindings() {
    
     ordersTabel.register(UINib(nibName: &quot;DeliveryCell&quot;, bundle: nil), forCellReuseIdentifier: String(describing: DeliveryCell.self))
     ordersTabel.register(UINib(nibName: &quot;TakeAwayCell&quot;, bundle: nil), forCellReuseIdentifier: String(describing: TakeAwayCell.self))
     ordersTabel.register(UINib(nibName: &quot;HistoryCell&quot;, bundle: nil), forCellReuseIdentifier: String(describing: HistoryCell.self))

       ordersTabel.rx.willDisplayCell
        .subscribe(onNext: ({ (cell,indexPath) in
            let transform = CATransform3DTranslate(CATransform3DIdentity, 0, -250, 0)
            cell.layer.transform = transform
            UIView.animate(withDuration: 1, delay: 0, usingSpringWithDamping: 0.7, initialSpringVelocity: 0.5, options: .curveEaseOut, animations: {
                cell.alpha = 1
                cell.layer.transform = CATransform3DIdentity
            }, completion: nil)

        })).disposed(by: disposeBag)

    orders
        .observeOn(MainScheduler.instance)
        .subscribe(
            onNext: { [self] in
                print(&quot;ononon onNext: \($0)&quot;)
                ordersDecoded = $0

                delivery = ordersDecoded.orderdelivery
                delivery2.onNext(delivery)

                takeAway = ordersDecoded.ordertakeaway
                takeAway2.onNext(takeAway)

                history = ordersDecoded.orders1
                history2.onNext(history)
                print(&quot;ononon onNext: \(delivery.count), \(takeAway.count), \(history.count)&quot;)

                let sections: [MultipleSectionModel] = [
                    .DeliverySection(title: &quot;Delivery&quot;, items: [.DeliveryItem(model: delivery)]),

                    .TakeAwaySection(title: &quot;Take Away&quot;,   items: [.TakeAwayItem(model: takeAway)]),

                    .HistorySection(title: &quot;History&quot;, items: [.HistoryItem(model: history)])
                ]

                let dataSource = OrdersVC.dataSource()

                Observable.just(sections)
                    .bind(to: ordersTabel.rx.items(dataSource: dataSource))
                    .disposed(by: disposeBag)
                

            },
            onError: { print(&quot;ononon onError: \($0)&quot;) },
            onCompleted: { print(&quot;ononon onCompleted&quot;) },
            onDisposed: { print(&quot;ononon onDisposed&quot;) }
        )
        .disposed(by: disposeBag)

    }
}

extension OrdersVC {
static func dataSource() -&gt; RxTableViewSectionedReloadDataSource&lt;MultipleSectionModel&gt; {
    return RxTableViewSectionedReloadDataSource&lt;MultipleSectionModel&gt;(
        configureCell: { dataSource, table, idxPath, _ in
            print(&quot;sjdkhbgdjkf \(idxPath)&quot;)
            print(&quot;sjdkhbgdjkf \(idxPath.row)&quot;)

            switch dataSource[idxPath] {
                case let .DeliveryItem(model):
                    print(&quot;sjdkhbgdjkf1 \(model.count)&quot;)
                    let cell: DeliveryCell = table.dequeueReusableCell(withIdentifier: &quot;DeliveryCell&quot;, for: idxPath) as! DeliveryCell
                    cell.model = model[idxPath.row]

                    return cell
                
                case let .TakeAwayItem(model):
                    print(&quot;sjdkhbgdjkf2 \(model.count)&quot;)
                    for i in 0 ... model.count - 1 {
                        let cell: TakeAwayCell = table.dequeueReusableCell(withIdentifier: &quot;TakeAwayCell&quot;, for: idxPath) as! TakeAwayCell
                        cell.model = model[i]
                        print(&quot;sjdkhbgdjkf2 \(i)&quot;)

                        return cell
                    }

                case let .HistoryItem(model):
                    print(&quot;sjdkhbgdjkf3 \(model.count)&quot;)
                    for i in 0 ... model.count - 1 {
                        let cell: HistoryCell = table.dequeueReusableCell(withIdentifier: &quot;HistoryCell&quot;, for: idxPath) as! HistoryCell
                        cell.model = model[i]
                        print(&quot;sjdkhbgdjkf3 \(i)&quot;)

                        return cell
                    }
            }
            
            return table.dequeueReusableCell(withIdentifier: &quot;HistoryCell&quot;, for: idxPath) as! HistoryCell
        },

        titleForHeaderInSection: { dataSource, index in
            let section = dataSource[index]

            if section.title == &quot;History&quot; {
                return section.title

            } else {
                return nil
            }
        }
    )
}
}

enum MultipleSectionModel {
    case DeliverySection(title: String, items: [SectionItem])
    case TakeAwaySection(title: String, items: [SectionItem])
    case HistorySection(title: String, items: [SectionItem])
}

extension MultipleSectionModel: SectionModelType {
typealias Item = SectionItem

var items: [SectionItem] {
    switch  self {
        case .DeliverySection(title: _, items: let items):
            return items.map { $0 }
        
        case .TakeAwaySection(title: _, items: let items):
            return items.map { $0 }
        
        case .HistorySection(title: _, items: let items):
            return items.map { $0 }
    
    }
}

init(original: MultipleSectionModel, items: [Item]) {
    switch original {
        case let .DeliverySection(title: title, items: _):
           self = .DeliverySection(title: title, items: items)
            
        case let .TakeAwaySection(title: title, items: _):
            self = .TakeAwaySection(title: title, items: items)
   
    case let .HistorySection(title, _):
           self = .HistorySection(title: title, items: items)

    }
    }
}

extension MultipleSectionModel {
var title: String {
    switch self {
        case .DeliverySection(title: let title, items: _):
            return title

        case .TakeAwaySection(title: let title, items: _):
            return title
        
        case .HistorySection(title: let title, items: _):
            return title

    }
}
}

 enum SectionItem {
case DeliveryItem(model: Array&lt;DetailsModel&gt;)
case TakeAwayItem(model: Array&lt;DetailsModel&gt;)
case HistoryItem(model: Array&lt;OrderModel&gt;)
}
</code></pre>
<p>okay as you can see in the image and the code</p>
<p>the tableView show 3 items only.</p>
<p>I tried to do a for loop because the count is more than one like this</p>
<pre><code>for i in 0 ... model.count - 1 {
                        let cell: HistoryCell = table.dequeueReusableCell(withIdentifier: &quot;HistoryCell&quot;, for: idxPath) as! HistoryCell
                        cell.model = model[i]
                        print(&quot;sjdkhbgdjkf3 \(i)&quot;)

                        return cell
                    }
</code></pre>
<p>I noticed that it does not do the loop, although the count is more than 1</p>
<p>and thank for helping</p>
","11700604","","11700604","","2020-09-22 10:46:23","2020-09-23 12:05:46","When using RxSwift and mutable sections in tableView, It show only one item per section","<ios><swift><xcode><rx-swift>","1","0","","","","CC BY-SA 4.0"
"64013269","1","","","2020-09-22 15:46:55","","1","168","<p>I am trying to implement something like this,</p>
<pre><code>    let api1 = Observable.of([&quot;documents&quot;])    //Replace with observable to download docs
    let api2 = Observable.of([&quot;applications&quot;]) //Replace with observable to download apps
    let api3 = Observable.of([&quot;videos&quot;])       //Replace with observable to download videos

    Observable.combineLatest(api1, api2, api3){(docs, apps, videos) in
        return (docs, apps, videos)
    }.skipWhile{ (docs, apps, videos) in
        return docs.count == 0 &amp;&amp; apps.count == 0 &amp;&amp; videos.count == 0
    }.subscribe(onNext:{(docs, apps, videos) in

    })
    .disposed(by:disposeBag)
</code></pre>
<p>In my case, I am trying to create observables dynamically and add it to an array like this,</p>
<pre><code>private var discoverObservables = [Observable&lt;Any&gt;]()


func loadDiscoverFeeds(){
      
        self.feeds.forEach({
            feed in
            switch feed.feedType{
            case &quot;a&quot;:
                let observable = self.aObservable(url: feed.feedURL ?? &quot;&quot;)
                self.discoverObservables.append(observable)
                break
            case &quot;b&quot;:
                let observable = self.bObservable(url: feed.feedURL ?? &quot;&quot;)
                self.discoverObservables.append(observable)
                break
            case &quot;c&quot;:
                let observable = self.cObservable(url: feed.feedURL ?? &quot;&quot;)
                self.discoverObservables.append(observable)
                break
            case &quot;d&quot; :
                let observable = self.dObservable(url: feed.feedURL ?? &quot;&quot;)
                self.discoverObservables.append(observable)
                break
            default:
                break
            
            }
        })
}

    private func aObservable(url : String) -&gt; Observable&lt;A?&gt;{
            return APIManager.shared.getA(url: url)
        }

    private func bObservable(url : String) -&gt; Observable&lt;B?&gt;{
            return APIManager.shared.getB(url: url)
        }


    private func cObservable(url : String) -&gt; Observable&lt;C?&gt;{
            return APIManager.shared.getC(url: url)
        }
</code></pre>
<p>But this is not working because discoverObservables array is expecting the value of Type <code>Observable&lt;Any&gt;</code> and I am trying to add <strong>Observable&lt;A?&gt;</strong></p>
<p>How can I do this correctly, I want to make sure all the observables return data before I start processing the data.</p>
<p><strong>Edit</strong>
I am trying to load data from different sources before that is added to the view, basically, I have a collectionview, each section loads data from different API, I am trying to get all the required data from all sources before that is added to collection view.</p>
","8780913","","8780913","","2020-09-23 15:20:42","2020-09-23 15:49:50","RXSwift ObservableCollection with CombineLatest","<swift><observable><rx-swift><combinelatest>","3","4","","","","CC BY-SA 4.0"
"64044647","1","64054887","","2020-09-24 10:36:29","","1","261","<p>I have a list of objects i need to send to a server and i would like to do this one after the other (not in parallel). After all objects have been sent and there was no error i want to run additional Observables which do different things.</p>
<pre class=""lang-swift prettyprint-override""><code>let objects = [1, 2, 3]

let _ = Observable.from(objects).flatMap { object -&gt; Observable&lt;Void&gt; in
    return Observable.create { observer in
        print(&quot;Starting request \(object)&quot;)
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) { // one request takes ~2sec
            print(&quot;Request \(object) finished&quot;)
            observer.onNext(Void())
            observer.onCompleted()
        }
        return Disposables.create()
    }
}.flatMap { result -&gt; Observable&lt;Void&gt; in
    print(&quot;Do something else (but only once)&quot;)
    return Observable.just(Void())
}.subscribe(
    onNext: {
        print(&quot;Next&quot;)
    },
    onCompleted: {
        print(&quot;Done&quot;)
    }
)
</code></pre>
<p>What i get is</p>
<pre><code>Starting request 1
Starting request 2
Starting request 3
Request 1 finished
Do something else (but only once)
Next
Request 2 finished
Do something else (but only once)
Next
Request 3 finished
Do something else (but only once)
Next
Done
</code></pre>
<p>The whole process ends after 2 sec. What i want is</p>
<pre><code>Starting request 1
Request 1 finished
Starting request 2
Request 2 finished
Starting request 3
Request 3 finished
Do something else (but only once)
Next
Done
</code></pre>
<p>The whole sequence should end after 6 seconds (because it's not executed parallel).</p>
<p>I got this to work with a recursive function. But with lots of requests this ends in a deep recursion stack which i would like to avoid.</p>
","1771537","","","","","2020-09-25 11:57:01","How do I sequentially and nonparallel loop through an array in RxSwift?","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"64049955","1","64070386","","2020-09-24 15:47:53","","6","452","<p>I have this generic <code>fetchData()</code> function in my NetworkManager class that is able to request make a authorised request to the network and if it fail (after a number of retries) emits an error that will restart my app (requesting a new login). I need that this retry token be called synchronously, I mean, if multiple requests failed, only one should be requesting the refresh token at once. And if that one fail, and the other one requests must be discarded. I already tried some approached using DispatchGroup / NSRecursiveLock / and also with calling the function cancelRequests describing bellow (in this case, the tasks count is always 0). How can I make this behaviour works in this scenario?</p>
<ul>
<li>My NetworkManager class:</li>
</ul>
<pre><code>
    public func fetchData&lt;Type: Decodable&gt;(fromApi api: TargetType,
                                           decodeFromKeyPath keyPath: String? = nil) -&gt; Single&lt;Response&gt; {
        
        let request = MultiTarget(api)

        return provider.rx.request(request)
                .asRetriableAuthenticated(target: request)
    }

    func cancelAllRequests(){
        if #available(iOS 9.0, *) {
            DefaultAlamofireManager
                .sharedManager
                .session
                .getAllTasks { (tasks) in
                tasks.forEach{ $0.cancel() }
            }
        } else {
            DefaultAlamofireManager
                .sharedManager
                .session
                .getTasksWithCompletionHandler { (sessionDataTask, uploadData, downloadData) in
                    
                sessionDataTask.forEach { $0.cancel() }
                uploadData.forEach { $0.cancel() }
                downloadData.forEach { $0.cancel() }
            }
        }
    }

</code></pre>
<ul>
<li>The Single extension that make the retry works:</li>
</ul>
<pre><code>
public extension PrimitiveSequence where TraitType == SingleTrait, ElementType == Response {
    
    private var refreshTokenParameters: TokenParameters {
        TokenParameters(clientId: &quot;pdappclient&quot;,
                grantType: &quot;refresh_token&quot;,
                refreshToken: KeychainManager.shared.refreshToken)
    }

    func retryWithToken(target: MultiTarget) -&gt; Single&lt;E&gt; {
        self.catchError { error -&gt; Single&lt;Response&gt; in
                    if case Moya.MoyaError.statusCode(let response) = error {
                        if self.isTokenExpiredError(error) {
                            return Single.error(error)
                        } else {
                            return self.parseError(response: response)
                        }
                    }
                    return Single.error(error)
                }
                .retryToken(target: target)
                .catchError { error -&gt; Single&lt;Response&gt; in
                    if case Moya.MoyaError.statusCode(let response) = error {
                        return self.parseError(response: response)
                    }
                    return Single.error(InvalidGrantException())
                }
    }

    private func retryToken(target: MultiTarget) -&gt; Single&lt;E&gt; {
        let maxRetries = 1
        return self.retryWhen({ error in
            error
                    .enumerated()
                    .flatMap { (attempt, error) -&gt; Observable&lt;Int&gt; in
                        if attempt &gt;= maxRetries {
                            return Observable.error(error)
                        }
                        if self.isTokenExpiredError(error) {
                            return Observable&lt;Int&gt;.just(attempt + 1)
                        }
                        return Observable.error(error)
                    }
                    .flatMap { _ -&gt; Single&lt;TokenResponse&gt; in
                        self.refreshTokenRequest()
                    }
                    .share()
                    .asObservable()
        })
    }
    
    private func refreshTokenRequest() -&gt; Single&lt;TokenResponse&gt; {
        return NetworkManager.shared.fetchData(fromApi: IdentityServerAPI
            .token(parameters: self.refreshTokenParameters)).do(onSuccess: { tokenResponse in
                    
            KeychainManager.shared.accessToken = tokenResponse.accessToken
            KeychainManager.shared.refreshToken = tokenResponse.refreshToken
        }, onError: { error in
            NetworkManager.shared.cancelAllRequests()
        })
    }

    func parseError&lt;E&gt;(response: Response) -&gt; Single&lt;E&gt; {
        if response.statusCode == 401 {
            // TODO
        }

        let decoder = JSONDecoder()
        if let errors = try? response.map([BaseResponseError].self, atKeyPath: &quot;errors&quot;, using: decoder,
                failsOnEmptyData: true) {
            return Single.error(BaseAPIErrorResponse(errors: errors))
        }

        return Single.error(APIError2.unknown)
    }

    func isTokenExpiredError(_ error: Error) -&gt; Bool {
        if let moyaError = error as? MoyaError {
            switch moyaError {
            case .statusCode(let response):
                if response.statusCode != 401 {
                    return false
                } else if response.data.count == 0 {
                    return true
                }
            default:
                break
            }
        }
        return false
    }

    func filterUnauthorized() -&gt; Single&lt;E&gt; {
        flatMap { (response) -&gt; Single&lt;E&gt; in
            if 200...299 ~= response.statusCode {
                return Single.just(response)
            } else if response.statusCode == 404 {
                return Single.just(response)
            } else {
                return Single.error(MoyaError.statusCode(response))
            }
        }
    }

    func asRetriableAuthenticated(target: MultiTarget) -&gt; Single&lt;Element&gt; {
        filterUnauthorized()
                .retryWithToken(target: target)
                .filterStatusCode()
    }

    func filterStatusCode() -&gt; Single&lt;E&gt; {
        flatMap { (response) -&gt; Single&lt;E&gt; in
            if 200...299 ~= response.statusCode {
                return Single.just(response)
            } else {
                return self.parseError(response: response)
            }
        }
    }
}

</code></pre>
","985979","","","","","2020-09-25 19:42:51","How to synchronously refresh an access token using Alamofire + RxSwift","<swift><alamofire><rx-swift><moya>","2","2","","","","CC BY-SA 4.0"
"64059182","1","64067245","","2020-09-25 06:47:45","","1","78","<p>Modified -----------------------------------------</p>
<p>there is a stream.</p>
<pre><code>let o = Observable.just(1).concatMap(someProcedure).debug()
let o1 = o.map { &quot;\($0 * 2)&quot; }
let o2 = o.map { &quot;\($0)&quot; }
let proc = [o1, o2]
        
Observable.from(proc).concatMap { $0 }
    .subscribe(onNext: { _ in
            
    }).disposed(by: disposeBag)

func someProcedure(_ value: Int) -&gt; Observable&lt;Int&gt; {
    print(&quot;someProcedure!!&quot;)
        
    var result = 100
        
    // do something
       
    return Observable.just(result)
}
</code></pre>
<p>in this case, 'someProcedure!!' is printed twice.</p>
<p>i just want to use return value of func 'someProcedure' in two stream(o1, o2)</p>
<p>func 'someProcedure' is not need to execute twice .</p>
<p>is it possible?</p>
","1095040","","1095040","","2020-09-25 07:48:52","2020-09-25 15:37:51","RxSwift separate stream","<swift><observable><rx-swift>","2","1","","","","CC BY-SA 4.0"
"64060258","1","","","2020-09-25 08:07:55","","2","110","<p>I have a <code>UISwitch</code> that is hooked to to <code>rx</code>. Whenever it's toggled an <code>alertView</code> is displayed. If ok is chosen, some stuff will happen, but if cancel is pressed, nothing will happen, and the <code>UISwitch</code> will remain in the same place, that is it's not toggled.</p>
<pre><code>mySwitch.rx.controlEvent(.valueChanged).subscribe(onNext: { [weak self] _ in
    guard let self = self else { return }

    CustomAlertViewController.standardTwoButtonMessageAlert(title: self.mySwitch.isOn ? &quot;Do you want to turn this on?&quot; : &quot;Do you want to turn this off?&quot;, msg: &quot;hello&quot;, action: {           
        print(&quot;Doing stuff&quot;)
    }, cancelAction: {
        //SHOULD NOT TOGGLE
    })?.present(animated: true, onView: UIApplication.topViewController())
}).disposed(by: disposeBag)
</code></pre>
<p>There is also the problem of the <code>UISwitch</code> already having been toggled when I reach <code>cancelAction</code>, meaning that it needs to be toggled back again. How do I toggle it back? And is there a way to prevent it from toggling at all so I can manage this manually inside the closures?</p>
","8591381","","","","","2020-09-26 21:57:55","How do I stop my UISwitch from toggling using rx swift?","<ios><swift><rx-swift><uialertcontroller><uiswitch>","1","0","1","","","CC BY-SA 4.0"
"64066888","1","","","2020-09-25 15:15:20","","0","19","<p>I'm still new with Swift and Reactive programming and I kinda stucked in passing data between VC and VM</p>
<p>So I have 2 VC with their own VM, where both of them has the access to 1 data model that will be handled in the VMs. I have researched a little about the solution is to define the view model of the target view controller in the current page view model, something like that. But the problem is, the view model has some of the rx view component bind to it, so when I initialize it, it will require the rx view component from the target view controller</p>
<p>Here is my main/current page VC</p>
<pre><code>
import UIKit

class MainPageViewController: UIViewController {
    
    
    var mainPageViewModel : MainPageViewModel!
    private let disposeBag = DisposeBag()
    
 
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.mainPageViewModel = MainPageViewModel(nil)
    }
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        
        let destVC : FilterPageViewController = segue.destination as! FilterPageViewController
        destVC.filterPageViewModel = FilterPageViewModel(minimumPriceQuery: destVC.minimumPriceTF.rx.text.orEmpty.asDriver(), maximumPriceQuery: destVC.maximumPriceTF.rx.text.orEmpty.asDriver(), wholesaleQuery: destVC.switchToggle.rx.isOn.asDriver(), requestModel: self.mainPageViewModel.requestParam())

    }
}
  
</code></pre>
<p>And my main/current page VM</p>
<pre><code>protocol RequestParameterProtocol{
    func requestParam() -&gt; RequestModel
}

class MainPageViewModel {
    private let disposeBag = DisposeBag()
    private var requestModel : RequestModel!
    
    init(_ model : RequestModel?){
        if let params = model {
            self.requestModel = params
        }else{
            self.requestModel = RequestModel()
        }
    }
    
}

extension MainPageViewModel : RequestParameterProtocol{
    func requestParam() -&gt; RequestModel {
        return self.requestModel
    }
    
    
}

</code></pre>
<p>And here is the target view controller</p>
<pre><code>

class FilterPageViewController: UIViewController {
    
    var filterPageViewModel : FilterPageViewModel!
    private let disposeBag = DisposeBag()
    
    @IBOutlet weak var switchToggle: UISwitch!
    @IBOutlet weak var minimumPriceTF: UITextField!
    @IBOutlet weak var maximumPriceTF: UITextField!
    override func viewDidLoad() {
        
        super.viewDidLoad()
        // self.filterPageViewModel = FilterPageViewModel(minimumPriceQuery: self.minimumPriceTF.rx.text.orEmpty.asDriver(), maximumPriceQuery: self.maximumPriceTF.rx.text.orEmpty.asDriver(), wholesaleQuery: self.switchToggle.rx.isOn.asDriver())
   }
    
}

</code></pre>
<p>And here is its view model</p>
<pre><code>class FilterPageViewModel {
    
    private let disposeBag = DisposeBag()
    private var requestModel : RequestModel
    
    
    init(minimumPriceQuery: Driver&lt;String&gt;?, maximumPriceQuery : Driver&lt;String&gt;?, wholesaleQuery : Driver&lt;Bool&gt;?, requestModel : RequestModel
    ) {
        self.requestModel = requestModel
    }
}
</code></pre>
<p>So my issue in here is I cannot define the target view model from my current view controller because it require some rx view component stuff to be defined</p>
","7824071","","","","","2020-09-25 15:15:20","Passing model to ViewModel from different ViewController w/ RxSwift","<ios><swift><xcode><rx-swift><reactive>","0","0","","2020-09-25 15:43:17","","CC BY-SA 4.0"
"64074403","1","","","2020-09-26 06:00:06","","0","20","<p>In <code>viewDidLoad()</code> of my <code>ViewController</code>, I'd like to create a stream of mousedown <code>NSEvents</code> and subscribe to it. I've tried to find suitable methods on <code>self.rx</code> but cannot find anything.</p>
","6354331","","","","","2020-09-26 06:00:06","How to subscribe to mousedown events in RxSwift for MacOS / OSX","<swift><rx-swift><rx-cocoa>","0","0","","","","CC BY-SA 4.0"
"64088444","1","64088524","","2020-09-27 12:25:31","","0","118","<p>I have a strange issue in my testing code. I want to test a <code>BehaviourRelay</code> in my view model changes from status <code>.fetching</code> to <code>.saving</code>. I have the following test code:</p>
<pre><code>class BankViewModelTests: XCTestCase {
    
    private var scheduler: TestScheduler!
    private var bag: DisposeBag!
    private var user: UserModel!
    

    override func setUpWithError() throws {
        try! super.setUpWithError()
        
        let url = Bundle(for: type(of: self)).url(forResource: &quot;User&quot;, withExtension: &quot;json&quot;)!
        let jsonData = try! Data(contentsOf: url)
        let jsonDict = try! JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) as! JSONDictionary
        user = UserModel(jsonDict)!
        
        scheduler = TestScheduler(initialClock: 0)
        bag = DisposeBag()
    }

    override func tearDownWithError() throws {
        user = nil
        scheduler = nil
        bag = nil
        try! super.tearDownWithError()
    }
    
}

extension BankViewModelTests {
    func testSavingStatus() {
        // Arrange
        
        let sut = BankViewModel(user: user)
        
        let status = scheduler.createObserver(BankViewModel.Status.self)
        sut.status.bind(to: status).disposed(by: bag)
        
        // Action
        
        scheduler.createColdObservable([.next(10, ())]).bind(to: sut.tappedSubmit).disposed(by: bag)
        
        scheduler.start()
        
        // Assert
        
        XCTAssertEqual(status.events, [
            .next(0, .fetching),
            .next(10, .saving)
        ])
    }
    
}
</code></pre>
<p>My <code>Status</code> enum is like so:</p>
<pre><code>enum Status: Equatable {
    case fetching, fetchSuccess, saving, saveSuccess, failure(Error)

    public static func == (lhs: Status, rhs: Status) -&gt; Bool {
        switch (lhs, rhs) {
        case (.fetching, .fetching),
             (.fetchSuccess, .fetchSuccess),
             (.saving, .saveSuccess),
             (.failure, .failure):
            return true
        default: return false
        }
    }
}
</code></pre>
<p>When I run the test I get the following message: <code>XCTAssertEqual failed: (&quot;[next(fetching) @ 0, next(saving) @ 10]&quot;) is not equal to (&quot;[next(fetching) @ 0, next(saving) @ 10]&quot;)</code></p>
<p>Cleary these events are equivalent, so why is it failing?</p>
","4083744","","4083744","","2020-09-27 12:40:42","2020-09-27 13:02:02","XCTAssertEqual fails when using createColdObservable for RxTest","<swift><rx-swift><xctest><rxtest>","1","0","","","","CC BY-SA 4.0"
"64102759","1","","","2020-09-28 13:03:12","","0","27","<p>I have set up a <code>relay</code> like this:</p>
<pre><code>class CustomAlertViewController: UIViewController {
    private let disposeBag = DisposeBag()
    var alertTextRelay = BehaviorRelay&lt;String&gt;(value: &quot;&quot;)

    alertTextField.rx.value.orEmpty.changed.subscribe(onNext: { [weak self] value in
         print(&quot;THIS IS RIGHT&quot;, value)
          self?.alertTextRelay.accept(value)
          print(&quot;THIS IS ALSO RIGHT&quot;, self?.alertTextRelay.value)  
        }).disposed(by: disposeBag)
...

</code></pre>
<p>I get the text writen in the <code>textField</code> and accept it to the <code>relay</code> and check so that the value is really there. But the subscription never trigger:</p>
<pre><code>class RecievingClass: UIViewController {
    let disposeBag = DisposeBag()
    let instance = CustomAlertViewController()

    instance.alertTextRelay.subscribe(onNext: { value in
        self.myText = value
            
     }, onError: { error in
         print(error)
     }, onCompleted: {
         print(&quot;completed&quot;)
     }).disposed(by: disposeBag)

...

</code></pre>
<p>Nothing in the <code>subscription</code> is triggered. Why? If it helps, <code>CustomAlertViewController</code> is used as a custom <code>alert</code> (a <code>view</code> on an overlay). Also, there are a lot of <code>static</code> functions in <code>CustomAlertViewController</code>. Not sure if that's relevant. Let me know if I can provide anything else.</p>
","8591381","","","","","2020-09-28 13:29:09","Why doesn't the subscription of the relay work even though there is a value passed to it?","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"64126686","1","64129553","","2020-09-29 19:51:23","","2","113","<p>I would like to do something like</p>
<pre class=""lang-swift prettyprint-override""><code>Completable.empty()
    .andThen { // this does not work
        // run some code
        NSLog(&quot;Now pushing objects&quot;)
        return Completable.empty // e.g. return api.pushObjects() -&gt; Completable
    }
    .andThen(Completable.empty()) // this is working
    .andThen { // this does not work
        // do something else
        NSLog(&quot;Now pulling objects&quot;)
        return Completable.empty // e.g. return api.pullObjects() -&gt; Completable
    }
</code></pre>
<p><code>andThen</code> (or <code>concat</code>) does not allow closures as argument. The compiler complains:</p>
<pre><code>Trailing closure passed to parameter of type 'Completable' (aka 'PrimitiveSequence&lt;CompletableTrait, Never&gt;') that does not accept a closure
</code></pre>
<p>My question is: How to chain completables with closures?</p>
","1771537","","","","","2020-09-30 01:01:10","How to chain completables with closures in RxSwift?","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"64159943","1","64170534","","2020-10-01 16:51:48","","1","163","<p>I'm trying to declare all of my subscriptions in one place and without any intermediate relays or triggers. Here's what I'm trying to achieve.</p>
<p>I have a <code>Signal&lt;X&gt;</code> which will start receiving values only after everything else is loaded and this thing works fine. But now I need to introduce another <code>Observable&lt;Y&gt;</code> which, when I subscribe, will start emitting values immediately because it's fetching data from DB. This is a bit problematic because my UI isn't yet ready to show the results and it'll only be ready when <code>Signal&lt;X&gt;</code> will emit its first value. After this I want to receive every single value <code>Observable&lt;Y&gt;</code> will receive.</p>
<p>I was trying with <code>skipUntil</code> and it's fine, but I'm losing the first element from <code>Observable&lt;Y&gt;</code>. <code>switchLatest</code> won't be a good match either. I was also looking into <code>amb</code>, but this won't give me the correct results either since it subscribes to both sequences and this isn't what I need.</p>
<p>My question is: Is there a possibility to subscribe to other Observable only after the original Observable has received one value? And also keep this subscription alive, so that it'll react to new values.</p>
","1911042","","1911042","","2020-10-01 21:31:28","2020-10-02 11:11:19","Subscribe to Observable only after another Observable has received element","<ios><swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"64178562","1","64179449","","2020-10-02 21:41:03","","1","218","<p>Reset password call occurs 2 times, how can I remove the subscription in that block.</p>
<pre><code>        let digits = [firstDigit, secondDigit, thirdDigit, fourthDigit, fifthDigit, sixthDigit]
        let digitsValid = digits.map { $0?.textField.rx.text.orEmpty.map({ $0.count == 1 }).share(replay: 1) }
        let allDigitsFilled = Observable.combineLatest(digitsValid.map{ $0 ?? BehaviorRelay(value: false).asObservable()}).share(replay: 1)
        allDigitsFilled.subscribe (onNext: { [weak self] (boolArray) in
            guard let self = self else { return }
            let isFilled = boolArray.allSatisfy({ $0 })
            if isFilled {
                self.viewModel.resetPassword()
            } 
        }).disposed(by: disposeBag)
</code></pre>
","13003829","","","","","2020-10-02 23:56:01","Subscription call 2 times, how to unsubscribe observable in RxSwift","<swift><observable><rx-swift><subscription>","1","0","","","","CC BY-SA 4.0"
"64288238","1","","","2020-10-09 22:48:39","","0","62","<p>It's my first time with widgets on iOS 14.
I want to show data that comes from an observer. (RxSwift)</p>
<p>This is my func, I don't know if is the best way to get the data, but I'm trying to get info but never is execute.
Up to line four, the func works, I mean, widget shows &quot;exito&quot; and &quot;787&quot; but the next lines never execute, because the widget never updates, also, the use case is working on app.</p>
<pre><code>func getTimeline(in context: Context, completion: @escaping (Timeline&lt;WidgetContent&gt;) -&gt; ()) {
        
        let currentDate = Date()
        let refreshDate = Calendar.current.date(byAdding: .minute, value: 5, to: currentDate)!
        var entries: [WidgetContent] = [WidgetContent(date: Date(), name: &quot;exito&quot;, cardViewSubtitle: &quot;&quot;, descriptionPlainText: &quot;787&quot;, releasedAtDateTimeString: &quot;&quot;)]
        completion(Timeline(entries: entries, policy: .atEnd))
        
        let contractsDataSource = CoreDataSource.contracts
        let data = ObserveBalanceUseCase(contractsDataSource: contractsLocalDataSource)
        _ = data.execute().subscribe { (balance) in
            let entry = WidgetContent(date: Date(), name: &quot;exito&quot;, cardViewSubtitle: &quot;&quot;, descriptionPlainText: balance?.availableBalance ?? &quot;&quot;, releasedAtDateTimeString: &quot;&quot;)
            entries.append(entry)
            
            let timeline = Timeline(entries: entries, policy: .after(refreshDate))
            completion(timeline)
        } onError: { (error) in
            let entry = WidgetContent(date: Date(), name: &quot;error&quot;, cardViewSubtitle: &quot;&quot;, descriptionPlainText: error.localizedDescription, releasedAtDateTimeString: &quot;&quot;)
            entries.append(entry)
            
            let timeline = Timeline(entries: entries, policy: .atEnd)
            completion(timeline)
        }.disposed(by: disposeBag)
    }
</code></pre>
<p>Why is use case not working?</p>
<p>Thanks</p>
","14232967","","","","","2020-10-09 22:48:39","why is the observer not working on widgets?","<swift><widget><rx-swift>","0","1","","","","CC BY-SA 4.0"
"64316997","1","64327148","","2020-10-12 11:28:18","","1","167","<p>I'm trying to convert my <code>firebase</code> project to work with <code>rx swift</code> but the <code>.do(onNext:{})</code> is discarded while the <code>onCompleted</code> trigger in the <code>subscription</code>.</p>
<p>I made an <code>observable</code> function of the <code>firebase</code> code:</p>
<pre><code>func fetchFireBaseData() -&gt; Observable&lt;[Recipe]&gt; {
    return Observable.create({ [weak self] observer -&gt; Disposable in
        guard let self = self else { return Disposables.create() }
        
        self.databaseRef.child(self.recipeType.description).observeSingleEvent(of: .value, with: { snapshot in
            guard let data = snapshot.children.allObjects as? [DataSnapshot] else { return }
            for item in data {
                guard let thisItem = item.value as? NSDictionary else { return }
                   
                let tempRecipe = Recipe()
                tempRecipe.fbKey = item.key
                tempRecipe.recipeImageObject = (thisItem[&quot;recipeImageFirebase&quot;] as? String) ?? &quot;&quot;
                tempRecipe.recipeHeaderObject = (thisItem[&quot;recipeHeaderFirebase&quot;] as? String) ?? &quot;&quot;
                tempRecipe.recipeTextObject = (thisItem[&quot;recipeIngredientsTextFirebase&quot;] as? String) ?? &quot;&quot;
                   
                    self.recipeArray.append(tempRecipe)

                    }
                    observer.onNext(self.recipeArray)

            })
            observer.onCompleted()
            return Disposables.create()
        })
</code></pre>
<p>and from the part that call the function:</p>
<pre><code>func reloadContent() -&gt; Observable&lt;[Recipe]&gt; {
    guard let fbDataHandler = fbDataHandler else { return Observable.just([]) }
    return fbDataHandler.fetchFireBaseData().do(onNext: { [weak self] value in
            print(&quot;WHY ISNT THIS BEING CALLED?&quot;)
            self?.content.accept(value.compactMap { RecipesCollectionViewCellViewModel(recipes: $0) })   
        })
</code></pre>
<p>The <code>.do(onNext:</code> is ignored, and I don't understand why. The completion work though:</p>
<pre><code>viewModel?.reloadContent().subscribe(onCompleted: {
    print(&quot;THIS IS CALLED&quot;)
}).disposed(by: disposeBag)
</code></pre>
<p>Any idea why it won't work? I read here: <a href=""https://github.com/ReactiveX/RxSwift/issues/1212"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxSwift/issues/1212</a> that</p>
<pre><code>a.do(onNext: {
  print($0) // not called 🤔
}) &lt;-- result is observable sequence that is discarded
</code></pre>
<p>But I'm not really sure what that means or how to fix it.</p>
<p><em><strong>EDIT</strong></em>
Ok, so this possible to fix with a completion handler, BUT the whole idea with rx is to do stuff like this without completion handlers no?</p>
","8591381","","8591381","","2020-10-12 17:41:22","2020-10-13 01:13:24","Rx Swift discards .do(onNext: {}) How do I make it trigger?","<ios><swift><firebase><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"64368058","1","","","2020-10-15 08:55:00","","1","83","<p>I am a RxSwift beginner and making a app with RxSwift + MVVM.</p>
<p>I have a method which calls API and converts to RxCocoa.Driver in ViewModel class like below.</p>
<pre class=""lang-swift prettyprint-override""><code>    func fetch() -&gt; Driver&lt;HomeViewEntity&gt; {
        apiUseCase.fetch(query: HomeViewQuery())
            .map { data in
                HomeViewEntity(userName: data.name,
                               emailAddress: data.email
            }
            .asDriver(onErrorRecover: { [weak self] error in
                if let printableError = error as? PrintableError {
                    self?.errorMessageRelay.accept(AlertPayload(title: printableError.title, message: printableError.message))
                }

                return Driver.never()
            })

    }
</code></pre>
<p>Now, I'd like to call this <code>fetchListPlace()</code> method at regular intervals a.k.a polling (e.g. each 5 minutes) at ViewController.</p>
<p>How to do that????</p>
<p>I think <code>interval</code> is suit in this case, but I can't get an implementation image....</p>
","13371800","","","","","2020-10-15 11:49:22","RxSwift - How to call method which returns Driver at regular intervals?","<swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"64379083","1","68518591","","2020-10-15 20:17:57","","3","326","<p>I've been working with RxSwift for a few years now, and am starting to explore Combine with SwiftUI and am having some trouble trying to replicate some functionality from RxSwift in Combine.</p>
<p>On the RxSwift <a href=""https://github.com/ReactiveX/RxSwift/blob/main/RxExample/RxExample/Services/ActivityIndicator.swift"" rel=""nofollow noreferrer"">GitHub</a> there is an example in a file called <code>ActivityIndicator.swift</code>.</p>
<p>Basic usage is as follows:</p>
<pre><code>class Foo {
  let activityIndicator = ActivityIndicator()

  lazy var activity = activityIndicator.asDriver()

  var disposeBag = DisposeBag()

  func doSomething() {
    Observable
      .just(&quot;this is something&quot;)
      .trackActivity(activityIndicator)
      .subscribe()
      .disposed(by: disposeBag)
  }
}
</code></pre>
<p>What this does is allow you to then drive off of the <code>activity</code> driver and it will emit boolean values every time something subscribes or a subscription completes.</p>
<p>You can then directly drive something like a UIActivityIndicatorView's isAnimating property using RxCocoa.</p>
<p>I've been trying to figure out how to create something similar to this in Combine but am not having any luck.</p>
<p>Say I have a viewModel that looks like this:</p>
<pre class=""lang-swift prettyprint-override""><code>class ViewModel: ObservableObject {
  @Published var isActive = false

  func doSomething() -&gt; AnyPublisher&lt;Void, Never&gt; {
    Just(())
      .delay(for: 2.0, scheduler: RunLoop.main)
      .eraseToAnyPublisher()
  }
}
</code></pre>
<p>What I would like to do is create an operator for a <code>Publisher</code> that will function similarly to how the Rx operator worked where I can forward the events from the subscription through the chain, but change the <code>isActive</code> value every time something subscribes/completes/cancels.</p>
<p>In the SwiftUI View I would initiate the <code>doSomething</code> function and sink to it, while also being able to use the published <code>isActive</code> property to show/hide a <code>ProgressView</code></p>
<p>Something similar to this:</p>
<pre class=""lang-swift prettyprint-override""><code>struct SomeView: View {
  let viewModel = ViewModel()

  var body: some View {
    var cancelBag = Set&lt;AnyCancellable&gt;()

    VStack {
      Text(&quot;This is text&quot;)

      if viewModel.isActive {
        ProgressView()
      }
    }
    .onAppear(perform: {
      viewModel
        .doSomething()
        .sink()
        .store(in: &amp;cancelBag)
    })
  }
}
</code></pre>
<p>Is there something that works like this already that I am just completely missing?</p>
<p>If not, how can I go about replicating the RxSwift functionality in Combine?</p>
<p>Thank you in advance for the help.</p>
","4408483","","","","","2021-07-25 12:45:50","RxSwift `ActivityIndicator` Functionality in Combine","<swift><swiftui><observable><rx-swift><combine>","2","0","1","","","CC BY-SA 4.0"
"64441173","1","","","2020-10-20 08:19:18","","0","189","<p>I have a weird crash that I managed to reproduce in skeleton app.
I have a framework which uses RxSwift az a cocoapod dependency.
It has a simple class defined:</p>
<pre><code>public final class FWSupplier {
    public let psubject = PublishSubject&lt;Int&gt;()
    public let bsubject = BehaviorSubject&lt;Int&gt;(value: 0)
    public init() { }
    public func triggerBehaviour() {
        self.bsubject.onNext(1)
    }

    public func triggerPublish() {
        self.psubject.onNext(1)
    }
}
</code></pre>
<p>I build the framework as an XCFramework and import it into a host app.
In the app I simply instantiate the FWSupplier in a view controller and call triggerPublish and it crashes.</p>
<pre><code>class ViewController: UIViewController {
    @IBOutlet var label: UILabel!
    let supplier = FWSupplier()

    override func viewDidLoad() {
        super.viewDidLoad()
        supplier.triggerPublish()
    }
}
</code></pre>
<p>Anyone have any idea what I'm doing wrong?
<a href=""https://i.stack.imgur.com/pqDb8.png"" rel=""nofollow noreferrer"">Screenshot of error</a>
<a href=""https://i.stack.imgur.com/waI8U.png"" rel=""nofollow noreferrer"">Screenshot of stack</a></p>
","13589878","","13589878","","2020-10-21 04:54:16","2020-10-21 04:54:16","RxSwift crash EXC_BAD_ACCESS, when OnNext called on subject","<ios><swift><rx-swift>","0","4","","","","CC BY-SA 4.0"
"64448040","1","","","2020-10-20 15:08:42","","1","104","<pre><code>let manager = CentralManager(queue: .main)
manager.observeStateWithInitialValue()
    .filter {$0 == .poweredOn}
    .flatMap { _ in manager.scanForPeripherals(withServices: [CBUUID.myDevice.mainService])}
    .filter { $0.peripheral.identifier == someSavedIdentifier}
    .flatMap { $0.peripheral.establishConnection() }
    .flatMap { $0.discoverServices([CBUUID.myDevice.mainService]) }
    .flatMap { Observable.from($0) }
    .flatMap { $0.discoverCharacteristics([CBUUID.myDevice.businessSecret]) }
    .flatMap { Observable.from($0) }
    .flatMap { $0.observeValueUpdateAndSetNotification() }
    .distinctUntilChanged({ (old, new) -&gt; Bool in
        if let oldValue = old.value?.toInt(),
           let newValue = new.value?.toInt() {
            print(&quot;old: \(oldValue), new: \(newValue)&quot;)
        }
        return old.value?.toInt() == new.value?.toInt()
    })
    .takeUntil(viewDidDisappear)
    .subscribe(onNext: { businessSecretValue in
        // business logic...
    })
    .disposed(by: disposeBag)
</code></pre>
<p>the distinctUntilChanged works on an Observable (which is a Bluetooth characteristic). I’m trying to have the sequence only contain the characteristics that have a distinct value. But it seems to somehow skip the comparison when they are not equal.</p>
<p>Output sample:</p>
<pre><code>old: 24, new: 24
old: 24, new: 24
old: 24, new: 24
old: 24, new: 24
old: 29, new: 29
old: 29, new: 29
old: 29, new: 29
</code></pre>
<p>This is causing it to never find distinct elements. Why isn’t there a line that says:</p>
<pre><code>old: 24, new: 29
</code></pre>
","3769647","","3769647","","2020-10-21 05:36:24","2020-10-21 11:25:16","DistinctUntilChanged only compares equal values","<ios><swift><rx-swift><rxbluetooth>","1","12","","2020-10-24 09:15:48","","CC BY-SA 4.0"
"64492282","1","64492836","","2020-10-23 00:25:12","","0","159","<h3>Background</h3>
<p>I'm trying to observe one <code>Int</code> stream (actually I'm not, but to make the argument easier) and do something with it while combining that stream to multiple other streams, say a <code>String</code> stream and a <code>Double</code> stream like the following:</p>
<pre class=""lang-swift prettyprint-override""><code>// RxSwift
let intStream = BehaviorSubject&lt;Int&gt;(value: 0) // subscribe to this later on
let sharedStream = intStream.share()
let mappedStream = sharedStream.map { ... }.share()
let combinedStream1 = Observable.combineLatest(sharedStream, stringStream).map { ... }
let combinedStream2 = Observable.combineLatest(sharedStream, doubleStream).map { ... }
</code></pre>
<p>The above code is just to demonstrate what I'm trying to do. The code above is part of view model code (the VM part of MVVM), and only the first <code>map</code> (for <code>mappedStream</code>) runs, while the others are not called.</p>
<h3>Question</h3>
<p>What is wrong with the above approach, and how do I achieve what I'm trying to do?
Also, is there a better way to achieve the same effect?</p>
<h3>Updates</h3>
<ul>
<li>I confirmed that setting the replay count to <code>1</code> makes things work. But why?</li>
<li>The code above all goes in the initialization phase of the view model, and the subscription happens afterwards.</li>
</ul>
","2828100","","2828100","","2020-10-23 01:39:08","2020-10-23 02:11:31","RxSwift - How to create two streams from one upstream","<rx-swift>","1","6","","","","CC BY-SA 4.0"
"64503000","1","","","2020-10-23 15:30:56","","1","87","<p>I've been trying to compile an already existing iOS project containing a target for an Apple Watch extension.</p>
<p>The project uses RxSwift/RxCocoa which, reading at the official documentation, is compatible with watchOS.</p>
<p>The project compiles and runs successfully on Apple Watch simulator, but it fails on a real Apple Watch, with the following error:</p>
<pre><code>Cannot find 'CGRectType' in scope
Cannot find 'CGPointType' in scope
Cannot find 'CGSizeType' in scope
</code></pre>
<p>The reason of this is that these three constants, declared in a class extension inside RxCocoa, are declared like this:</p>
<pre><code>#if arch(x86_64) || arch(arm64)
    let CGRectType = &quot;{CGRect={CGPoint=dd}{CGSize=dd}}&quot;
    let CGSizeType = &quot;{CGSize=dd}&quot;
    let CGPointType = &quot;{CGPoint=dd}&quot;
#elseif arch(i386) || arch(arm)
    let CGRectType = &quot;{CGRect={CGPoint=ff}{CGSize=ff}}&quot;
    let CGSizeType = &quot;{CGSize=ff}&quot;
    let CGPointType = &quot;{CGPoint=ff}&quot;
#endif
</code></pre>
<p>Do you know if there's any way to make it work, as this library is supposed to be compatible with watchOS?</p>
","4815555","","4815555","","2020-10-23 15:38:46","2020-10-23 15:45:01","Can't compile RxCocoa for Apple Watch","<swift><apple-watch><rx-swift><watchos><rx-cocoa>","1","2","","","","CC BY-SA 4.0"
"64516253","1","64517592","","2020-10-24 17:35:42","","1","42","<p>I'm trying to use the Google MLKitTranslate framework for offline translation in my app. I have written a function for downloading a language model.</p>
<pre><code>public func downloadModel(forLanguage language: TranslateLanguage) -&gt; Observable&lt;Double&gt; {
    let model = TranslateRemoteModel.translateRemoteModel(language: language)

    return Observable&lt;Double&gt;.create { _ -&gt; Disposable in

      // Observe the download progress
      self.progress = ModelManager.modelManager().download(
        model,
        conditions: ModelDownloadConditions(
          allowsCellularAccess: true,
          allowsBackgroundDownloading: true
        )
      )

      return Disposables.create()
    }
  }
</code></pre>
<p><code>progress</code> here has the <code>Progress</code> type.</p>
<p>However I want to create an Observable that sends out a .next event when I have an update in the <code>.fractionComplete</code> and a <code>.completed</code> event when <code>.fractionComplete</code> is 1.0.</p>
<p>I have tried using <code>.rx.observe</code> and <code>.rx.observeWeakly</code> (KVO) on the progress object but it didn't work.</p>
<p>So how can I create an observable from this Progress event? Help is much appreciated.</p>
","10762090","","","","","2020-10-24 20:10:41","Create Observable from Progress object","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"64533957","1","64538126","","2020-10-26 08:52:26","","1","347","<p>Let's say we have this pseudocode representing a network request call and show/hide an activity indicator, using RxSwift:</p>
<pre><code>func performRequest() {
   isLoading.accept(true)
   self.network.executeRequest()
       .subscribe(onNext: {
           self.isLoading.accept(false)
       }, onError: {
           self.isLoading.accept(false)
       })
}
</code></pre>
<p>The function <code>executeRequest</code> returns either an <code>Observable</code> or <code>Single</code>.</p>
<p>I am not feeling comfortable with having to write twice the same code, for onNext/onSuccess and onError, basically doing the same.</p>
<p>I am looking for suggestions to minimize/improve turning off the activity indicator, like for example handling all events of the request in a single statement and avoid using the <code>subscribe</code> function. Or maybe there are other suggestions?</p>
","491280","","491280","","2020-10-26 10:43:25","2020-10-26 13:31:39","RxSwift practice to show/hide ActivityIndicator","<ios><swift><rx-swift>","2","3","","","","CC BY-SA 4.0"
"64561358","1","64571798","","2020-10-27 19:08:34","","1","184","<p>I have three <code>Observable&lt;[Recipe]&gt;</code> streams that I want to combine into one single <code>Observable&lt;[Recipe]&gt;</code>.</p>
<pre><code>let breakfast = Database.database().reference().rx.fetchFireBaseData(recipeType: .breakfast)
    .map { $0.filter { UserDefaults.standard.favoriteRecipes.contains($0.fbKey) }}
        
let dessert = Database.database().reference().rx.fetchFireBaseData(recipeType: .dessert)
    .map { $0.filter { UserDefaults.standard.favoriteRecipes.contains($0.fbKey) }}

let cookies = Database.database().reference().rx.fetchFireBaseData(recipeType: .cookies)
    .map { $0.filter { UserDefaults.standard.favoriteRecipes.contains($0.fbKey) }}

</code></pre>
<p>If I use <code>Observable.zip(breakfast, dessert, cookies).do(onNext: { [weak self] value in...</code>
I get <code>([Recipe], [Recipe], [Recipe])</code></p>
<p>If I use <code>Observable.merge(breakfast, dessert, cookies).do(onNext: { [weak self] value in...</code>
I get the streams in turns, meaning that the last one completed overrides the previous two.</p>
<p>If I use <code>Observable.concat(breakfast, dessert, cookies).do(onNext: { [weak self] value in...</code>
I get sort of the same behavior as with <code>merge</code>.</p>
<p>So how do I combine the three streams into one without having them overwriting one another?</p>
<p>To get a better idea what I'm trying to do:</p>
<pre><code>return Observable.merge(breakfast, cookies, dessert).do(onNext: { [weak self] value in
    self?.content.accept(value.compactMap { FavoritesCollectionViewCellViewModel(favorite: $0)})
})
</code></pre>
<p>I want to <code>accept</code> all combined streams to the <code>behaviorRelay</code>, mapped to <code>cell</code> data. The <code>content</code> relay is then <code>bound</code> to a <code>collectionView</code>. When watching the <code>collectionView</code>, with <code>concat</code> I can see first and second stream briefly, then they are replaced with the last stream.</p>
","8591381","","","","","2020-10-28 11:21:59","How do I zip, merge or concat using rxSwift without overriding previous data?","<ios><swift><observable><concat><rx-swift>","2","0","","","","CC BY-SA 4.0"
"64602796","1","","","2020-10-30 04:36:12","","3","247","<p>Suppose I have some Observable which may have some arbitrarily long sequence of events at the time I subscribe to it but which may also continue to emit events after I subscribe.
I am interested only in those events from the time at which I subscribe and later. How do I just get the latest events?</p>
<p>In this example I use a ReplaySubject as an artificial source to illustrate the question. In practice this would be some arbitrary Observable.</p>
<pre><code>let observable = ReplaySubject&lt;Int&gt;.createUnbounded()

observable.onNext(1)
observable.onNext(2)
observable.onNext(3)
observable.onNext(4)

_ = observable.subscribe(onNext: {
    print($0)
})
observable.onNext(5)
observable.onNext(6)
observable.onNext(7)
</code></pre>
<p>Produces the output:
1
2
3
4
5
6
7</p>
<p>What I really want is only events from the time of subscription onwards. i.e. 4 5 6 7</p>
<p>I can use combineLatest with some other dummy Observable:</p>
<pre><code>let observable = ReplaySubject&lt;Int&gt;.createUnbounded()

observable.onNext(1)
observable.onNext(2)
observable.onNext(3)
observable.onNext(4)

_ = Observable.combineLatest(observable, Observable&lt;Int&gt;.just(42)) { value, _ in value }
    .subscribe(onNext: {
    print($0)
})
observable.onNext(5)
observable.onNext(6)
observable.onNext(7)
</code></pre>
<p>which produces the desired output 4 5 6 7</p>
<p>How can I produce a similar result without artificially introducing another arbitrary Observable?</p>
<p>I have tried a number of things including combineLatest with an array consisting of just one observable, but that emits the complete sequence, not just the latest. I know I could use PublishSubject but I am just using ReplaySubject here as an illustration.</p>
","1852207","","","","","2020-11-01 10:49:18","RxSwift subscribe to latest element in one sequence similar to combineLatest","<rx-swift>","2","2","","","","CC BY-SA 4.0"
"64629464","1","64629547","","2020-11-01 07:08:07","","1","31","<p>In my old project I did a small animation when clicking a <code>cell</code>:</p>
<pre><code>func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
    let cell = collectionView.cellForItem(at: indexPath)
    cell?.transform = CGAffineTransform(scaleX: 1.15, y: 1.15)
    UIView.animate(withDuration: 0.6, delay: 0, usingSpringWithDamping: 1, initialSpringVelocity: 0.5, options: .allowUserInteraction, animations: {
        cell?.transform = CGAffineTransform.identity
    }, completion: nil)
        if self.fbHasLoaded == true {
            performSegue(withIdentifier: &quot;collectionViewToCookieRecipe&quot;, sender: indexPath.row)
        }
    }
</code></pre>
<p>Now I'm trying to refactor my project using <code>rx swift</code>, but I'm not sure how to get ahold of the <code>cell</code> when clicking one in the <code>collectionView</code>. I have managed to get a hold of the <code>model</code> and the <code>cell</code> like this:</p>
<pre><code>Observable.zip(myCollectionView.rx.itemSelected, myCollectionView.rx.modelSelected(RecipesCollectionViewCellViewModel.self))
    .bind { indexPath, model in
        print(model)
}.disposed(by: disposeBag)
</code></pre>
<p>But how do I get ahold of the <code>cell</code> so that I can do my animation stuff?</p>
","8591381","","","","","2020-11-01 07:27:14","How do I get ahold of my cell when clicking in collectionView using rx?","<ios><swift><uicollectionview><uicollectionviewcell><rx-swift>","1","0","","","","CC BY-SA 4.0"
"64637376","1","64639500","","2020-11-01 21:53:00","","1","33","<p>I  having  issues  in  RxSwift Zip uses ,As  i  am  trying  to  achieve response  of  other  2  function  and  send reqest  to  3rd  function .i  have  debuged  in  xcode  and  break  point  not  itself came on  3rd  function using  zip .  i  have  triyed  like  this</p>
<pre><code>func  createOrAlterTable(_ call: CAPPluginCall) -&gt; Observable&lt;[[String:Any]]&gt;{
             

    return     Observable.zip(
                    readTableFromBackend(call), getUserData(call),resultSelector: { value1, value2 in
                        print(&quot;\(value1) \(value2)&quot;)
                        self.readTableFromBackendZipperFun(sqlliteDDLStr: value1, lastFV: value2! as [[String: Any]], call)

                }).subscribeOn(MainScheduler.instance)

                   .subscribe()

                   .disposed(by: disposeBag)
                   
                   
func readTableFromBackend() -&gt; String {

return &quot;response Table Data&quot;
}

func getUserData() -&gt; String {

return &quot;response user Data&quot;
}

func readTableFromBackendZipperFun(sqlliteDDLStr: value1, lastFV: value2! as [[String: Any]], call)) -&gt; [[String:Any]]


return &quot;JSon response&quot;
</code></pre>
","3401272","","","","","2020-11-02 03:38:57","How to pass RxSwift zip with calling function response of other 2 function","<swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"64639173","1","64639444","","2020-11-02 02:42:21","","1","188","<p>I'm seeing some unexpected results when using combineLatest on a collection of cold observables. It emits the latest from all but the last Observable and instead combines the latest from the first (n-1) Observables with each element from the nth Observable.</p>
<pre><code>let observable = ReplaySubject&lt;Int&gt;.createUnbounded()
let observable2 = ReplaySubject&lt;String&gt;.createUnbounded()

observable.onNext(1)
observable.onNext(2)
observable.onNext(3)
observable.onNext(4)

observable2.onNext(&quot;bed&quot;)
observable2.onNext(&quot;book&quot;)
observable2.onNext(&quot;table&quot;)

let latestObserver = Observable.combineLatest(observable, observable2)

_ = latestObserver
    .subscribe(onNext: {
    print($0)
})
.disposed(by: disposeBag)
</code></pre>
<p>Produces the output:
(4, &quot;bed&quot;)
(4, &quot;book&quot;)
(4, &quot;table&quot;)</p>
<p>I had expected to see output of just (4, &quot;table&quot;).</p>
<p>If I change the order of the observables like so:</p>
<pre><code>let latestObserver = Observable.combineLatest(observable2, observable)
</code></pre>
<p>The I get the output:
(&quot;table&quot;, 1)
(&quot;table&quot;, 2)
(&quot;table&quot;, 3)
(&quot;table&quot;, 4)</p>
<p>If I add a final arbitrary Observable then I see just the latest from each of the first ones:</p>
<pre><code>let observable = ReplaySubject&lt;Int&gt;.createUnbounded()
let observable2 = ReplaySubject&lt;String&gt;.createUnbounded()
let observable3 = Observable&lt;Int&gt;.just(42)

observable.onNext(1)
observable.onNext(2)
observable.onNext(3)
observable.onNext(4)

observable2.onNext(&quot;bed&quot;)
observable2.onNext(&quot;book&quot;)
observable2.onNext(&quot;table&quot;)

let latestObserver = Observable.combineLatest(observable, observable2, observable3)

_ = latestObserver
    .subscribe(onNext: {
    print($0)
})
.disposed(by: disposeBag)
</code></pre>
<p>produces the output: (4, &quot;table&quot;, 42)</p>
<p>Is this really the expected behaviour?</p>
","1852207","","","","","2020-11-02 03:44:58","RxSwift combineLatest emits all replayed elements from last Observable","<rx-swift><combinelatest>","1","3","","","","CC BY-SA 4.0"
"64668094","1","64680974","","2020-11-03 18:00:15","","1","246","<p>I have the following scheduler:</p>
<pre><code>let scheduler = ConcurrentDispatchQueueScheduler(queue: .global(qos: .background))
</code></pre>
<p>tried with:  <code>observeOn(scheduler)</code>
also with:   <code>subscribeOn(scheduler)</code></p>
<p>I'm expecting that the callback from the subscribe would be executed on some the background thread, because of the scheduler.</p>
<pre><code>func signIn(withExternalUserID userID: UserID, authenticationToken: String) -&gt; Single&lt;QBUUser&gt; {
        let authenticationToken = &quot;Bearer \(authenticationToken)&quot;
        return .create { observable in
            let request = QBRequest.logIn(
                withUserLogin: &quot;\(userID)&quot;,
                password: authenticationToken,
                successBlock: { _, user in
                    user.password = QBSession.current.sessionDetails?.token
                    observable(.success(user)) // &lt;- Here we are on the main thread
                }, errorBlock: { [unowned self] in
                    observable(.error(ChatError.signInError(self.resolve(errorResponse: $0))))  // &lt;- same here: main thread
                }
            )
            return Disposables.create {
                request.cancel()
            }
        }
    }
</code></pre>
<p>Because the callbacks of the internal API are executed in the main thread, all my subcribes instead of background thread are also executed on the main thread.</p>
<pre><code>tokenRequest
      .flatMap { [unowned self] token -&gt; Single&lt;QBUUser&gt; in
           return self.chatService.signIn(withExternalUserID: currentUser.id, authenticationToken: token)
      }
      .flatMap { [unowned self] user -&gt; Single&lt;QBUUser&gt; in
           return self.chatService.connect(user: user).andThen(Single.just(user))
      }
      .observeOn(self.scheduler)
      .subscribe(onNext: { [unowned self] user in
            self.chatStorage.set(currentQBUser: user, currentUser: currentUser)
            completable(.completed)
            self.loginSempahore.signal()
       }, onError: { [unowned self] error in
            self.chatStorage.unsetCurrentQBUser()
            completable(.error(error))
            self.loginSempahore.signal()
       })
       .disposed(by: self.disposeBag)
</code></pre>
<p>What is the correct way to force all callbacks from flatMap, and subscribe being executed by background thread?</p>
","326036","","","","","2020-11-04 13:25:14","RxSwift subscribeOn and observeOn not on the expected background Thread","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"64726932","1","","","2020-11-07 10:55:59","","0","14","<p>I have code:</p>
<pre><code>themeService.rx
            .bind({ $0.effectColor }, to: visualView.rx.effect)
            .disposed(by: disposeBag)
</code></pre>
<p>I understand I need implement the new reactive for UIVisualEffect. Could you help me implement it?
Thank you!</p>
","4098240","","","","","2020-11-07 10:55:59","Can I extension Reactive where UIVisualEffect?","<rx-swift>","0","1","","","","CC BY-SA 4.0"
"64733638","1","","","2020-11-08 00:03:18","","3","318","<p>I am learning about RxSwift and trying to understand the main difference between Observable and PublishSubject aka Sequence.</p>
<p>As far as I understood, Sequences / PublishesSubject act as Observable and Observer. You can subscribe to these and they emit notifications if the value changes. PublishesSubject can be changed.</p>
<p>My question is, what is the purpose of Observables then? I can only create Observable with a fix value with <code>just()</code> or <code>from()</code>. But I can not change these values or append an item, right? So my Observable will only emit the value I assigned to it in the init. Why do I need Observable then, when the actual value is immutable?</p>
<p>Let´s think of a function which returns an <code>Observable&lt;UIImage&gt;</code>. Instead of returning that Observable and then subscribe on next, I can just return an UIImage. Why do I need a Observable?</p>
<p>If I create following Observable:</p>
<pre><code>let observable = Observable.of(1,2,3)
</code></pre>
<p>I would have a static Marble diagram.. my Observable will emit 1,2 and 3. And afterwards..? It is ended?</p>
<p>I am just not getting the reason why I should use Observable. Any help is appreciated.</p>
","14598060","","","","","2020-11-15 15:16:02","RxSwift purpose of Observable","<swift><rx-swift>","2","1","1","","","CC BY-SA 4.0"
"64768243","1","","","2020-11-10 11:39:26","","0","57","<p>I am trying to create a <code>UICollectionView</code>, so that I can add and delete items from it's data source as a Driver. I have a viewModel below</p>
<pre><code>import Photos
import RxCocoa
import RxSwift

class GroupedAssetsViewModel {
enum ItemAction {
    case add(item: PHAssetGroup)
    case remove(indexPaths: [IndexPath])
}

let assets: Driver&lt;[GroupedAssetSectionModel]&gt;
let actions = PublishSubject&lt;ItemAction&gt;()
private let deletionService: AssetDeletionService = AssetDeletionServiceImpl()

init() {
    assets = actions
        .debug()
        .scan(into: []) { [deletionService] items, action in
            switch action {
            case .add(let item):
                let model = GroupedAssetSectionModel()
                items.append(GroupedAssetSectionModel(original: model, items: item.assets))
            case .remove(let indexPaths):
                var assets = [PHAsset]()
                for indexPath in indexPaths {
                    items[indexPath.section].items.remove(at: indexPath.item)
                    assets.append(items[indexPath.section].items[indexPath.row])
                }
                deletionService.delete(assets: assets)
            }
        }
        .asDriver(onErrorJustReturn: [])
}

func setup(with assetArray: [PHAssetGroup] = [PHAssetGroup]()) {
    for group in assetArray {
        actions.onNext(.add(item: group))
    }
}
</code></pre>
<p>}</p>
<p>but <code>.scan</code> closure is never being called, even though <code>actions.onNext</code> is being called in <code>setup</code>, therefore Driver's value is always empty.</p>
<p>It seems like I am getting some core concepts wrong, what might be the problem here?</p>
","10746797","","","","","2020-11-14 17:10:13","RxSwift onNext not calling scan","<ios><swift><rx-swift><reactivex><rx-cocoa>","1","3","","","","CC BY-SA 4.0"
"64778172","1","64779089","","2020-11-10 23:15:31","","3","255","<p>I need to validate the form with a radio button, but I can't do it, I share my code:</p>
<p>My View:</p>
<p><img src=""https://i.stack.imgur.com/6nbOQ.png"" alt=""&quot;view&quot;"" /></p>
<pre><code>private func registerForm() {
    tvUserName.rx.text.map { $0 ?? &quot;&quot; }.bind(to: viewModel.userNamePublishSubject).disposed(by: disposeBag)
    tvEmail.rx.text.map { $0 ?? &quot;&quot; }.bind(to: viewModel.emailPublishSubject).disposed(by: disposeBag)
    tvPassword.rx.text.map { $0 ?? &quot;&quot; }.bind(to: viewModel.passwordPublishSubject).disposed(by: disposeBag)
    tvRepeatPassword.rx.text.map { $0 ?? &quot;&quot; }.bind(to: viewModel.repeatPasswordPublishSubject).disposed(by: disposeBag)
    viewModel.formLoginNativaIsValid().bind(to: btnNext.rx.isEnabled).disposed(by: disposeBag)
    
    checkBoxOutlet.rx.tap
    .scan(false) { lastValue, _ in
        return !lastValue
    }
    .bind(to: btnNext.rx.isEnabled)
    .disposed(by: disposeBag)
}
</code></pre>
<p>My ViewModel:</p>
<p><img src=""https://i.stack.imgur.com/ReLJs.png"" alt=""&quot;viewmodel&quot;"" /></p>
<pre><code>let userNamePublishSubject = PublishSubject&lt;String&gt;()
let emailPublishSubject = PublishSubject&lt;String&gt;()
let passwordPublishSubject = PublishSubject&lt;String&gt;()
let repeatPasswordPublishSubject = PublishSubject&lt;String&gt;()

func formLoginNativaIsValid() -&gt; Observable&lt;Bool&gt; {
    return Observable.combineLatest(userNamePublishSubject.asObserver(),
        emailPublishSubject.asObserver(),
        passwordPublishSubject.asObserver(),
        repeatPasswordPublishSubject.asObserver()).map { userName, email, password, repeatPassword in
            return self.validateRegister(userName: userName, email: email, password: password,
                                         repeatPassword: repeatPassword)
    }.startWith(false)
}

private func validateRegister(userName: String, email: String, password: String, repeatPassword: String) -&gt; Bool {
    return userName.count &gt;= 5 &amp;&amp; email.isEmail() &amp;&amp; password.count &gt;= 5 &amp;&amp; repeatPassword.count &gt;= 5 &amp;&amp; password == repeatPassword
}
</code></pre>
<p>I have validated the form, but I also need the user to accept the terms and conditions for the &quot;next&quot; button to be enabled.</p>
","14615863","","14351818","","2020-11-11 15:32:12","2020-11-11 15:32:12","validate form with checkbox button RxCocoa/RxSwift","<swift><forms><checkbox><rx-swift><rx-cocoa>","1","2","","","","CC BY-SA 4.0"
"64807623","1","","","2020-11-12 16:16:28","","0","294","<p>I have been facing Ann issue with Websocket to connection, I have tried several methods to get connected, but always showing connection refused or failed connection. The library I have using is <code>Starscream</code> ref:- <a href=""https://github.com/daltoniam/Starscream"" rel=""nofollow noreferrer"">https://github.com/daltoniam/Starscream</a> and also tried with <code>RxStarscream</code> ref:- <a href=""https://github.com/RxSwiftCommunity/RxStarscream"" rel=""nofollow noreferrer"">https://github.com/RxSwiftCommunity/RxStarscream</a>.</p>
<p>In both cases when I tried the following code,</p>
<pre><code>@_exported import RxSwift
@_exported import RxStarscream
import Starscream

  override func viewDidLoad() {
        super.viewDidLoad()
 private let disposeBag = DisposeBag()
 
socket = WebSocket(url: URL(string: &quot;ws://localhost:8080/&quot;)!)
        socket.connect()

 socket.rx.response.subscribe(onNext: { (response: WebSocketEvent) in
            switch response {
            case .connected:
                print(&quot;Connected&quot;)
            case .disconnected(let error):
                print(&quot;Disconnected with optional error : \(error)&quot;)
            case .message(let msg):
                print(&quot;Message : \(msg)&quot;)
            case .data(_):
                print(&quot;Data&quot;)
            case .pong:
                print(&quot;Pong&quot;)
            }
        }).disposed(by: disposeBag)
}
</code></pre>
<p>I am beginner in web socket, what am trying to configure is I need to connect the websocket and socket event need to call, followed by target</p>
<pre><code>Socket Events
URI : ws://{host}:{port}?token={_token}&amp;lang={en}
Ip = {dev,qc}.example-app.info
Port = 8090
Main structure for Events Request and Response
{
event:”Event Name”
data:”Event Data”,
is_player:boolean(true,false)
}
Example: {&quot;event&quot;:&quot;xxxx&quot;,&quot;data&quot;:&quot;xxxx&quot;, &quot;is_player&quot;:true}
</code></pre>
<p>If anyone could give an idea or just suggestion on how to implement on the above web socket method for iOS with swift will be appreciated.</p>
","10686306","","10686306","","2020-11-13 03:14:41","2020-11-15 06:53:07","Web Socket Connection- refused/failed connection in iOS Swift - Starscream/RxStarscream","<ios><swift><websocket><swift4><rx-swift>","1","2","","","","CC BY-SA 4.0"
"64819641","1","64836287","","2020-11-13 10:54:19","","1","587","<p>I tried a few things but couldn't find a solution. I am navigating the controller in the onNext block but the deinit is not calling. I have also declared the self as weak in the rx closures.</p>
<p><strong>Below is the complete class code.</strong>
<strong>Please correct if I am doing anything wrong:</strong></p>
<pre class=""lang-swift prettyprint-override""><code>class LoginVC: UIViewController {

    //MARK:- Variables &amp; Consts
    private let tag = &quot;LoginVC&quot;
    private let loginViewModel = LoginViewModel()
    private let disposeBag = DisposeBag()
    
    //MARK:- IBOutlets
    @IBOutlet weak var tfUsername: MFTextField!
    @IBOutlet weak var tfPassword: MFTextField!
    @IBOutlet weak var btnLogin: UIButton!
    
    //MARK:- View Controller Life Cycle
    override func viewDidLoad() {
        super.viewDidLoad()
        
        setupBindings()
    }
    
    ///deinit
    deinit {
        print(&quot; deinit&quot;)
    }
    
    //MARK:- Custom Methods
    
    private func setupBindings() {
        loginViewModel
            .loginResponse
            .observeOn(MainScheduler.instance)
            .subscribe(onNext: { [weak self] loginResponse in
             let vc = UIStoryboard(name: Constants.MAIN, bundle: nil).instantiateViewController(withIdentifier: Constants.HOME_VC)
                self?.navigationController?.pushViewController(vc, animated: true)
            }, onError: { [weak self] error in
                self?.removeLoader()
            }, onCompleted: {  [weak self]  in
                self?.removeLoader()
            }, onDisposed: { [weak self] in
                print(&quot;\(self?.tag ?? &quot;&quot;) onDisposed&quot;)
            })
        .disposed(by: disposeBag)
        
        btnLogin.rx.tap.bind{ [weak self] in
            self?.loginViewModel.login(username: self?.tfUsername.text ?? &quot;&quot;, password: self?.tfPassword.text ?? &quot;&quot;)
        }.disposed(by: disposeBag)
    }
}
</code></pre>
<p>Any help would be appreciated.</p>
","6184454","","6184454","","2020-11-14 08:18:14","2020-11-14 16:56:26","why deinit of view controller is not calling using RXSwift?","<ios><swift><reactive-programming><rx-swift><rx-cocoa>","2","6","","","","CC BY-SA 4.0"
"64857998","1","64860471","","2020-11-16 12:25:21","","1","131","<h2>Observable Codes</h2>
<pre class=""lang-swift prettyprint-override""><code>private let reviewPublish = PublishSubject&lt;Review&gt;()

var review$: Observable&lt;Review&gt; {
    return reviewPublish.asObservable()
}
</code></pre>
<h2>Publishing Code</h2>
<pre class=""lang-swift prettyprint-override""><code>DB_REVIEWS.observe(.value){ snapShot in
    for child in snapShot.children {
        guard let snap = child as? DataSnapshot else { return }
        guard let data = snap.value as? [String: Any] else { return }
                
        var review = Review()
        review = self.changeDictionaryToReview(data, snap.key)
        self.reviewPublish.onNext(review)
   }
   self.reviewPublish.onCompleted()
} 
</code></pre>
<h2>Subscribe Code</h2>
<pre class=""lang-swift prettyprint-override""><code>DBUtil.shared.review$.subscribe(onNext: {
    self.reviews.append($0)
}).disposed(by: self.disposeBag)
</code></pre>
<h2>Question</h2>
<p>I subscribed when the app was launched. So, getting reviews from the database and storing them in an array succeeded. However, <strong>it cannot be reflected in real time.</strong> After the app is launched, if the user adds a new review, it is not reflected. <strong>&quot;self.reviewPublish.onNext(review)&quot; works, but subscribe code in viewController not work.</strong></p>
<p>any idea?</p>
","13151131","","209103","","2020-11-16 15:48:44","2020-11-16 15:48:44","RxSwift) Subscribing one observable two time not working","<ios><swift><firebase><firebase-realtime-database><rx-swift>","1","2","","","","CC BY-SA 4.0"
"64864422","1","","","2020-11-16 19:23:56","","1","177","<p>I want to listen for the <code>isHidden</code> property of the <code>UIView</code> and based on the changes in the value, I am notifying the respective delegates.</p>
<p>I trying to convert the following Rx code to Combine and I am not sure how.</p>
<p>Sample Rx Code:</p>
<pre><code>customView.rx
   .observe(Bool.self, &quot;hidden&quot;)
   .subscribe(onNext: { [weak self] value in
      guard let self = self else { return }
      self.view.isHidden = value ?? true
      self.delegate?didUpdate(isHidden: value ?? true)
   })
   .disposed(by: disposeBag)
</code></pre>
<p>Kindly share a few ideas or suggestions.</p>
<p>Note: I am pretty new to <strong>RxSwift</strong> and <strong>Combine</strong> Framework.</p>
","849486","","","","","2020-11-16 20:35:46","RxSwift to Combine: Listening for UIView property update","<ios><swift><rx-swift><combine>","1","1","","","","CC BY-SA 4.0"
"64893143","1","64943685","","2020-11-18 12:28:40","","1","74","<p>I have used RxSwift to call other function in the return of the first function. For that I have tried this code:</p>
<pre><code>func startSyncNow(_ call: CAPPluginCall,lastSyncTime: String) -&gt; Observable&lt;String&gt; {
         return   createOrAlterTable(call)

            .flatMapLatest(){ query -&gt; Observable&lt;String&gt; in
                let formschema = self.formSchemaToSQLite(call, lastSyncTime: lastSyncTime)
               return formschema
        }.flatMapLatest(){ query -&gt; Observable&lt;String&gt; in
            let menuTable = self.menuTableRecord(call, lastSyncTime: lastSyncTime)
               return menuTable
        }
        .map { query -&gt; String in
            return &quot;Success&quot;
       }
    }
    
    func  createOrAlterTable(_ call: CAPPluginCall) -&gt; Observable&lt;[[String:Any]]&gt;{
    
     return Observable.just(&quot;Sucess&quot;)
    }
    
    func formSchemaToSQLite(_ call: CAPPluginCall,lastSyncTime : String) -&gt; Observable&lt;String&gt; {
        return Observable.just(&quot;Sucess&quot;)
    }
    
    
    func menuTableRecord(_ call: CAPPluginCall,lastSyncTime:String) -&gt; Observable&lt;String&gt;{
        return Observable.just(&quot;Sucess&quot;)
    }
</code></pre>
<p>When I am debugging this code, I am not able to hit debug point on either formSchemaToSQLite or recordsTOSqlite. Please guide me what I am missing</p>
","3401272","","13302","","2020-11-21 09:16:50","2020-11-21 13:38:29","Rxswift how to call 1 or more functions in return of the other function","<swift><rx-swift>","1","5","","","","CC BY-SA 4.0"
"64930263","1","64931052","","2020-11-20 13:24:24","","1","118","<p>I am Chinna. I am new to rxswift. I have a task like I have a few functions which are acts like observables. Currently these all observables executing sequentially. due to this my application performance is going down. I want to execute all these functions parallelly. These functions are not depending on each other. I have tried with zip function but these are running sequentially.</p>
<pre><code>    return Observable.create({ (observer) -&gt; Disposable in
_ = Observable.zip(
self.createOrAlterTable(call).subscribeOn(ConcurrentMainScheduler.instance),
self.formSchemaToSQLite(call,lastSyncTime: lastSyncTime).subscribeOn(ConcurrentMainScheduler.instance),
self.menuTableRecord(call, lastSyncTime: lastSyncTime).subscribeOn(ConcurrentMainScheduler.instance),
self.recordsTOSqlite(call,lastSyncTime: lastSyncTime).subscribeOn(ConcurrentMainScheduler.instance),
self.imagerecordsTOSqlite(call,lastSyncTime: lastSyncTime).subscribeOn(ConcurrentMainScheduler.instance),
self.syncGraphDBNode(call).subscribeOn(ConcurrentMainScheduler.instance),
self.syncSchemasToSQLServer(call).subscribeOn(ConcurrentMainScheduler.instance),
self.syncRecordsToSQLServer(call).subscribeOn(ConcurrentMainScheduler.instance)
).observeOn(MainScheduler.asyncInstance)
.subscribe(onNext: {
xdata,ydata,adata,bdata,cdata,ddata,edata,fdata in
print(&quot;All Operations Done&quot;);
})
return Disposables.create()
</code></pre>
<p>all above functions will looks like below</p>
<pre><code>func syncSchemasToSQLServer(_ call: CAPPluginCall) -&gt; Observable&lt;String&gt;{
    return Observable.just(&quot;SYNC_SCHEMAS_TO_SQLSERVER&quot;)
}
</code></pre>
<p>but still these functions executing sequntially. please help me to solve this issue.</p>
<p><strong>Updated</strong></p>
<pre><code>    func example() -&gt; Observable&lt;String&gt;{
      var res=  Observable.zip(
            doJob(1).subscribeOn(ConcurrentDispatchQueueScheduler(qos: .default)),
            doJob(2).subscribeOn(ConcurrentDispatchQueueScheduler(qos: .default)),
            doJob(3).subscribeOn(ConcurrentDispatchQueueScheduler(qos: .default))
        )
        .debug(&quot;done&quot;)
        .subscribe()

   return Observable.just(&quot;Success&quot;);
    }
    
    func doJob(_ value: Int) -&gt; Observable&lt;Void&gt; {
        return Observable.create { observer in
            print(&quot;starting job&quot;, value)
            sleep(3)
            print(&quot;done with job&quot;, value)
            observer.onNext(())
            observer.onCompleted()
            return Disposables.create()
        }
    }
</code></pre>
","6391523","","6391523","","2020-11-26 04:21:13","2020-11-26 12:38:32","RxSwift: How to Run Multiple Observables parallelly","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"64950463","1","64955235","","2020-11-22 03:44:20","","1","57","<p>I am working with the <code>retry</code> operator in RxSwift. According to its documentation, it &quot;resubscribes&quot; to the source observable when it encounters an error.</p>
<p>This is all well and good. However, I'm not exactly sure how to reason about the &quot;source observable&quot; when it contains hot observables, or a mixture of hot/cold observables.</p>
<p>An example I am sure about:</p>
<pre><code>let coldObservable = Observable&lt;Int&gt;.interval(.seconds(1), scheduler: MainScheduler.instance)
let coldObservableRetry = coldObservable.flatMapLatest { num in 
      if num % 3 == 0 { return .just(num) } 
      else { return .error() }
    }
    .retry(2) // retry is inclusive of original attempt
coldObservableRetry.subscribe(onNext: { print ($0)} ) // prints 1, 2, 1, 2, before erroring out.
</code></pre>
<p>An example I am not sure about:</p>
<pre><code>let hotObservable = Observable&lt;Int&gt;.interval(.seconds(1), scheduler: MainScheduler.instance).publish().connect()
let hotObservableRetry = hotObservable.flatMapLatest { num in 
      if num % 3 == 0 { return .just(num) } 
      else { return .error() }
    }
    .retry(2)
hotObservableRetry.subscribe(onNext: { print ($0)} ) // What happens here?
</code></pre>
<p>Another example I am not sure about:</p>
<pre><code>let coldObservable = Observable&lt;Int&gt;.interval(.seconds(1), scheduler: MainScheduler.instance)
let delayedHotObservable = Observable&lt;Int&gt;.interval(.seconds(1), scheduler: MainScheduler.instance).delay(.milliseconds(100), scheduler: MainScheduler.instance).publish().connect()
let mixtureObservableRetry = Observable.combineLatest(coldObservable, delayedHotObservable).map { $0 + $1 }.flatMapLatest { num in 
      if num % 3 == 0 { return .just(num) } 
      else { return .error() }
    }
    .retry(5)
mixtureObservableRetry.subscribe(onNext: { print ($0)} ) // What happens here? What does it even mean to resubscribe to a combineLatest with a hot and a cold observable?
</code></pre>
<p>Yet another example I am not sure about:</p>
<pre><code>let coldObservable = Observable&lt;Int&gt;.interval(.seconds(1), scheduler: MainScheduler.instance)
let hotObservable = Observable&lt;Int&gt;.interval(.seconds(1), scheduler: MainScheduler.instance).publish().connect()
let mixtureObservable2Retry = coldObservable.flatMapLatest { _ in hotObservable }
.flatMapLatest { num in 
      if num % 3 == 0 { return .just(num) } 
      else { return .error() }
    }
    .retry(2)
mixtureObservable2Retry.subscribe(onNext: { print ($0)} ) // What happens here?
</code></pre>
","7612797","","7612797","","2020-11-22 22:20:46","2020-11-23 13:04:13","How do RxSwift operators affect resubscribes?","<ios><swift5><rx-swift>","1","0","","","","CC BY-SA 4.0"
"64957228","1","64957540","","2020-11-22 17:23:04","","0","1614","<p>I have following RxSwift view model code:</p>
<pre><code>private(set) var num = BehaviorRelay&lt;Int&gt;(value: 1)
private let indexTrigger = PublishRelay&lt;Int&gt;()
private let disposeBag = DisposeBag()

private func setupBindings() {
   //...
   self.num.distinctUntilChanged().bind(to: self.indexTrigger).disposed(by: self.disposeBag)
}

func numSelected(num: Int) {
   self.num.accept(num)
}

</code></pre>
<p>This code is working fine and does what I want. I'm trying to do same, but with swift Combine framework with following code:</p>
<pre><code>@Published private(set) var num: Int = 1
private let indexTrigger = PassthroughSubject&lt;Int, Never&gt;()
private var subscriptions = Set&lt;AnyCancellable&gt;()

private func setupBindings() {
   //...
   self.$num.removeDuplicates().sink(receiveValue: { [weak self] num in
      self.indexTrigger.send(num)
   }).store(in: &amp;self.subscriptions)
}

func numSelected(num: Int) {
   self.num = num
}
</code></pre>
<p>So RxSwift binding looks much clean and simple and without need of weak. I tried to check <code>assign(on:)</code> method in combine, but seems it is not the one. Is there way to do same thing?</p>
","1246675","","","","","2020-11-22 17:52:17","Combine assign publisher to PassthroughSubject","<ios><swift><rx-swift><combine>","1","5","","","","CC BY-SA 4.0"
"64963988","1","64968800","","2020-11-23 07:17:24","","1","73","<p><strong>Top Level Question:</strong>
I want to know how, within a retry, I can modify its source observable if it is an observable shared between multiple subscribers (in this case a BehaviorSubject/Relay).</p>
<p><strong>Solution(s) I have considered:</strong>
The suggestion of using <code>defer</code> from <a href=""https://stackoverflow.com/questions/40210655/modify-source-observable-on-retry-rxjava"">this post</a> doesn't seem to naturally port over if the source observable needs to be shared.</p>
<p><strong>Use case (to fully elaborate the question)</strong><br />
Say I have a server connection object that, when initialized, connects to an url. Once it is created, I can also use it to get a data stream for a particular input.</p>
<pre><code>class ServerConnection {
    var url: URL
    init(url: URL)
    func getDataStream(input: String) -&gt; Observable&lt;Data&gt; // the observable also errors when the instance is destroyed.
}
</code></pre>
<p>However, one particular url or another may be broken or overloaded. So I may want to obtain the address of a mirror and generate a new ServerConnection object. Let's say I have such a function.</p>
<pre><code>// At any point in time, gets the mirror of the url with the lowest load
func getLowestLoadMirror(url: URL) -&gt; URL {}
</code></pre>
<p>Ideally, I want this &quot;mirror url&quot; switching should be an implementation detail. The user of my code may only care about the data they receive. So we would want to encapsulate this logic in a new class:</p>
<pre><code>class ServerConnectionWithMirrors {
    private var currentConnection: BehaviorRelay&lt;ServerConnection&gt;
    init(startingURL: URL)
    func dataStream(for inputParams: String) -&gt; Observable&lt;Data&gt;
}

// usage
let connection = ServerConnectionWithMirrors(startingURL: &quot;www.example.com&quot;)
connection.dataStream(for: &quot;channel1&quot;)
    .subscribe { channel1Data in
        // do something with channel1Data
    }.disposed(by: disposeBag)

connection.dataStream(for: &quot;channel2&quot;)
    .subscribe { channel2Data in
        // do something with channel2Data
    }.disposed(by: disposeBag)
</code></pre>
<p>How should I write the <code>dataStream()</code> function for <code>ServerConnectionWithMirrors</code>? I should be using retries,  but I need to ensure that the retries, when faced with a particular error (<code>ServerOverLoadedError</code>) update the value on the behaviorRelay.</p>
<p>Here is code that I have so far that demonstrates the crux at what I am trying to do. One problem is that multiple subscribers to the behaviorRelay may all update it in rapid succession when they get an error, where only one update would do.</p>
<pre><code>func dataStream(for inputParams: String) -&gt; Observable&lt;Data&gt; {
    self.currentConnection.asObservable()
        .flatMapLatest { server in
            return server.getDataStream(input: inputParams)
        }
        .retryWhen { errors in
            errors.flatMapLatest { error in
                if error is ServerOverLoadedError {
                    self.currentConnection.accept(ServerConnection(url: getLowestLoadURL()))
                } else {
                    return Observable.error(error)
                }
            }
        }
}
</code></pre>
","7612797","","","","","2020-11-23 12:52:29","Rx: How to modify a shared source observable within a retry","<ios><rx-java><rx-swift>","1","0","","","","CC BY-SA 4.0"
"64969184","1","64979185","","2020-11-23 13:16:16","","1","86","<p>I have a model Users and in that model</p>
<pre><code>    static func getUsers() -&gt; Single&lt;[Users]&gt; {
    let path = API.Path.users.details
    let params: [String: Any] = [
        &quot;utcOffset&quot;: TimeZone.current.utcOffset
    ]

    return API.requestMany(path: path, method: .get, parameters: params)
    }
</code></pre>
<p>i declare it like this</p>
<pre><code>    let sus = [Users]()
</code></pre>
<p>And in my cellForRowAt i have this</p>
<pre><code>        Users
        .getUsers()
        .do(onError: { [weak self] error in
            print(error.localizedDescription)
        })
        .do(onSuccess: { [weak self] userNames in
            print(userNames)
            cell.name.text = userNames[indexPath.row].name
        })
        .subscribe()
        .disposed(by: rx.disposeBag)
</code></pre>
<p>That code is not being called so my tableview is empty but when i tried putting it in <strong>ViewDidLoad</strong> its being called and triggering my print statement <strong>print(userNames)</strong></p>
","11207211","","","","","2020-11-24 13:38:54","How to put JSON response to a tableview","<arrays><json><swift><uitableview><rx-swift>","1","6","","","","CC BY-SA 4.0"
"65011921","1","65013932","","2020-11-25 20:02:10","","1","28","<p>I am studying RxCocoa for UITableView now. Everything works fine with presenting cells but when I add a closure to handle row selection a delay appears. I mean when I tap first row nothing happens, when I tap second row closure shows the reaction I expected for the first row, the third - for the second, etc...
Please have a look at my code and help me fix the problem.</p>
<pre><code>import RxCocoa
import RxRelay
import RxSwift
import UIKit

final class ListViewController: UITableViewController {
    
    private var todos = BehaviorRelay&lt;[String]&gt;(value: [&quot;Clean the apt&quot;, &quot;Learn to code&quot;, &quot;Call mom&quot;, &quot;Do the workout&quot;, &quot;Call customers&quot;])
    let bag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()
        title = &quot;RxTodoList&quot;
        tableView.dataSource = nil
        tableView.delegate = nil
        
        todos
            .bind(to: tableView.rx.items) { (tableView, row, element) in
                let cell = tableView.dequeueReusableCell(withIdentifier: &quot;TodoCell&quot;)!
                cell.textLabel?.text = &quot;\(element)&quot;
                return cell
            }
            .disposed(by: bag)
        
        tableView.rx
            .modelDeselected(String.self)
            .asObservable()
            .subscribe(onNext: { [weak self] todo in
                print(todo)
            })
            .disposed(by: bag)
    }
    
}
</code></pre>
","12504820","","1180728","","2020-11-26 08:15:32","2020-11-26 08:15:32","Problem with handling row selection with RxCocoa","<swift><uitableview><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"65047776","1","","","2020-11-28 08:29:33","","1","465","<p>I have the following setup for a table view with RXSwift:</p>
<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    // Constraints setup etc
    
    items
        .subscribeOn(MainScheduler.instance)
        .bind(to: tableView.rx.items(cellType: SomeCell.self)) { [weak self] row, item, cell in
            // Code
        }
        .disposed(by: bag)

    // Observe the contentSize of tableView to update PanModal's height.
    tableView.rx.observe(CGRect.self, &quot;contentSize&quot;)
        .subscribeOn(MainScheduler.instance)
        .subscribe(onNext: { [weak self] _ in
            // Code
        })
        .disposed(by: bag)
}
</code></pre>
<p>It seems that because I am subscribed to <code>contentSize</code> with <code>RXSwift</code> I now get the following error:</p>
<blockquote>
<p>⚠️ Reentrancy anomaly was detected.
Debugging: To debug this issue you can set a breakpoint in /Users/kekearif/Documents/Snapask/ios-app/Pods/RxSwift/RxSwift/Rx.swift:96 and observe the call stack.
Problem: This behavior is breaking the observable sequence grammar. <code>next (error | completed)?</code>
This behavior breaks the grammar because there is overlapping between sequence events.
Observable sequence is trying to send an event before sending of previous event has finished.
Interpretation: This could mean that there is some kind of unexpected cyclic dependency in your code,
or that the system is not behaving in the expected way.
Remedy: If this is the expected behavior this message can be suppressed by adding <code>.observeOn(MainScheduler.asyncInstance)</code>
or by enqueuing sequence events in some other way.</p>
</blockquote>
<p>Has anyone seen this before? Any ideas what might be causing this error? I tried adding <code>.observeOn(MainScheduler.asyncInstance)</code> as it suggests and the UI just locks up when I present the view controller.</p>
<p>Any suggestions on how to fix this would be much appreciated!</p>
","4083744","","","","","2020-11-28 14:31:18","Reentrancy anomaly was detected when observing contentSize with RXSwift","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"65051791","1","","","2020-11-28 16:19:51","","0","30","<p>I have an app that have 3 views and a service logic layer. The services is sending messagings all the time to all this views.What I do to control all this data was use RxBehaviorRelay.</p>
<p>To this point all works great, I match the variables with the services layer and I am receiving data in the ViewController 1, 2 and 3.</p>
<p>The problem comes when I am on the view2 and then go to view3 and return to view2. On this return I lost all the changes and the BehaviorRelay object is like the beginning.</p>
<p><a href=""https://i.stack.imgur.com/kj93v.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kj93v.png"" alt=""App diagram"" /></a></p>
<p>My code in the view1 is like this one</p>
<pre><code>class View1: UIViewController {
    var service: ServiceModel? = ServiceModel()
    
    var observableView1 = BehaviorRelay(value: [Object]())
    var observableView2 = BehaviorRelay(value: [Object]())
    
    override func viewDidLoad() {
        service!.observableView1 = self.observableView1
        service!.observableView2 = self.observableView2
    }
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        let destination = segue.destination as! View2
        destination.observableView2 = self.observableView2
    }
}
</code></pre>
<p>Code of view2</p>
<pre><code>class View2: UIViewController {
    let disposeBag = DisposeBag()
    
    var observableView2 = BehaviorRelay(value: [Object]())
    
    override func viewDidLoad() {
        fillTable()
    }
    
    func fillTable() {
        observableView2.asObservable().bind(to: tvData.rx.items) { (tableview, row, data) in
            //code to fill the table
        }.disposed(by: disposeBag)
    }
}
</code></pre>
<p>On the service layer I only receive the changes and put in the BehaviorRelay object.</p>
<pre><code>observableView2.accept(changes)
observableView1.accept(changes)
</code></pre>
<p>As I said I obtain all the changes in the view2 but when I move to view3 and return to view2, the changes gone.</p>
<p>Sorry for my english.
Thanks</p>
","3516361","","","","","2020-11-28 20:35:57","Rx BehaviorRelay doesnt keep the data when return from a view","<swift><rx-swift><behaviorrelay>","1","0","","","","CC BY-SA 4.0"
"65077474","1","65250061","","2020-11-30 16:34:18","","1","35","<p>I need a library in Swift or an Rx solution.</p>
<p>I want to spread a listenable value in AppDelegate. From the screens that will occur after this value is spread, for example, when XController is created, I will subscribe to this value and I can get the newest values continuously. However, since the XController will be created after the first and only data is published in AppDelegate, I want to be able to get the last value when the data in AppDelegate is subscribed and do some operations if not nil. The detail is actually here.</p>
<p>Does anyone have a library or rx solution or any suggestions like this</p>
","14520297","","","","","2020-12-11 10:59:56","Subscribe and last value accessible notification structure when subscribed - Swift","<ios><swift><xcode><rx-swift>","1","3","","","","CC BY-SA 4.0"
"65078033","1","65081562","","2020-11-30 17:09:50","","1","61","<pre class=""lang-swift prettyprint-override""><code>protocol TodoUseCase {
    func add(title: String, description: String) -&gt; Completable
}


final class CreateTodoPresenterImpl: CreateTodoPresenter {
   var todoUseCase: TodoUseCase!
   var bag = DisposeBag()

   func setBind() {
        requestCreateTodoRelay
            .flatMap { [weak self] _ -&gt; Completable in
                guard let weakSelf = self else { return Completable.empty() }
                return weakSelf.todoUseCase.add(title: weakSelf.titleInputtedText.value, description: weakSelf.descriptionInputtedText.value)
                .debug() // debug#1
            }
            .debug() // debug#2
            .subscribe(onError: { [weak self] error in
                self?._showAPIErrorPopupRelay.accept(error)
            }, onCompleted: { [weak self] in
                self?.toLoginView() 
            })
            .disposed(by: bag)
   }
}

</code></pre>
<p>Why this function todoUseCase.add() -&gt; Completable, but does return nothing.</p>
<p>I want that when this todoUseCase.add called, call subscribe's onCompleted closure.</p>
<p>I tried to investigate this</p>
<ul>
<li><p>debug#1
return onCompleted</p>
</li>
<li><p>debug#2
return nothing</p>
</li>
</ul>
<p>I have a question, calling the returning Completable method inside of the flatMap method is wrong?</p>
","3688956","","","","","2020-11-30 21:48:11","Why calling Completable method inside of flatMap does not working?","<swift><rx-swift><rx-cocoa>","1","0","1","","","CC BY-SA 4.0"
"65109846","1","65118983","","2020-12-02 14:16:10","","3","227","<p>I am trying to perform a complex computation in the background upon table row selection but it freezes the UI. Please have a look at my code and tell me what might be wrong.</p>
<pre><code>tableView.rx
    .modelSelected(Sring.self)
    .flatMap { item -&gt; Observable&lt;String&gt; in
        
        for _ in 1...2_500 {
            for _ in 1...1_000 {
                
            }
        }
        return Observable.just(&quot;Hello world!&quot;)

    }
    .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .background))
    .observeOn(MainScheduler.instance)
    .retry()
    .subscribe(onNext: { value in
        print(value)
    })
    .disposed(by: bag)
</code></pre>
","12504820","","12504820","","2020-12-02 15:26:10","2020-12-03 02:24:36","How to perform RxSwift in the background?","<multithreading><concurrency><grand-central-dispatch><rx-swift>","1","0","","","","CC BY-SA 4.0"
"65118823","1","65125937","","2020-12-03 02:02:07","","1","431","<p>I'm writing a code that shows the values I've received from the server in the table view. However, the following error occurs: Instance method 'items(cellIdentifier:cellType:)' requires that 'Model' conform to 'Sequence'
This is my code. I don't know why errors occur.</p>
<pre><code>        rank.bind(to: tableView.rx.items(cellIdentifier: &quot;rankingCell&quot;, cellType: RankingCell.self)) { rkc, model, cell in
            cell.nickNameLbl.text = model.nickName
            cell.profileImage.image = model.profileImage
            cell.Ranking.text = model.profileImage
        }.disposed(by: disposeBag)
</code></pre>
<p>This is my viewController
An error occurs in the rx part.</p>
<pre><code>
struct RankingModel: Codable {
    var ranking: Int = -1
    var nickName: String = &quot;&quot;
    var profileImage: String = &quot;&quot;
    
    enum RankingModelKeys: String, CodingKey {
        case ranking
        case nickName
        case profileImage
    }
}

</code></pre>
<p>And this is my model</p>
","14063311","","","","","2020-12-03 12:25:36","Instance method 'items(cellIdentifier:cellType:)' requires that 'Model' conform to 'Sequence'","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"65125015","1","","","2020-12-03 11:20:45","","0","23","<p>I want to implement a tree structure by using RxCocoa &amp; RxSwift in a <code>UITableView</code> something like</p>
<pre><code> Item1
     child1
          child1.1
          child1.2             
     child2
 Item2
 Item3
     child1
     child2
          child2.1
          child2.2
          child2.3
</code></pre>
<p>I tried with <em><strong>RxDataSource</strong></em>.
<strong>RxTableViewSectionedAnimatedDataSource</strong> worked when the depth is 1.</p>
<p>Is there anyway to make it infinitely recursive?</p>
","10920285","","","","","2020-12-03 11:20:45","Rx-based tree structure with UITableView in Swift","<ios><objective-c><swift><rx-swift><rx-cocoa>","0","2","","","","CC BY-SA 4.0"
"65128898","1","65143855","","2020-12-03 15:24:36","","1","61","<p>I have a simple non-reactive function that I'd like to run on a <code>SerialDispatchQueueScheduler</code>. The method doesn't return anything neither I require it to emit any events but it has to be run on a scheduler</p>
<pre><code>func deleteDataOf(_ personId: Int, on scheduler: SerialDispatchQueueScheduler) {
    //Run the method body on scheduler
    try? removeItem(at: getDirectoryURL(personId: personId))
}
</code></pre>
","3490203","","","","","2020-12-05 17:55:07","RxSwift call a simple function on a Scheduler","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"65158144","1","","","2020-12-05 14:43:39","","2","73","<p>I want to change the API request code written using the closure to RxSwift. <br>
For example, I would like to make rxGetList() function using getList() function.</p>
<pre><code>// This function cannot be modified.
func getList(success: @escaping ([String]) -&gt; Void,
             failure: @escaping (Error) -&gt; Void) {
    // Request to Server...
}

func rxGetList() -&gt; Observable&lt;String&gt; {
    // Using getList() function
    // TODO
}
</code></pre>
<p>What code should I write in TODO section?
Please give me some advice.</p>
","3569109","","","","","2020-12-06 15:41:08","API funtion using RxSwift","<ios><swift><rx-swift>","2","1","","","","CC BY-SA 4.0"
"65165464","1","","","2020-12-06 06:49:07","","1","171","<p>I heard that I can get out of callback hell using RxSwift.<br>
But I don't have an idea how to improve callback hell.</p>
<p>
The samples below need to be called in the order getItem1() -> getItem2() -> getItem3()<br>
Is there a way out of this callback hell using RxSwift?
<pre><code>class MyItem {
    
    // MARK: - Public
    
    // Callback hell
    public func getMyItem(success: @escaping (String) -&gt; Void, failure: @escaping (Error) -&gt; Void) {
        self.getItem1(success: { [weak self] item1 in
            self?.getItem2(item1: item1, success: { [weak self] item2 in
                self?.getItem3(item2: item2, success: { item3 in
                    success(item3)
                }, failure: { err3 in
                    print(err3)
                    failure(err3)
                })
            }, failure: { err2 in
                print(err2)
                failure(err2)
            })
        }, failure: { err1 in
            print(err1)
            failure(err1)
        })
    }
    
    // MARK: - Private
    
    private func getItem1(success: @escaping (String) -&gt; Void, failure: @escaping (Error) -&gt; Void) {
        // Request to sever
    }
    
    private func getItem2(item1: String, success: @escaping (String) -&gt; Void, failure: @escaping (Error) -&gt; Void) {
        // Request to sever
    }
    
    private  func getItem3(item2: String, success: @escaping (String) -&gt; Void, failure: @escaping (Error) -&gt; Void) {
        // Request to sever
    }
}

</code></pre>
<p>I'm waiting for your answer to teach me.</p>
","3569109","","","","","2020-12-07 01:22:37","Can I get out of callback hell with RxSwift?","<swift><rx-swift>","2","2","","","","CC BY-SA 4.0"
"65182661","1","","","2020-12-07 13:30:44","","1","35","<p>My workflow is simple.</p>
<p>I don't need to make the same DataRequest 2 times and need to check wether this request is already in progress.
If request is not in progress I need to make the request if some specific time has passed.</p>
<p>How could I achieve something like this using Alamofire ?
I am using 'Alamofire', '5.2.2' and 'RxAlamofire', '5.6.2' .</p>
","7073962","","","","","2020-12-08 13:15:05","How to check if same DataRequest is already in progress using RxAlamofire or Alamofire 5 and up?","<swift><alamofire><rx-swift><rxalamofire>","1","1","","2020-12-10 17:21:38","","CC BY-SA 4.0"
"65193422","1","65199977","","2020-12-08 05:10:57","","1","55","<p>I am using RxSwift and Swinject in my project. The way I bind the inputs / outputs is not exactly the same as in the example given by RxSwift. In <a href=""https://github.com/ReactiveX/RxSwift/blob/main/RxExample/RxExample/Examples/GitHubSignup/UsingDriver/GithubSignupViewModel2.swift"" rel=""nofollow noreferrer"">RxExample/GitHubSignup</a>, the binding is done in the <code>init()</code>, right? But I found it difficult to implement because I use Swinject+SwinjectStoryboard to do Dependency Injection to the View Controller. Thus, the <code>init()</code> is unavailable because the one instantiating the View Models is the Swinject container. So, is there a way to bind the view controller and view model together besides using <code>init()</code>?</p>
<p>I was thinking that I can maybe use <code>var</code> instead of <code>let</code> for the output observables and make a func <code>bind(observables: [Observable])</code> or something that will do the bindings and transformations from input to output instead. But because they will be vars and not lets, that means it seems like we are permitted to change the bindings throughout the code. Unlike when we just use lets and bind them in the <code>init()</code>. And also, by using a function instead of the initializer, I have to store the dependencies into a member variable. While if I use the initializer, I can just transform the dependencies inside of a <code>map</code> or <code>flatMap</code>.</p>
<p>And also I have another question. Say, if I have this:</p>
<pre><code>class MyViewController: UIViewController {
    @IBOutlet weak var refreshButton: UIButton!
    @IBOutlet weak var tableView: UITableView!

    var viewModel: MyViewModel!
    private let disposeBag = DisposeBag()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        viewModel = MyViewModel(refreshTap: refreshButton.rx.tap, dataProvider: ApiAdapter().getData)
    
    }
    
    private func setupEvents() {
        viewModel.tableDTOs.bind(to: tableView.rx.items(
            cellIdentifier: reuseId, cellType: TableViewCell.self)) { _, dto, cell in
                cell.fill(with: dto)
        }.disposed(by: disposeBag)
    }
}

final class MyViewModel {
    let tableDTOs: Observable&lt;[TableDTO]&gt;
    
    init(refreshTap: Observable&lt;Void&gt;, dataProvider: () -&gt; Observable&lt;[TableDTO]&gt;) {
        tableDTOs = Observable.merge(.just(), refreshTap) //Merge with .just to emit at once for initial values
             .flatMapLatest { dataProvider().asDriver() }
    }
}
</code></pre>
<p>So in this case, if the dataProvider returned <code>complete</code> or <code>error</code>, the disposable will be disposed, right? So the scene will be unresponsive because the UI is already unbound. Any idea how to fix that?</p>
<p>Thanks.</p>
","4124849","","4124849","","2020-12-08 11:34:12","2020-12-08 13:35:20","Binding ViewModel events outside of the init","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"65238759","1","65244495","","2020-12-10 16:46:29","","1","278","<p>I have the following issue. I have two methods that both return <code>Single&lt;String&gt;</code>. I want to call the first at the beginning (e.g. user action) and if I get a <code>.success</code> event, I want to initialize navigation. However, when an error occurs, I first want to call another method and do display and after that display an error or do the navigation depending on its result.</p>
<p>The concrete example:</p>
<ul>
<li>I start a view controller and trigger a login function.</li>
<li>If the silent login fails to get a token (gets an error event), I want to have a login mask (an interactive token request) shown to the user.</li>
<li>If the silent login works, I don't want to show the login mask and just start the navigation.</li>
</ul>
<p>Here is the code:</p>
<pre><code>import UIKit
import RxSwift
import RxCocoa

final class SignInViewModel {
    private let authService: AuthenticationService
    private let disposeBag = DisposeBag()
    
    let loadingErrorOccurred = PublishSubject&lt;Void&gt;()
    
    init(authService: AuthenticationService) {
        self.authService = authService
    }
    
    func signInUser(in viewController: UIViewController) {
        // I want to trigger the getTokenInteractively when the getTokenSilently() fails
        // and never trigger it if it succeeds.

        getTokenSilently()
            .asObservable()
            .take(1)
            .catchAndReturn(&quot;&quot;)
            .map { token in !token.isEmpty }
            .bind(to: wasSilentTokenRequestSuccessful)
            .disposed(by: disposeBag)
    }
    
    private func getTokenSilently() -&gt; Single&lt;String&gt; {
        return Single.create { [authService] observer -&gt; Disposable in
            authService.getTokenSilently { token, error in
                if let token = token, error != nil {
                    observer(.success(token))
                } else {
                    observer(.failure(error ?? UnknownError()))
                }
            }
            
            return Disposables.create()
        }
    }
    
    private func getTokenInteractively(viewController: UIViewController) -&gt; Single&lt;String&gt; {
        return Single.create { [authService] observer -&gt; Disposable in
            authService.getTokenInteractively(parentView: viewController) { token, error in
                if let token = token, error != nil {
                    observer(.success(token))
                } else {
                    observer(.failure(error ?? UnknownError()))
                }
            }
            
            return Disposables.create()
        }
    }
}
</code></pre>
<p>I'm looking for a proper way of achieving the desired result. I thought of some kind of operator that first triggers one function, and only if the result of that fails it will trigger the next function. The rest of the stream could then stay the same.</p>
","3771915","","3771915","","2020-12-10 16:58:48","2020-12-11 01:25:21","RxSwift call a method on error event or don't call it at all","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"65242591","1","65314721","","2020-12-10 21:29:41","","0","120","<p>I'm trying to call the <code>modelSelected</code> function with RxSwift on my UITableView, but for some reason, unlike any other UITableView I've implemented in my codebase, it doesn't recognize my tap gesture unless I hold down on the table view cell.</p>
<p>I have a table view that I have connected to my .xib file. In that .xib file, I have embedded my table view inside my UIViewController and have defined the layout for a prototype table view cell.</p>
<pre><code>@IBOutlet private var tableView: UITableView!
</code></pre>
<p>And this is what I have in my <code>viewDidLoad</code> function.</p>
<pre><code>viewModel.modelArray
            .bind(to: tableView.rx.items(cellIdentifier: CustomTableViewCell.reuseIdentifier, cellType: CustomTableViewCell.self)) { row, element, cell in
                // Assign cell UI properties
            }
            .disposed(by: disposeBag)

tableView.rx.modelSelected(ModelClass.self)
            .subscribe(onNext: { [weak self] model in
                // Respond to cell tap
            })
            .disposed(by: disposeBag)
</code></pre>
<p>Is there something I might be missing here?</p>
","2853328","","","","","2020-12-15 22:38:47","RxSwift not recognizing tableView modelSelected without long press","<ios><swift><uitableview><rx-swift>","1","2","","","","CC BY-SA 4.0"
"65264087","1","65264466","","2020-12-12 10:53:57","","1","158","<p>I'm working on an iOS MVVM + Coordinator/ RxSwift project (non swiftUI).</p>
<p>In the groundViewController, there are multiple items on the screen, and the user can tap on any item to call a detailed view of that item. The detailed view will slide in after tapping on an item, and when the user taps another item, the detailed view will sliding out then sliding in again with updated info. detailedView is half screen size, user can also tap on empty space on groundViewController to dismiss the detailed view (sliding out animation).(So there will be only one detailedView)</p>
<p>I decided to make that detailed view as an UIView, which will have its own coordinator and ViewModel and be added to groundViewControll.view. But I'm now confused about how to communicate between them or event flow.</p>
<p>Question: In MVVM/Coordinator pattern, is it correct to make this flow as:</p>
<pre><code>groundViewController (receive a tap on the object) - &gt; 
groundViewModel - &gt;
groundCoordinator (creat and pass itemID ) - &gt; 
detailedViewCoordinator (creat) - &gt; 
detailedViewModel and detialedView
</code></pre>
<p>And who should in charge of detialedView's sliding in/out animation?</p>
","12027717","","12027717","","2020-12-12 11:39:01","2020-12-12 11:40:50","In MVVM + Coordinator, how to deal with sub view?","<ios><swift><mvvm><rx-swift>","1","3","","","","CC BY-SA 4.0"
"65300002","1","","","2020-12-15 04:26:24","","1","88","<p>I am new to <code>RxSwift</code>, so I wonder If it is possible to update <code>UIButton</code> title and select the action accordingly using <code>RxSwift</code>.</p>
<p>Say, I have a custom <code>UIButton</code> inside my <code>UITableViewCell</code> which I intend it to trigger a set of custom actions when the user taps, (e.g: like or dislike image or post or whatever...)</p>
<p>So, is that possible, for instance, to set the custom title, image, and action of a <code>UIButton</code> accordingly, and update the UI..</p>
<p>For more explanation of the point, say, I have two actions user can interact with the button: <code>func imageDisliked()</code> and <code>imageLiked()</code>, So when the Image is disliked, I want the button to set its title &quot;imageDisliked&quot; and its icon &quot;dislikeIcon&quot; and vice versa..</p>
<p>is that possible with <code>RxSwift</code>?</p>
","14785985","","","","","2020-12-15 12:45:21","Update UIButton title and select the action accordingly using RxSwift","<ios><swift><rx-swift><rx-cocoa>","1","1","","","","CC BY-SA 4.0"
"65302978","1","65305381","","2020-12-15 09:14:09","","1","21","<p>Could someone tell me why the first code gets triggered and the second code does not get triggered? (Assume &quot;someEndPoint&quot; is working properly)</p>
<pre><code>let provider = MoyaProvider&lt;MyApiService&gt;()
provider.rx.request(.someEndPoint).subscribe(onSuccess: { response in
  print(&quot;triggered&quot;)
}, onError: { error in
}).disposed(by: disposeBag)
</code></pre>
<pre><code>MoyaProvider&lt;MyApiService&gt;().rx.request(.someEndPoint).subscribe(onSuccess: { response in
  print(&quot;not triggered&quot;)
}, onError: { error in
}).disposed(by: disposeBag)
</code></pre>
<p>The difference between two codes is just to use &quot;let&quot; or not. I could not make &quot;not triggered&quot; printed in the second code and I can't see any network logs for the second code. I really want to know why it is.</p>
<p>Thanks in advance.</p>
","8799356","","","","","2020-12-15 11:56:26","Not getting triggered on RxMoya","<ios><swift><rx-swift><moya>","1","0","","","","CC BY-SA 4.0"
"65336584","1","","","2020-12-17 07:53:24","","0","122","<p>I write a demo about this leak.</p>
<pre class=""lang-swift prettyprint-override""><code>import UIKit
import RxSwift
import RxCocoa

class ViewController: UIViewController {
    
    private let viewModel = ViewModel()
    
    private let disposeBag = DisposeBag()
    
    private lazy var nameLabel: UILabel = {
        let label = UILabel()
        label.text = &quot;idle&quot;
        return label
    }()

    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.view.backgroundColor = .white
        self.view.addSubview(nameLabel)
        nameLabel.frame = CGRect(x: 100, y: 100, width: 100, height: 30)
        
        // not leak
        viewModel.name.asObservable().bind(to: nameLabel.rx.text).disposed(by: disposeBag)
        
        // leak
//        viewModel.name.asDriver().drive(onNext: { [weak self] (name) in
//            guard let weakSelf = self else { return }
//            weakSelf.nameLabel.text = name
//        }).disposed(by: disposeBag)
        
        // leak
//        viewModel.name.asDriver().drive(nameLabel.rx.text).disposed(by: disposeBag)
        
        viewModel.name.accept(&quot;act&quot;)
    }
}

class ViewModel {
    let name: BehaviorRelay&lt;String&gt; = BehaviorRelay(value: &quot;&quot;)
}
</code></pre>
<p>In Xcode Instrument Leaks, it will report leaks when using driver. But change to &quot;bindTo&quot;, it works fine and no leaks report.</p>
<p>I change &quot;driver.driveTo&quot; to driver.drive(onNext), and handle recycle problem, still report leaks.</p>
<p>I'm really confused about this. And I wish someone can tell me why this happened, how can I fix it, or avoid this kind of leaks in the future.</p>
<p>Thanks.</p>
","10435995","","","","","2020-12-17 07:53:24","Use RxSwift Driver cause memory leak","<memory-leaks><driver><rx-swift>","0","5","","","","CC BY-SA 4.0"
"65343363","1","","","2020-12-17 15:12:01","","-3","68","<p>What is the difference between PublishSubject and BehaviorRelay</p>
","11890426","","","","","2020-12-22 15:54:23","What is difference between PublishSubject and BehaviorRelay","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"65377033","1","65377117","","2020-12-20 04:56:12","","0","57","<p>Below is a simple example of binding a string array of viewModel to UITableView.<p>
I want to subscribe to one more viewModel.randomString and use it in the cell.<br>
I tried using combineLatest as below, but of course I couldn't bind to tableview.<br>
Do you have any ideas on how to implement it?<br></p>
<pre class=""lang-swift prettyprint-override""><code>class SimpleViewModel {
    var list = BehaviorRelay&lt;[String]&gt;(value: [])
    var randomString = BehaviorRelay&lt;String&gt;(value: &quot;&quot;)
    
    func fetch() {
        // Request...
        list.accept([&quot;result1&quot;, &quot;result2&quot;, &quot;result3&quot;])
        randomString.accept(&quot;Random...&quot;)
    }
}

class SimpleViewController {
    let tableView = UITableView()
    let viewModel = ViewModel()
    
    func foo() {
        // It works well.
        viewModel.list.bind(to: tableView.rx.items(cellIdentifier: &quot;Cell&quot;)) { (index, element, cell) in
            cell.textLabel?.text = element
        }
        
        // I want to bind the viewModel.list to the tableView and use the viewModel.randomString string together.
        Observable.combineLatest(viewModel.list, viewModel.randomString)
        // How???
//            .bind(to: tableView.rx.items(cellIdentifier: &quot;Cell&quot;)) { (index, element, cell) in
//                cell.textLabel?.text = element + &quot;RandomString&quot; // I want to use the &quot;RandomString&quot; of viewModel.randomString
//            }
    }
}
</code></pre>
","3569109","","","","","2020-12-20 05:15:09","Question about RxSwift/RxCocoa binding with combineLatest","<swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"65479835","1","","","2020-12-28 15:17:00","","0","136","<p>When I try to set a value, I have an error:</p>
<blockquote>
<p>Cannot assign to property: 'value' is a get-only property</p>
</blockquote>
<pre class=""lang-swift prettyprint-override""><code>var value: BehaviorRelay&lt;Any?&gt;

var unpackedValue: Any? {
    get {
        return value.value
    }

    set {
        value.value  = newValue // error
    }
}
</code></pre>
","12148262","","1549818","","2020-12-28 17:20:05","2020-12-28 17:20:05","Updating the value of BehaviorRelay property","<swift><xcode><rx-swift>","1","2","","","","CC BY-SA 4.0"
"65506924","1","65508521","","2020-12-30 12:25:14","","1","85","<p>I have the Tableview with UIAlertAction. When I press a cell, a pop-up appears and then I can decide which operation to perform. During the Ok operation (button click) I want to observe the data of the cell and receive it in the ViewModel. But there are problems.
When I press for the first time there is no value and if I just click a cell the data is still sending to the ViewModel. If I click more UIAlertAction popu-ups the sending data is increasing. For example: First click - nothing, second click - value 1, third click value 1, 1, 1 and so on.
How to start observing cells from the first click of the UIAlertAction pop-up and how to get only on example of the data?</p>
<p>ViewController:</p>
<pre><code>func bindTableView() {
    viewModel.stationItems.bind(to: addTableView.rx.items(cellIdentifier: &quot;addCell&quot;, cellType: AddTableViewCell.self)) { (row, item, cell)
        in
        cell.cellAdd = item
    }.disposed(by: disposeBag)
    
    addTableView.rx.modelSelected(StationItem.self)
        .subscribe(onNext: { item in

            let alert = UIAlertController(title: &quot;Add Station&quot;, message: &quot;Do you want to add a station to your favorites?&quot;, preferredStyle: .alert)
            let ok = UIAlertAction(title: &quot;Ok&quot;, style: .default, handler: { action in
                self.addTableView.rx.modelSelected(StationItem.self)
                    .bind(to: self.viewModel.stationItem)
                    .disposed(by: self.disposeBag)
                self.viewModel.addStationItem()
            })
            alert.addAction(ok)
            let cancel = UIAlertAction(title: &quot;Cancel&quot;, style: .default, handler: { action in
            })
            alert.addAction(cancel)
            DispatchQueue.main.async(execute: {
                self.present(alert, animated: true)
            })
        }).disposed(by: disposeBag)
    
    viewModel.fetchStations()
}
</code></pre>
<p>ViewModel:</p>
<pre><code> let stationItem = PublishSubject&lt;StationItem&gt;()

 func addStationItem() {
    stationItem.subscribe(onNext: {(data) in
        print(&quot;Data: \(data)&quot;)
        
        })
        .disposed(by: disposeBag)
    
    print(&quot;ADD:&quot;)
            
}
</code></pre>
","11056400","","","","","2020-12-30 14:34:32","RxSwift and AlertAction","<swift><rx-swift><uialertaction>","1","0","","","","CC BY-SA 4.0"
"65532684","1","65535091","","2021-01-01 18:51:58","","1","330","<p>I want to solve this error.
&quot;Cannot convert value of type 'SharedSequence&lt;DriverSharingStrategy, ControlProperty&lt;String?&gt;.Element&gt;' (aka 'SharedSequence&lt;DriverSharingStrategy, Optional&gt;') to expected argument type 'Driver' (aka 'SharedSequence&lt;DriverSharingStrategy, String&gt;')&quot;
And
&quot;Cannot convert value of type 'SharedSequence&lt;DriverSharingStrategy, Data?&gt;' to expected argument type 'Driver' (aka 'SharedSequence&lt;DriverSharingStrategy, String&gt;')&quot;</p>
<p>But I don't know how to fix this error. I don't think something fits with the viewModel, but I don't know what it is. The place where the error occurs is the asDriver.
I am using RxSwift and MVVM patterns.</p>
<pre><code>   func bindViewModel() {
        
        let api = ProfileAPI()
        let input = ModifyProfileViewModel.input(nickName: nickNameTxtField.rx.text.asDriver(onErrorJustReturn: nil), userImage: image.asDriver(), doneTap: saveBtn.rx.tap.asSignal())
        let output = viewModel.transform(input)
        
        output.result.emit(onCompleted: { self.navigationController?.popViewController(animated: true)}
        ).disposed(by: rx.disposeBag)
    }
</code></pre>
<p>This is my ViewController code</p>
<pre><code>class ModifyProfileViewModel: ViewModelType {
    
    let disposeBag = DisposeBag()
    
    struct input {
        let nickName: Driver&lt;String&gt;
        let userImage: Driver&lt;String&gt;
        let doneTap: Signal&lt;Void&gt;
    }
    
    struct output {
        let result: Signal&lt;String&gt;
        let isEnabled: Driver&lt;Bool&gt;
    }
    
    func transform(_ input: input) -&gt; output {
        let api = ProfileAPI()
        let result = PublishSubject&lt;String&gt;()
        let info = Driver.combineLatest(input.nickName, input.userImage)
        let isEnabled = info.map { !$0.0.isEmpty }
        
        input.doneTap.withLatestFrom(info).asObservable().subscribe(onNext: { nickName, image in
            api.putModifyProfile().subscribe(onNext: { (response, statusCode) in
                switch statusCode {
                case .success:
                    result.onCompleted()
                case .noHere:
                    result.onNext(&quot;fail&quot;)
                default:
                    result.onNext(&quot;default&quot;)
                }
            }).disposed(by: self.disposeBag)
        }).disposed(by: disposeBag)
        
        return output(result: result.asSignal(onErrorJustReturn: &quot;&quot;), isEnabled: isEnabled.asDriver())
        
    }
}
</code></pre>
<p>And this is my ViewModel code
What is the problem?</p>
","14063311","","","","","2021-01-02 00:48:38","Cannot convert value of type 'SharedSequence<DriverSharingStrategy, Data?>' to expected argument type","<swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"65539863","1","65539969","","2021-01-02 13:56:16","","1","172","<p>I want to bind the value of tableViewCell. But there is an error like the title. I've never seen this error before and I want to know how to fix it.</p>
<pre><code>  func bindViewModel() {
        let input = ListenViewModel.input(loadData: loadData.asSignal(onErrorJustReturn: ()))
        let output = viewModel.transform(input)
        
        output.loadApplyList.bind(to: tableView.rx.items) { tableView, index, element -&gt; UITableViewCell in
            guard let cell = self.tableView.dequeueReusableCell(withIdentifier: &quot;ListeningTableViewCell&quot;) as? ListeningTableViewCell else {
                return ListeningTableViewCell()}
            cell.listeningData = element
        }.disposed(by: disposeBag)
        
    }
</code></pre>
<p>This is my ViewController Code</p>
<pre><code>class ListenViewModel: ViewModelType {

    private let disposeBag = DisposeBag()
    static var loadData = PublishRelay&lt;listen&gt;()

    struct input {
        let loadData: Signal&lt;Void&gt;

    }
    struct output {
      //  let isEnabled: Driver&lt;Bool&gt;
        let result: Signal&lt;String&gt;
        let loadApplyList: PublishRelay&lt;listen&gt;
    

    }

    func transform(_ input: input) -&gt; output {
        let api = ProfileAPI()
        let result = PublishSubject&lt;String&gt;()
        let loadApplyList = PublishRelay&lt;listen&gt;()
    

        input.loadData.asObservable().subscribe(onNext: { [weak self] in
            guard let self = self else { return }
            api.getListenigList(&quot;admin123@gmail.com&quot;).subscribe(onNext: { (response, statuscode) in
                switch statuscode {
                case .ok:
                    if let response = response {
                        loadApplyList.accept(response)
                    }
                case .noHere: result.onNext(&quot;fail&quot;)
                default:
                    print(&quot;Default&quot;)
                }
            }).disposed(by: self.disposeBag)
        }).disposed(by: disposeBag)

        return output(result: result.asSignal(onErrorJustReturn: &quot;실패&quot;), loadApplyList: loadApplyList)
    }

}
</code></pre>
<p>And this is my ViewModel Code.
How to fix this error?</p>
","14063311","","","","","2021-01-02 14:06:33","Instance method 'items' requires that 'listen' conform to 'Sequence'","<swift><uitableview><bind><rx-swift>","1","2","","","","CC BY-SA 4.0"
"65540985","1","","","2021-01-02 15:45:39","","0","291","<p>I want to display the value of the table view cell on the screen. However, the following error occurs:
<strong>Cannot assign value of type ‘[listenings]’ to type ‘ProfileModel’</strong>
I think there is no problem with the model.</p>
<pre><code>func bindViewModel() {
        let input = ListenViewModel.input(loadData: loadData.asSignal(onErrorJustReturn: ()))
        let output = viewModel.transform(input)
        
        output.loadApplyList.map(CollectionOfOne.init).bind(to: tableView.rx.items) { tableView, index, element -&gt; UITableViewCell in
            guard let cell = self.tableView.dequeueReusableCell(withIdentifier: &quot;ListeningTableViewCell&quot;) as? ListeningTableViewCell else {
                return ListeningTableViewCell()
            }
            cell.listeningData = element.listen
        }.disposed(by: disposeBag)
        
    }
</code></pre>
<p>This is my ViewController code. Error occurs in 'cell.listingdata large = element.listen'</p>
<pre><code>class target: Codable {
    let nickname: String
    let image: String
    let listening: Int
    let listener: Int
    let isMine: Bool
}

class listen: Codable {
    let listen: [listenings]
}

class listenings: Codable {
    let nickname: String
    let image: String
    let listener: Int
    let listening: Int
    let isListening: Int
}
</code></pre>
<p>And this is my Model code.
How to solve this error?</p>
","14063311","","","","","2021-01-02 15:45:39","Cannot assign value of type ‘[model]’ to type ‘Model’","<swift><rx-swift>","0","7","","","","CC BY-SA 4.0"
"65547118","1","","","2021-01-03 06:09:58","","1","207","<p>I am trying to use RxSwift to calculate SMA(simple moving average) and EMA(exponentially weighted moving average)</p>
<p>The setup is like below, the methods take the close price stream as input <code>Observable&lt;Double&gt;</code>. so every time if there is a new <code>close</code> price being emitted, the sma obervable will emit a new calculated value to the stream</p>
<p>I finished the SMA version, which is working fine</p>
<pre><code>func sma(_ source: Observable&lt;Double&gt;, _ length: Int) -&gt; Observable&lt;Double?&gt; {
    let bag = DisposeBag()

    return Observable&lt;Double?&gt;.create { observer -&gt; Disposable in
        source.scan([]) { Array($0 + [$1].suffix(length)) }.subscribe(onNext: { value in
                if value.count &lt; length {
                    observer.onNext(nil)
                } else {
                    observer.onNext(value.reduce(0.0, { $0 + $1 / Double(length) }))
                }
        }).disposed(by: bag)

        return Disposables.create()
    }
} 
</code></pre>
<p>But the EMA formula is a bit complex</p>
<p><a href=""https://www.investopedia.com/ask/answers/122314/what-exponential-moving-average-ema-formula-and-how-ema-calculated.asp"" rel=""nofollow noreferrer"">https://www.investopedia.com/ask/answers/122314/what-exponential-moving-average-ema-formula-and-how-ema-calculated.asp</a></p>
<p>the formula involve the previous EMA value.</p>
<p><strong>I do not have clear idea how I can get the stream last value inside a Observable creation block :thinking</strong></p>
<p>below is the code I tried to implement, but <code>.withLatestFrom(ema(source, length))</code> did not work out</p>
<p><a href=""https://i.stack.imgur.com/07BFK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/07BFK.png"" alt=""enter image description here"" /></a></p>
<pre><code>func ema(_ source: Observable&lt;Double&gt;, _ length: Int) -&gt; Observable&lt;Double?&gt; {
    let bag = DisposeBag()
    return Observable&lt;Double?&gt;.create { observer -&gt; Disposable in
        source.scan([]) { Array($0 + [$1].suffix(length)) }.withLatestFrom(ema(source, length)) { return ($0, $1) }
            .subscribe(onNext: { value in
                let alpha: Double = Double(2) / Double(length + 1)
                let src = value.0
                var sum: Double? = 0.0
                let sum1 = value.1
                sum = na(sum1) ? sma(src, length) : alpha * src.last! + (1 - alpha) * nz(sum1)
            
                observer.onNext(sum)
        }).disposed(by: bag)

        return Disposables.create()
    }
}
</code></pre>
<p><strong>any help is greatly appreciated :pray</strong></p>
","1005570","","","","","2021-01-03 13:46:45","RxSwift observable creation which takes the last value of the stream itself","<rxjs><rx-java><reactive-programming><rx-swift>","2","0","1","","","CC BY-SA 4.0"
"65556605","1","65557120","","2021-01-04 01:16:21","","0","145","<p>I am going to send data in formData format. However, an error such as the title occurred.</p>
<pre><code>    func formData(_ api: URL, param: Parameters, img: String?) -&gt; DataRequest {
            return AF.upload(multipartFormData: { (multipartFormData) in
                if img != nil {
                    multipartFormData.append(img, withName: &quot;img&quot;, fileName: &quot;image.jpg&quot;, mimeType: &quot;image/jpg&quot;)
                }
                for (key, value) in param {
                    multipartFormData.append(&quot;\(value)&quot;.data(using: .utf8)!, withName: key, mimeType: &quot;text/plain&quot;)
                }
            }, to: baseURL + api.path(), method: .post, headers: api.header())
        }
</code></pre>
<p>This is the code I wrote.An error occurs in the if statement. Can you tell me if my code is correct or what the problem is?</p>
","14063311","","","","","2021-01-04 02:51:02","How to fix Cannot convert value of type 'String?' to expected argument type 'URL'","<swift><multipartform-data><rx-swift>","1","0","","","","CC BY-SA 4.0"
"65568751","1","65569818","","2021-01-04 19:36:18","","0","41","<p>I have big trouble because when I selected a cell in my <code>collectionView</code> and change my array Data I got this error message :</p>
<p>'Invalid update: invalid number of items in section 0.  The number of items contained in an existing section after the update (2) must be equal to the number of items contained in that section before the update (2), plus or minus the number of items inserted or deleted from that section (1 inserted, 0 deleted) and plus or minus the number of items moved into or out of that section (0 moved in, 0 moved out).'</p>
<p>It happens before iOS 13. In iOS 13 and Upper works well. There is my code:</p>
<pre><code>import UIKit
import ReactiveKit
import Bond

//Its in my viewModel

var arrayOfObjects = MutableObservableArray&lt;MyObject&gt;([])


  actionCollectionViewDidSelect.observeNext { [weak self] indexPath in
        guard indexPath.row != 0 else { return }
        guard let object = self?.arrayOfPhotoObjects[indexPath.row] else { return }
        photoObject.isSelected = !photoObject.isSelected
        if let value = self?.arrayOfObjects.value { self?.arrayOfPhotoObjects.value = value } // Gives error because there but I can't find solution.
    }.dispose(in: disposeBag)

//Its in my ViewController


collectionView.reactive.selectedItemIndexPath.observe(with: viewModel.actionCollectionViewDidSelect).dispose(in: disposeBag)

    viewModel.arrayOfObjects.bind(to: collectionView) { object, indexPath, collectionView in
        
        let objectForIndex = arrayObjects[indexPath.row]
       
            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: &quot;photoBoxCollectionViewCell&quot;, for: indexPath) as! MYCEll
             cell.data = objectForIndex
            return cell
        }
    }
</code></pre>
","12938902","","2392683","","2021-01-06 16:28:30","2021-01-06 16:28:30","Invalid update: invalid number of items in section 0 in Reactive Programming issue","<swift><reactive-programming><rx-swift><reactivekit><swiftbond>","1","0","","","","CC BY-SA 4.0"
"65575946","1","","","2021-01-05 09:10:12","","0","35","<p>How would I test a method that looks like this?</p>
<pre><code>// in unit test suite

var afterSubscribeClosureEntered = false
viewModel.afterSubscribe = { res in
     afterSubscribeClosureEntered = true
}

viewModel.someMethod()
expect(afterSubscribeClosureEntered).to(beTrue()) // if I used toEventually, it will fail in unit test (time out, unresponsive main loop)

// view model

var afterSubscribe: ((Bool) -&gt; Void)?

func someMethod() {

   observableOne() // method that returns Observable&lt;T&gt;
     .flatMap(observableTwo()) // returns Observable&lt;T&gt;
     .subscribe(onNext: { val in
         // some operation
         self.afterSubscribe?(val)
     })
     .disposed(by: disposeBag)
}
</code></pre>
<p>I tried using toEventually but that breaks in Fastlane (time out, main loop unresponsive). The test suite succeed in XCode test though. I don't want to inject a completionHandler in <code>someMethod</code>.Is there a way to test this without using toEventually and waitUntil? Thanks alot!</p>
","13432420","","13432420","","2021-01-05 18:32:33","2021-01-05 18:32:33","How to Unit Test RxSwift Chaining","<swift><unit-testing><rx-swift><quick-nimble>","0","3","","","","CC BY-SA 4.0"
"65590910","1","65718981","","2021-01-06 05:58:53","","1","75","<p>I write function 'asPromise()'</p>
<pre><code>extension PrimitiveSequence {
public func asPromise() -&gt; Promise&lt;Element&gt; {
    var disposed: Disposable? = nil
    return Promise&lt;Element&gt; { seal in
        disposed = self.asObservable()
            .subscribe { event in
                switch event {
                case .next(let element):
                    seal.fulfill(element)
                case .error(let error):
                    seal.reject(error)
                case .completed:
                    disposed?.dispose()
                }
            }
    }
}}
</code></pre>
<p>but dispose is weird, I don't better idea.
so If you have any better ideas, please let me know</p>
<p>thank you</p>
","10100150","","","","","2021-01-14 12:30:06","Use the 'asPromise ()' in the Observable RxSwift can be used in a PromiseKit Promise?","<ios><swift><rx-swift><promisekit>","1","0","","","","CC BY-SA 4.0"
"65594014","1","65594278","","2021-01-06 10:25:12","","0","41","<p>I have a ViewController where an array of data is displayed (FavoriteViewController). In the another one ViewController I can select the objects I want to add to the list from the previous ViewController, but there is a problem. If I come back from the second ViewController, the data is duplicated. Every time I go back to the ViewController with the Array mentioned, I refresh the data for the most current data and this causes duplication. How can I fix it?</p>
<p>FavoriteViewController:</p>
<pre><code>class FavoriteViewController: UIViewController {

@IBOutlet weak var stationsTableView: UITableView!
private var disposeBag = DisposeBag()
private var viewModel = FavoriteViewModel()


override func viewDidLoad() {
    super.viewDidLoad()
}

override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
    self.hidesBottomBarWhenPushed = true
    
    stationsTableView.rx.setDelegate(self).disposed(by: disposeBag)
    bindTableView()
}

override func viewWillDisappear(_ animated: Bool) {
    super.viewWillDisappear(animated)
    self.hidesBottomBarWhenPushed = false
    stationsTableView.dataSource = nil
    stationsTableView.delegate = nil
    
}

override func viewDidDisappear(_ animated: Bool) {
   disposeBag = DisposeBag()
}
    
func bindTableView() {
    self.viewModel.stationItems.asObservable().distinctUntilChanged().bind(to: stationsTableView.rx.items(cellIdentifier: &quot;cell&quot;, cellType: FavoriteTableViewCell.self)) { (row,item,cell) in
        cell.cellStation = item
    }.disposed(by: disposeBag)
    
    stationsTableView.rx.modelSelected(StationItem.self).subscribe(onNext: { item in
        print(&quot;SelectedItem: \(item)&quot;)
    }).disposed(by: disposeBag)
    
    deleteStation()
    
    viewModel.fetchSavedStationItems()
}
</code></pre>
<p>FavoriteViewModel:</p>
<pre><code>class FavoriteViewModel: ObservableObject {

private let apiService : APIServiceProtocol
private let persistenceService: PersistenceServiceProtocol
public let stationItems = BehaviorSubject&lt;[StationItem]&gt;(value: [])
var itemsList = [StationItem]()

init(apiService: APIServiceProtocol = APIService(), persistenceService: PersistenceServiceProtocol = PersistenceService()) {
    self.apiService = apiService
    self.persistenceService = persistenceService
}

func fetchSavedStationItems() {
    do {
        itemsList += try persistenceService.fetchStationItems()
        self.stationItems.onNext(itemsList)
    } catch {
        print(&quot;ERROR fetchedSavedStationItems FavoriteViewModel&quot;)
    }
}
</code></pre>
","11056400","","","","","2021-01-06 11:02:13","RxSwift and duplicated array data","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"65595650","1","","","2021-01-06 12:19:23","","0","49","<p>I am using RxSwift binding with the TableView and there is an option: itemDeleted, which shows the delete button after swipe. It is in English language. How to rename the delete button?</p>
<pre><code>func deleteStation() {
    stationsTableView.rx.itemDeleted
    .subscribe (onNext: { item in
        self.viewModel.deleteStationItem(indexPath: item)
    })
    .disposed(by: disposeBag)
}
</code></pre>
<p><a href=""https://i.stack.imgur.com/XTZ9l.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/XTZ9l.png"" alt=""enter image description here"" /></a></p>
","11056400","","","","","2021-01-06 12:19:23","RxSwift tableView.rx.itemDeleted and name of a button","<ios><swift><uitableview><rx-swift>","0","0","","","","CC BY-SA 4.0"
"65596239","1","","","2021-01-06 12:59:31","","1","48","<p>I am using RxSwift pod in project. It is working fine till now. I have upgraded RxSwift to latest version(RxSwift '6.0.0') and installed pod file.
After installing the latest RxSwift pod I am unable build the app. I am getting so many errors.</p>
<p>Please help me to fix and also let me know is their any dependency or limitations to use latest RxSwift pod.</p>
<p>Thank you in advance.</p>
","14570594","","","","","2021-01-06 12:59:31","RxSwift pod issue in Xcode12","<ios><xcode><rx-swift>","0","1","","","","CC BY-SA 4.0"
"65618231","1","65629665","","2021-01-07 18:46:21","","1","100","<p><strong>What I want to do</strong>:</p>
<ol>
<li>Present VC1</li>
<li>When VC1 is dismissed, present VC2</li>
</ol>
<p><strong>Problem</strong>:</p>
<ol>
<li>When VC1 is dismissed, VC2 does not present</li>
</ol>
<p><strong>Dirty Fix</strong>:
Put milisecond delay. It fixes the problem, but want to know why it happens</p>
<p><strong>Explanation</strong>: I get viewDidDissapear event when VC1 dismisses so I can present VC2</p>
<p><strong>If you need more details, please ask.</strong></p>
<p><strong>Code</strong>:</p>
<pre><code>class ViewModel {

    let coordinator = Coordinator()

    struct Input {
        let itemSelected: Driver&lt;IndexPath&gt;
    }

    struct Output {
        let presentVC1: Driver&lt;Void&gt;
        let presentVC2: Driver&lt;Void&gt;
    }

    func transform(input: Input) -&gt; Output {

        let navigateToVC1 = input.itemSelected
            .flatMap { [coordinator] in
                return coordinator.transition(to: Scene.VC1)
            }

        let navigateToVC2 = navigateToVC1
            .delay(.milliseconds(1))
            .flatMap { [coordinator] in
                return coordinator.transition(to: Scene.VC2)
            }

        return Output(presentVC1: presentVC1, presentVC2: presentVC2)
    }
</code></pre>
<p>Coordinator code:</p>
<pre><code>func transition(to scene: TargetScene) -&gt; Driver&lt;Void&gt; {
        let subject = PublishSubject&lt;Void&gt;()

        switch scene.transition {
           
            case let .present(viewController):
                _ = viewController.rx
                    .sentMessage(#selector(UIViewController.viewDidDisappear(_:)))
                    .map { _ in } 
                    .bind(to:subject)
                currentViewController.present(viewController, animated: true)
                
        return subject
            .take(1)
            .asDriverOnErrorJustComplete()
    }
</code></pre>
","6740231","","","","","2021-01-08 13:12:27","RxSwift concurrency problems with coordinator","<ios><swift><rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"65659620","1","65667814","","2021-01-10 23:32:37","","2","73","<p>I have a simple signal, in one of the app components, that returns an array of items:</p>
<pre class=""lang-swift prettyprint-override""><code>var itemsSignal: Signal&lt;[Item], Never&gt;
</code></pre>
<p>Those items <strong>might</strong> contain updates for the data that are rendered on the screen in a form of a table view. The task is to apply the updates to the cells if they are present on the screen.</p>
<p>There are two possible ways, that I can think of, on how this can be done. The app is written in MVVM style, but I will simply for the purposes of example.</p>
<p>The first way is to subscribe to this signal <strong>once</strong> on a level of view controller code, then in an <code>observeValues</code> block check wherever we receive the updates for the items on screen with some for-loop and update the states for the corresponding cells. This way we will have only a single subscription, but this introduce unnecessary, in my mind, code coupling, when we basically use view controller level code to pass updates from the source to individual cells on screen.</p>
<p>The second way is to subscribe to this signal from each individual cell (in reality cell's view model) and apply some filtering like this:</p>
<pre class=""lang-swift prettyprint-override""><code>disposables += COMPONENT.itemsSignal
    .flatten()
    .filter({ $0.itemId == itemId })
    .observeValues({ 
        ... 
    })
</code></pre>
<p>But this creates <strong>multiple</strong> subscriptions - one for each individual cell.</p>
<p>I actually prefer the second method, as it much cleaner from a design stand point, in my mind, as it doesn't leak any unnecessary knowledge to view controller level code. And wherever the same cell is re-used on a different screen this self-updating behaviour will be inherited and will work out of the box.</p>
<p>The question is how much more memory/cpu expensive is the second method due to multiple subscriptions? In this project we use <code>ReactiveSwift</code>, but I think this is relevant for other <code>Rx</code> libraries as well.</p>
","914729","","914729","","2021-01-11 00:43:18","2021-01-11 19:25:54","ReactiveSwift one vs multiple signal subscriptions and related memory overhead","<ios><swift><rx-swift><reactive-swift>","2","0","","","","CC BY-SA 4.0"
"65672226","1","","","2021-01-11 18:04:11","","0","11","<p>While changing identity for empty item (identifier == nil)</p>
<pre><code>extension Item: IdentifiableType {
    public var identity: Int64 {
        identifier ?? Self.emptyId
    }

    public static var emptyId: Int64 = .random(in: 0..&lt;Int64.max)

    public static func refreshEmptyItemId() {
        Self.emptyId = .random(in: 0..&lt;Int64.max)
    }
}
</code></pre>
<p>so table view does not refreshes this item. Why?</p>
<p>But If I do</p>
<pre><code>extension Item: IdentifiableType {
    public var identity: Int64 {
        identifier ?? .random(in: 0..&lt;Int64.max)
    }
}
</code></pre>
<p>It then refreshes, but too often, so I prefere to change id only on button tap.</p>
","4415642","","","","","2021-01-11 18:04:11","RxTableViewSectionedAnimatableDataSource does not call configureCell on item identity change","<tableview><rx-swift><rxdatasources>","0","1","","","","CC BY-SA 4.0"
"65708796","1","","","2021-01-13 19:44:12","","1","28","<p>My task is to add UICollectionView with several cells to the cell of UITableView using SwiftRx and MVVM pattern.</p>
<p>I add empty collectionView to tableView, but I can't figure out how to add some cells to it using SwiftRx.</p>
<p>Here is my CollectionCellView (also I have a method for layout):</p>
<pre><code>private(set) var bag = DisposeBag()
private let viewModel: SocialMediaCellViewModel

private let image: UIImageView = {
    let img = UIImageView()
    img.image = UIImage(named: &quot;plusSocialMedia&quot;)
    return img
}()

private let telegramButton: SocialMediaButton = {
    let bt = SocialMediaButton()
    bt.setImage(SocialMedia.telegram.icon, for: .normal)
    return bt
}()
</code></pre>
<p>If you can help me to figure out what I have to write in my ViewModel and how to correctly write bindViewModel() method in CollectionCellView, it will be so amazing!</p>
","14506424","","","","","2021-01-14 05:09:50","How can l add cells to UICollectionView with SwiftRx?","<swift><uicollectionview><rx-swift>","1","0","","","","CC BY-SA 4.0"
"65752440","1","","","2021-01-16 17:21:16","","-1","36","<p>I have a TextView and I want to make a counter of input symbols with the help of RxSwift (ex. 1/1000, 2/1000 etc)</p>
<p>If you know how can I achieve this, please, help</p>
","14506424","","","","","2021-01-16 19:16:24","How to make counter of input symbols using RxSwift?","<swift><textview><counter><rx-swift>","1","0","","","","CC BY-SA 4.0"
"65776033","1","","","2021-01-18 14:06:45","","1","134","<p>I am new in RxSwift and want to implement a feature in my project.
I have to validate 2 fields, OTP and Confirm OTP using input/output MVVM using RxSwift on submit click.</p>
<p>Case1: If any textfield is empty submit button should be disabled, so if user starts typing the first textfield the submit button will be enabled (Same for confirm OTP textfield also)</p>
<p>Case2: On submit click i need to validate if either textfield is empty or not and show error on screen, Also if both the textfields value doesnt matches, it will show the error on submit button click.</p>
<pre><code>
let otpChangedText = BehaviorSubject&lt;String&gt;(value:&quot;&quot;)
let confirmOtpChangedText = BehaviorSubject&lt;String&gt;(value:&quot;&quot;)
let submitButtonTapped = PublishSubject&lt;Void&gt;()

let otp1Validation =  otpChangedText.skipWhile { $0.isEmpty}.map {Validator.isEmpty(string: $0)}

let isValidOtp =  otp1Validation.asDriver(onErrorJustReturn:false)

outputs = Outputs (isValidOTP: isValidOtp)

</code></pre>
<p>I have achieved the submit button disable state somehow but not getting any idea how should i show the error on screen if any of the field is empty and if the value of both the textfields dont match.</p>
<p>Please guide me. Thanks</p>
","1115985","","1115985","","2021-01-18 14:13:30","2021-01-20 02:19:40","Rxswift ios - Validate OTP field and Confirm OTP field on button click","<ios><swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"65810539","1","","","2021-01-20 13:30:26","","0","220","<p>I have to implement below scenarios with RxSwift MVVM</p>
<p>I have two textfields (OTP &amp; Confirm OTP) and a Submit button, If user clicks on the OTP textfield when there is no value on the OTP textfield then submit button should be disabled, Now if user types something in otp textfield button should be enabled. Now if user taps on the second text field as it is blank now then the button should be disabled again &amp; its get enabled only when there is a value.</p>
<p>So basically I want to enable/disable the button by checking:</p>
<ol>
<li>If OTP field has value then enable the button or disable it if no value</li>
<li>User taps on the Confirm OTP field, it is empty now so disable the button again</li>
<li>If user deletes the value from OTP field, disable the button again (As it is empty, same with Confirm OTP field)</li>
</ol>
<p>Thanks</p>
","1115985","","1115985","","2021-01-20 13:37:38","2021-01-21 09:25:25","RxSwift enable/disable button based on textfield input","<ios><swift><xcode><mvvm><rx-swift>","1","2","","","","CC BY-SA 4.0"
"65824655","1","","","2021-01-21 09:37:21","","0","79","<p>I'm practicing RxSwift and doing some task with searchBar and CollectionView.
when i run the app, collectionview show giphy files.
but when i input some text in searchBar, collectionView doesn't reload any data.
so there's empty cell when searchBar has text.</p>
<p>I don't know what should I do.. please help me!</p>
<p>here's the problem's code.</p>
<pre><code>let _ = gifSearchBar.rx.text.orEmpty
            .throttle(.milliseconds(500), scheduler: MainScheduler.instance)
            .flatMapLatest { (query) -&gt; Observable&lt;[GIFViewModel]&gt; in
                
                guard let model = self.gifDataViewModel else { return .just([]) }
                if query.isEmpty {
                    return model.fetchGifViewModels().catchErrorJustReturn([])
                }
                
                return model.searchGifViewModels(keyword: query)
            }.bind(to: gifCollectionView.rx.items(
                    cellIdentifier: SearchCollectionViewCell.reuseIdentifier,
                    cellType: SearchCollectionViewCell.self)) { row, gif, cell in
                cell.configure(gif: gif)
            }.disposed(by: disposeBag)
</code></pre>
<p>and the screen</p>
<p><a href=""https://i.stack.imgur.com/WyULw.jpg"" rel=""nofollow noreferrer"">enter image description here</a></p>
","11732965","","","user9270170","2021-01-22 01:13:05","2021-01-22 01:13:05","How to ReLoadData UICollectionView using RxSwift?","<ios><swift><uicollectionview><rx-swift>","0","6","","","","CC BY-SA 4.0"
"65841065","1","65919563","","2021-01-22 07:38:57","","1","51","<p>I'm trying to bind a view model to a collection view. But I don't know how to do it. I'm using MVVM pattern and RxSwift, and I've only tried table view binding before. Here's my view model and the view controller code I've done so far.</p>
<pre><code>class SearchViewModel: ViewModelType {
    private let disposeBag = DisposeBag()

    struct input {
        let loadData: Signal&lt;Void&gt;
    }

    struct output {
        let result: Signal&lt;String&gt;
        let loadApplyList: PublishRelay&lt;friends&gt;
    }

    func transform(_ input: input) -&gt; output {
        let api = SearchAPI()
        let result = PublishSubject&lt;String&gt;()
        let loadApplyList = PublishRelay&lt;friends&gt;()

        input.loadData.asObservable().subscribe(onNext: { [weak self] in
            guard let self = self else { return }
            api.getFriend().subscribe(onNext: { (response, statuscode) in
                switch statuscode {
                case .ok:
                    if let response = response {
                        loadApplyList.accept(response)
                    }
                default:
                    print(&quot;default&quot;)
                }
            }).disposed(by: self.disposeBag)
        }).disposed(by: disposeBag)

        return output(result: result.asSignal(onErrorJustReturn: &quot;&quot;), loadApplyList: loadApplyList)
    }
}
</code></pre>
<p>This is my ViewModel code</p>
<pre><code>func bindViewModel() {
       let input = SearchViewModel.input(loadData: loadData.asSignal(onErrorJustReturn: ()))
       let output = viewModel.transform(input)
       
   }
</code></pre>
<p>And this is my ViewController code.<br />
How should the collection view bind?</p>
","14063311","","564532","","2021-01-22 16:09:17","2021-01-27 12:52:01","How do I bind a ViewModel to a Collationview?","<swift><uicollectionview><rx-swift>","1","7","","","","CC BY-SA 4.0"
"65853334","1","65857606","","2021-01-22 22:02:54","","1","45","<p>I am trying to code an observable for <code>NSManagedObjectContext</code> <code>save()</code> operation with no success. The function does not fire neither <code>onNext</code> nor <code>onCompleted</code> event and is being disposed immediately. When I debug with breakpoints it shows <code>Disposables.create()</code> and <code>@escaping</code> notification closure work on different threads. Please tell what am I doing wrong in the code below and help to fix the problem.</p>
<pre><code>func save() -&gt; Observable&lt;Void&gt; {
    guard base.hasChanges else { return Observable.just(()) }
    return Observable.create { observer -&gt; Disposable in
        var token: NSObjectProtocol?
        token = NotificationCenter.default.addObserver(forName: .NSManagedObjectContextObjectsDidChange, object: self, queue: nil) { _ in
            observer.onNext(()) /* Is executed on the other thread and is never called */
            observer.onCompleted()
            NotificationCenter.default.removeObserver(token!)
        }
        
        base.perform {
            do {
                try base.save()
            } catch {
                observer.onError(Error.some)
            }
        }
        return Disposables.create() \* Immediately calls this func *\
    }
}
</code></pre>
","12504820","","988260","","2021-01-23 06:43:06","2021-01-23 14:51:38","Problems with creating Observable when using @escaping closures","<swift><core-data><rx-swift>","2","3","","","","CC BY-SA 4.0"
"65864891","1","65866331","","2021-01-23 22:01:06","","1","55","<p>I'm new in RxSwift, I have this code snipped that print in my console:</p>
<p>next(second value)</p>
<p>completed</p>
<p>but I was expecting this result:</p>
<p>next(first value)</p>
<p>next(second  value)</p>
<p>completed</p>
<p>why is not reacting twice the subscribe? I understand that in react, the observable emits and trigger the subscribe evert time that the variable that we are observing change but the code is not showing this. Do I misunderstand the concept?</p>
<pre><code>var mutableString = &quot;first value&quot;
mutableString = &quot;second value&quot;

var stringObservable: Observable&lt;String&gt; = Observable.of(mutableString)
        
stringObservable.subscribe { event in
    print(event)
}
</code></pre>
","6546939","","","","","2021-01-24 01:30:47","Observable only emits one value?","<observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"65873649","1","65877965","","2021-01-24 17:18:01","","1","73","<p>I am a beginner in ReactiveSwift I have a <code>UICollectionView</code>. My aim is to filter / edit the <code>Observable</code> array of the UICollectionView. After getting no results with filtering, I print it out after trying to filter, the filter count is correct but there's a type mistake I guess.</p>
<pre><code>items &gt;&gt;  RxSwift.(unknown context at $1024d7ea8).Map&lt;Swift.Array&lt;ReactiveThings.AnotherController.Element&gt;, Swift.Array&lt;ReactiveThings.AnotherController.Element&gt;&gt;
</code></pre>
<p>These are output.</p>
<pre><code>    DispatchQueue.main.asyncAfter(deadline: .now() + 3.5) {
        
        let items = observableElement.asObservable().map { element in
            element.filter {
                $0.age &gt; 15
            }
        }
        
        print(&quot;items &gt;&gt; &quot;, items)
        
    }
</code></pre>
<p>Here are my code.</p>
<pre><code>import UIKit
import RxSwift
import RxCocoa

public final class AnotherController: UIViewController, UICollectionViewDelegateFlowLayout {

let disposeBag = DisposeBag()

var collectionView: UICollectionView = {
    let layout = UICollectionViewFlowLayout()
    var cv = UICollectionView.init(frame: .zero, collectionViewLayout: layout)
    cv.translatesAutoresizingMaskIntoConstraints = false
    return cv
}()

private func setup() {
    
    view.addSubview(collectionView)
    collectionView.topAnchor.constraint(equalTo: view.topAnchor).isActive = true
    collectionView.leftAnchor.constraint(equalTo: view.leftAnchor).isActive = true
    collectionView.rightAnchor.constraint(equalTo: view.rightAnchor).isActive = true
    collectionView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true
    
    collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: &quot;CustomCelly&quot;)
    
    collectionView.rx.setDelegate(self).disposed(by: disposeBag)
    

    var observableElement = Observable.just(elementArray)
    
    
    observableElement.bind(to: collectionView.rx.items(cellIdentifier: &quot;CustomCelly&quot;)) { _, eleman, cell in
        if let cellToUse = cell as? UICollectionViewCell {
            cellToUse.backgroundColor = .red
        }
    }.disposed(by: disposeBag)
    
    
    DispatchQueue.main.asyncAfter(deadline: .now() + 3.5) {
        
        let items = observableElement.asObservable().map { element in
            element.filter {
                $0.age &gt; 15
            }
        }
        
        print(&quot;items &gt;&gt; &quot;, items)
        
    }
    
    
    
}

struct Element {
    let name: String
    let age: Int
}

var elementArray = [
    Element.init(name: &quot;E0&quot;, age: 15),
    Element.init(name: &quot;E1&quot;, age: 12),
    Element.init(name: &quot;E2&quot;, age: 13),
    Element.init(name: &quot;E3&quot;, age: 14),
    Element.init(name: &quot;E4&quot;, age: 17),
    Element.init(name: &quot;E5&quot;, age: 18)
]


public override func viewDidLoad() {
    super.viewDidLoad()
    
    setup()
}

public func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize {
    return CGSize(width: UIScreen.main.bounds.width, height: 100)
}
</code></pre>
<p>I want to achieve manipulate the data after an action for example after a <code>UIButton</code> click, the count of the model array may reduce 3 from 6.</p>
<p>Thanks in advance</p>
","4334113","","","","","2021-01-25 01:49:28","RxSwift filter Observable variable for UICollectionView numberOfItems(: )","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"65886289","1","","","2021-01-25 14:04:05","","1","158","<p>I have a tableview whose cells are bound to a listItemRelay like so:</p>
<pre><code>viewModel?.listItemsRelay
        .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated))
        .share()
        .observeOn(MainScheduler.instance)
        .bind(to: cardTableView.rx.items(cellIdentifier: CardCell.identifier, cellType: CardCell.self))({ [weak self] index, listItem, cell in
            self?.update(cell: cell, at: index, with: listItem)
        })
        .disposed(by: disposeBag)
</code></pre>
<p>Now if one of the listItems have changed and I want to update just that cell. How would I do that here, I'm kind of new to RXSwift.</p>
","8312326","","","","","2021-01-26 02:40:32","How to reload data for a single tableview cell using RXSwift","<swift><tableview><rx-swift>","2","2","","","","CC BY-SA 4.0"
"65894545","1","65895262","","2021-01-26 01:04:41","","1","332","<p><strong>Problem</strong>: CollectionView header and footer are not shown before results are retrieved from network service. They are shown after items are retrieved from service.</p>
<p><strong>Result I want:</strong>: Show CollectionView header and footer before items are retrieved from api call</p>
<p><strong>What i've tried:</strong>
Used different datasource with header and footer on initial viewDidLoad and set that datasource to nil when results loaded. Didn't work</p>
<p><strong>My (not so elegant) solution:</strong>
Add headerView and footerView subviews on viewDidLoad and replace them with collectionView when results come from service.</p>
<pre><code>itemsLoading.drive(onNext: { loading in 
 if loading {
   view.addSubview(headerView)
   view.addSubview(footerView) 
} else {  
  headerView.removeFromSuperview()
  footerView.removeFromSuperView()
  view.addSubview(collectionView)

</code></pre>
<p><strong>Is there more elegant solution to this problem ?</strong></p>
<p><strong>My Code:</strong> Left only parts related to Rxswift/RxDataSources</p>
<pre><code>struct Input { 

let id: Driver&lt;String&gt;

} 

struct Output {

let items: Driver&lt;[Item]&gt;

}

class ViewModel {

    func transform(input: Input) -&gt; Output {

        let items = networkService.getItems(id: input.id) // async operation
 
        return Output(items: items)
    }
}
</code></pre>
<pre><code>class ViewController: UIViewController {

    private let viewModel = ViewModel()
    private let disposeBag = DisposeBag()
    private let collectionView = UICollectionView(frame: .zero, collectionViewLayout: UICollectionViewFlowLayout())

    override func viewDidLoad() {
        super.viewDidLoad()
        bindViewModel()
    }

    private func bindViewModel() {

        let dataSource = ViewController.dataSource()
        let id = .just(id)
        let input = Input(id: id)
        let output = viewModel.transform(input: input)

        output.items.map { items in
            items.map { item in
                SectionModel(model: &quot;first Section&quot;, items: [item])
            }
        }
        .drive(collectionView.rx.items(dataSource: dataSource))
        .disposed(by: disposeBag)
    }


extension ViewController {

    typealias DataSource = RxCollectionViewSectionedReloadDataSource
    static func dataSource() -&gt; DataSource&lt;SectionModel&lt;String, Item&gt;&gt; {
        .init(
            configureCell: { _, collectionView, indexPath, _ in
                let cell = collectionView.dequeueReusableCell(ofType: UICollectionViewCell.self, for: indexPath)
                return cell
            },
            configureSupplementaryView: { _, collectionView, kind, indexPath in
                switch kind {
                    case UICollectionView.elementKindSectionHeader:
                        let header = collectionView.dequeueReusableSupplementaryView(ofKind: kind, kindType: SectionHeader.self, for: indexPath)
                        return header

                    case UICollectionView.elementKindSectionFooter:
                        let footer = collectionView.dequeueReusableSupplementaryView(ofKind: kind, kindType: SectionFooter.self, for: indexPath)
                        return footer
                    default:
                        assert(false, &quot;Unexpected element kind&quot;)
                }

            })
    }
}
</code></pre>
","6740231","","","","","2021-01-26 02:49:34","RxDataSources headerView and footerView","<rx-swift><rxdatasources>","1","0","","","","CC BY-SA 4.0"
"65914159","1","","","2021-01-27 06:50:24","","0","65","<p>I am using Realm in my project.
so far it was working correctly but now we are getting crash. &amp; strange thing is its not reproducible by debugging.</p>
<blockquote>
<p>realm::util::terminate(char const*, char const*, long,
std::initializer_listrealm::util::Printable&amp;&amp;)</p>
</blockquote>
<p>I have checked from <a href=""https://github.com/ReactiveX/RxSwift"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxSwift</a> i am using latest version of Realm libraries &amp; Xcode 12.3.</p>
<p>I am here attaching screensot of Firebase which helps you better understand.
On firebase event it shows that it crashes on some devices with app launch on second time.</p>
<p><a href=""https://i.stack.imgur.com/ZsVL4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZsVL4.png"" alt=""enter image description here"" /></a></p>
","7825271","","","","","2021-01-29 12:54:33","Realm crash realm::util::terminate(char const*, char const*, long, std::initializer_list<realm::util::Printable>&&)","<ios><swift><xcode><realm><rx-swift>","0","1","","","","CC BY-SA 4.0"
"65914466","1","","","2021-01-27 07:16:17","","0","35","<p>I'm going to search for hashtags. The current code is now complete with the creation of a search bar. I am using RxSwift and Mvvm pattern. Here's the code I've been working on so far.How should I search for hashtags?</p>
<pre><code>
    func setUI() {
        self.searchBar = UISearchBar(frame: CGRect(x:300, y:0, width:300, height:20))

        searchBtn.rx.tap.subscribe(onNext: { _ in
            self.navigationItem.searchController = self.searchController
            self.navigationItem.hidesSearchBarWhenScrolling = false
            UIView.animate(withDuration: 0.25) {
                self.searchBar.frame = CGRect(x:0, y:0, width:300, height:20)

            }
        }).disposed(by: rx.disposeBag)

    }
</code></pre>
<p>This is ViewController.</p>
<pre><code>    private let disposeBag = DisposeBag()

    struct input {
        let loadData: Signal&lt;Void&gt;

    }

    struct output {
        let result: Signal&lt;String&gt;
        let loadApplyList: PublishRelay&lt;friends&gt;
    }

    func transform(_ input: input) -&gt; output {
        let api = SearchAPI()
        let result = PublishSubject&lt;String&gt;()
        let loadApplyList = PublishRelay&lt;friends&gt;()

        input.loadData.asObservable().subscribe(onNext: { [weak self] in
            guard let self = self else { return }
            api.getFriend().subscribe(onNext: { (response, statuscode) in
                switch statuscode {
                case .ok:
                    if let response = response {
                        loadApplyList.accept(response)
                    }
                default:
                    print(&quot;default&quot;)
                }
            }).disposed(by: self.disposeBag)
        }).disposed(by: disposeBag)

        return output(result: result.asSignal(onErrorJustReturn: &quot;&quot;), loadApplyList: loadApplyList)
    }
}
</code></pre>
<p>And this is viewModel</p>
","14063311","","","","","2021-01-27 07:16:17","How do I search for hashTag in SearchController?","<swift><search><rx-swift><hashtag>","0","2","","","","CC BY-SA 4.0"
"65931684","1","","","2021-01-28 05:50:16","","0","38","<p>I want to put the data in the collection view. This is part of my view controller code. I don't know what to put in &quot;for:&quot; of that code.</p>
<pre><code>    func bindViewModel() {
        let input = SearchViewModel.input(loadData: loadData.asSignal(onErrorJustReturn: ()))
        let output = viewModel.transform(input)

        output.loadApplyList.map(CollectionOfOne.init).bind(to: collectionView.rx.items) { collectionView, index, element -&gt; UICollectionViewCell in
            guard self.collectionView.dequeueReusableCell(withReuseIdentifier: &quot;friend&quot;, for: &lt;#IndexPath#&gt;) is FriendCell else {
                return FriendCell()
            }
        }

    }

</code></pre>
<p>I used this method when I bound the table view. Should I do a different collation view?</p>
","14063311","","","","","2021-01-28 05:50:16","CollectionView binding","<swift><uicollectionview><rx-swift>","0","1","","","","CC BY-SA 4.0"
"66000229","1","","","2021-02-01 21:14:11","","0","137","<p>I'm stuck on a Combine problem, and I can't find a proper solution for this.</p>
<p>My goal is to monitor a queue, and process items in the queue until it's empty. If then someone adds more items in the queue, I resume processing. Items needs to be processed one by one, and I don't want to lose any item.</p>
<p>I wrote a very simplified queue below to reproduce the problem. My items are modeled as just strings for the sake of simplicity again.</p>
<p>Given the contraints above:</p>
<ul>
<li>I use a <code>changePublisher</code> on the queue to monitor for changes.</li>
<li>A button lets me add a new item to the queue</li>
<li>The <code>flatMap</code> operator relies on the <code>maxPublishers</code> parameter to only allow one in-flight processing.</li>
<li>The <code>buffer</code> operator prevents items from being lost if the <code>flatMap</code> is busy.</li>
</ul>
<p>Additionally, I'm using a <code>combineLatest</code> operator to only trigger the pipeline under some conditions. For simplicity, I'm using a <code>Just(true)</code> publisher here.</p>
<p><strong>The problem</strong></p>
<p>If I tap the button, a first item goes in the pipeline and is processed. The <code>changePublisher</code> triggers because the queue is modified (item is removed), and the pipeline stops at the <code>compactMap</code> because the <code>peek()</code> returns <code>nil</code>. So far, so good. Afterwards, though, if I tap on the button again, a value is sent in the pipeline but <strong>never makes it through the <code>buffer</code></strong>.</p>
<p><strong>Solution?</strong></p>
<p>I noticed that removing the <code>combineLatest</code> prevents the problem from happening, but I don't understand why.</p>
<p><strong>Code</strong></p>
<pre><code>import Combine
import UIKit

class PersistentQueue {
    let changePublisher = PassthroughSubject&lt;Void, Never&gt;()

    var strings = [String]()

    func add(_ s: String) {
        strings.append(s)
        changePublisher.send()
    }

    func peek() -&gt; String? {
        strings.first
    }

    func removeFirst() {
        strings.removeFirst()
        changePublisher.send()
    }
}

class ViewController: UIViewController {

    private let queue = PersistentQueue()
    private var cancellables: Set&lt;AnyCancellable&gt; = []

    override func viewDidLoad() {
        super.viewDidLoad()
        start()
    }

    @IBAction func tap(_ sender: Any) {
        queue.add(UUID().uuidString)
    }

    /*
     Listen to changes in the queue, and process them one at a time. Once processed, remove the item from the queue.
     Keep doing this until there are no more items in the queue. The pipeline should also be triggered if new items are
     added to the queue (see `tap` above)
     */
    func start() {
        queue.changePublisher
            .print(&quot;Change&quot;)
            .buffer(size: Int.max, prefetch: .keepFull, whenFull: .dropNewest)
            .print(&quot;Buffer&quot;)
            // NOTE: If I remove this combineLatest (and the filter below, to make it compile), I don't have the issue anymore.
            .combineLatest(
                Just(true)
            )
            .print(&quot;Combine&quot;)
            .filter { _, enabled in return enabled }
            .print(&quot;Filter&quot;)
            .compactMap { _ in
                self.queue.peek()
            }
            .print(&quot;Compact&quot;)
            // maxPublishers lets us process one page at a time
            .flatMap(maxPublishers: .max(1)) { reference in
                return self.process(reference)
            }
            .sink { reference in
                print(&quot;Sink for \(reference)&quot;)

                // Remove the processed item from the queue. This will also trigger the queue's changePublisher,
                // which re-run this pipeline in case
                self.queue.removeFirst()
            }
            .store(in: &amp;cancellables)
    }

    func process(_ value: String) -&gt; AnyPublisher&lt;String, Never&gt; {
        return Future&lt;String, Never&gt; { promise in
            print(&quot;Starting processing of \(value)&quot;)
            DispatchQueue.global(qos: .userInitiated).asyncAfter(deadline: .now() + 2) {
                promise(.success(value))
            }
        }.eraseToAnyPublisher()
    }

}
</code></pre>
<p><strong>Output</strong></p>
<p>Here is a sample run of the pipeline if you tap on the button twice:</p>
<pre><code>Change: receive subscription: (PassthroughSubject)
Change: request max: (9223372036854775807)
Buffer: receive subscription: (Buffer)
Combine: receive subscription: (CombineLatest)
Filter: receive subscription: (Print)
Compact: receive subscription: (Print)
Compact: request max: (1)
Filter: request max: (1)
Combine: request max: (1)
Buffer: request max: (1)
Change: receive value: (())
Buffer: receive value: (())
Combine: receive value: (((), true))
Filter: receive value: (((), true))
Compact: receive value: (3999C98D-4A86-42FD-A10C-7724541E774D)
Starting processing of 3999C98D-4A86-42FD-A10C-7724541E774D
Change: request max: (1) (synchronous)
Sink for 3999C98D-4A86-42FD-A10C-7724541E774D // First item went through pipeline
Change: receive value: (())
Compact: request max: (1)
Filter: request max: (1)
Combine: request max: (1)
Buffer: request max: (1)
Buffer: receive value: (())
Combine: receive value: (((), true))
Filter: receive value: (((), true))

// Second time compactMap is hit, value is nil -&gt; doesn't forward any value downstream.

Filter: request max: (1) (synchronous)
Combine: request max: (1) (synchronous)
Change: request max: (1)

// Tap on button

Change: receive value: (())

// ... Nothing happens
</code></pre>
<p>[EDIT] Here is a much more constrained example, which can run in Playgrounds and which also demonstrates the problem:</p>
<pre><code>import Combine
import Foundation

import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true

func process(_ value: String) -&gt; AnyPublisher&lt;String, Never&gt; {
    return Future&lt;String, Never&gt; { promise in
        print(&quot;Starting processing of \(value)&quot;)
        DispatchQueue.global(qos: .userInitiated).asyncAfter(deadline: .now() + 0.1) {
            promise(.success(value))
        }
    }.eraseToAnyPublisher()
}

var count = 3

let s = PassthroughSubject&lt;Void, Never&gt;()

var cancellables = Set&lt;AnyCancellable&gt;([])

// This reproduces the problem. Switching buffer and combineLatest fix the problem…

s
    .print()
    .buffer(size: Int.max, prefetch: .keepFull, whenFull: .dropNewest)
    .combineLatest(Just(&quot;a&quot;))
    .filter { _ in count &gt; 0 }
    .flatMap(maxPublishers: .max(1)) { _, a in process(&quot;\(count)&quot;) }
    .sink {
        print($0)
        count -= 1
        s.send()
    }
    .store(in: &amp;cancellables)

s.send()

Thread.sleep(forTimeInterval: 3)

count = 1
s.send()
</code></pre>
<p>Switching combine and buffer fixes the problem.</p>
","283899","","283899","","2021-02-02 08:41:14","2021-04-18 09:08:27","Why is this Combine pipeline not letting items through?","<ios><swift><rx-swift><combine>","2","7","","","","CC BY-SA 4.0"
"66017998","1","66027793","","2021-02-02 21:36:39","","1","37","<p>Given an array of urls, is there a way to run those at once simultaneously? But in such a way so as soon as there is one success move to the next request using that successful url.</p>
<p>So far I tried chaining <code>concatMap</code>, and failed with <code>zip</code>.</p>
<pre><code>func updateAccountInfo() -&gt; Single&lt;Bool&gt; {
    
    var disposable: Disposable? = nil
    
    return Single&lt;Bool&gt;.create { observer in
      
      do {
        
        var urls = try self.settings.domains.value()
        
        disposable = Observable.from(urls)
          .enumerated()
          .concatMap { index, url -&gt; Single&lt;URL&gt; in
            return self.verifyUrl(url)
          }
          .concatMap { url -&gt; Single&lt;Account&gt; in
            return self.apiManager.loadAccountInfo(from: url)
          }
          .observeOn(MainScheduler.instance)
          .do(onNext: { (account: AccountInfo) in
            // use account unfo here
            disposable!.dispose()
          })
          .subscribe()
        
      } catch {
        observer(.error(error))
      }
      
      return Disposables.create()
    }
  }
</code></pre>
<p>Tried like so too:</p>
<pre><code>disposable = Observable.from(urls)
          .enumerated()
          .concatMap { index, url -&gt; Single&lt;(Bool, URL)&gt; in
            return self.verifyUrl(url)
          }
          .subscribe(onNext: { reachable, url in
            if reachable {

              self.apiManager.loadAccountInfo(from: url)
                .subscribe(onSuccess: { accountInfo in
                  
                  // use account info here

                }, onError: { error in
                  
                })
                .disposed(by: self.bag)

              disposable!.dispose()
            } else {
              
            }
          }, onError: { error in
            
          }, onCompleted: {
          
          })
</code></pre>
<p>Maybe I use zip but how would I create an array of <code>verifyUrl(url)</code> calls? Does <code>zip</code> accept arrays of <code>Observable</code> at all?</p>
<pre><code>let obs = Observable.from(urls)
          .enumerated()
          .concatMap { index, url -&gt; Single&lt;URL&gt; in
            return self.verifyUrl(url)
          }
        
        let test = Observable
        .zip(obs).map { [urls] in 
          return [urls]
        }
</code></pre>
","4355527","","","","","2021-02-03 12:42:32","Run multiple request at a time and continue as soon there is success","<swift><rx-swift><moya>","1","0","","","","CC BY-SA 4.0"
"66018892","1","","","2021-02-02 23:06:18","","1","244","<p>For using <a href=""https://github.com/Juanpe/SkeletonView"" rel=""nofollow noreferrer"">SkeletonView</a> you have to implement <code>UITableView/UICollectionView dataSource</code> which i can't use beacuse i'm using <code>tableView.rx.items</code> to bind my table to some observable. so how can i use <code>RxCocoa</code> besides <code>SkeletonView</code>.</p>
<p>any suggestion?</p>
<p>For more info: <code>RxSkeleton</code> library is not good idea for a non-RxDataSourced tableView</p>
","7861886","","","","","2021-02-03 12:52:40","How to use SkeletonView besides UITableView/UICollectionView RxCocoa binding","<ios><rx-swift><rx-cocoa><skeleton-ui>","1","0","","","","CC BY-SA 4.0"
"66024180","1","","","2021-02-03 08:57:15","","0","50","<pre><code>func bindTableView(){
    let cities = [&quot;London&quot;, &quot;Vienna&quot;, &quot;Lisbon&quot;]
            let citiesOb: Observable&lt;[String]&gt; = Observable.of(cities)

    citiesOb.bind(to: tableView.rx.items) { (tableView: UITableView, index: Int, element: String) -&gt; UITableViewCell in
        guard let cell = tableView.dequeueReusableCell(withIdentifier: &quot;cell&quot;) else { return UITableViewCell()}

    cell.textLabel?.text = element

    return cell
    }.disposed(by: bag)
}
</code></pre>
<p>I want to make TableView with RxSwift, it but occurs this error.</p>
<pre><code>Thread 1: Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value
</code></pre>
<p>I can't find what's the problem :(</p>
<p><img src=""https://i.stack.imgur.com/aWfvA.png"" alt=""A screenshot of the error"" /></p>
","15136199","","8080648","","2021-02-03 20:31:58","2021-02-03 20:31:58","TableView using RxSwift","<swift><rx-swift>","0","1","","","","CC BY-SA 4.0"
"66034093","1","","","2021-02-03 19:05:17","","0","30","<p>I have two independent observables. I need to perform some operation when both of them are complete and each of them provided an array.</p>
<pre><code>let myObj1Array = myObj1Manager.getMyObj1List()//returns Observable&lt;[MyObj1]&gt;
let myObj2Array = myObj2Manager.getMyObj2List()//returns Observable&lt;[MyObj2]&gt;
</code></pre>
<p>Now I need to compare values of myObj1Array and myObj2Array and on the basis of that create another array using values from both arrays. I know how to subscribe 1 variable but not sure how to observe completion of two different arrays.</p>
<p><strong>Edit:</strong>
I also tried following but I get values only from first array:</p>
<pre><code>let myObj1Array = myObj1Manager.getMyObj1List()
        let myObj2Array = myObj1Array.flatMap { _ in myObj2Manager.getMyObj2List() }
        Observable.combineLatest(myObj1Array, myObj2Array)
        .subscribe(onNext: { (sss, sds) in
            print(sss)
        })
        .addDisposableTo(disposeBag)
</code></pre>
<p>I am actually kind of clueless about how to handle such scenario.</p>
<p><strong>Edit2:</strong>
function to get the observables in first array:</p>
<pre><code>func getMyObj1List() -&gt; Observable&lt;[MyObj1]&gt; {
        return Observable.create { observer -&gt; Disposable in
            self.specialsRest.getMyObj1List { response, error in
                if let error = error {
                    observer.onError(Exception(error))
                    return
                }
                guard let saleItems = MyObj1.decode(data: response?.data) else {
                    observer.onError(Exception(&quot;Could not decode specials!&quot;))
                    return
                }
                queueBackground.async {
                   
                    observer.onNext(saleItems)
                    observer.onCompleted()
                }

            }
            return Disposables.create { self.specialsRest.cancel() }
        }
    }
</code></pre>
","9692737","","9692737","","2021-02-03 19:22:45","2021-02-03 19:54:25","Get values from two apis into two different Observable and perform some operation","<ios><swift><rx-swift>","2","1","","","","CC BY-SA 4.0"
"66132656","1","66137271","","2021-02-10 07:35:23","","1","65","<p>In my ViewModel file I have an observable array created after applying map on it. Now before returning it I want to check if it has any content or not. If there is nothing in there I want to return it without applying map. Following is my code:</p>
<pre><code>func retrieveDeals(location: CLLocation?) -&gt; Observable&lt;[SaleItem]&gt; {
    let specials = nearestFlightSpecials.retrieveNearestFlightSpecials(userLocation: location)
    let happyHourDeals = specials.map {
        $0.filter { $0.isHappyHour }
    }
    return happyHourDeals
}
</code></pre>
<p>Before I return happyHourDeals I want to check if it contains any element or not. The above array is subscribed in view but I don't want to apply the above logic there. I want to keep it here in ViewModel.</p>
","9692737","","","","","2021-02-10 12:52:46","Get count of Observable array before returning it","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"66140869","1","66141084","","2021-02-10 16:26:46","","2","37","<p>With swift compiler optimizations implicitly unwrapped optional variables do not survive the whole scope, but are released immediately after usage.</p>
<p>Here is my environment:</p>
<pre><code>swift --version
</code></pre>
<p>outputs</p>
<pre><code>Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
Target: x86_64-apple-darwin20.2.0
</code></pre>
<p>Xcode version is <code>Version 12.3 (12C33)</code></p>
<p>Consider this most rudimentary example that shows the issue:</p>
<pre class=""lang-swift prettyprint-override""><code>final class SomeClass {
    
    func doSth() {}
    
    deinit {
        print(&quot;deinit&quot;)
    }
}

func do() {
    var someObject: SomeClass! = SomeClass()

    someObject.doSth()
    
    print(&quot;done&quot;)
}
</code></pre>
<p>This should ouput</p>
<pre><code>done
deinit
</code></pre>
<p>However, in release builds (with Swift code optimizations enabled &quot;-O&quot;) it prints the other way round:</p>
<pre><code>deinit
done
</code></pre>
<p>This is ONLY the case for <code>var someObject: SomeClass!</code>.</p>
<p>The following alterations of that code ALL output correctly (meaning the Object is released when the scope of the function is left):</p>
<p>Define var as constant:</p>
<pre class=""lang-swift prettyprint-override""><code>func doSthSpecial() {
    let someObject: SomeClass! = SomeClass()

    someObject.doSth()
    
    print(&quot;done&quot;)
}
</code></pre>
<p>Define var as optional explicitly:</p>
<pre class=""lang-swift prettyprint-override""><code>func doSthSpecial() {
    var someObject: SomeClass? = SomeClass()

    someObject.doSth()
    
    print(&quot;done&quot;)
}
</code></pre>
<p>Access like an optional:</p>
<pre class=""lang-swift prettyprint-override""><code>func doSthSpecial() {
    var someObject: SomeClass! = SomeClass()

    someObject?.doSth()
    
    print(&quot;done&quot;)
}
</code></pre>
<p>These last three implementations all output</p>
<pre><code>done
deinit
</code></pre>
<p>in that order.</p>
<p>Somehow this leaves me speechless 🤷‍♂️.
I understand this optimization, it makes sense. But as a programmer we are used to local variables inside of functions being available until leaving the scope.</p>
<p>The problem I have here is about the lifetime of an object that is stored in such an implicitly unwrapped optional variable. If I have code that depends on the lifetime of this object (which is the case with <code>RxSwift</code> and its <code>DisposeBag</code>s for example) then I am getting weird behavior, unexpected behavior!</p>
<p>I could consider this as a bug in Swift, but what do you think? Bug or no bug?</p>
<p>Here is a more real-world scenario with <code>RxSwift</code> where you could be using such a construct:</p>
<pre class=""lang-swift prettyprint-override""><code>import UIKit
import RxSwift

final class SomeClass {
    
    func doSth() {}
    
    deinit {
        print(&quot;deinit&quot;)
    }
}

class ViewController: UIViewController {
    
    let providePassword = PublishSubject&lt;String&gt;()
    lazy var askForPassword: Observable&lt;String&gt; = {
        return Observable.create { observer in
            _ = self.providePassword.subscribe(observer)
            
            return Disposables.create()
        }
        .debug(&quot;&gt;&gt;&gt; ask for password signal&quot;)
    }()

    private func performAsyncSyncTask() {
        DispatchQueue.global().async {
            var disposeBag: DisposeBag! = DisposeBag()
            
            let sema = DispatchSemaphore(value: 0)
            
            self.askForPassword
                .subscribe(onNext: { pw in
                    print(pw)
                    sema.signal()
                })
                .disposed(by: disposeBag)
                    
            _ = sema.wait(timeout: DispatchTime.distantFuture)
            
            disposeBag = nil
        }
    }
    
    @IBAction func startAskPassword(sender: AnyObject) {
        self.performAsyncSyncTask()
    }
    
    @IBAction func sendPassword(sender: AnyObject) {
        self.providePassword.on(.next(&quot;hardcoded pw&quot;))
    }
}
</code></pre>
<p>The problem here is: When executing <code>self.performAsyncSyncTask()</code> it is subscribed to <code>askForPassword</code> but because in optimized builds the implicitly unwrapped optional variable is purged immediately after using it in <code>.disposed(by: disposeBag)</code>.</p>
<p>This destroys the signal immediately after subscribing to it.</p>
","1340499","","1340499","","2021-02-10 16:39:38","2021-02-10 16:53:21","Implicitly unwrapped optional var destroyed by compiler before end of scope?","<swift><variables><scope><rx-swift>","1","0","","","","CC BY-SA 4.0"
"66172836","1","66175575","","2021-02-12 13:35:51","","0","46","<p>I have several <code>completable rx subscriptions</code> in a stream like this:</p>
<pre><code>viewModel?.setupDoorMode().subscribe(onNext: { shouldConnectToDoor in
    if shouldConnectToDoor {
         self.viewModel?.connectAndOpenDoor().subscribe(onCompleted: {
             self.viewModel?.openOrCloseDoor().subscribe().disposed(by: self.disposeBag)
         }).disposed(by: self.disposeBag)
    } else {
         self.viewModel?.openOrCloseDoor().subscribe().disposed(by: self.disposeBag)
    }
}).disposed(by: disposeBag)
</code></pre>
<p>I have the feeling that this can be done in a nicer way, like flatMaping the streams into oneanother. But when I try using <code>flatMap</code> I get the error <code>Type '()' cannot conform to 'ObservableConvertibleType'; only struct/enum/class types can conform to protocols</code>. I'm not too familiar with <code>rx</code> to understand that message. Anyway, is there a way to create a more smooth looking stream rather than three <code>subscriptions</code> in a row?</p>
","8591381","","","","","2021-02-12 16:33:49","Can I flatMap into other streams with completables?","<ios><swift><rx-swift><flatmap>","1","2","","","","CC BY-SA 4.0"
"66197668","1","66197934","","2021-02-14 16:46:27","","0","34","<p>I have the following Model</p>
<pre class=""lang-swift prettyprint-override""><code>final class Vehicle {
var cars:[SportsCar] = []
}

final class SportsCar {
var isCheap:Bool = false
}

</code></pre>
<p>Assumming that Vehicle &amp; SportsCar are both Equatable (I Have ommited Equatable conformance for simplicity).</p>
<p><strong>Goal:</strong> Update isCheap property of one of the  cars embedded in cars array nested inside Vehicles BehaviorRelay relay.</p>
<p><strong>Attempts:</strong></p>
<pre class=""lang-swift prettyprint-override""><code>final class ViewModel {
    let vehicles:BehaviorRelay&lt;[Vehicle]&gt; = BehaviorRelay(value: [])
    // Attempt 1: Access vehicles direct without making a copy.
    
    // Toggling `isCheap` property when user tap a button on a collectionView cell.
    func updateCarProperty(checkedVehicle:Vehicle,checkedIndexPath:IndexPath){
        for car in vehicles.value[checkedIndexPath.section].cars {
            let checkedCar = checkedVehicle.cars[checkedIndexPath.item]
            if car == checkedCar {
                if car.isCheap {
                    vehicles.value[checkedIndexPath.section].cars[checkedIndexPath.item].isCheap = false
                }else {
                    vehicles.value[checkedIndexPath.section].districts[checkedIndexPath.item].isCheap = true
                }
                break
            }
        }
    }
    
}


// Attempt 2: Make a copy of vehicles then use it to change the property then on completion update the whole vehicles array by calling
//vehicles.accept(vehiclesCopy)
// As described on this answer: https://stackoverflow.com/a/58295908/7551807
// This approach didn't work too.
</code></pre>
<p><strong>Expectation:</strong> Car isCheap property to change when the function call finished.</p>
<p><strong>Result:</strong> The property doesn't change as expected 😢. It just remain as the default value (false) no matter what!!</p>
<p><strong>Question:</strong> Is there any other better way to deal with this issue?</p>
","7551807","","7551807","","2021-02-14 16:56:51","2021-02-14 17:09:57","Best way to update nested property in BehaviourRelay","<rx-swift><rx-cocoa>","1","0","","","","CC BY-SA 4.0"
"66242247","1","","","2021-02-17 12:47:41","","0","86","<p>I have created a <code>tableView</code> using <code>rx swift</code> and it works fine save for one thing: if I press a <code>cell</code> as soon as I enter the <code>view</code> nothing happens. I added a print in <code>.modeSelected</code> and it didn't register. If I wait approximately half a second to a second, then press again, it works fine. This makes the user experience feel like you have to double-tap for the action to take effect.</p>
<pre><code>@IBOutlet weak var tableView: UITableView! {
    didSet {
        tableView.rx.modelSelected(SettingsTableViewCellViewModel.self).subscribe(onNext: { [weak self] cellViewModel in
            print(&quot;THIS TRIGGERS ONLY IF YOU CLICK AFTER 0.5-1 SEC&quot;)
            //STUFF HAPPENS
        }).disposed(by: disposeBag)
    }
</code></pre>
<p>As <code>modeSelected</code> is inside the <code>didSet</code> of the <code>tableView</code> I know that the <code>tableView</code> is done with its thing and all the data is available. I tried setting <code>tableView.delaysContentTouches</code> to <code>false</code> and made sure that <code>tableView.isUserInteractionEnabled</code> was set to <code>true</code>.</p>
<p>This is how the content that is accepted:</p>
<pre><code>func reloadContent() {
    let allContent = [SettingsTableViewCellViewModel(title: &quot;active_errors&quot;.localized(),
                                                     segue: &quot;ErrorsSegue&quot;,
                                                     shouldBeShown: { return DoorConnectionStatus.connected == self.statusRelay?.value.status }),
                      SettingsTableViewCellViewModel(title: &quot;events&quot;.localized(),
                                                     segue: &quot;EventStatusSegue&quot;,
                                                     shouldBeShown: { return DoorConnectionStatus.connected == self.statusRelay?.value.status }),
                      SettingsTableViewCellViewModel(title: &quot;event_log&quot;.localized(),
                                                     segue: &quot;EventLogSegue&quot;,
                                                     shouldBeShown: { return DoorConnectionStatus.connected == self.statusRelay?.value.status }),
                          
                      //...and it keeps going
    ]
    content.accept(allContent.filter { $0.shouldBeShown() == true })
}
</code></pre>
<p>And then bound to the <code>tableView</code>:</p>
<pre><code>viewModel.content.bind(to: tableView.rx.items(cellIdentifier: SettingsTableViewCell.identifier, cellType: SettingsTableViewCell.self)) { _, data, cell in
    cell.viewModel = data
}.disposed(by: disposeBag)
</code></pre>
","8591381","","8591381","","2021-02-18 08:16:53","2021-02-26 12:27:05","Why isn't my rx tableview instantly responsive?","<ios><swift><tableview><rx-swift>","2","4","","","","CC BY-SA 4.0"
"66260748","1","","","2021-02-18 13:17:13","","0","115","<p>The solution for the above problem is pretty simple using approaches listed here:
<a href=""https://stackoverflow.com/questions/43566414/present-a-view-controller-dismiss-it-and-present-a-different-one-in-swift"">Present a view controller, dismiss it and present a different one in Swift</a></p>
<p>However, I wish to achieve the same using the RXFlow framework. I am not sure how should I do it.</p>
<p>So, I have two controllers <strong>A</strong> and <strong>SuccessMatchViewController</strong>. Its pretty simple to present <strong>SuccessMatchViewController</strong> from <strong>A</strong>. But on a tap of button in <strong>SuccessMatchViewController</strong>, I need to dismiss this controller and present a third one, let say <strong>C</strong>. I am not sure how to achieve that.</p>
<p>Below is the code for my <strong>SuccessfulMatchFlow</strong>.</p>
<pre><code>enum SuccessfulMatchFlowStep: Step {
  case start(partner: ZuylUser, currentUser: ZuylUser)
  case dismiss
}

class SuccessfulMatchFlow: Flow {
    var root: Presentable {
    rootViewController
}

private var rootViewController: MatchesSuccessViewController = {
    let root = MatchesSuccessViewController.loadController(from: .match)
    root.modalPresentationStyle = .fullScreen
    return root
}()

func navigate(to step: Step) -&gt; FlowContributors {
    guard let step = step as? SuccessfulMatchFlowStep else { return .none }

    switch step {
        case .start(let partner, let currentUser):
            return navigateToMatchSuccess(partner: partner, currentUser: currentUser)
        case .dismiss:
            return dismiss()
    }
}

private func navigateToMatchSuccess(partner: ZuylUser, currentUser: ZuylUser) -&gt; FlowContributors {
    rootViewController.modalPresentationStyle = .fullScreen
    rootViewController.modalTransitionStyle = .crossDissolve
    rootViewController.partner = partner
    rootViewController.currentUser = currentUser
    return .one(flowContributor: .contribute(withNext: rootViewController))
}

private func dismiss() -&gt; FlowContributors {
    rootViewController.dismiss(animated: true, completion: nil)
    /// Here I need to present a different Controller
    return .end(forwardToParentFlowWithStep: MatchStep.connect)
}
}
</code></pre>
","3730935","","","","","2021-02-18 13:17:13","RXFlow: Present a view controller, dismiss it and present a different one in Swift","<ios><swift><reactive-programming><rx-swift>","0","0","","","","CC BY-SA 4.0"
"66273469","1","66279830","","2021-02-19 07:37:14","","1","148","<p><strong>My actual requirement:</strong></p>
<p>I have a list of custom objects, and I want to iterate it with a delay. I can't use <code>DispatchQueue.main.asyncAfter</code> in my <code>for</code> loop since my iterations create a <code>CoreData</code> object that triggers <code>FetchedResultController</code> and hence updates my <code>TableView</code>. Anyway, so I tried using Rx to iterate my list with a delay of 1 second each. But I am unable to do so.</p>
<p><strong>Question</strong></p>
<p>I want to delay the iteration of each element of the array using RxSwift.
I was able to do it in Java, but couldn't do so in RxSwift.</p>
<p>the <code>.delay()</code> operator didn't help either, it just delayed the whole process.</p>
<p>Any example would help, thus I am not posting any specific code... but this is what I've been trying so far</p>
<pre><code>var array = [1, 2, 3, 4, 5]

Observable.from(array)
  .delay(RxTimeInterval(5), scheduler: MainScheduler.instance)
  .subscribe { (intValue) in
    print(&quot;onNext() \(intValue)&quot;)
}
</code></pre>
<p>Output</p>
<pre><code>onNext() next(1)
onNext() next(2)
onNext() next(3)
onNext() next(4)
onNext() next(5)
onNext() completed
</code></pre>
<p>The output gets printed after 5 seconds, not with 5 seconds interval.</p>
<p>I am not getting any integer values, but a <code>next(1)</code>.</p>
","8164116","","8164116","","2021-02-19 08:04:43","2021-02-19 15:11:43","Delay iteration of an collection in RxSwift","<swift><rx-swift>","1","4","","","","CC BY-SA 4.0"
"66333444","1","66341175","","2021-02-23 12:49:26","","1","43","<p>I have a refreshTrigger and BehaviourRelay of items:</p>
<pre><code>var refreshTrigger = PublishSubject&lt;Void&gt;()
var rootItems: BehaviorRelay&lt;[Codable]&gt; = BehaviorRelay(value: [])
</code></pre>
<p>Then, I use UITextField to run search query when user enters text:</p>
<pre><code>let queryText = queryTextField.rx.text.orEmpty
        .throttle(.milliseconds(300), scheduler: MainScheduler.instance)
        .distinctUntilChanged()
</code></pre>
<p>Finally, I have an observable which combines this observable with additional trigger to refresh manually:</p>
<pre><code>let refreshText = refreshTrigger.withLatestFrom(queryText)
Observable.merge(refreshText, queryText)
        .flatMapLatest { [weak self] query -&gt; Observable&lt;[Codable]&gt; in
            guard let strongSelf = self else { return .empty() }
            
            let ctgs = try strongSelf.getCategories()
                .startWith([])
                .catchErrorJustReturn([])
            
            let itms = try strongSelf.getSearchResults(query)
                .retry(3)
                .startWith([])
                .catchErrorJustReturn([])
            
            return Observable.merge(ctgs, itms)
        }
        .bind(to: rootItems)
        .disposed(by: disposeBag)
</code></pre>
<p>As you can see, I want to send 2 requests: fetch categories and items, because I'm displaying them in the same UITableView. It sends both requests at the same time, but first result disappear when the second comes in. But I use merge, so it should work.</p>
<p>Why it doesn't show combined results?</p>
<p>Headers of the getCategories and getSearchResults looks like this:</p>
<pre><code>func getSearchResults(_ text: String) throws -&gt; Observable&lt;[Codable]&gt; 

func getCategories() throws -&gt; Observable&lt;[Codable]&gt; 
</code></pre>
<p>they both use alamofire's rx extension to run queries.</p>
","1264375","","","","","2021-02-23 21:12:20","RxSwift merge two api request into one result clears first result","<ios><alamofire><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"66367805","1","67175627","","2021-02-25 11:42:34","","0","210","<p>An overview of what I am trying to achieve I am trying to make a notifications tableview and each notification is group by its created date, so the tableview sections will be the number of created date, each section with the notifications created at this date in the section title.
I have searched a lot but didn't get an absolute answer how to make with RxDataSource
the array is dynamic get loaded with dates received through an API?</p>
<pre><code>class T : UITableViewDataSource {
    func numberOfSections(in tableView: UITableView) -&gt; Int {
        return array.count
    }
}
</code></pre>
<p>All what I have found is to set the sections static like so</p>
<pre><code>       ViewModel.AllNotificationsObservable
                .map({ [NotificationSectionViewModel(header: &quot;Yet&quot;, items: $0.filter{$0.createAt.toDate()!.toString(format: &quot;yyyy-MM-dd&quot;) == Date().toString(format: &quot;yyyy-MM-dd&quot;) }),
                        NotificationSectionViewModel(header: &quot;Yesterday&quot;, items: $0)
                ]
                })
                .bind(to: NotificationTableView.rx.items(dataSource: ViewModel.dataSource))
                .disposed(by: notificationDisposeBag)

</code></pre>
<p>this is my struct</p>
<pre><code>struct NotificationSectionViewModel {
    var header: String
    var items: [AllNotificationModel] 
}
extension NotificationSectionViewModel: SectionModelType {
    typealias NotificationItem = AllNotificationModel
    
    init(original: NotificationSectionViewModel, items: [AllNotificationModel]) {
        self = original
        self.items = items
    }
}
</code></pre>
<p>and this the data model</p>
<pre><code>class AllNotificationModel : Codable {
    
    let id, userID : Int
    let title, body, createAt: String
    
    enum CodingKeys: String, CodingKey {
        case id, title, body
        case userID = &quot;user_id&quot;
        case createAt = &quot;create at&quot;
    }
}
</code></pre>
<p>what I am trying to achieve</p>
<p><a href=""https://i.stack.imgur.com/u7gtk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/u7gtk.png"" alt=""enter image description here"" /></a></p>
<p>need header to be like this</p>
<pre><code>“Today”: [
        {
            &quot;id&quot;: 2421,
            &quot;user_id&quot;: 39,
            &quot;title&quot;: &quot;todayNotification&quot;,
            &quot;body&quot;: &quot;test&quot;,
            &quot;create at&quot;: &quot;2021-02-26 17:33:44&quot;
        },
        {
            &quot;id&quot;: 2349,
            &quot;user_id&quot;: 39,
            &quot;title&quot;: &quot;check&quot;,
            &quot;body&quot;: &quot;test&quot;,
            &quot;create at&quot;: &quot;2021-02-26 09:36:05&quot;
        },
        {
            &quot;id&quot;: 2206,
            &quot;user_id&quot;: 39,
            &quot;title&quot;: &quot;New Deal&quot;,
            &quot;body&quot;: &quot;new Deal 2&quot;,
            &quot;create at&quot;: &quot;2021-02-26 13:43:16&quot;
        } ]
“Yesterday”: [
        {
            &quot;id&quot;: 2134,
            &quot;user_id&quot;: 39,
            &quot;title&quot;: &quot;Closed Deal&quot;,
            &quot;body&quot;: “deal deal”,
            &quot;create at&quot;: &quot;2021-02-25 13:21:30&quot;
        } ]

“2021-02-24”: [
        {
            &quot;id&quot;: 2134,
            &quot;user_id&quot;: 39,
            &quot;title&quot;: &quot;Closed Deal&quot;,
            &quot;body&quot;: “deal”,
            &quot;create at&quot;: &quot;2021-02-24 13:21:30&quot;
        },
        {
            &quot;id&quot;: 2063,
            &quot;user_id&quot;: 39,
            &quot;title&quot;: &quot;New Deal&quot;,
            &quot;body&quot;: &quot;new Deal&quot;,
            &quot;create at&quot;: &quot;2021-02-24 13:21:16&quot;
        }]
</code></pre>
","8397675","","8397675","","2021-02-27 06:55:18","2021-04-20 08:55:13","How to make Dynamic sections with RxDataSource?","<ios><swift><rx-swift><rxdatasources>","2","0","0","","","CC BY-SA 4.0"
"66428253","1","","","2021-03-01 19:14:48","","1","55","<p>I am aware that using Rx's <code>flatmap</code> or <code>flatmapLatest</code> is preferable to having nested subscriptions. However, I can't find a compelling reason why nested subscription calls &quot;should be avoided at all costs&quot; (<a href=""https://github.com/ReactiveX/RxSwift/blob/main/Documentation/Tips.md"" rel=""nofollow noreferrer"">RxSwift Github Tips</a>), and want to understand why.</p>
<p>Any insight into the specific issue(s) besides &quot;bad code smell&quot;?</p>
<p>Example (<a href=""https://github.com/ReactiveX/RxSwift/blob/main/Documentation/Tips.md"" rel=""nofollow noreferrer"">source</a>):</p>
<p><strong>Using nested subscription (bad)</strong></p>
<pre class=""lang-swift prettyprint-override""><code>textField.rx.text.subscribe(onNext: { text in
    performURLRequest(text).subscribe(onNext: { result in
        ...
    })
    .disposed(by: disposeBag)
})
.disposed(by: disposeBag)
</code></pre>
<p><strong>Using flatmapLatest (good)</strong></p>
<pre class=""lang-swift prettyprint-override""><code>textField.rx.text
    .flatMapLatest { text in
        // Assuming this doesn't fail and returns result on main scheduler,
        // otherwise `catchError` and `observeOn(MainScheduler.instance)` can be used to
        // correct this.
        return performURLRequest(text)
    }
    ...
    .disposed(by: disposeBag) // only one top most disposable
</code></pre>
","3370254","","","","","2021-03-02 02:16:55","Avoiding nested Rx subscription calls - what is the reasoning?","<ios><swift><system.reactive><rx-swift>","2","0","","","","CC BY-SA 4.0"
"66468911","1","","","2021-03-04 05:08:06","","0","32","<p>I'm going to search for names and hashtags through the search function. I want to show the collection view when I search the name. But I don't know how to do it. I am using RxSwift and MVVM pattern.</p>
<pre><code>        let input = SearchViewModel.input(searchName: searchBar.searchTextField.rx.text.orEmpty.asDriver(), doneTap: searchBtn.rx.tap.asDriver())
        let output = viewModel.transform(input)
        
        output.searchResult.emit(onCompleted: {
            guard let vc = self.storyboard?.instantiateViewController(identifier: &quot;search&quot;) as?  SearchViewController else { return }
            
        }).disposed(by: disposeBag)
</code></pre>
<p>This is my viewController Code.</p>
<pre><code>    private let disposeBag = DisposeBag()
//    static var loadData = PublishRelay&lt;friends&gt;()

    struct input {
       // let loadData: Signal&lt;Void&gt;
        let searchName: Driver&lt;String&gt;
        let doneTap: Driver&lt;Void&gt;
    }

    struct output {
        let result: Signal&lt;String&gt;
        let searchResult: Signal&lt;String&gt;
    }

    func transform(_ input: input) -&gt; output {
        let api = SearchAPI()
        let result = PublishSubject&lt;String&gt;()
        let searchResult = PublishSubject&lt;String&gt;()


        input.doneTap.asObservable().withLatestFrom(input.searchName).subscribe(onNext: { userName in
            api.getUserList(userName).subscribe(onNext: {  (response, statuscode) in
                switch statuscode {
                case .ok:
                    searchResult.onCompleted()
                case .noHere:
                    searchResult.onNext(&quot;no result&quot;)
                default:
                    print(&quot;default&quot;)
                }
            }).disposed(by: self.disposeBag)
        }).disposed(by: disposeBag)
        
     
      

        return output(result: result.asSignal(onErrorJustReturn: &quot;&quot;),searchResult: searchResult.asSignal(onErrorJustReturn: &quot;&quot;))
    }
}
```
This is my ViewModel code.

What should be included in the view controller output?
</code></pre>
","14063311","","","","","2021-03-04 05:08:06","Search name with swift","<swift><rx-swift>","0","1","","","","CC BY-SA 4.0"
"66490911","1","","","2021-03-05 10:31:57","","3","314","<p>I have a problem with Xcode 12.0. I'm trying to make a switch to XCFrameworks using Carthage <code>--use-xcframeworks</code>. Carthage build is a success, I can switch fat libraries to XCFrameworks and make App targets build and run. The problem is with testing. When I'm adding Quick, RxTesting, or RxBlocking to test targets it doesn't build, Xcode doesn't see symbols.
I have found a problem on RxSwift git: <a href=""https://github.com/ReactiveX/RxSwift/issues/2292"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/RxSwift/issues/2292</a>
Maybe someone made it work and successfully switched to XCFrameworks.</p>
","2762874","","","","","2021-03-05 10:31:57","Xcode 12.0 - XCFrameworks not working in test target","<swift><xcode><rx-swift><xctest><xcframework>","0","1","1","","","CC BY-SA 4.0"
"66497740","1","66497925","","2021-03-05 18:26:56","","0","47","<p>In the Button action, I call <code>getLatLongValues</code> method, It will return completion property after API success.</p>
<p>Hear problem is, If I click <strong>N</strong> th times in button action, <code>getLatLongValues</code> method execute <strong>N</strong> times.<br>
Like I click the button in 1st time <code>getLatLongValues</code> execute 1 time, I'm click 2nd time not two times <code>getLatLongValues</code> method execute 2 times.</p>
<pre><code>@IBAction func updateDeliveryAddress() {
    guard let address = self.addressTextField.text else { return }
    self.getLatLongValues(address, true, viewModel) { success in
        if success {
            //Success
        } else {
            // Error
        }
    }
}

func getLatLongValues(address: String, setAsDefault: Bool, viewModel:ViewModel, completion: @escaping (_ success: Bool) -&gt; Void) {
    viewModel.location.subscribe(onNext: { [weak self] results in
        guard self != nil else { return }
        if let result = results {
                completion(true) // Success
        }
    }).disposed(by: disposeBag)
    viewModel.fetchLocation(address: address)
}
</code></pre>
<p>Why <code>getLatLongValues</code> Execute <strong>N</strong> times?</p>
","8079610","","8079610","","2021-03-05 18:30:59","2021-03-05 18:44:41","Completion Handler Call N times","<ios><swift><swift5><rx-swift><completionhandler>","2","3","","","","CC BY-SA 4.0"
"66508048","1","66512989","","2021-03-06 16:37:29","","1","94","<p>There is a textfield with validation using RXSwift. I want to disable validation based on switch action.</p>
<pre><code> // Start Time
 startTimeValid = startTimeTextfield.rx.text.orEmpty.map{
            $0.count &gt; 0
  }

 // End time
 endTimeValid = endTimeTextfield.rx.text.orEmpty.map{
            $0.count &gt; 0
 }

 everythingValid = Observable.combineLatest(startTimeValid,endTimeValid){ $0 &amp;&amp; $1 }
        

 endTimeValid.bind(to: endTimeErrorLabel.rx.isHidden).disposed(by: bag)
 startTimeValid.bind(to: startTimeErrorLabel.rx.isHidden).disposed(by: bag)
 everythingValid.bind(to: createButton.rx.isEnabled).disposed(by: bag)

        
 createButton.rx.tap.subscribe(onNext:{

            print(&quot;success&quot;)

        }).disposed(by: bag)
</code></pre>
<p>so in above code End time and start time textfields both are being validated. Based on boolean i need to disable validation for EndTime Textfield.</p>
<p>The code i tried:</p>
<pre><code> @objc func endDateRequired(_ aSwitch : UISwitch){

        
        if aSwitch.isOn{

            everythingValid = Observable.combineLatest(eventTitleValid, startDateValid, endDateValid){ $0 &amp;&amp; $1 &amp;&amp; $2
            }
            everythingValid.bind(to: createButton.rx.isEnabled).disposed(by: bag)
       
        }else{
            
            everythingValid = Observable.combineLatest(eventTitleValid, startDateValid, endDateValid, startTimeValid,endTimeValid){ $0 &amp;&amp; $1 &amp;&amp; $2 &amp;&amp; $3 &amp;&amp; $4
            }
            everythingValid.bind(to: createButton.rx.isEnabled).disposed(by: bag)

        }
        
    }
</code></pre>
<p>I am trying to make it simplified in reactive style.</p>
","3766168","","3766168","","2021-03-06 16:51:15","2021-03-07 19:38:25","if else condition in RXSwift","<ios><uitextfield><rx-swift>","2","0","","","","CC BY-SA 4.0"
"66546715","1","","","2021-03-09 12:17:25","","1","53","<p>I am combining some Observables and I would like to skip anyone that returns an error so that the Observable can run completely</p>
<pre><code>let observable = Observable.combineLatest(
            remoteRepository.getxx1(),
            remoteRepository.getxx2(),
            remoteRepository.getxx3()
        ) { [weak self] xx1, xx2, xx3 in

            guard let self = self else { return }

        }

        runObservable(observable: observable)
</code></pre>
<p>The getxx3() gives an error and as result, the process does not complete. How can I move on if there is an error</p>
","8310287","","","","","2021-03-09 13:34:34","Skipping error value from combineLatest Observables","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"66647459","1","66647821","","2021-03-16 00:17:11","","1","65","<p>I got a problem. I got a collectionview which is binded to a winPinataActions PublishSubject&lt;[Object]&gt;(). Initially, when loading collectionview everything is fine, it displays as it has to the objects, however when the pull to refresh action changes the publishSubject data the UI is not updated, it still gets the old content of the PublishSubject.
Here is how I bind the collectionView :</p>
<pre><code>class WinPinatasViewController: UIViewController {
@IBOutlet weak var collectionView: UICollectionView!
private let bag = DisposeBag()

 override func viewDidLoad() {
        super.viewDidLoad()
        configureCollectionView()
    }

func configureCollectionView() {
     /..../
     viewModel.winPinataActions
            .observeOn(MainScheduler.instance)
            .bind(to: collectionView.rx.items(cellIdentifier: &quot;winPinatasCell&quot;, cellType: WinPinatasCell.self)) {(row, item, cell) in
            cell.configureCell(with: item)
            
        }.disposed(by: bag)
     viewModel.getPinataActions()
     }    

@objc func handleRefreshControl() {
    viewModel.getPinataActions()
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
      self.collectionView.refreshControl?.endRefreshing()
   }
}
}
</code></pre>
<p>This is my viewModel class:</p>
<pre><code>class WinPinatasViewModel {
    
    let winPinataActions = PublishSubject&lt;[WinPinatasAction]&gt;()
    
    func getPinataActions() {
        guard let ssoId = UserDefaultsStore.ssoId() else {
            return
        }
        NetworkEngine.shared.gamificationNetwork.getUserWinPinataActions(subject: winPinataActions, ssoID: ssoId)
    }
}
</code></pre>
<p>And my NetworkEngine getuserPinataActions method:</p>
<pre><code>func getUserWinPinataActions(subject winPinatasActions: PublishSubject&lt;[WinPinatasAction]&gt;, ssoID: String) {
           //...//
           let actions = try decoder.decode([WinPinatasAction].self, from: jsonData)
           winPinatasActions.onNext(actions)
           winPinatasActions.onCompleted()
          //...//
}
</code></pre>
<p>When the pull to refresh action is done, the handleRefreshControl() method is called. Also While debugging I could see that after pullToRefresh action the new data is received inside my NetworkEngine method and both .onNext()and onCompleted() are called. But when I scroll through the collectionView the data the cell items are from the old array, not the one new one. Could you help me please? What am I doing wrong?</p>
","13637073","","","","","2021-03-16 01:16:20","RXSwift collectionView doesn't update when calling .onNext(newArray)","<swift><uicollectionview><rx-swift>","1","3","","","","CC BY-SA 4.0"
"66689607","1","","","2021-03-18 10:52:58","","1","53","<p>So, I have this code in my <code>ViewModel</code> and trying to forward the events of <code>search</code> to the <code>publishSubject</code> so it can be observed in my <code>ViewController</code></p>
<p>Here is my <strong>Repository</strong></p>
<pre><code>func search(origin: String, destination: String, page: Int)-&gt; Observable&lt;[MyObject]&gt;
</code></pre>
<p>Here is my <strong>ViewModel</strong></p>
<pre><code>let searchObservable: Observable&lt;[MyObject]&gt; { searchPublishSubject.asObservable() }
private let searchPublishSubject = PublishSubject&lt;[MyObject]&gt;()

func search() {
        searchRepository
            .search(origin: origin.value!, destination: destination.value!, page: 1)
            .observe(on: scheduler)
            .subscribe(searchPublishSubject)
            .disposed(by: disposeBag)
}
</code></pre>
<p>Here is the extension function I wrote for the <code>Observable</code></p>
<pre><code>func forwardEvents(to publishSubject: PublishSubject&lt;Element&gt;)-&gt; Disposable {
        return subscribe { (element) in
            Log.d(&quot;onNext&quot;)
            publishSubject.on(.next(element))
        } onError: { (error) in
            Log.d(&quot;onError&quot;)
            publishSubject.on(.error(error))
        } onCompleted: {
            Log.d(&quot;onCompleted&quot;)
            publishSubject.on(.completed)
        }
    }
</code></pre>
<p>Here is my <strong>ViewController</strong></p>
<pre><code>viewModel.search()
viewModel.searchObservable.subscribe { (objects) in
            Log.d(&quot;\(objects.count) found&quot;)
        } onError: { (error) in
            if let apiError = error.asApiError {
                switch apiError {
                    default:
                        Log.e(&quot;Internal error maybe \(error)&quot;)
                }
            } else {
                Log.e(&quot;Client error \(error)&quot;)
            }
        } onDisposed: {
            Log.d(&quot;onDisposed&quot;)
        }.disposed(by: disposeBag)
</code></pre>
","7436566","","7436566","","2021-03-18 13:04:58","2021-03-18 13:04:58","How to forward events from Observable to a PublishSubject?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"66694943","1","","","2021-03-18 16:16:35","","1","56","<p>I am calling a service within an observable and when something fails in the service I call the <code>subscriber.onError(error)</code>. In my do - onNext - onError I catch this and handle it accordingly.</p>
<p>My Code:</p>
<pre><code> return Observable.create({ subscriber -&gt; Disposable in
        let request = self.service.request(target: xxx, success: { response in
            subscriber.onNext(response)
            subscriber.onCompleted()
        }, error: { customError in
            subscriber.onError(customError)
        }) { otherError in
            subscriber.onError(otherError)
        }

        return Disposables.create {
            request.cancel()
        }
    })
        .do(onNext: { response in
            self.doSomethingWithRespone(response)
        }, onError: { _ in
            self.doSomethingBecauseOfError()
        })
</code></pre>
<p>Yet when my code runs in Debug mode RXSwift crashes with a fatal exception on:</p>
<pre><code>func rxFatalErrorInDebug(_ lastMessage: @autoclosure () -&gt; String, file: StaticString = #file, line: UInt = #line) {
    #if DEBUG
    fatalError(lastMessage(), file: file, line: line)
    #else
    print(&quot;\(file):\(line): \(lastMessage())&quot;)
    #endif
} 
</code></pre>
<p>I see it has a special Debug tag to execute a fatalError but I am handling the error in <code>onError</code>.
How can I prevent my code from crashing when I am already handling the error?</p>
","1635284","","","","","2021-03-20 12:38:26","Observable subscriber.onError causes fatalException in Debug","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"66747996","1","","","2021-03-22 14:25:16","","2","140","<p>Hey I learned on an HackingWithSwift Tutorial How to make a chained network request with Combine (see code below). Now I will build the same logic with RXSwift but I don't know how can I get/subscribe like in Combine to get the end result.</p>
<p>Combine:</p>
<pre><code>//Combine code
func fetch&lt;T: Decodable&gt;(_ url: URL, defaultValue: T) -&gt; AnyPublisher&lt;T, Never&gt; {
       let decoder = JSONDecoder()
       decoder.dateDecodingStrategy = .iso8601

       return URLSession.shared.dataTaskPublisher(for: url)
           .retry(1)
           .map(\.data)
           .decode(type: T.self, decoder: decoder)
           .replaceError(with: defaultValue)
           .receive(on: DispatchQueue.main)
           .eraseToAnyPublisher()
   }

//call fetch method and get the end result 
fetch(url, defaultValue: [URL]())
        .flatMap { urls in
           urls.publisher.flatMap { url in
              fetch(url, defaultValue: [NewsItem]())
           }
        }
        .collect()
        .sink { values in
            let allItems = values.joined()
            items = allItems.sorted { $0.id &gt; $1.id }
        }
        .store(in: &amp;requests)



//RXSwift code
func fetchWithRX&lt;T: Decodable&gt;(_ url: URL, defaultValue: T) -&gt; Observable&lt;T&gt; {
       let decoder        = JSONDecoder()
       decoder.dateDecodingStrategy = .iso8601
       let request        = URLRequest(url: url)
       
       return URLSession.shared.rx.response(request: request)
           .retry(1)
           .map(\.data)
           .decode(type: T.self, decoder: decoder)
           .debug()
           .catchAndReturn(defaultValue)
           .observe(on: MainScheduler.instance)
   }


//call fetch2 method 
Now I want to subscribe to the values like in the first fetch method with flatMap..collect..sink etc.

fetchWithRX(url, defaultValue:  [URL]()) 

</code></pre>
","9094724","","","","","2021-03-24 11:19:21","Chained Network Request RXSwift","<swift><rx-swift><combine>","1","0","","","","CC BY-SA 4.0"
"66801249","1","66809084","","2021-03-25 14:10:00","","2","90","<p>Let's say there are 3 methods I want to run in order and entry point is dependent on an integer(number).</p>
<pre><code>func method1() -&gt; Single&lt;Void&gt; {
    return .just(())
}

func method2() -&gt; Single&lt;Void&gt; {
    return .just(())
}

func method3() -&gt; Single&lt;Void&gt; {
    return .just(())
}
</code></pre>
<p>in regular Swift there would be switch like this:</p>
<pre><code>func doThings(startingFrom number: Int) -&gt; Single&lt;Void&gt; {
    switch number {
    case 0:
        method1()
        fallthrough
    case 1:
        method2()
        fallthrough
    case 2:
        method3()
        fallthrough
    default:
        print(&quot;Finished&quot;)
    }

    return .just(())
}
</code></pre>
<p>but considering method1(), method2() and method3 are Single I am thinking there should be a way in RxSwift to chain them without messing with their execution order.</p>
<p>I thought something like this but this works synchronous therefore there is no guaranteed execution order for methods.</p>
<pre><code>public func doThings(startingFrom number: Int) -&gt; Single&lt;Void&gt; {
    var actions: [Single&lt;Void&gt;] = []
    switch number {
    case 0:
        actions.append(method1())
        fallthrough
    case 1:
        actions.append(method2())
        fallthrough
    case 2:
        actions.append(method3())
        fallthrough
    default:
        break
    }

    return Single
        .zip(actions)
        .do(onSuccess: { _ in
            Log.debug(&quot;Finished&quot;)
        })
        .mapToVoid()
}
</code></pre>
<p>Sorry if I don't make sense, I'm quite new to RxSwift. Please correct me if something is wrong.</p>
","4233703","","4233703","","2021-03-25 14:18:00","2021-03-26 11:43:16","How to chain RxSwift Singles in order","<ios><swift><rx-swift>","1","3","","","","CC BY-SA 4.0"
"66810402","1","","","2021-03-26 02:55:55","","0","57","<p>The array was converted to Observable using the <code>from</code> operator as shown below.</p>
<pre><code>Observable.from([1, 2, 3, 4, 5])
  .subscribe(onNext: {
    print($0)
  })
  .disposed(by: disposeBag)
</code></pre>
<pre><code>//Result Value
1
2
3
4
5
</code></pre>
<p>After that, I want to use several <code>map</code> or <code>flatMap</code> operators to transform, and finally I want to make an array again.<br>
Is there an Rx operator that can create an array without using <code>toArray()</code>?</p>
<pre><code>Observable.from([1, 2, 3, 4, 5])
  .map { .... }
  .flatMap { .... }
  .map { .... }
  ????? -&gt; convert to Array
  .subscribe(onNext: {
    print($0)
  })
  .disposed(by: disposeBag)
</code></pre>
<pre><code>//Expected Value
[someItem1, someItem2, ..., someItem5]
</code></pre>
","3569109","","","","","2021-03-26 11:58:11","How can I convert an element to an array?","<swift><rx-swift>","1","3","","","","CC BY-SA 4.0"
"66819151","1","66831880","","2021-03-26 14:49:06","","1","34","<p>Take a look at this example:</p>
<pre><code>func query2() -&gt; Observable&lt;Int&gt; {
    print(&quot;query2() called&quot;)
    return Observable.create { observer in
        print(&quot;creating query2() thread&quot;)
        let thread = Thread.init(block: {
            sleep(1)
            let numbers = [
                1,2,3,4,5
            ]
            for num in numbers {
                observer.onNext(num)
            }
            observer.onCompleted()
        })
        thread.start()
        return Disposables.create {
            thread.cancel()
        }
    }
}

let numbers = query2()
let even = numbers.filter { $0 % 2 == 0 }
let odd = numbers.filter { $0 % 2 != 0 }
let merged = even.concat(odd)

merged.subscribe(onNext: { n in
    print(n)
})
</code></pre>
<p>The expected output is:</p>
<pre><code>query2() called
creating query() thread
2
4
1
3
5
</code></pre>
<p>However, the thread seems to be created a second time when it comes time to pull values from <code>odd</code>.</p>
<p>Actual Output:</p>
<pre><code>query2() called
creating query2() thread
2
4
creating query2() thread
1
3
5
</code></pre>
<p>I looked at this code, and thought - ah I missed the <code>.share()</code> operator, since the <code>even</code> and <code>odd</code> are derived from the same stream. I did not add that in originally because I eventually merge those into a single stream <code>merged</code> to be subscribed on, and thought that Rx would do the optimization for me.</p>
<p>So I used share(): <code>let numbers = query2().share()</code></p>
<p>The output still remained the same.</p>
<p>How can I prevent this from happening?</p>
","10390454","","","","","2021-03-27 14:04:56","RxSwift - doing control flow leads to async operation being performed twice","<swift><macos><rx-swift><reactivex>","1","0","","","","CC BY-SA 4.0"
"66838864","1","","","2021-03-28 06:16:35","","1","36","<p>One API key can only make 100 requests per day. So one API key can't handle a lot of requests per day. There are other ways to solve this problem, but I would like to solve this problem by entering various API keys. For example, if the first API key makes 100 requests and the request value returns as an error, I want to add a function that automatically moves to the second API key.
Can you tell me how to make it with Rxswift?</p>
<p>I would appreciate any help you can provide.</p>
<p>The code is as below.</p>
<pre class=""lang-swift prettyprint-override""><code>private func loadTopNews() {
   let resource = Resource&lt;ArticleResponse&gt;(url: URL(string: &quot;https://newsapi.org/v2/top-headlines?country=\(selectedLanguagesCode[0])&amp;sortBy=%20popularity&amp;apiKey=\(apiKey[0])&quot;)!)
        
   URLRequest.load(resource: resource)
      .subscribe(onNext: { articleResponse in
         let topArticle = articleResponse.articles.first
         self.articleVM = ArticleViewModel(topArticle!)
   }).disposed(by: disposeBag)
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>

struct Resource&lt;T: Decodable&gt; {
    let url: URL
}

extension URLRequest {
    
    static func load&lt;T&gt;(resource: Resource&lt;T&gt;) -&gt; Observable&lt;T&gt; {
        return Observable.just(resource.url)
            .flatMap { url -&gt; Observable&lt;Data&gt; in
                let request = URLRequest(url: url)
                return URLSession.shared.rx.data(request: request)
            }.map { data -&gt; T in
                return try JSONDecoder().decode(T.self, from: data)
            }
    }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>struct ArticleResponse: Decodable {
    let articles: [Article]
}

struct Article: Decodable {
    let title: String
    let publishedAt: String
    let urlToImage: String?
    let url: String
}

</code></pre>
<pre class=""lang-swift prettyprint-override""><code>struct ArticleListViewModel {
    
    let articlesVM: [ArticleViewModel]
}

extension ArticleListViewModel {
    
    init(_ articles: [Article]) {
        self.articlesVM = articles.compactMap(ArticleViewModel.init)
    }
}

extension ArticleListViewModel {
    
    func articleAt(_ index: Int) -&gt; ArticleViewModel {
        return self.articlesVM[index]
    }
}


struct ArticleViewModel {
    
    let article: Article
    
    init(_ article: Article) {
        self.article = article
    }
}

extension ArticleViewModel {
    
    var title: Observable&lt;String&gt; {
        return Observable&lt;String&gt;.just(article.title)
    }
    
    var publishedAt: Observable&lt;String&gt; {
        return Observable&lt;String&gt;.just(article.publishedAt)
    }
    
    var urlToImage: Observable&lt;String&gt; {
        return Observable&lt;String&gt;.just(article.urlToImage ?? &quot;NoImage&quot;)
    }
    
    var url: Observable&lt;String&gt; {
        return Observable&lt;String&gt;.just(article.url)
    }
}

</code></pre>
","12635064","","","","","2021-03-29 12:04:20","How to add a function that automatically moves to the second API key in Rxswift","<ios><swift><rx-swift><api-key>","1","0","","","","CC BY-SA 4.0"
"66857614","1","66953480","","2021-03-29 16:06:42","","1","126","<p>I am new to testing un RxSwift.
I manage to test that an Observable emits values with RxBlocking. But I can't find the syntax to make a test pass if an Observable did not send any value.</p>
<p>I think I should use <code>toBlocking(timeout: )</code>,but I can't find how (I have an error that it timed out, but the test fail).</p>
<p>Thank you for your help</p>
","713599","","","","","2021-04-05 13:00:19","In RxSwift, how can I unit test that an observable sent no event?","<swift><unit-testing><observable><rx-swift>","1","0","0","","","CC BY-SA 4.0"
"66864955","1","66913370","","2021-03-30 04:48:17","","1","48","<p>I'm trying to write an integration test for a <code>Reactor</code> in an app built with ReactorKit and Realm/RxRealm.</p>
<p>I'm having trouble using <code>TestScheduler</code> to simulate user actions and test the expected emitted states.</p>
<p>In a nutshell, my problem is this: I'm binding an action that will make my Reactor save an item to Realm, my Reactor also observes changes to this object in Realm, and I expect my Reactor to emit the new state of this item observed from Realm.</p>
<p>What I'm seeing is that my test does not get the emission of the newly saved object in time to assert its value, it's emitted after my test assertion runs.</p>
<p>There is a fair amount of code involved, but attempting to whittle it down into a self-contained example of what it all roughly looks like below:</p>
<pre class=""lang-swift prettyprint-override""><code>struct MyObject {
    var counter: Int = 0
}

class MyReactor: Reactor {
    enum Action {
        case load
        case mutateState
    }

    enum Mutation {
        case setObject(MyObject)
    }

    struct State {
        var object: MyObject?
    }
    
    func mutate(action: Action) -&gt; Observable&lt;Mutation&gt; {
        switch action {
        case .load:
            return service.monitorObject().map(Mutation.setObject)
        case .mutateState:
            guard var myObject = currentState.object else { return .empty() }
            myObject.counter += 1
            return service.save(myObject).andThen(.empty())
        }
    }

    func reduce(state: State, mutation: Mutation) -&gt; Observable&lt;State&gt; {
        var newState = state
        switch mutation {
        case let .setObject(object):
            // Should be called twice in tests, once on load, once after mutateState action
            newState.object = object
        }
    }
}

struct Service {

    // There is always at least one default instance of `MyObject` in Realm.
    func monitorObject() -&gt; Observable&lt;MyObject&gt; {
        return Observable
            .collection(from: realm.objects(MyObject.self))
            .map { $0.first! }
    }

    func save(_ object: MyObject) -&gt; Completable {
        return Completable.create { emitter in
            try! realm.write {
                realm.add(object, update: .modified)
            }
            emitter(.completed)
            return Disposables.create()
        }
    }
}

class MyTest: QuickSpec {

    var scheduler: TestScheduler!
    var sut: MyReactor!
    var disposeBag: DisposeBag!
    var service: Service!
    var config: Realm.Configuration!

    override func spec() {
        beforeEach {
            config = Realm.Configuration(inMemoryIdentifier: UUID().uuidString)
            scheduler = TestScheduler(initialClock: 0)
            disposeBag = DisposeBag()
            sut = MyReactor()
            service = Service(realmConfig: config)
        }

        describe(&quot;when my reactor gets a mutateState action&quot;) {
            it(&quot;should mutate state&quot;) {

                scheduler.createHotObservable([
                    .next(1, Action.load),
                    .next(2, Action.mutateState),
                ])
                .bind(to: sut.action)
                .disposed(by: disposeBag)

                let response = scheduler.start(created: 0, subscribed: 0, disposed: 1000) {
                    sut.state.map(\.object)
                }

                // Counter always equals 0
                XCTAssertTrue(response.events.last!.value.element!!.counter == 1)
            }
        }
    }
}
</code></pre>
<p>What I'm expecting to happen is my Reactor's state is set for a 2nd time, before the <code>XCTAssertTrue</code> is hit. What is actually happening is the assert is hit with the initially loaded state, and then, my reactor's state is set again.</p>
<p>I thought my problem might be related to schedulers. Something I tried was injecting the test scheduler into my Service and doing <code>observeOn(testScheduler)</code> on my <code>monitorObject</code> function. But I'm still observing the assert get hit before the reactor's state is set for the 2nd time. I'm also not sure if a nuance of RxRealm/Realm change set notifications is the cause - not sure how to verify whether that might be the case.</p>
<p>Hopefully the problem and question is clear. Thanks in advance for any help.</p>
","3354041","","","","","2021-04-02 01:19:03","Not getting all expected events when subscribing to sequence with TestScheduler","<swift><realm><rx-swift><reactor>","2","1","","","","CC BY-SA 4.0"
"66916399","1","","","2021-04-02 08:17:08","","0","77","<p>I want to show the contents of the collection view through search. However, there are many errors while binding collection views. I think the model code got weird first, where is it weird? How can we fix this error?</p>
<pre><code> output.loadData.map(CollectionOfOne.init).bind(to: collectionView.rx.items) { (row,collectionView, element) -&gt; UICollectionViewCell in
            let indexPath = IndexPath(index: 1)
            guard let cell = self.collectionView.dequeueReusableCell(withReuseIdentifier: &quot;friendCell&quot;, for: indexPath) as? FriendCell else {
                return FriendCell()
            }
            cell.profileImage?.image = UIImage(systemName: element.image)
            cell.nickNameLbl?.text = element.nickname
            cell.listenBtn?.rx.tap.subscribe(onNext: {[unowned self] in
                selectIndexPath.accept(row)
            }).disposed(by: cell.disposeBag)
    
            return cell
        }
 output.searchNameResult.map(CollectionOfOne.init).bind(to: collectionView.rx.items) { collectionView, index, element -&gt; UICollectionViewCell in
            let indexPath = IndexPath(index: 0)
            guard let cell = self.collectionView.dequeueReusableCell(withReuseIdentifier: &quot;freindCell&quot;, for: indexPath) as? FriendCell else {
                return FriendCell()
            }
         //   cell.profileImage?.image = UIImage(systemName: (element as AnyObject).image)
            cell.profileImage?.image = UIImage(named: element.img)
            cell.nickNameLbl?.text = (element.nickname)
            
            return cell
        }
</code></pre>
<p>This is viewcontroller code</p>
<pre><code>struct input {
        let loadData: Signal&lt;Void&gt;
        let searchName: Driver&lt;Void&gt;
        let searchHashTag: Driver&lt;Void&gt;
    }

    struct output {
        let loadData: BehaviorRelay&lt;[User]&gt;
        let searchNameResult: PublishRelay&lt;users&gt;
    }
func transform(_ input: input) -&gt; output {
        let api = SearchAPI()
        let loadData = BehaviorRelay&lt;[User]&gt;(value: [])
        let searchName = PublishRelay&lt;users&gt;()

        input.loadData.asObservable().subscribe(onNext: { [weak self]  in
            guard let self = self else { return }
            api.getFriend().subscribe(onNext: { (response, statuscode) in
                switch statuscode {
                case .ok:
             //       loadData.accept(response!, User)
                    result.onCompleted()
                default:
                    result.onNext(&quot;default&quot;)
                }
            }).disposed(by: self.disposeBag)
        }).disposed(by: disposeBag)
        
        input.searchName.asObservable().withLatestFrom(input.name).subscribe(onNext: {[weak self] nickname in
            guard let self = self else { return }
            api.getUserList(nickname).subscribe(onNext: { (response,statuscode) in
                switch statuscode {
                case .ok:
                    result.onCompleted()
                case .noHere:
                    result.onNext(&quot;no user&quot;)
                default:
                    result.onNext(&quot;default&quot;)
                }
            }).disposed(by: self.disposeBag)
        }).disposed(by: disposeBag)
</code></pre>
<p>And this is my viewmodel.
What is the problem?</p>
","14063311","","","","","2021-04-03 11:24:48","Incorrect argument label in call (have 'named:', expected 'systemName:')","<ios><swift><rx-swift>","1","9","","","","CC BY-SA 4.0"
"66959183","1","67188908","","2021-04-05 20:10:53","","1","74","<p>I have:</p>
<ul>
<li><code>App</code> depends on <code>Framework A</code></li>
<li><code>Framework A</code> depends on <code>RxSwift v1.0</code></li>
<li><code>App</code> depends on <code>RxSwift v2.0</code></li>
</ul>
<p>Is it possible to resolve this using <code>CocoaPods, Carthage, SwiftPM</code>? How?</p>
<p>Or I should align these versions of <code>RxSwift</code>?</p>
<p>Related questions:</p>
<ul>
<li><a href=""https://stackoverflow.com/questions/20158522/using-two-versions-of-a-cocoapod-dependency"">Using two versions of a Cocoapod dependency</a> (outdated)</li>
<li><a href=""https://forums.raywenderlich.com/t/best-practice-on-handling-multiple-versions-of-nested-rxswift-community-dependencies-cocoapods/119252"" rel=""nofollow noreferrer"">https://forums.raywenderlich.com/t/best-practice-on-handling-multiple-versions-of-nested-rxswift-community-dependencies-cocoapods/119252</a></li>
</ul>
","1549840","","1549840","","2021-04-17 17:52:35","2021-04-21 03:29:28","Resolving overlapping dependencies (let's say RxSwift)","<ios><cocoapods><rx-swift><swift-package-manager><carthage>","1","0","1","","","CC BY-SA 4.0"
"66966386","1","","","2021-04-06 09:52:02","","0","13","<p>I have two providers for network calls</p>
<pre><code> public lazy var passwordProvider: MoyaProvider&lt;PasswordTarget&gt; = createPasswordProvider()
 public lazy var publicProvider: MoyaProvider&lt;PublicTarget&gt; = createPublicProvider()
</code></pre>
<p>And a function which can be called with public:</p>
<pre><code> func getGroceriesPublic() -&gt; Single&lt;[Grocery]&gt; {
    return publicProvider.rx
      .request(.getGroceries)
      .map([Grocery].self, atKeyPath: &quot;data&quot;, failsOnEmptyData: false)
      .map ({
        // data manipulation here same as for password provider
      })
  }
</code></pre>
<p>And exactly same function but with password provider:</p>
<pre><code>func getGroceriesPassword() -&gt; Single&lt;[Grocery]&gt; {
    return passwordProvider.rx
        .request(.getGroceries)
        .map([Grocery].self, atKeyPath: &quot;data&quot;, failsOnEmptyData: false)
        .map ({
            // data manipulation here same as for public provider
        })
    }   
</code></pre>
<p>I'm wondering if there is any way to make that a one function accepting <code>MoyaProvider&lt;T&gt;</code> as a parameter. I'll be adding more providers in the future and just copy pasting function code doesn't look like a good solution.</p>
<p>So far I tried this but not sure if I'm moving in a right direction:</p>
<pre><code>func getGroceries&lt;T&gt;(provider: MoyaProvider&lt;T&gt;) -&gt; Single&lt;[Grocery]&gt; {
    return provider.rx
      .request(.getGroceries) // gives me an error here because it doesn't know if it's passwordProvider or publicProvider
      .map([Grocery].self, atKeyPath: &quot;data&quot;, failsOnEmptyData: false)
      .map ({
        ...
      })
  }  
</code></pre>
","4355527","","","","","2021-04-06 09:52:02","Pass MoyaProvider<T> as a function parameter","<swift><rx-swift><moya>","0","0","","","","CC BY-SA 4.0"
"66971436","1","66972097","","2021-04-06 15:14:38","","-1","143","<p>A few days ago I have begun to learn RxSwift and but the more I write code and can't understand which cases need to use reactive programming, I am can write the same code without RxSwift and use NotificaitionCenter, delegate pattern, Grand Central Dispatch, Closures.</p>
<p>I understand that RxSwif and RxCocoa give next opportunity:</p>
<blockquote>
<p>There are some different ways to pass information from one object to
another in iOS reactively (Notification, pass in closure, delegate,
KVO, &amp; target/action,) each of these different systems may be simple
by itself but most of the complexity in the logic of an iOS app is in
having to convert from one of these systems to another.
RxSwift/RxCocoa replaces virtually all of these systems with one which
is in a Rx way.</p>
</blockquote>
<p>But when I am trying to write code on Rx I saw that this code not easy to understand.</p>
<p>Maybe someone can give examples of when need to use Rx inside the application or maybe in most cases doesn't need to use Rx because code will be complicated to understand, I am enjoyed from knowledge about Rx but not fully understand the good situation when need use it.</p>
","14088005","","","","","2021-04-07 12:12:39","In which situation good reason to use RxSwift & RxCocoa?","<ios><reactive-programming><rx-swift><rx-cocoa>","2","4","","2021-04-07 15:25:29","","CC BY-SA 4.0"
"67018158","1","67018411","","2021-04-09 09:03:07","","0","45","<p>I would like to create Observable object of User. This is my structure</p>
<pre><code>import Foundation

struct User {
    let email: String
    let username: String
}
</code></pre>
<p>When i do network request I get response of type Observable&lt;[String:Any]&gt;, that works fine, but I have no idea how to transform that into Observable&lt;[User]&gt;. I tried</p>
<pre><code>func loadUsers() -&gt; Observable&lt;[User]&gt; {
        return fetchUserData(cUser: Master.users).map(([String : Any]) throws -&gt; [User])
    }

</code></pre>
<p>But I get this error</p>
<pre><code>Cannot convert value of type '(([String : Any]) throws -&gt; [User]).Type' to expected argument type '([String : Any]) throws -&gt; [User]'
</code></pre>
","12046777","","12046777","","2021-04-09 10:10:14","2021-04-09 12:28:37","Creating observable from another observable","<swift><observable><rx-swift>","1","0","","","","CC BY-SA 4.0"
"67027370","1","","","2021-04-09 19:44:25","","1","143","<p>I have a network request that returns <code>Observable&lt;Result&lt;Data, APIError&gt;&gt;</code> which i map straight into array of Realm Object's so in the end i have <code>Observable&lt;Result&lt;[Model], APIError&gt;&gt;</code>, where <code>Model</code> conforms to <code>Decodable</code> and subclasses <code>Object</code>.</p>
<p>I would like to write an extension to Observable to filter out <code>APIError</code>'s and emit succesful results
So i tried to write something like this, but it wouln't work for me:</p>
<pre><code>extension Observable where Element == Result&lt;[Decodable], APIError&gt; {
 func toSuccesOrEmpty() -&gt; Observable&lt;[Decodable]&gt; {
  return flatMap { (result) -&gt; Observable&lt;[Decodable]&gt; in
   switch result {
    case .success(let data):
     return Observable&lt;[Decodable]&gt;.just(data)
    case .failure:
     return Observable&lt;[Decodable]&gt;.empty()
   }
  }
 }
}
</code></pre>
<p>I'm new to RxSwift and i might miss smth. Also i don't want to use <code>onError</code> when creating this observable since i want to use this error later on</p>
","15594250","","","","","2021-04-09 20:57:34","RxSwift extension to Observable where Element is Result<>","<ios><swift><generics><observable><rx-swift>","1","2","","","","CC BY-SA 4.0"
"67048515","1","67051270","","2021-04-11 18:03:20","","1","276","<p>When I use loadMovies function I get desired movies only after the ViewController has called function and disposed it, this function is inside API</p>
<pre><code>func loadMovies() -&gt; Observable&lt;[Movie]&gt; {
    let obsMovies = self.APICall(genrePath: Movies.action, structType: Movie.self)
    return Observable.create{ observer -&gt; Disposable in
        obsMovies.subscribe(
            onNext: { element in 
                      observer.onNext(element)
                      print(element) 
           }
        )
        observer.onCompleted()
        return Disposables.create()
    }
}
</code></pre>
<p>In ViewController I call this function inside viewDidLoad</p>
<pre><code>
request.api.loadMovies()
    .debug()
    .subscribe(
        onNext:{ data in
            do {
                print(data)
            }
        },
        onError: { error in
            print(error)
        },
        onCompleted: {
            print(&quot;Completed&quot;)
        },
        onDisposed: {
            print(&quot;Disposed&quot;)
        }
    )
    .disposed(by: disposeBag)

</code></pre>
<p>and get this output</p>
<pre><code>ViewController.swift:55 (viewDidLoad()) -&gt; subscribed
ViewController.swift:55 (viewDidLoad()) -&gt; Event completed
Completed
Disposed
ViewController.swift:55 (viewDidLoad()) -&gt; isDisposed

[MovieTest.Movie(name: &quot;Black Panther&quot;, year: &quot;2018&quot;, rating: &quot;83&quot;)]
[MovieTest.Movie(name: &quot;AVENGERS: ENDGAME&quot;, year: &quot;2019&quot;, rating: &quot;90&quot;)]
[MovieTest.Movie(name: &quot;MISSION: IMPOSSIBLE -- FALLOUT&quot;, year: &quot;2018&quot;, rating: &quot;88&quot;)]...
</code></pre>
<p>I want to how to wait for function to fetch movies before being disposed.I want to display everything in tableView. I'm beginner at RxSwift, I believe there is better way to achieve this but as of right now I have no idea. Thanks</p>
","12046777","","","","","2021-04-12 00:08:35","RxSwift wait for observable to complete, and return observable","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"67069089","1","","","2021-04-13 05:14:33","","0","56","<p>The main problem is am using currently Moya on my app, but I want to use some functions from &quot;Moya/RxSwift&quot; pod, the problem I am having is when i change the pod the Alamofire downgrades to 4.9.1 and produce a lot of error in the code, there is a way to edit the pod file to keep using Alamofire 5?</p>
<p>My PODS in the podfile:
<div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code># Uncomment this line to define a global platform for your project
# platform :ios, ’10.0’
platform :ios, '10.0'
use_frameworks!
inhibit_all_warnings!

def core_pods
    #core
    pod 'ZXingObjC'
    pod 'Moya/RxSwift'
    pod 'RxSwift'
    pod 'RxCocoa'
    pod 'RxViewModel'
    pod 'XCGLogger', '~&gt; 6.1.0'
    pod 'SwiftyJSON'
    pod 'CryptoSwift', :git =&gt; ""https://github.com/krzyzanowskim/CryptoSwift"", :branch =&gt; ""master""
    pod 'AFDateHelper'
    #pod 'Fabric'
    #pod 'Crashlytics'
end

def ui_pods
    pod 'SVProgressHUD'
    pod 'CropViewController'
    pod 'lottie-ios'
end</code></pre>
</div>
</div>
</p>
<p>examples of some errors i got on the code because of the downgrade:
<a href=""https://i.stack.imgur.com/ZPV2f.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZPV2f.png"" alt=""enter image description here"" /></a></p>
","10360601","","","","","2021-04-13 05:14:33","RxMoya downgrade Alamofire to 4.9.1, but i need to use Alamofire 5+","<ios><swift><xcode><alamofire><rx-swift>","0","2","","","","CC BY-SA 4.0"
"67120517","1","","","2021-04-16 07:00:05","","0","21","<p>I am trying to make a API resquest using RxSwift. My<code>SwiftUI view has the signUp()</code> method which calls the API request method in View Model. However when calling the method, I am getting the error as <code>Generic parameter 'U' could not be inferred</code>. What is the correct way to do this?</p>
<pre><code>func signup() {

    var signupDictionary = [String: Any]()
    signupDictionary.updateValue(firstName.lowercased(), forKey: &quot;firstName&quot;)
    signupDictionary.updateValue(lastName.lowercased(), forKey: &quot;lastName&quot;)
    signupDictionary.updateValue(userLatitude, forKey: &quot;latitude&quot;)
    signupDictionary.updateValue(userLongitude, forKey: &quot;longitude&quot;)
    signupDictionary.updateValue(email.lowercased(), forKey: &quot;emailId&quot;)

    let disposeBag = DisposeBag()

    do {
         try signUpViewModel.postRequestData(input: signupDictionary) // Error: Generic parameter 'U' could not be inferred
            .subscribe (onNext: { model in
                print(model)
        },
        onError: { error in
                print(error)
        },
        onCompleted: {
        }).disposed(by: disposeBag)
    }catch {
        
    }
}
</code></pre>
<p>Below function from View Model will hit the API Client and retrieve data.</p>
<pre><code>func postRequestData&lt;T, U: Codable&gt;(input: T)  -&gt; Observable&lt;U?&gt; {
    let signupURL = URLConstants.baseUsersURL + URLConstants.userSignUp
    return client.postRequest(data: input, urlString: signupURL)
}
</code></pre>
","1421910","","","","","2021-04-16 07:00:05","RxSwift Generic parameter type inference error","<swift><swiftui><rx-swift><urlsession>","0","3","","","","CC BY-SA 4.0"
"67126202","1","67133696","","2021-04-16 13:31:41","","1","42","<p>I'm new to RxSwift and guess I am doing it very very wrong, so please enlighten me!</p>
<p>Simpified example:</p>
<p>There's a view with three UITextField and an UIButton, and two Swagger-API-calls for GET and PUT UserData (a struct with three Strings).</p>
<pre><code>var firstName = UITextField()
var lastName = UITextField()
var email = UITextField()
var sendButton = UIButton()
</code></pre>
<p>ViewModel has a BehaviorSubject to hold the data:</p>
<pre><code>var userData = BehaviorSubject&lt;UserData?&gt;(value: nil)
</code></pre>
<p>Binding incoming data to the BehaviorSubject works:</p>
<pre><code>self.userData.onNext(response.userData)
</code></pre>
<p>And filling the UITextFields works:</p>
<pre><code>viewModel.userData.bind { userData in
    firstName.text = userData?.firstName
    lastName.text = userData?.lastName
    email.text = userData?.email
}.disposed(by: disposeBag)
</code></pre>
<p><strong>But typing in the UITextFields fails with this code:</strong></p>
<pre><code>// changing any of these fields should trigger an update of the whole object
BehaviorSubject.combineLatest(
    self.firstName.rx.text,
    self.lastName.rx.text,
    self.email.rx.text
)
.map {
    return UserData(
        firstName: $0,
        lastName: $1,
        email: $2
    )
}
.bind(to: viewModel.userData)
.disposed(by: disposeBag)
</code></pre>
<p>Most of the time the typed box stays, but all others get emptied or sometimes all get emptied or other weird stuff happens like values jumping around the fields.</p>
<p>For sending the data I use a simple tap handler, does not feel very Rx:</p>
<pre><code>saveButton.onTapHandler = { [weak self] in
    containerView.endEditing(true)
        do {
            try self?.viewModel.saveUserData()
        } catch {
            self?.showAlert(error)
        }
    }
}
</code></pre>
<p>Any help is welcome, also not sure if BehaviorSubject is correct, if combineLatest does what I need, ...</p>
<p>Additional info: I know I can create a seperate BehaviorSubject for each subject, but I am trying to understand how I can bind whole objects.</p>
","994486","","","","","2021-04-17 01:01:08","How to implement simple form with UITextFields and RxSwift?","<swift><rx-swift><behaviorsubject>","1","0","","","","CC BY-SA 4.0"
"67135966","1","","","2021-04-17 07:56:07","","0","341","<p>I would like to designate the constant print of tableview cell. However, the following error occurs: &quot;Thread 1: Fatal error: Expected superview but found nil when attempting make constraint <code>equalToSuperview</code>.&quot; What error is this and how can it be solved?</p>
<pre><code>override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?){
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        
        addSubview(profleImage)
        addSubview(nameLbl)
        addSubview(timeLbl)
        addSubview(titleTxtField)
        addSubview(contentTxtView)
        addSubview(postImage)
        addSubview(sirenLbl)
        addSubview(sirenBtn)
        
        profleImage.snp.makeConstraints {
            $0.centerX.equalToSuperview()
            $0.top.equalTo(snp.top).offset(15)
            $0.width.height.equalTo(50)
            $0.leading.equalTo(20)
        }
        nameLbl.snp.makeConstraints {
            $0.centerX.equalToSuperview()
            $0.top.equalTo(snp.top).offset(15)
            $0.leading.equalTo(profleImage.snp.trailing).offset(15)
        }
        timeLbl.snp.makeConstraints {
            $0.top.equalTo(nameLbl.snp.bottom).offset(5)
            $0.leading.equalTo(profleImage.snp.trailing).offset(15)
        }
        titleTxtField.snp.makeConstraints {
            $0.top.equalTo(profleImage.snp.bottom).offset(25)
            $0.leading.equalTo(30)
            $0.trailing.equalTo(-30)
        }
        contentTxtView.snp.makeConstraints {
            $0.top.equalTo(titleTxtField.snp.bottom).offset(18)
            $0.leading.equalTo(30)
            $0.trailing.equalTo(-30)
        }
        postImage.snp.makeConstraints {
            $0.top.equalTo(contentTxtView.snp.bottom).offset(18)
            $0.leading.equalTo(30)
            $0.trailing.equalTo(-30)
        }
        sirenLbl.snp.makeConstraints {
            $0.top.equalTo(postImage.snp.bottom).offset(23)
            $0.leading.equalTo(30)
        }
        sirenBtn.snp.makeConstraints {
            $0.leading.equalTo(sirenLbl.snp.trailing).offset(10)
            $0.top.equalTo(postImage.snp.bottom).offset(23)
        }
        moreBtn.snp.makeConstraints {
            $0.centerX.equalToSuperview()
            $0.trailing.equalTo(-10)
            $0.leading.equalTo(timeLbl.snp.trailing).offset(30)
        }
    }
</code></pre>
<p>This is my cell code.</p>
","14063311","","","","","2021-04-17 07:56:07","Thread 1: Fatal error: Expected superview but found nil when attempting make constraint `equalToSuperview`","<swift><rx-swift>","0","2","","","","CC BY-SA 4.0"
"67136159","1","67136443","","2021-04-17 08:25:26","","0","39","<p>I want to bind my data of <code>BehaviorRelay&lt;[Data]&gt;</code> from my View Model class into a <code>UITableView</code> in my <code>UIViewController</code> class, but unfortunately I keep getting this error:</p>
<blockquote>
<p>Unexpectedly found nil while implicitly unwrapping an Optional value: file project/ResultCell.swift, line 27
2021-04-17 15:06:32.497411+0700 project[5189:936745] Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value: file project/ResultCell.swift, line 27</p>
</blockquote>
<p>Here's what I did (In my View Controller class):</p>
<pre><code>    private func setupUI() { // Called in viewDidLoad()
        resultsTv.register(ResultCell.self, forCellReuseIdentifier: ResultCell.IDENTIFIER)
    }
    
    private func setupRxBindings() { // Called in viewDidLoad()
        viewModel.results.asObservable().bind(to: resultsTv.rx.items(cellIdentifier: ResultCell.IDENTIFIER, cellType: ResultCell.self)) { row, element, cell in
            cell.configureData(with: element)
        }.disposed(by: disposeBag)
        
        let query = searchTf.rx.text.observe(on: MainScheduler.asyncInstance).distinctUntilChanged().throttle(.seconds(1), scheduler: MainScheduler.instance).map { $0 }
        query.subscribe(onNext: { [unowned self] query in
            self.viewModel.search(query ?? &quot;&quot;) // Everytime I search something, it gives me the error
        }).disposed(by: disposeBag)
        
    }
</code></pre>
<p>My View Model class:</p>
<pre><code>fileprivate final class SearchVM {
    var results = BehaviorRelay&lt;[ModelData]&gt;(value: [ModelData]())
    
    init() { }
    
    func search(_ query: String) {
        // Get the data from a server and store it in the results property
    }
}
</code></pre>
<p>My <code>ResultCell.swift</code> class:</p>
<pre><code>class ResultCell: UITableViewCell {
    static let IDENTIFIER = &quot;ResultCell&quot;
    
    @IBOutlet weak var photoIv: UIImageView!
    @IBOutlet weak var idLbl: UILabel!
    @IBOutlet weak var nameLbl: UILabel!
    @IBOutlet weak var miscLbl: UILabel!

    override func awakeFromNib() {
        super.awakeFromNib()
    }
    
    func configureData(with data: ModelData) {
        idLbl.text = &quot;ID: \(data.id ?? &quot;&quot;)&quot; // The line that causes the error
        nameLbl.text = data.name
        miscLbl.text = &quot;\(data.gender), \(data.height), \(data.phone)&quot;
    }
}
</code></pre>
<p>In more detail, I'm making a search page that can show data based on the search results (I'm using an <code>.xib</code> files for both of my <code>UIViewController</code> and <code>UITableViewCell</code> files). Since I'm learning RxSwift I don't want to use any delegates and datasources for my <code>UITableView</code>. I'm guessing the error is because the cell was not loaded properly so the IBOutlets is not yet initialized. But I'm not sure how to solve the error. Is there anyway to solve this?</p>
","8279130","","","","","2021-04-17 09:05:21","How to fix IBOutlet ""unexpectedly found nil"" error when binding data with RxSwift?","<ios><rx-swift>","1","0","","","","CC BY-SA 4.0"
"67145429","1","","","2021-04-18 05:23:04","","0","52","<p>While running the project, the following error occurred:
<a href=""https://i.stack.imgur.com/43qo0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/43qo0.png"" alt=""enter image description here"" /></a></p>
<p>There seems to be an error in the delegate part, but I don't know how to solve it.
Delegate were used in tableView and pickerView.
This is my code:</p>
<pre><code>    func bindViewModel() {
        let input = MainViewModel.Input(loadData: loadData.asSignal(onErrorJustReturn: ()))
        let output = viewModel.transform(input: input)
        
        output.loadData.bind(to: tableView.rx.items(cellIdentifier: &quot;mainCell&quot;, cellType: MainCell.self)) { row, element, cell in
            cell.nameLbl.text = element.nickname
            cell.titleTxtField.text = element.title
            cell.contentTxtView.text = element.description
            cell.postImage.image = UIImage(named: element.media)
            cell.timeLbl.text = element.date
            cell.sirenBtn.rx.tap.subscribe(onNext: { _ in
                self.selectIndexPath.accept(row)
            }).disposed(by: self.disposeBag)
            
        }.disposed(by: disposeBag)
    }
    
    func setUI() {
        let cell = MainCell()
        
        doneBarButton.rx.tap.subscribe(onNext: { _ in
            let selectRow = self.pickerView.selectedRow(inComponent: 0)
            self.sequencePicker.text = self.sequenceData[selectRow]
            self.sequencePicker.resignFirstResponder()
            self.areaPicker.text = self.areaData[selectRow]
            self.areaPicker.resignFirstResponder()
        }).disposed(by: disposeBag)
        
        cell.moreBtn.rx.tap.subscribe(onNext: { _ in
            let actionSheet = UIAlertController(title: &quot;siren?&quot;, message: &quot;&quot;, preferredStyle: .actionSheet)
            let action = UIAlertAction(title: &quot;ok&quot;, style: .default, handler: nil)
            
            actionSheet.addAction(action)
            self.present(actionSheet, animated: true, completion: nil)
        }).disposed(by: self.disposeBag)
        
        tableView.delegate = self
        tableView.dataSource = nil
        tableView.register(MainCell.self, forCellReuseIdentifier: &quot;mainCell&quot;)
        tableView.rowHeight = 150
    }
      func pickerBind() {
        pickerView.delegate = self
        pickerView.dataSource = nil
        sequencePicker.inputView = pickerView
        areaPicker.inputView = pickerView
        
        _ = Observable.just(sequenceData).bind(to: pickerView.rx.itemTitles) { _, item in return &quot;\(item)&quot; }

    }
</code></pre>
<p>What is the problem?</p>
","14063311","","","","","2021-04-18 05:23:04","error in swift 'Thread 1: Assertion failed'","<ios><swift><rx-swift>","0","2","","","","CC BY-SA 4.0"
"67173139","1","","","2021-04-20 05:48:10","","0","39","<p>I am using the dropdown library. When you press a button, you want to develop it in a format where text changes on the button when you click an element.I can print but I don't know how to change the text of the button. And I want to change the sort order of the table view when I click that element. How should I do it?</p>
<pre><code>    func dropDown() {
        sequenceDropDown.dataSource = [&quot;Latest order
&quot;, &quot;Priority&quot;]
        sequenceDropDown.show()
        sequenceDropDown.anchorView = sequence
        sequenceDropDown.bottomOffset = CGPoint(x: 0, y:(sequenceDropDown.anchorView?.plainView.bounds.height)!)
        sequenceDropDown.selectedTextColor = .white
        sequenceDropDown.selectionBackgroundColor = .mainColor
}
</code></pre>
<p>This is dropDown function.</p>
<pre><code>  output.loadData.bind(to: tableView.rx.items(cellIdentifier: &quot;mainCell&quot;, cellType: MainCell.self)) { row, element, cell in
            cell.nameLbl.text = element.nickname
            cell.titleTxtField.text = element.title
            cell.contentTxtView.text = element.description
            cell.postImage.image = UIImage(named: element.media)
            cell.timeLbl.text = element.date
            cell.sirenBtn.rx.tap.subscribe(onNext: { _ in
                self.selectIndexPath.accept(row)
            }).disposed(by: self.disposeBag)
            
        }.disposed(by: disposeBag)
</code></pre>
<p>This is binding tableview code.</p>
","14063311","","","","","2021-04-20 06:06:39","Swift dropDown library","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"67179345","1","67179487","","2021-04-20 12:52:21","","0","37","<p>I am trying to implement UI state using a <code>ViewModel</code>, <code>BehaviorRelay</code>, and <code>State</code> (which is an enum).</p>
<p><strong>In the ViewModel:</strong></p>
<pre><code>class MyViewModel {
    ...
    let state = BehaviorRelay&lt;State?&gt;(value: nil)
    ...
}
</code></pre>
<p><strong>Observing changes in VC:</strong></p>
<pre><code>viewModel.state.asDriver().drive { state in
    // Problem is here. &quot;state&quot; seems to be of type Observable&lt;State?&gt; instead of actual State enum
}
</code></pre>
<p><strong>Here's how I see the type that comes from the Driver:</strong></p>
<p><a href=""https://i.stack.imgur.com/D235n.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/D235n.png"" alt=""enter image description here"" /></a></p>
<p><strong>And here's a bunch of errors when I try to handle it using switch:</strong></p>
<p><a href=""https://i.stack.imgur.com/31rcT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/31rcT.png"" alt=""enter image description here"" /></a></p>
<p>I am using the exact same code to observe other types of data and it works. It seems only when I try to use BehaviorRelay with enums, this happens. Can someone please point me in the right direction?</p>
","2454356","","","","","2021-04-20 13:01:43","Using enum with BehaviorRelay brings a different type of value downstream and makes it impossible to handle","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"67205702","1","67212570","","2021-04-22 01:55:59","","1","29","<p>Consider the below code.</p>
<ol>
<li>On tapButton, we subscribe to an Observable <code>isFetched</code> and then call <code>fetchPopularMovies()</code>.</li>
<li><code>fetchPopularMovies()</code> in turn calls an API. When the response is received, we will send <code>OnNext(true)</code> event.</li>
</ol>
<p>Problem is, I receive multiple events on 2nd button tap onwards. If I add onCompleted(), I don't even receive events on 2nd button tap onwards. My expectation is that one event will be triggered on each button tap. What am I missing here?</p>
<pre><code>class ViewController: UIViewController {

    let popularMoviesURL = URL(string: &quot;https://api.themoviedb.org/3/movie/popular?api_key=API_KEY&quot;)
    var isFetched = BehaviorSubject&lt;Bool?&gt;(value:nil)
    let disposeBag = DisposeBag()
        
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }

    @IBAction func tapButton(_ sender: Any) {
        let observable = isFetched.asObservable()
        observable.subscribe(onNext: { observer in
            guard let result = observer else { return }
            print(result)
            print(&quot;onNext Recieved&quot;)
            
        }, onError: { _ in
            print(&quot;onError Recieved&quot;)
        }).disposed(by: disposeBag)
        
        fetchPopularMovies()
    }
    
    func fetchPopularMovies() {
        let task = URLSession.shared.dataTask(with: popularMoviesURL!) {(data, response, error) in
            guard let _ = data else { return }
            self.isFetched.onNext(true)
           //self.isFetched.onCompleted()
        }
        task.resume()
    }
}
</code></pre>
","12382480","","","","","2021-04-22 22:17:23","RxSwift Subscriber receiving multiple events","<ios><swift><rx-swift>","1","4","","","","CC BY-SA 4.0"
"67224622","1","67229522","","2021-04-23 05:51:10","","1","35","<p>There is a function that calls the API from the server to return <code>Observable&lt;DataFromServer&gt;</code>.
<br><br>
I want to transform it into necessary data in UI and make it <code>Observable&lt;[DataForUI&gt;</code>.
<br>
I made a sample as below, but I want to simplify the transforming part.
<br><br>
Could you tell me if there is a way?</p>
<pre class=""lang-swift prettyprint-override""><code>
// Models
struct DataFromServer {
  var name: String
  var score: Int
}

struct DataForUI {
  var displayName: String
  var displayScore: String
}

// API function
func fetch() -&gt; Observable&lt;[DataFromServer]&gt; {
  // ...
}

// output
var resultData: PublishRelay&lt;[DataForUI]&gt; = PublishRelay()

// Sample Code
ActionSubject // Trigger for fetch()
  .flatMapLatest { fetch() }
  // I want to simplify the code below.
  .flatMap { data -&gt; Observable&lt;[DataForUI]&gt; in
    return Observable.just(data.map {
      DataForUI(displayName: “convert \($0.name)”, displayScore: “convert \($0.score)”)
    })
  }
  .bind(to: resultData)
  .disposed(by: disposeBag)
</code></pre>
","3569109","","","","","2021-04-23 19:41:56","Is there a way to simplify data trasforming?","<rx-swift>","1","0","","","","CC BY-SA 4.0"
"67257967","1","67258973","","2021-04-25 20:27:28","","1","62","<p>I am trying to do searching in the table view, with the throttle.</p>
<p>Here I have BehaviorRelay in ViewModel</p>
<pre><code>var countryCodes: BehaviorRelay&lt;[CountryDialElement]&gt; = BehaviorRelay&lt;[CountryDialElement]&gt;(value:[])
</code></pre>
<p>Here I have BehaviorRelay for the entered text</p>
<pre><code>var searchText: BehaviorRelay&lt;String&gt; = BehaviorRelay&lt;String&gt;(value: &quot;&quot;)
</code></pre>
<p>Here I have Table View which is binded with Observable from View Model</p>
<pre><code>self.viewModel.params.countryCodes.bind(to: tableView.rx.items(cellIdentifier: &quot;CountryDialTableViewCell&quot;)) { index, model, cell in
      let countryCell = cell as! CountryDialTableViewCell
      countryCell.configure(model)
    }.disposed(by: disposeBag)
</code></pre>
<p>Here I have Rx binding to UISearchBar in ViewController</p>
<pre><code>searchBar
      .rx
      .text
      .orEmpty
      .debounce(.milliseconds(300), scheduler: MainScheduler.instance)
      .distinctUntilChanged()
      .subscribe { [weak self] query in
        guard
          let query = query.element else { return }
        self?.viewModel.params.searchText.accept(query)
      }
      .disposed(by: disposeBag)
</code></pre>
<p>Then in ViewModel, I am trying to filter data and push filtered data to dataSource, to update the tableView.</p>
<pre><code>Observable.combineLatest(params.countryCodes, params.searchText) { items, query in
      return items.filter({ item in
        item.name.lowercased().contains(query.lowercased()) || item.dialCode.lowercased().contains(query.lowercased())
      })
    }.subscribe(onNext: { resultArray in
      self.params.countryCodes.accept(resultArray)
    })
    .disposed(by: disposeBag)
</code></pre>
<p>But I am getting this type of Error</p>
<pre><code>Reentrancy anomaly was detected.
This behavior breaks the grammar because there is overlapping between sequence events.
The observable sequence is trying to send an event before sending the previous event has finished.
Interpretation: This could mean that there is some kind of unexpected cyclic dependency in your code, or that the system is not behaving in an expected way.
</code></pre>
<p>I am trying to achieve:</p>
<ol>
<li>Binded table view with an observable array</li>
<li>Type text in the search bar</li>
<li>Filter observable, array</li>
<li>Update observable, reload tableView.</li>
</ol>
","7606400","","","","","2021-04-25 22:53:17","How can I update tableView from BehaviorRelay observable?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"67259802","1","","","2021-04-26 01:30:07","","0","29","<p>I'm writing a code to send a pin code by email. However, an error occurs in the process of push data. No member error occurs when email is written and sent to emailTxtField.How do I solve this error? I'm not sure what VC.email means. The error occurs at vc.mail = emailTxtField.text!</p>
<pre><code>    private func bindViewModel() {
        let input = SendEmailViewModel.Input(email: emailTxtField.rx.text.orEmpty.asDriver(),
                                             doneTap: nextBtn.rx.tap.asDriver())
        let output = viewModel.transform(input: input)

        output.isEnable.drive(nextBtn.rx.isEnabled).disposed(by: disposeBag)
    
        output.result.emit(onNext: { [unowned self] _ in
            print(&quot;error&quot;)
            nextBtn.isEnabled = true
        }, onCompleted: {[unowned self] in pushData()}
        ).disposed(by: disposeBag)
    }
    
    func pushData() {
        guard let vc = self.storyboard?.instantiateViewController(withIdentifier: &quot;pinCode&quot;) as? VerificationViewController else { return }
        vc.email = emailTxtField.text!
        self.navigationController?.pushViewController(vc, animated: true)
    }
</code></pre>
","14063311","","","","","2021-04-26 01:30:07","Value of type 'Viewcontroller' has no member","<swift><rx-swift>","0","2","","","","CC BY-SA 4.0"
"67263289","1","67327177","","2021-04-26 08:31:19","","1","136","<p>I have two textfields. I want to open a bottomsheet when the first textfield is tapped. And the other textfield is accepting user input regularly.</p>
<p>This is my trigger when the <code>produklistrikDropdown</code> text field with <code>edittingDidBegin</code>.</p>
<pre><code>produkListrikDropDown.rx.controlEvent(.editingDidBegin)
            .subscribe(onNext:{
                self.dismissKeyboard()
                print(&quot;produk Listrik Field did begin&quot;)
                self.viewModel.showProdukListrik()
            })
            .disposed(by: disposeBag)
</code></pre>
<p>And after I choose a product from the bottom sheet it just change the text of the field to the one i choose.</p>
<pre><code>viewModel.currentProdukListBehaviorSubject
            .map{$0?.rawValue}
            .subscribe(onNext: { [unowned self] in
                if produkListrikDropDown.text != $0 {
                    produkListrikDropDown.text = $0
                }
            })
            .disposed(by: disposeBag)
</code></pre>
<p>This is my second textfield configuration. Just a regular textfield receiving input from the user.</p>
<pre><code>idPelangganField.rx.text
            .bind(to: viewModel.currentIdPelangganBehaviorSubject)
            .disposed(by: disposeBag)
</code></pre>
<h2>What Happen</h2>
<p>When I tapped the first textfield and choose a product, its acting okay.
But when I tapped the second textfield and tapped back to the first textfield, the edittingDidBegin on the first textfield triggered twice. This doesn't happen on IOS 12.4.</p>
<p>You can clone this repo to reproduce the problem
<a href=""https://github.com/Bobbyphtr/TextfieldDidEdittingProblem/tree/master"" rel=""nofollow noreferrer"">https://github.com/Bobbyphtr/TextfieldDidEdittingProblem/tree/master</a></p>
","9394756","","9394756","","2021-04-28 07:04:47","2021-04-30 01:45:47","UITextField EditingDidBegin triggered twice on IOS 14.4","<ios><swift><uitextfield><rx-swift>","2","7","","","","CC BY-SA 4.0"
"67338872","1","67348738","","2021-04-30 18:33:40","","1","62","<p>I am new to Rx and trying to one network call.</p>
<p>i mange to do that as follow:</p>
<pre><code>struct Genre: Codable {
var genres: [Genres]?
}

struct Genres: Codable {
var id: Int?
var name: String?
 }

final class GenreViewModel {

let disposeBag = DisposeBag()

var networking: Networking!

let getGeners = PublishRelay&lt;[Genres]&gt;()

var items: PublishRelay&lt;[Genres]&gt;?
var itemsDriver: Driver&lt;[Genres]&gt;?
let isLoading: Driver&lt;Bool&gt;


init(networking: Networking = Networking()) {
    self.networking = networking

    
    let shouldLoadItems = Observable.merge(
    ).debug(&quot;merge.debug(🚘)&quot;)
    .startWith(())
    
    let gg = shouldLoadItems.flatMap {
        networking.preformNetwokTask(
            endPoint: TheMoviedbApi.genre,
            type: Genre.self)
            .debug(&quot;🚘 network call&quot;)
    }
    
    isLoading = Observable.merge(
        shouldLoadItems.map { true },
        gg.map { _ in false }
    )
    .asDriver(onErrorJustReturn: false).debug(&quot;🚘 is loading&quot;)
    
    itemsDriver = gg
        .map { $0.genres! }
        .asDriver(onErrorJustReturn: []).debug(&quot;🚘drive&quot;)
    
}
</code></pre>
<p>i am trying to figure a way of doing it without &quot;let shouldLoadItems&quot;.
something like that:</p>
<pre><code>final class GenreViewModel {

let disposeBag = DisposeBag()

var networking: Networking!

let getGeners = PublishRelay&lt;[Genres]&gt;()

var items: PublishRelay&lt;[Genres]&gt;?
var itemsDriver: Driver&lt;[Genres]&gt;?
let isLoading: Driver&lt;Bool&gt;


init(networking: Networking = Networking()) {
    self.networking = networking
    
   let geners =  getGeners
        .flatMap { geners in
            networking.preformNetwokTask(
                endPoint: TheMoviedbApi.genre,             
               type: Genre.self)
              .debug(&quot;🚘 network call not in use&quot;)
       }.startWith(())
       .share()


    
    isLoading = Observable.merge(
        shouldLoadItems.map { true },
        gg.map { _ in false }
    )
    .asDriver(onErrorJustReturn: false).debug(&quot;🚘 is loading&quot;)

    
    itemsDriver = geners
        .map { $0.genres! }
        .asDriver(onErrorJustReturn: []).debug(&quot;🚘drive&quot;)
    
}
</code></pre>
<p>The vc:</p>
<pre><code>func bindRx() {
    viewModel.isLoading
        .drive(hud.rx.animation)
        .disposed(by: disposeBag)
   
        
    
    viewModel.itemsDriver?.drive(collectionView.rx.items(cellIdentifier: GenreCollectionViewCell.reuseIdentifier, cellType: GenreCollectionViewCell.self)) { (row,item,cell) in
        cell.config(item: item)
    }.disposed(by: disposeBag)
}
</code></pre>
<p>Yet  let geners  not called.
what am i missing out?</p>
","5335109","","5335109","","2021-05-01 17:06:48","2021-05-01 18:25:38","RxSwift, invoking a network call","<ios><swift><mvvm><rx-swift>","1","10","","","","CC BY-SA 4.0"
"67356338","1","","","2021-05-02 12:22:30","","0","23","<p>I am trying to test Realm Database Service with RealmSwift but I get this error in the mock class in the functions addData and fetchData:</p>
<blockquote>
<p>'Data' is ambiguous for type lookup in this context</p>
</blockquote>
<p>In the original class, this error does not appear.</p>
<p>MockPersistence:</p>
<pre><code>@testable import AirWatcher
import RealmSwift

final class MockPersistenceService: PersistenceServiceProtocol {

func addStations(stations: [Station]) throws {
    &lt;#code#&gt;
}

func fetchStations() throws -&gt; Results&lt;Station&gt; {
    &lt;#code#&gt;
}

func addSensors(sensors: [Sensor]) throws {
    &lt;#code#&gt;
}

func fetchSensors() throws -&gt; Results&lt;Sensor&gt; {
    &lt;#code#&gt;
}

func addAddItem(addItem: AddItem) throws {
    &lt;#code#&gt;
}

func addAddItems(addItems: [AddItem]) throws {
    &lt;#code#&gt;
}

func deleteAddItem(addItem: AddItem) throws {
    &lt;#code#&gt;
}

func fetchAddItems() throws -&gt; Results&lt;AddItem&gt; {
    &lt;#code#&gt;
}

func addData(data: [Data]) throws { //the problem appears here
    
}

func fetchData() throws -&gt; Results&lt;Data&gt; { //the problem appears here

}

func addAirQualityIndex(air: [AirQualityIndex]) throws {
    &lt;#code#&gt;
}

func fetchAirQualityIndex() throws -&gt; Results&lt;AirQualityIndex&gt; {
    &lt;#code#&gt;
}

}
</code></pre>
<p>PersistenceService:</p>
<pre><code>import RealmSwift

enum RuntimeError: Error {

case NoRealmSet
}

protocol PersistenceServiceProtocol {

func addStations(stations: [Station]) throws
func fetchStations() throws -&gt; Results&lt;Station&gt;
func addSensors(sensors: [Sensor]) throws
func fetchSensors() throws -&gt; Results&lt;Sensor&gt;
func addAddItem(addItem: AddItem) throws
func addAddItems(addItems: [AddItem]) throws
func deleteAddItem(addItem: AddItem) throws
func fetchAddItems() throws -&gt; Results&lt;AddItem&gt;
func addData(data: [Data]) throws
func fetchData() throws -&gt; Results&lt;Data&gt;
func addAirQualityIndex(air: [AirQualityIndex]) throws
func fetchAirQualityIndex() throws -&gt; Results&lt;AirQualityIndex&gt;
}

final class PersistenceService: PersistenceServiceProtocol {

var realm: Realm?

    
func addStations(stations: [Station]) throws {
    let objects = stations.map { Station(value: $0)}
    autoreleasepool {
        do {
            realm = try Realm()
            try realm!.write {
                realm!.add(objects, update: Realm.UpdatePolicy.modified)
            }
        }
        catch RuntimeError.NoRealmSet
        {
            print(&quot;PERSISTENCE SERVICE: No Realm Database addStations&quot;)
        }
        catch let error as NSError
        {
            print(error.localizedDescription)
        }
    }
}

func addSensors(sensors: [Sensor]) throws {
    let objects = sensors.map { Sensor(value: $0)}
    autoreleasepool {
        do {
            realm = try Realm()
            try realm!.write {
                realm!.add(objects, update: Realm.UpdatePolicy.modified)
            }
        }
        catch RuntimeError.NoRealmSet
        {
            print(&quot;PERSISTENCE SERVICE: No Realm Database addSensors&quot;)
        }
        catch let error as NSError
        {
            print(error.localizedDescription)
        }
    }
}

func addData(data: [Data]) throws {
    let objects = data.map { Data(value: $0)}
    autoreleasepool {
        do {
            self.realm = try Realm()
            try self.realm!.write {
                self.realm!.add(objects, update: Realm.UpdatePolicy.modified)
            }
        }
        catch RuntimeError.NoRealmSet
        {
            print(&quot;PERSISTENCE SERVICE: No Realm Database addData&quot;)
        }
        catch let error as NSError
        {
            print(error.localizedDescription)
        }
    }
}

func addAirQualityIndex(air: [AirQualityIndex]) throws {
    let objects = air.map { AirQualityIndex(value: $0)}
    autoreleasepool {
        do {
            self.realm = try Realm()
            try self.realm!.write {
                self.realm!.add(objects, update: Realm.UpdatePolicy.modified)
            }
        }
        catch RuntimeError.NoRealmSet
        {
            print(&quot;PERSISTENCE SERVICE: No Realm Database addAirQualityIndex&quot;)
        }
        catch let error as NSError
        {
            print(error.localizedDescription)
        }
    }
}

func addAddItem(addItem: AddItem) throws {
    autoreleasepool {
    do {
        realm = try Realm()
        try realm!.write {
            realm!.add(addItem, update: Realm.UpdatePolicy.modified)
        }
    }
    catch RuntimeError.NoRealmSet
    {
        print(&quot;PERSISTENCE SERVICE: No Realm Database addAddItem&quot;)
    }
    catch let error as NSError
    {
        print(error.localizedDescription)
    }
    }
}

func addAddItems(addItems: [AddItem]) throws {
    let objects = addItems.map { AddItem(value: $0)}
    autoreleasepool {
        do {
            self.realm = try Realm()
            try self.realm!.write {
                self.realm!.add(objects, update: Realm.UpdatePolicy.modified)
            }
        }
        catch RuntimeError.NoRealmSet
        {
            print(&quot;PERSISTENCE SERVICE: No Realm Database addAddItems&quot;)
        }
        catch let error as NSError
        {
            print(error.localizedDescription)
        }
    }
}

func deleteAddItem(addItem: AddItem){
    let realm = try! Realm()
    try! realm.write {
        if let itemToDelete = realm.object(ofType: AddItem.self, forPrimaryKey: addItem.id) {
            realm.delete(itemToDelete)
        }
    }
}

func fetchAddItems() throws -&gt; Results&lt;AddItem&gt; {
    do {
        let realm = try Realm()
        return realm.objects(AddItem.self)
    }
    catch {
        throw RuntimeError.NoRealmSet
    }
}
    
func fetchStations() throws -&gt; Results&lt;Station&gt; {
        do {
            realm = try Realm()
            return realm!.objects(Station.self)
        }
        catch {
            throw RuntimeError.NoRealmSet
        }
    }

func fetchSensors() throws -&gt; Results&lt;Sensor&gt; {
    do {
        realm = try Realm()
        return realm!.objects(Sensor.self)
    }
    catch {
        throw RuntimeError.NoRealmSet
    }
  }

func fetchData() throws -&gt; Results&lt;Data&gt; {
    do {
        realm = try Realm()
        return realm!.objects(Data.self)
    }
    catch {
        throw RuntimeError.NoRealmSet
}
}

func fetchAirQualityIndex() throws -&gt; Results&lt;AirQualityIndex&gt; {
    do {
        let realm = try Realm()
        return realm.objects(AirQualityIndex.self)
    }
    catch {
        throw RuntimeError.NoRealmSet
    }
}
</code></pre>
<p>}</p>
<p>Data:</p>
<pre><code>import Foundation.NSURL
import RealmSwift

class Data: Object, Decodable, Identifiable {

@objc dynamic var id: Int = 0
@objc dynamic var stationId: Int = 0
@objc dynamic var key: String = &quot;&quot;
var values = List&lt;Value&gt;()

convenience init(id: Int, stationId: Int, key: String, values: [Value]) {
    self.init()
    self.id = id
    self.stationId = stationId
    self.key = key
    self.values.append(objectsIn: values)
}

private enum CodingKeys: String, CodingKey {
    case key = &quot;key&quot;
    case values = &quot;values&quot;
}

override class func primaryKey() -&gt; String? {
    return &quot;id&quot;
}
</code></pre>
<p>}</p>
<p>class Value: Object, Decodable {</p>
<pre><code>@objc dynamic var date: String? = &quot;&quot;
var value = RealmOptional&lt;Double&gt;()

convenience init(date: String, value: RealmOptional&lt;Double&gt;) {
    self.init()
    self.date = date
    self.value = value
}
</code></pre>
<p>}</p>
","11056400","","","","","2021-05-02 12:22:30","'Data' is ambiguous for type lookup in this context","<ios><realm><rx-swift>","0","3","","","","CC BY-SA 4.0"
"67410853","1","67413407","","2021-05-06 01:52:23","","1","94","<p>Initially the app shows UIViewCollection with one section and then new sections appears after receiving the content. A user scrolls the collection and new sections add to the bottom of the collection.</p>
<p>I use MVVM, so in my ViewModel I add a new section to the content array (model.content) and then notify the Publisher that binded to collectionView.rx.items(dataSource: self.dataSource).</p>
<p>So every time I add the section the collection is flashing and all cells are reloading that makes horrible user experience everything flashing, flickering, pictures disappearing and appearing. Is there a way not to reload all the collection but only the difference. I thought it should work like this by default. Maybe the method of notifying the BehaviorSubject is wrong idea?</p>
<p>I also tried to use the RxTableViewSectionedAnimatedDataSource but in this way everything disappearing and move the user to the very top of the collection view after every new section had beed added.</p>
<p>Please any idea why would all collection should be reloaded if I just added one section to the bottom, how to prevent it?</p>
<pre><code>typealias ContentDataSource = RxCollectionViewSectionedReloadDataSource&lt;ContentSection&gt;

class ContentViewController: BaseViewController&lt;ContentViewModel&gt; {

    func setupBindings() {
         viewModel?.sectionItemsSubject
                .bind(to: collectionView.rx.items(dataSource: self.dataSource))
                .disposed(by: self.disposeBag)
    }
}


class ContentViewModel: BaseViewModel&lt;ContentModel&gt; {

    lazy var sectionItemsSubject = BehaviorSubject&lt;[ContentSection]&gt;(value: model.content)

    func updateGeneratedSection(_ section: ContentSection) {
        model.content.append(item)
        sectionItemsSubject.onNext(self.model.content)
    }
}

struct ContentModel {
  
    var content: [ContentSection] = []
}
</code></pre>
<p><strong>EDITED</strong>:</p>
<pre><code>struct ContentSection {
    
    var id: String
    var items: [Item]
    var order: Int
}

extension ContentSection: SectionModelType {
    
    typealias Item = ItemCellModel
    
    init(original: ContentSection, items: [ItemCellModel]) {
        self = original
        self.items = items
    }
}

struct ItemCellModel {

    let id: String
    let img: String
   
    
    init(id: String, img: String) {
       self.id = id
       self.img = img
   }
}
</code></pre>
","2831157","","2831157","","2021-05-06 18:32:18","2021-05-07 22:38:42","RxDataSources flashing and flickering on every change in the datasource content","<ios><swift><rx-swift><rxdatasources>","2","2","","","","CC BY-SA 4.0"
"67496839","1","67497291","","2021-05-12 03:10:01","","1","97","<p>I have a UITableViewCell, and it contain a UICollectionView.
I put data for collection view in dataSource's tableview.</p>
<pre><code>class HomeTableViewCell: UITableViewCell {
    var disposeBag = DisposeBag()
    @IBOutlet weak var collectionItems: UICollectionView!
    var listItem: PublishSubject&lt;HomeResultModel&gt; = PublishSubject&lt;HomeResultModel&gt;()
    let dataSource = RxCollectionViewSectionedReloadDataSource&lt;SectionOfMenuData&gt;(configureCell: {(_, _, _, _) in
        fatalError()
    })

override func awakeFromNib() {
    super.awakeFromNib()
    setup()
    setupBinding()
}

override func prepareForReuse() {
    disposeBag = DisposeBag()
}

func setup() {
    collectionItems.register(UINib(nibName: MenuCollectionViewCell.identifier, bundle: nil), forCellWithReuseIdentifier: MenuCollectionViewCell.identifier)
    collectionItems.register(UINib(nibName: RecipeCollectionViewCell.identifier, bundle: nil), forCellWithReuseIdentifier: RecipeCollectionViewCell.identifier)
    collectionItems.rx.setDelegate(self).disposed(by: disposeBag)
    
    collectionItems.rx.modelAndIndexSelected(HomeListModel.self).subscribe { (model, index) in
        if let recipesID = model.recipesID {
            tlog(tag: self.TAG, sLog: &quot;recipesID : \(recipesID)&quot;)
            self.recipeIdSelected.onNext(&quot;\(recipesID)&quot;)
        }
    }.disposed(by: disposeBag)
    
    dataSource.configureCell = { (dataSource, collectionView, indexPath, item) -&gt; UICollectionViewCell in
        let cellType = dataSource.sectionModels.first?.type ?? .recipeCell
        if cellType == .menuCell {
            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: MenuCollectionViewCell.identifier, for: indexPath) as! MenuCollectionViewCell
            cell.showInfo(item)
            return cell
        } else {
            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: RecipeCollectionViewCell.identifier, for: indexPath) as! RecipeCollectionViewCell
            cell.showInfo(item.recipesName ?? &quot;&quot;, imageLink: item.imageThumb ?? &quot;&quot;)
            return cell
        }
    }
}

func setupBinding() {        
    listItem.map { model -&gt; [SectionOfMenuData] in
        let modelID = try JSONEncoder().encode(model.id)
        let modelResultID = String.init(data: modelID, encoding: .utf8)!
        return [SectionOfMenuData(type: modelResultID == &quot;0&quot; ? .menuCell : .recipeCell, id: modelResultID, items: model.list)]
    }.bind(to: collectionItems.rx.items(dataSource: dataSource))
    .disposed(by: disposeBag)
}
}
</code></pre>
<p>I pass data for tableviewcell with code:</p>
<pre><code>let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionOfHome&gt; { dataSource, tableView, indexPath, item in
            let cell = tableView.dequeueReusableCell(withIdentifier: HomeTableViewCell.identifier, for: indexPath) as! HomeTableViewCell
            cell.listItem.onNext(item)
            return cell
        }
</code></pre>
<p>First show it ok, but when scroll tableview, I reset DisposeBag in:</p>
<pre><code>func prepareForReuse{ 
    disposeBag = DisposeBag()
}
</code></pre>
<p>and so tableview show blank.
How wrong was I in this regard?</p>
","2756146","","2756146","","2021-05-12 03:56:43","2021-05-12 04:19:48","RxSwift DisposeBag and UITableViewCell","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"67532408","1","67616620","","2021-05-14 09:57:26","","0","149","<p>I'm using Carthage for setting up my project's RxSwift dependency. And recently, I tried to use XCFrameworks instead with the command <code>carthage update --platform ios --use-xcframeworks</code>. I've set up all that is needed to be set (eg. changing the .frameworks to .xcframeworks in the <code>Link Binary With Libraries</code> in the targets' <code>Build Phase</code>, etc). It worked and I can run or test in the simulator, until today that is. When I was trying to do the tests this morning, all of a sudden it failed (although it worked fine before) with the error <code>No such module 'RxBlocking'</code>. I've double-checked it and the xcframework has already been built in the <code>Carthage/Build</code> folder, and the xcframework has already been added to the test target's settings.</p>
<p>I've tried all of these but it all failed:</p>
<ol>
<li>Setting the <code>$(PROJECT_DIR)/Carthage/Build</code> to the <code>Framework Search Paths</code> for the target</li>
<li>Deleting <code>DerivedData/</code> and/or <code>Carthage/</code> folders</li>
<li>Resetting the Mac</li>
</ol>
<p>Can anybody help me to fix this? BTW, I'm on XCode 12.4 and Swift 5. Thanks.</p>
","4124849","","","","","2021-05-20 08:22:03","No such module 'RxBlocking' in test target","<ios><xcode><rx-swift><carthage><xcframework>","1","0","","","","CC BY-SA 4.0"
"67550198","1","67556822","","2021-05-15 18:46:45","","1","60","<p>I've got a function that will return an observable that will emit an enum based on what stage it is currently on. The enum basically goes like this:</p>
<pre><code>enum ViewModelAction {
    case inputEnabled(isEnabled: Bool)
    case loadingIndicatorShown(isShown: Bool)
    case errorMessageShownIfAvailable(error: Error?)
    case loadUIData(with entity: Entity)
    case startSession(for entity: Entity)
    case endSession(for entity: Entity)
    case loadEndUIData(with entity: Entity)
}
</code></pre>
<p>Now what I want the function do is like so:</p>
<ol>
<li>Function start with input params -&gt; go to 2</li>
<li>Do:
<ul>
<li>Emit disable input from UI</li>
<li>Emit show loading indicator</li>
<li>Call API to create session based on input params -&gt; API returns session data -&gt; go to 3</li>
</ul>
</li>
<li>Do:
<ul>
<li><p>If success -&gt; go to 4</p>
</li>
<li><p>If error:</p>
<ul>
<li>Emit enable input from UI</li>
<li>Emit hide loading indicator</li>
<li>Emit show error with the error -&gt; Complete stream</li>
</ul>
</li>
</ul>
</li>
<li>Do:
<ul>
<li><p>Loop and call API to poll the entity based on the session with the status of READY:</p>
<ul>
<li>If success with READY status -&gt; Emit load UI data with entity -&gt; go to 5</li>
<li>If success with non READY status -&gt; loop again / back to 4</li>
<li>If error -&gt; Emit show error with the error -&gt; Loop again / back to 4</li>
</ul>
</li>
</ul>
</li>
<li>Do:
<ul>
<li>Call API to start session using the entity -&gt; API returns session data -&gt; go to 6</li>
</ul>
</li>
<li>Do:
<ul>
<li><p>If success:</p>
<ul>
<li>Emit enable input from UI</li>
<li>Emit hide loading indicator</li>
<li>Emit start session for entity -&gt; Complete stream</li>
</ul>
</li>
<li><p>If error:</p>
<ul>
<li>Emit enable input from UI</li>
<li>Emit hide loading indicator</li>
<li>Emit show error with the error -&gt; Complete stream</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>So in a way, for a successful run, it will emit this exact sequence:</p>
<pre><code>Observable.merge(
    .just(ViewModelAction.inputEnabled(isEnabled: false)),
    .just(ViewModelAction.loadingIndicatorShown(isShown: true)),
    .just(ViewModelAction.loadUIData(with: entity)),
    .just(ViewModelAction.inputEnabled(isEnabled: true)),
    .just(ViewModelAction.loadingIndicatorShown(isShown: false)),
    .just(ViewModelAction.startSession(for: entity)),
    .complete()
)
</code></pre>
<p>I have actually done this, but I was thinking that it is not that clear and very complicated.</p>
<pre><code>protocol SessionHandlerProtocol {
    func create(for userId: String) -&gt; Observable&lt;SessionData&gt;
    func start(session: SessionData, entity: Entity) -&gt; Observable&lt;Void&gt;
}

protocol EntityPollerProtocol {
    var entity: Observable&lt;Entity?&gt; { get }
    func startPolling(for session: SessionData) //Will poll and emit to entity observable
    finc stopPolling()
}

class StartSessionStrategy {
    private let sessionHandler: SessionHandlerProtocol
    private let entityPoller: EntityPollerProtocol
    init(sessionHandler: SessionHandlerProtocol,
         entityPoller: EntityPollerProtocol) {

        self.sessionHandler = sessionHandler
        self.entityPoller = entityPoller
    }

    func handleSession(with userId: String) -&gt; Observable&lt;ViewModelAction&gt; {
        let initialUIObservable = 
            Observable.from(ViewModelAction.inputEnabled(isEnabled: false),
                            ViewModelAction.loadingIndicatorShown(isShown: true))

        let sharedCreateSession = 
            sessionHandler.create(for: userID).materialize.share()

        let createSessionError =
            sharedCreateSession
                .flatMapLatest {
                    switch $0 {
                    case .error(let error):
                        return Observable.merge(
                            .just(ViewModelAction.inputEnabled(isEnabled: true)),
                            .just(ViewModelAction.loadingIndicatorShown(isShown: false)),
                            .just(ViewModelAction.errorMessageShownIfAvailable(error: error)),
                            .complete()
                        )
                    default:
                        return .never()
                }

        let createSessionSuccess = 
            sharedCreateSession
                .flatMapLatest {
                    switch $0 {
                    case .next(let element):
                        return .just(element)
                    default:
                        return .never()
                }

        let sharedEntityPoller = 
            createSessionSuccess
                .do(onNext: { [weak self] in self?.entityPoller.startPolling(for: $0) })
                .withLatestFrom(entityPoller.entity) { return ($0, $1) }
                .materialize()
                .share()

        let entityPollerError =
            sharedEntityPoller
                .flatMapLatest {
                    switch $0 {
                    case .error(let error):
                        return .just(ViewModelAction.errorMessageShownIfAvailable(error: error))
                    default:
                        return .never()
                }

        let entityPollerSuccessWithReadyStatus = 
            sharedEntityPoller
                .filter { (_, entity) entity.status = .ready }
                .flatMapLatest {
                    switch $0 {
                    case .next(let element):
                        return .just(element)
                    default:
                        return .never()
                }
                .do(onNext: { [weak self] _ in self?.stopPolling() })

        let doOnEntityPollerSuccessWithReadyStatus = 
                entityPollerSuccessWithReadyStatus
                    .map { return ViewModelAction.loadUIData(with: $0.1) }

        let sharedStartSession = 
            entityPollerSuccessWithReadyStatus
                .flatMapLatest { [weak self] (session, entity) in
                    self?.sessionHandler
                        .start(session: userID, entity: entity)
                        .map { return (session, entity) }
                }.materialize.share()

        let startSessionError =
            sharedStartSession
                .flatMapLatest {
                    switch $0 {
                    case .error(let error):
                        return Observable.merge(
                            .just(ViewModelAction.inputEnabled(isEnabled: true)),
                            .just(ViewModelAction.loadingIndicatorShown(isShown: false)),
                            .just(ViewModelAction.errorMessageShownIfAvailable(error: error)),
                            .complete()
                        )
                    default:
                        return .never()
                }

        let startSessionSuccess = 
            sharedStartSession
                .flatMapLatest {
                    switch $0 {
                    case .next(let element):
                        return Observable.merge(
                            .just(ViewModelAction.inputEnabled(isEnabled: true)),
                            .just(ViewModelAction.loadingIndicatorShown(isShown: false)),
                            .just(ViewModelAction.startSession(for: element.1)),
                            .complete
                        )
                    default:
                        return .never()
                }

        return Observable.merge(
            initialUIObservable,
            createSessionError,
            entityPollerError,
            doOnEntityPollerSuccessWithReadyStatus,
            startSessionError,
            startSessionSuccess
        )
    }
}
</code></pre>
<p>As you can see, the function is pretty big and not that clear. Do you have a suggestion how to refactor this into a cleaner code? Thanks.</p>
","4124849","","4124849","","2021-05-16 03:12:34","2021-05-17 01:12:41","How to create a function that returns an observable that will emit multiple times?","<ios><rx-swift>","1","0","","","","CC BY-SA 4.0"
"67592278","1","67592451","","2021-05-18 18:48:37","","1","74","<p>So, I have this function which is copied from <a href=""https://gist.github.com/kean/64b9fc0963fd430594fdb3eb848bccf3"" rel=""nofollow noreferrer"">this</a> GitHub gist.</p>
<pre><code>protocol ClientProtocol {
    func request&lt;Response: Codable&gt;(_ endpoint: Endpoint&lt;Response&gt;)-&gt; Single&lt;Response&gt;
}

final class Client: ClientProtocol {
    
    private let manager: Alamofire.Session
    private let baseURL = URL(string: &quot;http://192.168.20:8080&quot;)!
    private let queue = DispatchQueue(label: &quot;&lt;your_queue_label&gt;&quot;)
    
    init(accessToken: String) {
        let configuration = URLSessionConfiguration.default
        configuration.headers.add(name: &quot;Authorization&quot;, value: &quot;Bearer \(accessToken)&quot;)
        configuration.timeoutIntervalForRequest = 15
        self.manager = Alamofire.Session.init(configuration: configuration)
        //self.manager.retrier = OAuth2Retrier()
    }
    
    func request&lt;Response&gt;(_ endpoint: Endpoint&lt;Response&gt;) -&gt; Single&lt;Response&gt; {
        return Single&lt;Response&gt;.create { observer in
            let request = self.manager.request(
                self.url(path: endpoint.path),
                method: httpMethod(from: endpoint.method),
                parameters: endpoint.parameters
            )
            request
                .validate()
                .responseData(queue: self.queue) { response in
                    let result: Result&lt;Response, AFError&gt; = response.result.flatMap(endpoint.decode)
                    switch result {
                        case let .success(val): observer(.success(val))
                        case let .failure(err): observer(.error(err))
                    }
                }
            return Disposables.create {
                request.cancel()
            }
        }
    }
    
    private func url(path: Path) -&gt; URL {
        return baseURL.appendingPathComponent(path)
    }
}

private func httpMethod(from method: Method) -&gt; Alamofire.HTTPMethod {
    switch method {
        case .get: return .get
        case .post: return .post
        case .put: return .put
        case .patch: return .patch
        case .delete: return .delete
    }
}


private class OAuth2Retrier: Alamofire.RequestRetrier {
    func retry(_ request: Request, for session: Session, dueTo error: Error, completion: @escaping (RetryResult) -&gt; Void) {
        if (error as? AFError)?.responseCode == 401 {
            // TODO: implement your Auth2 refresh flow
            // See https://github.com/Alamofire/Alamofire#adapting-and-retrying-requests
        }
        // completion(false, 0)
    }
}
</code></pre>
<p><strong>Endpoint</strong></p>
<pre><code>// MARK: Defines
typealias Parameters = [String: Any]
typealias Path = String

enum Method {
    case get, post, put, patch, delete
}


// MARK: Endpoint
final class Endpoint&lt;Response&gt; {
    
    let method: Method
    let path: Path
    let parameters: Parameters?
    let decode: (Data) throws -&gt; Response
    
    init(method: Method = .get, path: Path, parameters: Parameters? = nil, decode: @escaping (Data) throws -&gt; Response) {
        self.method = method
        self.path = path
        self.parameters = parameters
        self.decode = decode
    }
}


// MARK: Convenience
extension Endpoint where Response: Swift.Decodable {
    convenience init(method: Method = .get,  path: Path,  parameters: Parameters? = nil) {
        self.init(method: method, path: path, parameters: parameters) {
            try JSONDecoder().decode(Response.self, from: $0)
        }
    }
}


extension Endpoint where Response == Void {
    convenience init(method: Method = .get, path: Path, parameters: Parameters? = nil) {
        self.init(method: method, path: path, parameters: parameters, decode: { _ in () })
    }
}
</code></pre>
<p>At <code>let result = response.result.flatMap(endpoint.decode)</code> xCode is throwing</p>
<blockquote>
<p><code>Type of expression is ambiguous without more context</code></p>
</blockquote>
<p>The type of the <code>response.result</code> is <code>Result&lt;Data, AFError&gt;</code></p>
<p>I want to flatmap it to <code>Result&lt; Response, AFError&gt;</code>.</p>
<p>I tried</p>
<pre><code>let result = response.result.flatMap { (data) -&gt; Result&lt;Response, AFError&gt; in
 // don't know what to put here
}
</code></pre>
","7436566","","7436566","","2021-05-18 19:38:36","2021-05-18 19:57:59","How to use flatmap with Result in Swift","<ios><swift><rx-swift>","2","12","","","","CC BY-SA 4.0"
"67631348","1","","","2021-05-21 05:38:35","","1","35","<p>Currently I have the following working code:</p>
<pre><code>    mainView.saveButton.rx.tap.bind { [weak self] in
        if let self = self {
            // start indicator
            self.viewModel.save() // Completable
                .subscribe(onCompleted: { [weak self] in
                    // completed
                }, onError: { error in
                    // error
                })
                .disposed(by: self.disposeBag)
        }
    }.disposed(by: disposeBag)
</code></pre>
<p>But I know it is not a good approach (due to nested subscriptions), so I am trying to create working equivalent (now with no success):</p>
<pre><code>    mainView.saveButton.rx.tap
        .do(onNext: { [weak self] in
            // start indicator
        })
        .flatMapFirst { _ in
            self.viewModel.save() // Completable
        }
        .subscribe(onError: { error in
            // error
        }, onCompleted: { [weak self] in
            // completed
        })
        .disposed(by: disposeBag)
</code></pre>
<p>Subscribe closure is not calling at all. Why?</p>
","2725435","","2725435","","2021-05-21 05:57:16","2021-05-21 19:32:57","How to perform subscription within subscription using RxSwift?","<ios><swift><rx-swift>","1","2","1","","","CC BY-SA 4.0"
"67646668","1","67650247","","2021-05-22 06:18:45","","2","97","<p>I am working in a old project that mixes Objective-C and Swift, there is a lot of legacy code in Objective-C, so migrating everything to Swift is not realistic. New code is written in Swift but Objective-C needs to be mantained with small updates.</p>
<p>And I have been working with RxSwift recently and I want to start using in this old project too.</p>
<p>The problem is the Objective-C &lt;-&gt; Swift interoperability.</p>
<p>e.g. I can't write this:</p>
<pre><code>@objc let int = BehaviorSubject&lt;Int&gt;(value: 42)
</code></pre>
<p>Because I get <em>Property cannot be marked @objc because its type cannot be represented in Objective-C</em></p>
<p>How can I deal with this situation? Is anyone using RxSwift in a mixed objc/swift project?</p>
","11963674","","11963674","","2021-05-22 06:37:40","2021-05-22 13:50:35","How to use RxSwift in project with Objective-C code?","<swift><objective-c><rx-swift>","1","5","","","","CC BY-SA 4.0"
"67677028","1","","","2021-05-24 18:17:48","","-1","61","<p>I'm building a native IOS app using SwiftUI. I should use RXSwift to validate some fields of a form live, before the user clicks a button. In particular, I would need the validation checks on a text field, on a date, on a numeric field and on an email field.</p>
<p>Excuse me if the question is a bit generic, but I'm a beginner with applications.</p>
<p>Could someone please explain me how I could do the validation using SwiftUI and RXSwift? If you had any examples, it would be perfect.</p>
<p>Thanks in advance for your kindness!</p>
","15954801","","","","","2021-05-24 19:49:10","SwiftUI Form Validation using RXSwift?","<ios><validation><swiftui><rx-swift>","1","0","","","","CC BY-SA 4.0"
"67692248","1","67693139","","2021-05-25 16:41:55","","1","62","<p>I have an array of numbers, and I want the <code>tableview</code> to show the number(s) that I entered in searchbar. This is my code, I don't know what shall I write in the line after (instead of) <code>.subscribe</code></p>
<pre><code>let dataSource = BehaviorRelay(value: [String]())
let disposeBag = DisposeBag()
var numbers = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]

override func viewDidLoad() {
    super.viewDidLoad()
    
    dataSource.accept(numbers)
    
    searchBar.rx.text.orEmpty
        .throttle(.milliseconds(2000), scheduler: MainScheduler.instance)
        .filter{self.numbers.contains($0)}
        .subscribe(onNext: 
            
        })
    self.dataSource
        .asObservable()
        .bind(to: tableView.rx.items(cellIdentifier: &quot;Cell&quot;, cellType: TableViewCell.self)) {(row, element, cell) in
            cell.textLabel?.text = element
        }
        .disposed(by: disposeBag)
</code></pre>
<p>Maybe it doesn't work because of other reasons, anyway thank you for help</p>
","14685458","","14437411","","2021-05-25 17:17:46","2021-05-26 22:53:46","How to bind UISearchBar to UITableView with RxSwift","<ios><swift><uitableview><uisearchbar><rx-swift>","1","0","","","","CC BY-SA 4.0"
"67724985","1","","","2021-05-27 15:07:04","","0","37","<p>I'm mapping a json response coming from this <a href=""http://www.reddit.com/reddits.json"" rel=""nofollow noreferrer"">http://www.reddit.com/reddits.json</a> but i only need few from that json so i map it like the code below and i also do the request inside the Users</p>
<pre><code>class Users: Mappable {

    var kind: String?
    var data: Data?

    required init?(map: Map){
    }

    func mapping(map: Map) {
        kind &lt;- map[&quot;kind&quot;]
        data &lt;- map[&quot;data&quot;]
    }
}

class Children: Mappable {

    var kind: String?
    var data: Data?

    required init?(map: Map){
    }

    func mapping(map: Map) {
        kind &lt;- map[&quot;kind&quot;]
        data &lt;- map[&quot;data&quot;]
    }
}

class Data: Mappable {

    var title: String?
    var displayNamePrefixed: String?
    

    required init?(map: Map){
    }

    func mapping(map: Map) {
        title &lt;- map[&quot;title&quot;]
        displayNamePrefixed &lt;- map[&quot;display_name_prefixed&quot;]
    }
}

extension Users {
    
    static func getUsers() -&gt; Single&lt;[Users]&gt; {
        let path = API.Path.users.details
        let params: [String: Any] = [
            &quot;utcOffset&quot;: TimeZone.current.utcOffset
        ]
        return API.requestMany(path: path, method: .get, parameters: params)
    }
}
</code></pre>
<p>Here's my code for the request</p>
<pre><code>    static func requestMany&lt;T&gt;(path: String, method: HTTPMethod, parameters: [String: Any] = [:]) -&gt; Single&lt;[T]&gt; where T: BaseMappable {
        return NetworkManager.shared.request(path: path, method: method, parameters: parameters)
            .flatMap { (response) -&gt; Observable&lt;[T]&gt; in
                print(&quot;HOST:\(baseURL)&quot;)
                print(&quot;PATH:\(path)&quot;)
                print(&quot;PARAMETERS:\(parameters)&quot;)
                print(&quot;RESPONSE:\(response?.description ?? &quot;&quot;)&quot;)
                if let error = response as? NSError {
                    return Observable&lt;[T]&gt;.error(error)
                }
                guard let json = response as? [[String: Any]] else {
                    return Observable&lt;[T]&gt;.error(NSError(domain: path,
                                                         code: -1,
                                                         userInfo: [NSLocalizedDescriptionKey: &quot;Object mapping failed&quot;]))
                }
                let array = Mapper&lt;T&gt;().mapArray(JSONArray: json)
                return Observable&lt;[T]&gt;.just(array)
            }
            .observeOn(MainScheduler.instance)
            .asSingle()
    }
</code></pre>
<p>it said object mapping failed even if there's a response that i can see in the console</p>
<pre><code>Object mapping failed
Unhandled error happened: Error Domain=reddits.json Code=-1 &quot;Object mapping failed&quot; UserInfo={NSLocalizedDescription=Object mapping failed}
</code></pre>
","11207211","","","","","2021-05-27 15:07:04","Object mapping failed but there's a response","<swift><alamofire><rx-swift><objectmapper>","0","0","","","","CC BY-SA 4.0"
"67727464","1","","","2021-05-27 17:50:30","","0","45","<p>I have a data model, when it changes, there is no reboot in the controller. How can it be organized?</p>
<p>need professional help in RxSwift</p>
<p><strong>ViewModel</strong></p>
<pre><code>import RxCocoa

import RxSwift

import RxDataSources

protocol MessagesViewModelProtocolChanges {
    var reloading: Driver&lt;Bool&gt;! { get }
    var errorOccured: Driver&lt;String&gt;! { get }
    var sections:BehaviorSubject&lt;[ListSection]&gt; {get}
    func configure(bindings: MessagesViewModelBindingsChanges)
}


struct MessagesViewModelBindingsChanges {

    let didTriggerRefreshControll: Driver&lt;Void&gt;
    let didPressNewMessageButton: Driver&lt;Void&gt;
    let didTriggerLoadMore: Driver&lt;Void&gt;
    let didChangeSegment: Driver&lt;Int&gt;
    let didDidSelectItem: Driver&lt;IndexPath&gt;
}


final class MessagesViewModelChanges:BaseViewModel, MessagesViewModelProtocolChanges {

    typealias Dependency = HasUserStorage &amp; HasMessagesStorage &amp; HasMessagesService
    var dependencies: Dependency
    var messages_:PublishSubject&lt;[Message]&gt; = PublishSubject&lt;[Message]&gt;()
    var sections: BehaviorSubject&lt;[ListSection]&gt; = BehaviorSubject&lt;[ListSection]&gt;(value: [])
    let router: MessagesRouter
    var sentMsgLoaded = false
    let canLoadMore = BehaviorRelay&lt;Bool&gt;(value: false)
    var currentStudentName: Driver&lt;String&gt;!
    var reloading: Driver&lt;Bool&gt;!
    var errorOccured: Driver&lt;String&gt;!
    let messageType = BehaviorRelay&lt;MessageType&gt;(value: .inbox)
    let pageRelay = BehaviorRelay&lt;Int&gt;(value: 1)
    let loadingRelay = BehaviorRelay&lt;Bool&gt;(value: false)
 
    init(dependencies: Dependency, router: MessagesRouter) {
        self.dependencies = dependencies
        self.router = router
    }
    
    func configure(bindings: MessagesViewModelBindingsChanges) {
        let deps = dependencies
        let activityTracker = ActivityIndicator()
        let errorTracker = ErrorTracker()
        
        let _ = bindings.didChangeSegment.map({ index -&gt; MessageType in
            if index == 0 {
                return MessageType.inbox
            } else {
                return MessageType.sent
            }
        }).drive(messageType)
        
        let messageSentNotification = NotificationCenter.default.rx
            .notification(InAppNotifications.MessageSent)
            .mapToVoid()
            .asDriver(onErrorJustReturn: ())
        
        let updateFromNotification = NotificationCenter.default.rx
            .notification(InAppNotifications.NotificationReceived)
            .mapToVoid()
            .asDriverOnErrorJustComplete()
        
        let reloadTrigger = Driver.merge(bindings.didTriggerRefreshControll,
                                         updateFromNotification,
                                         messageSentNotification,
                                         messageType.mapToVoid().asDriver(onErrorJustReturn: ()))
            .do(onNext: { [unowned self] in
                self.pageRelay.accept(1)
                self.canLoadMore.accept(false)
            })
        
        let loadMoreTrigger = bindings
            .didTriggerLoadMore
            .withLatestFrom(canLoadMore.asDriver()).filter({ $0 })
            .withLatestFrom(loadingRelay.asDriver()).filter({ !$0 })
            .map({ _ in () })
            .do(onNext: { [unowned self] _ in
                self.pageRelay.accept(self.pageRelay.value + 1)
            })
        let trigger = Driver.merge([reloadTrigger, loadMoreTrigger])
        
        trigger.asObservable()
            .withLatestFrom(pageRelay)
            .withLatestFrom(messageType) { return ($0, $1) }
            .observeOn(ConcurrentDispatchQueueScheduler.userInitiated)
            .flatMap { (page, type) -&gt; Observable&lt;[Message]&gt; in
                return deps.messagesService
                    .messages(type: type, limit: Constants.updatesLoadingPageSize, page: page).asObservable()
                    .flatMap({ fetchedMessages -&gt; Observable&lt;[Message]&gt; in
                        
                        print(&quot;reloaded \(fetchedMessages.count) \(page)&quot;)

                        if page == 1 {
                            return deps.messagesStorage.save(messages: fetchedMessages, type: type)
                        } else {
                            
                            return deps.messagesStorage.add(messages: fetchedMessages)
                        }
                    })
                    .trackActivity(activityTracker)
                    .trackError(errorTracker)
                    .catchError({ _ in return .empty() })
                
            }
            .bind { [weak self] messages in
                
                self?.messages_.onNext(messages)
                
            }.disposed(by: disposeBag)
        
        
        activityTracker.asObservable().bind(to: loadingRelay).disposed(by: disposeBag)
        
        reloading = activityTracker.asDriver()
        
        self.messages_.asObservable().withLatestFrom(canLoadMore) { messages, canLoadMore in return (messages, canLoadMore) }.bind { [unowned self] data in
            
            let messages = data.0
            let canLoadMore = data.1
            
            var sctns = [ListSection]()
            
            print(&quot;CURRENT MESSAGES COUNT \(messages.count)&quot;)
            
            
            let unreadMsgCount = messages.filter({$0.isUnread}).count
            ApplicationBadgeManager.shared.unreadMsgCount = unreadMsgCount
            

            DispatchQueue.main.asyncAfter(deadline: .now() + 4) {
                if self.messageType.value == MessageType.inbox {
                    NotificationCenter.default.post(Notification(name: Notification.Name(rawValue: Constants.reloadSideMenuCellNotif)))
                }
            }
            
            if messages.count == 0 {
                sctns =  [ListSection(model: EmptySectionModelName, items: [.empty])]
            } else {
                let items = messages.map({ ListPresentableItem.custom($0) })
                sctns.append(ListSection(model: &quot;currentMessages&quot;, items: items))
            }
            if sctns.count &gt; 0 &amp;&amp; canLoadMore {
                sctns.append(ListSection(model: LoadingSectionModelName, items: [ListPresentableItem.loading]))
            }
            
            self.sections.onNext(sctns)
            
        }.disposed(by: disposeBag)
        
        
        bindings.didDidSelectItem.asObservable().withLatestFrom(sections) {
            ip, sections in return (ip, sections)
        }.bind { [weak self] data in
            
            let ip = data.0
            let sections = data.1
            
            let model = sections[ip.section].model
            guard model != LoadingSectionModelName, model != EmptySectionModelName else {
                return
            }
            guard case ListPresentableItem.custom(let item) = sections[ip.section].items[ip.row],
                  let message = item as? Message else {
                return
            }
            
            self?.router.openMessage(with: message.id, type: message.type)
            
        }.disposed(by: disposeBag)

        
        bindings.didPressNewMessageButton.drive(onNext: { [weak self] in
            self?.router.openNewMessageScreen()
        }).disposed(by: disposeBag) 
        
        
        errorOccured = errorTracker.asDriver().map({ $0.localizedDescription })
        
    }
   
}
</code></pre>
<p><strong>My Controller</strong></p>
<pre><code>class MessagesController: ViewController {


        super.viewDidLoad()

        addSideMenuButton()
        setupViews()
        setupTableView()
        setupRefreshControll()
        setupViewModel()
        setupBindings()
        
        NotificationCenter.default.addObserver(self, selector: #selector(reloadMSGTable), name: NSNotification.Name(rawValue: Constants.reloadMSGTableNotif) , object: nil)
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        navigationController?.navigationBar.hideBottomHairline()
        if #available(iOS 11.0, *) {
            navigationController?.navigationBar.prefersLargeTitles = false
        }
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)

        navigationController?.navigationBar.showBottomHairline()
    }

    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
    @objc func reloadMSGTable() {
        DispatchQueue.main.async {
            self.tableView.reloadData()
        }
    }
    
    func setupViews() {
        navigationItem.title = L10n.Messages.screenTitle
        let writeButton = UIBarButtonItem(
            image: Assets.Images.icWriteMessage.image, style: .plain, target: nil, action: nil)
        self.navigationItem.rightBarButtonItem = writeButton
        self.btnWriteMessage = writeButton
        vSegmentContainer.backgroundColor = Colors.defaultSystemBarsBackground
        segmentControl.setColors(with: Colors.defaultSystemBarsBackground, and: Colors.mainTheme)
        segmentControl.setTitle(L10n.Messages.inboxSegmentTitle, forSegmentAt: 0)
        segmentControl.setTitle(L10n.Messages.sentSegmentTitle, forSegmentAt: 1)
    }

    func setupTableView() {
        tableView.register(LoadingCell.nib, forCellReuseIdentifier: LoadingCell.reuseIdentifier)
        tableView.register(EmptyCell.nib, forCellReuseIdentifier: EmptyCell.reuseIdentifier)
        tableView.register(CommonMessageCell.nib, forCellReuseIdentifier: CommonMessageCell.reuseIdentifier)

        tableView.separatorStyle = .singleLine
        tableView.separatorInset = UIEdgeInsets(top: 0, left: 32, bottom: 0, right: 0)
        tableView.tableFooterView = UIView()

        tableView.rowHeight = UITableView.automaticDimension
    }

    func setupRefreshControll() {
        guard refreshControl.superview == nil else { return }

        if #available(iOS 10.0, *) {
            tableView.refreshControl = refreshControl
        } else {
            tableView.addSubview(refreshControl)
        }
    }
    
    func setupViewModel() {
        
        let didPressNewMessageButton = btnWriteMessage.rx.tap
            .mapToVoid().asDriver(onErrorJustReturn: ())
        let didTriggerRefreshControll = refreshControl.rx.controlEvent(.valueChanged)
            .mapToVoid().asDriverOnErrorJustComplete()
        let bindings = MessagesViewModelBindingsChanges(
            didTriggerRefreshControll: didTriggerRefreshControll,
            didPressNewMessageButton: didPressNewMessageButton,
            didTriggerLoadMore: willDisplayLastCellSubject.asDriverOnErrorJustComplete(),
            didChangeSegment: segmentControl.rx.value.asDriver(),
            didDidSelectItem: tableView.rx.itemSelected.asDriver())
        viewModel.configure(bindings: bindings)
    }

</code></pre>
<p>I can't figure out how to call the refresh of the entire model in the viewWillAppear or viewDidLoad method. I tried to do reload data, it doesn't help.</p>
","16050321","","10408494","","2021-05-28 12:30:38","2021-05-28 12:30:38","How the controller to reload the ViewModel?","<swift><rx-swift>","0","0","","","","CC BY-SA 4.0"
"67758957","1","67761020","","2021-05-30 07:52:11","","2","58","<p>This is code I am using currently:</p>
<pre><code>typealias ResponseHandler = (SomeResponse?, Error?) -&gt; Void

class LoginService {
    private var authorizeTokenCompletions = [ResponseHandler]()
    func authorizeToken(withRefreshToken refreshToken: String, completion: @escaping ResponseHandler) {
        if authorizeTokenCompletions.isEmpty {
            authorizeTokenCompletions.append(completion)
            post { [weak self] response, error in
                self?.authorizeTokenCompletions.forEach { $0(response, error) }
                self?.authorizeTokenCompletions.removeAll()
            }
        } else {
            authorizeTokenCompletions.append(completion)
        }
    }

    private func post(completion: @escaping ResponseHandler) {
        // async
        completion(nil, nil)
    }
}
</code></pre>
<p>What is idea of above code?</p>
<ol>
<li>authorizeToken function may be called as many times as it needs (for example 20 times)</li>
<li>Only one asynchronous request (post) may be pushed at a time.</li>
<li>All completions from called authorizeToken functions should be called with the same parameters as the first one completed.</li>
</ol>
<p>Usage:</p>
<pre><code>let service = LoginService()

service.authorizeToken(withRefreshToken: &quot;&quot;) { a, b in print(a)}
service.authorizeToken(withRefreshToken: &quot;&quot;) { a, b in print(a)}
service.authorizeToken(withRefreshToken: &quot;&quot;) { a, b in print(a)}
service.authorizeToken(withRefreshToken: &quot;&quot;) { a, b in print(a)}
service.authorizeToken(withRefreshToken: &quot;&quot;) { a, b in print(a)}
</code></pre>
<p>All completions above should be printed with result from the first one which was called.</p>
<p>Is it possible to do this with RxSwift?</p>
<p>PS I will award a bounty of 100 once it is possible for the one who help me with this;)</p>
","2725435","","","","","2021-05-30 12:46:06","How to prevent from calling async function many times but call completion for each of them?","<ios><swift><rx-swift>","2","5","","","","CC BY-SA 4.0"
"67774994","1","67787804","","2021-05-31 13:47:07","","1","93","<p>I want to create a Timer with RxSwift to call my method every 10 seconds, but l don't know how to make it the best way.</p>
<p>If you have any ideas, please, share!</p>
","14506424","","","","","2021-06-01 11:14:42","How to create Timer on RxSwift to call the method every 10 seconds?","<swift><timer><rx-swift>","2","0","","","","CC BY-SA 4.0"
"67800758","1","","","2021-06-02 07:33:01","","1","38","<p>I have a collectionView with cells. Every cell has a component imageView, I can tap on it and another controller will push.
I need to know exactly when l tap on imageView, what indexPath of cell is.</p>
<p>When l just tap on cell, not on imageView, l have this indexPath with the help of <code>collectionView.rx.itemSelected</code>, and l need to do the same but when tap on imageView in collection cell.</p>
<p>Help, please, maybe you have some good ideas :)</p>
","14506424","","","","","2021-06-02 11:09:16","How to get indexPath by tap on view in collectionCell with RxSwift?","<swift><rx-swift>","1","4","","","","CC BY-SA 4.0"
"67810893","1","","","2021-06-02 18:52:10","","0","77","<p>I want to show only 20 cells in my <strong>collectionView</strong> (or less if the count is less than 20). I found ways to do it with delegates/datasources, but my project is totally on RxSwift/RxCocoa, and l want to find alternative solution <strong>with Rx</strong>.</p>
<p>If you know the way to make it right with Rx, please, share :)</p>
","14506424","","","","","2021-06-03 06:17:29","How to set number of cells to show in collectionView with RxSwift?","<swift><uicollectionview><rx-swift>","1","1","","","","CC BY-SA 4.0"
"67839351","1","","","2021-06-04 14:50:08","","0","39","<p>not very expert with RxSwift, I tested some solution found here, such <a href=""https://stackoverflow.com/questions/15746745/handling-an-empty-uitableview-print-a-friendly-message"">this</a> but not working. Don't know if issue is about size of an empty tableview or som other UI update related issue.</p>
<p>the tableView I am using is a bit customized such this</p>
<pre><code>public class SelfSizedTableView: UITableView {
    public override var intrinsicContentSize: CGSize {
        self.layoutIfNeeded()
        return self.contentSize
    }

    public override var contentSize: CGSize {
        didSet{
            self.invalidateIntrinsicContentSize()
        }
    }

    public override func reloadData() {
        super.reloadData()
        self.invalidateIntrinsicContentSize()
    }
}
</code></pre>
<p>the solution I am testing</p>
<pre><code>extension UITableView {

    func setEmptyMessage(_ message: String) {
        let messageLabel = UILabel(frame: CGRect(x: 0, y: 0, width: self.bounds.size.width, height: self.bounds.size.height))
        messageLabel.text = message
        messageLabel.textColor = .black
        messageLabel.numberOfLines = 0
        messageLabel.textAlignment = .center
        messageLabel.font = UIFont(name: &quot;TrebuchetMS&quot;, size: 15)
        messageLabel.sizeToFit()

        self.backgroundView = messageLabel
        self.separatorStyle = .none
    }

    func restore() {
        self.backgroundView = nil
        self.separatorStyle = .singleLine
    }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>self.viewModel.things.subscribe(onNext: { [unowned self] things in
    if things.isEmpty {
        self.myTableView.backgroundColor = .purple
        self.myTableView.contentSize = CGSize(width: self.view.frame.width, height: self.view.frame.height)
        self.myTableView.frame = CGRect(x: CGFloat(0), y: CGFloat(0), width: CGFloat(200), height: CGFloat(200))
        self.myTableView.setNeedsLayout()
        self.myTableView.layoutIfNeeded()
        self.myTableView.setEmptyMessage(&quot;My Message&quot;)
    } else {
        self.myTableView.restore()
    }
}).disposed(by: self.rx.disposeBag)
</code></pre>
","4846391","","4846391","","2021-06-04 15:12:46","2021-06-04 15:12:46","How to show a backgroundVIew for empty tableView using RxSwift","<swift><rx-swift>","2","1","","","","CC BY-SA 4.0"
"67843392","1","","","2021-06-04 20:06:48","","1","20","<p>So, I added this extension function to the <code>PrimitiveSequenceType</code> to show a loader on screen when making a network call</p>
<pre><code>extension PrimitiveSequenceType where Trait == SingleTrait {
    
    func subscribeWithLoader(showLoaderOn viewController: MyUIViewController, onSuccess: ((Element) -&gt; Void)? = nil, onFailure: ((Swift.Error) -&gt; Void)? = nil)-&gt; Disposable {
        let loader = viewController.showLoading()
        return subscribe { (element) in
            DispatchQueue.main.async {
                loader.dismiss(animated: true, completion: {
                    onSuccess?(element)
                })
            }
        } onFailure: { (error) in
            DispatchQueue.main.async {
                loader.dismiss(animated: true, completion: {
                    onFailure?(error)
                })
            }
        }
    }
}
</code></pre>
<p>Here is my showLoading function</p>
<pre><code>func showLoading()-&gt; UIAlertController {
        let alert = UIAlertController(title: nil, message: &quot;Please wait...&quot;, preferredStyle: .alert)
        let loadingIndicator = UIActivityIndicatorView(frame: CGRect(x: 10, y: 5, width: 50, height: 50))
        loadingIndicator.hidesWhenStopped = true
        loadingIndicator.style = UIActivityIndicatorView.Style.medium
        loadingIndicator.startAnimating();
        alert.view.addSubview(loadingIndicator)
        present(alert, animated: true, completion: nil)
        return alert
    }
</code></pre>
<p>But the loader never stops. Can anybody let me know what I'm doing wrong. Any help would be appreciated.</p>
","7436566","","","","","2021-06-05 02:01:05","UIAlertController not working with Rx-Single","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"67849516","1","67851163","","2021-06-05 12:19:53","","1","20","<p>I have horizontal collection view with autosize cells. I'm new to RxSwift and can't figure out what's wrong with this code. Whenever I click on any element collection view is set to start point. Only one option that I came with is to save offset of collection view right before reload and then manually set collection view offset to previously saved but it seems like bad practice to me.</p>
<p>This is my Cell:</p>
<pre><code>class FilterCell: UICollectionViewCell {

   @IBOutlet weak var filterIcon: UIImageView!
   @IBOutlet weak var filterText: UILabel!

   func updateView(_ isSelected: Bool) {
      contentView.backgroundColor = isSelected ? .blue : .white
   }

   func updateData(icon: UIImage?, text: String?) {
      filterIcon.image = icon ?? filterIcon.image
      filterText.text = text ?? filterText.text
   }
}
</code></pre>
<p>This is Cell Model</p>
<pre><code>struct FilterCellModel {
    let id: Int
    let image: String
    let text: String
    var isSelected: Bool = false
}
</code></pre>
<p>In View Model I only have Array of Cell Models:</p>
<pre><code>class LoginViewModel {

let usernameTextFieldPublishSubject = PublishSubject&lt;String&gt;()
let passwordTextFieldPublishSubject = PublishSubject&lt;String&gt;()

let filters = BehaviorRelay&lt;[FilterCellModel]&gt;(value: [
    FilterCellModel(id: 0, image: &quot;filter-ic-1&quot;, text: &quot;Extra filter&quot;),
    FilterCellModel(id: 1, image: &quot;filter-ic-1&quot;, text: &quot;Different extra filter&quot;),
    FilterCellModel(id: 2, image: &quot;filter-ic-1&quot;, text: &quot;Short filter&quot;),
    FilterCellModel(id: 3, image: &quot;filter-ic-1&quot;, text: &quot;Lorem Ipsum&quot;),
    FilterCellModel(id: 4, image: &quot;filter-ic-1&quot;, text: &quot;Lorem filter&quot;),
    FilterCellModel(id: 5, image: &quot;filter-ic-1&quot;, text: &quot;Ipsum filter&quot;)
])
</code></pre>
<p>And this is how I display cells and update them with RxSwift</p>
<pre><code>loginViewModel.filters.bind(to: filterCollectionView.rx.items(cellIdentifier: &quot;FilterCell&quot;, cellType: FilterCell.self)) { cv, item, cell in
        cell.updateData(icon: UIImage(named: item.image), text: item.text)
        cell.updateView(item.isSelected)
    }.disposed(by: bag)
    
    filterCollectionView.rx.itemSelected.subscribe(onNext: { index in
        var filters = self.loginViewModel.filters.value
        let isSelected = filters[index.item].isSelected
        filters[index.item].isSelected = !isSelected
        self.loginViewModel.filters.accept(filters)
    }).disposed(by: bag)
</code></pre>
","11078428","","","","","2021-06-05 15:31:34","Changing cell's background is moving collection view offset to 1st element","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"67860009","1","","","2021-06-06 14:09:32","","0","46","<p>I have one Observable&lt;[String]&gt;, how do I map it to Another Observable &lt; Dash &gt;
where</p>
<pre><code>Class Dash{

var list :[String]
var count :int

} 
</code></pre>
<p>for simplicity count is any random integer .</p>
","8324957","","8324957","","2021-06-06 14:44:48","2021-06-06 20:26:05","How to Map one Observable<T> to another type Observable<E> in RxSwift?","<ios><swift><xcode><rx-swift>","1","1","","","","CC BY-SA 4.0"
"67865558","1","67871081","","2021-06-07 03:17:17","","1","82","<p>I'm learning MVVM and RxSwift, and I want to display data from GitHub api and populate into collectionViewDiffableDataSource. But it's not displaying my data, even with my snapshot is already setup to accept my data. This is my code</p>
<pre><code>class FollowersListViewModel {
    
    let searchText      = BehaviorRelay&lt;String&gt;(value: &quot;&quot;)
    let page            = BehaviorRelay&lt;Int&gt;(value: 1)
    var followers       = BehaviorRelay&lt;[FollowerViewModel]&gt;(value: [])
    var filterFollowers = BehaviorRelay&lt;[FollowerViewModel]&gt;(value: [])
    let hasMoreFollower = BehaviorRelay&lt;Bool&gt;(value: false)
    let isLoading       = BehaviorRelay&lt;Bool&gt;(value: true)
    
    private let manager: NetworkManager
        
    let disposeBag      = DisposeBag()
    
    init(manager: NetworkManager) {
        self.manager = manager
    }
    
    func fetchFollowers(with username: String) {
        isLoading.accept(true)
        searchText.asObservable()
            .filter { $0.count &gt; 2 }
            .throttle(.seconds(3), scheduler: MainScheduler.instance)
            .distinctUntilChanged()
            .flatMapLatest { query in
                self.manager.getFollowers(with: query, page: self.page.value)
            }.subscribe { followers in
                self.isLoading.accept(false)
                self.followers.accept(followers.map { FollowerViewModel(follower: $0)})
                print(self.followers.value)
            } onError: { error in
                print(error)
            }.disposed(by: disposeBag)
    }
    
}

class FollowersListVC: UIViewController {
    
    var viewModel: FollowersListViewModel
    
    enum Section { case main }
    
    var collectionView: UICollectionView!
    var dataSource: UICollectionViewDiffableDataSource&lt;Section, FollowerViewModel&gt;!

    override func viewDidLoad() {
        super.viewDidLoad()
        setupViewController()
        setupSearchController()
        setupCollectionView()
        setupCollectionViewDataSource()
        viewModel.fetchFollowers(with: username)
        setupSnapshot()
    }

    private func setupCollectionViewDataSource() {
        dataSource = UICollectionViewDiffableDataSource&lt;Section, FollowerViewModel&gt;(collectionView: collectionView, cellProvider: { (collectionView, indexPath, follower) -&gt; UICollectionViewCell? in
            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: FollowersCell.reuseID, for: indexPath) as! FollowersCell
            cell.set(followerVM: follower)
            
            return cell
        })
    }

    private func setupSnapshot() {
        var snapshot = NSDiffableDataSourceSnapshot&lt;Section, FollowerViewModel&gt;()
        snapshot.appendSections([.main])
        snapshot.appendItems(viewModel.followers.value)
        
        DispatchQueue.main.async { self.dataSource.apply(snapshot, animatingDifferences: true) }
    }
}
</code></pre>
<p>I don't know why but it's like my snapshot is not being called, it's seems different when use in MVVM</p>
","8907890","","","","","2021-06-07 11:52:41","Data not display in collectionView DiffableDataSource MVVM RxSwift","<swift><mvvm><rx-swift><uicollectionviewdiffabledatasource><nsdiffabledatasourcesnapshot>","1","0","","","","CC BY-SA 4.0"
"67867361","1","67870822","","2021-06-07 07:12:14","","2","36","<p>I have two subscribers for a <code>BehaviorRelay</code> observable type named <code>profileUpdates</code>.</p>
<p>Publishing my data through,</p>
<p><code>Observables.shared.profileUpdates.accept(data)</code></p>
<p>Subscribing in two points in code (Suppose <code>A</code> and <code>B</code>) through,</p>
<p><code>Observables.shared.profileUpdates.subscribe(onNext: { } )</code></p>
<p>Now, can I define the sequence I would be able to get the subscribed data or it is strictly dependant on the library?</p>
<p>For example, in point <code>A</code> after point <code>B</code>, or vice versa.</p>
","7769239","","","","","2021-06-07 11:29:47","RxSwift subscribe sequence","<swift><rx-swift>","1","0","1","","","CC BY-SA 4.0"
"67876405","1","","","2021-06-07 17:44:21","","1","24","<p>When I tap on item in collection view cell is loosing size with clumsy animation. Effect on first screenshots. I'm guessing there is something with my stackview inside custom cell but can't figure it out on my own. Stack view has top, right, bottom and left constrain set to superview (contentView)</p>
<p><a href=""https://i.stack.imgur.com/Pyin0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Pyin0.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.stack.imgur.com/v26jv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/v26jv.png"" alt=""enter image description here"" /></a></p>
<p>This is hierarchy of collection view structure:</p>
<p><a href=""https://i.stack.imgur.com/6BGjc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6BGjc.png"" alt=""enter image description here"" /></a></p>
<p>This is code responsible for selecting and reloading cells. I have array of selected items.</p>
<pre><code>filterCollectionView.rx.itemSelected.subscribe(onNext: { [weak self] index in
        guard let self = self else { return }
        
        if self.loginViewModel.filtersSelected.contains(index.item) {
            self.loginViewModel.filtersSelected.remove(index.item)
        } else {
            self.loginViewModel.filtersSelected.insert(index.item)
        }
        
        self.filterCollectionView.reloadItems(at: [index])
        
    }).disposed(by: bag)
</code></pre>
<p>This is code responsible for binding and displaying cells</p>
<pre><code>loginViewModel.filters.bind(to: filterCollectionView.rx.items(cellIdentifier: &quot;FilterCell&quot;, cellType: FilterCell.self)) { [weak self] cv, item, cell in
        guard let self = self else { return }
        
        DispatchQueue.main.async {
            cell.updateData(icon: UIImage(named: item.image), text: item.text)
            let isSelected = self.loginViewModel.filtersSelected.contains(item.id)
            cell.updateView(isSelected)
        }
        
    }.disposed(by: bag)
</code></pre>
<p>And this is custom cell</p>
<pre><code>class FilterCell: UICollectionViewCell {

    @IBOutlet weak var filterIcon: UIImageView!
    @IBOutlet weak var filterText: UILabel!


    func updateView(_ isSelected: Bool) {
        contentView.backgroundColor = isSelected ? .blue : .white
    }

    func updateData(icon: UIImage?, text: String?) {
        filterIcon.image = icon ?? filterIcon.image
        filterText.text = text ?? filterText.text
    }
}
</code></pre>
<p>I hope this is enough information to understand the problem :)</p>
<p>EDIT:
When I delete DispatchQueue.main it gets even weirder. Tapped cell is collapsing.
<a href=""https://i.stack.imgur.com/jqvGt.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jqvGt.png"" alt=""enter image description here"" /></a></p>
","11078428","","11078428","","2021-06-09 06:33:51","2021-06-09 06:33:51","Horizontal Collection View with automatic cell size is destroying cells on item reload","<swift><uikit><rx-swift>","1","0","","","","CC BY-SA 4.0"
"67876525","1","","","2021-06-07 17:53:39","","1","32","<p>We have three states.How can we test(with unit tests) our class which generates random state every 5 seconds, and which can not generate the same state twice in a row? The code of our random generator class is below
`
final class StateRandomGenerator: RandomGeneratorProtocol {
private var sourceObservable: Disposable?
private(set) var previousValue: Int?
var generatedValue: PublishSubject = PublishSubject()</p>
<pre><code>init(_ interval: RxTimeInterval,_ scheduler: SchedulerType = MainScheduler.instance) {
    sourceObservable = Observable&lt;Int&gt;
        .interval(interval, scheduler: scheduler)
        .flatMap { [unowned self] _ in self.generateRandom()}
        .compactMap { state in
            return state?.description
        }
        .subscribe(onNext: { [weak self] description in
            self?.generatedValue.onNext(description)
        })
}
func generateRandom() -&gt; Observable&lt;ConnectionState?&gt; {
    return Observable.create { [weak self] observer  in
        var randomNumber = Int.random(in: 0..&lt;ConnectionState.count)
        guard let previousValue = self?.previousValue else {
            let value = ConnectionState(rawValue: randomNumber)
            self?.previousValue = randomNumber
            observer.onNext(value)
            return Disposables.create()
        }
        while randomNumber == previousValue {
            randomNumber = Int.random(in: 0..&lt;ConnectionState.count)
        }
        self?.previousValue = randomNumber
        let value = ConnectionState(rawValue: randomNumber)
        observer.onNext(value)
        
        return Disposables.create()
    }
}
enum ConnectionState: Int {
case error
case connecting
case established

var description: String {
    switch self {
    case .connecting:
        return &quot;It is connecting&quot;
    case .error:
        return &quot;There is an error&quot;
    case .established:
        return &quot;Thе connection is established&quot;
    }
}
</code></pre>
<p>}
`</p>
","11503777","","11503777","","2021-06-07 18:00:54","2021-06-09 00:31:24","How can we test class which generates random states, and which can not generate same states twice?","<ios><unit-testing><rx-swift><xctestcase><rxtest>","1","0","","","","CC BY-SA 4.0"
"67892825","1","67895730","","2021-06-08 18:40:18","","1","100","<p>I have a view like custom popup, in it I have a button.</p>
<p>I observe tap on it with the help of <strong>let tap = button.rx.tap</strong></p>
<p>When this button had been tapped, l need to make action in my viewModel - for example, print &quot;tap&quot; and push action into relay, but l can't understand, how to bind whem together.</p>
<p>I try to make it in my viewModel:</p>
<pre><code>let buttonTapped = view.tap
let tapRelay = PublishRelay&lt;Void&gt;

func setTap() {
buttonTapped
.bind { [weak self] _ in {
print(&quot;tap&quot;)
self?.tapRelay.accept(())
.disposed(by: bag)
</code></pre>
<p>So my goal is to just make sure that taps on button is going on, and l don't understand how to do it right.</p>
","14506424","","","","","2021-06-09 01:34:19","How to make action in viewModel of ViewController when in UIView button was tapped in RxSwift?","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"67911382","1","67913016","","2021-06-09 20:36:24","","1","32","<p>I am trying to download some json, parse it, check some information in the json and depending one the result continue processing or not.</p>
<p>What's the most RxSwift idiomatic way of doing this?</p>
<pre><code>        URLSession.shared.rx
            .data(request:request)
            .observe(on: ConcurrentDispatchQueueScheduler(qos: .background))
            .flatMap(parseJson) // into ModelObject
            .flatMap(checkModel) // on some condition is there any way to jump into the onCompleted block? if the condition is false then execute processObject
            .map(processObject)
            .subscribe(
                onError: { error in
                print(&quot;error: \(error)&quot;)
            }, onCompleted: {
                print(&quot;Completed with no error&quot;)
            })
            .disposed(by: disposeBag)
</code></pre>
<p>where <code>parseJson</code>is something like:</p>
<pre><code>func parseJson(_ data: Data) -&gt; Single&lt;ModelObject&gt;
</code></pre>
<p><code>checkModel</code> does some checking and if some conditions are fullfilled should complete the sequence without ending in <code>processObject</code></p>
<pre><code>func checkModel(_ modelObject: ModelObject) -&gt; Single&lt;ModelObject&gt; {
  //probably single is not what I want here
}
</code></pre>
<p>And finally <code>processObject</code></p>
<pre><code>func processObject(_ modelObject: ModelObject) -&gt; Completable {
}
</code></pre>
","11963674","","","","","2021-06-10 11:51:13","RxSwift how to skip map depending on previous result?","<rx-swift>","1","2","","","","CC BY-SA 4.0"
"67913373","1","67927056","","2021-06-10 01:09:35","","1","37","<p>I have an issue where [unowned self] was changed to [weak self] within the dataSource function used for a CollectionView using RxDataSource due to a memory leak. I now received a crash from returning a blank collectionViewCell that doesn't have a reuseIdentifier. I understand that I need to return a cell with a reuseID.</p>
<p>What changes are suggested to deal with this properly?</p>
<p>Someone suggested making collectionView.dataSource = nil in viewDidLoad() would fix this...</p>
<p>I was thinking instead of returning CanvasItemCollectionViewCell() in the 'guard' check,
I return collectionView.dequeueReusableCell(for: indexPath, cellType: CanvasItemCollectionViewCell.self), but if self = self fails wouldn't that mean the collectionView is garbage?</p>
<p>This is a difficult problem to debug because this crash doesn't happen consistently.</p>
<p>Here are some screenshots to portray what I am looking at.</p>
<h3><strong>RxDataSource code:</strong></h3>
<pre><code>func dataSource()
        -&gt; RxCollectionViewSectionedAnimatedDataSource&lt;CanvasSectionModel&gt; {
        RxCollectionViewSectionedAnimatedDataSource&lt;CanvasSectionModel&gt;(
            animationConfiguration: AnimationConfiguration(
                insertAnimation: .fade,
                reloadAnimation: .fade,
                deleteAnimation: .fade
            ),
            configureCell: { [weak self] dataSource, collectionView, indexPath, _ in
                guard let self = self else { return CanvasItemCollectionViewCell() }
                
                switch dataSource[indexPath] {
                case let .CellModel(model):
                    let cell = collectionView
                        .dequeueReusableCell(
                            for: indexPath,
                            cellType: CanvasItemCollectionViewCell.self
                        )

                    cell.model = model

                    cell.onDeleteHandler = { _ in
                        self.presentDeleteConfirmation { deleteConfirmed in
                            guard deleteConfirmed else { return }
                            self.viewModel.inputs.deletePage(withProofID: model.id)
                        }
                    }

                    return cell
                }
            }
</code></pre>
<h3><strong>Crash</strong>:</h3>
<p><a href=""https://i.stack.imgur.com/bkD02.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bkD02.png"" alt=""enter image description here"" /></a></p>
","13724086","","13724086","","2021-06-10 18:54:07","2021-06-10 18:58:56","How do I properly return a CollectionViewCell with reuseIdentifier if weak self is nil in RxDataSource function?","<ios><uicollectionview><uicollectionviewcell><rx-swift><rxdatasources>","1","0","","","","CC BY-SA 4.0"
"67922346","1","67928440","","2021-06-10 13:39:22","","1","25","<p>I want to observe two <code>behaviorRelays</code> with a single <code>observer</code>, wait for both <code>relays</code> to emitt their values, then in the <code>subscription</code> have two seperate <code>closure arguemts</code>, one for each <code>relay</code>. Something like this:</p>
<pre><code>let one = firmwareService.basicIODeviceUnit.compactMap { $0?.canBeUpdated }
let two = firmwareService.motorDeviceUnit.compactMap { $0?.canBeUpdated }
        
Observable.of(one, two).flatMap{ $0 }.subscribe(onNext: { a, b in
    print(&quot;--&quot;, a, b)
}).disposed(by: disposeBag)
</code></pre>
<p>The above code isn't allowed. The operators like <code>merge</code> or <code>zip</code> seem to bundle both relays into a single closure argumet so I guess they won't work. What do I use?</p>
<p>I have looked through this thread, so it should be possible, but I can't wrap my head around it since I use <code>swift</code>
<a href=""https://stackoverflow.com/questions/50470406/rxjs-subscribe-with-two-arguments"">RxJS Subscribe with two arguments</a></p>
","8591381","","8591381","","2021-06-10 14:01:20","2021-06-10 21:03:35","How do I observe two rx sequences and subscribe with two closure arguments?","<ios><swift><observable><rx-swift>","2","0","","","","CC BY-SA 4.0"
"67922639","1","","","2021-06-10 13:56:55","","0","19","<p>I have an array of customCell that I currently display in a UICollectionView with <strong>RxSwift &amp; RxCocoa</strong> correctly. I want to add an extra static cell that should give the user the possibility to add another cell (this cell must always be there even if there are no elements in the customCell list). I register the two cell type:</p>
<pre><code>ticketCollectionList.register(UINib(nibName: &quot;TicketSmallCard&quot;, bundle: nil), forCellWithReuseIdentifier: &quot;TicketSmallCard&quot;)
ticketCollectionList.register(UINib(nibName: &quot;TicketRequestCard&quot;, bundle: nil), forCellWithReuseIdentifier: &quot;TicketRequestCard&quot;)
</code></pre>
<p>And I populate the array of customCell (TicketSmallCard) with:</p>
<pre><code>viewModel.prenotazioniTableData.asObservable()
 .bind(to: ticketCollectionList.rx.items(cellIdentifier: String(describing: TicketSmallCard.self), cellType: TicketSmallCard.self)) { row, element, cell in
    cell.configure(with: element)
 }
 .disposed(by: disposeBag)
</code></pre>
<p>I can't figure out how to add this static cell. In the storyboard I also added the reference to the second cell with the correct identifier.</p>
<p><a href=""https://i.stack.imgur.com/xZm8z.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xZm8z.png"" alt=""enter image description here"" /></a></p>
","1274172","","","","","2021-06-10 13:56:55","How to add an extra static cell to UICollectionView with RxSwift?","<swift><uicollectionview><uicollectionviewcell><rx-swift><rx-cocoa>","0","1","","","","CC BY-SA 4.0"
"68008168","1","68011552","","2021-06-16 18:23:54","","1","31","<p>I have array of Observables, say <code>[Observable &lt;WriteTaskResult&gt;]</code></p>
<p>I want to perform all write tasks keeping their order, and if any one of them fails then I want to perform <code>Observable&lt;ResetTaskResult&gt;</code></p>
<p>Following function will return observable of type <code>BatchTasksResult</code> for tracking tasks progress.</p>
<p>Sample Code:</p>
<pre><code>enum BatchTasksResult{
    case elapsedTime(Double)
    case failedFatal
    case rolledback
    case success
}

func writeBlocks(tasks: [WriteTask]) -&gt; Observable&lt;BatchTasksResult&gt;{
    return Observable.create {(observable) -&gt; Disposable in
       let allTasks: [Observable&lt;WriteTaskResult&gt;] = self.writeSomewhere(tasks)
       Observable.concat(allTasks)
         .subscribe { writeTaskResult in
               observable.onNext(.elapsedTime(writeTaskResult.totalTime))
            } 
            onError: { (err) in
               // Perform Observable&lt;ResetTaskResult&gt;
               // if ResetTask was successful then observable.onNext(.rolledback)
               // if ResetTask failed then observable.onNext(.failedFatal)
            }
            onCompleted: {
               observable.onNext(.success)
            }
            .disposed(by: disposeBag)
       return Disposables.create()
    }
}
</code></pre>
<p>How do I trigger rollback logic using Observable from onError of allTasks' observable?</p>
<p>Simple solution seems nested observable, but that's not good practice, I guess? I tried FlatMap, but it can't really solve <em>&quot;If any sinlge task fails, then rollback and reset&quot;</em> Any other solution to this?</p>
","6709940","","","","","2021-06-17 01:47:19","Dynamically terminate Observable based on another observable | RxSwift","<ios><swift><xcode><reactive-programming><rx-swift>","1","0","","","","CC BY-SA 4.0"
"68033731","1","68034301","","2021-06-18 10:42:13","","1","21","<p>I have a <code>behaviourRelay</code> that I would like to share between two subscriptions:</p>
<pre><code>var firmwareVersionRelay = BehaviorRelay&lt;FirmwareVersionModel?&gt;(value: nil).share()
</code></pre>
<p>This, however, turns the relay into an <code>observable</code>, which means that I can no longer use the <code>accept</code> operator.</p>
<p>So how do I get around this? Is it possible to have a relay with share? Should I simply skipp share? Or should I just use <code>onNext</code> instead of <code>accept</code>?</p>
","8591381","","","","","2021-06-18 11:23:58","How do I use share() on a relay?","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"68052420","1","68055290","","2021-06-20 03:30:23","","1","31","<p>I am pretty new to RxSwift and stuck in creating a sequence.</p>
<p>I have 3 observables (isChanged, updatedValue, savedValue).
If form value isChanged I want to use updatedValue otherwise savedValue.
I tried using .combineLatest as</p>
<pre><code>Observable.combineLatest( isChanged, updatedValue, savedValue,
resultSelector: {isChanged, updatedValue, savedValue in
   print (&quot;\(isChanged), \(updatedValue), \(savedValue)&quot;)
 }.observeOn(MainSchedular.instance)
  .subscribe()
  .disposed(by: bag)
</code></pre>
<p>I want to use updatedValue only if isChanged flag is changed otherwise always use savedValue.</p>
<p>I tried using flatMapLatest as well but I am struggling with syntax too. Any help will be appreciated. TIA</p>
","1977221","","","","","2021-06-20 12:18:23","RxSwift: Combining different types of observables and mapping result","<ios><swift><observable><rx-swift>","1","3","","","","CC BY-SA 4.0"
"68070187","1","","","2021-06-21 14:56:12","","1","32","<p>I have a function that writes/modifies the data and returns an Observable to track the progress of the task.</p>
<pre><code>func modifyChunk(data: SomeData) -&gt; Observable&lt;Double&gt;
</code></pre>
<p>Now in my use case user may preform N number of operations in runtime randomly, where he may modify same data over and over. I'm looking for a way to hold/postpone new Observable from <code>modifyChunk(data:)</code> till previously existing observable is finished, and once that happen immediately kick start this new Observable and so on.</p>
<p>I figured out that, I may need a queue that will take Observable tasks at runtime and execute them in FIFO manner. But I'm not able figure out how to achieve that using RxSwift.</p>
","6709940","","","","","2021-06-21 23:56:56","Run multiple instances of Observable Sequentially in dynamic way | RxSwift","<ios><swift><reactive-programming><rx-swift>","1","1","","","","CC BY-SA 4.0"
"68070842","1","68082439","","2021-06-21 15:40:27","","1","44","<p>I'm new to RxSwift and got confused when reading blogs about it.</p>
<p>Is this a proper way to create a button in a customized view?</p>
<pre><code>    let disposeBag = DisposeBag()
    lazy var followButton: UIButton = {
        let btn = UIButton(frame: .zero)
        btn.rx.tap.subscribe(onNext: { [weak self] in
            // do something when the button is tapped
        }).disposed(by: disposeBag) // this line
        
        return btn
    }()
</code></pre>
<p>Is it necessary to use <code>disposed(by: DisposeBag)</code> as long as the button is subscribed(observed)?</p>
<p><strong>Update</strong></p>
<pre><code> lazy var followButton: UIButton = {
        let btn = UIButton(frame: .zero)
        btn.rx.tap.subscribe(onNext: { [weak self] in
            // do something when the button is tapped
        }) 
        // a warning says 
        // Result of call to 'subscribe(onNext:onError:onCompleted:onDisposed:)' is unused
        
        return btn
    }()
</code></pre>
<p>The warning seems to imply the api is designed to connect with another method like <code>disposed</code>.
What method should be used here if we don't need <code>disposed</code>?<br />
Or just <code>_ = btn.rx.tap.subscribe...</code>?</p>
","11971010","","11971010","","2021-06-22 02:23:45","2021-06-22 18:52:46","should I manually dispose a UIButton instance in RxSwift?","<swift><uikit><rx-swift>","1","0","","","","CC BY-SA 4.0"
"68073250","1","68075114","","2021-06-21 18:50:32","","0","22","<p>With the code below:</p>
<pre><code>let stringSubject = BehaviorSubject&lt;String?&gt;(value: nil).share()
let intSubject = BehaviorSubject&lt;Int?&gt;(value: nil)

let intObservable = intSubject.compactMap { $0 }

let resultingSequence = intObservable
    .take(1)
    .withLatestFrom(stringSubject) { ($0, $1) }
    .filter { $0.1 == nil }
    .map { $0.0 }

let subscriptionB = resultingSequence
    .skip(1)
    .subscribe(onNext: { print(&quot;Subscription B: \($0)&quot;) })

let subscriptionA = resultingSequence
    .subscribe(onNext: { print(&quot;Subscription A: \($0)&quot;) })

intSubject.onNext(1)

print(&quot;Finished&quot;)
</code></pre>
<p>What I was expecting is the event <code>1</code> will be handled by <code>subscriptionA</code>, i.e. printing something like:</p>
<pre><code>Subscription A: 1
Finished
</code></pre>
<p>But in the actual result nothing was printed, i.e.</p>
<pre><code>Finished
</code></pre>
<p>However, if the <code>share()</code> for <code>stringSubject</code> is being removed, or <code>share()</code> is added to the end of <code>resultingSequence</code>'s declaration, the expected result will be printed.</p>
<p>What is the reason behind this?</p>
","1764327","","","","","2021-06-21 21:49:02","Why using the `share` operator on the observable in `withLatestFrom` will result in an event being skipped in one of the subscriptions?","<ios><reactive-programming><rx-swift><reactivex>","1","0","","","","CC BY-SA 4.0"
"68085646","1","","","2021-06-22 14:41:27","","1","52","<p>I am trying to use <code>distinctUntilChanged</code> with combineLatest, eg:</p>
<pre><code>Observable.combineLatest(focusedCourse, infoState)
    .distinctUntilChanged()
    .map { focusedCourse, infoState in
       // Implementation
    }
    .bind(to: videoSource)
    .disposed(by: bag)
</code></pre>
<p>However I am getting the error:</p>
<pre><code>Type '(BehaviorRelay&lt;Course?&gt;.Element, BehaviorRelay&lt;InfoState&gt;.Element)' cannot conform to 'Equatable'
</code></pre>
<p>I have conformed both <code>Course</code> and <code>InfoState</code> to equatable but still get this error. How can I fix this?</p>
","4083744","","","","","2021-06-22 17:17:09","Using distinctUntilChanged with combineLatest throws Equatable error with RxSwift","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"68139983","1","","","2021-06-26 06:56:48","","2","84","<p>I'm making an app which has a form in it. What I did is I use a <code>UITableView</code> to make the form with some sections in it. Each cell has a <code>UITextField</code> to get the user's input. Since I'm using <code>RxSwift</code>, I bind every textfield inside the cell to a <code>BehaviorRelay</code> to my ViewModel class. Unfortunately, it has a really strange behavior everytime the user inputs something to each cell. For example (as shown below) every time the user inputs some value to the first cell, after the user scrolls down, the last cell in the table view has the same value (Note that the user hasn't scroll the page yet, hence hasn't input any value to the last cell). The second example is when I input some value in the last 3 cells, the first 3 cell's values changed as well.</p>
<p><a href=""https://i.stack.imgur.com/sgZFm.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/sgZFm.gif"" alt=""enter image description here"" /></a></p>
<p>Here's how I manage to achieve this:</p>
<p>My custom cell class:</p>
<pre><code>class FormTableViewCell: UITableViewCell {
    
    @IBOutlet weak var titleLbl: UILabel!
    @IBOutlet weak var valueTf: UITextField!

    override func awakeFromNib() {
        super.awakeFromNib()
    }
    
    func configureCell(title: String, placeholder: String, keyboardType: UIKeyboardType? = .default) {
        titleLbl.text = title
        valueTf.placeholder = placeholder
        valueTf.keyboardType = keyboardType ?? .default
    }
    
    func getValueAsDriver() -&gt; Driver&lt;String&gt; {
        valueTf.rx.text.orEmpty.asDriver()
    }
    
}
</code></pre>
<p>How I configure each cell in <code>tableView(_:cellForRowAt:)</code> function in my <code>UIViewController</code> class (I have around 15 cells total in my app):</p>
<pre><code>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
    let formCell = tableView.dequeueReusableCell(withIdentifier: Config.FORM_TABLEVIEWCELL_ID) as! FormTableViewCell
    if indexPath.section == 1 {
        if indexPath.row == 0 {
            formCell.configureCell(title: &quot;Some title&quot;, placeholder: &quot;Some placeholder&quot;, keyboardType: .decimalPad)
            viewModel.bindValue(from: formCell.getValueAsDriver())
            return formCell
        } else if indexPath.row == 1 {
            // Do pretty much the same thing as before
        }
    } else if indexPath.section == 2 {
        // Do pretty much the same thing as before
    } ...
    
    return UITableViewCell()
}
</code></pre>
<p>How I bind the textfield value in my ViewModel class:</p>
<pre><code>final class ViewModel {
    private let _someValue = BehaviorRelay&lt;String&gt;(value: &quot;&quot;)

    func bindValue(from driver: Driver&lt;String&gt;) {
        driver.distinctUntilChanged().drive(onNext: { [unowned self] value in
            _someValue.accept(value)
        }).disposed(by: disposeBag)
    }
}
</code></pre>
<p>My question is how do keep the values for each textfield inside the cell when the user scrolls the tableview? Also if you have better approach please let me know. Thank you.</p>
","8279130","","","","","2021-06-26 16:27:48","How to retain UITextField's value inside a UITableViewCell when using RxSwift?","<ios><swift><rx-swift>","2","0","","","","CC BY-SA 4.0"
"68164737","1","","","2021-06-28 14:02:26","","0","24","<p>I am trying to learn how to instantiate an endpoint request with MVVM architecture, I took this project and did not build it, that is the reason why I do not understand it very well.</p>
<p>The firts layer is Endpoint</p>
<pre><code>enum TrackingOptionsEndpoint {

    case getTrackingOptions
}

extension TrackingOptionsEndpoint: TargetType, AccessTokenAuthorizable {

    var version: String {

        &quot;v1&quot;
    }

    var baseURL: URL {

        URL(string: Environment().configuration(PlistKey.serverURL))!
    }

    var path: String {

        switch self {

        case .getTrackingOptions:

            return &quot;api/\(self.version)/trackingoptions/all&quot;
        }
    }

    var method: Moya.Method {

        switch self {

        case .getTrackingOptions:
            return .get
        }
    }

    var task: Task {

        switch self {

        case .getTrackingOptions:
            return .requestPlain
        }
    }

    var headers: [String: String]? {
        [&quot;Content-Type&quot;: &quot;application/json&quot;]
    }

    var authorizationType: AuthorizationType? {
        .bearer
    }

    var sampleData: Data {
        &quot;&quot;.data(using: .utf8)!
    }
}
</code></pre>
<p>The sedond layer is Protocol or Repository:</p>
<pre><code>protocol TrackingOptionsRepositoryProtocol {
    func getCatalog() -&gt; Observable&lt;IBANResult&lt;TrackingOptionsResponse&gt;&gt;
}
final class TrackingOptionsEndRepository: TrackingOptionsRepositoryProtocol, MoyaEndpointResolver {
    typealias T = TrackingOptionsEndpoint
    private let provider: MoyaProvider&lt;T&gt;
    private let plugins: [PluginType] = [Auth0Plugin(),
                                         InterceptorPlugin()]

    init() {
        self.provider = MoyaProvider&lt;T&gt;(requestClosure: TrackingOptionsEndRepository.endpointResolver(),
                                        plugins: self.plugins)
    }
}

// MARK: - Requests -

extension TrackingOptionsEndRepository {
    // MARK: - Card Activation Flow -

    func getCatalog() -&gt; Observable&lt;IBANResult&lt;TrackingOptionsResponse&gt;&gt; {
        self.provider
            .rx
            .request(.getTrackingOptions)
            .map(EncapsulationResponse&lt;TrackingOptionsResponse&gt;.self)
            .map { $0.toResult() }
            .asObservable()
    }
}
</code></pre>
<p>The model or Response</p>
<pre><code>struct TrackingOptionsResponse: Codable {
    let data : [DataInfo]
    let meta : String
}

struct DataInfo : Codable {
    let id: String
    let verb: String
    let url: String
    let regex: String
    let isMovement: Bool
}
</code></pre>
<p>im trying to call or invoke the method with a function but i dont know which is the correct method to do it, i show you and example, trying to call it in the Splashviewmodel, the method where i trying to call is getTrackingOptionsIO</p>
<pre><code>class SplashViewViewModel: ViewModelType, Loadable {

    private let retrySubject: PublishSubject&lt;Void&gt; = PublishSubject&lt;Void&gt;()
    struct Input {
        let trigger: Driver&lt;Void&gt;
    }

    struct Output {
        let triggered: Driver&lt;Void&gt;
        let retrySubject: Driver&lt;Void&gt;
    }

    private let defaultsManager: UserDefaultsManager2.Type
    private let analyticsRepository: AnalyticsRepositoryProtocol
    private let trackingOptionsRepository: TrackingOptionsRepositoryProtocol
    init(coreDependencies: CoreProtocol) {
        
        self.defaultsManager = coreDependencies.userDefaultsManager2
        self.analyticsRepository = coreDependencies.analyticsRepository
        self.trackingOptionsRepository = coreDependencies.trackingsRepository
    }

    func transform(input: Input) -&gt; Output {
        self.getTrackingOptionsIO()
        let retry: Driver&lt;Void&gt; = self.retrySubject.asDriverOnErrorJustComplete().flatMap { self.loadData() }

        let triggered = input.trigger
            .flatMap { self.loadData() }

        return Output(triggered: triggered,
                      retrySubject: retry)
    }

    private func loadData() -&gt; Driver&lt;Void&gt; {
        
        return Observable.combineLatest(self.getCustomerIOId(),
                                 self.loadRemoteConfigValue())
            .do(onNext: { _, result in

                if result {

                    Application.shared.applicationStateTrigger.onNext(.finishedLoadingInitialValues)
                    RemoteConfigValues.shared.startTimer()
                }

            }, onError: { _ in

                if !Reachability.isConnectedToNetwork() { Reachability.displayNoConnectionErrorSnackBar(); return }

                Reachability.showSystemAlert(title: &quot;error_occurred&quot;.localized(), with: &quot;&quot;) { [weak self] in

                    self?.retrySubject.onNext(())
                }
            })
            .mapToVoid()
            .asDriver(onErrorJustReturn: ())
    }

    private func loadRemoteConfigValue() -&gt; Observable&lt;Bool&gt; {

        RemoteConfigValues.shared.fetchAndActivateObservable()
            .flatMap { _ in Reachability.checkBuildVersionSanity() }
    }
    
     
    private func getTrackingOptionsIO() -&gt; Observable&lt;TrackingOptionsResponse&gt; {
        return trackingOptionsRepository.getCatalog().map({ res in
            switch res {

            case let .success(res):


                return Observable&lt;TrackingOptionsResponse&gt;

            case let .failure(error):
                return Observable.error(IBANError.defaultError)
            }
        })
    }

    
    private func getCustomerIOId() -&gt; Observable&lt;String&gt; {
        
        guard let analyticsId = self.defaultsManager.analyticsId else {

            guard let identifierId = UIDevice.current.identifierForVendor?.uuidString else {

                print(&quot;missing vendor identifier&quot;)
                return Observable.error(IBANError.defaultError)
            }

            return self.analyticsRepository.getAnalyticsId(externalId: identifierId).flatMap { result -&gt; Observable&lt;String&gt; in

                switch result {

                case let .success(result):

                    guard let analyticsId = result?.analyticsId else {

                        return Observable.error(IBANError.defaultError)
                    }

                    return Observable.just(analyticsId)

                case let .failure(error):
                    return Observable.error(error)
                }

            }.do(onNext: { [weak self] analyticsId in

                print(&quot;AnalyticsId is \(analyticsId)&quot;)
                self?.defaultsManager.analyticsId = analyticsId
            })
        }

        print(&quot;AnalyticsId is \(analyticsId)&quot;)
        return Observable.just(analyticsId)
    }
}
</code></pre>
","5954258","","","","","2021-06-28 14:02:26","RxSwift + Moya, endpoint request instance?","<swift><request><observable><rx-swift><moya>","0","0","","","","CC BY-SA 4.0"
"68166444","1","","","2021-06-28 15:54:30","","0","60","<p>I'm migrating from RxSwift to Combine and ran into this issue related to error handling:</p>
<pre><code>func myMethod(firstName: String?) -&gt; Observable&lt;Data&gt; {
     guard let firstName = firstName else {
     return Observable.error(MyErrorEnum.error)
    }
    return someAPICall... 
}
</code></pre>
<p>I'm migrating to Combine as follows:</p>
<pre><code>func myMethod(firstName: String?) -&gt; AnyPublisher&lt;Data, Error&gt; {
     guard let firstName = firstName else {
     // can't quite figure out how to return an error here... 
    }
    return someAPICall... 
}
</code></pre>
<p>I normally don't struggle handling errors, specially when working with network calls, but for some reason this one is avoiding me.</p>
<p>Really appreciate any input!</p>
","14613107","","","","","2021-06-29 05:45:57","Migrating RxSwift to Combine","<ios><swift><rx-swift><combine>","1","3","","","","CC BY-SA 4.0"
"68170653","1","68175409","","2021-06-28 22:29:03","","0","45","<p>I'd like to use RxSwift to process video frames captured from the iPhone camera. I'm using a community maintained project, <a href=""https://github.com/RxSwiftCommunity/RxAVFoundation"" rel=""nofollow noreferrer"">https://github.com/RxSwiftCommunity/RxAVFoundation</a>, which bridges AVFoundation (used to capture camera output) and RxSwift.</p>
<p>I'm trying to just print a dummy log statement whenever new video frames get written to the output buffer. The following is my ViewController. I configure the AVCaptureSession, set up the Rx chain, then start the session. However, the print statement in the .next case is never triggered. I reached out to the project owner. Is the below code correct? Here's the Reactive extension for the AVCaptureSession class from the community maintained project: <a href=""https://github.com/RxSwiftCommunity/RxAVFoundation/blob/master/RxAVFoundation/AVCaptureSession%2BRx.swift"" rel=""nofollow noreferrer"">https://github.com/RxSwiftCommunity/RxAVFoundation/blob/master/RxAVFoundation/AVCaptureSession%2BRx.swift</a></p>
<pre><code>//  ViewController.swift
import UIKit
import AVFoundation
import RxSwift

class ViewController: UIViewController {

    // capture session
    private let session = AVCaptureSession()
    private var videoDevice: AVCaptureDevice!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.videoDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back)
    
        session
            .rx
            .configure(captureDevice: videoDevice)
    
        let disposeBag = DisposeBag()
        
        let videoSettings = [(kCVPixelBufferPixelFormatTypeKey as NSString) : NSNumber(value: kCVPixelFormatType_32BGRA)] as [String : Any]
        session
            .rx
            .videoCaptureOutput(settings: videoSettings)
            .observeOn(MainScheduler.instance)
            .subscribe { [unowned self] (event) in
                switch event {
                    case .next(let captureOutput):
                        print(&quot;got a frame&quot;)
                    case .error(let error):
                        print(&quot;error: %@&quot;, &quot;\(error)&quot;)
                    case .completed:
                        break // never happens
                }
            }
            .disposed(by: disposeBag)
        session
            .rx
            .startRunning()
    }
}
</code></pre>
","1041015","","","","","2021-06-29 08:46:44","Subscription to RxSwift Observable<VideoCaptureOutput> not triggering onNext()","<ios><swift><avfoundation><rx-swift>","1","2","","","","CC BY-SA 4.0"
"68192816","1","68194512","","2021-06-30 10:13:42","","0","16","<p>I have and array I'm subscribing, objects in this array has a property date, in form of a String. I need to order the array I receive from subscription by such date, but cannot make it if it is a string, I think need to convert that string in a date then use it to order them. I know how to convert from string to date, but no idea where to do</p>
<p>object is like to</p>
<pre><code>struct Task: codable {
var date = &quot;yyyy-MM-dd'T'HH:mm:ss.SSSZ&quot;
}

self.viewModel.tasks
    .map({ items in
       return items.sorted(by: { $0.date.compare($1.date) == .orderedAscending })
     })
            .bind(to: self.tasksTableView.rx.items(dataSource: self.dataSource))
            .disposed(by: self.rx.disposeBag)
</code></pre>
","4846391","","4846391","","2021-06-30 12:02:14","2021-06-30 12:10:21","RxSwift ordering by date after convertiing from string","<date><mapping><rx-swift>","1","2","","","","CC BY-SA 4.0"
"68194956","1","","","2021-06-30 12:39:26","","0","13","<p>in this code I get data from an observable, then pass it to a tableView. bookings were divided by Date, but now I don't need it anymore, how can I use a unique section, maintaining the right ordering?</p>
<pre><code>self.viewModel.bookings
    
    .map({ items in
        // Group items by initial (removing diacritic and case)
        return Dictionary(grouping: items, by: { item in
            return item.dateFromStringToDate()
        })
    })
    .map({ groups in
        // Map groups to sections
        return groups.reduce(into: [AppointmentHeaderSection]()) { (sections, tuple) in
            let (header, items) = tuple
            sections.append(AppointmentHeaderSection(header: header, items: items))
        }
    })
    .map({ sections in
        // Order sections by header
        return sections.sorted(by: { $0.header.compare($1.header) == .orderedAscending })
    })
    
    .bind(to: self.appointmentsTableView.rx.items(dataSource: self.dataSource))
    .disposed(by: self.rx.disposeBag)
</code></pre>
","4846391","","","","","2021-06-30 12:39:26","in RxSwift, how to avoid this section division?","<uitableview><mapping><rx-swift>","0","0","","","","CC BY-SA 4.0"
"68199602","1","","","2021-06-30 18:01:02","","0","43","<p>I simply have custom UIView called CheckboxView with property <code>isSelected: Bool</code>. How do I observe that value and bind it to another property in my view model?</p>
<pre><code>let isSelected = BehaviorRelay&lt;Bool&gt;(value: false)

class CheckboxView: UIView {
    var isSelected: Bool = false
}


let view = CheckboxView()
</code></pre>
","2725435","","","","","2021-07-07 09:35:33","How do I bind a Boolean property to BehaviorRelay<Bool>(value: false)","<ios><swift><rx-swift>","1","7","","","","CC BY-SA 4.0"
"68214212","1","68236864","","2021-07-01 16:59:09","","1","43","<p>I simply have something like this:</p>
<pre><code>    class CheckboxView: UIView {
        private let button = UIButton()
        var rxaction: RxSwift.Reactive&lt;UIButton&gt; {
            button.rx
        }
    }

    let view = CheckboxView()

    view.rxaction.tap.bind { in
          print(sth)
    }.disposed(by: disposeBag)
</code></pre>
<p>How can I perform action manually using <code>rxaction</code> to call bind closure?</p>
","2725435","","472495","","2021-07-17 10:24:17","2021-07-17 10:24:17","How do I trigger action for rx.tap.bind of UIButton?","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"68336140","1","68336437","","2021-07-11 12:16:54","","1","57","<p>I have used two functions. First <code>combineLatest</code>:</p>
<pre><code>        enum Weather {
            case cloudy
            case sunny
        }
        let left: Observable&lt;Weather&gt; = Observable.of(.sunny, .cloudy, .cloudy, .sunny)
        let right = Observable.of(&quot;Lisbon&quot;, &quot;Copenhagen&quot;, &quot;London&quot;, &quot;Madrid&quot;, &quot;Vienna&quot;)
        let observable = Observable.combineLatest(left, right) { weather, city in
            return &quot;It's \(weather) in \(city)&quot;
        }
        _ = observable.subscribe(onNext: { value in
            print(value)
        })
</code></pre>
<p>with output:</p>
<pre>It's sunny in Lisbon
It's cloudy in Lisbon
It's cloudy in Copenhagen
It's cloudy in Copenhagen
It's cloudy in London
It's sunny in London
It's sunny in Madrid
It's sunny in Vienna</pre>
<p>and <code>zip</code>:</p>
<pre><code>        enum Weather {
            case cloudy
            case sunny
        }
        let left: Observable&lt;Weather&gt; = Observable.of(.sunny, .cloudy, .cloudy, .sunny)
        let right = Observable.of(&quot;Lisbon&quot;, &quot;Copenhagen&quot;, &quot;London&quot;, &quot;Madrid&quot;, &quot;Vienna&quot;)
        let observable = Observable.zip(left, right) { weather, city in
            return &quot;It's \(weather) in \(city)&quot;
        }
        _ = observable.subscribe(onNext: { value in
            print(value)
        })
</code></pre>
<p>with output:</p>
<pre>It's sunny in Lisbon
It's cloudy in Copenhagen
It's cloudy in London
It's sunny in Madrid</pre>
<p>How does it work? I understand that zip just map values one to one, and if there is no value for same index, it just skip it. But how to understand <code>combineLatest</code>?</p>
","2725435","","","","","2021-07-12 00:37:30","Understanding difference between zip and combineLatest with RxSwift for sequence parameters","<ios><swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"68375165","1","","","2021-07-14 09:08:57","","1","73","<p>I am unable to figure out how to get the correct memory address for a computed variable defined inside a class/struct. I defined a class in the following way (similar way for struct also):</p>
<pre><code>class TestClass {
    private var a = &quot;Hello&quot;
    
    var getterSetter: String {
        get {
            return a
        }
        set {
            a = newValue
        }
    }
}
</code></pre>
<p>For the sake of simplicity, let's say I define my ViewController as follows:</p>
<pre><code>class ViewController: UIViewController {
    private let testClass = TestClass()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        demoMethod()
        
        print(&quot;--------&quot;)
        print(testClass.getterSetter)    //Prints &quot;I'm here&quot;
        
        /// Address of testClass
        print(&quot;Address of testClass: \(Unmanaged.passUnretained(self.testClass).toOpaque())&quot;)
        
        /// Address of computed variable in testClass
        withUnsafePointer(to: &amp;self.testClass.getterSetter) {
            print(&quot;Address of computed variable: \(String(format: &quot;%p&quot;, $0.pointee))&quot;)
        }
        print(&quot;--------&quot;)
        
    }
    
    private func demoMethod() {
        Observable.just(())
            .subscribe(onNext: { [weak self] in
                guard let self = self else { return }
                self.testClass.getterSetter = &quot;I'm here&quot;
                
                print(&quot;*****&quot;)
                /// Address of testClass
                print(&quot;Address of testClass: \(Unmanaged.passUnretained(self.testClass).toOpaque())&quot;)
                
                /// Address of computed variable in testClass
                withUnsafePointer(to: &amp;self.testClass.getterSetter) {
                    print(&quot;Address of computed variable: \(String(format: &quot;%p&quot;, $0.pointee))&quot;)
                }
                print(&quot;*****&quot;)
            })
            .disposed(by: DisposeBag())
    }
}
</code></pre>
<p>The value of <strong>getterSetter</strong> variable is accessed and set inside <strong>demoMethod</strong> function, using a simple <strong>Observable</strong>, which in turn changes <strong>a</strong> to <strong>&quot;I'm here&quot;</strong>. I'm printing the addresses of testClass and getterSetter variable inside the demoMethod function as well as after this function returns.</p>
<p>Please have a look at the link here, that shows output.</p>
<p><img src=""https://i.stack.imgur.com/Snkval.png"" alt=""Output here"" /></p>
<p>As we can see from the image, <em>the testClass instance address remains same</em>, as expected. But, <em>the getterSetter variable's address is shown different each time it is printed</em>, which does not make sense because the <strong>private variable a</strong> gets changed to <strong>&quot;I'm here&quot;</strong> (can be seen in the output link), implying that they should point to same memory.</p>
<p>If I remove <strong>self.testClass.getterSetter = &quot;I'm here&quot;</strong> from <strong>demoMethod</strong>, it starts giving correct and same memory addresses like this:</p>
<p><img src=""https://i.stack.imgur.com/kcMNml.png"" alt=""Updated Output"" /></p>
<ul>
<li><em>I believe it has to do something with <strong>Copy on Write</strong> mechanism, but I'm unable to figure out exactly what. If the original instance is
copied to a new memory when I do <strong>self.testClass.getterSetter = &quot;I'm here&quot;</strong>, then how come value of <strong>a</strong> got changed at
original memory address?</em></li>
<li>So, what exactly is going on here and how is memory getting
allocated?</li>
</ul>
<p><strong>P.S.</strong> Also, the exact same thing is observed when I use <strong>struct TestClass</strong> in place of <strong>class TestClass</strong> with only difference being, I print using <strong>print(&quot;Address of testClass: (String(format: &quot;%p&quot;, unsafeBitCast(self.testClass, to: String.self)))&quot;)</strong></p>
","16445325","","16445325","","2021-07-19 08:31:38","2021-07-19 08:31:38","Weird memory address issue in Swift","<swift><rx-swift>","0","3","","","","CC BY-SA 4.0"
"68376981","1","68377299","","2021-07-14 11:12:09","","0","41","<p>I have a function in HomeViewModel to get books from api service using Alamofire .. I want when error occur show alert to show the user error message</p>
<p>here my ViewModel..</p>
<blockquote>
<p>import Foundation
import RxCocoa
import RxSwift
import Alamofire</p>
</blockquote>
<p>class HomeViewModel {</p>
<pre><code>var loadingBehavior  = BehaviorRelay&lt;Bool&gt;(value: false)

private var homeModelSubject = PublishSubject&lt;[Book]&gt;()
private var isTableHidden    = BehaviorRelay&lt;Bool&gt;(value: false)

var homeModelObservable: Observable&lt;[Book]&gt; {
    return homeModelSubject
}

var isTableHiddenObservable:Observable&lt;Bool&gt; {
    return isTableHidden.asObservable()
}

func getBooks() {
    
    loadingBehavior.accept(true)
    
    let url = &quot;https://simple-books-api.glitch.me/books&quot;
    
    APIServices.instance.getData(url: url, method: .get, params: nil, encoding: JSONEncoding.default, headers: nil) {[weak self] (bookModel: [Book]?, baseError: HomeBaseError?, error) in
        
        guard let self = self else { return }
        
        self.loadingBehavior.accept(false)
        
        if let error = error {
            print(error)
            
        } else if let baseError = baseError {
            print(baseError)
            
        } else {
            
            guard let books = bookModel else { return }
            if books.count &gt; 0 {
                
                self.homeModelSubject.onNext(books)
                self.isTableHidden.accept(true)
                
            } else {
                self.isTableHidden.accept(false)
            }
        }
    }
}
</code></pre>
<p>}</p>
<blockquote>
<p>here my HomeVC
import UIKit
import RxCocoa
import RxSwift</p>
</blockquote>
<p>class HomeVC: UIViewController {</p>
<pre><code>let tableView: UITableView = {
    let tableView = UITableView()
    tableView.separatorColor = .clear
    tableView.rowHeight = 140
    tableView.register(HomeTableViewCell.self, forCellReuseIdentifier: HomeTableViewCell.reuseIdentifier)
    return tableView
}()

let homeViewModel = HomeViewModel()
let disposeBage   = DisposeBag()

override func viewDidLoad() {
    super.viewDidLoad()
    configureViewController()
    configureTableView()
    subscribeToLoading()
    subscribeToResponse()
    subscribeToPostSelection()
    getResponse()
    
}

func configureViewController() {
    title = &quot;Home&quot;
    view.backgroundColor = .systemBackground
}

func configureTableView() {
    tableView.translatesAutoresizingMaskIntoConstraints = false
    view.addSubview(tableView)
    NSLayoutConstraint.activate([
        tableView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
        tableView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
        tableView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
        tableView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor),
    ])
}

func subscribeToLoading() {
    homeViewModel.loadingBehavior.subscribe(onNext: { (isLoading) in
        if isLoading {
            self.showIndicator(withTitle: &quot;loading&quot;, and: &quot;&quot;)
        } else {
            self.hideIndicator()
        }
    }).disposed(by: disposeBage)
}

func subscribeToResponse() {
    homeViewModel.homeModelObservable.bind(to: self.tableView.rx.items(cellIdentifier: HomeTableViewCell.reuseIdentifier, cellType: HomeTableViewCell.self)) { row,books,cell in
        cell.separatorInset = UIEdgeInsets(top: 0, left: 0, bottom: 20, right: UIScreen.main.bounds.width)
        cell.titleLabel.text            = books.name
        cell.secondaryTitleLabel.text  = books.type
        if books.available == true {
            cell.avalibaleOrNotLabel.text = &quot;Avalibale&quot;
            cell.avalibaleOrNotStatus.backgroundColor = .green
        } else {
            cell.avalibaleOrNotLabel.text = &quot;Not Avalibale&quot;
            cell.avalibaleOrNotStatus.backgroundColor = .gray
        }
        
    }.disposed(by: disposeBage)
}

func subscribeToPostSelection() {
    Observable.zip(tableView.rx.itemSelected,tableView.rx.modelSelected(Book.self)).bind { selectedIndex , post in
        print(selectedIndex)
    }.disposed(by: disposeBage)
}

func getResponse() {
    homeViewModel.getBooks()
}
</code></pre>
<p>}</p>
","12468380","","","","","2021-07-14 11:34:31","I want to make alert to show message error in HomeVC","<ios><swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"68393398","1","68394183","","2021-07-15 11:59:13","","0","28","<p>I make a generic function using Alamofire</p>
<p>This is function</p>
<pre><code>class APIServices {
    
    private init() {}
    static let instance = APIServices()
    
    func getData&lt;T: Decodable, E: Decodable&gt;(url: String, method: HTTPMethod ,params: Parameters?, encoding: ParameterEncoding ,headers: HTTPHeaders? ,completion: @escaping (T?, E?, Error?)-&gt;()) {
        
        AF.request(url, method: method, parameters: params, encoding: encoding, headers: headers)
            .validate(statusCode: 200...300)
            .responseJSON { (response) in
                switch response.result {
                case .success(_):
                    guard let data = response.data else { return }
                    do {
                        let jsonData = try JSONDecoder().decode(T.self, from: data)
                        completion(jsonData, nil, nil)
                    } catch let jsonError {
                        print(jsonError)
                    }
                    
                case .failure(let error):
                    // switch on Error Status Code
                    guard let data = response.data else { return }
                    guard let statusCode = response.response?.statusCode else { return }
                    switch statusCode {
                    case 400..&lt;500:
                        do {
                            let jsonError = try JSONDecoder().decode(E.self, from: data)
                            completion(nil, jsonError, nil)
                        } catch let jsonError {
                            print(jsonError)
                        }
                    default:
                        completion(nil, nil, error)
                    }
                }
            }
    }
}
</code></pre>
<p>and use it in HomeViewModel</p>
<pre><code>class HomeViewModel {
    
    var loadingBehavior  = BehaviorRelay&lt;Bool&gt;(value: false)
    
    private var homeModelSubject = PublishSubject&lt;[Book]&gt;()
    private var isTableHidden    = BehaviorRelay&lt;Bool&gt;(value: false)
    
    var homeModelObservable: Observable&lt;[Book]&gt; {
        return homeModelSubject
    }
    
    var isTableHiddenObservable:Observable&lt;Bool&gt; {
        return isTableHidden.asObservable()
    }
    
    
    func getBooks(handler: @escaping networkHandler) {
        loadingBehavior.accept(true)
        let url = &quot;https://simple-books-api.glitch.me/books&quot;
        APIServices.instance.getData(url: url, method: .get, params: nil, encoding: JSONEncoding.default, headers: nil) {[weak self] (bookModel: [Book]?, baseError: HomeBaseError?, error) in
            guard let self = self else { return }
            self.loadingBehavior.accept(false)
            if let error = error {
                print(&quot;this is error discription\(error.localizedDescription)&quot;)
            } else if let baseError = baseError {
                print(baseError.error)
            } else {
                guard let bookModel = bookModel else { return }
                if bookModel.count  &gt; 0 {
                    self.homeModelSubject.onNext(bookModel)
                    self.isTableHidden.accept(false)
                } else {
                    self.isTableHidden.accept(true)
                }
            }
        }
        
    }
}
</code></pre>
<p>the problem is when close wifi loading do not stop and do not print error.localizedDescription and when I make debug do not go to if let error ...</p>
","12468380","","9223839","","2021-07-15 12:01:35","2021-07-15 12:56:57","loading behavior do not stop when error occur","<ios><swift><rx-swift>","1","4","","","","CC BY-SA 4.0"
"68418883","1","68420285","","2021-07-17 08:42:49","","1","90","<p>I want to learn MVVM RxSwift with input and output method, I want to get a username from textfield.</p>
<p>I have a scenario when user not enter a username it will present an error and when user enter a username it will present in viewController.</p>
<p>This is when I confuse. I got the error message and successfully present error but, how can I catch the query in my viewModel and passed the data to viewController.</p>
<p>This is how I setup my searchViewModel</p>
<pre><code>protocol ViewModelType {
    associatedtype Input
    associatedtype Output
    
    func transform(input: Input) -&gt; Output
}

class SearchViewModel: ViewModelType {
                
    // MARK: Binding
    struct Input {
        let searchText: Observable&lt;String&gt;
        let validate: Observable&lt;Void&gt;
    }
    
    struct Output {
        let username: Driver&lt;String&gt;
    }
    
    func transform(input: Input) -&gt; Output {
        let username = input.validate
            .withLatestFrom(input.searchText)
            .map { query in
                if query.isEmpty {
                    return &quot;Please enter a username. We need to know who to look for&quot;
                } else {
                    return query
                }
            }.asDriver(onErrorJustReturn: &quot;&quot;)
        
        
        
        return Output(username: username)
    }
}
</code></pre>
<p>and this is my viewDidLoad in SearchViewController</p>
<pre><code>    let searchTextField = GFTextField()
    let calloutBtn      = GFButton(backgroundColor: .systemGreen, title: &quot;Get followers&quot;)
    
    private let disposeBag = DisposeBag()

override func viewDidLoad() {
        super.viewDidLoad()

        view.backgroundColor = .systemBackground
        setupImageView()
        setupTextfield()
        setupCalloutBtn()
        
        let input = SearchViewModel.Input(
            searchText: searchTextField.rx.text.orEmpty.asObservable(),
            validate: calloutBtn.rx.tap.asObservable())
        
        let output = viewModel.transform(input: input)
        
        output.username.drive { [weak self] username in
            guard let self = self else { return }
            self.presentGFAlertOnMainThread(title: &quot;Empty Username&quot;, message: username, buttonTitle: &quot;Dismiss&quot;)
        }.disposed(by: disposeBag)

    }
</code></pre>
","8907890","","8907890","","2021-07-17 10:14:55","2021-07-18 00:25:39","Passed in data MVVM RxSwift","<ios><swift><mvvm><rx-swift>","1","1","","","","CC BY-SA 4.0"
"68432770","1","68433452","","2021-07-18 20:18:02","","1","50","<p><strong>Please note:</strong> Despite me using Swift-lang in the examples, I encourage you to try and help me even if you know RxJava and rxjs or any other Rx implementation.</p>
<p><strong>Question:</strong> I have a state machine that is written imperatively. I would like to rewrite reactively using Rx but I am struggling with coming up with the ways to do it proper.</p>
<p>Current imperative system looks like this:</p>
<pre class=""lang-swift prettyprint-override""><code>var state: State
var metaState: MetaState

func updateMetaStateIfNeeded() {
    if Bool.random() {
        metaState = MetaState()
    }
}

func tick() -&gt; State {
    updateMetaStateIfNeeded()

    let newState = State(currentState: state, metaState: metaState)
    self.state = newState
    return newState
}
</code></pre>
<p>What I came up with so far:</p>
<pre><code>let tick = PublishSubject&lt;Void&gt;()
let metaState = BehaviorSubject&lt;MetaState&gt;()
let state = BehaviorSubject&lt;State&gt;()

let tickAfterMetaStateUpdate = PublishSubject&lt;Void&gt;()

tick -&gt; withLatestFrom metaState -&gt; map to new metaState if update needed or the old one -&gt; put result into metaState AND tickWithUpdatedMetaState

tickAfterMetaStateUpdate -&gt; withLatestFrom state AND metaState -&gt; map State(currentState: state, metaState: metaState) -&gt; put result into state

(The users of this API subscribe to state subject, which will be updated every tick)
</code></pre>
<p>I am dissatisfied with this result I came up with. I wonder if it's possible to rewrite this using <code>scan</code> or <code>reduce</code> so that there is no usage of Subjects and it's a plain Observable.</p>
<p><strong>UPDATE after @Daniel T.'s answer:</strong></p>
<p>Wow, this was exactly the proper solution! I have prepared the analytics:</p>
<ul>
<li>There are 2 state machines, one for <code>metaState</code> update, one for <code>state</code> update</li>
<li>Each of them has it's own start states which we don't need to specify</li>
<li>The input alphabet for <code>metaState</code> is <code>Void</code>, a mere presence of a tick. For <code>state</code>, it's the <code>metaState</code> output of the first state machine</li>
</ul>
<p>So with this understanding, I have rewriten the system using 2 scans:</p>
<pre class=""lang-swift prettyprint-override""><code>let state = tick
    .scan(MetaState()) { currentMetaState, void in
        if Bool.random() {
            return MetaState()
        }
        return currentMetaState
    }
    .scan(State()) { currentState, currentMetaState in
        State(currentState: state, metaState: metaState)
    }
</code></pre>
<p>WINRAR! Mind_blown.jpg! Actually, now with hind-sight it kinda seems obvious... :) Thank you, thank you, thank you!</p>
","9353387","","9353387","","2021-07-19 07:23:20","2021-07-19 11:51:14","How do I properly organize this Rx-based reactive state machine?","<rxjs><rx-java><reactive-programming><rx-swift><frp>","1","1","","","","CC BY-SA 4.0"
"68451656","1","","","2021-07-20 08:17:29","","0","25","<p>I want to bind that debounce thing to my UIButton-star, but there are some issues.</p>
<pre class=""lang-swift prettyprint-override""><code>@IBOutlet weak var star: UIButton!

    
    private func starTapRx(){
        print( &quot;rx&quot; )     // this works well

//        star.rx.tap.asDriver().          &lt;- same error here
//             debounce(.seconds(1)).drive(onNext: { (_) in
//                print(&quot;presssssss&quot;)
//             }).disposed(by: bag)
        
        
        star.rx.tap.bind{ print(&quot;bind&quot;)}.disposed(by: bag)
    }
</code></pre>
<p>this is the error: <a href=""https://i.stack.imgur.com/im9da.png"" rel=""nofollow noreferrer"">image</a>
It occurs on &quot;.rx&quot;, and I cannot understand why it is Optional value.
I import RxSwift, RxCocoa.</p>

","15136199","","15136199","","2021-07-20 08:33:33","2021-07-20 08:33:33","RxSwift) cannot bind rx to IBoutlet button, occurs ""Thread 1: Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value""","<rx-swift><debounce>","0","1","","","","CC BY-SA 4.0"
"68479242","1","68484243","","2021-07-22 04:35:09","","1","58","<p><strong>I wrote such code for network request token refresh.</strong></p>
<pre><code>enum NetworkingClient {
    private static func _makeUnaryCall&lt;Request: SwiftProtobuf.Message, Response: SwiftProtobuf.Message&gt;(
        call maker: @escaping () -&gt; UnaryCall&lt;Request, Response&gt;
        ) -&gt; Single&lt;Response&gt; {
        return Single&lt;Response&gt;.create { (handler) -&gt; Disposable in
            let call = maker()
            call.response
                .whenComplete {
                    do {
                        handler(.success(try $0.get()))
                    } catch {
                        handler(.error(error))
                    }
                }
            return Disposables.create()
        }
        .subscribeOn(requestScheduler)
    }

    static func makeUnaryCall&lt;Request: SwiftProtobuf.Message, Response: SwiftProtobuf.Message&gt;(
        serverInfo: ServerInfo,
        call maker: @escaping () -&gt; UnaryCall&lt;Request, Response&gt;
        ) -&gt; Single&lt;Response&gt; {
        let gid = serverInfo.gid
        let uid = serverInfo.uid
        return self._makeUnaryCall(call: maker)
            .retryWhen { errorObservable -&gt; Observable&lt;Void&gt; in
                return errorObservable.flatMap { error -&gt; Observable&lt;Void&gt; in
                    if let errorCode = error as? NetworkingError, case .tokenExpired(let token) = errorCode {
                        return VoidToken.reLogin(token: token!, serverInfo: serverInfo)
                    }
                    throw error
                }            }
            .do(onError: { (err) in
                log.error(&quot;\(gid)-\(uid)-\(serverInfo.host)-\(serverInfo.port)-\(err)&quot;)
            })
            .observeOn(MainScheduler.instance)
    }
}

enum VoidToken {
    static var caches: [String: Observable&lt;Void&gt;] = [:]
    static let lock = NSLock()
    static func reLogin(token: Token, serverInfo: ServerInfo) -&gt; Observable&lt;Void&gt; {
        VoidToken.lock.lock()
        if let refreshTokenReq = VoidToken.caches[token.accessToken] {
            VoidToken.lock.unlock()
            return refreshTokenReq
        }
        var service: LoginService? = LoginService(serverInfo: serverInfo)
        let refreshReq = service!
            .refreshToken(refreshToken: token.refreshToken)
            .retryWhen({ errorObservable in
                return errorObservable.flatMap { error -&gt; Observable&lt;Void&gt; in
                    if let err = error as? GRPCStatus, err.code == .unavailable {
                        return .just(())
                    }
                    throw error
                }
            })
            .debug(&quot;refreshToken&quot;)
            .asObservable()
            .share(replay: 1, scope: .forever)
            .map { _ in }
            .do(afterCompleted: {
                service = nil
            })
        VoidToken.caches[token.accessToken] = refreshReq
        VoidToken.lock.unlock()
        return refreshReq
    }
}

enum NetworkingError: Error {
    case tokenExpired(Token?)
}

extension LoginService {
    func refreshToken(refreshToken: String, loginChatService: Bool = true) -&gt; Single&lt;Void&gt; {
        let gid = self.gid
        let uid = self.uid
        return defaultImplementation
            .reLogin(refreshToken: refreshToken)
            .map { (rsp) -&gt; Token in
                precondition(rsp.hasSess)
                AccountKit.shared.updateToken(pid: gid + uid, session: rsp.sess)
                let token = AccountKit.shared.fetchAuth(gid: gid, uid: uid)!
                log.warn(&quot;token refresh success, newToken: \(token.accessToken) newIMToken\(token.imToken)&quot;)
                return token
            }
            .flatMap { token -&gt; Single&lt;Void&gt; in
                guard loginChatService else { return Single.just(()) }
                guard let chatService = AccountKit.shared.chatInfos.fetchWrapper(pid: gid + uid) else {
                    throw SourceContextError()
                }
                return chatService.rx.login(imToken: token.imToken, updateSyncTime: false)
                    .map { _ in () }
                    .catchErrorJustReturn(())
            }
    }
}
</code></pre>
<p><strong>But, I get a log that looks like this</strong></p>
<blockquote>
<p>2021-07-19 16:24:24.208: refreshToken -&gt; subscribed<br />
2021-07-19 16:24:24.494: refreshToken -&gt; isDisposed<br />
2021-07-19 16:24:25.037: refreshToken -&gt; subscribed<br />
2021-07-19 16:24:25.251: refreshToken -&gt; Event error(notLogin)<br />
2021-07-19 16:24:25.251: refreshToken -&gt; isDisposed</p>
</blockquote>
<p>I don’t know why <code>Refresh Token</code> isDisposed when there is no <code>ON NEXT</code><br />
This is an occasional problem, but I don’t know what caused it<br />
Its log output should normally look like this:</p>
<blockquote>
<p>2021-07-22 10:04:45.794: refreshToken -&gt; subscribed<br />
2021-07-22 10:04:52.254: refreshToken -&gt; Event next(())<br />
2021-07-22 10:04:52.266: refreshToken -&gt; Event completed<br />
2021-07-22 10:04:52.266: refreshToken -&gt; isDisposed</p>
</blockquote>
<p>I'd really appreciate it if you could help me.</p>
","8185962","","8185962","","2021-07-22 04:40:49","2021-07-22 11:56:40","RxSwift refreshToken use retry(when:)","<swift><rx-swift><refresh-token><grpc-swift>","1","0","","","","CC BY-SA 4.0"
"68497638","1","","","2021-07-23 10:17:11","","1","38","<p>Hi I am having hard time trying to figure this out.
There is some bunch of other problem.</p>
<p>Can anyone help me making <code>Observable&lt;[Observable&lt;CellModel&gt;]</code> to <code>Observable&lt;[CellModel]&gt;?</code></p>
<p>the outcome for the <code>request(categoryId: $0)</code> was <code>Observable&lt;[Observable&lt;CellModel&gt;?]&gt;</code></p>
<p><a href=""https://i.stack.imgur.com/NSber.png"" rel=""nofollow noreferrer"">enter image description here</a></p>
<pre><code>  selectCategory
        .do(onNext: { _ in output.cells.onNext([.init(cellID: kSkeletonTableID)]) })
        .flatMap { [unowned self] in request(categoryId: $0) }
       // .showIndicator()
        .trackError(errorTracker)
        .compactMap {
            var cellModel:[CellModel] = $0.flatMap { $0 }
            return cellModel
        }
        .bind(to: output.cells)
        .disposed(by: disposeBag)
</code></pre>
","7356622","","","","","2021-07-23 12:02:57","Observable<Observable<T>> to Observable<T> rxswift","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"68518087","1","68521134","","2021-07-25 11:27:15","","0","98","<p>So i am doing paging in my app yet i encounter some strange behavior :</p>
<pre><code>class ViewController: UIViewController {
   func bindRx() {
    btn.rx
        .tap
        .bind(to: viewModel.searchButtonTapped)
        .disposed(by: disposeBag)
    
    searchField.rx
        .text
        .orEmpty
        .bind(to: viewModel.searchText)
        .disposed(by: disposeBag)
    
    searchField.rx
        .searchButtonClicked
        .bind(to: viewModel.searchButtonTapped)
        .disposed(by: disposeBag)
    
    viewModel.itemsDriver.drive(tableView.rx.items) { (tableView, row, element) -&gt; UITableViewCell in
        
        switch element {
        case .post(model: let vm):
            let cell = tableView.dequeueReusableCell(withIdentifier: &quot;PostTableViewCell&quot;) as! PostTableViewCell
            cell.config(viewModel: vm)
            return cell
            
        case .promotion(title: _):
            let cell = tableView.dequeueReusableCell(withIdentifier: &quot;PromotionTableViewCell&quot;) as! PromotionTableViewCell
            return cell
        }
        
    }.disposed(by: disposeBag)
    
    viewModel
        .isLoading
        .drive(tableView.rx.animation)
        .disposed(by: disposeBag)
    
    tableView.rx
        .modelSelected(CellType.self)
        .bind(to: viewModel.selectedCell)
        .disposed(by: disposeBag)
    
    
 //        tableView.rx
  //            .willDisplayCell
  //            .subscribe(onNext: { cell, indexPath in
 //                let lastItem = self.viewModel.counter - 1
  //                if indexPath.row == lastItem {
 //                    self.viewModel.loadMore.accept(())
  //                }
 //            })
 //            .disposed(by: disposeBag)
    
    tableView.rx
        .reachedBottom()
        .debug(&quot;botoom!!!!!!!!!&quot;)
        .bind(to: self.viewModel.loadMore)
        .disposed(by: disposeBag)
}
</code></pre>
<p>}</p>
<pre><code>public extension Reactive where Base: UIScrollView {
/**
 Shows if the bottom of the UIScrollView is reached.
 - parameter offset: A threshhold indicating the bottom of the UIScrollView.
 - returns: ControlEvent that emits when the bottom of the base UIScrollView is reached.
 */
func reachedBottom(offset: CGFloat = 0.0) -&gt; ControlEvent&lt;Void&gt; {
    let source = contentOffset.map { contentOffset in
        let visibleHeight = self.base.frame.height - self.base.contentInset.top - self.base.contentInset.bottom
        let y = contentOffset.y + self.base.contentInset.top
        let threshold = max(offset, self.base.contentSize.height - visibleHeight)
        return y &gt;= threshold
    }
    .distinctUntilChanged()
    .filter { $0 }
    .map { _ in () }
    return ControlEvent(events: source)
}
</code></pre>
<p>}</p>
<pre><code>final class PostsViewModel {

init(networking: Networking = Networking()) {
    self.networking = networking
    
    
    
    searchButtonTapped.subscribe(onNext: { [weak self] value in
        self?.page = 0
        self?.counter = 0
        self?.loadMore.accept(())
    }).disposed(by: disposeBag)
    
    searchText.subscribe(onNext: { [weak self] value in
        self?.params.updateValue(value, forKey: &quot;search_query&quot;)
    }).disposed(by: disposeBag)
    
    
    let load = loadMore.scan(0) { (value, _) -&gt; Int in
        self.page = self.page + 1
        self.params.updateValue(self.page, forKey: &quot;page&quot;)
        return value + 1
    }
            
   let test = load
        .flatMapLatest { page in
            self.networking.preformNetworkTaskGet(
                endPoint: Api.get,
                type: Posts.self,
                methodType: .get,
                param: self.params)
              //  .debug(&quot;call1 🚘&quot;)
        }
    .scan(into: [Post]()) { current, items in
        current.append(contentsOf: items.data)
        self.counter = current.count
        }
  //  .debug(&quot; all  🚘&quot;)
    .share()
    
    let vm = test.map {
        self.postsToCellViewModel(posts: $0)
    }
    
   
    
    itemsDriver = vm
        .map { $0 }
        .asDriver(onErrorJustReturn: [])
        .debug(&quot;🚘2&quot;)
}

 struct Networking: NetworkType {
func downloadImage(url: String) -&gt; Observable&lt;UIImage&gt; {
    return Observable&lt;UIImage&gt;.create { (observer) -&gt; Disposable in
            AF.request(url).response{ response in
                print(response)
                switch response.result {
                case .success(let responseData):
                    observer.onNext(UIImage(data: responseData!)!)
                case .failure(let error):
                    observer.onError(error)
                }
            }
        return Disposables.create()
    }
}


func preformNetworkTaskGet&lt;T: Codable&gt;(endPoint: EndpointType, type: T.Type, methodType: MethodsType, param: [String : Any]?) -&gt; Observable&lt;T&gt; {
    return Observable&lt;T&gt;.create { (observer) -&gt; Disposable in
        if let url = endPoint.baseURL.appendingPathComponent(endPoint.path).absoluteString.removingPercentEncoding {
            AF.request(url, method: methodType.method, parameters: param, encoding: URLEncoding.default).responseJSON  { (response) in
                switch response.result {
                case .failure(let error):
                    observer.onError(error)
                case .success(_):
                    if let data = response.data {
                        let response = Response.init(data: data)
                        if let decode = response.decode(type) {
                            observer.onNext(decode)
                        } else {
                            observer.onError(NSError())
                        }
                    }
                }
            }
        }
        return Disposables.create()
    }
}
</code></pre>
<p>}</p>
<p>After the first network call i will enter the if and trigger self.viewModel.loadMore.accept(())  without any scrolling.
Any ideas?</p>
","5335109","","5335109","","2021-07-25 16:31:06","2021-07-25 17:44:47","RxSwift pagination tableView near bottom","<ios><swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"68523787","1","68529189","","2021-07-26 02:08:56","","1","25","<p>I have a network request that return an Observable Result, I want only to catch error message as a string so I can merge the error message with another error message. I try to use map from the result to only map out the error, but I can't figure it out how to correctly catch the error.</p>
<p>This is my network manager</p>
<pre><code>class NetworkManager {
    private let baseURL = &quot;https://api.github.com/&quot;
    
    func getFollowers(with username: String, page: Int) -&gt; Observable&lt;Result&lt;[Follower], GFError&gt;&gt; {
        let endpoint = baseURL + &quot;users/\(username)/followers?per_page=100&amp;page=\(page)&quot;
        let url = URL(string: endpoint)!
        
        return Observable.create { (observer) -&gt; Disposable in
            let task = URLSession.shared.dataTask(with: url) { data, response, error in
                if let _ = error {
                    observer.onNext(.failure(.unableToComplete))
                    return
                }
                
                guard let response = response as? HTTPURLResponse, response.statusCode == 200 else {
                    
                    observer.onNext(.failure(.invalidResponse))
                    return
                }
                
                guard let data = data else {
                    observer.onNext(.failure(.invalidData))
                    return
                }
                
                do {
                    let decoder                     = JSONDecoder()
                    decoder.keyDecodingStrategy     = .convertFromSnakeCase
                    decoder.dateDecodingStrategy    = .iso8601
                    
                    let results = try decoder.decode([Follower].self, from: data)
                    observer.onNext(.success(results))
                    observer.onCompleted()
                } catch {
                    observer.onNext(.failure(.invalidData))
                }
            }
            task.resume()
            return Disposables.create {
                task.cancel()
            }
        }
    }
</code></pre>
<p>This is my viewModel</p>
<pre><code>protocol ViewModelType {
    associatedtype Input
    associatedtype Output
    
    func transform(input: Input) -&gt; Output
}

class SearchViewModel: ViewModelType {
    
    // MARK: Properties    
    let manager: NetworkManager
            
    // MARK: Binding
    struct Input {
        let searchText: Observable&lt;String&gt;
        let validate: Observable&lt;Void&gt;
    }
    
    struct Output {
        let followers: Driver&lt;Result&lt;[FollowerViewModel], GFError&gt;&gt;
        let errorMessage: Driver&lt;String&gt;
    }
    
    init(manager: NetworkManager) {
        self.manager = manager
    }
    
    func transform(input: Input) -&gt; Output {
        let followers = input.validate
            .withLatestFrom(input.searchText)
            .filter { !$0.isEmpty }
            .flatMapLatest { query in
                return self.manager.getFollowers(with: query, page: 1)
            }.asDriver { error in
                return Driver.just(.failure(error as! GFError))
            }
        
        let missingName = input.validate
            .withLatestFrom(input.searchText)
            .compactMap { $0.isEmpty ? &quot;Please enter a username. We need to know who to look for&quot; : nil }
            .asDriver(onErrorJustReturn: &quot;&quot;)
        
        let errorMessage = followers
        
        let followerVM = followers.map { $0.map { $0.map { FollowerViewModel(follower: $0) }}}
        
        return Output(followers: followerVM, errorMessage: errorMessage)
    }
}
</code></pre>
","8907890","","","","","2021-07-26 11:39:32","How to get Error from network request using RxSwift","<ios><swift><mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"68525265","1","","","2021-07-26 06:15:45","","0","58","<p>Hi I am uploading one more question since last question answer was so helpful !
so I am acutally trying to get <code>Observable&lt;[CellModel&gt;]&gt;</code>
There is 10 different questionId in the array.
and I need to fetch additional data each in the same order.
and in result I ultimately want to have <code>Observable&lt;[CellModel&gt;]&gt;</code>
but seems like without  <code>Observable.create</code>
api response get all mixed and if it takes longer, it will just returned 8 items instead of 10 items.
So I ended up getting item <code>Observable&lt;[Observable&lt;CellModel&gt;?]</code>like this.
So I want to know if there is any diffrent way I can fetch addtional data without making additional Observable.create !
Thank you so much!</p>
<pre><code>    private func request(categoryId: Int?) -&gt; Observable&lt;[Observable&lt;CellModel&gt;?]&gt; {
            return .create { obs -&gt; Disposable in
                self.requestAuthData(categoryId: categoryId)
                    .trackError(self.errorTracker)
                    .debug()
                    .subscribe(onNext: { [weak self] model  in
                        guard let self = self else { return }
                        var cells: [Observable&lt;CellModel&gt;] = model.items.questions.map {
                            switch $0.cardType {
                            case .open:
                                if $0.type.isEssay {
                                    let info = $0
                                    return  Observable.create { [weak self] observer in
                                        self?.requestEssayData(question_id: info.id, info, completion: { (cellmodel) in
                                            observer.onNext(cellmodel)
                                            observer.onCompleted()
                                        })
                                        return Disposables.create()
                                    }
                                } else {
                                    let info = $0
                                    return  Observable.create { [weak self] observer in
                                        self?.requestMutipleAnswerData(question_id: info.id, info, completion: { (cellmodel) in
                                            observer.onNext(cellmodel)
                                            observer.onCompleted()
                                        })
                                        return Disposables.create()
                                    }
                                }
                            case .blind, .sample, .not_confirmed, .please_sign_in:
                                let info = $0
                                return  Observable.create { [weak self] observer in
                                    self?.requestMutipleAnswerData(question_id: info.id, info, completion: { (cellmodel) in
                                        observer.onNext(cellmodel)
                                        observer.onCompleted()
                                    })
                                    return Disposables.create()
                                }
                            }
                        }
                        cells.append( Observable.create { [weak self] observer in
                            observer.onNext( NewsTopScrollCellModel())
                            observer.onCompleted()
                            return Disposables.create()
                        })
                        obs.onNext(cells)
                        obs.onCompleted()
                    })
                return Disposables.create()
            }
        }



 private func requestEssayData(question_id: Int, _ item: QuestionInfo,  completion: @escaping (CellModel) -&gt; Void) {
        let info = item
        Observable.zip(self.requestDetailData(question_id), self.requestTagData(question_id))
            .trackError(self.errorTracker)
            .share()
            .subscribe(onNext: { [weak self] essay, tag in
                guard let self = self else { return }
                let noData: Bool = essay.items.totalCount == 0
                guard !noData else {
                    return  completion(EmptyCellViewModel(spacing: 0.5)) }
                completion(PremiumReviewEssayCellModel(item, companyID: self.companyID, essay: essay, tag: tag, delegate: self))
            })
            .disposed(by: self.disposeBag)
    }

private func requestDetailData(_ question_id: Int) -&gt; Observable&lt;EssayModel&gt; {
    let params: [String: Any] = [&quot;company_id&quot;: companyID, &quot;question_id&quot;: question_id, &quot;type&quot;: &quot;text&quot;]
    return Network
        .request(&quot;/apiapi~~~mightbe important1&quot;, parameters: params)
        .expectType(EssayModel.self)
}

private func  requestTagData(_ question_id: Int) -&gt; Observable&lt;TagData&gt; {
    let params: [String: Any] = [&quot;company_id&quot;: companyID, &quot;question_id&quot;: question_id]
    return Network
        .request(&quot;/apiapi~~~mightbe important2&quot;, parameters: params)
        .expectType(TagData.self)
}
</code></pre>
","7356622","","7356622","","2021-07-26 06:24:59","2021-07-26 12:38:50","Rxswift Async api in switch array","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"68561602","1","68562355","","2021-07-28 13:45:53","","1","30","<p>Im new to RxSwift and what Im trying is perform the following,</p>
<ul>
<li>User type is search UiTextField</li>
<li>App must wait 1 sec after user finish typing to make sure not to hit the Api with each letter write or delete button pressed.</li>
<li>App hit my Api for search</li>
</ul>
<p>I tried the below code as example</p>
<pre><code>class DestinationSearch: UIViewController {
    

    let searchTF = UITextField()    
    var disposeBag = DisposeBag()


    override func viewDidLoad() {
        super.viewDidLoad()

        setUpUI()
        
        
        searchTF.rx.controlEvent(.editingChanged)
            .throttle(.milliseconds(1000), scheduler: MainScheduler.instance)
            .withLatestFrom(searchTF.rx.text)
        .subscribe(onNext:{ query in
            print(self.hitSomeApi(query: query ?? &quot;--&quot;))
        }).disposed(by: disposeBag)

    }

func hitSomeApi(query: String) -&gt; String {
        return query + &quot; Response from API&quot;
    }
</code></pre>
<p>When I run the app and start typing I get the the <strong>Response from API</strong> message with each letter or backspace button pressed! why the <code>throttle</code> delay is not working? Im I doing something wrong here?</p>
<p>Any help will be much appreciated</p>
","6452240","","","","","2021-07-28 14:33:42","RxSwift With UiTextField","<swift><rx-swift>","1","2","","","","CC BY-SA 4.0"
"68591539","1","","","2021-07-30 13:12:49","","1","48","<p>I'm pretty new in RX, so i'm kind confused how to do it correctly.</p>
<p>My view model:</p>
<pre><code>let feedItems: BehaviorSubject&lt;[FeedItem]&gt; = BehaviorSubject(value: [FeedItem]())
let isLoadingMore: PublishSubject&lt;Bool&gt; = PublishSubject()
let loadPageTrigger: PublishSubject&lt;Void&gt; = PublishSubject()
let isRefreshing: PublishSubject&lt;Bool&gt; = PublishSubject()

func fetchFeed(showLoading: Bool = false, loadMore: Bool = false) {

  //api call and set self.feedItems.onNext(response) after completion

}
</code></pre>
<p>In my VC i bind feedItems to collectionView, check when collectionView in bottom and bind it to isLoadingMore, and also bind UIRefresherControl to isRefreshing.</p>
<p>In my ViewModel i want to get value of isRefreshing and isLoadingMore in loadPageTrigger and call fetchFeed with some parameters:</p>
<p>ViewModel:</p>
<pre><code>override init() {
    super.init()
    loadPageTrigger.subscribe(onNext:  {
        // need to get values of isRefreshing and isLoadingMore to call fetchFeed with params
        self.fetchFeed()
    }).disposed(by: disposeBag)
}
</code></pre>
","3296088","","","","","2021-07-30 23:46:55","RXSwift combine two observables and call to API","<mvvm><rx-swift>","1","0","","","","CC BY-SA 4.0"
"68600695","1","68603088","","2021-07-31 09:08:07","","1","38","<p>Here is my view model:</p>
<pre><code>    let loadMoreTrigger = PublishSubject&lt;Void&gt;()
    let refreshTrigger = PublishSubject&lt;Void&gt;()
    let loading = BehaviorRelay&lt;Bool&gt;(value: false)
    let stories = BehaviorRelay&lt;[Story]&gt;(value: [])
    var offset = 0
    let error = PublishSubject&lt;String&gt;()
    let selectedFeedType: BehaviorRelay&lt;FeedType&gt; = BehaviorRelay(value: .best)

   override init() {
    super.init()
    let refreshRequest = loading.asObservable().sample(refreshTrigger).flatMap { loading -&gt; Observable&lt;[Story]&gt; in
        if loading {
            return Observable.empty()
        } else {
            self.offset = 0
            return self.fetchStories(type: self.selectedFeedType.value, offset: self.offset)
        }
    }
    let loadMoreRequest = loading.asObservable().sample(loadMoreTrigger).flatMap { loading -&gt; Observable&lt;[Story]&gt; in
        if loading {
            return Observable.empty()
        } else {
            self.offset += 10
            return self.fetchStories(type: self.selectedFeedType.value, offset: self.offset)
        }
    }
    let request = Observable.merge(refreshRequest, loadMoreRequest).share(replay: 1)
    
    let response = request.flatMap { (stories) -&gt; Observable&lt;[Story]&gt; in
        request.do(onError: { error in
            self.error.onNext(error.localizedDescription)
        }).catchError { (error) -&gt; Observable&lt;[Story]&gt; in
            Observable.empty()
        }
    }.share(replay: 1)
    
    Observable.combineLatest(request, response, stories.asObservable()) { request, response, stories in
        return self.offset == 0 ? response : stories + response
    }.sample(response).bind(to: stories).disposed(by: disposeBag)
    
    Observable.merge(request.map{_ in true}, response.map{_ in false}, error.map{_ in false}).bind(to: loading).disposed(by: disposeBag)
}
</code></pre>
<p>Then when i checking loading observer i have false -&gt; true, instead of true -&gt; false. I just don't understand why it happening.</p>
<pre><code>    loading.subscribe {
        print($0)
    }.disposed(by: disposeBag)
</code></pre>
<p>In my viewController i call refreshTrigger on viewWillAppear using rx.sentMessage</p>
<p>Here is getFeed function:</p>
<pre><code>func getFeed(type: FeedType, offset: Int) -&gt; Observable&lt;[Story]&gt; {
    return provider.rx.request(.getFeed(type: type, offset: offset)).asObservable().flatMap { (response) -&gt; Observable&lt;[Story]&gt; in
        do {
            let feedResponse = try self.jsonDecoder.decode(BaseAPIResponse&lt;[Story]&gt;.self, from: response.data)
            guard let stories = feedResponse.data else { return .error(APIError.requestFailed)}
            return .just(stories)
        } catch {
            return .error(error)
        }
    }.catchError { (error) -&gt; Observable&lt;[Story]&gt; in
        return .error(error)
    }
}
</code></pre>
","3296088","","3296088","","2021-07-31 14:14:44","2021-07-31 14:38:56","RXSwift why loading variable return wrong value?","<rx-swift>","1","3","","","","CC BY-SA 4.0"
"68613039","1","68614052","","2021-08-01 17:54:34","","3","51","<p>I have table view that contains list of books I tried to make searchBar and search by book name</p>
<p><a href=""https://i.stack.imgur.com/gJdJN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gJdJN.png"" alt=""enter image description here"" /></a>
<a href=""https://i.stack.imgur.com/kzguh.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kzguh.png"" alt=""enter image description here"" /></a></p>
<blockquote>
<p>this is HomeViewModel</p>
</blockquote>
<pre><code>private var homeModelSubject      = PublishSubject&lt;[Book]&gt;()
private var filterModelSubject    = PublishSubject&lt;[Book]&gt;()
private var isTableHidden         = BehaviorRelay&lt;Bool&gt;(value: false)
var searchValueBehavior           = BehaviorRelay&lt;String&gt;(value: &quot;&quot;)

var homeModelObservable: Observable&lt;[Book]&gt; {
    return homeModelSubject
}

var filterModelObservable: Observable&lt;[Book]&gt; {
    return filterModelSubject
}

var isTableHiddenObservable:Observable&lt;Bool&gt; {
    return isTableHidden.asObservable()
}

var serchValueObservable: Observable&lt;String&gt; {
    return searchValueBehavior.asObservable()
}

init() {
    serchValueObservable.subscribe(onNext: { value in
        self.homeModelObservable.map({ $0.filter ({
            if value.isEmpty {return true}
            return ($0.name.lowercased().contains(value.lowercased()))
        })
        }).bind(to: self.filterModelSubject).disposed(by: self.disposeBag)
    }).disposed(by: disposeBag)
}
</code></pre>
<blockquote>
<p>this function to make bind to text value</p>
</blockquote>
<pre><code>func bindToSearchValue() {
    searchController.searchBar.rx.text.orEmpty.throttle(.milliseconds(500), scheduler: MainScheduler.instance).distinctUntilChanged()
        .bind(to: homeViewModel.searchValueBehavior).disposed(by: disposeBage)
}
</code></pre>
<blockquote>
<p>this function to subscribe to response</p>
</blockquote>
<pre><code>func subscribeToResponse() {
    homeViewModel.filterModelObservable.bind(to: self.tableView.rx.items(cellIdentifier: HomeTableViewCell.reuseIdentifier, cellType: HomeTableViewCell.self)) { row,books,cell in
        cell.separatorInset = UIEdgeInsets(top: 0, left: 0, bottom: 20, right: UIScreen.main.bounds.width)
        cell.titleLabel.text           = books.name
        cell.secondaryTitleLabel.text  = books.type
        cell.selectionStyle            = .none
        
        if books.available == true {
            cell.avalibaleOrNotLabel.text = &quot;Avalibale&quot;
            cell.avalibaleOrNotStatus.backgroundColor = .green
        } else {
            cell.avalibaleOrNotLabel.text = &quot;Not Avalibale&quot;
            cell.avalibaleOrNotStatus.backgroundColor = .gray
        }
        
    }.disposed(by: disposeBage)
}
</code></pre>
<p>the problem ----&gt; when make search did not filter the cell</p>
","12468380","","12468380","","2021-08-03 16:12:49","2021-08-04 01:15:25","want to make search filter using RxSwift in iOS","<ios><rx-swift>","1","2","","","","CC BY-SA 4.0"
"68630223","1","68630633","","2021-08-03 04:02:27","","0","33","<p>I am making two ways binding for UITextField extension. It works well with string. But why not Int?
This is my extension:</p>
<pre><code>import Foundation
import RxCocoa
import RxSwift

extension UITextField {
    func bind(with property: BehaviorRelay&lt;String?&gt;, bag: DisposeBag = DisposeBag()) {
        property.bind(to: self.rx.text).disposed(by: bag)
        self.rx.text.bind(to: property).disposed(by: bag)
    }

    func bind(with property: BehaviorRelay&lt;Int?&gt;, bag: DisposeBag = DisposeBag()) {
        property.map { intValue in
            return Int.toString(intValue) //convert from Int to String
        }.bind(to: self.rx.text).disposed(by: bag)
        self.rx.text.orEmpty.map { text in
            return String.toInt(text) ?? 0 //convert from String to Int
        }.bind(to: property).disposed(by: bag)
    }
}
</code></pre>
<p>In my viewModel:</p>
<pre><code>let fullName = BehaviorRelay&lt;String?&gt;(value: nil)
let phone = BehaviorRelay&lt;Int?&gt;(value: nil)
</code></pre>
<p>Usage:</p>
<pre><code>textField1.bind(with: viewModel.fullName) //working well
textField2.bind(with: viewModel.phone) //only from viewModel to textField
</code></pre>
<p>But when I use directly it working like this:</p>
<pre><code>textField2.rx.text.map { text in
    return String.toInt(text) ?? 0
}.bind(to: viewModel.phone).disposed(by: bag)
</code></pre>
<p>Am I missing something?
Any answer are appeciated. Thanks.</p>
","14008786","","14008786","","2021-08-03 04:32:08","2021-08-03 05:50:20","Two ways binding textfiled in RxSwift in different type","<swift><binding><reactive-programming><rx-swift><rx-cocoa>","1","3","","","","CC BY-SA 4.0"
"68637711","1","","","2021-08-03 14:16:05","","0","33","<p>when I call getBooks() to init in HomeViewModel make this error ===&gt; 'self' used in method call 'getBooks' before all stored properties are initialized</p>
<blockquote>
<p>this is init</p>
</blockquote>
<pre><code>init() {
    
    getBooks()
    filterModelObservable = searchValueBehavior
        .map { $0 }
        .throttle(.milliseconds(500), scheduler: MainScheduler.instance)
        .distinctUntilChanged()
        .withLatestFrom(homeModelSubject) { searchValue, books in
            searchValue.isEmpty ? books : books.filter { $0.name.lowercased().contains(searchValue.lowercased()) }
        }
}
</code></pre>
<blockquote>
<p>this is getBooks() function</p>
</blockquote>
<pre><code>func getBooks() {
    loadingBehavior.accept(true)
    let url = &quot;https://simple-books-api.glitch.me/books&quot;
    APIServices.instance.getData(url: url, method: .get, params: nil, encoding: JSONEncoding.default, headers: nil) {[weak self] (bookModel: [Book]?, baseError: HomeBaseError?, error) in
        guard let self = self else { return }
        self.loadingBehavior.accept(false)
        if let error = error {
            //handler(false, &quot;Error message\(error.localizedDescription.description)&quot;)
            print(&quot;this is error discription\(error.localizedDescription)&quot;)
        } else if let baseError = baseError {
            //handler(false,baseError.error)
            print(baseError.error)
        } else {
            guard let bookModel = bookModel else { return }
            //handler(true, &quot;Success&quot;)
            if bookModel.count  &gt; 0 {
                self.homeModelSubject.onNext(bookModel)
                self.isTableHidden.accept(false)
            } else {
                self.isTableHidden.accept(true)
            }
        }
    }
    
}
</code></pre>
","12468380","","","","","2021-08-04 01:13:02","'self' used in method call 'getBooks' before all stored properties are initialized","<ios><rx-swift>","1","1","","","","CC BY-SA 4.0"
"68649382","1","68651008","","2021-08-04 10:10:49","","1","17","<p>Here is my code below. I need to call api multiple times until internet signal is on.</p>
<pre><code> buttonAction.do(onNext: { [weak self] in
                        
                          self?.activity.startAnimating()
                        
                              apiManager.callApi()
                            
                                .do(onNext: { [weak self] in
                                    
                                    self?.activity.stopAnimating()
                                    
                                },onError: { [weak self ] error in
                                    
                                    if let error = error as? NoNetwork {
                                        self?.activity.stopAnimating(errorInfo:error,presentationStyle:.alert)

                                        // here alert will be appear. On click ok button, need to trigger the API() again
                                    }
                                })
                .subscribe().disposed(by:bag)
</code></pre>
","6767616","","","","","2021-08-04 12:09:00","trigger an api again once network goes off in RxSwift","<rx-swift><uiactivityindicatorview><reachability>","1","0","","","","CC BY-SA 4.0"
"68689471","1","","","2021-08-07 04:43:28","","1","32","<p>I am a newbie to RxSwift. I ran into a problem</p>
<p>The requirement is like this,</p>
<blockquote>
<ol>
<li>If there are values return from stream A, B and C then I emit an event on stream X (boolean)</li>
<li>Whenever there is true value returns from streamX, I want to take a take a snapshot of stream A, B and C and do something</li>
<li>Due to class design reason, we need to separate the action 1 and 2 into two Rx blocks</li>
</ol>
</blockquote>
<p>below is the simplified version of my code</p>
<pre><code>class parent {
    let streamA: BehaviorRelay&lt;String?&gt; = BehaviorRelay(value: nil)
    let streamB: BehaviorRelay&lt;String?&gt; = BehaviorRelay(value: nil)
    let streamC: BehaviorRelay&lt;String?&gt; = BehaviorRelay(value: nil)
    let moduleVisibility: BehaviorRelay&lt;Bool?&gt; = BehaviorRelay(value: nil)

    BehaviorRelay.combineLatest(streamA.filterNil(), streamB.filterNil(), streamB.filterNil()).subscribe { [weak self ] _, _, _ in
            guard let self = self else { return }
            self.moduleVisibility.accept(true)
        }.disposed(by: bag)
}

class childClass {
   moduleVisibility.filterNil().filter({ $0 == true}).withLatestFrom(Observable.combineLatest(streamA.filterNil(), streamB.filterNil(), streamC.filterNil())).observeOn(MainScheduler.instance).subscribe(onNext: { valueA, valueB, valueC in
            // This line does not get called
            print(&quot;\(valueA) \(valueB) \(valueC)&quot;)
        }).disposed(by: bag)
}

// then I called
streamA.accept(&quot;A&quot;)
streamB.accept(&quot;B&quot;)
streamC.accept(&quot;C&quot;)
// but the block @ childClass does not get fired
</code></pre>
<p>I check there is event from the <code>moduleVisibility</code> stream. but it says that there is not value from <code>withLatestFrom</code> block.</p>
<p>Would like to know if my block setup is not correct.
Cause I think <code>A</code> <code>B</code> <code>C</code> are causing the event of <code>X</code>
while there is event from <code>X</code>, there must be values from <code>A</code> <code>B</code> <code>C</code></p>
<p>or I need to observe on main.thread? any help will be appreciated :pray</p>
","1005570","","","","","2021-08-07 11:57:49","Problem about the usage of `withLatestFrom`","<rx-swift>","2","0","","","","CC BY-SA 4.0"
"68711268","1","68711439","","2021-08-09 11:24:55","","0","25","<p>I have this function</p>
<pre><code>    func authorizeUser(user: User) -&gt; Completable {
    let client = Client(name: user.username!, allowedGrantTypes: [&quot;password&quot;, &quot;refresh_token&quot;])
    return self.userGateway.postClient(client: client)
        .flatMap { [weak self] authorizedClient in
             (self?.userGateway.getToken(authModel: AuthModel(
                                            clientId: &quot;\(authorizedClient.id!)_\(authorizedClient.randomId!)&quot;,
                                            grantType: &quot;password&quot;,
                                            username: user.username!,
                                            password: user.password!,
                                            clientSecret: authorizedClient.secret!)))!
        }.flatMap { token in
            self.settings.token = token
            return self.userGateway.getCurrentUser(token: token)
        }.map { user in
            self.settings.account = user
        }.asCompletable()
}
</code></pre>
<p>And it works fine. But when I'm trying to make AuthModel as variable and put it as function parameter I'm getting error &quot;Unable to infer type of a closure parameter 'token' in the current context&quot;.What am I doing wrong? My function with error looks like below</p>
<pre><code>    func authroizeUser(user: User) -&gt; Completable {
    let client = Client(name: user.username!, allowedGrantTypes: [&quot;password&quot;, &quot;refresh_token&quot;])
    return self.userGateway.postClient(client: client)
        .flatMap { [weak self] authorizedClient in
            let authModel = AuthModel(
                clientId: &quot;\(authorizedClient.id!)_\(authorizedClient.randomId!)&quot;,
                grantType: &quot;password&quot;,
                username: user.username!,
                password: user.password!,
                clientSecret: authorizedClient.secret!)
            return (self.userGateway.getToken(authModel: authModel))!
        }.flatMap { token in
            self.settings.token = token
            return self.userGateway.getCurrentUser(token: token)
        }.map { user in
            self.settings.account = user
        }.asCompletable()
}
</code></pre>
","12887812","","","","","2021-08-09 11:39:02","Unable to infer type of a closure parameter in the current context RxSwift","<swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"68714275","1","68717811","","2021-08-09 14:59:37","","1","20","<p>The question is pretty straight forward:</p>
<p>I have the following extension to subscribe to the <code>alpha</code> and <code>hidden</code> properties of an UIView using RxSwift. But this errors with an <code>invalidPropertyName</code> error.</p>
<p>Just simply replacing <code>observeWeakly</code> with <code>observe</code> fixes the error but I would rather not do this to prevent possible retention cycles.
The very same code does work for properties like the frame and bounds, and as far as I am aware, at least <code>hidden</code> is a KVO-compliant property.</p>
<p>Is this a known issue or is there any other way to observe these properties while targeting iOS 12.0?</p>
<p>The code in question:</p>
<pre><code>extension Reactive where Base: UIView {
    
    
    var observeAlpha: Observable&lt;CGFloat?&gt; {
        get {
            return observeWeakly(CGFloat.self, &quot;alpha&quot;)
                .do(
                    onError: {
                        print($0)
                    }
                )
                .catchErrorJustReturn(1.0)
                .startWith(base.alpha)
        }
    }

    
    var observeIsHidden: Observable&lt;Bool?&gt; {
        get {
            return observeWeakly(Bool.self, &quot;hidden&quot;)
                .do(
                    onError: {
                        print($0)
                    }
                )
                .catchErrorJustReturn(false)
                .startWith(base.isHidden)
        }
    }
}
</code></pre>
<p>The two errors:</p>
<pre><code>Object `&lt;UIView: 0x7f9a4654a170; frame = (0 0; 375 812); autoresize = W+H; layer = &lt;CALayer: 0x600002464940&gt;&gt;` doesn't have a property named `alpha`.
</code></pre>
<pre><code>Object `&lt;UITransitionView: 0x7f9a4654a170; frame = (0 0; 375 812); autoresize = W+H; layer = &lt;CALayer: 0x600002464940&gt;&gt;` doesn't have a property named `hidden`.
</code></pre>
","4621265","","","","","2021-08-09 19:50:31","RxSwift `observeWeakly` on certain UIView properties fails while `observe` does work","<ios><swift><uikit><rx-swift>","1","0","","","","CC BY-SA 4.0"
"68734825","1","68742013","","2021-08-11 00:49:15","","0","29","<p>I'm new in the RxSwift development and I've an issue while presentation a view controller.</p>
<p>My MainViewController is just a table view and I would like to present detail when I tap on a item of the list.</p>
<p>My DetailViewController is modally presented and needs a ViewModel as input parameter.</p>
<p>I would like to avoid to dismiss the DetailViewController, I think that the responsability of dismiss belongs to the one who presented the view controller, i.e the dismiss should happen in the MainViewController.</p>
<p>Here is my current code</p>
<p>DetailsViewController</p>
<pre><code>class DetailsViewController: UIViewController {

  @IBOutlet weak private var doneButton: Button!
  @IBOutlet weak private var label: Label!

  let viewModel: DetailsViewModel

  private let bag = DisposeBag()

  var onComplete: Driver&lt;Void&gt; {
    doneButton.rx.tap.take(1).asDriver(onErrorJustReturn: ())
  }

  override func viewDidLoad() {
    super.viewDidLoad()
    setup()
    bind()
  }

  private func bind() {
    let ouput = viewModel.bind()

    ouput.id.drive(idLabel.rx.text)
      .disposed(by: bag)
  }

}
</code></pre>
<p>DetailsViewModel</p>
<pre><code>class DetailsViewModel {

  struct Output {
    let id: Driver&lt;String&gt;
  }

  let item: Observable&lt;Item&gt;

  init(with vehicle: Observable&lt;Item&gt;) {
    self.item = item
  }

  func bind() -&gt; Output {
    let id = item
      .map { $0.id }
      .asDriver(onErrorJustReturn: &quot;Unknown&quot;)

    return Output(id: id)
  }

}
</code></pre>
<p>MainViewController</p>
<pre><code>class MainViewController: UIViewController {

  @IBOutlet weak private var tableView: TableView!

  private var bag = DisposeBag()

  private let viewModel: MainViewModel

  private var detailsViewController: DetailsViewController?


  override func viewDidLoad(_ animated: Bool) {
    super.viewDidLoad(animated)
    bind()
  }

  private func bind() {
    let input = MainViewModel.Input(
      selectedItem: tableView.rx.modelSelected(Item.self).asObservable()
    )
    let output = viewModel.bind(input: input)
    showItem(output.selectedItem)
  }


  private func showItem(_ item: Observable&lt;Item&gt;) {
    let viewModel = DetailsViewModel(with: vehicle)
    detailsViewController = DetailsController(with: viewModel)

    item.flatMapFirst { [weak self] item -&gt; Observable&lt;Void&gt; in
      guard let self = self,
            let detailsViewController = self.detailsViewController else {
        return Observable&lt;Void&gt;.never()
      }
      self.present(detailsViewController, animated: true)
      return detailsViewController.onComplete.asObservable()
    }
    .subscribe(onNext: { [weak self] in
      self?.detailsViewController?.dismiss(animated: true)
      self?.detailsViewController? = nil
    })
    .disposed(by: bag)
  }

}
</code></pre>
<p>MainViewModel</p>
<pre><code>class MainViewModel {

  struct Input {
    let selectedItem: Observable&lt;Item&gt;
  }

  struct Output {
    let selectedItem: Observable&lt;Item&gt;
  }

  func bind(input: Input) -&gt; Output {
    let selectedItem = input.selectedItem
      .throttle(.milliseconds(500),
                latest: false,
                scheduler: MainScheduler.instance)
      .asObservable()

    return Output(selectedItem: selectedItem)
  }

}
</code></pre>
<p>My issue is on <code>showItem</code> of MainViewController.
I still to think that having the DetailsViewController input as an Observable isn't working but from what I understand from Rx, we should use Observable as much as possible.</p>
<p>Having <code>Item</code> instead of <code>Observable&lt;Item&gt;</code> as input could let me use this kind of code:</p>
<pre><code>item.flatMapFirst { item -&gt; Observable&lt;Void&gt; in
      guard let self = self else {
        return Observable&lt;Void&gt;.never()
      }
      let viewModel = DetailsViewModel(with: item)
      self.detailsViewController = DetailsViewController(with: viewModel)
      guard let detailsViewController = self.detailsViewController else {
        return Observable&lt;Void&gt;.never()
      }
      present(detailsViewController, animated: true)
      return detailsViewController
    }
    .subscribe(onNext: { [weak self] in
      self?.detailsViewController?.dismiss(animated: true)
      self?.detailsViewController = nil
    })
    .disposed(by: bag)
</code></pre>
<p>What is the right way to do this?</p>
<p>Thanks</p>
","2448287","","259769","","2021-08-16 14:19:04","2021-08-16 14:19:04","How to pass chain view controller presenter with observable","<swift><rx-swift>","1","1","","","","CC BY-SA 4.0"
"68760301","1","68765125","","2021-08-12 15:29:51","","1","39","<p>I am fairly new to IOS development and working on a small project, I am trying to subscribe to UITextView using Rxswift. However, I can't seem to find any way to do so online or by following what I did to UITextField.</p>
<p>this is what I Done and its working for TextField:</p>
<pre><code>TextField.rx.controlEvent(.editingChanged).withLatestFrom(textField.rx.text.orEmpty)subscribe(onNext : { text in
        self.viewModel.address.accept(text)
Some code goes here
</code></pre>
<p>Now doing the same thing for a textView</p>
<pre><code>TextView.rx.controlEvent(.editingChanged).withLatestFrom(TextView.rx.text.orEmpty)subscribe(onNext : { text in
    self.viewModel.address.accept(text)
</code></pre>
<p>I get the following error:
Referencing instance method 'controlEvent' on 'Reactive' requires that 'UITextView' inherit from 'UIControl'</p>
<p>I am really confused on how to make controlEvent work with UITextField. it doesn't show in the suggested code when I use rx.</p>
","12401635","","","","","2021-08-13 11:05:19","how to subscribe to a UITextView in iOS swift?","<ios><swift><uitextview><rx-swift><uitextviewdelegate>","1","0","","","","CC BY-SA 4.0"
"68791357","1","","","2021-08-15 12:04:39","","1","22","<p>In my main VC i bind data like this:</p>
<pre><code>    let outputs = viewModel.transform(input: inputs)
    outputs.posts.drive(view.collectionView.rx.items(cellIdentifier: &quot;postsPagingCollectionViewCell&quot;, cellType: PostsPagingCollectionViewCell.self)) { row, post, cell in
        cell.post = post
    }.disposed(by: disposeBag)
</code></pre>
<p>Cell:</p>
<pre><code>var post: Post! {
    didSet {
        bindViewModel()
    }
}

override func bindViewModel() {
    guard let viewModel = cellViewModel as? PostsPagingCellViewModel, let cellView = cellView as? PostsPagingCellView else { return }
    let _post = BehaviorRelay&lt;Post&gt;(value: post)
    let outputs = viewModel.transform(input: .init(post: _post.asObservable()))
    outputs.fullName.drive(cellView.fullNameLabel.rx.text).disposed(by: disposeBag)
    outputs.nickname.drive(cellView.nickNameLabel.rx.text).disposed(by: disposeBag)
    //etc
}
</code></pre>
<p>In my cell i have user profile image, and on tap i want to push specific VC. Also, there could be many buttons and i guess i should handle it in mainVC/mainViewModel. How can i do this?</p>
","3296088","","","","","2021-08-16 19:54:50","RxSwift handle cell actions","<mvvm><rx-swift>","1","2","","","","CC BY-SA 4.0"
"68872523","1","68873186","","2021-08-21 11:16:53","","1","62","<p>RxFSCalendarDelegateProxy.swift</p>
<pre><code>import Foundation
import RxSwift
import RxCocoa
import FSCalendar

class RxFSCalendarDelegateProxy: DelegateProxy&lt;FSCalendar, FSCalendarDelegate&gt;, DelegateProxyType, FSCalendarDelegate {
    static func registerKnownImplementations() {
        self.register { (calendar) -&gt; RxFSCalendarDelegateProxy in
            RxFSCalendarDelegateProxy(parentObject: calendar, delegateProxy: self)
        }
    }
    
    static func currentDelegate(for object: FSCalendar) -&gt; FSCalendarDelegate? {
        return object.delegate
    }
    
    static func setCurrentDelegate(_ delegate: FSCalendarDelegate?, to object: FSCalendar) {
        object.delegate = delegate
    }
}

extension Reactive where Base: FSCalendar {
    var delegate : DelegateProxy&lt;FSCalendar, FSCalendarDelegate&gt; {
        return RxFSCalendarDelegateProxy.proxy(for: self.base)
    }
    
    var didSelect : Observable&lt;Date&gt; {
        return delegate.methodInvoked(#selector(FSCalendarDelegate.calendar(_:didSelect:at:)))
            .map({ (params) in
                return params[1] as? Date ?? Date()
            })
    }
}
</code></pre>
<p>MainViewController.swift</p>
<pre><code>import UIKit
import ReactorKit
import FSCalendar

class MainViewController: BaseViewController, View {
    
    typealias Reactor = MainViewReactor
    
    let calendar = FSCalendar()
    let label = UILabel()
    
    init(reactor: Reactor) {
        super.init()
        defer { self.reactor = reactor }
    }
    
    required init?(coder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
    }
    
    override func setupLayout() {
        self.view.addSubview(calendar)
    }
    
    override func makeConstraints() {
        
        self.calendar.snp.makeConstraints {
            $0.bottom.equalToSuperview()
            $0.top.equalToSuperview()
            $0.left.equalToSuperview()
            $0.right.equalToSuperview()
        }
    }
    
    func bind(reactor: MainViewReactor) {
        // MARK: input
        calendar.rx.didSelect.asObservable()
            .map { Reactor.Action.setDay($0) }
            .bind(to: reactor.action)
            .disposed(by: disposeBag)
        // MARK: output
    }

}
</code></pre>
<p>I am trying to change FSCalendarDelegate func to Observable to use ReactorKit.
But When I run this code, error occurred
&quot;RxCocoa/DelegateProxy.swift:230: Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value&quot;
I don't know how to fix my DelegateProxy. why aSelector is nil?</p>
<p><a href=""https://i.stack.imgur.com/0zkGd.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0zkGd.jpg"" alt=""enter image description here"" /></a></p>
","16420419","","","","","2021-08-21 14:31:27","error occurred when I using RxSwift's DelegateProxy with FSCalendar","<swift><delegates><rx-swift><fscalendar>","1","0","","","","CC BY-SA 4.0"
"68908887","1","68922395","","2021-08-24 14:14:23","","1","38","<p>I’m learning RxSwift and I’d could really use some help here. Basically I want to achieve 4 things:</p>
<ol>
<li>Call login request</li>
<li>Save access and refresh tokens</li>
<li>Get the user and save him to the database</li>
<li>And after all of this is done I want the function to return void (afterwards my app goes to the home screen)</li>
</ol>
<p>This is what I have now:</p>
<pre><code>func login(email: String, password: String) -&gt; Single&lt;Void&gt; {
    return request(type: Auth.self, endpoint: ApiAuthRouter.login(email: email, password: password))
        .do(onSuccess: { [unowned self] auth in
            self.apiService.authenticationManager.setAuthTokens(auth: auth)
            self.getUser()
        }
        .asVoid
}

private func getUser() {
    request(type: UserNew.self, endpoint: ApiUserRouter.me)
        .subscribe(onSuccess: { user in
            self.realmManager.writeSync({ realm in
                realm.add(user, update: .modified)
            })
            self.apiService.authenticationManager.setUser(user: user)
        }.disposed(by: disposeBag)
}
</code></pre>
<p>It does work somewhat, but when I get to the home screen I still don’t have my user, he is fetched in the background. How to chain these requests effectively?</p>
","4942539","","","","","2021-08-25 11:49:58","Chaining login and getUser requests in RxSwift","<swift><rx-swift>","2","4","","","","CC BY-SA 4.0"
"68917635","1","","","2021-08-25 06:07:22","","1","33","<p>I am trying to create a login page using in <code>MVVM</code> using <code>RxSwift + AppCoordinator</code>.</p>
<p>What I am trying to achieve is:</p>
<ol>
<li>Api request to login</li>
<li>Validate the Login Credentials: If <code>success</code> -&gt; Success Alert, If <code>error</code> -&gt; ErrorAlert</li>
</ol>
<p>However, using the <code>AppCoordinator</code> and <code>MVVM</code> together, the <code>subscriber</code> and <code>observer</code> seems to be NOT working, because:</p>
<ul>
<li>on <code>success</code> response from the API, Success Alert is not displayed.</li>
<li>on <code>error</code> response from the API, Error Alert is not displayed.</li>
</ul>
<p>I have tried debugging, but since I am quite new to <code>RxSwift</code>, I could not figure this out, and I do not know where I am going wrong, however, to me, the flow and logic in my code seems to be correct.</p>
<p>can anyone help/guide me with a better approach or help spot any errors in my code?</p>
<p>thanks in advance.</p>
<p>here is what i have:</p>
<ol>
<li>AppDelegate.swift</li>
</ol>
<pre><code>import UIKit

@main
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?
    private var appCoordinator = AppCoordinator()

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
                
        appCoordinator.start()
        return true
    }
}
</code></pre>
<ol start=""2"">
<li>AppCoordinator.swift</li>
</ol>
<pre><code>import Foundation
import RxCocoa
import RxSwift
import Swinject


class AppCoordinator: BaseCoordinator {
    let sessionService = SessionService()
    var window = UIWindow(frame: UIScreen.main.bounds)
    
    override func start() {
        navigationController.navigationBar.isHidden = true
        window.rootViewController = navigationController
        window.makeKeyAndVisible()
        
        // TODO: here you could check if user is signed in and show appropriate screen
        let coordinator = LogInCoordinator()
        coordinator.navigationController = navigationController
        start(coordinator: coordinator)
    }
}

protocol LogInListener {
    func didLogIn()
}

extension AppCoordinator: LogInListener {
    func didLogIn() {
            print(&quot;Logged In&quot;)
            // TODO: Navigate to Dashboard or any other flow
           // However, this lines of code is NOT being called at all, and I do not see 
          // the print statement either. I dont know why.?
    }
}
</code></pre>
<ol start=""3"">
<li>BaseCoordinator.swift</li>
</ol>
<pre><code>import Foundation
import UIKit

protocol Coordinator: AnyObject {
    var navigationController: UINavigationController { get set }
    var parentCoordinator: Coordinator? { get set }
    
    func start()
    func start(coordinator: Coordinator)
    func didFinish(coordinator: Coordinator)
}
 
class BaseCoordinator: Coordinator {
    var childCoordinators: [Coordinator] = []
    var parentCoordinator: Coordinator?
    var navigationController = UINavigationController()
    
    func start() {
        fatalError(&quot;Start method must be implemented&quot;)
    }
    
    func start(coordinator: Coordinator) {
        childCoordinators.append(coordinator)
        coordinator.parentCoordinator = self
        coordinator.start()
    }
    
    func didFinish(coordinator: Coordinator) {
        if let index = childCoordinators.firstIndex(where: { $0 === coordinator }) {
            childCoordinators.remove(at: index)
        }
    }
}
</code></pre>
<ol start=""4"">
<li>SessionService.swift</li>
</ol>
<pre><code>import Foundation
import RxSwift
import RxCocoa
import SwiftyJSON
import Alamofire

protocol Authentication {
    func login(username: String, password: String) -&gt; Single&lt;AuthResponse&gt;
}
// MARK: - SessionService
class SessionService: Authentication {
    
    func login(username: String, password: String) -&gt; Single&lt;AuthResponse&gt; {
        let formHeader: HTTPHeaders? = [
            &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;
        ]
        let parameters: Parameters = [
            &quot;username&quot;: username,
            &quot;password&quot;: password
        ]
        let decoder = JSONDecoder()
        return Single&lt;AuthResponse&gt;.create { single in
            AF.request(API.auth, method: .get, parameters: parameters, headers: formHeader).responseDecodable(of: AuthResponse.self, decoder: decoder, completionHandler: { _ in
                // it returns either error or success, I got Success.
                single(.success(AuthResponse()))
            })
            return Disposables.create()
        }
    }
}

</code></pre>
<p><code>And, the Below is the LogIn Part</code></p>
<ol>
<li>LogInCoordinator.swift</li>
</ol>
<pre><code>import Foundation
import RxSwift
import RxCocoa


class LogInCoordinator: BaseCoordinator {
    private let disposeBag = DisposeBag()
    
    override func start() {
        let vc = LoginViewController.instantiate()
        
        // Coordinator initializes and injects viewModel
        let logInViewModel = LogInViewModel(authentication: SessionService())
        vc.viewModel = logInViewModel
        
        // Coordinator subscribes to events and notifies parentCoordinator
        logInViewModel.didLogIn
            .subscribe(onNext: { [weak self] in
                guard let self = self else { return }
                self.navigationController.viewControllers = []
                self.parentCoordinator?.didFinish(coordinator: self)
                (self.parentCoordinator as? LogInListener)?.didLogIn()
            })
            .disposed(by: disposeBag)
        
        navigationController.viewControllers = [vc]
    }
}
</code></pre>
<ol start=""2"">
<li>LogInViewModel.swift</li>
</ol>
<pre><code>import Foundation
import RxSwift
import RxCocoa


class LogInViewModel {
    private let disposeBag = DisposeBag()
    private let authentication: Authentication
    
    var username: BehaviorRelay&lt;String&gt; = BehaviorRelay(value: &quot;&quot;)
    
    var password: BehaviorRelay&lt;String&gt; = BehaviorRelay(value: &quot;&quot;)
    let isLogInActive: Observable&lt;Bool&gt;
    
    // events
    let didLogIn = PublishSubject&lt;Void&gt;()
    let logInDidFail = PublishSubject&lt;Error&gt;()
    
    init(authentication: Authentication) {
        self.authentication = authentication
        self.isLogInActive = Observable.combineLatest(username, password).map { $0.0 != &quot;&quot; &amp;&amp; $0.1 != &quot;&quot; }
    }
    
    func onLoginClicked() {
        authentication.login(username: username.value, password: password.value).map { _ in }
            .observe(on: MainScheduler.instance)
            .subscribe(onSuccess: { [weak self] _ in   // not being called
                self?.didLogIn.onNext(())
            }, onFailure: { [weak self] error in      // not being called
                self?.logInDidFail.onNext(error)
            })
            .disposed(by: disposeBag)
    }
}
</code></pre>
<ol start=""3"">
<li>LoginViewController.swift</li>
</ol>
<pre><code>import UIKit
import RxSwift
import RxCocoa
import CocoaLumberjack


class LoginViewController: UIViewController, Storyboarded {
    @IBOutlet weak var emailTextField: UITextField!
    @IBOutlet weak var passwordTextField: UITextField!
    @IBOutlet weak var loginButton: UIButton!
    
    private let disposeBag = DisposeBag()
    var viewModel: LogInViewModel!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.emailTextField.placeholder = &quot;Email or Username&quot;
        self.passwordTextField.placeholder = &quot;Password&quot;
        self.passwordTextField.isSecureTextEntry = true
        
        viewModel = LogInViewModel(authentication: SessionService())
        self.setUpBindings()
        
    }
    private func setUpBindings() {
        guard let viewModel = viewModel else { return }
        
        emailTextField.rx.text.orEmpty
            .bind(to: viewModel.username)
            .disposed(by: disposeBag)
        
        passwordTextField.rx.text.orEmpty
            .bind(to: viewModel.password)
            .disposed(by: disposeBag)
        
        
        loginButton.rx.tap
            .bind { viewModel.onLoginClicked() }
            .disposed(by: disposeBag)
        
        viewModel.isLogInActive
            .bind(to: loginButton.rx.isEnabled)
            .disposed(by: disposeBag)
        
        viewModel.logInDidFail
            .subscribe(onNext: { error in
                print(&quot;Failed: \(error)&quot;) // not printing the line
            })
            .disposed(by: disposeBag)
    }
}
</code></pre>
","14472283","","","","","2021-08-27 12:29:46",".subscribe(onSuccess/onError) not being called","<ios><swift><mvvm><rx-swift><rx-cocoa>","1","3","","","","CC BY-SA 4.0"
"68954343","1","","","2021-08-27 13:34:02","","1","21","<p>I'm very new to RXSwift and looking to control my table view swipe action based on a value of an observable.</p>
<p>I have a variable - Observable&lt;[Product]&gt; and based on the if Product.isEnabled I want to show a &quot;Sold Out&quot; or &quot;In Stock&quot; swipe action. Here is the current code:</p>
<pre><code>func tableView(
    _ tableView: UITableView,
    trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath
) -&gt; UISwipeActionsConfiguration? {

    self.interactionService.prod
    let soldOutAction = UIContextualAction(
        style: .normal,
        title: &quot;Sold Out&quot;
    ) { [weak self] (_, _, completionHandler) in
        guard let self = self else { return }
        self.interactionService.products.map({
            $0[indexPath.row]
        })
        .take(1)
        .do(onNext: { [weak self] in
            guard let self = self else { return }
            self.analytics.userMarkedAsSoldOut(product: $0.productID)
        })
        .flatMapLatest({self.interactionService.disableProduct($0)})
        .subscribe(onCompleted: {
            completionHandler(true)
        })
        .disposed(by: self.disposeBag)
    }
    soldOutAction.backgroundColor = UIColor(red: 0.996,
                                            green: 0.09,
                                            blue: 0.478,
                                            alpha: 1)
    let config = UISwipeActionsConfiguration(actions: [soldOutAction])
    config.performsFirstActionWithFullSwipe = false
    return config
}
</code></pre>
<p>The above code works fine. But I need to update it so that if products[indexPath.row].isEnabled -&gt; use soldOutAction and if !isEnabled, use a newly created inStockAction.</p>
<p>As stated earlier, I'm very new to RXSwift so I don't know how to change the RXSwift syntax to use either soldOutAction or inStockAction. Any help on this matter would be greatly appreciated.</p>
","1014029","","","","","2021-08-28 03:59:06","RXSwift with UITableView - How to change swipe action based on observable","<swift><xcode><rx-swift>","1","0","","","","CC BY-SA 4.0"
"68998569","1","","","2021-08-31 12:20:10","","1","27","<p>Im new to RXSwift and in my app I use Google Places Service to get a Place coordinates and then I have to hit my API with get request to check if the fetched coordinate is within our operation areas how can I flat map the both requests ?</p>
<p>Here is My Code:</p>
<pre><code>func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
    progress.startAnimating()
    GMSPlacesClient.shared().lookUpPlaceID(placesArray[indexPath.row].placeID) { (place, error) in
        //check if place is within the bounds array
        if error == nil {
            if checkPlace(place: place!){
                // valid location
            }else{
                // un valid location
            }
            self.progress.stopAnimating()
        }
        
        print(place?.coordinate.latitude)
    }
}

}


func checkPlace(place : GMSPlace)-&gt;Bool{
    
    // Hit the api with get request
}
</code></pre>
<p>Any help will be much appreciated</p>
","6452240","","","","","2021-09-01 11:55:13","RXSwift Flat Map","<swift><rx-swift>","1","0","","","","CC BY-SA 4.0"
"69016371","1","69017122","","2021-09-01 15:07:34","","1","20","<p>I found a probable leak in my code because of a unit test which tests whether a dependency is called at <code>deinit</code>:</p>
<pre><code>func testDeinit_ShouldStopMinutesTicker() throws {
    let minutesTicker = MockMinutesTicker(elapsedTicksAfterStart: [(), (), ()])
    var viewModel: AppointmentViewModel? = createAppointmentViewModel(minutesTicker: minutesTicker)
    viewModel = nil
    
    XCTAssertTrue(minutesTicker.isStopCalled)
}
</code></pre>
<p>This test is usually green. But when I refactored this:</p>
<pre><code>func selectAppointment(index: Int) {
    selectedCellParamRelay.accept(index)
}

private func setupCellParamSelection() {
    selectedCellParamRelay
        .withLatestFrom(sortedCellParams) { ($0, $1) }
        .compactMap { [weak self] index, cellParams in
            guard let `self` = self,
                  let selectedParam = cellParams[safe: index],
                  self.isUpcomingAppointment(selectedParam) else { return nil }
            
            return selectedParam
            
        }
        .bind(to: upcomingCellParamRelay)
        .disposed(by: disposeBag)
}
</code></pre>
<p>Into this:</p>
<pre><code>func selectAppointment(index: Int) {
    selectedCellParamRelay.accept(index)
}

private func setupCellParamSelection() {
    selectedCellParamRelay
        .withLatestFrom(sortedCellParams) { ($0, $1) }
        .compactMap(selectAppointment(index:from:))
        .bind(to: upcomingCellParamRelay)
        .disposed(by: disposeBag)
}

private func selectAppointment(
    index: Int,
    from cellParams: [AppointmentCellParam]
) throws -&gt; AppointmentCellParam? {
    guard let selectedParam = cellParams[safe: index],
          isUpcomingAppointment(selectedParam) else { return nil }

    return selectedParam
}

private func isUpcomingAppointment(_ appointment: AppointmentCellParam) -&gt; Bool {
    return appointment.status != .missed &amp;&amp; appointment.status != .finished
}
</code></pre>
<p>It becomes red and the <code>deinit</code> is not called at all.</p>
<p>The <code>setupCellParamSelection</code> func is being called from the <code>init</code> to setup the event handler for selecting any appointment cell by index. The <code>sortedCellParams</code> is a relay that is emitted by a dependency that in turn will get the values from the backend.</p>
<p>Can you help me figure out what went wrong with the second code?</p>
<p>Thanks.</p>
","4124849","","","","","2021-09-01 15:58:07","Memory leak after refactoring `compactMap` for RxSwift.Observable from closure to function","<ios><swift><memory-management><memory-leaks><rx-swift>","1","0","","","","CC BY-SA 4.0"
"69041241","1","","","2021-09-03 07:44:52","","1","40","<p>I have an Observable array of objects to subscribe to, each object has to be bind with a UI component and inside UI component I have to add tap gesture on a subview which requires another subscription. I am new to RxSwift and did a bit reading on similar questions and articles but either I couldnt understand or content is not much related.</p>
<pre><code>   items.subscribe(onNext: { [weak self] items in
        for item in items {
            let view = aView()
            view.label.text = item.name
            view.image.rx.touchUpInside.subscribe(onNext: { [viewModel] _ in
                doSomething()
        }).disposed(by: disposeBag)
           self?.stackView.addArrangedSubview(view)
       }
    }).disposed(by: disposeBag)
</code></pre>
<p>I have read about <code>flatMap</code> <a href=""https://betterprogramming.pub/rxswift-deep-inside-flatmap-1ca150c41b18"" rel=""nofollow noreferrer"">here</a> and a similar question <a href=""https://stackoverflow.com/questions/50917935/avoid-nested-rxswift-subscriptions"">here</a> but couldnt comprehend it. Please explain your answer a bit so I could learn to tackle similar queries.</p>
","16821071","","1974224","","2021-09-03 18:35:01","2021-09-03 18:35:01","Rxswift: Avoid nested subscirption","<ios><swift><rx-swift>","1","4","","","","CC BY-SA 4.0"
"69046217","1","69055414","","2021-09-03 14:04:44","","1","37","<p>I am trying to extend my KeyboardView view with rx action with no success. According to debugging with breakpoints value is passed to the relay but extension is not called despite further subscription in a view controller. What might be a problem and how to fix it?</p>
<pre><code>final class KeyboardView: UIView {

    private let disposeBag = DisposeBag()
    
    fileprivate let buttonTappedRelay = PublishRelay&lt;ActionType&gt;()
    
    private let digitButtons: [KeyboardButton] = {
        return stride(from: 0, through: 9, by: 1)
            .compactMap { $0 }
            .map { KeyboardButton(actionType: .digit($0)) }
    }()
    
    private let eraseButton: KeyboardButton = {
        let button = KeyboardButton(actionType: .erase)
        return button
    }()
    
    public override init(frame: CGRect) {
        super.init(frame: frame)
        
        setupViews()
        setupConstraints()
        setupActions()
    }
    
    private func setupViews() { ... }
    
    private func setupConstraints() { ... }
    
    private func setupActions() {
        eraseButton.rx.buttonTap
            .asObservable()
            .observeOn(MainScheduler.instance)
            .subscribe(onNext: { [weak self] actionType in
                self?.buttonTappedRelay.accept(actionType)
            }).disposed(by: self.disposeBag)
        
        for button in digitButtons {
            button.rx.buttonTap
                .asObservable()
                .observeOn(MainScheduler.instance)
                .subscribe(onNext: { [weak self] actionType in
                    self?.buttonTappedRelay.accept(actionType)
                }).disposed(by: self.disposeBag)
        }
    }
    
}

extension Reactive where Base: KeyboardView {
    
    internal var buttonTap: ControlEvent&lt;ActionType&gt; {
        return ControlEvent&lt;ActionType&gt;(events: base.buttonTappedRelay.asObservable() )
    }
    
}
</code></pre>
","12504820","","12504820","","2021-09-03 15:58:45","2021-09-04 14:14:22","Can't pass the RxSwift PublishRelay value from custom view","<uikit><rx-swift><rx-cocoa>","1","6","","","","CC BY-SA 4.0"
"69063212","1","69064367","","2021-09-05 12:00:58","","0","50","<p>So I have an api request that requests a bunch of data from a fake api url, the data I am getting is being put on a placeholder, I just want to have a global variable to be able to use that array of codable data in my collectionviews.</p>
<pre class=""lang-swift prettyprint-override""><code>   struct productsList{
        static var itemsList = [ProductItem]()
    
    }
    func getProducts() {
        storeRepo
            .getAllProducts()
            .subscribe { result in
                productsList.itemsList = result
                for item in productsList.itemsList{
                    print(item.category)
                }
            } onError: { error in
                print(error.localizedDescription)
            }.disposed(by: disposeBag)
    }
    func printReuslt() {
        for i in productsList.itemsList{
            print(i.id)
        }
    }
</code></pre>
<p>note that it's not printing the printResult() but it's looping inside of the .subscribe</p>
<p>note that i am using Moya as well as RXswift</p>
","16835098","","4294399","","2021-09-08 16:13:54","2021-09-08 16:13:54","how to change value in struct globally in swift","<arrays><swift><rx-swift><moya>","1","1","","","","CC BY-SA 4.0"
"69071634","1","69073933","","2021-09-06 08:41:31","","1","30","<p>I am pretty new to RxSwift and trying to understand how the tableview datasource works.</p>
<p>I have a cell that has two buttons in it. Here is the code of the datasource I made. I am unable to access self. The two buttons should present new view controller when tapped.</p>
<pre><code> let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;String, CustomObject&gt;&gt;(
    configureCell: { (_, table, indexPath, element) in
        guard let cell: AppHelpTableViewCell = table.dequeueReusableCell(withIdentifier: AppHelpTableViewCell.reuseIdentifier,
                                                                         for: indexPath) as? AppHelpTableViewCell
        else { return UITableViewCell() }
        cell.configure(object: element)
        
        cell.introductionBtn.rx.tap.asDriver().drive(onNext: { [weak self] vc in
           self.openIntroductionHelp(object: element)
        }).disposed(by: cell.bag)
        
        cell.onlineBtn.rx.tap.asDriver().drive(onNext: { [weak self] vc in
            self.openIntroductionHelp(object: element)
        }).disposed(by: cell.bag)
        
        return cell
    }
)
</code></pre>
<p>When I call function from the UIViewController I get this error <code>Value of type '((AppHelpDetailViewController) -&gt; () -&gt; AppHelpDetailViewController)?' has no member 'openIntroductionHelp'</code> I am basically trying to call two functions implemented in the view controller that this tableview lives in and I cannot do it from this closures.</p>
<p>I considered using <code>didSelectRow</code> but I have two buttons in once cell.</p>
<p>The rx examples I have seen did not have any buttons in them or did not show ho to access self in the <code>configureCell</code>. Thanks for any  tips.</p>
","4107264","","4107264","","2021-09-06 09:15:28","2021-09-06 13:25:49","Calling self from RxTableViewSectionedReloadDataSource not working","<ios><swift><rx-swift>","1","5","","","","CC BY-SA 4.0"
"69094339","1","","","2021-09-07 20:41:04","","0","19","<p>im stucked with this situation</p>
<p>This is the view
raidobuttons and label are inside of a stackview</p>
<pre><code>    var radioButton: RadioButton = RadioButton(duration: 0).usingAutoLayout()
    var radioButtonNo: RadioButton = RadioButton(duration: 0).usingAutoLayout()
    let lblYes: UILabel = UILabel().usingAutoLayout()
    let lblNo: UILabel = UILabel().usingAutoLayout()
</code></pre>
<p>The model im working with input and output, but i don´t know if i should set the control on viewmodel or in controller</p>
<p>and whats the sequence?</p>
<p>Model:</p>
<pre><code>   struct Input {
        let trigger: Driver&lt;Void&gt;
        let viewWillAppear: Driver&lt;Void&gt;
        let callingCodeTap: Driver&lt;Void&gt;
        let yesTap: Driver&lt;Void&gt;
        let phoneNumber: Driver&lt;String&gt;
        let callingCodeDidBeginEditing: Driver&lt;Void&gt;
        let phoneNumberDidEndEditing: Driver&lt;Void&gt;
        let actionBtnTap: Driver&lt;Void&gt;
    }

    struct Output {
        let triggered: Driver&lt;Void&gt;
        let viewWillAppear: Driver&lt;Void&gt;
        let callingCodeTapped: Driver&lt;Country&gt;
        let yesTapped: Driver&lt;Void&gt;
        let country: Driver&lt;Country&gt;
        let phoneNumber: Driver&lt;(Bool, Phone)?&gt;
        let callingCodeDidBeginEditing: Driver&lt;Void&gt;
        let phoneNumberDidEndEditing: Driver&lt;Void&gt;
        let actionBtnTapped: Driver&lt;Void&gt;
        let error: Driver&lt;IBANError&gt;
    }
</code></pre>
<p>And finally the controler</p>
<pre><code>         output
        .yesTapped
        .do(onNext: { print(&quot;test&quot;)})
</code></pre>
","5954258","","","","","2021-09-07 20:41:04","RxSwift with MVVM, RadioButton not working","<ios><swift><radio-button><rx-swift>","0","0","","","","CC BY-SA 4.0"
"69112639","1","","","2021-09-09 05:22:44","","0","38","<p>There is a UIScrollView, contentView of scrollView have a UINibView, UINibView have three UITextField:</p>
<p>Action of first UITextField: display a custom view;
Action of second UITextField: show system keyboard;
Action of third UITextField: display a custom view.</p>
<p>Click the second one first, then click the first, the keyboard cannot be hidden at this time.</p>
<pre><code>kehuiInfoView.dateInput.rx.controlEvent(.editingDidBegin)
            .subscribe { _ in
                weakSelf?.view.endEditing(true)
                weakSelf?.kehuiInfoView.dateInput.resignFirstResponder()
                weakSelf?.datePicker.show()
            }
            .disposed(by: bag)
</code></pre>
","6197611","","","","","2021-09-09 12:01:45","A page has multiple UITextField the keyboard cannot be hidden","<swift><uiscrollview><keyboard><uitextfield><rx-swift>","1","1","","","","CC BY-SA 4.0"