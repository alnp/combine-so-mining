Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"49825131","1","49826432","","2018-04-13 21:06:00","","8","7787","<p>I am migrating to rxjs <code>6.0.0-ucandoit-rc.6</code>. In version <code>5.5.2</code> I was using <code>ErrorObservable</code> to create errorous observable.</p>

<p>I was using the way recommended here: <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md"" rel=""noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md</a></p>

<blockquote>
  <p>Because throw is a key word you could use _throw after import { _throw } from 'rxjs/observable/throw'.</p>
</blockquote>

<p>However this is not recommended way to import in rxjs6 anymore.</p>

<p>What is correct way how to import <code>_throw</code> or <code>ErrorObservable</code>?</p>
","691345","","691345","","2018-05-11 17:48:20","2018-05-11 17:48:20","How to import ErrorObservable or _throw in rxjs6? throw in rxjs","<angular><migration><rxjs><throw><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"50002262","1","50002355","","2018-04-24 12:55:07","","-2","415","<p>I have a service ice that pulls an array from the back-end, I need to get a single item from the array based on the ID, how do I do this in Angular?</p>

<p><a href=""https://i.stack.imgur.com/Uo0gW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Uo0gW.png"" alt=""enter image description here""></a></p>

<blockquote>
  <p>I'm looking for how to do it specifically with angulars pipeable operators. Filter tends to just stop everything from working without throwing errors if not done correctly. I can get the the row info but I cant target the properties i get <code>""Cannot read property 'id' of undefined""</code></p>
</blockquote>
","8511870","","2218635","","2018-04-24 13:04:35","2018-04-24 13:46:47","how to properly filter an array in angular","<angular><rxjs-pipeable-operators>","4","3","","","","CC BY-SA 3.0"
"50155590","1","50156128","","2018-05-03 12:53:02","","5","9996","<p>I have an <code>Observable&lt;Recipe[]&gt;</code> that I want to reduce to an array of a different class <code>ChartData[]</code> to use as a data source for a highcharts graph (column and piechart).</p>

<p>I am trying to use the RxJS pipe operator on the <code>Observable&lt;Recipe[]&gt;</code> to call the reduce operator on my data but I cannot get it to work? The <code>reduce</code> operator does not iterate over them items in my <code>Observable&lt;Recipe[]&gt;</code> Below is my attempt:</p>

<pre><code>this.foodService.getAllReceipes()
  .pipe(
    reduce((array: ChartData[], value: Recipe[], i: number) =&gt; {
        const author = this.createOrFindAuthor(array, value[i]);
        author.y += 1;

        return array;
      }, new Array&lt;ChartData&gt;())
  )
  .subscribe(data =&gt; this.chartData$ = of(data.sort((a, b) =&gt; b.y - a.y)));
}
</code></pre>

<p><code>getAllRecipes()</code> returns the <code>Observable&lt;Recipe[]&gt;</code></p>

<p><code>this.chartData$</code> is <code>Observable&lt;ChartData[]&gt;</code></p>

<p>I am trying to reduce this to <code>ChartData[]</code>. I have been able to do this in the <code>subscribe</code> operator and the graphs display the expected data but I thought I should be able to do it as a pipeable operator? Here is the reduce being done as part of the subscribe:</p>

<pre><code>this.foodService.getAllReceipes()
  .subscribe((data) =&gt; {
    const list = data.reduce((arr: ChartData[], v: Recipe) =&gt; {
      const author = this.createOrFindAuthor(arr, v);
      author.y += 1;

      return arr;
    }, new Array&lt;ChartData&gt;());

    this.chartData$ = of(list.sort((a, b) =&gt; b.y - a.y));
  });
</code></pre>

<p>I have tried using the <code>subscribe</code> code within the pipeable <code>reduce</code> but I get compile errors saying that the method expects <code>Recipe[]</code> for the value. But if I use the array then I only get the first element from the Observable (or am I just getting the Observable and need to do something with that?)</p>

<p>Is this possible or is my thought process wrong about how the pipeable operator should work on the Observable?</p>

<p>For reference here are the models and the createOrFindAuthor function:</p>

<pre><code>export class Recipe {

    public Title: string;
    public Author: string;
    public Source: string;
    public Page: number;
    public Link?: string;
}

export class ChartData {
    name: string;
    y: number;
}

private createOrFindAuthor(array: ChartData[], recipe: Recipe): ChartData {
  const name = (recipe.Author.length &gt; 0 ? recipe.Author : 'UNKNOWN');

  let found = array.find(i =&gt; i.name === name);

  if (!found) {
    const newData = new ChartData();
    newData.name = name;
    newData.y = 0;
    array.push(newData);

    found = newData;
  }

  return found;
}
</code></pre>
","2309376","","2309376","","2018-05-03 13:11:45","2018-05-03 16:14:35","Use RxJs Pipe to reduce Observable to different type","<angular><typescript><rxjs><rxjs-pipeable-operators>","3","0","","","","CC BY-SA 4.0"
"50290874","1","","","2018-05-11 11:02:40","","1","176","<p>I am trying to use RxJS pipeable operators in my angular project. I have an implementation as below.</p>

<pre><code>// Service Method
public getItems(params: Object = {}): Observable&lt;JsendResponse&gt; {
    return this.apiService.get('v1/url', params);
}

// JsendResponse interface
import { Response } from '@angular/http';

export interface JsendResponse extends Response {
    data: any;
    message: string;
    status: number;
}

// Component call
this.service
    .getItems({})
    .finally(() =&gt; this.loading = false)
    .subscribe(
         response =&gt; this.actions = response.data,
         error =&gt; this.errors = error
    );
</code></pre>

<p>In the above example, I am getting the <code>response</code> typed correctly with <code>JsendResponse</code> type. But when I use <code>pipe</code> operator, the <code>response</code> is not typed correctly and my IDE is telling that <code>TS2339: Property 'data' does not exist on type {}</code>.</p>

<pre><code>this.service
    .getItems({})
    .pipe(
        finalize(() =&gt; this.loading = false)
    )
    .subscribe(
        response =&gt; this.actions = response.data,
        error =&gt; this.errors = error
    );
</code></pre>

<p>What could be the reason? Thanks in advance.</p>
","1816449","","6120338","","2018-05-13 18:14:40","2018-05-13 18:14:40","RxJS type issue in subscribe for pipeable operators","<angular><typescript><rxjs5><tslint><rxjs-pipeable-operators>","0","3","","","","CC BY-SA 4.0"
"50648482","1","","","2018-06-01 17:33:40","","2","1569","<p>I'm zipping a three observables, each of the three observables has it's own ""success"" callback using <code>.pipe(tap() =&gt; {...});</code>.  This works fine when all three observables execute without error, but if one of the observables errors out, then none of the tap methods execute.  How can I have the tap methods always execute if that observable runs successfully?</p>

<pre><code>var request1 = Observable.create(...);  //Pretend this one will fail (though request2 or request3 could also fail)
var request2 = Observable.create(...);
var request3 = Observable.create(...);

request1.pipe(tap(() =&gt; {
    //Unique success callback should always run if request1 succeeds, even if request2 or request 3 fails.
}));

request2.pipe(tap(() =&gt; {
    //Unique success callback should always run if request2 succeeds, even if request1 or request 3 fails.
}));

request3.pipe(tap(() =&gt; {
    //Unique success callback should always run if request3 succeeds, even if request1 or request 2 fails.
}));

var observable = zip(request1, request2, request3);
observable.subscribe(() =&gt; {
    //Do something when all three execute successfully
});
</code></pre>
","","user1007817","","user1007817","2018-06-01 18:41:17","2018-06-03 01:03:31","RxJS Pipe Not Called With zip","<rxjs><rxjs-pipeable-operators>","3","2","","","","CC BY-SA 4.0"
"50707626","1","50709605","","2018-06-05 19:29:57","","2","4159","<p>I am new to using NGRX/RXJS in my angular application, and I have a situation where I have to dispatch an action from my component, which fetches data from an API if the property is empty and updates Store_1 and set a property, and then dispatch another action which uses that data from Store_1 to perform some functions in Store_2 and update state after action 1 completes and fill in ""pluralconfig"". This is the code I came up with but I dont think/believe it's the most efficient way to  do this, and If I'm using the operators correctly.</p>

<pre><code>  if(isEmpty(definition.pluralconfig == null))
     {
         this.store$.dispatch(new FormDBAction(definition.formId));

         let id = definition.id;
         this.formLoadSubscription = this.store$.select(getOrderById(id))
         .filter(v =&gt; v.pluralconfig != null).subscribe(() =&gt;{

            this.store$.select&lt;TosModel&gt;(getOrderById(id)).subscribe(updatedDefinition =&gt; {
              this.store$.dispatch(new OrderDetailAction(updatedDefinition));
            });             
         });
     }
     else{
      this.store$.dispatch(new OrderDetailAction(definition));
     }
</code></pre>
","4849537","","","","","2021-08-13 21:18:38","Dispatch second action after first action completes from component in NGRX/RXJS","<angular><rxjs><ngrx><ngrx-effects><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"51045757","1","51047869","","2018-06-26 14:48:37","","0","367","<p>I'm rewriting some of my code to use Pipeable Operators in place of ""patch"" operators and I'm a little confused about when to use <code>pipe()</code> and how do I subscribe to a piped <code>Observable</code> to ""activate"" it if I only want side-effects?</p>

<p>For example, I have this code:</p>

<pre><code>this.messages$ = this.messageService.getMessages(messageType)
    .do((messages: Message[]) =&gt; {
        console.log('The first message is ' + deviceMessages[0].text);
    });
</code></pre>

<p>I get confused here because I figure I want to do <code>this.messageService.getMessages(messageType).pipe(...)</code> so I get an <code>Observable</code> returned and assigned to <code>this.messages$</code> but then that won't execute because I haven't <code>subscribe()</code>'d. But if I do <code>.pipe(...).subscribe()</code> then it'll return a <code>Subscription</code> object, which isn't what I want.</p>

<p>What should I be doing here?</p>
","1504964","","","","","2018-06-26 16:46:11","Side-effects only when using Pipeable Operators?","<rxjs><reactive-programming><rxjs-pipeable-operators>","1","8","","","","CC BY-SA 4.0"
"51072003","1","51072504","","2018-06-27 21:58:10","","0","371","<p>I have a situation where I want to access action payload in a third level operation. 
I was able to such thing in lettable operators but how can I do the same with pipeable operator?</p>

<p>this my code,</p>

<pre><code> @Effect()
  onTrySignin = this.actions$.pipe(
    ofType(AuthActions.TRY_SIGNIN),
    map((action: AuthActions.TrySignin) =&gt; {
      return action.payload;
    }),
    switchMap(action =&gt; {
      return this.httpService
        .postRequest('UserAccounts/Login', action.credentials);
    }), catchError((error: HttpErrorResponse) =&gt; {
      return Observable.of(new AuthActions.FailedAuth(error));
    }),
    mergeMap((response: any) =&gt; {
      // how to access action payload here?
    })
  );
</code></pre>
","2157801","","","","","2018-06-28 00:23:11","How to pass action data downstream a pipeable operator stream in rxjs?","<rxjs><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"51157294","1","","","2018-07-03 14:39:13","","1","901","<p>Here is a simple post function, I am able to unit test success and catchError 
in jasmine. Is it possible to test the finalize in jasmine? i.e in finalize, can we expect loader to be closed or not?</p>

<pre><code> post(url,requestData){
    this.http.post(url, requestData).pipe(
          response =&gt; this.Response(response),
          catchError((error: Response) =&gt; this.Error(error, msg)),
          finalize(() =&gt; {
            loader.close();
          })
    }
</code></pre>

<p>In finalize I am closing loader. I need to unit test the close loader to be called in finalize.</p>
","4031891","","2117156","","2020-06-10 13:00:30","2020-06-10 13:00:30","RXjs 6 callbacks testing with jasmine","<rxjs><karma-jasmine><jasmine2.0><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"51516606","1","51588547","","2018-07-25 10:27:01","","2","268","<p>I'm creating <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md"" rel=""nofollow noreferrer"">pipeable operators</a> using RxJS 6, and am unclear about how to <code>complete()</code> the observer when the operation is <em>asynchronous</em>.</p>

<p>For a <strong>synchronous</strong> operation, the logic is simple. In the example below, all values from the source <code>Observable</code> will be passed to <code>observer.next()</code>, and after that <code>observer.complete()</code> is called.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const syncOp = () =&gt; (source) =&gt;
  new rxjs.Observable(observer =&gt; {
    return source.subscribe({
      next: (x) =&gt; observer.next(x),
      error: (e) =&gt; observer.error(err),
      complete: () =&gt; observer.complete()
    })
  });
  
rxjs.from([1, 2, 3]).pipe(syncOp()).subscribe(x =&gt; console.log(x));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.2.2/rxjs.umd.min.js""&gt;
&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>For an <strong>asynchronous</strong> operation, however, I'm a bit at a loss. In the example below, the asynchronous operation is represented by a call to <code>setTimeout()</code>. Obviously, <code>observer.complete()</code> will be called <em>before</em> any of the values are passed to <code>observer.next()</code>.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const asyncOp = () =&gt; (source) =&gt;
  new rxjs.Observable(observer =&gt; {
    return source.subscribe({
      next: (x) =&gt; setTimeout(() =&gt; observer.next(x), 100),
      error: (e) =&gt; observer.error(err),
      complete: () =&gt; observer.complete()
    })
  });
  
rxjs.from([1, 2, 3]).pipe(asyncOp()).subscribe(x =&gt; console.log(x));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.2.2/rxjs.umd.min.js""&gt;
&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>So the question is: what is the idiomatic RxJS approach to make it so that the call to <code>observer.complete()</code> is only made after all values are asynchronously passed to <code>observer.next()</code>? Should I be manually keeping track of pending calls or is there a more ""reactive"" solution?</p>

<p><em>(Note that the example above is a simplification of my actual code, and that the call to <code>setTimeout()</code> is meant to represent ""any asynchronous operation"". I'm looking for a general approach to dealing with async operations in pipeable operators, not advice on how to deal with delays or timeouts in RxJS.)</em></p>
","3558960","","3558960","","2018-07-30 04:41:53","2018-07-30 06:59:29","Preventing premature completion of an async pipeable operator in RxJS","<javascript><asynchronous><rxjs><rxjs-pipeable-operators>","3","3","","","","CC BY-SA 4.0"
"51549166","1","","","2018-07-27 00:26:23","","4","17820","<p>Is there a better way using RxJS operators to loop over an array returned from an observable than this to emit a new individual ListingItem?</p>

<pre><code>onGetItemData(){
this.dataService.getItemData().subscribe((itemData) =&gt;
{
  this.itemDataJSON = itemData;
  this.itemDataJSON.forEach(function (value) {
    let new_listing = new ListingItem(value.label,value.market,value.name);
    console.log(new_listing);
  });
 });
}
</code></pre>

<p>The API returns a single array containing the items, so I am unable to use .map to access itemData.name</p>

<pre><code>//-- DataService --// 
getItemData(){
 return this.http.get(this._URL, { headers })
        .pipe(map((res: Listings) =&gt; res.items))
}
</code></pre>
","4003765","","4003765","","2018-07-27 00:37:23","2020-12-09 19:10:15","RxJs looping over returned array","<angular><rxjs><angular2-observables><rxjs-pipeable-operators>","2","1","","","","CC BY-SA 4.0"
"51689582","1","51689765","","2018-08-04 21:11:29","","1","7198","<p>Can someone please illustrate the syntax for take(1) in Angular 6 / rxjs 6?</p>

<p>In the code below, I retrieve a document from Firestore and then make it available as an observable.  </p>

<p>I then subscribe to that observable, read the timestamp of the document, and format the age in human-readable format.  That works great, however it does not need to execute every time there are changes in the document stream.  It only needs to execute one time, since the document timestamp is never, ever going to change.</p>

<p>How can I modify this code to incorporate <code>take(1)</code>, so that the age string is only generated once and the subscription to <code>items</code> is not kept open?  I cannot find any clear example of the syntax for <code>take(1)</code> under Angular / rxjs version 6.  All of the examples I can find are for previous versions.</p>

<pre><code>import { Component, Input, OnChanges } from '@angular/core';
import { AngularFirestore, AngularFirestoreDocument } from 'angularfire2/firestore';
import { Item } from '../../interfaces/item';

@Component({
  selector: 'app-item',
  templateUrl: './item.component.html',
  styleUrls: ['./item.component.scss']
})
export class ItemComponent implements OnChanges {

  @Input() itemId: string;
  private itemDoc: AngularFirestoreDocument&lt;Item&gt;;
  public item: Observable&lt;Item&gt;;
  public age: string;

  constructor(private afs: AngularFirestore) {}

  ngOnChanges() {

    if ( this.itemId ) {

      this.itemDoc = this.afs.doc&lt;Item&gt;('items/' + this.itemId);
      this.item = this.itemDoc.valueChanges();

      this.item.subscribe(thisitem =&gt; {
        this.age = Utils.getFormattedAgeString(thisitem.timestamp);
      });

    }

  }

}
</code></pre>
","649131","","","","","2018-08-04 21:45:31","How to use take(1) in Angular 6?","<angular><rxjs><rxjs6><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"51767204","1","51791430","","2018-08-09 12:35:18","","2","2503","<p>I have some code which polls until a task is complete</p>

<p>See below</p>

<pre><code>this.simulationStatus =
  interval(2000).pipe(
    switchMap(
      () =&gt; from(this.simulationService.getSimulationStatus(this.route.snapshot.paramMap.get('jobId')))),
    takeUntil(this.stopPoll),
    tap(simulation =&gt; {
      if (simulation &amp;&amp; simulation.complete) {
        if (this.stopCount == 1) {
          // Get once after complete
          this.stopPoll.next(true);
        }
        this.stopCount++;
      }
    })
  );
</code></pre>

<p>I have tried using takeUntil and takeWhile the problem is that that the last value is never published once the task is complete.</p>

<p>To get around this I have to include the tap method to with the stopPoll subject and incrementing the stopCount to get the last value. </p>

<p>So the above works but just feels a bit messy, I'm sure there must be a better way of achieving this?</p>

<p>I would have expected takeUntil to publish the last value or have an override to tell it to e.g takeUntil(observable, {publishLast: true})</p>

<p>BTW Update, the observable is subscribed to by an Angular 6 template 
Thanks in advance</p>
","2248174","","2248174","","2018-08-09 12:57:05","2021-06-23 14:17:33","RxJs Interval with takeUntil to publish last value","<angular6><rxjs6><rxjs-pipeable-operators>","3","0","1","","","CC BY-SA 4.0"
"51828801","1","","","2018-08-13 18:51:15","","0","256","<p>I am migrating from angular 5 to 6 and I can't quite figure out the new pipeable operator syntax.</p>

<p>Consider my angular 5 http interceptor</p>

<pre><code>intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
this.request = req;

//do stuff
return next.handle(this.request)
  .do(event =&gt; {

   //do logging stuff
  },
  err =&gt; {
    //do error stuff
  });
}
</code></pre>

<p>Here is my attempt in converting this to the <code>pipe</code> way</p>

<pre><code>intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
this.request = req;

//do stuff
return next.handle(this.request).pipe(
  tap(event =&gt; {

   //do logging stuff
  },
  err =&gt; {
    //do error stuff
  }));
}
</code></pre>

<p>This doesn't compile however - the whole thing withing the <code>pipe</code> function is underlined with the following error.</p>

<pre><code>Severity    Code    Description Project File    Line    Suppression State
Error   TS2345  (TS) Argument of type 'MonoTypeOperatorFunction&lt;{}&gt;' is not 
assignable to parameter of type 'UnaryFunction&lt;Observable&lt;HttpEvent&lt;any&gt;&gt;, 
Observable&lt;any&gt;&gt;'.
Types of parameters 'source' and 'source' are incompatible.
Type 'Observable&lt;HttpEvent&lt;any&gt;&gt;' is not assignable to type 
'Observable&lt;{}&gt;'.
  Property 'source' is protected in type 'Observable&lt;HttpEvent&lt;any&gt;&gt;' but public in type 'Observable&lt;{}&gt;'.  C:\Users\stas.levich\Documents\Projects\EEA.Projects\DEP\MassAir\Web (tsconfig or jsconfig project) C:\Users\stas.levich\Documents\Projects\EEA.Projects\DEP\MassAir\Web\src\app\services\httpinterceptor.service.ts    44  Active
</code></pre>
","2501497","","1930348","","2018-10-07 11:58:24","2018-10-07 11:58:24","patched operators to pipable operators, angular 5 to 6","<angular><rxjs><angular-http-interceptors><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"51948960","1","51949125","","2018-08-21 12:43:36","","6","78","<p>I am using an Angular service to allow the user to upload files. </p>

<p>The implementation of the service is working ; my question is about RxJS and its pipeable operators, but here is the service signature just in case : </p>

<pre><code>askUserForFile(): Observable&lt;File&gt;;
toBase64(file: File): Observable&lt;string&gt;;
isFileValid(file: File, configuration?: { size?: number, extensions?: string | string[] }): boolean;
</code></pre>

<p>The call to this service is as follows : </p>

<pre><code>  this.fileService
    .askUserForFile()
    .pipe(
      // this is the operator I'm looking for 
      unknownOperator(file =&gt; this.fileService.isFileValid(file, { extensions: ['txt'] }))
      mergeMap(file =&gt; {
        fichier.filename = file.name;
        return this.fileService.toBase64(file);
      }))
    .subscribe(base64 =&gt; {
      fichier.base64 = base64;
      // Rest of my code
    }, error =&gt; {/* error handling */});
</code></pre>

<p>I would like to find an operator in place of <code>unknownOperator</code> that would throw an error if the condition isn't met. </p>

<p>I've tried with </p>

<ul>
<li><code>filter</code> : if the condition isn't met, the code stops after it,</li>
<li><code>map</code> : the code continues even if an error is thrown with <code>throwError</code></li>
</ul>

<p>I thought about using the following piping </p>

<pre><code>.pipe(
  map(...),
  catchError(...),
  mergeMap(...)
)
</code></pre>

<p>Which I think might work, but I would like to find (if possible) an operator that shortens this piping. </p>

<p>Is it possible ? if not, is there a better piping ? </p>
","","user4676340","","","","2018-08-21 13:07:26","Looking for an RxJS operator","<angular><typescript><rxjs><rxjs-pipeable-operators>","1","2","1","","","CC BY-SA 4.0"
"52036693","1","52036966","","2018-08-27 09:49:23","","0","1012","<p>I am trying to create an angular app which can send multiple HTTP requests, based on the options selected by a user from a <a href=""https://imgur.com/ndINIUL"" rel=""nofollow noreferrer"">drop-down</a>, using observables. I checked online but wasn't able to understand the concepts fully. I am not able to use <code>switchMap operator</code> in order to achieve my goals. </p>

<p>Can anyone please have a look and point out my error.</p>

<p>Any suggestions/help would be appreciated. </p>

<p>Thanks.</p>

<p>.component.ts file:</p>

<pre><code>import { Component, OnInit, OnDestroy } from '@angular/core';
import { Location } from '@angular/common';

// Router Module for Application level Route
import { Router, ActivatedRoute } from '@angular/router';

//importing route code
import { CountryLanguageService } from '../country-language.service';
import { CountryLanguageHttpService } from '../country-language-http.service';


//importing observables related code
import { Observable, pipe } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { tap } from 'rxjs/operators';
import { delay } from 'rxjs/operators';
import { switchMap } from 'rxjs/operators';


@Component({
  selector: 'app-language',
  templateUrl: './language.component.html',
  styleUrls: ['./language.component.css']
})
export class LanguageComponent implements OnInit, OnDestroy {

  public allSameLanguagesCountries;
  public selectedCode;

  constructor(private countryLanguageHttpService: CountryLanguageHttpService, private _route: ActivatedRoute, private location: Location) {

    console.log(""Languages Component Called"");
  }

  backClicked() {
    this.location.back();
  }


  ngOnInit() {

    // method to get all same language speaking countries

    this._route.params
    .pipe(switchMap(params =&gt; this.selectedCode = params['code']));
    console.log(this.selectedCode);
    this.allSameLanguagesCountries = this.countryLanguageHttpService.getAllSameLanguagesCountries(this.selectedCode)
      .subscribe(
        data =&gt; {
          console.log(data);
          this.allSameLanguagesCountries = data;

        },
        error =&gt; {
          console.log(""Some Error Occurred"");
          console.log(error.errorMessage);
        }
      )
  }

  ngOnDestroy() {
    console.log(""Language Component Destroyed"");
  }
}
</code></pre>

<p>.http-service.ts file:</p>

<pre><code>import { Injectable } from '@angular/core';

//importing Http Client to make the request
import { HttpClient, HttpErrorResponse } from '@angular/common/http';

// Router Module for Application level Route
import { Router, ActivatedRoute } from '@angular/router';

//importing observables related code
import { Observable, pipe } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { tap } from 'rxjs/operators';
import { delay } from 'rxjs/operators';
import { switchMap } from 'rxjs/operators';


@Injectable({
  providedIn: 'root'
})


export class CountryLanguageHttpService {

  public currentLanguageCode;

  public baseUrl = 'https://restcountries.eu/rest/v2/lang/';

  constructor(private _http: HttpClient) { 
    console.log(""Country Language View Service Called"");

  }

  // Exception Handler
  private handleError(err: HttpErrorResponse) {
    console.log(""Handle error Http calls"")
    console.log(err.message);
    return Observable.throw(err.message);
  }


  // method to return single country Informations
  public getAllSameLanguagesCountries(currentLanguageCode): any {

    let myResponse = this._http.get(this.baseUrl + currentLanguageCode);
    console.log(myResponse);
    return myResponse;
  } // end get country info function
}
</code></pre>

<p><a href=""https://imgur.com/jMnEvEu"" rel=""nofollow noreferrer"">This</a> is the error I am getting in console.</p>
","7608935","","","","","2018-08-27 12:16:40","How to send multiple Http request using single Observable","<angular><rxjs><rxjs-pipeable-operators>","1","5","1","","","CC BY-SA 4.0"
"52038565","1","52040106","","2018-08-27 11:42:57","","6","683","<p>Please give me some ideas of workaround for my app! I am trying to switch dynamicly template in my component but have odd behavior. Thanks! Here is <a href=""https://stackblitz.com/edit/angular-era9lu"" rel=""noreferrer"">stackblitz</a></p>

<p><strong>What I want basically:</strong> I want to recieve async data (node) from service in my alert component, and show this data (node) in my #initTemplate, then I want to take id of this data (node), send request with this id and get another data (styles) which I want to display in my #stylesTemplate.
Both templates are in my alert component.</p>

<p><strong>What's my problem?</strong>
I realized desired behavior of my component, but this is not exactly what I need... 
What I am doing:
1. Click on ""pushData"" button
2. Look at my alert component
3. Click on change template button <strong>(!! component disappears !!)</strong> 
4. Click on ""pushData"" again
5. Look at my component with changed template</p>

<p><strong>I need to switch component's template  without it's disappearing.</strong></p>

<p>Here is my simplified alert component (see also at <a href=""https://stackblitz.com/edit/angular-era9lu"" rel=""noreferrer"">stackblitz</a> working sample)</p>

<pre><code>class AlertComponent implements OnInit, OnDestroy {
    private subscription: Subscription;
    message: any;

    node$: Observable&lt;{}&gt;;
    styles$: Observable&lt;{}&gt;;

    constructor(private dataService: DataService) { }

    activeInit: boolean = true;

    ngOnInit() {
        this.node$ = this.dataService.getAsyncData().pipe(share());


        this.styles$ = this.node$.pipe(
            mergeMap(node =&gt; {
                if(!!node) {
                  // I need node here, because getSecondAsyncData send request with this data
                    return this.dataService.getSecondAsyncData(node);
                }
                else return of(null);
            }));
    }

    ngOnDestroy() {

    }

    openSecond() {
        this.activeInit = false;
    }

    openFirst() {
      this.activeInit = true;
    }

    close() {
        this.dataService.sendNodeToSubscribe(null);
    }
</code></pre>

<p><strong>And here is my html with both templates:</strong> </p>

<pre><code>&lt;ng-container *ngTemplateOutlet=""activeInit ? initTemplate : stylesTemplate""&gt;&lt;/ng-container&gt;

&lt;ng-template #initTemplate&gt;
    &lt;div class=""card left-settings position-fixed"" *ngIf=""(node$ | async) as node;""&gt;
        &lt;div class=""row justify-content-end mx-0""&gt;
            &lt;div class=""col-0""&gt;
                &lt;button type=""button"" class=""btn btn-block btn-ghost-light p-1 px-2"" (click)=""close()""&gt;Close&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=""row custom-width""&gt;
            &lt;div class=""col-lg-12""&gt;
                &lt;button (click)=""openSecond()""&gt;switch second template&lt;/button&gt;

            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/ng-template&gt;

&lt;ng-template #stylesTemplate&gt;
    &lt;div class=""card left-settings position-fixed"" *ngIf=""(styles$ | async) as styles;""&gt;
        &lt;div class=""row justify-content-end mx-0""&gt;
            &lt;div class=""col-0""&gt;
                &lt;button type=""button"" class=""btn btn-block btn-ghost-light p-1 px-2"" (click)=""close()""&gt;
          Close
        &lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=""row custom-width""&gt;
            &lt;label&gt;{{styles.isIcon}}&lt;/label&gt;
            &lt;label&gt;{{styles.radius}}&lt;/label&gt;
      &lt;button (click)=""openFirst()""&gt;switch first template&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/ng-template&gt;
</code></pre>

<p><strong>Thank you !!</strong></p>
","10148102","","","","","2018-08-28 04:22:44","*ngIf async pipe angular merge with another observable","<angular><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"52063634","1","","","2018-08-28 17:44:33","","2","140","<p>I am looking for an operator that would help me pace the results emitted from an observable, it would look like this : </p>

<pre><code>[--A-BC--D-E----------------]
[--A----B----C----D----E----]
</code></pre>

<p>I tried AuditTime() but it does not replay the results that was emitted between intervals, it does something like this :</p>

<pre><code>[--A-BC--D-E----------------]
[--A----C----E--------------]
</code></pre>

<p>Thanks for your help. </p>
","1550071","","","","","2018-08-29 13:20:20","Observable and how to control results pace","<rxjs><observable><rxjs-pipeable-operators>","1","8","","","","CC BY-SA 4.0"
"52144306","1","","","2018-09-03 06:34:52","","2","2014","<p>We are slowly updagrading from angular 4 to 5 then 6. So we upgraded rxjs. I used to do</p>

<pre><code>Observable.of(test').do(i=&gt;console.log(i))
</code></pre>

<p>In the new rxjs, I can't find the do operator something like: </p>

<pre><code>of('test')
.pipe(do(i=&gt;console.log(i)
)
</code></pre>

<p>What's the proper way ?</p>
","5056266","","","","","2018-09-03 06:34:52","Where is the 'do' operator on rxjs 6?","<angular><rxjs><rxjs-pipeable-operators>","0","2","","2018-09-03 06:40:05","","CC BY-SA 4.0"
"52383286","1","","","2018-09-18 09:25:57","","0","375","<p>I have to upgrade Angular5 code to Angular6, but I have an issue with the static combineLatest.</p>

<pre><code>export function test&lt;T&gt;(id: string | Observable&lt;string&gt;): OperatorFunction&lt;T[], T&gt; {

const id$ = asObservableIfNot(id);
return pipe(
  combineLatest(id$, (collection: T[], resolvedId) =&gt; {
    return collection.find(element =&gt; {
      return element.id === resolvedId;
    });
  }),
  distinctUntilChanged()
 );
}
</code></pre>

<p>In this case the combineLatest is import from rxjs/operators and return an OperatorFunction, but the static one return an Observable.</p>

<p>How can I convert this code in angular6 ?</p>
","10379442","","","","","2018-09-18 13:11:41","Angular6 no pipeable combineLatest","<angular6><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"52413570","1","","","2018-09-19 20:14:51","","0","28","<p>I'm trying to test latency of messages sent through a shared/hot observable. I noticed when I have multiple observers on a single shared observable, a single observer gets invoked <em>n</em> times from a single message (where <em>n</em> is the number of observers on the shared observable). </p>

<p>I ran the code below with <strong>10 Observers</strong> and <strong>1 Message Per Observer</strong>, and each observer gets invoked 10 times per message (implying 100 total observer.next() calls). From my understanding of observers/observable, each observer should only get invoked <strong>once per message</strong>. Am I just using the <code>share()</code> operator incorrectly here? Or is my understanding of it in general flawed?</p>

<pre><code>const getMessageLatency = (observersCount, messagesPerObserver) =&gt; {
    const completedMessages = [];
    const source = new Subject();
    const sharedObservable = source.pipe(
        tap((message) =&gt; console.log(`Subject: Incoming for ${message.id}`)),
        share()
    );

    // Setup observers
    for (i = 0; i &lt; observersCount; ++i) {
        sharedObservable
        .pipe(
            tap((message) =&gt; console.log(`SharedObservable: Incoming for ${message.id}`)),
            filter((message) =&gt; message.id === getObserverId(i)),
            tap(() =&gt; console.log(`Filtered for ${getObserverId(i)}`))
        )
        .subscribe((message) =&gt; {
            const date = new Date();
            message.endTime = date.getMilliseconds();
            completedMessages.push(message);
        })
    }

    // send out messages
    for (i = 0; i &lt; observersCount; ++i) {
        for (j = 0; j &lt; messagesPerObserver; ++j) {
            const date = new Date();
            const message = {
                id: getObserverId(i),
                startTime: date.getMilliseconds()
            }

            // send message
            source.next(message);
        }
    }

    // process data (get average message latency)
    const totalMessageLatency = completedMessages.reduce(
        (accumulatedLatency, currentMessage) =&gt; {
            const currentMessageLatency = 
                currentMessage.endTime - currentMessage.startTime;
            return accumulatedLatency + currentMessageLatency;
        }, 0);
    const averageLatency = totalMessageLatency / completedMessages.length;

    console.log(""=============================================================================="");
    console.log(`Observers: ${observersCount}, MessagesPerObserver: ${messagesPerObserver}`);
    console.log(`Total Messages Sent: ${observersCount * messagesPerObserver}`);
    console.log(`Total Messages Received: ${completedMessages.length}`);
    console.log(`Average Latency per Message: ${averageLatency}`);
    console.log(""=============================================================================="");

    return averageLatency;
}
</code></pre>

<p>Once this is done running, if ""Total Messages Sent"" is <em>x</em>, then ""Total Message Received"" will be <em>x^2</em></p>
","10382082","","","","","2018-09-19 20:55:11","Observable piped through `share()` invokes a single observer an unnecessary number of times","<javascript><rxjs><observable><reactivex><rxjs-pipeable-operators>","1","4","","","","CC BY-SA 4.0"
"52413679","1","","","2018-09-19 20:22:11","","0","3406","<p>I'm pretty new to RxJS and am wondering if I am doing this right... in the ngOnInit() function below, I get a client object, then pipe it...</p>

<p>Is there a better way to do the repeat switchMap/map operations below?</p>

<p>My code works... but I am wondering if there is a more elegant approach that I should be adopting...</p>

<pre><code>public client: Client;
public contract: Contract;      
public alreadyPendingContract: boolean;
public alreadyActiveContract: boolean;
public minimumStartDate: Date;
public minimumEndDate: Date;
public rolloverExclusionDate: Date;
public startDateFilter;

  ngOnInit() {
    this.clientService.getClient$().pipe(
      filter(client =&gt; client != null),
      map(client =&gt; this.client = client),
      pluck('client_id'),
      map((client_id: string) =&gt; {
        this.clientContractForm.get('client_id').setValue(client_id);
        return client_id;
      }),
      switchMap((client_id: string) =&gt; {
        return this.contractAddService.getAlreadyPendingContract$(client_id);
      }),
      map(alreadyPendingContract =&gt; {
        this.alreadyPendingContract = alreadyPendingContract;
        return this.client.client_id;
      }),
      switchMap((client_id: string) =&gt; {
        return this.contractAddService.getAlreadyActiveContract$(client_id);
      }),
      map(alreadyActiveContract =&gt; {
        this.alreadyActiveContract = alreadyActiveContract;
      }),
      switchMap(() =&gt; {
        return this.contractAddService.getMinimumStartDate$(this.client.client_id);
      }),
      map((minimumStartDate: IMinimumStartDate) =&gt; {
        this.minimumStartDate = minimumStartDate.minimumStartDate;
        this.rolloverExclusionDate = minimumStartDate.rolloverExclusionDate;
        this.startDateFilter = (m: Moment): boolean =&gt; {
          // Filters out the rollover exclusion day from being an available start date.
          return !moment.utc(m).isSame(moment.utc(this.rolloverExclusionDate), 'day');
        }
      })
    ).subscribe();
  }
</code></pre>
","1708078","","","","","2018-09-20 06:29:22","RxJS multiple switchMap and map operators... is there a better way?","<rxjs><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"52504988","1","52532558","","2018-09-25 18:52:17","","2","373","<p>I'm using Redux Observable and need to solve a timing issue when firing off actions from epics.</p>

<p>I have an array of items that I want to loop over for making AJAX calls on each one. Immediately after receiving the AJAX response, I want to fire off some actions. After all of the AJAX responses come back for each item in the original array, I want to fire off more actions.</p>

<p>How can I get these actions to fire immediately after the <code>timer</code> expires even though the original array hasn't finished looping?</p>

<pre class=""lang-js prettyprint-override""><code>const someEpic = action$ =&gt; (
    action$
    .pipe(
        ofType(SOME_ACTION),
        switchMap(({ payload }) =&gt; (
            from(payload) // This is an array of items
            .pipe(
                mergeMap(() =&gt; (
                    timer(5000) // This is my AJAX call
                    .pipe(
                        map(loadedAction),
                    )
                )),
                toArray(),
                map(anotherAction),
            )
        ))
    )
)
</code></pre>
","7113321","","1624862","","2018-09-30 17:45:11","2018-09-30 17:45:11","Emit actions before `toArray` - Redux Observable","<rxjs><rxjs5><redux-observable><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"52543957","1","","","2018-09-27 19:33:26","","0","2212","<p>In an rxjs observable chain, how could I do something with access to the current value of the observable after a set amount of time has passed? Essentially I am looking for something like the <a href=""https://www.learnrxjs.io/operators/utility/do.html"" rel=""nofollow noreferrer"">tap operator</a> but that only executes if a set amount of time has passed without seeing a value from the observable. So really it's like a combination of tap and timeout.</p>

<p>I'm imagining something like the following</p>

<pre><code>observable$.pipe(
  first(x =&gt; x &gt; 5),
  tapAfterTime(2000, x =&gt; console.log(x)),
  map(x =&gt; x + 1)
).subscribe(...);
</code></pre>

<p>This is a made up example, and the ""tapAfterTime"" function isn't real. But the basic idea is that if 2000ms pass after subscribing and the observable hasn't seen a value greater than 5, then do the tapAfterTime callback function on whatever the current value of the observable is. If we saw a value greater than 5 before 2000ms then the tapAfterTime callback would never run, but the map function would always run as expected.</p>

<p>Is there an operator to achieve this or any combination of operators?</p>
","4409188","","","","","2018-09-28 08:22:34","Observable operators to ""do"" something after an amount of time has passed","<javascript><angular><typescript><rxjs><rxjs-pipeable-operators>","3","3","","","","CC BY-SA 4.0"
"52641088","1","52641348","","2018-10-04 07:17:36","","0","543","<p>I have a List of Post with Pagination that I subscribe to the query parameter <code>?page=</code> to recalled the service API</p>

<pre><code>ngOnInit(): void {

    this.route.queryParams.subscribe(params =&gt; {

        const page = params['page'];

        // on query parameter change, call the API service here


    });
}
</code></pre>

<p>Now, I have a new requirement where User can also filter the list by selecting Category dropdown using <strong>Reactive Form</strong>. </p>

<p>Using Reactive Form, I can subscribe to the observer using this code here</p>

<pre><code>onChanges(): void {
  this.myForm.get('category').valueChanges.subscribe(val =&gt; {
    // on form value change, call the API service here
  });
}
</code></pre>

<p>My question is, how can I simplify this using Angular and RXJS? </p>

<p>The method in the example above not really DRY because the are calling the same API, only with different request parameter</p>

<p>Thanks.</p>
","417899","","7470786","","2018-10-04 07:25:10","2018-10-04 07:33:08","How to combine query parameter observable and form observable using Angular and RXJS","<angular><rxjs5><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"52650043","1","","","2018-10-04 15:08:13","","0","36","<p>I want to perform some action with one observable say add 20 to one of its property</p>

<pre><code>const mainObservable = of({id:1, count: 20});
const example = mainObservable.pipe(
    map(val=&gt; { val.count+20; return val;})
);
</code></pre>

<p>Then I need to check a condition of other observable and if it is true, then perform further operations like adding 40 to one of the property of first observable</p>

<p><strong>Combined code:</strong></p>

<pre><code>const mainObservable = of({id:1, count: 20});

const otherObservable = of([10,20]);
const example = mainObservable.pipe(
  map(val=&gt; { val.count+20; return val;}),
  switchMap(outerVal =&gt; otherObservable.pipe(map(val=&gt;{
     console.log(outerVal);
     return val.length &gt; 0;
     }))),
 // map(val=&gt; {val.count+ 40, return val})

);
</code></pre>

<p>Here, if condition of otherObservable is true then I need to added 40 into count and at last in the subscribe I should get the actual object of first observable.</p>

<p>Could anybody please help me with this along with explanation? Commented code should be introduced in order to achieve the requirement so that</p>

<p>example observable should emit object of from first observable</p>

<p><a href=""https://stackblitz.com/edit/rxjs-fraqgl?devtoolsheight=60"" rel=""nofollow noreferrer"">StackBlitz</a></p>
","2396624","","2396624","","2018-10-04 15:32:51","2018-10-04 16:48:13","Use of Rxjs functions with two observables","<typescript><rxjs><observable><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"53064231","1","53064627","","2018-10-30 12:22:59","","0","41","<p>I have a call to an HTTP service that return an observable (it's part of a third party library so I cannot change its inner code) and it is throwing an error on the subscribe for a use case that I would like to handle in the happy path.</p>

<p>I have something like this:</p>

<p><strong>My service class:</strong></p>

<pre><code>class MyService {
  getEntities(): Observable&lt;any&gt; {
    return this.http.get('&lt;the url'&gt;)
      .pipe(
        catchError(err =&gt; {
          // Handle the errors and returns a string corresponding to each message.
          // Here I show an example with the status code 403
          if (err.status === 403) {
            return throwError('My error message for 403');
          }

          // This is what I want to do.
          if (err.status === 409) {
            // Somehow, make this to trigger the goodResponse in the consumer class.
          }
        })
      );
  }
}
</code></pre>

<p><strong>My consumer:</strong></p>

<pre><code>class MyComponent {
  private myService: MyService;

  constructor() {
    this.myService = new MyService();
  }

  callTheAPI() {
    this.myService.getEntities()
      .subscribe(goodResponse =&gt; {
        // Handle good response
      }, error =&gt; {
        // Handle error
      });
  }
}
</code></pre>

<p>So, for the current code example, what I want to do is, for the case where the status code is 409, make the subscription to succeed.</p>
","4848267","","","","","2018-10-30 12:46:06","Convert failing Observable into a good one","<typescript><rxjs><rxjs6><rxjs-pipeable-operators><rxjs-lettable-operators>","1","0","","","","CC BY-SA 4.0"
"53180787","1","53188683","","2018-11-06 22:07:02","","4","7677","<p>I use angular 6 and I would like to filter the results of an async pipe, before rendering them in the UI.</p>

<p>Here is my code right now </p>

<pre class=""lang-js prettyprint-override""><code>this.results = this.form.get('name').valueChanges.pipe(           
  filter(formdata =&gt; formdata.name.length &gt; 0), 
  switchMap( formdata =&gt; this.service.getNames(formdata.name)) 
);
</code></pre>

<p>and the template</p>

<pre class=""lang-html prettyprint-override""><code>  &lt;div *ngIf='results | async ; let items'&gt;
       &lt;div *ngFor='let item of items'&gt;{{item.id}} {{item.name}} &lt;/div&gt;               
  &lt;/div&gt; 
</code></pre>

<p>From the pipe I get some ids and names. I already have an array of ids. I would like to filter the ids of the pipe and not render the ones that are already in the array. </p>

<p>So, here is what I try to do. </p>

<pre class=""lang-js prettyprint-override""><code>array = [{id:1,name:'one'},{id:2,name:'two'}];//I already have this
</code></pre>

<p>new version of filter in pipe</p>

<pre class=""lang-js prettyprint-override""><code>this.results = this.form.get('name').valueChanges.pipe(           
  filter(formdata =&gt; formdata.name.length &gt; 0), 
  switchMap( formdata =&gt; this.service.getNames(formdata.name)) ,
  filter(checkIfResultIdInArray())//pseudocode
);
</code></pre>

<p>Assume that <code>checkIfResultIdInArray</code> is I function I created. Filters and returns all the ids that are not in the <code>array</code>. So the ids/names that end up in the template are not the <code>{id:1,name:'one'},{id:2,name:'two'}</code>.</p>

<p>Or maybe I can filter in the template somehow? </p>
","2045016","","7147233","","2018-11-07 15:50:16","2020-01-23 13:25:59","angular 6 filter the async pipe results","<angular><filter><rxjs><rxjs-pipeable-operators>","3","2","2","","","CC BY-SA 4.0"
"53225356","1","","","2018-11-09 12:00:50","","1","2777","<p>This is not related to a bug I am encountering, but rather a syntax issue. </p>

<p>The workflow is simple : </p>

<ul>
<li>make an HTTP request that returns a boolean</li>
<li>if the boolean is true, then continue</li>
<li>if the boolean is false, log a warning, and stop the stream. </li>
</ul>

<p>To manage that, my current code is this :</p>

<p><strong>Boilerplate</strong></p>

<pre><code>private _getBoolean() { return this.http.get(...); }
private _getData() { return this.http.get(...); }
</code></pre>

<p><strong>Current code</strong></p>

<pre><code>public getData() {
  return this._getBoolean().pipe(
    filter(bool =&gt; {
      if(!bool) {
        console.warn('Wrong server answer, stream stopped');
        return false;
      }
      return true;
    }),
    switchMap(bool =&gt; this._getData())
  );
}
</code></pre>

<p>And I don't know why, but it doesn't feel natural and optimized to me. </p>

<p>I thought that there would be something that simplifies the syntax, something like this </p>

<pre><code>public getData() {
  return this._getBoolean().pipe(
    throwError(bool =&gt; bool ? new Error('Wrong server answer, stream stopped') : null),
    catchError(err =&gt; console.warn(err)),
    switchMap(bool =&gt; this._getData())
  );
}
</code></pre>

<p>Is there something along the lines of that, or do I have the correct syntax ?</p>
","","user4676340","","","","2018-11-09 16:27:39","RxJS : how to throw an error then catch it?","<angular><typescript><rxjs><rxjs-pipeable-operators>","3","0","","","","CC BY-SA 4.0"
"53235649","1","53237701","","2018-11-10 02:58:16","","2","916","<p>I have an RxJS Observable that emits a series of changes to an underlying data structure—specifically, <a href=""https://github.com/angular/angularfire2/blob/master/docs/firestore/collections.md#snapshotchanges"" rel=""nofollow noreferrer"">snapshotChanges() from an AngularFirestoreCollection</a>.</p>

<ul>
<li>I'm currently mapping this to an array of plain JavaScript objects for consumption by my app.</li>
<li>This array is not protected in any way, and consuming code could accidentally modify this structure.</li>
<li>The entire array is rebuilt whenever the underlying data source emits, even if only one (or sometimes no) item in the array has actually changed.</li>
<li>Because of this, all references change each time, making change detection harder than it needs to be—and really slowing down my app.</li>
</ul>

<p>What I want to do instead is use <a href=""https://github.com/mweststrate/immer"" rel=""nofollow noreferrer"">Immer</a> to maintain an immutable structure, such that unchanged data is structurally shared with the “new” array.</p>

<p>What I can't work out is how to <code>pipe()</code> off the <code>snapshotChanges()</code> observable such that the pipe gets access to the previously emitted immutable data (or a first-time default) <strong>in addition to</strong> the latest <code>snapshotChanges()</code> output.</p>

<p>In code, what I basically already have is this:</p>

<pre><code>const docToObject = (doc) =&gt; { /* change document to fresh plain object every time */ };
const mappedData$ = snapshotChanges().pipe(
    map(changes =&gt; changes.map(change =&gt; docToObject(change.payload.doc)),
    tap(array =&gt; console.log('mutable array:', array)),
);
</code></pre>

<p>and I'm essentially looking for something like this, where I don't know what <code>XXX(...)</code> should be:</p>

<pre><code>const newImmutableObject = (changes, old) =&gt; {
  // new immutable structure from old one + changes, structurally sharing as much as
  // possible
};
const mappedData$ = snapshotChanges().pipe(

// ==================================================================================
    XXX(...), // missing ingredient to combine snapshotChanges and previously emitted
              // value, or default to []
// ==================================================================================

    map(([snapshotChanges, prevImmutableOutput]) =&gt; newImmutableOutput(...)),
    tap(array =&gt; console.log('IMMUTABLE ARRAY with shared structure:', array)),
);
</code></pre>

<p>I feel like <a href=""https://www.learnrxjs.io/operators/transformation/expand.html"" rel=""nofollow noreferrer"">the <code>expand</code> operator</a> is close to what I need, but it seems to only pass the previously emitted value in on subsequent runs, whereas I also need the newly emitted <code>snapshotChanges</code>.</p>

<p><strong>Given an RxJS Observable pipe, how can I operate on this Observable's emissions while also having access to the pipe's previous emission?</strong></p>
","4877269","","","","","2018-11-10 09:41:04","How can I give an RxJS observable pipe access to the original observable's emission AND the pipe's previous emission?","<angular><rxjs><angularfire2><rxjs-pipeable-operators><immer.js>","1","2","","","","CC BY-SA 4.0"
"53240192","1","53241246","","2018-11-10 15:00:25","","0","35","<p>I have a similar case to one described in <a href=""https://stackoverflow.com/questions/49627239/casting-a-type-interface-via-map-to-observable"">this post</a>.</p>

<p>I have a user login service, which (among other things) verifies if user's token is still valid. The server's response is defined in an interface:</p>

<pre class=""lang-js prettyprint-override""><code>export interface UserVerifyResponse {
    success: boolean
}
</code></pre>

<p>My aim was to create an observable that will return a boolean value depending on whether user is verified. This code was working with RxJS v6.2:</p>

<pre><code>authenticate(): Observable&lt;boolean&gt; {
    return this.http.get&lt;boolean&gt;(
        this.apiUrl+'/verify_user'
    ).pipe(
        map&lt;UserVerifyResponse, boolean&gt;((receivedData: UserVerifyResponse) =&gt; {
            return receivedData.success;
        }),
        tap((data: boolean) =&gt; {console.log(""User authenticated"", data)}),
        catchError(this.handleError)
    )
}
</code></pre>

<p>However, now that I have updated RxJS to v6.3 I get this error:</p>

<pre><code>ERROR in src/app/login/user.service.ts(50,13): error TS2345: Argument of type 'OperatorFunction&lt;UserVerifyResponse, boolean&gt;' is not assignable to parameter of type 'OperatorFunction&lt;boolean, boolean&gt;'.
  Type 'UserVerifyResponse' is not assignable to type 'boolean'.
</code></pre>

<p>It bothers me, because I use this approach of mapping API response to an internal class or a primitive (in other place I have a service which uses <code>http.get&lt;T&gt;</code>) and now I wonder if I should force RxJS 6.2 or there is an easy way to migrate to 6.3. I can rewrite all of them as it is described in the answer to the above mentioned post, but I I want to return a boolean value and my approach looks clearer in my opinion. </p>

<p>Any suggestions?</p>
","5854688","","","","","2018-11-10 16:56:50","Why map doesn't work after upgrading RxJS to v6.3","<typescript><type-conversion><rxjs><rxjs6><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"53308571","1","","","2018-11-14 20:54:47","","0","268","<p>My question is:
How can i manipulate an object in an object list that i get from http request. For example, i receive a list of objects with every object like</p>

<pre><code>{
    start:start,
    end:end,
    title:title,
}
</code></pre>

<p>i need to modify to</p>

<pre><code>{
    start: new Date(start),
    end: new Date(end),
    title:title,
    draggable:true,
    resizable:true,
}
</code></pre>

<p>my code </p>

<pre><code>this.http.get('https:url-to-guest-events').pipe(
    //what operator can i use, map maybe?
)
.subscribe(
    events =&gt; this.events = events;
)
</code></pre>
","8821906","","7247920","","2018-11-14 21:00:20","2018-11-14 21:19:00","How can I manipulate through rxjs operators an object that i get from a request?","<javascript><angular><rxjs><rxjs-pipeable-operators>","2","3","","","","CC BY-SA 4.0"
"53361733","1","","","2018-11-18 14:02:56","","0","969","<p>Since this morning I'm trying to solve a really headache-giving issue.</p>

<p>I'll begin by explaining the (really simple) situation.</p>

<p>I've created Groups, which are composed of a title, and an array of members, only given by their id string.</p>

<p>Now, I want to display these Groups. Simple isn't it ? 
However, I don't want of course to just display the ids of the members, but the complete informations on users of the groups (such as basically their names...).</p>

<p>So, I have of course a service for getting all Groups, and another for getting a User by its Id.</p>

<p>In React, since I'm not using rxjs, I wouldn't have any problem ; async/awaits and Promise.all would do the trick.</p>

<p>However here, several problems appear while trying to get complete infos (calling the 2 services) before rendering it, as:
1. I want to get the groups
2. iterate on it
3. iterate on group members
4. finally for each member get its id. Therefore each group could have a groupcompleteusers array for example, that i would fill each time I would be getting the info on the users from the id...</p>

<p>So I tried the following: <br />
- first I tried to play with async/awaits, Promises, but since I'm calling services returning Observables, I'm a bit lost. <br />
- then I tried to have nested subscriptions. However, I'm completely unable to write it properly, as I'm not only iterating on groups, but also on group.members (which is not existing at the time of the nested subscription, as group is at that time an Observable...)</p>

<p>So, with angular 7/rxjs 6, I tried the following : </p>

<pre><code>getGroups(){
this.groupsService.getGroups().pipe(
  flatMap(group =&gt; 
    {
      for(let member of group.members){
        this.userService.getUser(member);
      }
    }
    )
).subscribe(u =&gt; this.groups = u)


}
</code></pre>

<p>Of course, it's not working, especially as group.members doesn't exist at that time...</p>

<p>So I'm a bit stuck.</p>

<p>Maybe some have a clue?</p>

<p>Thanks!</p>
","10271412","","","","","2018-11-18 15:58:21","Nested subscriptions in Angular with iteration on first result","<angular><rxjs><observable><angular-observable><rxjs-pipeable-operators>","1","6","","","","CC BY-SA 4.0"
"53374029","1","53374909","","2018-11-19 11:49:11","","1","76","<p>I have tried to trim down my use case in below example.</p>

<p>I am stuck at the a point where I need to pass the result of operator which should have </p>

<ul>
<li>input passed of operator </li>
<li>and result of the defer operation inside the
<code>concatMap</code>.</li>
</ul>

<p>so that I can use it next operator.</p>

<pre><code>import { of, from, defer } from 'rxjs';
import { mergeMap, filter, concatMap, map, reduce } from 'rxjs/operators';

const list: number[] = [1, 2, 3, 4, 5, 6];

function testFunctionPromise(value: number) {
  return () =&gt; {
    return new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        return resolve('processed-value ' + value);
      }, 1000);
    });
  }
}


from(list)
  .pipe(
    filter((item: number) =&gt; item % 2 === 0),
    concatMap((item: number) =&gt; {
      const pf = testFunctionPromise(item);

      /**
       *  QUESTION: from this step I want to pass both
       *  the result of defer(pf); and item
       * 
       *  as
       * 
       *  return { item: &lt;result of defer(pf)&gt; }
       * 
       */
      return defer(pf);
    }),
    reduce((acc: any[], item: any) =&gt; acc.concat([item]), [])
  )
  .subscribe(
    data =&gt; console.log({ data }),
    error =&gt; console.error({ error })
  )
</code></pre>

<p>url: <a href=""https://stackblitz.com/edit/rxjs-defer?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-defer?file=index.ts</a></p>
","571156","","571156","","2018-11-20 05:21:24","2018-11-20 05:21:24","How to combine operator input and result of defer operation together","<angular><rxjs><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"53390328","1","53495354","","2018-11-20 09:53:06","","3","402","<p>I know this question has been asked before <a href=""https://stackoverflow.com/questions/51210629/angular-6-pipe-rxjs-operator-to-chain-3-dependant-observables/51210930"">here</a>. But the solution accepted is not working for me or I am not able to understand it well.</p>

<p>I am using ng-7
I have simple use case:</p>

<p>I have 2 APIs, 2nd is dependent on 1st's response.
I subscribe to result of 1st API and then using pipe subscribe to 2nd API result.</p>

<p>My code looks like below;</p>

<pre><code>this._SomeService
        .addUserToDb(payload)
        .pipe(
          map(res =&gt; res),
          mergeMap(db1Response =&gt;
            this._SomeService.addUserToDb2(db1Response
            )
          ),
          catchError(errodb1 =&gt; {

            return Observable.throw(new 
            Error(errorSso));
          })
        )
        .subscribe(
          resDb2 =&gt; {
              // Here I get response of addUserToDb2
          },
          errDb2 =&gt; {


          }
        )
</code></pre>

<p>Now before subscribing to second API response I want to subscribe to another observable say:</p>

<p>this._tokenService.getToken.pipe(</p>

<p>)</p>

<p>And Want to use it's response in service 2.
Such that:</p>

<p>API1 => token => API2</p>

<p>Please suggest how to implement.</p>

<p><strong>UPDATE:</strong></p>

<p>I tried to implement, below is my implementation:</p>

<pre><code>  this._service.addUserToDB1(payload).pipe(
          map(resp =&gt; this.resDB1 = resp) // Adding to global variable because I need this response while subscribing to DB2 service.
          ,mergeMap(resdb1=&gt;this._tokenService.getToken.pipe(
            mergeMap(token =&gt; this._service.addUserToDb2(
              this.resDB1,
              this.organizationId,
              this.practitionerId,
              token
            ),
            catchError(errorToken =&gt; {

              return Observable.throw(new Error(errorToken));
            })),
            )
          ),
          catchError(errordb1 =&gt; {

            return Observable.throw(new Error(errordb1));
          })

      ).subscribe (
        resdb2Response =&gt;
        {

        },
        errdb2 =&gt; {

        }
      )
</code></pre>

<p>Can someone validate if above implementation is fine or suggest right way?</p>
","3032338","","3032338","","2018-11-26 11:58:21","2018-11-27 08:18:21","Chain 3 or more dependent observables","<observable><rxjs6><angular7><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"53466280","1","53466352","","2018-11-25 09:42:12","","0","400","<p>I'm getting an <code>id</code> from the <strong>route params</strong> and that I'm passing to my API call. For this, I'm currently using <strong>nested subscription</strong>. But I want to use the <code>concat()</code> or maybe some other operator of <strong>RxJs</strong>(I don't know which) so that I can avoid nesting. Since the docs <a href=""http://reactivex.io/documentation/operators/concat.html"" rel=""nofollow noreferrer"">here</a> is not giving some example, which left me confused regarding, how I can use it here in my code. </p>

<p>Below is code where nesting is implemented, I want to implement same logic using <code>concat()</code> or maybe some other operator of RxJs.</p>

<pre><code>this.route.params.subscribe((params: Params) =&gt; {
  this.selectedPostId = +params['id'];
  if (this.selectedPostId) {
    // Simple GraphQL API call below
    this.apollo.watchQuery(GetPost, {id: this.selectedPostId})
      .subscribe((post: PostType) =&gt; {
        if (post) {
          console.log(post);
        }
      });
  }
});
</code></pre>
","5893995","","5893995","","2018-11-25 10:10:12","2018-11-25 10:43:30","Implement RxJs operator instead of nested subscribe blocks","<angular><rxjs><graphql><angular-router><rxjs-pipeable-operators>","1","3","","","","CC BY-SA 4.0"
"53504241","1","53504407","","2018-11-27 16:39:03","","2","815","<p>I've trying to use Angular material paginator and sorting, and get some code from material.angular.io example. This part:</p>

<pre><code>ngOnInit() {
    this.exampleDatabase = new ExampleHttpDao(this.http);

    // If the user changes the sort order, reset back to the first page.
    this.sort.sortChange.subscribe(() =&gt; this.paginator.pageIndex = 0);

    merge(this.sort.sortChange, this.paginator.page)
      .pipe(
        startWith({}),
        switchMap(() =&gt; {
          this.isLoadingResults = true;
          return this.exampleDatabase!.getRepoIssues(
            this.sort.active, this.sort.direction, this.paginator.pageIndex);
        }),
        map(data =&gt; {
          // Flip flag to show that loading has finished.
          this.isLoadingResults = false;
          this.isRateLimitReached = false;
          this.resultsLength = data.total_count;

          return data.items;
        }),
        catchError(() =&gt; {
          this.isLoadingResults = false;
          // Catch if the GitHub API has reached its rate limit. Return empty data.
          this.isRateLimitReached = true;
          return observableOf([]);
        })
      ).subscribe(data =&gt; this.data = data);
}
</code></pre>

<p>when server return an error and catchError handled it, sorting ang paging stopt to send requests to the server. What's wrong with theirs example?</p>
","1100481","","6782707","","2020-02-23 04:30:48","2020-02-23 04:30:48","merge pipe die after catchError","<angular><rxjs><angular-material><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"53528334","1","","","2018-11-28 21:23:20","","-1","549","<p>i am trying to use filter in angular 4, this is my code</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { range } from 'rxjs/observable/range';
import { map, scan, filter, tap } from 'rxjs/operators';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent implements OnInit {  

  ngOnInit(){
    this.rxjs();
  }
  rxjs(){
    const source$ = range(1, 10);

    source$.pipe(
      filter(n =&gt; n % 2 !== 0), 
      tap(n =&gt; console.log('filtered value: ' + n)),
      map(n =&gt; n * n),
      tap(n =&gt; console.log('squared value: ' + n)),
      scan((acc,s) =&gt; acc + s, 0)
    )
    .subscribe(v =&gt; console.log(`sum of squared values : ${v}`));    
  }    
}
</code></pre>

<p>this is my angular version, which i found out using <strong>ng --version</strong> command</p>

<pre><code>@angular/cli: 1.4.10
node: 8.9.1
os: win32 x64
@angular/animations: 4.4.7
@angular/common: 4.4.7
@angular/compiler: 4.4.7
@angular/core: 4.4.7
@angular/forms: 4.4.7
@angular/http: 4.4.7
@angular/platform-browser: 4.4.7
@angular/platform-browser-dynamic: 4.4.7
@angular/router: 4.4.7
@angular/cli: 1.4.10
@angular/compiler-cli: 4.4.7
@angular/language-service: 4.4.7
typescript: 2.3.4
</code></pre>

<p>but when i compile, i am getting an error like this</p>

<blockquote>
  <p>ERROR in E:/angular-mock/routes/src/app/app.component.ts (19,19): The
  left-hand side of an arithmetic operation must be of type 'any',
  'number' or an enum type.</p>
</blockquote>

<p>can anyone help me on what i am doing wrong in this</p>
","2711059","","","","","2019-03-14 13:11:48","Not able to use filter operators of rxjs in angular4","<angular><rxjs5><rxjs-pipeable-operators>","2","8","","","","CC BY-SA 4.0"
"53556039","1","","","2018-11-30 10:49:54","","0","158","<p>In my service, I want get one object but I also want the details of that single object before I return it to my component.</p>

<p>Using the pipe operator I try to call the function that would provide me the details (in this case <code>Bar</code>).</p>

<p>But I'm a bit lost how I would do this, since I return <code>observable&lt;Bar&gt;</code> and not a <code>Bar</code>.</p>

<pre><code>export class Foo {
  public ID;
  public Bar: Bar;
}

export class Bar { }

  /**
  * Returns a single Foo
  */
  public FindSingleFoo(fooID: string): Observable&lt;Foo | HttpError&gt; {
    return this._httpClient.post&lt;Foo&gt;('API/FindSingleFoo', fooID)
      .pipe(
        map((data) =&gt; this.FindBarOfFoo(data)),
      );
  }

   /**
   * Returns the Bar of Foo
   * @param fooID - the ID you want Bar for
   */
  public FindBarOfFoo(foo: Foo): Observable&lt;Foo | HttpError&gt; {
    return this._httpClient.post&lt;Bar&gt;('API/FindBarOfFoo', foo.ID).subscribe(
      (result: Bar) =&gt; foo.Bar = result
    );
  }
</code></pre>
","5695833","","","","","2018-11-30 11:17:19","Get extra details via pipe operator with rxjs","<angular><rxjs><angular-services><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"53592001","1","","","2018-12-03 10:37:25","","1","100","<p>I´m trying to merge multiple observables together. In general i am trying to request an xsd file using angular httpClient and parse it using xml2js library. the problem is that this xsd file contains import statements which reference external files.</p>

<p>So what i am trying to do is the following:</p>

<ol>
<li>request main xsd file</li>
<li>parse main xsd file (rxjs map operator)</li>
<li>process all import statements within that file</li>
<li>recursive all of 1. for each import (use a forkJoin operator to merge those)</li>
<li><p>merge parsed imports with parsed main xsd file</p>

<pre><code>this.http.get('&lt;PATH to main xsd&gt;')
  .pipe(map(data =&gt; {
    xml2js.parseString(data, (err, xmlObject) =&gt; {
      if (err) {
        console.error('ERROR', err);
      } else {
      data = xmlObject;
      }
    });
    return data;
  }))
  .pipe(mergeMap((data) =&gt; {
    if (xmlObject.xs_schema.xs_import !== undefined) {
      const requests: Observable&lt;any&gt;[] = [];
      for (const xmlImport of xmlObject.xs_schema.xs_import) {
        const path = 'xmlImport.path';
        requests.push(this.getXsdSchema(path));
      }
      return forkJoin(requests);
    } else {
      return empty();
    }
  }));
</code></pre></li>
</ol>

<p>The code above works until the pipe with mergeMap is executed for one of the imported files. I think returning an empty observable if there are not imports in the file might be a problem.
So far i was not able to figure out how i can include the imports in my main xsd object.</p>

<p>I tried to make up a demo to show the current state and the problem:
<a href=""https://stackblitz.com/edit/angular-x26paa"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-x26paa</a></p>
","10555800","","10555800","","2018-12-03 11:56:50","2018-12-03 11:56:50","Observable inside observable and merge results into the others","<angular><xsd><rxjs><observable><rxjs-pipeable-operators>","0","12","","","","CC BY-SA 4.0"
"53608948","1","53611615","","2018-12-04 08:52:30","","0","425","<p>I am working with an API that has a fixed, consistent structure of responses: it is always an object that has a <code>data</code> property on it. As it is very tiresome and too explicit to constantly map the data in RxJS requests (or ngrx effects), I decided to introduce a custom RxJS operator that plucks the data and applies an optional callback.</p>

<p>But now some of my effects complain about the type information (like: <code>property x doesn't exist on type {}</code>), so I guess my effort to properly type-guard the operator's I/O isn't enough:</p>

<pre><code>export function mapData&lt;T, R&gt;(callback?: (T) =&gt; R) {
  return (source: Observable&lt;T&gt;) =&gt; source.pipe(
    map(value =&gt; value['data'] as R), // isn't that an equivalent of `pluck&lt;T&gt;('data')` ?
    map(value =&gt; typeof callback === 'function' ? callback(value) : value as R),
  );
}
</code></pre>

<p>An example of ngrx effect with type-guard problems :</p>

<pre><code>switchMap(() =&gt; this.api.getData().pipe(
  mapData(),
  mergeMap(data =&gt; [
     new actions.DataSuccessAction({ id: data.id }), // &lt;-- id does not exist on type {}
     new actions.SomeOtherAction(data),
  ]),
  catchError(err =&gt; of(new actions.DataFailureAction(err))),
)),
</code></pre>

<p>Which of course goes away when I type-cast it explicitly:</p>

<pre><code>mapData&lt;any, IMyData&gt;(....),
</code></pre>

<p>I would love to hear whether this is the right, TypeScript way to do stuff.</p>
","776686","","776686","","2018-12-04 08:58:20","2018-12-04 11:09:31","Properly type-guarding custom RxJS pipeable operators","<typescript><rxjs><typescript-typings><rxjs-pipeable-operators><custom-operator>","1","3","","","","CC BY-SA 4.0"
"53677959","1","","","2018-12-07 23:16:52","","0","557","<p>I am implementing a publish and subscribe pattern using an Angular service and an RxJS Subject. The service if firehosed with updates from the backend and has to filter these updates so that any given compenent only gets the updates they sign up for. It may be easier if I give my working example.</p>

<p>Here is the service code:</p>

<pre><code>public getUpdates(updatesIWant: UPDATE[]): Observable&lt;UPDATE[]&gt; {
  return this.updateSubject.pipe(
    map(updates =&gt; updates.filter(update =&gt; updatesIWant.indexOf(update) != -1)));
}
</code></pre>

<p>And here is the component code:</p>

<pre><code>this.updateService.getUpdates(this.updatesIWant).subscribe(updates =&gt; {
  this.processUpdates(updates);
}
</code></pre>

<p>This works, but when receiving thousands of updates a second, it becomes inefficient. How can I optimize this pattern? Is there any way I can incorporate a custom rxjs operator that will do the job, or perhaps a webworker?</p>
","9196513","","","","","2018-12-07 23:16:52","Optimizing Pubsub Pattern with Angular and RxJS","<angular><rxjs><rxjs-pipeable-operators>","0","9","","","","CC BY-SA 4.0"
"53920820","1","","","2018-12-25 08:56:51","","1","431","<p>I have created a new RxJs(6) operator switchIfEmpty(other), it switches to <code>other</code> when the source is empty.</p>

<p>i'am new in marble tests, i've created some tests for validating my operator, all tests pass except one. i dont know if the bugs comes from the operator or the test !</p>

<pre><code>import { Observable } from 'rxjs';

export const switchIfEmpty = &lt;T, R&gt;(emptySource: Observable&lt;R&gt;) =&gt;
  (source: Observable&lt;T&gt;) =&gt; {
    return new Observable&lt;T | R&gt;(subscriber =&gt; {
      let empty = true;
      const subscription = source.subscribe(
        e =&gt; {
          empty = false;
          subscriber.next(e);
        },
        error =&gt; subscriber.error(error),
        () =&gt; {
          if (empty) {
            const innerSub = emptySource.subscribe(
              innerE =&gt; subscriber.next(innerE),
              error =&gt; subscriber.error(error),
              () =&gt; subscriber.complete()
            );
            subscription.add(innerSub);
          } else {
            subscriber.complete();
          }
        }
      );
      return subscription;
    });
  };
</code></pre>

<p>the test spec:</p>

<pre><code>import { TestScheduler } from 'rxjs/testing';
import { of, throwError } from 'rxjs';
import { switchIfEmpty } from './switch-empty';
import { delay } from 'rxjs/operators';

describe('SWITCH IF EMPTY OPERATOR', () =&gt; {

  let scheduler: TestScheduler;

  beforeEach(() =&gt; {
    scheduler = new TestScheduler((actual, expected) =&gt; {
      expect(actual).toEqual(expected);
    });
  });

  it('switchIfEmpty : source not empty', () =&gt; {
    const source = '-x-y-z|';
    const expected = '-x-y-z|';
    scheduler.run(helper =&gt; {
      const source$ = scheduler.createColdObservable(source);
      helper.expectObservable(source$.pipe(switchIfEmpty(of(1)))).toBe(expected);
    });
  });

  it('switchIfEmpty : source empty', () =&gt; {
    const source = '|';
    const expected = '(1 a|)';
    scheduler.run(helper =&gt; {
      const source$ = scheduler.createColdObservable(source);
      helper.expectObservable(source$.pipe(switchIfEmpty(of('1', 'a')))).toBe(expected);
    });
  });

  it('switchIfEmpty : source error', () =&gt; {
    const source = '-x#';
    const expected = '-x#';
    scheduler.run(helper =&gt; {
      const source$ = scheduler.createColdObservable(source);
      helper.expectObservable(source$.pipe(switchIfEmpty(of(1)))).toBe(expected);
    });
  });

  it('switchIfEmpty : empty source switched to error', () =&gt; {
    const source = '|';
    const expected = '#';
    scheduler.run(helper =&gt; {
      const source$ = scheduler.createColdObservable(source);
      helper.expectObservable(source$.pipe(switchIfEmpty(throwError('error')))).toBe(expected);
    });
  });

  it('switchIfEmpty : empty source switched to delay', () =&gt; {
    const source = '|';
    const expected = '--x|'; // tried '--(x|)' not work
    scheduler.run(helper =&gt; {
      const source$ = scheduler.createColdObservable(source);
      const switchedSource = of(1).pipe(delay(20));
      helper.expectObservable(source$.pipe(switchIfEmpty(switchedSource))).toBe(expected, {x: 1});
    });
  });
});
</code></pre>

<p>only the last one is not working:</p>

<pre><code>it('switchIfEmpty : empty source switched to delay', () =&gt; {
    const source = '|';
    const expected = '--x|'; // tried '--(x|)' not work
    scheduler.run(helper =&gt; {
      const source$ = scheduler.createColdObservable(source);
      const switchedSource = of(1).pipe(delay(20));
      helper.expectObservable(source$.pipe(switchIfEmpty(switchedSource))).toBe(expected, {x: 1});
    });
  });
</code></pre>

<p>the error message</p>

<pre><code>SWITCH IF EMPTY OPERATOR switchIfEmpty : empty source switched to delay FAILED
        Expected $.length = 0 to equal 2.
        Expected $[0] = undefined to equal Object({ frame: 2, notification: Notification({ kind: 'N', value: 1, error: undefined, hasValue: true }) }).
        Expected $[1] = undefined to equal Object({ frame: 3, notification: Notification({ kind: 'C', value: undefined, error: undefined, hasValue: false }) }).
            at TestScheduler.assertDeepEqual (http://localhost:9876/src/switch-empty.spec.ts?:12:22)
            at http://localhost:9876/node_modules/rxjs/_esm5/internal/testing/TestScheduler.js?:122:1
            at Array.filter (&lt;anonymous&gt;)
            at TestScheduler.push../node_modules/rxjs/_esm5/internal/testing/TestScheduler.js.TestScheduler.flush (http://localhost:9876/node_modules/rxjs/_esm5/internal/testing/TestScheduler.js?:120:1)
</code></pre>
","8325761","","8325761","","2018-12-25 22:47:13","2018-12-25 22:47:13","RxJs SwitchIfEmpty Custom pipable operator","<typescript><rxjs><reactive-programming><rxjs6><rxjs-pipeable-operators>","0","6","","","","CC BY-SA 4.0"
"54030722","1","54030977","","2019-01-03 22:33:00","","7","510","<p>Take for example:</p>

<pre><code> this.http.get('/getdata').pipe(delay(2000))
</code></pre>

<p>I would like this request to take a <strong>minimum</strong> of 2s to complete, but not any longer than it takes for the request to complete.</p>

<p>In other words:</p>

<ol>
<li><p>if the request takes <strong>1s</strong> to complete, I want the observable to complete in <strong>2s</strong>.</p></li>
<li><p>if the request takes <strong>3s</strong> to complete, I want the observable to complete in <strong>3s</strong> NOT <strong>5s</strong>.</p></li>
</ol>

<p>Is there some other pipe other than <code>delay()</code> that can achieve this that I don't know about or is there a way to build a custom pipe for this if necessary?</p>

<p>The use case is to show a loader, however if the request completes too fast it doesnt look good when the loader just ""flashes"" for a split second</p>
","1267778","","3001761","","2019-01-03 22:39:40","2020-06-22 08:08:34","How can I delay an observable only if it returns faster than the delay","<rxjs><rxjs6><rxjs-pipeable-operators>","2","5","","","","CC BY-SA 4.0"
"54232123","1","","","2019-01-17 08:53:41","","0","251","<p><a href=""https://stackblitz.com/edit/angular-kendo-2grid"" rel=""nofollow noreferrer"">stackblitz.com/edit/angular-kendo-2grid</a>  check with this.
If I am clicking next grid it should call new api and display data but it also changes previous data too</p>

<p>I have two different method in my single component which uses .pipe() method and refer to two different method in service file. which means they intended to give different result but give same result.</p>

<p>I am having a view which comes good and i am implement a new view on click on one of the list. I am getting new result fine but exist result updated to new one too. </p>

<p>In my service file:</p>

<pre><code>methodOne(){
  return this.http
      .get(`https://jsonplaceholder.typicode.com/posts`, this.httpOptions)
       .pipe(
        map(
          res =&gt; {
            if (!res) {
              return res = '';
            } else {
              return res
            }
          }
        )
      )
      .pipe(
        tap(data =&gt; {
          this.data = data
        })
      )
      .subscribe(data =&gt; {
        super.next(data);
      });
  }
}
</code></pre>

<p>Initial First Method Works and Below second works too but When Second Works It changes result of first view too</p>

<pre><code>methodTwo(){
  return this.http
      .get(`https://jsonplaceholder.typicode.com/newposts`, this.httpOptions)
       .pipe(
        map(
          res =&gt; {
            if (!res) {
              return res = '';
            } else {
              return res
            }
          }
        )
      )
      .pipe(
        tap(data =&gt; {
          this.data = data;
        })
      )
      .subscribe(data =&gt; {
        super.next(data);
      });
  }
}
</code></pre>

<p>In my component file:</p>

<pre><code>comOne(value){
this.editService.methodOne(value);
    this.view = this.editService.pipe(map(
      data =&gt; process(data, this.gridState)
));
}

comTwo(value){
this.editService.methodTwo(value);
    this.view2 = this.editService.pipe(map(
      data =&gt; process(data, this.gridState)
));
}
</code></pre>

<p>Both Works but But When I Call comTwo(value) it changes the this.view result too, I want to to persist this.view result</p>
","8393519","","8393519","","2019-01-17 10:30:57","2019-01-17 23:29:16","two rxjs .pipe() method in different view in same component gives same result although using two different method in service file in angular","<angular><rxjs><kendo-ui-angular2><subscribe><rxjs-pipeable-operators>","1","10","","","","CC BY-SA 4.0"
"54395824","1","","","2019-01-28 05:06:22","","5","808","<p>In RxJS, filters such as <code>auditTime</code> and <code>throttleTime</code> emit an Observable (in different ways) after a certain duration has passed. I need to emit an Observable and <em>then</em> wait for a period of time before emitting the next value.</p>

<p>In my case I am working in Angular. For example, this code:</p>

<pre><code>this.fooService$.pipe(throttleTime(10000)).subscribe(() =&gt; this.doSomething());
</code></pre>

<p>will not accomplish what I need because the emission happens at the end of the duration. I need the opposite: the emission happens and then a delay. How can I accomplish this?</p>
","3357958","","3357958","","2019-01-28 05:32:55","2019-01-28 07:36:33","How to emit an Observable and then throttle the subscription","<angular><rxjs><rxjs6><rxjs-pipeable-operators>","2","4","2","","","CC BY-SA 4.0"
"54518039","1","","","2019-02-04 14:13:49","","0","41","<p><strong>This question has been moved to Code-Review:</strong></p>

<p><a href=""https://codereview.stackexchange.com/questions/212854/rxjs-caching-different-http-requests"">https://codereview.stackexchange.com/questions/212854/rxjs-caching-different-http-requests</a></p>

<hr>

<p>There have been multiple discussions on caching http-requests with rxjs, in this question/proposal I want to propose a custom rxjs-operator (non-pure) to provide caching:</p>

<pre><code>const cacheHttp = (cacheKey: string, cacheStorage: any) =&gt; (source: Observable&lt;any&gt;) =&gt; {
  if (!cacheStorage[cacheKey]) {
    cacheStorage[cacheKey] = source.pipe(
      shareReplay(1)
    );
  }
  return cacheStorage[cacheKey];
};
</code></pre>

<p>This operator is not pure, as it modifies one of its arguments (cacheStorage).</p>

<p>This operator could be used like this:</p>

<pre><code>public cachedItems = {};

public getDataForItem$(itemId: string) {
    return this.http.get('/item/' + itemId).pipe(
        cacheHttp(itemId, this.cachedItems),
        shareReplay(1)
    );
}
</code></pre>

<p>The client could then call this multiple times without causing superfluous http-requests:</p>

<pre><code>// the following two subscriptions cause http-requests
this.itemService.getDataForItem('firstItem').subscribe((val) =&gt; console.log(val));
this.itemService.getDataForItem('secondItem').subscribe((val) =&gt; console.log(val));

// all further subscriptions would not cause any additional http-requests
this.itemService.getDataForItem('firstItem').subscribe((val) =&gt; console.log(val));
this.itemService.getDataForItem('secondItem').subscribe((val) =&gt; console.log(val));
this.itemService.getDataForItem('firstItem').subscribe((val) =&gt; console.log(val));
this.itemService.getDataForItem('secondItem').subscribe((val) =&gt; console.log(val));

// this subscription would again cause an http-request:
this.itemService.getDataForItem('thirdItem').subscribe((val) =&gt; console.log(val));
</code></pre>

<p><strong>Now my questions:</strong>
Is this an acceptable approach to solving the ""cache-for-different-requests-problem""? Is there possibly a memory-leak or are there any leaked subscriptions? Is it ok to have side-effects on a provided argument?</p>

<p>Any comments or hints on problems with this custom-operator are very welcome!</p>
","2767626","","2767626","","2019-02-04 15:52:29","2019-02-04 15:52:29","rxjs: caching different http-requests","<rxjs><rxjs6><rxjs-pipeable-operators>","0","2","","","","CC BY-SA 4.0"
"54537025","1","","","2019-02-05 14:49:50","","0","35","<p>This is example code from the docs. I am new to RXJS, so this might be real easy. </p>

<p>Can anyone explain how map operator is returning a single digit integer after operating on an array?</p>

<p>I checked that the return value of scan operator is an array which increases from [0], [0,1], [0,1,2], [0,1,2,3] .... and so on.</p>

<pre><code>// RxJS v6+
import { interval } from 'rxjs';
import { scan, map, distinctUntilChanged } from 'rxjs/operators';

// Accumulate values in an array, emit random values from this array.
const scanObs = interval(1000)
  .pipe(
    scan((a, c) =&gt; [...a, c], []),
    map(r =&gt; r[Math.floor(Math.random() * r.length)]),
    distinctUntilChanged()
  )
  .subscribe(console.log);
</code></pre>
","7425747","","4095444","","2019-02-05 16:16:04","2019-02-07 04:48:04","Map operator returning integer as output with array as input","<javascript><rxjs><rxjs6><rxjs-pipeable-operators>","1","3","","","","CC BY-SA 4.0"
"54538795","1","54548978","","2019-02-05 16:24:38","","6","162","<p><em>RxJs</em> version 5.5 introduced the pipe operator to make it easier to combine <em>RxJs</em> operators and to make tree shaking more efficient for these situations. My question is, should you use the pipe operator if you only intend to use one operator?</p>

<p>Consider the following examples:</p>

<pre><code>someObservable.map(mappingLogicMethod).subscribe(x =&gt; console.log(x));
</code></pre>

<p>vs</p>

<pre><code>someObservable.pipe(map(mappingLogicMethod)).subscribe(x =&gt; console.log(x));
</code></pre>

<p>In situations such as this where you only use one operator what is the most appropriate approach?</p>
","5525739","","","","","2019-02-06 08:20:43","Should I use the pipe operator if I only use one operator?","<javascript><rxjs><reactive-programming><rxjs-pipeable-operators>","1","2","1","","","CC BY-SA 4.0"
"54596819","1","54598007","","2019-02-08 16:44:48","","4","4674","<p><strong>Cancelling a pending HTTP request when changing the page</strong></p>

<p>We have an Angular service that has an expensive HTTP query that 3 different consumers can access. Each consumer can modify this query at any point, make a new request, and all other consumers must be updated with the new data. </p>

<p>Because HTTP subscriptions close immediately on completion, we used the inner observable pattern with behavior subjects to keep the consumers connected (see below).</p>

<p>The problem then, is when the user changes the page, there's no way for the current pending HTTP response to get cancelled.</p>

<p>Normally I don't think it would be too much of an issue to throw away an HTTP request in the background...but beyond it being an expensive operation, I have discovered if the pending response is indeed resolved after the user has returned back to the page, it'll update the consumers with data for an older query. </p>

<p>No bueno.</p>

<h3>Service call</h3>

<pre><code>private dataSubject = new BehaviorSubject&lt;MyData&gt;(...);
public data$ = this.dataSubject.asObservable();
...

getData(): Observable&lt;MyData&gt; {
  if (this.dataSubject)
    return this.data$;
  } else {
    const http$ = this.http.post(...))
      .pipe(map(response =&gt; response as MyData),
        takeUntil(this.unsubscribe$)); // see tearDown() below
    http$.subscribe(
      (availableDevices: MyData) =&gt; {
        this.dataSubject.next(availableDevices);
      }
    );
    return this.data$;
  }
}
</code></pre>

<p>I attempted to create a tear down method in the service that each consumer calls during it's ngDestroy(), but it did not work unless I completed the stream. But at that point, I wasn't unable to restart the stream again when the user returns to the page.</p>

<pre><code>tearDown(): void {
  this.unsubscribe$.next();
  this.unsubscribe$.complete();
  // this.dataSubject.next(null);
  // this.dataSubject.complete(); -- breaks
}
</code></pre>

<p>I'm by no mean an RXJS expert, so feel free to point out if my overall design is wrong. I have a nagging suspicion that I should be using <strong>switchMap()</strong> or <strong>share</strong> to prevent two consumers making the same request; but because this observable pattern is semi-hot, I'm not sure what the right course of action is.  Let alone when it comes to cancelling it.</p>

<p>Any and all help would be appreciated. </p>
","4945784","","4945784","","2019-02-11 20:29:46","2019-02-11 20:29:46","How to cancel a pending request in an inner HTTP observable with RXJS?","<angular><http><rxjs><observable><rxjs-pipeable-operators>","2","3","","","","CC BY-SA 4.0"
"54641065","1","54645663","","2019-02-12 00:20:28","","0","275","<p>I feel like I'm missing something really simple here. I'm trying to create a simple retry for fetch but only the code in the <code>retryWhen</code> is getting executed. I'm using React so i dont have the <code>this.http.get</code> convenience. Perhaps it's an issue with <code>from(/*promise*/)</code>? I was trying to base the retry logic off of  <a href=""https://mobiarch.wordpress.com/2018/06/21/retry-failed-http-calls-in-angular-6/"" rel=""nofollow noreferrer"">this post</a>.</p>

<p>This is what I would expect to see:</p>

<pre><code>Getting data from fetch...
In the retryWhen
In the interval
/* repeat the previous 3 lines 3x times including the Fetch */
Giving up
</code></pre>

<p>Instead I get:</p>

<pre><code>Getting data from fetch...
In the retryWhen
In the interval...
In the interval...
In the interval...
In the interval...
Giving up
</code></pre>

<p>So it is just repeating the code in he retryWhen interval but not repeating the original fetchData call. I'm probably missing something fundamental to my RXJS knowledge.</p>

<p>Here's the test code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const fetchData = new Promise((res, rej) =&gt; {
  console.log(""Getting data from fetch..."");
  rej(); // just fail immediately to test the retry
});

const source = from(fetchData)
  .pipe(
    retryWhen(_ =&gt; {
      console.log(""In the retryWhen"");
      return interval(1000).pipe(
        tap(_ =&gt; console.log(""In the interval..."")),
        flatMap(count =&gt; count == 3 ? throwError(""Giving up"") : of(count))
      )
    }));

source.subscribe(
  result =&gt; console.log(result),
  err =&gt; console.log(err)
);</code></pre>
</div>
</div>
</p>
","2435006","","2435006","","2019-02-12 04:23:19","2019-02-13 08:03:56","rxjs 5.5+ retryWhen not calling source observable?","<rxjs><observable><rxjs6><rxjs-pipeable-operators><retrywhen>","1","0","","","","CC BY-SA 4.0"
"54725546","1","","","2019-02-16 17:05:07","","3","6512","<p>Trying to sort an array of returned Observable.subscribe() data ... new to Angular 7. I'm confused about how to use RXJS methods here, where I need to import what, and how to sort the array of type Event.</p>

<p>Event.ts</p>

<pre><code>import {Venue} from './Venue';

export class Event {
  id: number;
  url: string;
  date: string;
  venue_id: number;
  venue: Venue;
}
</code></pre>

<p>EventResultObj.ts</p>

<pre><code>import {Event} from './Event';

export interface EventResultObj {
  count: number;
  next?: any;
  previous?: any;
  results: Event[];
}
</code></pre>

<p>EventsService.ts:</p>

<pre><code>import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Event } from '../models/Event';
import {Observable} from 'rxjs';
@Injectable({
  providedIn: 'root'
})
export class EventsService {
  eventsUrl = 'http://localhost:4200/assets/tempData/events.json';
  constructor(  private http: HttpClient) { }

  getEvents(): Observable&lt;EventResultObj&gt; {    
    return this.http.get&lt;EventResultObj&gt;(this.eventsUrl).pipe(
          /// CANNOT FIGURE OUT HOW TO GET A SORT FUNCTION TO WORK HERE 
          /// WITH THE OBSERVABLE
    )
  }
}
</code></pre>

<p>EventsList.ts</p>

<pre><code>import {Component, OnInit} from '@angular/core';
import {EventsService} from '../../services/events.service';

@Component({
  selector: 'app-buyer-events-list',
  templateUrl: './buyer-events-list.component.html',
  styleUrls: ['./buyer-events-list.component.scss']
})
export class BuyerEventsListComponent implements OnInit {

  constructor(private eventsService: EventsService) {
  }

  events;

  ngOnInit() {
    this.eventsService.getEvents().subscribe(events =&gt; this.events = events); // OR DO I ADD A PIPE OR MAP HERE AND HOW DO I DO IT?
  }

}
</code></pre>
","1067156","","1067156","","2019-07-04 13:25:40","2019-07-04 13:25:40","Angular 7 Sort Observable.subscribe() by date?","<angular><rxjs><observable><rxjs-pipeable-operators>","4","0","1","","","CC BY-SA 4.0"
"54741794","1","","","2019-02-18 06:47:56","","1","84","<p>Need your help. I am new to Rxjs world and am trying to use distinctUntilChanged() operator to avoid duplicate values received from stream through input box. But I could not see any difference in the output. May be i have miss-understood the explanation by rxjs docs.
Below is the url where I am trying to demonstrate this example. 
It will be great if you could help me with the little explanation and changes where I am suppose to make in the code.</p>

<p><a href=""https://stackblitz.com/edit/angular-z1yhec?file=src%2Fapp%2Frxjs-check%2Frxjs-check.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-z1yhec?file=src%2Fapp%2Frxjs-check%2Frxjs-check.component.ts</a></p>

<pre><code> ngOnInit() {


const inputObs$ =
  fromEvent&lt;any&gt;(this.inputVal.nativeElement, 'keyup').pipe(
    map(res =&gt; res.target.value),
    //tap(char =&gt; console.log(char)),
    debounceTime(1000),
    distinctUntilChanged(),
    tap(char =&gt; console.log(char)),
    map(text =&gt; this.fnGetDbData(text))
  )

inputObs$.subscribe(res =&gt; {
  console.log(res)
  this.dbPlace = res;

});
</code></pre>

<p>}</p>
","9574546","","5394220","","2019-02-18 08:26:29","2019-02-18 08:26:29","Unable to filter the unique value using distinctUntilChanged() from the input stream","<rxjs><rxjs-pipeable-operators>","0","8","","","","CC BY-SA 4.0"
"54851475","1","54853099","","2019-02-24 11:35:41","","0","92","<p>I'm building a notifications component which should show notifications to the user. When multiple notifications gets created at once it should queue them. </p>

<p>Right now it shows the first notification just fine, but after that it triggers 2 notifications at the same time (see current output below). It doesn't wait for the previous notification to show and then hide again before showing the next one.</p>

<p><strong>notifications.api.ts</strong>:</p>

<pre><code>public notifications = new Subject&lt;INotificationEvent&gt;();
public notifications$ = this.notifications.asObservable();
</code></pre>

<p><strong>notifications.component.ts</strong>:</p>

<pre><code>private finished = new Subject();

constructor(private notifications: NotificationsApi) {}

zip(this.notificationsApi.notifications$, this.notificationsApi.notifications, (i, s) =&gt; s).pipe(
  tap(() =&gt; {

    if (!this.isActive) {
      this.finished.next();
    }
  }),
  delayWhen(() =&gt; this.finished),
  delay(450),
  tap((event: INotificationEvent) =&gt; {
    this.notification = event;
    this.isActive = true;
    this.cd.markForCheck();
    console.log(this.notification);
    console.log('showing');
  }),
  delay(this.hideAfter),
  tap(() =&gt; {
    this.isActive = false;
    this.cd.markForCheck();
    console.log('closing');
  }),
  delay(450)
).subscribe(() =&gt; {
  console.log('finishing');
  this.finished.next();
});
</code></pre>

<p><strong>app.component.ts</strong>:</p>

<pre><code>let i = 0;
setInterval(() =&gt; {
  this.notifications.newNotification({message: `${i}`, theme: 'primary'});
  i++;
}, 2000);
</code></pre>

<p><strong>Current output</strong>:</p>

<pre><code>{message: ""0"", theme: ""primary""}
showing
closing
finishing
{message: ""1"", theme: ""primary""}
showing
{message: ""2"", theme: ""primary""}
showing
closing
finishing
{message: ""3"", theme: ""primary""}
showing
{message: ""4"", theme: ""primary""}
showing
closing
closing
finishing
finishing
{message: ""5"", theme: ""primary""}
showing
{message: ""6"", theme: ""primary""}
</code></pre>

<p><strong>Desired output</strong>:</p>

<pre><code>{message: ""0"", theme: ""primary""}
showing
closing
finishing
{message: ""1"", theme: ""primary""}
showing
closing
finishing
{message: ""2"", theme: ""primary""}
showing
closing
finishing
{message: ""3"", theme: ""primary""}
showing
closing
finishing
{message: ""4"", theme: ""primary""}
showing
closing
finishing
{message: ""5"", theme: ""primary""}
showing
closing
finishing
{message: ""6"", theme: ""primary""}
showing
closing
finishing
</code></pre>

<p>How can I fix this?</p>
","4054974","","","","","2019-02-25 09:01:19","Angular/RxJS - Delay stream until previous stream finished","<angular><rxjs><angular-services><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"54856654","1","54856922","","2019-02-24 21:18:01","","9","7929","<p>In an rxjs stream, I'm using <code>distinctUntilChanged</code> with lodash's <code>isEqual</code> to filter out duplicate values. However it <em>appears</em> to not be working as expected. Take the following code snippet</p>

<pre class=""lang-js prettyprint-override""><code>import { isEqual } from 'lodash-es';

let cachedValue: any;

function testFn(observableVal: Observable&lt;any&gt;) {
  return observableVal
    .pipe(
      distinctUntilChanged(isEqual),
      tap(val =&gt; {
        const equal = isEqual(cachedValue, val);
        console.log('""output"":', equal, cachedValue, val);
        cachedValue = val;
      })
    )
}
</code></pre>

<p>In this example, I would expect that <code>const equal</code> inside the <code>tap</code> function would never <code>=== true</code>. I would expect that <code>distinctUntilChanged(isEqual)</code> would filter out any values where <code>isEqual(cachedValue, val) === true</code> --> meaning that <code>const equal === false</code> always. However, console output shows:</p>

<pre><code>""output"": false undefined [ContactList]
""output"": true [ContactList] [ContactList]
""output"": true [ContactList] [ContactList]
""output"": true [ContactList] [ContactList]
</code></pre>

<p>Do I misunderstand something fundamental about how the <code>distinctUntilChanged()</code> operator works? I've posted a simplified example because the actual rxjs stream is very complex, but I wouldn't expect the complexity to make any difference in so far as <code>const equal</code> should always <code>=== false</code> in the <code>tap</code> operator.</p>

<p>I'm just trying to understand what's going on, so any info is appreciated. Thanks!</p>

<h3>Update</h3>

<p>It should be noted that if I change the code to:</p>

<pre class=""lang-js prettyprint-override""><code>function testFn(observableVal: Observable&lt;any&gt;) {
  return observableVal
    .pipe(
      filter(val =&gt; {
        const equal = isEqual(cachedValue, val);
        cachedValue = val;
        return !equal;
      }),
      tap(val =&gt; {
        console.log('""output"":', val);
      })
    )
}
</code></pre>

<p>Then the filtering works as expected. <a href=""https://rxjs-dev.firebaseapp.com/api/operators/distinctUntilChanged"" rel=""noreferrer"">I was under the impression that <code>distinctUntilChanged(isEqual)</code> was equivalent to:</a></p>

<pre><code>filter(val =&gt; {
  const equal = isEqual(cachedValue, val);
  cachedValue = val;
  return !equal;
})
</code></pre>

<p>Am I mistaken / misunderstanding the <a href=""https://rxjs-dev.firebaseapp.com/api/operators/distinctUntilChanged"" rel=""noreferrer""><code>distinctUntilChanged</code></a> operator?</p>
","5490505","","5490505","","2019-02-24 22:37:33","2019-02-24 22:37:33","Rxjs `distinctUntilChanged()` appears to not be working","<rxjs><lodash><rxjs-pipeable-operators>","1","0","1","","","CC BY-SA 4.0"
"54870292","1","","","2019-02-25 16:07:01","","0","60","<p>I have an Angular 7 template which presents an observable <code>book$</code> having an observable <code>translationsAsArray$</code> as member:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;div *ngIf=""book$ | async as book""&gt;
  &lt;dl&gt;
    &lt;div *ngIf=""(book.translationsAsArray$ | async) as translations""&gt;
      &lt;dt&gt;&lt;b class=""text-muted""&gt;TRANSLATIONS&lt;/b&gt;&lt;/dt&gt;
      &lt;dd&gt;
        &lt;ul class=""list-unstyled""&gt;
          &lt;li *ngFor=""let translation of translations""&gt;
            &lt;a routerLink=""/books/{{translation.rid}}""&gt;{{translation.title}}&lt;/a&gt; ({{translation.languageAsString}})
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/dd&gt;
    &lt;/div&gt;
  &lt;/dl&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
</p>

<p><strong>Edit:</strong> The <code>book.translationsAsArray$</code> looks as follows (just for test purposes):</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>get translationsAsArray$(): Observable&lt;Book[]&gt; {
    return timer(50).pipe(
        tap(time =&gt; console.log('translationsAsArray$() subsribed')),
        map(time =&gt; [new Book(this.bookService, 'abc')]));
}</code></pre>
</div>
</div>
</p>

<p>The problem I have is that the <code>translationsAsArray$</code> is being repeatedly re-subscribed.</p>

<p>When I change the solution to invoking <code>subscribe</code> in the component typescript instead of using the <code>async</code> pipe for both <code>book$</code> and <code>translationsAsArray$</code> the problem is solved.</p>

<p>Do you know the reason? Should my template look differently?</p>
","693101","","693101","","2019-02-26 08:00:53","2019-02-26 15:29:11","Observable having observable member in template","<angular><rxjs><rxjs-pipeable-operators>","2","2","","","","CC BY-SA 4.0"
"54888503","1","","","2019-02-26 15:06:28","","1","221","<p>I have a helper function that makes an API call and returns an array of <code>items</code>. Each of these items represents an entity, let's say a <code>User</code>.</p>

<p>Each user has a <code>category_id</code> property which is null by default. I would like to populate this property, for each user, from the result of another helper function that takes a user ID and returns an Observable of the Category object, from which I can extract the ID, to be used as <code>category_id</code> attribute of the user.</p>

<p>I've reached the following (pseudo) code (TypeScript syntax, but the question is applicable to Observable operators in general):</p>

<pre><code>this.backend
    .request(
      'v1/users',
    )
    .pipe(
      map(items =&gt; {
        items.forEach(user =&gt; {
          this.categories.getName(user['id']).subscribe(category =&gt; {
            user['category_id'] = category['id'];
          });
        });
        return items;
      })
    )
</code></pre>

<p>Naturally, this doesn't work because it's mixing Observable operators with Array functions (forEach).</p>
","1364793","","1364793","","2019-02-26 15:12:59","2019-02-26 17:33:19","Observable stream, whose values are enriched from other, ""one-shot"" Observables","<rxjs><observable><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"55039579","1","","","2019-03-07 08:51:39","","0","248","<p>Let's say I have two Observables A and B, and I want to combine them to produce this behaviour: the subscription combination returns only if A fires when a B has already been fired. It differs from the zip because I don't want any return if A has already been fired and then a B fires. In other words: ignores A until B fires then return on the next A, then ignore any other A until B fires ... so on</p>
","5590857","","7436489","","2019-03-07 10:38:50","2019-03-07 10:40:50","Rxjs zip-like operator which returns only when observable fires in specific order","<rxjs><rxjs6><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"55068855","1","55069918","","2019-03-08 18:17:50","","-1","44","<p>I am using ngrx and have an @Effect hooked up to a LOAD_CONTRACT action, which then makes 3 HTTP calls to get data. Private variables are used to store the data from each GET, so that at the end the LoadContractSuccessAction can be called with a payload containing the 3 retrieved objects.</p>

<p>My code below works fine, and the error handling works as well... but I feel like there may be a neater or better way of structuring things.</p>

<p>I don't know if all the nesting is necessary, or if things could be flattened out in some way. I also am not sure if using switchMap is the best operator.</p>

<p>Could someone with better knowledge of ngrx best practices comment on how the below could be improved/simplified...?</p>

<pre class=""lang-js prettyprint-override""><code>private clientContractIds: IClientContractIds;
private contract: Contract;
private contractSummaryMonths: ContractSummaryMonth[];
private contractSummaryTotals: ContractSummaryTotals;

// Loads a contract and its summary months and totals.
@Effect()
loadContract$ = this.actions$.pipe(
  ofType(ContractActionTypes.LOAD_CONTRACT),
    map((action: IActionWithPayload&lt;IClientContractIds&gt;) =&gt; {
      this.clientContractIds = {
        client_id: action.payload.client_id,
        contract_id: action.payload.contract_id
      };
    }),

    // Get the contract.
    switchMap(() =&gt; {
      return this.contractService.getContract$(this.clientContractIds).pipe(
        map(contract =&gt; (this.contract = contract)),
        catchError(error =&gt; throwError(error)),

        // Get the summary months.
        switchMap(() =&gt; {
          return this.contractService
            .getContractSummaryMonths$(this.clientContractIds)
            .pipe(
              map(
                contractSummaryMonths =&gt;
                  (this.contractSummaryMonths = contractSummaryMonths)
              ),
              catchError(error =&gt; throwError(error))
            );
        }),

        // Get the summary totals.
        switchMap(() =&gt; {
          return this.contractService
            .getContractSummaryTotals$(this.clientContractIds)
            .pipe(
              map(
                contractSummaryTotals =&gt;
                  (this.contractSummaryTotals = contractSummaryTotals)
              ),
              catchError(error =&gt; throwError(error))
            );
        }),

        // Call the success action with the payload objects.
        switchMap(() =&gt; {
          return of(
            new LoadContractSuccessAction({
              contract: this.contract,
              contractSummaryMonths: this.contractSummaryMonths,
              contractSummryTotals: this.contractSummaryTotals
            })
          );
        })
    );
  }),
  catchError(error =&gt; {
    return of(new LoadContractFailAction(error));
  })
);
</code></pre>
","1708078","","","","","2019-03-08 20:32:09","What is the cleanest way of structuring multiple HTTP calls within one @Effect using ngrx","<angular><typescript><rxjs><ngrx><rxjs-pipeable-operators>","2","0","","2019-03-09 14:30:02","","CC BY-SA 4.0"
"55178875","1","55180037","","2019-03-15 08:59:27","","1","95","<p>I'm trying to generate overs for a cricket match simulation with values as follows:</p>

<p>Overs -> 0 - 19 (total 20 overs)<br>
Balls -> 1 - 6 (total 120, each over has 6 balls)</p>

<p>Hence the sequence that has to be generated would be something like <code>0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 1.1, 1.2, 1.3, ....., 19.4, 19.5, 19.6</code></p>

<p>I can easily achieve this by iterating, using 2 nested loops, but since I am using angular with RxJS, I wanted to do this the reactive way. I came up with the following code which should work AFAIK:</p>

<pre><code>import { range } from 'rxjs';
import { map, combineAll } from 'rxjs/operators';

let overs = range(0, 20);

let balls = range(1, 6);

let ob = overs.pipe(
  map((over) =&gt; balls.pipe(
    map((ball) =&gt; `${over}.${ball}`)
  ))
).pipe(combineAll())

ob.subscribe((val) =&gt; console.log(val));
</code></pre>

<p>But the problem with this is, it is missing a lot of values. I get the following output:</p>

<pre><code>[ '0.6',
  '1.6',
  '2.6',
  '3.6',
  '4.6',
  '5.6',
  '6.6',
  '7.6',
  '8.6',
  '9.6',
  '10.6',
  '11.6',
  '12.6',
  '13.6',
  '14.6',
  '15.6',
  '16.6',
  '17.6',
  '18.6',
  '19.1' ]
[ '0.6',
  '1.6',
  '2.6',
  '3.6',
  '4.6',
  '5.6',
  '6.6',
  '7.6',
  '8.6',
  '9.6',
  '10.6',
  '11.6',
  '12.6',
  '13.6',
  '14.6',
  '15.6',
  '16.6',
  '17.6',
  '18.6',
  '19.2' ]
[ '0.6',
  '1.6',
  '2.6',
  '3.6',
  '4.6',
  '5.6',
  '6.6',
  '7.6',
  '8.6',
  '9.6',
  '10.6',
  '11.6',
  '12.6',
  '13.6',
  '14.6',
  '15.6',
  '16.6',
  '17.6',
  '18.6',
  '19.3' ]
[ '0.6',
  '1.6',
  '2.6',
  '3.6',
  '4.6',
  '5.6',
  '6.6',
  '7.6',
  '8.6',
  '9.6',
  '10.6',
  '11.6',
  '12.6',
  '13.6',
  '14.6',
  '15.6',
  '16.6',
  '17.6',
  '18.6',
  '19.4' ]
[ '0.6',
  '1.6',
  '2.6',
  '3.6',
  '4.6',
  '5.6',
  '6.6',
  '7.6',
  '8.6',
  '9.6',
  '10.6',
  '11.6',
  '12.6',
  '13.6',
  '14.6',
  '15.6',
  '16.6',
  '17.6',
  '18.6',
  '19.5' ]
[ '0.6',
  '1.6',
  '2.6',
  '3.6',
  '4.6',
  '5.6',
  '6.6',
  '7.6',
  '8.6',
  '9.6',
  '10.6',
  '11.6',
  '12.6',
  '13.6',
  '14.6',
  '15.6',
  '16.6',
  '17.6',
  '18.6',
  '19.6' ]
</code></pre>

<p>As one can observe, all overs are generated (0-19) but we are getting only the <code>.6</code> values with each. Only the last over, i.e. <code>19th</code> is having unique values <code>19.1, 19.2...</code></p>

<p>What am I missing in this code?</p>

<p>Also, if it helps here's the repl for the above code in case you want to try and experiment with it in browser: <a href=""https://repl.it/@ishankhare07/cricket-overs"" rel=""nofollow noreferrer"">https://repl.it/@ishankhare07/cricket-overs</a></p>
","2972348","","","","","2019-03-15 10:57:35","RxJS missing values when using combineAll with 2 observables","<typescript><rxjs><observable><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"55268729","1","","","2019-03-20 19:24:50","","0","59","<p>Simply put, I constantly hit roadblocks with RXJS because almost every example relies on a constant stream of data whereas I'm making HTTP requests that are singular in nature.</p>

<p>My common scenario is as such: I have a service that makes API calls and updates the necessary consumers. In my head, it's like simple event emitting. The subscribers connect and wait for the event - once they get it, they go off and do their own thing separately. </p>

<p>The problem, as I'm sure you're aware, is that HTTP subscriptions terminate immediately upon completion and to ""connect"" triggers it immediately. It's a concept of RXJS that I still struggle to wrap my head around.</p>

<p>So when you throw in concurrent calls to the method, consumers relying on other consumers, forkjoins and asynchronous hell - I've tried all sorts of abominations involving Subjects, replays, shared maps. I've ultimately settled on something like so:</p>

<pre><code>myBehaviorSubject = new BehaviorSubject&lt;Result&gt;(null);
myBehaviorSubject$ = myBehaviorSubject.asObservable()
...
getData(params): Observable&lt;Result[]&gt; {
      const http$ = this.httpClient
        .get('blah', {params})
        .pipe(map(response =&gt; response as Result[]));

      http$.subscribe(result: Result =&gt; {
         myBehaviorSubject.next(result);
      });

      return myBehaviorSubject$;
    }
</code></pre>

<p>It feels...<em>wrong</em>. I know things like mergeMap handle internal subscriptions similarly and higher order observables aren't anti-pattern, but I can't help but think I'm just doing it wrong. </p>

<p>Is internal subscriptions really the way to do this? Are there ways too keep consumers waiting for HTTP requests without making redundant calls to the server? </p>

<p>Can anyone shed some light on this matter? </p>
","4945784","","","","","2019-03-20 19:58:28","Is there an RXJS standard for creating/handling HTTP streams?","<angular><http><rxjs><observable><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"55292196","1","","","2019-03-22 02:49:43","","1","194","<p>RsJs moved from a ""dot"" to a ""pipe"" abstraction for its operators for <a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md#why"" rel=""nofollow noreferrer"">these four reasons</a>. Would those reasons have also been addressed if the operators were aliased with symbols? So instead of adding a property named <code>'myOp'</code> to the prototype, what if the name were a symbol like <code>Symbol('myOp')</code>? Then it could be invoked as </p>

<pre class=""lang-js prettyprint-override""><code>var MyOp = require('my-op');
var o = getObservable();
var x = o[MyOp]();
</code></pre>

<p>Taking the justifications one-by-one:</p>

<blockquote>
  <p>Any library that imports a patch operator will augment the Observable.prototype for all consumers of that library, creating blind dependencies. If the library removes their usage, they unknowingly break everyone else. With pipeables, you have to import the operators you need into each file you use them in.</p>
</blockquote>

<p>The symbol would only be attached to the prototype when the module is loaded via <code>require('myOp')</code> and wouldn't collide because it's a symbol and wouldn't be removed.</p>

<blockquote>
  <p>Operators patched directly onto the prototype are not ""tree-shakeable"" by tools like rollup or webpack. Pipeable operators will be as they are just functions pulled in from modules directly.</p>
</blockquote>

<p>Symbols added to the prototype would not need to be shaken because they're imported one-by-one as needed; If the symbol is present on the prototype then it's being used by whoever imported it. </p>

<blockquote>
  <p>Unused operators that are being imported in apps cannot be detected reliably by any sort of build tooling or lint rule. That means that you might import scan, but stop using it, and it's still being added to your output bundle. With pipeable operators, if you're not using it, a lint rule can pick it up for you.</p>
</blockquote>

<p>Symbols that are loaded but not used are easy to detect; If <code>var MyOp = require('my-op')</code> and <code>MyOp</code> is not used, then the linter could ask that the package be removed and so the op would never be attached as the module is never loaded. </p>

<blockquote>
  <p>Functional composition is awesome. Building your own custom operators becomes much, much easier, and now they work and look just like all other operators from rxjs. You don't need to extend Observable or override lift anymore.</p>
</blockquote>

<p>The module <code>my-op</code> would declare the operator like so:</p>

<pre class=""lang-js prettyprint-override""><code>var MyOp = Symbol('MyOp');
Observable.prototype[MyOp] = function() { ... }
module.exports = MyOp
</code></pre>
","2303356","","","","","2019-03-22 02:49:43","RxJS ""dot"" vs ""pipe"" abstraction","<javascript><angular><rxjs><rxjs5><rxjs-pipeable-operators>","0","11","","","","CC BY-SA 4.0"
"55295252","1","","","2019-03-22 08:04:22","","0","45","<pre><code>export class LoginResponse {
value: string;
expiration: string;
tokenType: string;
refreshToken: {
    value: string;
    expiration: string;
};
scope: [];
additionalInformation: {};
expiresIn: string;
expired: boolean;
</code></pre>

<p>}</p>

<pre><code>export class LoginErrorResponse {
code: number;
error: string;
message: string;
sucess: boolean;
</code></pre>

<p>}</p>

<pre><code>return this.httpClient.post(url,body,headers).pipe(map(res=&gt;&lt;LoginResponse&gt;res),map(res=&gt;&lt;LoginErrorResponse&gt;res));
</code></pre>

<p>Error: Conversion of type 'LoginResponse' to type 'LoginErrorResponse' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
  Property 'code' is missing in type 'LoginResponse'</p>

<p>I can get either of the responses from server.I want to typecast the response based on the server response and should return observable of that.</p>
","8331045","","1000551","","2019-03-22 08:06:37","2019-03-22 08:21:25","Typecast multiple responses based on the response from server in angular","<angular><angular-httpclient><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"55444071","1","","","2019-03-31 18:27:34","","1","463","<p>Conditional adding debounce time to a stream based on value from other stream</p>

<pre><code>const configuration$ = new Subject().asObservable();
const animation$ = new BehaviorSubject(false).asObservable;
</code></pre>

<p>the above comes from some service</p>

<pre><code>configuration$.pipe(debounceTime(CONSTANTS.DEBOUNCE),sample(interval(CONSTANTS.SAMPLE)));

configuration.subscribe(data=&gt; {
   // do the stuff; 
});


</code></pre>

<p>If animation$ has true value then <code>debounceTime</code>, <code>sample</code> should be skipped.</p>

<p>How can I extract value from animation$ and apply if else logic.</p>

<p>If only I can do</p>

<pre><code> configuration$.pipe(
    animation$ ? 
    pipe(debounceTime(CONSTANTS.DEBOUNCE),sample(interval(CONSTANTS.SAMPLE))) :
    of
);
</code></pre>
","4404499","","4404499","","2019-03-31 19:39:25","2019-03-31 19:39:25","RxJs Conditional Debounce and Sampling","<angular><rxjs><rxjs-pipeable-operators>","1","3","","","","CC BY-SA 4.0"
"55446753","1","","","2019-04-01 00:35:53","","0","565","<p>I am trying to create my own click, hold and drag events using Rxjs and the mousedown, mouseup and mousemove events.  My attempts use a number of streams that begin with a mousedown event, each with a takeUntil that listens for emissions from the other streams. Basically once one of the streams has ""claimed"" the action (i.e. passed all the requirements and emitted a value) the other observables should complete with no emissions.</p>

<p>I have looked at other answers and thought it might have something to do with the timer running async but it happens between streams that do not rely the timer e.g. drag and click.  I have been playing around in codesandbox.io using rxjs v6. </p>

<p>The takeUntil's also have to sit on the inner observables as I don't want the outer observables to run once and complete.</p>

<p>The code is shown below:</p>

<pre><code>const mouse_Down$ = fromEvent(document, ""mousedown"").pipe(
  tap(event =&gt; event.preventDefault())
);

const mouse_Up$ = fromEvent(document, ""mouseup"").pipe(
  tap(event =&gt; event.preventDefault())
);

const mouse_Move$ = fromEvent(document, ""mousemove"");

const mouse_drag$ = mouse_Down$
  .pipe(
    mergeMap(mouseDownEvent =&gt;
      mouse_Move$.pipe(takeUntil(merge(mouse_Up$, mouse_Hold$, mouse_drag$)))
    )
  ).subscribe(event =&gt; console.log(""Drag""));

const mouse_Hold$ = mouse_Down$
  .pipe(
    mergeMap(mouseDownEvent =&gt;
      timer(1000).pipe(takeUntil(merge(mouse_drag$, mouse_Click$)))
    )
  ).subscribe(event =&gt; console.log(""Hold""));

const mouse_Click$ = mouse_Down$
  .pipe(
    mergeMap(mouseDownEvent =&gt;
      mouse_Up$.pipe(takeUntil(mouse_drag$, mouse_Hold$))
    )
  ).subscribe(event =&gt; console.log(""Click""));
</code></pre>

<p><strong>Expected behaviour:</strong>
If the user moves the mouse within 1s of the mousedown event the <code>mouse_drag$</code> stream should begin emitting and the <code>mouse_Click$/mouse_Hold$</code>'s inner observables should complete (thanks to the <code>takeUntil(mouse_drag$)</code> without emitting and await the next <code>mouse_down$</code> emmission. </p>

<p>If the mouse button remains down for more than 1s without moving the <code>mouse_Hold$</code> should emit and <code>mouse_drag$/mouse_click$</code>'s inner observable should complete (thanks to the <code>takeUntil(mouse_Hold$)</code> without emitting and await the next <code>mouse_down$</code> emmission.</p>

<p><strong>Actual Behaviour:</strong> Currently the <code>mouse_Drag$</code> will emit, the <code>mouse_Hold$</code> will emit after one second and the <code>mouse_Click$</code> will emit when the button is released. </p>

<p>My question is why doesn't the emitting <code>mouse_Drag$</code> stream cause the <code>mouse_Hold$</code> and <code>mouse_Click$</code>'s inner observable to complete without emitting?</p>
","9140532","","9140532","","2019-04-02 01:39:24","2019-05-08 13:36:29","takeUntil failing to prevent emissions from observable","<rxjs><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"55481929","1","","","2019-04-02 19:08:11","","0","36","<p>I have been struggling with the following issue for quite some time now. </p>

<pre><code>...

export interface HotelRoomType {
  foo: string;
  boo: number;
  rplans: Array&lt;RatePlan&gt;
}

export interface RatePlan {
  prop1: string;
  prop2: boolean;
  prop3: number 
}

doc1: HotelRoomType;
doc2: HotelRoomType;
doc3: HotelRoomType;

ratePlansArr$: Observable&lt;RatePlan[]&gt;;
...

</code></pre>

<p>doc1, doc2 and doc3 are firestore documents of a </p>

<pre><code>/Company/CompanyId/Room_Types
</code></pre>

<p>sub-collection.</p>

<p>The first document is the following </p>

<pre><code>doc1 = {
  foo: 'a',
  boo: 1,
  rplans: [
    {
      prop1: 'xxx',
      prop2: true,
      prop3: 512.50
    },
    { 
      prop1: 'yyy',
      prop2: false,
      prop3: 101  
    }
  ]
}

</code></pre>

<p>the second one:</p>

<pre><code>doc2 = {
  foo: 'b',
  boo: 9,
  rplans: [
    {
      prop1: 'ooo',
      prop2: false,
      prop3: 90
    },
    { 
      prop1: 'mmm',
      prop2: false,
      prop3: 120.80  
    },
    { 
      prop1: 'nnn',
      prop2: true,
      prop3: 80  
    },
  ]
}
</code></pre>

<p>and a third one following the same pattern</p>

<p>The following method, (using AngularFire) returns an observable of RatePlan Array</p>

<pre><code>public getAllRatePlansForCompany(companyId: string): Observable&lt;RatePlan[]&gt; {
    return this._fsSrvc.colWithIds$&lt;RatePlan[]&gt;('Company/' + companyId + '/Room_Types/')
      .pipe(
        map((res, idx) =&gt; res = res[idx].Rate_plans)
      );
  }

</code></pre>

<p>The method is called like this:</p>

<pre><code>this.ratePlansArr$ = this.inventoryService.getAllRatePlansForCompany(this.company.id);
this.ratePlansArr$.subscribe();
</code></pre>

<p>However, when executed, it only returns the rplans of the first document (doc1).</p>

<p>How shall it be modified to return an Array containing the rplans of all 3 documents ?</p>

<p>Thank you</p>
","9022137","","","","","2019-04-27 06:45:33","map operator does not return the correct results","<angular><rxjs-pipeable-operators>","2","3","","","","CC BY-SA 4.0"
"55586924","1","","","2019-04-09 07:06:23","","0","46","<p>I'm looking at the convert guide available <a href=""https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/v6/migration.md"" rel=""nofollow noreferrer"">here</a> and I'm trying to convert merge used in pipe following this guide, but it is not working as it was before the change. </p>

<p>Here is my piece of code I'm using to learn new merge: </p>

<pre class=""lang-js prettyprint-override""><code>    this.form.valueChanges.pipe(
      startWith(1),
      merge(this.form.statusChanges),
      merge(this.click$),
      map(() =&gt; this.form.value.query),
      filter(() =&gt; this.form.valid)
    )
    .subscribe(this.search);
</code></pre>

<pre class=""lang-js prettyprint-override""><code>  private search = (query: string) =&gt; {
    this.tvs.search(query).subscribe(shows =&gt; this.shows = shows);
  }
</code></pre>

<p>I've tried to do something like that: </p>

<pre class=""lang-js prettyprint-override""><code>    merge(
    this.form.valueChanges.pipe(
    startWith(1),
      map(() =&gt; this.form.value.query),
      debounceTime(500),
      tap(() =&gt; this.form.controls.query.errors &amp;&amp; console.log(this.form.controls.query.errors)),
      tap(() =&gt; this.form.status &amp;&amp; console.log(this.form.status)),
      filter(() =&gt; this.form.valid)
    ), this.form.statusChanges, this.click$)
    .subscribe(this.search);
</code></pre>

<p>But in network tab in chrome I'm getting the call to api with query equal to status of the form (VALID or INVALID). What is the proper way to convert this?</p>
","2846167","","","","","2019-04-09 07:57:56","How should I convert merge used in pipe in v5 to v6","<angular><typescript><rxjs5><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"55608806","1","55608987","","2019-04-10 09:10:51","","1","2829","<p>I have an array of objects like: </p>

<pre><code>const data: any[] = [
     { x: 1, y: 1 },
     { x: 2, y: 2 },
     { x: 3, y: 4 },
     { x: 4, y: 6 }
];

// get x as array
from(d).pipe(map(m =&gt; m.x), toArray()).subscribe(x =&gt; ...);
</code></pre>

<p>And would like to map it to something like below to use it in <code>Plotly</code></p>

<pre><code>{
  x: [1,2,3,4],
  y: [1,2,4,6]
}
</code></pre>

<p>Of course, I could duplicate the pipe above to get y values, but this would be different subscriptions. Is there another way to solve this?</p>
","1171811","","","","","2019-04-10 09:26:18","How to map multiple properties to arrays in Angular 6?","<angular><rxjs><rxjs-pipeable-operators>","3","0","","","","CC BY-SA 4.0"
"55610096","1","55610955","","2019-04-10 10:18:08","","0","82","<p>I'm having problems with error handlers. I'm trying to create a generic retryPipeline in my service: when the call fails, it retry 3 times before throw and error. So far so good. It works if I put the code inside the method, like this :</p>

<pre><code>  getMun(id_del: number, id_muno: number): Observable&lt;Mun&gt; {

    let urlAPIMun = urlAPI;
    urlAPIMun += '/' + id_del + '/mun' + '/' + id_mun + '?flag_geometry=true';
    return this._http.get&lt;Mun&gt;(urlAPIMunicipios).pipe(
     //   tap(() =&gt; console.log('HTTP request executed')),
      retryWhen(errors =&gt; errors.pipe(
        // Concat map to keep the errors in order and make sure they
        // aren't executed in parallel
        concatMap((e: HttpErrorResponse, i) =&gt;
          // Executes a conditional Observable depending on the result
          // of the first argument
          iif(
            () =&gt; i &gt;= 3,
            // If the condition is true we throw the error (the last error)
            throwError(e.error.errores),
            // Otherwise we pipe this back into our stream and delay the retry
            of(e).pipe(delay(5000))
          )
        ))));
  }
</code></pre>

<p>I'm trying to extrac the code inside pipe to declare a const and then call the const in my service call:</p>

<pre><code>const RETRYPIPELINE =
  retryWhen((errors) =&gt;
    errors.pipe(
      concatMap((e: HttpErrorResponse, i) =&gt;
          () =&gt; i &gt;= 3,
          throwError(e.error.errores),
          of(e).pipe(delay(5000))
        )
      )
    )
  );

return this._http.get&lt;Mun&gt;(urlAPIMunicipios).pipe(RETRYPIPELINE);
</code></pre>

<p>But I'm receiving this error: </p>

<blockquote>
  <p>error TS2322: Type 'Observable&lt;{}>' is not assignable to type 'Observable'.
        Type '{}' is missing the following properties from type 'Mun': id_mun, id_del, den</p>
</blockquote>

<p>Is there any way to create a generic const, that can be able to asign to any method, although the method returns a typed value? Thanks in advance</p>
","7114164","","7114164","","2019-04-10 10:41:40","2019-07-17 08:57:27","Create generic type on const angular","<angular><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"55745046","1","55745289","","2019-04-18 11:27:29","","-5","438","<p>Hi I have an angular 5 application. I have a service method that returns undefined . 
here is what i am trying to do . i have a function named cloneFlight. i am making a call to flightsService.getCampaignsToClone(this.flight) which is returning value undefined .</p>

<pre><code>cloneFlight() {
    combineLatest(
      this.translateService.get('CONFIRM.CLONE_FLIGHT', { item: this.flight.name}),
      this.flightsService.getCampaignsToClone(this.flight)
    ).subscribe( ([header, campaigns]) =&gt; { 
      this.cloneFlightService.openModal(header,this.flight,campaigns);
    });
  }
</code></pre>

<p>the code for getCampaignsToClone  is as follows.</p>

<pre><code> getCampaignsToClone(flight: Flight){

    let campaignStatusesIdArr: string[];
    let campaigns: CampaignUnpaginated[] ; 
    this.campaignService.getStatuses().subscribe(
      (data) =&gt; { 
        campaignStatusesIdArr = data.filter( x =&gt; x.code === (CampaignStatusCode.IN_PROGRESS || 
          CampaignStatusCode.READY)).map( y =&gt; y.id);
      }
    );
    let accountId: string = flight.campaign.account.id;    

    this.campaignService.getUnpaginatedCampaigns(
      {
        statuses: campaignStatusesIdArr,
        accounts: accountId
      }
    ).subscribe(data=&gt;{
      console.log(data);
      campaigns = data;
    });
    return Observable.of(campaigns);
  }
</code></pre>

<p>in getCampaignsToClone i am making an http call  campaignService.getStatuses() that returns Observable . then filtering out some of them and then i make a call to 
getUnpaginatedCampaigns which is another http call. anyidea what is the best way to write this code so that the method wont return undefined. I think i am probably not utilising the rxjs operators. could someone help me to figure it out . </p>

<p>thank you so much</p>
","11119821","","","","","2019-04-18 11:42:17","typescript method returning undefined?","<typescript><rxjs5><rxjs-pipeable-operators>","1","3","","","","CC BY-SA 4.0"
"55787655","1","56002219","","2019-04-21 23:33:48","","0","211","<p>I have request to google drive using gapi:</p>

<pre><code>getFolders(folderId: string): Observable&lt;{ id: string, name: string }[]&gt; {
    const promise = gapi.client.drive.files.list({
      fields: 'incompleteSearch,nextPageToken,files(id,name)',
      q: `'${folderId}' in parents`,
    }).then((res) =&gt; {
      return JSON.parse(res.result.files);
    });
    return from(promise);
  }
</code></pre>

<p>then I try to show this data in component:
.ts file <code>ngOnInit</code>:</p>

<pre><code>this.data$ = this.googleDriveService.getFolders(rootFolderId)
        .pipe(
          map((files) =&gt; {
            debugger;
            return files.map(file =&gt; ({ id: file.id, header: file.name, content: '', imageUrl: this.defaultImageUrl }));
          }),
          takeUntil(this.destroy$),
        );
</code></pre>

<p>and html file:</p>

<pre><code>  &lt;mat-grid-tile *ngFor=""let elem of (data$ | async)""&gt;
    &lt;app-card (input)=""returnCartItem(elem)"" (click)=""goto(elem.header, elem.id)""&gt;&lt;/app-card&gt;
  &lt;/mat-grid-tile&gt;
</code></pre>

<p>The problem is that <code>data$</code> always empty. I added <code>debugger</code> to <code>map</code> to check maybe something wrong with there, but it never goes in <code>map</code> function. From response, I get 2 files, so <code>res.result.files</code> isn't empty;</p>
","8054597","","8054597","","2019-05-07 08:13:44","2019-05-07 08:13:44","GAPI and Angular 7 issue","<angular><typescript><rxjs><rxjs6><rxjs-pipeable-operators>","4","4","","","","CC BY-SA 4.0"
"55824599","1","55825257","","2019-04-24 07:32:33","","0","449","<p>In my current project I have an observable returning values and I have to update my local variable according to the value returned by the observable.</p>

<p>I see two ways of doing this, either by directly subscribing to my observable, or by using pipable operator.</p>

<p>According to your experience/knowledge, what is the best practice ?</p>

<p>1st approach (directly subscribing):</p>

<pre><code>this.myObservable$.subscribe(value=&gt; {
  this.myValue = value;
});
</code></pre>

<p>2nd approach (using pipable operator):</p>

<pre><code>this.myObservable$.pipe(
    tap(value=&gt; this.myValue = value)
  ).subscribe();
</code></pre>
","10514369","","3001761","","2019-04-24 09:00:09","2019-04-24 09:00:09","Observable best practice","<angular><rxjs><rxjs-pipeable-operators>","2","4","","","","CC BY-SA 4.0"
"55986843","1","55988275","","2019-05-04 21:12:57","","0","118","<p>I'm working on a username search input that fires after a debounceTime(). I also filter out values. I want to trigger some side effects if values are filtered (such as setting an error message and stopping loaders).</p>

<p>I'm achieving this right now by using tap() and checking the same predicate that I later check in a filter() function. I feel this is bad/there is a more proper way to achieve this.</p>

<pre><code>private setUserSearchObservable() {
    this.userSearch = userSearch$.pipe(
      tap(() =&gt; this.loading = true),
      debounceTime(500),
      this.filterValuesWithErrorMessages(),
      ......
    );
}

private filterValuesWithErrorMessages() {
    return pipe(
      tap((val: string) =&gt; { if (this.usernamesMatch(val)) { this.errorMessage = 'You will be added to the frame automatically'; this.loading = false; }}),
      tap((val: string) =&gt; { if (this.usernameInArray(val)) { this.errorMessage = 'User is already added'; this.loading = false; }}),
      tap((val: string) =&gt; { if (val.length &lt; 2) { this.errorMessage = ''; this.loading = false; }}),
      filter((val: string) =&gt; (val.length &gt;= 2 &amp;&amp; !this.usernamesMatch(val) &amp;&amp; !this.usernameInArray(val))),
    );
}
</code></pre>

<p>As you can see, I explicitly check the exact same conditionals using tap() right before using them on filter(). Is there an operator/different pattern that will allow me to achieve this in a more concise way?</p>
","7892913","","","","","2019-05-05 02:06:43","Triggering side effects when a value is filtered using filter() operator","<rxjs><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"56018885","1","56018985","","2019-05-07 08:53:07","","9","5731","<p>Having the following (just a quick example):</p>

<pre><code>observable.pipe(map( s =&gt; s.anything ))
          .pipe(filter(t =&gt; t &gt; 5))
          .pipe(map( t =&gt; t+5))
          .subscribe( XXX )
</code></pre>

<p>Why should I use 1 pipe instead?</p>

<pre><code>    observable.pipe(
                   map( s =&gt; s.anything ), filter(t =&gt; t &gt; 5),map( t =&gt; t+5))
              .subscribe( XXX )
</code></pre>

<p>To me, the code is more nice and readable in the first case. But no idea if that affects the behaviour anyway.</p>
","2992476","","10959940","","2020-11-09 10:43:29","2020-12-23 16:18:44","RxJS / Angular Observables use 1 or multiple pipes?","<angular><rxjs><observable><rxjs-pipeable-operators>","1","1","1","","","CC BY-SA 4.0"
"56038459","1","56045075","","2019-05-08 10:20:10","","0","253","<p>I am trying to integrate <code>ngrx</code> caching, using <code>rxjs</code> <code>withLatestFrom</code> operator. But getting an error as:</p>

<pre><code>You provided 'undefined' where a stream was expected.
You can provide an Observable, Promise, Array, or Iterable.
</code></pre>

<p>Anyone correct my code please?</p>

<p>here is my code :</p>

<pre class=""lang-js prettyprint-override""><code>@Effect()
EffLoadCourse = this.actions.pipe(
  ofType(LoadCourse.TYPE),
  withLatestFrom(
    this.store.pipe(select(subscribes.getCourses)), //getting it from store
    (action: LoadCourse, courses: ModelCourse[]) =&gt; {
      // console.log('action is ', action, 'courses is', courses)
      return courses;
    }
  ),
  mergeMap((courses: ModelCourse[]) =&gt; {

    if (courses) { //if courses available just return it
      map((courses: ModelCourse[]) =&gt; (new LoadCourseSuccess(courses))),
        catchError(err =&gt; of(new LoadCourseFail(err)))
      return;
    }
    //only return on courses unavailability
    return this.courseService.getCourse().pipe(
      map((courses: ModelCourse[]) =&gt; (new LoadCourseSuccess(courses))),
      catchError(err =&gt; of(new LoadCourseFail(err)))
    )
  })
)

</code></pre>
","2024080","","6921829","","2019-05-09 00:27:45","2019-05-09 00:27:45","`withLatestFrom` - throw error on implementing with observable","<rxjs><ngrx><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"56042704","1","56042781","","2019-05-08 14:07:03","","0","1767","<p>I want to pass URL besides getting its response data in next pipable operator of RxJS. What do you think is the smartest way to achieve this?
Thanks in advance.</p>

<p>Here is an example.
<a href=""https://stackblitz.com/edit/angular-rxjs-passing-data-to-next-operator-question"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-rxjs-passing-data-to-next-operator-question</a></p>

<p>I tried some operators, but I couldn't find right one.
(Actually, I don't even know why passing function which returns observable to <code>mergeMap</code> results in getting data as parameter of function in next operator...)</p>

<pre><code>from([
  'https://jsonplaceholder.typicode.com/posts',
  'https://jsonplaceholder.typicode.com/comments',
  'https://jsonplaceholder.typicode.com/albums',
])
  .pipe(
    mergeMap(url =&gt; this.getData(url)),
    tap(posts =&gt; console.log(posts[0])), // I want to get url too here!!
  ).subscribe();
</code></pre>

<p>I expect to get url and its response data as pair in pipable operator.</p>
","11470377","","11470377","","2019-05-09 01:06:58","2020-05-06 14:11:48","Best way to pass data between RxJS pipable operators?","<angular><rxjs><rxjs-pipeable-operators>","3","0","","","","CC BY-SA 4.0"
"56052824","1","","","2019-05-09 05:36:47","","1","241","<p>I'm trying to pull the last emitted value from an observable. But rxJS have two operator <a href=""https://rxjs.dev/api/operators/last"" rel=""nofollow noreferrer"">last()</a>  and <a href=""https://rxjs.dev/api/operators/publishLast"" rel=""nofollow noreferrer"">publishLast()</a>.</p>

<p>What is the difference between last and publishLast operator in rxJS?</p>
","1116399","","","","","2019-05-09 08:15:30","What is the difference between last and publishLast operator in rxJS?","<rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"56052960","1","","","2019-05-09 05:51:49","","1","88","<p>I have a network call where it's likely that api will throw an 400 error. I want to handle this gracefully.</p>

<p>Right now I do it like below - </p>

<pre><code>   private fetchStatus(objectId: string): Observable&lt;string&gt; {
      return Observable.create((observer) =&gt; {
        this.http.get('/api/data-one').subscribe(response =&gt; {
          if (response.result === 'SUCCESS') {
              observer.next('SUCCESS');
          } else {
              observer.next('DENIED');
          }
          observer.complete();
        },
        error =&gt; {
          observer.next('DENIED');
          observer.complete();
        });
      });
  }
</code></pre>

<p><strong>But I will prefer doing it with Observable.map operator.</strong> The problem with Observable.map is when api throws a 400 the entire observable goes in error mode. </p>

<p>I want to prevent this because this get call is being used in a forkJoin with other calls. Failure of this would mean failure of the entire forkJoin below</p>

<pre><code>forkJoin([
        this.http.get('/api/route-2'),
        this.http.get('/api/route-1'),
        this.fetchStatus('abc')
      ]).subscribe((responseCollection: any) =&gt; {
        observer.next({
          result1: responseCollection[0],
          result2: responseCollection[1],
          result3: responseCollection[2]
        });
        observer.complete();
      }, error =&gt; observer.error(error));
</code></pre>
","1078923","","","","","2019-05-09 06:14:53","RxJS do not throw error while mapping even when underlying observable throws error","<rxjs><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"56197163","1","56197471","","2019-05-18 08:14:30","","2","2000","<p>I have an array of objects. For each object I need to trigger an asynchronous request (http call). But I only want to have a certain maximum of requests running at the same time. Also, it would be nice (but not neccessary) if I could have one single synchronization point after all requests finished to execute some code.</p>

<p>I've tried suggestions from:</p>

<p><a href=""https://stackoverflow.com/questions/34535685/limit-number-of-requests-at-a-time-with-rxjs/34535954#34535954"">Limit number of requests at a time with RxJS</a></p>

<p><a href=""https://stackoverflow.com/questions/26111037/how-to-limit-the-concurrency-of-flatmap/26126750#26126750"">How to limit the concurrency of flatMap?</a></p>

<p><a href=""https://stackoverflow.com/questions/34486932/fire-async-request-in-parallel-but-get-result-in-order-using-rxjs"">Fire async request in parallel but get result in order using rxjs</a></p>

<p>and many more... I even tried making my own operators.</p>

<p>Either the answers on those pages are too old to work with my code or I can't figure out how to put everything together so all types fit nicely.</p>

<p>This is what I have so far:</p>

<pre class=""lang-js prettyprint-override""><code>for (const obj of objects) {
  this.myService.updateObject(obj).subscribe(value =&gt; {
    this.anotherService.set(obj);
  });
}
</code></pre>

<p><strong>EDIT 1:</strong>
Ok, I think we're getting there! With the answers of <em>Julius</em> and <em>pschild</em> (both seem to work equally) I managed to limit the number of requests. But now it will only fire the first batch of 4 and never fire the rest. So now I have:</p>

<pre><code>const concurrentRequests = 4;
from(objects)
  .pipe(
    mergeMap(obj =&gt; this.myService.updateObject(obj), concurrentRequests),
    tap(result =&gt; this.anotherService.set(result))
  ).subscribe();
</code></pre>

<p>Am I doing something wrong with the <code>subscribe()</code>?</p>

<p>Btw: The <code>mergeMap</code> with <code>resultSelector</code> parameter is deprecated, so I used <code>mergeMap</code> without it.
Also, the <code>obj</code> of the <code>mergeMap</code> is not visible in the <code>tap</code>, so I had to use <code>tap</code>'s parameter</p>

<p><strong>EDIT 2:</strong></p>

<p>Make sure your observers complete! (It cost me a whole day)</p>
","4461720","","4461720","","2019-05-19 11:18:01","2019-05-19 11:18:01","How to prevent multiple http requests from firing all at once","<javascript><angular><typescript><rxjs><rxjs-pipeable-operators>","3","7","1","","","CC BY-SA 4.0"
"56281901","1","","","2019-05-23 19:36:30","","1","68","<p>Assume you have the following code:</p>

<pre><code>protected _state = new ReplaySubject&lt;CartState&gt;();

getTransformedState(id: number) {
    return this._state.pipe(map(({ items }) =&gt; items[id]));
}
</code></pre>

<p>And im getting this transformed Observable in another component, and I subscribe to it.</p>

<pre><code>ngOnInit() {
    this.cart.getTransformedState(this.product.id).pipe(takeUntil(this.destroy$)).subscribe((item) =&gt; {})
}
</code></pre>

<p>Diving into Rxjs documentation we can see that transforming one Observable with usage of pipeable operators and then subscribing to the 'outcome' observable also subscribes to 'origin' observable.</p>

<blockquote>
  <p>An Pipeable Operator is essentially a pure function which takes one Observable as input and generates another Observable as output. <b>Subscribing to the output Observable will also subscribe to the input Observable.</b></p>
</blockquote>

<p>My question arise from unit test provided in the project that is failing to complete</p>

<pre><code>it('should have one subscription for product cart item', async(() =&gt; {
    const mockSubject = ServiceMock.getItemUpdates(MockProduct);

    component.ngOnInit();
    fixture.detectChanges();

    expect(mockSubject['observers'].length).toEqual(1);
}));
</code></pre>
","6941058","","","","","2019-05-23 19:36:30","Using pipeable operators and subscribing to only ""inner"" observable","<angular><observable><rxjs6><rxjs-pipeable-operators>","0","2","","","","CC BY-SA 4.0"
"56330324","1","56347733","","2019-05-27 17:34:24","","10","2526","<p>I have a component which triggers an <code>onScrollEnd</code> event when the last item in a virtual list is rendered. This event will do a new API request to fetch the next page and merge them with the previous results using the <code>scan</code> operator.</p>

<p>This component also has a search field which triggers an <code>onSearch</code> event.</p>

<p>How do I clear the previous accumulated results from the <code>scan</code> operator when a search event is triggered? Or do I need to refactor my logic here?</p>

<pre><code>const loading$ = new BehaviorSubject(false);
const offset$ = new BehaviorSubject(0);
const search$ = new BehaviorSubject(null);

const options$: Observable&lt;any[]&gt; = merge(offset$, search$).pipe(
  // 1. Start the loading indicator.
  tap(() =&gt; loading$.next(true)),
  // 2. Fetch new items based on the offset.
  switchMap(([offset, searchterm]) =&gt; userService.getUsers(offset, searchterm)),
  // 3. Stop the loading indicator.
  tap(() =&gt; loading$.next(false)),
  // 4. Complete the Observable when there is no 'next' link.
  takeWhile((response) =&gt; response.links.next),
  // 5. Map the response.
  map(({ data }) =&gt;
    data.map((user) =&gt; ({
      label: user.name,
      value: user.id
    }))
  ),
  // 6. Accumulate the new options with the previous options.
  scan((acc, curr) =&gt; {
    // TODO: Dont merge on search$.next 
    return [...acc, ...curr]);
  }
);

// Fetch next page
onScrollEnd: (offset: number) =&gt; offset$.next(offset);
// Fetch search results
onSearch: (term) =&gt; {
  search$.next(term);
};
</code></pre>
","3647773","","","","","2021-03-13 15:38:30","How to reset a RXJS scan operator based on another Observable","<javascript><angular><typescript><rxjs><rxjs-pipeable-operators>","4","0","1","","","CC BY-SA 4.0"
"56388508","1","56388638","","2019-05-31 04:01:29","","1","45","<p>Using RxJS, I have a situation where I need to retrieve a single value from an Observable and then immediately apply it to a separate subscription using <code>pluck()</code>.</p>

<p>I have a workable solution, but it is inelegant. Is there a way to simplify or improve the process?</p>

<pre><code>this.fooService.singleValue$.subscribe(value =&gt; {
   this.barService.allResults$.pipe(pluck(value)).subscribe(pluckedResult =&gt; {
       // do something with the plucked result
   });
});
</code></pre>
","3357958","","","","","2019-05-31 04:21:04","Take a subscribed result and immediate apply it to another subscription","<rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"56460436","1","56460488","","2019-06-05 12:23:40","","25","7882","<p>I'm trying to understand <code>throttleTime</code> vs <code>debounceTime</code> and which one is to be used when?</p>
<p>I have an upvote button that makes an API request to the backend (which counts the votes). User can submit button multiple times, but I'd like to limit the times per second button can be pressed.</p>
<p>I know <code>throttleTime</code> and <code>debounceTime</code> operators can do that, but which one should I choose?</p>
<pre class=""lang-js prettyprint-override""><code>const upvoteClicks = fromEvent(this.el.nativeElement, 'click')
   .pipe(debounceTime(500))
   .subscribe(() =&gt; this.myService.postUpvote(this.postId));
</code></pre>
","11573388","","74089","","2020-12-02 12:26:59","2021-05-25 16:39:19","What is the difference between throttleTime vs debounceTime in RxJS and when to choose which?","<rxjs><observable><rxjs-pipeable-operators>","2","0","4","","","CC BY-SA 4.0"
"56467176","1","56467270","","2019-06-05 19:58:16","","0","695","<p>I am doing an auto-complete search box and the problem I have is that when I write a word in the input, the service return very well the list of the items result. The service return if there are elements that match or empty if there are not, but the problems is that the list of my component doesn't update with the service values and I don't know why. I was following an example, and mine doesn't work. I hope someone can help me.</p>

<p>This is the service request.</p>

<pre><code>searchNewsInList2(filterValue:any):Observable&lt;New[]&gt;{
    return this.httpClient.get&lt;New[]&gt;(this.basePath)
    .pipe(
            tap((response:any)=&gt;{
                response=response
                .filter(news=&gt;news.title.includes(filterValue))
            return response;
            })

        );

    }
</code></pre>

<p>This is the request in the component, the list doesn't update with the service return data.</p>

<pre><code>constructor(private notificationService:NotificationsService,private newsService: NewsService, private router: Router,private tost:ToastrService) {

    this.notificationRequest=new Notification();
    this.newsSelected=new New();
    this.newsCntrlToAdd = new FormControl();

    }

    ngOnInit() {
    this.filteredNews=this.newsCntrlToAdd.valueChanges
        .pipe(
            debounceTime(300),
            startWith(''),
            switchMap(value =&gt;this.newsService.searchNewsInList2( value))
        );
    }

    displayFn(newFound: New) {
        if (newFound) {
            return newFound.title;
        }
    }
</code></pre>

<p>This is the view.</p>

<pre><code>&lt;mat-form-field class=""example-full-width""&gt;
    &lt;input matInput placeholder=""Specify a news to add""[formControl]=""newsCntrlToAdd""
    [matAutocomplete]=""auto"" required minlength=""4""&gt;
    &lt;/mat-form-field&gt;
        &lt;mat-autocomplete #auto=""matAutocomplete"" [displayWith]=""displayFn""&gt;
            &lt;mat-option *ngFor=""let newFound of (filteredNews | async)"" [value]=""newFound""&gt;
            &lt;span&gt;{{ newFound.title }}&lt;/span&gt;
            &lt;!--small&gt; | ID: {{newFound.id}}&lt;/small--&gt;
            &lt;/mat-option&gt;
        &lt;/mat-autocomplete&gt;
</code></pre>
","8722606","","5437671","","2019-06-05 20:04:37","2019-06-05 20:05:43","Angular autocomplete async dont filter","<angular><autocomplete><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"56500268","1","56500394","","2019-06-07 19:31:45","","2","124","<p><strong>Situation:</strong><br>
I've encountered a use case for the rxjs <code>Observable</code> system, where I may need to add <code>pipe</code>d commands to a <code>Subscription</code> after it has been started.</p>

<p>In my case, the application I'm working on has to passively listen to a push notification system.  A number of messages can be pushed out over this system, which my system needs to respond to.  <em>However</em>, there's a foreseeable case where a dynamically-loaded view that will be implemented in the future will need to add a listener to the push notification system.</p>

<p><strong>Question:</strong><br>
Given that my app is in a state where my <code>Subscription</code> already exists, can I add an additional pipe after <code>.subscribe(() =&gt; {})</code> has been invoked?</p>

<pre><code>// this.something is an Observable&lt;any&gt;, for discussion purposes.
const subscription = this.something.subscribe(() =&gt; { // commands });

this.something.pipe(
  map((something) =&gt; {
    // ...Commands that I want to add to the subscription...
  })
);
</code></pre>

<p>...And if I do that, then what happens, if anything?</p>

<p><strong>Solution:</strong><br>
The two answers by @user2216584 and @SerejaBogolubov both had an aspect of the answer to this question.</p>

<p>My high-level push notification listener service needed to to do two things:</p>

<ol>
<li>Hold onto the subscription, and  </li>
<li>Be able to draw from a list of listeners.</li>
</ol>

<p>The complication is that each listener needs to be listening for a different message.  Put differently, if I receive a message on <code>foo_DEV</code>, the app needs to do something different than if the push notification system pushes a message on <code>bar_DEV</code>.</p>

<p>So, here's what I came up with:</p>

<pre><code>export interface PushNotificationListener {
  name: string,
  onMessageReceived: (msg: PushNotificationMessage) =&gt; any,
  messageSubject$: Subject&lt;PushNotificationMessage&gt;
}

export class PushNotificationListenerService {
  private connection$: Observable&lt;PushNotificationConnection&gt;;
  private subscription$: Subscription;

  private listeners: PushNotificationListener[] = [];

  constructor(
    private connectionManager: PushNotificationConnectionManager
  ) {
  }

  connect() {
    // Step 1 - Open the socket connection!
    this.connection$ = this.connectionManager.connect(
      // The arguments for setting up the websocket are unimportant here.
      // The underlying implementation is similarly unimportant.
    );
  } 

  setListener(
    name: string,
    onMessageReceived: (msg: PushNotificationMessage) =&gt; any
  ) {
    // Step 3...or maybe 2...(shrug)...
    // Set listeners that the subscription to the high-order connection
    // will employ.
    const newListener: PushNotificationListener = {
      name: name,
      onMessageReceived: onMessageReceived,
      messageSubject$: null
    };

    this.listeners.push(newListener);
  }

  listen() {
    // Step 2 - Listen for changes to the high-order connection observable.
    this.subscription$ = this.connection$
      .subscribe((connection: PushNotificationConnection) =&gt; {
        console.info('Push notification connection established');

        for (let listener of this.listeners) {
         listener.messageSubject$ = connection.subscribe(listener.name);
         listener.messageSubject$.subscribe((message: PushNotificationMessage) =&gt; {
           listener.onMessageReceived(message);
         }
        }
      },
      (error: any) =&gt; {
        console.warn('Push notification connection error', error);
      }
  }
}
</code></pre>

<p>I discovered through careful study of the internal code that comprises the core of my push notification system, that we've already got a higher-order <code>Observable</code>.  The websocket code creates an observable (<code>connectionManager.connect()</code>), that needs to be cached in the service, and subscribed to.  As that code is specific to where I work, I can say no more about it.</p>

<p>However, caching the listeners is important too!  The <code>subscribe</code> call in <code>.listen()</code> just iterates through all the attached listeners any time that the connection changes state, so I can extemporaneously add listeners through <code>.addListener()</code>, and because of how rxjs' <code>Observable</code> system inherently works, <em>AND</em> the fact that I'm working from an in-scope list of listeners, I have a system whereby I can dynamically set listeners, even if <code>.connect()</code> is called before any listeners are configured.</p>

<p>This code probably can still benefit from redesign/refactoring, but I have something that works, which is the important first step of any good coding.  Thank you all!</p>
","1404206","","1404206","","2019-06-10 14:52:08","2019-06-10 14:52:08","Adding pipes after subscribing to a push notification service","<typescript><rxjs><rxjs-pipeable-operators><rxjs-subscriptions>","2","0","","","","CC BY-SA 4.0"
"56578177","1","","","2019-06-13 10:09:29","","0","66","<p>I am trying to subscribe multiple times to my own backend. While my code is fetching the data, something seems not to work right. By executing the following code everything is showed as it should be, except of the sequence. So my accounts are getting fetched in the correct sequence but my transactions are sometimes in the wrong order.</p>

<p>My code:</p>

<pre><code> for(var i = 0; i &lt; this.userlength; i++) {

              //fetch transactions data of the account with index ""countul"" to our local storage
              this.getAccounts(this.as.getUserId(), countul)
              .pipe(map(accountData =&gt; {
                  return {
                    accounts2: accountData.accounts.map(account =&gt; {
                      return {
                        productDescription: account.productDescription,
                        balance: account.currentBalance,
                        iban: account.iban
                      };
                  })
                };
              })
              //If an error at requesting data from external bank occurs, delete every token 
              )
              .subscribe(transformedTransactionData =&gt; {

                this.accounts[countul] = transformedTransactionData.accounts2;


                      for(var j = 0; j &lt; this.accounts[countul].length; j++) {

                          //Printing some things to the console for testing purpose
                          console.log(""countacc: ""+countacc);
                          console.log(this.accounts[countul][countacc].iban);

                          //fetch transactions data of the useraccount with index ""countul"" and subaccount with index ""countacc"" to our local storage
                          (this.getTransactions(this.transactionsPerPage, this.currentPage, this.accounts[countul][countacc].iban, countul, this.as.getUserId()))
                          .pipe(map(transactionData =&gt; {
                              return {
                                transactions2: transactionData.transactions.map(transaction =&gt; {
                                  return {
                                    date: transaction.bookingDate,
                                    receiver: transaction.counterPartyName,
                                    amount: transaction.amount,
                                    mandateReference: transaction.mandateReference,
                                    id: transaction.paymentIdentification,
                                    purpose: transaction.paymentReference
                                  };
                                })
                            };
                          }))
                          .subscribe(transformedTransactionData =&gt; {

                            this.transactions[countacc2] = transformedTransactionData.transactions2;

                            //Stop loading spinner
                            this.isLoading = false;

                            setTimeout(() =&gt; {}, 2000);
                            console.log(""Transactions of account "" +countacc2 + "": ""+JSON.stringify(this.transactions[countacc2]));
                            console.log(""Transactions of account "" +countacc2 + "": ""+JSON.stringify(this.transactions[countacc2]));
                            countacc2++;

                          }), error =&gt; {
                            console.log('There was an error getting data');
                            return Observable.throw(error);
                          };

                           //Go to the possible subaccount                            
                          countacc++;

                        }
                        //Go to the next bankaccount
                        countul++;

                      }), error =&gt; {
                        console.log('There was an error getting data');
                        return Observable.throw(error);
                      };    
            }  
      }
</code></pre>

<p>methods ""getTransaction"" and ""getAccounts"":</p>

<pre><code>//Get account data of bankaccount with index (if there are more than one bank account integrated)
 getAccounts(userid: string, index: number) {

  //DataSchema for the http request
  const data = {userid, index};

  //Making a HTTP Request to our Backend with sending out userid and the index of the bankaccount we want
  return this.http.post&lt;{message: string; accounts: any}&gt;(this.apiUrl + ""/get"", data);

  } 


//Get transaction data of account with index of chosen bankaccount and the iban (if there is a subaccount)
getTransactions(transactionsPerPage: number, currentPage: number, iban: string, index:number, userid: string) {

  //Making a HTTP Request to our Backend with sending out iban of account, index of bakaccount and our userid
  return this.http.post&lt;{transactions: any}&gt;(this.apiUrl + ""/transactions"", {iban, index, userid});

}
</code></pre>

<p>So sometimes it looks like this:</p>

<p><strong>Account 1</strong> - ""first name"" ""second name"" 
--Transactions of <strong>account 2</strong>--</p>

<p><strong>Account 2</strong> - ""first name"" ""second name"" 
--Transactions of <strong>account 1</strong>--</p>

<p>I have to notice, that sometimes it is shown in the correct sequence.</p>

<p>May anyone help me to fix my code?</p>
","11631321","","","","","2019-06-13 10:27:24","How can i fix the nested subscription to work sequential?","<node.js><angular><rxjs><rxjs-pipeable-operators><rxjs-subscriptions>","1","4","","","","CC BY-SA 4.0"
"56633716","1","","","2019-06-17 14:47:06","","10","14400","<p>I have an API call that returns a certain amount of ids. 
Each of these ids are used to make a new api call. The results of these API calls need to be combined into a single object.</p>

<p>At first I used a loop inside the .pipe(map) operator of the first api call. In this loop I did the second api calls, and in the .pipe(map) operator in each of these calls I would edit a variable in my angular component.</p>

<p>This wasn't very pretty, and I was actually wondering if this is thread safe. I know javascript is single threaded, but it doesn't seem very safe to have multiple asynchronous processes messing with the same global variable.</p>

<p>after that I just stored the observable returned by the second api call in an  array by looping over the returned Ids by apiCall1, and used forkJoin to subscribe and handle each result accordingly (see example).</p>

<p>This isn't very pretty however, and I was wondering if there's an operator I can use in my pipe for this?</p>

<p>So instead of (pseudocode):</p>

<pre><code>  .pipe(
      map(ids=&gt; {

        let observables = []
        for (const id of ids) {
         observables.push(this.service.getSomeStuff(id));
        }

        forkJoin(...observables).subscribe(dataArray) =&gt; {
          for (data of dataArray) {
            //Do something
          }
        });

      }),
      takeWhile(() =&gt; this.componentActive),
      catchError(error =&gt; {
        console.log(error);
        return throwError(error);
      })
    )
    .subscribe();
</code></pre>

<p>Is there an operator that makes it something like this:</p>

<pre><code>  .pipe(
      map(ids=&gt; {

        let observables = []
        for (const id of ids) {
         observables.push(this.service.getSomeStuff(id));
        }

      return observables
      }),
      forkJoin(dataArray =&gt; {
          for (data of dataArray) {
            //Do something
          }
        });
      takeWhile(() =&gt; this.componentActive),
      catchError(error =&gt; {
        console.log(error);
        return throwError(error);
      })
    )
    .subscribe();
</code></pre>
","5406968","","","","","2019-06-18 02:50:59","RXJS Combining multiple observables inside a pipe","<angular><rxjs><rxjs-pipeable-operators>","3","0","","","","CC BY-SA 4.0"
"56684044","1","","","2019-06-20 10:29:52","","1","927","<p>Consider the following Http interceptor:</p>

<pre><code>export class BusyIndicatorInterceptor implements HttpInterceptor {
    constructor(private busyIndicatorService: BusyIndicatorService) { }

    intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
        this.busyIndicatorService.show();

        return next.handle(req).pipe(tap((event: HttpEvent&lt;any&gt;) =&gt; {
            if (event instanceof HttpResponse) {
                this.busyIndicatorService.hide();
            }
        }, err =&gt; {
            console.warn(err);
            this.busyIndicatorService.hide();
        }));
    }
}
</code></pre>

<p>I am trying to unit test that the <code>busyIndicatorService.hide</code> is called when an error occurs such as <code>400</code>, <code>404</code> etc. I have written the following test but I think I am not mocking the handler properly.</p>

<pre><code>    it(""should set busy indicator visibility to false when HttpResponse is returned"", () =&gt; {
        mockhandler.handle.and.returnValue(of(new HttpErrorResponse({ error: ""Not Found"", status: 404 })));
        const result = testee.intercept(mockRequest, mockhandler);
        result.subscribe(() =&gt; {
            expect(busyIndicatorService.hide).toHaveBeenCalledTimes(1);
        });
    });
</code></pre>

<p>Result:</p>

<pre><code>Expected spy BusyIndicatorService.hide to have been called once. It was called 0 times
</code></pre>

<p>The following test works for testing the success block, where I mock the handler to return a new HttpResponse.</p>

<pre><code>it(""should set busy indicator visibility to false when HttpResponse is returned"", () =&gt; {
    mockhandler.handle.and.returnValue(of(new HttpResponse()));
    const result = testee.intercept(mockRequest, mockhandler);
    result.subscribe(() =&gt; {
        expect(busyIndicatorService.hide).toHaveBeenCalledTimes(1);
    });
});
</code></pre>

<p>Here is the full test class:</p>

<pre><code>describe(""BusyIndicatorInterceptor"", () =&gt; {
    let testee: BusyIndicatorInterceptor;
    let busyIndicatorService: any;
    let mockRequest: any;
    let mockhandler: any;

    beforeEach(() =&gt; {
        mockRequest = jasmine.createSpyObj(""HttpRequest"", [""""]);
        mockhandler = jasmine.createSpyObj(""HttpHandler"", [""handle""]);
        busyIndicatorService = jasmine.createSpyObj(""BusyIndicatorService"", [""show"", ""hide""]);
        busyIndicatorService.visibility = jasmine.createSpyObj(""BehaviourSubject&lt;boolean&gt;"", [""next""]);
        testee = new BusyIndicatorInterceptor(busyIndicatorService);
    });

    it(""should be created"", () =&gt; {
        expect(testee).toBeTruthy();
    });

    describe(""intercept"", () =&gt; {

        it(""should set busy indicator visibility to true"", () =&gt; {
            mockhandler.handle.and.returnValue(of(null));
            testee.intercept(mockRequest, mockhandler);

            expect(busyIndicatorService.show).toHaveBeenCalledTimes(1);
        });

        it(""should set busy indicator visibility to false when HttpResponse is returned"", () =&gt; {
            mockhandler.handle.and.returnValue(of(new HttpResponse()));
            const result = testee.intercept(mockRequest, mockhandler);
            result.subscribe(() =&gt; {
                expect(busyIndicatorService.hide).toHaveBeenCalledTimes(1);
            });
        });

        it(""should set busy indicator visibility to false when HttpResponse is returned"", () =&gt; {
            mockhandler.handle.and.returnValue(of(new HttpErrorResponse({ error: ""Not Found"", status: 404 })));
            const result = testee.intercept(mockRequest, mockhandler);
            result.subscribe(() =&gt; {
                expect(busyIndicatorService.hide).toHaveBeenCalledTimes(1);
            });
        });
    });
});
</code></pre>
","2093029","","","","","2021-04-01 05:04:04","How to unit test error block of rxjs tap operator with jasmine mocks?","<angular><rxjs><karma-jasmine><karma-runner><rxjs-pipeable-operators>","0","8","","","","CC BY-SA 4.0"
"56740884","1","","","2019-06-24 16:49:02","","0","152","<p>I'm using rxjs with NodeJS in backend. 
I have a Rest API which allow consumers to run remote yarn installation process. The install function returns an observable of the process. So when the module is installed successfully it emits a value in the observable and complete. At this point, the Rest API will returns a response to the user to say that the installation is successful. In case that the installation fails, the process will throw an Error in the stream and the Rest API returns another response with the error information.</p>

<p>My issue is: </p>

<p>The API is called multiple times in parallel by consumers, so there will be a parallel installations in the backend. </p>

<p>I tried throttle operator to create a queue but it keeps the first stream active. So if the first process is ""completed"", it returns ""true"" but the stream doesn't complete</p>

<pre><code>export class MyService {
    // the function called by the REST API
    installGlobal(moduleName: string): Observable &lt; boolean &gt; {
        // I think, there are something to do here to make it queuing
        return this.run('yarn', ['global', 'add', moduleName]);
    }

    private run(cmd: string, args: string[]): Observable &lt; boolean &gt; {
        const cmd$ = fromPromise(spawn(cmd, args)).pipe(
            map(stdout =&gt; {
                this.logger.info(`Install Module Successfully`);
                this.logger.info(`stdout: ${stdout.toString()}`);
                return true;
            }),
            catchError(error =&gt; {
                const errorMessage: string = error.stderr.toString();
                return _throw(errorMessage.substr(errorMessage.indexOf(' ') + 1));
            })
        );
        return cmd$;
    }
} 
</code></pre>

<p>My expectation: </p>

<p>Either there are multiple request, they must be queued. So the first one will be treated and all parallel onces must be queued. When the first is processed, it must returns the response to the API consumers (like 200 completed) and resume the next stream from the queue.</p>

<p><strong>[UPDATE-01 July 2019]: adding an example</strong></p>

<p>You can fetch a demo of the code at <a href=""https://stackblitz.com/edit/rxjs-queuing"" rel=""nofollow noreferrer"">stackblitz</a></p>

<p>I have reimplemented the existant code and i'm simulating my API call by subscribing multi time to the service which will call the queue</p>
","1368125","","1368125","","2019-07-01 13:09:51","2019-07-01 13:09:51","Queuing function using RxJS","<rxjs><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"56748777","1","56748887","","2019-06-25 07:21:14","","4","772","<p>Are there any differences when using the Pipe function with one argument, versus not using Pipe at all? </p>

<p>I am currently implementing the takeUntil unsubscribe strategy from <a href=""https://stackoverflow.com/questions/38008334/angular-rxjs-when-should-i-unsubscribe-from-subscription/51732897?stw=2#51732897"">this article</a>. In the ""official solution"" from <a href=""https://stackoverflow.com/questions/38008334/angular-rxjs-when-should-i-unsubscribe-from-subscription/51732897?stw=2#51732897"">this SO question</a> the takeUntil operator is sent through a pipe. However, on <a href=""https://alligator.io/angular/takeuntil-rxjs-unsubscribe/"" rel=""nofollow noreferrer"">this page</a> takeUntil is used with no pipe. </p>

<p>I am therefore wondering if there is any difference (memory leakage/performance, etc) in using a Pipe with a single Rx operator, versus no Pipe at all. </p>

<pre class=""lang-js prettyprint-override""><code>private destroy$ = new Subject();
...
this.potatoService.getPotato()
   .pipe(
    takeUntil(this.destroy$)
   ).subscribe(...
</code></pre>

<p>as opposed to</p>

<pre class=""lang-js prettyprint-override""><code>this.potatoService.getPotato()
    .takeUntil(this.destroy$)
    .subscribe(...
</code></pre>
","10138883","","","","","2019-06-28 02:24:30","Rxjs, Pipe with one argument","<angular><rxjs><rxjs-pipeable-operators>","3","2","","","","CC BY-SA 4.0"
"56877330","1","56877395","","2019-07-03 20:14:02","","5","8670","<p>TL;DR
Is it possible to use forkJoin inside a pipe of an observable?</p>

<p>Full story:
I have a service that returns Observable of array of objects. For each of those objects I will need to make another call to a service which returns an observable, and apply another operation to each of the results.</p>

<pre><code>op1 -&gt;[] ----&gt; op2 --&gt; op3
          \\-&gt; op2 --&gt; op3
           \-&gt; op2 --&gt; op3
</code></pre>

<p>My current solution is this:</p>

<pre class=""lang-js prettyprint-override""><code>    this.tournamentParticipantService.getNotAssigned(this.tournamentId).subscribe(
      (players: Player[]) =&gt; {
        let dict = {};
        players.forEach(player =&gt; {
          dict[player.id] = this.teamService.add(
            { 
                id: 0,
                members: [],
                tournament: this.tournamentId,
                name: player.name + "" "" + player.surname
            })
            .pipe(
              map((team: Team) =&gt; 
                this.teamMemberService.add({ player: player.id, team: team.id })
              ))
        });
        forkJoin(dict).subscribe(result =&gt; console.log(result));
     });
</code></pre>

<p>I would like to get rid of the first subscribe and use pipe instead. Problem is that tutorials for forkJoin show it as the source to which an object or array is handed into, never as part of a pipe.</p>

<p>Calling forkJoin from inside map</p>

<pre><code>.pipe(
    map(value=&gt;forkJoin(value))
</code></pre>

<p>returns <code>Observable&lt;Observable&lt;resolved forkJoin arguments&gt;&gt;</code> which I probably would need to subscribe recursively. Seems like not a good way.</p>

<p>Putting fJ inside pipe without arguments </p>

<pre class=""lang-js prettyprint-override""><code>this.tournamentParticipantService.getNotAssigned(this.tournamentId).pipe(
      map((players: Player[]) =&gt; players.map(
        (player: Player) =&gt; this.teamService.add({ id: 0, members: [], tournament: this.tournamentId, name: player.name + "" "" + player.surname })
          .pipe(
            map((team: Team) =&gt; {
              let pipe = new JsonPipe();
              console.log(""team: "" + pipe.transform(team) + "" player: "" + pipe.transform(player));
              this.teamMemberService.add({ player: player.id, team: team.id });
            })))),
      forkJoin
    ).subscribe((result: [[Observable&lt;void&gt;]]) =&gt; {
      console.log(result)
      result[0].forEach(element =&gt; {
        element.subscribe(res =&gt; console.log(res));
      });
    });
</code></pre>

<p>ends with weird tangled structure of observables. This also does not seem to be a good way.</p>

<p>Is it even possible to use forkJoin from inside a pipe?</p>
","661211","","","","","2019-07-17 07:27:17","How to call forkJoin inside a pipe?","<angular><rxjs><rxjs-pipeable-operators>","2","0","1","","","CC BY-SA 4.0"
"56908956","1","","","2019-07-05 20:32:39","","5","1191","<p>I have a question about one of the common pattern for the unsubscribing with the takeUntil operator for Angular and RxJs.
In <a href=""https://blog.angularindepth.com/the-best-way-to-unsubscribe-rxjs-observable-in-the-angular-applications-d8f9aa42f6a0"" rel=""noreferrer"">this article</a>, it 's under the third position.
For example, we have such code in a component class:</p>

<pre><code>  private destroy$: Subject&lt;boolean&gt; = new Subject();

  ngOnInit() {
     this.control.
     .pipe(takeUntil(this.destroy$)
     .subscribe(doSmthngFunc); 
  }

  ngOnDestroy() {
    this.destroy$.next(true);
    // Which next line of code is correct?
    // this.destroy$.complete()     // this one?
    // this.destroy$.unsubscribe()  // or this one?
  }
</code></pre>

<p>The first line this.destroy$.next(true) is totally clear.
But the second is not. If we look into the realization of these methods, we find that they have somewhat similar behavior.
<a href=""https://github.com/ReactiveX/rxjs/blob/master/src/internal/Subject.ts#L91"" rel=""noreferrer"">complete():</a>
<a href=""https://github.com/ReactiveX/rxjs/blob/master/src/internal/Subject.ts#L105"" rel=""noreferrer"">unsubscribe():</a></p>

<p>As I understand semantically complete() is preferable, because we call next() for the first and the last time during the component life and then we finished with this Subject, treated as Observable and can invoke complete(). These methods belong to the observer and unsubscribe belong to the observable, and we have no subscriptions to unsubscribe from. 
But under the hood, these methods have a similar code:</p>

<pre><code>    this.isStopped = true; // both

    this.observers.length = 0; // complete
    this.observers = null;     // unsubscribe

    this.closed = true;        // only unsubscribe

</code></pre>

<p>Theoretically complete() has delayed effect as it's may invoke complete() on every observer subscribed, but we have no observers on destroy$.
So the question - which way is more preferable, less error-prone, and why?</p>
","11654839","","","","","2019-07-06 11:26:06","What approach is better for killing an observable, provided for takeUntil operator, and why?","<angular><rxjs><rxjs-pipeable-operators>","3","3","","","","CC BY-SA 4.0"
"56939066","1","56958433","","2019-07-08 16:26:27","","4","2313","<p>I'm a bit confused about the rxjs operator <code>delay</code>.</p>

<p>When I test it with a fake observable created with <code>from</code>, then I only see an <em>initial</em> delay:</p>

<pre class=""lang-js prettyprint-override""><code>const { from } = Rx;
const { delay, tap } = RxOperators;

from([1, 2, 3, 4]).pipe(
  tap(console.log),
  delay(1000));
</code></pre>

<p>(You can copy &amp; paste this code snippet into <a href=""https://rxviz.com"" rel=""nofollow noreferrer"">rxviz</a>.)</p>

<p>I placed a <code>tap</code> in there to make sure <code>from</code> actually emits the array items as separate values instead of a single array value.</p>

<p>An initial delay is not what I expected, but at least that's what <a href=""https://github.com/ReactiveX/rxjs/blob/a9fa9d421d69e6e07aec0fa835b273283f8a034c/src/internal/operators/delay.ts#L19"" rel=""nofollow noreferrer"">the docs</a> say:</p>

<blockquote>
  <p>[...] this operator time shifts the source Observable by that amount of time expressed in milliseconds. The relative time intervals between the values are preserved.</p>
</blockquote>

<p>However, when I test it with an observable created from an event, then I see a delay <em>before each emitted value</em>:</p>

<pre class=""lang-js prettyprint-override""><code>const { fromEvent } = Rx;
const { delay } = RxOperators;

fromEvent(document, 'click')
  .pipe(delay(1000))
</code></pre>

<p>What's going on here? Why is <code>delay</code> behaving differently in both cases?</p>
","1025555","","1025555","","2019-07-08 17:00:48","2019-07-11 20:20:23","Confusing behavior of rxjs operator `delay`","<rxjs><reactivex><rxjs-pipeable-operators>","3","2","","","","CC BY-SA 4.0"
"56950329","1","56952468","","2019-07-09 10:16:00","","0","26","<p>Is there a way to keep track of a value with pipeable operators?</p>

<p>To give a tangible example, let's say that I want to :<br>
Over a data stream <strong>S</strong>:</p>

<ol>
<li>Memorize <strong>S</strong> current data</li>
<li>Make a HTTP request </li>
<li>Do stuff with the response</li>
<li>Make another HTTP request using the result of the operation</li>
<li>Create an object containing a value base on <strong>1.</strong> and the response</li>
</ol>

<p>Then merge these and exploit the objects I created.</p>

<p>Basically,  </p>

<pre class=""lang-js prettyprint-override""><code>const data = from([1, 2, 3]).pipe(
  // Memorize here
  map(a =&gt; req1(a)),
  flatMap(a =&gt; a),
  map(b =&gt; syncOp(b)),
  map(c =&gt; req2(c)),
  flatMap(d =&gt; d),
  map(e =&gt; ({id: _memorized_, value: e}))

merge(data).subscribe(f =&gt; console.log(f.id, f.value))
</code></pre>

<p><a href=""https://stackblitz.com/edit/rxjs-dy5jps"" rel=""nofollow noreferrer"">Related stackblitz</a></p>

<p>Any input on the matter will be greatly appreciated.</p>

<hr>

<p><em>Note:</em> If possible, I'd prefer not to carry the value I need all the way down via the creation of an object at the top.</p>
","3456021","","3456021","","2019-07-09 10:24:35","2019-07-09 12:20:03","Can I keep track of a value when using pipeable operators?","<rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"57045892","1","","","2019-07-15 19:13:04","","6","2038","<h1>The abstract problem</h1>
<p>Is there any way to consume the result of a <code>mergeMap</code> in the original order of the outer observable, while still allowing the inner observables to run in parallel?</p>
<hr />
<h2>More detailed explanation</h2>
<p>Let's look at two merge-mapping operators:</p>
<ul>
<li><p><a href=""https://rxjs.dev/api/operators/mergeMap"" rel=""nofollow noreferrer""><code>mergeMap</code></a></p>
<p>...which takes a mapping callback, and a number of how many inner observables may run concurrently:</p>
  <pre class=""lang-js prettyprint-override""><code>  of(1, 2, 3, 4, 5, 6).pipe(
      mergeMap(number =&gt; api.get('/double', { number }), 3)
  );
</code></pre>
<p><strong>See it here in action</strong>: <a href=""https://codepen.io/JosephSilber/pen/YzwVYNb?editors=1010"" rel=""nofollow noreferrer"">https://codepen.io/JosephSilber/pen/YzwVYNb?editors=1010</a></p>
<p>This will fire off 3 parallel requests for <code>1</code>, <code>2</code> and <code>3</code>, respectively. As soon as one of those requests completes, it'll fire off another request for <code>4</code>. And so on and so forth, always maintaining 3 concurrent requests, until all of the values have been processed.</p>
<p>However, since previous requests may complete before subsequent requests, the values produced may be out of order. So instead of:</p>
  <pre class=""lang-js prettyprint-override""><code>  [2, 4, 6, 8, 10, 12]
</code></pre>
<p>...we may actually get:</p>
  <pre class=""lang-js prettyprint-override""><code>  [4, 2, 8, 10, 6, 12] // or any other permutation
</code></pre>
</li>
<li><p><a href=""https://rxjs.dev/api/operators/concatMap"" rel=""nofollow noreferrer""><code>concatMap</code></a></p>
<p>...enter <code>concatMap</code>. This operator ensures that the observables are all concatenated in the original order, so that:</p>
  <pre class=""lang-js prettyprint-override""><code>  of(1, 2, 3, 4, 5, 6).pipe(
      concatMap(number =&gt; api.get('/double', { number }))
  );
</code></pre>
<p>...will always produce:</p>
  <pre class=""lang-js prettyprint-override""><code>  [2, 4, 6, 8, 10, 12]
</code></pre>
<p><strong>See it here in action</strong>: <a href=""https://codepen.io/JosephSilber/pen/OJMmzpy?editors=1010"" rel=""nofollow noreferrer"">https://codepen.io/JosephSilber/pen/OJMmzpy?editors=1010</a></p>
<p>This is what we want, but now <em>the requests won't run in parallel</em>. As <a href=""https://rxjs.dev/api/operators/concatMap"" rel=""nofollow noreferrer"">the documentation</a> says:</p>
<blockquote>
<p><code>concatMap</code> is equivalent to <code>mergeMap</code> with <code>concurrency</code> parameter set to <code>1</code>.</p>
</blockquote>
</li>
</ul>
<p><strong>So back to the question</strong>: is it possible to get the benefits of <code>mergeMap</code>, whereby a given amount of requests can be run in parallel, while still having the mapped values be emitted in the original order?</p>
<hr />
<h1>My concrete problem</h1>
<p>The above described the problem in abstract. It is sometimes easier to reason about a problem when you know the actual problem at hand, so here goes:</p>
<ol>
<li><p>I have a list of orders that have to be shipped:</p>
 <pre class=""lang-js prettyprint-override""><code> const orderNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
</code></pre>
</li>
<li><p>I have a <code>shipOrder</code> method that actually ships the orders. It returns a <code>Promise</code>:</p>
 <pre class=""lang-js prettyprint-override""><code> const shipOrder = orderNumber =&gt; api.shipOrder(orderNumber);
</code></pre>
</li>
<li><p>The API can only process up to 5 order shipments simultaneously, so I'm using <code>mergeMap</code> to handle that:</p>
 <pre class=""lang-js prettyprint-override""><code> from(orderNumbers).pipe(
     mergeMap(orderNumber =&gt; shipOrder(orderNumber), 5)
 );
</code></pre>
</li>
<li><p>After an order is shipped, we need to print its shipping label. I have a <code>printShippingLabel</code> function that, given the order number of a shipped order, will print its shipping label. So I subscribe to our observable, and print the shipping labels as the values come in:</p>
 <pre class=""lang-js prettyprint-override""><code> from(orderNumbers)
     .pipe(mergeMap(orderNumber =&gt; shipOrder(orderNumber), 5))
     .pipe(orderNumber =&gt; printShippingLabel(orderNumber));
</code></pre>
</li>
<li><p>This works, but <strong>now the shipping labels are printed out of order</strong>, since <code>mergeMap</code> emits values based on when <code>shipOrder</code> completes its request. What I want is for <strong>the labels to print in the same order as the original list</strong>.</p>
</li>
</ol>
<p>Is that possible?</p>
<hr />
<h2>Visualization</h2>
<p>See here for a visualization of the problem: <a href=""https://codepen.io/JosephSilber/pen/YzwVYZb?editors=1010"" rel=""nofollow noreferrer"">https://codepen.io/JosephSilber/pen/YzwVYZb?editors=1010</a></p>
<p>You can see that earlier orders are being printed before later orders are even shipped.</p>
","825568","","825568","","2020-06-23 14:50:03","2020-06-25 17:56:35","RxJS mergeMap() with original order","<javascript><rxjs><rxjs6><rxjs-pipeable-operators>","3","1","3","","","CC BY-SA 4.0"
"57055017","1","57055525","","2019-07-16 10:17:03","","0","254","<p>I am doing some correction in the response at <code>tap</code> before <code>map</code> but i am not getting called the <code>map</code> after the <code>tap</code> implementation. <code>map</code> not consoles me at all. </p>

<p>what is the best way to do some correction in the response before we send to <code>map</code> any one help me?</p>

<p>as well let me know exact use of <code>tap</code> here.
Here is my code:</p>

<pre><code>createTranslationId(translationId: ModelTranslationId) {
        console.log('translationId', translationId);
        return this.http.post&lt;any&gt;(environment.configUrl + `Configuration`, translationId)
            .pipe(
                tap(response =&gt; {
                    return Object.assign({}, response, {
                        Response: {
                            'Name': response.Response.Name,
                            'Description': response.Response.Description,
                            'TypeId': response.Response.TypeId,
                            'Type': response.Response.Type,
                            'Id': response.Response.Id,
                            'CreatedBy': response.Response.CreatedBy,
                            'CreatedDate': response.Response.CreatedDate,
                            'UpdatedBy': response.Response.UpdatedBy,
                            'UpdatedDate': response.Response.UpdatedDate
                        }
                    });
                }),
                map(response =&gt; {
                    console.log('response3', response);
                    return response;
                }),
                catchError(this.handleError)
            );
    }
</code></pre>

<p>thanks in advance.</p>
","2024080","","","","","2019-07-16 10:47:04","When I use `tap` method later the `map` is not called. i get return from tap","<angular><rxjs><angular8><rxjs-pipeable-operators>","2","3","","","","CC BY-SA 4.0"
"57055032","1","","","2019-07-16 10:18:00","","2","112","<p>I'm creating a page with multiple forms and I want to detect mousedown, focus and blur events on each of those forms.</p>

<p>Most of the times, they are emitted simultaneously (e.g. clicking on one form while another one is already selected, emits ""blur"" and ""mousedown""). The goal is to process only one of them.</p>

<p>I created an Observable called interactions$ which emits values which are ""Event"" objects such as mousedown, focus or blur event.</p>

<p>I'm using pipe on that Observable and now I have two options for the operator:</p>

<ul>
<li>debounceTime(100) so that only the last of them is processed</li>
<li>throttleTime(100) so that only the first of them is processed.</li>
</ul>

<pre class=""lang-js prettyprint-override""><code>      this.interaction$
         .pipe(
            debounceTime(100),
            tap(evt =&gt; console.log('processing event' + evt))
         )
         .subscribe();
</code></pre>

<p>Ideally, I want both mousedown and focus events to be processed over the blur event but the problem is that when interactions$ emits:</p>

<ul>
<li>""mousedown"" is emitted before ""blur""</li>
<li>""focus"" is emitted after ""blur""</li>
</ul>

<p>So, my question is:</p>

<p>Is there any way to apply either debounceTime() or throttleTime() depending on the source value?</p>

<p>EDIT:</p>

<p>This interaction$ is a Subject whose values are being emitted on this event handler:</p>

<pre class=""lang-js prettyprint-override""><code>onFieldInteract(field: string, evt: Event) {
    this.interaction$.next(new FormFieldInteraction(field, evt.type));
}
</code></pre>

<p>where FormFieldInteraction is just a class with 2 string properties.</p>

<p>EDIT 2:</p>

<p>Basically I want something like this but I'm not sure if there's any rxjs operator for it:</p>

<pre class=""lang-js prettyprint-override""><code>this.interaction$.pipe(
      // if event.type === 'blur',
      debounceTime(100),
      // else
      throttleTime(100),
      tap(evt =&gt; this.fieldInteract.emit(evt))
   ).subscribe();
</code></pre>
","9148900","","9148900","","2019-07-16 12:50:30","2019-07-16 13:13:05","How to apply rxjs operator depending on value from source?","<angular><rxjs><rxjs-pipeable-operators>","1","6","","","","CC BY-SA 4.0"
"57125889","1","57126071","","2019-07-20 15:01:30","","0","29","<p>I'm trying to filter an array that comes from an observable if the property ""start"" which is a date string match with another date string, but within the filter operator function the argument is not recognizing ""start"" as a valid property</p>

<p>I have read multiple examples and comparing to mine seems to be a very similar scenario</p>

<pre><code>export class AuctionsService() {

private _auctions = new BehaviorSubject(
    [
      {
        idAuction: '1',
        start: '2019-07-18T15:30',
      },
      {
        idAuction: '2',
        start: '2019-07-18T15:30',
      },
      {
        idAuction: '3',
        start: '2019-07-18T15:30',
      },
      {
        idAuction: '4',
        start: '2019-07-19T15:30',
      },
    ]
  );
 get auctions() {
    return this._auctions.asObservable();
  }
}
</code></pre>

<p>On another file when I'm subscribing to this observable</p>

<pre><code>    selectedDate = '2019-07-19T12:46';

  constructor(
    private auctionsService: AuctionsService,
  ) { }

      ngOnInit() {
        this.auctionsService.auctions.pipe(filter(
          aucs =&gt; aucs.start.slice(0, 10) === this.selectedDate.slice(0, 10)
        )).subscribe(
          aucs =&gt; { this.auctions = aucs; }
        );
      }
</code></pre>

<p>Expected output should be:
      {
        idAuction: '4',
        start: '2019-07-19T15:30',
      },</p>

<p>but is not compiling it states .start is not a valid property of aucs</p>
","5781717","","","","","2019-07-20 15:29:55","why the argument from filter operator is not taking a property that exist in the observable array","<angular><typescript><rxjs-pipeable-operators>","1","5","","","","CC BY-SA 4.0"
"57135573","1","57135670","","2019-07-21 17:43:32","","0","55","<p>I have a simple question &amp; I think that would be easy to answer for Angular Experts.</p>

<p>I have a method like below:</p>

<pre><code> private uploadPicture(imagePath: string, apiUrl: string): Observable&lt;ApiResponse&lt;string&gt;&gt; {

   return this.convertFileFromFilePathToBlob(imagePath).pipe(
      switchMap(item =&gt; this.convertBlobToFormData(item)),
      switchMap(formData =&gt; this.postImageToServer(formData, apiUrl)),
      catchError((error: any) =&gt; {
        if (error instanceof Response) {
            return throwError(new AppError(error));
        } else {
            return throwError(new AppError(null, 'Error occured at convertFileFromFilePathToBlob.'));
        }
      })
    );
  }
</code></pre>

<p>I have chained 3 methods in one method:</p>

<ol>
<li><code>convertFileFromFilePathToBlob</code></li>
<li><code>convertBlobToFormData</code></li>
<li><code>postImageToServer</code></li>
</ol>

<p>All 3 methods can raise/emit error at any point of failure. My question is about how to do exception handling in such cases?</p>

<p>Is my current implementation, having only one <code>catchError</code> is fine? If fine, will it be executed if any of the chained methods raise an error?</p>

<p>or </p>

<p>Do I need to use multiple <code>catchError</code> operators after each method to catch its error? If yes, I don't know how can I do that?</p>

<p>Can someone please explain how should I handle error in such cases?</p>
","1273882","","","","","2019-07-21 17:56:01","Exception Handling in Angular Chained Methods?","<angular><ionic-framework><rxjs><ionic4><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"57461030","1","57461277","","2019-08-12 12:15:34","","1","152","<p>I'm trying to turn this:</p>

<pre class=""lang-js prettyprint-override""><code>/* ...inside a pipe */
tap(() =&gt; logData('my process')),
tap(() =&gt; someCallback()),
tap(() =&gt; logDataEnd('my process'),
/* pipe continues */
</code></pre>

<p>Into a new operator that takes the callback <code>() =&gt; someCallback()</code> and adds the logging side-effects before and after it. My logging functions use <code>performance.now()</code> and they work as expected* when I just use the explicit <code>tap</code> version, but none of my operators do the same thing.</p>

<p><strong>Expected Results</strong></p>

<p>A pipe using my operator:</p>

<pre><code>of(null).pipe(
  withLogging(() =&gt; callbackA()),
  withLogging(() =&gt; callbackB()),
  /* etc. */
)
</code></pre>

<p>should produce a log that looks like this:</p>

<pre><code>Action A start
Action A end
Action B start
Action B end
...
</code></pre>

<p>However I'm getting this:</p>

<pre><code>Action A start
Action B start
/* ... rest of the pipe */
Action A end
Action B end
</code></pre>

<p>By looking at the timestamps I can see that the <code>end</code> logs are timestamped correctly but the <code>begin</code> ones are too early.</p>

<p>I've tried using <code>defer</code> in different ways but the outcome doesn't change.</p>

<p><strong>What I've tried</strong></p>

<pre class=""lang-js prettyprint-override""><code>withLogging&lt;T, R&gt;(project: (value :T) =&gt; R): OperatorFunction&lt;T, R&gt; {
  return (source: Observable&lt;T&gt;) =&gt;
  defer(() =&gt; of(startLogging())).pipe(
    flatMap(() =&gt; source),
    tap(() =&gt; stopLogging())
  );
}
</code></pre>

<p>I've tried wrapping the entire pipe with a <code>defer</code> or just the start of the logging process, or doing <code>of(null).pipe</code> and then putting all of the effects together. I've even tried not using <code>defer</code> at all and just returning a pipe starting with <code>null</code>. Nothing has produced the desired behavior.</p>
","6338059","","","","","2019-08-12 12:31:54","rxjs operator that adds logging before and after a callback","<javascript><typescript><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"57631442","1","","","2019-08-23 18:34:38","","0","193","<p>I would like to use existing rxjs operators to create a multicasting observable that resubscribes to its source every time it is subscribed to but does not unsubscribe its subscribers when the source completes. </p>

<p>The intent is to have a mix of short-lived and long-lived components that share the same data source. When a new short-lived component is created, the shared data should be updated for both the new component and any long-lived components also subscribed to the data source.</p>

<p>Using Observable.create(), I was able to create a custom observable that produces this behavior but it feels like there is probably an out-of-the box solution that doesn't require writing custom code.</p>

<p>Here's what I have tried.</p>

<pre><code>import { of, Observable, Observer, zip, interval, merge } from ""rxjs"";
import { filter, map, publish, tap, delay, shareReplay, share } from ""rxjs/operators"";

class MySubject {
  constructor(private observable: Observable&lt;any&gt;) {}

  sourceActive = false;
  subscribers: Array&lt;Observer&lt;any&gt;&gt; = [];

  public subscribe(observer: Observer&lt;any&gt;) {
    this.subscribers.push(observer);

    if (!this.sourceActive) {
      console.log(""subscribing"");
      this.sourceActive = true;
      this.observable.subscribe(
        x =&gt; this.subscribers.forEach(sub =&gt; sub.closed || sub.next(x)),
        x =&gt; this.subscribers.forEach(sub =&gt; sub.closed || sub.error(x)),
        () =&gt; this.sourceActive = false
      );
    }
  }
}

const source$ = of(1).pipe(
  tap(x=&gt;console.log(""invoked cold"")),
  delay(2000)
);
const mySubject = new MySubject(source$);
const super$ = Observable.create(observer =&gt; mySubject.subscribe(observer));

const sub1 = super$.subscribe(x =&gt; console.log(""sub 1""));
const sub2 = super$.subscribe(x =&gt; console.log(""sub 2""));

setTimeout(x =&gt; {
  sub1.unsubscribe();
  super$.subscribe(x =&gt; console.log(""sub 3""));
}, 3000);
</code></pre>
","1035797","","1035797","","2019-08-23 18:40:45","2019-08-23 18:58:48","Long-lived multicasting Observable that resubscribes to its source every time it is subscribed to","<angular><typescript><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"57691553","1","57692318","","2019-08-28 11:39:04","","0","38","<p>I'm trying to understand what the difference would be between these two observables. The only difference in code is this:</p>

<pre class=""lang-js prettyprint-override""><code>/**
* Inside rxjs pipe
*/
if(typeof x === 'number' &amp;&amp; x &gt; 3) {
    return of(x);
} else {
    return EMPTY;
}
</code></pre>

<p>vs:</p>

<pre class=""lang-js prettyprint-override""><code>.filter(typeof x === 'number' &amp;&amp; x &gt; 3)
</code></pre>

<p>The test I'm running:</p>

<pre class=""lang-js prettyprint-override""><code>const a$ = from([1, 6, '4']).pipe(
            tap(console.log),
            flatMap((x) =&gt; {
                if (typeof x === 'number') {
                    if (x &gt; 3) {
                        return of(x);
                    }
                    return EMPTY;
                }
                return EMPTY;
            }),
            tap(console.log)
        );
        const sub_a = a$.subscribe(
            (x) =&gt; { console.log(x, 'success'); done(); },
            (e) =&gt; { console.log(e, 'error'); done(); },
            () =&gt; { console.log('complete'); sub_a.unsubscribe(); done(); }
        );
</code></pre>

<p>and:</p>

<pre class=""lang-js prettyprint-override""><code>        const b$ = from([2, 5, '8']).pipe(
            tap(console.log),
            filter(x =&gt; typeof x === 'number' &amp;&amp; x &gt; 3),
            tap(console.log)
        );
        const sub_b = b$.subscribe(
            (x) =&gt; { console.log(x, 'success'); done(); },
            (e) =&gt; { console.log(e, 'error'); done(); },
            () =&gt; { console.log('complete'); sub_b.unsubscribe(); done(); }
        );
</code></pre>

<p>for both of them I get the first value logged once (before the filter/flatMap), the second value logged twice from the taps and once with ""complete"", and the third one once.</p>

<p>I thought the difference would be that emitting <code>EMPTY</code> would cause the observable to close entirely but subsequent values are still seen through the pipe.</p>

<p>I've done the same with a <code>Subject</code> and the only difference was that the <code>Subject</code>s didn't emit <code>Complete</code> which was to be expected.</p>
","6338059","","","","","2019-08-28 12:21:49","Is there a difference between filter(cond) and flatMap(x => cond? of(x) : EMPTY)?","<javascript><typescript><rxjs><rxjs-pipeable-operators>","1","8","","","","CC BY-SA 4.0"
"57769727","1","57770551","","2019-09-03 10:22:01","","0","79","<p>Hi I have a small code snippet using rxjs library as follows. It is working fine . However I would like to re write it using switchmap . I tried all option however i am getting an error . was wondering if someone could help me out .</p>

<pre><code>this.campaignControl.valueChanges.subscribe(
(value) =&gt; {
    this.flightsService.getUnpaginatedFlightsWithinRange(
          {
                 campaignId : value,
                 jobStatuses: this.flightStatusIds,
                 rangeStartDate: 
                 (this.rangeControl.value[0]).toISOString(),
                 rangeEndDate: (this.rangeControl.value[1]).toISOString()
          }
).subscribe(
      (flightsUnpaginated) =&gt; {
             this.flights = flightsUnpaginated;
            }
         );
   }
);
</code></pre>

<p>thank you </p>
","11957755","","11957755","","2019-09-03 10:42:07","2019-09-03 11:15:28","How can i rewrite the following code with switchmap","<rxjs><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"57791588","1","","","2019-09-04 15:29:49","","0","345","<p>switchMap does not repeat HTTP calls.</p>

<p>I have created a directive that validates an email if it already exists.</p>

<p>Inside that directive, is an API. Every time a keypress happens, the API is being called to check if it already exists.</p>

<p><strong>I'm using switchMap to prevent multiple HTTP requests and cancel previous ones.</strong></p>

<p>But the problem is once the request has already been made and canceled, it would not repeat again.</p>

<p>e.g. test@gmail.com - canceled request</p>

<p>test2@gmail.com - successful API</p>

<p>test@gmail.com (again) - the API call will not happen anymore.</p>

<p>Why is this happening (to me) ??</p>

<p>I have checked switchMap operator docs and I do not see any situations regarding about this.</p>

<pre><code>&lt;input [(ngModel)]=""sampleEmail"" placeholder=""Email""  isEmailExistsValidator&gt;

export class isEmailExistsValidator implements AsyncValidator {
  constructor(private someService: SomeService) { }
  public validate(control: AbstractControl): Observable&lt;ValidationErrors|null&gt; { 

if (isNullOrUndefined(control.value)) {
  return of(null);
} 

return this.someService
  .isEmailExistsValidator(control.value)
  .pipe(
    switchMap((response) =&gt; {
      if (response.availability) {
        return of(null);
      } else {
        return of({ emailAlreadyExists: response.response });
      }
    })
  );
  }

}

public isEmailExistsValidator(email: string): Observable&lt;EmailAvailability&gt; {
return this.httpClient.get&lt;EmailAvailable&gt;('/api/sampleEmailValidation/' + email);
</code></pre>

<p>}</p>

<p>I expect the API to be successful in any email input.</p>
","","user12020633","","user12020633","2019-09-04 18:20:40","2019-09-06 10:43:10","RXJS SwitchMap not repeating a request after it has been cancelled","<angular><rxjs><rxjs-pipeable-operators><switchmap>","1","8","","","","CC BY-SA 4.0"
"57859097","1","57861640","","2019-09-09 18:05:10","","1","428","<p>I have an array of objects. I have to check each object trough an API call to see if the object is eligible for a certain promo.
What is the best way to keep calling the API with objects until the last object is called in which the observable should return false, or one of the objects get a true state from the API?</p>

<p>At the moment I have this as code but it feels like there should be a better way with RxJS operators.</p>

<pre><code>checkProductForPromo(items: []) {
   const promoChecker$ = new EventEmitter&lt;boolean&gt;();

   items.forEach((item, key, arr) =&gt; {
        // This does a HTTP callback to the API
        this.ApiService.getProductInformation(item).subscribe(
            (product) =&gt; {
                // Based on some properties this will return true or false of the product is eligible for the promo.
                if (product.isEligibleForPromo()) {
                    promoChecker$.emit(true);
                } else if (Object.is(arr.length - 1, key)) {
                    promoChecker$.emit(false);
                }
            }
        );
    });

    return promoChecker$;
}
</code></pre>
","391345","","","","","2019-09-09 21:53:02","RxJS stop foreach when observable meets condition","<typescript><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"57914907","1","","","2019-09-12 21:48:02","","1","57","<p>As far as I understand, <code>debounce</code> <code>keeps track of the most recent value from the source Observable, and spawns a duration Observable by calling the durationSelector function</code></p>

<p>I have the following code</p>

<pre><code>    import { interval } from 'rxjs';
    import { debounce } from 'rxjs/operators';

    const data = interval(1000);

    const silenceTimer = interval(2000);
    data.pipe(debounce(val =&gt; silenceTimer)).subscribe(x =&gt; console.log(x));

</code></pre>

<p>I expect it will emit 1, 3, 5,etc., but it does not emit any value at all. 
Do I understand the operator correctly or did I do something wrong.
Thank you</p>

<p>EDIT:
I understand why no value is emitted now! because the interval 2000 is greater than the generation interval 1000, so all values are thrown away. If I reduce the debouncing interval to 500, all values will be emitted</p>
","386188","","386188","","2019-09-13 00:39:57","2019-09-13 00:39:57","RxJs Debounce does not emit any value","<javascript><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"57934134","1","57934692","","2019-09-14 09:23:13","","3","395","<ul>
<li>I have an autocomplete input.</li>
<li>Every time a letter is entered or deleted I do an HTTP request.</li>
<li>The response is mapped to a list of suggestions, which I show in a dropdown beneath the input.</li>
</ul>

<p>However: If the last letter is deleted, making the input empty, I want to skip the HTTP request etc. and return an empty array instead.</p>

<p>So I need an operator called first in the pipe, which every time a condition is met skips all operators below and ""returns early"" just like a ""break"" or ""return"" statement in a for loop.</p>

<p>I cannot use filter(), because this operator would prevent the resulting observable to emit. But I need it to emit to clear the dropdown.</p>

<pre class=""lang-html prettyprint-override""><code>&lt;input [formControl]=""formGroup.searchTerm""&gt;
&lt;ul&gt;
 &lt;li *ngFor=""let suggestion of suggestions$ | async""&gt;{{suggestion}}&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<pre class=""lang-js prettyprint-override""><code>suggetions$ = this.formGroup.valueChanges.pipe(
    pluck('searchString')
    // filter(searchString =&gt; searchString.length &gt; 0) // does not help
    unknownOperator(searchString =&gt; {
        if(searchString.length === 0) {
            skipOperatorsBelowAndReturnThisInstead([])
        } else {
            continueWithOperatorsBelow(searchTerm)
        }
    })
    switchMap(values =&gt; this.http.get(this.url + values.term)),
    map(this.buildSuggestions),
),
</code></pre>

<p>Thanks!</p>
","10116894","","10116894","","2019-09-14 10:06:59","2019-09-14 13:50:50","Looking for RxJs Operator that returns early, skipping operators below, not filter() or skip()","<javascript><rxjs><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"58004185","1","58004323","","2019-09-19 05:23:25","","-1","87","<p>I am subscribing a value from a reducer, where it will always <code>true</code>. when first time i subscribes it works. but next time it's not. from my research always the value is <code>true</code> if i change value to <code>false</code> then it works fine.</p>

<p>so subscribe expect the different value to observer or unsubscription.  at present I do like this:</p>

<pre><code>this.store.dispatch(new actionsMc.CheckConcurrencySuccess(false));
this.store.dispatch(new actionsMc.CheckConcurrency(true));
</code></pre>

<p>even though I required to pass <code>true</code> always i do above to subscribe my update. instead of this work around any other way is there is <code>rxjs</code> any one help me?</p>

<p>in subscription i tried with take <code>once</code> but it not working further. but looking for some other work around.</p>

<p>here is my subscription:</p>

<pre><code>this.store.pipe(last(select(subscribe.newvalue))).subscribe(res =&gt; {
   console.log('new res', res);
}) 
</code></pre>

<p>but not works. as a simple how to subscribe and unsubscribe on each value received?</p>
","218349","","","","","2019-09-19 05:36:37","Is there a way to subscribe the same value all time without subscribe break?","<rxjs><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"58070512","1","","","2019-09-23 21:36:46","","0","940","<p>I have the following code</p>

<pre><code>export function featureReady(feature: BaseFeatureService) {
  return pipe(
    zip(feature.loading$),
    filter(([inputObject, loading]) =&gt; !loading),
    map(([inputObject, loading]) =&gt; {
      return inputObject;
    })
  );
}
</code></pre>

<p>And I wish to consume it like this.</p>

<pre><code>observable$.pipe(
   featureReady(this.propertyFeatureService)
);
</code></pre>

<p><code>zip</code> is now deprecated in place of the static <code>zip</code> which means my above solution will stop working is there an RXJS operator I can replace either the <code>zip</code> operator or the whole solution with?</p>

<p>I would also be happy with any solution that accepts an `Observable' for the wait condition, as I wouldn't mind passing in <code>feature.loading$</code></p>

<p>Thanks.</p>
","6946339","","","","","2019-09-24 17:11:10","Making a custom RXJS pipe that accepts an observable and waits until that observable meets a condition","<angular><typescript><rxjs><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"58071648","1","58071860","","2019-09-24 00:33:18","","0","40","<p>I am trying to create a pipeable operator and throw when particular conditions not met..  I am unable to throw and catch the error however.</p>

<p>This is my pipeable:</p>

<pre class=""lang-js prettyprint-override""><code>// My custom pipeable
export function waitFor&lt;T&gt;(thisToComplete$: Observable&lt;any&gt;) {
  return (beforeRunningThis$: Observable&lt;T&gt;) =&gt; {
    return new Observable&lt;T&gt;(observer =&gt;
      thisToComplete$.pipe(first()).subscribe(x =&gt; {
        if (x !== 'Success') {
          console.log('Non success result encountered');
          return throwError('Rando IO Error');
        }
        return beforeRunningThis$.subscribe(observer);
      })
    );
  }
}
</code></pre>

<p>And consuming code:</p>

<pre class=""lang-js prettyprint-override""><code>const preReq$ = timer(1000);
const dataReq$ = getData();

try {
  dataReq$
    .pipe(waitFor(preReq$), catchError(x =&gt; {
      console.log('Code here reached');
      return of('Error was handled either here')
    }))
    .subscribe(x =&gt; console.log(`I have result ${x.toString()}`));
} catch (e) {
  console.log('Error was handled here');
}
</code></pre>

<p>None of the above consoles log however.</p>

<p>Here is a <a href=""https://stackblitz.com/edit/rxjs-error-propogation-with-pipable?file=src/app/app.component.ts"" rel=""nofollow noreferrer"">stackblitz</a></p>
","1327570","","","","","2019-09-24 04:27:40","Why isn't this throwError being caught in catchError?","<angular><error-handling><rxjs><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"58127740","1","58129344","","2019-09-27 04:05:20","","1","552","<p>I'm trying to learn the reactive development in Angular by converting my old methods in a service to NOT subscribe at all in an Observable. So far, the simplest method that I already converted was the getAll method. What I want now is that, when I selected a single card in the card list, I will be redirected to another page to view it's details. Consider the below code that I'm currently working.</p>

<p><strong>SERVICE</strong></p>

<pre class=""lang-js prettyprint-override""><code>@Injectable({
  'providedIn': 'root'
})
export class CardService {

  private selectedCardIdSubject = new Subject&lt;number&gt;();
  selectedCardIdAction$ = this.selectedCardIdSubject.asObservable();

 /**
   * Retrieve single card based on card id.
   */
  card$ = this.selectedCardIdAction$
    .pipe(
      tap(id =&gt; console.log(`card$: ${this._cardsApi}/${id}`)),
      concatMap(id =&gt;
        this._http.get&lt;Card&gt;(`${this._cardsApi}/${id}`)
          .pipe(
            map(card =&gt; ({
              ...card,
              imageUrl: `${this._cardImageApi}/${card.idName}.png`
            }))
          )
      ),
      catchError(this.handleError)
    );

  onSelectedCardId(id: number) {
    this.selectedCardIdSubject.next(id);
    console.log(`onSelectedCardId: ${id}`)
  }    
}
</code></pre>

<p><strong>COMPONENT</strong></p>

<pre class=""lang-js prettyprint-override""><code>@Component({})
export class CardDetailsComponent {
    constructor(private _cardService: CardService,
        private route: ActivatedRoute) { 

        this.selectedCardId = this.route.snapshot.params['id'];
        this._cardService.onSelectedCardId(this.selectedCardId);
    }

    card$ = this._cardService.card$;
}
</code></pre>

<p><strong>HTML</strong></p>

<pre class=""lang-html prettyprint-override""><code>&lt;div class=""container mb-5"" *ngIf=""card$ | async as card""&gt;
    &lt;p&gt;{{ card.name }}&lt;/&gt;
&lt;/div&gt;
</code></pre>

<p>In the code above, when redirected, it does not render my simple HTML to show the name of the selected card. I'm using a <code>[routerLink]</code> to redirect in the card detail page.</p>

<p><strong>Card List Component</strong></p>

<pre class=""lang-html prettyprint-override""><code>&lt;div *ngIf=""cards$ | async as cards""&gt;
    &lt;div class=""col-md-1 col-4 hover-effect"" *ngFor='let card of cards'&gt;
      &lt;a class=""d-block mb-1""&gt;
        &lt;figure&gt;
          &lt;img class=""img-fluid img-thumbnail"" [src]='card.imageUrl' [title]='card.name' [alt]='card.name'
            [routerLink]=""['/cards', card.id]"" /&gt;
        &lt;/figure&gt;
      &lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>Anyone who can enlighten me on what happen here?</p>
","1160123","","6694645","","2019-09-27 09:19:39","2019-10-08 06:56:11","Reactive Development | RxJS async pipe not working","<angular><rxjs><rxjs-pipeable-operators>","2","4","","","","CC BY-SA 4.0"
"58261991","1","","","2019-10-06 23:19:42","","0","367","<p>I am writing an Angular8 application where the server always gives 200s series answers. All errors from the server side are wrapped inside the <code>Response object</code> therefore, I have to create errors from it.</p>

<p><strong>A typical answer looks like the following</strong>; where the <code>APP_CODE</code> property represents health of the answer, <code>APP_CODE: '001'</code> means I can read it from result array. If it is <code>APP_CODE=""002""</code> or <code>APP_CODE=""002""</code> then there is an error and I should read the error array, etc.</p>

<pre><code>{ ""input"": null, 
  ""warningMessages"": [],
  ""errorMessages"": [
     ""Please enter at least 3 characters""
  ],
  ""numFound"": 0,
  ""results"": [],
  ""APP_CODE"": ""003""
}
</code></pre>

<p><strong>Solution Strategy</strong>: There are several strategies that I can go with, but the one that I want is at service level using <code>map</code> in <code>pipe</code>, generate application specific error then <code>catchError()</code>, and pass it to component to decide how to show it whether in a toast, or somehow in the form.</p>

<p>Therefore the code should look like this</p>

<pre><code>private handleError(error: MyAppError) {
    console.log('******got you inside handleError', error);
    return throwError(error);
  }

private handleErrorAppCodes(res: any[]) {
    console.log('**** handleErrorAppCodes ****');
    console.log(""%o"", res);
    if (res[""APP_CODE""] === ""003"") {
    console.log('dataAccess service| Results APP_CODE is', res[""APP_CODE""]);
    return throwError(new MyAppError('APP CODE 3:' + res[""errorMessages""][0]));
  } 
}
  return res;
}


getMyObject(objectName: string):Observable&lt;any[]&gt; {

let url = 'thisIsAUrl';

return this.http.get&lt;any[]&gt;(url).pipe(
  map(this.handleErrorAppCodes),
  catchError(this.handleError)
);
</code></pre>

<p>Seems to be a descent error. BUT I get the following error during compile</p>

<pre><code>error TS2322: Type 'Observable&lt;any[] | Observable&lt;never&gt;&gt;' is not assignable to type 
'Observable&lt;any[]&gt;'.Type 'any[] | Observable&lt;never&gt;' is not assignable to type 'any[]'.
Type 'Observable&lt;never&gt;' is missing the following properties from type 'any[]': length, pop,  
push,concat, and 25 more.
</code></pre>

<p>I also tried <code>map(res =&gt; this.handleErrorAppCodes(res))</code> the compile error is similar.</p>

<p>Later I tried <code>map&lt;any[]&gt;(this.handleErrorAppCodes)</code> but I got</p>

<pre><code>error TS2558: Expected 2 type arguments, but got 1.
</code></pre>
","2809423","","","","","2020-02-23 14:08:32","Creating custom errors hidden in backend response in Angular","<angular><observable><angular-httpclient><rxjs6><rxjs-pipeable-operators>","2","1","1","","","CC BY-SA 4.0"
"58275508","1","58305572","","2019-10-07 18:51:33","","4","647","<p>I am doing some parallel HTTP get with RxJs pipe and the mergeMap operator.</p>

<p>On the first request fail (let's imagine /urlnotexists throw a 404 error) it stops all other requests.</p>

<p>I want it to continue query all remaining urls without calling all remaining mergeMap for this failed request.</p>

<p>I tried to play with throwError, and catchError from RxJs but without success.</p>

<p>index.js</p>

<pre><code>const { from } = require('rxjs');
const { mergeMap, scan } = require('rxjs/operators');

const request = {
  get: url =&gt; {
    return new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        if (url === '/urlnotexists') { return reject(new Error(url)); }
        return resolve(url);
      }, 1000);
    });
  }
};

(async function() {
  await from([
    '/urlexists',
    '/urlnotexists',
    '/urlexists2',
    '/urlexists3',
  ])
    .pipe(
      mergeMap(async url =&gt; {
        try {
          console.log('mergeMap 1:', url);
          const val = await request.get(url);
          return val;
        } catch(err) {
          console.log('err:', err.message);
          // a throw here prevent all remaining request.get() to be tried
        }
      }),
      mergeMap(async val =&gt; {
        // should not pass here if previous request.get() failed 
        console.log('mergeMap 2:', val);
        return val;
      }),
      scan((acc, val) =&gt; {
        // should not pass here if previous request.get() failed 
        acc.push(val);
        return acc;
      }, []),
    )
    .toPromise()
    .then(merged =&gt; {
      // should have merged /urlexists, /urlexists2 and /urlexists3
      // even if /urlnotexists failed
      console.log('merged:', merged);
    })
    .catch(err =&gt; {
      console.log('catched err:', err);
    });
})();
</code></pre>

<pre class=""lang-sh prettyprint-override""><code>$ node index.js
mergeMap 1: /urlexists
mergeMap 1: /urlnotexists
mergeMap 1: /urlexists2
mergeMap 1: /urlexists3
err: /urlnotexists
mergeMap 2: /urlexists
mergeMap 2: undefined &lt;- I didn't wanted this mergeMap to have been called
mergeMap 2: /urlexists2
mergeMap 2: /urlexists3
merged: [ '/urlexists', undefined, '/urlexists2', '/urlexists3' ]
</code></pre>

<p>I expect to make concurrent GET requests and reduce their respectives values in one object at the end.</p>

<p>But if some error occurs I want them not to interrupt my pipe, but to log them.</p>

<p>Any advice ?</p>
","5083349","","","","","2019-10-09 13:42:42","Continue on error in RxJs pipeable with mergeMap","<javascript><node.js><functional-programming><rxjs><rxjs-pipeable-operators>","2","1","1","","","CC BY-SA 4.0"
"58278450","1","","","2019-10-07 23:49:30","","0","110","<p>I am new to Angular and RXJS - I'm trying to return normalized data from a rest api and assemble the hierarchy on the client.  I created this stack blitz which is a really basic version of what I'm trying to accomplish:  <a href=""https://stackblitz.com/edit/angular-ffdbza"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-ffdbza</a>  </p>

<p>These interfaces ( ParentData, AssnData, and ChildData ) represent the JSON data being returned from the API.  The Parent and Child interfaces are the way I want the data to be represented on the client (in the real app I will bind this new object to a hierarchical grid).  The key points are that the Assn data has an attribute (statusCode) that needs to be applied to each Child based on the Parent.</p>

<pre><code>// represents normalized data coming from the service
export interface ParentData {
  parentCode: string, 
  name: string
}

export interface AssnData {
  parentCode: string
  childId: number,
  statusCode: string
}

export interface ChildData {
  childId: number,
  type: string
}

// represents the merged data for display 
export interface Parent {
  parentCode: string,
  name: string
  kids: Child[]
}

export interface Child {
  childId: number
  type: string,
  statusCode: string
}
</code></pre>

<p>This is the code I have so far (grabbed from data.component.ts in the stack blitz).  It is adding the Assn objects to the correct parent but I'm having trouble merging the Child object with each Assn object.  I am doing a console.log to see the results.</p>

<pre><code>  getRelationalData() {
    let x = combineLatest(
      this.parentData$,
      this.assnData$,
      this.childData$
    ).pipe(
      map(([pData, aData, cData]) =&gt; {
        return pData.map(p =&gt; {
          return {
            ...p,
            kids: aData.filter(a =&gt; a.parentCode === p.parentCode)
          }
        })
      })
    )
    return x;
  }
</code></pre>
","3551865","","","","","2019-10-08 16:22:09","rxjs/angular - how to merge normalized data from service?","<angular><rxjs-pipeable-operators><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"58634742","1","58635055","","2019-10-30 22:58:22","","2","859","<p>Considering I have the following code:</p>

<pre class=""lang-js prettyprint-override""><code>private readonly postAction$ = new Subject();

postStream$ = this.postAction$.pipe(
    exhaustMap(() =&gt; {
      this.count ++;
      console.log('fired')
      return of('my other post');
    }),
    startWith(''),
    exhaustMap(()=&gt; {
      this.count ++;
      console.log('fired first')
      return of('my post' + this.count);
    })
  )
</code></pre>

<p>Which I subscribe to in my template using the <code>async</code> pipe.</p>

<p>I wasn't expecting this to work, but the output to the console was:</p>

<pre><code>&gt; fired first
</code></pre>

<p>Until I call <code>.next()</code> on the <code>postAction$</code> subject, the first <code>console.log('fired')</code> is never called.</p>

<p>What's the execution context of RxJS operators? How do they work? I would have expected that the first exhaust map needed to emit a value, before the rest of the operators are ran. Couldn't find anything in the rxjs <a href=""https://rxjs.dev/guide/operators"" rel=""nofollow noreferrer"">docs</a></p>

<p>Demo on <a href=""https://stackblitz.com/edit/rxjs-action-stream-mm"" rel=""nofollow noreferrer"">stackblitz</a></p>
","6118550","","6118550","","2019-11-29 13:32:16","2019-11-29 13:32:16","RxJS operators execution order","<angular><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"58669932","1","58672483","","2019-11-02 09:48:32","","0","52","<p>I am trying to check the validity of a function I have written in Typescript, in congruence with RxJS observables, that fetches some bookings from one service and then for each booking fetches its corresponding location and activity from another service. </p>

<p>I am simply writing this post to verify the validity of what I have written and to ask if there is anything I could have done more efficiently.</p>

<pre class=""lang-js prettyprint-override""><code>let params = new HttpParams();
params = params.append('status', 'C');
params = params.append('offset', offset.toString());
params = params.append('limit', limit.toString());
return this.http.get(`${this.environment.booking.url}/my/bookings`, { params }).pipe(
    mergeMap((bookings: Booking[]) =&gt; {
        if(bookings.length &gt; 0) {
            return forkJoin(
                bookings.map((booking: Booking) =&gt;
                    forkJoin(
                        of(booking),
                        this.activityService.getActivity(booking.activity),
                  this.locationService.getLocation(booking.finalLocation),
                    ).pipe(
                        map((data: [ Booking, Activity, Location ]) =&gt; {
                            let booking = data[0];
                            booking.activityData = data[1];
                            booking.finalLocationData = data[2];
                            return booking;
                        })
                    )
                )
            )
        }

        return of([]);
    }),
    catchError((err: HttpErrorResponse) =&gt; throwError(err))
);
</code></pre>

<p>I am expecting for this function to return a list of bookings alongside their corresponding location and activity. However more importantly I want to verify that what I am doing is correct and sensible. Is there anything I could have done differently to make it cleaner/ more human-readable (not nit-picking, please 😁 )?</p>

<p>On a different note, that of performance, I also have a follow-up question with regards to performance. Given that a list of bookings has common activities and locations. Is there a way to only fetch activities and locations without any duplicate HTTP requests? Is this already handled under the hood by RxJS? Is there anything I could have done to make this function more efficient?</p>
","12311649","","498031","","2019-11-02 13:05:49","2019-11-02 15:26:32","Combining observables in series & parallel to fetch data from multiple APIs","<javascript><rxjs><angular2-observables><rxjs-pipeable-operators><rxjs-observables>","2","3","","","","CC BY-SA 4.0"
"58781909","1","58875722","","2019-11-09 17:45:00","","1","82","<p>I'm trying to implement service, which provides observable if app has connection to my server or not, so when browser online, we ping server with timer. Here is code: </p>

<pre><code>public get $connected(): Observable&lt;boolean&gt; {
    return this.hasInternetConnection
               .asObservable()
               .pipe(
                 distinctUntilChanged(),
                 flatMap((connected: boolean) =&gt; {
                   if (!connected) {
                     return of(connected);
                   } else {
                     return timer(5000)
                       .pipe(
                         map(() =&gt; {
                           var success = Math.random() &gt; 0.5;
                           console.log('PING: ' + success);
                           return success;
                         })
                       );
                   }
                 })
               );
  }
</code></pre>

<p><code>hasInternetConnection</code> is just a BehaviorSubject bound to window <code>online</code> and <code>offline</code> events, timer emulates ping to my API server.</p>

<p>The issue is that my subscription <code>$connected</code> catches only first value from timer observable and then doesn't work. After <code>hasInternetConnection</code> subject changes to <code>false</code> and back to <code>true</code>, my subscription again gets first value and then nothing. Here is what I see in console:</p>

<pre><code>PING: true
subscription tap
PING: true
PING: false
PING: true
...
</code></pre>

<p>How can I fix that? Thank you!</p>
","7290992","","","","","2019-11-15 11:06:25","RXJS flatMap to repetitive observable","<rxjs><observable><ngrx><rxjs-pipeable-operators><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"58798234","1","58798342","","2019-11-11 08:58:17","","1","141","<p>Is is possible (I can't find anything comprehensive on this) to combine multiple pipable operators in one function, so I can pipe it and re-use in a different method as well?</p>

<p>Here is the thing:</p>

<pre><code>public ngOnInit(): void {
      this.route.url
            .pipe(
                switchMap( (ids: UrlSegment[]) =&gt; /* http call */),
                tap(result =&gt; /* setting a variable within a service */),
                tap(result =&gt; /* some more manipulating and logic */),
                map(result =&gt; /* setting a _this_ variable */)
            )
            .subscribe( () =&gt; {
                /* some other async tasks, which depend on _this_ variables */
                this.cdr.detectChanges();
            });
      }
</code></pre>

<p>How do I extract everything within <code>pipe()</code> so I can call the same chain of operators from a different method, which would need to perform the same http call and subsequent logic and manipulating?</p>

<p>What I try to achieve is:</p>

<pre><code> this.route.url
   .pipe(
       this.combinedPipableMethod(url: UrlSegment[])
   )
   .subscribe()
</code></pre>
","542191","","","","","2019-11-11 11:52:41","Combined pipable operators with RxJS / Angular","<angular><typescript><rxjs><rxjs-pipeable-operators>","3","5","","","","CC BY-SA 4.0"
"58806560","1","58806697","","2019-11-11 18:11:19","","0","21","<p>Hi I am getting an error when i tries to do the following operation </p>

<pre><code>export class FlightFormTemplatesStepComponent
{

 tagonMessagePrefix: TagOnMessagePrefix;


  ngOnInit() {
     this.flightService.get(this.flightId).pipe(
         tap (flight =&gt; {this.flight = flight}),
         mergeMap( (flight) =&gt; {
           return this.flightService.getTagonMessagePrefix(flight);
         })
        ).subscribe(
          (tagonMessagePrefix) =&gt; { this.tagonMessagePrefix = tagonMessagePrefix}

        );
   }
}
</code></pre>

<p>this is the error I am recieving. </p>

<pre><code>property) FlightFormTemplatesStepComponent.tagonMessagePrefix: TagOnMessagePrefix
Type '{}' is missing the following properties from type 'TagOnMessagePrefix': id, flightName, flightTagonTypes, configuredGlobalTagonSettings, tagonTextts(2739)
</code></pre>

<p>Any idea how can i fix this issue </p>
","11957755","","11957755","","2019-11-11 18:16:31","2019-11-11 22:52:23","How can I pass the output of an http call as input to another http call in Rx JS?","<rxjs><angular5><rxjs5><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"58844874","1","","","2019-11-13 20:12:10","","1","493","<p>I'm attempting to write a service that measures the completion time of the app becoming stable.  Here's the service:</p>

<h3>measure.service.ts</h3>

<pre class=""lang-js prettyprint-override""><code>import { ApplicationRef, Injectable } from ""@angular/core"";
import { first, map } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class MeasureService {
  public constructor(private readonly applicationRef: ApplicationRef) { }

  public measure(): void {
    const startTime = Date.now();

    console.log(startTime);
    /**
     * Test stability metrics of application.
     */
    this.applicationRef.isStable.pipe(
      first(isStable =&gt; isStable),
      map(() =&gt; {
        /* tslint:disable-next-line:no-console */
        console.log(""App stable (""+ Math.round((Date.now() - startTime) / 1000) + "" secs)"");
      })
    );
  }
}
</code></pre>

<h3>app.module.ts (abbreviated):</h3>

<pre class=""lang-js prettyprint-override""><code>...
@NgModule({
   providers: [
      MeasureService
   ]
})
</code></pre>

<h3>root.component.ts</h3>

<pre class=""lang-js prettyprint-override""><code>import { Component, OnInit } from ""@angular/core"";
import { MeasureService } from ""../application-insights/measure.service"";

@Component({
  selector: ""mr-root"",
  template: `
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
  `,
})
export class RootComponent implements OnInit {
  public constructor(
    private readonly measureService: MeasureService
  ) {  
    this.measureService.measure();    
  }

  public ngOnInit(): void {
  }
}

</code></pre>

<p>The first <code>console.log</code> of the <code>MeasureService</code> correctly logs the time.  However, it appears the <code>applicationRef.isStable</code> never fires and, therefore, the second <code>console.log</code> never writes to the console.</p>

<p>Am I doing this right, or am I missing something?</p>
","916995","","","","","2019-11-14 02:05:29","ApplicationRef.isStable not executing","<javascript><angular><rxjs><rxjs-pipeable-operators><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"59022830","1","59023073","","2019-11-24 21:57:05","","2","3102","<p>I am a back-end developer starting with front-end development for a project I am working on. The front-end uses Angular7 and NgRx. I have studied a lot in the last 4 days, but here is something I am stuck with and would appreciate your help.</p>

<p>I learnt that we can dispatch multiple actions from an effect in NgRx by returning an Observable array having multiple actions. I want to dispatch one of the action in the array based on a condition.</p>

<p>My code looks something like this </p>

<pre><code>@Effect()
  something$: Observable&lt;Action&gt; = this.actions$.pipe(
    ofType(ActionType),
    switchMap.(action: any) =&gt; {
       return service.call(action.payload)
         .pipe(
             switchMap((data: ReturnType) =&gt; [ 
                new Action1(),
                new Action2(),
              ]),
        catchError(error handling)
      );
    }),
   );
</code></pre>

<p>and I want to achieve something like this</p>

<pre><code>   @Effect()
  something$: Observable&lt;Action&gt; = this.actions$.pipe(
    ofType(ActionType),
    switchMap.(action: any) =&gt; {
       return service.call(action.payload)
         .pipe(
             switchMap((data: ReturnType) =&gt; [ 
                 if(condition)
                   new Action1()
                  else
                    new Action1.1() ,
                new Action2(),
              ]),
        catchError(error handling)
      );
    }),
   );
</code></pre>

<p>I think its my lack of knowledge of RxJs, which is preventing me to implement the condition.</p>
","12426044","","","","","2021-03-20 00:49:41","How to dispatch multiple actions from an effect in ngrx conditionally","<rxjs><ngrx><ngrx-effects><rxjs-pipeable-operators><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"59257679","1","59259751","","2019-12-09 22:37:46","","1","624","<p>I'm new to Angular and I'm filtering the user with the id same as in the JWT payload.</p>

<p>I can do this in the subscribe() of the Observable like this:</p>

<pre><code>  this.route.data.subscribe((data) =&gt; {
      this.users = data.users.filter((u: User) =&gt; u.id !== +this.authService.decodedToken.nameid);
  });
</code></pre>

<p>I also can do this in the pipe() method like:</p>

<pre><code>this.route.data
  .pipe(map(data =&gt; data.users.filter((u: User) =&gt; u.id !== +this.authService.decodedToken.nameid)))
  .subscribe((data) =&gt; {
    this.users = data;
  });
</code></pre>

<p>Resolver code (probably irrelevant to the question):</p>

<pre><code>  resolve(route: ActivatedRouteSnapshot): Observable&lt;User[]&gt; {
        return this.userService.getUsers().pipe(
            catchError(error =&gt; {
                this.alertify.error('Problem retrieving data');
                this.router.navigate(['/home']);
                return of(null);
            })
        );
    }
</code></pre>

<p>Now why should I use the pipe() method rather than filtering directly in the subscribe() method are there any advantages or disadvantages of using pipe() in this scenario? Which of the two is the conventional Angular way of doing this?</p>

<p>I would think that the pipe() would be a little bit slower, since it first maps and then filters.</p>
","12336785","","12336785","","2019-12-09 22:44:18","2019-12-10 03:26:06","What are the advantages/disadvantages of performing operations in pipe() rather than directly in subscribe() method?","<angular><rxjs><observable><rxjs6><rxjs-pipeable-operators>","2","4","","","","CC BY-SA 4.0"
"59557389","1","","","2020-01-02 01:10:21","","0","87","<p>Is there any way to use a map function in RxJs from the observable's emitted value's property?</p>

<p>Let's say I have an Observable of type:  <code>Observable&lt;Something&gt;</code>, and  <code>Something</code> has a property called  <code>mapFunction</code> with the value:  <code>mapTo({ isTicking: true })</code>. Is there anyway I can use this map function on that observable? Like this: </p>

<p><code>private composingObs$ = this.streamOfSomethings$.pipe( // I would like to use the instance function: something.mapFunction as map here.</code></p>
","10103655","","10103655","","2020-01-02 02:09:10","2020-01-02 07:11:28","Use map function from the Observable's emitted value's own property in RxJs","<rxjs><rxjs-pipeable-operators>","1","4","","","","CC BY-SA 4.0"
"59881087","1","59881291","","2020-01-23 14:42:04","","0","35","<p>I have a question about the pipes of the observables</p>

<p>suppose I have the following code:</p>

<pre><code>const skip$ = of(4);
const length$ = of(24);
const schoolId$ = of(1);

const source = combineLatest(skip$, length$, schoolId$).pipe(
  map(([skip, length]) =&gt; `skip: ${skip}, length: ${length}`),
  map(text =&gt; text ) // I need now schoolId, how can i get
);
</code></pre>

<p>in the second map i need the schoolId. How can i get the schoolId without doing this:</p>

<pre><code>const source = combineLatest(skip$, length$, schoolId$).pipe(
  map(([skip, length, schoolId]) =&gt; ({text: `skip: ${skip}, length: ${length}`, schoolId})),
  map(text =&gt; `${text.text}, schoolId: ${text.schoolId}` )
);
</code></pre>

<p>here you have the <a href=""https://stackblitz.com/edit/rxjs-ah5mpp"" rel=""nofollow noreferrer"">stackblitz</a> to try</p>
","10053191","","","","","2020-01-24 10:10:24","Observable pipes","<rxjs><rxjs-pipeable-operators><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"60097260","1","","","2020-02-06 14:29:24","","3","826","<p>Let's assume we have a Subject, that can return a given set of values, all of which might require a different approach to them. We could debate whether or not that should ever be the case BUT not quite the point of my inquiry. </p>

<p>So...to handle that we might have our code look something like: </p>

<pre><code>var sub = new Subject(); 

sub.subscribe( 
    data =&gt; {
        if (caseA) {
            // do something
        }
        if (caseB) {
            // do something else
        }
     });
</code></pre>

<p>which is all swell and great and all...but I was wondering if there's some operator that we can chain to make it more rx-ish? Thought of filter, but chaining caseA and caseB will just make it not work (obviously) since it ends up filtering both out. </p>

<p>So, my question boils down to this: is it possible to have anything remotely resembling the bellow pseudocode? Any operator(s) you know that would work like this?</p>

<pre><code>var sub = new Subject(); 

sub.pipe(
    magicOperator(//handles caseA),
    magicOperator(//handles caseB),
)
subscribe( 
    data =&gt; {
        // handles common thread
     });
</code></pre>
","3278687","","","","","2020-02-07 06:23:03","RxJS pipe to filter into 2+branches","<javascript><rxjs><rxjs6><rxjs-pipeable-operators>","2","4","","","","CC BY-SA 4.0"
"60149866","1","60150308","","2020-02-10 11:54:31","","4","874","<p>I have two observable streams which do very separate mapping logic, but then ultimately end with following 3 operators:</p>

<pre><code>  this.selection
    .pipe(
      ..Custom mapping operators
      tap(_ =&gt; this.devicesLoading = true),
      switchMap(d =&gt; this.mapService.findLocationForDevices(d)),
      map(loc =&gt; marker([loc.latitude, loc.longitude])
    )
    .subscribe(markers =&gt; this.plotMarkers(markers));
</code></pre>

<p>I want to move the last <code>tap, switchMap, map</code> operators to a common function so I can just apply these within both of my observable streams.</p>

<p>I thought of doing:</p>

<pre><code>  private resolveLocationsAndConvertToMarkers = (devices: String[]) =&gt; [
    tap(_ =&gt; this.devicesLoading = true),
    switchMap((devices: string[]) =&gt; this.mapService.findLocationForDevices(devices)),
    map(loc =&gt; marker([loc.latitude, loc.longitude])
  ];
</code></pre>

<p>But I wasn't sure how to spread these operators into the pipe arguments, like:#</p>

<pre><code>      this.selection
        .pipe(
          // Custom mapping operators
          ... this.resolveLocationsAndConvertToMarkers
        )
        .subscribe(markers =&gt; this.plotMarkers(markers));
</code></pre>

<p>this errors that <code>there are no overloads that expect 3 or 5 arguments</code>..</p>
","12680986","","","","","2021-08-17 16:28:35","RxJs: Can you spread operators as arguments into pipe operator","<rxjs><rxjs-pipeable-operators><rxjs-observables>","3","0","","","","CC BY-SA 4.0"
"60158754","1","","","2020-02-10 21:32:14","","0","53","<p>I have the following function that should trigger an HTTP Get call (getPollResults) every 3 seconds. The problem that I'm seeing is that only the initial event fires. </p>

<pre><code>pollResults() {
  return timer(0, 3000)
  .pipe(
    switchMap(() =&gt;  this.pollService.setPollResults()),
    tap(results=&gt; {
      console.log(`updated results: `${results}`);
    })
  );
}

this.pollResults().subscribe()
</code></pre>

<p>If i remove the switchMap, it's working fine (I see a new console log every 3 seconds). So I believe it has to do with how switchMap works. Why would this be impeding on new events from the timer?</p>
","5332322","","","","","2020-02-10 21:57:11","Timer function not firing on subsequent events","<angular><rxjs><rxjs6><rxjs-pipeable-operators>","2","2","","","","CC BY-SA 4.0"
"60271980","1","60272571","","2020-02-17 23:58:20","","0","578","<p>I have made a multi select dropdown which is implemented like below </p>

<pre><code> MyFilter{
      key: string;      // uniquely identifies selected filter among many filters on page
      order: number;    // display order of filter on page
      options: DropListOption[];  // options in a dropdown
      values: DropListOption[];   // selected values from dropdown
    }  

 DropListOption{
    label: string;  // name of option
    value: any;     //value of option
   }
</code></pre>

<p>I have implemented a method which is called when a checkbox is selected or unselected as below:</p>

<pre><code>onSelect(key: string, option: DropListOption): void{
  const filtersOpt = this.filters;  // type of filter is MyFilter
  filtersOpt.map((filter) =&gt; {
    if(filter.key === key){
      const selected: boolean = !!filter.values.find((opt) =&gt; opt.value === option.value);
      filters.values = selected  // filters.values used as property binding to display number of selected values
                      ? filters.values.filter((opt) =&gt; opt.value !== option.value)
                      : [...filters.values, option];
    }
    return filter;
  });
  this.updateFilters.emit(filtersOpt); //emitting to parent component
}
</code></pre>

<p>Although my logic is working fine but being new to Angular/RxJS (front-end development), I am not very sure if my code is good code. Please can you let me know our thoughts or correct me. I would appreciate if someone can tell me any better way of implementing my onSelect() method.</p>
","12426044","","12426044","","2020-02-18 00:06:27","2020-02-18 01:32:58","Selecting and Unselecting values from a multi select dropdown in Angular 7","<angular><functional-programming><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"60553986","1","60556806","","2020-03-05 21:10:37","","4","2048","<p>Things I have tried include following where values is array of values of which I want to find the sum.</p>
<p>I have also added necessary functions from rxjs as follows:
I get an error saying</p>
<blockquote>
<p>typeError: Rx.Observable.from(...).sum is not a function</p>
</blockquote>
<pre><code>const { merge , interval ,from} = rxjs;
const { tap ,take ,sum } = rxjs.operators;   
             
var sumSource = Rx.Observable.from(values).sum(function (x) {
    return x;
});

var subscription = sumSource.subscribe(
    function (x) {
        console.log('Next: ' + x);
        x.target.value = x;
    },
    function (err) {
        console.log('Error: ' + err);
    },
    function () {
        console.log('Completed');
    }
);
</code></pre>
<p>Not much is available about sum on internet.Any inputs to fix and get the sum?</p>
","4206540","","6324775","","2020-10-28 10:37:53","2020-10-28 10:37:53","How to use sum operator of rxjs?","<javascript><rxjs><rxjs6><rxjs-pipeable-operators>","1","6","","","","CC BY-SA 4.0"
"60569209","1","60570110","","2020-03-06 17:48:58","","0","281","<p>Values is list of obervables over input fields</p>

<pre><code>    var example = combineLatest(values);
</code></pre>

<p>How do I find sum of values in text field.</p>

<pre><code>    example.subscribe(val =&gt; {
        console.log('Sum:', val);
    });
</code></pre>

<p>Having subscriber over it gives me output of the form </p>

<p><em>Sum: (2) [""1"", ""2""]</em></p>

<p>Piping over combineLatest gives me NaN</p>

<pre><code>     .pipe(reduce((acc, one) =&gt; {
         var a =Number(acc) + Number(one);
         console.log(a);
         return a;
     }, 0));
</code></pre>
","4206540","","","","","2020-03-06 19:00:20","How to find sum using reduce, pipe and combinelatest?","<javascript><rxjs><rxjs5><rxjs-pipeable-operators><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"60643851","1","","","2020-03-11 20:17:06","","0","24","<p>So I am trying to add an additional property to the objects inside the itemAlarms observables array.
This is one object in the itemsAlarm array:</p>

<pre><code>{
    ""id"": ""1"",
    ""healthType"": ""warning"",
    ""createdOn"": ""2020-03-11T05:47:14.38Z"",
    ""module"": ""00100"",
    ""version"": ""0"",
    ""index"": 14
}
</code></pre>

<p>I am trying to transform it to add this additional property in each object of the array:</p>

<pre><code>{
    ""id"": ""1"",
    ""itemsTypeId"": ""23"",
    ""healthType"": ""warning"",
    ""createdOn"": ""2020-03-11T05:47:14.38Z"",
    ""module"": ""00100"",
    ""version"": ""0"",
    ""index"": 14
}
</code></pre>

<p>Both of these observables have an Id that are the same one and that is how I am finding the itemTypeId to merge it into the itemAlarms objects. 
items has id and itemsAlarms has itemId that have primary and fk relationship.</p>

<pre><code>  this.items$ = this.itemsService.getEntities();
    this.itemsAlarms$ = this.itemsAlarmsEntityService.getEntities();

this.itemsAlarms$ = combineLatest([this.items$, this.itemsAlarms$]).pipe(
  map(([items, itemsAlarms]) =&gt; {
    itemsAlarms.forEach(alarm =&gt;
      Object.assign({ itemId: items.find(item =&gt; item.id === alarm.Itemid).itemTypeId}, itemsAlarms)
    );
    return itemsAlarms;
  })
);
</code></pre>

<p>I thought the itemsAlarm would be the new transfered array, but it is the exact result of the original. I feel like I am doing something small wrong.</p>

<p>This is an example of what I am trying to do, but without zip because I keep getting messages it is deprecated:
<a href=""http://jsbin.com/jiqofihoko/edit?js,console"" rel=""nofollow noreferrer"">http://jsbin.com/jiqofihoko/edit?js,console</a></p>
","10602563","","","","","2020-03-11 20:17:06","Returning the new value with Object.assign with combinedLatestest in rxjs","<angular><angular8><rxjs-pipeable-operators>","0","5","","","","CC BY-SA 4.0"
"60662552","1","60662610","","2020-03-12 22:18:50","","1","59","<p>Why are operators <code>tap</code> and <code>map</code> of inner observable not called? <code>combineLatest</code> should subscribe to observables it gets in <code>obsArr</code>, right? Why this subscription does not trigger those operators?</p>

<pre><code>const obsArr = [];

[[1, 2], [3, 4], [5, 6]].map(arr =&gt; {

  const observable = from(arr);

  observable.pipe(
    tap(item =&gt; {
      // this is NOT called
      console.log('tap', item)
    }),
    map(item =&gt; {
      // this is NOT called
      return item * -1;
    })
  );

  obsArr.push(observable);
});

combineLatest(obsArr).subscribe(latestValues =&gt; {
  console.log(latestValues);
  // LOG: [2, 4, 5]
  // LOG: [2, 4, 6]
});
</code></pre>

<p>Working stackblitz: <a href=""https://rxjs-y2h4rn.stackblitz.io"" rel=""nofollow noreferrer"">https://rxjs-y2h4rn.stackblitz.io</a></p>

<p>Thanks for explanation!</p>
","1212547","","","","","2020-03-12 23:09:02","Why operators (tap, map) are not called on inner observable, when using combineLatest?","<javascript><typescript><rxjs><rxjs-pipeable-operators><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"60703935","1","60704059","","2020-03-16 10:06:59","","0","127","<p>I have already consulted other questions regarding this issue but I have not pulled a spider out of the hole. I have to use distinct on an array of objects, with the code that I propose to you the distinct does not work and I have no errors in the console. How can I make it work?</p>

<p><strong>carRecent</strong></p>

<pre><code>export class CarRecent {

    id:number;
    carId:number;
    userId:number;
    imageURL:string;

}
</code></pre>

<p><strong>carsService</strong></p>

<pre><code> getRecentCars(userId){

    let params = new HttpParams().set('userId', userId);
    let options = {headers:this.headers, params:params};

    return this.http.get&lt;CarRecent[]&gt;(this.host + 'getRecentCars', options);

  }
</code></pre>

<p><strong>recentCar.component.ts</strong></p>

<pre><code>export class RecentCarsComponent implements OnInit {

  url:string = 'assets/';

  recentCars = new BehaviorSubject&lt;CarRecent[]&gt;(null);
  subscriptionRecentCars;

  constructor( public carsService:CarsService, public authService:AuthenticationService ) { }

  ngOnInit(): void {

    this.loadRecentCars();

  }

  loadRecentCars(){

    this.subscriptionRecentCars = this.carsService.getRecentCars(this.authService.currentUserValue.id)
    .pipe( 
      tap( cars =&gt; console.log(cars) ),
      distinct( (car:any) =&gt; car.carId )
    )  
    .subscribe({
        next:cars =&gt; {
          this.recentCars.next(cars);
        }
      })

  }

}
</code></pre>
","14023131","","","","","2020-03-16 10:22:13","how to use rxjs distinct on array of object","<angular><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"60907063","1","60907830","","2020-03-28 21:13:36","","0","133","<p>I have an <em>observable</em> which pumps a list of items. I need to <em>pipe</em> the observable so that each of the items would do an api call, update itself with the result from the api call and finally provide an updated list of items from the observable.</p>

<ul>
<li><p>Consider an array like below<br>
<code>[{id: 1, name: 'a'}, {id: 2, name: 'b'}, {id: 3, name: 'c'}]</code></p></li>
<li><p>Each item needs to do an api call which returns if its a 'new' or 'old' item<br>
GET <code>/api/type/:id</code> returns <code>new</code> / <code>old</code>  </p></li>
<li><p>Update the item to take the api result value on a new <code>type</code> property</p></li>
<li><p>Return the updated list<br>
<code>[{id: 1, name: 'a', type: 'new'}, {id: 2, name: 'b', type: 'old'}, {id: 3, name: 'c', type: 'new'}]</code></p></li>
</ul>

<p>What kind of <code>rxjs</code> operators can i use to do this? </p>
","1278141","","","","","2020-03-28 22:34:47","Pipe an observable to update list of items with result from api","<javascript><rxjs><observable><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"60946981","1","","","2020-03-31 09:08:25","","1","1221","<p>I have to catch the event emit of an event emitter in a pipe and perform some operations on the basis of that one.</p>

<p>Below is the snippet of code of both the html and ts file.</p>

<p>xyx.component.html</p>

<pre><code>    &lt;div *ngIf=""count | async as count""&gt;
  &lt;div style=""text-align: center""&gt;
    &lt;div&gt;{{ count.counter }}&lt;/div&gt;
    &lt;div&gt;
      &lt;input type=""button"" value=""start"" (click)=""start.emit()""&gt;
      &amp;nbsp;
      &lt;input type=""button"" value=""stop"" (click)=""stop.emit()""&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<hr>

<p>xyx.component.ts</p>

<pre><code>@Component({
  selector: 'xyz-app',
  templateUrl: './xyz.component.html',
  styleUrls: ['./xyz.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class XYZComponent {
  public readonly count: Observable&lt;{
    counter: number,
  }&gt;;

  public readonly start: EventEmitter&lt;void&gt; = new EventEmitter();
  public readonly stop: EventEmitter&lt;void&gt; = new EventEmitter();

  constructor() {
    this.count = interval(1000).pipe(
      map(counter =&gt; counter + 1),
      startWith(0),
      map(counter =&gt; ({counter})),
    );
  }
}
</code></pre>

<p>What should I do in the pipe to catch that event emit and perform the start and stop operation of counter.</p>
","11775604","","","","","2020-03-31 13:23:26","How can we catch an event emit of an event emitter in a pipe of rxjs","<angular><rxjs><pipe><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"60978632","1","","","2020-04-01 19:14:19","","0","251","<p>I have an Angular application (9) and have multiple components that request calculation operations over rest and the displays the result in different editors.
Now before I make the request I call a loading panel and after the request fininished I hide the loading panel in the finalize callback. Something like this:</p>

<pre><code>this.isloading = false;
httpclient.get('http://localhost/calculate').pipe(finalize(() =&gt;this.isloading=false).subscribe(v=&gt;{
 //make some operations with the data and set editor values
});
</code></pre>

<p>now the loading panel disappers before all editor values are set. The finalize callback is called directly if the request fininishes, but how to call something like finalize, if the code inside of subscribe or error finishes?</p>
","1959238","","","","","2020-04-01 19:23:41","Rxjs finalize after code in subscribtion ends","<angular><observable><rxjs6><rxjs-pipeable-operators><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61023712","1","61043499","","2020-04-04 04:20:01","","0","72","<p>I am trying to find a way to run some code only if there was no error in a given rxjs chain. Consider the following, is there something like the artificial <code>NO_ERROR_OCCURED_RUN_HAPPY_PATH_CODE</code> operator in rxjs?</p>

<pre class=""lang-js prettyprint-override""><code>private wrap(obs: Observable&lt;any&gt;): Observable&lt;any&gt; {
  return of(1).pipe(
    tap(() =&gt; this.spinner.startSpinner()),
    mergeMap(() =&gt;
      obs.pipe(
        NO_ERROR_OCCURED_RUN_HAPPY_PATH_CODE(() =&gt; this.generic_success_popup()),
        catchError(this.handleError),            
      )
    ),
    finalize(() =&gt; this.spinner.stopSpinner())
  );
}
</code></pre>
","7698435","","5583283","","2020-04-05 01:51:03","2020-04-05 13:39:05","How to run some code in an RxJS chain given there were no errors","<rxjs><rxjs-pipeable-operators><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"61086134","1","","","2020-04-07 17:43:01","","0","65","<p>I am a complete beginner. 
The issue I am having is that once I throw an error in rxjs observable, my test doesn't know about it. When I am subscribing in a test, and it fails within rxjs it just throws an error and I need to notify my test that the error occurred. Here's a more simple example that shows that ""test failed"" is never printed.</p>

<pre><code>import { sample } from ""rxjs/operators"";
const source = interval(1000);
// sample last emitted value from source every 2s
// output: 2..4..6..8..
const example = source.pipe(sample(interval(2000)));
async function test_runner() {
    setup();
    try {
        await test();
        console.log(""test succeeded"");
    } catch (e) {
        console.log(""test failed"");
    }
}
async function setup() {
    console.log(""setup"");
    const subscribe = example.subscribe((val) =&gt; {
        console.log(val);
        if (val === 4) {  throw Error(""error!""); }
    });
}
async function test() {
    console.log(""test"");
    await waitMs(10000);
}

test_runner();

async function waitMs(waitTime: number): Promise&lt;void&gt; {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve();
        }, waitTime);
    });
}
</code></pre>

<p>Is there a way to handle this? I appreciate any help.</p>
","11556744","","","","","2020-04-07 21:01:13","When you subscribe with rxjs, how do you signal to your test if it fails?","<rxjs><rxjs-pipeable-operators><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"61492443","1","61492526","","2020-04-29 00:53:41","","0","138","<p>I am using a route guard (or resolver, I have tried to use either but got the same error) where I want to get Observable as a return value:</p>

<pre><code>canActivate(): Observable&lt;boolean&gt; {
    return this.store.pipe(
      select(fromUserProfileState.getUserProfiles),
      tap((loaded: UserProfile[]) =&gt; {
        if (!loaded || loaded.length == 0) {
          this.store.dispatch(new fromUserProfileActions.LoadUPs());
        } else {
          return of(true);
        }
      }),
      filter((loaded: UserProfile[]) =&gt; loaded.length &gt; 0),
      first()
    );
  }
</code></pre>

<p>However, this doesn't return Observable, it returns Observable which is not acceptable. How can I tweak the rxjs (v 6.5.5) operators to return Observable only?</p>

<p><a href=""https://i.stack.imgur.com/b80Rt.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/b80Rt.png"" alt=""enter image description here""></a></p>
","6741619","","","","","2020-04-29 01:45:21","Angular route guard/resolver - Type 'Observable<boolean | object[]>' is not assignable to type 'Observable<boolean>'","<angular><typescript><rxjs6><rxjs-pipeable-operators><rxjs-observables>","3","0","","","","CC BY-SA 4.0"
"61628903","1","","","2020-05-06 06:40:15","","0","92","<p>I have done quite a bit of research before deciding to post the questions here. My knowledge of how Angular (or generally) handles HTTP error is very cloudy, so I am looking for some clarification/suggestion.</p>

<p>To make things simple, let's say I have a rest API <code>GET http://example.com</code> that will returns <code>{error: 'Error message'}</code> or <code>{data: 'Data is available'}</code> randomly where <code>error</code> indicates something went wrong (the request completed successfully, but there is some internal error) and <code>data</code> indicates that everything works fine.</p>

<p>Now, there are 2 things that, to my understanding, need handling. The first thing is to handling when the request fails, for example, network error, blocked by CORS, etc., and the second thing is to handle a successful request, but see if it is <code>error</code> or <code>data</code>.</p>

<p><strong>TL;DR: How can I transform the below jQuery into Angular?</strong></p>

<p>Normally, with jQuery, this is what I would do:</p>

<pre><code>$.get('http://example.com').done(data =&gt; {

    if ('error' in data) console.log('Request completed, but there is an error in the remote server');
    else console.log('Everything completed successfully');

).fail(error =&gt; {

    console.log('Error while requesting data', error);

});
</code></pre>

<p>Now in Angular, things get complicated and I no matter what I try, I can't seem to throw an error (all functions are properly imported):</p>

<pre><code>//service.ts
    getStatus() {

        return this.http.get('https://test.com/')
        .pipe(
            map(data =&gt; {
                if ('error' in data) {
                    //I would like to throw an error that can be caught at subscribe(done, error) later
                    //But this rxjs won't throw anything, subscribe() will still resolve with done()
                    return throwError('Request completed, but there is an error in the remote server');
                }
                return data;
            }),
            tap(data =&gt; {
                //Process the data, should not be called if map() throwError()?
            },
            catchError(error =&gt; {
                //I assume this is where the HTTP request failed due to network, CORS, etc.
                return throwError('Error while requesting data');
            })
        );

    }
</code></pre>

<pre><code>//app.ts
    this.service.getStatus().subscribe(data =&gt; {

        //I expect this function to be called ONLY if there was no throwError(), but that wasn't the case
        //No matter what I try in `service.ts`, this will always be called

    }, (error) =&gt; {

       //I expect this to call when throwError() is called from `service.ts` but it never happens

    });
</code></pre>

<p>I also read another suggestion to use <code>catch()</code> on <code>subscribe()</code> but <code>catch()</code> was never a method on a Subscription:</p>

<pre><code>//app.ts
    this.service.getStatus().subscribe(data =&gt; {

        //I expect this function to be called ONLY if there was no throwError(), but that wasn't the case
        //No matter what I try in `service.ts`, this will always be called

    }).catch(error =&gt; {

        //This is not valid

    });
</code></pre>

<p>None of what I tried has worked, and there are multiple places within the pipe I can <code>throwError()</code> but I'm not quite sure what their differences are (example, <code>catchError()</code> in <code>service.ts</code> and <code>error</code> from <code>subscribe(success, error)</code> in <code>app.ts</code>.</p>
","3622260","","13860","","2020-05-09 12:54:04","2020-05-09 12:54:04","How to throwError properly and what are the meaning of different error catchers in Angular HTTP","<angular><rxjs><rxjs-pipeable-operators>","1","1","","2020-05-07 00:03:14","","CC BY-SA 4.0"
"61647684","1","61647811","","2020-05-07 00:16:29","","0","24","<p>I have the next pipe:</p>

<pre class=""lang-js prettyprint-override""><code>this.adminService.companies$
      .pipe(
        takeUntil(this.unsubscriber),
        map((data: CompanyCard[]) =&gt; {
          const companies: CompanyCard[] = [...data.map(company =&gt; ({...company}))]

          companies.forEach((company: CompanyCard) =&gt; {
            if ('_seconds' in company.created) {
              company.created = new Date(company.created._seconds * 1000)
            }

            if (company.owner) {
              this.userService.getUser(company.owner).pipe(
                take(1),
                takeUntil(this.unsubscriber),
                map((data: User) =&gt; data.email)
              ).subscribe(email =&gt; company.owner = email)
            }
          })

          return companies;
        }),
        tap(companies =&gt; this.companies = companies)
      ).subscribe();
</code></pre>

<p>My problem is when I render this data in the template, I see the blinking content because I get the data before all transforms inside <code>map()</code> finishes. So I guess I have to wrap all operators in <code>forkJoin</code>, but I do not know how to do it properly.</p>
","7325495","","","","","2020-05-07 00:29:51","How to correctly implement forkJoin in my pipe","<rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"61727665","1","61727881","","2020-05-11 10:35:57","","0","366","<p>I am working on an app using Angular 9 and RxJS 6.5. The functionality I have problems with uses Angular services to fetch some data from a server and provides this data to views (using RxJS behaviorSubjects). Before passing that data to the views though, I want to do some unit conversion, so that the user can use a toggle/switch to change between two units for the entire app, specifically ""metric tons"" and ""short tons"".</p>

<p>While the actual conversion functions are provided within a dedicated service, I need to control which properties of the data (that was fetched by the server) should be converted, so I am ""piping"" the subjects, calling the conversion methods inside the pipe.</p>

<pre class=""lang-js prettyprint-override""><code>// This ""CommoditiesService"" fetches data from the server
// and should return all fetched commodities, so ""Commodity[]""
export class CommoditiesService {
    // Inside this subject, all Commodities are stored (without unit conversion)
    private _commodities: BehaviorSubject&lt;Commodity[]&gt; = new BehaviorSubject(null);

   public readonly commodities: Observable&lt;Commodity[]&gt; = this._commodities.pipe(
    // This pipe is where all unit conversions for commodities is happening,
    // so for every commodity, the function ""convertCommodityUnits"" is called.
    // the arguments there are the base and the target unit. Base is always kilogram, as this is what the server returns.
    // The target unit is what the user can set globally. This ""preferredWeightUnit"" is subscribed to inside the service, so it is updated once the user changes the unit.

    map((commodities: Commodity[]) =&gt; {
      // For every commodity, convert Price and inventory into the prefered display unit
      return commodities?.map(commodity =&gt; this.convertCommodityUnits(commodity, ""kg"", this.preferedWeightUnit)) || null;
    })
  );
}
</code></pre>

<p>So far this works like a charm: The units are converted and views can subscribe to the commodities observable.
The problem is now, when the user updates the ""preferredWeightUnit"", the ""commodities"" observable is not re-evaluated, so ""this.preferredWeightUnit"" is updated inside CommoditiesService, but the unit conversion is not done again.</p>

<p>I suppose I could update the subject with the same data, so calling <code>this._commodities.next(this._commodities.value)</code>, but this just looks wrong to me.</p>

<p>How could I trigger the unit conversion (so the RxJS pipe) again once the prefered unit changed?
Also, is this design choice even a good idea to make the units changable in a reactive way? I thought it was better then changing the units inside views everywhere they might appear.</p>
","5254957","","","","","2020-05-11 10:48:06","Angular/RxJS update piped subject manually (even if no data changed), ""unit conversion in rxjs pipe""","<angular><rxjs><angular-services><rxjs-pipeable-operators><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61745849","1","61746442","","2020-05-12 07:13:47","","0","237","<p>I am working on an Angular 9, RxJS 6 app and have a question regarding the different outcomes of piping subject values and doing unit conversion in that pipe.</p>

<p>Please have a look at <a href=""https://stackblitz.com/edit/ng-rxjs-pipe-question"" rel=""nofollow noreferrer"">this stackblitz</a>. There, inside the <code>backend.service.ts</code> file, an observable is created that does some ""unit conversion"" and returns everything that is emmitted to the _commodities Subject. If you look at the <code>convertCommodityUnits</code> function, please notice that I commented out the working example and instead have the way I solved it initially.</p>

<p>My question: When you use the unsubscribe buttons on the screen and subscribe again, when using the ""conversion solution"" that just overrides the object without making a copy, the values in the HTML are converted multiple times, so the pipe does not use the original data that the subject provides. If you use the other code, so creating a clone of the commodity object inside <code>convertCommodityUnits</code>,  it works like expected.</p>

<p>Now, I don't understand why the two ways of converting the data behave so differently. I get that one manipulates the data directly, because js does <a href=""https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing"" rel=""nofollow noreferrer"">Call by sharing</a> and one returns a new object. But the object that is passed to the <code>convertCommodityUnits</code> function is created by the <code>array.prototype.map</code> function, so it should not overwrite anything, right? I expect that RxJS uses the original, last data that was emitted to the subject to pass into the pipe/map operators, but that does not seem to be the case in the example, right?</p>

<p>How/Why are the values converted multiple times here?</p>

<p>This is more or less a follow-up question on this: <a href=""https://stackoverflow.com/questions/61727665/angular-rxjs-update-piped-subject-manually-even-if-no-data-changed-unit-conv"">Angular/RxJS update piped subject manually (even if no data changed), &quot;unit conversion in rxjs pipe&quot;</a>, so it's the same setup.</p>
","5254957","","5254957","","2020-05-12 07:19:05","2020-05-12 08:36:27","Difference between returning a copy or manipulating original objects in array.prototype.map (In RxJS pipe)","<javascript><angular><rxjs><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"61884807","1","","","2020-05-19 06:45:45","","2","753","<p>I'm using RxJS <code>shareReplay()</code> operator on an observable (<code>courses$</code>) to share observable stream among other two observables (<code>beginnerCourses$</code> and <code>advancedCourses$</code>). It's working fine and single API call response is shared between both observables on success.</p>

<p>But, when it comes to error, these observable don't share error and error is seen to be thrown twice in the browser console. Doesn't <code>shareReplay()</code> operator shares error also? Is it an intended behavior?</p>

<pre class=""lang-js prettyprint-override""><code>const http$ = createHttpObservable('/api/courses');

const courses$ = http$
  .pipe(
    map(res =&gt; res['payload'] ),
    shareReplay(),
    catchError(err =&gt; {
      return throwError(err);
    })
  );

this.beginnerCourses$ = courses$
  .pipe(
    map(courses =&gt; courses
      .filter(course =&gt; course.category === 'BEGINNER')));

this.advancedCourses$ = courses$
  .pipe(
    map(courses =&gt; courses
      .filter(course =&gt; course.category === 'ADVANCED')));

}
</code></pre>
","6848923","","","","","2020-05-19 10:55:19","RxJS: Even if used `shareReplay()` on source observable, `throwError()` gets executed separately for each observable","<rxjs><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"61933968","1","","","2020-05-21 11:55:24","","0","43","<p>I have an input of a string array for Enums I want to recieve from server:</p>

<pre><code>enumList = ['somethin','branch','country', 'serviceType', 'thatandthis'];
</code></pre>

<p>I then have a generic http-service method that takes an <strong>enumList</strong> string as a parameter and returns an HttpClient observable for that Enum service:</p>

<pre><code>this.webApi.getEnumByName('somethin','en').subscribe((res)=&gt;{/*do something*/})
this.webApi.getEnumByName('branch','en').subscribe((res)=&gt;{/*do something*/})...
</code></pre>

<p>I'm than combining the two into a loop</p>

<pre><code>   for (const item of this.enumList) {
      this.webApi.getEnumByName(item).subscribe((res: any) =&gt; {
          this.enums[item] = res;
      });
    } 
</code></pre>

<p>But this is not good...
I want the a subscription that completes only once when all subscriptions has resolved, while keeping a reference to the associated <strong>item string</strong> 
<br/><br/>
using an array of observables returned from this.webApi.getEnumByName(item), <strong>concat or forkJoin won't work because they won't keep refference to the associated string/key/token of the response</strong> e.g the string in the enumList.
<br/> <br/></p>

<p>The end result of these concatinated observables should be:</p>

<pre><code>{
    'somethin':{respopnse...},
    'branch':{respopnse...},
    'country':{respopnse...},
    'serviceType':{respopnse...},
    'thatandthis':{respopnse...}
}
</code></pre>

<p>breaking my head on this will appriciate an rxjs solution</p>
","2557085","","","","","2020-05-21 15:26:51","subscribing to multiple observable while keeping reference to function parameters","<rxjs><angular8><angular9><rxjs-pipeable-operators><rxjs-observables>","3","0","","","","CC BY-SA 4.0"
"61953826","1","61953968","","2020-05-22 11:19:08","","0","74","<p>In ngOnChanges I listen Input data to component.</p>

<pre><code>ngOnChanges(): void {
    from(this.zuPrimaryData).pipe(
      max((a, b) =&gt; a[""nu""] - b[""n""])
    ).subscribe((data) =&gt; {
      console.log(data);
    });
  }
</code></pre>

<p>First time <code>this.zuPrimaryData</code> comes as <code>null</code> ir arises error, thus ngChanges works.</p>

<p>How to handle this and dont create stream if null?</p>

<p>This code is not get me data in template:</p>

<pre><code>  ngOnChanges(): void {
    this.zu$ = iif(() =&gt; this.data, from(this.data)).pipe(
      max((a, b) =&gt; a[""n""] - b[""n""]),
      map((data) =&gt; data)
    );
  }
</code></pre>

<p>Template is:</p>

<pre><code>{{zu$ | async }}
</code></pre>
","","user13406409","","user13406409","2020-05-22 11:55:31","2020-05-22 12:07:45","How to handle error rxjs using operator from?","<angular><rxjs><angular8><rxjs-pipeable-operators>","3","0","","","","CC BY-SA 4.0"
"61972724","1","","","2020-05-23 13:25:50","","1","868","<p>I'm trying to filter an observable of products with an array of filters but i really don't know how..</p>

<p>Let me explain, I would like to set the result of my filtering to filteredProducts.
For filtering i have to check, for each filter, if the product's filter array contains the name of the filter and if the products values array's contains filter id.</p>

<p>For the moment, the filter works but only with the last selected filter and i'd like to filter products list with all filters in my selectedFilters array. I can have one or multiple filters.</p>

<p><a href=""https://stackblitz.com/edit/angular-ivy-bhkjre?file=src%2Fapp%2Fapp.component.ts"" rel=""nofollow noreferrer"">StackBlitz</a></p>

<pre><code>export class ProductsFilterComponent extends BaseComponent implements OnInit {
    @Select(FiltersState.getAllFilters) filters$: Observable&lt;any&gt;;
    @Input() products$: Observable&lt;Product[]&gt;;
    filteredProducts$: Observable&lt;Product[]&gt;;
    public selectedFilters = [];

    constructor(
        private store: Store) { super(); }

    ngOnInit() {
        this.store.dispatch(new GetAllFilters());
    }

    private filterProducts() {
        this.filteredProducts$ = this.products$.pipe(
            map(
                productsArr =&gt; productsArr.filter(
                    p =&gt;
                        p.filters.some(f =&gt; this.selectedFilters.some(([selectedF]) =&gt; selectedF === f.name.toLowerCase()) // Filter name
                            &amp;&amp; f.values.some(value =&gt; this.selectedFilters.some(([, filterId]) =&gt; filterId === value)) // Filter id
                        )
                )
            )
        );
        this.filteredProducts$.subscribe(res =&gt; console.log('filtered:', res));
    }
}
</code></pre>

<p>Here's the structure of a product object
<a href=""https://i.stack.imgur.com/o7LPb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/o7LPb.png"" alt=""Here&#39;s the structure of a product object""></a></p>

<p>Here's the structure of selectedFilters
<a href=""https://i.stack.imgur.com/BfoqL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BfoqL.png"" alt=""enter image description here""></a></p>

<p>A big thank you in advance :-).</p>
","11346839","","11346839","","2020-05-23 16:24:58","2020-05-23 16:24:58","Angular rxjs filter observable","<angular><filter><rxjs><observable><rxjs-pipeable-operators>","1","4","","","","CC BY-SA 4.0"
"62008855","1","62009117","","2020-05-25 18:52:14","","0","51","<p>Apologies for the newbie/dump question about RxJS, just started since I am learning Angular.</p>

<p>So I've created an asynchronous validator static method that calls an API service method checking the uniqueness of username in the database. The code snippets below works when the backend server is up and running. When it is not, it prints an error log message which I should be handling in the presentation component instead.</p>

<p>What am missing here in the transformation step to handle such generics use case to convert both <code>Observable&lt;SuccessResponse&gt;</code> and <code>Observable&lt;ErrorResponse&gt;</code> to <code>Observable&lt;ValidationErrors | null&gt;</code>.</p>

<p><strong>Validator</strong></p>

<pre><code>static usernameUnique(service: ApiService): AsyncValidatorFn {
    return (control: FormControl): Observable&lt;ValidationErrors | null&gt; =&gt; {
        return service.isUsernameTaken(control.value as string)
            .pipe(
                map((response: SuccessResponse) =&gt; response.data ? { taken: true } : null)
            );
    };
}
</code></pre>

<p><strong>ApiService</strong></p>

<pre><code>isUsernameTaken(username: string): Observable&lt;SuccessResponse | ErrorResponse&gt; {
    return this.httpCient.get('/backend/account/checkUnique', { params: { username: username } })
                .pipe(catchError(this.handleError));
}

handleError(error: HttpErrorResponse) : Observable&lt;ErrorResponse&gt; {
    // return specific payload of ErrorResponse based on error.status
}
</code></pre>

<p>Thanks in advance.</p>
","999452","","","","","2020-05-25 19:56:28","Observable transformation to handle backend server error","<angular><rxjs><rxjs-pipeable-operators><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"62031824","1","","","2020-05-26 21:37:10","","0","30","<p>In general we need behavior subject functionality. But  only on first subscription we should send subscribe to server in REST. And to send unsubscribe on the last unsubscribe, and all late observers subscribed will gwt the latest json recwived from the first. can i do it using rxjs operaTors and how? or shoul i use custom obserbale ?</p>

<p>currently the custom code for this is this:</p>

<pre><code>public observable: Observable&lt;TPattern&gt; = new Observable((observer: Observer&lt;TPattern&gt;) =&gt; {
 this._observers.push(observer);
 if (this._observers.length === 1) {
  this._subscription = this.httpRequestStream$
    .pipe(
      map((jsonObj: any) =&gt; {
        this._pattern = jsonObj.Data;
        return this._pattern;
      })
    )
    .subscribe(
      (data) =&gt; this._observers.forEach((obs) =&gt; obs.next(data)),
      (error) =&gt; this._observers.forEach((obs) =&gt; obs.error(error)),
      () =&gt; this._observers.forEach((obs) =&gt; obs.complete())
    );
}
if (this._pattern !== null) {
  observer.next(this._pattern); // send last updated array
}
return () =&gt; {
  const index: number = this._observers.findIndex((element) =&gt; element === observer);
  this._observers.splice(index, 1);
  if (this._observers.length === 0) {
    this._subscription.unsubscribe();
    this._pattern = null; // clear pattern when unsubscribed
  }
};
</code></pre>

<p>});</p>
","3982102","","3982102","","2020-05-27 08:42:37","2020-05-27 08:42:37","how to use multicasting obs with behavioursubject?","<rxjs><rxjs-pipeable-operators><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"62050173","1","","","2020-05-27 18:20:12","","1","112","<p>In my html i am using async pipe to subscribe the observable like shown below.</p>

<pre><code>&lt;button  (click)=""getData(1)"" &gt;getUser1&lt;/button&gt;
&lt;button style=""margin:50px;"" (click)=""getData(2)"" &gt;getUser2&lt;/button&gt;
&lt;div&gt;------------------------------------------&lt;/div&gt;
&lt;div *ngIf=""userData$ |async as user""&gt;
data is{{  user | json}}&lt;/div&gt;
</code></pre>

<p>and this userData$ observable become new each time user click on button1 or 2.</p>

<pre><code>  getData(id) {

   this.userData$ = this.getDataFromBackend(id);
  }

 getDataFromBackend(id) {
    //delay added to simulate network delay
    // fake backend call but i have to use real one in actual project
  return of(this.dataSource[id]).pipe(delay(1000));
  }
</code></pre>

<p>now whenever user change from user1 to user2 the new observable is assigned. and since this new observable takes some time to get data for that time being it shows empty.</p>

<p>can we do something so that till the time the new observable data is not return we can show the previous data. </p>

<pre><code>  I can not user loader here meanwhile.
  I know i can do something like 
  let subject = new Subject();
  let userObservable$ = subject.asObservable()
  and use this observable in the html
  and the subscribe to these observable form getDataFromBackend() here in the class and from 
  subscription do the subject.next() and it will send the updated value
  but this does not seem the best way as it do the manual subscription in the component
</code></pre>

<p>below is the linke for stackblitz showing the problem.</p>

<p><a href=""https://stackblitz.com/edit/angular-ivy-d9nsxu?file=src%2Fapp%2Fapp.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-ivy-d9nsxu?file=src%2Fapp%2Fapp.component.ts</a></p>
","9834715","","","","","2020-05-29 04:38:12","How to show the data of prev observable till the time new observable emit the value","<angular><rxjs><observable><angular2-observables><rxjs-pipeable-operators>","4","1","","","","CC BY-SA 4.0"
"62057510","1","","","2020-05-28 05:17:05","","0","71","<p>I am using Angular 5 and loading a list of items using a selector with my NGRX library. My selector returs a list of items which I used to dynamically create tabs on a page using the async pipe. Now, when a user clicks on a tab, I want to fire off another selector to go fetch data from my NGRX store, which may or may not exist, ad could trigger an API request in the effect and updated by the reducer. All that works fine.</p>

<p>My issue is, I have a variable number of tabs, which could potentially trigger multiple async requests, and I want to bind the response to each of these requests to the right tab. I'm not sure how to do that? 
I have my code like this:</p>

<p>this.store$
            .select(getTabContent(id)).pipe(takeUntil(this.onDestroy$), take(1)).subscribe((data) => { ...};</p>

<p>but would rather use an async pipe, and I'm not sure if this is the best way to do it using the reactive library. How can I create variable async pipes and be able to bind to specific tabs in my case?</p>
","4849537","","","","","2020-05-28 08:07:55","Creating multiple async pipes of unknown number","<angular><rxjs><rxjs5><async.js><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"62141648","1","62141649","","2020-06-01 21:59:48","","4","5457","<p>A very common problem when using RxJs seems to be to want the result of one or more observables to then use them in subsequent ones.</p>

<p>e.g. in pseudo-code (This is not rx or valid js syntax deliberately)</p>

<pre><code>var someResult = $observable-A; // wait to complete
var finalResult = $observable-B(someResult.aValueINeed);
</code></pre>

<p>This can be done in an ugly way where you could subscribe to both and call one inside the other.. however, this is very messy and doesn't afford you much flexibility.</p>

<p>e.g. (real syntax)</p>

<pre><code>$observable-A.subscribe(resultA =&gt; { 
    $observable-B(resultA.aValueINeed)
        .subscribe(resultB =&gt; { 
            console.log('After everything completes: ', resultB); 
        }
}
</code></pre>

<p>This also means that nothing else can easily consume this stream as you're completing both of the observables.</p>

<p>My specific use case requires the following:</p>

<ol>
<li>An initial call to get $observable-A as it doesn't require anything else (it's a basic http GET call)</li>
<li>An http GET call to another service that requires data from $observable-A, which returns $observable-B</li>
<li>Using both observable results (A + B) to create an object for my service (In my case, an Angular service) to return a single list.</li>
</ol>

<blockquote>
  <p>I also need to be able to subscribe to this function inside my service, this is why going with the subscribe method above, won't work for me.</p>
</blockquote>
","8974088","","","","","2020-06-01 21:59:48","RXJS How do I use the result of one observable in another (and then process those two results together)","<angular><rxjs><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"62161099","1","62167779","","2020-06-02 20:43:28","","3","1053","<p>I'm trying to achieve what is described here: <a href=""https://www.prestonlamb.com/blog/rxjs-cache-and-refresh-in-angular"" rel=""nofollow noreferrer"">https://www.prestonlamb.com/blog/rxjs-cache-and-refresh-in-angular</a></p>

<p>In other words, I want to cache an observable, during a given time (let's say 1minute). When a subscription is made after that given time, data should be retrieved again and cache again for 1 minute.</p>

<p>Example of the expected result: </p>

<pre><code>T 00:00: Request (1) =&gt; RETRIEVE data
T 00:10: Request (2) =&gt; data from cache
T 00:35: Request (3) =&gt; data from cache
T 00:50: Request (4) =&gt; data from cache
T 01:10: Request (5) =&gt; RETRIEVE data
T 01:15: Request (6) =&gt; data from cache
T 01:30: Request (7) =&gt; data from cache
T 02:30: Request (8) =&gt; RETRIEVE data
</code></pre>

<p>The shareReplay operator is working fine to cache data for a given time, but I'm not able to re-launch it when that given time is elapsed.</p>

<p>Example using shareRelay(1, 1000) operator:</p>

<pre><code>T 00:00: Request (1) =&gt; RETRIEVE data
T 00:10: Request (2) =&gt; data from cache
T 00:35: Request (3) =&gt; data from cache
T 00:50: Request (4) =&gt; data from cache
T 01:10: Request (5) =&gt; no response
T 01:15: Request (6) =&gt; no response
T 01:30: Request (7) =&gt; no response
T 02:30: Request (8) =&gt; no response
</code></pre>

<p>The link above try to change that behavior using first operator catching null results. Unfortunately, it's not working fine as data is not cached after the first time.</p>

<p>Here's what I've got using the article of the above link (following picture is describing the code used)</p>

<p><a href=""https://i.stack.imgur.com/jVVeW.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jVVeW.jpg"" alt=""code details""></a></p>

<p>Result I've got:</p>

<pre><code>T 00:00: Request (1) =&gt; RETRIEVE data
T 00:10: Request (2) =&gt; data from cache
T 00:35: Request (3) =&gt; data from cache
T 00:50: Request (4) =&gt; data from cache
T 01:10: Request (5) =&gt; RETRIEVE data
T 01:15: Request (6) =&gt; RETRIEVE data
T 01:30: Request (7) =&gt; RETRIEVE data
T 02:30: Request (8) =&gt; RETRIEVE data
</code></pre>

<p>I've also seen some example with the timer operator, but in that cases, data is retrieved every minute, even if there is no subscribtion on it. I do not want to refresh data every minute, I want to expire cache every minute. Unfortunately, I've lost the code with the timer operator, but the result was something like that:</p>

<p>Result with timer operator:</p>

<pre><code>T 00:00: Request (1) =&gt; RETRIEVE data
T 00:10: Request (2) =&gt; data from cache
T 00:35: Request (3) =&gt; data from cache
T 00:50: Request (4) =&gt; data from cache
T 01:00: NO REQUEST =&gt; RETRIEVE data
T 01:10: Request (5) =&gt; data from cache
T 01:15: Request (6) =&gt; data from cache
T 01:30: Request (7) =&gt; data from cache
T 02:00: NO REQUEST =&gt; RETRIEVE data
T 02:30: Request (8) =&gt; data from cache
</code></pre>

<p>Anyone with a ""pure"" RxJS solution to do what I want?</p>
","863581","","","","","2020-06-18 11:07:42","Cache Http requests using only RxJS operators","<caching><rxjs><rxjs-pipeable-operators>","3","2","1","","","CC BY-SA 4.0"
"62180284","1","","","2020-06-03 18:37:26","","0","137","<p>I'm using an rxjs observable to model a sequence of steps that occurs in my app.</p>

<p>Pseudocode</p>

<pre><code>const steps = [{id: ""step1""}, {id: ""step2""}, {id: ""step3""}]

//... then at some point later do things based on the steps
from(steps).pipe(
    concatMap((step) =&gt; {
        ... do stuff with each step, perhaps including needing to go back to previous step
    })
)
</code></pre>

<p>Given this pattern how might I model ""going back"" if some condition makes it necessary?</p>

<p>For example going from step1 -> step2 -> step3 -> step2 -> step3</p>

<p>From what I can tell rxjs seems to be pretty strictly one-way-linear. I haven't found a way to set the position/index of an observable (if that's the right way to conceptualize it).</p>

<p>Apologies if I'm missing something obvious but it seems like this could be a fairly common use case for observables created from arrays.</p>
","1294382","","","","","2020-06-04 15:24:27","How to set current index of or move backwards though an rxjs observable?","<rxjs><rxjs6><rxjs-pipeable-operators><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"62213554","1","62213861","","2020-06-05 10:45:42","","2","745","<p>I have a fetchDrives method which will return an observable which on subscription will return a list of drives</p>

<pre><code>this.fetchDrives(points).subscribe(drives =&gt; {
     console.log(drives);
});
</code></pre>

<p>Assume The drives array which I got on subscription look some what like this</p>

<pre><code>[ {driveId: 1}, {driveId: 2}, {driveId: 3} ]
</code></pre>

<p>Now I need to use the driveId one by one and make three calls ( three because length of the drives array is 3 ) by passing driveId to each api call.I need to pass driveId to the below method one at a time and get the lat and lon and store the result of three calls in an array.</p>

<pre><code>this.getLatLong(driveId).subscribe( res =&gt; console.log(res))
</code></pre>

<p>The res will contain an object like <code>{ lat: 12, lon: 54 }</code></p>

<p>I don't want to do two subscriptions, is there a way I can use the Rxjs operators and achieve this with one subscription using the result of previous observable, loop through the drives array and make three calls to <code>getLatLong</code> method using <code>mergeMap</code> as the sequence of the calls doesn't matter and store the result of those three calls in an array?</p>

<p>I tried using scan operator to loop through but failed to use it to get the desired output</p>

<p>Thanks for the help in advance :)</p>
","6072233","","6072233","","2020-06-05 10:57:58","2020-06-05 11:39:48","Using MergeMap with the array of data received from another observable - RxJs Angular","<javascript><angular><rxjs><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"62254792","1","62261290","","2020-06-08 03:59:19","","2","83","<p>I want to display partial results of an analysis as the data comes in. It would be very inefficient to recompute for each new value (as with 'scan'). However, in this case, I can do the analysis on chunks of the data and combine those results. So I've been using 'window' to break up the data and then 'scan' to combine the results of each window calculation. The result is itself an observable, so it would be very natural to emit that as a nested observable. Also, the next step in the process works really well when consuming observables.</p>

<p>However, I couldn't get this to work as I expected. (I did make it work with an awkward step of turning the inner observables into arrays and later back into observables.) It seems there is something I don't understand about ""window"" and/or ""scan"".</p>

<p>Here are two examples that differ in how I produce the nested observable. I'd have expected the following two examples to give the same result, but they do not.</p>

<p>In the first, I create the nested observable directly. In the second, I create it with the window operation. Then, in both cases, I apply the same scan to the nested observable. </p>

<p>This behaves as I expected:</p>

<pre><code>rxjs.from([rxjs.from([1, 2]), rxjs.from([3, 4])])
    .pipe(
        ops.scan((acc, curr) =&gt; rxjs.merge(acc, curr), rxjs.from([]))
    ).subscribe(win =&gt; win.subscribe(
        x =&gt; console.log(JSON.stringify(x)), e =&gt; console.log(""error""), () =&gt; console.log(""|"")),
        e =&gt; console.log(""outer error""), () =&gt; console.log(""outer |""))
</code></pre>

<p>With each emitted observable, I see the accumulation of the values of the previous one followed by the new ones. 
<code>1 2 | 1 2 3 4 |</code></p>

<p>I expected this next one to produce the same result, but it doesn't:</p>

<pre><code>rxjs.from([1, 2, 3, 4])
    .pipe(
        ops.windowCount(2),
        ops.scan((acc, curr) =&gt; rxjs.merge(acc, curr), rxjs.from([]))
    ).subscribe(win =&gt; win.subscribe(x =&gt; console.log(JSON.stringify(x)), e =&gt; console.log(""error""), () =&gt; console.log(""|"")),
        e =&gt; console.log(""outer error""), () =&gt; console.log(""outer|""))
</code></pre>

<p>It seems to effectively ignore the scan operation and emits the original windows,
<code>1 2 | 3 4 |</code></p>

<p>What am I missing? What would a conventional solution to this look like? Thanks!</p>
","1831859","","","","","2020-06-09 21:54:41","Unexpected behavior with rxjs nested observables, window, and scan","<rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"62344288","1","","","2020-06-12 12:28:17","","1","166","<p>I have one scenario where I need to fetch the mapping for status and priority from backend, as it is static values so once the application loads I do not want to get those values multiple time from backend so for that I need a way which can give me values again without calling the backend here is the snippet for that which I am using.</p>

<pre class=""lang-js prettyprint-override""><code>    ngOnInit() {
        const status  = this.http.get('https://my-json-server.typicode.com/darpankumar/Fakedb/status').pipe(
          shareReplay(1)
        );

        const priority = this.http.get('https://my-json-server.typicode.com/darpankumar/Fakedb/priority').pipe(
          shareReplay(1)
       );
        this.statusPriority$ = combineLatest(status,priority)
      }

</code></pre>

<p>and the place where I need to use it I use it like this</p>

<pre class=""lang-js prettyprint-override""><code>    btnClick() {
        this.task$ = this.statusPriority$.pipe(flatMap((data :Array&lt;any&gt;) =&gt; {
          const [status, priority] = [...data];
          return this.http.get('https://my-json-server.typicode.com/darpankumar/Fakedb/data').pipe(
          map((data : any) =&gt;{
            // this is the place where i do the mapping. 
            data.status = status[data.statusCode];
            data.priority = priority[data.priorityCode];
            return data;
          })
        );
        }))  
      }
</code></pre>

<p>So my question in brief is, is it a right way to implement this behaviour, as one thing which is bothering me is <code>shareReplay</code> gives a <code>multicast observable</code> and I am not using it multiple places.</p>

<p>but apart from this, I can not find any way which can achieve the same functionality for me.</p>

<p>And another question is is there any way I can make this status and priority observable hot so that it fetches the values on load time, not on the button click.</p>

<p>I know I can use <code>behavioursubject(withsomeinitialValue)</code> and then can do the backend call and subscribe to those values in ts and can do the next on behavioursubject but i do not want to do the subscription in the component.</p>

<p><a href=""https://stackblitz.com/edit/angular-ivy-mdehhl?file=src/app/app.component.ts"" rel=""nofollow noreferrer"">fiddle</a></p>
","9834715","","2304474","","2020-06-13 23:00:40","2020-06-13 23:00:40","does it make sense to use shareReplay where i want to replay the value but do not want it to share with multiple observer","<angular><rxjs><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"62511792","1","","","2020-06-22 09:56:19","","-1","455","<p>We have an application based on the Location. Once the user changes the Location drop down (in app component) I need to call all the dependent APIs in the sub components.</p>
<p>How can I achieve this RxJS operators ?</p>
<p>I tried something like this but couldn't get the expected results.
Expected on change of the Location with setLocation function getOutwardReturnableData$ | async is called in the other components where all its referenced.</p>
<pre><code>selectedLocation: string = '';

setLocation(location: string) {
    this.selectedLocation = location;
}

get getOutwardReturnableData$(): Observable&lt;IEntryOutwardReturnable&gt; {
    // console.log(&quot;DataService -&gt; getOutwardReturnableData&quot;, this.getOutwardReturnableData$);
    return this.http.post&lt;IEntryOutwardReturnable&gt;(
        endPointData.GetOutwardReturnablMatDet,
        { LocationID: this.selectedLocation }
    );
}
</code></pre>
","2104335","","6324775","","2020-06-23 20:16:58","2020-06-23 20:16:58","How can I trigger api calls with async pipe on a value change in the service file in angular?","<angular><typescript><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"62607760","1","","","2020-06-27 08:43:14","","1","448","<p>In my current angular project I have a service that returns Observable&lt;Product[]&gt;.
I would like to convert that stream to an array of Observables of  single Product.  I want to achieve this using pipe operators, without subscribing to the original stream.</p>
<p><em><strong>From Observable of &lt;entity[]&gt; to array of Observables of entity</strong></em></p>
","7757474","","7757474","","2020-06-27 09:14:01","2020-06-27 10:37:38","How to convert Observable<Product[]> to Observable<Product>[] without subscribe?","<angular><rxjs><observable><rxjs-observables><rxjs-pipeable-operators>","1","5","","","","CC BY-SA 4.0"
"62633276","1","66274142","","2020-06-29 07:33:39","","5","1913","<p>I am using a caching for some data retrieved from an API, for logical reasons the stored data is valid only for a limited time, so I am making use of something like:</p>
<pre><code>someApiData$ = this.getData()
    .pipe(shareReplay(1, 3000))
</code></pre>
<p>What seems to be obvious to me but apparently is not to the creator of the <code>shareReplay</code> operator is that if the data is no longer cached it should be re-fetched, or at the very least I should have another parameter that will give me this option, something like:</p>
<pre><code>someApiData$ = this.getData()
    .pipe(shareReplay(1, 3000, shouldRefresh))
</code></pre>
<p>Instead, what the next subscriber will get is null.
So, I am looking for an elegant solution to this issue.</p>
","2363706","","","","","2021-02-19 08:33:17","RxJS cache and refresh with shareReplay","<angular><rxjs><rxjs-pipeable-operators>","5","0","","","","CC BY-SA 4.0"
"62686649","1","62686744","","2020-07-01 23:14:23","","0","36","<p>I have a service <code>carriersService</code> with method <code>getAll()</code>, which returns an <code>Observable&lt;Carrier[]&gt;</code>.
In my component, I'm trying to read route parameter <code>carrierId</code>, find the carrier with such <code>carrierId</code> and assign it to a local variable</p>
<pre><code>let carrier = null;

this.route.paramMap.pipe(
      switchMap(
        (params: ParamMap) =&gt; this.carriersService.getAll()));
</code></pre>
<p>I need to find a single Carrier from an Observable of <code>Carrier[]</code> using <code>params.get('carrierId')</code> and assign it to local carrier variable.</p>
","5481269","","","","","2020-07-01 23:27:47","Reading parameter and then finding single element in Angular","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"62726961","1","","","2020-07-04 08:27:30","","0","470","<p>I am using RxJs to create data stream observable. It sends 400 entries after some interval.
I am subscribing to it in other react component,</p>
<pre><code>constructor(props) {
        super(props);
        this.state = {data : []};
    }
    componentDidMount() {
        mock.subscribe(val =&gt; {
            var data = this.state.data;
            data[val.id] = val;
            this.setState({data: data});
        });
    }
</code></pre>
<p>I am facing one issue here, when entries come through observable, it takes time to copy those in react state and then to display the updated data(almost all rows in table) and till that time app becomes slow (sometimes freeze).</p>
<p>What is the better way to subscribe to observable to avoid time delay?</p>
<p>Thanks</p>
","6629722","","","","","2020-07-04 08:27:30","Best way to subscribe RxJS observable in React.js","<javascript><reactjs><rxjs><rxjs-observables><rxjs-pipeable-operators>","0","2","0","","","CC BY-SA 4.0"
"62822579","1","","","2020-07-09 19:47:11","","1","90","<p>Hello in Rxjs documentation I see this code:</p>
<pre><code>first()(of(1, 2, 3)).subscribe((v) =&gt; console.log(`value: ${v}`));

// Logs:
// value: 1
</code></pre>
<p>I knew it's like Just as <code>[1, 2, 3].map(x =&gt; x * x)</code> , but I would know if we can do the same with native JavaScript if so please give me an example ?</p>
<p>my question is :</p>
<p>I don't understand how first()(of(1, 2, 3)) can you explain me how this code return an observable with an operator and source ? I knew operator is the first() and source is of() but how they're merged together inside a new observable ?</p>
<p>Thank you</p>
","13550713","","13550713","","2020-07-09 21:47:10","2020-07-10 00:14:55","Rxjs how this syntax is valid?","<javascript><rxjs><rxjs-pipeable-operators>","3","2","","","","CC BY-SA 4.0"
"62993739","1","","","2020-07-20 10:48:20","","0","1256","<p>In RxJS I need to execute some code after all subscriptions for a given observable have been executed. I need to do this after every single <code>next</code> notification that fires and after all subscriber functions have completed (not only once when the observable completes).</p>
<p>In other words, I need an operator like <code>tap()</code> that runs after all subscribers have been executed. Is there a way?</p>
<p><strong>Example:</strong></p>
<p>I'm developing a library of UI widgets (say some kind of extensions to those already provided by angular material). One of those widgets has to accomplish the following:</p>
<ol start=""0"">
<li>provide a button,</li>
<li>when the button is clicked, display a spinner inside the button,</li>
<li>yield the control to who is using the widget to do some work (e.g. write inside a database),</li>
<li>when the work is done hide the spinner inside the button.</li>
</ol>
<p>Assuming to use an <code>Observable</code> to achieve the above, I would like to be able to do something like (I'm using typescript in an Angular 10 project if it could help to provide a solution):</p>
<pre class=""lang-js prettyprint-override""><code>const eventEmitter = new EventEmitter&lt;any&gt;();

const observable = eventEmitter.asObservable().pipe(
  tap(() =&gt; ...show the spinner...), // OK, no problem
  someOperator(() =&gt; ...hide the spinner when all subscriber functions complete...) // Which operator can I use?
);

observable.subscribe(() =&gt; console.log('First consumer'));
observable.subscribe(() =&gt; console.log('Second consumer'));

eventEmitter.emit('DATA');
</code></pre>
<p>The desired sequence of events when the button is clicked is:</p>
<ol>
<li>The event is emitted with <code>'DATA'</code> as payload,</li>
<li>The spinner inside the button is displayed,</li>
<li><code>'First consumer'</code> is logged in the console,</li>
<li><code>'Second consumer'</code> is logged in the console,</li>
<li>The spinner inside the button is removed.</li>
</ol>
<hr />
<p>BONUS QUESTION: how could I run some code after the execution of every single subscriber?</p>
","3333319","","3333319","","2020-07-21 06:39:56","2020-07-22 08:45:12","Execute function after subscribers to an RxJS observable complete","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","4","","","","CC BY-SA 4.0"
"63019730","1","63030759","","2020-07-21 17:19:31","","0","457","<p>I am having trouble getting the sum (or any reduction) of an inner number property of an Observable within another Observable.</p>
<p>I have an Observable array of &quot;Account&quot; objects (<code>Observable&lt;AppAccount[]&gt;</code>).</p>
<pre><code>export interface AppAccount {
    _id?: string;
    name: string;
}
</code></pre>
<p>And an Observable array of &quot;Balance&quot; objects, each with an accountId. many balances can be associated with an account (sorted/filtered by date, but that piece is removed for brevity)</p>
<pre><code>export interface AccountBalance {
    _id?: string;
    accountId: string;
    amount: number;
}
</code></pre>
<p>I have a helper method which returns just the last Balance object's Amount for a given Account.</p>
<pre><code>getLastAmount(account: AppAccount): Observable&lt;number&gt; {
    return this.balanceService.balances$.pipe(
      map(balances =&gt; {
        let last = balances.filter(balance =&gt; {
          return balance.accountId === account._id;
        }).sort().pop();
        //console.log(last)
        return last ? last.amount : 0;
      }),
      tap(amount =&gt; console.log(`getLastAmount() =&gt; ${amount}`)),
    );
  }
</code></pre>
<p>Now I am trying to write a method which will loop through the Accounts, call getLastAmount() for each, and then sum them all and return an Observable. This is what I have managed so far:</p>
<pre><code>getTotalBalance(accounts$: Observable&lt;AppAccount[]&gt;): Observable&lt;number&gt; {
    return accounts$.pipe(
      map(accounts =&gt; from(accounts)),
      mergeAll(),
      mergeMap(account =&gt; this.getLastAmount(account)),
      reduce((sum, current) =&gt; {
        console.log(`${sum} + ${current}`);
        return sum + current;
      }, 0)
    );
  }

</code></pre>
<p>But this seems to never return, and gets stuck in an infinite loop??</p>
<p>With just one account and one balance associated, with the balance having an 'amount' of '10', I get this from my console log: '0 + 10' over and over, and the network log also confirm it is calling getBalances() continuously.</p>
<p>Am I on the right track? Is there a better way? Why does this RXJS pipe get stuck in a loop?</p>
<p><strong>EDIT</strong>: I've made some changes based on picci's suggestions:</p>
<pre><code>getTotalBalance(accounts$: Observable&lt;AppAccount[]&gt;): Observable&lt;number&gt; {
    return accounts$.pipe(
      map(accounts =&gt; accounts.map(account =&gt; this.getLastAmount(account))),
      concatMap(balances$ =&gt; { console.log('balances$', balances$); return forkJoin(balances$); }),
      tap(balances =&gt; console.log('balances', balances)),
      map(balances =&gt; balances.reduce(
        (amountSum, amount) =&gt; {
          console.log(`${amountSum} + ${amount}`)
          amountSum = amountSum + amount;
          return amountSum
        }, 0))
    );
  }
</code></pre>
<p>But this is still not returning, or the pipe is not completing?
I've made a stackblitz here: <a href=""https://stackblitz.com/edit/angular-rxjs-nested-obsv"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-rxjs-nested-obsv</a>
If you check the console output, it seems to not get any further than the forkJoin call...</p>
","6505573","","6505573","","2020-07-22 19:51:38","2020-07-22 19:51:38","How to sum inner property of nested observable arrays, using Angular/RXJS?","<angular><rxjs><sum><rxjs-observables><rxjs-pipeable-operators>","2","1","","","","CC BY-SA 4.0"
"63103329","1","63103461","","2020-07-26 17:16:15","","0","168","<p>I'm having a bit of trouble understanding the take() operator. In it's definition it is supposed to return the first value emitted by the observable but to me it seems like it's returning the last one.</p>
<p>I tried the following test to understand it better :</p>
<p>UsersService.ts</p>
<pre><code>import {User} from '../models/user.model';
import {BehaviorSubject} from 'rxjs';

@Injectable({providedIn: 'root'})
export class UsersService {

  userObs = new BehaviorSubject&lt;{test: string}&gt;(null);

  testEmit(inp: string) {
    this.userObs.next({test: inp});
  }
}
</code></pre>
<p>and a component.</p>
<p>users.component.html</p>
<pre><code>  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-xs-12 col-md-6 col-md-offset-3&quot;&gt;
      &lt;input type=&quot;text&quot; class=&quot;form-control&quot; #inp&gt;
      &lt;button class=&quot;btn btn-primary&quot; (click)=&quot;testTake(inp)&quot;&gt;Emit&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt; 
</code></pre>
<p>users.component.ts</p>
<pre><code>import {Component, Input, OnDestroy, OnInit} from '@angular/core';
import {User} from '../models/user.model';
import {UsersService} from '../services/users.service';
import {interval, Observable, Observer, Subscription} from 'rxjs';
import {take} from 'rxjs/operators';

@Component({
  selector: 'app-users',
  templateUrl: './users.component.html',
  styleUrls: ['./users.component.css']
})
export class UsersComponent implements OnInit, OnDestroy {
  constructor(private usersService: UsersService) {
  }

  ngOnInit(): void {
    this.usersService.userObs.pipe(take(1)).subscribe((data: {test: string}) =&gt; {
      console.log(data.test);
    });
  }

  testTake(inp: HTMLInputElement) {
    this.usersService.testEmit(inp.value);
  }
}
</code></pre>
<p>In the view I type something in the input and I click the button to emit it and then I go to another component and come back to this one to retrigger the OnInit() function and what I get in the console is the last value I wrote in the input.
Am I looking at this the wrong way?</p>
<p>Thank you for your time and help.</p>
","4396633","","1178940","","2020-07-26 18:11:42","2020-07-26 18:11:42","RxJS take() operator","<angular><typescript><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"63114588","1","63115197","","2020-07-27 11:42:07","","0","121","<p>I want to check first service call result before proceeding further. If the first call fails, I have some thing to handle</p>
<pre><code>    return this.http.get(this.partySiteAddressUrlOrganization + &quot;?&quot; + new Date().toString(), { params: newparams }).pipe(
  concatMap((result1: any) =&gt; {
    if (result1.success)
      return this.http.post(this.postRequestListURL, parm)
    else {
    }

  }));
</code></pre>
","6689996","","9880356","","2020-07-27 12:12:26","2020-07-27 12:19:10","Rxjs concat map condition check before it go to second call","<angular><rxjs><rxjs-pipeable-operators><concatmap>","1","0","","","","CC BY-SA 4.0"
"63316478","1","63317510","","2020-08-08 14:25:44","","0","73","<p>I am trying to use the merge operator is given below. I want to put only 'Mr' before login but I am getting an error, your help is much appreciated, thank you</p>
<pre><code>  let data=this.http.get('https://api.github.com/users');
  let output=data.pipe(map(data=&gt;{'Mr, '+data.login}));
            output.subscribe(data=&gt;{
  console.log(data);
})
</code></pre>
","4747554","","1188074","","2020-08-09 01:25:22","2020-08-09 01:25:22","How do I map a list of objects from an HTTP API to a list of strings?","<angular><rxjs><rxjs5><rxjs6><rxjs-pipeable-operators>","2","1","","2020-08-09 01:29:02","","CC BY-SA 4.0"
"63381609","1","","","2020-08-12 17:13:37","","0","34","<p>Since i was with angular9 and ivy compiler enable false.Everything was working fine.But after upgraded app to angular v10 and getting rxjs related operator and observable related getting compile error.</p>
<p><strong>Before</strong>:</p>
<p>&quot;rxjs&quot;: &quot;^6.5.5&quot;,
&quot;rxjs-compat&quot;: &quot;^6.5.5&quot;</p>
<p><strong>After</strong>(now rxjs-compat removed):</p>
<p>&quot;rxjs&quot;: &quot;^6.6.2&quot;</p>
<p><strong>Error:</strong></p>
<pre><code> error TS2339: Property 'filter' does not exist on type 'Observable&lt;any&gt;'.
</code></pre>
<p><strong>Code:</strong></p>
<pre><code> let fromdate$ = of(fromdatevalue)
          let fromdateIfNull = fromdate$.filter(date =&gt; date != null)
            .map(date =&gt; {
              let fromdate = new Date(fromdatevalue);
              fromdate.setHours(8, 0, 0, 0);
              return fromdate;
            })
</code></pre>
<p>How to solve error and i want with properly use of <code>rxjs</code> import in angular v10 app.</p>
<p>Thanks.</p>
","9948050","","","","","2020-08-12 17:13:37","Property 'filter' does not exist on type 'Observable<any>'. rxjs v6","<javascript><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","0","7","","","","CC BY-SA 4.0"
"63468068","1","63468247","","2020-08-18 11:54:18","","0","848","<p>I have an Issue with timeout operator in subject.</p>
<p>my problem look like sample above, but I got all of source,</p>
<p>response:
observable: 1
observable: 2</p>
<p>url: <a href=""https://stackblitz.com/edit/ou5yp1?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/ou5yp1?file=index.ts</a></p>
<pre><code>import { Subject, from,Observable } from 'rxjs';
import {timeout} from 'rxjs/operators';

const subject = new Subject();
 subject.subscribe({
  next: (v) =&gt; console.log(`observer: ${v}`),
   error: (e) =&gt; console.log(`There is an Error ${e}`)
  });
subject.pipe(timeout(2000));

const observable = new Observable( sub=&gt; {
 sub.next( 1);
 setTimeout(()=&gt; {
 sub.next(2)
 },5000)
})
observable.subscribe(subject); 
</code></pre>
","10614684","","","","","2020-08-18 12:05:35","timeout() operator not working in pipe Rxjs subject","<javascript><node.js><typescript><rxjs><rxjs-pipeable-operators>","1","0","1","","","CC BY-SA 4.0"
"63476916","1","63476973","","2020-08-18 21:32:13","","0","192","<p>In my Angular (v10) project I can import all kinds of RxJS (v6.6.2) operators like</p>
<pre><code>import { debounceTime, filter, map, ... and so on } from 'rxjs/operators';
</code></pre>
<p>except <code>merge</code>. <code>merge</code> I import like</p>
<pre><code>import { merge } from 'rxjs/internal/observable/merge';
</code></pre>
<p>but I think it's not the proper way doing it. I could also write</p>
<pre><code>import { merge } from 'rxjs';
</code></pre>
<p>but it's prohibited by a suggested blacklist rule for tslint:</p>
<pre><code>&quot;import-blacklist&quot;: [true, &quot;rxjs&quot;, &quot;rxjs/Rx&quot;]
</code></pre>
<p>What's the right way importing <code>merge</code>?</p>
","5214911","","","","","2020-08-18 21:50:55","How to import RxJS merge?","<angular><rxjs><tslint><rxjs-pipeable-operators>","1","3","","","","CC BY-SA 4.0"
"63491389","1","63492139","","2020-08-19 16:39:27","","1","83","<p>Theoretically, I know what mergeMap is and how it works, but when I try to understand using
practical approach I get confused, this is what I have done so far</p>
<pre><code>const input1$= of(&quot;value 1&quot;,&quot;value 2&quot;,&quot;value 3&quot;);
const input2$= of(1,2,3,4);
const obs=input1$.pipe(
            mergeMap(data1=&gt;{
              return input2$
              .pipe(map(ch=&gt;{ch+' '+data1}))})
        )   
</code></pre>
<p>unfortunately, I am getting undefined when I try to merge them, your help would be appreciated to make me understand how it works.</p>
","4747554","","","","","2020-08-19 17:30:55","undefined output while using mergeMap in Rxjs","<angular><rxjs><rxjs5><rxjs6><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"63523282","1","","","2020-08-21 12:52:20","","1","30","<p>I receive some data chunk-wise and want to precess the data-points with a minimum temporal distance. (You could formulate it as <code>throttleTime</code> without data loss or the opposite of <code>buffer</code>).
After a ton of trying and googling I came up with this solution:</p>
<pre><code>dataChunkReceiver
  .pipe(
    switchMap(chunk =&gt; of(...chunk)), // spread chunk of data-points to distinct events
    zip(interval(minimumInterval)), // make sure events don't get executed more often than minimumInterval
    map(itemAndNumber =&gt; itemAndNumber[0]) // only forward the data-point
  )
</code></pre>
<p>The <code>zip(interval(minimumInterval))</code>-solution works fine with, let's say, mouse events but not in this combination with switchMap and chunks. It still works like a charm when chunks come more often than <code>minimumInterval</code> - but not if they are slower. I can't figure out why, maybe someone can enlighten me?</p>
<p>To see the problem <a href=""https://stackblitz.com/edit/rxjs-delay-bewteen-items?file=index.ts"" rel=""nofollow noreferrer"">try my Stackblitz</a> an set <code>chunkInterval</code>(the interval in which new chunks of data arrive) to 2000 while the <code>minimumInterval</code> is 400. As you can see, all data-points from each chunk get processed at the same time. While when you set <code>chunkInterval</code> to 400, they come out every 500 milliseconds as expected.
For 2000 as <code>chunkInterval</code> I would expect the data points at ms</p>
<pre><code>2000 | 2500 | 3000 | 4000 | 4500 | 5000 | 6000 | 6500 | 7000
</code></pre>
<p>I am sure the must be a subtle misconception in my solution, please help to find it!</p>
","1814493","","215552","","2020-08-21 12:57:47","2020-08-21 12:57:47","Ensure that there is a minimum time delay between events","<javascript><rxjs><rxjs-pipeable-operators>","0","2","","2020-08-21 13:24:50","","CC BY-SA 4.0"
"63737435","1","63738352","","2020-09-04 08:21:11","","0","328","<p>A ShoppingCart with ShoppingCartItems is fetched via an outer REST call, after which an Observable of the ShoppingCartItems makes the inner call to enhance the ShoppingCartItems with a Provider.</p>
<p>A tap(console.log) after the inner call, reveals that the contents of the ShoppingCart are as expected - with the 5 ShoppingCartItems enhanced with a Provider. Tapping the subscription however, returns 5 alerts each containing the Provider I wanted to add as a property of ShoppingCartItem.</p>
<p>It seems I am using the wrong mergeMap/concatMap/switchMap - or not doing a 'collect' of some sort at the end of one or both calls.</p>
<p>The calls:</p>
<pre><code>  getShoppingCart$(userId: number): Observable&lt;ShoppingCart&gt; {
    return this.rest.getShoppingCart$(userId)
      .pipe(
        mergeMap(
          (shoppingCart) =&gt; from(shoppingCart.shoppingCartItems)
            .pipe(
              concatMap(
                item =&gt; this.rest.getProviderByWine$(item.wine.id)
                  .pipe(
                    map(provider =&gt; item.provider = provider),
                  )
              ),
              // Returns ShoppingCart with Providers added
              tap(() =&gt; console.log('ShoppingCart: ' + JSON.stringify(shoppingCart)))
            )
        ),
      )
  }
</code></pre>
<p>The subscription:</p>
<pre><code>  ngOnInit(): void {
    this.shoppingCartService.getShoppingCart$(1037).subscribe(
      (shoppingCart: ShoppingCart) =&gt; {
        this.dataSourceShoppingCart = new NestedMatTableDataSource&lt;ShoppingCartItem&gt;(shoppingCart.shoppingCartItems);
        // Runs 5 times - each time displaying a Provider, not the ShoppingCart
        alert(JSON.stringify(shoppingCart))
      }
    );
  }
</code></pre>
<p>The actual REST calls:</p>
<pre><code>  getShoppingCart$(userId: number): Observable&lt;ShoppingCart&gt; {
    return this.http.get&lt;ShoppingCart&gt;(this.getBaseUrl() + 'users/' + userId + '/shopping-cart');
  }

  getProviderByWine$(wineId: number): Observable&lt;any&gt; {
    return this.http.get&lt;Provider&gt;(this.getBaseUrl() + 'wine/' + wineId + '/provider');
  }
</code></pre>
<p>Any pointers are greatly appreciated. Angular version is 8.</p>
","818722","","","","","2020-09-04 10:32:56","Angular - nested REST API calls only returning inner call","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","2","2","","","","CC BY-SA 4.0"
"63795528","1","63796303","","2020-09-08 13:58:42","","2","1266","<p>I have multiple observables that emit values during the lifetime of the page. For example:</p>
<pre><code>chartData$: Observable;
tableData$: Observable;
filterData$: Observable;
</code></pre>
<p>At any time user can click the 'Download' button, and get the JSON combining the values that were last emitted from each of these observables:</p>
<pre><code>downloadButtonClicked$.pipe(
    combine chartData$, tableData$ and filterData$    // &lt;- how do I get latest values here?
).subscribe(([chart, table, filter]) =&gt; downloadJson(chart, table, filter))
</code></pre>
<p>but the <code>downloadJson</code> function shouldn't be called when any of these 3 observables emit values as part of page lifecycle, only on Download click.</p>
<p><strong>TLDR;</strong></p>
<p>working most elegant solution (as suggested by Mike)
<a href=""https://stackblitz.com/edit/typescript-jm3zma?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/typescript-jm3zma?file=index.ts</a></p>
","1457181","","1457181","","2020-09-08 15:14:05","2020-09-08 15:22:29","Rxjs: get latest values from multiple observables later after they emitted","<rxjs><rxjs6><rxjs-pipeable-operators>","4","0","","","","CC BY-SA 4.0"
"63797228","1","63797819","","2020-09-08 15:38:36","","2","127","<p>I have a fromEvent attached to input keydown event. This way I can listen to KeyEvents.</p>
<p>Inside the pipe, I use the scan operator, so I can accumulate the latest 3 keys introduced by the user.</p>
<p>I check in the scan, the accumulator length, so if it's already three, I clean it up (manual reset).</p>
<p>I need a way that when the user types in, within the next 3000ms, he can keep typing until reaching the limit (3 keys) but if the user is slower than the time limit (3s), next time he types in, I will reset the accumulator manually.</p>
<pre><code>  fromEvent(myInput.nativeElement, 'keydown').pipe(
    tap(e =&gt; e.preventDefault()),
    scan((acc: KeyboardEvent[], val: KeyboardEvent) =&gt; {
      // Add condition here to manually reset the accumulator...
      if (acc.length === 3) {
        acc = [];
      }
      return [...acc, val];
    }, []),
    takeUntil(this.destroy$)
  ).subscribe((events: KeyboardEvent[]) =&gt; console.log(events));
</code></pre>
<p>I have tried to merge this with a timer in some way, but I can't figure out how. Not sure how to get there.</p>
","4775350","","","","","2020-09-08 17:46:35","Reset Scan Accumulator RxJS after certain time","<rxjs><rxjs-pipeable-operators>","1","4","","","","CC BY-SA 4.0"
"63845774","1","63849833","","2020-09-11 11:01:45","","2","55","<p>I have an angular application that should sync some data with the server on some conditions (some triggers in software or when user request). So i have a function like this:</p>
<pre><code>    ...

    public createSyncObservable(): Observable&lt;any&gt; {
        return this.retriveDataFromStorage().pipe(
            switchMap(
                (data) =&gt; forkJoin(this.api.sendData1(data.data1),this.api.sendData2(data.data2),this.api.sendData3(data.data3))
            ),
            switchMap(
                (data) =&gt; this.api.getDataFromServer()
            ),
            switchMap(
                (data) =&gt; this.updateLocal(data)
            )
        )
    }
</code></pre>
<p>The behaviour I want is:</p>
<ul>
<li>If user (or some trigger) request the sync and it is already happening, I should not do it again, just wait for the current sync to end and return the same observable (shared).</li>
<li>If last sync already finished, it should start again (create a new observable).</li>
</ul>
<p>My best solution for now is to do something like this (untested code):</p>
<pre><code>    ...
    public syncData(): Observable&lt;any&gt; {
        if (this.observable_complete) {
            this.observable_complete = false;
            this.syncObservable$ = this.createSyncObservable().pipe(share())
            this.syncObservable$.subscribe(
                (data) =&gt; {this.observable_complete = true}
            ) 
        }
        return this.syncObservable$;
    }
</code></pre>
<p>Is this the way to go? Maybe I am missing some RxJS operator that would help me in this case? This solution just seems a bit hacky...</p>
","2085389","","","","","2020-09-11 15:23:29","Share a subscription if observable not done","<angular><typescript><rxjs><rxjs-observables><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"63846906","1","63847606","","2020-09-11 12:14:39","","1","40","<p>I have one endpoint for getting list of users, and another for getting list of apartments for every user:</p>
<pre><code>getUsers() =&gt; Observable&lt;User[]&gt;;
getUserApartments(userId) =&gt; Observable&lt;Apartment[]&gt;`
</code></pre>
<p>How do I merge the data from the two into single observable:</p>
<pre><code>const usersWithApartments$: Observable&lt;{ user: User, apartments: Apartment[] }[]&gt; = getUsers().pipe(
    // users.map(user =&gt; { user, apartments: getUserApartments(user.id) }) &lt;-- turn this pseudocode into Rxjs
);
</code></pre>
","1457181","","1457181","","2020-09-11 13:03:26","2020-09-11 14:35:25","rxjs: load many for many from 2 endpoints and merge into single Observable","<rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"63867586","1","63868331","","2020-09-13 05:49:55","","-1","143","<p>I have two observable pipes. I need to run one after the other and compare two values equal or not. I tried the below code.This should work, when the first observable value emitted , it should go and take second obserbla value and should comapre it first return value.I need to some expert help , to refator this code better way.</p>
<pre><code>   this.selectedUnitDetailModel$.pipe(shareReplayUntil(this.destroySub)).subscribe(
          (res: UnitDetail) =&gt;{
              if(res.unitTwo){
                this.appStore.select(selectUnit).
                pipe(shareReplayUntil(this.destroySub)).subscribe(
                  (unitId: string) =&gt; {
                    if(unitId ===  res.unitTwo){
                      this.sameUnit = true;
                    }else{
                      this.sameUnit = false;
                    }
                  });
              }
          }
       );
</code></pre>
","4108618","","4108618","","2020-09-13 06:08:03","2020-09-13 08:40:16","How to write below code using MergeMap or FlatMap or some better way with rxJs-operators?","<angular><typescript><rxjs><ngrx><rxjs-pipeable-operators>","2","3","","","","CC BY-SA 4.0"
"63868680","1","63870811","","2020-09-13 08:27:20","","-1","143","<p>I wrote subscribe service and get value form that and after that call another API. but the first subscription API changed. Now value can be null. so, how can I handle that?. Now code came compile error in, <code>oc.id</code>, or can be null.</p>
<pre><code> getE$ = createEffect(() =&gt; this.actions$.pipe(
ofType(ActionType.A),
switchMapTo(this.store.select(selectP)),
mergeMap((oc) =&gt; this.reviewService.findByR(oc.id,
  new Date(new Date()),
  new Date(new Date()), 'A')
  .pipe(
    mergeMap(d =&gt; {
      return of(LoadSuccess({ reviews: getReviews(d) }));
    }
    ),
    catchError(error =&gt; {
      return of(LoadFailure({ error: error }));
    })
  )
)));
</code></pre>
","4108618","","","","","2020-09-13 12:32:49","How to add null filter to below mergeMap?","<typescript><rxjs><ngrx><ngrx-effects><rxjs-pipeable-operators>","1","8","","","","CC BY-SA 4.0"
"63886559","1","63887834","","2020-09-14 14:41:26","","2","51","<p>How do I access the <code>resultB</code> in the <code>tap</code> operator after it was <code>switchMap</code>ped ?</p>
<pre><code>streamA$.pipe(
    switchMap(resultA =&gt; {
        const streamB$ = resultA ? streamB1$ : streamB2$;

        return streamB$.pipe(                   // &lt;- nesting
            switchMap(resultB =&gt; loadData(resultB)),
            tap(data =&gt; {
                // how do I access resultB here?
            })
        );

    })
);
</code></pre>
<p>bonus question:
Is it possible to avoid the nesting here, and chain the whole flow under single pipe?</p>
","1457181","","","","","2020-09-15 05:25:27","rxjs: access the result of original observable after it was switchMap'ped","<rxjs><rxjs6><rxjs-pipeable-operators><switchmap>","3","1","","","","CC BY-SA 4.0"
"63929550","1","","","2020-09-17 00:16:24","","0","77","<p>I have three services that return observables. The first returns a list of recipes, the second gets all ingredients for a given recipe, and the last gets the quantity of a given ingredient type. I want to call all three consecutively passing the previous information along to the next call so that the returned responses can be mapped to the same initial list of recipes. Essentially each consecutive call would add to the previously returned info and the list of objects would grow in complexity with each successive call. I also need to apply a custom mapping to each return. I also need them to resolve at the same time so I can simply subscribe to the end result. I know I'll probably need to use switchMap or concatMap but I'm unsure of how to structure this.</p>
<p>Any help would be appreciated</p>
<p>Examples of my service calls and their mappings</p>
<p>Get recipes</p>
<pre class=""lang-js prettyprint-override""><code>let allRecipes: Observable&lt;RecipeModel[]&gt; = this.recipeListService.GetRecipesFromAirtable(
      allTypes, allOccassions, allPrepStyles, allFamilies, muddlingReq, 
      allPrimaryComponents, allSecondaryComponents, recipeName
    ).pipe(map(response =&gt; {
      let allRecipes: RecipeModel[] = response.records.map(
        recipeObj =&gt; {
          //console.log(recipeObj.fields);

          let model: RecipeModel = {
            id: recipeObj.fields[&quot;Recipe ID&quot;],
            name: recipeObj.fields[&quot;Name&quot;],
            variant: '',
            version: 0,
            type: recipeObj.fields[&quot;Type&quot;]
          }

          let variant: string = recipeObj.fields[&quot;Variant&quot;];
          if(variant !== null &amp;&amp; variant !== undefined) {
            model.variant = variant;
          }

          let version: number = recipeObj.fields[&quot;Version&quot;];
          if(version !== null &amp;&amp; version !== undefined &amp;&amp; isNaN(version) !== true) {
            model.version = version;
          }

          return model;
        }
      )

      return allRecipes;
    }));
</code></pre>
<p>Get Ingredients</p>
<pre class=""lang-js prettyprint-override""><code>let allIngredients: Observable&lt;IngredientModel[]&gt; = this.ingredientService.GetIngredientsFromAirtable(recipe.id)
    .pipe(
      map(response =&gt; {
      let allIngredientObjs: IngredientModel[] = response.records.map(
        ingredientObj =&gt; {
          let model: IngredientModel = {
            order: ingredientObj.fields[&quot;Order&quot;],
            name: ingredientObj.fields[&quot;Ingredient Name&quot;][0],
            qualifier: ingredientObj.fields[&quot;Qualifier&quot;],
            optional: ingredientObj.fields[&quot;Optional&quot;] ? ingredientObj.fields[&quot;Optional&quot;] : false,
            amountReq: { },
            notes: ingredientObj.fields[&quot;Notes&quot;]
          }

          let allFields: [string, string][] = [[&quot;Cups&quot;, &quot;cup&quot;], [&quot;Ounces&quot;, &quot;oz&quot;], [&quot;Millilitres&quot;, &quot;mL&quot;], [&quot;Quantity&quot;, &quot;&quot;], [&quot;Grams&quot;, &quot;g&quot;], 
            [&quot;Dashes&quot;, &quot;&quot;], [&quot;Barspoons&quot;, &quot;barspoons&quot;], [&quot;Teaspoons&quot;, &quot;tsp&quot;], [&quot;Misc&quot;, &quot;&quot;]];
          for(let i = 0; i &lt; allFields.length; i++) {   
            let fieldName: string = allFields[i][0];
            let value: string = ingredientObj.fields[fieldName];

            if(value === null || value === undefined || value.length == 0) {
              continue;
            }

            model.amountReq[fieldName.toLowerCase()] = {units: allFields[i][1], amount: value};
          }

          // Add type info
          model.type = {
            superType: ingredientObj.fields[&quot;Ingredient Supertype&quot;],
            type: ingredientObj.fields[&quot;Ingredient Type&quot;],
            subType: ingredientObj.fields[&quot;Ingredient Subtype&quot;]
          }

          return model;
        }
      )

      return allIngredientObjs;
    }));
</code></pre>
<p>Get Ingredient Quantity</p>
<pre class=""lang-js prettyprint-override""><code>let ingredientQuantity: Observable&lt;number&gt; = this.inventoryService.GetIngredientQuantitiesFromAirtable(
      inventoryName, ingredientName)
    .pipe(
      map(response =&gt; {
        let quantity = 0;

        let allLiquorObjs = response.records.map(
          liquorObj =&gt; {
            let model = {
              brand: liquorObj.fields[&quot;Brand&quot;][0],
              desc: liquorObj.fields[&quot;Description&quot;][0],
              volume: liquorObj.fields[&quot;Current Volume (mL)&quot;]
            }

            if(&quot;specialValue&quot; in model.volume) {
              model.volume = -1;
            }

            if(model.volume &gt; 0) {
              quantity += model.volume;
            }

            // return model;
          }
        )

        return quantity;
      }));
</code></pre>
<p>So far I have the following worked out thanks to Elias Dal Ben's help</p>
<pre class=""lang-js prettyprint-override""><code>let allRecipes: Observable&lt;RecipeModel[]&gt; = this.getAllRecipesObservable(this.allDrinkTypes, 
      this.allDrinkOccassions, this.allPreparationStyles, this.allFamilies, this.muddlingRequired, 
      this.allPrimaryComponents, this.allSecondaryComponents, this.recipeNameToFind)
    .pipe(
      tap(allRecipes =&gt; { 
        console.debug('Recipes(' + allRecipes + ')'); 
      }),
      concatMap(data =&gt; {
        let allRecipes = data;
        allRecipes.map(
          recipe =&gt; {
            let allIngredients: Observable&lt;IngredientModel[]&gt; = this.getAllIngredientsObservable(recipe);

            allIngredients.pipe(
              tap(allIngredients =&gt; {
                console.debug('Ingredients(' + allIngredients + ')');
              }),
              concatMap(data =&gt; {
                let allIngredients = data;
                allIngredients.map(
                  ingredient =&gt; {
                    let quantity: Observable&lt;number&gt; = 
                    this.getIngredientQuantityObservable(this.inventoryAddr, ingredient.type.name);
                    
                    quantity.pipe(
                      tap(quantity =&gt; {
                        console.debug('Quantity(' + quantity + ')');
                      })
                    )

                    return quantity;
                  }
                )
              })
            )

            return allIngredients;
          }
        )

        return allRecipes;
      })
    )
</code></pre>
<p>However on the first line allRecipes gives me an error of</p>
<blockquote>
<p>&quot;Type 'Observable' is not assignable to type 'Observable&lt;RecipeModel[]&gt;'&quot;</p>
</blockquote>
<p>and data in the second concatMap gives me an error of</p>
<blockquote>
<p>&quot;Argument of type '(data: IngredientModel[]) =&gt; void' is not assignable to parameter of type '(value: IngredientModel[], index: number) =&gt; ObservableInput'.
Type 'void' is not assignable to type 'ObservableInput'.&quot;</p>
</blockquote>
<p>Does anyone know what I'm missing?</p>
","4531149","","4531149","","2020-09-17 04:01:30","2020-09-17 04:01:30","Angular - Chaining multiple observables together","<angular><rxjs><observable><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"63934153","1","63936684","","2020-09-17 08:28:00","","0","51","<p>I have pipe and It will return <code>of{}</code> when some error occured. So I need to filter it  , to other code flows. Currently I used following senario. I need to know , are there any way to remove map and filter it in the exiting filter ?</p>
<pre><code> readonly k$ = combineLatest(
    [this.x$.pipe(filter(isNotNullOrUndefined), //this filter not filtering  of{} type.
      map((res: A) =&gt; {  //need to remove this map
        return res;
      })
    ), this.y$]).pipe(shareReplayUntil(this.destroySub));
</code></pre>
","4108618","","","","","2020-09-17 11:04:11","Are there any way to filter of{} not put aditional map?","<typescript><rxjs><ngrx><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"63963926","1","","","2020-09-18 23:28:41","","2","119","<p>I was trying to create a reusable selector pipe by following the <a href=""https://ngrx.io/guide/store/selectors#solution-extracting-a-pipeable-operator"" rel=""nofollow noreferrer"">ngrx documentation</a>.</p>
<p>I have this in several of my components, so i want to create a reusable selector</p>
<pre><code>    this.bookmarks$ = this.store.pipe(
      select(fromBookmarks.selectBookmarksLoading),
      filter(loading =&gt; loading === false),
      concatMap(loading =&gt;
        of(loading).pipe(
          withLatestFrom(
            this.store.select(fromBookmarks.selectCurrentBookmarks),
            (_, bookmarks) =&gt; {
              return bookmarks;
            }
          )
        )
      )
    );
</code></pre>
<p>So i came up with this one.</p>
<pre><code>export const selectBookmarksAfterLoad = pipe(
  select(selectBookmarksLoading),
  filter(loading =&gt; loading === false),
  concatMap(loading =&gt;
    of(loading).pipe(
      withLatestFrom(select(selectCurrentBookmarks), (_, bookmarks) =&gt; {
        return bookmarks;
      })
    )
  )
);
</code></pre>
<p>and converted the selector in my components like this</p>
<pre><code>    this.bookmarks$ = this.store.pipe(fromBookmarks.selectBookmarksAfterLoad);
</code></pre>
<p>but i'm getting error such as this one:</p>
<pre><code>rollbar.umd.min.js:1 TypeError: You provided 'function selectOperator(source$) {
        /** @type {?} */
        let mapped$;
        if (typeof pathOrMapFn === 'string') {
            /** @type {?} */
            const pathSlices = [(/** @type {?} */ (propsOrPath)), ...paths].filter(Boolean);
            mapped$ = source$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[&quot;pluck&quot;])(pathOrMapFn, ...pathSlices));
        }
        else if (typeof pathOrMapFn === 'function') {
            mapped$ = source$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[&quot;map&quot;])((/**
             * @param {?} source
             * @return {?}
             */
            (source) =&gt; pathOrMapFn(source, (/** @type {?} */ (propsOrPath))))));
        }
        else {
            throw new TypeError(`Unexpected type '${typeof pathOrMapFn}' in select operator,` +
                ` expected 'string' or 'function'`);
        }
        return mapped$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[&quot;distinctUntilChanged&quot;])());
    }' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
</code></pre>
","9732932","","9732932","","2020-09-19 00:08:32","2020-09-19 00:08:32","TypeError: You provided 'function selectOperator(source$) where a stream is expected","<angular><typescript><rxjs><ngrx><rxjs-pipeable-operators>","0","0","","","","CC BY-SA 4.0"
"63979392","1","63979536","","2020-09-20 13:16:26","","-1","55","<p>I had subscribed for async pipe and one pipe retrun - &gt; <code>bservable&lt; AModel | undefined | null&gt;</code>.
I compine this four pipe in combineLatest and subcribe.but I need below code excute only  -&gt; AModel came.
So ,I used  <code>skipWhile(([, , , selectedA]) =&gt; !selectedA)</code> . but AModel -&gt; undefind it not stop and go to exute below code. need some expert help to resolve it.</p>
<p>------------------code -----------------------------------</p>
<pre><code>   combineLatest(observables)
     .pipe(skipWhile(([, , , selectedA]) =&gt; !selectedA),
       shareReplayUntil(this.destroySub))
     .subscribe(([a, b, c, selectedA]) =&gt; { }```
</code></pre>
","4108618","","","","","2020-09-20 13:33:13","Undefind type not filter in skipWhile?","<typescript><rxjs><ngrx><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"64137503","1","","","2020-09-30 12:23:37","","0","8","<p>I'm studying the rjx operators following the official documentation.</p>
<p>In Operator section, there is an example of how to use map operator</p>
<pre><code>map(x =&gt; x * x)(of(1, 2, 3)).subscribe((v) =&gt; console.log(`value: ${v}`));
</code></pre>
<p>It doesn't make sense to me. how is</p>
<pre><code>(of(1, 2, 3)).subscribe((v) =&gt; console.log(`value: ${v}`)) 
</code></pre>
<p>outside of first parenthesis? I can't figure out this syntax. I appreciate if anyone can explain it to me.</p>
<p>The below makes sense to me,</p>
<pre><code>x =&gt; x*x and (of(1, 2, 3)).subscribe((v) =&gt; console.log(`value: ${v}`)) 
</code></pre>
<p>put in one parenthesis as an argument of map.</p>
<pre><code>map.call(x =&gt; x* x, (of(1, 2, 3)).subscribe((v) =&gt; console.log(`value: ${v}`)));
map(x =&gt; x* x, (of(1, 2, 3)).subscribe((v) =&gt; console.log(`value: ${v}`)));
</code></pre>
","7794766","","9868785","","2020-09-30 12:37:02","2020-09-30 12:37:02","can't figure out why map operator can use like this map<number, void>(x => x * x)(of(1, 2, 3)).subscribe((v) => console.log(`value: ${v}`));","<rxjs-pipeable-operators>","0","0","","","","CC BY-SA 4.0"
"64161538","1","64162280","","2020-10-01 18:48:59","","2","497","<p>I have some cards displayed in the UI.</p>
<pre><code>&lt;div *ngFor=&quot;let item of cards | async&quot;&gt;...&lt;/div&gt;
</code></pre>
<p>Obviosuly cards will be the Observable of array of type card.</p>
<p>So I have an interface of card lets say it has 3 properties</p>
<p>Id, name, description.</p>
<p>My use case is.</p>
<ol>
<li><p>I want to add new card to the observables array and must reflect to array.</p>
</li>
<li><p>I want to delete the card from the observable and must reflect to the template.</p>
</li>
<li><p>I must be able to filter the card baaed on lets say name and must be reflected in the template.</p>
</li>
</ol>
<p>In short all the aperations must be done in the observable as I have used async pipe in the template.</p>
","7413086","","","","","2020-10-01 19:48:27","Update Rxjs observable of array by adding ,filtering or deleting items","<angular><observable><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"64166422","1","64166620","","2020-10-02 05:08:17","","0","27","<p>I have a BehaviourSubject with an array of employee data. When I want to add a new employee to the array, I want to take old data, insert new records into it, and reemit that into the behaviour subject. I am not able to get a clue on how to do that.</p>
<pre><code>export class EmployeeService {


employeesSub = new BehaviorSubject&lt;Employee[]&gt;([]);

  constructor(private http: HttpClient) {
    this.api().subscribe((res) =&gt; {
      this.employeesSub.next(res.data);
    });

  }

  addEmployee(name,age,salary) {
    this.employeesSub.pipe(
      map((res:Employee[])=&gt;{
       res.unshift({id:(res.length + 1).toString(),employee_age:age,employee_name:name,employee_salary:salary,profile_image:&quot;&quot;});
       return res;
      })
    ).subscribe(emp=&gt;{
      // this.employeesSub.next(emp);
    })
  }

  api() {
    return this.http
      .get&lt;any&gt;(&quot;http://dummy.restapiexample.com/api/v1/employees&quot;)
      .pipe(map((data) =&gt; data.items));
  }
}
</code></pre>
<p>I am trying something similar to add employee method but able to fix it.</p>
<p>The same code can also be found at StackBlitz</p>
<p><a href=""https://stackblitz.com/edit/angular-buwj6n"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-buwj6n</a></p>
","9588631","","9588631","","2020-10-02 05:39:36","2020-10-02 05:51:43","How to read data from BehaviourSubject and emit new data into it","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"64267309","1","","","2020-10-08 17:00:11","","1","63","<p>I have a scenario where I want to take only the first value of a certain type and then take the next different value which is of a different type.</p>
<p>To understand let's consider the following:</p>
<pre><code>of(1,1,1,1,2,3,4)
.pipe(
    // some operators
)
.subscribe(val =&gt; console.log(val);
</code></pre>
<p>I am only interested in the output <code>1,2,3,4</code></p>
<p>note that the 1 in the output should be the first value in the source and not the one before 2.</p>
<p>how do I achieve this using <code>rxjs</code> operators?</p>
","4366237","","","","","2020-10-11 04:38:49","RxJs only take the first value of certain type and skip the rest until a different type of value","<javascript><typescript><rxjs><rxjs-pipeable-operators>","2","4","","","","CC BY-SA 4.0"
"64303198","1","64340286","","2020-10-11 10:53:19","","0","143","<p>I have a Subject <code>refreshData$</code> that triggers data refetch:</p>
<pre><code>const data$ = refreshData$.pipe(
    switchMap(() =&gt; dataService.load())
);
</code></pre>
<p>I need to show loading indicator only if load take more than 1 second. If data arrives in under 1s - do not show the spinner.</p>
<p>Found very good answer <a href=""https://stackoverflow.com/a/56361092/1457181"">here</a>, but it recreates the observables on every refresh. And I want to reuse them. I have started with the following, but it it only works one time. I guess <code>takeUntil</code> has to be replaced with something else here.</p>
<pre><code>const showSpinner$ = merge(
    refreshData$.pipe(
        delay(1000),
        mapTo(true),
        takeUntil(data$)    // FIXME: only shows loading once
    ),
    data$.pipe(
        timeInterval(),
        mapTo(false)
    )
);

----
to be used in template as:
&lt;loading-spinner *ngIf=&quot;showSpinner|async&quot;&gt;&lt;/loading-spinner&gt;
</code></pre>
","1457181","","1457181","","2020-10-11 11:14:19","2020-10-13 17:39:02","rxjs: show loading spinner only if it takes > 1s to load","<rxjs><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"64397313","1","64979242","","2020-10-16 22:42:25","","0","97","<p>I would like to add debounce for an argument inside a function</p>
<p>I am having issue because Angular debounce only works for pipe and observable, so I use lodash debounce instead.</p>
<p>whenever the clarity datagrid table refresh, it will call onRefreshTable function and pass the event object which has table filter and sorting state.</p>
<p>Since refreshTable() will call API which takes longer time, I would like to minimize the API call.</p>
<p>Sometimes table refresh is being called multiple times with the same argument, or different argument. If different argument, the last table refresh call will contain all of the needed argument to pass to the API.</p>
<p>My atttempt where no error in the code, but it still call the function few times after 1 second with the same argument,</p>
<pre><code>import * as _ from lodash;
onRefreshTable(event: ClrDatagridStateInterface&lt;any&gt;) {
        _.debounce((event) =&gt; {
            this.refreshTable(event)
        }, 1000);     
}
refreshTable(event) {
   // save state to the rxjs store 
   // call API which is expensive
}
</code></pre>
<p>I am thinking of using distinctUntilChanged, however it doesn't seems to work for this case, as the argument inside the function is not observable .</p>
<p>Maybe I should use _.cloneDeep instead to compare previous arguments vs current arguments?</p>
","3355407","","3355407","","2020-10-16 22:49:06","2020-11-24 02:02:37","debounce a function inside angular","<rxjs><lodash><angular8><debounce><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"64416100","1","64416407","","2020-10-18 17:12:48","","1","79","<p>I have such file structure:</p>
<ul>
<li>facade.ts</li>
<li>state.ts</li>
<li>component.ts</li>
</ul>
<p>In <code>facade</code> I have:</p>
<pre><code>...
getArticles(): Observable&lt;Article&gt; {
  return this.articleService.fetchAll();
}
...
</code></pre>
<p>In <code>state</code> I have:</p>
<pre><code>...
triggerArticlesFetch$ = new ReplaySubject&lt;void&gt;(1);

articles$ = this.triggerArticlesFetch$.pipe(
  switchMap(() =&gt; this.fc.getArticles()),
  shareReplay(1)
);

loadArticles(): void {
  this.triggerArticlesFetch$.next();
}

getArticles(): Observable&lt;ArticleShare[]&gt; {
  return this.articles$;
}
...
</code></pre>
<p>and finally in <code>component</code> I have:</p>
<pre><code>...
`
  &lt;span&gt; {{ articles$ | async | json }} &lt;/span&gt;
`
...
...
articles$: Observable&lt;Article&gt; = this.st.getArticles();

ngOnInit() {
  this.st.loadArticles();
}
...
</code></pre>
<p>But I have some issues with 'invalidating' this data (component is reusable - and state contains previous data).</p>
<p>What is the best way to clear/reset to <code>[]/null</code>  <code>articles$</code> (probably in state file) everytime I call <code>loadArticles()</code> ?</p>
","1645431","","","","","2020-10-18 17:43:44","Reset ReplaySubject value","<javascript><angular><rxjs><rxjs-pipeable-operators>","1","4","","","","CC BY-SA 4.0"
"64605860","1","","","2020-10-30 09:38:06","","1","19","<p>I am currently trying to figure out how to load an angular/fire-collection including all of its subcollections with RxJS.</p>
<p>This is my current approach:</p>
<pre><code>return this.collectionRef.valueChanges().pipe(
      flatMap((entities: Entity[]) =&gt; entity),
      mergeMap((entity: Entity) =&gt; this.setSubCollection1(entity)),
      mergeMap((entity: Entity) =&gt; this.setSubCollection2(entity)),
      scan((entities: Entity[], entity: Entity) =&gt; entities.filter(a =&gt; a.id !== entity.id).concat(entity), [])
    );
</code></pre>
<p>and to load the documents in their subcollections</p>
<pre><code>  private setSubCollection1 = (entity: Entity): Observable&lt;Entity&gt; =&gt; {
    return this.subCollectionRef.valueChanges(actor).pipe(
      map((subEntities1: SubEntity1[]) =&gt; {
        entity.subEntities1 = subEntities1;
        return entity;
      })
    );
  }
</code></pre>
<p>It works fine when having a full stream.
But now I wanted to get all of data in one single Promise: I already tried <code>.first().toPromise()</code> but this only gets the first entry, and does not finish if the collection has no entries. Using <code>reduce</code> in the query also does not work, because <code>valueChanges()</code> never finishes.</p>
<p>Am I using the wrong operators? Or any other ideas on how to solve that?</p>
<p>I hope to hear from you.</p>
","11723447","","","","","2020-10-30 09:38:06","How to load a firebase-collection with all its subcollection in one promise?","<rxjs><angularfire2><angularfire><rxjs-observables><rxjs-pipeable-operators>","0","0","","","","CC BY-SA 4.0"
"64621267","1","","","2020-10-31 11:35:33","","0","45","<p>I wondering can I instead catchError in pipe of every foreign stream that is mergemaped in my infinite main stream, use one catchError in the end of my main stream. This catchError return a reference to main stream itself for rescue. It could cause memory leak or any other problems?</p>
<p>This is sample code:</p>
<pre class=""lang-typescript prettyprint-override""><code>import { Observable, fromEvent } from &quot;rxjs&quot;;
import { catchError, mergeMap } from &quot;rxjs/operators&quot;;

function foreignStream() {
  return new Observable(observer =&gt; {
    observer.next(0);
    observer.next(1);
    observer.next(2);
    observer.error(&quot;error&quot;);
  });
}

const stream$ = fromEvent(document, &quot;click&quot;).pipe(
  mergeMap(foreignStream),
  catchError(x =&gt; {
    console.log(x);
    return stream$;
  })
);
stream$.subscribe(
  console.log,
  x =&gt; console.log(&quot;err&quot; + x),
  () =&gt; console.log(&quot;complete&quot;)
);

</code></pre>
","13584583","","13680115","","2020-10-31 13:10:33","2020-10-31 13:10:33","rxjs: keep infinite stream alive after error","<angular><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"64757534","1","","","2020-11-09 18:45:51","","1","168","<p>I'm trying to learn rxjs observables for an ionic project. I've made some headway, but am stuck on a syntax error that I have no idea what it means. The message appeared after I added the pipe to the http.get.</p>
<p>Any ideas of what is wrong and how to fix it would be very welcome:</p>
<pre><code>TS2740: Type '{ (): Observable ; (op1: OperatorFunction ): Observable; (op1: OperatorFunction , op2: OperatorFunction...&gt;): Observable...&gt;; (op1: OperatorFunction...&gt;, op2: OperatorFunction...&gt;, op3: OperatorFunction...&gt;): Observable...&gt;; (op1: OperatorFunction......' is missing the following properties from type 'Observable ': _isScalar, source, operator, lift, and 6 more.
</code></pre>
<p>My code is:</p>
<pre class=""lang-js prettyprint-override""><code>// Ionic Modules
import { catchError, map } from 'rxjs/operators';
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs-compat/Observable';
import { pipe, throwError } from 'rxjs';

// Models
import { Game } from '../models/game';
import { GamesList } from '../models/games-list';

// Other Modules
import { environment } from '../environments/environment';

@Injectable({
  providedIn: 'root'
})

export class GamesProvider {
  constructor(
      private http: HttpClient
  ){}

  /**
   * @summary Retrieve the full games list
   * @returns The returned games list data
   */
  public getGamesAll(): Observable&lt;GamesList&gt; {
    console.log('GamesProvider, in getGamesAll');
    return this.http.get(environment.API_URL, {responseType: 'json'}).pipe{
      map(data =&gt; {
        return new GamesList(data);
      }),

      catchError(err =&gt; {
        console.error(err);
        return throwError('Something went wrong ;)');
      });
    }
  }
}
</code></pre>
","9043945","","3625171","","2020-11-09 20:47:51","2020-11-09 20:47:51","missing the following properties from type 'Observable'","<ionic-framework><rxjs><rxjs-observables><rxjs-pipeable-operators>","0","1","","","","CC BY-SA 4.0"
"64868332","1","","","2020-11-17 02:08:37","","0","9","<p>I have this following setup in a service -</p>
<pre><code> user = new Subject&lt;User&gt;();

    login(email: string, password: string) {
    return this._http
      .post&lt;AuthResponseData&gt;(
        `url`,
        {
          email,
          password,
        }
      )
      .pipe(
        catchError(this._handleError),
        tap((resData) =&gt;
          this._handleAuthentication(
            resData.email,
            resData.localId,
            resData.idToken,
            +resData.expiresIn
          )
        )
      );
  }
    private _handleAuthentication(
        email: string,
        localId: string,
        idToken: string,
        expiresIn: number
      ) {
        const expirationDate = new Date(new Date().getTime() + expiresIn * 1000);
        const user = new User(email, localId, idToken, expirationDate);
        this.user.next(user);
      }

 private _handleError(errorResponse: HttpErrorResponse) {
    let errorMessage = 'An unknown error occurred!';

    ...error code checking in a switch

    return throwError(errorMessage);
  }
</code></pre>
<p>Everthing works fine but when I replace the tap() and the _handleAuthentication() method as below, <strong>the Subject 'user' stays 'undefined' in the _handleAuthentication() method</strong> -</p>
<pre><code>...
tap(this._handleAuthentication)
...
private _handleAuthentication(resData: AuthResponseData) {
    const { email, localId, idToken, expiresIn } = resData;
    const expirationDate = new Date(new Date().getTime() + +expiresIn * 1000);
    const user = new User(email, localId, idToken, expirationDate);
    console.log(this.user);
    // this.user.next(user);
  }
</code></pre>
<p>The this.user Subject gets undefined and the next() method throws an error. What I am missing here, please?</p>
<p>Is it related to _handleAuthentication not waiting for response data? How this can be handled?</p>
","2815464","","","","","2020-11-17 02:08:37","Angular Subject stays undefined at certain condition in a service, can't call next()","<angular><subject><rxjs-pipeable-operators>","0","0","","","","CC BY-SA 4.0"
"64914846","1","","","2020-11-19 15:32:02","","1","119","<p>I like the readability provided by</p>
<pre><code>observable
  .pipe(operator1)
  .pipe(operator2)
  .pipe(operator3)
  .subscribe()
</code></pre>
<p>And it reminds me of a chain of thens for a promise.</p>
<p><strong>But</strong> I know this is in every documentation example</p>
<pre><code>observable
  .pipe(
    operator1,
    operator2,
    operator3
).subscribe()
</code></pre>
<p>Is there something lost in doing the first thing over the second? I am probably missing some crucial information here and maybe it's very obvious, actually. Thanks for the help.</p>
","3278687","","","","","2020-11-19 21:12:43","Rxjs pipes - multiple operators in one pipe or multiple pipes?","<rxjs><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"64974421","1","64974895","","2020-11-23 18:42:00","","0","51","<p>I have the following code in my service</p>
<pre><code>        let b = new BehaviorSubject({ a: undefined })
        let o = b.asObservable();
        o.pipe(filter(_ =&gt; _.a === 5)).subscribe(() =&gt; {
            debugger;
        }, error =&gt; {
            debugger
        })
        b.next({ a: 10 })
        b.next({ a: 5 })
        b.error({ a: 10 })
</code></pre>
<p>When I invoke b.next({a:10}) it does not hit the debugger in the onNext callback When I invoke b.next({a:5}) it hits the debugger in the onNext callback.
When I invoke b.error({a:10}) it hits the debugger in the onError callback.</p>
<p>My expectation was the onError callback should not be called since the filter condition was not satisfied. But, clearly I have something wrong here.</p>
<p>How do I filter the errors too?</p>
<p>Thank you in advance.</p>
","10235280","","10235280","","2020-11-23 18:56:17","2020-11-23 19:14:32","Rxjs Observer filter not working for error","<angular><rxjs><behaviorsubject><rxjs-observables><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"65359708","1","65361783","","2020-12-18 15:30:17","","1","91","<p>I have the following setup, which, every 3 seconds would make a new HTTP request to a server.</p>
<pre class=""lang-js prettyprint-override""><code>  getData(param1: string): Observable&lt;any&gt; {
    return timer(0, 3000).pipe(
      switchMap(() =&gt; this.http.get(param1))
    );
  }
</code></pre>
<p>If a given request takes more than 3 seconds, the <code>switchMap()</code> (I think) will cancel it and fire off a new one.</p>
<p>Now, I want to make it so that if a request is taking more than 3 seconds it waits for it to complete before firing off another one. Just for context, the idea is that if there's performance issues with the requests, my front-end is not stuck firing off and cancelling requests too early.</p>
<p>I somewhat got this to work with the following:</p>
<pre class=""lang-js prettyprint-override""><code>currentObs: Observable&lt;any&gt;;

getData(param1: string): Observable&lt;any&gt; {
  return timer(0, 3000).pipe(
    throttle(_ =&gt; this.currentObs),
    switchMap(() =&gt; {
      this.currentObs = this.http.get(param1)
      return this.currentObs;
    })
  );
}
</code></pre>
<p>This will keep track of the <code>currentObs</code> which is the observable of the current HTTP request. It then passes it to a <code>throttle()</code> method so that the values from <code>timer()</code> that normally prompt new requests are ignored until the request (<code>currentObs</code>) completes.</p>
<p>This seems to work but it's a bit awkward as I'd need to keep some of the state outside the <code>pipe()</code>. It's also a bit confusing because the throttling is based on an event that happens after it. I've been looking for a way to pass the result of the <code>switchMap()</code> onto the <code>throttle()</code> but first I didn't find one, and second, wouldn't that cause the <code>throttle()</code> to be in the wrong side of the pipe?</p>
<p>Is there a neater way to achieve this using RxJS?</p>
<h1>Edit:</h1>
<p>With @Mrk Sef's answer for a more elegant solution and @kvetis' warning for handling errors, I ended up with the following pipe that will make a request, wait for 3 seconds after a success and then make another request. If the request fails, it's going to wait for 3 seconds and make another request. and then start from the top.</p>
<pre class=""lang-js prettyprint-override""><code>getData(param1: string): Observable&lt;any&gt; {
  return this.http.get(param1).pipe(
    repeatWhen(s =&gt; s.pipe(
      delay(3000)
    )),
    retryWhen(s =&gt; s.pipe(
      delay(3000)
    ))
  );
}
</code></pre>
","1821741","","1821741","","2020-12-21 13:39:15","2020-12-21 13:39:15","Throttle based on a previous Observable","<rxjs><angular-httpclient><rxjs-observables><rxjs-pipeable-operators>","2","1","","","","CC BY-SA 4.0"
"65446887","1","","","2020-12-25 09:31:19","","1","69","<p>How to combine the distinct, switchMap and mergeMap operators, so that when the source emits repeated values (detected by distinct.keySelector), the previous subscription is canceled (as in the switchMap), but if the value is not repeated follow the behavior of mergeMap?</p>
<p>Example:</p>
<pre><code>source = from(1, 2, 1, 2, 3) // 'abcde'
result = source.pipe(delay(), combination() // '--cde'
</code></pre>
<p>I'm currently doing something like:</p>
<pre><code>const activeSubscriptions = new Map();
source$.pipe(
  mergeMap((value) =&gt; {
    const pendingSubscription = activeSubscriptions.get(value);
    if (pendingSubscription) {
      pendingSubscription.unsubscribe();
      activeSubscriptions.delete(value);
    }
    const request$ = new Subject();
    const subscription = this.service.get(value).subscribe({
      complete: () =&gt; request$.complete(),
      error: (err) =&gt; request$.error(err),
      next: (value) =&gt; request$.next(value),
    });
    activeSubscriptions.set(value, subscription);
    return request$;
  })
);
</code></pre>
<p>But looking for a better way to do that.</p>
<p>Thank you in advance</p>
","4233401","","","","","2020-12-26 12:16:14","Cancel repeated subscription in mergeMap","<rxjs><rxjs5><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"65457823","1","65477872","","2020-12-26 15:20:28","","2","171","<p>I have a <code>csv</code> file and I want to conver it into a <code>JSON</code>.</p>
<p>I' m reading the CSV file with <code>HttpClient</code> and then I'm using <a href=""https://github.com/Keyang/node-csvtojson"" rel=""nofollow noreferrer"">csvToJson</a> to convert it.</p>
<p>This test code works:</p>
<pre class=""lang-js prettyprint-override""><code>this.httpClient
      .get('assets/csv/results.csv', { responseType: 'text' })
      .subscribe(
        (data) =&gt; {
          csv()
            .fromString(data)
            .subscribe((jsonObj) =&gt; console.log(jsonObj));
        }
      );
</code></pre>
<p>But when I try to merge the two observables to create a function:</p>
<pre class=""lang-js prettyprint-override""><code>
  convert() {
    this.httpClient
      .get('assets/csv/results.csv', { responseType: 'text' })
      .pipe(switchMap((d) =&gt; csv().fromString(d)))
      .subscribe((c) =&gt; console.dir(c));
  }
</code></pre>
<p>I get this error:</p>
<pre><code>core.js:4352 ERROR TypeError: You provided an invalid object where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
    at subscribeTo (subscribeTo.js:27)
    at innerSubscribe (innerSubscribe.js:69)
    at SwitchMapSubscriber._innerSub (switchMap.js:44)
    at SwitchMapSubscriber._next (switchMap.js:34)
    at SwitchMapSubscriber.next (Subscriber.js:49)
    at MapSubscriber._next (map.js:35)
    at MapSubscriber.next (Subscriber.js:49)
    at FilterSubscriber._next (filter.js:33)
    at FilterSubscriber.next (Subscriber.js:49)
    at MergeMapSubscriber.notifyNext (mergeMap.js:70)
    at SimpleInnerSubscriber._next (innerSubscribe.js:10)
    at SimpleInnerSubscriber.next (Subscriber.js:49)
    at XMLHttpRequest.onLoad (http.js:1678)
    at ZoneDelegate.invokeTask (zone-evergreen.js:399)
    at Object.onInvokeTask (core.js:27474)
    at ZoneDelegate.invokeTask (zone-evergreen.js:398)
</code></pre>
<h3>Update</h3>
<p>I've created a <a href=""https://stackblitz.com/edit/angular-ivy-2ksumy?devtoolsheight=33&amp;file=src/app/csv-2-json.service.ts"" rel=""nofollow noreferrer"">stackblitz</a> to experiment.</p>
<p>In the stackblitz I get an error I don't get on localhost:</p>
<pre class=""lang-js prettyprint-override""><code>Error in src/app/csv-2-json.service.ts (18:24)
This expression is not callable.
Type '{ default: (param?: Partial&lt;CSVParseParam&gt;, options?: any) =&gt; Converter; }' has no call signatures.
</code></pre>
<p>In the library <a href=""https://github.com/Keyang/node-csvtojson"" rel=""nofollow noreferrer"">source code</a> I see that the <code>fromString()</code> returns a <a href=""https://github.com/Keyang/node-csvtojson/blob/master/src/Converter.ts"" rel=""nofollow noreferrer"">Converter</a> that implements <code>PromiseLike&lt;any[]&gt;</code> so I thought it should work.</p>
<p>What I'm doing wrong?</p>
","1471829","","1471829","","2020-12-28 10:33:05","2020-12-28 12:48:05","Merge two observables in angular for CSV to JSON conversion","<angular><rxjs><observable><rxjs-pipeable-operators>","2","2","","","","CC BY-SA 4.0"
"65495915","1","65496126","","2020-12-29 17:04:52","","0","50","<p>The situation:</p>
<p>I have an http request, that, once I get it I need to make another request. However, the second request that I make depends on the result of the first one. As in, my first request returns either pass or fail, and if it returns pass I want to call apiPass, and if it fails I want to instead return a different Observable.</p>
<p>I know if I had just one call to call after the first, I could use something like mergemap and write something like</p>
<pre><code>return this.http.post&lt;{id:string, resPass:boolean}&gt;(this.urlFirst, bodyObject)
    .pipe(mergeMap(this.http.get&lt;any&gt;(this.passUrl)));
</code></pre>
<p>But my situation is different - I want to use resPass to know if I should indeed call the pass Api, or if I should instead do the fail logic (which should also return an Observable, just a different one). How can I, without subscribing unnecessarily, map to one Observable (<code>http.get(this.passUrl)</code>) if the first call param passes, and a different one (<code>otherObservable</code>) if the param fails?</p>
<p>In both instances my first call should return <code>http code 200</code> , so it is not a matter of an http failure either.</p>
<p>Any leads?</p>
","14492841","","","","","2020-12-29 17:21:34","How can I have an observable call another one based on the result?","<angular><http><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"65617167","1","65617496","","2021-01-07 17:26:47","","0","40","<p>In order to inspect intermediate values between operators in an rxjs pipe, I am trying to use tap for simply logging them to the console.</p>
<p>I have two taps, one before a map operator that is used for sorting an Array, and one after it. What surprised me is, that <strong>for both taps, the same sorted Array is logged, while I expected to see the original order first, and then the sorted one</strong>.</p>
<p>So the sorting in the map operator affects the observable used by the previous tap operator. Nonetheless, the operators' functions seem to be executed one after another as expected, since the log of the second map is logged inbetween the taps' logs.</p>
<p>My code (I intend to replace the Observable Array's type with a proper one later on):</p>
<pre><code>public getJSONData(): Observable&lt;any[]&gt; {
    return this.http.get(this.poisJSONPath).pipe(
      map((featureCollection: any) =&gt; featureCollection.features),
      tap((features) =&gt; console.log(features)),
      map((features: any) =&gt; {
        console.log('this is logged in between as expected');
        return features.sort((a, b) =&gt;
          a.properties.name &gt; b.properties.name ? 1 : -1
        );
      }),
      tap((features) =&gt; console.log(features))
    );
  }
</code></pre>
<p>I assume I am missing some fundamental feature of the rxjs pipes' mode of operation. In all other examples I found, the tap seems to work as I expect. What am I missing here?</p>
","7143832","","7143832","","2021-01-07 17:33:45","2021-01-07 18:31:20","How is a piped rxjs operator possibly affected by a subsequent operator's returned value?","<angular><typescript><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"65643749","1","65655470","","2021-01-09 14:25:19","","0","33","<p>I have written the following effect in my Angular app which uses <code>rxjs</code>. On <code>MyActions.myAction</code>, I receive an object containing a property <code>ids</code> - an array of ids - and for each id I want to send an HTTP request via <code>this.myApiService.getResource</code>, which returns an <code>Observable&lt;Resource&gt;</code>. I want then to collect all results in an array, and dispatch another action passing the array.</p>
<pre><code>  public loadResources$: Observable&lt;MyAction&gt; = this.actions$.pipe(
    ofType(MyActions.myAction),
    switchMap(({ ids }) =&gt; from(ids).pipe(
      mergeMap(id =&gt; this.myApiService.getResource(id)),
      toArray()
    )),
    map(resources) =&gt; MyActions.resourcesLoaded({ resources } )),
  );
</code></pre>
<p>The code above does the job, but I wonder whether I should avoid nesting two flows of reactive operators, and whether there is a better way to write that.</p>
<p>The reason I wonder that is that I am having problems writing a test for it. I wrote the test below but I cannot make it pass.</p>
<pre><code> it('should dispatch an resourcesLoaded action with the resources', () =&gt; {
      const ids = ['5f7c723832758b859bd8f866'];
      const resources = [{} as Resource];

      const values = {
        l: MyActions.loadResources({ ids }),
        t: ids[0],
        o: MyActions.resourcesLoaded({ resources })
      };

      actions =         hot('--l------------', values);
      const get$ =     cold('  -------t-----', values);
      const expected = cold('---------o-----', values);

      myApiService.getResource.withArgs(ids[0]).returns(get$);

      expect(myEffects.loadResources$).toBeObservable(expected);
    });
</code></pre>
<p>The error I get is:</p>
<pre><code>     Expected $.length = 0 to equal 1.
Expected $[0] = undefined to equal Object({ frame: 50, notification: Notification({ kind: 'N', value: { ....
Error: Expected $.length = 0 to equal 1.
Expected $[0] = undefined to equal Object({ frame: 50, notification: Notification({ kind: 'N', value: { ....
    at &lt;Jasmine&gt;
    at compare (http://localhost:9876/Users/jacopolanzoni/Documents/Development/myProject/node_modules/jasmine-marbles/index.js:91:1)
    at &lt;Jasmine&gt;
</code></pre>
","976992","","976992","","2021-01-10 12:37:45","2021-01-10 16:17:47","Should we avoid nested rxjs operators? One case which I cannot test","<rxjs><rxjs-pipeable-operators><jasmine-marbles><rxjs-marbles><marble-diagram>","2","6","","","","CC BY-SA 4.0"
"65689898","1","","","2021-01-12 18:31:08","","2","50","<p>There are two observables that may be emiting together or separately: <code>stream1</code> and <code>stream2</code>.
I need my subscription to fire only if <code>stream2</code> fires less then 1 second after <code>stream1</code> does.
<br>
Any way to achieve that with RxJS?</p>
","10344505","","","","","2021-01-12 22:33:47","RxJS. Combine observables that emit less then 1 second apart","<javascript><rxjs><reactive-programming><rxjs-observables><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"65710733","1","65711943","","2021-01-13 22:30:45","","0","166","<pre><code>of([1,2,3]).subscribe(console.log)
</code></pre>
<p>prints:<code>[1,2,3]</code></p>
<p>But:</p>
<pre><code>of([1,2,3]).pipe(concatAll()).subscribe(console.log)
</code></pre>
<p>prints:</p>
<pre><code>1
2
3
</code></pre>
<p><strong>Why the above happens?</strong> Why adding <code>concatAll()</code> emits the elements of the array one by one? Isn't this somehow the opposite of what the word concat means?</p>
<p>I feel that <code>concatAll()</code> acts differently depending on the input.</p>
<p>Consider also this:</p>
<pre><code>from([of(1),of(2),of(3)]).pipe(concatAll()).subscribe(console.log)
</code></pre>
<p>It will again print:</p>
<pre><code>1
2
3
</code></pre>
<p>So <code>of([1,2,3]).pipe(concatAll())</code> <strong>==</strong> <code>from([of(1),of(2),of(3)]).pipe(concatAll())</code></p>
<p>But <code>of([1,2,3])</code> <strong>!=</strong> <code>from([of(1),of(2),of(3)])</code> because subscribing to the latter will print:</p>
<pre><code>Observable { _isScalar: false, _subscribe: [Function] }
Observable { _isScalar: false, _subscribe: [Function] }
Observable { _isScalar: false, _subscribe: [Function] }
</code></pre>
<p>The right side of the above equality is pretty clear to me, but where is documented that <code>concatAll()</code> should emit all the values of the array separately, acting like a pipeable <code>from</code>?</p>
","1555615","","","","","2021-01-14 00:55:04","How can of([1,2,3]).pipe(concatAll()) emit 3 values when of([1,2,3]) emits one?","<rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","0","1","","","CC BY-SA 4.0"
"65744897","1","65748168","","2021-01-15 23:36:16","","1","43","<p>Suppose that you have a function that returns an rxjs observable that contains a list of objects.</p>
<pre class=""lang-js prettyprint-override""><code>const getItems = () =&gt;
  of([
    {
      id: 1,
      value: 10
    },
    {
      id: 2,
      value: 20
    },
    {
      id: 3,
      value: 30
    }
  ]);
</code></pre>
<p>and a second function that returns an observable with a single object</p>
<pre class=""lang-js prettyprint-override""><code>const getItem = id =&gt;
  of({
    id,
    value: Math.floor(Math.random() * 30) + 1
  });
</code></pre>
<p>Now we want to create an observable that will get the first list and at a regular interval will randomly update any list item.</p>
<pre class=""lang-js prettyprint-override""><code>const source = getItems().pipe(
  switchMap(items =&gt;
    interval(5000).pipe(
      switchMap(x =&gt; {
        // pick up a random id
        const rId = Math.floor(Math.random() * 3) + 1;

        return getItem(rId).pipe(
          map(item =&gt;
            items.reduce(
              (acc, cur) =&gt;
                cur.id === item.id ? [...acc, item] : [...acc, cur],
              []
            )
          )
        );
      })
    )
  )
);

source.subscribe(x =&gt; console.log(JSON.stringify(x)));

</code></pre>
<p>The problem with the above code is that each time the interval is triggered the items from the previous iteration reset to their initial form. e.g,</p>
<pre><code>[{&quot;id&quot;:1,&quot;value&quot;:10},{&quot;id&quot;:2,&quot;value&quot;:13},{&quot;id&quot;:3,&quot;value&quot;:30}]
[{&quot;id&quot;:1,&quot;value&quot;:10},{&quot;id&quot;:2,&quot;value&quot;:20},{&quot;id&quot;:3,&quot;value&quot;:18}]
[{&quot;id&quot;:1,&quot;value&quot;:10},{&quot;id&quot;:2,&quot;value&quot;:16},{&quot;id&quot;:3,&quot;value&quot;:30}]
[{&quot;id&quot;:1,&quot;value&quot;:21},{&quot;id&quot;:2,&quot;value&quot;:20},{&quot;id&quot;:3,&quot;value&quot;:30}]
</code></pre>
<p>As you see, on each interval our code is resetting the list and updates a new item (eg value 13 is lost in the second iteration and reverts to 20).
The behaviour seems reasonable since the <code>items</code> argument in the first <code>switchMap</code> acts like a closure.</p>
<p>I managed to somehow solve the issue by using <code>BehaviorSubject</code> but i think that my solution is somehow dirty.</p>
<pre class=""lang-js prettyprint-override""><code>const items$ = new BehaviorSubject([]);

const source = getItems().pipe(
  tap(items =&gt; items$.next(items)),
  switchMap(() =&gt;
    interval(5000).pipe(
      switchMap(() =&gt; {
        const rId = Math.floor(Math.random() * 3) + 1;

        return getItem(rId).pipe(
          map(item =&gt;
            items$
              .getValue()
              .reduce(
                (acc, cur) =&gt;
                  cur.id === item.id ? [...acc, item] : [...acc, cur],
                []
              )
          ),
          tap(items =&gt; items$.next(items)),
          switchMap(() =&gt; items$)
        );
      })
    )
  )
);
</code></pre>
<p>Is there a better approach ?</p>
<p>Example code can be found <a href=""https://stackblitz.com/edit/rxjs-6wd75j?file=index.ts"" rel=""nofollow noreferrer"">here</a></p>
","1149919","","","","","2021-01-16 09:33:20","Keep state while operating in switchMap","<rxjs><behaviorsubject><rxjs-pipeable-operators><switchmap>","1","0","","","","CC BY-SA 4.0"
"65834915","1","68132628","","2021-01-21 19:59:33","","1","23","<p>Here is an example that can be run with ts-node. Why is the value displayed in result 2 instead of 3.</p>
<pre><code>import { interval, Subject } from 'rxjs';
import { startWith, takeUntil, tap, map } from 'rxjs/operators';

const done = new Subject();
let times = 0;

function test() {
  return interval(5000).pipe(
    startWith(0),
    map(() =&gt; times++ ),
    tap(n =&gt; {
      console.log(n);
      if (n === 3) {
        done.next();
      }
    }),
    takeUntil(done),
  ).toPromise();
}

test().then(n =&gt; {
  console.log('result: ', n);
}).catch(err =&gt; {
  console.error('error: ', err.message);
});
</code></pre>
<p>output is: what expecting result: 3</p>
<pre><code>0
1
2
3
result:  2
</code></pre>
","2475472","","","","","2021-06-25 14:26:08","toPromise doesn't return last observed value","<rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"65959106","1","65959358","","2021-01-29 17:29:01","","0","49","<p>Given an Angular route, i need to read two parameters from the router in sequence.
Actually my code have nested subscription, but i don't like them so much</p>
<pre><code>  this.route.parent.parent.params.subscribe(params =&gt; { 
      //read 'params'
      this.route.parent.parent.data.subscribe(anotherParams =&gt; {
         //read 'anotherParams' and do some thing with 'params'
       })
   })
</code></pre>
<p>I want to use rxjs operators for write 'subscribe' once, and inside of it give the access to both params.</p>
<p>Something like this:</p>
<pre><code> this.route.parent.parent.params.pipe( //some operators )
 .subscribe ( params, anotherParams =&gt; {
    'params' and 'anotherParams&quot; readable inside that
  })
</code></pre>
","1088417","","","","","2021-01-29 17:47:15","RxJs and Angular, i need read two params from route and i want to use pipeable operators","<angular><rxjs><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"66018071","1","","","2021-02-02 21:44:57","","0","83","<p>I have an input search with debounceTime operator, but I want to emit only when the typing event is stopped by the user, in that window of time I will emit the value, if another value is coming it should cancel this new values and waiting for stopped event to emit the new value.</p>
<p>The behavior happened when the I pressed a letter key for a while (one second), after that I erase with backspace emitting the value after pressed not waiting for the new value after backspace event.</p>
<pre><code>  Observable.fromEvent(this.emailRef.nativeElement, 'keyup')
  .map((evt: any) =&gt; evt.target.value)
  .debounceTime(700)        
  .distinctUntilChanged()
   // emit only when the typing is paused for 1000 ms
  .subscribe((text: string) =&gt; this.submit(text));
</code></pre>
<p><a href=""https://stackblitz.com/edit/angular-rxjs-observable-form-input-debounce-qneels"" rel=""nofollow noreferrer"">Link to stackblitz</a></p>
","1399262","","","","","2021-02-02 21:44:57","How to emit value in a window of time when keyup event is paused in rxjs?","<javascript><angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","0","2","","","","CC BY-SA 4.0"
"66050842","1","","","2021-02-04 17:33:59","","1","62","<p>I have a situation where I have an observable, and for each emitted item, I want to create another observable, but ignore that observable's value and instead return the result of the first observable.<br />
For example, if I click a button, I want to track something that happens in another button, only when the first button is toggled on.</p>
<p>I can do this now, sort of, with a hack, by taking the output of the child observable and piping it to a <code>mapTo</code> with the parent's value.  You can see it in this code, which can be played with in a <a href=""https://codesandbox.io/s/rxjs-playground-forked-61tgl?file=/src/index.js"" rel=""nofollow noreferrer"">code sandbox</a>:</p>
<pre class=""lang-js prettyprint-override""><code>import { fromEvent, from } from &quot;rxjs&quot;;
import { mapTo, switchMap, tap, scan  } from &quot;rxjs/operators&quot;;

const buttonA = document.getElementById(&quot;a&quot;);
const buttonB = document.getElementById(&quot;b&quot;);

const textA = document.querySelector('#texta');
const textB = document.querySelector('#textb');

fromEvent(buttonA, 'click').pipe(
  // this toggles active or not.
  scan((active) =&gt; !active, false),
  switchMap(active =&gt; {

    if (active) {
      const buttonBClicks$ = fromEvent(buttonB, 'click');
 
      // here we can observe button b clicks, when button a is toggled on.
      return buttonBClicks$.pipe(
        // count the sum of button b clicks since button a was toggled on.
        scan((count) =&gt; count+1, 0),
        tap(buttonBCount  =&gt; {
          textB.value = `button b count ${buttonBCount}`;
        }),
        // ignore the value of the button b count for the final observable output. 
        mapTo(active)
      )
    } else {
      textB.value = ``;

      return from([active]);
    }
   
  })
).subscribe({
  next: buttonActive =&gt; {
    textA.value = `Button a active: ${buttonActive}`
  }
});
</code></pre>
<p>A couple issues here.  In the case that the button is toggled on, the outer observable only receives a value once the button is clicked.
This <code>mapTo</code> use seems hacky.</p>
<p>Any better ways to do this?</p>
","773210","","","","","2021-03-24 02:49:14","rxjs - how can you create another observable from an observable but ignore its output in the parent observable?","<rxjs><rxjs-observables><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"66123980","1","66124321","","2021-02-09 17:30:17","","0","71","<p>I am trying to use rxjs in typescript for one of my projects and am struggling with typing one function.
The function I am trying to give a type (Return value type) is <strong>createMessageSource</strong>.</p>
<pre><code>import { interval, Subscription, Observable } from 'rxjs';
import { map } from 'rxjs/operators';

type MessageType = {
      name: string;
      content: string;
}

const createMessageSource =
      (period: number, name: string, content: string) =&gt;
        interval(period)
          .pipe(map(i =&gt; ({
            name,
            content: `${content} - ${i}`,
          })));
</code></pre>
<p>As far as I understand the problem, the return value of the pipe command should be an Observable or a Subscription. So I tried the following types so far:</p>
<pre><code>const createMessageSource: Observable&lt;MessageType[]&gt; = ...

const createMessageSource: Subscription = ...
</code></pre>
<p>Both combinations end in the following typescript error shown in vscode:</p>
<p><em>Type '(period: number, name: string, attribute: string) =&gt; Observable&lt;{ name: string; content: number; }&gt;' is missing the following properties from type 'Observable&lt;MessageType[]&gt;': _isScalar, source, operator, lift, and 6 more.ts(2740)</em></p>
<p>Thx for the help beforehand</p>
","8553358","","","","","2021-02-09 17:57:53","Type Error while using interval and map with RXJS in Typescript. errorcode: ts(2740)","<typescript><rxjs><typescript-typings><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"66155699","1","66164527","","2021-02-11 13:29:05","","0","451","<p>I'm trying to automatize a process of updating some data in the backend of my program.
I'm using my Angular frontend, where I created a function only the master user can access and that should make him login in every administration (tenant), where it will download some objects with some wrong data inside, ask from a google service the right data and update the data in the backend, and do all this operations for each tenant.</p>
<p>I thougt of writing each of this operations as an observable and using concat to do everything in order, but before even finishing getting the right data, which I do inside a tap, it alredy tries to login in the next tenant, so when it actually has the right data he wont be able to upload them to the backend since it will refuse them as from the wrong tenant.</p>
<p>I think this problem is caused by the long operations needed in the tap (and there are some stuff I'll need to do that will require even more time),.</p>
<p>This is my code snippet (without unrelated stuff):</p>
<pre><code>const obsList = [] as Observable&lt;any&gt;[];
this.assignedTenants.forEach(tenant =&gt; {
  const obsList2 = [] as Observable&lt;any&gt;[];
  obsList.push(this.authenticationService.login(new Credentials(usr, psw), tenant.id));
  obsList.push(this.structureService.getStructuresWithWrongAltitude()
    .pipe(tap(structuresReceived =&gt; {
      obsList2 = [] as Observable&lt;any&gt;[];
      if (structuresReceived != null &amp;&amp; structuresReceived.length &gt; 0) {
        structuresReceived.forEach(s =&gt; {
          this.getElevation(new google.maps.LatLng(s.centro.coordinates[0], s.centro.coordinates[1]))
            .then(a =&gt; {
              s.centroAltitudine = a;
              this.obsList2.push(this.structureService.putStructure(s));
            })
            .catch();
        });
      }
  })));
  obsList.push(forkJoin(obsList2)
    .pipe(tap(() =&gt; this.storageService.logout())));
});
concat(...obsList).subscribe();
</code></pre>
<p>As you can see the this code should create and execute 3 observables for each tenant, the first one used to login, the second one to get the wrong data, get the right data and prepare for the third, which will update the data.
As I said, usually when entering the tap from the second observable, the getStructuresWithWrongAltitude one, I can alredy see by using logs that it tries to login to other tenants.</p>
<p>My theory is that as soon as it gets the wrong data it tries to execute the third observable, which is still void, and go to the next tenant, but I dont know how to fix this.</p>
<p>I would need a way for the second observable to not emit until the tap is completed, or another way to prevent the concat to go on before other operations have finished</p>
<p>Thank you for your help</p>
<p>EDIT:</p>
<p>I was able to fix this by making the getElevation (which returns a promise) to an observable list, which would in turn create a new observable list to save the data.</p>
<p>As I said before I need to do something very similar, with the difference that this time the tap will actually have to do a lot of calculations that will take a long time, so I wont be able to use the same fix, as such my question remains: can I make the concat wait until the tap is finished?</p>
<p>EDIT 2 for clarification</p>
<p>As I said in my last edit, that specific example got solved by converting the stuff inside the tap into other observables, but I have almost the same problem with another function</p>
<p>this function needs to find files inside a folder, before uploading them</p>
<pre><code>const folderInput = this.folderInput.nativeElement;
folderInput.onchange = () =&gt; {
  this.filesUploaded = folderInput.files;
  const obsList = [] as any[];

  this.assignedTenants.forEach(tenant =&gt; {
    const obsList2 = [] as Observable&lt;any&gt;[];

    obsList.push(this.authenticationService.login(new Credentials(usr, psw), tenant.id));

    obsList.push(this.fileService.getAll()
      .pipe(
        tap(filesReceived =&gt; {
          if (filesReceived != null &amp;&amp; filesReceived.length &gt; 0) {
            console.log('upload picture: received list of files to update');

            let i = filesReceived?.length;
            filesReceived?.forEach(f =&gt; {
              const pathReceived = (f.originalFilename as string).substr(1).split('\\');

              let found = false;
              let index = -1;
              
              // searching the file in the folder
              //...
              
              if (found) {
                console.log('found a file');
                const selectedFile = this.filesUploaded[index];
                const formData = new FormData();
                formData.append('file', selectedFile, selectedFile.name);
                obsList2.push(this.fileService.updateFile(formData, f.id));
              }
              i--;
            });
            console.log('upload picture: updated obsList2');
            obsList.push(forkJoin(obsList2).subscribe(() =&gt; {
              console.log('upload picture: uploaded pictures');
              this.storageService.logout();
            }));
          }
      }))
    );
  });

  this.loadingIndicatorService.loading$.next(true);
  let counter = obsList.length;
  concat(...obsList).subscribe(() =&gt; {
    counter--;
    console.log('upload pictures: remaining phases: ' + counter);
    if (counter &lt;= 0) {
      this.loadingIndicatorService.loading$.next(false);
  }
});
};
folderInput.click();
</code></pre>
","14762821","","14762821","","2021-02-11 15:37:10","2021-02-12 16:34:48","Angular Rxjs: Have concat wait for a very long tap","<rxjs><concatenation><rxjs-observables><rxjs-pipeable-operators><rxjs-pipe>","2","4","","","","CC BY-SA 4.0"
"66243990","1","66244858","","2021-02-17 14:31:30","","0","63","<p>My first observable returns an array of Persons. I want to update each person of that array with a list of clients from second observable. How do I do that? So far I have this:</p>
<pre><code>const json: Person[] = [new Person('Alice'), new Person('Bob')];

const resultsObservable = new Observable&lt;string[]&gt;(subscriber =&gt; {

  setTimeout(() =&gt; {
    subscriber.next(['Client1', 'Client2', 'Client3']);
    subscriber.complete();
  }, 1000);
});

of(json).pipe(
  switchMap( dataArray =&gt; {
    return from(dataArray);
  }),
  map((x: Person) =&gt; {
    resultsObservable.subscribe(r =&gt; {
      x.clients = r;
    });
    return x;
  }),
).subscribe(value =&gt; {
    console.log(value);
});
</code></pre>
<p>}</p>
<p>Person:</p>
<pre><code>export class Person{
  name: string;
  clients?: string[];

  constructor(name: string) {
    this.name = name;
  }
}
</code></pre>
<p>But the problem is that return happens before the values are set, so at the end value of person.clients is undefined. How do I fix this? Or what is a better way to achieve what I'm trying to do?</p>
","1328889","","","","","2021-02-17 15:18:55","rxjs: subscribing to observable in map","<rxjs><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"66263164","1","","","2021-02-18 15:36:44","","1","38","<p>I have seen and tried a lot of other threads describing the same issue, but couldn't find the solution. I am a beginner in angular technology. I am using angular 11. I am trying to refresh the JWT token in the HttpInterceptor class</p>
<pre><code>this.loginService.checkRefreshToken(this.refreshtoke).pipe(
switchMap((tokenResponse: any) =&gt; {
          if (tokenResponse) {
            localStorage.setItem('authToken', tokenResponse.Token)
            localStorage.setItem('refreshToken', tokenResponse.RefreshToken)
            this.tokenSubject.next(tokenResponse);
            console.log('token refreshed');
            return next.handle(this.attachAuthToken(request));
          }
          else return &lt;any&gt;this.loginService.LogOutUser();
        })
      );
</code></pre>
<p>The above is my interceptor class calling login service</p>
<pre><code>checkRefreshToken(data : Irefreshtoken) : Observable&lt;any&gt; {
        var body = JSON.stringify(data)
    const httpOptions = {
      headers: new HttpHeaders({
          'Content-Type': 'application/json',
          'Authorization': 'my-auth-token'
      }),
        
    };

    const postURL = this.constants.API_ENDPOINT + this.constants.CheckRefreshToken;

    return this.http.post&lt;any&gt;(postURL,data,httpOptions)
        .pipe(
            tap((result: any) =&gt; {
            localStorage.setItem('authToken', result.Token)
            localStorage.setItem('refreshToken', result.RefreshToken)
        })
    );
</code></pre>
<p>This is my login service function</p>
<pre><code>[HttpPost]
        [Route(&quot;CheckRefreshToken&quot;)]
        public async Task&lt;IActionResult&gt; CheckRefreshToken(RefreshToken data)
</code></pre>
<p>This is my controller method</p>
<p>The post call is not hitting the back end and is always ending up with error</p>
<pre><code>ERROR TypeError: You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
    at subscribeTo (subscribeTo.js:27)
    at innerSubscribe (innerSubscribe.js:69)
    at CatchSubscriber.error (catchError.js:36)
    at XMLHttpRequest.onLoad (http.js:1700)
    at ZoneDelegate.invokeTask (zone-evergreen.js:402)
    at Object.onInvokeTask (core.js:28499)
    at ZoneDelegate.invokeTask (zone-evergreen.js:401)
    at Zone.runTask (zone-evergreen.js:174)
    at ZoneTask.invokeTask [as invoke] (zone-evergreen.js:483)
    at invokeTask (zone-evergreen.js:1596)
</code></pre>
<p>I know that this is a general error in angular. Any help will be much appreciated. Correct me if I am wrong somewhere. These codes were copied from tutorial codes</p>
<p>Thanks for your help</p>
","10325225","","","","","2021-02-18 15:47:27","You provided 'undefined' where a stream was expected. Error in HttpInterceptor","<angular><rxjs><angular-httpclient><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"66277643","1","66277918","","2021-02-19 12:32:12","","1","65","<p>I made a service that gets some userdata from a remote source. The service a method for getting multiple users, and one for getting a specific user.
The observables returned from the two methonds get .pipe(ed) thru a map() to be able to mutate the user-objects before they get consumed.</p>
<p>What I want is to only define the mutators once, for both the multiple users stream and the single users stream, but I run into scope problems with my current approach.</p>
<p>Be aware that I call users &quot;heroes&quot;. This is a design aspect.
Following are the corresponding methods from my HeroService class:</p>
<pre><code>export class HeroService {
  // [...]

  getHeroes(): Observable&lt;Hero[]&gt; {
    return this.http.get&lt;Hero[]&gt;(this.heroesUrl).pipe(
      map((heroes: Hero[]) =&gt; this.mutateHeroes(heroes, this.addSkillsToHero)),
      map((heroes: Hero[]) =&gt; this.mutateHeroes(heroes, this.splitName))
    );
  }

  getHero(id): Observable&lt;Hero&gt; {
    return this.http.get&lt;Hero&gt;(this.heroesUrl + &quot;/&quot; + id).pipe(
      map((hero: Hero) =&gt; this.addSkillsToHero(hero)),
      map((hero: Hero) =&gt; this.splitName(hero))
    );
  }

  private mutateHeroes(heroes: Hero[], mutator) {
    heroes.forEach((hero: Hero) =&gt; {
      hero = mutator(hero);
    });
    return heroes;
  }

  private splitName(hero: Hero) {
    let heroNames: string[] = hero.name.split(&quot; &quot;);

    hero.firstname = heroNames.splice(0, 1).join(&quot; &quot;);
    hero.lastname = heroNames.splice(heroNames.length - 1, 1).join(&quot; &quot;);
    hero.middlename = heroNames.join(&quot; &quot;);

    return hero;
  }

  private addSkillsToHero(hero: Hero) {
    hero.skills = this.getSkills(Math.ceil(Math.random() * 10));
    return hero;
  }

  private getSkills(count: number): string[] {
    let skills: string[] = [];
    let i;

    for (i = 0; i &lt; count; i++) {
      skills.push(this.getRandomSkill());
    }

    return skills;
  }

  private getRandomSkill(): string {
    return SKILL_TAGS[Math.floor(Math.random() * SKILL_TAGS.length)];
  }
  // [...]
}
</code></pre>
<p>The catchError() of the Observable(s) return: <code>Cannot read property 'getSkills' of undefined</code>
I am suspecting that the mutator does not get called inside the class scope, and cant be found therefore.</p>
<p>How would I do such a thing in JS?</p>
<p>The whole project can be inspected at:</p>
<ul>
<li><a href=""https://github.com/maxbethke/myFirstAngularApp"" rel=""nofollow noreferrer"">https://github.com/maxbethke/myFirstAngularApp</a></li>
<li><a href=""https://stackblitz.com/edit/angular-ivy-rfghml"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-ivy-rfghml</a></li>
</ul>
","5641300","","","","","2021-02-19 21:00:49","Mutating a RxJS observable with variable mutators - Angular","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"66311923","1","66312238","","2021-02-22 07:58:28","","0","61","<p>I want to find string sequence with rxjs</p>
<p>for example</p>
<p>Target string: <code>01234010</code></p>
<p>Match stringe: <code>01</code></p>
<p>answer = 2</p>
<p>I have a solution with using javascript</p>
<pre><code>let index = 0;
while (true) {
  let foundIndex = targetSequence.indexOf(matchSequence, index);
  if (foundIndex == -1) break;

  index = foundIndex + 1;
}
</code></pre>
<p>but the problem is that I have to use rxjs with those skeleton code</p>
<pre><code>import { from, Observable } from &quot;rxjs&quot;;
const targetSequence = `01234010`;
const matchSequence = &quot;01&quot;;

const _target = from(targetSequence);
const _output: Observable&lt;number&gt; = _target.pipe(
  // here is your code
);

_output.subscribe({
    next: val =&gt; console.log(`count : ${val}`)
  });
</code></pre>
<p>do you guys have any idea?</p>
","12905645","","","","","2021-02-22 08:25:22","I want to find string sequence with rxjs","<javascript><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"66415607","1","","","2021-03-01 01:37:26","","2","127","<p>Using Data/Action Streams via RxJS, I want to return/pass an error if a user inputs an invalid bay number. My code currently will return a bay object if it matches the number that the user inputs, <strong>BUT I can't figure out how to throw an error if the user inputs an invalid bay number that doesn't exist in my list of bays</strong></p>
<ol>
<li>In order for me to share data amongst multiple components/pages, I've done most of my stuff in the BayService class:</li>
</ol>
<pre><code>  private baysUrl = 'api/bays';

  bays$ = this.http.get&lt;Bay[]&gt;(this.baysUrl)
    .pipe(
      tap(data =&gt; console.log('Bays: ', JSON.stringify(data))),
      catchError(this.handleError)
    );

  /*--------------------------------------------------------------*/
  // Grab A Single Bay
  private baySelectedSubject = new BehaviorSubject&lt;number&gt;(0);
  baySelectedAction$ = this.baySelectedSubject.asObservable();

  selectedBay$ = combineLatest([
    this.bays$,
    this.baySelectedAction$
  ])
    .pipe(
      map(([bays, selectedBayNumber]) =&gt;
        bays.find(bay =&gt; bay.bayCode === selectedBayNumber)
      ),
    );

  selectedBayChanged(selectedBayNumber: number): void {
    this.baySelectedSubject.next(selectedBayNumber);
  }
</code></pre>
<ol start=""2"">
<li>I created an Action stream by making a BehaviorSubject. Then I created a method to emit a value onto my Action stream. I then call this method in the <code>bay.page.ts</code> where I pass the input parameter and then emit it to my Data stream.</li>
<li>I then combine my data stream and my action stream and then return a single bay object that matches the value from my action Stream.</li>
<li><strong>ISSUE</strong>: SO, I can already emit the value from a users input into my observable and return the bay object based on the number like so:</li>
</ol>
<pre><code>onSubmit() {
     this.bayDoesNotExistError = false;
      this.bayService.selectedBayChanged(this.bayForm.get('bayStart').value);
      this.navCtrl.navigateForward([`/results/`]);
      this.bayForm.reset();
    }
</code></pre>
<p>, but <strong>HOW</strong> do I handle an Invalid number? For example, How, when a user presses the submit button after typing in a number, check if it's invalid against my observable, and then return something back to my component to display on the UI? Currently, I client-side check what the user types and then display an error, But I need to actually check if the input value actually exists in my Observable&lt;bay[]&gt; objects and if it doesn't, return an error or something back to my bay.page.ts file to display in my HTML.</p>
<p>Sorry If I didn't explain this very well as I am trying to figure out how to word it.</p>
<p>Here's my BayService:
<a href=""https://i.stack.imgur.com/SVrUn.png"" rel=""nofollow noreferrer"">BayService.ts</a></p>
<p>Here's my Bay.page.ts: <a href=""https://i.stack.imgur.com/u9gnZ.png"" rel=""nofollow noreferrer"">Bay.page.ts</a></p>
","11569843","","11569843","","2021-03-01 20:12:13","2021-03-02 05:05:17","Check if object in array of objects exists against user input in RxJS HTTP Request","<angular><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"66548689","1","66549424","","2021-03-09 14:20:34","","0","22","<p>I have two different data streams which gives same object with modified property values. I want to write a single subscription so that whenever any of the two DataStream notifies about property modification I can reuse the same code.</p>
<pre><code>const selectedItems$ = this.grid.onSelect.pipe(.... this gives me the selected object);
const updatedItem$ = this.fetchData.onUpdate.pipe(.....this gives me the updated object);

displayItem$(selection$, updatedItem$) {
   (..here i want to get notified whenever there is change in).subscribe(item =&gt; {
       this.displayLatest(item)
   })
}
</code></pre>
<p>selectedItem$ and updatedItem$ can return same object with different property values when the already selected item is modified.</p>
<p>This is the first time I am working on RxJs and bit confused about this part. I searched in RxJS operators list (like concat, merge, combine) but most of the working examples are for different data structures. Also is there any other better way to achieve this?</p>
","2467136","","","","","2021-03-09 15:04:46","how to handle same value from multiple datastreams in Angular RxJs","<javascript><angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"66554068","1","66562801","","2021-03-09 20:09:54","","0","48","<p><strong>OBJECTIVE:</strong> I want to <strong>GET</strong> a single object and/or a range of objects from my backend service by passing in user inputs as HTTP params using RxJS.
For Example, I am using declarative RxJS and so I have two Subjects (Action streams) to grab the input from the user when they hit Submit. I want to pass those Subjects values, <strong>as HTTP params</strong>, into my http request in order to get either the specified bay object, or a range of bays.
The first Subject/UserInput will always be mandatory, whereas the second Subject/UserInput will be optional. So if someone enters 4 for the first input, and then nothing for the second input. The backend will accept both inputs as 4 and 'null' because nothing was put in. If that's the case, return the bay that has a bay Number of 4. If there is a second input like 6, return a range of bays from 4 -&gt; 6, if they exist.</p>
<p><strong>The Issue:</strong> How do I pass those two Subjects as http params using declarative RxJS?</p>
<p>Here are my two subjects and their method, as well as my attempt at the HTTP request in my <code>bay-service.ts</code> file.</p>
<pre><code>  private bayStartSelectedSubject = new Subject&lt;number&gt;();
  baySelectedAction$ = this.bayStartSelectedSubject.asObservable();

  private bayEndSelectedSubject = new Subject&lt;number&gt;();
  bayEndSelectedAction$ = this.bayEndSelectedSubject.asObservable();

  selectedBayChanged(selectedBayStartNumber: number, selectedBayEndNumber?: number): void {
    this.bayStartSelectedSubject.next(selectedBayStartNumber);
    this.bayEndSelectedSubject.next(selectedBayEndNumber);
  }

  private HandlingUnitResponseUrlSecondary = 'http://localhost:8080/sbtemplate/readBayInventory';


bayOrBays$ = combineLatest([
    this.baySelectedAction$,
    this.bayEndSelectedAction$
  ])
    .pipe(
      map(([bayStart, bayEnd]) =&gt; {
        mergeMap(() =&gt; this.http.get&lt;HuResponse&gt;(`${this.HandlingUnitResponseUrlSecondary}/COS/${bayStart}/${bayEnd}`))
      })
    );
</code></pre>
<p>Here is where I grab the user inputs in my <code>bay-page.ts</code> file, and call their method to emit the user inputs value:</p>
<pre><code>onSubmit() {
    this.bayService.selectedBayChanged(this.bayForm.get('bayStart').value, this.bayForm.get('bayEnd').value);
    if(!this.invalidBay) {
      this.bayDoesNotExistError = true;
      this.selectedBay = this.bayForm.get('bayStart').value;
      this.vibration.vibrate(500);
      console.log('Vibrating for 3 second...')
    } else {
      this.navCtrl.navigateForward([`/results/`]);
    }
</code></pre>
<p>I know the code doesn't look great, but I can't find any information on this. Thanks for the help!</p>
<p><strong>Also</strong> Here is the backend API that I am trying to hit:</p>
<pre><code>@RequestMapping(value=&quot;/readBayInventory/{centerId}/{beginBayId}/{endBayId}&quot;, method = GET)
    public ResponseEntity&lt;HUResponse&gt; readBayInventory(@PathVariable String centerId, @PathVariable int beginBayId, @PathVariable(required = false) int endBayId) {
</code></pre>
","11569843","","11569843","","2021-03-09 20:43:46","2021-03-10 10:24:55","How to pass two Subjects/Action streams as HTTP Params in a GET request to return a single object/Array of objects in Angular using RxJS?","<angular><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","6","","","","CC BY-SA 4.0"
"66615681","1","","","2021-03-13 16:10:10","","0","154","<h2>Intro</h2>
<p>I am trying to use RxJS in a TypeScript project but I am seeing strange behavior when using the <code>switchMap</code> and <code>mergeMap</code> pipeline operator where the type is being lost somewhere. I have separate TypeScript project (react app) that includes the same version of RxJS and I am not seeing this behavior. Both projects are being evaluated by the same version of TypeScript (4.2.3). I am at a loss as to what might be wrong, any help would be appreciated.</p>
<h2>Context</h2>
<p>Here is a simple test case that I created to demonstrate the problem. Copying this code into my other project compiles and works as expected. As you can see I have one source stream or type <code>Observable&lt;number&gt;</code> and when I map this into a <code>string</code> the output type is <code>Observable&lt;string&gt;</code>, which is correct. However, when I apply a <code>switchMap</code> and return a stream of a string, the type emitted by the call to pipe is <code>Observable&lt;unknown&gt;</code></p>
<p><a href=""https://i.stack.imgur.com/Skhgu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Skhgu.png"" alt=""Sample code"" /></a></p>
<p>Here you can see the IDE highlighting the type mismatch</p>
<p><a href=""https://i.stack.imgur.com/8eq5i.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8eq5i.png"" alt=""TypeScript error"" /></a></p>
<p>I examining the type of the <code>switchMap</code> operation itself shows that the type is being inferred correctly going in, but the type is lost in the return value. I have inspected the <code>OperatorFunction</code> type and I don't see anything wrong (and is no different in the other project)</p>
<p><a href=""https://i.stack.imgur.com/bv68z.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bv68z.png"" alt=""switchMap type"" /></a></p>
<h2>Config</h2>
<p>Given the problem above and the fact that this works in another project, makes me think that the problem is in my TypeScript config. After half an hour of switching things on and off I have seem glimmers of hope but nothing has worked. Here is my <code>tsconfig.json</code> and I am using TypeScript 4.2.3:</p>
<pre class=""lang-json prettyprint-override""><code>{
  &quot;compilerOptions&quot;: {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */

    /* Basic Options */
    // &quot;incremental&quot;: true,                         /* Enable incremental compilation */
    &quot;target&quot;: &quot;es5&quot;,                                /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */
    &quot;module&quot;: &quot;commonjs&quot;,                           /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */
    // &quot;lib&quot;: [],                                   /* Specify library files to be included in the compilation. */
    // &quot;allowJs&quot;: true,                             /* Allow javascript files to be compiled. */
    // &quot;checkJs&quot;: true,                             /* Report errors in .js files. */
    // &quot;jsx&quot;: &quot;preserve&quot;,                           /* Specify JSX code generation: 'preserve', 'react-native', 'react', 'react-jsx' or 'react-jsxdev'. */
     &quot;declaration&quot;: true,                         /* Generates corresponding '.d.ts' file. */
     &quot;declarationMap&quot;: true,                      /* Generates a sourcemap for each corresponding '.d.ts' file. */
     &quot;sourceMap&quot;: true,                           /* Generates corresponding '.map' file. */
    // &quot;outFile&quot;: &quot;./&quot;,                             /* Concatenate and emit output to single file. */
     &quot;outDir&quot;: &quot;./lib&quot;,                              /* Redirect output structure to the directory. */
    // &quot;rootDir&quot;: &quot;./&quot;,                             /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */
    // &quot;composite&quot;: true,                           /* Enable project compilation */
    // &quot;tsBuildInfoFile&quot;: &quot;./&quot;,                     /* Specify file to store incremental compilation information */
    // &quot;removeComments&quot;: true,                      /* Do not emit comments to output. */
    // &quot;noEmit&quot;: true,                              /* Do not emit outputs. */
    // &quot;importHelpers&quot;: true,                       /* Import emit helpers from 'tslib'. */
    // &quot;downlevelIteration&quot;: true,                  /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
    // &quot;isolatedModules&quot;: true,                     /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */

    /* Strict Type-Checking Options */
    &quot;strict&quot;: true,                                 /* Enable all strict type-checking options. */
     &quot;noImplicitAny&quot;: true,                       /* Raise error on expressions and declarations with an implied 'any' type. */
     &quot;strictNullChecks&quot;: true,                    /* Enable strict null checks. */
     &quot;strictFunctionTypes&quot;: true,                 /* Enable strict checking of function types. */
     &quot;strictBindCallApply&quot;: true,                 /* Enable strict 'bind', 'call', and 'apply' methods on functions. */
     &quot;strictPropertyInitialization&quot;: true,        /* Enable strict checking of property initialization in classes. */
     &quot;noImplicitThis&quot;: true,                      /* Raise error on 'this' expressions with an implied 'any' type. */
     &quot;alwaysStrict&quot;: true,                        /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */

    /* Additional Checks */
     &quot;noUnusedLocals&quot;: true,                      /* Report errors on unused locals. */
     &quot;noUnusedParameters&quot;: true,                  /* Report errors on unused parameters. */
     &quot;noImplicitReturns&quot;: true,                   /* Report error when not all code paths in function return a value. */
     &quot;noFallthroughCasesInSwitch&quot;: true,          /* Report errors for fallthrough cases in switch statement. */
//     &quot;noUncheckedIndexedAccess&quot;: false,            /* Include 'undefined' in index signature results */
//     &quot;noPropertyAccessFromIndexSignature&quot;: false,  /* Require undeclared properties from index signatures to use element accesses. */

    /* Module Resolution Options */
    // &quot;moduleResolution&quot;: &quot;node&quot;,                  /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    // &quot;baseUrl&quot;: &quot;./&quot;,                             /* Base directory to resolve non-absolute module names. */
    // &quot;paths&quot;: {},                                 /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    // &quot;rootDirs&quot;: [],                              /* List of root folders whose combined content represents the structure of the project at runtime. */
    // &quot;typeRoots&quot;: [],                             /* List of folders to include type definitions from. */
    // &quot;types&quot;: [],                                 /* Type declaration files to be included in compilation. */
    // &quot;allowSyntheticDefaultImports&quot;: true,        /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
    &quot;esModuleInterop&quot;: true,                        /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */
    // &quot;preserveSymlinks&quot;: true,                    /* Do not resolve the real path of symlinks. */
    // &quot;allowUmdGlobalAccess&quot;: true,                /* Allow accessing UMD globals from modules. */

    /* Source Map Options */
    // &quot;sourceRoot&quot;: &quot;&quot;,                            /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // &quot;mapRoot&quot;: &quot;&quot;,                               /* Specify the location where debugger should locate map files instead of generated locations. */
    // &quot;inlineSourceMap&quot;: true,                     /* Emit a single file with source maps instead of having a separate file. */
    // &quot;inlineSources&quot;: true,                       /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */

    /* Experimental Options */
     &quot;experimentalDecorators&quot;: true,              /* Enables experimental support for ES7 decorators. */
     &quot;emitDecoratorMetadata&quot;: true,               /* Enables experimental support for emitting type metadata for decorators. */

    /* Advanced Options */
    &quot;skipLibCheck&quot;: true,                           /* Skip type checking of declaration files. */
    &quot;forceConsistentCasingInFileNames&quot;: true,        /* Disallow inconsistently-cased references to the same file. */
    &quot;lib&quot;: [
      &quot;dom&quot;,
      &quot;es5&quot;,
      &quot;scripthost&quot;,
      &quot;es2015.collection&quot;,
      &quot;es2015.promise&quot;
    ]
  },
  &quot;include&quot;: [&quot;./src/**/*.ts&quot;],
  &quot;exclude&quot;: [&quot;./node_modules/**/*&quot;]
}
</code></pre>
<p>and just for completeness, here is the code from the pictures above</p>
<pre class=""lang-js prettyprint-override""><code>import { Observable, of } from &quot;rxjs&quot;;
import { map, switchMap } from &quot;rxjs/operators&quot;;

const source = new Observable&lt;number&gt;();

const switchMapToString: Observable&lt;string&gt; = source.pipe(
    switchMap(n =&gt; of(`${n}`)),
);

const mapToString: Observable&lt;string&gt; = source.pipe(
    map(n =&gt; `${n}`),
);
</code></pre>
","5053124","","","","","2021-03-13 16:10:10","RxJS switchMap/mergeMap resulting in Obserable<unknown>","<typescript><rxjs><tsconfig><rxjs-observables><rxjs-pipeable-operators>","0","7","1","","","CC BY-SA 4.0"
"66646173","1","66646935","","2021-03-15 21:53:11","","0","41","<p>I'm using declarative RxJS to return a response object from my back-end service. I am able to grab the data in my <code>bay-page.ts</code> file and display it in my html. However, I want the data to be displayed in my <code>results-page.ts</code> file. I grab the user inputs using Subjects and pass them in a method in my <code>bay-page.ts</code> file, that will then fire off the HTTP request.</p>
<p><strong>But, how do I grab those results and display them in my <code>results-page.html</code> file?</strong></p>
<p><code>bay-service.ts</code> file:</p>
<pre><code>private bayStartSelectedSubject = new Subject&lt;number&gt;();
  bayStartSelectedAction$ = this.bayStartSelectedSubject.asObservable();

  private bayEndSelectedSubject = new Subject&lt;number&gt;();
  bayEndSelectedAction$ = this.bayEndSelectedSubject.asObservable();


  selectedBayChanged(selectedBayStartNumber: number, selectedBayEndNumber?: number): void {
    this.bayStartSelectedSubject.next(selectedBayStartNumber);
    this.bayEndSelectedSubject.next(selectedBayEndNumber);
  }

  grabHuResponsePOST$ = combineLatest([
    this.bayStartSelectedAction$,
    this.bayEndSelectedAction$
  ])
    .pipe(
      switchMap(([bayStart, bayEnd]) =&gt; {
        if (bayEnd == null || bayEnd &lt;= 0) {
          bayEnd = bayStart;
        }
        let huRequest: HuRequest = {
          &quot;centerId&quot;: &quot;COS&quot;,
          &quot;beginBayId&quot;: bayStart,
          &quot;endBayId&quot;: bayEnd
        }
        const headers = new HttpHeaders({
          'Content-Type': 'application/json'
        });
        let options = {
          headers: headers
        }
        // this.invalidBay.next(true);
        return this.httpClient.post&lt;HuResponse&gt;(this.HandlingUnitResponseUrl, huRequest, options);
      }),
      tap(showDataPlease =&gt; console.log('Bays: ', JSON.stringify(showDataPlease))),
    );
</code></pre>
<p><code>bay-page.ts</code> file:</p>
<pre><code>ngOnInit() {
    this.bayForm = new FormGroup({
      'bayStart': new FormControl(null, [Validators.required]),
      'bayEnd': new FormControl(null, [Validators.required])
    });
    this.bayService.invalidBay$.subscribe(
      value =&gt; {
        console.log(value);
        this.invalidBay = value;
      }
    );
    this.bayService.grabHuResponsePOST$.subscribe(p =&gt; {

    });
  }

  onSubmit() {
    this.bayService.selectedBayChanged(this.bayForm.get('bayStart').value, this.bayForm.get('bayEnd').value);
    this.navCtrl.navigateForward([`/results/`]);
  }
</code></pre>
<p><code>results-page.ts</code> file:</p>
<pre><code>bayOrBays$ = this.bayService.grabHuResponsePOST$
    .pipe(
      map(response =&gt; response.bays),
      catchError(err =&gt; {
        this.errorMessageSubject.next(err);
        return EMPTY;
      }),
      tap(showDataPlease =&gt; console.log('Bays: ', JSON.stringify(showDataPlease)))
    );
</code></pre>
<p><code>results-page.html</code> file:</p>
<pre><code>&lt;ion-card *ngFor=&quot;let bay of bayOrBays$ | async; index as i&quot;
                    class=&quot;ion-no-margin&quot;&gt;
            &lt;ion-card-header&gt;
              &lt;ion-card-title&gt;Bay {{ bay.bayCode }}&lt;/ion-card-title&gt;
              &lt;ion-card-subtitle&gt;{{ bay.shipments.length }} Shipments&lt;/ion-card-subtitle&gt;
            &lt;/ion-card-header&gt;
          &lt;/ion-card&gt;
</code></pre>
<p>I am obviously missing something with a subscription because this doesn't work in my <code>results-page.ts</code> file, but it DOES work, if I put it in my <code>bay-page.ts</code> file.</p>
","11569843","","","","","2021-03-15 23:12:10","Using declarative RxJS, is there a way to pass Observable data to child component from parent component?","<angular><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","7","","","","CC BY-SA 4.0"
"66690603","1","66691323","","2021-03-18 11:54:42","","0","30","<p>Hi I am having an angular2 project.
I have two rxjs expressions. how can i combine both of them . the following is my rxjs expressions.</p>
<pre><code>this.trafficTypeControl.valueChanges
      .pipe(
        filter(x =&gt; x !== null),
        switchMap(x =&gt; {
          if (x === TrafficType.TRANSACTIONAL || x === TrafficType.BULK_SEND) {
            this.campaignControl.setValue(null);
            this.flightControl.setValue(null);
            this.campaigns = [];
            this.flights = [];
          }
          return x;
        })
      ).subscribe();



this.trafficTypeControl.valueChanges
  .pipe(
    filter(x =&gt; x !== null),
    switchMap(x =&gt; {
      if (x === TrafficType.CAMPAIGN) {
        return this.campaignsService.getUnpaginatedCampaignsWithinRange({
          accountIds: this.currentUser.account
            ? this.currentUser.account.id
            : null,
          campaignStatuses: this.campaignStatusIds,
          rangeStartDate: this.rangeControl.value[0].toISOString(),
          rangeEndDate: this.rangeControl.value[1].toISOString()
        });
      }
    }),
    tap(campaigns =&gt; {
      console.log(&quot;TrafficType.CAMPAIGN :&quot; + JSON.stringify(campaigns));
      this.campaigns = campaigns;
    })
  ).subscribe();
</code></pre>
<p>i would like to have a single expression that incorporate both logic.</p>
<p>appreciate if you can help
thank you</p>
","14820140","","14820140","","2021-03-18 12:43:47","2021-03-18 12:55:00","How can i combine my RXJS expressions that represents two different logic?","<rxjs><rxjs5><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"66696284","1","66696907","","2021-03-18 17:37:07","","1","83","<p>I'm trying to use below simplified version of my http request pipeline to ensure that if my response  does not have the required data in res.myCondition to utlize repeatWhen and make another call, but I'm clearly not utilizing repeatWhen the way it's meant to be. (angular 8/ rxjs 6.5)</p>
<p>Intention is for the first call to come into the map, where I check the returned data, if the data is there I'll return it to the subscriber back in my component, but if myCondition is missing from res I'd like to repeat the api call a pre-determined number of times stored in reties.</p>
<p>any thoughts on where I'm going wrong with my repeatWhen implementation?</p>
<p>method1:</p>
<pre><code>return this.http.get()
   .pipe(map(res =&gt; res.myCondition ? res : null),
        repeatWhen(res =&gt; retries-- &gt; 0 ? of(res) : res), 
        catchError((error: HttpErrorResponse) =&gt; (error))
</code></pre>
","10768827","","","","","2021-03-20 20:01:12","Utilizing rxjs repeatWhen in http request pipe in order to repeat the request if desired response is not returned","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"66896536","1","66903638","","2021-03-31 23:25:32","","0","46","<p>I am trying to setup a poller using expand but the behavior is not what I want</p>
<p><a href=""https://stackblitz.com/edit/rxjs-finalize-unsubscribe-6xy2yb?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-finalize-unsubscribe-6xy2yb?file=index.ts</a></p>
<p>checkExistence produces a random boolean - With the expand, I expect a recursive delayed call of the same checkExistence function producing random booleans every 5 seconds (after one initial call).</p>
<p>I also expect the stop to kick in 30seconds and stop the polling and 5 seconds later resume the random boolean stream. Any pointers will help.</p>
<p>Instead I get the same boolean value getting printed; also after the start is triggered, it produces batches of booleans together.</p>
","2789284","","","","","2021-04-01 11:25:29","Polling using expand in rxjs gives an unexpected result","<rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"66922012","1","66922310","","2021-04-02 16:01:27","","0","39","<p>I don't understand how to solve an issue in the following scenario:</p>
<pre><code>getPosts(): Observable&lt;Post[]&gt; {
    return this.http.get&lt;Post[]&gt;(this.postsUrl).pipe(
      tap(() =&gt; console.log('fetched posts')),
      catchError(this.handleError&lt;Post[]&gt;('getPosts', []))
    );
  }
</code></pre>
<p>.......</p>
<pre><code>export const mapYearWeek = (post: Post): Post =&gt; {
  post.time = `
  ${moment(parseInt(post.time)).year()}
  -${moment(parseInt(post.time)).week()}
  `;
  return post;
};
</code></pre>
<p>.........</p>
<pre><code>ngOnInit(): void {
    this.postService
      .getPosts()
      .pipe(
        mergeMap(res =&gt; res.map(mapYearWeek(post: Post))),  
        tap((res) =&gt; console.log(res)),
        groupBy((post: Post) =&gt; post.time),
        mergeMap((group) =&gt; group.pipe(toArray())),
        tap((res) =&gt; console.log(res))
      )
      .subscribe();
  }
</code></pre>
<p>I'm getting error with mapYearweek func:</p>
<blockquote>
<p>Argument of type 'Post' is not assignable to parameter of type
'(value: Post, index: number, array: Post[]) =&gt; unknown'.   Type
'Post' provides no match for the signature '(value: Post, index:
number, array: Post[]): unknown'.ts(2345)</p>
</blockquote>
","12566163","","","","","2021-04-02 16:25:57","RxJs map operator","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"67012221","1","67097062","","2021-04-08 21:38:21","","-1","46","<p>Hi I am having an angular 5 project and rxjs library used. i have code snippet below. I would like to rewrite in a better way.</p>
<pre><code> export class AccountDetailsComponent implements OnInit {
     ngOnInit() {
        this.route.paramMap
          .pipe(
            tap(paramMap =&gt; { this.id = paramMap.get('id') }),
            switchMap(paramMap =&gt;
              forkJoin(
                this.accountsService.get(paramMap.get('id')).pipe(
                  catchError(error =&gt; {
                    this.notFoundService.checkStatus(error);
                    return _throw(error);
                  })
                ),
                this.accountsService.getAccountUsers(paramMap.get('id'))
                )
              )
            )
          .subscribe(
            ([account, users]) =&gt; {
              this.isLoading = false;
              this.account = account;
    
             let hasTransactionalReportingEnabled : boolean = this.account.features.some( feature =&gt; feature.code === FeatureCode.TRANSACTIONAL_REPORTING);
    
              if(hasTransactionalReportingEnabled) {
    
                this.accountsService.getAccountEsmeGroup(this.id).subscribe(
                   (accountEsmeGroup) =&gt; {
                     this.accountEsmeGroup = accountEsmeGroup;
                   }
                );
              }
              this.users = users;
            },
            () =&gt; {
              this.isLoading = false;
            }
          );
      }
    }
</code></pre>
<p>In the account-details.component.ts class have an ngOnInit() method. Its two http service calls using  rxjs forkJoin function namely, this.accountsService.get(paramMap.get('id')) &amp; this.accountsService.getAccountUsers(paramMap.get('id')) . Then in the subcribe I am making another call this.accountsService.getAccountEsmeGroup(this.id), only if the variable hasTransactionalReportingEnabled expression is  true. Is there any better way to rewrite the above snippet of code in rxjs. I am not sure it is good idea to make another call in the subscribe method.</p>
<p>appreciate if you can help</p>
<p>thank you</p>
","14820140","","14820140","","2021-04-08 21:54:26","2021-04-14 18:18:22","How to rewrite rxjs code without making calls within the subcribe method?","<angular><rxjs><angular5><rxjs-pipeable-operators>","1","2","1","","","CC BY-SA 4.0"
"67110036","1","67110149","","2021-04-15 14:06:54","","0","31","<p>I am upgrading an app to RxJS from Promises and I am not entirely sure whether I am on the right track.</p>
<p>Case:
Given a ModalComponant that loads in when an HTTP request is sent and destroys when the response is received.
So what I do is as follows</p>
<pre><code>public post(uri: string, body: object, showLoading: boolean = true, params: object = {}): Observable&lt;any&gt; {
if (showLoading) {
  this.toggleModal('open');
}

return this.http.post(
  this.createUrl(uri),
  body,
  this.createOptionsWrapper(params)
)
.pipe(
  this.toggleModal('close'),
  catchError(err =&gt; this.handleError(err))
);
</code></pre>
<p>}</p>
<p><em>toggleModal()</em> accepts 1 parameter and based on that it will open/close the Modal. I understand pipeable Operators must return a OperatorFunction type. What do you reckon what is the most suitable RxJS Operator for the above case where I don't touch the Observable itself I merely want to make it pipeable so it runs in the given sequence? Might be worth creating a custom one myself? Of course the Observable being returned here will be piped again wherever the service is injected.</p>
","9294210","","","","","2021-04-15 14:19:54","RxJS pipe function disregarding observable","<angular><typescript><rxjs><rxjs-pipeable-operators>","3","1","","","","CC BY-SA 4.0"
"67118974","1","67120069","","2021-04-16 04:09:35","","1","75","<p>I have two observable data streams. One retrieves an account, one gets permissions.</p>
<p>What I need to do is check if the current user has the role of admin, or has the role of external and the current account does not have a flag set. But how to do that with rxjs is eluding me.</p>
<p>Here is a stripped down test case to show what I'm trying to do, but because all of the data isn't there when it runs (either the account is null, or the permissions haven't been loaded yet), it errors out.</p>
<p>How can I make this work?</p>
<p>I'm using rxjs6.</p>
<pre class=""lang-js prettyprint-override""><code>export class ViewComponent implements OnInit {
    private account: AdminUser;
    private permissions: Permissions;

    constructor(private _service: AdminUserService,
                private _permissions: PermissionsService,
                private _activatedRoute: ActivatedRoute) {
    }

    canEdit(): boolean {
        let isAdmin = this.permissions.hasRole('Admin');
        return isAdmin || (this._permissions.hasRole('External') &amp;&amp; !this.account.isActiveDirectory);
    }

    ngOnInit() {
        this._permissions
            .getPermissions()
            .subscribe(p =&gt; this.permissions = p);

        this._activatedRoute.params.subscribe(
            params =&gt; {
                    this._service.get(params.id)
                        .pipe(map(account =&gt; this.account = account))
                        .subscribe();
            });
    }
}
</code></pre>
","70235","","","","","2021-04-16 06:49:23","rxjs Observable mixed with pre-resolved data","<angular><rxjs><rxjs6><rxjs-pipeable-operators>","2","3","1","","","CC BY-SA 4.0"
"67139504","1","67159341","","2021-04-17 14:52:23","","3","159","<p>Considering I have the following code:</p>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let Rx = window['rxjs'];
const { of,
    queueScheduler,
    asapScheduler,
    asyncScheduler,
    animationFrameScheduler
} = Rx;
const { observeOn, tap } = Rx.operators;
console.clear();


let source$ = of(1, 2, 3, asapScheduler).pipe(
    tap((v) =&gt; {
        console.log('tap ', v);
    }),
)

source$.subscribe((v) =&gt; {
    console.log('Value ', v);
    Promise.resolve().then(() =&gt; {
        console.log('Microtask value ', v);
    });
});</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.2.1/rxjs.umd.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
<p>Which I use asapScheduler operator.</p>
<p>As per the documentation,</p>
<p>asap will wait for the current synchronously executing code to end and then it will try to execute the given task as fast as possible.</p>
<p>What's the execution order of the above code? How do they work? I would not have expected that the tap3 to print at the last</p>
<p>Below are the output,</p>
<pre><code>tap  1
Value  1  
tap  2    // here why did this not print Microtask value 1 and Microtask value 2 after printing tap1 and value1?
Value  2
Microtask value  1
Microtask value  2
tap  3
Value  3
Microtask value  3
</code></pre>
","4646531","","4646531","","2021-04-18 18:23:22","2021-04-19 09:25:57","Order of execution with rxjs asapscheduler","<rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators><rxjs-marbles>","2","0","","","","CC BY-SA 4.0"
"67297034","1","67297650","","2021-04-28 09:00:06","","0","49","<p>I am having a requirement to make multiple API calls using fork-join we need to make a retry if any one of the API calls after 3seconds and even then the API is failing then we should not go to subscribe. And the retry should also happen for one time retry that's all
For the above requirement, I implemented in the below way:-</p>
<pre><code>const getPosts = this.api
      .get(&quot;/posts/&quot;)
      .pipe(catchError(this.getCatchError));
    const getPostsFaliure = this.api.get(&quot;/postsasdfs/&quot;)
      .pipe(catchError(this.getCatchError));
    ;
    forkJoin(getPosts, getPostsFaliure)
      .pipe(
        retryWhen(err =&gt; {
          err.pipe(
            tap(val =&gt; console.log(`Value ${val} was too high!`)),
            //restart in 6 seconds
            delayWhen(val =&gt; timer(val * 1000))
          );
        })
      )
      .subscribe(res =&gt; console.log(res));
</code></pre>
<p>and getCatcherror is there in this way:-</p>
<pre><code>getCatchError(error) {
    return of(false);
  }
</code></pre>
<p>for the above implementation, I am getting the below result:-</p>
<pre><code>[Array(100),false]
</code></pre>
<p>it's not going into err and retry is also not working for me API call is going only one time and  I need to restrict it going to subscribe until the APIs are passing if at least one is failing I need to go to err part of subscribing. And I am having a strict rule to use retry when from rxjs
How to solve this issue</p>
<p>Stackblitz URL:-<a href=""https://stackblitz.com/edit/angular-api-call-cpr1hk?file=src/app/app.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-api-call-cpr1hk?file=src/app/app.component.ts</a></p>
","13851398","","9406763","","2021-04-29 16:26:35","2021-04-29 16:26:35","Unable to make a retry for API call Getting the success event","<angular><typescript><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","6","","","","CC BY-SA 4.0"
"67379098","1","","","2021-05-04 05:06:31","","-1","27","<p>I am getting dynamic values as array format like this</p>
<pre><code>var sections = [
    { id: &quot;1&quot;, section: &quot;I&quot;, group: &quot;Section1&quot;},
    { id: &quot;2&quot;, section: &quot;I&quot;, group: &quot;Section1&quot;},
    { id: &quot;3&quot;, section: &quot;I&quot;, group: &quot;Section2&quot;},
    { id: &quot;4&quot;, section: &quot;I&quot;, group: &quot;Section2&quot;},
    { id: &quot;5&quot;, section: &quot;II&quot;, group: &quot;Section3&quot;},
    { id: &quot;6&quot;, section: &quot;III&quot;, group: &quot;Section4&quot;},
    { id: &quot;7&quot;, section: &quot;IV&quot;, group: &quot;Section5&quot;}
];
</code></pre>
<p>Output should be in tree structure format like below</p>
<p>I
|--- Section1
|--- Section2</p>
<p>II
|-- Section3</p>
<p>III
|-- Section4</p>
<p>IV
|--- Section5</p>
<p>How to do it, I am getting values from Rest API, I am using Angular 8 version, How can we achieve this filter in javascript/typescript</p>
","14442579","","","","","2021-05-04 06:21:26","Filter data from dynamic array values and bring a structure format as output in angular","<javascript><angular><typescript><rxjs-observables><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"67385195","1","67385288","","2021-05-04 12:55:31","","2","242","<p>I have 2 API calls in a service that each return an Observable, and in my component I have some condition that, if true, I must call both those functions, but I need to wait for the get() call, so that I can execute the post function with arguments returned from the get call. If false, I just want to call the post function with the already defined arguments.</p>
<p>service:</p>
<pre><code>  get(id: string) {
    return this.http.get&lt;any&gt;('get path');
  }

  post(data: data) {
    return this.http.post&lt;any&gt;('post path', {data: data});
  }
</code></pre>
<p>component:</p>
<pre><code>  execute() {
    if (condition) {
      this.service.get(id).subscribe( (res) =&gt;
        // ...
        this.data = res.data;
        post(data).subscribe(() =&gt; // do stuff...);
      );
    } else { post(data).subscribe(() =&gt; // do stuff...); }
   }

</code></pre>
<p>I want to not repeat code for the post call, or if not at all possible, just not use a subscribe() inside another subscribe(). How can I do this? without async await.</p>
<p>Thanks in advance</p>
","15832673","","","","","2021-05-04 13:07:14","rxjs - Angular: How to wait for an Observable function, to call another function that returns an Observable?","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","2","1","","","","CC BY-SA 4.0"
"67506586","1","67508863","","2021-05-12 15:25:42","","0","142","<p>So, I was utilizing shareReplay(1) to cache the array of Items in memory that are returned from an HttpClient GET call.</p>
<pre><code>if (!this.getItems$) {
    this.getItems$ = this.httpClient
            .get&lt;Item[]&gt;(url, options)
            .pipe(shareReplay(1));
}
return this.getItems$;
</code></pre>
<p>I'm doing this because I have many components on the page that need the array of Items and I don't want to make the http call for each one.</p>
<p>I am also creating an Item on the page.  So, after I make a call to the service to call the API which creates the Item in the database and returns it, I would like to add it to the array of Items in memory and alert all the components that are subscribing to the updated array.  So, I tried this:</p>
<pre><code>private items = new BehaviorSubject&lt;Item[]&gt;(null);
</code></pre>
<p>...</p>
<pre><code>if (!this.getItems$) {
this.getItems$ = this.httpClient
    .get&lt;Item[]&gt;(url, options)
    .pipe(
      tap({
        next: (items) =&gt; {
          this.items.next(items);
        },
      })
    )
    .pipe(multicast(() =&gt; this.items));
}
return this.getItems$;
</code></pre>
<p>Then in the method that calls the API:</p>
<pre><code>return this.httpClient.post&lt;Item&gt;(url, item, options).pipe(
      tap({
        next: (item) =&gt; {
          this.items.next(this.items.value.push(item));
        },
      })
    );
</code></pre>
<p>The issue is, that anything that is subscribing to the getItems method, is always returning null.  There are items in the database, so even on the first call, there should be items returned.  There are, as I tested it with the shareReplay(1) and it works.</p>
<p>How can I share utilizing a BehaviorSubject instead of a ReplaySubject?</p>
","787958","","","","","2021-05-12 23:24:53","How to share HttpClient GET with BehaviorSubject?","<angular><rxjs><angular-httpclient><behaviorsubject><rxjs-pipeable-operators>","2","3","","","","CC BY-SA 4.0"
"67526174","1","67526589","","2021-05-13 20:59:01","","1","76","<p>I'm iterating over a object array obtained from a service with 'NgFor'.</p>
<p>At first I updated the object array variable inside subscribe method, and I realize two things.</p>
<pre><code>this._myService.sendRequest(input).subscribe((value: SomethingInterface[]) =&gt; {
    this.objectArray = value.map((v) =&gt; new Something(v))
});
</code></pre>
<p><strong>First</strong>: (advantage) If I do a new request the old value is keeped until I receive a new value.</p>
<p><strong>Second</strong>: (disadvantage) If I do multiples requests, they are put in a queue and each request is made consuming unnecessary bandwidth.</p>
<p>Then I moved to Async pipe, and realize another two things.</p>
<pre><code>this.objectArrayObservable = this._myService.sendRequest(value: SomethingInterface[]).pipe(
    map((value) =&gt; value.map((v) =&gt; new ChartDisplayDOM(v)))
);
</code></pre>
<p><strong>First</strong>: (advantage) If I do multiples requests the old are cancelled, and only the last request is made.</p>
<p><strong>Second</strong>: (disadvantage) While waiting the request to complete, the array is empty...and I don't want to make a loading bar.</p>
<p>Is there a way to take both advantages?</p>
<blockquote>
<p>If I do a new request the old value is keeped until I receive a new value.</p>
</blockquote>
<blockquote>
<p>If I do multiples requests the old are cancelled, and only the last request is made.</p>
</blockquote>
<p>I tried some operators combinations like 'combineLatest' whith two differents Observables but I didn't figure out how to solve it.</p>
","4801171","","","","","2021-05-13 21:48:47","How to keep the last value from observable Async pipe array while waiting for update in Angular 11 / Rxjs","<angular><rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"67584300","1","67588201","","2021-05-18 10:19:18","","0","39","<p>I'm making a stopwatch and when I wanna reset the clock for the second time, it is not changed.
On click at the first time, it sets h: 0, m: 0, s: 0. But when click again, it doesn't set h: 0, m: 0, s: 0 and stopwatch goes ahead.</p>
<pre><code>const events$ = merge(
    fromEvent(startBtn, 'click').pipe(mapTo({count: true})),
    click$.pipe(mapTo({count: false})), 
    fromEvent(resetBtn, 'click').pipe(mapTo({time: {h: 0, m: 0, s: 0}})) // there is reseting
    )
    
const stopWatch$ = events$.pipe(
    startWith({count: false, time: {h: 0, m: 0, s: 0}}), 
    scan((state, curr) =&gt; (Object.assign(Object.assign({}, state), curr)), {}), 
    switchMap((state) =&gt; state.count
    ? interval(1000)
        .pipe(
            tap(_ =&gt; {
                if (state.time.s &gt; 59) {
                    state.time.s = 0
                    state.time.m++
                }
                if (state.time.s &gt; 59) {
                    state.time.s = 0
                    state.time.h++
                }
                const {h, m, s} = state.time
                secondsField.innerHTML = s + 1
                minuitesField.innerHTML = m
                hours.innerHTML = h
                state.time.s++
            }),
        )
    : EMPTY)
stopWatch$.subscribe()
</code></pre>
","14795542","","","","","2021-05-18 15:18:13","Why mapTo changes only one time?","<rxjs><rxjs-observables><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"67606419","1","67606618","","2021-05-19 15:38:50","","0","35","<p>I'm trying to combine two Observables to have few values for the call to service method that accepts two values. But here I have few errors</p>
<ul>
<li><p>Argument of type '([filter, sort]: [string, string]) =&gt; void' is not assignable to parameter of type '(value: [string, string], index: number) =&gt; ObservableInput'.
Type 'void' is not assignable to type 'ObservableInput'.</p>
</li>
<li><p>in console -</p>
<p>You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
at subscribeTo (subscribeTo.js:27)
at innerSubscribe (innerSubscribe.js:71)
at SwitchMapSubscriber._innerSub (switchMap.js:44)
at SwitchMapSubscriber._next (switchMap.js:34)
at SwitchMapSubscriber.next (Subscriber.js:49)
at CombineLatestSubscriber.notifyNext (combineLatest.js:73)
at InnerSubscriber._next (InnerSubscriber.js:11)
at InnerSubscriber.next (Subscriber.js:49)
at BehaviorSubject._subscribe (BehaviorSubject.js:14)
at BehaviorSubject._trySubscribe (Observable.js:42)</p>
</li>
</ul>
<ol>
<li><p>Defining Observables and Subjects.</p>
<pre><code> private openSortQuerySubject: BehaviorSubject&lt;string&gt; = new BehaviorSubject&lt;string&gt;(this.formatSortQuery(this.multiSortMeta));
 public openSortQuery: Observable&lt;string&gt; = this.openSortQuerySubject.asObservable();

 private closedSortQuerySubject: BehaviorSubject&lt;string&gt; = new BehaviorSubject&lt;string&gt;(this.formatSortQuery(this.multiSortMeta));
 public closedSortQuery = this.closedSortQuerySubject.asObservable();
</code></pre>
</li>
<li><p>Combine observables.</p>
<pre><code>   const openQueries$ = combineLatest([this.openFilterQuery, this.openSortQuery]);
   const closedQueries$ = combineLatest([this.closedFilterQuery, this.closedSortQuery]);
</code></pre>
</li>
<li><p>Use merged values in service method.</p>
</li>
</ol>
<pre><code>openQueries$
      .pipe(
        switchMap(([filter, sort]) =&gt; {
          this.alertService
            .listAlerts(filter, sort);
        }),
        tap(v =&gt; console.log(v))
      )
      .subscribe((openAlerts) =&gt; {
        this.openAlertsCount = openAlerts.length;
        this.openAlerts = this.parseAlerts(openAlerts);
      });

    closedQueries$
      .pipe(
        switchMap(([filter, sort]) =&gt; {
          this.alertService
            .listAlerts(filter, sort);
        })
      )
      .subscribe((closedAlerts) =&gt; {
        this.closedAlertsCount = closedAlerts.length;
        this.closedAlerts = this.parseAlerts(closedAlerts);
      });
</code></pre>
","924646","","","","","2021-05-19 15:49:31","undefined when combine combineLatest and switchMap","<rxjs><rxjs-observables><rxjs-pipeable-operators><switchmap><combinelatest>","1","0","","","","CC BY-SA 4.0"
"67955183","1","67955389","","2021-06-13 05:31:46","","1","56","<p>I have the following call to Firebase database. If I want to share the result of the observable, where I'd I put the share really(1) ?</p>
<pre class=""lang-ts prettyprint-override""><code>get userStacks(): Observable&lt;StackModel[]&gt; {
        return this.auth.authState
            .pipe(
                shareReplay(1), ===&gt;&gt;&gt; HERE ?
                switchMap(user =&gt; {
                    if (user) {
                        return this.db
                            .collection&lt;StackModel&gt;('stacks', ref =&gt;
                                ref.where('perm.readers', 'array-contains', user.uid),
                            )
                            .valueChanges()
                            .pipe(shareReplay(1),  ===&gt;&gt;&gt; HERE ?
                                 stackList =&gt;
                                combineLatest([
                                    stackList,
                                    this.dataService.currentNormalOrReverse,
                                    this.idsFilter$,
                                ]).pipe(
                                    shareReplay(1),  ===&gt;&gt;&gt; HERE ?
                                    map(([stacks, normalOrReverse]) =&gt; [
                                        ...StacksService.sortAlphabetical(stacks, normalOrReverse),
                                    ]),
                                ),
                            );
                    }
                    return [];
                }),
            )
            .pipe(shareReplay(1)),  ===&gt;&gt;&gt; HERE?
    }
</code></pre>
<p>I suppose it should be the last operation in the chain, just before I'd subscribe to the observable, therefore it should be the last on here. Is my assumption correct? Thank you.</p>
","2029378","","","","","2021-06-13 06:10:05","Where to put ShareReplay(1) pipe","<google-cloud-firestore><rxjs><observable><angularfire><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"67966213","1","67966399","","2021-06-14 07:20:08","","0","99","<p>For some reason, I'm unable to use <code>shareReplay()</code> inside the <code>pipe()</code> operator in the observable, <code>courses$</code>.</p>
<p>Below is the <code>home.component.ts</code></p>
<pre><code>import {Component, OnInit} from '@angular/core';
import {Course} from &quot;../model/course&quot;;
import { Observable } from 'rxjs';
import {interval, noop, of, timer} from 'rxjs';
import {catchError, delayWhen, map, retryWhen, shareReplay, tap} from 'rxjs/operators';
import { createHttpObservable } from '../common/util';



@Component({
    selector: 'home',
    templateUrl: './home.component.html',
    styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit {
beginnerCourses$: Observable&lt;Course[]&gt;;

advancedCourses$: Observable&lt;Course[]&gt;;


constructor() {

}

ngOnInit() {

    const http$ = createHttpObservable('/api/courses');

    const courses$: Observable&lt;Course[]&gt; = http$
        .pipe(
            tap(() =&gt; console.log('HTTP request')), // tap() operator is used to produce the side effects in our obsevable chain. Whenever we want to update something outside of our observable chain, we use the tap() operator.
            map(res =&gt; Object.values(res['payload'])),
            shareReplay()
        ); // Whenever we want to derive new observables from existing observables, we need to use one of the RxJs operators, the pipe() operator. The pipe() function is what allows us to chain multiple operators in order to produce a new observable.

    this.beginnerCourses$ = courses$
        .pipe(
            map(courses =&gt; courses.filter(course =&gt; course.category == 'BEGINNER'))
        )

    this.advancedCourses$ = courses$
        .pipe(
            map(courses =&gt; courses.filter(course =&gt; course.category == 'ADVANCED'))
        )
</code></pre>
<p>I get this error when I try to run it:</p>
<pre><code>Error: src/app/home/home.component.ts:30:15 - error TS2322: Type 'Observable&lt;unknown[]&gt;' is not assignable to type 'Observable&lt;Course[]&gt;'.
  Type 'unknown[]' is not assignable to type 'Course[]'.
    Type '{}' is missing the following properties from type 'Course': id, description, iconUrl, courseListIcon, and 3 more.
</code></pre>
<p>But whenever I remove the <code>shareReplay()</code> from the <code>pipe()</code> in the <code>courses$</code>, it works. What could be the problem here? I want to be able to use <code>shareReplay()</code> without any errors.</p>
<pre><code>home.component.html
</code></pre>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-css lang-css prettyprint-override""><code>.courses-panel {
    max-width: 400px;
    margin: 0 auto;
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;div class=""courses-panel""&gt;

  &lt;h3&gt;All Courses&lt;/h3&gt;

  &lt;mat-tab-group&gt;

    &lt;mat-tab label=""Beginners""&gt;

      &lt;courses-card-list [courses]=""beginnerCourses$ | async""&gt;
        &lt;!--What ""async"" pipe does is, it's going to subscribe to this observable ""beginnerCourses$"" and it's going to retrieve that data and assign it to the ""[courses]"".--&gt;

      &lt;/courses-card-list&gt;

    &lt;/mat-tab&gt;

    &lt;mat-tab label=""Advanced""&gt;

      &lt;courses-card-list [courses]=""advancedCourses$ | async""&gt;&lt;/courses-card-list&gt;

    &lt;/mat-tab&gt;

  &lt;/mat-tab-group&gt;



&lt;/div&gt;</code></pre>
</div>
</div>
</p>
<p>Above is the HTML and CSS for reference. It's working without any problems when I remove <code>shareReplay()</code>. I'm watching a tutorial that's using the same code as this but it runs without any problem, unlike mine.</p>
","12825619","","","","","2021-06-14 07:34:54","RxJs: Type 'unknown[]' is not assignable to type 'Course[]'","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"68048489","1","68051788","","2021-06-19 15:51:37","","0","32","<p>I'd like to replicate the observable dependency graph for time travel debugging, similar to this example (<a href=""https://youtu.be/HQWnCo_lMJQ?t=74"" rel=""nofollow noreferrer"">https://youtu.be/HQWnCo_lMJQ?t=74</a>).</p>
<p>How can I access the names of the observables and piped operators?  Initial attempts have been so far unsuccessful.</p>
<p>e.g., in <a href=""https://stackblitz.com/edit/j7tvss-adrhxq?devtoolsheight=33&amp;file=index.ts"" rel=""nofollow noreferrer"">this example</a>, tap can access the values, but I haven't found a way to log <code>map</code>, <code>take</code>, and <code>interval</code> at the same time.</p>
<pre class=""lang-js prettyprint-override""><code>import { interval } from 'rxjs';
import { map, take } from 'rxjs/operators';
interval(100)
  .pipe(
    take(3),
    map((e, i) =&gt; i * 2),
    tap(console.log)
  )
  .subscribe({
    next: console.log,
    error: console.error,
    complete: () =&gt; console.log('complete')
  });
</code></pre>
","656259","","","","","2021-06-20 00:42:58","How to log rxjs observable and operator names?","<rxjs><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"68172148","1","68172925","","2021-06-29 03:09:01","","0","34","<p>This question is for learning purposes, not to solve a particular problem (please move it to the appropriate section if necessary).</p>
<p>I'm learning about piping operators in the RxJS library. At this site here (<a href=""https://rxjs.dev/guide/operators"" rel=""nofollow noreferrer"">https://rxjs.dev/guide/operators</a>) it distinguishes between pipeable operators and creator operators.</p>
<p>It defines pipeable operators as follows:</p>
<blockquote>
<p>A Pipeable Operator is a function that takes an Observable as its input and returns another Observable. It is a pure operation: the previous Observable stays unmodified.</p>
</blockquote>
<p>And it defines creator operators as follows:</p>
<blockquote>
<p>Creation Operators are the other kind of operator, which can be called as standalone functions to create a new Observable. For example: of(1, 2, 3) creates an observable that will emit 1, 2, and 3, one right after another.</p>
</blockquote>
<p>But this leaves me wondering: is there such an operator as one that DOES modify the observable it gets as input and returns it as output? I haven't come across anything like that. Is there a reason such an operator doesn't exist? What kind of undesired behavior would result from such an operator?</p>
","9334823","","","","","2021-06-29 05:09:46","Are there RxJS operators that modify the observable?","<rxjs><pipe><rxjs-observables><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"68260536","1","68260785","","2021-07-05 18:14:54","","0","64","<p>In my angular component I have the below properties:</p>
<pre><code>memberInfoLists$: Observable&lt;MemberInfo[]&gt;;
total$: Observable&lt;number&gt;;
memberPhotoUrl: string = environment.memberPhotoUrl;
memberDefaultPhoto: string = environment.defaultPersonPhoto;
</code></pre>
<p>Now in <strong>ngOnInit</strong> function I have called the service to get the observable to fill <strong>memberInfoLists$</strong> property. But before the fill I want to change one of the property value of each object in the collection. Here is my code:</p>
<pre><code>ngOnInit(): void {
        this.memberInfoLists$ = this.service.memberInfoLists$.pipe(map(item =&gt; item.forEach(y =&gt; {
            if (y.MemberPhotoUrl) {
                y.MemberPhotoUrl = this.memberPhotoUrl + y.MemberPhotoUrl;
            }   
            else{
                y.MemberPhotoUrl = this.memberDefaultPhoto;
            }   
            
            if (y.VoterPhotoUrl) {
                y.VoterPhotoUrl = this.memberPhotoUrl + y.VoterPhotoUrl;
            }   
            else{
                y.VoterPhotoUrl = this.memberDefaultPhoto;
            }   

            return item;
        })));
        this.total$ = this.service.total$;
    }
</code></pre>
<p>But it throws the below exceptions:</p>
<blockquote>
<p>src/app/setup-module/pages/member-info-list/member-info.component.ts:69:3</p>
<ul>
<li><p>error TS2322: Type 'Observable' is not assignable to type 'Observable&lt;MemberInfo[]&gt;'.   Type 'void' is not assignable to type
'MemberInfo[]'.</p>
<p>this.memberInfoLists$ =
this.service.memberInfoLists$.pipe(map(item =&gt; item.forEach(y =&gt; {</p>
</li>
</ul>
</blockquote>
<p>Can anyone help me to solve the problem?</p>
","2975931","","2975931","","2021-07-05 18:22:10","2021-07-05 18:44:05","RxJs map operator to change the property value of a collection of objects in angular","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"68288843","1","","","2021-07-07 15:24:54","","0","50","<p>I'm working on Angular project with NgRx and I'm in the following scenario:</p>
<pre><code>   forkJoin({
     sub1: this.getSub1(),
     sub2: this.getSub2()
   }).pipe(takeUntil(this.destroy$));
 }

 getSub1() {
   return this.store.select(select1)
     .subscribe();
 }

 getSub2() {
   return this.store.select(select2)
     .subscribe();
 }
</code></pre>
<p>The question is: Will takeUntil(this.destroy$) affects getSub1 and getSub2?</p>
<p>Many thanks in advance.</p>
","12566163","","","","","2021-07-07 15:24:54","How to unsubscribe the forkJoin subscriptions","<angular><rxjs><ngrx><rxjs-observables><rxjs-pipeable-operators>","0","2","","","","CC BY-SA 4.0"
"68385391","1","68385875","","2021-07-14 21:40:46","","0","28","<p>I am trying to dynamically build an array for linkObjects. Dynamically because I need to read the Ngrx Store and get parameters.
like in the heatmap</p>
<pre class=""lang-js prettyprint-override""><code>public linksObject = [
    {
        name: 'Consumption',
        link: ['../consumption'],
    },
    {
        name: 'Heatmap',
        link: ['../heatmap&amp;res=foo'],
    }
 ];
 
</code></pre>
<p>I have a switchMap that builds out the individual objects, but I need to append it to <code>this.linkObjects</code></p>
<p>the second switchMap is getting an array of roles like ['admin', 'test', 'field_engineer'] and inside getLinkObjects it is building the object:</p>
<p><code>{name: label, link:['..\ ...']}</code></p>
<p><code>pages</code> is just a static list of labels ['consumption', 'heatmap']</p>
<pre><code>    public getLinkObjects(roles: string[]): Observable&lt;any&gt; {
        return from(this.pages).pipe(
            switchMap(
                (page): Observable&lt;ILinksObject&gt; =&gt;
                    from(roles).pipe(
                        map((role) =&gt; ({
                            name: page,
                            link: [`../${page}&amp;role=${role}`],
                        })),
                    ),
            ),
        );
    }
</code></pre>
<pre class=""lang-js prettyprint-override""><code>this.fetchRoles()
    .pipe(
        switchMap((roles: IUserSite[]) =&gt; this.getCurrentRoles(roles)),
        switchMap((role: string[]) =&gt; this.getLinkObjects(role)),
        // concat the objects emitted by switchMap
    )
    .subscribe();
</code></pre>
<p>I tried the following 3 ways, that didn't work:</p>
<ul>
<li>adding a push in the subscribe</li>
<li>adding a tap</li>
</ul>
<pre class=""lang-js prettyprint-override""><code>this.fetchRoles()
    .pipe(
        switchMap((roles: IUserSite[]) =&gt; this.getCurrentRoles(roles)),
        switchMap((role: string[]) =&gt; this.getLinkObjects(role)),
        // concat the objects emitted by switchMap
    )
    .subscribe(this.linkObjects.push);
</code></pre>
<pre class=""lang-js prettyprint-override""><code>this.fetchRoles()
    .pipe(
        switchMap((roles: IUserSite[]) =&gt; this.getCurrentRoles(roles)),
        switchMap((role: string[]) =&gt; this.getLinkObjects(role)),
        tap((role) =&gt; this.linkObjects.push(role))
        // concat the objects emitted by switchMap
    )
    .subscribe();
</code></pre>
<pre><code>        this.fetchRoles()
            .pipe(
                switchMap((roles: IUserSite[]) =&gt; this.getCurrentRoles(roles)),
                switchMap((role: string[]) =&gt; this.getLinkObjects(role)),
                tap(console.log), // this gets printed
                reduce((acc, role) =&gt; acc.concat(role), this.linksObject),
                tap(console.log), // this does not get printed
            )
            .subscribe(console.log);
</code></pre>
<p>I need help to point me in the direction of the correct rxjs operator to use and help troubleshooting the reason as to why those 2 solutions didn't work.</p>
","3861330","","3861330","","2021-07-14 22:50:21","2021-07-14 22:58:06","Collect / Concat objects emitted from switchMap into an array","<angular><rxjs><observable><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"68459361","1","","","2021-07-20 17:52:41","","1","35","<p>I'm trying to refactor the code and meanwhile I found a bug which I wanted to understand.
It's working on local environment but not in QA environment.
Data:</p>
<pre><code>const dataSet: DataSetInterface[] = [
      { id:57, firstProperty:148, secondProperty:1, thirdProperty:10.30 },
      { id:58, firstProperty:149, secondProperty:4, thirdProperty:20.60 },
      { id:59, firstProperty:148, secondProperty:4, thirdProperty:22.20 }
    ];
</code></pre>
<p>Old method which is not working:</p>
<pre><code>private groupAndSumUp(dataSet: DataSetInterface[]) {
  Rx.Observable.from(dataSet)
      .groupBy(x =&gt; x.secondProperty)
      .flatMap(group =&gt; group.toArray())
      .map(g =&gt; {
        return {
          id: g[0].secondProperty,
          secondProperty: g[0].thirdProperty,
          budgetDays: _.sumBy(g, 'budgetDays'), 
        }
      })
      .toArray()    
      .subscribe(d =&gt; this.budgetDays = d); 
}
</code></pre>
<p>Locally it's working but on QA environment I'm getting an error:</p>
<pre><code>ERROR TypeError: e.map is not a function
</code></pre>
<p>I have no idea why. Maybe that's because GroupedObservables are not completed before first method toArray() ?</p>
<p>I will try to refactor in but it's not tested yet and before that I want to understand why it's not working correctly in QA.
Example how I want to refactor it:</p>
<pre><code>    const example = source.pipe(
      groupBy(x =&gt; x.id),
      mergeMap(group =&gt; group.pipe(toArray())),
      map(g =&gt; {
        return {
          id: g[0].secondProperty,
          secondProperty: g[0].thirdProperty,
          budgetDays: _.sumBy(g, 'budgetDays'), 
        }
      }),
      toArray()
    );
</code></pre>
<p><strong>Update</strong></p>
<p>I've tried refactored version:</p>
<pre><code>private groupAndSumUp(pricingLevels: SingleContractWorkPackagePricingLevel[]) {
  from(pricingLevels).pipe(
    groupBy(x =&gt; x.masterAgreementPricingLevelId),
    mergeMap(group =&gt; group.pipe(toArray())),
    map(g =&gt; {
      return {
        id: g[0].masterAgreementPricingLevelId,
        masterAgreementPricingLevel: g[0].budgetDays,
        budgetDays: _.sumBy(g, 'budgetDays'), 
      }
    }),
    toArray()
  ).subscribe(d =&gt; this.budgetDays = d); 
}
</code></pre>
<p>And now I have and error:
ERROR TypeError: Vn.a.from(...).groupBy is not a function</p>
<p>My imports:</p>
<pre><code>import { from } from 'rxjs';
import { groupBy, map, mergeMap, toArray } from 'rxjs/operators';
import * as _ from 'lodash';
import { Observable } from 'rxjs/Observable';
</code></pre>
<p>Rxjs version:</p>
<pre><code>&quot;rxjs&quot;: &quot;^6.6.7&quot;,
&quot;rxjs-compat&quot;: &quot;^6.6.7&quot;,
</code></pre>
<p>My error has changes:</p>
<pre><code>ERROR TypeError: Cannot set property 'checked' of undefined
    at 7-es2015.23db786fc6208d7e819e.js:1
    at Array.forEach (&lt;anonymous&gt;)
    at t.setSelectedDays (7-es2015.23db786fc6208d7e819e.js:1)
    at t.ngOnChanges (7-es2015.23db786fc6208d7e819e.js:1)
    at t.We (main-es2015.1967bf97e6c77b08a1d5.js:1)
    at Ut (main-es2015.1967bf97e6c77b08a1d5.js:1)
    at $t (main-es2015.1967bf97e6c77b08a1d5.js:1)
    at Vt (main-es2015.1967bf97e6c77b08a1d5.js:1)
    at Zi (main-es2015.1967bf97e6c77b08a1d5.js:1)
    at main-es2015.1967bf97e6c77b08a1d5.js:1
</code></pre>
","6701254","","6701254","","2021-07-22 11:39:49","2021-07-22 11:39:49","GroupBy transformation operator is working only on local environment","<angular><typescript><rxjs><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"68482552","1","","","2021-07-22 09:37:06","","1","22","<p>Is there something like flatTap in RxJS? If no, why? Would it be &quot;bad practice&quot;?</p>
<p>Suppose you want to tap something and automatically subscribe (an) inner observable(s) - similar as with flatMap -  but you want to keep the same object for further piping. Then I see myself sometimes do something like this:</p>
<pre><code>outerObservable.pipe(
  flatMap(v =&gt; {
    return createInnerObservables(v).pipe(
      toArray(),
      map(() =&gt; v),
    );
  }),
  map(v =&gt; do something with v),
)...
</code></pre>
<p>With a flatTap operator this could simplify to:</p>
<pre><code>outerObservable.pipe(
  flatTap(v =&gt; createInnerObservables(v)),
  map(v =&gt; do something with v),
)...
</code></pre>
","15567795","","","","","2021-07-22 14:32:10","Is there something like flatTap in RxJS","<rxjs><rxjs6><rxjs-pipeable-operators>","1","3","","","","CC BY-SA 4.0"
"68595397","1","","","2021-07-30 18:05:43","","-1","45","<p>I have added the below rxjs and the first call made is a Post. Once the takeUntil(OnDestroy) is added, the post API returns a cancelled option as below</p>
<p><a href=""https://i.stack.imgur.com/AvyZ0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/AvyZ0.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.stack.imgur.com/wyr03.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wyr03.png"" alt=""enter image description here"" /></a></p>
<p>[<img src=""https://i.stack.imgur.com/yGdbh.png"" alt=""enter image description here"" /><a href=""https://i.stack.imgur.com/yGdbh.png"" rel=""nofollow noreferrer"">3</a></p>
<p>If the takeuntil line is removed the post returns a successfule status - 204.
Why does this problem occur ?</p>
","14534955","","14534955","","2021-08-03 12:49:54","2021-08-03 12:49:54","RXJS call with takeUntil(OnDestroy) returns cancelled from the post API","<angular><rxjs><rxjs-pipeable-operators>","1","4","","","","CC BY-SA 4.0"
"68625711","1","68626062","","2021-08-02 17:25:22","","1","55","<p>I have 3 filter values (select boxes basically). When there is a selection change, I want to fire a combined API call along with other filter values selected previously (using BehaviorSubject for each filter). Unfortunately, in the 'combineLatest' I can see only 1 filter value. Other values from other subjects are disappearing. Please help me understand where am i going wrong:</p>
<p><strong>Service:</strong></p>
<pre class=""lang-ts prettyprint-override""><code>private typeFilterSubject = new BehaviorSubject('');
typeFilterObs$ = this.typeFilterSubject.asObservable();

private priceFilterSubject = new BehaviorSubject('');
priceFilterObs$ = this.priceFilterSubject.asObservable();

private brandFilterSubject = new BehaviorSubject('');
brandFilterObs$ = this.brandFilterSubject.asObservable();

updateTypeFilter(filter) {
  this.typeFilterSubject.next(filter);
}
updatePriceFilter(filter) {
  this.priceFilterSubject.next(filter);
}
updateBrandFilter(filter) {
  this.brandFilterSubject.next(filter);
}

getData$ = combineLatest([
  this.typeFilterObs$,
  this.priceFilterObs$,
  this.brandFilterObs$
]).pipe(
  switchMap(([type, price,brand]) =&gt; {
    console.log([type, price, brand]);

    // here i am getting [&quot;electronics&quot;,&quot;&quot;,&quot;&quot;]
    // or [14, &quot;&quot;, &quot;&quot;] or [&quot;IKEA&quot;, &quot;&quot;, &quot;&quot;]
    // instead of [&quot;electronics&quot;, 14, &quot;IKEA&quot;]

    return this._http.get&lt;IProduct[]&gt;(
      `http://localhost:3000/products?type=${type}&amp;price=${price}&amp;brand=${brand}`
    );
  })
);
</code></pre>
<p><strong>Component -1 : from where 'next' is fired</strong></p>
<pre class=""lang-ts prettyprint-override""><code>onTypeChanged() {
  this._appService.updateTypeFilter(this.typeSelected) //&quot;Electronics&quot;
}

onBrandChanged() {
  this._appService.updateTypeFilter(this.brandSelected) //&quot;IKEA&quot;
} 

onPriceChanged() {
  this._appService.updateTypeFilter(this.priceSlected) //14
}
</code></pre>
<p><strong>component 2 - from where I am subscribing to the combined data</strong></p>
<pre class=""lang-ts prettyprint-override""><code>this.getData = this._appService.getData$
</code></pre>
","6456247","","17447","","2021-08-02 17:35:56","2021-08-02 17:57:46","RxJS combineLatest: Unable to merge with latest values in Angular 12","<angular><rxjs><angular2-observables><rxjs-observables><rxjs-pipeable-operators>","1","2","1","","","CC BY-SA 4.0"
"68629353","1","","","2021-08-03 01:22:37","","3","47","<p>When using Dependency injection in Angular I often need to subscribe to an observable that I haven't yet created!</p>
<p>I often end up using something like this:</p>
<pre><code>// create behavior subject OF Observable&lt;number&gt;
const subject = new BehaviorSubject&lt;Observable&lt;number&gt;&gt;(EMPTY);

// subscribe to it, using flatMap such as to 'unwrap' the observable stream
const unwrappedSubject = subject.pipe(flatMap((x: number) =&gt; x));
unwrappedSubject.subscribe(s =&gt; console.log(s));

// now actually create the observable stream
const tim = timer(1000, 1000);

// set it into the subject
subject.next(tim);
</code></pre>
<p>This uses <code>flatMap</code> to 'unwrap' the observable contained in the subject.</p>
<p>This works fine, but frankly it always feels 'icky'.</p>
<p>What I really want is something like this, where the consumer of the subject treats the instance of the <code>Subject</code> as <code>Observable&lt;number&gt;</code> without having to pipe it every usage.</p>
<pre><code>const subject = new UnwrappingBehaviorSubject&lt;number&gt;(EMPTY);
subject.subscribe((x: number) =&gt; console.log(x));

// this could use 'next', but that doesn't feel quite right
subject.setSource(timer(1000, 1000));
</code></pre>
<p>I'm aware that I could subscribe to the timer and <a href=""https://stackoverflow.com/questions/48880671/pipe-rxjs-observable-to-existing-subject"">hook it up directly to the subject</a>, but I also want to avoid an explicit subscribe call because that complicates the responsibility of unsubscribing.</p>
<pre><code>timer(1000, 1000).subscribe(subject);
</code></pre>
<p>Is there a nice way to achieve this?</p>
<p>The <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/internal/Subject.ts"" rel=""nofollow noreferrer"">Subject.ts</a> and <a href=""https://github.com/ReactiveX/rxjs/blob/master/src/internal/BehaviorSubject.ts"" rel=""nofollow noreferrer"">BehaviorSubject.ts</a> source files get more complicated than I expected. I'm scared I'll end up with horrible memory leaks if I try to fork it.</p>
","16940","","","","","2021-08-03 18:56:08","Subject-like RxJS Observable that transparently pipes through flatMap","<rxjs><rxjs-pipeable-operators>","1","8","","","","CC BY-SA 4.0"
"68666100","1","","","2021-08-05 11:53:11","","0","42","<p>I have set of emitted values (stock market transactions) with time and price and vol like this...</p>
<pre><code>TIME      PRICE    VOL
13:45:01  12       1
13:45:01  12       1
13:45:01  12       10
13:45:01  13       1
13:45:01  13       3
13:45:02  13       1
</code></pre>
<p>And I just want to merge values within the same second and same value and accumulate VOL so the resulting observable will be emitting such values based on source above:</p>
<pre><code>TIME      PRICE  ACCUMULATED VOL
13:45:01  12     12
13:45:01  13     4
13:45:02  13     1
</code></pre>
<p>This is some kind of grouping and then reducing. I'm reading documentation but can't figure out which operators to use...</p>
<p>Can somebody help?</p>
","752775","","1244884","","2021-08-08 16:46:33","2021-08-08 16:46:33","RxJS — Group items by multiple conditions and process each group","<rxjs><rxjs-pipeable-operators>","3","3","","","","CC BY-SA 4.0"
"68668377","1","68673272","","2021-08-05 14:20:47","","1","30","<p>In RSJS how to buffer values so buffer will be flushed when next element is different from previous. If elements by some comparator are the same then it should buffer them until next change is detected...</p>
<p>Suppose I have such elements...</p>
<pre><code>{ t: 10, price:12 },
{ t: 10, price:13 },
{ t: 10, price:14 },
{ t: 11, price:12 },
{ t: 11, price:13 },
{ t: 10, price:14 },
{ t: 10, price:15 },
</code></pre>
<p>The elements are the same if <code>t</code> property value is the same as previous element <code>t</code> value so at the output I just want such buffers...</p>
<pre><code>[ { t: 10, price:12 }, { t: 10, price:13}, { t: 10, price:14} ],
[ { t: 11, price:12}, { t: 11, price:13} ],
[ { t: 10, price:14 }, { t: 10, price:15 } ]
</code></pre>
<p>So in the result I have two elements emited (two buffers each containing the same objects ).</p>
<p>I was trying to use <code>bufferWhen</code> or just <code>buffer</code> but I don't know how to specify <code>closingNotifier</code> in this case because this need to be dependent on elements that are approaching. Anyone can help?</p>
","752775","","","","","2021-08-05 20:42:25","Buffer elements based on its contents with comparer function","<rxjs><rxjs-pipeable-operators>","1","0","1","","","CC BY-SA 4.0"
"68932089","1","","","2021-08-26 03:20:25","","2","54","<p>Based on searchCriteria collected from a form, I have a method that return observable of talents.</p>
<pre><code>getTalents(searchCriteria) {
        return this._allUsers$.pipe(
            tap((talents) =&gt; console.log(talents)),
            map((talents: any) =&gt; {
                let filtered = talents.filter(
                    (t) =&gt;
                        (t.userType === 'talent' || t.userType === 'both') &amp;&amp;
                        this.matchOccupationOrSkill(
                            searchCriteria.occupation,
                            t.occupation,
                            t.skills
                        )
                );
                if (searchCriteria.loggedInUserId) {
                    filtered = filtered.filter(
                        (t) =&gt; t.id !== searchCriteria.loggedInUserId
                    );
                }
                return filtered;
            })
        );
    }
</code></pre>
<p>where _allUsers$ is a shared observable,</p>
<pre><code>this._allUsers$ = firestore.collection&lt;any&gt;('users').valueChanges().pipe(share());
</code></pre>
<p>I am calling getTalents inside ngOnInit method of a route component TalentSearchResult.</p>
<pre><code>ngOnInit(): void {
    this.subs.add(
        this.route.queryParams.subscribe(params =&gt; {
            if (params.action==='homesearch' || params.action==='jobsearch'){
                this.criteria = {
                    occupation:params.occupation,
                    industry:params.industry,
                    loggedInUserId:params.loggedInUserId,
                }
                this.dataService.getTalents(this.criteria).pipe(take(1)).subscribe(talents =&gt; {
                    this.count = talents.length;
                    if (this.count &gt;0){
                       this.Talents = talents.sort((p1,p2)=&gt; p2.createdate-p1.createdate);
                    }
                })
            }
        })
    )
  }
</code></pre>
<p>Search works for the first time, then when I go back (using brower back button) and search with a new criteria, it routed correctly to the TalentSearchResult component, however, stale list is being returned. I debugged and found that line 3 in the first code section above, i.e. tap((talents) =&gt; console.log(talents)) already logs in the stale value, even before the pipe/map/filter is executed !
Please advice</p>
","1126248","","","","","2021-08-30 05:39:10","Angular rxjs data not updating correctly when using share , map & filter","<javascript><angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"68986671","1","","","2021-08-30 15:34:15","","0","37","<p>I've written a function to combine two firestore collection observables and it's working great, however it's running the map function 7 times for just one result. Am I doing something wrong here, or is there a way to reduce the amount of processing being done?</p>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>return combineLatest(
    [
      this.approvedToppings$,
      this.myPendingToppings$
    ],
  ).pipe(
    map(([approved, pending], index) =&gt; {
      console.log(index);
      //console.log(pending);
      let toppingDocs = approved.concat(pending);
      //console.log(toppingDocs);
      let toppings: Topping[] = [];
      toppingDocs.forEach((toppingDoc) =&gt; {
        toppings.push(this.convertToppingDocToTopping(toppingDoc));
      });
      return toppings as Topping[];
    })
  );
}</code></pre>
</div>
</div>
</p>
<p>The console.log at the top of the map runs 7 times for every update, and that doesn't make any sense to me.
Subscribing to each of the input observables shows one result each, and subscribing to the output observable also shows one combined output.</p>
","4363576","","","","","2021-08-31 15:18:59","RXJS combineLatest running pipe 7 times for one emit","<typescript><rxjs><observable><rxjs-observables><rxjs-pipeable-operators>","2","5","","","","CC BY-SA 4.0"
"69005547","1","69009479","","2021-08-31 21:35:23","","0","38","<p>In my service class I'm firing post request like this</p>
<pre><code>// my-service.service.ts
sendRequest(
    param: string
  ): Observable&lt;HttpResponse&lt;string&gt;&gt; {
    return this.http.post&lt;HttpResponse&lt;string&gt;&gt;(&quot;&quot;, {
      param
    }).pipe(
      retry(3),
    )
}
</code></pre>
<p>Thus the component is subscribing to the returned <code>Observable</code> by</p>
<pre><code>// my-component.ts
this.myService.sendRequest(
      &quot;&quot;
    ).subscribe(
      res =&gt; {
        console.log(res)
      },
      (err: HttpErrorResponse) =&gt; {
        console.log(err.message)
      }
)
</code></pre>
<p>As you notice I'm doing post requests to <code>&quot;&quot;</code> that is converted into <code>http://localhost:4200</code> that doesn't exist, so every post request will result in a <code>Cannot POST /</code> response (404).</p>
<p>I'm not getting why by adding a delay at</p>
<pre><code>this.myService.sendRequest(
      &quot;&quot;
    ).pipe(delay(10000)).subscribe(
      res =&gt; {
        console.log(res)
      },
      (err: HttpErrorResponse) =&gt; {
        console.log(err.message)
      }
)
</code></pre>
<p>will cause the error response to ignore it and print on the console as long as the request completes thus ignoring it.</p>
","9780816","","","","","2021-09-01 07:29:35","Http post request ignoring piped delay","<angular><typescript><rxjs><delay><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"69195470","1","","","2021-09-15 14:56:52","","0","13","<p>I have some code where I have an observable that will do different things in different pipes. Something like this wherein each pipe may have different filters to do different things to the various other observables:</p>
<pre class=""lang-js prettyprint-override""><code>subject$.pipe().subscribe(another$);
subject$.pipe().subscribe(another2$);
subject$.pipe().subscribe(another3$);
</code></pre>
<p>Each &quot;another&quot; relies on the prior one such that I wouldn't want <code>another2$</code> getting values until <code>another$</code> was done. This worked great for me while all the pipes had <code>map</code> in them.</p>
<p>Is there a way to put things in order as it was, without arbitrarily adding concatMap to each pipe?</p>
","511501","","","","","2021-09-15 15:03:19","Can I have map and conatMap pipes run on same timer in rxjs?","<rxjs><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"