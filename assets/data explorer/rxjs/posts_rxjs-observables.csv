Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"39494058","1","40231605","","2016-09-14 15:14:44","","867","481123","<p>I'm looking into Angular RxJs patterns and I don't understand the difference between a <code>BehaviorSubject</code> and an <code>Observable</code>.</p>

<p>From my understanding, a <code>BehaviorSubject</code> is a value that can change over time (can be subscribed to and subscribers can receive updated results). This seems to be the exact same purpose of an <code>Observable</code>.  </p>

<p>When would you use an <code>Observable</code> vs a <code>BehaviorSubject</code>? Are there benefits to using a <code>BehaviorSubject</code> over an <code>Observable</code> or vice versa?</p>
","6620551","","5377805","","2020-02-26 10:38:08","2021-03-23 17:33:44","BehaviorSubject vs Observable?","<angular><rxjs><behaviorsubject><rxjs-observables>","11","1","311","","","CC BY-SA 3.0"
"56702200","1","","","2019-06-21 11:04:10","","4","5455","<p>There are many ways to handle multiple subscriptions efficiently in a component, I have 2 ways here and wanted to know which is more efficient and why??</p>
<h1>Method 1: Using Array</h1>
<p>Step 1: creating Array</p>
<pre><code>private subscriptionArray: Subscription[];
</code></pre>
<p>Step 2: Adding subscriptions to the array</p>
<pre><code>this.subscriptionArray.push(this._storeManagementHttp.createStore(newStore).subscribe(resp =&gt; {
  this._toast.success('New store created');
}));
</code></pre>
<p>Step 3: iterating each subscription and unsubscribing</p>
<pre><code>this.subscriptionArray.forEach(subs =&gt; subs.unsubscribe());
</code></pre>
<h1>Method 2</h1>
<p>Step 1: creating a new subscription</p>
<pre><code>private subscriptions = new Subscription();
</code></pre>
<p>Step 2: Adding subscriptions</p>
<pre><code>this.subscriptions.add(this._storeManagementHttp.createStore(newStore).subscribe(resp =&gt; {
  this._toast.success('New store created');
  this._router.navigate(['/store-management']);
}));
</code></pre>
<p>Step3: Clearing subscription</p>
<pre><code>this.subscriptions.unsubscribe();
</code></pre>
","6715606","","6715606","","2020-12-15 13:15:24","2020-12-15 13:15:24","Angular better way to clear subscriptions","<angular><rxjs><observable><rxjs-subscriptions><rxjs-observables>","4","3","2","","","CC BY-SA 4.0"
"57110578","1","","","2019-07-19 10:34:15","","1","1166","<p>I'm writing a nav component for an Angular app.  I've got the following code.  I want to avoid the multiple subscription anti-pattern.  I am struggling with the RxJs syntax, and which way to go (forkJoin, mergeMap, etc).</p>

<p>How can I refactor these, to remove the subscribe within the subscribe.</p>

<p>Here's what I have, which currently works, but has a subscribe within a subscribe:</p>

<pre><code>@Component({
  selector: 'ehrcc-nav',
  templateUrl: './nav.component.html',
  styleUrls: ['./nav.component.css']
})
export class NavComponent implements OnInit {

  applicationName: string = 'AppName';
  userDisplayName: string = '';
  isAuthorizedUser: boolean = false;
  isAdminUser: boolean = false;

  groupsList: MemberGroup[] = [];

  constructor(private userService:UserService,
    private auditService: UserAuditService,
    private router: Router) { }

  ngOnInit() {

    this.getDisplayName();

    this.userService.getGroupMembershipsForUser().subscribe(members =&gt;{
      this.groupsList = members;
      for (let g of this.groupsList){
        if (g.id === this.userService.usersGroupId){
          this.isAuthorizedUser = true;
          this.router.navigate(['/workItem']);
        }
        if (g.id === this.userService.adminGroupId){
          this.isAdminUser = true;
        }
      }
      this.logUserInfo();   &lt;---- ANTI-PATTERN
     });

  }

  getDisplayName(){
    this.userService.getSignedInAzureADUser().subscribe(
      (user) =&gt; this.userDisplayName = user.displayName,
      (error: any) =&gt; {
        return console.log(' Error: ' + JSON.stringify(&lt;any&gt;error));
    });
  }

  logUserInfo(){
    var audit = new UserAudit();
    audit.Application = this.applicationName;
    audit.Environment = ""UI"";
    audit.EventType= ""Authorization"";
    audit.UserId = this.userDisplayName;
    audit.Details = ` User Is Authorized: ${this.isAuthorizedUser}, User Is Admin: ${this.isAdminUser}`;

    this.auditService.logUserInfo(audit)
    .subscribe({ 
      next: (id)=&gt; console.log('Id created: '+ id),
      error: (error: any) =&gt; console.log(' Error: ' + JSON.stringify(&lt;any&gt;error) )
    });
  }
}

</code></pre>
","430620","","6225838","","2019-09-25 15:57:18","2019-09-25 15:57:18","RxJs operators avoid multiple subscriptions, with loop","<angular><typescript><rxjs><rxjs-observables>","2","8","1","","","CC BY-SA 4.0"
"57196538","1","","","2019-07-25 07:29:53","","0","40","<p>Hi guys I try to solve one bug. After click on button is timeinput sometimes empty. When I use delay() all is ok. But without I have empty input when I create new visitor. </p>

<pre><code>export const visitListStartFetchAfterChange: Epic = (action$, store) =&gt;
  action$
    .ofType(
      'VR.FILTER_BAR.PICK_DATES',
      'VR.FILTER_BAR.PICK_LOCATION',
      'VR.FILTER_BAR.PICK_STATUS_TAB',
      'VR.VISIT.DELETE.SUCCESS',
      'VR.FILTER_BAR.PICK_VISITOR',
      'VR.FILTER_BAR.CLEAR_VISITOR',
    )

    // .delay(2000)
    .filter(() =&gt; isFilterBarInitialized(pathToVrFilterBar(store.getState())))
    .mapTo(visitListFetch());
</code></pre>

<p><a href=""https://i.stack.imgur.com/GaoQl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GaoQl.png"" alt=""Without delay()""></a></p>

<p><a href=""https://i.stack.imgur.com/ms36c.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ms36c.png"" alt=""With delay""></a></p>
","10255663","","","","","2019-07-25 08:04:05","Probably race conditions","<reactjs><react-redux><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"57204874","1","57218451","","2019-07-25 14:53:29","","3","756","<h3>Simply put</h3>

<p>Given an existing Observable (which has not completed yet), is there a way to retrieve associated subscribers (functions passed to subscribe) to make them subscribe to another Observable instead?</p>

<h3>Context</h3>

<p>A service in my application helps creating <em>SeverEvent</em> connections, returning  a <em>ConnectableObservable</em> to proxy connection and allow multicasting using <em>publish</em> operator. The service keeps track of existing connections via an internal store :</p>

<pre class=""lang-js prettyprint-override""><code>store: {[key: string]: ConnectionTracker};

// …

interface ConnectionTracker {
    url: string;
    eventSource: EventSource;
    observable: rx.ConnectableObservable&lt;any&gt;;
    subscription: rx.Subscription;
    observer: rx.Observer&lt;any&gt;;
    data?: any; // Arbitrary data
}
</code></pre>

<p>Upon connection creation, if an associated tracker already exists (identity is made using the connection's endpoint), the service should:</p>

<ul>
<li>ok <s>Close existing tracker's <em>ServerEvent</em> connection</s></li>
<li>ok <s>Open a new <em>SerevrEvent</em> connection (hence a new ConnectableObservable)</s>  </li>
<li>Replace existing tracker's Observable with the fresh observable <strong>but make existing subscribers now subscribe to the new Observable instead</strong></li>
</ul>

<p>Here is the code part which creates <em>ConnectionTracker</em>s</p>

<pre class=""lang-js prettyprint-override""><code>/**
* Create/Update a ServerEvent connection tracker
*/
createTracker&lt;T&gt;(endpoint: string, queryString: string = null): ConnectionTracker
{
    let fullUri = endpoint + (queryString ? `?${queryString}` : '')
        , tracker = this.findTrackerByEndpoint(endpoint) || {
            observable: null,
            fullUri: fullUri,
            eventSource: null,
            observer: null,
            subscription: null
        }
    ;

    // Tracker exists
    if (tracker.observable !== null) {
        // If fullUri hasn't changed, use the tracker as is
        if (tracker.fullUri === fullUri) {
            return tracker;
        }

        // At this point, we know ""fullUri"" has changed, the tracker's
        // connection should be replaced with a fresh one

// ⇒ TODO
// ⇒ Gather old tracker.observable's subscribers/subscriptions to make
//   them subscribe to the new Observable instead (created down below)

        // Terminate previous connection and clean related resouces
        tracker.observer.complete();
        tracker.eventSource.close();
    }

    tracker.eventSource = new EventSource(&lt;any&gt;fullUri, {withCredentials: true});
    tracker.observable = rx.Observable.create((observer: rx.Observer&lt;T&gt;) =&gt; {
            // Executed once
            tracker.eventSource.onmessage = e =&gt; observer.next(JSON.parse(e.data));
            tracker.eventSource.onerror = e =&gt; observer.error(e);
            // Keep track of the observer
            tracker.observer = observer;
        })
        // Transform Observable into a ConnectableObservable for multicast
        .publish()
    ;

    // Start emitting right away and also keep a reference to 
    // proxy subscription for later disposal
    tracker.subscription = tracker.observable.connect();

    return tracker;
}
</code></pre>

<p>Thank you.</p>
","1463336","","","","","2019-08-22 18:33:35","Retrieve Observable subscribers and make them subscribe to another Observable","<rxjs><rxjs-observables>","2","2","1","","","CC BY-SA 4.0"
"57224210","1","57224358","","2019-07-26 16:51:15","","0","60","<p>I have two methods that make api calls and return observables.</p>

<pre><code>private method1(): Observable&lt;Home&gt; {
  return homeService.call.get();
}

private method2(): Observable&lt;User&gt; {
  return userService.call.get();
}
</code></pre>

<p>Then I have the following two methods:</p>

<pre><code>private method3(): void {
  this.method1().subscribe();
  this.method2().subscribe();
}
</code></pre>

<p>and one last one</p>

<pre><code>private method4(): void {
 // does things
 this.method3();
}
</code></pre>

<p>I want the <code>method4</code> to wait for the <code>method3</code> to finish all is requests in order to proceed, but I have no idea how to achieve it in angular 8. Any tips?</p>
","2421208","","","","","2019-07-26 17:04:01","Awaiting for two methods that return observables in angular","<angular><rxjs><angular8><rxjs-observables>","1","4","","","","CC BY-SA 4.0"
"57299849","1","","","2019-07-31 23:03:09","","0","98","<p>I have a function that gets called inside Angular HttpClient catchError. I want to debounce the call to the function <strong>without using Lodash</strong>.
Cannot use <strong>debounceTime</strong> here since the function is not a subject. 
Is there a ES5/ES6 equivalent?</p>

<pre><code>this.http.get(`api/test`)
  .pipe(
    catchError((err) =&gt; {
      alertUser(err); // Option 1 - debounce here 
      return throwError(err);
    }),
  );
</code></pre>

<pre class=""lang-js prettyprint-override""><code>alertUser(err) {
  alert(err.text); // Option 2 - debounce here
}
</code></pre>
","1546005","","","","","2019-07-31 23:26:06","How to debounce a plain function call without ""lodash"" inside Angular httpClient errorCatch","<javascript><angular><rxjs><angular-httpclient><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"57304357","1","57304595","","2019-08-01 07:59:52","","0","100","<p>So, I am using ngrx store for getting data. Once I select the property I want from the store, after then I subscribed it to get observable stream.
My data contains array of object. So in this array of objects, I have to do some modifications in some properties of each objects.</p>

<p>So for that I converted my array of objects into sequential observable by using 'from()' operator of rxjs library and then assign this into new Observable object. With this new Observable object, I applied map function for doing modification and at the end again returned a  new Observable object.
Till this step everything is working fine.
Problem occurs, when I am subscribing to this new modified observable object it is emitting values sequentially not the whole array of objects.
But I want modified array of objects.</p>

<pre><code>this.statusObj = this.store.select(s =&gt; s.userStore.data);
this.statusObj.subscribe(rslt =&gt; {
    this.usrArr = rslt;
})

this.newstatusObj = from(this.usrArr);
this.newstatusObj2 = this.newstatusObj
    .pipe(map(() =&gt; {
        //////some modifications
        return
    }))

this.newstatusObj2.subscribe(val =&gt; {
    console.log(val);  //this line is emitting sequential values..but i want array of objects
})
</code></pre>
","8553943","","2829204","","2019-08-01 08:08:42","2019-08-01 08:13:29","How to convert sequentially emitted data to a single array","<angular><rxjs><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"57494077","1","57494149","","2019-08-14 11:46:58","","1","3505","<p>I'm pretty new to Angular and my question may seem basic but some guidance would be appreciated. I am currently writing an app to teach myself some real development skills. In my app I have an Angular Component that imports a service that I wrote that provides data.</p>
<p>This is my component</p>
<pre class=""lang-js prettyprint-override""><code>@Component({
  selector: 'music-instrument-list',
  templateUrl: './instrument-report.component.html',
  styleUrls: ['./instrument-report.component.css']
})
export class InstrumentReportComponent implements OnInit, OnDestroy {
    
    constructor(public apiService: ApiService) {}
    public availableInstruments: any[];

    ngOnInit() {
        this.apiService.getInstruments().subscribe((result) =&gt; {
            this.availableInstruments = result;
        });
    }

    ngOnDestroy() {
    // how do I unsubscribe?
    }
}
</code></pre>
<p>This is pretty simple but should I try to add <code>this.apiService.getInstruments.unsubscribe()</code> to the <code>ngOnDestroy</code> block I get the error that  P<strong>roperty 'unsubscribe' does not exist on type =&gt; Observable'</strong>. I even considered add <code>.unsubscribe()</code> after the <code>.subscribe()</code> like chaining but this just makes my page hang. I get no error either. Can someone please tell me how to best unsubscribe? Do I need to assign the api call to a variable and then use .unsubscribe() on the varable name in the <code>ngOnDestroy</code> block</p>
","11124340","","7665955","","2020-12-13 12:40:21","2020-12-15 14:16:44","How to unsubscribe from observable created by an Angular Service","<angular><angular-observable><rxjs-observables>","4","0","1","2019-08-14 11:53:16","","CC BY-SA 4.0"
"57516681","1","57516754","","2019-08-15 21:54:50","","0","28","<p>I have a function which returns an object. Instead of returning the object synchronously, can I have it returned inside an observable which can be later resolved using callbacks (similar to an http call). </p>

<p><strong>Caller Function:</strong></p>

<pre><code>getResource() {
  this.someService.getData().subscribe((data) =&gt; { 
      this.playWithData(data);
    }, (error) {                                   
         console.log(error); 
    });
}
</code></pre>

<p><strong>Called Fn</strong> </p>

<pre><code>getData() {
  return data; //required to return observable/subscriber object
}
</code></pre>

<p>can you let know if this is possible and how to create and return an observable just like how http call would return one ?</p>
","4049008","","5383945","","2019-08-15 22:09:09","2019-08-15 22:13:36","wrapper observable event on top of http call","<angular><rxjs><angular-httpclient><rxjs-observables><rxjs-subscriptions>","1","0","","","","CC BY-SA 4.0"
"57642895","1","57651105","","2019-08-25 02:56:35","","0","42","<p>I have spent hours trying different ways to get this Observable to work in ionic / angular. I have tried different setups and interfaces to plugin to Observable which has properties which are strings. I have tried plugging in JSON as an interface. I simply need to do a GET to an https server with extra parameters. I keep getting errors stating that essentially the returned http cannot properly be typed to the observable defined in getGP. 
error is <a href=""https://i.stack.imgur.com/ygxai.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ygxai.png"" alt=""enter image description here""></a>
When removing the subscribe I get an almost identical error when JSON isnt used as an interface. A simple GET/POST is easy to do in vanilla and angular is driving me nuts. I also need to save the response in a variable and inject the data into another module. I have looked through the rxjs docs and just at a loss. Help would be appreciated.
I am running the latest angular and the latest ionic framework.</p>

<pre><code>import { HttpClient, HttpHeaders } from '@angular/common/http';

getGP(): Observable&lt;JSON&gt; {
    this.httpOptions = {
        headers: new HttpHeaders({
            'Content-Type': 'application/json',
            'token': 'token',
            'mtype': 'g',
        })
    }

    return this.http.get&lt;JSON&gt;(this.base_path + '/pathtoserver', this.httpOptions).subscribe(res =&gt; console.log(res))

}
</code></pre>
","11915510","","","","","2019-08-26 02:25:55","sending get with attached observable with angular and ionic framework","<angular><ionic-framework><rxjs><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"57684539","1","57703905","","2019-08-28 03:10:09","","0","1341","<p>I have an api which responses like this and I am using rxjs observables</p>

<pre><code>[{
  ""error"": ""error_1"",
  ""types"": [
     {
       ""type"": ""new_type""
     },
     {
       ""type"": ""old_type""
     }
  ],
  ""date"": ""2019-08-29""
}]
</code></pre>

<p>I need to transform it into a new json format so i can get the response format i wanted.</p>

<p>I have tried pipe(map()) but i get error that Type '<code>Observable&lt;void&gt;</code>' is not assignable to type '<code>Observable&lt;Error[]&gt;</code>'</p>

<p>My Model</p>

<pre><code>export interface Data {
    error: string,
    types: Types[],
    date: string
}

interface Types {
    type: string
}
</code></pre>

<p>My Service.ts</p>

<pre><code>getError(): Observable&lt;Data[]&gt; {
    return this.http.get&lt;Data[]&gt;(url);
  }
</code></pre>

<p>This is what i tried so far and i deleted the code which produces error
My Component.ts</p>

<pre><code>getUserErrors(user): Observable&lt;Data[]&gt; {
    return this.getData.getError()
      .pipe(map((x) =&gt; x.filter(one =&gt; one.error !== null)))
}
</code></pre>

<p>Here is the observable output i need</p>

<pre><code>[{
  ""new_error"": ""error_1"",
  ""type_1"": ""new_type"",
  ""date"": ""2019-08-29""
}]
</code></pre>

<p>Thank you for those who will help</p>
","8194808","","571407","","2019-08-29 05:47:50","2019-08-29 06:05:14","Angular 7 Transform Observable response to a new observable object","<angular><typescript><rxjs><observable><rxjs-observables>","1","4","0","","","CC BY-SA 4.0"
"57807343","1","","","2019-09-05 14:08:37","","0","56","<p>I have been working on another question here and the helper has gone a little quiet and I need to get a solution on this pretty quickly. <a href=""https://stackoverflow.com/questions/57803978/how-to-remove-duplicate-records-from-ngfor-loop-in-angular/57804357#57804357"">See Here For More Information</a></p>

<p>I have implemented the new code and find that the array is returning 'false' to the browser: </p>

<p><a href=""https://i.stack.imgur.com/m4jSW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/m4jSW.png"" alt=""enter image description here""></a></p>

<p>I have mapped from the get request and then try bind commissions$ to the click-cards.component.html. This should then filter out any duplicate records and render them into groups using lodash.</p>

<p><strong>Edits: based on feedback, but the result still seems to be the same</strong></p>

<p><strong>click-cards.component.ts</strong></p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { Commission } from '../commission';
import { AnalyticsService } from '../analytics.service';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import * as _ from 'lodash';

@Component({
  selector: 'app-click-cards',
  templateUrl: './click-cards.component.html',
  styleUrls: ['./click-cards.component.scss']
})
export class ClickCardsComponent implements OnInit {

  commissions$: Observable&lt;any&gt;;

  constructor(private analyticsService: AnalyticsService) {}

  ngOnInit() {
    this.getCommissions();
  }

  getCommissions(){
    this.commissions$ = this.analyticsService.getAllCommissionData().pipe(
      map((commissions: Commission[]) =&gt; {
        if (commissions !== undefined &amp;&amp; commissions !== null) {
          return _.uniqBy(commissions, 'url');
        }
      }),
      map((commissions: Commission[]) =&gt; {
        commissions = _.groupBy(commissions, commission =&gt; commission.page_type);
        return commissions;
      })
    )
  }
}
</code></pre>

<p>I can't seem to find a way to get commissions$ to bind to the .html file: </p>

<p><strong>click-cards.html</strong></p>

<pre><code>&lt;ng-container *ngIf=""commissions$ | async as commissions""&gt;
  &lt;ng-container *ngFor=""let page_type of ['home', 'article','statistics', 'products']""&gt;
    &lt;h4&gt;{{ page_type | titlecase }}&lt;/h4&gt;
    &lt;p *ngIf=""!commissions[page_type]""&gt;No {{ page_type }} Commissions Logged Yet&lt;/p&gt;
    &lt;ul *ngFor=""let card of commissions[page_type]""&gt;
      &lt;app-click-card [card]=""card""&gt;&lt;/app-click-card&gt;
    &lt;/ul&gt;
  &lt;/ng-container&gt;
&lt;/ng-container&gt;
</code></pre>

<p>Does anyone know what I am doing wrong here? I don't usually work with Observables, so I normally subscribe to the service REST method and it works. So I am a little new to this process.</p>
","9885143","","9885143","","2019-09-05 14:35:46","2019-09-05 14:35:46","Observable<any> Is not binding Angular 6","<html><angular><typescript><rxjs-observables>","1","3","1","","","CC BY-SA 4.0"
"57810500","1","","","2019-09-05 17:34:00","","4","6281","<p>I have a data service that triggers http calls periodically and when required by other services. Now, this services work asynchronously so it may happen that the data service is requested to trigger an http call while a previous one hasn't yet finished.</p>

<p>I was wondering how I could use rxjs to check if there's an undergoing call when I need to make an http call </p>

<p>Data Service:</p>

<pre><code>constructor(private http: HttpClient){}

// if this gets called while another hasn't returned, wait for it and then trigger the next http call
public request(method, url, options): Observable&lt;any&gt;{
    return this.http.request(method, url, options);
}
</code></pre>

<p>Service A:</p>

<pre><code>public syncA(){
    setTimeout(() =&gt; {
       this.dataService.request('GET', 'someUrl', someOptions).subscribe((response) =&gt; {
        console.log('periodic call returns ', response});
    }, 45000);
}
</code></pre>

<p>Service B:</p>

<pre><code>public doB(): Observable&lt;any&gt;{
 return this.dataService.request('GET', 'someUrl', someOptions)
}
</code></pre>

<p>The situation would be when service B invokes doB while syncA has triggered a request and hasn't yet finished.</p>
","2975069","","","","","2019-09-06 16:03:09","Angular 7 Wait for http network call to finish before triggering next one","<angular><typescript><rxjs><rxjs-observables>","2","3","","","","CC BY-SA 4.0"
"57893010","1","57916796","","2019-09-11 16:05:58","","0","806","<p>I'm writing unit tests for one of my Angular component methods which assigns a property the response value from a service call and calls another method. </p>

<p>I have my service stubbed with response data and I subscribe to it inside my test with the expect statements inside the subscription but it keeps showing the value of the property as being an empty array. I've confirmed the ""response"" in the test below contains the mock data but cannot get the component property ""resultSet"" to show as assigned a value. The spy for the ""toggleSearchForm()"" method never appears to be called either.</p>

<p>The method being tested:
<strong>search.component.ts</strong></p>

<pre><code>submitSearchCriteria() {
    this.searchService.searchRequest(this.myForm.value)
        .pipe(take(1))
        .subscribe(response =&gt; {
            this.resultSet = response;
            this.toggleSearchForm();
        });
}
</code></pre>

<p>The failing test:
<strong>search.component.spec.ts</strong></p>

<pre><code>it('should assign resultSet to response data and trigger toggle', fakeAsync(() =&gt; {
    const spy = spyOn(component, 'toggleSearchForm');
    component.myForm.controls['field1'].setValue('some search query');
    component.myForm.controls['field2'].setValue('something that narrows it down more');

    searchServiceStub.searchRequest(component.myForm.value)
        .subscribe(response =&gt; {
            expect(component.resultSet).toContain(response);
            expect(spy).toHaveBeenCalled();
            expect(spy.calls.count()).toBe(1);
        });

    tick();
}))
</code></pre>

<p>The service stub:
<strong>search-service.stub.ts</strong></p>

<pre><code>...
const searchResults = require('./test-data/search-results.json');

searchRequest(searchCriteria) {
    if (!searchCriteria) {
        return of([])
    }
    return of(searchResults);
}
</code></pre>

<p>I expect resultSet to contain the stub response and the spy to have been called but the test fails with the following error messages:</p>

<pre><code>Expected [  ] to contain [ Object({ thingName: 'thing i was searching for', thingId: 1234 }) ].
</code></pre>

<p>and</p>

<pre><code>Error: Expected spy toggleSearchForm to have been called.
</code></pre>
","2019974","","","","","2019-09-13 03:03:07","Angular Unit Test: How to cover activity inside service stub method subscriptions","<angular><jasmine><subscribe><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"57918914","1","","","2019-09-13 07:12:38","","-1","31","<p>First one returns an array of objects . Every object has a unique user id which I need in order to call the second service.</p>

<pre><code>this._vendorService.getAllPickupLoc().subscribe(val =&gt; {
  val.forEach(element =&gt; {
    this.finalObject = element;
    this._vendorService.getVendorUserInfo(element.id).subscribe(res =&gt; {
      this.finalObject[""userInfo""] = res;
      this.finalArray.push(this.finalObject);
    });
  });
});
</code></pre>

<p>While it works fine, there are two drawbacks to the code above. 
1. It’s starting to look like callback hell. 
2. I’d have to handle the disposal of every subscription by myself.</p>
","11543970","","11543970","","2019-09-13 07:20:37","2019-09-13 08:30:58","i’m having problems nesting two services","<angular><callback><rxjs><angular2-observables><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"58000869","1","58003345","","2019-09-18 21:20:31","","0","55","<p>I am using 3 endpoints for my application, 1 of the endpoints depends on other of the endpoint's response, which is a list, then I need to use each item of the list in order to use the other endpoint, let's call them <code>epA</code>, <code>epB</code> and <code>epC</code>, <code>epA</code> returns a list and then i use this list on <code>epB</code>, something like <code>epA.Foreach( x =&gt; epB(x))</code> and I am trying to combine <code>epB</code> and <code>epC</code> into one combined list, since both share similar fields.</p>
<p>My problem is, I am too new using angular and observables, I don't know if there is a way to combine these epB and epC results (without mentioning that currently, I subscribe to the observables and assign its values to other objects I need)...If someone could give me a hand it would be greatly appreciated. Sorry if this is too messy, I have little experience posting here and coding in angular.</p>
<p>here's some code I currently have... it is a bit ugly but it does the job</p>
<h2>code</h2>
<pre><code>this._serverRequests.epA(this._Token).subscribe(x =&gt; {
    this.servers = x;
    x.forEach(server =&gt; 
      this._serverRequests.epB(server)
      .subscribe(info =&gt; {
         this.serverInfo = info;
         this.GridModel.data = info['States'];
         this.GridModel.data.forEach(se =&gt; {
             se.Start = this.formatValuesPipe.transform(se.Start, 'grid');
         });
         this.GridModel.data.map( o =&gt; {
            o.ServerUrl = server;
         });
       })
     );
},
   error =&gt; this.errMsg = &lt;any&gt;error
);

this._serverRequests.epC(this._Token).subscribe(lic =&gt; {
   this.licensesList = lic;
   this.licensesModel.data = this.licensesList.LicenseUsageList;
   this.licensesModel.data.forEach(li =&gt; {
      li.AcquisitionTime = this.formatValuesPipe.transform(li.AcquisitionTime, 'grid'); 
   });
});
</code></pre>
<p><strong>I also tried forkjoin, but since epA returns a list, I don't know how to call each item inside of the forkjoin</strong></p>
","12059007","","-1","","2020-06-20 09:12:55","2019-09-19 03:36:00","Wait for an observable's value (as a list) to call another observable using each member from the list?","<angular><rxjs><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"58014367","1","","","2019-09-19 15:25:24","","-4","434","<p>I am working with Angular and WordPress rest API. Everything is going fine. But I have a little confusion with the behavior of the following code.</p>

<pre><code>getpost(){
    return this.http.get('someURL');
}
</code></pre>

<p>The above function is residing in a service. When I try to subscribe to the returned observable, I get an error.
But the code below is working fine.</p>

<pre><code>getpost(){
    let someVAR = this.http.get('someURL');
    return someVAR;
} 
</code></pre>

<p>Please clarify <strong>WHY</strong> the above code is not returning observable. thanks in advance</p>
","8988535","","8988535","","2019-09-19 20:56:18","2019-09-20 10:47:54","Why ""return <observable>"" is not working?","<angular><ionic4><rxjs-observables>","3","3","","","","CC BY-SA 4.0"
"58111396","1","","","2019-09-26 07:14:30","","0","63","<p>I have a <code>BehaviorSubject</code>. I am trying to convert its <code>Observable</code> into a <code>ConnectableObservable</code> but I am getting error <code>publishBehaviour</code> is not a function. What am I doing wrong?</p>

<blockquote>
  <p>this.questionsArray$.publishBehavior is not a function TypeError:
  this.questionsArray$.publishBehavior is not a function</p>
</blockquote>

<p>The code snippet is</p>

<pre class=""lang-ts prettyprint-override""><code>private questionsArraySubject: BehaviorSubject&lt;Result&gt;; 
questionsArray$: Observable&lt;Result&gt;;
questionsArrayConnectable$:ConnectableObservable&lt;Result&gt;;

this.questionsArraySubject = new BehaviorSubject&lt;Result&gt;(new Result('initial',{}));

// create Observable. Other components can subcribe to it now to get notifications/values
this.questionsArray$ = this.questionsArraySubject.asObservable(); 
this.questionsArrayConnectable$ = this.questionsArray$.publishBehavior(new Result('initial',{}))
</code></pre>
","6703783","","9423231","","2019-09-26 15:11:46","2019-09-26 15:11:46","unable to convert an Observable into a ConnectableObservable","<rxjs><rxjs6><rxjs-observables>","0","3","","","","CC BY-SA 4.0"
"58220642","1","58220699","","2019-10-03 13:52:20","","0","2772","<p>I'm setting <code>isUpdate</code> flag true in subscribe and I have to set it back to false after some delay so that I can show a quick popup</p>

<p>I have tried using <code>.pipe(delay(2000)).subscribe</code> However the entire callback is getting delayed </p>

<pre><code>this.sp.myservice(data).subscribe(
data =&gt; {
this.isUpdate = true;
//something like this but not setTimeout
setTimeout(() =&gt; 
{
this.isUpdate = false
}, 2000) 
}
);
</code></pre>

<p>Expected Result: isUpdated should be false in some time</p>
","12142969","","9386929","","2019-10-03 14:54:24","2019-10-03 14:54:24","Delay inside/after subscribe in angular","<javascript><angular><rxjs><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"58266162","1","58317898","","2019-10-07 08:47:55","","1","94","<p>The observer seems to initialize the subscription just fine. However, when the value of the layer changes the observer doesn't execute the function it supposes to. Am I missing something?</p>

<p>You can check my repository on github:
<a href=""https://github.com/stefiHB/ol-angular-ionic"" rel=""nofollow noreferrer"">https://github.com/stefiHB/ol-angular-ionic</a></p>

<p>layer-msg.service.ts</p>

<pre><code>import { Injectable } from '@angular/core';
import {BehaviorSubject, Observable, Subject} from 'rxjs';
import {customMapLayers} from './customMapLayers';

@Injectable({
  providedIn: 'root'
})
export class LayerMsgService {

  private layer = new BehaviorSubject&lt;customMapLayers&gt;(customMapLayers.pwd);

  constructor() { }

  getLayer() {
    return this.layer.asObservable();
  }

  setLayer(mapLayer: customMapLayers) {
    this.layer.next(mapLayer);
    console.log('Setting new value...', this.layer.value);
  }
}


</code></pre>

<p>MyButtons.ts</p>

<pre><code>import {LayerMsgService} from './layer-msg.service';
import {customMapLayers} from './customMapLayers';


export class MyButton {

  private layerService: LayerMsgService;
  buttonPWD: HTMLButtonElement;
  buttonOSM: HTMLButtonElement;
  myElement: Element;

  constructor(el: Element) {
    this.layerService = new LayerMsgService();

    this.buttonPWD = document.createElement('button');
    this.buttonPWD.innerHTML = 'pwd';
    this.buttonOSM = document.createElement('button');
    this.buttonOSM.innerHTML = 'osm';

    this.buttonOSM.addEventListener('click', () =&gt; this.changeLayer(customMapLayers.osm));
    this.buttonPWD.addEventListener('click', () =&gt; this.changeLayer(customMapLayers.pwd));

    el.appendChild(this.buttonPWD);
    el.appendChild(this.buttonOSM);
  }

  changeLayer(l: customMapLayers) {
    console.log('Request for Changing layer...');
    this.layerService.setLayer(l);
  }


}

</code></pre>

<p>app.component.ts</p>

<pre><code>import {Component, OnDestroy, OnInit, Renderer2} from '@angular/core';
import {LayerMsgService} from './layer-msg.service';
import {Subscription} from 'rxjs';
import {MyButton} from './MyButton';
import {customMapLayers} from './customMapLayers';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit, OnDestroy {
  title = 'ObservablesMashup';
  layer: customMapLayers;

  layerSub: Subscription;
  private myBtn: MyButton;

  myText: Element;

  constructor(private layerService: LayerMsgService) {

    this.layerSub = this.layerService.getLayer().subscribe(
      l =&gt; {
        if (l) {
          console.log('Getting layer... ', l);
          this.layer = l;
        }
      });
  }

  ngOnInit(): void {
    const el = document.getElementById('map');
    console.log(el);
    this.myBtn = new MyButton(el);
    this.myText = document.getElementById('p1');
  }

  ngOnDestroy(): void {
    this.layerSub.unsubscribe();
  }
}


</code></pre>

<p>I tried to use <code>btn.onclick = (event) =&gt; {...}</code> but it doesn't seem to fix the problem.</p>

<p>I expect the console to log:</p>

<pre><code>Request for Changing layer...
Setting new value... PWD
Changing Layer... PWD
</code></pre>

<p>but the function of the observer is not being executing so this is the actual log when i click on the buttons:</p>

<pre><code>Request for Changing layer...
Setting new value... PWD
</code></pre>
","11873024","","11873024","","2019-10-07 12:38:49","2019-10-10 07:47:08","The Observer seems not to be executed whenever the observable is changing its value","<angular><typescript><angular7><openlayers-5><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"58278450","1","","","2019-10-07 23:49:30","","0","110","<p>I am new to Angular and RXJS - I'm trying to return normalized data from a rest api and assemble the hierarchy on the client.  I created this stack blitz which is a really basic version of what I'm trying to accomplish:  <a href=""https://stackblitz.com/edit/angular-ffdbza"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-ffdbza</a>  </p>

<p>These interfaces ( ParentData, AssnData, and ChildData ) represent the JSON data being returned from the API.  The Parent and Child interfaces are the way I want the data to be represented on the client (in the real app I will bind this new object to a hierarchical grid).  The key points are that the Assn data has an attribute (statusCode) that needs to be applied to each Child based on the Parent.</p>

<pre><code>// represents normalized data coming from the service
export interface ParentData {
  parentCode: string, 
  name: string
}

export interface AssnData {
  parentCode: string
  childId: number,
  statusCode: string
}

export interface ChildData {
  childId: number,
  type: string
}

// represents the merged data for display 
export interface Parent {
  parentCode: string,
  name: string
  kids: Child[]
}

export interface Child {
  childId: number
  type: string,
  statusCode: string
}
</code></pre>

<p>This is the code I have so far (grabbed from data.component.ts in the stack blitz).  It is adding the Assn objects to the correct parent but I'm having trouble merging the Child object with each Assn object.  I am doing a console.log to see the results.</p>

<pre><code>  getRelationalData() {
    let x = combineLatest(
      this.parentData$,
      this.assnData$,
      this.childData$
    ).pipe(
      map(([pData, aData, cData]) =&gt; {
        return pData.map(p =&gt; {
          return {
            ...p,
            kids: aData.filter(a =&gt; a.parentCode === p.parentCode)
          }
        })
      })
    )
    return x;
  }
</code></pre>
","3551865","","","","","2019-10-08 16:22:09","rxjs/angular - how to merge normalized data from service?","<angular><rxjs-pipeable-operators><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"58428998","1","","","2019-10-17 09:13:43","","0","321","<p>I have two behaviorSubjects  </p>

<p><code>offset = new behaviorSubject&lt;sring&gt;(null)</code><br>
<code>filter = new behaviorSubject&lt;string&gt;(null)</code>  </p>

<p>I do the following..</p>

<pre><code>combineLatest(
    this.offset, // last item in the list, ID for example
    this.filter //  can be any string
).pipe(
    mergeMap(([offset, filter]) =&gt; this.getChunkOfTen(offset, filter)),
    scan((acc, chunkOfTen) =&gt; {
        return { ...acc, ...chunkOfTen }
    }, {}),
    map(results =&gt; Object.values(results)) // to be able to loop on the frontend
)
</code></pre>

<p>When the page loads I get 10 records from DB, onScroll I get 10 more and 10 more.. that's what <strong>mergeMap</strong> and <strong>scan</strong> are in charge of (as expected).  </p>

<p>onFilter all the existing records are gone (as expected) and I get NEW 10 filtered records from DB, NOW when I scroll I DO NOT get more records and I have them in DB.  </p>

<p>as far as I know the problem lays.. in <strong>scan</strong> operator</p>

<p>is there an if else operator? or some other operators I can use before <strong>scan</strong>?</p>
","12163165","","12163165","","2019-10-17 12:23:13","2019-10-19 12:49:10","RxJS scan to accumulate database results using filter and offset as url parameters","<rxjs><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"58540668","1","58541677","","2019-10-24 11:44:23","","2","246","<p>Let's take the code bellow: </p>

<pre><code>myObservable.subscribe({
  next: async () =&gt; {
    await something();
  },
  complete: () =&gt; {
    console.log('All async task are comlpeted');
  }
});
</code></pre>

<p>The problem is that the <code>console.log</code> is called after the last <code>next</code> is triggered but I want it to be called after the last <code>something()</code> is finished.</p>

<p>Is there any way to do that ?</p>

<p>I specify that I implemented the <code>myObservable</code> by myself using <code>new Obsercable(observer =&gt; ...)</code>. So  it could be modified.</p>
","5735030","","","","","2019-10-24 12:43:39","How to await an asynchonous method defined inside subscribe before to complete an Rxjs Observable?","<javascript><rxjs><rxjs-observables>","1","5","","","","CC BY-SA 4.0"
"58617865","1","58618347","","2019-10-30 02:17:39","","2","839","<p>I use <code>rxjs</code> in <code>React Native</code>. I call <code>Observable.fromPromise(storage.load({key: key})).map(() =&gt; value);</code> shows the error.</p>

<p>My rxjs version:</p>

<pre><code>""rxjs"": ""^6.5.3"",
""rxjs-compat"": ""^6.5.3"",
</code></pre>

<p>I have three steps.</p>

<p>Step1:</p>

<pre><code>rxInit().flatMap(() =&gt; {

  console.log('I can not see the console log');

  return rxInit()

}).subscribe(() =&gt; {

  console.log('I can not see the console log');
  // some code...

})
</code></pre>

<p>Step2 rxInit():</p>

<pre><code>import { Observable } from 'rxjs';

  rxInit() {
    console.log('I can see the console log')

    return StorageService.shared.get('deviceuuid').flatMap((deviceuuid) =&gt; {

      console.log('I can't not see the console log')

      if (deviceuuid == null) {
        return StorageService.shared.set('deviceuuid', this.deviceuuid);
      } else {
        return Observable.of(this.deviceuuid);
      }

    }).do((deviceuuid) =&gt; {
        // some code...
    })
  }
</code></pre>

<p>Step3 about the get():</p>

<pre><code>import { Observable } from 'rxjs';
import Storage from 'react-native-storage';
import AsyncStorage from '@react-native-community/async-storage';

let storage = new Storage({
  size: 1000,
  storageBackend: AsyncStorage,
  defaultExpires: null,
})  

export default class StorageService {
  set(key, value) {
    console.log('StorageService set');
    return Observable.fromPromise(storage.save({ key: key, data: value })).map(() =&gt; value);
  }

  get(key) {
    console.log('It is a ', storage.load({key: key}));  // It is a Promise
    return Observable.fromPromise(storage.load({key: key})).map(() =&gt; value);
  }

  remove(key) {
    return Observable.fromPromise(storage.remove({key: key})).catch(() =&gt; Observable.of(null))
  }
}

StorageService.shared = new StorageService();
</code></pre>

<p>I looking for some answer, somebody says it is because rxjs is above 6.0, so I try to use </p>

<pre><code>import { from } from 'rxjs';

return from(storage.load({key: key})).map(() =&gt; value);
</code></pre>

<p>It sill shows </p>

<pre><code>TypeError: _rxjs.from.fromPromise is not a function
</code></pre>

<p>or</p>

<pre><code>_rxjs.from().map is not a function.
</code></pre>

<p>Any help would be appreciated.</p>
","6902961","","6902961","","2019-10-30 02:36:27","2019-10-30 03:29:01","TypeError: _rxjs.Observable.fromPromise is not a function","<react-native><rxjs><rxjs5><rxjs6><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"58619944","1","58620434","","2019-10-30 06:48:35","","0","704","<p>I use the code with <code>rxjs 5.5.12</code> in React Native, it works.</p>

<p>In rxjs 5.5.12:</p>

<pre><code>// the function will return Observable
  rxInit() {
    return Observable.combineLatest(
      myObservable1,
      myObservable2,
    ).flatMap((result) =&gt; {
      console.log('rxInit result =&gt;', result) // I can see the result
      const [token, email] = result

      this.token = token
      this.email = email

      // check the value is empty or not and return Observable.

      if (this.token != null &amp;&amp; this.email != null) {
        return Observable.fromPromise(myApiPromise).catch(handleErrorFunction)
      } else if (this.token != null &amp;&amp; this.uid != null) {
        return Observable.fromPromise(myApiPromise).catch(handleErrorFunction)
      } else {
        return Observable.of(null)
      }
    })
  }
</code></pre>

<p>In rxjs 6.5.3:</p>

<p>import some oerator first:</p>

<pre><code>import { combineLatest } from 'rxjs';
import { flatMap } from 'rxjs/operators';
</code></pre>

<p>I change the code:</p>

<pre><code>rxInit() {
  console.log('rxInit start');

  return combineLatest(
    myObservable1,
    myObservable2
   ).flatMap((result) =&gt; {
     console.log('rxInit result =&gt;', result)
   });

   console.log('rxInit end');
 }
</code></pre>

<p>It will show error <code>TypeError: (0 , _rxjs.combineLatest)(...).flatMap is not a function</code>.</p>

<p>So I note that may be I have to use <code>pipe</code>, I try to change the code.</p>

<pre><code>rxInit() {
    console.log('rxInit start'); // it works.

    return combineLatest(
      myObservable1,
      myObservable2
    ).pipe(flatMap((result) =&gt; {
      console.log('rxInit result =&gt;', result);  // the console log doesn't work
    }));
    console.log('rxInit end'); // the console log doesn't work
  }
</code></pre>

<p>I have no idea why I can't get the result in my console.log.</p>

<p>Any help would be appreciated.</p>
","6902961","","","","","2019-10-30 07:30:58","How to use combineLatest with flatMap in rxjs6?","<react-native><rxjs><rxjs5><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"58622320","1","58622526","","2019-10-30 09:33:49","","0","180","<p>In <code>rxjs 5.5.12</code>, I created a <code>login()</code> to <code>subscribe</code> with multiple observable by <code>do()</code></p>

<pre><code>login(userEmail, userPassword).subscribe((response) =&gt; {
  console.log(response);

  if (response === 'something') {
    // some actions
  } else {
    // some actions
  }
},(error) =&gt; {
  // some error actions
});
</code></pre>

<p>I use rxLoginPOST to call api:</p>

<pre><code>rxLoginPOST(url, params) {
  return Rx.Observable.fromPromise(somePromise).catch(handleErrFunction);
}
</code></pre>

<p>I use it in login function it return multiple observable:</p>

<pre><code>login(email, password) {
  return APIService.shared.rxLoginPOST('users/signin', { ...arguments })
  .flatMap((response) =&gt; {
    if (response.status === 200) {
        return Rx.Observable.combineLatest(
          myObservable1,
          myObservable2,
          myObservable3
        )
      } else {
        return Rx.Observable.of(response)
      }
  }).do((result) =&gt; {
      if (result.length &gt; 0) {
        // some logic
      } else {
        return Rx.Observable.of(result)
      }
  }).flatMap((result) =&gt; {
      if (result.length &gt; 0) {
        return this.checkUserIsRegistered()
      } else {
        return Rx.Observable.of(result)
      }
  })
}
</code></pre>

<p>In <code>rxjs 6.5.3</code>, I had changed all the import like</p>

<pre><code>import { Observable, combineLatest, of } from 'rxjs';
import { mergeMap, map, catchError, flatMap, tap } from 'rxjs/operators';
</code></pre>

<p>If I trigger <code>login()</code> it will show <code>do is not a function</code></p>

<p>So I change the code:</p>

<pre><code>login(userEmail, password) {
    return APIService.shared.rxLoginPOST('users/signin', { ...arguments }).pipe(
        mergeMap((response) =&gt; {
        if (response.status === 200) {
          return combineLatest(
            myObservable1,
            myObservable2,
            myObservable3
          )
        } else {
          return of(response)
        }
      }).tap((result) =&gt; { // I am stuck here, I have no idea how to continue with it...
         console.log('check 4');  // check 4 does not appear.
         console.log('response', response);
         return of(response)
      }
    );
</code></pre>

<p>I try to use <code>tap</code> instead of <code>do</code>, but check 4 does not appear.</p>

<p>Any help would be appreciated.</p>
","6902961","","","","","2019-11-04 16:39:04","How to subscribe multiple observable in rxjs 6 ? do is not a function in rxjs 6","<react-native><rxjs><rxjs5><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"58669932","1","58672483","","2019-11-02 09:48:32","","0","52","<p>I am trying to check the validity of a function I have written in Typescript, in congruence with RxJS observables, that fetches some bookings from one service and then for each booking fetches its corresponding location and activity from another service. </p>

<p>I am simply writing this post to verify the validity of what I have written and to ask if there is anything I could have done more efficiently.</p>

<pre class=""lang-js prettyprint-override""><code>let params = new HttpParams();
params = params.append('status', 'C');
params = params.append('offset', offset.toString());
params = params.append('limit', limit.toString());
return this.http.get(`${this.environment.booking.url}/my/bookings`, { params }).pipe(
    mergeMap((bookings: Booking[]) =&gt; {
        if(bookings.length &gt; 0) {
            return forkJoin(
                bookings.map((booking: Booking) =&gt;
                    forkJoin(
                        of(booking),
                        this.activityService.getActivity(booking.activity),
                  this.locationService.getLocation(booking.finalLocation),
                    ).pipe(
                        map((data: [ Booking, Activity, Location ]) =&gt; {
                            let booking = data[0];
                            booking.activityData = data[1];
                            booking.finalLocationData = data[2];
                            return booking;
                        })
                    )
                )
            )
        }

        return of([]);
    }),
    catchError((err: HttpErrorResponse) =&gt; throwError(err))
);
</code></pre>

<p>I am expecting for this function to return a list of bookings alongside their corresponding location and activity. However more importantly I want to verify that what I am doing is correct and sensible. Is there anything I could have done differently to make it cleaner/ more human-readable (not nit-picking, please 😁 )?</p>

<p>On a different note, that of performance, I also have a follow-up question with regards to performance. Given that a list of bookings has common activities and locations. Is there a way to only fetch activities and locations without any duplicate HTTP requests? Is this already handled under the hood by RxJS? Is there anything I could have done to make this function more efficient?</p>
","12311649","","498031","","2019-11-02 13:05:49","2019-11-02 15:26:32","Combining observables in series & parallel to fetch data from multiple APIs","<javascript><rxjs><angular2-observables><rxjs-pipeable-operators><rxjs-observables>","2","3","","","","CC BY-SA 4.0"
"58698409","1","58717458","","2019-11-04 17:29:35","","1","459","<p>I have a <code>ConnectableObservable</code> which is part of a <code>BehaviourSubject</code>.</p>

<pre><code>question$: ConnectableObservable&lt;Result&gt;;
private questionSubject: BehaviorSubject&lt;Result&gt;; 

this.questionSubject = new BehaviorSubject&lt;Result&gt;(new Result('initial',{}));
this.question$ = (this.questionSubject.asObservable()).pipe(publish()) as ConnectableObservable&lt;Result&gt;;
</code></pre>

<p>I use <code>next</code> method to <code>emit</code> values when response from the server is received.</p>

<pre><code>this.questionSubject.next(new Result(response.result,getQuestionResponse));
</code></pre>

<p>It seems that the <code>Subject</code> is emitting past values as well.</p>

<pre><code>    jsonQuestion response:  {""question-id"":""78830909-b23e-4345-bc69-63f3ce039b20"",...} //SUBJECT SENDS THIS
question-details.component.ts:369 got stream value  Result {result: ""success"", additionalInfo: ""{""question-id"":""78830909-b23e-4345-bc69-63f3ce039b…2-ae23-f284213ff80a""},""is-question-creator"":true}""}// OBSERVABLE RECEIVED THIS
... AND THE SAME TRACE COMES AGAIN!!
question-details.component.ts:369 got stream value  Result {result: ""success"", additionalInfo: ""{""question-id"":""78830909-b23e-4345-bc69-63f3ce039b…2-ae23-f284213ff80a""},""is-question-creator"":true}""}
</code></pre>

<p>Why is the Observable sending multiple values. How can i make it send only the latest value?</p>
","6703783","","","","","2019-11-05 18:34:07","How can I make an observable emit only latest value and not past values","<rxjs><angular6><angular2-observables><rxjs-observables>","1","5","","","","CC BY-SA 4.0"
"58781909","1","58875722","","2019-11-09 17:45:00","","1","82","<p>I'm trying to implement service, which provides observable if app has connection to my server or not, so when browser online, we ping server with timer. Here is code: </p>

<pre><code>public get $connected(): Observable&lt;boolean&gt; {
    return this.hasInternetConnection
               .asObservable()
               .pipe(
                 distinctUntilChanged(),
                 flatMap((connected: boolean) =&gt; {
                   if (!connected) {
                     return of(connected);
                   } else {
                     return timer(5000)
                       .pipe(
                         map(() =&gt; {
                           var success = Math.random() &gt; 0.5;
                           console.log('PING: ' + success);
                           return success;
                         })
                       );
                   }
                 })
               );
  }
</code></pre>

<p><code>hasInternetConnection</code> is just a BehaviorSubject bound to window <code>online</code> and <code>offline</code> events, timer emulates ping to my API server.</p>

<p>The issue is that my subscription <code>$connected</code> catches only first value from timer observable and then doesn't work. After <code>hasInternetConnection</code> subject changes to <code>false</code> and back to <code>true</code>, my subscription again gets first value and then nothing. Here is what I see in console:</p>

<pre><code>PING: true
subscription tap
PING: true
PING: false
PING: true
...
</code></pre>

<p>How can I fix that? Thank you!</p>
","7290992","","","","","2019-11-15 11:06:25","RXJS flatMap to repetitive observable","<rxjs><observable><ngrx><rxjs-pipeable-operators><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"58806251","1","","","2019-11-11 17:46:50","","0","99","<p>We want to buffer the data until the below two events are reached such as the debounce time reached to 5 or value is changed. But based on the below test we seeing it is not working properly. </p>

<p>The behavior I want to achieve is.</p>

<p>a) When there is a change in the value, I want to emit those buffered values.</p>

<p>b) When debounce time reached, I want to emit the buffered value.</p>

<pre><code>import {
    mergeMap,
    tap,
    map,
    takeUntil,
    concatMap,
    throttle,
    throttleTime,
    debounceTime,
    distinctUntilChanged,
    bufferWhen,
} from 'rxjs/operators';
import { of, from, race } from 'rxjs';
import 'jest';




describe('test ', () =&gt; {
    const source$ = from([
        { name: 'Brian' },
        { name: 'Joe' },
        { name: 'Joe' },
        { name: 'Joe' },
        { name: 'Joe' },
        { name: 'Sue' },
        { name: 'Brian' },
        { name: 'Brian' },
        { name: 'Brian' },
        { name: 'Brian' },
        { name: 'Brian' },
        { name: 'Brian' },
        { name: 'Brian' },
        { name: 'Brian' },
        { name: 'Brian' },
        { name: 'Brian' },
        { name: 'Joe' },
        { name: 'Joe' },
        { name: 'Sue' }

    ]);


    const distinctEvent$ = source$.pipe(
        distinctUntilChanged((prev, curr) =&gt; prev.name === curr.name),
        tap(() =&gt; console.log('-1-- AFTER DISTINCT'))
    )


    const batch$ = source$.pipe(
        bufferWhen(() =&gt;
            race(
                distinctEvent$,
                source$.pipe(debounceTime(5)),
            ),
        ),
    );
    it('test', () =&gt; {

         batch$.subscribe(() =&gt; {
            console.log('--only');
        });
    });
});
</code></pre>
","1595858","","1595858","","2019-11-11 18:05:41","2019-11-11 18:05:41","distinctUntilChanged under Race observable not working as expected","<javascript><rxjs><rxjs-observables>","0","4","","","","CC BY-SA 4.0"
"58807293","1","","","2019-11-11 19:10:02","","1","456","<p>I have a method in my testComponent that returns an observable which is been subscribed to and after been unsubscribe from, then it runs the code in the .add() (i.e when the subscription is been unsubscribed from) </p>

<p>How do i spy on this method and watch the actions taking place when the subscribe method is called and when the add() method when unsubscribed from the subscription. Thanks</p>

<p>Here goes the code sample</p>

<pre><code>const loading; 
const done; 
const error; 

onClick() {
this.loading = true;  
this.myService.processData(someValues)
.subscribe(
    result =&gt; {
        this.done = true; 
     },
    error =&gt; {
        this.error = true; 
     } )
.add(() =&gt; { this.loading = false })
}
</code></pre>

<p>I need a way to watch what's happening in the subscribe() and add() block. </p>
","11732685","","11732685","","2019-11-11 21:00:55","2019-11-21 18:42:31","Spying on Observable subscribe() and add() method in Angular unit test","<angular><unit-testing><jasmine><angular2-observables><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"58815471","1","58951456","","2019-11-12 09:18:39","","8","9197","<p>I have various methods in my components that subscribe to methods in injected dependencies, that return observables.</p>

<p>I want to write Jest unit tests to ensure that when these observables return / error, my methods do the correct thing.</p>

<p>In the below example I am trying to write a test that checks if <code>doAThing</code> has fired. Neither of the below tests work. They both fail with errors like </p>

<blockquote>
  <p>'returnMyObservable.subscribe is not a function'.</p>
</blockquote>

<pre><code>// Example method to test component 
public testFunction (): void {
    this.myService.returnMyObservable.subscribe(
        ( value ) =&gt; this.doAThing( value )
    )
}
</code></pre>

<pre class=""lang-js prettyprint-override""><code>describe( 'myComponemt', () =&gt; {

    let fixture;
    let myServiceMock;

    beforeEach( () =&gt; {
        myServiceMock = {
            returnMyObservable: fn()
        }

        fixture = new myComponent( myServiceMock );
    });


    // 1) I have tried mocking with a returned value
    it ( 'should call do a thing when value is returned', () =&gt; {
        myServiceMock.returnMyOnservable.mockReturnValue( true );

        fixture.testFunction();

        expect( fixture.doAThing ).toHaveBeenCalled();
    });

    // 2) I have tried returning an observable
    it ( 'should call do a thing when value is returned', () =&gt; {
        myServiceMock.returnMyOnservable.mockReturnValue( of( true ) );

        fixture.testFunction();

        expect( fixture.doAThing ).toHaveBeenCalled();
    });

});
</code></pre>
","7490332","","6463558","","2020-12-23 02:34:43","2020-12-23 02:34:43","In Jest, how can I unit test a method that subscribes to an observable","<typescript><unit-testing><jestjs><rxjs-observables>","2","0","1","","","CC BY-SA 4.0"
"58844874","1","","","2019-11-13 20:12:10","","1","493","<p>I'm attempting to write a service that measures the completion time of the app becoming stable.  Here's the service:</p>

<h3>measure.service.ts</h3>

<pre class=""lang-js prettyprint-override""><code>import { ApplicationRef, Injectable } from ""@angular/core"";
import { first, map } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class MeasureService {
  public constructor(private readonly applicationRef: ApplicationRef) { }

  public measure(): void {
    const startTime = Date.now();

    console.log(startTime);
    /**
     * Test stability metrics of application.
     */
    this.applicationRef.isStable.pipe(
      first(isStable =&gt; isStable),
      map(() =&gt; {
        /* tslint:disable-next-line:no-console */
        console.log(""App stable (""+ Math.round((Date.now() - startTime) / 1000) + "" secs)"");
      })
    );
  }
}
</code></pre>

<h3>app.module.ts (abbreviated):</h3>

<pre class=""lang-js prettyprint-override""><code>...
@NgModule({
   providers: [
      MeasureService
   ]
})
</code></pre>

<h3>root.component.ts</h3>

<pre class=""lang-js prettyprint-override""><code>import { Component, OnInit } from ""@angular/core"";
import { MeasureService } from ""../application-insights/measure.service"";

@Component({
  selector: ""mr-root"",
  template: `
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
  `,
})
export class RootComponent implements OnInit {
  public constructor(
    private readonly measureService: MeasureService
  ) {  
    this.measureService.measure();    
  }

  public ngOnInit(): void {
  }
}

</code></pre>

<p>The first <code>console.log</code> of the <code>MeasureService</code> correctly logs the time.  However, it appears the <code>applicationRef.isStable</code> never fires and, therefore, the second <code>console.log</code> never writes to the console.</p>

<p>Am I doing this right, or am I missing something?</p>
","916995","","","","","2019-11-14 02:05:29","ApplicationRef.isStable not executing","<javascript><angular><rxjs><rxjs-pipeable-operators><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"58896088","1","","","2019-11-16 23:13:34","","0","484","<p>I am attempting to use a CanDeactivate guard to detect when a user navigates away from the component. The purpose is to #1 check if the current user owns the 'Is Being Edited' lock on the record, and #2 if so, call an observable to update the database.</p>

<p>The code I have is partially working, but there is a race condition where the lock isn't always released, probably because the subscription to <code>this.updateIsBeingEdited$(false)</code> doesn't always complete by the time the next return statement is called. So I know this isn't implemented correctly.</p>

<p>How can I make it such that the <code>this.updateIsBeingEdited$</code> observable completes before the canDeactivate returns a value?</p>

<p>The return value should always be true, because the component should always deactivate, it just need to make sure <code>this.updateIsBeingEdited$.subscribe()</code> is done before deactivation completes.</p>

<p><strong>COMPONENT</strong></p>

<pre><code>  canDeactivate(): Observable&lt;boolean&gt; | boolean {

    // Check if Is Being Edited must be removed
    if (this.mustReleaseIsBeingEdited()) {
      this.removeIsBeingEditedSub = this.updateIsBeingEdited$(false).subscribe(result =&gt; {
        // QUESTION: How to wait until this is complete before allowing component to deactivate?
        return true;
      }, err =&gt; { console.error(err); }, () =&gt; { });

      // Always allow deactivation
      return true;
    } else {
      return true;
    }

  }

  private updateIsBeingEdited$(isBeingEdited): Observable&lt;boolean&gt; {

    const editedObj = {
      _id: this.record._id,
      IsBeingEdited: isBeingEdited,
      EditedBy: this.accessLevelService.getUserId()
    }

    return this.httpService!.postData$(
      `records/_id/${editedObj._id}/IsBeingEdited/`,
      editedObj
    );

  }
</code></pre>

<p><strong>GUARD</strong></p>

<pre><code>export interface ComponentCanDeactivate {
  canDeactivate: () =&gt; boolean | Observable&lt;boolean&gt;;
}
/**
 * Guard to notify client that user has navigated away from route
 * Implemented in component for managing record locks only
 */
@Injectable({
  providedIn: 'root'
})
export class RecordLocksGuard implements CanDeactivate&lt;ComponentCanDeactivate&gt; {
  canDeactivate(component: ComponentCanDeactivate): boolean | Observable&lt;boolean&gt; {
    if (!component) {
      return true;
    }
    component.canDeactivate();
    // Always allow component to deactivate
    return true;
  }
}
</code></pre>
","2183592","","","","","2019-11-17 17:29:08","Angular8 RXJS CanDeactivate wait for result of observable before deactivation","<angular><rxjs><rxjs-observables><rxjs-subscriptions><candeactivate>","1","1","","","","CC BY-SA 4.0"
"58937494","1","","","2019-11-19 15:27:13","","0","207","<p>I have an observable that makes an API call. The API call returns an array of objects in the response. </p>

<p>I am using this observable in multiple places. In most cases, I want the object in the response.</p>

<p>However, in the case of CanDeactivate, I need to 'pre-process' the response to return true or false instead, since CanDeactivate is expected to return Observable.</p>

<p>Is there a way to tap into the response to process it ahead of time (perhaps using the 'tap' operation?)</p>

<pre><code>  canDeactivate(): Observable&lt;boolean&gt; | boolean {

    // Check if Is Being Edited must be removed
    if (this.mustReleaseIsBeingEdited()) {
      return this.updateIsBeingEdited$(false);
    } else {
      return of(true);
    }

  }

  public updateIsBeingEdited$(_id: string, IsBeingEdited: boolean): Observable&lt;Record[]&gt; {

    return this.httpService!.postData(
      `records/_id/${_id}/IsBeingEdited/${IsBeingEdited}`,
      {}
    );

  }
</code></pre>
","2183592","","","","","2019-11-19 15:27:13","Angular 8 RXJS6 Observable pre-process response before return","<angular><rxjs><observable><angular2-observables><rxjs-observables>","0","6","","","","CC BY-SA 4.0"
"58956664","1","58956790","","2019-11-20 14:28:24","","0","211","<p>I need to pass data from one component to another but I'm having a hard time doing so.</p>

<p>I have an <code>Observable</code> that I need to pass as <code>Subject</code> which is another Observable. How do I do that?
The way I currently have is not working as it gets in the <em>target component</em> <code>undefined</code>.</p>

<p>This is what I have:</p>

<p><strong>card.component.ts</strong> <em>(where it all begins)</em></p>

<pre><code>showBox(studentID) {
    const airportPickup = this.studentService.getCurrentStudents().pipe(
        map(snaps =&gt; {
            const student = snaps.find( s =&gt; s.studentID === studentID );
            return {
                requirePickup: student.pickup,
                whopickup: student.whoPickup
            };
        })
    );
    this.studentService.airportPickupDropoff.next(airportPickup);
}
</code></pre>

<p>If I <code>console.log()</code> the <code>airportPickup</code> I get the object. No issues. The problem is when I get it in the other component, I get it as <code>undefined</code>.</p>

<p><strong>flight-info.component.ts</strong> <em>(the target)</em></p>

<pre><code>getAirportPickup() {
    this.studentService.airportPickupDropoff.subscribe(
        (apdata) =&gt; {
            this.airportPickupDropoff = apdata;
        },
        (e) =&gt; alert(e)
    );
}
</code></pre>

<p>The <strong>service</strong> I have this:</p>

<p><code>airportPickupDropoff = new Subject&lt;any&gt;();</code></p>
","3747104","","","","","2019-11-20 14:34:58","Passing and unwrapping Observable as Subject","<angular><rxjs><angular2-observables><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"58970173","1","","","2019-11-21 08:14:43","","1","330","<p>I am new to rxjs operators</p>

<p>What is the most efficient way to execute two requests and check if one of the requests comes back as valid and also check if both failed. </p>

<p>I tried forkJoin but unable to determine how to when both requests failed.</p>
","1827400","","","","","2019-11-21 10:24:53","execute multiple requests angular 8","<angular><rxjs><observable><angular8><rxjs-observables>","2","2","1","","","CC BY-SA 4.0"
"59022830","1","59023073","","2019-11-24 21:57:05","","2","3102","<p>I am a back-end developer starting with front-end development for a project I am working on. The front-end uses Angular7 and NgRx. I have studied a lot in the last 4 days, but here is something I am stuck with and would appreciate your help.</p>

<p>I learnt that we can dispatch multiple actions from an effect in NgRx by returning an Observable array having multiple actions. I want to dispatch one of the action in the array based on a condition.</p>

<p>My code looks something like this </p>

<pre><code>@Effect()
  something$: Observable&lt;Action&gt; = this.actions$.pipe(
    ofType(ActionType),
    switchMap.(action: any) =&gt; {
       return service.call(action.payload)
         .pipe(
             switchMap((data: ReturnType) =&gt; [ 
                new Action1(),
                new Action2(),
              ]),
        catchError(error handling)
      );
    }),
   );
</code></pre>

<p>and I want to achieve something like this</p>

<pre><code>   @Effect()
  something$: Observable&lt;Action&gt; = this.actions$.pipe(
    ofType(ActionType),
    switchMap.(action: any) =&gt; {
       return service.call(action.payload)
         .pipe(
             switchMap((data: ReturnType) =&gt; [ 
                 if(condition)
                   new Action1()
                  else
                    new Action1.1() ,
                new Action2(),
              ]),
        catchError(error handling)
      );
    }),
   );
</code></pre>

<p>I think its my lack of knowledge of RxJs, which is preventing me to implement the condition.</p>
","12426044","","","","","2021-03-20 00:49:41","How to dispatch multiple actions from an effect in ngrx conditionally","<rxjs><ngrx><ngrx-effects><rxjs-pipeable-operators><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"59134458","1","59134863","","2019-12-02 07:37:54","","3","911","<p>What is the best way in angular with rxjs to already display the result of a first observable, and combining the data when other observables are finished?</p>

<p>Example:</p>

<pre><code>@Component({
    selector: 'app-component',
    template: `
&lt;div *ngFor=""let group of groups$ | async""&gt;
    &lt;div *ngFor=""let thisItem of group.theseItems""&gt;
        ...
    &lt;/div&gt;
    &lt;div *ngFor=""let thatItem of group.thoseItems""&gt;
        ...
    &lt;/div&gt;
&lt;/div&gt;
`
})
export class AppComponent implements OnInit {
    ...
    ngOnInit() {
        this.groups$ = this.http.get&lt;IThisItem[]&gt;('api/theseItems').pipe(
            map(theseItems =&gt; {
                return theseItems.groupBy('groupCode');
            })
        );

        // combine these results? This operation can take 5 seconds
        this.groups$$ = this.http.get&lt;IThatItem[]&gt;('api/thoseItems').pipe(
            map(thoseItems =&gt; {
                return thoseItems.groupBy('groupCode');
            })
        );
    }
}
</code></pre>

<p>I understand it can be done by subscribing to both, and merge the results. But is it possible to use pipe operators for this, and using the <code>async</code> pipe?</p>
","3153169","","","","","2019-12-02 13:46:02","rxjs: Combine result of observables while already displaying the first with async pipe","<angular><rxjs><rxjs-observables>","3","2","","","","CC BY-SA 4.0"
"59180733","1","59181144","","2019-12-04 16:36:12","","1","79","<p>Here is the test, in the ngInit of any angular component:</p>

<pre><code>console.log('a');

observableFoo$.subscribe(x =&gt; console.log('b'));
observableNotFoo$.subscribe(() =&gt; console.log('c'));

forkJoin([
  observableFoo$,
  observableNotFoo$
]).subscribe(([foo, ntFoo]) =&gt; {
  console.log('d');
});
</code></pre>

<p>The ObservableFoo$ will fire 2 times, that is behaviour that I need, this observable will observe a value that can quickly change during the initialisation. </p>

<p>result is : </p>

<pre><code>a
b
b
c
</code></pre>

<p>And d never log.
So, I first tried to do the same, but with only ObservableNotFoo$ just to be sure I can forkJoin on a single Observable (useless but it works), then I tried the same thing with ObservableFoo$ and it's not working.</p>

<p>It seems forkJoin just doesn't accept subscriptions that will fire twice. Is that so? Seem's really strange...</p>

<p>** EDIT : **</p>

<pre><code>observableFoo$ = initFoo(this.id); 

observableNotFoo$ = of('notFoo');

</code></pre>

<pre><code>
initFoo(id: string): Observable&lt;any&gt; {
 const content = this.store.select({
      filterBy: entity =&gt; entity.id === id
    }).pipe(
      flatMap(v =&gt; {
        const value = v[0];
        if (!value) {
          return httpRequest.get(this.baseUrl + '/' + id).pipe(map(val =&gt; {
            this.store.add(val);
            return val;
          }));
        }
        return of(value);
      })
    );
    return content;
  }
}

</code></pre>
","9016032","","9016032","","2019-12-04 17:08:37","2019-12-04 17:08:37","Twin subscribes block forkJoin subscription","<angular><typescript><rxjs><rxjs-observables>","2","2","0","","","CC BY-SA 4.0"
"59233971","1","59234018","","2019-12-08 09:16:18","","0","78","<p>I would like to do sequential HTTP calls and merge the responses into one and unique observable.</p>

<p>Problem is: the way I am doing it seems to be wrong. Indeed, I would like to merge the data from the second request into the first one, but the way I did it seems to replace the result of the first one by the result of the seconde one.</p>

<p>Here it is the first request called:</p>

<pre><code>[{vehicule_id:123, statistics:{speed:60,rotation:38}},...]
</code></pre>

<p>The second one:</p>

<pre><code>[{vehicule_id:123, name:""name"",description:""description},...]
</code></pre>

<p>And the result I would like to get:</p>

<pre><code>[{vehicule_id:123, statistics:{speed:60,rotation:38}, name:""name"",description:""description},...]
</code></pre>

<p>Important thing to know: the second request needs a vehicule_id provided in the response of the first one.
With my code, the response of the second call replace the result of the first one instead of merging them.</p>

<p>Here it is my code:</p>

<pre><code>getUserVehiculesInfo(user_id: number, language: string): void {
this._data.getUserVehiculesInfo(user_id, language)
  .pipe(
    map(res =&gt; res.data[user_id]),
    switchMap(vehicules =&gt; forkJoin(vehicules.map(vehicule =&gt; this._data.getVehiculesInfo(tank.vehicule_id, language)))),
    tap(console.log)
  )
  .subscribe();
}
</code></pre>
","7683776","","","","","2019-12-08 09:22:18","RXJS sequential HTTP request","<rxjs><observable><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"59247679","1","","","2019-12-09 11:14:06","","-1","186","<p>I'm calling some API call on submit, due to internet connection interrupt failed API calls. I need to re-send failed API's on re-connection.</p>
","8307695","","","","","2019-12-09 12:13:13","How to re-send failed API requests on internet re-connection using Angular 8?","<javascript><angular><typescript><angular-http-interceptors><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"59310490","1","59311580","","2019-12-12 18:10:28","","0","90","<p>I have two main components - list and detail. In the third component, which doesn't have a parent/child relationship with either of the first two components, I need to know which component is currently being used/displayed and based on that, perform some actions in it.</p>

<p>Right now, I'm subscribed to URL parameters within each of the two components (list and detail). Within the two subscriptions I'm setting a behaviour subject (using next) to which the third component is subscribed. I set the behaviour subject to 'list' within the subscription to URL parameters within list component and I set the behaviour subject to 'detail' within the subscrription to URL parameters within detail component. That is how the third component always knows which component is being displayed.</p>

<p>I'm sure there is a a better way than to play this kind of ping-pong?</p>
","10587869","","","","","2019-12-13 04:09:11","Angular 8 - keeping track of displayed components without access to URL params","<angular><components><angular-routing><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"59319114","1","59319182","","2019-12-13 08:57:04","","2","358","<p>I have got an Angular app that gets data from APIs. 
So first my code for <em>detail.component.ts</em> looked kind of like this: </p>

<pre class=""lang-js prettyprint-override""><code>//code
getData()
{
this.http.get(url1).subscribe(data1 =&gt; 
{/*code: apply certain filter to get a filtered array out*/

this.http.get(url2).subscribe(data2 =&gt; 
{/*code: apply certain filter to get a filtered array out*/

this.http.get(url3).subscribe(data3 =&gt; 
{/*code: apply certain filter to get a filtered array out*/
})//closing third subscribe form

})//closing second subscribe form
})//closing first subscribe form
}
</code></pre>

<p>As you can see, because of nesting all these calls inside each other, the more calls I will have in the future, the messier it all will get. I did some research and got the idea that <em>observables</em> might solve the problem. So I changed the code and this is how it looks like now - <em>data.service.ts</em>: </p>

<pre class=""lang-js prettyprint-override""><code>//code
getData1()
{this.data1 = this.http.get(this.url1)
return this.data1;}

getData2()
{this.data2 = this.http.get(this.url2)
return this.data2;}

getData3()
{this.data3 = this.http.get(this.url3)
return this.data3;}
</code></pre>

<p><em>detail.component.ts</em>: </p>

<pre class=""lang-js prettyprint-override""><code>//code
ngOnInit()
{
this.dataService.getData1().subscribe(data1 =&gt; 
{/*code: apply certain filter to get a filtered array out*/

this.dataService.getData2().subscribe(data2 =&gt; 
{/*code: apply certain filter to get a filtered array out*/

this.dataService.getData3().subscribe(data3 =&gt; 
{/*code: apply certain filter to get a filtered array out*/
})//closing third subscribe form

})//closing second subscribe form
})//closing first subscribe form
}
</code></pre>

<p><em>Data1</em> must be executed first because <em>Data2</em> and <em>Data3</em> need information of the filtered Array from <em>Data1</em>. This is why I struggled to apply solutions like <em>forkJoin</em>. So my question is, if this is a good solution or if you know of a better way to make the code less messy and keep the functionality?</p>
","","user11962606","","user11962606","2019-12-13 09:02:16","2019-12-13 09:20:06","What is the best way to use observables for http requests in angular?","<angular><typescript><rxjs-observables>","4","4","2","","","CC BY-SA 4.0"
"59330526","1","59334023","","2019-12-13 22:22:26","","0","117","<p>When Angular tries to connect, I want to show ""Connecting"". I can do it on first connect, but I don't know how to do it when using retryWhen(). I need to hook into the actual execution and then do:</p>

<pre><code>this.connectionStatus = ""Connecting""
</code></pre>

<p>Current code:</p>

<pre><code>    this.connectionStatus = ""Connecting"";

    let socket = new WebSocketSubject(..);

    this.socket
      .pipe(retryWhen(errors =&gt;
        errors.pipe(
          tap(val =&gt; {
            console.log(""Retry in 10 sec"", val);
          }),
          delay(10000)
        )))
      .subscribe(..);
</code></pre>
","2811653","","","","","2019-12-16 03:58:27","RXJS: How to get connect event? retrywhen: how to hook into execution?","<angular><websocket><rxjs><rxjs-observables><retrywhen>","1","2","","","","CC BY-SA 4.0"
"59411788","1","","","2019-12-19 14:31:49","","0","628","<p>Although I feel <a href=""https://stackoverflow.com/a/54085199/7773582"">this answer</a> is relatively close to my problem and got some reputation, I don't get it right. I read a lot of posts on how to use the ""new"" style of Observer-pattern (<code>(...).pipe(map(...)).subscribe(...)</code> and <code>*ngFor=""... | async""</code>) in Angular and now also stumbled across <a href=""https://dev.to/angular/how-to-avoid-observables-in-angular-273h"" rel=""nofollow noreferrer"">How to Avoid Observables in Angular</a>. I don't want to avoid reactive behaviour; I want to have changes in the REST-API to be reflected ""live"" to the user without reloading the Observer. That's why I want to subscribe an object (and therefore also its properties) to an Observable (and the 'might-be-there' values from the data-stream in it), right?</p>

<p>In my template I have:</p>

<pre><code>&lt;p&gt;Werte:&lt;br&gt;&lt;span *ngFor=""let attribute of _attributes | slice:0:5; index as h""&gt;
 {{attribute.name}}: &lt;strong&gt;{{getParamNameAt(h)}}&lt;/strong&gt; &lt;/span&gt;&lt;br&gt;
&lt;span *ngFor=""let attribute of _attributes | slice:5: _attributes.length; index as h""&gt;
 {{attribute.name}}: &lt;strong&gt;{{getParamNameAt(h + 5)}}&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
</code></pre>

<p>In my component I have:</p>

<pre><code>private _attributes: Attribute[];

constructor(private attributesService: BkGenericaAttributesService) {
    attributesService.getAttributes().subscribe({ next:  attributes =&gt; this._attributes = attributes });
  }

  getParamNameAt(h: number): string {
    let attrVal = this.bkHerstArtNr.charAt(h);
    return attributes[h].subModule.find(param =&gt; param.subModuleValue === attrVal).subModuleName;
  }
</code></pre>

<p>and as service I have:</p>

<pre><code>const localUrl = '../../assets/json/response.json';

@Injectable()
export class BkGenericaAttributesMockService implements BkGenericaAttributesService {

  constructor(private http: HttpClient) {
    }

  getAttributes(): Observable&lt;Attribute[]&gt; {
    return this.http.get&lt;Attribute[]&gt;(localUrl).pipe(
      tap((attributes : Attribute[]) =&gt; attributes.map((attribute : Attribute) =&gt; console.log(""Piping into the http-request and mapping one object after another: "" + attribute.name))),
      map((attributes : Attribute[]) =&gt; attributes.map((attribute : Attribute) =&gt; new Attribute(attribute.id, attribute.name, attribute.title, attribute.description,
        (attribute.parameters ? attribute.parameters.map((parameter : Parameter) =&gt; new Parameter(parameter.id,
          parameter.name, parameter.value)) : [])))));
  }
</code></pre>

<p>My problem running the application at this point is the 'to-create-on-stream' <code>Attribute</code>-objects and ""nested"" Parameters[]-array (created by pushing <code>Parameter</code>-objects into it) pushed into the <code>_attributes</code>-array from the httpClient's Observable: <code>Piping into the http-request and mapping one object after another: undefined</code>.</p>

<p><strong>Apart from this</strong> - is my construct the right way to read values from a JSON-file (or alternatively an API-stream, which may change while a user visits the SPA) into properties of multiple objects displayed on the Angular view?</p>

<p>With <a href=""https://stackoverflow.com/a/54085199/7773582"">the answer</a> mentioned above - or the way I thought I have to translate it into my code - I start to doubt that I'm really understanding (and using) the reactive Angular way with Data-Providers &lt;= Observables => Operators => Subscribers and finally Observers displayed to the user.</p>

<p>I really am confused (as you can read), because a lot of answers and descriptions that I found so far use either older patterns (before Angular 5.5?) and/or partially contradict each other.</p>

<p>Do I handle the API-changes in the right place? Has the array for the template's <code>*ngFor</code>-directives to be an Observer (handled with <code>| async</code>) or will the changes of respectively within the array be handled by the model behind the template and the template grabs its new values (with interpolation and property binding) and also directives with a change in the components properties without <code>async</code>ing?</p>

<p><strong>Briefly:</strong>
Is there a for-dummies default instruction to ""stream-read"" values from a http-request into multiple Typescript-objects and their properties concurrently displayed in a template with on-stream-changing directives rendered only in the relevant DOM nodes, the Angular 8 opinionated way? ""Stream-reading"" meaning: pulling and pushing (only) if there are changes in the API, without wasting resources.</p>
","7773582","","7773582","","2019-12-23 17:38:09","2019-12-23 17:38:09","How to map values from JSON-file or REST-response in Angular with service into properties of two (or more) typescript-objects?","<json><angular><rest><httpresponse><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"59468489","1","","","2019-12-24 11:57:16","","-2","90","<p>getModel() method always return array with empty name array even when languages Observable returns value. why?</p>

<pre><code>    export interface Category extends BaseModel {
      code: string;
      name: LocalizedValue[];
      description: LocalizedValue[];
      active: boolean;
    }

    getAllLanguages(): Observable&lt;Language[]&gt; {
       // this return list of languages
    }

    protected getModel(): Category {
    let model: Category = {
      id: '',
      code: '',
      name: [],
      description: [],
      active: false,
    };
    let nameField: LocalizedValue[] = [];
    this.languageService.getAllLanguages().subscribe(list =&gt; {
      list.forEach(l =&gt; {
        let n: LocalizedValue = {
          language: l.code,
          value: '',
        };
        nameField.push(n);
      });
    });
    model.name = nameField;
    return model;
  }
</code></pre>
","663011","","","","","2019-12-24 12:10:30","Observable returning value after method call finished","<angular><rxjs><rxjs-observables>","1","3","","2019-12-29 16:40:02","","CC BY-SA 4.0"
"59509197","1","","","2019-12-28 08:12:16","","0","211","<p>I am taking records from REST API and showing it in input type as a type-ahead feature, where I have to enter at least 3 letters before giving an API call. </p>

<p>This is my HTML code</p>

<pre><code>&lt;mat-form-field&gt;                                
    &lt;mat-label translate&gt;Color&lt;/mat-label&gt;
        &lt;input matInput #coatcolor=""ngModel"" name=""coatcolor [(ngModel)]=""coat.color""
              [resultFormatter]=""productFormatter"" [inputFormatter]=""productInputFormatter""
              [ngbTypeahead]=""productColorSearch"" [editable]=""false"" /&gt;                           
&lt;/mat-form-field&gt;
</code></pre>

<p>This is the response I get from API </p>

<pre><code>[
  { 
     ""color"": ""ALUMINIUM""
  }
]
</code></pre>

<p>This is the Typescript File</p>

<pre><code>  productColorSearch = (text$: Observable&lt;string&gt;) =&gt; {
  return text$.pipe(
  debounceTime(750),
  distinctUntilChanged(),
  switchMap((searchText) =&gt; searchText.length &lt; 3 ? [] : 
  this.facadeService.getProductColorsOnSearch(searchText))
  );
}

productFormatter = (result: any) =&gt; result.color;
productInputFormatter = (result: any) =&gt; result.color;
</code></pre>

<p>Now when I type first three letters I am supposed to get only one record in the drop-down that is ""<strong>ALU</strong>MINIUM""
instead, I am getting all the records including <strong>ALU</strong>MINIUM + other colors below this.</p>

<p>Any help in this appreciated</p>
","9032524","","7177756","","2019-12-28 11:07:59","2019-12-28 11:07:59","Angular 6 / 7 / 8 ngbtypeahead returns matching and non matching records both","<angular><angular-material><typeahead><rxjs-observables>","0","9","","","","CC BY-SA 4.0"
"59620679","1","59634293","","2020-01-07 00:29:14","","-1","213","<p>I'm creating an app that takes a list of apps installed on the device and checks for version updates from the google play store.</p>

<p>This is my method to get the app information based on package name:</p>

<pre><code>    public Observable&lt;DetailsResponse&gt; getUpdates(@NonNull List&lt;ApplicationInfo&gt; apps) {
        return Observable.fromIterable(apps)
            .flatMap(appInfo -&gt; googlePlayApiService.getDetails(appInfo.packageName));
    }
</code></pre>

<p>It works fine if the package is actually on the google play store, but it returns <code>retrofit2.adapter.rxjava2.HttpException: HTTP 404</code> if the package name is not found (ie: sideloaded app)</p>

<p>This is my method to handle the observables:</p>

<pre><code> updatesViewController.getUpdates(apps)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .as(AutoDispose.autoDisposable(ViewScopeProvider.from(this)))
            .subscribe(responseItem -&gt; responseList.add(responseItem),
                    throwable -&gt; responseList.add(null), //404's here, doesn't do the onComplete at all.
                    () -&gt; { // onComplete
                        for (int i = 0; i &lt; apps.size(); ++i) {
                          if (responseList.get(i) != null &amp;&amp; apps.get(i).isLowerVersion(responseList.get(i)) {
                              doSomething();
                          }
                     });
</code></pre>

<p>If all the apps are on the playstore, this works as intended. I want to make it so that if one or more of the apps are <strong>not</strong> found in the playstore, it can still doSomething() on the apps that are found, while ignoring the apps that aren't. Any help is appreciated!</p>
","4822495","","","","","2020-01-08 11:26:16","RxJava - How to make flatmap continue if one of the observables causes an error?","<java><android><rx-java><rx-java2><rxjs-observables>","3","0","","","","CC BY-SA 4.0"
"59620997","1","59656371","","2020-01-07 01:17:55","","0","235","<p>I am new to Angular.  I have a Node and Express backend pulling data from an MS SQL database.  If I go to the endpoint URL it displays my data as JSON.  I am running on localhost so I set a proxy for CORS.  I have a class that defines the data, a service that pulls the data from the endpoint and a component that tries to set an array equal to the data pulled from the service.  The HTML has an *ngFor that is supposed to loop through the values and display them in a grid.</p>

<p>If I call my data in my component through my service, so this.userService.getUsers(), and do a console.log I can see the recordset in the browser console.  I try to set the array equal to the userService.getUsers() and then call the array and I get ""undefined"".  Being that I am new, I have tried to follow the Heroes tutorial and that did not work.  I spent a day searching Google and trying different solutions that I have come across but they all come up as undefined.  I will attach the code here.  If someone can guide me a bit, it would be much appreciated.</p>

<p>User class defining User:</p>

<pre><code>export class User{
    id: number;
    ccn: string;
    firstName: string;
    lastName: string;
    email: string;
}
</code></pre>

<p>User Service doing Http request:</p>

<pre><code>import { Injectable } from '@angular/core';
import { User } from './user';
import { USERS } from './mock-users';
import { MessageService } from './message.service';
import { Observable, of } from 'rxjs';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { catchError, map, tap } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class UserService {

  private userURL = 'api/users'
  //private userURL = 'localhost:5000'

  httpOptions = {
    headers: new HttpHeaders({ 'Content-Type': 'application/json' })
  };

  constructor(
    private http: HttpClient,
    private messageService: MessageService) { }

  //getUsers(): Observable&lt;User[]&gt; {
  //  this.messageService.add('UserService: fetched users');
  //  return of(USERS);
  //}

  /** GET users from the server */
  getUsers(): Observable&lt;User[]&gt; {
    //console.log('getting users');
    return this.http.get&lt;User[]&gt;(""http://localhost:5000/api/user"")
      .pipe(
        tap(_ =&gt; this.log('Fetched users')),
        catchError(this.handleError&lt;User[]&gt;('getUsers', []))
      );
      //return this.http.get&lt;User[]&gt;(""http://localhost:5000/api/user"");
      //console.log('got users');
  }

  /* GET heroes whose name contains search term */
  searchUsers(term: string): Observable&lt;User[]&gt; {
    if (!term.trim()) {
      // if not search term, return empty hero array.
      return of([]);
    }
    return this.http.get&lt;User[]&gt;(`${this.userURL}/?ccn=${term}`).pipe(
      tap(_ =&gt; this.log(`found users matching ""${term}""`)),
      catchError(this.handleError&lt;User[]&gt;('searchUsers', []))
    );
  }

  addUser (user: User): Observable&lt;User&gt; {
    return this.http.post&lt;User&gt;(this.userURL, user, this.httpOptions).pipe(
      tap((newUser: User) =&gt; this.log(`added user w/ id=${newUser.id}`)),
      catchError(this.handleError&lt;User&gt;('addUser'))
    );
  }

  private handleError&lt;T&gt; (operation = 'operation', result?: T) {
    return (error: any): Observable&lt;T&gt; =&gt; {
      console.error(error);

      this.log(`${operation} failed: ${error.message}`);

      return of(result as T);
    };
  }

  private log(message: string) {
    this.messageService.add(`User service: ${message}`);
  }
}
</code></pre>

<p>Display Users Component TS file:</p>

<pre><code>import { Component, OnInit } from '@angular/core';
//import { USERS } from '../mock-users';
import { UserService } from '../user.service';
import { User } from '../user';
import { Observable, of } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';
import { element } from 'protractor';

@Component({
  selector: 'app-display-users',
  templateUrl: './display-users.component.html',
  styleUrls: ['./display-users.component.css']
})
export class DisplayUsersComponent implements OnInit {
  users: User[] = [];

  constructor(private userService: UserService) { }

  //users$ = this.getUsers();

  ngOnInit() {
    this.getUsers();
    console.log(this.userService.getUsers());
    this.userService.getUsers().forEach(element =&gt; {
      console.log(element);
    });
  }

  getUsers(): void {
    /*this.userService.getUsers()
    .subscribe(users =&gt; this.users = users);*/
    const userObservable = this.userService.getUsers();
    userObservable.subscribe((userData: User[]) =&gt; {
      this.users = userData;
    });
  }

}
</code></pre>

<p>Display Users Component HTML:</p>

<pre><code>&lt;div class=""clr-row""&gt;
    &lt;div class=""clr-col-lg-11 clr-col-md-11 clr-col-11 main-div""&gt;
        &lt;div class=""card card-style"" style=""box-shadow: 0 0 0 0;""&gt;
            &lt;div class=""card-header""&gt;
                &lt;h1&gt;&lt;img src=""../assets/images/BSOLOGO_gray.png"" class=""title-img""&gt;&lt;span class=""title""&gt;&amp;nbsp;&amp;nbsp;Users&lt;/span&gt;&lt;/h1&gt;
            &lt;/div&gt;
            &lt;div class=""card-block""&gt;
                &lt;div class=""card-title""&gt;
                    &lt;clr-datagrid&gt;
                        &lt;clr-dg-column&gt;CCN&lt;/clr-dg-column&gt;
                        &lt;clr-dg-column&gt;Last Name&lt;/clr-dg-column&gt;
                        &lt;clr-dg-column&gt;First Name&lt;/clr-dg-column&gt;
                        &lt;clr-dg-column&gt;Email&lt;/clr-dg-column&gt;

                        &lt;clr-dg-row *ngFor=""let user of users""&gt;
                            &lt;clr-dg-cell&gt;{{user.ccn}}&lt;/clr-dg-cell&gt;
                            &lt;clr-dg-cell&gt;{{user.lastName}}&lt;/clr-dg-cell&gt;
                            &lt;clr-dg-cell&gt;{{user.firstName}}&lt;/clr-dg-cell&gt;
                            &lt;clr-dg-cell&gt;{{user.email}}&lt;/clr-dg-cell&gt;
                        &lt;/clr-dg-row&gt;

                        &lt;clr-dg-footer&gt;{{users.length}} users&lt;/clr-dg-footer&gt;
                    &lt;/clr-datagrid&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>Any help would be greatly appreciated!</p>

<p><strong>UPDATED</strong>
<a href=""https://i.stack.imgur.com/vYFmz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vYFmz.png"" alt=""enter image description here""></a></p>
","3793297","","3793297","","2020-01-08 00:16:41","2020-01-09 02:20:14","Observable to Array *ngFor saying undefined","<arrays><angular><rxjs-observables>","3","3","","","","CC BY-SA 4.0"
"59670953","1","","","2020-01-09 19:33:59","","2","291","<p>I had a perfectly running code (and still running perfectly). When I upgraded from angular 7 to angular 8,  my visual studio code started showing errors for HttpClient.get methods. </p>

<p>The errors are coming in the catch part of the HttpClient.get method. Code is compiling fine and working fine as well. I checked angular examples and everything looks correct. I am not sure why editor showing issues. </p>

<pre><code>     getLaborStats(dt: string, hotelId: string): Observable&lt;LaborStats&gt; {
    let lastDayLaborURL = HelloGMVars.varServiceURL + 'laborstats' ;
    const options = { headers: new HttpHeaders().append('AccessToken', this.accessToken)};
       return this.httpC.get&lt;LaborStats&gt;(lastDayLaborURL + '/' + hotelId + '/' + dt, options)
     .pipe(
        catchError(this.handleError('getLastDayLabor', null))
     );
     }
</code></pre>

<p>Here are the errors my editor is showing -</p>

<pre><code>""[ts]
Type 'Observable&lt;LaborStats | Observable&lt;any&gt;&gt;' is not assignable to type 'Observable&lt;LaborStats&gt;'.
  Type 'LaborStats | Observable&lt;any&gt;' is not assignable to type 'LaborStats'.
    Type 'Observable&lt;any&gt;' is not assignable to type 'LaborStats'.
      Property 'today' is missing in type 'Observable&lt;any&gt;'.
(method) Observable&lt;LaborStats&gt;.pipe&lt;LaborStats | Observable&lt;any&gt;&gt;(op1: OperatorFunction&lt;LaborStats, LaborStats | Observable&lt;any&gt;&gt;): Observable&lt;LaborStats | Observable&lt;any&gt;&gt; (+10 overloads)
""
</code></pre>

<p>If I remove the .pipe part, then errors go away. So, it tells me that something is problem in the catchError part. </p>

<p>Here is my error handler -</p>

<pre><code>import { Injectable } from '@angular/core';
import { HttpErrorResponse } from '@angular/common/http';

import { Observable ,  of } from 'rxjs';

import { MessageService } from './message.service';
import { OktaAuthService } from './services/okta-auth.service';

/** Type of the handleError function returned by HttpErrorHandler.createHandleError */
export type HandleError =
  &lt;T&gt; (operation?: string, result?: T) =&gt; (error: HttpErrorResponse) =&gt; Observable&lt;T&gt;;

/** Handles HttpClient errors */
@Injectable()
export class HttpErrorHandler {
  constructor(private okta: OktaAuthService, private messageService: MessageService) { }

  /** Create curried handleError function that already knows the service name */
  createHandleError = (serviceName = '') =&gt; &lt;T&gt;
    (operation = 'operation', result = {} as T) =&gt; this.handleError(serviceName, operation, result);

  /**
   * Returns a function that handles Http operation failures.
   * This error handler lets the app continue to run as if no error occurred.
   * @param serviceName = name of the data service that attempted the operation
   * @param operation - name of the operation that failed
   * @param result - optional value to return as the observable result
   */
  handleError&lt;T&gt; (serviceName = '', operation = 'operation', result = {} as T) {

    return (error: HttpErrorResponse): Observable&lt;T&gt; =&gt; {
      // TODO: send the error to remote logging infrastructure
      console.error(error); // log to console instead

      const message = (error.error instanceof ErrorEvent) ?
        error.error.message :
       `server returned code ${error.status} with body ""${error.error}""`;

      // TODO: better job of transforming error for user consumption
      this.messageService.add(`${serviceName}: ${operation} failed: ${message}`);

      if (error.status === 401) {
        console.log('401 returned so logging out') ;
        this.okta.logout() ;
      }
      // Let the app keep running by returning a safe result.
      return of( result );
    };
  }
}
</code></pre>
","10987869","","10987869","","2020-01-10 14:37:04","2020-01-10 19:55:56","Angular 8 upgrade - typescript error - Type 'Observable<XYZ | Observable<any>>' is not assignable to type 'Observable<XYZ>'","<angular><typescript><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"59726914","1","59789030","","2020-01-14 02:53:41","","0","42","<p>I have found several questions similar to mine, but the big part are related to params, the answers didn't help me to solve my issue. Basically the problem is the following: 
Once the user logs in, the user is able to visualize his/her username in the navbar, when they click on it, the page takes the user to the profile page, the first time it works perfectly, when the user logs out and logs in with different username the information of the old user is still there unless the page is refreshed. </p>

<p>Service Account</p>

<pre><code>getUserInformation(userId: number) {
if (!this.userInformation$) {
  this.userInformation$ = this.http.post&lt;any&gt;(this.baseUrlGetUserInfo, { userId }).pipe(shareReplay());
}
return this.userInformation$;
}
</code></pre>

<p>On init method</p>

<pre><code>ngOnInit() {
this.route.params.subscribe(params =&gt; {
  this.loaderSpinner = true;
  // tslint:disable-next-line: radix
  // this.userId = this.accntService.currentUserId;
  // tslint:disable-next-line: radix
  this.accntService.currentUserId.subscribe(res =&gt; {
    this.userId = res;
  });
  // tslint:disable-next-line: radix
  this.userInformation$ = this.accntService.getUserInformation(parseInt(this.userId));
  this.userInformation$.subscribe(result =&gt; {
    this.userInformation = result.userInformation;
    console.log(this.userInformation);
    this.loaderSpinner = false;
  }, error =&gt; {
    this.loaderSpinner = false;
    console.error(error);
  });
});
}
</code></pre>

<p>Navbar HTML</p>

<pre><code>&lt;a [routerLink]=""['/profile']"" class=""nav-link"" *ngIf=""(userName$ | async) as userName""&gt;
          {{userName}}
        &lt;/a&gt;
</code></pre>

<p>Can somebody help me with this?</p>

<p>Thanks in advance. </p>
","11745278","","","","","2020-01-17 14:09:08","Angular routerLink only triggers ngOnInit once","<angular><typescript><routerlink><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"59794255","1","","","2020-01-17 20:10:53","","2","526","<pre><code> employeeChanged: Subject&lt;any&gt; = new Subject&lt;any&gt;();
 setInterval(() =&gt; {
     this.employeeChanged.next(1);
     this.employeeChanged.next(1);
     this.employeeChanged.next(2);
     this.employeeChanged.next(2);
     this.employeeChanged.next(3);
     this.employeeChanged.next(3);
 },1000);

 this.employeeChanged.pipe(debounceTime(1000),distinctUntilChanged()).subscribe(((key) =&gt; {
            console.log(`Employee update: ${key}`);
 }));
</code></pre>

<p>My example looks like this. I want to get latest value by key that i provide to subject observable so my output looks like this</p>

<pre><code>Employee update: 1
Employee update: 2
Employee update: 3
</code></pre>

<p>Which operator i need to use to achieve that?</p>
","3455079","","","","","2020-01-18 06:38:06","How to get last value of observable by key using debounceTime","<javascript><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"59825456","1","","","2020-01-20 14:35:25","","2","219","<p>I want to know, when to unsubscribe on a Observable Subscription.
And when there is no need to unsubscribe.
It is kind of hard to understand the concept of the subscriptions.</p>
<p>I give you an example:</p>
<pre class=""lang-js prettyprint-override""><code>this.http
    .get(
        environment.baseUrl + &quot;/user/init&quot;,
        this.storageService.getAuthHeader(),
    )
    .subscribe(
        (user: AppUser) =&gt; {
            console.log(user.username);
            this.currentUser = user;
        },
        (err: HttpErrorResponse) =&gt; {
            log(err);
            this.router.navigateByUrl(&quot;/login&quot;);
        },
    )
    .add((teardown: TeardownLogic) =&gt; {
        // this will get called always after the User is retrieved/ subscription is unsubscribed
        console.log(&quot;Unsubscribe automatically ?&quot;);
    });

</code></pre>
<p>in this call I get an Observable. But i get told that I need to manually &quot;unsubscribe&quot; every subscription, after a Component is destroyed.
But no one can clearly explain why.</p>
<p>Also I always get the recommendation to use Pipes (which makes sense I think, when dealing with multiple asynchronous calls which are dependent on each other), but I wonder when to use it, because the whole
<strong>pipe().take(1) ...</strong> call seems hacky or like a <em>workaround</em> &quot;</p>
<p>I also read the documentation about <a href=""http://reactivex.io/rxjs/class/es6/Subscription.js%7ESubscription.html#instance-method-unsubscribe"" rel=""nofollow noreferrer""><strong>Subscriptions</strong> RxJS</a> which doesn't help me that much, but to know, that &quot;teardownLogic&quot; will always be applied after <strong>.unsubscribe()</strong></p>
<p>I also read <a href=""https://stackoverflow.com/questions/51269372/difference-between-the-methods-pipe-and-subscribe-on-a-rxjs-observable"">Difference between the methods .pipe() and .subscribe() on a RXJS observable</a></p>
<p>and</p>
<p><a href=""https://stackoverflow.com/questions/38008334/angular-rxjs-when-should-i-unsubscribe-from-subscription"">Angular/RxJs When should I unsubscribe from `Subscription`</a></p>
<p>which both don't really answer the &quot;mechanics&quot; of Subscription in RxJS / Angular</p>
","8226794","","214143","","2021-01-15 00:23:13","2021-01-15 00:23:13","How and when does a Subscription on an Observable get automatically unsubscribed?","<angular><typescript><rxjs><rxjs-observables>","0","10","","","","CC BY-SA 4.0"
"59827065","1","59827810","","2020-01-20 16:09:39","","0","625","<p>I am trying to go through my JSON object and add specific fields to their own array.</p>

<p>I am trying to iterate through the below object and store the 'appSupportedId' in its own array. </p>

<p>I am getting an ERROR</p>

<p><strong>ERROR</strong></p>

<pre><code> core.js:15714 ERROR TypeError: info.flatMap is not a function
</code></pre>

<p>I have implemented something similar in my code but the only difference with the backend json object is that this below object has a nested array </p>

<p>Any help would be appreciated!</p>

<p><strong>component.ts</strong></p>

<pre><code>userAppDetails:[];

this.incidentService.get(this.id)
  .subscribe((info) =&gt; 
    this.userAppDetails = (info.flatMap(x =&gt; x.applicationsSupported)).contactAll().map(y=&gt; y.appSupportedId))
</code></pre>

<p><strong>JSON OBJECT</strong></p>

<pre><code> ""incidentNumber"": 18817,
 ""Email"": null,
 ""applicationsSupported"": [
    {
        ""appSupportedId"": 18569,           
        ""supportAreaId"": 122,
        ""supportAreas"": {
            ""applicationId"": 122,               
            ""activeFlag"": ""Y"",
        },
        ""appSupportedName"": ""app 1""
    },
    {
        ""appSupportedId"": 18592,          
        ""supportAreaId"": 123,
        ""supportAreas"": {
            ""applicationId"": 123,
            ""activeFlag"": ""Y"",
        },
        ""appSupportedName"": ""app 2""
    },
    {
        ""appSupportedId"": 18655,
        ""supportAreaId"": 122,
        ""supportAreas"": {
            ""applicationId"": 122,
            ""activeFlag"": ""Y"",
        },
        ""appSupportedName"": ""app 3""
    }
],
""createdDate"": ""2020-01-17T18:02:51.000+0000"",
</code></pre>
","8441289","","","","","2020-01-20 16:53:41","Angular observable, how to iterate through an object with nested array to collect fields into an array","<angular><observable><rxjs-observables>","1","4","0","","","CC BY-SA 4.0"
"59834002","1","59934502","","2020-01-21 04:00:15","","0","268","<p>I want to cancel the http request made in RXJS effects in angular 8. </p>

<pre><code>@Effect() getReport$ = this.action$.pipe(
ofType(ActionTypes.GET_WIDGET),   
map(toPayload),
mergeMap(payload =&gt; {
  return this.dashboardService.getReport(payload).pipe(
    map(this.extractData),
    switchMap(result =&gt; {
      return observableOf(&lt;ReceivedWidgetAction&gt;{
        type: ActionTypes.RECEIVED_WIDGET,
        payload: result
      });
    }),
    catchError((err: Response | any) =&gt; {
      return this.handleReportError(err);
    }));

}));
</code></pre>

<p>Please let me know how i can do the same using angular 8. Also please note that I wont be able to use switch map as multiple widgets angular components will be invoking this action with a different payload.</p>
","2935450","","","","","2020-01-27 15:49:07","How cancel angular http request made in RXJS Effects","<angular8><ngrx-store><ngrx-effects><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"59881087","1","59881291","","2020-01-23 14:42:04","","0","35","<p>I have a question about the pipes of the observables</p>

<p>suppose I have the following code:</p>

<pre><code>const skip$ = of(4);
const length$ = of(24);
const schoolId$ = of(1);

const source = combineLatest(skip$, length$, schoolId$).pipe(
  map(([skip, length]) =&gt; `skip: ${skip}, length: ${length}`),
  map(text =&gt; text ) // I need now schoolId, how can i get
);
</code></pre>

<p>in the second map i need the schoolId. How can i get the schoolId without doing this:</p>

<pre><code>const source = combineLatest(skip$, length$, schoolId$).pipe(
  map(([skip, length, schoolId]) =&gt; ({text: `skip: ${skip}, length: ${length}`, schoolId})),
  map(text =&gt; `${text.text}, schoolId: ${text.schoolId}` )
);
</code></pre>

<p>here you have the <a href=""https://stackblitz.com/edit/rxjs-ah5mpp"" rel=""nofollow noreferrer"">stackblitz</a> to try</p>
","10053191","","","","","2020-01-24 10:10:24","Observable pipes","<rxjs><rxjs-pipeable-operators><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"59943284","1","","","2020-01-28 06:34:24","","0","38","<p>I have a an inelegant solution to a problem I'm having looping data from an observable. I would like to know the correct way to do it because this doesn't seem right to me.</p>

<p>I am dynamically creating a form using the response from an api call</p>

<p>This is my component</p>

<pre><code>export class NewProductGeneralComponent implements OnInit, OnDestroy {
  productTitles: [];
  subscription: Subscription;
  startform  = false;
  productDescFormGroup: FormGroup;
  group = {};
  constructor(
    private apiservice: ApiService
  ) { }

  getProductColumns() {
    this.apiservice.getProductTable('/api/products-columns')
      .subscribe( res =&gt;  {
        this.productTitles = res;
        for(const k in this.productTitles) {
          this.group[k] = new FormControl('');
        }
      });
  }

  ngOnInit() {
    this.getProductColumns();
    setTimeout(() =&gt; {
      this.productDescFormGroup = new FormGroup(this.group);
      this.startform = true;
    }, 300);
  }

  ngOnDestroy(): void {
    this.subscription.unsubscribe();
  }

  onSubmit() {
    console.log(this.productDescFormGroup.value);
  }

}
</code></pre>

<p>This is my template</p>

<pre><code>
&lt;ng-container *ngIf=""startform""&gt;
  &lt;form [formGroup]=""productDescFormGroup"" (ngSubmit)=""onSubmit()""&gt;
    &lt;div *ngFor=""let form_elem of productTitles| keyvalue""&gt;
      &lt;div [ngSwitch]=""form_elem.value""&gt;

        &lt;fieldset *ngSwitchCase=""'string'""&gt;
          &lt;label&gt; {{ form_elem.key.replace('_', ' ') }} &lt;/label&gt;
          &lt;input type=""text"" formControlName=""{{form_elem.key}}"" /&gt;
        &lt;/fieldset&gt;

        &lt;fieldset *ngSwitchCase=""'decimal'""&gt;
          &lt;label&gt; {{ form_elem.key.replace('_', ' ') }} &lt;/label&gt;
          &lt;input type=""number"" formControlName=""{{form_elem.key}}"" /&gt;
        &lt;/fieldset&gt;

        &lt;fieldset *ngSwitchCase=""'boolean'""&gt;
          &lt;label&gt; {{ form_elem.key.replace('_', ' ') }} &lt;/label&gt;
          &lt;select formControlName=""{{form_elem.key}}"" &gt;
            &lt;option value=""""&gt;Select Value&lt;/option&gt;
            &lt;option value=""1""&gt;Yes&lt;/option&gt;
            &lt;option value=""0""&gt;No&lt;/option&gt;
          &lt;/select&gt;
        &lt;/fieldset&gt;

      &lt;/div&gt;
    &lt;/div&gt;
    &lt;input type=""submit"" value=""SAVE"" class=""btn btn-sm btn-danger""
    [disabled]=""productDescFormGroup.invalid"" /&gt;
  &lt;/form&gt;
&lt;/ng-container&gt;
</code></pre>

<p>My problem is that if I don't put in a timeout, the formgroup doesn't initialise so on submit nothing comes through plus the submit button is enabled even when the form isn't complete. How do I fix this without using a timeout?</p>
","827920","","","","","2020-01-28 09:35:27","Looping through data from Angular subscription","<angular><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"59960844","1","","","2020-01-29 05:16:22","","0","750","<p>I have several observables and want to combine them to one but want to ignore those which emits errors, I want the operator to emit values for successful observables even if some of them emits an error.</p>

<p>I was looking for operators like concat, forkJoin but when an error occurs they emit it immediately</p>

<pre><code>import { concat, interval } from 'rxjs';
import { take } from 'rxjs/operators';

const timer1 = interval(1000).pipe(take(10));
const timer2 = interval(2000).pipe(take(6));
const timer3 = interval(500).pipe(take(10));

const result = concat(timer1, timer2, timer3);
result.subscribe(x =&gt; console.log(x));

// results in the following:
// (Prints to console sequentially)
// -1000ms-&gt; 0 -1000ms-&gt; 1 -1000ms-&gt; ... 9
// -2000ms-&gt; 0 -2000ms-&gt; 1 -2000ms-&gt; ... 5
// -500ms-&gt; 0 -500ms-&gt; 1 -500ms-&gt; ... 9
</code></pre>
","4640834","","","","","2020-01-29 09:39:54","how to combine observables to one ignoring errors in rxjs","<angular><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"59979077","1","59979091","","2020-01-30 04:27:33","","0","40","<p>I have a local variable and want to use the Observable in our Angular Component just to subscribe to it and store the response locally,but some how its getting undefined always.Any clues why its not assigning?</p>

<pre><code>export class ScheduleHistoryComponent implements OnInit, OnDestroy {

    subscription: Subscription = new Subscription();
    toAccountListDto: any;

    constructor(public paymentService: PaymentService) {}

    ngOnInit(): void {
        this.subscription.add(this.paymentService.getLiteAccountsList()
            .subscribe((res: any) =&gt; {
                this.toAccountListDto = (res.data.accountDtoList);
                this.toAccountListDto = this.toAccountListDto.filter(account =&gt; account.accountSource.toUpperCase() === 'DDA' ||
                    account.accountSource.toUpperCase() === 'SVG');
                console.log('Inside', this.toAccountListDto); &lt; -- --its prints output here
            }, error =&gt; {
                console.error();
            })
        );
        console.log('Outside', this.toAccountListDto); &lt; -- --its prints output as undefined
    }

    ngOnDestroy(): void {
        this.subscription.unsubscribe();
    }

}
</code></pre>
","3552638","","10409167","","2020-01-30 04:34:31","2020-01-30 04:34:31","Angular subscription getting undefined in local variable","<angular><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"60035752","1","","","2020-02-03 08:47:06","","0","45","<p>I am pretty new in Angular2+ and RxJs, so I apologise if I am asking some obvious things. </p>

<h3>Functionality</h3>

<p>When the data is just started to load, <code>startAction</code> is getting emitted, <code>isLoaded</code> turns <code>false</code> and the spinner is getting shown.</p>

<p>Once the data is loaded, <code>endAction</code> is emitted, isLoaded is being set to <code>true</code>. The spinner is getting hide and the main data is depicted.</p>

<p>Once the user clicks another button, another amount of data is getting loaded. <code>startAction</code> is getting emitted again, the spinner to be shown again untill the data is loaded.</p>

<h3>What I have</h3>

<p>In component:</p>

<pre><code>this.startAction.subscribe(() =&gt; {this.isLoaded = false;});
this.endAction.subscribe(() =&gt; {this.isLoaded = true;});
</code></pre>

<p>In template:</p>

<pre><code>&lt;ng-container *ngIf=""isLoaded; else loading""&gt;
  ...data...
&lt;/ng-container&gt;

&lt;ng-template #loading&gt;
  &lt;mat-spinner&gt;&lt;/mat-spinner&gt;
&lt;/ng-template&gt;
</code></pre>

<h3>What I need</h3>

<p>Everything works pretty fine, but I need to rework this approach making it more reactive. I have to get rid of subscribes and turn <code>isLoaded</code> into observable to be able to use it via <code>async</code> pipe in template.</p>

<h3>What I tried</h3>

<p>In component:</p>

<pre><code>isStartLoading = this.startAction.pipe(mapTo(false));
isEndLoading = this.endAction.pipe(mapTo(true));
isLoaded = combineLatest([this.isStartLoading, this.isEndLoading])
  .pipe(takeLast(1)); // does not emit
  //.pipe(last()); // does not emit
  //.pipe(take(1)); // emits only once
</code></pre>

<p>In template:</p>

<pre><code>&lt;ng-container *ngIf=""isLoaded | async; else loading""&gt;
...
</code></pre>

<h3>My explanation</h3>

<p>As per my understanding, <code>takeLast(1)</code> have to emit the last action among <code>isStartLoading</code> and <code>isEndLoading</code>. So when <code>startAction</code> happens, <code>takeLast(1)</code> should emit an observable over <code>false</code>, when <code>endAction</code> - an observable over <code>true</code>.</p>

<p>For some reason I see only the initial spinner, and the result data is not depicted. Looks like I have wrong understanding of how <code>combineLatest</code> + <code>takeLast</code> should work together. </p>

<p>When I added <code>tap(console.log)</code> after <code>takeLast(1)</code> / <code>last()</code>, I saw that it never emits. But when replaced it with <code>take(1)</code>, it expectedly emitted only once. So I saw the spinner, then the data, and then, after clicking another button - newly loaded data with a delay and without spinner, since we taking only the first one.</p>

<p>Any help appreciated!</p>
","6676594","","6676594","","2020-02-03 09:18:36","2020-02-04 22:50:26","rxjs - change single data in two different subscribes - make more reactive","<angular><rxjs><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"60092671","1","60093048","","2020-02-06 10:21:23","","0","160","<p>In my program, I have a few <code>timer(1000).subscribe()</code> instances as well as some <code>timer(1000, 1000).subscribe()</code> parts.</p>

<p>I was experiencing some memory leak issues and was wondering if I could alleviate those by unsubscribing from timers. Unsubscribing from recurring timers seems straight forward and necessary, but <strong>do I also have to unsubscribe from timers that only emit once?</strong></p>

<p>The second part of my question is if there is a better way to unsubscribe from the emitting timer than to put it into a variable like so:</p>

<pre><code>const myTimer = timer(1000).subscribe(() =&gt; {
    myTimer.unsubscribe();
});
</code></pre>

<p>Thanks!</p>
","6892466","","672630","","2020-02-06 10:23:57","2020-02-06 10:39:32","Unsubscribe from observable timers that emit only once necessary?","<node.js><typescript><rxjs><observable><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"60116130","1","","","2020-02-07 15:11:08","","2","303","<p>I have to render a chain of components(say grids in blades) wherein after first component's data is loaded I will click on the data row of that component and it will open the next component. On click of data row of the next component, it will open another component and so on.</p>

<p>Approach that I am following - I have a shared service between all these components and whenever data is loaded for any component, that component calls next method on the BehaviourSubject of my service - <code>this.service.dataLoadedEvent$.next(componentName)</code></p>

<p>My service method looks like -</p>

<pre><code>public renderAllComponents(selectedOption, componentsToRender, componentsInfo): void {
    let componentInstance;

    for (let i = 0; i &lt; componentsToRender.length; i++) {
      componentInstance = new componentsToRender[i](this);

      if (i === 0) {
        // For the component in the first/initial blade
        this.addFirstComponent(componentInstance[i]);
      }
      this.dataLoadedEvent$.subscribe((val) =&gt; {
         if (val === componentsInfo[i].name) {
           componentInstance.onSelect(selectedOption[componentsToRender[i].name]);
         }
      });
    }
  }
</code></pre>

<p>Components look like -</p>

<pre><code> public ngOnInit() {
    this.view = this.comp.pipe(
      tap(state =&gt; {
        this.isLoading = true;
      }),
      switchMap(state =&gt; {
        return this.orderService.fetch(state);
      }),
      tap(() =&gt; {
        this.isLoading = false;
        this.service.dataLoadedEvent$.next(this.constructor.name);
      })
    );
  }
</code></pre>

<p>But the problem here is, the for loop advances before service is notified about the data loading complete. So it sets the loop variable to the last value and the method is called on the last componentInstance which is not the expected behavior. Any help will be appreciated. Thanks in advance ! </p>
","7984313","","7984313","","2020-02-09 10:02:08","2020-02-09 12:07:10","Wait for data of a component to load before rendering the next component - Angular","<angular><typescript><rxjs><angular2-observables><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"60149866","1","60150308","","2020-02-10 11:54:31","","4","874","<p>I have two observable streams which do very separate mapping logic, but then ultimately end with following 3 operators:</p>

<pre><code>  this.selection
    .pipe(
      ..Custom mapping operators
      tap(_ =&gt; this.devicesLoading = true),
      switchMap(d =&gt; this.mapService.findLocationForDevices(d)),
      map(loc =&gt; marker([loc.latitude, loc.longitude])
    )
    .subscribe(markers =&gt; this.plotMarkers(markers));
</code></pre>

<p>I want to move the last <code>tap, switchMap, map</code> operators to a common function so I can just apply these within both of my observable streams.</p>

<p>I thought of doing:</p>

<pre><code>  private resolveLocationsAndConvertToMarkers = (devices: String[]) =&gt; [
    tap(_ =&gt; this.devicesLoading = true),
    switchMap((devices: string[]) =&gt; this.mapService.findLocationForDevices(devices)),
    map(loc =&gt; marker([loc.latitude, loc.longitude])
  ];
</code></pre>

<p>But I wasn't sure how to spread these operators into the pipe arguments, like:#</p>

<pre><code>      this.selection
        .pipe(
          // Custom mapping operators
          ... this.resolveLocationsAndConvertToMarkers
        )
        .subscribe(markers =&gt; this.plotMarkers(markers));
</code></pre>

<p>this errors that <code>there are no overloads that expect 3 or 5 arguments</code>..</p>
","12680986","","","","","2021-08-17 16:28:35","RxJs: Can you spread operators as arguments into pipe operator","<rxjs><rxjs-pipeable-operators><rxjs-observables>","3","0","","","","CC BY-SA 4.0"
"60181723","1","","","2020-02-12 05:31:51","","0","49","<p>Demo: <a href=""https://stackblitz.com/edit/rxjs-unsubscribe-issue?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-unsubscribe-issue?file=index.ts</a></p>

<p><strong>Below code is not working</strong></p>

<blockquote>
  <p>Error: Cannot read property 'unsubscribe' of undefined</p>
</blockquote>

<pre class=""lang-js prettyprint-override""><code>    const a = (): Observable&lt;any&gt; =&gt;
    new Observable(sub =&gt; {
      sub.next(1);
      return () =&gt; {
        console.log('unsubscribe');
      };
    });
    const observer = a().subscribe(
      value =&gt; {
        console.log('Subscription');
        observer.unsubscribe();
      },
      e =&gt; console.log(e),
      () =&gt; console.log('complete')
    );
</code></pre>

<p><strong>But the following code is working</strong></p>

<pre class=""lang-js prettyprint-override""><code>    const b = (): Observable&lt;any&gt; =&gt;
    new Observable(sub =&gt; {
      setTimeout(()=&gt;sub.next(1),0);
      return () =&gt; {
        console.log('unsubscribe');
      };
    });
    const observer2 = b().subscribe(
      value =&gt; {
        console.log('Subscription b');
        observer2.unsubscribe();
      },
      e =&gt; console.log(e),
      () =&gt; console.log('complete')
    );
</code></pre>

<p><em>Help me understand the reason behind it</em></p>
","10120247","","946789","","2020-02-12 05:36:02","2020-02-12 07:54:35","Synchronous RxJs unsubscription not working","<rxjs><observable><subscription><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"60235005","1","60235377","","2020-02-15 00:29:24","","2","4429","<p>I'm trying to accomplish what I had hoped would be a simple &quot;look at the key in Session Storage and update it when it changes&quot; scenario, but Observables really trip me up.</p>
<pre class=""lang-js prettyprint-override""><code>message$ = new Observable(observer =&gt; {
    observer.next(window.sessionStorage.getItem('message'));
});
    
ngOnInit() {
    this.message$.subscribe();
}
</code></pre>
<p>And the message$ is bound to the HTML, pretty straightforward:</p>
<pre class=""lang-html prettyprint-override""><code>&lt;p id=&quot;message&quot;&gt;{{message$ | async}}&lt;/p&gt;
</code></pre>
<p>The <code>Observable</code> will output the text to the <code>HTML</code> if there's already value stored in 'message' but if there's no message on init and then it gets added, or the message value does exist and is updated, nothing happens. I'm obviously doing something wrong, and I would appreciate the insight of someone knowledgeable with <code>Observables</code>.</p>
","184539","","1335789","","2021-07-14 14:26:46","2021-07-14 14:26:46","Using Angular Observable to subscribe to Session Storage key","<angular><rxjs-observables>","3","0","","","","CC BY-SA 4.0"
"60300786","1","60300996","","2020-02-19 12:51:03","","0","133","<p>I'm fairly new to observables and according to <a href=""https://medium.com/angular-in-depth/when-to-subscribe-a83332ae053#d688"" rel=""nofollow noreferrer"">this article</a>. The examples below leaks memory. However, I saw tonnes of tutorials online showing examples like this.</p>

<pre><code>someObservable.subscribe(data =&gt; {
   // do something
});
</code></pre>

<p>Does the code above leak memory? Do we always have to unsubscribe? How about http calls too?</p>

<pre><code>this.http.get&lt;Any&gt;('someurl').subscribe(response =&gt; {
    // do something
});
</code></pre>

<p>What are the general best practices for observables?</p>
","4117450","","","","","2020-02-19 13:02:09","Does this observable leak memory?","<angular><memory-leaks><rxjs><rxjs-observables>","1","2","","2020-02-19 13:06:00","","CC BY-SA 4.0"
"60317291","1","60318194","","2020-02-20 10:01:07","","0","93","<p>I am creating mat-select options using results from Observable but the options are not rendering. When it simple array it is rendering.</p>

<p>Following is the example i build - <a href=""https://stackblitz.com/edit/angular-material-v9-mat-select-with-mat-chip-list-xznxzx?file=src%2Fapp%2Fselect-multiple-example.ts"" rel=""nofollow noreferrer"">See here</a></p>
","12931387","","","","","2020-02-20 11:02:41","Mat Select displaying empty options with Observable","<angular><rxjs><angular-material><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"60418574","1","","","2020-02-26 16:37:53","","0","212","<p>I am using RxJs concatMap to control the saving of some data in my application.</p>

<pre><code>this.myService.saveData(this.updatedData)
  .pipe(
    tap(data1Res =&gt; this.onData1Success(data1Res)),
    concatMap(() =&gt; this.myService.saveOne(this.OneData)),
    tap(data2Res =&gt; this.onData2Success(data2Res)),
    concatMap(() =&gt; this.myService.saveTwo(this.TwoData)),
    tap(data3Res =&gt; this.onData3Success(data3Res)),
    concatMap(() =&gt; this.myService.saveThree(this.ThreeData)),
    tap(data4Res =&gt; this.onData4Success(data4Res)),
    concatMap(() =&gt; this.myService.saveFour(this.FourData)),
  )
  .subscribe(
    res =&gt; this.onSaveSuccess(), // Reload values
    err =&gt; console.log('error while saving', err) // Save to file or db
  );
</code></pre>

<p>Currently this works however it also executes even if say ""this.OneData"" is empty or null...how can I keep it from sending essentially a NoOpp request?</p>
","3557112","","","","","2020-02-27 11:29:02","Using RxJs ConcatMap don't send a value of null or empty string","<angular><rxjs><rxjs5><rxjs6><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"60420842","1","60420889","","2020-02-26 19:05:35","","0","43","<p>I'm trying to wrap my head around using Observables. But I'm struggling. I've googled this for a while, and i can't really decide if the examples i see do what i try to do.</p>

<p>I'll try to explain it, so maybe someone can explain it to me. </p>

<p>I have this http endpoint, to which i post a JSON object. The backend stores it, and returns the persisted object, with an id. Then based on what i get in response here, i need to update the object by calling http endpoint number two.</p>

<p>Let's say service1 is the post or creating the object and service2 is for updating it. I would then do the following: </p>

<pre><code>service1.create(theNewObject).subscribe(response =&gt; {
   service2.update(response).subscribe(secondResponse =&gt; { console.log(secondResponse) })
})
</code></pre>

<p>I am pretty sure that this does what I'm trying to do, but I've read somewhere that doing a subscribe inside another subscribe is not the way to do it. </p>

<p>So my question is.. what do do here, if i can't do it this way? </p>

<p>This is hard to wrap my head around..</p>

<p>Thanks in advance! </p>
","3283978","","","","","2020-02-26 19:30:19","RXJS Nested dependant subscriptions","<rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"60426879","1","","","2020-02-27 05:39:04","","0","59","<p>I have declared a subject in service and tried to push the response got by making a GET call to back end using ""subject.next()""..also assigned an observable for the subject using ""subject.asObservable()"" and subscribed to the observable in two different components(parent and router outlet child). Problem is that the observable is emitting the new value for only one subscriber not for two subscribers. </p>

<p><strong>Service</strong></p>

<pre><code>  subject = new Subject&lt;any&gt;();
  observable = this.subject.asObservable();


 public getDetails(id) {
    return this.http.get(this.url.concat(id))
      .pipe(map(data =&gt; this.extractDetails(data),
            catchError(err =&gt; this.handleError(err)));
  }
 public extractDetails(data){
    this.subject.next(data);
    return data;
  }

</code></pre>

<p><strong>parent component</strong></p>

<pre><code>ngOnInIt(){
 this.hitUrl();

}
getDetails(){
    this.service.observable.subscribe(
      (data: any) =&gt; {
        console.log(data);
      },
      err =&gt; {
        console.error(err);
      }
    )
  }

  hitUrl(id: string) {
    this.service.getDetails(id).subscribe(
      (data: any) =&gt; 
        if(!!data){
            console.log(data);
            this.getDetails();
          }
      },
      err =&gt; {
        console.log(err);
      }
    );
  }

</code></pre>

<p><strong>router-outlet child component</strong></p>

<pre><code>ngOnInIt(){
 this.hitUrl();

}
getDetails(){
    this.service.observable.subscribe(
      (data: any) =&gt; {
        console.log(data);
      },
      err =&gt; {
        console.error(err);
      }
    )
  }

  hitUrl(id: string) {
    this.service.getDetails(id).subscribe(
      (data: any) =&gt; 
        if(!!data){
            console.log(data);
            this.getDetails();
          }
      },ngOnInIt(){
 this.hitUrl();

}
getDetails(){
    this.service.observable.subscribe(
      (data: any) =&gt; {
        console.log(data);
      },
      err =&gt; {
        console.error(err);
      }
    )
  }

  hitUrl(id: string) {
    this.service.getDetails(id).subscribe(
      (data: any) =&gt; 
        if(!!data){
            console.log(data);
            this.getDetails();
          }
      },
      err =&gt; {
        console.log(err);
      }
    );
  }

      err =&gt; {
        console.log(err);
      }
    );
  }


</code></pre>

<p>In the components hitUrl() also triggers when a call to action is performed then i need that observable should emit latest data to both the subscribers(if call to action is performed from parent or router outlet child).</p>
","12970874","","","","","2020-02-27 07:47:20","Rxjs Observable Issue","<angular><typescript><rxjs><rxjs-observables>","1","6","","","","CC BY-SA 4.0"
"60567691","1","","","2020-03-06 16:03:38","","1","160","<p>I have multiple inputs that are created dynamically (Can add or delete inputs). and a text field that shows the sum of the inputs. How can I attach observable dynamically and how can my text subscribe to all of them?</p>

<p>Since I am not able to figure out how to create and attach observables to field or how to access them using their id maybe. I don't have much code to post! Any input ?</p>

<p><strong><em>Function has loop and returns list of obeservables</em></strong></p>

<pre><code>    var source = Rx.Observable.fromEvent(cellVal, 'keyup',(evt) =&gt; evt.target.value).startWith(cellVal.value);
    arr.push(source); 
    }
    return arr;


    values = funct() //calls function that returns array of obervables
    var example = Rx.Observable.combineLatest(values);
    example.subscribe(val =&gt; {
        console.log('Sum:', val);
    });
</code></pre>

<p><a href=""https://i.stack.imgur.com/9t5o5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9t5o5.png"" alt=""The inputs can be created or deleted and sum shud be updated accordingly""></a></p>
","4206540","","4206540","","2020-03-06 16:54:15","2020-03-07 14:27:29","How to update sum from dynamically created inputs?","<javascript><rxjs><rxjs6><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"60569209","1","60570110","","2020-03-06 17:48:58","","0","281","<p>Values is list of obervables over input fields</p>

<pre><code>    var example = combineLatest(values);
</code></pre>

<p>How do I find sum of values in text field.</p>

<pre><code>    example.subscribe(val =&gt; {
        console.log('Sum:', val);
    });
</code></pre>

<p>Having subscriber over it gives me output of the form </p>

<p><em>Sum: (2) [""1"", ""2""]</em></p>

<p>Piping over combineLatest gives me NaN</p>

<pre><code>     .pipe(reduce((acc, one) =&gt; {
         var a =Number(acc) + Number(one);
         console.log(a);
         return a;
     }, 0));
</code></pre>
","4206540","","","","","2020-03-06 19:00:20","How to find sum using reduce, pipe and combinelatest?","<javascript><rxjs><rxjs5><rxjs-pipeable-operators><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"60607260","1","","","2020-03-09 19:35:47","","0","43","<p>Im trying to update this code to version 6 but I cannot figure out how rework the flow, from reading and playing around I think I need to pipe results etc but I cant see how it can be done using the flow of merge, filter, timer, map, first, toPromise() that used to work. Any RxJS folks able to educate me or point me in the right direction ?</p>

<pre class=""lang-js prettyprint-override""><code>const chats: chats[] = &lt;chats[]&gt;await Observable.merge(
  this.chatService.$chats.filter(chats =&gt; chats.length &gt; 0),
  Observable.timer(5000).map(x =&gt; { 
    throw 'Timeout'
  })
).first().toPromise()

if(chats.find( chat =&gt; chat.id === chatId )) {
  this.log.log(`Found active chat ${chatId}, navigating to it from push notification...`)                       
}
</code></pre>
","12903777","","9423231","","2020-03-10 12:31:39","2020-03-10 12:31:39","Converting old RxJS code to v6 : merge, filter, timer, map, first, toPromise()","<rxjs><rxjs5><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"60630878","1","60632009","","2020-03-11 07:12:02","","0","68","<p>I want to Patch the data to my forms after passing the ID to the service and getting the data on my <code>SERVER</code> but I don't get any data. here is my code </p>

<pre><code>addForm: FormGroup;
  ngOnInit(){
    const routesParams=this.routes.snapshot.params;


    this.addForm=this.formBuilder.group({
      Title:['',[Validators.required,Validators.minLength(1)]],
      Body:['',[Validators.required,Validators.minLength(1)]],
      Author:['',[Validators.required,Validators.minLength(1)]],
    })
     console.log(routesParams.post_id);

    this.blogService.getBlogbypost_id(routesParams.post_id).subscribe((data:any)=&gt;{
      this.addForm.patchValue(data);

    });
  }
</code></pre>

<p>code for my <code>service.ts</code></p>

<pre><code>getBlogbypost_id(id:number){
  return this.http.get&lt;cBlog[]&gt;(this.updateUrl+id);
}
</code></pre>

<p>I also get the data on the server but not fetching on <code>subscribe((data: any))</code></p>
","10448700","","4964373","","2020-03-11 07:35:52","2020-03-11 08:36:32","Angular 8 Subscribe not getting the return data from service","<angular><angular2-observables><subscribe><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"60659274","1","","","2020-03-12 17:39:32","","0","143","<p>In my TypeScript app I've reached the point where I have a method that internally does several <code>fromPromise</code> and <code>toPromise</code> operations:</p>

<pre><code>  myMethod(...): Promise&lt;string&gt; {
    return fromPromise(this.someService1.someMethod1(...)).pipe(
      mergeMap(param =&gt; fromPromise(this.someMethod2(...))),
      map(param =&gt; getSomethingFromParam(param)),
    ).toPromise();
  }
</code></pre>

<p>also the <code>someMethod1</code> and <code>someMethod2</code> internally use <code>toPromise</code> and <code>fromPromise</code>.</p>

<p>I understand that if I put it like this, it looks quite messy. However the reason is to have a clean API in every service (e.g. I mostly use the result of <code>someMethod1</code> and <code>someMethod2</code> as promises so I convert their internal observable to a Promise and expose it like this).</p>

<p>I could of course refactor the whole thing, having my services to expose more methods so I can for example call a method that returns me directly an Observable instead of a Promise.</p>

<p>My question is: do I need such a refactor?</p>

<p>In other words: currently my services' APIs are quite clean, they only expose Promises. But I do have to play with <code>fromPromise</code> and <code>toPromise</code> whenever I want to benefit from rxjs operators. So I would like to keep things the way they currently are, unless these operations are expensive  (in terms of performance).</p>
","3497671","","","","","2020-03-12 21:57:38","Rxjs: are the fromPromise and toPromise operations expensive?","<typescript><rxjs><es6-promise><rxjs6><rxjs-observables>","1","0","1","","","CC BY-SA 4.0"
"60662552","1","60662610","","2020-03-12 22:18:50","","1","59","<p>Why are operators <code>tap</code> and <code>map</code> of inner observable not called? <code>combineLatest</code> should subscribe to observables it gets in <code>obsArr</code>, right? Why this subscription does not trigger those operators?</p>

<pre><code>const obsArr = [];

[[1, 2], [3, 4], [5, 6]].map(arr =&gt; {

  const observable = from(arr);

  observable.pipe(
    tap(item =&gt; {
      // this is NOT called
      console.log('tap', item)
    }),
    map(item =&gt; {
      // this is NOT called
      return item * -1;
    })
  );

  obsArr.push(observable);
});

combineLatest(obsArr).subscribe(latestValues =&gt; {
  console.log(latestValues);
  // LOG: [2, 4, 5]
  // LOG: [2, 4, 6]
});
</code></pre>

<p>Working stackblitz: <a href=""https://rxjs-y2h4rn.stackblitz.io"" rel=""nofollow noreferrer"">https://rxjs-y2h4rn.stackblitz.io</a></p>

<p>Thanks for explanation!</p>
","1212547","","","","","2020-03-12 23:09:02","Why operators (tap, map) are not called on inner observable, when using combineLatest?","<javascript><typescript><rxjs><rxjs-pipeable-operators><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"60684347","1","","","2020-03-14 15:29:52","","-2","376","<p>In my app I use rxjs and I have a method that looks like this:</p>

<pre><code>query&lt;T extends TableRow&gt;(queryString: string, silent = false): Observable&lt;T[]&gt; {
  return this.sqliteService.dbQuery&lt;T&gt;(queryString).pipe(
    tap(val =&gt; {
      if (this.configService.debugMode &amp;&amp; !silent) {
        console.log(`\n${queryString}`);
        console.log(val);
      }
    })
  );
}
</code></pre>

<p>My <code>query</code> method interlly calls <code>dbQuery</code> that queries an sqlite database.</p>

<p>Also, the <code>query</code> method is called many times in my app. So I'd like to globally cache the result whenever the <code>queryString</code> is the same.</p>

<p>In other words, I'd like the <code>query</code> method to avoid calling again <code>dbQuery</code> when called with a <code>queryString</code> parameter that has been called before, by returning the previously-cached value.</p>

<p>Not sure if this is relevant: my <code>query</code> method lives in an Angular singleton service.</p>
","3497671","","","","","2020-03-15 09:48:32","Rxjs how to cache the result of an observable for a given argument?","<angular><typescript><rxjs><rxjs6><rxjs-observables>","2","0","1","","","CC BY-SA 4.0"
"60730451","1","","","2020-03-17 21:25:35","","1","940","<p>I have two HTML buttons 'previous' and 'next'. I have different tabs (components) to which I navigate to using these buttons. The code works as expected in Chrome and Firefox but it gives a blank screen when clicking next and previous buttons in IE or Edge.</p>

<p>'next' button event handler:</p>

<pre class=""lang-js prettyprint-override""><code>saveAndNextClick(form: FormGroup, section: string) {
  this.markFormGroupTouched(form);
  if (form) {
    if (section === 'lastsection') {
      this.sectionChangeService.change('schoolSection');
    } else {
      this.hideShowTabSection();
      this.selectedSectionGroup[section] = false;
    }
  }
  this.saveData(); 
  this.saveService.saveQuestion();
}
</code></pre>

<p>Template</p>

<pre><code>&lt;div class=""d-flex app-question-navigation justify-content-between""&gt;
  &lt;a class=""btn btn-secondary buttonSize (click)=""previousClick(appSectionThree,'sectionTwo')""&gt;
    Previous
  &lt;/a&gt;
  &lt;span class=""app-question-pagination""&gt;Section 3 of 8&lt;/span&gt;
  &lt;a class=""btn btn-secondary buttonSize"" (click)=""saveAndNextClick(appSectionThree,'sectionFour')""&gt;
    Next
  &lt;/a&gt;
&lt;/div&gt;
&lt;/form&gt;
</code></pre>

<p>component.ts</p>

<pre class=""lang-js prettyprint-override""><code>ngOnInit() {
  this.sectionChangeService.listen().subscribe((message: any) =&gt; {
    if (message.text === 'prvsparentdemosection') {
      this.saveAndNextClick(this.pdemographicsSectionFive, 'sectionFour');
    }
  });
}

Service:

```typescript
import { Injectable } from '@angular/core';
import { Observable, Subject } from 'rxjs';

@Injectable({ providedIn: 'root' })

export class SectionChangeService {
  private listner = new Subject&lt;any&gt;();

  change(message: string) {
    this.listner.next({ text: message });
  }

  clearListner() {
    this.listner.next();
  }

  listen(): Observable&lt;any&gt; {
    return this.listner.asObservable();
  }
}
</code></pre>
","12287206","","6513921","","2020-03-17 23:46:42","2020-03-18 00:29:31","Observable.subscribe() not working in IE on component change in Angular 7","<javascript><angular><internet-explorer><rxjs><rxjs-observables>","1","3","0","","","CC BY-SA 4.0"
"60762132","1","60763055","","2020-03-19 17:22:19","","0","126","<p>I'm totally clueless about why error is not firing</p>

<p>this is the code where I call the server</p>

<pre><code>this.userService.createUser(values).subscribe((response)=&gt; {
                this.alertService.showConfirm(""Usuario creado"");
                this.dialogRef.close(response);
            }),error =&gt; this.alertService.showError({message: error.error.message}) 
</code></pre>

<p>this error is the one not firing</p>

<p>create user has the following code</p>

<pre><code> createUser(usuario): Observable&lt;boolean&gt;{
    const accessToken  = this.webStorageService.getAccessToken();
    return this.http.post&lt;boolean&gt;(`${this.usersUrl}?access_token=${accessToken}`, usuario,{ headers: this.headers });
</code></pre>

<p>where this.http is HttpClient from AngularCommon and headers is</p>

<pre><code>this.headers = new HttpHeaders().set('Content-Type', 'application/json');
</code></pre>

<p>I have a response interceptor that catch every error response, the important code of the interceptor is the following</p>

<pre><code>return throwError(err);
</code></pre>

<p>because I have the inteceptor only to do something if the http error is 401, but I'm sending a 400 error
I have a console log of err on the interceptor and it catch the error fine, any clue  why doesn't it reach the subscribe? </p>

<p>I've tried to remove the whole interceptor and it does not work too, so I assume is not a interceptor problem </p>
","7447283","","","","","2020-03-19 18:25:19","Subscribe not firing error when the server response with 400 http error","<angular><rxjs><xmlhttprequest><rxjs-observables>","1","4","","","","CC BY-SA 4.0"
"60805149","1","60871576","","2020-03-22 21:25:50","","0","56","<p>I am using RxJS. I have two Observables (API calls) that return a different amount of information for the same array. I want to switch between the Observables and have the subscription recognize both results, i.e. fire each time a value is returned.</p>

<p>Here's an example using Typescript (this does <em>not</em> work):</p>

<pre class=""lang-js prettyprint-override""><code>let foo = [];
const callOne$ = this.service.getSomeData$; // this should take 0.5 seconds
const callTwo$ = this.service.getAllTheData$; // this should take 6 seconds

callOne$.pipe(
    switchMap(data =&gt; data.length &gt; 0 ? callTwo$ : of(data)
).subscribe(data =&gt; {
    console.log(data); // this fires once but I want it to fire twice
    foo = data;
});
</code></pre>

<p>The above example retrieves <code>callOne$</code>, then retrieves <code>callTwo$</code>, and then gives me the result. Instead I want the results of both in order. How would I subscribe to the Observables so that the first result is received and then updated by the second call?</p>
","3357958","","3357958","","2020-03-22 21:31:32","2020-03-26 16:17:14","How do I switch between two Observables in order and have the subscription fire twice?","<rxjs><rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"60872706","1","60872953","","2020-03-26 17:18:02","","0","30","<p>When I select the add button in the patient-allergies.component.ts, select options for the addition of patient allergies and click save, I receive the following error:</p>

<p><strong>ERROR Error: Error trying to diff '[object Object]'. Only arrays and iterables are allowed.</strong></p>

<p>I cannot understand why I am receiving this error as I cast the object to an array when it is passed from the rest-api.service.ts through _patientAllergies.next().</p>

<p>patient-allergies.component.html</p>

<pre><code>&lt;mat-card class=""mat-typography""&gt;
  &lt;mat-card-title&gt;Allergies&lt;/mat-card-title&gt;
  &lt;mat-card-content&gt;
    &lt;hr&gt;
    &lt;div *ngFor=""let patientAllergy of this.patientAllergies""&gt;
      &lt;h3 *ngIf=""!patientAllergy.nickname""&gt; {{ patientAllergy.fullname }} &lt;/h3&gt;
      &lt;h3 *ngIf=""patientAllergy.nickname""&gt; {{ patientAllergy.fullname }} ({{ patientAllergy.nickname }}) &lt;/h3&gt;
    &lt;/div&gt;
  &lt;/mat-card-content&gt;
  &lt;mat-card-actions *ngIf=""isEdit""&gt;
    &lt;button mat-button class=""dark"" (click)=""onAdd()""&gt;ADD&lt;/button&gt;
    &lt;button mat-button class=""dark"" (click)=""onRemove()""&gt;REMOVE&lt;/button&gt;
  &lt;/mat-card-actions&gt;
&lt;/mat-card&gt;

&lt;mat-card *ngIf=""isLoading"" style=""display: flex; justify-content: center; align-items: center""&gt;
  &lt;mat-progress-spinner class=""mat-spinner-color"" mode=""indeterminate""&gt;&lt;/mat-progress-spinner&gt;
&lt;/mat-card&gt;
</code></pre>

<p>patient-allergies.component.ts</p>

<pre><code>import {Component, OnInit, Input, Pipe, PipeTransform} from '@angular/core';
import {RestAPIService} from 'src/app/rest-api.service';
import {ActivatedRoute} from '@angular/router';
import {MatDialog} from '@angular/material';

@Component({selector: 'app-patient-allergies', templateUrl: './patient-allergies.component.html', styleUrls: ['./patient-allergies.component.css']})
export class PatientAllergiesComponent implements OnInit {

    @Input()isEdit : boolean = false;

    constructor(private restAPIService : RestAPIService, private route : ActivatedRoute, public dialog : MatDialog) {}

    isLoading : boolean;
    patientAllergies;
    subscription = null;

    ngOnInit() {
        this.isLoading = true;
        this
            .restAPIService
            .getPatientAllergies(this.route.snapshot.params.id);

        this.subscription = this
            .restAPIService
            .patientAllergies
            .subscribe((patAllergies) =&gt; {
                this.patientAllergies = patAllergies as [];
                this.isLoading = false;
            });
    }

    onAdd() {
        let dRef = this
            .dialog
            .open(AllergiesDialogComponent, {
                disableClose: true,
                height: '800px',
                width: '600px',
                data: {
                    isAdding: true,
                    patientAllergies: this.patientAllergies
                }
            });

        dRef
            .afterClosed()
            .subscribe((res) =&gt; {
                res.forEach((ele) =&gt; {
                    this
                        .restAPIService
                        .addPatientAllergies(this.route.snapshot.params.id, ele.value.allergyID);
                });
            });
    }

    onRemove() {
        let dRef = this
            .dialog
            .open(AllergiesDialogComponent, {
                disableClose: true,
                height: '800px',
                width: '600px',
                data: {
                    isAdding: false,
                    patientAllergies: this.patientAllergies
                }
            });

        dRef
            .afterClosed()
            .subscribe((res) =&gt; {
                res.forEach((ele) =&gt; {
                    this
                        .restAPIService
                        .deletePatientAllergies(this.route.snapshot.params.id, ele.value.allergyID);
                });
            })
    }
}

import {Inject} from '@angular/core';
import {MatDialogRef, MAT_DIALOG_DATA} from '@angular/material';
import {DialogData} from 'src/app/patient/patient.component';

@Component({selector: 'app-allergies-dialog', templateUrl: './allergies-dialog.component.html', styleUrls: ['./allergies-dialog.component.css']})
export class AllergiesDialogComponent implements OnInit {
    allergies = [];
    filterName : string;
    subscription;

    constructor(public dialogRef : MatDialogRef &lt; AllergiesDialogComponent &gt;, @Inject(MAT_DIALOG_DATA)public data : DialogData, private restAPIService : RestAPIService) {}

    ngOnInit() {
        this
            .restAPIService
            .getAllergies();

        if (this.data['isAdding']) {
            this.subscription = this
                .restAPIService
                .allergies
                .subscribe((allergies) =&gt; {
                    let allergiesArr = allergies as [];
                    this.allergies = [];

                    let patientAllergyNames = [];
                    this
                        .data['patientAllergies']
                        .forEach(patientAllergy =&gt; {
                            patientAllergyNames.push(patientAllergy['fullname'])
                        });

                    allergiesArr.forEach(allergy =&gt; {
                        if (!patientAllergyNames.includes(allergy['fullname'])) 
                            this.allergies.push(allergy);
                        }
                    );
                })
        } else {
            this.allergies = this.data['patientAllergies'];
        }
    }

    onClose(selectedOptions) {
        if (this.data['isAdding']) 
            this.subscription.unsubscribe();

        // either [] or the IDs of the objects to add/remove
        this
            .dialogRef
            .close(selectedOptions);
    }
}

@Pipe({name: 'filterOnName'})
export class filterNames implements PipeTransform {
    transform(listOfObjects : any, nameToFilter : string) : any {
        let allergyArr = listOfObjects as[];
        let matchedObjects = [];

        if (!listOfObjects) 
            return null;
        if (!nameToFilter) 
            return listOfObjects;

        allergyArr.forEach(allergyObj =&gt; {
            let fullname : string = allergyObj['fullname'];
            let nickname : string = allergyObj['nickname'];

            let fullnameLower = fullname.toLowerCase();
            let nicknameLower = fullname.toLowerCase();
            let filter = nameToFilter.toLowerCase();

            if (nickname) {
                if ((fullnameLower.includes(filter) || nicknameLower.includes(filter))) 
                    matchedObjects.push(allergyObj);
                }
            else {
                if (fullnameLower.includes(filter)) 
                    matchedObjects.push(allergyObj);
                }
            });

        return matchedObjects;
    }
}
</code></pre>

<p>rest-api.service.ts</p>

<pre><code>    private _allergies;
    private allergiesSubject = new Subject();
    allergies = this
        .allergiesSubject
        .asObservable();

    private _patientAllergies;
    private patientAllergiesSubject = new Subject();
    patientAllergies = this
        .patientAllergiesSubject
        .asObservable();

getPatientAllergies(patientID) {
    const request = {
        headers: {},
        response: true
    };

    API
        .get('DiagnetAPI', '/v1/patients/' + patientID + '/allergies', request)
        .then(resp =&gt; {
            this._patientAllergies = resp.data;
            this
                .patientAllergiesSubject
                .next(this._patientAllergies);
        })
        .catch((err) =&gt; console.log(err))
}

addPatientAllergies(patientID, allergyID) {
    const request = {
        headers: {},
        response: true,
        body: allergyID
    };

    API
        .post('DiagnetAPI', '/v1/patients/' + patientID + '/allergies', request)
        .then(resp =&gt; {
            console.log(resp.data);
            this._patientAllergies = resp.data;
            this
                .patientAllergiesSubject
                .next(this._patientAllergies);
        })
        .then(() =&gt; {
           this.getPatientAllergies(patientID);
        })
        .catch((err) =&gt; console.log(err))
}

deletePatientAllergies(patientID, allergyID) {
    const request = {
        headers: {},
        response: true
    };

    API
        .del('DiagnetAPI', '/v1/patients/' + patientID + '/allergies/' + allergyID, request)
        .then((res) =&gt; console.log(res))
        .then(() =&gt; {
            this.getPatientAllergies(patientID);
        })
        .catch((err) =&gt; console.log(err))
}
</code></pre>
","11841323","","","","","2020-03-26 17:36:54","Why am I receiving the following error when subscribed to the patientAllergies observable?","<node.js><angular><rxjs><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"60949049","1","","","2020-03-31 11:02:41","","0","172","<p>Hi I am learning Angular 8 and as a learner I have many doubts. I am sharing one of my doubts in detail. I hope some of you can easily help and correct me.</p>

<p>I have a service which consumes to Web API and returns some company details like</p>

<pre><code>0: {CompanyId: 1, Name: ""xxxx"", Address: ""bn""}
1: {CompanyId: 2, Name: ""yyyy"", Address: ""tv""}
</code></pre>

<p>service.ts</p>

<pre><code>GetAll(): Observable&lt;IEmployee&gt;{
return this.httpClient.get&lt;IEmployee&gt;(this.apiUrl + ""GetCompany_test"").}
</code></pre>

<p>component.ts</p>

<pre><code>private emp : IEmployee;

getAllEmployees(){
 this.service.GetAll().subscribe(
  response =&gt; {this.emp =response;console.log(response)},
  error =&gt; console.log(error)
  );}
</code></pre>

<p>IEmployee.ts</p>

<pre><code>export interface IEmployee{
fullName:string,
Email:string,
Mobile:string,
City:string,
HireDate:Date
}
</code></pre>

<p>I get the company details even though I use Observable of <code>Observable&lt;IEmployee&gt;</code>. So what is the need of casting here? and when I cast to Employee and I easily get non Employee data,it should so me some warning or error in the console right? I am totally confused about what is happening. </p>

<p>Can somebody please help me to understand the concept of casting here and advice me to correctly use casting.</p>

<p>Regards.</p>
","8486579","","","","","2020-03-31 11:16:34","Type casting issue in Observable in Angular 8","<angular><casting><angular-httpclient><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"60954281","1","60959292","","2020-03-31 15:31:54","","-1","49","<p>I have a angular 8 application and a service, like this:</p>

<pre><code>export class ProfileUserService {
  user$ = this.authService.loginStatus().pipe(take(1));

  constructor(private profileService: ProfileService, private authService: AuthService) {}

  getProfile(): Observable&lt;ProfileApi&gt; {
    return this.user$.pipe(mergeMap(({ profile }) =&gt; this.profileService.get(profile.participant)));
  }
}

</code></pre>

<p>And I have a component where I use the service where I call the method, like this:</p>

<pre><code>export class SettingsAccountComponent extends FormCanDeactivate implements OnInit, OnDestroy {

 constructor(
    private profileUserService: ProfileUserService){}

 ngOnInit() {
    this.innerWidth = window.innerWidth;
    this.profileSubscription = this.profileUserService.getProfile().subscribe((profile: ProfileApi) =&gt; {
      this.profile = profile;
      this.deletePicture = false;
      this.buildForm();
    });
  }




}

</code></pre>

<p>But I want to call directly in the component SettingsAccountComponent : this service:</p>

<pre><code>private profileService: ProfileService
</code></pre>

<p>But the problem is this:</p>

<pre><code> user$ = this.authService.loginStatus().pipe(take(1));
</code></pre>

<p>Because I need that for getting the participantId. But so my question is, how to combine  the ProfileService, like this</p>

<pre><code> this.profileSubscription = this.profileService.get().subscribe((profile: ProfileApi) =&gt; {
      this.profile = profile;
      this.deletePicture = false;
      this.buildForm();
    });
</code></pre>

<p>witht the:</p>

<pre><code> user$ = this.authService.loginStatus().pipe(take(1));
</code></pre>

<p>because now in the get() method it expecs a ParticipantId</p>

<p>So what I have to change? </p>

<p>Thank you</p>
","","user13052269","","","","2020-03-31 20:24:14","How to make from two services one service?","<javascript><angular><typescript><rest><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"60956980","1","","","2020-03-31 17:58:49","","0","536","<p>component controller:</p>

<pre class=""lang-js prettyprint-override""><code>private updateSplitScreenService = () =&gt; {
    this.splitScreenService.emitNewState(this.products);
    this.splitScreenService.emitNewState(this.stores);
};
</code></pre>

<p>splitScreenService:</p>

<pre class=""lang-js prettyprint-override""><code>
// emitNewState is called multiple times in quick succession but
// we want to only fire one API request and return the observable back 
// to the component
public emitNewState = (items: Products[] | Stores[]): void =&gt; {
    // If we already have a debounce active but a new call to emit 
    // the state has come in, cancel the current one.
    if (this.debounceTimeout) {
        clearTimeout(this.debounceTimeout);
    }

    // Create a new timeout
    this.debounceTimeout = setTimeout(() =&gt; {
        this.http.post().subscribe();
    }, 500);
};
</code></pre>

<p>As you can see above I am calling from my component a service function which has a custom ""debounce"" functionality to ensure that an API request will only happen if said function does not get called again within 500ms of the last call. Any call within 500ms will cancel the previously set up debounce function to make an API request and set up a timeout function again to wait and call the API request. This ensures that the API is called only once.</p>

<p>But if I wanted to return the observable of the API request back to my component controller I am running into the issue of how to return it from within the custom debounce/timeout function itself. The goal is to debounce a call so that not only does the subscriber only receive 1 result, but the previous calls were canceled (or not made at all).</p>
","3406930","","3406930","","2020-03-31 20:19:45","2020-03-31 22:03:51","RxJS: Make a single API request from a function which might have been called multiple times","<angular><rxjs><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"60978632","1","","","2020-04-01 19:14:19","","0","251","<p>I have an Angular application (9) and have multiple components that request calculation operations over rest and the displays the result in different editors.
Now before I make the request I call a loading panel and after the request fininished I hide the loading panel in the finalize callback. Something like this:</p>

<pre><code>this.isloading = false;
httpclient.get('http://localhost/calculate').pipe(finalize(() =&gt;this.isloading=false).subscribe(v=&gt;{
 //make some operations with the data and set editor values
});
</code></pre>

<p>now the loading panel disappers before all editor values are set. The finalize callback is called directly if the request fininishes, but how to call something like finalize, if the code inside of subscribe or error finishes?</p>
","1959238","","","","","2020-04-01 19:23:41","Rxjs finalize after code in subscribtion ends","<angular><observable><rxjs6><rxjs-pipeable-operators><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"60984553","1","60985335","","2020-04-02 05:05:39","","0","502","<p>I have a list of Products an array products:Product[]</p>

<p>Using Observable and Observer next method, I want to emit each product to my UI after every 1 second. How can I accomplish this?</p>

<p>This is what I tried , it is producing an infinite loop.Any help will be much appreciated.</p>

<pre><code> public streamAllProducts(): Observable&lt;Product&gt; {
    const products = this.ds.getProducts();

    const sequence = new Observable((observer) =&gt; {

      products.forEach(element =&gt; {


        setTimeout(() =&gt; {
          observer.next(element);
        }, 1000
        );
      });


    });
    return sequence;
  }
</code></pre>
","12397949","","12397949","","2020-04-02 05:14:43","2021-01-08 14:40:14","How to use Observable to emit each value from an array after every 1 second(Angular 5)?","<angular><rxjs><rxjs-observables>","3","0","","","","CC BY-SA 4.0"
"61004814","1","61015275","","2020-04-03 03:48:29","","0","89","<p>To be honest I am a total noob at NGRX and only limited experience in rxjs.  But essentially I have code similar to this:</p>

<pre><code>@Effect()
applyFilters = this.actions$.pipe(
ofType&lt;ApplyFilters&gt;(MarketplaceActions.ApplyFilters),
withLatestFrom(this.marketplaceStore.select(appliedFilters),
  this.marketplaceStore.select(catalogCourses)),
withLatestFrom(([action, filters, courses]) =&gt; {
  return [courses,
    this.combineFilters([
      this.getCourseIdsFromFiltersByFilterType(filters, CatalogFilterType.TRAINING_TYPE),
      this.getCourseIdsFromFiltersByFilterType(filters, CatalogFilterType.INDUSTRIES)
      ])
  ];
}),
map(([courses, filters]) =&gt; {
  console.log('[applyFilters effect] currently applied filters =&gt;', filters);

  console.log('courseFilters', filters);
  const filteredCourses = (courses as ShareableCourse[]).filter(x =&gt; (filters as number[]).includes(+x.id));
  console.log('all', courses);
  console.log('filtered', filteredCourses);

  return new SetCatalogCourses(filteredCourses);
})
);
</code></pre>

<p>Helper method:</p>

<pre><code>private combineFilters(observables: Observable&lt;number[]&gt;[]): number[] {
if (!observables.some(x =&gt; x)) {
  return [];
} else {
  let collection$ = (observables[0]);
  const result: number[] = [];

  for (let i = 0; i &lt; observables.length; i++) {
    if (i &gt;= 1) {
      collection$ = concat(collection$, observables[i]) as Observable&lt;number[]&gt;;
    }
  }

  collection$.subscribe((x: number[]) =&gt; x.forEach(y =&gt; result.push(y)));
  return result;
}
</code></pre>

<p>}</p>

<p>So essentially the store objects gets populated, I can get them.  I know that the observables of 'this.getCourseIdsFromFiltersByFilterType(args)' do work as on the console log of the 'filters' they are there.  But the timing of the operation is wrong.  I have been reading up and am just lost after trying SwitchMap, MergeMap, Fork.  Everything seems to look okay but when I am trying to actually traverse the collections for the result of the observables from the service they are not realized yet.  I am willing to try anything but in the simplest form the problem is this:</p>

<p>Two observables need to be called either in similar order or pretty close.  Their 'results' are of type number[].  A complex class collection that has a property of 'id' that this number[] should be able to include.  This works just fine when all the results are not async or in a component.(I event dummied static values with variables to check my 'filter' then 'includes' logic and it works) But in NGRX I am kind of lost as it needs a return method and I am simply not good enough at rxjs to formulate a way to make it happy and ensure the observables are fully realized for their values from services to be used appropriately.  Again I can see that my console log of 'filters' is there.  Yet when I do a 'length' of it, it's always zero so I know somewhere there is a timing problem.  Any help is much appreciated. </p>
","580428","","","","","2020-04-03 18:22:06","How do I get my observable to have it's values for use in an NGRX effect","<rxjs><ngrx><angular9><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"61007628","1","61007770","","2020-04-03 08:14:09","","0","73","<p>I want to import <code>of</code> from <code>rxjs</code> on my Angular 8.2.3 project.
However, I see that this is present in 2 locations -</p>

<p><code>import { of } from 'rxjs/observable/of';</code></p>

<p><code>import { of } from 'rxjs/internal/observable/of';</code></p>

<p>Which way do I go?</p>
","4327976","","","","","2020-04-03 08:23:20","Importing rxjs modules the right way","<angular><rxjs><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"61023472","1","61024353","","2020-04-04 03:39:37","","3","2756","<p>What is the difference between merge and mergeAll? They both seem identical to me:
<a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeAll"" rel=""nofollow noreferrer"">http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeAll</a>
<a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-merge"" rel=""nofollow noreferrer"">http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-merge</a></p>
","2620860","","","","","2020-04-04 14:17:08","What is the difference between merge and mergeAll?","<rxjs><rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"61023712","1","61043499","","2020-04-04 04:20:01","","0","72","<p>I am trying to find a way to run some code only if there was no error in a given rxjs chain. Consider the following, is there something like the artificial <code>NO_ERROR_OCCURED_RUN_HAPPY_PATH_CODE</code> operator in rxjs?</p>

<pre class=""lang-js prettyprint-override""><code>private wrap(obs: Observable&lt;any&gt;): Observable&lt;any&gt; {
  return of(1).pipe(
    tap(() =&gt; this.spinner.startSpinner()),
    mergeMap(() =&gt;
      obs.pipe(
        NO_ERROR_OCCURED_RUN_HAPPY_PATH_CODE(() =&gt; this.generic_success_popup()),
        catchError(this.handleError),            
      )
    ),
    finalize(() =&gt; this.spinner.stopSpinner())
  );
}
</code></pre>
","7698435","","5583283","","2020-04-05 01:51:03","2020-04-05 13:39:05","How to run some code in an RxJS chain given there were no errors","<rxjs><rxjs-pipeable-operators><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"61025160","1","61025328","","2020-04-04 07:45:20","","0","231","<p>In an angular interceptor, I want to check wether an auth-token exists. If not, it should be refreshed and the request should be resent.</p>

<pre><code>return next.handle(authReq).pipe(map((result: any) =&gt; {
  if (result.body &amp;&amp; result.body.error) {
    if (result.body.error === 'ERR_TOKEN_EXPIRED' || result.body.error === 'ERR_TOKENS_DO_NOT_MATCH') {
      console.log('Token is expired or invalid, refreshing.', result.body.error);

      return this.userService.refreshLoginToken().subscribe(success =&gt; {
        if (success) {
          return this.intercept(req, next);
        }
      });
    }
  }
  return result;
}));
</code></pre>

<p>The Problem is that I don't know how to replace the original Observable returned by next.handle() with a new one. The return statement before <code>this.userService.refreshLoginToken().subscribe()</code> returns a Subscription object. If I just pipe the result of <code>refreshLoginToken()</code> it wont work because refreshLoginToken sends an httprequest which is only executed when there is a subscription.</p>

<p>To reduce the question to a single line:
How can I replace the Observable returned in line 1 by next.handle() with the one returned by <code>this.intercept(req, next)</code>?</p>

<p>Thank you!</p>
","10791391","","","","","2020-04-04 08:07:18","RXJS/Angular Replace Observable","<angular><rxjs><angular-httpclient><angular-http-interceptors><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"61035351","1","61036283","","2020-04-04 21:57:34","","0","217","<p>I am working on a front-end project with Rxjs and Angular Framework and I want to get json data from a api ""api/data_processor_classlib.php...."". There are three parts was subscribed the pipe this.webProtectionHTML$ at HTML. I don't know why the pipe this.webProtectionHTML$ made requests 3 times. Is any possible solution that just sent one request and update all data in HTML? Thanks.</p>

<p>HTML Code:</p>

<pre><code>    &lt;div class=""tr""&gt;
      &lt;div class=""align-left""&gt;Phishing &amp; Other Frauds&lt;/div&gt;
      &lt;div class=""align-right""&gt;{{ (webProtectionHTML$|async)?.phishing}}&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=""tr""&gt;
      &lt;div class=""align-left""&gt;Spam URLs&lt;/div&gt;
      &lt;div class=""align-right""&gt;{{ (webProtectionHTML$|async)?.spamURLs}}&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=""tr""&gt;
      &lt;div class=""align-left""&gt;Malware Sites&lt;/div&gt;
      &lt;div class=""align-right""&gt;{{ (webProtectionHTML$|async)?.malware}}&lt;/div&gt;
    &lt;/div&gt;
</code></pre>

<p>Component:</p>

<pre><code>this.webProtectionHTML$ = this.dayService$
      .pipe(
        mergeMap((days: DaysPeriod // params added to request url) =&gt; this.httpClient.get(`api/data_processor_classlib.php....`//request url, { responseType: 'text' })),
        map((html: string) =&gt; {
          //get html code and find data return as json data
          let result = this.getWebProtectionData(html)
          return result
        }))
</code></pre>

<p>Network log:</p>

<p><a href=""https://i.stack.imgur.com/H4asb.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/H4asb.jpg"" alt=""enter image description here""></a></p>
","12919784","","","","","2020-04-05 12:25:52","How to remove the redundant requests in RXJS?","<angular><rxjs><rxjs5><rxjs6><rxjs-observables>","5","0","1","","","CC BY-SA 4.0"
"61048693","1","61049204","","2020-04-05 20:00:38","","0","50","<p>I have a function as below where I need to make a call to the server and get a value that the function returns. I am using rxjs subscribe. I get the value but since rxjs is async the function returns before the value is obtained from the server. Below is a pseudo code to explain what I am trying to do:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>..

let myValue = getValue();
private getValue(): string {
	let val = '';
    this.httpClient.get('/server url', { observe: ""response"" }).subscribe(res =&gt; {
                val = res.headers.get('X-Some-Header-Name');
            });}
    return val;
}
..</code></pre>
</div>
</div>
</p>

<p>I know that susbscribe returns right away and hence the function getValue does not return the value from the server. Is there a way I can make the function return teh value only when observable returns?</p>
","8491316","","","","","2020-04-05 20:49:18","Using http client to get a value from server and using it for next steps","<javascript><angular><rxjs><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"61065038","1","","","2020-04-06 17:03:02","","2","181","<p>My HTML has the following code:</p>

<pre><code>button (click)=""doFunc()"" 
</code></pre>

<p>In my ts-file I have the following:</p>

<pre><code>doFunc(){
    this.service.executeAFuncWhichIsAsynchronous().subscribe(x =&gt; { updateMyUi(); });
}
</code></pre>

<p>When I click the button twice, two service calls are made. I don't want this to happen. Instead, subsequent clicks should be ignored.</p>

<p>How can I accomplish this?</p>
","13238759","","78972","","2020-04-07 20:09:21","2020-04-07 20:09:21","How do i use rxjs to ignore second,third button click till my first button click process is complete","<rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"61086134","1","","","2020-04-07 17:43:01","","0","65","<p>I am a complete beginner. 
The issue I am having is that once I throw an error in rxjs observable, my test doesn't know about it. When I am subscribing in a test, and it fails within rxjs it just throws an error and I need to notify my test that the error occurred. Here's a more simple example that shows that ""test failed"" is never printed.</p>

<pre><code>import { sample } from ""rxjs/operators"";
const source = interval(1000);
// sample last emitted value from source every 2s
// output: 2..4..6..8..
const example = source.pipe(sample(interval(2000)));
async function test_runner() {
    setup();
    try {
        await test();
        console.log(""test succeeded"");
    } catch (e) {
        console.log(""test failed"");
    }
}
async function setup() {
    console.log(""setup"");
    const subscribe = example.subscribe((val) =&gt; {
        console.log(val);
        if (val === 4) {  throw Error(""error!""); }
    });
}
async function test() {
    console.log(""test"");
    await waitMs(10000);
}

test_runner();

async function waitMs(waitTime: number): Promise&lt;void&gt; {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve();
        }, waitTime);
    });
}
</code></pre>

<p>Is there a way to handle this? I appreciate any help.</p>
","11556744","","","","","2020-04-07 21:01:13","When you subscribe with rxjs, how do you signal to your test if it fails?","<rxjs><rxjs-pipeable-operators><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"61201219","1","61201453","","2020-04-14 05:27:25","","0","608","<p>I have two interfaces, they are Team and Company</p>

<pre><code>public interface Team {
  id: number;
  name: string;
  companyId: number;
}

public interface Company {
  id: number;
  name: string;
}
</code></pre>

<p>This is the sample data:</p>

<pre><code>""companies"": [
    {
      ""id"": 3,
      ""name"": ""XSoftware"",
      ""location"": ""Nagar""
    },
    {
      ""id"": 5,
      ""name"": ""Google"",
      ""location"": ""Seattle""
    },
    {
      ""id"": 7,
      ""name"": ""YS"",
      ""location"": ""Dhanmondi""
    },
    {
      ""id"": 8,
      ""name"": ""Amazon"",
      ""location"": ""Seattle DC""
    },
    {
      ""name"": ""ToTD"",
      ""location"": ""Pink City"",
      ""id"": 10
    }
]
</code></pre>

<pre><code>""teams"": [
    {
      ""id"": 1,
      ""name"": ""Team X"",
      ""expertise"": ""Java"",
      ""companyId"": 3
    },
    {
      ""id"": 2,
      ""name"": ""Team Y"",
      ""expertise"": ""Angular"",
      ""companyId"": 3
    },
    {
      ""id"": 3,
      ""name"": ""Team Z"",
      ""expertise"": ""Spring Boot"",
      ""companyId"": 8
    },
    {
      ""id"": 4,
      ""name"": ""Team M"",
      ""expertise"": ""Node Js"",
      ""companyId"": 5
    }
]
</code></pre>

<p>So I want to assign <strong>company</strong> as property to each team based on <strong>companyId</strong>.
Like this:</p>

<pre><code>""teams"": [
    {
      ""id"": 1,
      ""name"": ""Team X"",
      ""expertise"": ""Java"",
      ""companyId"": 3,
      ""company"": {
         ""id"": 3,
          ""name"": ""XSoftware"",
          ""location"": ""Nagar""
       }
    },
    {
      ""id"": 2,
      ""name"": ""Team Y"",
      ""expertise"": ""Angular"",
      ""companyId"": 3,
      ""company"": {
         ""id"": 3,
          ""name"": ""XSoftware"",
          ""location"": ""Nagar""
       }
    },
    {
      ""id"": 3,
      ""name"": ""Team Z"",
      ""expertise"": ""Spring Boot"",
      ""companyId"": 8,
      ""company"": {
         ""id"": 8,
         ""name"": ""Amazon"",
         ""location"": ""Seattle DC""
       }
    },
    {
      ""id"": 4,
      ""name"": ""Team M"",
      ""expertise"": ""Node Js"",
      ""companyId"": 5,
      ""company"": {
         ""id"": 5,
         ""name"": ""Google"",
         ""location"": ""Seattle""
       }
    }
]
</code></pre>

<p>So how can I achieve this using RxJs.
I have two observables that return Observable of Team[] and Company[] respectively.</p>

<pre><code>const teams$: Observable&lt;Team[]&gt; = this.httpClient.get&lt;Team[]&gt;('/teams');
const companies$: Observable&lt;Company[]&gt; = this.httpClient.get&lt;Company[]&gt;('/companies');
</code></pre>

<p>So, How to do this? I know it can be done in imperative way (by using loops, if-else etc), but I want to do this in reactive way by only using reactive operators, observers. </p>
","7515993","","","","","2020-04-14 05:58:01","How to combine two arrays into a single array using RxJs where 2nd array's each element will be assigned to first arrays each object property?","<arrays><angular><reactive-programming><rxjs6><rxjs-observables>","3","1","","","","CC BY-SA 4.0"
"61202642","1","61218507","","2020-04-14 07:27:58","","2","1393","<p>I have an observable in my angular 8  project, and subscribing in ngOnInit().</p>

<pre class=""lang-js prettyprint-override""><code>     export class ChartComponent implements OnInit {
       urlSubject: Subject&lt;string&gt; = new Subject();
       isLoading: BehaviorSubject&lt;boolean&gt; = new BehaviorSubject(false);
       chartData: BehaviorSubject&lt;any[]&gt; = new BehaviorSubject&lt;any[]&gt;([]);
       dataSubscription: Subscription;

       dataObservable: Observable&lt;any&gt; = this.urlSubject.pipe(
         switchMap((url: any) =&gt; this.httpClient.get&lt;any[]&gt;(url))
       )

       ngOnInit() {
         this.dataSubscription = this.dataObservable
          .pipe(tap(() =&gt; this.isLoading.next(true)))          
          .pipe(map((response: any) =&gt; response.result))      
          .subscribe((response: any) =&gt; this.chartData.next(response),
            () =&gt; this.isLoading.next(false),
            () =&gt; this.isLoading.next(false));

         this.urlSubject.next(this.data.settings.dataEndpoint)
      }
}
</code></pre>

<p>But complate method does not fire of subscribe.</p>

<p>I am subscribing to <code>chartData</code> that type is <code>BehaviourSubject</code>. So I do not subscribe to <code>urlSubject</code>. Because the url may change any time for searh or filter parameters. </p>

<p>I am using finilize but it does not work. I think this problem is about switchmap inner porecess. How can I finilize and set loading to false?</p>
","694716","","13093310","","2020-04-14 09:45:51","2021-08-11 12:54:04","How to finilize rxjs switchmap observable?","<angular><rxjs><angular8><rxjs-observables><switchmap>","2","3","","","","CC BY-SA 4.0"
"61232603","1","61330250","","2020-04-15 15:30:55","","0","82","<p>I have get rest service data call that is called 3 times. I need to create a data service to reduce the call to once so it keeps a local copy.if the copy hasn't been populated yet, it hits the api to get them. it should do this only once. So,  need a bool  that indicates the status of the get call.
If not already making a call to get data, toggle the bool and get the data. 
I know this can be done if 
The component would subscribe to observable, and when the data service had data, it would provide it via the BehaviorSubject. BUt not sure how to implement it because i havent worked with observables and behaviour subject. Any guidance on this is appreciated. Thanks.</p>

<p>Here is my sample stackblitz 
<a href=""https://stackblitz.com/edit/angular-sqxp9e?file=src%2Fapp%2Fnotifications-data.service.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-sqxp9e?file=src%2Fapp%2Fnotifications-data.service.ts</a></p>
","13041945","","","","","2020-04-20 19:15:12","behaviour subject and observable in Angular8","<angular><angular8><rxjs5><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61246830","1","61247009","","2020-04-16 09:23:10","","0","100","<p>I am getting the following error in my services file, suggest the changes in the code:-</p>

<p><em>Property 'map' does not exist on type 'Observable[]>'.</em></p>

<p>My Event.ts contains an interface with 5 declared parameters which are id: string; code: string; name: string; password: string; pollCat: string;</p>

<p>events.service.ts:-</p>

<pre><code>import { Injectable } from '@angular/core';
    import { AngularFirestore , AngularFirestoreCollection, AngularFirestoreDocument} from 'angularfire2/firestore';
    import { Event } from '../models/Event';
    import { Observable } from 'rxjs';
    import {map} from 'rxjs/operators';


    @Injectable({
      providedIn: 'root'
    })
    export class EventsService {

      eventsCollection : AngularFirestoreCollection&lt;Event&gt;;
      events: Observable&lt;Event[]&gt;;

      constructor(public afs: AngularFirestore) { 
        this.events = this.afs.collection&lt;Event&gt;('Events').snapshotChanges().map(changes =&gt; {
          return changes.map(a =&gt; {
            const data = a.payload.doc.data() as Event;
            data.id = a.payload.doc.id;
            return data;
          })
        });
      }

      getEvents()
      {
        return this.events;
      }
    }
</code></pre>

<p>events.component.ts:-</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { EventsService } from 'src/app/services/events.service';
import { Event } from '../../models/Event';


@Component({
  selector: 'app-events',
  templateUrl: './events.component.html',
  styleUrls: ['./events.component.css']
})
export class EventsComponent implements OnInit {

  events: Event[];

  constructor(public eventsService: EventsService) { }

  ngOnInit() {
    this.eventsService.getEvents().subscribe(events =&gt; {
      this.events = events;
      console.log(events);
    });
  }
}
</code></pre>
","13321892","","","","","2020-04-16 09:32:34","Property 'map' does not exist on type 'Observable<DocumentChangeAction<Event>[]>'","<angular><firebase><rxjs><angular9><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"61295392","1","","","2020-04-18 19:56:44","","0","136","<p>I'm quite new to RXJS and development in general. I started working with rxjs recently and I found myself stuck with the following issue and I would appreciate some help/ guidance and some explanation please.</p>

<pre><code>    export const updateSomethingEpic1 = (action$) =&gt;
 action$
    .ofType('UPDATE_SOMETHING')
    .switchMap(({ result }: { result }) =&gt;
      //SOME API CALL
        .map(({ response }) =&gt; updateSomethingSuccess(response)) 

         **make call to second epic**

        .catch(err =&gt; updateSomethingError(err)),
    );


      //My second epic

        export const updateSomethingEpic2 = (action$) =&gt;
 action$
    .ofType('UPDATE_SOMETHING2')
    .switchMap(({ result }: { result }) =&gt;
      //SOME API CALL
        .map(({ response }) =&gt; updateSomethingSuccess2(response))
        .catch(err =&gt; updateSomethingError2(err)),
    );
</code></pre>

<p>My question is how would I make a call to my second epic after my first epic has called the api and made a successful request. Want to make a call in the first epic after <code>updateSomethingSuccess</code> action, which adds response to the store and then call the second api afterwards.</p>
","4118441","","4118441","","2020-04-18 20:16:12","2020-04-18 20:16:12","Call another epic inside one epic RXJS","<javascript><react-redux><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61353881","1","","","2020-04-21 21:49:36","","0","190","<p>Taking example of HeroService from angular documentation. </p>

<p>Below is a POST method in HeroService </p>

<pre><code>addHero (hero: Hero): Observable&lt;Hero&gt; {
    return this.http.post&lt;Hero&gt;(this.heroesUrl, hero, httpOptions)
           .pipe(
            catchError(this.handleError('addHero', hero))
            );
   }
</code></pre>

<p>We can see that every time addHero is called a new Observable is returned.</p>

<p>Ok now here is the service call from HeroComponent</p>

<pre><code>this.heroesService
  .addHero(newHero)
  .subscribe(hero =&gt; this.heroes.push(hero));
</code></pre>

<p>Now In my component this add hero service call is happening very frequently one after another.
Each addHero call is returning a new Object of Observable and it is being subscribed.</p>

<p>My question is what is the correct way of subscribing to this service in my use case where addHero is frequently being called one after another 1000 of times.</p>

<p>I should be calling the hero service like this</p>

<pre><code>addHero(){
  this.heroesService
  .addHero(newHero)
  .subscribe(hero =&gt; this.heroes.push(hero));
}
</code></pre>

<p>Or I should call the hero service like this, so that only one observable object is created for each call </p>

<pre><code>const req = this.heroesService.addHero(newHero);

addHero(){
  req.subscribe(hero =&gt; this.heroes.push(hero));
}
</code></pre>

<p>What is the difference between both approaches apart from that only one object of Observable is created in second approach.
Also what are the disadvantages or advantages of both the approaches.</p>

<p>For my scenario which is the correct implementation ? Does the second approach makes any difference ? What will happen in terms of memory leak if I go with the first approach ?</p>
","2327445","","","","","2020-04-22 13:20:38","How to correctly subscribe Angular HttpClient Observable?","<angular><memory-leaks><rxjs><angular-httpclient><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"61399384","1","","","2020-04-24 01:00:46","","0","80","<p>I want to send a bulk of data and after completing it, want to move to the next one. For example: 
I have this function: </p>

<pre><code>async function test() {
  await sample.sampleStructure()
  await sample.sampleDataAdd()
  await sample.sampleDataGet()
}
</code></pre>

<p>Where I am calling the 3 functions for each call. But I wanted to send for example 200 data for <code>await sample.sampleDataAdd()</code> and if the first 200 data response is 'Success' then it will send the rest of the 200 datas. After completing 1000 datas, I want to move on to the next function call.
So I looked and I think RXJS can provide the solution. But I am not use if is it possible to use the filter and next for this scenario. </p>

<pre><code>async function test() {
  await sample.sampleStructure()
  // let observable = Observable.range(1,1000)
  let observable = Observable.create()
  observable
  .filter(aysnc function () {
    await sample.sampleDataAdd()
   })
  .subscribe({
    .next: async function () {
       // await sample.sampleDataAdd()
    },
    .error: function (error) {
      console.log(error)
     }
   })
</code></pre>

<p>I am very new at rxjs, so there are lots of mistakes as well. Please can anyone help me regarding this matter ? </p>
","12882502","","","","","2020-04-28 12:10:11","Bulk data call using RXJS in nodejs","<javascript><node.js><rxjs><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61404986","1","61406607","","2020-04-24 09:16:42","","2","501","<p>I have two Observables. The rendering of the template should only start when <strong>BOTH</strong> Observables are completed or failed:</p>

<ul>
<li>Observable 1 completes and Observable 2 completes or</li>
<li>Observable 1 completes, but Observable 2 fails</li>
<li>When Observable 1 fails Observable 2 is not important because the template won't be rendered completely then</li>
</ul>

<p>(Ignore the <code>&lt;any&gt;</code> type, it's only for simplification here)</p>

<p>Component:</p>

<pre class=""lang-js prettyprint-override""><code>@Component({
  selector: 'app-page',
  templateUrl: './page.component.html',
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class PageComponent implements OnInit {
  obs1$ = new Subject&lt;any&gt;();
  obs2$ = new Subject&lt;any&gt;();

  isLoading = true;
  isObs1Error: boolean;
  isObs2Error: boolean;


  ngOnInit() {
    this.initializeDataRetrieval();
  }

  initializeDataRetrieval() {
    this.obs1$ = this.obs1Method();
    this.obs1$.subscribe((response: any) =&gt; {
      this.isObs1Error = false;
      this.obs1 = response;

      this.obs2$ = this.obs2Method();
      this.obs2$.subscribe((response: any) =&gt; {
        this.isObs2Error = false;
        this.isLoading = false;
        this.obs2 = response;
        this.cdr.detectChanges();
      });
    });
  }

  private obs1Method(): any {
    return this.obs1Service
      .getStuff()
      .pipe(
        catchError(() =&gt; {
          this.isError = true;
          this.isLoading = false;
          this.cdr.detectChanges();
          return EMPTY;
        })
      );
  }

  private obs2Method(): any {
    return this.obs2Service
      .getStuff()
      .pipe(
        catchError(() =&gt; {
          this.isObs2Error = true;
          this.isLoading = false;
          this.cdr.detectChanges();
          return EMPTY;
        })
      );
  }

  canDisplayContent(): boolean {
    return !this.isLoading &amp;&amp; !this.isObs1Error;
  }

</code></pre>

<p>Template:</p>

<pre class=""lang-html prettyprint-override""><code>&lt;ng-container *ngIf=""isLoading""&gt;
  &lt;app-loading-indicator&gt;&lt;/app-loading-indicator&gt;
&lt;/ng-container&gt;

&lt;ng-container *ngIf=""isObs1Error""&gt;
  &lt;div class=""error""&gt;
    This Obs1 stuff could not be loaded currently
  &lt;/div&gt;
&lt;/ng-container&gt;

&lt;ng-container *ngIf=""canDisplayContent()""&gt;
  &lt;div class=""error"" *ngIf=""isObs2Error""&gt;
    Technical error
  &lt;/div&gt;
  More content here which is shown when at least Obs1 doesn't had an error
&lt;/div&gt;
</code></pre>

<p>So basically:</p>

<ul>
<li>I wanna wait with template rendering until both Observables are done and display a loading indicator during the time</li>
<li>When there is an error with Obs1 then show a message</li>
<li>When there is an error with Obs2 then render the 3rd <code>ng-container</code> with the Obs2 error message</li>
</ul>

<p>I'm sure the TS code can be simplified by the usage of ... which RxJS operator? Although reading through <a href=""https://scotch.io/tutorials/rxjs-operators-for-dummies-forkjoin-zip-combinelatest-withlatestfrom"" rel=""nofollow noreferrer"">RxJS Operators for Dummies: forkJoin, zip, combineLatest, withLatestFrom</a> I'm not sure if any of these fits. As far as I understood e.g. <code>combineLatest</code> only succeeds when both streams complete successfully ...</p>

<p>Any hint is welcome, thanks.</p>
","13076470","","542251","","2020-04-24 10:32:09","2020-04-24 10:48:22","Wait for two observables (incl. failed one) before rendering template","<angular><rxjs><observable><angular-observable><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"61423790","1","61423823","","2020-04-25 09:48:18","","0","574","<p>I use <code>combineLatest</code> to get latest values from each observables:</p>

<pre><code>combineLatest$ = combineLatest(_block$, _field$);
    combineLatest$.subscribe(() =&gt; {
      console.log(""Completed..."");
    });
</code></pre>

<p>Then I have another observable that works until <code>forkJoin$</code> sends data:</p>

<pre><code>of(true).pipe(delay(1000), takeUntil(combineLatest$)).subscribe(() =&gt; console.log());
</code></pre>

<p>How to complete <code>combineLatest$</code>? And should I unsubscribe from <code>of()</code> or it will be destroyed automaticaly?</p>
","","user13295902","","user13295902","2020-04-25 09:55:27","2020-04-25 16:34:36","How to complete combineLatest?","<rxjs><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"61427736","1","61428070","","2020-04-25 15:04:48","","0","48","<p>I'm here thinking about observables ..</p>

<p>And I imagined the following situations:</p>

<p><strong>Example 1)</strong>
In my case when I use <code>NGRX</code> I create all the architecture correctly, and I create a selector service for that particular store.</p>

<p>In the service it is not possible to use ngOnDestroy because it is not a component and I have the following question, is there a memory leak in a service? Or does this service automatically destroy observables?</p>

<p><strong>Example 2)</strong>
Using the selectors in example one, is it necessary to subscribe to this selector and then destroy it?</p>

<p><strong>PEOPLE-SELECTORS.SERVICE</strong></p>

<pre><code>@Injectable({ providedIn: 'root' })
export class PeopleSelectorsService {
    constructor(private readonly store: Store&lt;StoreState&gt;) {}

    get error(): Observable&lt;IRequestError&gt; {
        return this.store.pipe(select(fromPeopleSelectors.getError));
    }

    get loading(): Observable&lt;boolean&gt; {
        return this.store.pipe(select(fromPeopleSelectors.getLoading));
    }

    get main(): Observable&lt;IPeople&gt; {
        return this.store.pipe(select(fromPeopleSelectors.getMain));
    }

    get total(): Observable&lt;number&gt; {
        return this.store.pipe(select(fromPeopleSelectors.selectTotal));
    }

    get all(): Observable&lt;Array&lt;IPeople&gt;&gt; {
        return this.store.pipe(select(fromPeopleSelectors.selectAll));
    }

    get allIds(): Observable&lt;Array&lt;string | number&gt;&gt; {
        return this.store.pipe(select(fromPeopleSelectors.selectIds));
    }
}
</code></pre>

<p><strong>APP.COMPONENT</strong></p>

<pre><code>    ngOnInit(): void {
        this.peopleDispatchService.getAll();
        this.isLoading$ = this.peopleSelectorsService.loading;
}

&lt;main [attr.isLoading]=""isLoading$ | async""&gt;
    &lt;ng-container&gt;&lt;/ng-container&gt;
    &lt;app-loading-container *ngIf=""isLoading$ | async; else isMainController""&gt;&lt;/app-loading-container&gt;

    &lt;ng-template #isMainController&gt;
        &lt;app-user-talk-controller-container&gt;&lt;/app-user-talk-controller-container&gt;
        &lt;app-user-talk-container&gt;&lt;/app-user-talk-container&gt;
    &lt;/ng-template&gt;
&lt;/main&gt;
</code></pre>
","","user11472365","","","","2020-04-25 15:33:16","Is it necessary to subscribe and remove observables it in these cases?","<angular><rxjs><ngrx><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"61428404","1","","","2020-04-25 15:53:00","","0","23","<p>I have 2 components on my app: filters-component and card-component.
On the filters-component I added a routing method for data filtering based on country selector anchor.</p>

<p>Filters-component:
<div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import { Component, OnInit } from '@angular/core';
import { TestimonialsDataService } from '../../services/testimonials-data.service';
import { Router,  ActivatedRoute, ParamMap } from '@angular/router';

@Component({
  selector: 'app-filters',
  templateUrl: './filters.component.html',
  styleUrls: ['./filters.component.scss']
})
export class FiltersComponent implements OnInit {
  public filters = [];
  public filterId;

  selectedIndex: number = null;

  constructor(private router: Router, private route: ActivatedRoute, private _testimonialsService: TestimonialsDataService) { }

  ngOnInit(): void {
    this._testimonialsService.getData().subscribe(data =&gt; this.filters = data);
    this.route.paramMap.subscribe((params: ParamMap) =&gt; {
      let id = parseInt(params.get('id'));
      this.filterId = id;
    });
  }

  onSelect(country) {
    this.router.navigate(['/country', country.id]);
  }
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;div class=""container filters""&gt;
  &lt;p&gt;{{filters[""filtersTitle""]}}&lt;/p&gt;

  &lt;ul class=""filter-wrap"" *ngIf=""filters['filtersData']""&gt;
    &lt;li class=""filter-item"" *ngFor=""let filter of filters['filtersData']"" (click)=""onSelect(filter)""&gt;
      &lt;a id=""{{filter.id}}"" class=""filter""&gt;
        &lt;span class=""flag flag-{{filter.id}}""&gt;&lt;/span&gt;
        &lt;span class=""flag-text""&gt;{{filter.id}}&lt;/span&gt;
      &lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
</p>

<p>Card component: </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import { Component, OnInit } from '@angular/core';
import { TestimonialsDataService } from '../../services/testimonials-data.service';
import { Router,  ActivatedRoute, ParamMap } from '@angular/router';

@Component({
  selector: 'app-card',
  templateUrl: './card.component.html',
  styleUrls: ['./card.component.scss']
})
export class CardComponent implements OnInit {
  public authors: Object = {};
  public pageList: number = 1;

  constructor(private _testimonialsService: TestimonialsDataService) { }

  ngOnInit(): void {
    this._testimonialsService.getData().subscribe(data =&gt; this.authors = data);
  }
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;div class=""container""&gt;
  &lt;div class=""content""&gt;
    &lt;div class=""card"" *ngFor=""let author of authors['user'] | paginate: {id: 'list-pagination', itemsPerPage: 9, currentPage: pageList}""&gt;
      &lt;div class=""card-content""&gt;
        &lt;img class=""image"" src=""{{author.image}}""/&gt;
        &lt;p class=""author""&gt;{{author.name}}&lt;/p&gt;
        &lt;p class=""job""&gt;{{author.job}}&lt;/p&gt;
        &lt;p class=""company""&gt;&lt;a href=""https://www.materahub.com/""&gt;{{author.company}}&lt;/a&gt;&lt;/p&gt;
        &lt;p class=""country""&gt;&lt;span class=""flag flag-{{author.country}}""&gt;&lt;/span&gt;&lt;span class=""country""&gt;{{author.country}}&lt;/span&gt;&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;pagination-controls id=""list-pagination"" previousLabel="""" nextLabel="""" class=""list-pagination"" directionLinks=""true"" (pageChange)=""pageList = $event""&gt;&lt;/pagination-controls&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
</p>

<p>Basically what I want to achieve here is this:
Click on the <code>&lt;li class=""filter-item"" *ngFor=""let filter of filters['filtersData']"" (click)=""onSelect(filter)""&gt;</code> the url goes like: country/DE or country/IT</p>

<p>on the card component I want to display the data that matches the /DE or /IT based on the  card</p>

<p>I load all the cards at page start but I have to be <strong>able to filter them based on the country selector</strong></p>

<p>Image: 
<a href=""https://i.stack.imgur.com/tptfY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tptfY.png"" alt=""App info""></a></p>
","8449805","","","","","2020-04-26 06:40:39","Display data based on routing on the first component from the second component","<angular><routes><components><angular9><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"61449225","1","61840586","","2020-04-26 22:58:30","","1","872","<p>I have pretty much the same question as in <a href=""https://stackoverflow.com/questions/49555931/ngrx-get-value-in-function"">ngrx get value in function</a> , but I'm wondering if the answer (see comment in that topic) is still the best practice nowadays.</p>

<p>My situation is:</p>

<ol>
<li>I want to get 2 values from the store to show in my component --> I use a selector and the async pipe</li>
<li>I need to pass those same values to an Angular Material dialog, to work with them in the dialogcomponent.</li>
</ol>

<p>I have a working solution: I use subscribe functions in ngOnInit() and set a local variable with the value from the Observable. So I don't need to use the async pipe anymore and I can easily pass the value to some functions... This one sounds like the best option, but everywhere I look for answers I see ""avoid using subscriptions"".</p>

<p>So I'm wondering: </p>

<ul>
<li>is there a better way of handling this scenario? </li>
<li>Or is this ""the ngrx/rxjs way of handling this scenario""?</li>
<li>Or do I use the selector Observable and async pipe to show the value in the component AND subscribe to the Observable to create a local variable to pass to my function (this seems a bit redundant...)</li>
<li>Or ...?</li>
</ul>

<p>My problem is that I want a consistent approach of handling ngrx values, but now it looks like I need to use 2 approaches depending on the scenario:</p>

<ul>
<li>Async pipe for showing values in component (preferred approach according to the community)</li>
<li>Subscription when using values in local functions (community advises against the use of subscriptions ""unless necessary"")</li>
</ul>

<p>(To my surprise: it's hard to find a clear answer on the internet ...)</p>
","2546179","","2546179","","2020-05-10 09:56:58","2020-05-16 17:07:14","Angular + Ngrx : best practice to select a value in component and in function","<angular><redux><ngrx><rxjs-observables><angular-ngrx-data>","1","0","","","","CC BY-SA 4.0"
"61458533","1","","","2020-04-27 12:06:47","","0","59","<p>The <a href=""https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/switch.md"" rel=""nofollow noreferrer"">switch</a> documentation on github contains an example on how to use the command. </p>

<pre><code>var source = Rx.Observable.range(0, 3)
.select(function (x) { return Rx.Observable.range(x, 3); })
.switch();

var subscription = source.subscribe(
function (x) {
    console.log('Next: ' + x);
},
function (err) {
    console.log('Error: ' + err);
},
function () {
    console.log('Completed');
});
</code></pre>

<p>I've tested the code at <a href=""https://stackblitz.com/edit/rxjs-vmvjni?file=index.ts"" rel=""nofollow noreferrer"">stackblitz</a> but the output differs. Instead of</p>

<pre><code>Next: 0
Next: 1
Next: 2
Next: 3
Next: 4
Completed 
</code></pre>

<p>the console logs</p>

<pre><code>Next: 0
Next: 1
Next: 2
Next: 1
Next: 2
Next: 3
Next: 2
Next: 3
Next: 4
Completed
</code></pre>

<p>Can somebody explain?</p>
","3443820","","3443820","","2020-04-29 14:24:57","2020-05-24 17:55:10","Confusion using Observable.switch","<rxjs5><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61466116","1","61466353","","2020-04-27 18:44:09","","1","1099","<p>Angular experts! I'm trying to understand async pipes in Angular, but I'm stuck in a basic scenario. I have two select elements in the UI, one containing posts and one containing related comments. I want to set a posting (the last one) as the initially selected one for the select element displaying posts, and I want to use the selected item to filter related comments in the second select. This is not working in my code, for which I have created a simplified version in Stackblitz: </p>

<p><a href=""https://stackblitz.com/edit/angular-p6ynuy"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-p6ynuy</a></p>

<p>Can any of you explain to me what I'm doing wrong? This is the relevant code fragment and HTML:</p>

<pre><code>ngOnInit() {
    this.postList$ = this.getPostList();

    // latestPost$ is not is use yet, but maybe it could be used to set the selected post?
    this.latestPost$ = this.postList$ 
      .pipe(
        map(posts =&gt; posts[posts.length - 1])
      );

    this.selectedPost$ = combineLatest([
      this.postList$,
      this.postSelectedAction$
    ])
      .pipe(
        map(([posts, selectedPostId]) =&gt; posts.find(post =&gt; post.id === selectedPostId))
      );

    this.commentList$ = this.selectedPost$
      .pipe(switchMap(
        post =&gt; this.getCommentList(post)
      ));
  }


&lt;select [ngModel]=""selectedPost$ | async"" (change)=""onSelected($event.target.value)""&gt;
  &lt;option *ngFor=""let post of postList$ | async"" [ngValue]=""post""&gt;
    {{post.id}} {{post.title}}
  &lt;/option&gt;
&lt;/select&gt;
&lt;select&gt;
  &lt;option *ngFor=""let comment of commentList$ | async"" [ngValue]=""comment""&gt;
    {{comment.id}} {{comment.postId}} {{comment.name}}
  &lt;/option&gt;
&lt;/select&gt;
</code></pre>
","5974555","","","","","2020-04-27 18:57:22","Setting selected item of a select element using async pipes in Angular","<angular><rxjs><rxjs-observables><async-pipe>","1","0","0","","","CC BY-SA 4.0"
"61486807","1","61487012","","2020-04-28 17:56:31","","0","160","<p>I am studying angular now. When it comes to data sharing using service, many are recommending that we should use <a href=""https://fireship.io/lessons/sharing-data-between-angular-components-four-methods/"" rel=""nofollow noreferrer"">Subject like BehaviorSubject</a>.
But should we do it all the time?</p>

<pre><code>@Injectable({
  providedIn: 'root'
})
export class DataService {

  private imageUrls = new Map&lt;number, string&gt;();
  public imageUrlsSubject = new BehaviorSubject(this.imageUrls);

   public size(): number {
     return this.imageUrls.size;
   }

   public set(id: number, url: string): void {
     this.imageUrls.set(id, url);
     this.imageUrlsSubject.next(this.imageUrls);
   }

   public get(id: number): string {
     return this.imageUrls.get(id);
    }


    public has(id: number): boolean {
      return this.imageUrls.has(id);
    }
}
</code></pre>

<p>I wrote a service like this following this practice. It makes me wonder: Do we really need Subject here? Can I just <strong>get rid of imageUrlsSubject</strong> under the context that another component just need to use the map in the DOM. </p>

<pre><code>&lt;img   
  *ngIf=""dataService.has(row.id)"" 
  [src]=""dataService.get(row.id).url""&gt;
</code></pre>

<p>And in another component maybe I just need to call <em>dogDataService.set</em> to update the map. </p>

<pre><code>this.dataService.set(id, url);
</code></pre>

<p>If I get rid of Subject, will it bring some potential drawbacks here?</p>

<p>Thanks!</p>
","9747267","","","","","2020-04-28 18:14:19","What is the best practice to share data in map/object/array by service among Angular components","<angular><typescript><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61492443","1","61492526","","2020-04-29 00:53:41","","0","138","<p>I am using a route guard (or resolver, I have tried to use either but got the same error) where I want to get Observable as a return value:</p>

<pre><code>canActivate(): Observable&lt;boolean&gt; {
    return this.store.pipe(
      select(fromUserProfileState.getUserProfiles),
      tap((loaded: UserProfile[]) =&gt; {
        if (!loaded || loaded.length == 0) {
          this.store.dispatch(new fromUserProfileActions.LoadUPs());
        } else {
          return of(true);
        }
      }),
      filter((loaded: UserProfile[]) =&gt; loaded.length &gt; 0),
      first()
    );
  }
</code></pre>

<p>However, this doesn't return Observable, it returns Observable which is not acceptable. How can I tweak the rxjs (v 6.5.5) operators to return Observable only?</p>

<p><a href=""https://i.stack.imgur.com/b80Rt.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/b80Rt.png"" alt=""enter image description here""></a></p>
","6741619","","","","","2020-04-29 01:45:21","Angular route guard/resolver - Type 'Observable<boolean | object[]>' is not assignable to type 'Observable<boolean>'","<angular><typescript><rxjs6><rxjs-pipeable-operators><rxjs-observables>","3","0","","","","CC BY-SA 4.0"
"61500538","1","61501281","","2020-04-29 11:17:21","","0","305","<p>I couldn't find any documentation related to this, so here it is. I have this usage of async pipe in a template:</p>

<pre><code>&lt;component [aliases]=""(users$ | async).profile.aliases$ | async""/&gt;
</code></pre>

<p>Is <code>aliases$</code> subscription correctly unsubscribed when <code>users$</code> emits? And what if there is an <code>*ngIf</code> on the wrapping element?</p>
","8836232","","","","","2020-04-29 11:57:15","Angular: are nested async pipe usage safe?","<angular><rxjs><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61562511","1","","","2020-05-02 16:13:51","","0","58","<p>I am using @CodeWithDan/Observable store package for state management. However while started to play with it, there was no help on how to have a reactive programming using the observable stores. Is there any help links out there to get an idea on how we can manage state with reactive programming></p>
","12354121","","","","","2020-05-02 16:13:51","How to implement reactive programming in angular with Observable store state management?","<angular><rxjs-observables>","0","2","","","","CC BY-SA 4.0"
"61596544","1","","","2020-05-04 16:05:13","","-1","38","<p><strong>Service code</strong></p>

<pre><code>private posts: Post[] = [];
  private postsupdated = new Subject&lt;Post[]&gt;();
  getPost() {
    return [...this.posts]
  }
  getPostsUpdatedListener() {
    return this.postsupdated.asObservable()
  }

  addPosts(title: String, content: String) {
    const post: Post = { title: title, content: content }
    this.posts.push(post)
    this.postsupdated.next([...this.posts])
  }
  constructor() { }
</code></pre>

<p><strong>component code</strong></p>

<pre><code>  Posts: Post[] = [];
  private postsSub = Subscription;
  ngOnInit(): void {
    this.Posts = this.postService.getPost();
    this.postsSub = this.postService.getPostsUpdatedListener()
      .subscribe((posts: Post[]) =&gt; {
        this.Posts = posts
      })
  }
  ngOnDestroy() {
    this.postsSub.unsubscribe();
  }
</code></pre>

<p>Type 'Subscription' is missing the following properties from type 'typeof Subscription': prototype, EMPTY and
Property 'unsubscribe' does not exist on type 'typeof Subscription'.how to resolve it???</p>
","13461030","","","","","2020-05-04 16:19:44","I have a component here i used to subscription and after subscribed method and unsubscribe the subscrimed method in order to avvoid the memory leakage","<angular><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61596757","1","61600417","","2020-05-04 16:15:49","","1","44","<p>I'm using rxjs map to retrive data in firestore like this:</p>

<pre class=""lang-js prettyprint-override""><code>  getArtists(): Observable&lt;DocumentData&gt; {
    const users$ = this.firestore.collection('/Users').get()
    users$.subscribe((users) =&gt; {
      users.docs.map(user =&gt; user.data().artistName !== """" &amp;&amp; user.data().role === 'ARTIST')
    });
    return users$;
  }
</code></pre>

<p>but when i'm getting value like this : </p>

<pre class=""lang-js prettyprint-override""><code>this.userService.getArtists().subscribe(
      (userDocs) =&gt; {
        userDocs.docs.map((user) =&gt; {
          this.artists.push(user.data());
          console.log(this.artists)
          this.record = this.artists.length;
        })
      });
</code></pre>

<p>it's return always the user when the artistName is equals to <code>""""</code> and role is not equals to <code>'ARTIST'</code>.
why ?</p>

<p>thank's everybody!</p>
","13096988","","13112018","","2020-05-05 06:16:08","2020-05-05 06:16:08","why map with condition return always value","<dictionary><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61605324","1","","","2020-05-05 03:35:22","","0","98","<p>I have created a directive to show/hide element according to permission.
Implementation of directive is somehow like:</p>

<pre><code> &lt;ng-container *appHasAccess=""'user.profile'""&gt;
&lt;button&gt;Profile&lt;/button&gt;
&lt;/ng-container&gt;
</code></pre>

<p>Directive code is:</p>

<pre><code>import {
  Directive,
  Input,
  OnDestroy,
  OnInit,
  TemplateRef,
  ViewContainerRef,
} from ""@angular/core"";
import { PermissionsService } from ""@core/services/permissions"";
import { Subject } from ""rxjs"";
import { takeUntil } from ""rxjs/operators"";

@Directive({
  selector: ""[appHasAccess]"",
})
export class HasAccessDirective implements OnInit, OnDestroy {
  @Input() appHasAccess: string;
  stop$ = new Subject();

  constructor(
    private templateRef: TemplateRef&lt;any&gt;,
    private viewContainer: ViewContainerRef,
    private permissionsService: PermissionsService
  ) {}

  ngOnInit(): void {
    this.permissionsService
      .checkAuthorization(this.appHasAccess)
      .pipe(takeUntil(this.stop$))
      .subscribe((authorized) =&gt; {
        if (authorized) {
          this.viewContainer.createEmbeddedView(this.templateRef);
        } else {
          this.viewContainer.clear();
        }
      });
  }

  ngOnDestroy() {
    this.stop$.next();
  }
}
</code></pre>

<p>This works for only page refresh scenario. View is not updated on value change.
Can anyone help me on this?</p>
","4993303","","","","","2020-05-05 14:44:52","Implementing permission directive won't update view until page refresh","<angular><permissions><rxjs><angular2-directives><rxjs-observables>","1","7","","","","CC BY-SA 4.0"
"61609499","1","","","2020-05-05 09:03:24","","0","234","<p>Using an Observable from AngularFireFunctions' <code>httpsCallable</code>, the view never updates with the value even after the http request returns.</p>

<p>I have a simple component that uses AngularFireFunctions to make an httpCallable to a simple function. I can see the call being made in the browser's network inspector, and I have a <code>tap(x=&gt;console.log(x))</code> on the observable which does indeed log the value returned from the function. However, <code>{personObservable | async | json}</code> <strong>is null even after the observable has a value</strong> (the console log from the tap triggers).</p>

<p><strong>Component:</strong></p>

<pre><code>import { AngularFireFunctions } from '@angular/fire/functions';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Component({
 selector: 'app-simple-test',
 template: '{{personObservable | async | json}}'
})
export class SimpleTestComponent implements OnInit {

    personObservable: Observable&lt;any&gt; = this.fireFunctions
            .httpsCallable('getPerson')({})
                .pipe(
                    tap(person =&gt; console.log(person))
                );

    constructor(
            private fireFunctions: AngularFireFunctions) { 
    }
...
</code></pre>

<p><strong>Firebase function:</strong></p>

<pre><code>import * as functions from 'firebase-functions';

export const viewInvite = 
        functions.https.onCall((data, context) =&gt; {
    return {name: ""test name""};
});
</code></pre>

<p>As expected, a page load causes an http request to the firebase function, and the console will contain <code>{name: ""test name""}</code> indicating that the http request worked, tap was triggered, and the observable now has a value. <strong>The page will still render ""null"".</strong></p>

<p>I've tried replacing the <code>httpsCallable(...)(...)</code> with a simple <code>of({name:""test""})</code>, and that worked fine. </p>

<p>Is there something special about the Observable that httpsCallable returns that prevents the view from using its value?</p>
","328484","","328484","","2020-05-05 09:11:42","2020-12-12 11:20:20","AngularFireFunctions httpCallable not updating after response","<angular><angularfire2><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"61638329","1","61638719","","2020-05-06 14:53:05","","0","397","<p>I'm using Rxjs, and I want to create an Observable from the following pattern (in order):</p>
<ol>
<li><p>get params from paramMap$, then ...</p>
</li>
<li><p>based on the value of params, get both (getData():Observable, getCategories():Observables) together, then ....</p>
</li>
<li><p>from ([data, categories]) create the final object.</p>
</li>
</ol>
<p>The code would look like:</p>
<pre><code>//route = this.ActivatedRoute

let obs$ = route.paramMap.pipe(

// combineLatest() is not a pipable operator, so it shouldn't be used inside .pipe()
// also it doesn't accept a function,
// but this just to show you what I want to do.

combineLatest(params=&gt;getData(params.id), params=&gt;getCategories(params.id)),

map(([data, categories])=&gt;{
//do some changes...
return {data,categories}
}
)
)

</code></pre>
<p>also where is the best place to put this code in Angular project:</p>
<ul>
<li><p><code>constructor()</code> is not the best practice, because this is a long-running operation (actually it has to do API requests)</p>
</li>
<li><p><code>ngOnInit()</code> is not recommended, because in some point I have to change <code>this.params</code> which is used in the template</p>
</li>
</ul>
<pre><code>...
combineLatest(params=&gt;
   getData(params.id).pipe(
        map(data=&gt;{
            this.params.type=data.type; 
            return data
           })), 
   params=&gt;getCategories(...) 
)
</code></pre>
<p>in template:</p>
<pre><code>&lt;div&gt;{{params.type}}&lt;/div&gt;
</code></pre>
","12577650","","13302","","2020-06-21 14:18:44","2020-06-21 14:18:44","Combine two observables inside pipe() chain","<angular><observable><rxjs6><rxjs-observables><combinelatest>","1","3","","","","CC BY-SA 4.0"
"61674902","1","","","2020-05-08 08:16:47","","0","31","<p>I followed a tutorial about dynamic forms (<a href=""https://angular.io/guide/dynamic-form"" rel=""nofollow noreferrer"">https://angular.io/guide/dynamic-form</a>) and everything worked just fine untill I tried to retrieve the data from an HttpClient. </p>

<p><strong>The problem</strong>: <code>@Input() questions: QuestionBase&lt;string&gt;[] = [];</code>in ""dynamic-form.component.ts"" returns null.</p>

<p>What did I change? In the <code>question.service.ts</code>, I replaced an <code>of</code> rxjs operator with <code>this.&lt;myHttpClientInstance&gt;.get&lt;any&gt;(...)</code> and then nothing worked anymore. </p>

<p>Other things equal I assumed that the problem resides in the change from <code>of</code> to <code>this.&lt;myHttpClientInstance&gt;.get&lt;any&gt;(...)</code>. Therefore, I printed on the console the two different outputs of <code>of</code> and <code>this.&lt;myHttpClientInstance&gt;.get&lt;any&gt;(...)</code>. They misteriously look different. Here they are:</p>

<p><a href=""https://i.stack.imgur.com/XJH7t.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/XJH7t.png"" alt=""enter image description here""></a></p>

<p><strong>Disclaimer</strong>: nothing has changed in ""app.component.html"" (in particular I'm referring to this line of code: <code>[questions]=""questions$ | async""</code>)</p>

<p>Any clue?</p>

<p><strong>Edit:</strong></p>

<p><em>Service code</em></p>

<pre><code>   constructor(private http: HttpClient) {}

   getFormElementsFromHttpClient() {

return this.http.get&lt;FormElementBase&lt;any&gt;[]&gt;(environment.apiUrl + '/attribute-manager-be/view/fields')
.pipe(map( (response : any[]) =&gt; {

  let formElementsList : FormElementBase&lt;any&gt;[] = [];

  for (const formElement of response) {

    switch (formElement.type) {

      case ""text"":

        formElementsList.push(

          new FormElementText({
            fieldId: formElement.id,
            key: formElement.key,
            label: formElement.label,
            value: formElement.defaultValue,
            required: formElement.required,
            order: formElement.position
          }),

        )

        break;

      case ""dropdown"":

        formElementsList.push(

          new FormElementDropdown({
            fieldId: formElement.id,
            key: formElement.key,
            label: formElement.label,
            options: formElement.options,
            required: formElement.required,
            order: formElement.position
          })

        )

        break;

      case ""checkbox"":

        formElementsList.push(

          new FormElementCheckbox({
            fieldId: formElement.id,
            key: formElement.key,
            label: formElement.label,
            type: formElement.type,
            order: formElement.position,
            required: formElement.required
          })

        )

        break;

      case ""multipleDropdown"":

        formElementsList.push(

          new FormElementMultipleDropdown({
            fieldId: formElement.id,
            key: formElement.key,
            label: formElement.label,
            options: formElement.options,
            order: formElement.position,
            required: formElement.required
          }),

        )

        break;

      default:
        break;
    }

  }

    return formElementsList.sort((a, b) =&gt; a.order - b.order);    

  }
  ));

   }

   getFormElementsFromForOperator() {

let questions: FormElementBase&lt;string&gt;[] = [

  new FormElementMultipleDropdown({
    fieldId: 2,
    label: ""dropdown"",
    position: 4,
    required: true,
    key: ""idtdropdown"",
    options: [
        {
            id: 1,
            key: ""ciambella"",
            value: ""ciambella""
        },
        {
            id: 2,
            key: ""oreo"",
            value: ""oreo""
        }
    ]
  }),

  new FormElementText({
    fieldId: 1,
    type: ""text"",
    label: ""text"",
    position: 3,
    required: true,
    key: ""idtext"",
    options: null
  }),

  new FormElementCheckbox({
    fieldId: 1,
    type: ""checkbox"",
    label: ""checkbox"",
    position: 4,
    required: true,
    key: ""idcheckbox"",
    options: null
  }),

  new FormElementDropdown({
    fieldId: 4,
    type: ""multipleDropdown"",
    label: ""multipledropdown"",
    position: 1,
    required: true,
    key: ""multipledropdown"",
    options: [
        {
            id: 3,
            key: ""abbracci"",
            value: ""abbracci""
        },
        {
            id: 4,
            key: ""fagottini"",
            value: ""fagottini""
        }
    ]
  })

];

return of(questions.sort((a, b) =&gt; a.order - b.order));


   }
</code></pre>

<p><em>Component (ts) code</em></p>

<pre><code>     @Component({
       selector: 'app-home',
       templateUrl: './home.component.html',
       styleUrls: ['./home.component.css'],
       providers:  [FormService]
     })
     export class HomeComponent {

     questions$: Observable&lt;FormElementBase&lt;any&gt;[]&gt;;

       constructor(formService: FormService) {

         this.questions$ = formService.getFormElementsFromForOperator();

         console.log(""(for operator) works"", this.formelements$);
         console.log(""(HttpClient) doesn't work"", formService.getFormElementsFromHttpClient());

       }
     }
</code></pre>
","10489555","","10489555","","2020-05-08 10:10:30","2020-05-08 10:10:30",""" observable$ | async "" failing with HttpClient observables, but succeeding with for operator","<angular><angular-httpclient><rxjs-observables>","0","8","","","","CC BY-SA 4.0"
"61676209","1","61676935","","2020-05-08 09:39:06","","1","366","<p>trying to understand rxjs and rxjs within redux and redux observables by trying to do a simple fetch example</p>

<p>got my store set up like so:</p>

<pre><code>import { applyMiddleware, createStore } from 'redux'
import { reducers } from 'redux/reducers'
import { createEpicMiddleware } from 'redux-observable'
import rootEpic from '../epics'

const epicMiddleware = createEpicMiddleware()
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__

epicMiddleware.run(rootEpic)

export const store = createStore(reducers, composeEnhancers(applyMiddleware(epicMiddleware)))
</code></pre>

<p>and in my epic I've got</p>

<pre><code>const getUserDataEpic = (action$, state$) =&gt;
    action$.pipe(
        ofType('GET_USER_DATA'),
        mergeMap(async (action) =&gt; {
            const url = `my-url-is-here`
            const data = await fetch(url).then((res) =&gt; res.json())
            return Object.assign({}, action, { type: 'GET_DATA_SUCCESS', data })
        }),
        catchError((err) =&gt; Promise.resolve({ type: 'FETCH_ERROR', message: err.message })),
    )

const epic2 = (action$, state$) =&gt; {}

export default combineEpics(getUserDataEpic)
</code></pre>

<p>I also have my action creator:</p>

<pre><code>export const fetchData = () =&gt; ({ type: 'GET_USER_DATA' })
</code></pre>

<p>this gets fired in my component on mount. I've wrapped in mapDispatchToProps and I've verified it's definitely getting called. as is my reducer</p>

<p>I don't understand why my epic is not being triggered tho?? I was hoping it would see the <code>GET_USER_DATA</code> being fired and then fire it's own action to put the resolved API request into my state.</p>

<p>please advise where im going wrong</p>
","10795348","","","","","2020-05-08 10:22:26","Why is my redux-observable epic not being triggered?","<javascript><reactjs><redux><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61677747","1","61686378","","2020-05-08 11:07:48","","0","88","<p>please take a look at this code below</p>

<p>basically what is happening my action is being dispatched here:</p>

<pre><code>   useEffect(() =&gt; {
        fetchData()
        setLoaded(true)
    }, [])
</code></pre>

<p>but for some reason this is infinite looping and causing my action to be dispatched continuously</p>

<pre><code>export const fetchData = () =&gt; ({ type: 'GET_USER_DATA' })
</code></pre>

<p>and this is triggering my epic</p>

<pre><code>const getUserData = (action$, state$) =&gt;
    action$.pipe(
        ofType('GET_USER_DATA'),
        mergeMap(
            (action) =&gt;
                ajax
                    .getJSON(
                        `myurlishere`,
                    )
                    .pipe(map((response) =&gt; fetchUserFulfilled(response))),
        )
    )
</code></pre>

<p>which trigger this: </p>

<pre><code>const fetchUserFulfilled = (payload) =&gt; ({ type: 'GET_DATA_SUCCESS', data: payload })
</code></pre>

<p>this code all works but it's continuously calling it in an infinite loop</p>

<p>however, if I move the code from <code>useEffect</code> to a button call like so:</p>

<pre><code> &lt;button onClick={fetchData}&gt;fetch&lt;/button&gt;
</code></pre>

<p>it only calls it once, which is what I want</p>

<p>but I need the data to be called onmount. so how do I fix it?</p>

<p>please note I have tried adding various things to the second argument of useEffect but it's having no effect</p>

<pre><code>   useEffect(() =&gt; {
        fetchData()
        setLoaded(true)
    }, [user.id])
</code></pre>
","10795348","","","","","2020-05-08 19:21:33","Why is my RXJS epic in an infinite loop on mount but only called once on button click?","<javascript><reactjs><rxjs><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"61707376","1","","","2020-05-10 04:58:11","","1","399","<p>I have very simple code in my service class:</p>

<pre><code>userContext$ = this.http.post&lt;UserContext&gt;(this.userContextService, {}).pipe(
    shareReplay(1),
    tap((val: UserContext) =&gt; (this.userContext = val))
  );
</code></pre>

<p>This is called twice, first in Header and then in Body:</p>

<pre><code>changeDetection: ChangeDetectionStrategy.OnPush,
})
export class HeaderComponent{

  userContext$ = this.userContextService.userContext$;
</code></pre>

<p>2nd time:</p>

<pre><code>    export class PortfolioComponent {

  userContext$ = this.userContextService.userContext$;
</code></pre>

<p>But this doesn't seems to work, in my Network Tab I always have 2 calls, even if I do Console.log it's logged twice:</p>

<p><a href=""https://i.stack.imgur.com/gu389.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gu389.png"" alt=""enter image description here""></a></p>
","1032248","","3001761","","2020-05-28 22:03:22","2020-05-28 22:03:22","Why my Angular/Rxjs6.5 shareReplay(1) not working?","<angular><typescript><functional-programming><rxjs6><rxjs-observables>","1","10","","","","CC BY-SA 4.0"
"61727665","1","61727881","","2020-05-11 10:35:57","","0","366","<p>I am working on an app using Angular 9 and RxJS 6.5. The functionality I have problems with uses Angular services to fetch some data from a server and provides this data to views (using RxJS behaviorSubjects). Before passing that data to the views though, I want to do some unit conversion, so that the user can use a toggle/switch to change between two units for the entire app, specifically ""metric tons"" and ""short tons"".</p>

<p>While the actual conversion functions are provided within a dedicated service, I need to control which properties of the data (that was fetched by the server) should be converted, so I am ""piping"" the subjects, calling the conversion methods inside the pipe.</p>

<pre class=""lang-js prettyprint-override""><code>// This ""CommoditiesService"" fetches data from the server
// and should return all fetched commodities, so ""Commodity[]""
export class CommoditiesService {
    // Inside this subject, all Commodities are stored (without unit conversion)
    private _commodities: BehaviorSubject&lt;Commodity[]&gt; = new BehaviorSubject(null);

   public readonly commodities: Observable&lt;Commodity[]&gt; = this._commodities.pipe(
    // This pipe is where all unit conversions for commodities is happening,
    // so for every commodity, the function ""convertCommodityUnits"" is called.
    // the arguments there are the base and the target unit. Base is always kilogram, as this is what the server returns.
    // The target unit is what the user can set globally. This ""preferredWeightUnit"" is subscribed to inside the service, so it is updated once the user changes the unit.

    map((commodities: Commodity[]) =&gt; {
      // For every commodity, convert Price and inventory into the prefered display unit
      return commodities?.map(commodity =&gt; this.convertCommodityUnits(commodity, ""kg"", this.preferedWeightUnit)) || null;
    })
  );
}
</code></pre>

<p>So far this works like a charm: The units are converted and views can subscribe to the commodities observable.
The problem is now, when the user updates the ""preferredWeightUnit"", the ""commodities"" observable is not re-evaluated, so ""this.preferredWeightUnit"" is updated inside CommoditiesService, but the unit conversion is not done again.</p>

<p>I suppose I could update the subject with the same data, so calling <code>this._commodities.next(this._commodities.value)</code>, but this just looks wrong to me.</p>

<p>How could I trigger the unit conversion (so the RxJS pipe) again once the prefered unit changed?
Also, is this design choice even a good idea to make the units changable in a reactive way? I thought it was better then changing the units inside views everywhere they might appear.</p>
","5254957","","","","","2020-05-11 10:48:06","Angular/RxJS update piped subject manually (even if no data changed), ""unit conversion in rxjs pipe""","<angular><rxjs><angular-services><rxjs-pipeable-operators><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61771578","1","61782146","","2020-05-13 09:57:55","","1","706","<p><strong>Note</strong> I have created a simplified version of this question at <a href=""https://stackoverflow.com/questions/61772610/template-binding-with-function-return-observable-and-async-pipe"">Template binding with function return Observable and async pipe</a></p>

<p>Template:</p>

<pre class=""lang-html prettyprint-override""><code>&lt;div *ngIf=""entity?.ext.insuredDetails.insuredType$() | async as insuredType""&gt;
 {{insuredType}}
&lt;/div&gt;
</code></pre>

<p><code>insuredType$</code> definition:</p>

<pre class=""lang-js prettyprint-override""><code>@NeedsElement(sp(115621),ap(116215))
insuredType$(): Observable&lt;string&gt; {
  return empty();
}
</code></pre>

<p><code>NeedsElement</code> decorator:</p>

<pre class=""lang-js prettyprint-override""><code>export function NeedsElement(...mappings: NeedsElementMapping[]) {
  if (mappings.length === 0) {
    throw new Error('needs mapping expected');
  }

  let lookup = new Map&lt;ProductId, number&gt;();
  mappings.forEach((mapping) =&gt; {
    lookup.set(mapping.productId, mapping.elementId);
  });

  return (target: any, propertyKey: string, descriptor: PropertyDescriptor) =&gt; {
    descriptor.value = function (...args: any[]) {
      Logger.info(""bbbbb"");
      let entity = UcEntityStoreContext.currentEntity;
      let productId = entity['productId'];
      if (!productId) {
        throw new Error(`Cannot get product Id from host entity: ${entity.ucId}`);
      }
      let elementId: number = lookup.get(entity['productId']);
      if (!elementId) {
        throw new Error(`Cannot locate needs element ID by productId ${productId}`);
      };
      let enitityStore = UcEntityStoreContext.current;
      let entityApi = enitityStore.apiService as QuotePolicyApiBase&lt;any&gt;;
      let needsDefApi = NeedsDefinitionApi.instance;

      return needsDefApi.fetchOne(productId, elementId).pipe(
        concatMap(
          nd =&gt; {
            return entityApi.fetchNeedsElementValue(entity.ucId, elementId).pipe(
              concatMap(needsVal =&gt; {
                if (!needsVal) {
                  return of("""");
                }
                if (nd.lookupId) {
                  return LookupApi.instance.getByPrimaryValueId(nd.lookupId, needsVal).pipe(
                    map(res =&gt; res.primaryValue)
                  );
                } else {
                  return of(needsVal);
                }
              })
            )
          }
        )
      );
    };
  };
}
</code></pre>

<p>The problem is the the decorator is called multiple times:</p>

<p><a href=""https://i.stack.imgur.com/RBG9o.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RBG9o.png"" alt=""enter image description here""></a></p>

<p>And if it goes this branch:</p>

<p><a href=""https://i.stack.imgur.com/5UAjd.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5UAjd.png"" alt=""enter image description here""></a></p>

<p>then it keep sending requests to the backend servcie and the binding never output anything:</p>

<p><a href=""https://i.stack.imgur.com/r8Nvq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/r8Nvq.png"" alt=""enter image description here""></a></p>

<p>It looks like it will always keep trying evaluate the observable without ending if it is an async obserable, say this one:
<a href=""https://i.stack.imgur.com/MfHUr.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/MfHUr.png"" alt=""enter image description here""></a></p>

<hr>

<p><strong>Updates 14/May/2020</strong></p>

<p>I got the answer from <a href=""https://stackoverflow.com/questions/61772610/template-binding-with-function-return-observable-and-async-pipe/61772828"">Template binding with function return Observable and async pipe</a></p>

<p>In the end I changed the Method Decorator to Property Decorator and issue fixed.</p>
","391227","","391227","","2020-05-13 22:14:57","2020-05-13 22:22:13","Angular template binding with Observable async pipe issue","<angular><rxjs><rxjs6><rxjs-observables>","2","0","1","2020-05-14 07:19:03","","CC BY-SA 4.0"
"61772610","1","61772828","","2020-05-13 10:46:46","","1","1188","<p><strong>Note</strong> this is simplified question of <a href=""https://stackoverflow.com/questions/61771578/angular-template-binding-with-observable-async-pipe-issue"">Angular template binding with Observable async pipe issue</a></p>

<p>template:</p>

<pre class=""lang-html prettyprint-override""><code>&lt;div&gt;{{foo()$ | async}}&lt;/div&gt;
</code></pre>

<p>source code:</p>

<pre class=""lang-js prettyprint-override""><code>import { Component } from ""@angular/core"";
import { BehaviorSubject, of, Observable } from ""rxjs"";
import { tap, delay, map, switchMap, concatMap } from ""rxjs/operators"";

@Component({
  selector: ""my-app"",
  templateUrl: ""./app.component.html"",
  styleUrls: [""./app.component.css""]
})
export class AppComponent {
  private index = 0;
  foo$(): Observable&lt;any&gt; {
    console.log(""aaa"")
    return of(""Delayed"");
  }
}
</code></pre>

<p>The above code works as expected:</p>

<p><a href=""https://i.stack.imgur.com/B8agY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B8agY.png"" alt=""enter image description here""></a></p>

<p>However if I added <code>.pipe(delay(1))</code> to the <code>foo$()</code>:</p>

<pre class=""lang-js prettyprint-override""><code>  foo$(): Observable&lt;any&gt; {
    return of(""Delayed"").pipe(delay(1));
  }
</code></pre>

<p>it won't work and keep ""aaa"" in the console log.</p>

<p>See <a href=""https://stackblitz.com/edit/angular-qbhkg3"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-qbhkg3</a></p>
","391227","","","","","2020-05-13 11:26:48","Template binding with function return Observable and async pipe","<angular><rxjs><rxjs6><rxjs-observables>","1","1","1","","","CC BY-SA 4.0"
"61773760","1","61773932","","2020-05-13 11:45:16","","0","29","<p>I normally tend to use Observables in components by passing them into functions through template using <code>myFunction(myObservable$ | async)</code> and it works quite well.</p>

<p>However, in my template I have an output function that emits values to the parent component.</p>

<pre><code>&lt;my-component
   [myInput]=""something$ | async""
   (childOutputEmitter)=""onChildEmitFunction($event)""&gt;
&lt;/my-component&gt;
</code></pre>

<p>The problem is the <code>onChildEmitFunction()</code> function I need combine both the emitted value ($event) and the <code>myObservable$ | async</code> values.</p>

<p>This doesn't seem to work though: </p>

<pre><code>&lt;my-component
   [myInput]=""something$ | async""
   (childOutputEmitter)=""onChildEmitFunction($event, (myObservable$ | async))""&gt;
&lt;/my-component&gt;
</code></pre>

<p>Is there a way to pass the value of myObservable$ to onChildEmitFunction() without subscribing to it and storing the value in another variable?</p>
","4388875","","","","","2020-05-14 10:28:59","Angular 5 + RxJS: using observables in the component without subscribing to them","<angular><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61791397","1","61791460","","2020-05-14 07:13:23","","0","914","<p>Here is my code snippet:</p>

<p>In Typescript:</p>

<pre><code>isDataSearch = false;

getDatacollectionByID() {
  const params = {
    id: &lt;some random ID&gt;,
  };
  this.metaData = this.dataService.getDatacollectionByID(params)
    .pipe(
      pluck('level1', 'level2', 'level3'),
      tap(() =&gt; this.isDataSearch = true),
      map(metaData =&gt; [metaData]), // to be used as an array for ag grid
    )
}
</code></pre>

<p>In HTML template:</p>

<pre><code>&lt;ag-grid-angular
    *ngIf=""isDataSearch""
    [gridOptions]=""dataCollectionConfig""
    [rowData]=""metaData | async""
    [modules]=""modules""
    class=""ag-theme-balham data-collection-grid""
&gt;
&lt;/ag-grid-angular&gt;
</code></pre>

<p>What I am trying to accomplish is to show the ag-grid only when the data from observable sequence is done.
I am first plucking the data which is deeply nested and then using <code>tap</code> operator to reverse the boolean binding to <code>*ngIf</code>.</p>

<p>I guess this can be fixed using subscribe method but I want to avoid it because I am using async pipe in template directly.</p>
","2028631","","","","","2020-05-14 07:17:10","RxJs operators and Angular: using async pipe and tap does not populate data","<javascript><angular><typescript><rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"61822797","1","61824856","","2020-05-15 15:26:58","","2","183","<p>I'm trying to refactor my Angular code to be more ""reactive""</p>

<p>I have data returned from an Observable which retreives account data account$ into an object
for example: </p>

<pre><code>{
 accountid: ""123435"", 
 name: 'bob', 
 customerId: ""AR4533"" 
 ..etc}
</code></pre>

<p>I also want to retreive payment data from another method call and merge it into the account object data: </p>

<pre><code>{
 paymentId: ""13434"", 
 paymentName:""pay1"" 
 ..etc}
</code></pre>

<p>The payment data needs a customerId parameter which is in the parent account data.</p>

<p>I've managed to pass this data through from the first observable using mergeMap however the resulting output is giving me the the payment data only, I want to have the account object with the payment data added within it as the output.
Like so:</p>

<pre><code>{
 accountid: ""123435"", 
 name: 'bob', 
 paymentData: {
    paymentId: ""13434"", 
    paymentName:""pay1"" ..etc
   }
}
</code></pre>

<pre><code>account$ = this.http.get&lt;IAccountResponse&gt;('account')
    .pipe(
      map(data =&gt; data.data),
      mergeMap(data =&gt; this.http.get&lt;any&gt;(`payment/subscription?customer=${data.stripe.customerId}`)),
      tap(data =&gt; console.log('PIPE:account', data))
    )
</code></pre>

<p>I know mergeMap does replace the data in the stream but is there a way to make the data merge into the current stream data object?</p>
","6797021","","","","","2020-05-15 17:16:10","Angular RxJs Observable stream merge data","<javascript><angular><rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"61855510","1","61897665","","2020-05-17 16:58:15","","0","107","<p>I try to make an articles app.<br>
<img src=""https://i.stack.imgur.com/pclOo.jpg"" alt=""1""></p>

<p>based on angular and ionic but the problem I face is the programming structure for <strong>Behaviorsubject</strong> for the serializer nested data.
My backend uses django-rest-framework</p>

<p>*I successfully perform ""CRUD"" operations <strong>(I.e. live updates from server and behavior subject)</strong> with basic data I.e. only with author data or article data <strong>but failed with nested serialize data</strong> *</p>

<p>All I want the best practice of behavior subject for the nested data of authors and articles </p>

<p>Question.) Make an Behaviorsubject for one URLs
<em>http:local host:8000/v1/authors/</em> 
Which Uses <strong>nested serializer</strong> and returns both <strong>authors and articles data</strong>
<em>Below image</em> ?</p>

<p>Below image shows authors array  data <em>with</em> <strong>articles data</strong> of second model as nested 
(Thanks in advance)</p>

<p>[1]: </p>

<p>Code of my <strong>articles.service.ts</strong></p>

<pre><code>  extractArticles(data : AuthorsInterface[]){
/*
* Extracting then Returns
  * [] of Articles Data
  * from Parent Data
*/

let localArray = []
if (data.length &gt; 0){
  for( let x in data ){
    if ( data[x].articles.length &gt; 0 ){
      for( let y in data[x].articles){
        localArray.push(data[x].articles[y])
      }
    }
  }
  return this.articlesInterface.concat(localArray)
}
</code></pre>

<p>}</p>

<pre><code>getParents() {
/*
* Calling REST-API
  * Extract Authors &amp; Articles
  * from the parent Data
  * &amp; cached them
*/
return this.http.get&lt;AuthorsInterface[]&gt;(this.AUTHOR_URL)
  .pipe(
    map(mapData=&gt;{
        **here comes the combined data of articles and authors **
        *as shown in image*
        this.articlesBehavior.next(
        this.extractArticles(mapData)
      )        
    }
  )
)
</code></pre>

<p><strong>Am i doing right ?</strong></p>

<p>*Right now i just split the data after recieving from backend
 (by extracting the article's data from author's dictionary)
and store it separetely</p>

<p>*articlesInterface for holding all the article
<em>authorsInterface for holding all the authors</em></p>

<p><strong>Then inject article's service into authors's service don't know it's a best practice or not ?</strong></p>

<p>I made two BehaviorSubject</p>
","8101741","","7389970","","2020-05-28 09:46:18","2020-05-28 09:46:18","Make an Behaviorsubject for nested serializer's data","<angular><django-rest-framework><django-serializer><behaviorsubject><rxjs-observables>","1","5","0","","","CC BY-SA 4.0"
"61882095","1","61883206","","2020-05-19 02:11:26","","0","23","<p>Heres how I am calling the GET HTTP method:</p>

<pre><code>getTextbooks() :Observable&lt;Textbook[]&gt; {
    return this.http.get&lt;Textbook[]&gt;('http://localhost:3000/catalogue');
}
</code></pre>

<p>Which parses the HTTP response to Textbook[] and returns an observable</p>

<p>I then subscribe to the observable and get the data like so:</p>

<pre><code>
this.textbookService.getTextbooks().subscribe(
    (data: Textbook[]) =&gt; this.textbooks = data,
    (err: any) =&gt; console.log(err),
);

</code></pre>

<p>The weird thing is, checking in the Network tab in the Chrome inspecting tool shows that it indeed received an array of objects, each with the correct parameters, as well as a 200OK status. If I printed out data in the callback of the .subscribe method it also shows the array of Textbooks just fine. It is just when I try to set this.textbooks = data when I get that this.textbook is undefined. this.textbooks is also of type Textbook[], same as data[].</p>

<p>Any advice would be amazing, thank you!</p>
","","user7299402","","","","2020-05-19 04:22:31","Textbook[ ] is undefined after setting it equal to subscribing to Observable<Textbook[]>","<angular><typescript><rxjs><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"61933968","1","","","2020-05-21 11:55:24","","0","43","<p>I have an input of a string array for Enums I want to recieve from server:</p>

<pre><code>enumList = ['somethin','branch','country', 'serviceType', 'thatandthis'];
</code></pre>

<p>I then have a generic http-service method that takes an <strong>enumList</strong> string as a parameter and returns an HttpClient observable for that Enum service:</p>

<pre><code>this.webApi.getEnumByName('somethin','en').subscribe((res)=&gt;{/*do something*/})
this.webApi.getEnumByName('branch','en').subscribe((res)=&gt;{/*do something*/})...
</code></pre>

<p>I'm than combining the two into a loop</p>

<pre><code>   for (const item of this.enumList) {
      this.webApi.getEnumByName(item).subscribe((res: any) =&gt; {
          this.enums[item] = res;
      });
    } 
</code></pre>

<p>But this is not good...
I want the a subscription that completes only once when all subscriptions has resolved, while keeping a reference to the associated <strong>item string</strong> 
<br/><br/>
using an array of observables returned from this.webApi.getEnumByName(item), <strong>concat or forkJoin won't work because they won't keep refference to the associated string/key/token of the response</strong> e.g the string in the enumList.
<br/> <br/></p>

<p>The end result of these concatinated observables should be:</p>

<pre><code>{
    'somethin':{respopnse...},
    'branch':{respopnse...},
    'country':{respopnse...},
    'serviceType':{respopnse...},
    'thatandthis':{respopnse...}
}
</code></pre>

<p>breaking my head on this will appriciate an rxjs solution</p>
","2557085","","","","","2020-05-21 15:26:51","subscribing to multiple observable while keeping reference to function parameters","<rxjs><angular8><angular9><rxjs-pipeable-operators><rxjs-observables>","3","0","","","","CC BY-SA 4.0"
"61997306","1","61997560","","2020-05-25 07:00:34","","0","52","<p>I have attached an <code>open()</code> method to my <a href=""https://github.com/ng-select/ng-select"" rel=""nofollow noreferrer"">ng-select</a> element in order to populate it with data from an external API.</p>

<p>The problem I encountered: if I open the dropdown 5 times and then I type a letter, it will make 5 http requests to the server in order to populate it with data. Same issue when I use the virtual scroll functionality.</p>

<p><strong>component.html</strong></p>

<pre><code>&lt;ng-select [items]=""filterValuesBuffer""
         [typeahead]=""filterValuesInput$[filter.name]""
         [virtualScroll]=""true""
         [multiple]=""true""
         [closeOnSelect]=""false""
         [loading]=""filterValuesLoading[filter.name]""
         [(ngModel)]=""filter.filter_values""
         (scrollToEnd)=""onScrollToEnd(filter.name)""
         (open)=""onFilterOpen(filter.name)""
         typeToSearchText=""No values found""
         bindLabel=""name""&gt;
&lt;/ng-select&gt;
</code></pre>

<p><strong>component.ts</strong></p>

<pre><code>filterValuesInput$: Map&lt;string, Subject&lt;string&gt;[]&gt; = new Map();

onFilterOpen(filterName) {
    this.filterValuesLoading[filterName] = true;

    this.getFilterValues(filterName, '')
      .subscribe(res =&gt; {
        this.afterKey = res.after_key;
        this.filterValuesLoading[filterName] = false;
        this.filterValuesBuffer = res.filter_values;
      });
}


getFilterValues(filterName, afterKey) {
    return this.filterValuesInput$[filterName].pipe(
      tap(() =&gt; this.filterValuesLoading[filterName] = true),
      startWith(''),
      distinctUntilChanged(),
      switchMap(term  =&gt; this.search.getFilterValues(filterName, '' + term, '' + afterKey)),
    )
}
</code></pre>

<p>How can I prevent this behaviour?</p>

<p>EDIT virtual scroll: </p>

<pre><code>(scrollToEnd)=""fetchMore(filter.name)""

fetchMore(filterName) {
    this.filterValuesLoading[filterName] = true;

    this.getFilterValues(filterName, this.afterKey)
      .subscribe(res =&gt; {
        this.afterKey = res.after_key;
        this.filterValuesLoading[filterName] = false;
        this.filterValuesBuffer = this.filterValuesBuffer.concat(res.filter_values);
      })
  }
</code></pre>
","5958128","","5958128","","2020-05-25 07:14:15","2020-05-25 08:44:47","RxJS http request made multiple times","<angular><rxjs><behaviorsubject><rxjs-observables>","2","3","","","","CC BY-SA 4.0"
"61998602","1","61999727","","2020-05-25 08:30:05","","1","1192","<p>I have a scenario like i need to fetch file content when click on a file.
I want to cache the file content API with shareReplay(), how can i achieve it?</p>

<p>fileService.getContent is an API service which will fetch content with params(repository_id, filePath);</p>

<p>Question:</p>

<ul>
<li>Where should i use the shareReplay() pipe? Inside API service? or the place i wrote below.</li>
<li><strong>Below code does not work as expected.</strong> The API will be triggered multi-times. How can i cache the API with shareReplay() to call only once.</li>
</ul>

<p><strong>Component</strong></p>

<p>`</p>

<pre><code>fileOpened$ = new Subject();
...

this.fileOpened$.pipe(
    switchMap(file =&gt; this.fileService.getContent(this.repository_id, file.filePath)),
    shareReplay(1)
);
</code></pre>

<p>`</p>

<p><strong>service</strong>:</p>

<p>`</p>

<pre><code>getContent(repoId: string, path: string): Observable&lt;string&gt; {
    return this.http.get&lt;string&gt;(
        `/api/xxx/${repoId}/files/${decodeURIComponent(path)}`,
        {
            responseType: 'text' as 'json'
        });
}
</code></pre>

<p>`</p>
","3943632","","3943632","","2020-05-25 11:43:55","2020-05-25 11:43:55","How to use shareReplay for cache HTTP response with request params","<angular><rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"62008855","1","62009117","","2020-05-25 18:52:14","","0","51","<p>Apologies for the newbie/dump question about RxJS, just started since I am learning Angular.</p>

<p>So I've created an asynchronous validator static method that calls an API service method checking the uniqueness of username in the database. The code snippets below works when the backend server is up and running. When it is not, it prints an error log message which I should be handling in the presentation component instead.</p>

<p>What am missing here in the transformation step to handle such generics use case to convert both <code>Observable&lt;SuccessResponse&gt;</code> and <code>Observable&lt;ErrorResponse&gt;</code> to <code>Observable&lt;ValidationErrors | null&gt;</code>.</p>

<p><strong>Validator</strong></p>

<pre><code>static usernameUnique(service: ApiService): AsyncValidatorFn {
    return (control: FormControl): Observable&lt;ValidationErrors | null&gt; =&gt; {
        return service.isUsernameTaken(control.value as string)
            .pipe(
                map((response: SuccessResponse) =&gt; response.data ? { taken: true } : null)
            );
    };
}
</code></pre>

<p><strong>ApiService</strong></p>

<pre><code>isUsernameTaken(username: string): Observable&lt;SuccessResponse | ErrorResponse&gt; {
    return this.httpCient.get('/backend/account/checkUnique', { params: { username: username } })
                .pipe(catchError(this.handleError));
}

handleError(error: HttpErrorResponse) : Observable&lt;ErrorResponse&gt; {
    // return specific payload of ErrorResponse based on error.status
}
</code></pre>

<p>Thanks in advance.</p>
","999452","","","","","2020-05-25 19:56:28","Observable transformation to handle backend server error","<angular><rxjs><rxjs-pipeable-operators><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"62025167","1","","","2020-05-26 15:01:32","","0","33","<p>I am writing a log service, in the log service have several log info. if I fetch IP address, it will fetch IP address after some delay, IP address as undefined in the error object.because </p>

<pre><code> logError(response: any): any {

      let errors:any;
      console.log(response, ""log service error"");
      this.getIP();

      error = {
        ExceptionMessage: response.message,
        ipaddress: this.getIP(),//  is undefined

        htmlDOM: document.getElementsByTagName(""body"")
        screenShot:another service call,
      }

      console.log(error, 'logged');
      return error;
 }

 getIP() {
   this.getIPAddress().subscribe((res: any) =&gt; {
      //getting ipaddress
      return res.ip;
   });
 }

 getIPAddress() {
   return this.httpClient.get(""http://api.ipify.org/?format=json"");
 }

 getScreen() {}
</code></pre>

<p>O.p: currently it works by using this set timeout solution.Better solution appreciated.</p>

<p>Tried with async and await but it did not work,</p>

<pre><code> logError(response: any): any {

       setTimeout(()=&gt;{

          let errors:any;
          console.log(response, ""log service error"");
          this.getIP();
          error = {
            ExceptionMessage: response.message,
            ipaddress: this.getIP(),//  is undefined

            htmlDOM: document.getElementsByTagName(""body"")
            screenShot:another service call,
          }

          console.log(error, 'logged');
           return error;
         },7000);

         return error;
}
</code></pre>
","4031891","","6072233","","2020-05-26 16:15:29","2020-05-26 16:15:29","asynchronous execution issue while fetching ip address in angular service call","<angular><typescript><rxjs><rxjs6><rxjs-observables>","0","4","","2020-05-26 15:07:24","","CC BY-SA 4.0"
"62031824","1","","","2020-05-26 21:37:10","","0","30","<p>In general we need behavior subject functionality. But  only on first subscription we should send subscribe to server in REST. And to send unsubscribe on the last unsubscribe, and all late observers subscribed will gwt the latest json recwived from the first. can i do it using rxjs operaTors and how? or shoul i use custom obserbale ?</p>

<p>currently the custom code for this is this:</p>

<pre><code>public observable: Observable&lt;TPattern&gt; = new Observable((observer: Observer&lt;TPattern&gt;) =&gt; {
 this._observers.push(observer);
 if (this._observers.length === 1) {
  this._subscription = this.httpRequestStream$
    .pipe(
      map((jsonObj: any) =&gt; {
        this._pattern = jsonObj.Data;
        return this._pattern;
      })
    )
    .subscribe(
      (data) =&gt; this._observers.forEach((obs) =&gt; obs.next(data)),
      (error) =&gt; this._observers.forEach((obs) =&gt; obs.error(error)),
      () =&gt; this._observers.forEach((obs) =&gt; obs.complete())
    );
}
if (this._pattern !== null) {
  observer.next(this._pattern); // send last updated array
}
return () =&gt; {
  const index: number = this._observers.findIndex((element) =&gt; element === observer);
  this._observers.splice(index, 1);
  if (this._observers.length === 0) {
    this._subscription.unsubscribe();
    this._pattern = null; // clear pattern when unsubscribed
  }
};
</code></pre>

<p>});</p>
","3982102","","3982102","","2020-05-27 08:42:37","2020-05-27 08:42:37","how to use multicasting obs with behavioursubject?","<rxjs><rxjs-pipeable-operators><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"62036303","1","62037510","","2020-05-27 05:51:40","","0","545","<p>I am a beginner to use RxJs operators and I am having a requirement of a method, which calls 5 observables from service and it should fetch data from service only after first observable completes,  then combine all the observables and transform to a new observable and return a new observable with in a function. The below code illustrates the scenario. </p>

<pre><code>GetAllDetails(): Observable&lt;AllDetails&gt; {

const user = this.service.getUser() // Observable&lt;User&gt;
const firstDetails = this.service.getFirstDetail() // returns Observable&lt;FirstDetail&gt;
const secondDetails = this.service.getSecondDetail() // returns Observable&lt;SecondDetail&gt;
const thirdDetails = this.service.getThirdDetail() // returns Observable&lt;ThirdDetail&gt;
const fourthDetails = this.service.getFourthDetail() // returns Observable&lt;FourthDetail&gt;

// need to return a value that something compatible with Observable&lt;AllDetails&gt;
// so the logic should check if user info available then do combining all observable values and 
// return as new observable 

return of(new AllDetails(first, second, third, fourth) 
}
</code></pre>

<p>I tried using CombineLatest and switchMap, but I cannot achieve this after my first observable complete. Appreciate if someone could help me out on this. </p>
","6786362","","","","","2020-05-27 11:25:20","how to combine multiple observables on first observable complete and return as new observable in method","<angular><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"62047826","1","","","2020-05-27 16:16:09","","2","366","<p>Having a piece of code that fetches some data to a cache, and keeps it in sync using a websocket connection, and provides an access interface to the data using an Observable, how can I know that there are no subscribers to said data at one point in time?</p>

<p>I would like to hook onto the <code>unsubscribe()</code> call for the observable (and check wether the subscribers count is 0), but I'm not sure how to achieve that.</p>

<p>The real life scenario is a graphql query (apollo-angular), and a websocket subscription to keep the data in sync. Once there is no subscribers to the data (the user navigated to another page for ex.), the websocket connection could be closed to save server resources, but the data needs to be deleted from the cache at the same time, otherwise it might go out of sync, as there are no push events received from the server anymore, in case the user navigates back again.
I'm reluctant to keep data in the cache that is stale.</p>

<p>So... How can I hook into the event that a observable is being destroyed / all subscribers have unsubscribed to delete the data from the cache as well? The service sets up a graphql query and sets up the subscription to listen for changes, returning the Observable, but i'm not sure how can I tear the thing down, as the instance has been passed on the the user code.</p>

<p>I'm not looking for network-only, circumventing the cache, and similar setups of the apollo client, I'm looking for a way to actually use, but keep the data in the apollo cache clean and up to date, as the server provides a way to do that.</p>
","1726544","","","","","2020-05-27 20:42:30","RxJS unsubscribe hook","<angular><rxjs><graphql><rxjs-observables><apollo-angular>","1","1","","","","CC BY-SA 4.0"
"62075160","1","","","2020-05-28 21:53:07","","0","146","<p>My app is integrated with ASP.NET MVC and works with a cookie-based authentication. </p>

<p>At first, I run a config method to get the basic user ID &amp; culture that needs to pass in subsequent calls, using <code>APP_INITIALIZER</code>, this resolved in 72 ms:</p>

<p><a href=""https://i.stack.imgur.com/5x4Vx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5x4Vx.png"" alt=""enter image description here""></a> </p>

<p>This sets a cookie in the browser via </p>

<p><strong>Response header:</strong></p>

<pre><code>Set-Cookie: access-cookie=iT0VQOmOIn-NcJNGoJ3Qc32iLUnxsyIe3GLexNmtqq6sIiGSEHCCs8unI-m_F_hZsVmwtlLRPx-5zxomc5tusNXDC5I1; expires=Thu, 28 May 2020 21:42:21 GMT; path=/
</code></pre>

<p>This token is further used by next API call (automatically) like:</p>

<p><strong>Request Header:</strong></p>

<pre><code>access-token: iT0VQOmOIn-NcJNGoJ3Qc32iLUnxsyIe3GLexNmtqq6sIiGSEHCCs8unI-m_F_hZsVmwtlLRPx-5zxomc5tusNXDC5I1
</code></pre>

<p><a href=""https://i.stack.imgur.com/QV8zR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QV8zR.png"" alt=""enter image description here""></a></p>

<p>As you can see call took really long time to resolve.</p>

<p>Now if I copy the same <code>access-token</code> to the parameters in Postman and run it from my local machine, it's resolved in 732ms</p>

<p><a href=""https://i.stack.imgur.com/XQTZX.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/XQTZX.png"" alt=""enter image description here""></a></p>

<p>I have no idea why it is like this.</p>

<p>My Angular code:</p>

<pre><code>ngOnInit(): void {
    this.getData().subscribe({
      next: e =&gt; console.log(e)
    });
}

getData() {
    return  this.http.post('./api/Portfolio/GetUiData', this.configService.getHeaderParams());
}
</code></pre>
","1032248","","13302","","2020-05-29 04:36:17","2020-05-29 04:36:17","Why do Angular 9 http calls take longer compared to Postman?","<c#><angular><asp.net-mvc><http><rxjs-observables>","0","3","","","","CC BY-SA 4.0"
"62085811","1","","","2020-05-29 12:18:30","","0","141","<p>We are using ChangeDetectionStrategy Onpush in all the components, so we are following dump/smart component approach, so we are keeping all the logical part in service/facade side.</p>

<p>Right now we need to generate dynamic controls using Reactive Forms, FormGroup, FormArray, </p>

<p>So we are preparing FormGroup and FormArray in service side, and passing these to dump component as Input parameter, in this case I couldn't pass these as behaviour subject as observable, I'm directly passing as Input parameter.</p>

<p>If anything changes in FormArray, it doesn't not reflect in dump component due to the OnPush changeDectionStrategy.</p>

<p>I have mocked the implementation in this <a href=""https://stackblitz.com/edit/angular-formarray-changedection"" rel=""nofollow noreferrer"">stackblitz</a></p>

<p>In this sample, I have prepared FormArray, FormGroup in service file, and passing to dump component via smart component.</p>

<p>I couldn't find proper samples on Behavioursubject and Abstract control, </p>

<p>If it is possible to pass FormArray, FormGroup as Observable, Kindly help me to know.</p>
","3142515","","","","","2020-05-29 12:27:26","Angular Reactive Form - FormArray ChangeDection onPush not working","<angular><rxjs><angular-reactive-forms><angular-forms><rxjs-observables>","1","5","","","","CC BY-SA 4.0"
"62133525","1","62134083","","2020-06-01 13:37:31","","1","334","<p>I have a method that returns roles of a user like:</p>

<pre><code>  getUserRoles() : Observable&lt;string[]&gt; {
    return this.getToken().pipe(
      map(token =&gt; {
        let payload = decode(token);
        return payload[""roles""];
      })
    )
  }
</code></pre>

<p>I'm trying to use this in an anchor to hide/show the item based on a role like:</p>

<pre><code>&lt;a *ngIf=""(authService.getUserRoles | async).includes('admin')"" routerLink=""/admin"" clrDropdownItem&gt;Admin&lt;/a&gt;
</code></pre>

<p>However, I get the compiler error:</p>

<pre><code>ERROR in src/app/components/profile/profile.component.html:15:18 - error TS2769: No overload matches this call.
  The last overload gave the following error.
    Argument of type '() =&gt; Observable&lt;string[]&gt;' is not assignable to parameter of type 'Promise&lt;unknown&gt;'.
      Type '() =&gt; Observable&lt;string[]&gt;' is missing the following properties from type 'Promise&lt;unknown&gt;': then, catch, [Symbol.toStringTag], finally

15       &lt;a *ngIf=""(authService.getUserRoles | async).includes('admin')"" routerLink=""/admin"" clrDropdownItem&gt;Admin&lt;/a&gt;
                    ~~~~~~~~~~~~~~~~~~~~~~~~~

  src/app/components/profile/profile.component.ts:7:16
    7   templateUrl: './profile.component.html',
                     ~~~~~~~~~~~~~~~~~~~~~~~~~~
    Error occurs in the template of component ProfileComponent.
</code></pre>

<p>Can't quite figure out what I'm doing wrong. I'm using Angular 9.</p>
","5387794","","5387794","","2020-06-01 14:18:46","2020-06-02 13:32:57","Observable<string[]> in ngIf directive","<angular><angular-ng-if><rxjs-observables>","2","10","","","","CC BY-SA 4.0"
"62153413","1","62153555","","2020-06-02 13:41:49","","0","77","<p>How do I make this line return a value in the subscribe ? It is returning an observable instead:</p>

<pre><code>let test = undefined;
of(test, this.myService.whatever(var1, var2))
    .pipe(
        first(n=&gt;!!n) 
    ).subscribe(result=&gt;console.log(result)); // returns Observable, should return value.
</code></pre>

<p>myservice.whatever returns an observable. I want to make it resolve inside pipe. Something like this:</p>

<pre><code>let test = undefined;
of(test, this.myService.whatever(var1, var2))
    .pipe(
        first(n=&gt;!!n),
        getValueFromObserver() // if it's an observer get the value
    ).subscribe(result=&gt;console.log(result)); 
</code></pre>

<p>Is this possible ? 
What I'm trying to do is check inside the observer's sequence if a local variable has a value and if it doesn't, then get the value from the backend. I want to make this because the real code is far more complex and the result of this observable will be forkJoined with other observers.</p>
","2752520","","6782707","","2020-06-03 03:50:14","2020-06-03 03:50:14","How can I get a value from an observer inside another?","<angular><typescript><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"62164945","1","62165878","","2020-06-03 03:51:35","","0","298","<p>I'm likely missing something simple but can't quite puzzle this out from the docs. I'd simply like to have a function that when called will emit a value on an rxjs observable.</p>

<p>Psuedocode:</p>

<pre><code>const myFunction = () =&gt; true //or whatever value
const myObservable = ... emit true whenever myFunction is called

...use myFunction somewhere where it being called is a useful event so 
observers of myObservable can process it
</code></pre>

<p>What's the standard pattern to emit a value when a function is called with rxjs?</p>
","1294382","","","","","2020-06-03 05:33:25","Rxjs create an observable that emits when a function is called","<rxjs><rxjs-observables>","2","1","","","","CC BY-SA 4.0"
"62180284","1","","","2020-06-03 18:37:26","","0","137","<p>I'm using an rxjs observable to model a sequence of steps that occurs in my app.</p>

<p>Pseudocode</p>

<pre><code>const steps = [{id: ""step1""}, {id: ""step2""}, {id: ""step3""}]

//... then at some point later do things based on the steps
from(steps).pipe(
    concatMap((step) =&gt; {
        ... do stuff with each step, perhaps including needing to go back to previous step
    })
)
</code></pre>

<p>Given this pattern how might I model ""going back"" if some condition makes it necessary?</p>

<p>For example going from step1 -> step2 -> step3 -> step2 -> step3</p>

<p>From what I can tell rxjs seems to be pretty strictly one-way-linear. I haven't found a way to set the position/index of an observable (if that's the right way to conceptualize it).</p>

<p>Apologies if I'm missing something obvious but it seems like this could be a fairly common use case for observables created from arrays.</p>
","1294382","","","","","2020-06-04 15:24:27","How to set current index of or move backwards though an rxjs observable?","<rxjs><rxjs6><rxjs-pipeable-operators><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"62225553","1","","","2020-06-05 23:34:40","","0","38","<p>I am working on some dialogs with angular 9 and I came into a situation where I need to unsubscribe from a Subject after the first emission.</p>

<p>Initially, I thought of piping the subject using the <code>take(1)</code> or <code>first()</code> operator and subscribe to this ""transformed finite subject"". So the unsubscription will be handled automatically just after the first emissions ocurrs, because when an observable completes the unsubscription logic is called. Example:</p>

<pre class=""lang-js prettyprint-override""><code>const subject = new Subject();

subject.pipe(take(1)).subscribe(console.log);

subject.next(""hola"");
</code></pre>

<p>But then I have also found this ""hack"" that I think its also working, can someone confirm?</p>

<pre class=""lang-js prettyprint-override""><code>const subject = new Subject();

const subscription = subject.subscribe((value) =&gt; {
  console.log(value);
  subscription.unsubscribe(); // &lt;----- this is the magic line
}

subject.next(""hola"");
</code></pre>

<p>I have never seen this before, I think its convenient in some occasions. The thing that confused me is that the observer is calling the subscription defined in the same line. Is this good practice? Is there any other way of achieving this?</p>

<p>Thanks!</p>
","155915","","155915","","2020-06-05 23:44:16","2020-06-06 00:04:13","How can I unsubscribe from Observable/Subject on the first emission while defining the observer","<angular><typescript><observable><rxjs-observables>","1","0","1","","","CC BY-SA 4.0"
"62238784","1","","","2020-06-06 22:31:29","","1","193","<p>I'm new to RxJs and need help/understanding for the following.</p>

<p>I have page that displays current covid cases.  I have it setup to poll every 60 seconds. What I'm trying to understand is, if I subscribe to this observable via another new component, I have wait until the next iteration of 60 seconds is complete to get the data.  My question is, if I want to share, is there any way to force to send the data and restart the timer? </p>

<p>I don't want 2 different 60 second intervals calling the API.  I just want one, and the interval to restart if a new subscriber is initialized. Hope that makes sense.</p>

<pre><code>this.covidCases$ = timer(1, 60000).pipe(
      switchMap(() =&gt;
        this.covidService.getCovidCases().pipe(

          map(data =&gt; {
            return data.cases;
          }),
        ),
      ),
      retry(),
      share(),
    );
</code></pre>
","866206","","866206","","2020-06-07 14:23:15","2020-06-07 18:00:31","rxjs share with interval causes issue when waiting for next interval iteration","<rxjs><rxjs-observables>","3","3","","","","CC BY-SA 4.0"
"62245125","1","62245228","","2020-06-07 12:10:53","","0","32","<p>I'm trying to print out the <code>long_name</code> for the item that has <code>types === ""locality""</code>. I'm using Angular and httpClient, which makes an observable. I'm lost in the complexity of rxjs and js.
Can anyone help?</p>

<p>Service:</p>

<pre><code>getGoogleGeo2(postalCode: string) {
    return this.http
      .get(`https://maps.googleapis.com/maps/api/geocode/json?address=${postalCode}ES&amp;key=${api}`)
      .pipe(map(&lt;T&gt;(item) =&gt; item.results[0].address_components));
  }
</code></pre>

<p>Component:</p>

<pre><code>this.geoService.getGoogleGeo2(postalCode).subscribe((item) =&gt; console.log(item));
</code></pre>

<p>I'm getting this in my console.log:</p>

<pre><code>[
  { long_name: ""08820"", short_name: ""08820"", types: [""postal_code""] },

  { long_name: ""El Prat de Llobregat"", short_name: ""El Prat de Llobregat"", types: [""locality"", ""political""] },
];
</code></pre>

<p>In my component I'll need to save the value <code>El Prat de Llobegrat</code>, to then be used in html.</p>
","3240410","","","","","2020-06-07 13:04:24","Return the ""long_name"" for the item that has types ""locality""","<angular><rxjs><httpclient><subscribe><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"62254252","1","","","2020-06-08 02:48:53","","1","105","<p>Below is my code snippets. I wonder why it NEVER run into the completion handler?
What I wanted to do is, first call serviceA to get objectA with given route param['key'], and then call serviceB to get objectB. So, objectB depends on result of objectA which depends on given param['key'].</p>

<p>p.s. I am using Angular 7 with rxjs6</p>

<pre><code>ngOnInit() {
    this.route.params.pipe(
      mergeMap(
        (params: Params) =&gt; {
          this.key = params.key;
          return this.serviceA.getObjectA(this.key);    // http request service to backend
        }
      ),
      mergeMap(
        (objectA: ObjectA) =&gt; {
          // do something with objectA

          return this.serviceB.getListOfObjectB();  // http request service to backend
        }
      )
    ).subscribe(
      (objectBList: ObjectB[]) =&gt; {
        for (const b of objectBList) {
          // do something with objectB
        }
        // the code execution ends here
      },
      () =&gt; {
        // error handler
      },
      () =&gt; {
        // completion handler
        // the code execution NEVER comes to here, WHY??
      }
    );
  }
</code></pre>
","12635883","","","","","2020-06-08 09:40:22","Angular observables never come to completion handler","<angular><rxjs><angular2-observables><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"62260337","1","62260505","","2020-06-08 10:48:33","","0","68","<p>I'm writing an app with Angular 8. I'm kind of new to the framework coming from AngularJS. I have a lot of experience with Promises.</p>

<p>I have HTTP requests to my backend API. These are just GET &amp; POST calls as there aren't any WebSockets in our Delphi backend. I have successfully called out backend API and used promises.</p>

<p>My code calls the backend API to get a string value that I want to display to the user.</p>

<p>I'm wondering how I can refactor my code to use Observables and if there is any benefit in doing so?</p>

<p>Service</p>

<pre><code>import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { ILicenseInfo } from './ilicense-info';

@Injectable({
    providedIn: 'root'
})
export class AboutService {

    constructor(private http: HttpClient) { }

    public getVersionNumber() {

        const endpoint: string = 'myEndpoint';

        const params = {
            password: 'yes'
        };

        return this.http.post&lt;ILicenseInfo&gt;(endpoint, params)
            .toPromise()
            .then((response: ILicenseInfo) =&gt; {
                return response.versionNumberField;
            });

    }

}
</code></pre>

<p>Component</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { Constants } from '../../../../app/core/constants/constants.service';
import { AboutService } from './about.service';

@Component({
    selector: 'ns-about',
    templateUrl: './about.component.html',
    styleUrls: ['./about.component.css']
})
export class AboutComponent implements OnInit {

    public version: string;

    constructor(private aboutService: AboutService) { }

    public ngOnInit(): void {

        this.aboutService.getVersionNumber().then((response: string) =&gt; {
            this.version = response;
        });

    }

}
</code></pre>

<p>Template</p>

<pre><code>&lt;FlexboxLayout&gt;

    &lt;FlexboxLayout&gt;
        &lt;Label text=""Version:""&gt;&lt;/Label&gt;
        &lt;Label text=""{{version}}""&gt;&lt;/Label&gt;
    &lt;/FlexboxLayout&gt;

&lt;/FlexboxLayout&gt;
</code></pre>
","1261710","","","","","2020-06-08 13:21:28","Angular - would observables benefit me in a basic HTTP POST request vs promises?","<angular><http><nativescript><rxjs-observables>","1","0","2","","","CC BY-SA 4.0"
"62326617","1","62326702","","2020-06-11 14:23:45","","0","80","<p>How do I merge two function returns (one returns a promise, one returns a object) from an Observables?
How do I chain the results? What is the proper way to do this?</p>

<pre><code>functionReturnObservable(
        element: SomeInterface,
    ): Observable&lt;Interface&gt; {
        return this.someService.fn2ReturnObservable().pipe(
            map((result) =&gt; {
                // the promise function needs to merge with the funcObject
                const updatedElement= from(this.fnPromise(element))
                return this.funObject(updatedElement, result);
            }),
        );
    }

funcObject(
        updatedElement: Readonly&lt;Interface&gt;,
        listItems: IInterface[],
    ): IObject {
        // returns a revised Object
        return updatedObjects;
    }

async fnPromise(elements: IElements): Promise&lt;SomeInterface&gt; {
        // ... some other stuff 
        let result;
        result.Name = ""John""
        if( elements.References) {
            await this.otherService
            .lookup(elements.References)
            .then((result) =&gt; {
                result.Secret= result;
            });
        }
        return result;
    }
</code></pre>
","3232194","","","","","2020-06-11 14:28:14","Merging an Observable and Promise to an Object","<angular><rxjs><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"62352744","1","62353656","","2020-06-12 21:25:22","","2","93","<p>This title probably needs more explanation.</p>

<p>Basically what I get from the backend is an Observable with an array of racedrivers, and to each of the array items, I want to map another property isOnTrack, which consists of another Observable (simple boolean) I retrieve from the backend. I want to flatten the end result so I don't have an Observable within an Observable. I've tried many of the rxjs operators but I cannot get it to work.</p>

<p>Code that doesn't work:</p>

<pre><code>this.drivers$ = this.db.list('users').valueChanges().pipe(
  map(arr =&gt; arr.map( (driver:any) =&gt; {
    driver.isOnTrack = this.db.object(`telemetry/${driver.uid}/values/IsOnTrack`).valueChanges();
     return driver
  })),
  mergeAll()
);
</code></pre>

<p>This successfully maps the isOnTrack observable to the array items but I can't get it flattened.</p>

<p>Project is on RxJS 6</p>

<p><strong>Update 1</strong></p>

<p>After Jonathan's answer I believe I should have used the word unpacked instead of flattening</p>

<p>The Observable after transformations that I would be looking for should deliver something similar to</p>

<pre><code>of([
  {id: 1, name: 'foo', isOnTrack: true},
  {id: 2, name: 'bar', isOnTrack: true},
  {id: 3, name: 'baz', isOnTrack: false},
])
</code></pre>

<p>and after one IsOnTrack is changed in the backend it should emit the complete array again.</p>

<pre><code>of([
  {id: 1, name: 'foo', isOnTrack: false},
  {id: 2, name: 'bar', isOnTrack: true},
  {id: 3, name: 'baz', isOnTrack: false},
])
</code></pre>
","1306861","","12336882","","2020-06-14 15:33:54","2020-06-14 15:33:54","Mapping an Observable in array items of another Observable, flattening the result","<typescript><rxjs><angularfire><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"62400272","1","62400512","","2020-06-16 03:03:42","","0","777","<p>I am trying to show response from an observable on console that comes from a service in my angular project. But it appears to be undefined. When I try with a loop, the error in console says it is not iterable while the observable is supposed to return an array. Why could this be happening?</p>

<p><strong>Component</strong></p>

<pre><code>@Component({
  selector: 'app-heroes',
  templateUrl: './heroes.component.html',
  styleUrls: ['./heroes.component.css']
})
export class HeroesComponent implements OnInit {

  heroes: Hero[];          

  constructor(private heroService: HeroService, private messageService: MessageService) { }

  getHeroes(): void {
    this.heroService.getHeroes()
    .subscribe(data =&gt; this.heroes = data);     
  }


  ngOnInit() {
    this.getHeroes();
    // for(let hero of this.heroes){
    //   console.log(hero);
    // }
    console.log(this.heroes);
  }

}
</code></pre>

<p><strong>Service</strong></p>

<pre><code>@Injectable({
  providedIn: 'root'
})
export class HeroService {

  private heroesUrl = 'api/heroes';  

  constructor(
    private messageService: MessageService,
    private http: HttpClient
  ) { }

  httpOptions = {
    headers: new HttpHeaders({ 'Content-Type': 'application/json' })
  };

  getHeroes(): Observable&lt;Hero[]&gt; {
    return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
    .pipe(
      tap(_ =&gt; this.log('fetched heroes')),
      catchError(this.handleError&lt;Hero[]&gt;('getHeroes', []))
    );
  }


  private log(message: string) {
    this.messageService.add(`HeroService: ${message}`);
  }

  private handleError&lt;T&gt;(operation = 'operation', result?: T) {
    return (error: any): Observable&lt;T&gt; =&gt; {

      console.error(error); 

      this.log(`${operation} failed: ${error.message}`);

      return of(result as T);
    };
  }

}
</code></pre>
","12985903","","119732","","2020-06-16 05:05:51","2020-06-16 05:05:51","showing by console.log an observable array in angular 8","<arrays><angular><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"62415271","1","","","2020-06-16 18:27:36","","0","876","<p>I have a backend api to create new product. The frontend angular code needs to call a backend API. How to carry out error handling using ** .subscribe**. I'm using <em>HTTPClient</em> and using <em>Observable</em> and been reading about how RXJS utilizes error handling,</p>

<p>The app should call it as Observable and .subscribe(). </p>

<p>the api /create should handle success and failure(error) 
- If API returns 200: it should print success
- If API returns 400, should throw an error</p>

<p><strong>pseudo code</strong></p>

<pre><code>import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable } from 'rxjs/Observable';

ID = 'foo';
            this.http.post('/api/create', {
                productName: this.form.value.productName,
                productValue: this.form.value.productValue,
            }).subscribe(
                resp =&gt; this.onSubmitSuccess(resp), err =&gt; this.onSubmitFailure(err)
            );


private onSubmitSuccess(resp) {
        console.log(resp);
        this.ID = resp.ID;
        this.submitSuccess = true;
        this.submitFailed = false;
    }

    private onSubmitFailure(resp) {
        console.log(resp);
        this.submitFailed = true;
        this.submitSuccess = false;
    }  ```

</code></pre>
","2762855","","2762855","","2020-06-16 20:10:11","2020-06-16 23:29:42","RXJS Angular - Error handling using .subscribe and Observable","<typescript><error-handling><rxjs><httpclient><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"62416534","1","62416646","","2020-06-16 19:54:14","","-1","104","<p>I have a service with this code:</p>

<pre><code>cars() {
    return 'something here';
}
</code></pre>

<p>Then from the component I want to get the data with an observable so I'm doing this:</p>

<pre><code>getcars() {
    this.dataService.cars().subscribe((result) =&gt; {
      console.log(result);
  });
}
</code></pre>

<p>I cannot do this as I'm getting: </p>

<pre><code>Error: Property 'subscribe' does not exist on type 'string'.
</code></pre>

<p>How can I fix this?</p>
","13282175","","","","","2020-06-16 20:01:20","Angular cannot call method from service with observable","<angular><typescript><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"62434358","1","62434831","","2020-06-17 16:57:26","","1","68","<p>To ensure an error doesn't complete the <strong>outer</strong> observable, a common <a href=""https://ngrx.io/guide/effects"" rel=""nofollow noreferrer"">rxjs effects</a> pattern I've adopted is:</p>

<pre class=""lang-js prettyprint-override""><code> public saySomething$: Observable&lt;Action&gt; = createEffect(() =&gt; {

    return this.actions.pipe(

      ofType&lt;AppActions.SaySomething&gt;(AppActions.SAY_SOMETHING),

      // Switch to the result of the inner observable.
      switchMap((action) =&gt; {
        // This service could fail.
        return this.service.saySomething(action.payload).pipe(
          // Return `null` to keep the outer observable alive!
          catchError((error) =&gt; {
            // What can I do with error here?
            return of(null);
          })
        )
      }),

      // The result could be null because something could go wrong.
      tap((result: Result | null) =&gt; {
        if (result) {
          // Do something with the result!
        }
      }),

      // Update the store state.
      map((result: Result | null) =&gt; {
        if (result) {
          return new AppActions.SaySomethingSuccess(result);
        }
        // It would be nice if I had access the **error** here. 
        return new AppActions.SaySomethingFail();
      }));
});
</code></pre>

<p>Notice that I'm using <code>catchError</code> on the <strong>inner</strong> observable to keep the <strong>outer</strong> observable alive if the underlying network call fails (<code>service.saySomething(action.payload)</code>):</p>

<pre class=""lang-js prettyprint-override""><code>catchError((error) =&gt; {
  // What can I do with error here?
  return of(null);
})
</code></pre>

<p>The subsequent <code>tap</code> and <code>map</code> operators accommodate this in their signatures by allowing <code>null</code>, i.e. <code>(result: Result | null)</code>. However, I lose the error information. Ultimately when the final <code>map</code> method returns <code>new AppActions.SaySomethingFail();</code> I have lost any information about the error.</p>

<p>How can I keep the error information throughout the pipe rather than losing it at the point it's caught?</p>
","828547","","","","","2020-06-17 22:58:47","Keeping error information and the outer observable alive","<rxjs><ngrx><ngrx-effects><rxjs-observables>","2","4","","","","CC BY-SA 4.0"
"62486841","1","62491925","","2020-06-20 14:04:18","","0","2060","<p>I'm pretty much a standstill with this now guys. I'm using a small service to get the details from an API, returning a JSON object. I am returning this as an Observable from the service method; then initialising the local component variable &quot;sateliteData$&quot; with it on class creation.</p>
<p>In the HTML I'm trying to use the | async pipe to handle automatic change detection as the values from this API, change every second. But when looking at my application, it gets the first set of values and displays them to the screen, but never updates them.</p>
<p>You have to manually refresh the page to get different values, which is what I'm trying to avoid by using Observables and the | async pipe.</p>
<p>I've read so much online, and everything I'm doing seems to match what everyone else does. I just can't figure this out and would really appreciate someone taking the time to have a look at this for me.</p>
<p>See below screen grabs of the code.</p>
<p>Thanks guys.</p>
<p><a href=""https://i.stack.imgur.com/NowJT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/NowJT.png"" alt=""r"" /></a></p>
<p><a href=""https://i.stack.imgur.com/w3gdD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/w3gdD.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.stack.imgur.com/fM3mB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fM3mB.png"" alt=""enter image description here"" /></a></p>
","8651857","","","","","2020-06-20 21:31:43","Angular V9 Async pipe not updating template view on data change","<typescript><angular2-template><angular2-pipe><rxjs-observables><async-pipe>","1","0","","2020-06-22 00:15:19","","CC BY-SA 4.0"
"62523517","1","","","2020-06-22 21:08:32","","0","209","<p>i created a service by driving my service from</p>
<pre><code>EntityCollectionServiceBase&lt;Transaction&gt;
</code></pre>
<p>My entity is called Transaction.</p>
<p>i am overriding the getAll method like this</p>
<pre><code>  getAll(): Observable&lt;Transaction[]&gt; {
return this.http
  .get&lt;ApiResponse&gt;('https://localhost:xxxx/transaction/GetLastSixMonth')
  .pipe(
    tap((data) =&gt; {
      this.notifyService.showSuccess(data.message, 'Sucess');
    }),
    map((res) =&gt; res.result),
    catchError((err) =&gt; {
      this.notifyService.showError(
        'Error While Six Month Transactions',
        'Error'
      );
      return of();
    })
  );
}
</code></pre>
<p>i am calling this getAll somewhere appropriate.</p>
<p>so in the component where i want to use it i am using the &quot;entities$&quot; property of this service like this</p>
<pre><code>this.last6MonthWithdrawCount$ = this.transactionsDataService.entities$.pipe(
  map((transactions) =&gt; {
    const res = transactions.filter(
      (transaction) =&gt;
        transaction.transactionType === TransactionType.Withdraw
    ).length;
    return res;
  })
);
</code></pre>
<p>so this variable &quot;this.last6MonthWithdrawCount$ &quot; works fine when i use it in html using asyn operator.</p>
<pre><code>{{ last6MonthWithdrawCount$  | async }}
</code></pre>
<p>but when i want to read its value in the code by subscribing to it</p>
<pre><code>this.last6MonthWithdrawCount$.subscribe(x =&gt; this.withdrawCount = x);
</code></pre>
<p>i dont get proper value. i get 0 . looks like it is giving me first value in the stream.</p>
<p>how to get the last value ?
<strong>UPDATE</strong>
or simply how can i get the value from this.last6MonthWithdrawCount$ in the code.
actually this value is supposed to be passed to a graph data. i have graph that shows the value and also i have to pass the same value in data array of a graph.</p>
<p><a href=""https://i.stack.imgur.com/CrrS8.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CrrS8.png"" alt=""enter image description here"" /></a></p>
<p>this value 45 (same sort of stuff for the value 10) is coming from
entities$.pipe code mentioned above and in the html i am doing a simple | async as mentioned above, and it works.</p>
<p>i have to pass the same 2 values in data of my chartJS chart.</p>
<pre><code>  this.myChartData.data.datasets[0].data = [this.depositCount, this.withdrawCount];
</code></pre>
<p>how to get this value from that observable ? the same that is working in html.</p>
","2624698","","2624698","","2020-06-23 01:11:57","2020-06-23 01:11:57","subscribing to observable returned from ngrx's Entity Collection Service not returning proper result","<angular><ngrx><rxjs-observables><ngrx-entity><angular-ngrx-data>","0","3","","","","CC BY-SA 4.0"
"62532007","1","","","2020-06-23 09:54:20","","0","130","<p>I am calling the API using retrofit in ApiClient Class. Where I am trying to store the output of successful login either message or responseBody into the output string. I tried using the output string as part of ViewModel Observer type too</p>
<p>But I CANNOT pass the value of output from AplClient to MainActivity</p>
<p>APICLIENT</p>
<pre><code>...
package com.example.services.api


lateinit var service: ApiInterface



object ApiClient {

    @JvmStatic
    private val BASE_URL = GlobalConstants.SWAGGER
    //private val sharedPrefClass = SharedPrefClass()
    @JvmStatic
    private var mApiInterface: ApiInterface? = null
    var output = &quot;Initializing&quot;


    // val sharedPrefClass: SharedPrefClass? = null


  //  @JvmStatic
  //  fun getApiInterface(): ApiInterface {
  //      return setApiInterface()
  //  }

    @JvmStatic
    fun setApiInterface() : String {
        val platform = GlobalConstants.PLATFORM
        var mAuthToken = GlobalConstants.SESSION_TOKEN
        var companyId = GlobalConstants.COMPANY_ID
        var phone     = phone
        var cCode     = cCode


        //Here a logging interceptor is created
        //Here a logging interceptor is created
        val logging = HttpLoggingInterceptor()
        logging.setLevel(HttpLoggingInterceptor.Level.BODY)

        //The logging interceptor will be added to the Http client

        //The logging interceptor will be added to the http client
        val httpClient = OkHttpClient.Builder()
        httpClient.addInterceptor(logging)

       //The Retrofit builder will have the client attached, in order to get connection logs

       //The Retrofit builder will have the client attached, in order to get connection logs
        val retrofit: Retrofit = Retrofit.Builder()
            .client(httpClient.build())
            .addConverterFactory(GsonConverterFactory.create())
            .baseUrl(BASE_URL)
            .build()
        service = retrofit.create&lt;ApiInterface&gt;(ApiInterface::class.java)

        val call: Call&lt;Tree&gt; = service.post(phone, cCode, companyId, platform)

        var model: Model



        call.enqueue(object : Callback&lt;Tree&gt; {
            override fun onResponse(
                call: Call&lt;Tree&gt;, response: Response&lt;Tree&gt;)
            {

                Log.e(TAG, &quot;Success&quot;)

                if (!response.isSuccessful()) {
                    model = Model(&quot;Success&quot;, &quot;91&quot;, &quot;8884340404&quot;)

                    model.output += response.body().toString()

                    return;
                }


            }

            override fun onFailure(
                call: Call&lt;Tree&gt;,
                t: Throwable
            ) {

                Log.e(TAG, &quot;Json/Network Error&quot;)

                model = Model(&quot;Json/Network Error&quot;, &quot;91&quot;, &quot;8884340404&quot;)

                model.output = &quot;Json/Network Error&quot;
                // handle execution failures like no internet connectivity
            }
        })
        return output
    }



}

VIEWMODEL
package com.example.kotlinloginapi.viewModel

import androidx.databinding.Observable
import androidx.databinding.ObservableField
import androidx.lifecycle.MutableLiveData

class Model {

    var output:String? = null
    var cCode:String? = null
    var phone: String? = null

    constructor(output: String?, cCode: String?, phone: String?) {
        this.output = output
        this.cCode = cCode
        this.phone = phone
    }
}

...

MAINACTIVTY

...

package com.example.kotlinloginapi.ui.login

lateinit var textView: TextView

class MainActivity : AppCompatActivity() {

    lateinit var mainBinding : ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        mainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)
        textView = findViewById&lt;TextView&gt;(R.id.textView)


        val mApiService: ApiService&lt;Tree&gt;

        val mApiClient = ApiClient

        var model: Model

        model = Model(&quot;Creating View&quot;, &quot;91&quot;, &quot;8884340404&quot;)

        model.output = &quot;Creating View&quot;


        Observable.just(setApiInterface())
            .subscribe {
                println(it)
                textView!!.append(setApiInterface())}

//        mainBinding.viewModel!!.output = &quot;Creating View&quot;

        textView.append(&quot;\n&quot; + model.output)


        /*fun getLoginData(jsonObject : JsonObject?) {
        if (jsonObject != null) {
            val mApiService = ApiService&lt;JsonObject&gt;()
            mApiService.get(
                object : ApiResponse&lt;JsonObject&gt; {
                    override fun onResponse(mResponse : Response&lt;JsonObject&gt;) {
                        val loginResponse = if (mResponse.body() != null)
                            finish()
                        else {
                            output = mResponse.body().toString()
                        }



                    }

                    override fun onError(mKey : String) {
                        Toast.makeText(
                            applicationContext,
                            &quot;Error&quot;,
                            Toast.LENGTH_LONG
                        ).show()

                    }

                }, ApiClient.getApiInterface().callLogin(jsonObject)

            )

        }

    }*/
    }

}

LOGINACTIVITY

package com.example.kotlinloginapi.ui.login

lateinit var cCode: String
lateinit var phone: String

class LoginActivity : AppCompatActivity() {

    lateinit var loginBinding : ActivityLoginBinding

   lateinit var eTcCode: EditText
   lateinit var eTphone: EditText

    private lateinit var loginViewModel: LoginViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        loginBinding = DataBindingUtil.setContentView(this, R.layout.activity_login)

        eTcCode = findViewById&lt;EditText&gt;(R.id.etcCode)
        eTphone = findViewById&lt;EditText&gt;(R.id.etPhone)
        val login = findViewById&lt;Button&gt;(R.id.login)
        val loading = findViewById&lt;ProgressBar&gt;(R.id.loading)

        var model = Model(&quot;Binding Model&quot;, &quot;91&quot;, &quot;8884340404&quot;)


        loginBinding.model = model

        loginBinding.lifecycleOwner



        loginViewModel = ViewModelProviders.of(this, LoginViewModelFactory())
                .get(LoginViewModel::class.java)

        loginViewModel.loginFormState.observe(this@LoginActivity, Observer {
            val loginState = it ?: return@Observer

            // disable login button unless both username / password is valid
            login.isEnabled = loginState.isDataValid

            if (loginState.usernameError != null) {
                eTcCode.error = getString(loginState.usernameError)
            }
            if (loginState.passwordError != null) {
                eTphone.error = getString(loginState.passwordError)
            }
        })

        loginViewModel.loginResult.observe(this@LoginActivity, Observer {
            val loginResult = it ?: return@Observer

            loading.visibility = View.VISIBLE
            if (loginResult.error != null) {
                showLoginFailed(loginResult.error)
            }
            if (loginResult.success != null) {
                updateUiWithUser(loginResult.success)
            }
            setResult(Activity.RESULT_OK)

            //Complete and destroy login activity once successful
            finish()
        })

        eTcCode.afterTextChanged {
            loginViewModel.loginDataChanged(
                    eTcCode.text.toString(),
                    eTphone.text.toString()
            )
        }

        eTphone.apply {
            afterTextChanged {
                loginViewModel.loginDataChanged(
                        eTcCode.text.toString(),
                        eTphone.text.toString()
                )
            }

            setOnEditorActionListener { _, actionId, _ -&gt;
                when (actionId) {
                    EditorInfo.IME_ACTION_DONE -&gt;
                        loginViewModel.login(
                                eTcCode.text.toString(),
                                eTphone.text.toString()
                        )
                }
                false
            }

            login.setOnClickListener {
                loading.visibility = View.VISIBLE
                loginViewModel.login(eTcCode.text.toString(), eTphone.text.toString())
            }
        }
    }

    private fun updateUiWithUser(model: LoggedInUserView) {
        val welcome = getString(R.string.welcome)
        val displayName = model.displayName
        // TODO : initiate successful logged in experience

        cCode = eTcCode.text.toString()
        phone = eTphone.text.toString()

        var intent = Intent(this, MainActivity::class.java)
        startActivity(intent)

        Toast.makeText(
                applicationContext,
                &quot;$welcome $displayName&quot;,
                Toast.LENGTH_LONG
        ).show()



    }

    private fun showLoginFailed(@StringRes errorString: Int) {
        Toast.makeText(applicationContext, errorString, Toast.LENGTH_SHORT).show()
    }
}

/**
 * Extension function to simplify setting an afterTextChanged action to EditText components.
 */
fun EditText.afterTextChanged(afterTextChanged: (String) -&gt; Unit) {
    this.addTextChangedListener(object : TextWatcher {
        override fun afterTextChanged(editable: Editable?) {
            afterTextChanged.invoke(editable.toString())
        }

        override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}

        override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {}
    })
}


...
</code></pre>
<p>Ideally, I want to use binding observers but I am unable to pass the output of retrofit to      MainActivity even without that.</p>
","13797899","","3269958","","2020-06-23 13:08:44","2020-06-24 11:49:38","Cannot Pass output from Retrofit enqueue to MainActivity Kotlin","<android><kotlin><observable><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"62534516","1","62534582","","2020-06-23 12:16:56","","0","226","<p>I would like to have the ability to reinitialize an Observable object.
I don't know if &quot;reinitialize&quot; is the corrent term, but what I mean by that is that I would like to refresh the data</p>
<ol>
<li>without creating a new Observable object, and</li>
<li>without creating new subscriptions (existing subscriptions to the existing Observable object should work seamlessly)</li>
</ol>
<pre><code>@Injectable({
  providedIn: 'root',
})
export class MyService {
  private url = 'http://mydummydomain.com/api/entries';
  private data$: Observable&lt;any&gt;;

  constructor(private http: HttpClient) {
    this.data$ = this.http.get(this.url).pipe(
      shareReplay(1)
    );
  }

  getData(): Observable&lt;any&gt; {
    return this.data$;
  }
  
  reloadData() {
    // TODO:
    // Refresh data from the url
    // Theoretically this should be a function with no input parameters and no return value
  }
}
</code></pre>
<p>Thanks</p>
","12356861","","12356861","","2020-06-25 05:28:45","2020-06-25 05:28:45","Reinitializing an Observable object","<angular><typescript><rxjs><rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"62561889","1","","","2020-06-24 18:35:10","","0","193","<p>I have a simple async observable which takes 2 parameters to perform some calculations:</p>
<pre><code>  public preferredCurrency: string = '';

  wmData$ = this.http.get&lt;any&gt;(&quot;./api/wealthModeling/GetWMData&quot;);
  portfolioCalculation$ = this.wmData$.pipe(
    mergeMap((wmData) =&gt; {
      return this.portfolioCalculationService.getPortfolioValues(wmData, this.preferredCurrency);
    })
</code></pre>
<p>As you can see on initial load preferredCurrency is empty, However UI allows user to choose a different currency (via a dropdown) and hence the need to perform the calculations again.</p>
<p>I am not able to figure out a way to execute the <code>portfolioCalculation$</code> again.</p>
<p>Hopefully, this explains what I am trying to achieve.</p>
<p>Thanks much.</p>
","1032248","","","","","2020-06-25 18:43:22","How to re-execute async observable on parameter change?","<angular><async-await><rxjs><behaviorsubject><rxjs-observables>","2","6","","","","CC BY-SA 4.0"
"62579473","1","","","2020-06-25 15:58:24","","4","836","<p>I'm implementing an angular service that lets consumers observe various values based on their id:</p>
<p>The essence of it looks like this:</p>
<pre><code>private subjects = new Map&lt;number, Subject&lt;any&gt;&gt;();

public subscribe(id: number, observer: any): Subscription {
  // try getting subject for this id (or undefined if it does not yet exist)
  let subj = this.subjects.get(id);

  // create subject if it does not yet exist
  if (!subj) {
    subj = new Subject&lt;any&gt;();
    this.subjects.set(id, subj);
  }

  // subscribe observer
  const subscription = subj.subscribe(observer);

  // set up teardown logic (gets called when subscription is unsubscribed)
  subscription.add(() =&gt; { 
    // remove subject from the map, if this was the last subscription
    if (subj.observers.length == 0) {
      this.subjects.delete(id);
    }
  });

  // return subscription
  return subscription;
}
</code></pre>
<p><a href=""https://stackblitz.com/edit/angular-ivy-5pmwgn"" rel=""nofollow noreferrer"">Here is the full stackblitz example</a></p>
<p>The above works fine but the API is a bit cumbersome to use (in the consumers I need to manually keep track of all the subscriptions and make sure to unsubscribe them properly).</p>
<p>I would prefer to have a method that returns an <code>Observable</code> like this:</p>
<pre><code>public subscribe(id: number): Observable&lt;any&gt; {
  // TODO: Return an observable for this id and make sure that
  // its corresponding subject is in the map iff at least one of the observables
  // for this id has at least one subscription.
  
  return ...;
}
</code></pre>
<p>Because this would allow me to subscribe to the values I need directly from the component templates using the <code>async</code> pipe, where angular would take care of unsubscribing the observers.</p>
<p>But I can't quite figure out how I can implement the logic to remove unused <code>Subject</code>s from the <code>Map</code> when they are no longer used. Is there a good way to do that?</p>
<p><a href=""https://stackblitz.com/edit/angular-ivy-ohjem6"" rel=""nofollow noreferrer"">Here is an incomplete stackblitz examples with some test cases</a></p>
","487356","","487356","","2020-06-29 09:11:52","2020-06-29 12:04:27","Detect when a Subject has no more subscriptions","<angular><rxjs><rxjs-observables><subject-observer>","1","0","","","","CC BY-SA 4.0"
"62607760","1","","","2020-06-27 08:43:14","","1","448","<p>In my current angular project I have a service that returns Observable&lt;Product[]&gt;.
I would like to convert that stream to an array of Observables of  single Product.  I want to achieve this using pipe operators, without subscribing to the original stream.</p>
<p><em><strong>From Observable of &lt;entity[]&gt; to array of Observables of entity</strong></em></p>
","7757474","","7757474","","2020-06-27 09:14:01","2020-06-27 10:37:38","How to convert Observable<Product[]> to Observable<Product>[] without subscribe?","<angular><rxjs><observable><rxjs-observables><rxjs-pipeable-operators>","1","5","","","","CC BY-SA 4.0"
"62622020","1","","","2020-06-28 11:40:12","","0","61","<p>I have the following code where I need to get a value from two separate observables (they are actually promises but have been converted to observables using &quot;from&quot;) and then use the values returned from each to make a final API call where both the values are used.</p>
<p>The method should return the result from the API call which is an object called &quot;AppUser&quot;.</p>
<p>My code also has some logic in it to retry from a backup API if the primary API fails and then if the backup fails it should return the value from local storage.</p>
<p>This code does work but having read up about nested observables not being good practice I wondered if there is a better way to write this? Any advice would be appreciated.</p>
<pre><code>    // Get app user
    getAppUser(getFromLocal: boolean = false, isRetry: boolean = false): Observable&lt;AppUser&gt; {

      // If &quot;get from local&quot; is true
      if (getFromLocal) {
        return this.getAppUserFromLocal();
      } else {

        // Create observables to get values from local storage
        const customerObs = from(this.authLocal.getCustomerId());
        const authTokenObs = from(this.authLocal.getAuthToken());

        return customerObs
        .pipe(mergeMap((customerId) =&gt; {

          return authTokenObs
          .pipe(mergeMap((authToken) =&gt; {

            // API Header
            const headers = new HttpHeaders({
              'Content-Type': 'application/json',
              Accept: 'application/json',
              Authorization: `Bearer ${authToken}`
            });
            const url = (!isRetry ? this.baseUrl : this.backupBaseUrl) + '/GetAppUser?customerid=' + customerId;

            return this.http.get(url, { headers })
              .pipe(map((appUser: AppUser) =&gt; {
   
                // Set AppUser in local storage
                this.storage.set('appUser', appUser);
   
                return appUser;
              }),
              catchError(e =&gt; {

                if (!isRetry) {
                  // Try again using backup API
                  return this.getAppUser(getFromLocal, true);
                } else {
                  // Try again from local storage
                  return this.getAppUser(true, true);
                }
              }));
          }));
        }));
      }
    }
</code></pre>
<p><strong>UPDATED with potential solution</strong></p>
<p>I have updated as per the answers with the following potential solution:</p>
<pre><code>    // Get app user
    getAppUser(getFromLocal: boolean = false, isRetry: boolean = false): Observable&lt;AppUser&gt; {

      // If &quot;get from local&quot; is true
      if (getFromLocal) {
        return this.getAppUserFromLocal();
      } else {

        // Create observables to get values from local storage
        const customerId$ = from(this.authLocal.getCustomerId());
        const authToken$ = from(this.authLocal.getAuthToken());

        return forkJoin([
          customerId$,
          authToken$
        ]).pipe(
          switchMap(([customerId, authToken]) =&gt; {
            const headers = new HttpHeaders({
              'Content-Type': 'application/json',
              Accept: 'application/json',
              Authorization: `Bearer ${authToken}`
            });
            const url = (!isRetry ? this.baseUrl : this.backupBaseUrl) + '/GetAppUser?customerId=' + customerId;
            return this.http.get(url, { headers })
            .pipe(
              map((appUser: AppUser) =&gt; {
                appUser.AuthToken = authToken;
                return appUser;
              }),
              catchError(e =&gt; {
                if (!isRetry) {
                  // Try again using backup API
                  return this.getAppUser(getFromLocal, true);
                } else {
                  // Try again from local storage
                  return this.getAppUser(true, true);
                }
              }));
          }),
          tap((appUser: AppUser)  =&gt; {

            // Set AppUser in local storage
            this.storage.set('appUser', appUser);
          }),
        );
</code></pre>
","1806809","","1806809","","2020-06-28 20:59:08","2020-06-28 20:59:08","Nested observables where final API call needs to use result from both observables","<angular><typescript><rxjs><observable><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"62622725","1","62622895","","2020-06-28 12:45:23","","0","315","<p>What is the correct way to write this without using a nested subscription?</p>
<p>The first observable will return a value that is passed to the second observable, then I need to use the returned values from both observables in the final subscription.</p>
<p>Also, the &quot;doStuff&quot; method is called from a button click, do I need to also unsubscribe from these observables to prevent memory leaks?</p>
<pre><code>  doStuff() {

    // Get app user
    this.appUserService.getAppUser(true).subscribe((appUser) =&gt; {
      
      // Get login key
      this.accountApi.getLoginKey(appUser).subscribe(loginKey =&gt; {

        // Open in app browser
        this.browser = this.inAppBrowser.create(appUser.Url + loginKey, '_system');
      });
    });
  }
</code></pre>
<p><strong>Edit 1</strong></p>
<p>Tried the following as suggested but this does not compile, on the second pipe there is the following error:</p>
<p><em>Property 'pipe' does not exist on type 'OperatorFunction&lt;AppUser, any&gt;'</em></p>
<p>Then within the &quot;map&quot; function there is the following error:</p>
<p><em>Cannot find name 'appUser'.</em></p>
<pre><code>   return this.appUserService.getAppUser(true).pipe(
      switchMap((appUser: AppUser) =&gt; this.accountApi.getUserLoginKey(appUser)).pipe(
        map(loginKey =&gt; { appUser, loginKey; }),
      ),
      tap(({ appUser, loginKey }) =&gt; {
        this.browser = this.inAppBrowser.create(appUser.Url + loginKey, '_system');
      }),
      take(1)
    );
</code></pre>
<p><strong>Edit 2</strong></p>
<p>I have now updated my solution as follows which works (but I could argue my original solution did work), so I have removed the nested subscriptions but they have been replaced with nested pipes instead. I believe this is a more acceptable solution (i.e. using nested &quot;pipes&quot; rather than nested &quot;subscriptions&quot;) but not sure if it can be improved any further?</p>
<pre><code>doStuff() {
       // Get app user
        this.appUserService.getAppUser(true).pipe(
          switchMap(appUser =&gt; this.accountApi.getLoginKey(appUser).pipe(
            tap(loginKey =&gt; {
              // Open in app browser as return URL
              this.browser = this.inAppBrowser.create(appUser.Url + loginKey, '_system');
            })
          )),
          take(1)
        ).subscribe();
}
</code></pre>
","1806809","","1806809","","2020-06-30 11:23:45","2020-06-30 16:43:21","Nested observables where response from first observable is passed to the second and both responses are used in the final subscription","<angular><typescript><rxjs><observable><rxjs-observables>","3","0","","","","CC BY-SA 4.0"
"62652789","1","62653188","","2020-06-30 07:58:06","","0","48","<p>I've been working on a simple test project, but i happened to come across this really weird problem. I can't access values in an array.</p>
<pre><code>pokemonStats$: Observable&lt;PokemonStats[]&gt;;

getPokemonStats(id: number): any {
this.pokemonStats$
.pipe(take(1))
.subscribe(stats =&gt; {
  console.log(stats instanceof Array);
  console.log('length', stats.length);
  console.log('du', stats);
  console.log('test', stats[1]);
});
}
</code></pre>
<p>And this is the output:</p>
<p><a href=""https://i.stack.imgur.com/ObOKW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ObOKW.png"" alt=""Output in browser console"" /></a></p>
<p>What's going on here? A colleague suggested it might be an array-like structure, that's why i added the 'instanceof' log. Any help is greatly appreciated.</p>
<p>EDIT: here's the code, where it gets filled</p>
<pre><code>this.pokemonStats$ = this.getAllPokemonStats(ids);

getAllPokemonStats(ids: number[]): Observable&lt;PokemonStats[]&gt; {
const pokemonArray: PokemonStats[] = [];
ids.forEach(id =&gt; {
  const url = 'https://pokeapi.co/api/v2/pokemon/' + id;
  this.http.get(url)
    .pipe(take(1))
    .subscribe((data: PokemonStatsAPI) =&gt; {
      pokemonArray.push({
          id: data.id,
          name: data.name,
          speed: data.stats[0].base_stat,
          hp: data.stats[5].base_stat,
          attack: data.stats[4].base_stat,
          defense: data.stats[3].base_stat
        });
    });
});
return of(pokemonArray);
</code></pre>
<p>}</p>
","7507997","","7507997","","2020-06-30 08:15:14","2020-06-30 08:23:17","Accessing value in an Array","<arrays><angular><typescript><rxjs-observables>","1","9","","","","CC BY-SA 4.0"
"62686649","1","62686744","","2020-07-01 23:14:23","","0","36","<p>I have a service <code>carriersService</code> with method <code>getAll()</code>, which returns an <code>Observable&lt;Carrier[]&gt;</code>.
In my component, I'm trying to read route parameter <code>carrierId</code>, find the carrier with such <code>carrierId</code> and assign it to a local variable</p>
<pre><code>let carrier = null;

this.route.paramMap.pipe(
      switchMap(
        (params: ParamMap) =&gt; this.carriersService.getAll()));
</code></pre>
<p>I need to find a single Carrier from an Observable of <code>Carrier[]</code> using <code>params.get('carrierId')</code> and assign it to local carrier variable.</p>
","5481269","","","","","2020-07-01 23:27:47","Reading parameter and then finding single element in Angular","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"62694196","1","","","2020-07-02 10:24:38","","1","101","<p>I have a data store implementation that is shared among a lot of instances of the same component. I am subscribing to the observable of the store's <code>datasource</code> which is a behavior subject at all of these different component instances. I am passing data to store several times and the store notifies it using .next() in the <code>datasource</code>. But sometimes all these subscriptions are executed, sometimes only the last few are executed. I get no errors in the console as well. Any thoughts?</p>
<p>UPDATE: My application heavily uses create embedded views and dynamic module injection. So I found out that there is a delta time to get any reference for the embedded view. Which is why we use ngAfterViewInit in case of embedded views. Hence, the child components had not yet subscribed to the data stream and I had already sent data fram the parent components. But since I have multiple instances of the same component I do not want n callbacks for n ngAfterViewInit.</p>
<p>Closing this issue. Since, this is an issue/bug in my proprietary app architecture.</p>
","8311720","","8311720","","2020-07-06 06:16:31","2020-07-06 06:16:31","Multiple subscriptions to the same Behaviour Subject observable / datasource in Angular 8 intermittently fails","<angular><rxjs><angular8><behaviorsubject><rxjs-observables>","0","1","","","","CC BY-SA 4.0"
"62721318","1","","","2020-07-03 19:01:40","","4","1401","<p>I am looking for away to do &quot;lazy rendering&quot; with RxJS in Angular, what I want to achieve is the following:</p>
<pre><code>&lt;div *ngFor=&quot;let item of items$ | async&quot;&gt;
  {{item.text}}
&lt;div&gt;
</code></pre>
<p>and in the component I have:</p>
<pre><code>export class ItemsComponent implements OnInit {
  public items$: Observable&lt;Item[]&gt;;
  
  constructor(private setStore: SetStore){}

  ngOnInit() {
     const setId = 1;
     this.items$ = this.setStore.sets$.pipe(map(sets =&gt; sets.find(set =&gt; set.id = 1).items));
  }
}
</code></pre>
<p>And this works fine but when the set has +50 items, the rendering takes time and it freeze's for a second or more.
I was looking for a way to do it lazy by somehow rendering first 30 items and then do load the next 30 after 500ms and so on until the list reach's its end.</p>
<p><strong>Edit:</strong>
I have tried this approach:</p>
<pre><code>
const _items$ = this.setStore.sets$.pipe(
  map(sets =&gt; sets.find(set =&gt; set.id == 1).items)
);
const loadedItems = [];
_items$.subscribe(data =&gt; {
  this.items$ = from(data).pipe(
    concatMap(item =&gt; {
        loadedItems.push(item);
        return of(loadedItems).pipe(delay(1));
      })
    );
  });
})

</code></pre>
<p>The above works fine in terms of lazy rendering but has some disadvantages like:</p>
<ul>
<li>initially you don't have see any item in the page</li>
<li>items are loaded one by one every 1ms, not in batch</li>
</ul>
<p><em><strong>The above codes are not tested, if needed I can provide a sample</strong></em></p>
","861607","","861607","","2020-07-04 18:07:25","2020-07-17 04:22:38","Angular async lazy rendering with RxJS","<angular><asynchronous><rxjs><rxjs-observables>","6","9","","","","CC BY-SA 4.0"
"62721332","1","62721454","","2020-07-03 19:02:47","","-1","145","<p>How to loop through a range of numbers for example: 0 to 10, in prime ng input number spinner?</p>
","10978960","","","","","2020-07-03 19:12:33","Looping in a particular range of numbers in prime ng- input number spinner","<angular><primeng><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"62726961","1","","","2020-07-04 08:27:30","","0","470","<p>I am using RxJs to create data stream observable. It sends 400 entries after some interval.
I am subscribing to it in other react component,</p>
<pre><code>constructor(props) {
        super(props);
        this.state = {data : []};
    }
    componentDidMount() {
        mock.subscribe(val =&gt; {
            var data = this.state.data;
            data[val.id] = val;
            this.setState({data: data});
        });
    }
</code></pre>
<p>I am facing one issue here, when entries come through observable, it takes time to copy those in react state and then to display the updated data(almost all rows in table) and till that time app becomes slow (sometimes freeze).</p>
<p>What is the better way to subscribe to observable to avoid time delay?</p>
<p>Thanks</p>
","6629722","","","","","2020-07-04 08:27:30","Best way to subscribe RxJS observable in React.js","<javascript><reactjs><rxjs><rxjs-observables><rxjs-pipeable-operators>","0","2","0","","","CC BY-SA 4.0"
"62767003","1","62770354","","2020-07-07 01:54:01","","2","885","<p>So I'm a little new to observables, I'm struggling with a scenario, and I thought it might be a good candidate for an SO question. Here we go...</p>
<p>The scenario is this: I have a drop-down field; when it is changed, I want to</p>
<ol>
<li>check a condition based on the <em>previous and new values</em> of the field</li>
<li>request from the user a confirmation if the condition passes, and ...</li>
<li>then revert the value of the field if the user did not confirm.</li>
</ol>
<hr />
<p>Here's the code with comments:</p>
<pre><code>  ngOnInit(): void {
    
    // I am waiting for my view-model to load, then initializing my FormGroup using that view model data.
    // NOTE: My view model is for &quot;Contact&quot; (this code is for contact list)
    this.addSubcription(this.vm$.subscribe((vm) =&gt; this.initFormGroup(vm)));
    
    const field:string = 'customerEmployerId'; // the field's name
    // I create the observable that should listen to changes in the field, and return them in pairs
    const employerValueChanges$ = this.formInit$.pipe(
      switchMap(form=&gt; form.get(field).valueChanges.pipe(
        startWith(form.get(field).value)
      )),
      pairwise()
    );

    // I combine the changes observable with my other observables to access data from each
    let employerCheckSub = combineLatest([
      employerValueChanges$, // the value-changes obs
      this.vm$, // the view-model data
      this.customers$ // a list of customers from a CustomerService
    ]).subscribe(
      ([
        [oldid,newid], // values from value-changes obs
        contact, // the contact info / data
        customers // the list of customers
      ])=&gt; {
        
        // check the previously and newly selected employer values
        // request confirmation if contact was listed as the primary contact for the previously selected employer
         if(oldid &gt; 0 &amp;&amp; newid !== oldid){
           const employer = customers.find(c=&gt; c.customerId === oldid &amp;&amp; c.contactId === contact.contactId);
           if(employer === null) return;
           if(!confirm('Warning: changing this contact\'s employer will also remove them '+
           'as the primary contact for that customer. Are you should you want to continue?')){ 
             // user clicked cancel, so revert back to the previous value without emitting event
             this.contactEditForm.get(field).setValue(oldid, {emitEvent:false});
           }
         }
      });

    this.addSubcription(employerCheckSub);
  }
</code></pre>
<p>The problem is that when I revert the value without emitting an event, the pairwise observable emits an incorrect &quot;previous&quot; value on the next value change. My hope is that there is an RxJS operator or two out there that I am missing and would work perfectly here. Does anyone have a trick to resolve this that they can share?</p>
<hr />
<h2>UPDATE WITH WORKING CODE:</h2>
<p>First off, special thanks to <a href=""https://stackoverflow.com/a/62770354/1751792"">Andrej's answer</a>. His use of the <code>scan</code> operator was definitely the way to go. There was only one little fix that I needed which was to also set the <code>crt</code> (or <code>current</code> in the code below) value as well as the <code>prev</code> values in the accumulator. And voila! Here is my final working version:</p>
<pre><code>/**
   * Requests confirmation when attempting to change a contact's employer if that contact is also
   * designated as the employer's primary contact.
   */
  private addEmployerChangeConfirmation() {
    // NOTE: In this scenario, &quot;customers&quot; are synonymous with &quot;employers&quot;; i.e., our customers are employers of these contacts.
    const field: string = 'customerEmployerId'; // the field's name
    const valueChanges$ = this.formInit$.pipe(
      switchMap((form) =&gt; form.get(field).valueChanges)
    );

    let employerCheckSub = combineLatest([
      // the value-changes obs
      valueChanges$,
      // the id needed from the view model
      this.vm$.pipe(
        filter((vm) =&gt; vm !== null),
        map((vm) =&gt; vm.contactId)
      ),
      // the customer/employer list
      this.customers$,
    ])
      .pipe(
        // once the user approves, I don't bother re-confirming if they change back in same session
        // NOTE: I use a &quot;$$&quot; naming convention to indicate internal subjects that lack a corresponding public-facing observable.
        takeUntil(this.employerChangeApproved$$),
        scan(
          (acc, [current, contactId, customers], i) =&gt; ({
            prevOfPrev: acc.prev,
            ///////////////////////////////////////////////////////////////////////////////////////////////////
            // NOTE: This was an interesting issue. Apparently the seed value is resolved immediately.
            // So, there is no way I found to seed a value from another obs.
            // Instead, I just check if this is the first run, and if so I use the resolved data for prev value.
            // I know the data is resolved because an upstream obs provides it.
            ///////////////////////////////////////////////////////////////////////////////////////////////////
            prev: i === 0 ? this.contactData.customerEmployerId : acc.current, // &lt;-- setting seed manually on first emission
            current,
            contactId,
            customers,
          }),
          {
            prevOfPrev: null,
            prev: null,
            current: this.contactData?.customerEmployerId,
            contactId: this.contactData?.contactId,
            customers: [],
          }
        ),
        // only continue if condition passes
        filter((data) =&gt;
          this.checkIfChangeWillRemoveAsPrimaryContact(
            data.prev,
            data.current,
            data.contactId,
            data.customers
          )
        ),
        // we only want to revert if user clicks cancel on confirmation box.
        // NOTE: If they approve change, this also triggers the &quot;employerChangeApproved$$&quot; subject.
        filter((data) =&gt; !this.confirmRemoveAsPrimaryContact())
      )
      // and now we actually subscribe to perform the action
      .subscribe((data) =&gt; {
        data.current = data.prev;
        data.prev = data.prevOfPrev;
        this.contactEditForm
          .get(field)
          .setValue(data.current, { emitEvent: false });
      }); 

    this.addSubcription(employerCheckSub);
  }
</code></pre>
","1751792","","1751792","","2020-07-07 20:54:29","2020-07-07 20:54:29","RxJS - Using pairwise to confirm and revert input field","<angular><typescript><rxjs><angular-reactive-forms><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"62768097","1","62768372","","2020-07-07 04:22:55","","1","2194","<p>I have a <code>HeaderComponent</code> which displays the header in which I have a search bar, where a user when inputs something and presses enter I take the user to <code>SearchComponent</code>.</p>
<p>I want to implement the functionality that when a user is on search page (<code>SearchComponent</code>), the searchBar in header should not be visible while it should be visible on all other pages.</p>
<p>For this, I added variable <code>searchShow</code> in <code>HeaderComponent.ts</code> and by <code>ng-if</code> in <code>HeaderComponent.html</code>,
I show/hide the searchBar.</p>
<p>To change the value of <code>searchShow</code>, I implemented a <code>Header.service.ts</code>.</p>
<p><strong>header.service.ts</strong></p>
<pre><code>import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
@Injectable({
  providedIn: 'root'
})
export class HeaderService {
  showSearch = new BehaviorSubject&lt;boolean&gt;(true);
  public showSearchObservable = this.showSearch.asObservable()
  constructor(){}
}
</code></pre>
<p><strong>header.component.ts</strong></p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { HeaderService } from './header.service';
@Component({
  selector: 'app-header',
  templateUrl: './header.component.html',
  styleUrls: ['./header.component.scss']
})
export class HeaderComponent implements OnInit {
  searchShow;
  constructor(
    private headerService: HeaderService
  ) {}

  ngOnInit() {
    this.headerService.showSearchObservable.subscribe(
      value =&gt; {
        this.searchShow = value
        console.log(value) ##==&gt; prints true first time when header is initialized but does not prints anything when search component is loaded
      }
    )
  }
}
</code></pre>
<p><strong>search.component.ts</strong></p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { HeaderService } from 'src/app/shared/header/header.service.js';
@Component({
  selector: 'app-search',
  templateUrl: './search.component.html',
  styleUrls: ['./search.component.scss']
})
export class SearchComponent implements OnInit {
 constructor(
    private headerService: HeaderService
  ) {}

  ngOnInit() {
    console.log(this.headerService.showSearch.value) ##==&gt; prints true
    this.headerService.showSearch.next(false)
    console.log(this.headerService.showSearch.value) ##==&gt; prints false, but this value is not emitted to header component
}
}
</code></pre>
<p>What am I missing? Please help. Thanks</p>
","9534861","","9534861","","2020-07-07 04:50:15","2020-07-07 05:53:27","behaviorSubject next() not working angular 8","<angular><observable><angular8><behaviorsubject><rxjs-observables>","1","4","","","","CC BY-SA 4.0"
"62828646","1","62829192","","2020-07-10 06:42:02","","2","1108","<p>Let's say I have an observable called 'todoList$'. Using the 'async' operator, I'm able to automatically subscribe/unsubscribe from it. The problem in the code below is that there are two identical subscriptions to the same observable:</p>
<pre><code>&lt;ng-container *ngIf=&quot;(todoList$ | async).length &gt; 0&gt;
  &lt;div *ngFor=&quot;let todo of todoList$ | async&quot;&gt;
    ...
</code></pre>
<p>This isn't very DRY, and consequentially, we allocate memory for a subscription that could handled more efficiently.</p>
<p>Because of the syntax in the ngIf condition, I don't believe I can use the 'as' keyword to create a template variable for the observable output. <strong>Instead what works is when I use the RxJs 'share' operator from the component file</strong>:</p>
<pre><code>todoList$ = this.store.select(todoList).pipe(tap(x =&gt; {console.log('testing')}), share());
//testing  
</code></pre>
<p>Without the share operator, &quot;testing&quot; is printed twice. This leads me to believe the share() operator solves this problem. If it does, not exactly sure why/how? Since this can be a prevalent issue/ code smell, what's the best way of handling multiple subscriptions that are identical within the same template?</p>
<p><em>I acknowledge there are a few flavors of a similar question floating on StackOverflow. But none have given me exactly what I'm looking for.</em></p>
","5332322","","","","","2020-07-10 07:47:06","How to best handle multiple subscriptions to the same observable on the template?","<angular><rxjs><angular2-observables><rxjs-observables>","5","1","1","","","CC BY-SA 4.0"
"62836619","1","62838071","","2020-07-10 14:37:39","","0","42","<p>we have an REST-API that is frontend agnostic, which means that it always sends the IRI to its nested resources. So to retrieve some data you always have to make multiple http calls (first get the parent resource, then its child resources etc.)
So each Country has a list of linked Entries. Each entry is linked to a product, which has a IRI to its category resource.</p>
<pre><code>export interface Country {
  countryId: number;
  name: string;
  code: string;
  projects: string[]; //contains an array of IRIs for the project resources
  entries: string[];
}

export interface Entry {
  entryId: number,
  country: string,
  information: string,
  strategy: string,
  action: string,
  user: string,
  product: string,
  salesStatus1: string,
  salesStatus2: string,
  salesStatus3: string,
  salesStatus4: string,
  salesStatus5: string,

}

export interface Product {
  productId: number,
  productName: string,
  sharepointId: string,
  category: string,
  plmId: string,
  productStatus1: string,
  productStatus2: string,
  productStatus3: string,
  productStatus4: string,
  productStatus5: string,
  productComponents: string[]
}

export interface Category {
  categoryId: number,
  name: string,
  children: string[]
}
export class Node {
  children: Node[] = [];
  name: string;
  isProduct: boolean;
}
</code></pre>
<p>So to consume all data that i needed to display an navigation tree i wrote the following code :</p>
<pre><code>ngOnInit() {
    let nodes: Node[] = new Array&lt;Node&gt;();
    this.countriesService.getAll()
      .subscribe(
        (countries) =&gt; {
          for (let country of countries) {
            let countryNode = new Node();
            countryNode.name = country.name;
            countryNode.isProduct = false;
            for (let entryUrl of country.entries) {
              this.entriesService.getByUrl(entryUrl).subscribe(
                (entry) =&gt; {
                  this.productsService.getByUrl(entry.product).subscribe(
                    (product) =&gt; {
                      this.categoryService.getByUrl(product.category).subscribe(
                        (category) =&gt; {
                          let categoryNode = new Node();
                          categoryNode.name = category.name;
                          categoryNode.isProduct = true;
                          countryNode.children.push(categoryNode);
                          for (let childrenUrl of category.children) {
                            this.categoryService.getByUrl(childrenUrl).subscribe(
                              (childCategory) =&gt; {
                                let categoryChildNode = new Node();
                                categoryChildNode.name = childCategory.name;
                                categoryChildNode.isProduct = false;
                                categoryNode.children.push(categoryChildNode);
                              }
                            )
                          }
                        }
                      )
                    }
                  )
                }
              )
            }
            nodes.push(countryNode);
          }
          this.dataChange.next(nodes);
        }
      );
  }
</code></pre>
<p>However as i am kinda new to Angular and rxjs i am having problems to &quot;wait&quot; until all calls are finished and all data (as its asynchronous) is there (and therefore the navigation tree always misses elements). Also it is kinda ugly and bad practice to chain like this. So i wanted to refactor
the code to rxjs-methods, however i am completly lost how to even start with it, because after retrieving data i have to iterate over it again to get the nested resource IRIs and also have to create Node objects for the tree-navigation.</p>
<p>Can you pls give me some help, on how to refactor that code?</p>
","10061440","","","","","2020-07-10 15:58:47","How to refactor HttpRequests in nested for-loops that use subscribe?","<angular><typescript><rxjs><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"62841252","1","62856405","","2020-07-10 19:40:07","","1","208","<p>I am trying write what seems like a simple method to fetch a users profile details for my Angular app and load that data before navigating to the profile page using a resolver. . The resolver doesn't complete even though there a no errors This is my code for the resolver class:</p>
<pre><code>export class ProfileResolverService implements Resolve&lt;Observable&lt;any&gt;&gt; {

  constructor(private fs: FirestoreService, private auth:AuthService) { }

   resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot){
    return this.auth.user.pipe(take(1),
      mergeMap(userdata =&gt; {
        return this.fs.getUserProfile(userdata.uid) //get user profile returns  Observable&lt;unknown[]&gt;
      })
    )
    
  }
   
}
</code></pre>
<p>and in my routing module:</p>
<pre><code>path: 'profile',
            children: [
                {
                    path: '',
                    resolve: {
                      userdata: ProfileResolverService
                    },
                    loadChildren: () =&gt; import('../profile/profile.module').then( m =&gt; m.ProfilePageModule)
                }
</code></pre>
<p>Can anyone please help. Been on this for 2 days</p>
","13908081","","1486848","","2020-07-11 08:38:53","2020-07-12 02:13:08","How to return result of inner observable in route resolver Angular","<angular><typescript><angularfire><rxjs-observables><mergemap>","2","2","","","","CC BY-SA 4.0"
"62878721","1","62878778","","2020-07-13 15:07:45","","0","21","<p>In my Ionic/Angular app I am converting some promised-based implementations to use observables instead. I am running into one issue with a particular function. My original (working, promised-based) code looked like this:</p>
<pre><code>  async getPlayerStats() {
    this.user = await this.mainService.getPlayerStats(this.username);
    this.checkRookieTopicCompletionStatus();
  }
</code></pre>
<p>As you can see, with the above implantation I am waiting on <code>this.user</code> before calling <code>this.checkRookieTopicCompletionStatus();</code> That's important because I use <code>this.user</code> in a <code>for-loop</code> in that function.</p>
<p>Now, in my new observable-based implementation, my <code>getPlayerStats()</code> function looks like this:</p>
<pre><code>  getPlayerStats() {
    this.mainService.getPlayerStats(this.username).subscribe(
      user =&gt; this.user = user,
      error =&gt; this.errorMsg = error,
    );
    this.checkRookieTopicCompletionStatus();
  }
</code></pre>
<p>The problem here is that <code>this.checkRookieTopicCompletionStatus()</code> fires before <code>this.user</code> is available. So my question is, how do I change this function above here so that I am assured I have <code>this.user</code> data <em>before</em> <code>this.checkRookieTopicCompletionStatus()</code> is called? Do I call it from somewhere within the <code>subscribe()</code> block?</p>
","7934883","","","","","2020-07-13 15:10:58","Issue in Observable vs Promised-based Approach","<angular><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"62920504","1","62920741","","2020-07-15 17:25:23","","1","45","<p>I am new to the whole concept of Observables and rxjs so this might be very obvious. But please help as I am desperate to learn</p>
<p>I have a funtion when a user clicks to show comments under a blog post</p>
<pre><code> showComments(){
    
    this.firestoreservice.getComments(this.job.id).subscribe( data =&gt;{
      this.comments = data //type [] of comment objects with (message,posterID,timeposted...)
    })

    this._showcomments = true;

  }
</code></pre>
<p>This function calls a service function that returns an observable to my comments list for that job.
In the subscribe to that observable is initialise a variable to hold all my comments.
Before I do that however, is there a way to replace the posterID attribute of each comment with the matching username? See desired outcome below:</p>
<pre><code>showComments(){
   
   this.firestoreservice.getComments(this.job.id).subscribe( data =&gt;{

     //for each comment held in data, replace comment.posterID with getUserName(posterID)
     //getUserName(posterID) will also return an observable which emmits one string
     //then append comment to comments list (or add back in to data then destructively assign 
     //comments=data )
     
     this.comments = data //type [] of comment objects with (message,posterID,timeposted...)
   })

   this._showcomments = true;

 }
</code></pre>
","13908081","","13908081","","2020-07-15 17:33:46","2020-07-16 20:49:40","How to modify inner element of each Object emitted by observable before returning the outer observable","<angularjs><rxjs><observable><angularfire><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"62934781","1","62946443","","2020-07-16 12:32:38","","0","829","<p>I have a user service which allows login, logout and maintains data about the currently logged in user:</p>
<pre class=""lang-js prettyprint-override""><code>user$ = this.http.get&lt;User&gt;('/api/user')
            .pipe(
              shareReplay(1),
            );
</code></pre>
<p>I am using <code>shareReplay(1)</code> because I do not want the webservice to be called several times.</p>
<p>On one of the components, I have this (for simplicity), but I have several other things I want to do if a user is logged in:</p>
<pre class=""lang-html prettyprint-override""><code>&lt;div *ngIf=&quot;isUserLoggedIn$ | async&quot;&gt;Logout&lt;/div&gt;
</code></pre>
<pre class=""lang-js prettyprint-override""><code>isUserLoggedIn$ = this.userService.user$
                    .pipe(
                      map(user =&gt; user != null),
                      catchError(error =&gt; of(false)),
                    );
</code></pre>
<p>However, the <code>isLoggedIn$</code> does not change after the user logs in or logs out. It does change when I refresh the page.</p>
<p>Here's my logout code:</p>
<pre class=""lang-js prettyprint-override""><code>logout() {
  console.log('logging out');
  this.cookieService.deleteAll('/');

  this.user$ = null;

  console.log('redirecting');
  this.router.navigateByUrl('/login');
}
</code></pre>
<p>I understand that the internal observable is not reset if I assign the variable to null.</p>
<p>So, for logout, I took clue from this answer: <a href=""https://stackoverflow.com/a/56031703"">https://stackoverflow.com/a/56031703</a> about refreshing a <code>shareReplay()</code>. But, the user$ being used in the templates causes my application to go into a tizzy as soon as I attempt to logout.</p>
<p>In one of my attempts, I tried <code>BehaviorSubject</code>:</p>
<pre class=""lang-js prettyprint-override""><code>user$ = new BehaviorSubject&lt;User&gt;(null);

constructor() {
  this.http.get&lt;User&gt;('/api/user')
    .pipe(take(1), map((user) =&gt; this.user$.next(user))
    .subscribe();
}

logout() {
  ...
  this.user$.next(null);
  ...
}
</code></pre>
<p>This works a little better except when I refresh the page. The auth-guard (<code>CanActivate</code>) always gets the user$ as null and redirects to the login page.</p>
<p>This seemed like an easy thing to do when I started out, but I am going on falling into a deeper hole with each change. Is there a solution to this?</p>
","6238914","","","","","2020-07-17 03:01:51","RxJS shareReplay() does not emit updated value","<angular><typescript><rxjs><rxjs6><rxjs-observables>","1","5","0","","","CC BY-SA 4.0"
"62936591","1","","","2020-07-16 14:07:20","","-1","43","<p>I want to have multiple observables scheduled consistently with forkJoin, but want to subscribe each of them individually, like below.</p>
<pre><code>const ox = http.get('x');
const oy = http.get('y');
const all = interval(1000).pipe(
  switchMap(
    () =&gt; forkJoin(ox, oy)
  );
);

// component x
const sx = ox.subscribe((x) =&gt; { showX(x); });
// component y
const sy = oy.subscribe((y) =&gt; { showY(y); });
// Another component
const sAll = all.subscribe(([x, y]) =&gt; { doStuffThatNeedsBothXY(x, y); });
</code></pre>
<p>What would be a best way to do this? I want to keep <code>ox</code> and <code>oy</code> type as Observable, instead of using other techniques like piping side effect (<code>tap</code>) at <code>all</code>.</p>
","9959891","","9959891","","2020-07-16 16:31:15","2020-07-17 02:20:47","Subscribe each observables in forkJoin","<rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"62993739","1","","","2020-07-20 10:48:20","","0","1256","<p>In RxJS I need to execute some code after all subscriptions for a given observable have been executed. I need to do this after every single <code>next</code> notification that fires and after all subscriber functions have completed (not only once when the observable completes).</p>
<p>In other words, I need an operator like <code>tap()</code> that runs after all subscribers have been executed. Is there a way?</p>
<p><strong>Example:</strong></p>
<p>I'm developing a library of UI widgets (say some kind of extensions to those already provided by angular material). One of those widgets has to accomplish the following:</p>
<ol start=""0"">
<li>provide a button,</li>
<li>when the button is clicked, display a spinner inside the button,</li>
<li>yield the control to who is using the widget to do some work (e.g. write inside a database),</li>
<li>when the work is done hide the spinner inside the button.</li>
</ol>
<p>Assuming to use an <code>Observable</code> to achieve the above, I would like to be able to do something like (I'm using typescript in an Angular 10 project if it could help to provide a solution):</p>
<pre class=""lang-js prettyprint-override""><code>const eventEmitter = new EventEmitter&lt;any&gt;();

const observable = eventEmitter.asObservable().pipe(
  tap(() =&gt; ...show the spinner...), // OK, no problem
  someOperator(() =&gt; ...hide the spinner when all subscriber functions complete...) // Which operator can I use?
);

observable.subscribe(() =&gt; console.log('First consumer'));
observable.subscribe(() =&gt; console.log('Second consumer'));

eventEmitter.emit('DATA');
</code></pre>
<p>The desired sequence of events when the button is clicked is:</p>
<ol>
<li>The event is emitted with <code>'DATA'</code> as payload,</li>
<li>The spinner inside the button is displayed,</li>
<li><code>'First consumer'</code> is logged in the console,</li>
<li><code>'Second consumer'</code> is logged in the console,</li>
<li>The spinner inside the button is removed.</li>
</ol>
<hr />
<p>BONUS QUESTION: how could I run some code after the execution of every single subscriber?</p>
","3333319","","3333319","","2020-07-21 06:39:56","2020-07-22 08:45:12","Execute function after subscribers to an RxJS observable complete","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","4","","","","CC BY-SA 4.0"
"63011271","1","63011471","","2020-07-21 09:16:38","","0","153","<p>In one of my components I have a function that updates a local observable (<code>album$</code>) which is then used in my html to display the data (<code>*ngIf=&quot;album$ | async as album&quot;</code>). This works perfectly fine.</p>
<pre><code>  getData() {
    this.album$ = this._activatedRoute.params.pipe(
      tap(params =&gt; {
        // Update variables
      }),
      switchMap(params =&gt; {
        return this.service.getData(params.id, params.id2);
      })
    )
  }
</code></pre>
<p>However, a new requirement means that I need to update a BehaviorSubject I have in one of my services. The function above seemed like a great place to kill two birds with one stone.</p>
<p>I would like to perform a <code>patchValue</code> and <code>this.service.obs$.next</code> once the function above returns it's data.</p>
<p>I do achieve this functionality in a separate component I have, but as I'm not using a subscription in the one above, how would i go above adding <code>this.service.album$.next(data);</code> to my above function?</p>
<p>// Example of another function that has the functionality i'm pretty much after, but is subscription based.</p>
<pre><code>  getData(){
    this._subscription = this._activatedRoute.params.pipe(
      tap(params =&gt; {
        // update variables
      }),
      switchMap(params =&gt; {
        return this.service.getData(params.id1, params.id2);
      })
    ).subscribe(data =&gt; {
      if (data) { 
        this.service.obs$.next(data);
      } 
    });
  }
</code></pre>
","9497310","","","","","2020-07-21 10:41:52","Angular / RXJS - How to perform logic after a switchMap","<angular><rxjs><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"63012613","1","63014841","","2020-07-21 10:34:05","","1","1649","<p>I want to achieve dynamic client side filtering with data from Angular FireStore.</p>
<p>I've the following service, which is working more or less, but it's really verbose and I think it can be improved. My problem is with the filteredFiles$ part, I think the if logic I'm using can be omitted with proper usage of RxJs operators, but I can't figure out how.</p>
<p>Any help would be appreciated.</p>
<p>Thank you.</p>
<p>The service:</p>
<pre class=""lang-js prettyprint-override""><code>files$: Observable&lt;FileModel[]&gt;;
public filteredFiles$: Observable&lt;FileModel[]&gt;;

public sourceFilter$ = new BehaviorSubject&lt;string | null&gt;(null);
public extensionFilter$ = new BehaviorSubject&lt;string[] | null&gt;(null);
public channelIdFilter$ = new BehaviorSubject&lt;string | null&gt;(null);
public teamIdFilter$ = new BehaviorSubject&lt;string | null&gt;(null);
public idFilter$ = new BehaviorSubject&lt;string[] | null&gt;(null);
private filesCollectionRef: AngularFirestoreCollection&lt;FileModel&gt;;

constructor(
    private afs: AngularFirestore,
    private userService: UserService
  ) {

this.filesCollectionRef = this.afs.collection&lt;FileModel&gt;('files', ref =&gt;
  ref.where('perm.readers', 'array-contains', this.userService.uid));

this.files$ = this.filesCollectionRef.valueChanges({idField: 'id'});

this.filteredFiles$ = combineLatest([
  this.files$,
  this.extensionFilter$,
  this.channelIdFilter$,
  this.teamIdFilter$,
  this.idFilter$
]).pipe(
  map(([files, extension, channel, teamId, id]) =&gt; {
      if (extension === null &amp;&amp; channel === null &amp;&amp; teamId === null &amp;&amp; id === null) {
        return files;
      } else {

        if (channel !== null &amp;&amp; extension !== null &amp;&amp; id !== null) {          
          return files.filter(
            (file) =&gt;
              file.channel === channel &amp;&amp; extension.includes(file.extension) &amp;&amp; id.includes(file.id)
          );
        }

        if (extension !== null &amp;&amp; id !== null) {          
          return files.filter(
            (file) =&gt;
              extension.includes(file.extension) &amp;&amp; id.includes(file.id)
          );
        }

        if (channel !== null &amp;&amp; extension !== null) {          
          return files.filter(
            (file) =&gt;
              file.channel === channel &amp;&amp; extension.includes(file.extension)
          );
        }

        if (id !== null) {
          return files.filter(
            (file: FileModel) =&gt;
              id.includes(file.id)
          );
        }

        if (extension !== null) {          
          return files.filter(
            (file: FileModel) =&gt;
              extension.includes(file.extension)
          );
        }

        if (channel !== null) {          
          return files.filter(
            (file: FileModel) =&gt;
              file.channel === channel
          );
        }
      }
    }
  )
);

filterByExtension(extensions: string[]) {
    this.extensionFilter$.next(extensions);
}

filterByChannelId(channelId: string | null) {
  this.channelIdFilter$.next(channelId);
}

filterByTeamId(teamId: string | null) {
  this.teamIdFilter$.next(teamId);
}

filterById(id: string[] | null) {
  this.idFilter$.next(id);
}
</code></pre>
<p>And in the template:</p>
<pre class=""lang-html prettyprint-override""><code>&lt;li *ngFor=&quot;let file of this.fileService.filteredFiles2$ | async&quot;&gt;
   &lt;app-display-file [file]=&quot;file&quot;&gt;&lt;/app-display-file&gt;       
&lt;/li&gt;
</code></pre>
","2029378","","2029378","","2020-07-21 13:36:17","2020-07-21 13:36:17","Angular dynamically filter RxJS observable with multiple condition","<angular><filter><rxjs><observable><rxjs-observables>","2","0","1","","","CC BY-SA 4.0"
"63019730","1","63030759","","2020-07-21 17:19:31","","0","457","<p>I am having trouble getting the sum (or any reduction) of an inner number property of an Observable within another Observable.</p>
<p>I have an Observable array of &quot;Account&quot; objects (<code>Observable&lt;AppAccount[]&gt;</code>).</p>
<pre><code>export interface AppAccount {
    _id?: string;
    name: string;
}
</code></pre>
<p>And an Observable array of &quot;Balance&quot; objects, each with an accountId. many balances can be associated with an account (sorted/filtered by date, but that piece is removed for brevity)</p>
<pre><code>export interface AccountBalance {
    _id?: string;
    accountId: string;
    amount: number;
}
</code></pre>
<p>I have a helper method which returns just the last Balance object's Amount for a given Account.</p>
<pre><code>getLastAmount(account: AppAccount): Observable&lt;number&gt; {
    return this.balanceService.balances$.pipe(
      map(balances =&gt; {
        let last = balances.filter(balance =&gt; {
          return balance.accountId === account._id;
        }).sort().pop();
        //console.log(last)
        return last ? last.amount : 0;
      }),
      tap(amount =&gt; console.log(`getLastAmount() =&gt; ${amount}`)),
    );
  }
</code></pre>
<p>Now I am trying to write a method which will loop through the Accounts, call getLastAmount() for each, and then sum them all and return an Observable. This is what I have managed so far:</p>
<pre><code>getTotalBalance(accounts$: Observable&lt;AppAccount[]&gt;): Observable&lt;number&gt; {
    return accounts$.pipe(
      map(accounts =&gt; from(accounts)),
      mergeAll(),
      mergeMap(account =&gt; this.getLastAmount(account)),
      reduce((sum, current) =&gt; {
        console.log(`${sum} + ${current}`);
        return sum + current;
      }, 0)
    );
  }

</code></pre>
<p>But this seems to never return, and gets stuck in an infinite loop??</p>
<p>With just one account and one balance associated, with the balance having an 'amount' of '10', I get this from my console log: '0 + 10' over and over, and the network log also confirm it is calling getBalances() continuously.</p>
<p>Am I on the right track? Is there a better way? Why does this RXJS pipe get stuck in a loop?</p>
<p><strong>EDIT</strong>: I've made some changes based on picci's suggestions:</p>
<pre><code>getTotalBalance(accounts$: Observable&lt;AppAccount[]&gt;): Observable&lt;number&gt; {
    return accounts$.pipe(
      map(accounts =&gt; accounts.map(account =&gt; this.getLastAmount(account))),
      concatMap(balances$ =&gt; { console.log('balances$', balances$); return forkJoin(balances$); }),
      tap(balances =&gt; console.log('balances', balances)),
      map(balances =&gt; balances.reduce(
        (amountSum, amount) =&gt; {
          console.log(`${amountSum} + ${amount}`)
          amountSum = amountSum + amount;
          return amountSum
        }, 0))
    );
  }
</code></pre>
<p>But this is still not returning, or the pipe is not completing?
I've made a stackblitz here: <a href=""https://stackblitz.com/edit/angular-rxjs-nested-obsv"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-rxjs-nested-obsv</a>
If you check the console output, it seems to not get any further than the forkJoin call...</p>
","6505573","","6505573","","2020-07-22 19:51:38","2020-07-22 19:51:38","How to sum inner property of nested observable arrays, using Angular/RXJS?","<angular><rxjs><sum><rxjs-observables><rxjs-pipeable-operators>","2","1","","","","CC BY-SA 4.0"
"63021653","1","","","2020-07-21 19:20:27","","0","135","<p>If I know all of the possible values of my api parameters when the pages is loading, is it better to try to load all of these values at once into a map on page load like so? Will the constructor ensure that all of the values will be set into the map?</p>
<p>The this.apiService.get(possibleQuery) returns an observable.</p>
<pre><code>export class DataService {
  private queryMap: Map&lt;string, string&gt;;
  private possibleQueries = [
    'query1',
    'query2',
    'query3',
    'query4'
  ];

  constructor() {
      this.createQueryMap();
    }

  displayData(query: string) {
    console.log(queryMap.get(query));
  }

  private createQueryMap() {
    this.queryMap = new Map&lt;string, string&gt;();
    for (const possibleQuery of this.possibleQueries) {
      this.apiService.get(possibleQuery)
      .subscribe(result =&gt; { this.queryMap.set(possibleQuery, result); });
    }
  }
}
</code></pre>
","8418879","","8418879","","2020-07-21 19:39:41","2020-07-21 20:04:33","Best way to get data from observables on page load?","<angular><rxjs-observables>","2","3","","","","CC BY-SA 4.0"
"63035725","1","63048713","","2020-07-22 13:48:15","","0","143","<p>I fetch data from json.typicode.com that is the public fake rest api and convert that json into object by getting my required number of fields now if I want to update that object would there be any mismatch for type or something or I need to perform anything extra?</p>
<p>I have an interface called User with certain number of fields</p>
<pre><code>export interface  User {
    id: number;
    email: string;
    name: string;
    phone: string;
    username: string;
}
</code></pre>
<p>I am fetching data from fake Rest api that is</p>
<pre><code>public getUsers():Observable&lt;User[]&gt;{
    return this.http.get&lt;User[]&gt;(&quot;https://jsonplaceholder.typicode.com/users&quot;);
}
</code></pre>
<p>so the above code is written in a service which I inject in my ts file</p>
<p>if you will hit <a href=""https://jsonplaceholder.typicode.com/users"" rel=""nofollow noreferrer"">https://jsonplaceholder.typicode.com/users</a> in browser you will get the Json Objects like below</p>
<pre><code>{
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;Leanne Graham&quot;,
    &quot;username&quot;: &quot;Bret&quot;,
    &quot;email&quot;: &quot;Sincere@april.biz&quot;,
    &quot;address&quot;: {
      &quot;street&quot;: &quot;Kulas Light&quot;,
      &quot;suite&quot;: &quot;Apt. 556&quot;,
      &quot;city&quot;: &quot;Gwenborough&quot;,
      &quot;zipcode&quot;: &quot;92998-3874&quot;,
      &quot;geo&quot;: {
        &quot;lat&quot;: &quot;-37.3159&quot;,
        &quot;lng&quot;: &quot;81.1496&quot;
      }
    },
    &quot;phone&quot;: &quot;1-770-736-8031 x56442&quot;,
    &quot;website&quot;: &quot;hildegard.org&quot;,
    &quot;company&quot;: {
      &quot;name&quot;: &quot;Romaguera-Crona&quot;,
      &quot;catchPhrase&quot;: &quot;Multi-layered client-server neural-net&quot;,
      &quot;bs&quot;: &quot;harness real-time e-markets&quot;
    }
  },
</code></pre>
<p>I am able to map the Data by using the Map function and getting only those fields which I want.</p>
<p>But now If I want to update users the problem would be how to update the Data with my custom Object that is different from the api json?</p>
","7413086","","7413086","","2020-07-23 07:08:02","2020-07-23 07:08:02","How to update a customized object in a public api in angular?","<angular><rxjs><angular-material><angular8><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"63051711","1","","","2020-07-23 10:04:40","","1","39","<p>For Example, I have a stream a number of numbers say 1,2,3,4 and so on. I want to sense each of these data and whenever it's even I want to emit true in another data stream. keeping the source data stram[1,2,3,4] as is.</p>
","6097829","","6097829","","2020-07-23 12:47:46","2020-07-23 15:17:44","Can I create a brand new stream from the existing stream in rxjs","<rxjs><rxjs-observables>","1","7","","","","CC BY-SA 4.0"
"63061257","1","","","2020-07-23 18:55:01","","0","706","<p>This is a followup question for another question I had posted, which remains half-solved: <a href=""https://stackoverflow.com/questions/62934781/rxjs-sharereplay-does-not-emit-updated-value"">RxJS shareReplay() does not emit updated value</a></p>
<p>I am creating an Angular app and I'm trying to use Observables extensively. The problem is with creating a <code>UserService</code> class which has an observable <code>user$</code> which can be piped to throughout the application to get the currently logged in user.</p>
<p>The currently accepted answer (by @DeborahK - she had been very patient with me) is a great solution, but has a bug - A user logs in, then logs out. Then a second user logs in. The <code>user$</code> object for the second user is not refreshed (because it is <code>shareReplay()</code>) and they can see all the data of the first user.</p>
<p>If I refresh the page, things work just fine.</p>
<p>I found another question with a similar problem from 2018 and it still remains unsolved: <a href=""https://stackoverflow.com/questions/51213698/angular-2-typescript-reload-components-on-login-logout"">Angular 2 Typescript reload components on login/logout</a></p>
<p>I have tried several other ways, even with <code>BehaviorSubject</code>, but the problem there is that the <code>user$</code> is never ready in time for the <code>CanActivate</code> auth-guards. So, the auth-guards get the value of the user as <code>null</code> and redirect them to the login page.</p>
<p>I am looking for a way to serve the following use cases:</p>
<ol>
<li>User should be able to login</li>
<li>Show 'Logout' link (and/or other user related things) when the user is logged in.</li>
<li>Refreshing the page should load the user for the auth-guards, in order to redirect to the right page.</li>
<li>User should be able to logout</li>
<li>New user should be able to login</li>
<li><code>user$</code> could be used several times and still call the webservice only once throughout its lifetime.</li>
</ol>
<p>In one of the solutions (<a href=""https://stackblitz.com/edit/angular-user-logout-deborahk-hz1agh"" rel=""nofollow noreferrer"">stackblitz example here</a>), it appears that things are working fine, until you pop the hood to check the Network tab of the browser. Each time <code>$user</code> is used, a new network call is made. One of my pages has an array of data being looped through. With this approach, there are so many network calls made to the API, that the browser become irresponsive.</p>
<p>Even with the simplest of examples...</p>
<pre class=""lang-js prettyprint-override""><code>user$ = this.logInAction$.pipe(
    switchMap(userId =&gt; {
      console.log(&quot;userid = &quot;, userId);
      if (userId &gt; 0) {
        // returning webservice observable
        return this.callWS(userId);
      } else {
        // user logged out
        return of(null);
      }
    }),
  );
</code></pre>
<p>... a stream (or the observable) once returned is what is subscribed to. There is no way to actually switch the observable again when required.</p>
<p>Is there a way to achieve the desired result using RxJS and Observables?</p>
","6238914","","","","","2020-07-23 18:55:01","Angular app - User login, logout and session reload with Observables","<angular><typescript><rxjs><rxjs6><rxjs-observables>","0","0","","","","CC BY-SA 4.0"
"63063532","1","63063654","","2020-07-23 21:41:29","","1","727","<p>I am successfully subscribing to an observable in a couple of different components in my Angular/Ionic app. However, because I am doing so manually, that also means I need to manually unsubscribe to them, which I currently do in my <code>ngOnDestroy()</code> life cycle hook.</p>
<p>The component code implementation I have, that IS working, looks like this:</p>
<pre><code>  getPlayerStats() {
    this.playerSubscription = this.mainService.getPlayerStats(this.username).subscribe(
      user =&gt; {
        this.user = user;
      },
      error =&gt; this.errorMsg = error
    );
  }
</code></pre>
<p>My view code for the component looks like this:</p>
<pre><code>&lt;ion-card *ngIf=&quot;user&quot;&gt;
  ... display user info
&lt;/ion-card&gt;
</code></pre>
<p>And the service method that is called here looks like this:</p>
<pre><code>  getPlayerStats(username: string) {
    const req = `users/stats/${username}`;
    return this.apiService.sendRequest(req);
  }
</code></pre>
<p>What I'd like to do, but am having difficulty getting to work, is using the <code>async</code> pipe do the subscribing in my HTML view. That'd be cleaner because then I wouldn't have to be so verbose and I wouldn't have to manually subscribe and unsubscribe in the components where I use this. My understanding is that this is also the recommended way of handling these scenarios, for precisely these reasons.</p>
<p>What would that code look like? I tried this but it did not work:</p>
<pre><code>getPlayerStatus() {
  this.user = this.mainService.getPlayerStats(this.username);
}
</code></pre>
<p>And in my HTML view I did this:</p>
<pre><code>&lt;ion-card *ngIf=&quot;user | async&quot;&gt;
  ... display user info
&lt;/ion-card&gt;
</code></pre>
<p>But as I say, this isn't working. What do I need to change here? How can I call the service <code>getPlayerStats()</code> method, but handle the subscribing in the component view with the async pipe?</p>
","7934883","","7934883","","2020-07-23 22:09:07","2020-07-23 22:09:27","Using Angular Async Pipe to Subscribe to Observable","<angular><asynchronous><ionic-framework><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"63125464","1","63126300","","2020-07-28 00:35:48","","0","165","<p>i have a service called TransactionEntityService derived from EntityCollectionServiceBase for a model called Transaction.</p>
<pre><code>export class TransactionEntityService
extends EntityCollectionServiceBase&lt;Transaction&gt; {
</code></pre>
<p>I am using TransactionDataService to override default behavior of DefaultDataService .
In AppModule TransactionDataService is registered like this</p>
<pre><code>    export class AppModule {
  constructor(
    private eds: EntityDefinitionService,
    private entityDataService: EntityDataService,
    private transactionsDataService: TransactionsDataService
  ) {
    eds.registerMetadataMap(entityMetadata);

    entityDataService.registerService('Transaction', transactionsDataService);
  }
}
</code></pre>
<p>and TransactionsDataService overrides getAll like below.</p>
<pre><code>    export class TransactionsDataService extends DefaultDataService&lt;Transaction&gt; {
  constructor(
    http: HttpClient,
    httpUrlGenerator: HttpUrlGenerator,
    private notifyService: NotificationService
  ) {
    super('Transaction', http, httpUrlGenerator);
  }
  getAll(): Observable&lt;Transaction[]&gt; {
    return this.http
      .get&lt;ApiResponse&gt;('https://localhost:xxxx/transaction/GetLastSixMonth')
      .pipe(
        tap((data) =&gt; {
          this.notifyService.showSuccess(data.message, 'Sucess');
        }),
        map((res) =&gt; res.result),
        catchError((err) =&gt; {
          this.notifyService.showError(
            'Error While Six Month Transactions',
            'Error'
          );
          return of();
        })
      );
  }
</code></pre>
<p>The &quot;$entitie&quot; property of entity service is returning proper result after calling the api. and i am filtering that result to get count of something in an observable called last6MonthDepositCount$.</p>
<pre><code>  this.last6MonthDepositCount$ = this.transactionsEntityService.entities$.pipe(
  map((transactions) =&gt; {
    const res = transactions.filter(
      (transaction) =&gt;
        transaction.transactionType === TransactionType.Deposit
    ).length;
    return res;
  })//,
 // tap((val) =&gt; this.depositCount = val)
);
</code></pre>
<p>in the html i can use this observable</p>
<pre><code>{{ last6MonthDepositCount$  | async }}
</code></pre>
<p>it works.</p>
<p>what should i do to use the value of this observable in another variable in my code ?</p>
<pre><code>this.last6MonthDepositCount$.subscribe(x =&gt; this.dipositCount = x);
</code></pre>
<p>this kind of a code is not working. i get 0 in dipositCount which looks like the intial value of the observable.</p>
<p><a href=""https://i.stack.imgur.com/EJA3f.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/EJA3f.png"" alt=""enter image description here"" /></a></p>
","2624698","","2624698","","2020-07-28 02:29:31","2020-07-28 03:13:13","how to subscribe to an Observable returned from ngrx's Entity Data Service","<angular><ngrx><rxjs-observables><ngrx-entity><angular-ngrx-data>","1","7","1","","","CC BY-SA 4.0"
"63128777","1","63129486","","2020-07-28 07:09:36","","0","63","<p>I have the following entries with the type Observable&lt;User[]&gt;:</p>
<pre><code>[{
   &quot;id&quot;: 1,
   &quot;name&quot;: &quot;Testuser 1&quot;,
   &quot;projectAccess&quot;: Role,
}] 
</code></pre>
<p>.json</p>
<pre><code>Role {
id: string;
name:string;
}
</code></pre>
<p>so requirement is like to have an array where user is group-by role which i want to pass inside generic autocomplete component as group-entries</p>
<pre><code>  return data:
  [{
  manager, [{&quot;1&quot;, &quot;Frank&quot;}, {&quot;3&quot;, &quot;Seba&quot;}]
  },
  {employee, [{&quot;2&quot;, &quot;Simi&quot;}]
  },]
</code></pre>
<p>any help will be appreciated.Thank You</p>
","9549528","","9549528","","2021-09-02 09:26:06","2021-09-02 09:26:06","GroupBy an RxJS Observable into key-values","<angular><autocomplete><rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"63187365","1","","","2020-07-31 07:15:14","","0","106","<p>I have a service file having a function call with rxjs debounce time, when on writing the spec for the same, the execution context is not reaching to the service file from running the test, but on commenting the  <code>debounceTime(1000)</code> then the spec works resulting in success expectation, And I can not remove the debounceTime for the spec purpose.</p>
<p>what I have tried : I have tried to add tick, fackAsync, flush combinations, but no clue what is the issue.</p>
<p>Here is the detailed code and screenshot for easy understanding</p>
<pre><code>const saveQuestion$ = this.assessmentDetailMiddleware$.pipe(
      filter(filterForQuestionSave),
      debounceTime(1000), //THIS IS CAUSING THE ISSUE, if i remove this, it will work. but it is needed
      rxMap(() =&gt; of(checkIfSupposedToTriggerTheSave())),
      switchMap(triggerSave =&gt; (!!triggerSave ? this.saveSectionResponses() : NEVER)),
      rxMap((assessmentModel: IAssessmentModel) =&gt;
        assessmentModel
          ? this.assessmentDetailAdapter.convertAssessmentStructure(assessmentModel)
          : false
      ),
      tap(
        (assessmentModel: IAssessmentModel) =&gt;
          assessmentModel &amp;&amp; handleSectionUpdatesToStore(assessmentModel)
      ),
      catchError(error =&gt; {
        console.log('First this should display'); //THIS IS NOT GETTING DISPLAYED
        this.aaDetailSaveHelperStoreService.saveInProgress(false);
        return throwError(error);
      })
    );
</code></pre>
<p>My unit test spec</p>
<pre><code> fit('should call saveInProgress on catchError', fakeAsync(() =&gt; {
        mockAaDetailSaveHelperStoreService.getSaveMetada.and.returnValue({
          questionIdsToSave: [1],
          subQuestionIdsToSave: [1],
        });        
        mockAaDetailSaveHelperStoreService.saving.and.returnValue(true);
        const spySaveSectionResponses = spyOn(service, 'saveSectionResponses');
        spySaveSectionResponses.and.returnValues(throwError('error 2'));
        const action = {
          type: 'SAVE_QUESTION',
          payload: () =&gt; Promise.resolve,
        };

        service.assessmentDetailMiddleware$.subscribe(data =&gt; {
          //  expect(true).toBe(true);
          console.log('now display this : ');
          expect(mockAaDetailSaveHelperStoreService.saveInProgress).toHaveBeenCalled(); //THIS IS NOT DETECTED, SINCE THE EXECUTION NOT REACHED THE SERVICE FILE DUE TO `debounceTime(1000)`.  
          //expect(true).toBe(true);
          flush();
          //
        });
        flush();
        tick(1000);
        service.assessmentDetailMiddleware$.next(action);
        discardPeriodicTasks();
      }));
    })
</code></pre>
<p>Now the problem is the flow of execution is coming like , first the console inside .spec is displayed WITHOUT displaying the console inside spec, due to this the expectation is not deetcted.</p>
<p><a href=""https://i.stack.imgur.com/UGsvZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UGsvZ.png"" alt=""Screenshot"" /></a></p>
<p>Now here is the success spec, WITHOUT debounceTime, and it is working</p>
<pre><code>const saveQuestion$ = this.assessmentDetailMiddleware$.pipe(
      filter(filterForQuestionSave),
      //debounceTime(1000), //NOW spec WORKS,
      rxMap(() =&gt; of(checkIfSupposedToTriggerTheSave())),
      switchMap(triggerSave =&gt; (!!triggerSave ? this.saveSectionResponses() : NEVER)),
      rxMap((assessmentModel: IAssessmentModel) =&gt;
        assessmentModel
          ? this.assessmentDetailAdapter.convertAssessmentStructure(assessmentModel)
          : false
      ),
      tap(
        (assessmentModel: IAssessmentModel) =&gt;
          assessmentModel &amp;&amp; handleSectionUpdatesToStore(assessmentModel)
      ),
      catchError(error =&gt; {
        console.log('First this should display');
        this.aaDetailSaveHelperStoreService.saveInProgress(false);
        return throwError(error);
      })
    );
</code></pre>
<p>Please Let me know if need more info</p>
<p><a href=""https://i.stack.imgur.com/628H0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/628H0.png"" alt=""Success"" /></a></p>
","665864","","","","","2020-07-31 07:38:43","Jasmine unit test Spec on debounceTime with tick and flush, execution context not reaching the service file","<angular><unit-testing><jasmine><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"63226367","1","","","2020-08-03 08:48:49","","0","43","<p>My project use Angular and RxJS to be reactive, and I'd like to expose some reactive objects from the web-assembly code.<br />
The WASM already uses events (doing internal HTTP requests or managing mouse events), but I have no idea of how to <em>fire</em> some events to the JS from the C++, and make the front-end react on them.</p>
<p>So far, our front-end is polling the getters of the wasm to remain up to date, but cannot react to a change.</p>
","6165833","","","","","2020-08-03 08:48:49","How to fire events from Emscripten?","<c++><rxjs><emscripten><rxjs-observables>","0","2","","","","CC BY-SA 4.0"
"63234226","1","63240049","","2020-08-03 17:28:18","","1","83","<p>I am having trouble combining the emitted values of two different <code>Observable</code>s for use in an http request, and then returning the request's <code>Observable</code> for use by clients.</p>
<p>Some background: I am working on a Twitch extension. Part of their ecosystem is that extensions receive environment information through event callbacks. The ones I am interested in are located at <code>window.Twitch.ext.onAuthorized()</code> and <code>window.Twitch.ext.configuration.onChanged()</code> (if interested, see here for more details: <a href=""https://dev.twitch.tv/docs/extensions/reference#helper-extensions"" rel=""nofollow noreferrer"">https://dev.twitch.tv/docs/extensions/reference#helper-extensions</a>).</p>
<p>When making calls to my backend, I need information from both of the above events. These will not change often (if ever), but I can't make calls until they are both available, and I want to get the most recently provided value when making calls. It looks like <code>BehaviorSubject</code>s would be ideal for this:</p>
<pre><code>export class TwitchService {
  private authSubject: BehaviorSubject&lt;TwitchAuth&gt; = new BehaviorSubject&lt;TwitchAuth&gt;(null);
  private configSubject: BehaviorSubject&lt;TwitchConfig&gt; = new BehaviorSubject&lt;TwitchConfig&gt;(null);
  private helper: any;

  constructor(private window: Window) {
    this.helper = this.window['Twitch'].ext;
    this.helper.onAuthorized((auth: TwitchAuth) =&gt; {
      this.authSubject.next(auth);
    });
    this.helper.configuration.onChanged(() =&gt; {
      this.configSubject.next(JSON.parse(this.helper.configuration.global.content));
    });
  }

  onAuthorized(): Observable&lt;TwitchAuth&gt; {
    return this.authSubject.asObservable().pipe(filter((auth) =&gt; !!auth));
  }

  onConfig(): Observable&lt;TwitchConfig&gt; {
    return this.configSubject.asObservable().pipe(filter((config) =&gt; !!config));
  }
}
</code></pre>
<p>This model works well for parts of the app that subscribe to one of those two <code>Observable</code>s. My problem is I cannot find a working way to combine them and use the latest emitted values from both to create a single-use <code>Observable</code> for http requests.</p>
<p>Here's what I have so far:</p>
<pre><code>type twitchStateToObservable&lt;T&gt; = (auth: TwitchAuth, config: TwitchConfig) =&gt; Observable&lt;T&gt;;

export class BackendService {
  constructor(private http: HttpClient, private twitch: TwitchService) {}

  private httpWithTwitchState&lt;T&gt;(f: twitchStateToObservable&lt;T&gt;): Observable&lt;T&gt; {
    let subject = new Subject&lt;T&gt;();
    combineLatest(this.twitch.onAuthorized(), this.twitch.onConfig()).pipe(
      first(), // because we only want to make the http request one time
      map(([auth, config]) =&gt; f(auth, config).subscribe((resp) =&gt; subject.next(resp)))
    );
    return subject.asObservable();
  }

  exampleHttpRequest(): Observable&lt;Response&gt; {
    return this.httpWithTwitchState((auth, config) =&gt;
      // this.url() and this.headers() are private functions of this service
      this.http.get&lt;Response&gt;(this.url(config) + 'exampleHttpRequest', { headers: this.headers(auth, config)})
    );
  }
}
</code></pre>
<p>And then, a client of this service should be able to make http requests with this simple call, without needing to know anything about the events or care when they fire:</p>
<pre><code>this.backend.exampleHttpRequest().subscribe((resp) =&gt; {
  // do stuff with resp here...but this is never hit
}
</code></pre>
<p>Based on my understanding, <code>combineLatest()</code> should emit new values whenever either of the input <code>Observable</code>s emits a new value. However, the call <code>f(auth, config)</code> inside of <code>map()</code> is never triggered in my application. I've tested it with breakpoints, with <code>console.log</code>s, and by keeping an eye on the Network tab in the browser debugger tools. It's possible the call to <code>first()</code> is throwing it off, but I don't want to repeat the http request if the events fire again, for obvious reasons.</p>
<p>Thanks in advance for any advice or pointers!</p>
","885128","","885128","","2020-08-04 00:50:09","2020-08-04 04:14:41","How do I use RxJS & Observables to do an http request only after multiple other events have fired?","<angular><typescript><rxjs><twitch><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"63249480","1","","","2020-08-04 14:52:46","","0","197","<p>I have a Method in a Service which looks like this</p>
<pre><code>public getAnwendungZuClientId(clientId: string, nurBerechtigteAnwendungen: boolean = true): Observable&lt;Anwendung&gt; {
const anwObservable = this.prüfeObNurBerechtigt(nurBerechtigteAnwendungen);

let observableToReturn: Observable&lt;Anwendung&gt;;

observableToReturn = anwObservable
.pipe(
  map((anwendungen: Anwendung[]) =&gt; {
      return anwendungen
        .find(anwendung =&gt; {
            return anwendung.client_id === clientId
        })
      }
    ),
  first()
);

return observableToReturn;
</code></pre>
<p>}</p>
<p>It returns an <code>Observable&lt;Anwendung&gt;</code>.
In my component I just call this service Methode to make it available in the View</p>
<pre><code>getAnwendungByClientId (anwendungId: string): Observable&lt;Anwendung&gt; {
    return this.anwendungService.getAnwendungZuClientId(anwendungId);
  }
</code></pre>
<p>And consume it in a View with an async Pipe</p>
<pre><code>{{ (getAnwendungByClientId(anwendung.clientId) | async).name }}
</code></pre>
<p>It works if I navigate from another page to the page with the component which includes the observable.
But if i call the route directly, or reload, the page crashes without a specific error.
Does anybody know where the Problem, in directly calling that route, is ?</p>
<p><a href=""https://i.stack.imgur.com/btb5b.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/btb5b.png"" alt=""Page Crash"" /></a></p>
","12251460","","","","","2020-08-04 15:01:42","Page Crash on reload with Angular Observable","<angular><google-chrome><rxjs><angular2-observables><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"63271005","1","63316924","","2020-08-05 18:02:07","","0","306","<p>I am attempting to display data like so:</p>
<pre class=""lang-html prettyprint-override""><code>    &lt;a *ngFor=&quot;let month of months&quot;&gt;
      &lt;div&gt;
        &lt;h4&gt;{{month.name + month.date.getFullYear()}}&lt;/h4&gt;
        &lt;p *ngFor=&quot;let topic of month.topics&quot;&gt;
            &lt;span&gt;{{topic.description}}&lt;/span&gt;
            &lt;li *ngFor=&quot;let item of topic.items&quot;&gt;
                &lt;span&gt;{{item.content}}&lt;/span&gt;
            &lt;/li&gt;
        &lt;/p&gt;
      &lt;/div&gt;
    &lt;/a&gt;
</code></pre>
<p>This works perfectly well when I use static Month[] data like so:</p>
<pre><code>export const MONTHS: Month[] = [
    { id: 0, name: &quot;September &quot;, date: new Date(2020, 9), topics:[{id: 0, description: &quot;I need a new description&quot;, items: [{ id: 0, content: &quot;I need a new todo&quot;, isDone: false}]}]},
    { id: 1, name: &quot;August &quot;, date: new Date(2020, 8), topics:[{id: 0, description: &quot;I need a second description&quot;, items: [{ id: 0, content: &quot;I need a second todo&quot;, isDone: false}]}]},
];
</code></pre>
<p>However, when I attempt to get the Month[] from an in memory server like so:</p>
<pre><code>///The database
export class InMemoryDataService implements InMemoryDbService {
  createDb() {
    const months = [
      { id: 0, name: &quot;September &quot;, date: new Date(2020, 9), topics:[{id: 0, description: &quot;I need a new description&quot;, items: [{ id: 0, content: &quot;I need a new todo&quot;, isDone: false}]}]},
      { id: 1, name: &quot;August &quot;, date: new Date(2020, 8), topics:[{id: 0, description: &quot;I need a second description&quot;, items: [{ id: 0, content: &quot;I need a second todo&quot;, isDone: false}]}]},
    ];
    return {months};
  }
}

///The month.service
/** GET months from the server */
  getMonths(): Observable&lt;Month[]&gt; {
    return this.http.get&lt;Month[]&gt;(this.monthsUrl)
      .pipe(
        tap(_ =&gt; this.log('fetched months')),
        catchError(this.handleError&lt;Month[]&gt;('getMonths', []))
      );
  }

///the .ts component of the html display
export class CurrentMonthComponent implements OnInit {
  months: Month[];

  constructor(private monthService: MonthService) { }

  ngOnInit(): void {
    this.getMonths();
  }

  getMonths(): void {
    this.monthService.getMonths()
    .subscribe(months =&gt; this.months = months);
  }

}
</code></pre>
<p>At that point the month.date.getFullYear() line in the html throws this exception:</p>
<pre><code>core.js:4197 ERROR TypeError: month_r1.date.getFullYear is not a function
    at CurrentMonthComponent_a_3_Template (current-month.component.html:6)
</code></pre>
<p>Why does it no longer understand that date is a Date object when retrieving it from the server? Shouldn't the getMonths() method return a Month[] which defines date as a Date? Or does it have to do with the rxjs-observables? Here's my month.ts interface for reference. Thanks!</p>
<pre><code>export interface Month {
    id: number;
    name: string;
    date: Date;
    topics: Array&lt;Topic&gt;;
}
</code></pre>
","12027484","","","","","2020-08-08 15:09:23","Angular TypeScript Date.getFullYear() not a function when returning Observable from server","<angular><typescript><rxjs-observables><angular-in-memory-web-api>","2","0","","","","CC BY-SA 4.0"
"63321727","1","63322458","","2020-08-09 01:42:35","","2","96","<p>I am struggling to understand , why i need to use observable.
I have a very simple store like below</p>
<pre><code>@Injectable({
  providedIn: 'root'
})
export class DataService {   

  private readonly personData: Person   = new Person();
  constructor() {
  }

  public getPerson():Person{
    return this.personData;
  }    
  public setAge(age:number){
    this.personData.age = age;
  }
}
</code></pre>
<p>this above service works just fine and exactly same if I were to use observable</p>
<pre><code>@Injectable({
  providedIn: 'root'
})
export class DataService {

  // @ts-ignore
  private readonly personData: BehaviorSubject&lt;Person&gt; = new BehaviorSubject&lt;Person&gt;({});

  public personData$: Observable&lt;Person&gt; ;

  constructor() {
    this.personData$ = this.personData.asObservable();
  }

  public getPerson():Person{
    return this.personData.getValue();
  }

  public setAge(age:number){
    this.getPerson().age = number;
  }
}
</code></pre>
<p>My question is , why would I use observable , the simple service property is working just fine!
Or I am missing the big picture! Please help me to understand.</p>
","899974","","","","","2020-08-09 04:27:40","Service without observables","<angular><rxjs><observable><rxjs-observables>","4","2","","","","CC BY-SA 4.0"
"63381609","1","","","2020-08-12 17:13:37","","0","34","<p>Since i was with angular9 and ivy compiler enable false.Everything was working fine.But after upgraded app to angular v10 and getting rxjs related operator and observable related getting compile error.</p>
<p><strong>Before</strong>:</p>
<p>&quot;rxjs&quot;: &quot;^6.5.5&quot;,
&quot;rxjs-compat&quot;: &quot;^6.5.5&quot;</p>
<p><strong>After</strong>(now rxjs-compat removed):</p>
<p>&quot;rxjs&quot;: &quot;^6.6.2&quot;</p>
<p><strong>Error:</strong></p>
<pre><code> error TS2339: Property 'filter' does not exist on type 'Observable&lt;any&gt;'.
</code></pre>
<p><strong>Code:</strong></p>
<pre><code> let fromdate$ = of(fromdatevalue)
          let fromdateIfNull = fromdate$.filter(date =&gt; date != null)
            .map(date =&gt; {
              let fromdate = new Date(fromdatevalue);
              fromdate.setHours(8, 0, 0, 0);
              return fromdate;
            })
</code></pre>
<p>How to solve error and i want with properly use of <code>rxjs</code> import in angular v10 app.</p>
<p>Thanks.</p>
","9948050","","","","","2020-08-12 17:13:37","Property 'filter' does not exist on type 'Observable<any>'. rxjs v6","<javascript><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","0","7","","","","CC BY-SA 4.0"
"63386585","1","63462962","","2020-08-13 00:58:06","","29","4133","<p><strong>Abstract problem:</strong> Every time a source Observable emits and event, a sequence of API calls and Angular services need to be triggered. Some of those invocations are depending on previous results.</p>
<p>In my example, the source Observable <code>startUpload$</code> triggers a series of depending invocations.</p>
<p>Using destructuring this can be written like this:</p>
<pre><code>this.startUploadEvent$.pipe(
      concatMap(event =&gt; this.getAuthenticationHeaders(event)),
      map(({ event, headers }) =&gt; this.generateUploadId(event, headers)),
      tap(({ event, headers, id }) =&gt; this.emitUploadStartEvent(id, event)),
      concatMap(({ event, headers, id }) =&gt; this.createPdfDocument(event, headers, id)),
      concatMap(({ event, headers, id, pdfId }) =&gt; this.uploadBilderForPdf(event, pdfId, headers, id)),
      mergeMap(({ event, headers, id, pdfId, cloudId }) =&gt; this.closePdf(cloudId, event, headers, id, pdfId)),
      tap(({ event, headers, id, pdfId, cloudId }) =&gt; this.emitUploadDoneEvent(id, event, cloudId)),
).subscribe()
</code></pre>
<p>It almost reads like an imperative approach. But it has certain problems:</p>
<ul>
<li>The destructuring chain is repeated over the code and gets longer and longer <code>{ event, headers, id, pdfId, cloudId }</code></li>
<li>Methods (like <code>generateUploadId(event, headers)</code>) are required to receive all previous values so that they are able to pass them to the next pipe, even if the method itself doesn't require it</li>
<li>Inner Observables (within the methods) are required to map the values so that further pipe stages can destruct them:</li>
</ul>
<p>_</p>
<pre><code>private closePdf(cloudId, event, headers, id, pdfId) {
    return this.httpClient.post(..., { headers } )
        .pipe(
             //...,
             map(() =&gt; ({ event, headers, id, pdfId, cloudId }))
        )
}
</code></pre>
<p>It would be nice if the compiler could take care of the boilerplate (like with <code>async await</code>) to write the code that reads like this (with none of the problems mentioned above):</p>
<pre><code>private startUpload(event: StartUploadEvent) {
    const headers = this.getAuthenticationHeaders(event)
    const id = this.generateUploadId()

    this.emitUploadStartEvent(id, event)

    const pdfId = this.createPdfDocument(event, headers, id)
    this.uploadBilderForPdf(event, pdfId, headers, id)

    const cloudId = this.closePdf(headers, pdfId)
    this.emitUploadDoneEvent(id, event, cloudId)

    return cloudId
  }
</code></pre>
<p>How to pass results between chained observables without the problems i've mentioned? Is there a rxjs concept i've missed?</p>
","1199731","","1199731","","2020-08-13 01:03:14","2020-08-19 06:43:25","How to pass results between chained observables","<angular><typescript><rxjs><rxjs-observables>","7","2","11","","","CC BY-SA 4.0"
"63395024","1","63409153","","2020-08-13 12:18:51","","1","917","<p>I have following code that mimics HTTP Requests polling.</p>
<pre><code>  timeout:Observable&lt;number&gt; = timer(10000);

  startPollingStackblitz(arnId: string) {
    const poll:Observable&lt;BuyingData[]&gt; = of({}).pipe(
        mergeMap(_ =&gt; {
          console.log('polling...' + arnId);
          return of([]);
          // return this.service.getData(arnId);
        }),
        takeUntil(this.timeout),
        tap(_ =&gt; console.info('---waiting 2 secs to restart polling')),
        delay(2000),
        repeat(),
        tap(_ =&gt; console.info('---restarted polling')),
      );

    this.subscription = poll.subscribe((data) =&gt; {
      console.log('subscribe...')
      if (data.length &gt; 0) {
        console.log('timeout...');
        console.log(this.timeout);// I want to stop polling immediately before timer will elapse
      }
    });
  }
</code></pre>
<p>I want my polling stops sending HTTP Requests (it logs 'polling...' at this demo version) when server responds with <strong>data.length &gt; 0</strong>. For some reason it continues to send Requests even after 10000ms timeout. How can I do that?</p>
","578663","","","","","2020-08-14 08:22:38","Stop RxJS HTTP Polling after HTTP success response","<angular><rxjs><observable><polling><rxjs-observables>","2","5","0","","","CC BY-SA 4.0"
"63396085","1","63396186","","2020-08-13 13:18:31","","1","511","<p>I use RxJs 6.6.0 and Angular 9.</p>
<p>I have two functions which returns Observable&lt;'Class1'&gt; and Observable&lt;'number'&gt;.</p>
<p>so I use to:</p>
<pre><code>funcA().subscribe(x=&gt;{ // do something...});

funcB().subscribe(x=&gt;{// do somethings..});
</code></pre>
<p>But I need to call funcB only when funcA() is finish. I see than concat may be helpful but I can't get the two answers like that</p>
<pre><code>concat(funcA,funcB).subscribe( (x,y)=&gt;{// do with x
//do with y});
</code></pre>
<p>I would like to do this because parameters of funcB depend of the return of funcA.</p>
","11353746","","214143","","2020-08-13 14:59:07","2020-08-13 16:59:19","Chain Observable RxJs in Angular","<angular><rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"63418891","1","63418960","","2020-08-14 19:20:32","","0","162","<p>The following code works fine if the &quot;canLogin&quot; property exists.</p>
<pre><code>this.canLogin$ = this.permissions$.pipe(pluck('canLogin'));
</code></pre>
<p>If the property doesn't exist, I get this error:</p>
<blockquote>
<p>ERROR TypeError: Cannot read property 'canLogin' of undefined</p>
</blockquote>
<p>How can I check for null or return null if the property doesn't exist?</p>
<p>I tried something like this but it doesn't work</p>
<pre><code>this.canLogin$ = this.permissions$.pipe(pluck('canLogin')) || of(false);
</code></pre>
","4293271","","","","","2020-08-14 19:26:56","How do I check if property exists before using RXJS pluck()?","<angularjs><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"63459335","1","","","2020-08-17 22:16:46","","-1","40","<p><strong>Angular 10</strong></p>
<p>In my component I have a simple Observable:</p>
<pre><code>me$: Observable&lt;User&gt; = this.store.select((s) =&gt; s.user);
</code></pre>
<p>I wish to show the user.firstName, but this is blank result:</p>
<pre><code>&lt;div&gt;You are {{ me$.firstName | async }}&lt;/div&gt;
</code></pre>
<p>If I use this, it works, so I know data is coming:</p>
<pre><code>me$ = this.store.select((s) =&gt; s.user.firstName);
</code></pre>
","172861","","","","","2020-08-17 22:27:53","Angular: Binding Observable values in the template","<angular><rxjs-observables>","1","2","","2020-08-17 23:52:32","","CC BY-SA 4.0"
"63468767","1","63469280","","2020-08-18 12:36:16","","0","62","<p>HI I have a api call and want to show the image from the property: welcomePopupImage: string;</p>
<pre><code></code></pre>
","","user13448251","","user13448251","2020-08-19 08:22:58","2020-08-19 08:22:58","How to show image from api call in Angular?","<javascript><angular><typescript><rxjs-observables>","1","7","","","","CC BY-SA 4.0"
"63470144","1","","","2020-08-18 13:52:28","","4","295","<p>When you subscribe to query params in a component, do you need to unsubscribe? I'm trying to avoid a memory leak.</p>
<p><strong>Subscription with variable for <code>unsubscribe()</code></strong></p>
<pre><code>  subscription$: Subscription

  constructor(private route: ActivatedRoute) {}

  ngOnInit() {
    this.subscription$ = this.route.queryParams.subscribe(
      (params: any): void =&gt; {
        // ... Do stuff here ...
      }
    )
  }

  ngOnDestroy() {
    if (this.subscription$ !== undefined || this.subscription$ !== null) {
      this.subscription$.unsubscribe()
    }
  }
</code></pre>
<p><strong>Subscription without variable for <code>unsubscribe()</code></strong></p>
<pre><code>
  constructor(private route: ActivatedRoute) {}

  ngOnInit() {
    this.route.queryParams.subscribe(
      (params: any): void =&gt; {
        // ... Do stuff here ...
      }
    )
  }

</code></pre>
<p><strong>Which one is a better solution?</strong></p>
","2197975","","2197975","","2020-08-18 13:58:25","2020-08-18 14:01:10","Do you need to unsubscribe from a subscription to router params in Angular?","<angular><typescript><angular-router><angular2-observables><rxjs-observables>","2","2","1","","","CC BY-SA 4.0"
"63540958","1","","","2020-08-22 20:45:25","","0","37","<p><strong>app.comp.ts</strong></p>
<pre><code>import { Component, OnInit } from '@angular/core';
// import { Observable } from 'rxjs/Observable';
import {LoginAuthService} from '../app/services/login-auth.service';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  title = 'Kaksha-UI';
  isLogin$: Observable&lt;boolean&gt;

  constructor(private authService: LoginAuthService) { }


  ngOnInit(): void {
    this.isLogin$ = this.authService.isLoggedIn;
    // let valueFromSession = sessionStorage.getItem(&quot;userLogin&quot;);
    // if(valueFromSession != undefined){
    //   this.isLogin = true;
    // }
    console.log(this.isLogin$);
  }


  

}
</code></pre>
<p><strong>app.comp.html</strong></p>
<pre><code>&lt;nav  class=&quot;navbar navbar-expand-lg navbar-dark bg-dark&quot;&gt;
    &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Kaksha&lt;/a&gt;
    &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarSupportedContent&quot;
        aria-controls=&quot;navbarSupportedContent&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt;
        &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt;
    &lt;/button&gt;

    &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarSupportedContent&quot;&gt;
        &lt;ul class=&quot;navbar-nav ml-auto&quot;&gt;
            &lt;li class='nav-item active' &gt;
                &lt;a class=&quot;nav-link&quot; *ngIf='!isLogin$ | async'   [routerLink]='[&quot;/login&quot;]'&gt;Login&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class='nav-item'&gt;
                &lt;a class=&quot;nav-link&quot; *ngIf='!isLogin$| async'  [routerLink]='[&quot;/register&quot;]'&gt;Register&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class='nav-item'&gt;
                &lt;a class=&quot;nav-link&quot; *ngIf='isLogin$ | async'  [routerLink]='[&quot;/register&quot;]'&gt;Logout&lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/nav&gt;

&lt;!-- &lt;h1 *ngIf='isLogin$ | async' &gt;Hello World&lt;/h1&gt; --&gt;

&lt;div class=&quot;container&quot;&gt;
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
&lt;/div&gt;
</code></pre>
<p><strong>login.service.ts</strong></p>
<pre><code>import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable ,BehaviorSubject} from 'rxjs';
import { Router } from '@angular/router';

@Injectable({
  providedIn: 'root'
})
export class LoginAuthService {

  private loginUrl = 'http://localhost:1050/login';

  private loggedIn = new BehaviorSubject&lt;boolean&gt;(false);

  constructor(private http: HttpClient,private router:Router) { }

  
  get isLoggedIn(){
    console.log('I am called');

    return this.loggedIn.asObservable();
  }

  loginUser(userObj){
    if(userObj.username != &quot;&quot; &amp;&amp; userObj.password != &quot;&quot;){
      this.loggedIn.next(true);
      this.router.navigate(['/dashboard']);
      console.log(this.loggedIn);
    }
  }
}
</code></pre>
<p>In the initial render of code the login/register button present in navbar should be rendered which is not rendering. If the code is analyzed in the initial render it should display login and register button</p>
<p>Also when I am going to login component and calling the registerUser function, then logout is appearing in the navbar</p>
","12315259","","5437671","","2020-08-22 20:53:41","2020-08-24 12:09:51","Login not appearing in initial render of angular application, using Behaviour of rxjs","<angular><rxjs><angular-ng-if><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"63545822","1","63546523","","2020-08-23 10:20:21","","1","702","<p>I have a service that is responsible to execute a httpClient.get every x seconds, using a timer.
I need this timer to start running whenever the service is up, so the <strong>timer</strong> is defined in the <strong>service</strong> <strong>constructor</strong>. According to my understanding, the subscription should be registered in the timer scope as seen below (I don't want to change it if there's no need, unless it is incorrect).</p>
<p>The all system is working fine as long as there are no errors\exceptions\error 500 exception from the backend server.
Now, I need 2 things:</p>
<ol>
<li>I would like to <strong>catchError</strong> whenever there is a problem in the backend server.</li>
<li>I would like the observer to keep running according to the timer times (to the next tick), even if there is an exception.
My final result should be reaching the popUpAlert in the component whenever there is exception
See my code - this the webapi controller:</li>
</ol>
<pre class=""lang-cs prettyprint-override""><code>public IActionResult getSomeErrorAsTest()
{
    try
    {
        throw new Exception(&quot;Serer error&quot;);
    }
    catch(Exception ex)
    {
        return StatusCode(StatusCodes.Status500InternalServerError, new List&lt;string&gt;());
        //throw ex;
    }
}
</code></pre>
<p>This is the service (assume that the data changes in every get request - no need to implement if it really do):</p>
<pre><code>export class MyService
{
    MyDataSubject = new Subject&lt;any[]&gt;();
    MyDataChanged :Observable&gt;any[]&gt; = this.MyDataSubject.asObservable();
    
    subscribe :Subscription;
    constructor(private httpClient : HttpClient)
    {
        this.subscribe = timer(0, 30000).pipe(
        switchMap(()=&gt;
            this.getData())).subscribe();
    }
    getData()
    {
        return this.httpClient.get&lt;any[]&gt;(&lt;controller url&gt;)
        .pipe(
            tap(res =&gt;
            {
                this.MyDataSubject.next(res);
            }),
            catchError(error =&gt;
                {
                    debugger;//I would expect to catch the debugger here, but nothing happens
                    return throwError(error);
                })
            )
    }
}   
</code></pre>
<p>The consumer component:</p>
<pre><code>export class MyComponent (private mySrv : MyService)
{
    getMyData()
    {
        let sub =this.mySrv.MyDataChanged.subscribe(result =&gt; doSomething(),
                                                    error=&gt; popUpAlert());
    }
}
</code></pre>
","6721134","","6721134","","2020-08-23 10:32:46","2021-06-24 21:44:14","How to continue catchError in timer (rxjs)","<angular><timer><rxjs><rxjs-observables><rxjs-pipe>","1","3","","","","CC BY-SA 4.0"
"63553113","1","63553152","","2020-08-23 23:51:08","","1","116","<p>this is my first time using <code>switchMap</code> from the rxjs library.</p>
<p>Im guessing this error message means its unhappy with how I am doing things.</p>
<p>Observe my <code>addemail</code> function</p>
<pre><code>addemail(form:NgForm){
    this.googlerecaptchaservice.verifyinteraction('general_marketing_email_signup')
      .subscribe(
        (score: any)=&gt;{
          console.log(score);
          const value = form.value.emailaddform;
          this.addemailservice.add_email_to_general_marketing(value)
            .subscribe(
              (req: any)=&gt;{
                console.log('here is the test');
                console.log(req);
              }
            );
        });

  }
</code></pre>
<p>more specifically the <code>googlerecaptchaservice.verifyinteraction</code></p>
<pre><code>verifyinteraction(action): Observable&lt;any&gt;{
    return this.recaptchaV3Service.execute(action).pipe(
      switchMap((value: any) =&gt; {
        const payload = {
        token: value
        };
        this.http.post(
          'http://127.0.0.1:8000/verify/recaptcha', payload
        );

      }));
  }
</code></pre>
<p>what I don't understand is why am I getting the error. What am I doing wrong?</p>
","","user14150478","","","","2020-08-24 00:00:48","Unhandled Promise rejection: You provided 'undefined' where a stream was expected. Using SwitchMap and a function of type Observable","<angular><rxjs><recaptcha><rxjs-observables>","2","0","1","","","CC BY-SA 4.0"
"63553232","1","","","2020-08-24 00:17:38","","0","31","<p>I am using rxjs to fetch registrants and their associated service and service image, however when the service get's updated it is not being reflected in my observable?</p>
<p>Can somebody figure out why, what am I doing wrong?</p>
<p>I have to keep writing stuff because stackoverflow won't let me post unless I write down redundant, superfluous information for the reader to read.</p>
<pre><code>that._registrantsSubscription = that.userForumRegistrantService.getRegistrants(forum.uid, forum.forumId)
  .switchMap(registrants =&gt; {
    if (registrants &amp;&amp; registrants.length &gt; 0) {
      let observables = registrants.map(registrant =&gt; {
        let getService$ = that.userServiceService.getService(registrant.uid, registrant.serviceId);
        let getDefaultServiceImages$ = that.userServiceImageService.getDefaultServiceImages(registrant.uid, registrant.serviceId);

        return combineLatest(getService$, getDefaultServiceImages$)
          .switchMap(results =&gt; {
            const [service, defaultServiceImages] = results;

            if (service){
              if (defaultServiceImages &amp;&amp; defaultServiceImages.length &gt; 0)
                service.defaultServiceImage = of(defaultServiceImages[0]);
              else {
                let tempImage = {
                  tinyUrl: '../../../assets/defaultTiny.jpg',
                  name: 'No image'
                };
                service.defaultServiceImage = of(tempImage);
              }
              return of(service);
            }
            else return of(null);
          }
        );
      });
      return zip(...observables, (...results) =&gt; {
        return results.map((result, i) =&gt; {
          if (result)
            registrants[i].service = of(result);
          else
            registrants[i].service = of(null);
          return registrants[i];
        });
      });
    }
    else
      return of([]);
  })
  .subscribe(registrants =&gt; {
    that.registrants = of(registrants);
  }
);


public getRegistrants(parentUserId: string, forumId: string): Observable&lt;any[]&gt; {
    return this.afs.collection&lt;any&gt;(`users/${parentUserId}/forums/${forumId}/registrants`, ref =&gt; ref.orderBy('creationDate', 'desc')).valueChanges();
}


public getService (parentUserId: string, serviceId: string): Observable&lt;any&gt; {
  return this.afs.collection(`users/${parentUserId}/services`).doc(serviceId).valueChanges();
}

public getDefaultServiceImages (parentUserId: string, serviceId: string): Observable&lt;any&gt; {
  return this.afs.collection&lt;any&gt;(`users/${parentUserId}/services/${serviceId}/images`, ref =&gt; ref.where('default', '==', true).limit(1)).valueChanges();
}
</code></pre>
","559724","","","","","2020-08-24 04:37:48","Inner observable not being updated","<rxjs><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"63561907","1","63562542","","2020-08-24 13:21:05","","0","35","<p>I made this functionality, each iteration i have 7 requests that sent each environment.dashboard.frequency time,
but at the beginning, I see that i send 14 requests to the server instead of 7 :</p>
<pre><code>let requests: Observable&lt;ResourceResponse&gt;[] = initRequests(this.durationService.resourceDataDuration)
    timer(0, environment.dashboard.frequency)
      .pipe(
        takeUntil(this.destroy),
        startWith(0),
        switchMap(() =&gt; forkJoin(requests))
      )
      .subscribe((responsesArr: ResourceResponse[]) =&gt; {
        this.updateBegin()
        for (const response of responsesArr) {
          this.durationService.resourceDurationHandler.setPresentedDataRanges(
            response,
            this.durationService.resourceDataDuration,
            this.durationService.resourcePresnetedDataDurations
          )
          this.updateMany(response.Resource, response.Response, true)
        }
        this.updateEnd()
        requests = initRequests(this.durationService.resourceDataDuration)
      })
</code></pre>
","14157627","","","","","2020-08-24 13:57:59","rxjs : get duplicate http requests on the first set that I send","<rxjs><rxjs5><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"63620920","1","63621060","","2020-08-27 17:03:54","","0","30","<p>I don't yet have the service to call for the values, so I am doing some boiler plate code with aysnc ngFors.</p>
<p>I am trying to create an obserable that can be consumed by an ngFor. I try:</p>
<pre><code> statuses$ = Observable.create((o) =&gt; {
    o.next(new NameValue('Open', 'OPEN'));
    o.next(new NameValue('Closed', 'CLOSED'));
    o.complete();
  });
</code></pre>
<p>then</p>
<pre><code>        &lt;mat-option *ngFor=&quot;let status of statuses$ | async&quot; [value]=&quot;status.value&quot;&gt;
          {{ status.name }}
        &lt;/mat-option&gt;
</code></pre>
<p>but I get an Async error</p>
<p>Cannot find a differ supporting object '[object Object]' of type 'Open'. NgFor only supports binding to Iterables such as Arrays</p>
","172861","","172861","","2020-08-27 17:10:46","2020-08-27 17:12:12","RxJS Observables: Creating with values","<angular><rxjs><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"63662285","1","63662346","","2020-08-30 21:23:48","","0","765","<p>I am using nestjs HttpService.get to retrieve data from the following API:</p>
<pre><code> getVehicleMake(): Observable&lt;AxiosResponse&lt;any&gt;&gt; {
   return  this.httpService.get('https://vpic.nhtsa.dot.gov/api/vehicles/getallmakes?format=json')
                 .pipe(
                       map(response =&gt; response.data.Results),
                       map(obj =&gt; obj.Make_Name),
                       );
}
</code></pre>
<p>The API returns a nested array of objects among other data. I am trying to access an Array of Make_Name property without success. I have tried various observable operators none seems to work. I know I could switch to a Promise...but I want to use observables......any ideas would be much appreciated.</p>
","6074455","","","","","2020-08-31 00:53:19","how to get nested api data using nestjs httpservice (axios)","<javascript><node.js><axios><nestjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"63669369","1","63669724","","2020-08-31 10:48:33","","0","64","<p>I have an http response like this:</p>
<pre><code>{
  version: &quot;&quot;,
  result: {
   pageInfo: {...},
     data: []
  }
}
</code></pre>
<p>So I am getting this response using an angular service. And using this service in component.</p>
<pre class=""lang-js prettyprint-override""><code>export class UserComponent implements OnInit {
    users$: Observable&lt;User[]&gt;;
    pageInfo$: Observable&lt;PageInfo&gt;;
    
    constructor(private userService: UserService) { }
    
      ngOnInit() {
    
        this.users$ = this.userService.getUsers().pipe(
          /// how to map response for users$ and pageInfo$ ???
          // response.data will be in users$
          // response.pageInfo will be in pageInfo$
        );
    
    }
    
}
</code></pre>
<p>But I can not map two different observable the response. Is there any practical solution for that?</p>
","694716","","1731935","","2020-08-31 12:16:21","2020-08-31 12:16:21","How to get values from angular observable?","<angular><rxjs><angular8><rxjs-observables>","3","3","","","","CC BY-SA 4.0"
"63683786","1","","","2020-09-01 08:13:12","","0","35","<p>I asked a question here recently about observables and you guys were of really great help (as always). Now I'm having a similar situation, and me and my team-mate are bending our brains over it.</p>
<p>The bug to fix was: user sees a collection of assets, and on browser refresh the wrong set of assets was being loaded. It turns out the key to the problem was one particular pipe observing the currently selected collection. Here's the relevant code:</p>
<pre><code>this.selectedCollection.pipe(
  filter((v) =&gt; !!v)).subscribe((v) =&gt; {
    console.log('PIPE: selected collection', v.collectionId);
    this.store.dispatch(
      // action jackson on redux
    )
  );
});
</code></pre>
<p>The action to be dispatched here is for loading the assets of the collection. One collection was always loaded first as default and it was conflicting with further selections made by the user.</p>
<p>I've also added console.logs on the relevant reducers and effect to visualize behavior.</p>
<p>What happens on browser refresh is this:</p>
<p><a href=""https://i.stack.imgur.com/6IHLL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6IHLL.png"" alt=""enter image description here"" /></a></p>
<p>Collection <em>9-em...</em> is the default collection we don't want to see, and collection <em>9uem...</em> is the user's choice whose asset's we want to see.</p>
<p>The first five lines show the expected output of the observable:</p>
<ul>
<li>default collection set as selected collection</li>
<li>reducer 'is loading' assets</li>
<li>the user triggers a change selected collection action</li>
<li>the selected collection value is being updated and emitted accordingly</li>
</ul>
<p>Now we would have expected the effect to load the assets and that's it. But what happens is that the pipe keeps emitting the same values once again, which is weird, because I'm 100% sure no further value is being set from anywhere. But it would also be fine, since we end up with the desired value. Yet strangely, the reducer is handling the load actions in reverse order, which led to the wrong assets being loaded (this could be a whole different issue on top).</p>
<p>Adding <em>auditTime(200)</em> as first operator to the pipe above fixed the issue. No further values were emitted.</p>
<p>Now, my questions are:</p>
<ul>
<li>Why are the values emitted twice? Could it be an inappropriate operator/subscription some place else (didn't see anything suspicious)?</li>
<li>And why is <em>auditTime(200)</em> magically fixing this?</li>
</ul>
<p>The effect also works as a pipe of actions being filtered, and it contains an <em>auditTime(200)</em> operator before executing, so that it executes only on the last action. While I do understand on principle what it does, I'm not quite sure if using <em>auditTime</em> like that just because it works is such a good idea.</p>
<p>I assume this is an issue out of noob confusion resulting in using rxjs not the right way. Unfortunately, I couldn't find anything useful on google. I really don't like 'fixing' a bug by adding a line of code that I just don't understand.</p>
<p>Thank you so much in advance!</p>
<p>As requested by fridoo, here's the code for <em>this.selectedCollection</em>:</p>
<pre><code>get selectedCollection(): Observable&lt;collectionState.CollectionsData&gt; {
  return this.store
     .select(collectionState.getSelectedCollection)
     .pipe(distinctUntilChanged());
}
</code></pre>
<p>And for <em>getSelectedCollection</em>:</p>
<pre><code>export const getSelectedCollection: (state: any) =&gt; CollectionsData = (state: any) =&gt;
getCollectionsState(state)
  ? getCollectionsState(state).selectedCollection
  : undefined;
</code></pre>
<p>The rest is pretty forward just objects of state, the observable created via the select method. We're not using any library for redux (not my decision), so select is implemented like this:</p>
<pre><code>select&lt;T&gt;(fn: (state: any) =&gt; T): Observable&lt;T&gt; {
  return this.state$.pipe(map(fn), distinctUntilChanged());
}
</code></pre>
<p>Does this help any further?</p>
","2013273","","2013273","","2020-09-02 06:50:37","2020-09-02 06:50:37","Why is my Observable emitting more values than expected, and why is auditTime a fix?","<redux><rxjs><rxjs-observables>","0","4","","","","CC BY-SA 4.0"
"63684206","1","63687077","","2020-09-01 08:41:42","","0","72","<p>Below is the effect used to trigger some actions when I load the application. When I run the below code it's throwing error.</p>
<pre><code>
@Injectable()
export class BootStrapEffects {
  bootStrap$ = createEffect(() =&gt; {
    return this.actions$.pipe(
      ofType(GetPrefSuccess),
      map((action) =&gt; action.payload),
      concatMapTo((payload: any) =&gt; [
        GetUser(payload.parsed.userId),
        GetMenu(payload.parsed.language),
      ])
    )
  })

  constructor(private actions$: Actions) {}
}
</code></pre>
<p>The above code is throwing the below error</p>
<pre><code>
error TypeError: You provided 'function (payload) { return [
                Object(_app_store_actions_account_action__WEBPACK_IMPORTED_MODULE_3__[&quot;GetUser&quot;])(),
                Object(_app_store_actions_product_action__WEBPACK_IMPORTED_MODULE_7__[&quot;GetMenu&quot;])()

  ]; }' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
</code></pre>
<p>From TSLint</p>
<pre><code>Argument of type '() =&gt; Observable&lt;never&gt;' is not assignable to parameter of type '() =&gt; never'.
  Type 'Observable&lt;never&gt;' is not assignable to type 'never'.ts(2345)
</code></pre>
<p>Can anyone help me to resolve this error?</p>
","1654619","","1654619","","2020-09-01 09:52:26","2020-09-01 11:49:37","Issue in NGX effects by passing payload to concatMapTo [actions]","<rxjs><ngrx><ngrx-effects><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"63698509","1","63708451","","2020-09-02 03:59:35","","0","49","<p>I have a class with more than 30 observable attributes. Each time my server receives a payload containing these 30 attributes I call the <code>next()</code> method for all the corresponding attributes of the instance, so far so good.</p>
<p>The problem is that, sometimes, I have to check for an attribute's value, outside the scope of the observer that subscribed to that observable attribute.<br />
What comes to mind is that I have to have duplicate attributes for everything, one is the observable and the other one is a stateful attribute to save the arriving values for later consumption.<br />
Is there some way to avoid this with a method like: <code>Observable.getCurrentValue()</code>?</p>
<h1>As requested, some example code</h1>
<pre class=""lang-js prettyprint-override""><code>class Example {
    public subjects = {
        a1: new Subject&lt;any&gt;(),
        a2: new Subject&lt;any&gt;(),
        a3: new Subject&lt;any&gt;(),
        a4: new Subject&lt;any&gt;(),
        a5: new Subject&lt;any&gt;()
    }

    public treatPayload(data: any) {
        for (const prop in data) {
            if (data.hasOwnProperty(prop) &amp;&amp; prop in this.subjects){
                Reflect.get(this.subjects, prop).next(data[prop])
            }
        }
    }

    public test() {
        const a1_observable = this.subjects.a1.asObservable()
        const a2_observable = this.subjects.a2.asObservable()

        const example_payload_1 = {
            a1: &quot;first&quot;,
            a2: &quot;second&quot;,
            a10: &quot;useless&quot;
        }

        const example_payload_2 = {
            a1: &quot;first-second&quot;,
            a2: &quot;second-second&quot;,
            a10: &quot;useless-second&quot;
        }

        a1_observable.subscribe((a1_new_value: any) =&gt; {
            const i_also_want_the_last_value_emitted_by_a2 = a2_observable.last_value() // of course, this doesn't exist
            console.log(a1_new_value)
            console.log(i_also_want_the_last_value_emitted_by_a2)
        })
        
        this.treatPayload(example_payload_1)
        this.treatPayload(example_payload_2)

    }
}
</code></pre>
<p>So, is there a way to retrieve the correct value of <code>i_also_want_the_last_value_emitted_by_a2</code> without a pipe operator? I think it would be a problem to emit all values I could possibly use in a subscriber within a pipe of the <code>a2_observable</code>.</p>
","12603421","","12603421","","2020-09-02 14:47:32","2020-09-02 15:11:46","How to retrieve last value passed to next() of an Rxjs Observable outside the observer","<rxjs><rxjs6><rxjs-observables>","1","8","","","","CC BY-SA 4.0"
"63698797","1","","","2020-09-02 04:38:45","","1","151","<p>New to Angular. Wanted to learn how to manage state centrally so used ngRx. Also, have not used an Observable before so I am really stuck. Below is my code where the cart holds and array of objects. I just need to iterate over the <code>cart</code> which is array of objects with reduce() to get a total of the price. No matter what I try it does not work. Just to add, up till this point my code is working fine and I am able to get cart data from the store.
Appreciate if someone can guide me in the right direction.</p>
<p>Thank you!</p>
<pre><code>import { Component } from '@angular/core';
import { Store, select } from '@ngrx/store';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-cart-icon',
  templateUrl: './cart-icon.component.html',
  styleUrls: ['./cart-icon.component.scss']
})
export class CartIconComponent {

  constructor(private store: Store&lt;any&gt;) {}

  cart: Observable&lt;Array&lt;any&gt;&gt;

  ngOnInit() {
    this.cart = this.store.select('cart')
  }
}
</code></pre>
","812355","","","","","2020-09-03 05:48:17","Angular - How To Process an Observable in the Class","<javascript><angular><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"63737435","1","63738352","","2020-09-04 08:21:11","","0","328","<p>A ShoppingCart with ShoppingCartItems is fetched via an outer REST call, after which an Observable of the ShoppingCartItems makes the inner call to enhance the ShoppingCartItems with a Provider.</p>
<p>A tap(console.log) after the inner call, reveals that the contents of the ShoppingCart are as expected - with the 5 ShoppingCartItems enhanced with a Provider. Tapping the subscription however, returns 5 alerts each containing the Provider I wanted to add as a property of ShoppingCartItem.</p>
<p>It seems I am using the wrong mergeMap/concatMap/switchMap - or not doing a 'collect' of some sort at the end of one or both calls.</p>
<p>The calls:</p>
<pre><code>  getShoppingCart$(userId: number): Observable&lt;ShoppingCart&gt; {
    return this.rest.getShoppingCart$(userId)
      .pipe(
        mergeMap(
          (shoppingCart) =&gt; from(shoppingCart.shoppingCartItems)
            .pipe(
              concatMap(
                item =&gt; this.rest.getProviderByWine$(item.wine.id)
                  .pipe(
                    map(provider =&gt; item.provider = provider),
                  )
              ),
              // Returns ShoppingCart with Providers added
              tap(() =&gt; console.log('ShoppingCart: ' + JSON.stringify(shoppingCart)))
            )
        ),
      )
  }
</code></pre>
<p>The subscription:</p>
<pre><code>  ngOnInit(): void {
    this.shoppingCartService.getShoppingCart$(1037).subscribe(
      (shoppingCart: ShoppingCart) =&gt; {
        this.dataSourceShoppingCart = new NestedMatTableDataSource&lt;ShoppingCartItem&gt;(shoppingCart.shoppingCartItems);
        // Runs 5 times - each time displaying a Provider, not the ShoppingCart
        alert(JSON.stringify(shoppingCart))
      }
    );
  }
</code></pre>
<p>The actual REST calls:</p>
<pre><code>  getShoppingCart$(userId: number): Observable&lt;ShoppingCart&gt; {
    return this.http.get&lt;ShoppingCart&gt;(this.getBaseUrl() + 'users/' + userId + '/shopping-cart');
  }

  getProviderByWine$(wineId: number): Observable&lt;any&gt; {
    return this.http.get&lt;Provider&gt;(this.getBaseUrl() + 'wine/' + wineId + '/provider');
  }
</code></pre>
<p>Any pointers are greatly appreciated. Angular version is 8.</p>
","818722","","","","","2020-09-04 10:32:56","Angular - nested REST API calls only returning inner call","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","2","2","","","","CC BY-SA 4.0"
"63755564","1","63755813","","2020-09-05 15:26:08","","1","578","<p>I have the following code and I'm trying to calculate the total of all items added to the cart. When I use reduce I don't get back anything but while troubleshooting I added a map in there (commented out code) and that prints a value. I can add more code here but so you know everything is working fine. I am able to see data in the cart which is an array of objects. I just need to iterate over and calculate the total price.
Please advise.</p>
<pre><code>this.store.select('cart').pipe(reduce((accumalatedTotal, cartItem) =&gt; accumalatedTotal + (cartItem.price), 0))subscribe((val:number) =&gt; console.log(&quot;===&gt;&gt;&gt;&quot;, val));

//this.store.select('cart').pipe(map(cartItem =&gt; cartItem.price)).subscribe((val:number) =&gt; console.log(&quot;===&gt;&gt;&gt;&quot;, val));
</code></pre>
<p>With that commented out map I can print the item price but I cannot see anything with reduce.</p>
","812355","","","","","2020-09-05 16:49:48","Angular with RxJS - Array's Reduce Function Not Working When Subscribed To An Observable","<javascript><angular><rxjs-observables>","3","0","1","","","CC BY-SA 4.0"
"63797229","1","63797314","","2020-09-08 15:38:46","","0","46","<p>Suppose I have 2 interfaces defined like:</p>
<pre><code>export interface SpecFormatA{
  CPUFullname: string;
  CPUmanufacturer: string;
  Physicalmemory: number;
  Pagesize: number;
  OSinfo: string;
  Videocontroller: Array&lt;string&gt;
}

export interface SpecFormatB{
  CPUname: string;
  OSinfo: string;
  RAM: string;
  VideoController: Array&lt;string&gt;;
}
</code></pre>
<p>I call a method and get observable of <code>SpecFormatA</code>. I want to format the observable received and create a new observable of <code>SpecFormatB</code> and return it from my method instead.
Is there an easy way to do it?</p>
<p>My conversion logic is like:</p>
<pre><code>SpecFormatB.CPUname = SpecFormatA.CPUFullname
SpecFormatB.OSinfo = SpecFormatA.OSinfo
SpecFormatB.RAM = `${SpecFormatA.Physicalmemory / Math.pow(1024, 3)} GB`
SpecFormatB.VideoController =  SpecFormatA.VideoController
</code></pre>
","7366323","","","","","2020-09-08 15:59:57","Convert an Observable<Type1> to an Observable<Type2>","<angular><typescript><rxjs><rxjs-observables>","2","1","","","","CC BY-SA 4.0"
"63807974","1","","","2020-09-09 08:44:25","","0","195","<p>i am having a custom component</p>
<pre class=""lang-js prettyprint-override""><code>export class SystemInputComponent implements OnInit, OnDestroy {

  @Input() ...

  @Output() enterFn: EventEmitter&lt;any&gt; = new EventEmitter&lt;any&gt;();
  ...
</code></pre>
<p>that has output that act as an event <em>as i know</em></p>
<p>and that component imported outside in other component html</p>
<pre class=""lang-html prettyprint-override""><code>&lt;div class=&quot;input-group&quot;&gt;
    &lt;system-input #systemInput&gt;&lt;/system-input&gt;
&lt;/div&gt;
</code></pre>
<p>the regular way to bind the event is add it into the component tag as attribute with () and bind it to a function</p>
<pre class=""lang-html prettyprint-override""><code>&lt;system-input #systemInput (enterFn)=&quot;someFunct($event)&quot;&gt;&lt;/system-input&gt;
</code></pre>
<p>the question is can i bind it from ts code with rxjs fromEvent function like this</p>
<p><strong>inside .ts file</strong></p>
<pre class=""lang-js prettyprint-override""><code>import { fromEvent } from 'rxjs';
.
.
..
@ViewChild('systemInput') systemInput:any;
ngOnInit(){
     fromEvent(this.systemInput.nativeElement,'enterFn').subscribe(a =&gt; //a is the $event );
}
..

</code></pre>
<p>and if it could how to it properly, because it give me a error</p>
<pre><code>Cannot read property 'nativeElement' of undefined
</code></pre>
<p><strong>EDIT</strong>
as JoH said in the first comment i moved it to ngAfterViewInit</p>
<pre class=""lang-js prettyprint-override""><code>ngAfterViewInit(){
     fromEvent(this.systemInput.elementRef.nativeElement,'enterFn').subscribe(a =&gt; //a is the $event );
}
</code></pre>
<p>it give me that new error</p>
<pre><code>Invalid Event Traget
</code></pre>
","13399674","","13399674","","2020-09-09 09:15:26","2020-09-24 19:31:10","can i bind from event to custom component output","<angular><rxjs6><rxjs-observables><angular10>","1","4","","","","CC BY-SA 4.0"
"63816537","1","63816726","","2020-09-09 17:18:50","","1","116","<p>I am trying to &quot;reset&quot; a timer when a service emits a new Expiration time. I have it overwriting the observable. I am not sure if i should &quot;garbage collect&quot; the observable OR if there is a better way to &quot;reset&quot; the timer.</p>
<p>This code works fine but i am unsure if this is best practices</p>
<pre class=""lang-js prettyprint-override""><code>    const openModal = () =&gt; {
      if (this.sessionModal === null) {
        this.sessionModal = this.modalService.open(SessionModalComponent, {size: 'sm', backdrop: 'static', keyboard: false});
        this.sessionModal.result.then(() =&gt; this.sessionModal = null);
      }
    };

    this.expiresAt = authService.expiresAt;

    if (this.expiresAt !== null) {

      this.sessionTimerSubscription
        = timer(this.expiresAt.getTime() - (new Date()).getTime() - this.sessionModalOffset).subscribe(openModal);

      authService.expiresAt$.subscribe((expiresAt) =&gt; {

        this.expiresAt = expiresAt;

        this.sessionTimerSubscription.unsubscribe();
        this.sessionTimerSubscription
          = timer(this.expiresAt.getTime() - (new Date()).getTime() - this.sessionModalOffset).subscribe(openModal);
      });
    }
</code></pre>
","338456","","338456","","2020-09-09 18:09:03","2020-09-09 18:09:03","RxJS Overwrite Timer/Observable Best Practice","<angular><typescript><rxjs><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"63818659","1","63818855","","2020-09-09 19:51:07","","0","70","<p>there is code:</p>
<pre><code>    ngOnInit(): void {
        [this.newReleaseNotes$, this.readReleaseNotes$] = partition(this.getReleaseNotes$(), ({ id }: ReleaseNoteInterface) =&gt;
            this.releaseNotesService.readReleaseNotes.includes(id),
        );
    }

    private getReleaseNotes$(): Observable&lt;ReleaseNoteInterface[]&gt; {
        return forkJoin(this.releaseNotes.map((releaseNoteId: string) =&gt; this.releaseNotesService.fetchReleaseNoteById$(releaseNoteId)));
    }
</code></pre>
<p>this code throws an error in TypeScript:</p>
<blockquote>
<p>error TS2345: Argument of type '({ id }: ReleaseNoteInterface) =&gt; boolean' is not assignable to parameter of type '(value: ReleaseNoteInterface[], index
: number) =&gt; boolean'.
[0]       Types of parameters '__0' and 'value' are incompatible.
[0]         Type 'ReleaseNoteInterface[]' is missing the following properties from type 'ReleaseNoteInterface': id, type, importance, actuality, and 8 more.</p>
</blockquote>
<p>method this.releaseNotesService.fetchReleaseNoteById $ makes a request to the server and returns <code>Observable&lt;ReleaseNoteInterface&gt;</code></p>
<p>How to use the <strong>partition</strong> operator correctly to solve my problem?</p>
","1162208","","","","","2020-09-10 05:20:01","RxJS partition. ERROR - is missing the following properties from type","<angular><rxjs><rxjs-observables>","2","1","","","","CC BY-SA 4.0"
"63819437","1","","","2020-09-09 20:56:40","","-1","247","<p>one of angular service method(http call) created with switchMap operator,so it can reject/cancel the previous rest API calls if new one arrived. it is working fine and make a backend call but it not reject any BE call but it sequentially calling every call and wait for all of BE call to response, it should reject previous calls.</p>
<p>where I am doing wrong ?</p>
<p><a href=""https://stackblitz.com/edit/angular-rxjs-switchmap-merge-results-multiple-http-reque-yyq7sn?embed=1&amp;file=src/app/app.component.ts"" rel=""nofollow noreferrer"">stackblitz example</a></p>
<p>to create first observer event I am using from() method and by each typing it calls HTTP get API.</p>
<p><a href=""https://i.stack.imgur.com/qVJ2P.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qVJ2P.png"" alt=""enter image description here"" /></a></p>
","12815961","","12815961","","2020-09-09 21:06:56","2020-09-09 21:06:56","switchMap is not cancelling previous HTTP call","<angular><rxjs><rxjs-observables><switchmap>","1","0","","2020-09-10 01:22:59","","CC BY-SA 4.0"
"63822298","1","","","2020-09-10 03:15:23","","2","629","<p>I am a novice user in the library RXJS and trying to figure out how to use properly Observable and Subjects.
I am trying to draw parallels with pattern design Observer.
At some point, I have a question if the instance of the Observable from the library RXJS is a special case of Observer pattern design?</p>
","1067943","","","","","2020-09-10 06:57:10","Observer pattern design and RXJS library","<design-patterns><rxjs><observable><observer-pattern><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"63835672","1","63835701","","2020-09-10 18:27:43","","0","106","<p>I am using <code>switchMapTo</code> to create an inner stream that is triggered by an outer observer.</p>
<h2>What I'd like to do (but can't)</h2>
<pre><code>// a change in value of categoryId triggers the inner observer to reinitialize
this.category$ = this.categoryId$.pipe(
  switchMapTo((newCategoryId) =&gt; 
    // inner stream is reinitialized using result from outer stream
    this.categoriesQuery.selectEntity(newCategoryId)
  )
)
</code></pre>
<h3>...because this is how switchMapTo actually works</h3>
<p><code>.switchMapTo</code> doesn't actually return the result from the outer observer to the inner observer. As far as I can tell, the inner stream is initialized just once and then it is triggered by each new emission from the outer observer</p>
<p>How <code>.switchMapTo</code> actually works:</p>
<pre><code>this.category$ = this.categoryId$.pipe(
  switchMapTo(
    this.categoriesQuery.selectEntity(newCategoryId) // &lt;= where does newCategoryId come from now?
  )
)
</code></pre>
<h3>And the inner observer is only initialized once</h3>
<p>Unfortunately this doesn't work either:</p>
<pre><code>this.category$ = this.categoryId$.pipe(
  tap((newValue) =&gt; {
     this.currentCategoryId = newValue
  }),
  switchMapTo(() =&gt;{
    this.categoriesQuery.selectEntity(this.currentCategoryId)
  }
  )
)
</code></pre>
<p>Because the inner observer is only initialized once (not at every emission from the outer observer) and so the value of <code>this.currentCategoryId</code> is hard-coded in the first time it's evaluated.</p>
<h3>Is it possible to do what I want to do?</h3>
<p>I'm pretty stuck. I'd like to have the effect of <code>switchMapTo</code> i.e. the outer observer triggers the emission of a new inner stream. But it needs to be a <em>new</em> inner stream and not just the repetition of the original one. Is this possible?</p>
","400790","","","","","2020-09-10 18:35:16","How do I use the result of the outer observer in the inner observer of switchMapTo?","<angular><rxjs><rxjs-observables>","1","0","0","","","CC BY-SA 4.0"
"63845774","1","63849833","","2020-09-11 11:01:45","","2","55","<p>I have an angular application that should sync some data with the server on some conditions (some triggers in software or when user request). So i have a function like this:</p>
<pre><code>    ...

    public createSyncObservable(): Observable&lt;any&gt; {
        return this.retriveDataFromStorage().pipe(
            switchMap(
                (data) =&gt; forkJoin(this.api.sendData1(data.data1),this.api.sendData2(data.data2),this.api.sendData3(data.data3))
            ),
            switchMap(
                (data) =&gt; this.api.getDataFromServer()
            ),
            switchMap(
                (data) =&gt; this.updateLocal(data)
            )
        )
    }
</code></pre>
<p>The behaviour I want is:</p>
<ul>
<li>If user (or some trigger) request the sync and it is already happening, I should not do it again, just wait for the current sync to end and return the same observable (shared).</li>
<li>If last sync already finished, it should start again (create a new observable).</li>
</ul>
<p>My best solution for now is to do something like this (untested code):</p>
<pre><code>    ...
    public syncData(): Observable&lt;any&gt; {
        if (this.observable_complete) {
            this.observable_complete = false;
            this.syncObservable$ = this.createSyncObservable().pipe(share())
            this.syncObservable$.subscribe(
                (data) =&gt; {this.observable_complete = true}
            ) 
        }
        return this.syncObservable$;
    }
</code></pre>
<p>Is this the way to go? Maybe I am missing some RxJS operator that would help me in this case? This solution just seems a bit hacky...</p>
","2085389","","","","","2020-09-11 15:23:29","Share a subscription if observable not done","<angular><typescript><rxjs><rxjs-observables><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"63846906","1","63847606","","2020-09-11 12:14:39","","1","40","<p>I have one endpoint for getting list of users, and another for getting list of apartments for every user:</p>
<pre><code>getUsers() =&gt; Observable&lt;User[]&gt;;
getUserApartments(userId) =&gt; Observable&lt;Apartment[]&gt;`
</code></pre>
<p>How do I merge the data from the two into single observable:</p>
<pre><code>const usersWithApartments$: Observable&lt;{ user: User, apartments: Apartment[] }[]&gt; = getUsers().pipe(
    // users.map(user =&gt; { user, apartments: getUserApartments(user.id) }) &lt;-- turn this pseudocode into Rxjs
);
</code></pre>
","1457181","","1457181","","2020-09-11 13:03:26","2020-09-11 14:35:25","rxjs: load many for many from 2 endpoints and merge into single Observable","<rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"63899830","1","","","2020-09-15 10:21:16","","0","41","<p>Loading spinner should appear and disapper after a delay but it doesn't appear at all, but if i remove the line &quot;this.isLoading = false&quot; the spinner is showing but doesn't disappear !</p>
<pre><code> const myObservable = of(&quot;foobar&quot;);

    myObservable.subscribe((value) =&gt; {

      this.isLoading = true,
        delay(5000),
       // If i remove the line below the spinner is showing
        this.isLoading = false

      console.log(value);  
    });
</code></pre>
","3963082","","","","","2020-09-15 10:32:06","Loading spinner does not appear with delay","<angular><rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"63942143","1","","","2020-09-17 16:14:22","","1","131","<p>Let's say the proper pattern in Angular to unsubscribe from an observable in a component is thus:</p>
<p><a href=""https://i.stack.imgur.com/pHt0l.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pHt0l.png"" alt=""Canonical subscribe/unsubscribe"" /></a></p>
<p>Now let's say I forgot the .unsubscribe() call in ngOnDestroy(). Is there any linting rule I could set up to catch this, or it must strictly rely on code review?</p>
","10002542","","","","","2020-10-05 08:47:24","Is there a way to perform static code analysis/linting for Angular memory leak?","<angular><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"63970461","1","63971865","","2020-09-19 15:33:26","","0","31","<p>I want to iterate over a series of asynchronous functions and end the iterating when a false is returned.
I'm new to <code>rxjs</code> and can't get the use-case below to work. I feel like I'm not understanding something fundamental. Can someone please point it out to me?</p>
<pre><code>function validateA(): Observable&lt;any&gt; {
  // do stuff.
  return of({ id: &quot;A&quot;, result: true }); // hardcoding result for now
}

function validateB(): Observable&lt;any&gt; {
  // do stuff
  return of({ id: &quot;B&quot;, result: true }); // hardcoding result for now
}

function validateC(): Observable&lt;any&gt; {
  // do stuff
  return of({ id: &quot;C&quot;, result: false });// hardcoding result for now
}

from([validateA, validateB, validateC])
  .pipe(
    map(data =&gt; data()),
    takeWhile(data =&gt; !!data.result)
  )
  .subscribe(data =&gt; console.log(`${data.id} passed!`));
</code></pre>
<p><a href=""https://stackblitz.com/edit/typescript-ub9c5r?file=index.ts&amp;devtoolsheight=100"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/typescript-ub9c5r?file=index.ts&amp;devtoolsheight=100</a></p>
","3508264","","13754420","","2020-09-22 20:20:16","2020-09-22 20:20:16","How do I iterate over functions that return rxjs observables","<rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"63975212","1","","","2020-09-20 03:23:32","","1","241","<p>I have an angular 2+ app running onsen ui, I have setup some components as pages and I am using the ons-navigator to switch between them.</p>
<p>The problem im having is that when im subscribed to an observable in an ons-page and the user navigates away from that page, The observable is still active. It seems like ngOndestroy doesnt get called when changing pages using the onsen navigator.</p>
<p>Im wondering how can I resolve this?</p>
<p>heres some code:</p>
<pre><code>import { Component, OnDestroy, OnInit } from '@angular/core';
import { OnsNavigator } from 'ngx-onsenui';
import { HomePageComponent } from '../home-page/home-page.component';
import { CommonDataService } from '../_services/common-data.service';
import { MenuService } from '../_services/menu.service';
import { UserService } from '../_services/user.service';

@Component({
  selector: 'ons-page',
  templateUrl: './login-page.component.html',
  styleUrls: ['./login-page.component.scss']
})
export class LoginPageComponent implements OnInit {

  constructor(
    private menuService: MenuService,
    private commonDataService: CommonDataService,
    private _navigator: OnsNavigator,
    private userService: UserService) { }
  

  ngOnInit() {
    this.menuService.changePage$.subscribe((page) =&gt; {
      this._navigator.element.pushPage(page, {data: {hoge: &quot;fuga&quot;}});
    });
  }

  ngOnDestroy(): void {
    //doesnt work
    console.log('on destroy called.');
  }

}
</code></pre>
","5047415","","","","","2020-09-20 04:49:00","Unsubscribe to observable when navigating away from an onsen ui page","<angular><typescript><onsen-ui><angular2-observables><rxjs-observables>","2","4","","","","CC BY-SA 4.0"
"63979392","1","63979536","","2020-09-20 13:16:26","","-1","55","<p>I had subscribed for async pipe and one pipe retrun - &gt; <code>bservable&lt; AModel | undefined | null&gt;</code>.
I compine this four pipe in combineLatest and subcribe.but I need below code excute only  -&gt; AModel came.
So ,I used  <code>skipWhile(([, , , selectedA]) =&gt; !selectedA)</code> . but AModel -&gt; undefind it not stop and go to exute below code. need some expert help to resolve it.</p>
<p>------------------code -----------------------------------</p>
<pre><code>   combineLatest(observables)
     .pipe(skipWhile(([, , , selectedA]) =&gt; !selectedA),
       shareReplayUntil(this.destroySub))
     .subscribe(([a, b, c, selectedA]) =&gt; { }```
</code></pre>
","4108618","","","","","2020-09-20 13:33:13","Undefind type not filter in skipWhile?","<typescript><rxjs><ngrx><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"63980632","1","","","2020-09-20 15:28:10","","0","30","<p>I'm trying to return &quot;cartProducts&quot; and apply its value to &quot;userCartProducts&quot; and then use this var to display the products in my HTML
but I can't manage to get &quot;cartProducts&quot; out of the subscribe scope.</p>
<p>My code:</p>
<pre><code>   export class CartComponent implements OnInit {
    
      storeProductList$: Observable&lt;IProduct[]&gt;;
      userCart$: Observable&lt;ICart&gt;;
    
      userCartProducts: ICart
    
      constructor(private _store: Store&lt;IState&gt;) {
        this.storeProductList$ = _store.select(state =&gt; state.store.storeProductList);
        this.userCart$ = _store.select(state =&gt; state.store.userCart);
      }
    
      ngOnInit(): void {
        this.loadCartProducts()
      }
    
      deleteFromCart(productId: IProductId) {
        this._store.dispatch(deleteFromCartRequest({ productId }))
      }
    
      loadCartProducts = () =&gt; {
        this.storeProductList$.subscribe(value =&gt; {
          this.userCart$.subscribe(cartValue =&gt; {
            const cartProducts = cartValue[0].products.map((cartProduct) =&gt; {
              const foundProduct = value.find((product) =&gt; {
                console.log(&quot;product._id&quot;, product._id)
                console.log(&quot;cartProduct.productID&quot;, cartProduct.productID)
                // cartProduct.amount = product['amount']
                return cartProduct.productID === product._id
              });
              console.log({ foundProduct })
              return foundProduct
            });
          });
        });
      };
    };
</code></pre>
","10793009","","3001761","","2020-09-20 15:31:05","2020-09-20 15:31:05","How to return value of of map inside subscribe?","<javascript><angular><rxjs><rxjs-observables>","0","1","","2020-09-20 15:38:52","","CC BY-SA 4.0"
"63999437","1","63999699","","2020-09-21 20:18:45","","1","616","<p>I have an Angular 7 application that allows you to multi-upload files. For each file chosen, it makes a request to the server. This isn't great because opening hundreds of concurrent calls seems like a  potential problem for my backend servers.</p>
<p>What I'd like to do is limit the number of concurrent requests that can be made by my application. I have a generic API class that I'd like to use to do the limiting in app-wide beyond just the file uploading, instead of needing the file-upload component itself to have to manage it.</p>
<p>I'm admittedly confused at times by RxJx, but I'm pretty sure that this is possible.</p>
<pre><code>class ApiService {

    get(path: string, params: any = {}): Observable&lt;any&gt; {
        return this.http.get(path`, { params: params });
    }
    
    uploadFile(path: string, body: any = {}): Observable&lt;any&gt; {
        ...code for preparing file here...
        return this.http.post(path, body);
    }
    
}

class FileUploader {

    // called many times-- once for each file
    uploadFile(file) {
        this.apiService.uploadFile(path, body: file).subscribe(response =&gt; {
             // use response here
        })
    }
}

</code></pre>
<p>What I imagine is that in the api class, instead of executing the http call immediately in the fileUpload or get functions, I could add to a queue that uses a max concurrency or something and waits to make the call until there is room. But I'm not sure how to do this given that I'm subscribed immediately in the File Uploader class.</p>
","5858777","","","","","2020-09-22 10:38:25","How To Limit Concurrent API Requests In Angular Using RxJs","<angular><rxjs><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"64064668","1","64071266","","2020-09-25 13:00:16","","0","118","<p>I have an app that should scan for specific ble devices. The scan function I use keeps scaning all devices and should even report duplicates (the same device can be scanned multiple times). To organize the scanned data, I created an observable that emits all devices found in a list and remove the ones that were not scanned within certain time:</p>
<pre><code>public findMyDevice() {
    let my_devices: any[] = [];

    return this.ble.startScan().pipe(
        filter(
            (device) =&gt; this.deviceIsMyDevice(device)
        ),
        map(
            (device) =&gt; {
                device = this.treatData(device);
                my_devices =  my_devices.filter((dev) =&gt; dev.id != device.id); // in case it is already in the list
                let now = new Date();
                device.time_scan = now;
                my_devices.push(device);
                my_devices.sort((a, b) =&gt; a.sn - b.sn);
                my_devices = this.removeOldDevices(my_devices); // remove scans older than 5 seconds
                return my_devices;
            }
        )
    )
}
</code></pre>
<p>It works fine if there is at least one device ON nearby.</p>
<p>Problem is: if all devices are turned off, my scan function never emits and the call to removeOldDevices is never made... That way, some old devices are kept in the list...</p>
<p>I tried to solve it adding to my pipe:</p>
<pre><code>timeoutWith(3000,
    of().pipe(
        map(
            () =&gt; {my_devices = this.removeOldDevices(my_devices); return my_devices}
        )
    )
)
</code></pre>
<p>but it seems to finish the subscription after the timeout. What is the best way to solve this? How can I force the observable to emit after some idle time without finishing the subscription? Is there any other rxjs operator to help with this situation?</p>
","2085389","","","","","2020-09-25 21:00:45","How to force an observable to always emit after some time idle","<typescript><ionic5><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"64092140","1","64120929","","2020-09-27 18:51:43","","0","81","<p>I think maybe it would be better to use something like map&lt;T,R&gt; then what I'm doing currently. Hopefully, I can receive some suggestions on how to get this working. Currently the result is no events get mapped because I'm mapping incorrectly so the path is wrong.</p>
<p>My main issue is bks.fname is undefined as the path is wrong. The correct path is
[&quot;05182020&quot;].Peeter.[-MCcGOMe0FT1IqvlCJkd].fname</p>
<p>But how would I define this in a model?</p>
<p>**Returned Json with each key being dynamic: **</p>
<pre><code>
05182020:
   Peteer:
     -MCcGOMe0FT1IqvlCJkd:   //The start of the book model
        date: &quot;05/18/2020&quot;
        name: &quot;Peteer&quot;
        service: &quot;b&quot;
        shop: &quot;Howards&quot;
        time: &quot;10:00 AM&quot;

</code></pre>
<p><strong>The Models:</strong></p>
<pre><code>export interface Books {
    date?: string;
    fname?: string;
    lname?: string
    name?: string;
    service?: string;
    shop?: string
    time?: string;
}


export interface IDictionary&lt;T&gt; {
    [index:string]: Books;
}

export interface Bookings {
  [index:string]: Books;
}

export interface CalendarEvent&lt;MetaType = any&gt; {
    id?: string | number;
    start: Date;
    end?: Date;
    title: string;
    color?: EventColor;
    actions?: EventAction[];
    allDay?: boolean;
    cssClass?: string;
    resizable?: {
        beforeStart?: boolean;
        afterEnd?: boolean;
    };
    draggable?: boolean;
    meta?: MetaType;
}

</code></pre>
<p><strong>TS</strong> NOTE: the bks.fname and others are undefined because currently   map((results) =&gt;  is taking in the root object instead of just the Books model.</p>
<pre><code>Calaendar.component.ts

events$: Observable&lt;CalendarEvent&lt;IDictionary&lt;Books&gt;&gt;[]&gt;;

   this.events$ = this.fs.getFullList2(this.shopName)

      .pipe(
        catchError(err =&gt; {
          console.log(err)
          return throwError(err);
        }),
        first(),
        tap(results =&gt;
          console.log(&quot;bookings:&quot;, results[0])
        ),
        map((results) =&gt; {
          return results.map((bks: Books) =&gt; {
           return {
              title: bks.fname + &quot; &quot; + bks.lname + &quot; ---Time: &quot; + bks.time + &quot; , Service: &quot; + bks.service,
              start: new Date(bks.date),
              color: colors.red,
              allDay: true,
              meta: bks,//.time,
            };
          }
          );
        }
         ));


fireserveice.ts

  getFullList2(shop: string): Observable&lt;any&gt; {

    return this.db.list(shop,ref=&gt;ref.limitToFirst(1)).valueChanges()
  }

</code></pre>
","9911192","","9911192","","2020-09-28 20:03:58","2020-09-29 13:44:42","Working with observables how to map nested dynamic object keys? Using angular-calendar events","<angular><rxjs><pipe><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"64097767","1","64100498","","2020-09-28 07:33:11","","1","1465","<p>I would like to call onDataChange() only if previous value of input / selection != current Value of input / selection.</p>
<p>However I've noticed that it is still calling onDataChange() whenever put the cursor on the input field (but didn't change any value of the input field / change selection of the dropdown value).</p>
<p>I have used startWith(null), pairwise, and then filter(prev!=next) but it still executing the onDataChange() even though the previous value is same as next value.</p>
<p>The main problem is when putting the cursor on the input field but doesn't change any value, it still call onDataChange().</p>
<p>I would like to call onDataChange() only if there is changes in the input value/ changes in the dropdown selection. onDataChange() will invoke the api call, which might takes longer time to retrieve the result.</p>
<p>Does anybody experience similar issue and could provide guidance? Thanks.</p>
<p>'</p>
<pre><code>  &lt;form class=&quot;form&quot; [formGroup]=&quot;numberForm&quot; noValidate [style.width.px]=&quot;width&quot;&gt;
       &lt;select name=&quot;types&quot; id=&quot;dropdown-number-types&quot; formControlName=&quot;dropdown&quot;&gt;
           &lt;option *ngFor=&quot;let type of types&quot; [value]=&quot;type&quot;&gt;{{type}}&lt;/option&gt;
       &lt;/select&gt;
    
       &lt;input id=&quot;onValue&quot; type=&quot;text&quot; name=&quot;onValue&quot; formControlName=&quot;onValue&quot;&gt;
       &lt;select name=&quot;equalsUnit&quot; id=&quot;dropdown-number-unit&quot; formControlName=&quot;onValueUnit&quot;&gt;
            &lt;option *ngFor=&quot;let unit of units&quot; [value]=&quot;unit&quot;&gt;{{unit}}&lt;/option&gt;
       &lt;/select&gt;
&lt;/form&gt;

ngOnInit() {
  const valueChanges: Observable&lt;any&gt;[] = [
    this.numberForm.get('dropdown').valueChanges,
    this.numberForm.get('onValue').valueChanges,
    this.numberForm.get('onValueUnit').valueChanges
  ].map(obs =&gt;
      obs.pipe(
          startWith(null), pairwise(),
          filter(([prev, next]) =&gt; prev !== next),
      )
  );

  // Merge all valueChanges observables into one - and debounce time for 250ms to avoid processing
  // events in quick succession which can happen if user is changing values quite fast in UI.
  merge(...valueChanges)
  .pipe(
      takeUntil(this.ngUnsubscribe),
      debounceTime(this.delay)
  )
  .subscribe(([prev, next]: [any, any]) =&gt; {
      this.onDataChange();
  });
  this.updateValidators();
  super.ngOnInit();
}
</code></pre>
<p>if I remove the merge and just watch for changes for formcontrolname of 'onValue', then it will execute onDataChange() only when there is difference in the value.</p>
<p>Is there any alternative that I can use for merging those 3 formcontrolname and watch for changes for any of the formcontrolname?</p>
","3355407","","3355407","","2020-09-28 08:01:09","2020-09-28 18:24:32","angular subscribe to changes only if previous value of the form control !== currentvalue of the formcontrol","<rxjs><observable><angular8><angular-pipe><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64108524","1","","","2020-09-28 19:34:49","","0","18","<p>For reasons unknown to me I'm not able to 'next' the BehaviorSubject. I don't know what I'm doing wrong, I'm doing it step by step with video tutorial, got almost everything like in that tutorial and it's still not working for me.</p>
<p><strong>chat-window.component.ts</strong></p>
<pre><code>import { Component, OnDestroy, OnInit,  } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Subscription } from 'rxjs';
import { ChatroomsService } from '../../services/chatrooms.service';

@Component({
  selector: 'app-chat-window',
  template: `
&lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-12&quot;&gt;
        &lt;app-room-title [room]=&quot;room&quot;&gt;&lt;/app-room-title&gt;
        &lt;app-message&gt;&lt;/app-message&gt;
        &lt;app-input&gt;&lt;/app-input&gt;
    &lt;/div&gt;
&lt;/div&gt;
`,
  styleUrls: ['./chat-window.component.css']
})
export class ChatWindowComponent implements OnInit, OnDestroy {
  subscriptions: Subscription[] = [];
  room: any;

  constructor(private chatroomsService: ChatroomsService, private acivatedRoute: ActivatedRoute) {
    this.subscriptions.push(
      this.chatroomsService.roomTaken.subscribe(chatroom =&gt; {
        this.room = chatroom;
      }));
  }
  ngOnInit(): void {
    this.subscriptions.push(
      this.acivatedRoute.paramMap.subscribe(parameters =&gt; {
        const chatroomId = parameters.get('roomID');
        this.chatroomsService.changeTheRoom.next(chatroomId);
      })
    );
  }

  ngOnDestroy() {
    this.subscriptions.forEach(subscription =&gt; {subscription.unsubscribe(); });
  }
}
</code></pre>
<p><strong>room-title.component.ts</strong></p>
<pre><code>import { Component, Input, OnInit } from '@angular/core';

@Component({
  selector: 'app-room-title',
  template: `&lt;p&gt;{{room.title}}&lt;/p&gt;`,
  styleUrls: ['./room-title.component.css']
})
export class RoomTitleComponent {
  @Input() room: any;
  constructor(){}
}
</code></pre>
<p><strong>chatrooms.service.ts</strong></p>
<pre><code>import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable, of } from 'rxjs';
import { AngularFirestore } from '@angular/fire/firestore';
import { switchMap } from 'rxjs/operators';


@Injectable({
  providedIn: 'root'
})
export class ChatroomsService {
  public changeTheRoom: BehaviorSubject&lt;string | null&gt; = new BehaviorSubject(null);
  public roomTaken: Observable&lt;any&gt;;

  constructor(private angularFirestore: AngularFirestore) {
    this.roomTaken = this.changeTheRoom.pipe(switchMap(roomID =&gt; {
      if (roomID) {
        return angularFirestore.doc(`chatRooms/${roomID}`).valueChanges();
      }
      return of(null);
    }));
  }
}
</code></pre>
<p>When I'm switching on a different route, the BehaviorSubject isn't being 'nexted', it remains null. That's why, when I try to display 'title' of room, I'm getting an error, that can't find property 'title' of null. I beg for help, I'm pulling my hair out~! Thanks in advance.
/Ernest</p>
","14294659","","","","","2020-09-28 20:01:13","BehaviorSubject isn't being 'nexted'","<angular><typescript><firebase><angularfire><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64122216","1","64122709","","2020-09-29 14:54:47","","1","45","<p>I have a service with a RXJS subject and i am assigning data to subject inside constructor doing an api call. This subject I am subscribing in a component template. Though the data is provided to the subject, it is not emitting immediately the first time.</p>
<pre><code>interface Employee {
employee_age: number;
employee_name: string;
employee_salary: number;
id: string;
profile_image: string;
}

@Injectable({
  providedIn: &quot;root&quot;,
})
export class EmployeeService {
 employeesSub = new Subject&lt;Employee[]&gt;();

 employees: Employee[];

 constructor(private http: HttpClient) {

this.api().subscribe((res) =&gt; {
  this.employees = res.data;
  this.employeesSub.next(this.employees);
});

}

 getEmployees(){
     this.employeesSub.next(this.employees);
 }

 addEmployee(name,age,salary) {
    this.employees.unshift({id:(this.employees.length + 
 1).toString(),employee_age:age,employee_name:name,employee_salary:salary,profile_image:&quot;&quot;});
   this.employeesSub.next(this.employees);
 }
 
 api() {
    return this.http
     .get&lt;any&gt;(environment.employeeUrl)
     .pipe(map((data) =&gt; data.items));
   }
  }

 Code in template

  &lt;h2&gt;List&lt;/h2&gt;
  &lt;div style=&quot;display: flex;&quot;&gt;&lt;/div&gt;
  &lt;table&gt;
     &lt;tr *ngFor=&quot;let item of employeeService.employeesSub|async&quot;&gt;
       &lt;td&gt;      {{ item.employee_name}}    &lt;/td&gt;
       &lt;td&gt;      {{ item.employee_age}}    &lt;/td&gt;
       &lt;td&gt;      {{ item.employee_salary}}    &lt;/td&gt;
     &lt;/tr&gt;
  &lt;/table&gt;
</code></pre>
<p>I am reassigning data by calling the getEmployees() function after 200ms and it is working. Any idea why this is happening.</p>
","9588631","","9588631","","2020-10-02 06:05:49","2020-10-02 06:05:49","Rxjs Subject not emitting data immediately","<angular><rxjs><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"64131524","1","","","2020-09-30 05:40:22","","0","60","<p>I am working on angular tour of heroes example. There is a feature to add a new hero to the existing list of heroes.
My add hero method in hero.service.ts is as below:</p>
<pre><code>addNewHero(hero : Hero) : Observable&lt;Hero&gt; {
    console.log(hero)
   return this._http.post&lt;Hero&gt;(this.url,hero).pipe(
    tap(res =&gt; this._service.addMessage(`new hero is ${hero.name} added`)),
    catchError(error =&gt; this.handleerror('adding a hero'))

   )
  }
</code></pre>
<p>addHero method in Heroescomponent class is as below :</p>
<pre><code>export class HeroesComponent implements OnInit {

  heroes : Observable&lt;Array&lt;Hero&gt;&gt;;
  selectedHero: Hero;

  constructor(private _service : HeroService,private _router : Router) { }

  ngOnInit() {
    this.heroes = this._service.getHeroes()
  }

  onSelect(hero: Hero): void {
    this.selectedHero = hero;
  }

  details(id : Number) {
    this._router.navigate(['heroes',id])
  }

  **addHero(name : String){
    console.log(name)
    this._service.addNewHero({ name } as Hero).subscribe((res : Hero) =&gt; {
      this.heroes = this._service.getHeroes()
     
    })
  }**
}
</code></pre>
<p>Heroes.HTML file is as below:</p>
<pre><code>&lt;h2&gt;My Heroes&lt;/h2&gt;
&lt;div&gt;
  &lt;input type=&quot;text&quot; #heroname&gt;
  &lt;button (click) = &quot;addHero(heroname.value)&quot;&gt;Add&lt;/button&gt;
&lt;/div&gt;
&lt;ul class=&quot;heroes&quot;&gt;
  &lt;li *ngFor=&quot;let hero of heroes | async&quot;&gt;
    &lt;a routerLink = &quot;/detail/{{hero.id}}&quot;
    style = &quot;text-decoration : none&quot;&gt;&lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}&lt;/a&gt; 
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>I am using the <code>heroes</code> variable with type <code>Observable&lt;Hero[]&gt;</code>.</p>
<p>so, whenever I am adding a new hero I want to add a newly added hero to the existing <code>heroes</code>. But, I am not able to do it as there is no push method for <code>observable of arrays</code>. So, I am calling <code>getHeroes</code> method again to refresh the list to display newly added items. Is there any workaround to add the item to the Data type <code>Observable&lt;Array&gt;</code> instead of hitting the server again</p>
","11922673","","2387977","","2020-10-01 12:08:38","2020-10-01 12:08:38","How to add New Item onto Observable of type Array?","<arrays><angular><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64161538","1","64162280","","2020-10-01 18:48:59","","2","497","<p>I have some cards displayed in the UI.</p>
<pre><code>&lt;div *ngFor=&quot;let item of cards | async&quot;&gt;...&lt;/div&gt;
</code></pre>
<p>Obviosuly cards will be the Observable of array of type card.</p>
<p>So I have an interface of card lets say it has 3 properties</p>
<p>Id, name, description.</p>
<p>My use case is.</p>
<ol>
<li><p>I want to add new card to the observables array and must reflect to array.</p>
</li>
<li><p>I want to delete the card from the observable and must reflect to the template.</p>
</li>
<li><p>I must be able to filter the card baaed on lets say name and must be reflected in the template.</p>
</li>
</ol>
<p>In short all the aperations must be done in the observable as I have used async pipe in the template.</p>
","7413086","","","","","2020-10-01 19:48:27","Update Rxjs observable of array by adding ,filtering or deleting items","<angular><observable><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"64166422","1","64166620","","2020-10-02 05:08:17","","0","27","<p>I have a BehaviourSubject with an array of employee data. When I want to add a new employee to the array, I want to take old data, insert new records into it, and reemit that into the behaviour subject. I am not able to get a clue on how to do that.</p>
<pre><code>export class EmployeeService {


employeesSub = new BehaviorSubject&lt;Employee[]&gt;([]);

  constructor(private http: HttpClient) {
    this.api().subscribe((res) =&gt; {
      this.employeesSub.next(res.data);
    });

  }

  addEmployee(name,age,salary) {
    this.employeesSub.pipe(
      map((res:Employee[])=&gt;{
       res.unshift({id:(res.length + 1).toString(),employee_age:age,employee_name:name,employee_salary:salary,profile_image:&quot;&quot;});
       return res;
      })
    ).subscribe(emp=&gt;{
      // this.employeesSub.next(emp);
    })
  }

  api() {
    return this.http
      .get&lt;any&gt;(&quot;http://dummy.restapiexample.com/api/v1/employees&quot;)
      .pipe(map((data) =&gt; data.items));
  }
}
</code></pre>
<p>I am trying something similar to add employee method but able to fix it.</p>
<p>The same code can also be found at StackBlitz</p>
<p><a href=""https://stackblitz.com/edit/angular-buwj6n"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-buwj6n</a></p>
","9588631","","9588631","","2020-10-02 05:39:36","2020-10-02 05:51:43","How to read data from BehaviourSubject and emit new data into it","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"64168500","1","","","2020-10-02 08:35:41","","1","143","<p>For example this is the json which I am receiving,</p>
<pre><code>{
    &quot;events&quot;: [...
    ],
    &quot;total&quot;: 12341,
    &quot;students&quot;: [
        {
            &quot;id&quot;: 1,
            &quot;first_name&quot;: &quot;John&quot;,
            &quot;last_name&quot;: &quot;Apple&quot;
        },
        {
            &quot;id&quot;: 2,
            &quot;first_name&quot;: &quot;Bob&quot;,
            &quot;last_name&quot;: &quot;Banana&quot;
        },
        {
            &quot;id&quot;: 3,
            &quot;first_name&quot;: &quot;Charles&quot;,
            &quot;last_name&quot;: &quot;Carrot&quot;
        }
    ]
}
</code></pre>
<p>And I want to transform the data to the following form, and return it as an observable</p>
<pre><code>[
    {
        &quot;first_name&quot;: &quot;John&quot;,
        &quot;last_name&quot;: &quot;Apple&quot;
    },
    {
        &quot;first_name&quot;: &quot;Bob&quot;,
        &quot;last_name&quot;: &quot;Banana&quot;
    },
    {
        &quot;first_name&quot;: &quot;Charles&quot;,
        &quot;last_name&quot;: &quot;Carrot&quot;
    }
]
</code></pre>
<p>I have tried the following, but it returns undefined.</p>
<pre><code>getStudentsName(): Observable&lt;any&gt; {
    const requestUrl = this.rootURL + `students/`;
    let studentsInfo = this.http.get&lt;any&gt;(requestUrl).pipe(map(o =&gt; o.students));
    return studentsInfo.pipe(map(students =&gt; {students.first_name, students.last_name}));
  }
</code></pre>
<p>returns undefined when subscribing to observable</p>
<pre><code>this.getStudentsInfoService.getStudentsName()
      .subscribe((result) =&gt; console.log('here', result));
</code></pre>
","10572540","","10572540","","2020-10-02 08:41:57","2020-10-02 11:14:40","How to extract only certain properties of json, returning as an observable using rxjs","<json><angular><typescript><rxjs><rxjs-observables>","4","0","","","","CC BY-SA 4.0"
"64183113","1","64183601","","2020-10-03 10:17:09","","0","31","<p>I want to write a collapsible component which has an &quot;Expand&quot; button that opens a list of items. This list is created through a web request, and I'm wondering when this request happens - since to my understanding the <code>async</code> pipe is like a subscription and the <code>ngIf</code> would cause the component subscribing to be recreated, I would expect the value of the request to only be available once, however it is created each time I 'show' the expander.</p>
<p><a href=""https://stackblitz.com/edit/angular-ivy-766npv?devtoolsheight=33&amp;file=src/app/app.component.ts"" rel=""nofollow noreferrer"">StackBlitz minimal example</a></p>
<p>Inside my <code>AppComponent</code> I have this logic:</p>
<pre class=""lang-js prettyprint-override""><code>  data$ = of('expensive data from server').pipe(
    take(1),
    tap(() =&gt; console.log('data from server emit!')),
    // shareReplay(1),
    finalize(() =&gt; console.log('complete!'))
  );
  showSon = true;
</code></pre>
<p>The template is like this:</p>
<pre class=""lang-js prettyprint-override""><code>&lt;button (click)=&quot;showSon=!showSon&quot;&gt;Click me!&lt;/button&gt;
&lt;p *ngIf=&quot;showSon&quot;&gt;
  &lt;ng-container *ngIf=&quot;data$ | async as data&quot;&gt;
    &lt;div&gt;{{data}}&lt;/div&gt;
  &lt;/ng-container&gt;
&lt;/p&gt;
</code></pre>
<p>My understanding is that since the observable is created via <code>of</code>, that it should fire its value once and then complete, confirmed by the console logs. However I'm surprised that every time I show the element inside the <code>ngIf</code>, I still get a value even though <code>async</code> is now subscribing to a completed observable that is not a <code>ReplaySubject</code>.</p>
<p>I think using <code>shareReplay(1)</code> would solve the issue of making multiple web requests, <strong>but I still don't understand how the single-use observable is repeatedly available whenever the template inside the <code>ngIf</code> is recreated.</strong></p>
","6338059","","","","","2020-10-03 11:16:39","async pipe inside ngIf still gets value","<angular><rxjs><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"64208725","1","","","2020-10-05 12:35:23","","0","38","<p>I need to subscribe &amp; do some actions, when mouseover on particular elements in the DOM.</p>
<p>For Example: home.component.html</p>
<pre><code>        &lt;div class=&quot;container&quot;&gt;
              &lt;div class=&quot;row1&quot;&gt; &lt;/div&gt;
              &lt;div class=&quot;row2&quot;&gt; &lt;/div&gt;
              &lt;div class=&quot;row3&quot;&gt; &lt;/div&gt;
        &lt;/div&gt;
</code></pre>
<p>home.component.ts:</p>
<pre><code>         import {
                 AfterViewInit,
                 Component,
                 Input,
                 OnInit,
                } from '@angular/core';

                @Component({
                             selector: 'app-home',
                             templateUrl: './home.component.html',
                             styleUrls: ['./home.component.scss'],
                           })
          export class homeComponent implements OnInit {
          
               public hover: boolean;

               constructor() {}

               ngOnInit(): void {
                     this.hover= true;       // it may be false also.
               }

          }
</code></pre>
<p>In the above example when mouseover on row1 &amp; row3 elements then I need to subscribe. Also I need to check one variable called &quot;hover&quot;, if it is true then only I need todo the above action(mouseover). If the variable is false then no need to check for mouseover(no need to do any action), just I need to unsubscribe it. Can any one help me to achieve this.</p>
","7148829","","","","","2020-10-05 14:15:26","subscribing when mouseover on particular element in the DOM","<javascript><angular><rxjs5><rxjs6><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"64211346","1","64230453","","2020-10-05 15:10:26","","0","202","<p>Clicking on second tab in a tab bar shows this error:</p>
<pre><code>core.js:6241 ERROR Error: Uncaught (in promise): TypeError: this.networkService.getRequest(...).pipe is not a function
TypeError: this.networkService.getRequest(...).pipe is not a function
at PaymentService.getPaymentList (payment.service.ts:359)
at PaymentComponent.loadDataPaymentState (payment.component.ts:188)
at PaymentComponent.ngAfterViewInit (payment.component.ts:130)
</code></pre>
<p>Two pages in these tabs are using PaymentComponent. Everything works in the tab which is first open. Clicking on second tab causes error.</p>
<p>The code on which error occurs is :</p>
<pre><code>getpaymentList() {
let list = this.buildListURL();
return this.networkService.getRequest(list).pipe(
  tap(
    (data) =&gt; {
      console.log(data);
   
      this.lastbill= data[&quot;bill&quot;];
    },
    (error) =&gt; {
      console.log(&quot; error&quot;);
      console.log(error);
    }
  )
);
</code></pre>
<p>}</p>
<p>The code of getRequest:</p>
<pre><code>getRequest(path, customHeader?) {
let options = this.createOptions();
if (customHeader) {
  options.headers = this.jsonConcat(options.headers, customHeader);
}

if (!this.isOnline) {
  this.errorOccurred(null);
}
let cachedData = this.cacheService.getCachedNode(path);
if (cachedData) {
  return cachedData;
} else {
  return this.http
    .get(
      path,
      options
    )
    .pipe(
      map(
        (data) =&gt; {
          console.log(&quot;data&quot;);
          return data;
        },
        (error) =&gt; {
          console.log(&quot;error&quot;);
          console.log(error);
          this.errorOccurred(error);
        }
      )
    );
}
</code></pre>
<p>}</p>
<p>I am not able to figure out what is the issue. If anyone have an idea about it then please let me know. Thanks</p>
","14242154","","14242154","","2020-10-06 17:47:27","2020-10-06 17:47:27","TypeError: this.networkService.getRequest(...).pipe is not a function in ionic Angular","<angular><ionic-framework><rxjs><ionic4><rxjs-observables>","1","5","","","","CC BY-SA 4.0"
"64220714","1","","","2020-10-06 06:52:46","","0","357","<p>Angular 8 provides us rxjs library , we can use subject from that library to set data that can be used gloabally in our application by declaring it in service file and this same we can do is by declaring just a variable in service file and using it globally in our application . Is there any benefits using subject over a variable in this case?</p>
","7923196","","","","","2020-10-06 07:44:56","Difference between using a variable and using a subject in angular service to create the global variable which can be used throughout the application?","<angular><rxjs-observables><subject-observer>","1","0","","","","CC BY-SA 4.0"
"64222794","1","64236385","","2020-10-06 09:16:44","","0","60","<p>I have a problem, I got an HTML element that acts like a loding spinner, and I would like it not to be displayed. I would to use the observables to be able to load that element only once the data is fully loaded. So far, in my component, i made it like that :</p>
<pre><code>const matchTableList$ = this.matchTablesService.list().pipe(
            map(matchTables =&gt; {
                matchTables = matchTables.sort((a, b) =&gt; a.name.toLocaleLowerCase() === b.name.toLocaleLowerCase() ? 0 : a.name.toLocaleLowerCase() &lt; b.name.toLocaleLowerCase() ? -1 : 1);
                this.matchTables$.next(matchTables);
            }),
            catchError( (error: HttpErrorResponse) =&gt; {
                this.loadingError$.next(true);
                return EMPTY;
            }),
            finalize(() =&gt; {
                this.prettyMessageData = new PrettyMessageContent();
                this.prettyMessageData.title = &quot;hello&quot;
                this.prettyMessageData.message = &quot; &quot;;
              this.prettyMessageData.withMessage(this.prettyMessageData.message);
            })
        );
</code></pre>
<p>and in my HTML i made :</p>
<pre><code>&lt;div *ngIf=&quot;!matchTablesLine&quot; class=&quot;justify-content-center&quot;&gt;
    &lt;pretty-message style=&quot;width: 100%;&quot; [data]=&quot;prettyMessageData&quot;&gt;
    &lt;/pretty-message&gt;
    &lt;div class=&quot;d-flex justify-content-center mt-5&quot;&gt;
        &lt;button class=&quot;btn--primary&quot; (click)=&quot;createMatchTable()&quot;&gt;&lt;i class=&quot;add-circle-line&quot;&gt;&lt;/i&gt;add&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>So the problem here is that, when there is no data, the pretty message is not displayed, and when there is data, the html div is loaded before i got the data, so it's weird to see a button while the page load. I think it is possible to use observables and operators here, but i really don't know which one to use to make this work. Thanks.</p>
<p>Edit : I solved the problem using a simple resolver, which is really helpful in that kind of cases.</p>
","12138602","","12138602","","2020-10-08 13:24:01","2020-10-08 13:24:01","Angular - Image appears while loading","<javascript><angular><typescript><rxjs><rxjs-observables>","1","7","","","","CC BY-SA 4.0"
"64225268","1","64226851","","2020-10-06 11:53:11","","3","75","<p>I am investigating an issue which appears to be coming from the fact that the &quot;unsubscribe&quot; method of the &quot;Subscription&quot; class does not appear to be disposing of the resources quickly enough which creates a memory leak.</p>
<p>Here is my scenario:</p>
<p><a href=""https://i.stack.imgur.com/jpmaa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jpmaa.png"" alt=""enter image description here"" /></a></p>
<p>I have 2 components - <strong>LandingPageComponent</strong> (LPC) and <strong>WebPlayerComponent</strong> (WPC). The LPC is the first page that the user sees when they access the site. On that page, they have a link which takes them to the second page or WPC (passing an argument, e.g. &quot;<em>Operator Benchmarking</em>&quot;) The user goes back to the previous page by clicking the browser's back button. That triggers the WPC's <strong>ngOnDestroy</strong> method which disposes of subscribtions (see code below).</p>
<p>WebPlayerComponent</p>
<pre><code>export class WebPlayerComponent implements OnInit, OnDestroy {
    @Input() workbookId: string;
    @Input() workbookPage: string | number;

    private _workbooks: Workbook[];
    private _filters: Filter[];

    private _subscriptions: { [key: string]: Subscription } = {};
    
    ngOnInit() {
        this._subscriptions[&quot;combined&quot;] = combineLatest(
            this.workbookService.workbooks$,
            this.filterService.filters$,
            this.libraryService.userFolderInitialised$
        ).subscribe(([workbooks, filters, userFolderInitialised]) =&gt; {
            this._workbooks = workbooks;
            this._filters = filters;

            this._subscriptions[&quot;webPlayerServiceSubscription&quot;] = this.webPlayerService.openWorkbook(workbook.libraryPath, parameterString).subscribe(
                    (webPlayer) =&gt; {
                        console.log(&quot;_subscriptions before 'openWorkbook call'&quot;);
                        Object.keys(this._subscriptions).map((key) =&gt; {
                        console.log(key);
                        });

                        console.log(&quot;Openning document page: &quot; + this.workbookPage);
                        webPlayer.openDocument(&quot;spotfire-container&quot;, this.workbookPage);
                    });
        });

    }
    
    ngOnDestroy() {
        Object.keys(this._subscriptions).map((key) =&gt; {
            this._subscriptions[key].unsubscribe();
            console.log(&quot;---Unsubscribed &quot; + key + &quot;---&quot;);
        });
    }
}
</code></pre>
<p>The problem starts occuring if the user clicks the browser's Back button and clicks on the &quot;Link&quot; quickly enough (in my example that's anything less that 5seconds). The subscribtions that are supposed to be disposed are not and are still active. I am able to confirm that by looking at the console's output:</p>
<p><a href=""https://i.stack.imgur.com/fWJ5k.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fWJ5k.png"" alt=""enter image description here"" /></a></p>
<p>In the above image you can see that after clickon on the &quot;Link&quot; again from the <strong>LandingPageComponent</strong> we see 2 sets of calls (the green numbers (1) &amp; (2)), we also see the <em>&quot;Opening document page:&quot;</em> 3 times</p>
<p>This is how the output should look like if I wait 5 seconds before I click the link again</p>
<p><a href=""https://i.stack.imgur.com/yYsCE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yYsCE.png"" alt=""enter image description here"" /></a></p>
<p>I am not sure why my subscription resources are not being disposed of fast enough (at least that is what I think the problem here is).</p>
<p>Note: I am using <strong>RxJS 6.4.0</strong> and <strong>Angular 8.1.3</strong></p>
","3398554","","472495","","2020-11-24 23:03:25","2020-11-24 23:03:25","RxJS ""unsubsribe"" method in ngOnDestroy does not disposes resources quickly enough","<angular><rxjs><rxjs6><rxjs-observables>","1","4","","","","CC BY-SA 4.0"
"64245814","1","64245983","","2020-10-07 14:06:35","","1","1537","<p>I know there is a ton of questions like this, but none of the solutions solve my problem.
IVe been stuck on this for a while, and would really appreciate some help/guidance.
I suppose there is something big I am missing in the ideas of observable, cloud firestore, etc...</p>
<p><strong>Primary Issue:</strong> How can I get a single document field from cloud firestore db as a string?
I attempted two different approaches and niether gave me the results i need:</p>
<pre><code>getUsername(uid : string) {
    const user = this.afs.firestore.doc(`users/${uid}`)
    return user.get().then((doc) =&gt; {
        return (doc.exists ? doc.data().username : null);})

} //this one returns a promise and i need a string
</code></pre>
<pre><code>getUsername(uid : string) {
    let answer;
    this.get(uid).valueChanges().subscribe((doc) =&gt; answer = doc.username) //intellisense reccomended username as m attribute which was hopeful
    return answer;
} //this returns undefined    
 
</code></pre>
<p><strong>Quick aside</strong>- ive seen people use the rxjs map operator to access the fields in an object, like</p>
<p><code>getUsername() return userDoc.pipe(map(user =&gt; user.username))</code></p>
<p>I tried this one too, and it did not work. I also checked the rxjs documentation and it said the intended use of map was for applying an operation to observable stream. Can it be used like how shown above? ( and if so, what am i doing wrong? )</p>
<p><strong>Details/background:</strong>
I am using Google Firebase for both authentication and Firestore cloud db. The problem arises because users create a user account through my application (creating a new user document in the users collection), but on the backend, i use firebase createUserWithEmailAndPassword method- so there is two seperate instances of user data- google record and my application. To resolve this, I use the firebase.user.uid as the uid for the user document, and sync googles data with my application db during runtime, so that if a user changes their gmail address, their user document has the most up to date email address. The problem here is that I have a seperate collection &quot;profiles&quot; that stores the user public profile and preference data, where username is used as the uid, and also is used as query parameter in the url like</p>
<p><code>localhost/4200/profiles/username</code></p>
<p>so for here, the username has to be one word without spaces. I validate for this in the create-account form, but there is a separate issue now- google username can contain spaces. So when I sync the google account with my user document, i have to use two data sources.</p>
<pre><code>userDoc.set({
username : from user document
email : from firebase.User.email
uid : Firebase.User.uid
})
</code></pre>
<p>and so, a few questions arise from this.</p>
<ol>
<li>how do i get a single firestore document field <strong>as a string</strong> rather than an promise, observable, [object object] etc..?</li>
<li>should i go back to the drawing board with this whole situation- (</li>
</ol>
<p>ie</p>
<ul>
<li>redesign my db so that profile is a subcollection of user</li>
<li>find a way to navigate to profile page without using username as a route parameter</li>
<li>think of a better plan for authentication, so that there isnt a seperate db table that needs to get        synced to googles auth data whenever the user logs in</li>
</ul>
<p>Any help or suggestion(s) are greatly appreciated</p>
","13063790","","","","","2020-10-07 14:26:32","Angular firestore get document field as string","<angular><typescript><firebase><google-cloud-firestore><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"64249896","1","64250035","","2020-10-07 18:08:07","","0","78","<p>I am working on an Angular application implementing an AuthGuard class to avoid that a not logged user can access to a protected page. Following an online course I have done:</p>
<pre><code>import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';

import { AuthService } from './auth.service';
import 'rxjs/Rx';
import 'rxjs/add/operator/map'
import { Observable } from 'rxjs';

export class AuthGuard implements CanActivate {

  constructor(private authService: AuthService,
              private router:Router) {}

  canActivate(route: ActivatedRouteSnapshot,
                     state: RouterStateSnapshot): Observable&lt;boolean&gt;  {

    return this.authService.authInfo$
                           .map(authInfo =&gt; authInfo.isLoggedIn())
                           .take(1)
                           .do(allowed =&gt; {
                             if(!allowed) {
                               this.router.navigate(['/login']);

                             }
                           })
  }

}
</code></pre>
<p>And into my <strong>AuthService</strong> class I simply defined this property:</p>
<pre><code>authInfo$:Observable&lt;boolean&gt;;
</code></pre>
<p>The problem is that into my <strong>AuthGuard</strong> class the IDE give me the following error on this line:</p>
<pre><code>.map(authInfo =&gt; authInfo.isLoggedIn())
</code></pre>
<p>the error is:</p>
<blockquote>
<p>Property 'map' does not exist on type 'Observable'.ts(2339)</p>
</blockquote>
<p>And I can't understand why because, as you can see in my code, I have importend the <strong>import 'rxjs/add/operator/map'</strong> operator.</p>
<p>What is wrong? What am I missing? How can I fix this issue?</p>
","1833945","","","","","2020-10-07 19:06:09","Why I obtain this error? Property 'map' does not exist on type 'Observable<boolean>'","<angular><typescript><rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"64253226","1","64253824","","2020-10-07 22:32:02","","0","270","<p>I have a ngrx store selector:</p>
<pre><code>export const selectActivePracticeUsersListSnapshot = pipe(
  select(selectPracticeUsersList),
  filter((users) =&gt; !!users),
  take(1),
  map((users) =&gt; users.filter((user) =&gt; user.active))
);
</code></pre>
<p>I have a service that is injected into multiple components that contains the following method:</p>
<pre><code>public getTeamMembersWithAccess(permission: string): string[] {
  let flagAvatars: string[];
  this.store.dispatch(loadUsers());
  this.store.pipe(selectActivePracticeUsersListSnapshot).subscribe((activePracticeUsers) =&gt; {
    flagAvatars = activePracticeUsers.reduce((teamMembers, activeUser) =&gt; {
      if (!!activeUser.permissions[permission]) {
        const { firstName, lastName } = activeUser;
        return [...teamMembers, `${firstName} ${lastName}`];
      }
      return teamMembers;
    }, []);
  });
  return flagAvatars;
}
</code></pre>
<p>I call this from my component thusly:</p>
<pre><code>constructor(private helperService: HelperService) {
  const flagAvatars = this.helperService.getTeamMembersWithAccess('AdminPage');
}
</code></pre>
<p>My problem is that the service method returns undefined because of the <em>let flagAvatars: string[];</em> before the subscription to the store selector returns as it is waiting for the dispatch of <em>loadUsers()</em> to complete. I know I need to change the <em>getTeamMembersWithAccess()</em> method to return an <em>Observable&lt;string[]&gt;</em> somehow, but I'm not sure how to write this. I've tried multiple things but can't get it right. Pretty sure I need to use a map instead of a subscribe, but just can't figure out how to write that.</p>
","2116356","","","","","2020-10-07 23:48:33","Return Observable from ngrx store pipe selector","<angular><ngrx-store><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64287018","1","","","2020-10-09 20:39:46","","0","75","<p>I have an array of observables (HTTP POST requests) that I need to send off to an API after a specific event. The following is a simplified example of the approach, where I use <code>concat</code> so I can leverage success, error and complete callbacks.</p>
<pre><code>// build up an array of stored POST requests to fire off later
// array is indeterminate length, could be 1 request could be 1,000
let requests = [ req1, req2, req3, req4 ];

concat(...requests).subscribe(
  success =&gt; ... handle success ...
  error =&gt; ... handle error ...
  () =&gt; ... handle completion ...
);
</code></pre>
<p>The issue is the concat basically sends all the requests at once, raising the potential for concurrency issues in the API consuming the requests. This issue should be resolved if I am able to fire the requests off one-by-one rather than all at once. I've determined that a <code>forEach</code> loop is not an option.</p>
<p>Is there an RxJS approach such that <code>req2</code> only emits after <code>req1</code> completes and <code>req3</code> emits only after <code>req2</code> completes and so on? I've been reviewing the RxJS docs but have yet to find anything that fits this scenario.</p>
","4184075","","","","","2020-10-09 22:08:11","RxJS array of HTTP observables: fire next only after previous completes","<angular><rxjs><rxjs6><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"64304367","1","64304661","","2020-10-11 13:10:18","","0","87","<p>Api response (json) -</p>
<pre><code>{
    &quot;count&quot;: 1050,
    &quot;next&quot;: &quot;....&quot;,
    &quot;previous&quot;: null,
    &quot;results&quot;: [
        {
            &quot;name&quot;: &quot;Test1&quot;,
            &quot;url&quot;: &quot;https://test/1/&quot;
        },
        {
            &quot;name&quot;: &quot;Test2&quot;,
            &quot;url&quot;: &quot;https://test/2/&quot;
        }
     ]
}
</code></pre>
<p>Interface:</p>
<pre><code>export interface ITestModel{
  name: string;
  url: string;
}
</code></pre>
<p>Service:</p>
<pre><code>getData(): Observable&lt;ITestModel[]&gt; {
    return this.http.get&lt;ITestModel[]&gt;(this.apiUrl).pipe(
      map((res) =&gt;
        res.map((data) =&gt; ({
          name: data.name,
          url: data.url
        }))
      )
    );
  }
</code></pre>
<p>Error: (When I subscribe the above function in controller)</p>
<p><strong>core.js:4352 ERROR TypeError: res.map is not a function at MapSubscriber.project (test.service.ts:19)</strong></p>
<p>Expectation:</p>
<ol>
<li>In getData() function, I would like to transform observable as <strong>ITestModel[]</strong></li>
<li>Expected output while subscribe (Json)</li>
</ol>
<p>[
{
&quot;name&quot;: &quot;Test1&quot;,
&quot;url&quot;: &quot;https://test/1/&quot;
},
{
&quot;name&quot;: &quot;Test2&quot;,
&quot;url&quot;: &quot;https://test/2/&quot;
}
]</p>
<p>Thank you !</p>
","1131575","","","","","2020-10-11 14:53:22","Try to transform object (type casting) using map operator in angular","<angular><typescript><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64316316","1","64316594","","2020-10-12 10:45:59","","0","39","<p>I have an observable that I want to modify.</p>
<pre><code>private userProposalConversatorAfterLogin = new BehaviorSubject&lt;any&gt;([]);
    getUserProposalConversatorAfterLogin$ = this.userProposalConversatorAfterLogin.asObservable();
    currentUserProposalConversatorAfterLoginValue():ParcelModel[] {
      return this.userProposalConversatorAfterLogin.value;
    }
    setUserProposalConversatorAfterLogin(x) {
      this.userProposalConversatorAfterLogin.next(x);
    }
</code></pre>
<p>and here is the result with the subscription<code>(this.getUserProposalConversatorAfterLogin$.suscribe(proposal))</code></p>
<pre><code>{
id:1,
messages:[{id:'1', comments:'hello'}, {id=2, comments:'aaa'}, .....]
}
</code></pre>
<p>I want to add a new message to the messages array for exemple: {id=3, comments:'oooo'} and
and when i go to subscribe again i want to get:</p>
<pre><code>  {
    id:1,
    messages:[{id:'1', comments:'hello'}, {id=2, comments:'aaa'},  {id=3, comments:'oooo'} .....]
    }
</code></pre>
<p>i tried many way but no success</p>
<pre><code>getUserProposalConversatorAfterLogin$.pipe(
    switchMap(x =&gt; {
      const new_array = (x.filter(x =&gt; x['id'] === proposal_identifiant))
      console.log(new_array);
      if (new_array &amp;&amp; new_array.length &gt;=1) {
        new_array[0]['message_proposal_identifiant'].push(new_message);
        console.log(new_array[0]['message_proposal_identifiant']);
        
      }
      return new_array

      }),
    share(),
    distinctUntilChanged(),
  )
</code></pre>
<p>when i subscribe again i don't see the new value. I think we need to modify userProposalConversatorAfterLogin but how?</p>
<p>I tried with <code>this.userProposalConversatorAfterLogin.next(val)</code> but it adds just a new object
Thank you in advance</p>
","9714967","","","","","2020-10-12 11:16:54","how to update a nested observable ain angular 9?","<angular><observable><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"64320171","1","64321534","","2020-10-12 14:52:19","","0","171","<p>I have two Observables, one depends on data from the other.</p>
<p>When the data on the first Observable is changed it should update the second Observable.</p>
<p>Unfortunately, this is not working as I expect.</p>
<p>Here is the primary Observable (which works fine)</p>
<pre class=""lang-js prettyprint-override""><code>export class LocaleService {
  locale$: Observable&lt;string&gt;;

  constructor(private router: Router) {
    this.locale$ = router.events.pipe(
      filter(evnt =&gt; envt instanceof ActivationEnd),
      map((evnt: ActivationEnd) =&gt; evnt.snapshot.paramMap.get('locale')),
      shareReplay(1),
    );
  }
}
</code></pre>
<p>Here is the second Observable, which should update based on the value of the first Observable (seen above):</p>
<pre class=""lang-js prettyprint-override""><code>// This type is more complex, but made it simple for demonstrating the problem
interface ICountries { code: string; }

export class DataService {
  countries$: Observable&lt;ICountries&gt;;

  constructor(private http: HttpClient, private localService: LocaleService) {
    this.localeService.locale$.subscribe(locale =&gt; {
      // this is only here for debug purposes, showing it does change
      console.log('changed locale', locale);
    });

    this.countries$ = localeService.locale$.pipe(
      tap(locale =&gt; { console.log('http updated', locale); }), // called first time only, not on locale changes...
      switchMap(locale =&gt; this.http.get&lt;ICountries&gt;(`http://localhost:8080/countries?lang=${locale}`)),
      shareReplay(1),
    );
  }
}
</code></pre>
<p>and if it matters, the way I am consuming the <code>countries$</code> is as follows (again, simplified to demonstrate the problem) :</p>
<pre class=""lang-js prettyprint-override""><code>@Component({
  template: `&lt;ng-container *ngIf=&quot;countries$ | async as countries&quot;&gt;{{ countries.code }}&lt;/ng-container&gt;`,
})
export class CountryComponent implements OnInit {
  countries$: Observable&lt;ICountries&gt;;

  constructor(private dataService: DataService) {
    this.countries$ = dataService.countries$;
  }
}
</code></pre>
<p>I have been struggling with this for a few days now, looked for answers on StackOverflow, numerous other forums and asking friends who use Observables more frequently, but I cannot seem to solve this. Any help would be greatly appreciated!</p>
","221456","","221456","","2020-10-12 17:32:48","2020-10-12 17:32:48","Observable pipe not called when source Observable is updated","<angular><rxjs><angular2-observables><rxjs-observables>","1","8","","","","CC BY-SA 4.0"
"64330519","1","64338513","","2020-10-13 07:28:35","","0","85","<p>I need the help in the following vue-rx / RxJs question.</p>
<p>I have to make a subscription in vue-rx that watches a props value, and when it is true then it calls a http request in every 500 ms, and stops it when it is false, or when the returned value is 'COMPLETED'.</p>
<p>I tried something like this:</p>
<pre><code>export default {
  props: ['started'],
  subscriptions() {
   return {
    currentHttpState: this.$watchAsObservable('started')
                      .pipe(pluck('newValue'),filter(value =&gt; value === false))
                      .switchMap(() =&gt; interval(500).pipe(switchMap(() =&gt; this.callHttpRequest()),distinctUntilChanged())),
</code></pre>
<p>Thank you for the help!</p>
","10659616","","","","","2020-10-13 20:25:40","VUE with vue-rx / rxjs : How to create a subscription with $watchAsObservable using filter and interval","<rxjs><rxjs-observables><vue-rx>","1","0","","","","CC BY-SA 4.0"
"64350768","1","64351603","","2020-10-14 09:52:52","","6","2128","<p>I have some javascript:</p>
<pre><code>this.mySubscription = someObservable.subscribe((obs: any) =&gt; {
   this.mySubscription.unsubscribe();
   this.mySubscription = undefined;
}
</code></pre>
<p>on execution, the console logs the error <code>ERROR TypeError: Cannot read property 'unsubscribe' of undefined</code>.
I wonder why I can not unsubscribe inside the subscribe lambda function. Is there a correct way to do so? I have read a bit about using dummy-subjects and completing them or using takeUntil/takeWhile and other pipe operators workArounds.</p>
<p>What is a correct way/workaround to unsubscribe a subscription inside the subscription's subscribe-function?</p>
<p>I am currently using a dummy subscription like so:</p>
<pre><code>mySubscription: BehaviorSubject&lt;any&gt; = new BehaviorSubject&lt;any&gt;(undefined);


// when I do the subscription:
dummySubscription: BehaviorSubject&lt;any&gt; = new BehaviourSubject&lt;any&gt;(this.mySubscription.getValue());
this.mySubscription = someObservable.subscribe((obs: any) =&gt; {
    // any work...
    dummySubscription.next(obs);
    dummySubscription.complete();
    dummySubscription = undefined;
}, error =&gt; {
    dummySubscription.error(error);
});

dummySubscription.subscribe((obs: any) =&gt; {
    // here the actual work to do when mySubscription  emits a value, before it should have been unsubscribed upon
}, err =&gt; {
    // if errors need be
});
</code></pre>
","2660921","","2660921","","2020-10-14 13:04:46","2020-10-18 19:52:18","how to unsubscribe a RXJS subscription inside the subscribe method?","<rxjs><rxjs-observables>","2","0","1","","","CC BY-SA 4.0"
"64380993","1","","","2020-10-15 23:33:39","","0","23","<p>I have an app that I need to check if the last viewed lesson was greater than 1. If it is I have to ask if the user wants to navigate to that lesson. I am doing it in a resolver so my page doesn't render until they answer the question. I can't seem to figure out how to return an observable with my xml from the service call. If they haven't started yet, it is on lesson one and it returns the xml just fine, the resolve works and they go to page one. However, when I try to return the http request inside of the dialogs.confirm, I don't get a proper resolve with the data. I've tried returning of() on the dialog, I've tried returning the data in the if then of the confirm, I've tried returning of(data) in the if/then. Nothing seems to give me the data on the resolve ActivatedRouteSnapshot. Can anyone help me?</p>
<pre><code>if(+route.params['lesson'] === 1) {
            this.playerService.setLessonNum(1);
            this.lessonnum = 1;
            this.playerService.setLessonNum(+route.params['lesson']);
            return this.httpService.getPlayerData({&quot;userId&quot;: this.user.username, &quot;corporateId&quot;: 1, &quot;classId&quot;: this.itemid, &quot;type&quot;: &quot;I&quot;, &quot;AuthToken&quot;: this.user.AuthToken, &quot;lesson&quot;: this.lessonnum, &quot;class_ID&quot;: this.class_ID, &quot;version&quot;: this.version})
            .pipe(
                catchError((err: string) =&gt; {
                    const errMsg = &quot;There was a network error, please check your connection or try again later&quot;;
                    return of(errMsg)
                })
            );
        } else {
            return of(from(dialogs.confirm({
                title: &quot;Bookmark&quot;,
                message: &quot;Would you like to return to your bookmark?&quot;,
                okButtonText: &quot;OK&quot;,
                cancelButtonText: &quot;No&quot;,
                // neutralButtonText: &quot;Neutral text&quot;
            }).then(result =&gt; {
                // result argument is boolean
                console.log(&quot;Then result from dialog&quot;, result);
                this.goToBookmark = result;
                if(this.goToBookmark){
                    console.log(&quot;calling player 2 service in resolver&quot;, route.params['lesson']);
                    // return this.callService(route.params['lesson']);
                    this.playerService.setLessonNum(+route.params['lesson']);
                    this.lessonnum = +route.params['lesson'] 
                } else {
                    this.playerService.setLessonNum(1);
                    this.lessonnum = 1;
                }
                this.playerService.setLessonNum(this.lessonnum);
                this.httpService.getPlayerData({&quot;userId&quot;: this.user.username, &quot;corporateId&quot;: 1, &quot;classId&quot;: this.itemid, &quot;type&quot;: &quot;I&quot;, &quot;AuthToken&quot;: this.user.AuthToken, &quot;lesson&quot;: this.lessonnum, &quot;class_ID&quot;: this.class_ID, &quot;version&quot;: this.version})
                .pipe(    
                    map((data) =&gt; {this.xml = data}),
                    catchError((err: string) =&gt; {
                    const errMsg = &quot;There was a network error, please check your connection or try again later&quot;;
                    return of(errMsg)
                    }));
                    return this.xml;
                })))}
</code></pre>
","568352","","","","","2020-10-15 23:33:39","Return observable from dialogs.confirm","<rxjs><nativescript><rxjs-observables>","0","0","","","","CC BY-SA 4.0"
"64396129","1","","","2020-10-16 20:40:39","","1","268","<p>I am having issues with a front-end component not rendering updates to a <code>BehaviorSubject</code> and I'm hoping someone can point out where my error is coming from. I have read many other questions about BehaviorSubject issues, but so far I cant get a solution. I'm using Angular 8 with Ionic 4.</p>
<p><strong>Here is the front end experince</strong>: When I navigate to the component the <strong>first time</strong>, it will not show any <code>projectDetails</code>.
Navigating to the componenet the <strong>second time</strong>, it shows me the <code>projectDetails</code> that should have been displayed the first time.
This 'lag' <strong>persists for subsequent</strong> navigations</p>
<p>I understand that this must mean my call to <code>.next()</code> is not getting reflected in the component until it is re-initialized.</p>
<p>I know that <code>this.s.getProject(this.projectId);</code> is working correctly when the component loads because the <code>console.log('service fetch complete&gt;&gt;&gt;&gt;&gt;&gt;',this.project.getValue()['name']);</code> from the service reports the appropriate 'project' per the current navigation. But I'm struggling to understand why this data is only propagating to the component the next time it is opened.</p>
<p>I'm starting to suspect that I am missing something on the layout side...</p>
<h3>The Service</h3>
<pre class=""lang-js prettyprint-override""><code>import { Injectable} from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, BehaviorSubject } from 'rxjs';


@Injectable({
  providedIn: 'root'
})

export class myService {

  private API_URL = 'http://xxx.xxxxx.com/endpoint/';

  private project: BehaviorSubject&lt;any&gt; = new BehaviorSubject({});
  public readonly projectObservable: Observable&lt;Object&gt; = this.project.asObservable();

  constructor(private http:HttpClient) { }

  getProject(projectID:string ){
    console.log('service fetching from&gt;&gt;&gt;&gt;&gt;&gt;&gt;',this.API_URL+projectID);
    this.http.get(this.API_URL+projectID).subscribe(
      (res) =&gt; {
        this.project.next(res);
        console.log('service fetch complete&gt;&gt;&gt;&gt;&gt;&gt;',this.project.getValue()['name']);
      }
    );
  }
}

</code></pre>
<h3>The Component</h3>
<pre class=""lang-js prettyprint-override""><code>import { Component, OnInit, OnDestroy } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { myService } from '../../services/myService.service';


@Component({
  selector: 'app-layout',
  templateUrl: './layout.component.html',
  styleUrls: ['./layout.component.scss'],
})
export class LayoutComponent implements OnInit, OnDestroy {
  // Route Paramaters
  private projectTitle: string; 
  private projectId: string;
  // Content Object
  private projectDetails;

  constructor(private route: ActivatedRoute, private s: myService) {
    this.route.params.subscribe(routeParams =&gt; console.log(&quot;layout.component params&quot;, routeParams));
  }

   ngOnInit() {
    this.projectTitle = this.route.snapshot.params.projectTitle;
    this.projectId = this.route.snapshot.params.projectId;

    this.s.getProject(this.projectId);
    this.s.projectObservable.subscribe(prj =&gt; this.projectDetails = prj);  
  }

  ngOnDestroy() {
    console.log('hello - layout component destroyed');
  }

}
</code></pre>
<h3>The Layout</h3>
<pre class=""lang-html prettyprint-override""><code>&lt;ion-card&gt;

  &lt;ion-card-header&gt;
    &lt;ion-card-subtitle&gt;{{projectDetails.type}}&lt;/ion-card-subtitle&gt;
    &lt;ion-card-title&gt;{{ projectTitle }}&lt;/ion-card-title&gt;
  &lt;/ion-card-header&gt;

  &lt;ion-card-content&gt;
    &lt;div markdown ngPreserveWhitespaces&gt;
      {{projectDetails.Narrative}}
    &lt;/div&gt;  
  &lt;/ion-card-content&gt;

&lt;/ion-card&gt;
</code></pre>
<p>Any help is much appreciated!</p>
","3106576","","13680115","","2020-10-18 09:21:25","2020-10-18 09:21:25","Angular BehaviorSubject has delayed update to front-end","<angular><ionic-framework><rxjs><rxjs-observables>","2","1","","","","CC BY-SA 4.0"
"64429503","1","64433099","","2020-10-19 14:30:58","","1","102","<p>In my service I have these methods:</p>
<pre><code>  getMap(): any {
    return this.http.get(`someURL`);
  }

  getAssets(): any {
    return this.http.get(`someURL`);
  }
</code></pre>
<p>In my Component I use them like this:</p>
<pre><code>  ngOnInit() {
    this.myService.getMap().subscribe(data =&gt; {
      this.map = data; // Returns [&quot;map-1.svg&quot;, &quot;map-0.svg&quot;]
    });

    this.systemMapService.getAssets().subscribe(data =&gt;  {
        this.assets = data; // Returns [&quot;map-mapping-0.json&quot;, &quot;map-mapping-1.json&quot;]
    });
  }
</code></pre>
<p>In my template I want to use it like this:</p>
<pre><code>&lt;mat-tab-group mat-align-tabs=&quot;end&quot;&gt;
  &lt;div *ngFor=&quot;let item of assets; let i = index&quot;&gt;
    &lt;mat-tab label=&quot;{{i}}&quot;&gt;
      &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;map&quot;&gt;
          &lt;img id=&quot;img_equipment&quot; [src]=&quot;apiUrl + '/path/to/svg/' + item&quot;&gt;
          &lt;a *ngFor=&quot;let link of map&quot;
             title=&quot;{{ link.title }}&quot;
             class=&quot;ink&quot;
             [ngStyle]=&quot;{ left: link.left, top: link.top, width: link.width }&quot;&gt;
          &lt;/a&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/mat-tab&gt;
  &lt;/div&gt;
&lt;/mat-tab-group&gt;
</code></pre>
<p>I provided the return values of the calls as comments in die code.</p>
<p>For example, the file <code>map-0.svg</code> should use this JSON as a mapping <code>map-mapping-0.json</code>. The file <code>map-1.svg</code> then in turn this JSON file <code>map-mapping-1.json</code>.</p>
<p>..and do the arrays that the calls return have to be sorted for it to work? Because unfortunately they are currently being returned unsorted by the backend.</p>
","6475284","","","","","2020-10-19 18:20:22","How to merge two observables in Angular/RxJS?","<angular><typescript><rxjs><angular-material><rxjs-observables>","1","5","","","","CC BY-SA 4.0"
"64472249","1","64472921","","2020-10-21 21:53:02","","0","718","<p>finalize nested observables after the last item is processed. <a href=""https://stackblitz.com/edit/map-example-jx43fg?file=index.ts"" rel=""nofollow noreferrer"">Stackblitz</a></p>
<p>finalize() should be called when the observables complete - all the numbers (11, 12, 13) are output.</p>
<p>How should the observables be nested?</p>
<pre><code>import { from } from &quot;rxjs&quot;;
import { map, finalize } from &quot;rxjs/operators&quot;;

//emit (1,2,3)
const data = [
  {
    userId: 1,
    id: 1
  },
  {
    userId: 1,
    id: 2
  },
  {
    userId: 1,
    id: 3
  }
];
const source = from(data);
//add 10 to each value
const example = source.pipe(map(val =&gt; add(val.id)));
//output: 11,12,13
const subscribe = example.subscribe(val =&gt; console.log(val));
function add(n) {
  return n + 10;
}
</code></pre>
<p>The Stackblitz was a starting point.</p>
<p>In the following code, I want to send a message to all the users.</p>
<p>I want to unsubscribe and close the modal when all the messages are sent.</p>
<pre><code>  submit() {
    const users = from(this.form.value.users).pipe(
      finalize(() =&gt; {
        console.log('finalize'),
        this.dismissModal()
      }),
      map(user =&gt; this.buildMessage(user))
    ).subscribe(message =&gt; {
      this.subscription = this.firestoreService.addMessage(message)
        .subscribe();
    });
  }

  ngOnDestroy(): void {
    this.subscription?.unsubscribe();
  }

  dismissModal() {
    this.dialogRef.close('modal dismissed');
  }

</code></pre>
<p>Now <code>firestoreService.addMessage(message)</code> logs the <code>console.log('addMessage')</code> and returns but does not add the message to the database.</p>
<pre><code>  addMessage(data:Message):Observable&lt;T&gt; {
    console.log('addMessage');
    data.timestamp = firebase.firestore.FieldValue.serverTimestamp();
    return this.authService.currentUser$.pipe(
      switchMap(user =&gt; {
        console.log('addMessage user: ', user);
        if (user) {
          return this.firestore
            .collection&lt;any&gt;(user.company)
            .doc(user.licence)
            .collection&lt;any&gt;(message)
            .add(data)
              .then(res =&gt; {
                console.log(&quot;Message successfully added! &quot;, res);
              })
              .catch(e =&gt; {
                console.error(&quot;Error adding message: &quot;, e);
              });
          } else {
            return [];
          }
        }
      )
    );
  }
</code></pre>
","1074660","","1074660","","2020-10-22 00:36:59","2020-10-22 00:44:42","Angular 10 call finalize() when nested observables complete","<angular><subscribe><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"64481273","1","64481820","","2020-10-22 11:28:34","","1","170","<p>Am having some const array values and i have the response value in subscribe and i want to check whether the const array value is availabe in response.i dont know how to use map and filter in subscribe. if the value is available then the checkval should return true other wise false.i can able to did using some function but here i needs to use rxjs operators</p>
<pre><code> Response:
{
    &quot;testLoad&quot;: 1603367083993,
    &quot;checkData&quot;: &quot;test1&quot;
    &quot;type&quot;: &quot;flag&quot;,
    &quot;title&quot;: &quot;TestFlag&quot;,
    &quot;styleId&quot;: &quot;test&quot;,
    &quot;BodyContent&quot;: {
        &quot;properties&quot;: &quot;undefined&quot;
    }

}
 

       const styleid: Array&lt;string&gt; = ['test1','test2','test3'];
        public checkVal(){
        this.idVal =this.data.getresponse().subscribe((response =&gt; console.log(response ));
       }
</code></pre>
<p>since am new to angular rxjs can you please guide me and help out from this issue</p>
","14485906","","14485906","","2020-10-23 11:15:11","2020-10-23 11:15:11","Check the array value exist in subscribe angular10","<angular><rxjs><angular9><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"64499097","1","64499550","","2020-10-23 11:26:34","","1","628","<p>I am using method inside a template to call the function, that returns <code>boolean</code> value. The issue is that the function is called more than 6 times. After that I used <code>changeDetectionStrategy.onPush</code>  which reduced the calls to 2 times. Below is my code</p>
<p><strong>HTML</strong></p>
<pre><code>&lt;div *ngIf=&quot;(checkboolObs(check$)) | async&quot;&gt;&lt;/div&gt;
</code></pre>
<p><strong>TS</strong></p>
<pre><code>check$: Observable&lt;service&gt; = this.data.getresponse();

ngOnInit() {
  this.checkboolObs();
}
checkboolObs(style):boolean {
  return somestyleIDS.includes(style.component)
}
</code></pre>
<p>If the value is found it returns <code>true</code>, but it is called several times i need to call it only once. The reason behind this is because <code>checkboolobs()</code> is not triggered some times while navigating that's why I am calling this method from the template.</p>
","14485906","","9423231","","2020-10-23 14:13:15","2021-08-10 14:01:02","Multiple times method calling from angular template","<angular><typescript><rxjs><angular9><rxjs-observables>","2","3","","","","CC BY-SA 4.0"
"64499461","1","","","2020-10-23 11:51:18","","1","322","<ul>
<li>There is a function that would get called from anywhere within the
application, which would be passed an object.</li>
<li>What we need to do, is call a backend API with this item as Post<br />
Body.</li>
<li>However, what I would like to do is collate these updates for
an interval of time - and then send them across together, to<br />
reduce the number of calls made to backend.</li>
</ul>
<p>So, I am thinking of <em>adding these items to an Array</em>
. Create an observable with this array
and pipe <strong>bufferTime</strong> to buffer the values for a specific amount of time, before emitting them.</p>
<p>I created a Stackblitz - <a href=""https://stackblitz.com/edit/typescript-fzezep?file=index.ts&amp;devtoolsheight=100"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/typescript-fzezep?file=index.ts&amp;devtoolsheight=100</a>
and if you see the output -
The first 20 values are output, the ones that are added before subscribing.
But the last 20 values are never emitted.</p>
<p>So the subscription is complete, but then <em><strong>how do we create a subscription with a dynamic array?</strong></em></p>
","1535830","","","","","2020-10-23 12:37:57","How to create a rxJS subscription with a dynamic array?","<angular><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64503923","1","","","2020-10-23 16:31:29","","2","45","<p>I want to change the agm-circle color when the map changes its mode to dark mode.</p>
<p>I have a behavior subject as follows in the service file</p>
<pre><code>private isDarkModeActiveSubject = new BehaviorSubject&lt;boolean&gt;(false);
readonly isDarkModeActive$ = this.isDarkModeActiveSubject.asObservable();
</code></pre>
<p>In my component file, In ngOnInit method have the following code</p>
<pre><code>this.mapToolbarService.isDarkModeActive$
  .pipe(takeUntil(this.unsubscriber.done))
  .subscribe((isDarkModeActive: boolean) =&gt; {
    this.changeTheAgCircleColor(isDarkModeActive);
    ComponentChangeUtils.detectChanges(this.changeRef);
  });
</code></pre>
<p>and then changeTheAgCircleColor method</p>
<pre><code>  changeTheAgCircleColor(isDarkModeActive: boolean) {
    if (isDarkModeActive) {
      this.pickupClusterPoints.forEach((point) =&gt; {
        point.fillColor = '#FFCF4D';
        point.strokeColor = '#FFEB3B';
      });
    } else {
      console.log('light mode', isDarkModeActive);
      // this.pickupClusterPoints.forEach((point) =&gt; {
      //   point.fillColor = '#333';
      //   point.strokeColor = '#333';
      // });
    }
  }

export interface PickupClusterPoint extends PositioningPoint {
  strokeColor?: string;
  fillColor?: string;
 // some other varibles 
}
</code></pre>
<p>HTML file</p>
<pre><code>  &lt;ng-container *ngFor=&quot;let point of pickupClusterPoints&quot;&gt;
    &lt;agm-circle
       
      [strokeColor]=&quot;point.strokeColor&quot;
      [strokeWeight]=&quot;point.strokeWeight&quot;
      [fillColor]=&quot;point.fillColor&quot;
   
    &gt;&lt;/agm-circle&gt;
</code></pre>
<p>the circle color change if dark mode active but when I revert to light mode it remains the same.
The commented code in else block, if I uncomment it nothing works, I mean subscriber does not work and hence no method call. console.log alone works.</p>
","3222876","","3222876","","2020-10-23 16:37:13","2020-10-23 16:37:13","change the agm-circle color","<angular><typescript><rxjs><rxjs-observables><agm-map>","0","0","","","","CC BY-SA 4.0"
"64553092","1","","","2020-10-27 11:05:48","","0","349","<p>I have a problem with Observables used in this implementation. I am new to Observables.
I am implementing ngx-pagination on existing component with list of users. Problem is that next page is not populating results (only page 1 has 10 first results) but API call is being made and I can see the results in Network tab.
I think it's something with Observables. Any help will be highly appreciated.</p>
<p>component</p>
<pre><code>  pageSize: any;
  pageNumber = 1;
  count = 0;

 ngOnInit() {
    this.users$ = this.userapiService.getUsers(this.pageNumber);
  }

  handlePageChange(event) {
    this.pageNumber = event;
    this.users$ = this.userapiService.getUsers(this.pageNumber);
  }
</code></pre>
<p>html</p>
<pre><code>
      &lt;tr *ngFor=&quot;let user of users$.getValue() | paginate: { itemsPerPage: pageSize, currentPage: pageNumber }&quot;&gt;
               
     &lt;pagination-controls 
                    (pageChange)=&quot;handlePageChange($event)&quot;
                    previousLabel=&quot;Previous&quot;
                    nextLabel=&quot;Next&quot;
            &gt;&lt;/pagination-controls&gt;
 
</code></pre>
<p>service</p>
<pre><code>
 getUsers(pageNumber: number): Observable&lt;User[]&gt; {

        let params = new HttpParams();

        params = params.append('id', id).append('pageNumber', (pageNumber - 1).toString())
            .append('pageSize', constants.pageSize);

        this.httpService.httpGet(this.Endpoint, params)
            .subscribe(
                (response: User[]) =&gt; {
                    this.users$.next(response
                        .filter(user =&gt;  user
                        ));

                });
        return this.users$;
    }



</code></pre>
","6007311","","","","","2020-10-29 07:59:11","ngx-pagination angular 8 Observables next page not populating on FE","<angular8><angular2-observables><rxjs-observables><ngx-pagination>","1","0","","","","CC BY-SA 4.0"
"64556377","1","","","2020-10-27 14:15:57","","0","212","<p>I am fairly new to angular. I have two components namely header and profile component. The header component handles the login functionality and maintains two information- the user details which is json object and a isLoggedIn which is a boolean that saves current state of login. The general layout of the profile page is-</p>
<pre><code>&lt;header-component&gt;
&lt;profile-component&gt;
</code></pre>
<p>Now since the header component handles the login. I want to avoid writing the logic for getting userDetails and the isLoggedIn status again for profile component. So i decided writing a shared service called profile service so that i can upload userDetails and isLogged from header and access that info in the profile component. The input in the loginlogout method comes from the header component.</p>
<p>SharedService code -</p>
<pre><code>import { Injectable } from '@angular/core';
import { HttpService } from './https.service';
import { Observable, BehaviorSubject, of as observableOf } from 'rxjs';
import * as _ from 'lodash';
import { HttpHeaders, HttpParams } from '@angular/common/http';
import { BaseService } from './base.service';

@Injectable()
export class ProfileServices{
    constructor(){};

    userDetailsBS = new BehaviorSubject&lt;any&gt;('original value');
    userDetails= this.userDetailsBS.asObservable();
    isLoggedIn:boolean;

    loginlogout(userDetails:any , isLoggedIn:boolean){
        this.userDetails=userDetails;
        this.userDetailsBS.next(this.userDetails);
        console.log(&quot;Value of user details set in profile service&quot;,this.userDetails); //debug
        console.log(&quot;.getValue() method:&quot;,this.userDetailsBS.getValue()); //debug
        this.isLoggedIn=isLoggedIn;
    }

    getUserDetails(){
        
        return this.userDetailsBS.getValue();
    }
    
}
</code></pre>
<p>Post login from the header-component.ts i call the loginlogout method in the profile service to set the values. I also tried to access the value passed to the shared Service using the getUserDetails which shows that the userDetails object is passed correctly to the shared service.</p>
<p>The issue arises when i try to access the data from the profile component-</p>
<pre><code>export class ProfileT1Component implements OnInit {
    
    userDetails:any;
    constructor(
        public profileService: ProfileServices){
          this.profileService.userDetails.subscribe((result)=&gt;{
            console.log(result);
            this.userDetails=result;
            console.log(&quot;received user details in profile component constructor: &quot;, this.userDetails);
          })
    
      }
    }
</code></pre>
<p>the result still shows &quot;original value&quot; and not the updated value. Is this wrong approach altogether or am i handling the observables incorrectly. Help would be much appreciated.</p>
","12554550","","","","","2020-10-27 16:02:23","BehaviourSubject.getValue() returning default values","<javascript><angular><typescript><rxjs><rxjs-observables>","2","3","","","","CC BY-SA 4.0"
"64559353","1","","","2020-10-27 17:00:23","","1","54","<p>I have a data structure like the following being returned as an observable using Akita state management, but in essence its just like any other observable, if there is some way to do this in Akita even better but any pointers with rxjs would be great also.</p>
<pre><code>    {
        title: &quot;Cool project&quot;,
        date: &quot;12-09-2020 15:10:33&quot;
        events: [{
            id: 1,
            title: &quot;Beer festival&quot;,
            location: &quot;Paris&quot;
        },{
            id: 2,
            title: &quot;Fashion week&quot;,
            location: &quot;Dubai&quot;
        }]
    }
    
    
</code></pre>
<p>I would like to perform some kind of filtering on the subarray of events and return the following as an observable also where I just
have the event I need having filtered by the ID but also to return the top level object properties like <code>date</code> etc</p>
<pre><code>    {
        title: &quot;Cool project&quot;,
        date: &quot;12-09-2020 15:10:33&quot;
        event: {
            id: 1,
            title: &quot;Beer festival&quot;,
            location: &quot;Paris&quot;
        }
    }        
</code></pre>
","3461985","","","","","2020-10-28 03:10:27","How to modify an observable to bring a sub array item up to the top level properties - filtering by ID","<angular><rxjs><rxjs-observables>","2","1","","","","CC BY-SA 4.0"
"64585005","1","64585090","","2020-10-29 04:29:04","","1","35","<p>I have a function that runs when a file is uploaded to a html form.</p>
<pre><code>uploadidnexttofacepicture(event){
    let subscription = this.s3service.publicresourceuploadtos3(event)
      .subscribe((req: any)=&gt;{
        console.log(req);
      });
    
  }
</code></pre>
<p>this function calls a function <code>publicresourceuploadtos3</code> from a injected service. this function is displayed below:</p>
<pre><code>publicresourceuploadtos3(event): Observable&lt;any&gt;{
    console.log('the service at least ran');

    const mediatobeuploaded = event.target.files[0];
    this.http.get(environment.public_generate_presigned_url_resource).pipe(
      switchMap((req : any)=&gt;{
        console.log('did the call to the server');

        const resourceurl = req.uriroot + req.fields.key;

        let fd = new FormData();
        fd.append('acl', req.fields.acl);
        fd.append('key', req.fields.key);
        fd.append('content-type', req.fields['content-type']);
        fd.append('policy', req.fields.policy);
        fd.append('x-amz-algorithm', req.fields['x-amz-algorithm']);
        fd.append('x-amz-credential', req.fields['x-amz-credential']);
        fd.append('x-amz-date', req.fields['x-amz-date']);
        fd.append('x-amz-signature', req.fields['x-amz-signature']);
        fd.append('file', mediatobeuploaded);
        this.http.post(req.url, fd).pipe(
          switchMap((req2: any)=&gt;{
            const result = {
              resourceurl : resourceurl,
              resourcekey: req.fields.key
            };
            return of(result);


        }));


      }));


  }
</code></pre>
<p>the console log <code>console.log('the service at least ran');</code> does fire in the console but the server call one: <code>console.log('did the call to the server');</code>
did not.</p>
<p>but this results in an error:</p>
<pre><code>ERROR TypeError: Cannot read property 'subscribe' of undefined
    at ContentcreatorverificationComponent.uploadidnexttofacepicture
</code></pre>
<p>Im worried this is a syntax issue, would be helpful if any of you know what happening.</p>
","14358140","","14358140","","2020-10-29 04:40:02","2020-10-29 04:40:24","using a function that calls observable with 3 different observables tied together with switch map. results in error","<angular><typescript><rxjs><rxjs-observables><switchmap>","1","0","","","","CC BY-SA 4.0"
"64605860","1","","","2020-10-30 09:38:06","","1","19","<p>I am currently trying to figure out how to load an angular/fire-collection including all of its subcollections with RxJS.</p>
<p>This is my current approach:</p>
<pre><code>return this.collectionRef.valueChanges().pipe(
      flatMap((entities: Entity[]) =&gt; entity),
      mergeMap((entity: Entity) =&gt; this.setSubCollection1(entity)),
      mergeMap((entity: Entity) =&gt; this.setSubCollection2(entity)),
      scan((entities: Entity[], entity: Entity) =&gt; entities.filter(a =&gt; a.id !== entity.id).concat(entity), [])
    );
</code></pre>
<p>and to load the documents in their subcollections</p>
<pre><code>  private setSubCollection1 = (entity: Entity): Observable&lt;Entity&gt; =&gt; {
    return this.subCollectionRef.valueChanges(actor).pipe(
      map((subEntities1: SubEntity1[]) =&gt; {
        entity.subEntities1 = subEntities1;
        return entity;
      })
    );
  }
</code></pre>
<p>It works fine when having a full stream.
But now I wanted to get all of data in one single Promise: I already tried <code>.first().toPromise()</code> but this only gets the first entry, and does not finish if the collection has no entries. Using <code>reduce</code> in the query also does not work, because <code>valueChanges()</code> never finishes.</p>
<p>Am I using the wrong operators? Or any other ideas on how to solve that?</p>
<p>I hope to hear from you.</p>
","11723447","","","","","2020-10-30 09:38:06","How to load a firebase-collection with all its subcollection in one promise?","<rxjs><angularfire2><angularfire><rxjs-observables><rxjs-pipeable-operators>","0","0","","","","CC BY-SA 4.0"
"64625561","1","64626728","","2020-10-31 19:18:51","","1","76","<p>I want to incrementally increase the delay for this:</p>
<pre><code>const source = from(839283, 1123123, 63527, 4412454); // note: this is random
const spread = source.pipe(concatMap(value =&gt; of(value).pipe(delay(1000)))); // how to incrementally increase the delay where the first item emits in a second, the second item emits in three seconds, the third item emits in five seconds, and the last item emits in seven seconds.
spread.subscribe(value =&gt; console.log(value));
</code></pre>
<p>I'm aware of using interval to incrementally increase the delay time as below. But I also need to consume this source <code>const source = from(839283, 1123123, 63527, 4412454); </code></p>
<pre><code>const source = interval(1000); // But I also need to use have this from(839283, 1123123, 63527, 4412454)
const spread = source.pipe(concatMap(value =&gt; of(value).pipe(delay(value * 200))));
spread.subscribe(value =&gt; console.log(value
</code></pre>
<p>How to incrementally increase the delay time when starting with <code>const source = from(839283, 1123123, 63527, 4412454); </code>?</p>
","3073280","","","","","2020-11-01 00:47:46","RxJS - How to incrementally increase the delay time without using interval?","<angular><rxjs><rxjs5><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64632418","1","64634806","","2020-11-01 13:28:07","","2","71","<p>Is it possible to ensure that a subscriber is the last to be executed in the observer queue? A <code>delay(0)</code> is no option for me since I need the code to be executed in line and not asynchrounus.</p>
<pre><code>let observable = new Subject&lt;void&gt;();

//delay(0) no option!
observable.pipe().subscribe(() =&gt; console.log(&quot;I want to be last!&quot;));
observable.subscribe(() =&gt; console.log(&quot;I want to be first!&quot;));

observable.next();
</code></pre>
<p>I've created an example here: <a href=""https://stackblitz.com/edit/rxjs-demo-xuf2ru"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-demo-xuf2ru</a></p>
<p>I want the first subscriber, to be executed last. The current console output is:</p>
<blockquote>
<p>I want to be last!</p>
<p>I want to be first!</p>
</blockquote>
","1039407","","","","","2020-11-02 13:40:48","RXJS modify order of subscribers","<javascript><rxjs><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"64643847","1","","","2020-11-02 10:33:24","","0","56","<p>I am new to using combinedObservables in Angular. I have the following code snippet. The multiple http requests using forkJoin seems to be taking almost 15seconds.</p>
<p>Not sure how to debug this performance issue.</p>
<p>Can anyone help me with what am i doing wrong here or is there a better way to achieve a faster response?</p>
<pre><code>    forkJoin(this.layersArray
        .map((layer: any) =&gt; this.service.getLayerTreatyNumber(layer.layerId)))
        .subscribe((treatyNumbers: SelectItem[][]) =&gt; {
            treatyNumbers.forEach((treatyNumberOptions: StructuringLayerTreatyData[], index: number) =&gt; {
                const layer: StructuringLayerOverviewData = this.structuringOverviewStateService.initialData.layers[index];
                layer.treatyNumberOptions = treatyNumberOptions;
                const matchingOption: StructuringLayerTreatyData = treatyNumberOptions.find(t =&gt; t.name === layer.treatyNumber);
                if (matchingOption) {
                    layer.selectedTreatyNumber = matchingOption;
                    layer.businessUnit = matchingOption.businessUnit;
                } else {
                    layer.treatyNumber = '';
                    layer.businessUnit = '';
                    this.service.saveLayers(); //This takes the layers[] and saves.
                }
            });
            this.isFirstLoad = false;
        });
</code></pre>
<p>Thanks</p>
","4717427","","","","","2020-11-02 10:33:24","Angular 10 using forkJoin to make multiple http requests is slower","<fork-join><angular10><rxjs-observables><mergemap>","0","0","","","","CC BY-SA 4.0"
"64660232","1","","","2020-11-03 09:40:21","","0","72","<p>I am using RxJS Observables within Angular and cannot work out which operator to use to emit a single stream. I am using types and have one observable that emits this:</p>
<pre><code>export interface user {
   id: string,
   name: string,
}
</code></pre>
<p>And one that emits this:</p>
<pre><code>export interface devices {
    type: string,          
    os: string,     
    user_id: string,               
}
</code></pre>
<p>and am trying to combine them into a single observable that gives me this:</p>
<pre><code>export interface user {
    id: string,
    name: string,
    devices: Array &lt;{
        type: string,          
        os: string,     
        user_id: string,               
    }&gt;
}
</code></pre>
<p>With devices mapped to users based on their user_id.</p>
","6180606","","9880356","","2020-11-04 04:18:56","2020-11-04 04:18:56","How do I add one Observable to another as a value mapped to an ID","<angular><rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"64666511","1","","","2020-11-03 16:13:36","","-1","45","<p>I have an form wth autocomplete, it does work well in local but when i compile it to pwa it is not filtering datas.
The api works well and return a data json array response</p>
<pre><code>     var normalize = function (term) {
          var ret = &quot;&quot;;
          for (var i = 0; i &lt; term.length; i++) {
            ret += accentMap[term.charAt(i)] || term.charAt(i);
          }
          return ret;
        };

 search(Objobs: { Objobs?: any; id?: any; }, filter: { name: string } = { name: '' }, page = 1): Observable&lt;IUserResponse&gt; {

     return this.http.get&lt;IUserResponse&gt;('https://tutututu.com/agriobs-codeigniter/index.php/structure/get_area/17' ).pipe(
          tap((response: IUserResponse) =&gt; {
            response.results = response.results
              
           // Not filtering on mobile device (Android, Ios) ! 
              .map(user =&gt; new User(user.id_commune, user.nom_commune))
              .filter(user =&gt; normalize(user.nom_commune.toLowerCase()).includes(filter.name))
    
               return response;
               //console.log(response); 
          })
        )
}
</code></pre>
","3963082","","3963082","","2020-11-03 18:03:48","2020-11-04 15:58:31","Autocomplete not filtering on mobile device in Ionic with Angular","<angularjs><typescript><rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"64687699","1","","","2020-11-04 21:03:27","","0","16","<p>Having difficulty wrapping my head around observables. I have the following:</p>
<pre><code>const check = this.http.get(myUrl);
</code></pre>
<p>This returns JSON data. I want to test that the &quot;url&quot; field exists in the JSON data. If it doesn't I'd like to query a second URL. (Assume the API is fixed and two calls are necessary, because that is in fact the case.)</p>
<p>The problem is that I can't figure out how to do that. If <code>check</code> was just JSON (and no an observable) this would be trivial:</p>
<pre><code>if(check.url) {
    return check;
} else {
    return this.http.get(myOtherUrl);
}
</code></pre>
<p>This clearly doesn't work as I can't directly check the URL property. Reading the page on <a href=""https://angular.io/guide/rx-library#operators"" rel=""nofollow noreferrer"">RxJS operators</a>, I've written the following:</p>
<pre><code>const check = this.http.get(myUrl);
const mapResponse = map(response =&gt; {
    ...format data into JSON structure...
    return jsonResponse;
});
mapResponse(check).subscribe(result =&gt; {
  if (result['url']) {
      return result;
  } else {
      return this.http.get(myOtherUrl);
  }
});
</code></pre>
<p>This looks crazy awkward, as in order to use the second <code>get</code> I'd have to replicate the code within the lambda function. Not sure how to access the result of the second <code>http</code> call to actually do something with it. Should I just nest the entire thing again?</p>
","168775","","13302","","2020-11-04 21:19:16","2020-11-04 21:19:16","Testing the output of an Observable","<typescript><design-patterns><rxjs-observables>","0","6","","","","CC BY-SA 4.0"
"64715919","1","","","2020-11-06 13:55:22","","0","18","<p>I have come across a problem a few times now and I can't really figure out how to word it to get the answer I'm looking for on Google/SA so here goes.</p>
<p>I have multiple http observables. Lets say I want to delete object 1, 2 and 3. I send three http delete requests to <code>myapi/{id}</code> one after the other. I can subscribe to each request as each returns an Observable. This allows me to do something after each has completed or failed with <code>myHttpObservable.subscribe(successFn, failFn)</code>.</p>
<p>Heres where the problem comes in. I now want to know when all three delete requests have finished. To do this I can use <code>forkJoin([deleteRequest1, deleteRequest2, deleteRequest3]</code> but forkJoin takes an array of Observables and subscribes to them. I cannot subscribe to them individually now since <code>forkJoin</code> wants an array or Observables.</p>
<p>So how do I subscribe to each Observable with its own success and failure functions but also know when all three are done?</p>
","2066039","","2066039","","2020-11-06 14:03:25","2020-11-06 15:57:45","How do I subscribe to multiple Observables individually and know when they are all finished?","<rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64730020","1","64731205","","2020-11-07 16:37:03","","1","47","<p>I have this logic here, which creates many observable and executes a call back after each of them is done.</p>
<pre><code>from(rows).pipe(
    concatMap(row =&gt; this.uploadItem(row))
).subscribe(response =&gt; {
    this.currentRowNode.data.uploadStatus = UploadStatus.Success;
    this.currentRowNode.data.cmsRowId = response.responsePayload.cmsRowId
    this.currentRowNode.setData(this.currentRowNode.data);
});

currentRowNode: RowNode;
uploadItem(rowNode: RowNode): Observable&lt;any&gt; {
    this.currentRowNode = rowNode;
    rowNode.data.uploadStatus = UploadStatus.Uploading;
    rowNode.updateData(rowNode.data);
    return this.importService.uploadItem(rowNode.data)
 }
</code></pre>
<p>My issue here is that I'd like to be able to subscribe to something that would tell me <code>uploadItem</code> has been called for each of the <code>rows</code></p>
<p>Where would that go ?</p>
","731678","","","","","2020-11-07 18:47:02","Subscribe to final observable after all observable completed?","<angular><angular9><angular10><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64740572","1","","","2020-11-08 16:42:03","","0","36","<p>Seemingly an easy task, and should be a lot of answers already out there, but I just can't find one that solves my problem.</p>
<p>I have an Observable which emits an object. One of the properties of that object is another Observable. I want this property to be replaced with the value of the second Observable when the first one emits the object.</p>
<pre><code>const outer = of({
  someProperty: 'This is a simple value',
  inner: of('This is a value from the inner Observable')
});
</code></pre>
<p>I would like to have the following:</p>
<pre><code>// output: { someProperty: 'This is a simple value', inner: 'This is a value from the inner Observable' }
const subscribe = outer.subscribe(console.log);
</code></pre>
<p>How could I achieve this outcome? Some combination of RxJS operators should do the trick, but I just can't find the proper solution.</p>
","9267001","","9267001","","2020-11-09 09:51:39","2020-11-09 09:51:39","Map Observable's property which is another Observable","<rxjs-observables>","0","0","","","","CC BY-SA 4.0"
"64757534","1","","","2020-11-09 18:45:51","","1","168","<p>I'm trying to learn rxjs observables for an ionic project. I've made some headway, but am stuck on a syntax error that I have no idea what it means. The message appeared after I added the pipe to the http.get.</p>
<p>Any ideas of what is wrong and how to fix it would be very welcome:</p>
<pre><code>TS2740: Type '{ (): Observable ; (op1: OperatorFunction ): Observable; (op1: OperatorFunction , op2: OperatorFunction...&gt;): Observable...&gt;; (op1: OperatorFunction...&gt;, op2: OperatorFunction...&gt;, op3: OperatorFunction...&gt;): Observable...&gt;; (op1: OperatorFunction......' is missing the following properties from type 'Observable ': _isScalar, source, operator, lift, and 6 more.
</code></pre>
<p>My code is:</p>
<pre class=""lang-js prettyprint-override""><code>// Ionic Modules
import { catchError, map } from 'rxjs/operators';
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs-compat/Observable';
import { pipe, throwError } from 'rxjs';

// Models
import { Game } from '../models/game';
import { GamesList } from '../models/games-list';

// Other Modules
import { environment } from '../environments/environment';

@Injectable({
  providedIn: 'root'
})

export class GamesProvider {
  constructor(
      private http: HttpClient
  ){}

  /**
   * @summary Retrieve the full games list
   * @returns The returned games list data
   */
  public getGamesAll(): Observable&lt;GamesList&gt; {
    console.log('GamesProvider, in getGamesAll');
    return this.http.get(environment.API_URL, {responseType: 'json'}).pipe{
      map(data =&gt; {
        return new GamesList(data);
      }),

      catchError(err =&gt; {
        console.error(err);
        return throwError('Something went wrong ;)');
      });
    }
  }
}
</code></pre>
","9043945","","3625171","","2020-11-09 20:47:51","2020-11-09 20:47:51","missing the following properties from type 'Observable'","<ionic-framework><rxjs><rxjs-observables><rxjs-pipeable-operators>","0","1","","","","CC BY-SA 4.0"
"64801947","1","","","2020-11-12 10:13:46","","4","150","<p>The view contains the element:</p>
<pre><code>&lt;div *ngIf=&quot;showMe&quot;&gt;Hello&lt;/div&gt;
</code></pre>
<p>When calling the component method:</p>
<pre><code>downloadDemo(): void {
  this.download$ = this.downloadService.downloadUrlAsBlobWithProgressAndSaveInFile('assets/skypeforlinux-64.deb', 'demo')
  this.download$.subscribe((download: Download) =&gt; {
    this.showMe = true;
    console.log('Progress: ' + download.progress);
  })
}
</code></pre>
<p>the element shows in the view before all the <code>Progress</code> loggers. And that is how it should be. This HTTP based downloading works just fine.</p>
<p>However when calling the component method:</p>
<pre><code>downloadSoundtrack(soundtrack: Soundtrack): void {
  const fileName: string = soundtrack.name + '.' + MIDI_FILE_SUFFIX;
  const progress$: Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; = this.midiService.progressiveCreateSoundtrackMidi(soundtrack);
  this.download$ = this.downloadService.downloadObservableDataAsBlobWithProgressAndSaveInFile(progress$, fileName);
  this.download$.subscribe((download: Download) =&gt; {
    this.showMe = true;
    console.log('Progress: ' + download.progress);
  })
}
</code></pre>
<p>the element shows in the view last after all the <code>Progress</code> loggers. It is not how it should be. This custom <code>ReplaySubject</code> based observable is not working as expected. Indeed, the element should show before and not after all the <code>Progress</code> loggers.</p>
<p>I wanted to see if one subscribe call was blocking.</p>
<p>So I changed the two methods to:</p>
<pre><code>downloadSoundtrack(soundtrack: Soundtrack): void {
  const fileName: string = soundtrack.name + '.' + MIDI_FILE_SUFFIX;
  const progress$: Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; = this.midiService.progressiveCreateSoundtrackMidi(soundtrack);
  this.download$ = this.downloadService.downloadObservableDataAsBlobWithProgressAndSaveInFile(progress$, fileName);
  this.showMe = true;
  this.download$.subscribe((download: Download) =&gt; {
    console.log('Progress: ' + download.progress);
  });
  console.log('Call done');
}

downloadDemo(): void {
  this.download$ = this.downloadService.downloadUrlAsBlobWithProgressAndSaveInFile('assets/skypeforlinux-64.deb', 'demo')
  this.showMe = true;
  this.download$.subscribe((download: Download) =&gt; {
    console.log('Progress: ' + download.progress);
  });
  console.log('Call done');
}
</code></pre>
<p>Here are the loggers when calling the <code>downloadDemo()</code> method:</p>
<pre><code>Progress: 0
Call done
Progress: 0
Progress: 0
Progress: 2
Progress: 3
</code></pre>
<p>We can see the <code>subscribe()</code> call is non blocking.</p>
<p>Here are the loggers when calling the <code>downloadSoundtrack()</code> method:</p>
<pre><code>Progress: 96
Progress: 97
Progress: 100
Call done
</code></pre>
<p>We can see the <code>subscribe()</code> call is blocking.</p>
<p>Adding an explicit <code>this.detectChanges();</code> call made no difference:</p>
<pre><code>downloadSoundtrack(soundtrack: Soundtrack): void {
  const fileName: string = soundtrack.name + '.' + MIDI_FILE_SUFFIX;
  const progress$: Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; = this.midiService.progressiveCreateSoundtrackMidi(soundtrack);
  this.download$ = this.downloadService.downloadObservableDataAsBlobWithProgressAndSaveInFile(progress$, fileName);
  this.download$.subscribe((download: Download) =&gt; {
    this.showMe = true;
    this.detectChanges();
    console.log('Progress: ' + download.progress);
  })
}
</code></pre>
<p>It still showed after all the <code>Progress</code> loggers.</p>
<p>I have also tried some explicit  subscription in place of the <code>*ngIf=&quot;download$ | async as download&quot;</code> in the template, but it did not help any:</p>
<pre><code>downloadInProgress(soundtrack: Soundtrack): boolean {
  let inProgress: boolean = false;
  if (soundtrack.download) {
    if (soundtrack.download.progress &gt; 0 &amp;&amp; soundtrack.download.progress &lt; 100) {
      inProgress = true;
    } else if (soundtrack.download.progress == 100) {
      console.log('complete');
      soundtrack.download = undefined;
    }
  }
  console.log('inProgress ' + inProgress);
  return inProgress;
}
</code></pre>
<p>The long running service:</p>
<pre><code>public progressiveCreateSoundtrackMidi(soundtrack: Soundtrack): Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; {
  return Observable.create((progressTaskBis$: ReplaySubject&lt;ProgressTask&lt;Uint8Array&gt;&gt;) =&gt; {
    this.createSoundtrackMidi(soundtrack, progressTaskBis$);
    progressTaskBis$.complete();
    return { unsubscribe() { } };
  });
}

public createSoundtrackMidi(soundtrack: Soundtrack, progressTask$?: ReplaySubject&lt;ProgressTask&lt;Uint8Array&gt;&gt;): Uint8Array {
  const midi: Midi = new Midi();
  midi.name = soundtrack.name;
  midi.header.name = soundtrack.name;
  let noteIndex: number = 0;
  if (soundtrack.hasTracks()) {
    soundtrack.tracks.forEach((track: Track) =&gt; {
      const midiTrack: any = midi.addTrack();
      midiTrack.name = track.name;
      midiTrack.channel = track.channel;
      if (track.hasMeasures()) {
        let totalDurationInSeconds: number = 0;
        for (const measure of track.getSortedMeasures()) {
          if (measure.placedChords) {
            if (!this.notationService.isOnlyEndOfTrackChords(measure.placedChords)) {
              for (const placedChord of measure.placedChords) {
                if (!this.notationService.isEndOfTrackPlacedChord(placedChord)) {
                  const duration: string = placedChord.renderDuration();
                  const durationInSeconds: number = Tone.Time(duration).toSeconds();
                  const velocity: number = placedChord.velocity;
                  // const tempoInMicroSecondsPerBeat: number = this.beatsToMicroSeconds(1, measure.getTempo());
                  // const ticks: number = this.beatsToTicks(durationInBeats, DEFAULT_MIDI_PPQ, tempoInMicroSecondsPerBeat);
                  for (const note of placedChord.notes) {
                    if (!this.notationService.isEndOfTrackNote(note)) {
                      if (progressTask$) {
                        this.commonService.sleep(50);
                        progressTask$.next(this.downloadService.createProgressTask&lt;Uint8Array&gt;(soundtrack.getNbNotes(), noteIndex));
                      }
                      noteIndex++;
                      midiTrack.addNote({
                        midi: this.synthService.textToMidiNote(note.renderAbc()),
                        time: totalDurationInSeconds,
                        // ticks: ticks,
                        name: note.renderAbc(),
                        pitch: note.renderChroma(),
                        octave: note.renderOctave(),
                        velocity: velocity,
                        duration: durationInSeconds
                      });
                    }
                  }
                totalDurationInSeconds += durationInSeconds;
                }
              }
            }
          }
        }
      }
    });
  }
  if (progressTask$) {
    progressTask$.next(this.downloadService.createProgressTask&lt;Uint8Array&gt;(soundtrack.getNbNotes(), soundtrack.getNbNotes(), midi.toArray()));
  }
  return midi.toArray();
}
</code></pre>
<p>There is a sleep call of 50ms slowing down the file creation, so as to give some ample time.</p>
<p>The implementation of the download service is based on <a href=""https://nils-mehlhorn.de/posts/angular-file-download-progress"" rel=""nofollow noreferrer"">this article</a></p>
<p>I'm on Angular 9.1.0</p>
","958373","","958373","","2020-11-15 09:41:22","2020-11-15 09:41:22","Synchronous blocking subscribe call to a custom ReplaySubject based observable","<angular><observable><rxjs-observables>","1","4","","","","CC BY-SA 4.0"
"64815883","1","","","2020-11-13 05:20:35","","0","105","<p>I have a large application built on Angular 7. I want to implement something which will unsubscribe the RxJs subscribers if developer has forgotten to unsubscribe in ngOnDestroy. This is to ensure no memory leak in application.</p>
<p>Is it possible with Guards? When the route changes, the Guard will check which component was last loaded and unsubscribe its subscribers?</p>
","1312242","","","","","2021-01-14 18:32:02","Angular Subscribers - auto unsubscribe a subscriber when the component destroys","<angular><rxjs-observables>","2","1","","","","CC BY-SA 4.0"
"64820832","1","64821053","","2020-11-13 12:22:19","","2","1076","<p>I have an observable that I would like to create a variable with in the ngIf as well as only return false if the value is null (the observable returns a number)</p>
<p>I need to explicitly check for null as my observable can return 0 as a value which triggers the else block.</p>
<p>I have tried the following</p>
<pre><code>*ngIf=&quot;(observable$ | async) as obs; obs !== null; esle #elseTemplate&quot;
</code></pre>
<pre><code>*ngIf=&quot;((observable$ | async) as obs) !== null; esle #elseTemplate&quot;
</code></pre>
<pre><code>*ngIf=&quot;(observable$ | async) !== null; $implicit = obs; else #elseTemplate&quot;
// this returns the boolean 
</code></pre>
<p>My current solution which doesn't seem very elegant is</p>
<pre><code>*ngIf=&quot;(observable$ | async) !== null; esle #elseTemplate&quot;
{{ observable$ | async }}
</code></pre>
<p>I am using Angular 10.</p>
","6395235","","6395235","","2020-11-13 12:41:38","2020-11-13 12:55:43","ngIf Async Pipe as value with only null check","<angular><rxjs><angular10><rxjs-observables><async-pipe>","2","3","","","","CC BY-SA 4.0"
"64887316","1","","","2020-11-18 04:54:42","","0","40","<p>I'm experimenting with Observables but I still couldn't figure out why this is not working.
All the methods seems to be working fine if I call them outside the pipe <strong>but</strong> when I nest them this way it simply won't work:</p>
<pre><code>createUserWithEmailAndPassword(email, password): Observable&lt;Session&gt; {
    return from(this.firebaseAuth.createUserWithEmailAndPassword(email, password))
        .pipe(map(v =&gt; v.user as unknown as User),
            switchMap(this.userDatabase.createUser),
            map(this.userDatabase.createSession)
        );
}
</code></pre>
<h2>it throws this error:</h2>
<blockquote>
<p>ERROR TypeError: Cannot read property 'post' of undefined</p>
<pre><code>at SwitchMapSubscriber.create (database-core.service.ts:57)
at SwitchMapSubscriber.createUser [as project] (database-user.service.ts:28)
at SwitchMapSubscriber._next (switchMap.js:30)
at SwitchMapSubscriber.next (Subscriber.js:49)
at MapSubscriber._next (map.js:35)
at MapSubscriber.next (Subscriber.js:49)
at subscribeToPromise.js:5
at ZoneDelegate.invoke (zone-evergreen.js:364)
at Object.onInvoke (core.js:27437)
at ZoneDelegate.invoke (zone-evergreen.js:363)
</code></pre>
</blockquote>
<h2>database-user:</h2>
<pre><code>createUser(user: User): Observable&lt;User&gt; {
    return super.create(this.DB_URL, user) //&lt;--- line 28
        .pipe(map(v =&gt; v as unknown as User));
}

createSession(user: User): Session {
    const newSession: Session = {
        firstLogin: false,
        id: user.id
    };
    this.angularFirestore.collection('session').doc(user.uid).set(newSession)
        .catch(e =&gt; {
            throw new Error(e);
        });
    return newSession;
}
</code></pre>
<h2>In database-core:</h2>
<pre><code>constructor(
    private globalService: GlobalService,
    protected httpClient: HttpClient
) {}
// (...)
protected create(url: string, data: any): Observable&lt;JsonObject&gt; {
    return this.httpClient.post&lt;JsonObject&gt;(url, data, this.globalService.getHttpOptions()) //&lt;-- lines 57
        .pipe(catchError(DatabaseCoreService.handleError)); 
}
</code></pre>
<h2>Subscribing to the observable:</h2>
<pre><code>createUser(email, password) {
    this.authService.createUserWithEmailAndPassword(email, password).subscribe();
}
</code></pre>
<h2>App-Module:</h2>
<pre><code>@NgModule({
    declarations: [AppComponent],
    entryComponents: [],
    imports: [
        BrowserModule,
        IonicModule.forRoot(),
        AppRoutingModule,
        AngularFireModule.initializeApp(environment.firebaseConfig),
        HttpClientModule
    ],
    // (...)
</code></pre>
","12604952","","","","","2020-11-19 04:00:11","Why nesting these observables is not working in Ionic-Angular?","<angular><typescript><ionic-framework><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64888505","1","","","2020-11-18 07:05:14","","0","51","<p>Im trying to upload multiple images, hence converting the image to a base64 encoded string and also storing its metadata with an array.We store the reference to the image path to database hence functionionality is written in  backend for insertion.</p>
<p>However ,</p>
<ol>
<li>To process image files into base64 and store metadata i use array and trying to pass as arguments to a function but i receive empty array in service call. Could someone help me understand why and how to fix this.</li>
<li>the upload image is called for every iteration of for loop , WHY?</li>
</ol>
<p>Thanks in advance .</p>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>export class ItemsDetailsComponent {
  //image variables
  itemImageDetails: any = [];
  ItemImageURLs: any = [];
  itemImageCount: number = 0;
  base64image: any = [];
  CustImageData: any;
  itemImageData: any;
  itemimagePath: any;
  fileList: any = [];
  newImageMetaData: any = [];
  imageMetaData: any = [];
  addImagePopupVisible: boolean = false;
  deleteImagePopupVisible: boolean = false;
  tempImageCount: number = 0;
  deleteImageURL: any;
  deleteImageName: any;
  deleteImageConfirmPopUp: boolean;
  value: any[] = [];


  constructor() {
    // ...
  }

  processFile() {
    let count = 0;

    for (let i = 0; i &lt; this.value.length;
      (i++, count++)) {
      this.fileList.push(this.value[count]);
      this.httpDataService.getBase64(this.value[count])
        .then(base64img =&gt; {
          this.base64image[this.tempImageCount] = base64img;
          this.base64image[this.tempImageCount] = this.base64image[this.tempImageCount].split("","")[1];
          this.tempImageCount++;

          this.newImageMetaData.push({
            ""type"": this.fileList[i].type,
            ""name"": this.fileList[i].name,
            ""size"": this.fileList[i].size
          });

        });
    }
//want to call this function only after for loop is complete but is getting called at every iteration , WHY?
    this.uploadImages(); 
  }
  


uploadImages() {
  if (this.newImageMetaData.length == this.base64image.length) {
    //recieves expected output(the array in log) **

    console.log(this.newImageMetaData);
    console.log(this.base64image); **

     // below service call is receiving empty array - &gt;&gt; [] for ** [...this.base64image] ** ** [...this.newImageMetaData] **

    this.httpDataService.uploadMultipleImages(["""", this.itemCode, [...this.base64image],
        [...this.newImageMetaData]
      ])
      .subscribe(status =&gt; {
        if ((status != -1) &amp;&amp; status) {
          this.toastr.success(status + ""Image(s) Successfully Uploaded"");
          this.getImag();
          this.getItemImageDetails();
          this.newImageMetaData = [];
          this.base64image = [];
        } else {
          this.toastr.error(""Error Uploading image"" + status + "" Image(s) Uploaded "");
        }

        this.addImagePopupVisible = false;
      });
  }

}

// </code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;div class=""widget-container""&gt;
  &lt;form enctype=""multipart/form-data""&gt;
    &lt;dx-file-uploader #fileUploader [multiple]=""true"" accept=""image/*"" [(value)]=""value"" uploadMode=""useForm""&gt;&lt;/dx-file-uploader&gt;
    &lt;div class=""content""&gt;
      &lt;div *ngIf=""value.length &gt; 0""&gt;
        &lt;h4&gt;Selected Files&lt;/h4&gt;
      &lt;/div&gt;
      &lt;div *ngFor=""let file of value""&gt;
        &lt;div class=""selected-item""&gt;
          Name:
          &lt;span&gt;{{file.name}}&lt;/span&gt;&lt;br /&gt; Size:
          &lt;span&gt;{{file.size}}&lt;/span&gt;bytes&lt;br /&gt; Type:
          &lt;span&gt;{{file.type}}&lt;/span&gt;&lt;br /&gt; Last Modified Date:
          &lt;span&gt;{{file.lastModifiedDate}}&lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;dx-button text=""Create Product"" type=""submit"" (onClick)=""uploadImages()""&gt;
    &lt;/dx-button&gt;
  &lt;/form&gt;

&lt;/div&gt;
&lt;div class=""options""&gt;
  &lt;div class=""caption""&gt;Options&lt;/div&gt;
  &lt;div class=""option""&gt;
    &lt;dx-check-box text=""Allow multiple files selection"" [(value)]=""fileUploader.multiple""&gt;&lt;/dx-check-box&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","8895401","","8895401","","2020-11-19 06:35:15","2020-11-19 06:35:15","Im trying to pass array as arguments to httpservice call, but the argumments is evaluating to empty array","<javascript><angular><typescript><rxjs-observables><devextreme-angular>","1","2","","","","CC BY-SA 4.0"
"64956917","1","64956953","","2020-11-22 16:55:36","","0","56","<p>I'm trying to use combineLatest with a BehaviourSubject.asObservable but getting this error:</p>
<pre><code>TypeError: You provided 'function () {
        return this.ctaButtonSpinnerTriggered.asObservable();
    }' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
</code></pre>
<pre><code>private ctaButtonSpinnerTriggered: BehaviorSubject&lt;
    boolean
&gt; = new BehaviorSubject(false);

public isCtaButtonSpinnerTriggered(): Observable&lt;boolean&gt; {
    return this.ctaButtonSpinnerTriggered.asObservable();
}

public setCtaButtonSpinnerTriggered(isDisabled: boolean): void {
    this.ctaButtonSpinnerTriggered.next(isDisabled);
}

public get showCtaSpinner(): Observable&lt;boolean&gt; {
    return combineLatest([
        this.ctaDisabled,
        this.isCtaButtonSpinnerTriggered,
    ]).pipe(
        map(
            ([ctaDisabled, isCtaButtonSpinnerTriggered]: [
                boolean,
                boolean
            ]) =&gt; {
                console.log(
                    !ctaDisabled,
                    isCtaButtonSpinnerTriggered,
                    'ctaDisabled + isCtaButtonSpinnerTriggered'
                );
                return !ctaDisabled &amp;&amp; isCtaButtonSpinnerTriggered;
            }
        )
    );
}
</code></pre>
<p>Any ideas what would be the right implementation of combineLatest with BehaviourSubject ?</p>
","1194797","","","","","2020-11-22 16:59:01","combineLatest with BehaviourSubject.asObservable causing stream was expected error","<angular><rxjs><behaviorsubject><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64962546","1","64962618","","2020-11-23 04:26:15","","2","44","<p>In the below code I have used subscribe inside subscribe. This code works but the code structure is very bad. I would like to refactor this code using rxjs(<strong>forkjoin or mergemap</strong>).I'm not sure how to achieve this. Can someone help me with this? Any help is appreciated.</p>
<pre><code>this.chapservice.cycle().subscribe((current) =&gt; {
      this.selectedCycleId = current.ratingCycleId;
      this.chapService
        .getChapterEvalWithSkills(
          this.activeUser.ipn,
          this.selectedRatingCycleId
        )
        .subscribe((response) =&gt; {
          console.log(&quot;response&quot;, response);
          if (response &amp;&amp; response.length &gt; 0) {
            this.chapterEvals = response;
          }
        });
      this.chapservice
        .getIsitEmployeeStatus(this.activeUser.ipn, this.selectedCycleId)
        .subscribe((sdpStatus) =&gt; {
          this.activeUserStatus = sdpStatus;
       if (this.activeUserStatus.statusDescription == 'SUBMITTED') {
                 //do something
            }
        });
    });
</code></pre>
","13879147","","","","","2020-11-23 05:14:34","How to use rxjs for multiple inner nested subscribes","<angular><typescript><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"64973295","1","","","2020-11-23 17:28:41","","0","37","<p>I have component1.ts:</p>
<pre><code>  export class Component1 implements OnInit, AfterViewInit  {
    public inputData1: any[] = [];
    public inputData2: any[] = [];
    public inputData3: any[] = [];
    private sub: Subscription;

    ngOnInit() {
       this.sub= this.service.dataObservable.subscribe((val: any) =&gt; {
       try {
          this.inputData1 = some logic to filter input data1 from val. &lt;--- Here this.inputdata1/2/3 says undefined after assignment.
          this.inputData2 = some logic to filter input data2 from val.
          this.inputData3 = some logic to filter input data3 from val. 
       }
       catch (ex) {
    
       }
    }
</code></pre>
<p>component.html</p>
<pre><code>&lt;mat-card class=&quot;tab-card&quot;&gt;
   &lt;app-component2 [inputData1]='inputData1' [inputData2]='inputData2' [inputData3]='inputData3' &gt; 
   &lt;/app-component2&gt;
&lt;/mat-card&gt;
</code></pre>
<p>component2.ts</p>
<pre><code>export class Component2 implements OnInit {

  inputData1Columns: string[] = ['col1', 'col2'];
  @Input() inputData1: any[] = [];
  inputDataSource1 = new MatTableDataSource(this.inputData1);

  inputData2Columns: string[] = ['col1', 'col2'];
  @Input() inputData2: any[] = [];
  inputDataSource2 = new MatTableDataSource(this.inputData2);

  inputData3Columns: string[] = ['col1', 'col2'];
  @Input() inputData3: any[] = [];
  inputDataSource3 = new MatTableDataSource(this.inputData3);

  constructor() {}

}
</code></pre>
<p>For some reason when the subscription is triggered and the inputdata1,2,3 are not assigned. When i put a breakpoint, it says inputdata1 is undefined. What am I missing?</p>
","9969157","","","","","2020-11-23 17:28:41","Adding angular component input data from inside subscribe","<angular><rxjs><angular-material><rxjs-observables>","0","4","","","","CC BY-SA 4.0"
"64974421","1","64974895","","2020-11-23 18:42:00","","0","51","<p>I have the following code in my service</p>
<pre><code>        let b = new BehaviorSubject({ a: undefined })
        let o = b.asObservable();
        o.pipe(filter(_ =&gt; _.a === 5)).subscribe(() =&gt; {
            debugger;
        }, error =&gt; {
            debugger
        })
        b.next({ a: 10 })
        b.next({ a: 5 })
        b.error({ a: 10 })
</code></pre>
<p>When I invoke b.next({a:10}) it does not hit the debugger in the onNext callback When I invoke b.next({a:5}) it hits the debugger in the onNext callback.
When I invoke b.error({a:10}) it hits the debugger in the onError callback.</p>
<p>My expectation was the onError callback should not be called since the filter condition was not satisfied. But, clearly I have something wrong here.</p>
<p>How do I filter the errors too?</p>
<p>Thank you in advance.</p>
","10235280","","10235280","","2020-11-23 18:56:17","2020-11-23 19:14:32","Rxjs Observer filter not working for error","<angular><rxjs><behaviorsubject><rxjs-observables><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"64978335","1","64978901","","2020-11-23 23:53:02","","2","25","<p>I'm having an issue where I'm returning  _scalar for a value in my object when I should be return the entire object. This one property in my object is stopping my code. The parameters are all return the correct values.</p>
<p>I'm trying to document as much of the code as possible to help understand the problem. I'm as junior as can be so bare with me.</p>
<p>relevant viewmodel (class should be interface which I'll change later):</p>
<pre><code>    export class StandardWaiver {
    id?: number;
    waiverType?: WaiverType;
    duplicateFound?: boolean;
    notFoundInCAP?: boolean;
    policyNumber?: string;
    policyType?: number;
    dateOfLoss?: Date;
</code></pre>
<p>Waiver Service:</p>
<pre><code>   export class WaiverSevice {
   privat baseURL = '/xxx/XXX/xxxxxx/';
   constructor(private http: HttpClient) {}

   searchForWaiver(waiverTypeId: number, policyNumber: string, dateOfLoss: Date): any {
    let options = this.setOptionHeaders();

    if (isNotNullOrUndefined(policyNumber) &amp;&amp; isNotNullOrUndefined(dateOfLoss)) {
      const duplicateCheck: any = {
        policyNumber,
        dateOfLoss,
      };
      if (waiverTypeId === 1) { return this.http.post(this.baseURL + 
    'Standard/CheckForDuplicateOrCAP', duplicateCheck, options); }
      else if (waiverTypeId === 2) { return this.http.post(this.baseURL + 
    'ICC/CheckForDuplicateOrCAP', duplicateCheck, options); }
      else {
        return null;
       }
     }

   }
</code></pre>
<pre><code>    export const standardWaiverFromJSON = (data: any) =&gt; {
    let standardWaiver: StandardWaiver;
   standardWaiver.id = isNotNullOrUndefined(data?.id) ? data.id : null;
</code></pre>
<blockquote>
<p><strong>this is where the code breaks:</strong></p>
</blockquote>
<pre><code>    export class CreateNewWaiverModalComponent {

     public opened = false;
 
    standardWaiver: StandardWaiver = new StandardWaiver(); 
    dateOfLoss: Date = null;
    policyNumber: string;
    waiverTypeId: number;
    waiverData: any;

    constructor(
    private activatedRoute: ActivatedRoute,
    private router: Router,
    private waiverService: WaiverService) { }

    async searchForDuplicateAndCAP() {
     if (this.waiverTypeId === 1)// standard
    {
      this.waiverData = this.waiverService.searchForWaiver(this.waiverTypeId, this.policyNumber, 
    this.dateOfLoss);

    console.log('DATA: ' + this.waiverData, '; WAIVERTYPEID: ' + this.waiverTypeId, '; 
    POLICYNUMBER: ' + this.policyNumber, '; DATEOFLOSS: ' + this.dateOfLoss, '; STANDARDWAIVER 
    OBJECT: ' + this.standardWaiver);

    this.standardWaiver = standardWaiverFromJSON(this.waiverData);
    }
</code></pre>
<p>This is the what I'm returning from the console.log:</p>
<pre><code>    DATA: [object Object] ; WAIVERTYPEID: 1 ; POLICYNUMBER: 1234556654 ; DATEOFLOSS: Thu Jan 31 
    2019 00:00:00 GMT-0500 (Eastern Standard Time) ; STANDARDWAIVER OBJECT: [object Object] 

    ERROR Error: Uncaught (in promise): TypeError: standardWaiver is undefined - firefox browser
    ERROR Error: Uncaught (in promise): TypeError: Cannot set property 'id' of undefined - chrome browser
</code></pre>
<p>I have to return this.standardWaiver as a property with values that has <code>(this.waiverTypeId, this.policyNumber, this.dateOfLoss)</code> in the parameters. So far it's not giving me that just <code>[object Object]</code> and I'm not understanding why. I welcome any suggestion, and thank you in advance.</p>
","9183130","","6553328","","2020-11-24 01:14:17","2020-11-24 01:15:50","Possibly returning a nested observable: _scalar: false; Definetly returning undefined objects","<angular><typescript><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64984273","1","","","2020-11-24 10:09:37","","0","339","<p>I have a basic timer observable that I want to be shared across multiple subscribers.</p>
<pre><code>time = 30;
timer$ = timer(0,1000).pipe(
    map(i =&gt; this.time - i),
    take(this.time + 1),
    finalize(() =&gt; console.log('DONE')),
    share()
);
</code></pre>
<p>I subscribe to the observable in both template and component, in the component to start the timer, and in the template to show the remaining time.</p>
<pre><code>ngOnInit() {
    this.runTimer();
}

runTimer() {
    this.timer$.subscribe();
}

{{ timer$ | async }}
</code></pre>
<p>This works, but only for the first time. If I call the runTimer() function again (e.g a button triggering that call), the timer starts again, but the change is not reflected in the template where I see <code>0</code> (probably because the previous timer finished).</p>
<p>What am I doing wrong?</p>
<p>I've created stackblitz: <a href=""https://stackblitz.com/edit/angular-ivy-qc759v?embed=1&amp;file=src/app/app.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-ivy-qc759v?embed=1&amp;file=src/app/app.component.ts</a></p>
","14698234","","14698234","","2020-11-24 10:17:54","2020-11-24 12:23:55","Shared countdown timer observable","<angular><rxjs><rxjs-observables>","3","5","","","","CC BY-SA 4.0"
"65014131","1","","","2020-11-25 23:28:41","","0","36","<p>I am not so into RxJS and I have the following doubt about why it is the best way to solve this problem. I will try to explain it in details. Into a service class I have these 2 methods:</p>
<pre><code>  acceptArtistBid(bid): void {

    this.findArtistBidsAppliedByCurrentWall(bid)
    .subscribe(artistsBisdList =&gt; {
      console.log(&quot;ARTISTS BIDS LIST RELATED THE CURRENT WALL: &quot;, artistsBisdList);

      // ITERATE ON EACH ELEMENT OF THE artistsBisdList, DO SOME CHANGE TO EACH ELEMENT AND UPDATE ALL THESE ELEEMENTS ON FIRESTORE
      
    }); 
  }

  findArtistBidsAppliedByCurrentWall(bid):Observable&lt;Bid[]&gt; {
    return this.db.collection('bids',
    ref=&gt; ref.where(&quot;wallId&quot;, &quot;==&quot;, bid.wallId))
    .snapshotChanges()
    .pipe(
        map(snaps =&gt; {

            const courses = this.convertSnaps&lt;Bid&gt;(snaps);

            return courses;
        })
    )
  }
</code></pre>
<p>So basically I have this <strong>acceptArtistBid()</strong> method that call the <strong>findArtistBidsAppliedByCurrentWall()</strong> in order to retrieve an <strong>Observable</strong> containing a <strong>Bid</strong> objects array.</p>
<p>At the moment inside my <strong>acceptArtistBid()</strong> method I am subscribing this observable in order to retrieve the list of objects...then I have to iterate on this list in order to apply some logic to each of these object (I simply have to change the value of a status field) and then update these object on Firestore database.</p>
<p>Using this approach at the moment I was thinking to do a simple classical for loop interation or maybe the <strong>forEach()</strong> method passing an iterator function as parameter (as shown here: <a href=""https://www.w3schools.com/js/js_array_iteration.asp"" rel=""nofollow noreferrer"">https://www.w3schools.com/js/js_array_iteration.asp</a>) in order to change the status field value of each object in my array and then update these object on Firebase one by one.</p>
<p>I am asking if this approach is correct or if it is possible do something better using RxJS....in this case I think that I have not to subscribe my <strong>findArtistBidsAppliedByCurrentWall(bid)</strong> method but that maybe I have to use some RxJS operators directly on the Observable.</p>
<p>Is it possible? What could be an elegant solution using RxJS to solve this problem?</p>
","1833945","","","","","2020-11-26 08:11:23","What is an elegand solution to iterate (and apply some logic) on an Observable containing an array using RxJS?","<typescript><google-cloud-firestore><rxjs><observable><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"65020548","1","","","2020-11-26 10:50:07","","0","83","<p>I had this method:</p>
<pre><code>public progressiveCreateSoundtrackMidi(soundtrack: Soundtrack): Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; {
  return Observable.create((progressTask$: ReplaySubject&lt;ProgressTask&lt;Uint8Array&gt;&gt;) =&gt; {
    this.createSoundtrackMidi(soundtrack, progressTask$);
    return { unsubscribe() { } };
  });
}
</code></pre>
<p>which was compiling and working fine, only its <code>Observable.create()</code> method call was warned as being deprecated.</p>
<p>I thus tried to replaced the <code>Observable.create()</code> method call by an <code>of()</code> method call as in:</p>
<pre><code>public progressiveCreateSoundtrackMidi(soundtrack: Soundtrack): Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; {
  return of((progressTask$: ReplaySubject&lt;ProgressTask&lt;Uint8Array&gt;&gt;) =&gt; {
    this.createSoundtrackMidi(soundtrack, progressTask$);
    return { unsubscribe() { } };
  });
}
</code></pre>
<p>But it gives me the compile error:</p>
<pre><code>Type 'Observable&lt;(progressTask$: ReplaySubject&lt;ProgressTask&lt;Uint8Array&gt;&gt;) =&gt; { unsubscribe(): void; }&gt;' is not assignable to type 'Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt;'.
  Type '(progressTask$: ReplaySubject&lt;ProgressTask&lt;Uint8Array&gt;&gt;) =&gt; { unsubscribe(): void; }' 
is missing the following properties from type 'ProgressTask&lt;Uint8Array&gt;': body, loaded, total, taskIsCompletets(2322)
</code></pre>
<p>I also tried with each of these alternatives:</p>
<pre><code>public progressiveCreateSoundtrackMidi(soundtrack: Soundtrack): Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; {
  return of((progressTask$: ReplaySubject&lt;ProgressTask&lt;Uint8Array&gt;&gt;) =&gt; {
    this.createSoundtrackMidi(soundtrack, progressTask$);
    return progressTask$.asObservable();
    // return of({body: '', loaded: 0, total: 0, taskIsComplete: false});
    // return new ProgressTask&lt;Uint8Array&gt;((soundtrack.getNbNotes(), 0);
    // return of(this.downloadService.createProgressTask&lt;Uint8Array&gt;(soundtrack.getNbNotes(), 0, new Array()));
    // return this.downloadService.createProgressTask&lt;Uint8Array&gt;(soundtrack.getNbNotes(), 0, new Array());
  });
}
</code></pre>
<p>But I still get the same compile error.</p>
<p>The service method signature:</p>
<pre><code>public createSoundtrackMidi(soundtrack: Soundtrack, progressTask$?: ReplaySubject&lt;ProgressTask&lt;Uint8Array&gt;&gt;): Uint8Array {
}
</code></pre>
<p>The progress task method:</p>
<pre><code>public createProgressTask&lt;T&gt;(total: number, loaded: number, body?: T): ProgressTask&lt;T&gt; {
  if (body) {
    return new ProgressTask&lt;T&gt;(total, loaded, body);
  } else {
    return new ProgressTask&lt;T&gt;(total, loaded);
  }
}
</code></pre>
<p>The progress class:</p>
<pre><code>export class ProgressTask&lt;T&gt; {

  body: T | undefined;
  loaded: number;
  total: number;

  constructor(total: number, loaded: number, body?: T) {
    this.loaded = loaded;
    this.total = total;
    if (body) {
      this.body = body;
    }
  }

  public taskIsComplete(): boolean {
    return this.total &gt; 0 &amp;&amp; this.total === this.loaded;
  }

}
</code></pre>
<p>The <code>rxjs</code> dependency:</p>
<pre><code>stephane@stephane-pc:~/dev/js/projects/angular/musicng$ npm ls rxjs
musicng@0.0.1 /home/stephane/dev/js/projects/angular/musicng
├─┬ @angular-devkit/build-angular@0.1100.2
│ ├─┬ @angular-devkit/architect@0.1100.2
│ │ └── rxjs@6.6.3 deduped
│ ├─┬ @angular-devkit/build-webpack@0.1100.2
│ │ └── rxjs@6.6.3 deduped
│ ├─┬ @angular-devkit/core@11.0.2
│ │ └── rxjs@6.6.3 deduped
│ ├─┬ inquirer@7.3.3
│ │ └── rxjs@6.6.3 deduped
│ └── rxjs@6.6.3 deduped
├─┬ @angular/cli@11.0.2
│ └─┬ @angular-devkit/schematics@11.0.2
│   └── rxjs@6.6.3 deduped
├─┬ @angular/common@11.0.2
│ └── rxjs@6.6.3 deduped
├─┬ @angular/core@11.0.2
│ └── rxjs@6.6.3 deduped
├─┬ @angular/forms@11.0.2
│ └── rxjs@6.6.3 deduped
├─┬ @angular/router@11.0.2
│ └── rxjs@6.6.3 deduped
├─┬ @ngx-translate/core@13.0.0
│ └── rxjs@6.6.3 deduped
├─┬ @ngx-translate/http-loader@6.0.0
│ └── rxjs@6.6.3 deduped
├─┬ @stephaneeybert/lib-core@0.1.58
│ └── rxjs@6.6.3 deduped
├─┬ @stephaneeybert/lib-i18n@0.0.5
│ └── rxjs@6.6.3 deduped
├─┬ @stephaneeybert/lib-pwa@0.1.34
│ └── rxjs@6.6.3 deduped
├─┬ @stephaneeybert/lib-toast@0.0.4
│ └── rxjs@6.6.3 deduped
├─┬ angular-ide@0.9.75
│ └── rxjs@5.0.1
├─┬ angular-in-memory-web-api@0.11.0
│ └── rxjs@6.6.3 deduped
├─┬ codelyzer@6.0.1
│ ├─┬ @angular/core@9.0.0
│ │ └── rxjs@6.6.3 deduped
│ └── rxjs@6.6.3 deduped
└── rxjs@6.6.3
</code></pre>
<p>UPDATE: I could work around the issue with the following:</p>
<pre><code>public progressiveCreateSoundtrackMidi$(soundtrack: Soundtrack): Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; {
  return new Observable((observer$ : Subscriber&lt;ProgressTask&lt;Uint8Array&gt;&gt;) =&gt; {
    this.createSoundtrackMidi(soundtrack, observer$);
    return { unsubscribe() { } };
  });
}

public createSoundtrackMidi(soundtrack: Soundtrack, progressTask$?: Subscriber&lt;ProgressTask&lt;Uint8Array&gt;&gt;): Uint8Array {
}
</code></pre>
","958373","","958373","","2020-11-29 11:39:32","2020-11-29 11:39:32","Missing object properties in an observable return type","<angular><typescript><rxjs><rxjs-observables>","0","2","","","","CC BY-SA 4.0"
"65041205","1","","","2020-11-27 17:08:51","","-2","69","<p>I am working on an Angular project using Firebase FireStore database and I implemented this method to perform a query:</p>
<pre><code>  findArtistBidsAppliedByCurrentWall(bid):Observable&lt;Bid[]&gt; {
    console.log(&quot;findArtistBidsAppliedByCurrentWall() START&quot;)
    return this.db.collection('bids',
        ref=&gt; ref.where(&quot;wallId&quot;, &quot;==&quot;, bid.wallId))
        .get()
        .pipe(
            map(snaps =&gt; {
                console.log(&quot;TEST&quot;);
                const bids = this.convertSnaps&lt;Bid&gt;(snaps);

                return bids;
            })
        )
  }
</code></pre>
<p><strong>NOTE:</strong> I have to use <strong>get()</strong> and not <strong>snapshotChanges()</strong> in order to not listen to changes.</p>
<p>The problem is that when the previous code is excecuted I obtain the following error message into the browser developer tools:</p>
<pre><code>ERROR TypeError: snaps.map is not a function
    convertSnaps notifications.service.ts:185
    findArtistBidsAppliedByCurrentWall notifications.service.ts:159
    RxJS 4
    Angular 6
    RxJS 3
    Angular 16
    RxJS 4
    schedule Angular
    RxJS 4
    Angular 20
    node_modules vendor.js:157356
    node_modules NextJS
    node_modules vendor.js:149711
    node_modules vendor.js:149679
    Ur index.cjs.js:5711
    Us index.cjs.js:11891
    step tslib.es6.js:100
    verb tslib.es6.js:81
    fulfilled tslib.es6.js:71
    Angular 13
        invoke
        run
        scheduleResolveOrReject
        invokeTask
        runTask
        drainMicroTaskQueue
        invokeTask
        invokeTask
        globalZoneAwareCallback
        customScheduleGlobal
        scheduleTask
        scheduleTask
        scheduleEventTask
core.js:6241:19
    Angular 4
    RxJS 5
    Angular 20
    RxJS 12
    Angular 6
    RxJS 3
    Angular 16
    RxJS 4
    schedule Angular
    RxJS 4
</code></pre>
<p>why this error? What is wrong? What am I missing?</p>
","1833945","","","","","2020-11-27 17:42:02","Why this error using Firestore get() method? ERROR TypeError: snaps.map is not a function","<angular><firebase><google-cloud-firestore><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"65060800","1","","","2020-11-29 13:46:05","","0","255","<p>I have an element in a component view:</p>
<pre><code>&lt;div&gt;Progress: {{ progress$ | async }}&lt;/div&gt;
</code></pre>
<p>It is supposed to be updated in a continuous way by a <code>next()</code> call in a <code>subscribe()</code> block:</p>
<pre><code>progress$: BehaviorSubject&lt;number&gt; = new BehaviorSubject(0);
downloadSoundtrack(soundtrack: Soundtrack): void {
  const fileName: string = soundtrack.name + '.' + MIDI_FILE_SUFFIX;
  const progress$: Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; = this.midiService.progressiveCreateSoundtrackMidi$(soundtrack);
  console.log('Created the observable');
  const piper$: Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; = progress$.pipe(
    tap((progressTask: ProgressTask&lt;Uint8Array&gt;) =&gt; {
      this.progress$.next(progressTask.loaded);
      console.log('Loaded: ' + progressTask.loaded);
    })
  );
  this.download$ = this.downloadService.downloadObservableDataAsBlobWithProgressAndSaveInFile(piper$, fileName);
  console.log('Controller method call complete');
}
</code></pre>
<p>When running it, the console log shows:</p>
<pre><code>Created the observable
Controller method call complete
Loaded: 0
Loaded: 1
Loaded: 2
...
Loaded: 591
</code></pre>
<p>However, the element in the view is not updating continuously, but only at the last value, changing from 0 to 591 straight.</p>
<p>I tried adding a <code>this.detectChanges();</code> after the <code>next()</code> call but it didn't help.</p>
<p>I tried wrapping the <code>next()</code> call within an <code>ngZone</code> block but it didn't help.</p>
<p>The sleep method is implemented as:</p>
<pre><code>public sleep(milliseconds: number): void {
  const date = Date.now();
  let currentDate = null;
  do {
    currentDate = Date.now();
  } while (currentDate - date &lt; milliseconds);
}
</code></pre>
<p>On Angular 11.</p>
<p>UPDATE: I created another component method to trigger an <code>interval()</code> observable and that worked. It did show the <code>progress</code> value in the template changing continuously.</p>
<pre><code>testProgress(): void {
  console.log('Called the testProgress method');
  interval(1000)
  .subscribe((value: number) =&gt; {
    this.progressSubject$.next(value);
    this.detectChanges();
    console.log('The progress: ' + value);
  });
}
</code></pre>
<p>UPDATE: I also tried subscribing to the first observable as in:</p>
<pre><code>downloadSoundtrack(soundtrack: Soundtrack): void {
  const fileName: string = soundtrack.name + '.' + MIDI_FILE_SUFFIX;
  const progress$: Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; = this.midiService.progressiveCreateSoundtrackMidi$(soundtrack);
  console.log('Created the observable');
  const piper$: Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; = progress$
  .subscribe((progressTask: ProgressTask&lt;Uint8Array&gt;) =&gt; {
    this.progressSubject$.next(progressTask.loaded);
    this.detectChanges();
    console.log('Loaded: ' + progressTask.loaded);
  });
  console.log('Controller method call complete');
}
</code></pre>
<p>But the progress in the template still didn't update before the last value.</p>
<p>UPDATE: This time I tried to change the way the progress is being produced by the service class. Instead of doing it with a download as in:</p>
<pre><code>public progressiveCreateSoundtrackMidi$(soundtrack: Soundtrack): Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; {
   return new Observable((observer$ : Subscriber&lt;ProgressTask&lt;Uint8Array&gt;&gt;) =&gt; {
     this.createSoundtrackMidi(soundtrack, observer$);
     return { unsubscribe() { } };
   });
}
</code></pre>
<p>I faked it with:</p>
<pre><code>public progressiveCreateSoundtrackMidi$(soundtrack: Soundtrack): Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; {
  return interval(1000)
  .pipe(
    map((value: number) =&gt; {
      return this.downloadService.createProgressTask&lt;Uint8Array&gt;(1000, value);
    })
  );
}
</code></pre>
<p>And this now works fine with the progress being changed and reflected in the template continuously.</p>
<p>There is something fishy in my <code>createSoundtrackMidi</code> service method:</p>
<pre><code>public createSoundtrackMidi(soundtrack: Soundtrack, progressTask$?: Subscriber&lt;ProgressTask&lt;Uint8Array&gt;&gt;): Uint8Array;
</code></pre>
<p>So I faked this above service method with:</p>
<pre><code>public createSoundtrackMidi(soundtrack: Soundtrack, progressTask$?: Subscriber&lt;ProgressTask&lt;Uint8Array&gt;&gt;): Uint8Array {
  const midi: Midi = new Midi();
  if (progressTask$){
    for (let index: number = 0; index &lt; 1000; index++) {
      this.commonService.sleep(10);
      progressTask$.next(this.downloadService.createProgressTask&lt;Uint8Array&gt;(1000, index));
    }
    progressTask$.next(this.downloadService.createProgressTask&lt;Uint8Array&gt;(1000, 1000));
    progressTask$.complete();
  }
  return midi.toArray();
}
</code></pre>
<p>and the issue showed up again.</p>
<p>To see if the method parameter <code>progressTask$?: Subscriber&lt;ProgressTask&lt;Uint8Array&gt;&gt;</code> was updating only a local copy I faked the following service method:</p>
<pre><code>public progressiveCreateSoundtrackMidi$(soundtrack: Soundtrack): Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; {
  return new Observable((observer$ : Subscriber&lt;ProgressTask&lt;Uint8Array&gt;&gt;) =&gt; {
    for (let index: number = 0; index &lt; 1000; index++) {
      this.commonService.sleep(10);
      observer$.next(this.downloadService.createProgressTask&lt;Uint8Array&gt;(1000, index));
    }
    observer$.next(this.downloadService.createProgressTask&lt;Uint8Array&gt;(1000, 1000));
    observer$.complete();
    return { unsubscribe() { } };
  });
}
</code></pre>
<p>and the issue showed up. The method call is not the cause for the issue.</p>
<p>The issue does not show either when using my own <code>interval</code> implementation:</p>
<pre><code>public progressiveCreateSoundtrackMidi$(soundtrack: Soundtrack): Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; {
  const max: number = 200;
  return this.interval(max)
  .pipe(
    map((value: number) =&gt; {
      return this.downloadService.createProgressTask&lt;Uint8Array&gt;(max, value);
    })
  );
}

private interval(period: number): Observable&lt;number&gt; {
  return new Observable((observer$: Subscriber&lt;number&gt;) =&gt; {
    let i = 0;
    const handler = setInterval(() =&gt; observer$.next(i++), period);
    return () =&gt; clearInterval(handler);
  });
}
</code></pre>
<p>Is it because the <code>setInterval()</code> function is un-blocking between each iteration ?</p>
<p>The issue does not show either with:</p>
<pre><code>public progressiveCreateSoundtrackMidi$(soundtrack: Soundtrack): Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; {
  const max: number = 200;

  return new Observable((observer$: Subscriber&lt;ProgressTask&lt;Uint8Array&gt;&gt;) =&gt; {
    let index = 0;
    const handler = setInterval(() =&gt; {
      observer$.next(this.downloadService.createProgressTask&lt;Uint8Array&gt;(max, index));
      index++;
    }, max);
    return () =&gt; clearInterval(handler);
  });
}
</code></pre>
<p>But a loop in a <code>setTimeout()</code> function call shows the issue:</p>
<pre><code>public progressiveCreateSoundtrackMidi$(soundtrack: Soundtrack): Observable&lt;ProgressTask&lt;Uint8Array&gt;&gt; {
  const max: number = 200;

  return new Observable((observer$: Subscriber&lt;ProgressTask&lt;Uint8Array&gt;&gt;) =&gt; {
    const handler = setTimeout(() =&gt; {
      for (let index: number = 0; index &lt; max; index++) {
        this.commonService.sleep(10);
        observer$.next(this.downloadService.createProgressTask&lt;Uint8Array&gt;(max, index));
      }
      observer$.next(this.downloadService.createProgressTask&lt;Uint8Array&gt;(max, max));
      observer$.complete();
    }, max);
    return () =&gt; clearTimeout(handler);
  });
}
</code></pre>
<p>How to un-block between each loop iteration, in the same fashion the <code>setInterval()</code> function is doing ?</p>
","958373","","958373","","2020-12-04 16:51:39","2020-12-04 16:51:39","Detecting change of a BehaviorSubject component member variable updated in a subscribe block?","<angular><rxjs><rxjs-observables>","0","14","0","","","CC BY-SA 4.0"
"65150379","1","","","2020-12-04 20:35:56","","0","25","<p>I want to refactor this to use observables:</p>
<pre><code>    post&lt;T&gt;(
    url: string,
    body: any,
    params?: HttpParams,
    headers?: HttpHeaders
  ): Observable&lt;T&gt; {
    this.isLoading$.next(true);
    const res = this.http
      .post&lt;T&gt;(url, body, { headers, params })
      .pipe(timeout(3000));
    this.isLoading$.next(false);
    return res;
  }
</code></pre>
<p>How can I emit the the isLoading$ observable right after the post returns, but not change the function return type?</p>
","12425532","","1433107","","2020-12-05 09:44:53","2020-12-05 09:44:53","How can I emit subject when observable returns?","<angular><rxjs><observable><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"65174727","1","","","2020-12-07 00:49:34","","1","49","<p>I hope you can help me to understand my problem, I have a problem with RXJS and Angular, I try to avoid that the call of an observable is activated using an if condition but in the execution of my website it is executed even if the condition is false, I have a service (_chatService) that is in charge of making the HTTP requests, the findChatMessage() method is called and it returns me an observable, I have another webSocket service that informs me when I get a notification, within this Observable I have the condition, that allows me to know if the notification I received is for current conversation, and then run the method findChatMessage().</p>
<p>I don't know what I am doing wrong since I am new in Angular
Thank you very much</p>
<pre class=""lang-js prettyprint-override""><code>ngOnInit(): void {
    this._router.paramMap.subscribe(
      res =&gt; {
        if (res.has('idConversation')) {
          var localIdConversation = res.get('idConversation');

          if (typeof localIdConversation === 'string') {
            this._chatService.findChatMessages(localIdConversation, this._authService.getCurrentUsername()).subscribe(
              resp =&gt; {
                if (typeof localIdConversation === 'string') {
                  this.messages = resp;
                  this.setMessageFields(localIdConversation);
                  // update bagde
                  this._webSocketClientService.notificationReceived.next(true);
                }
            });

            this._webSocketClientService.notificationMessage.subscribe(
                notif =&gt; {
                  if (notif.idConversation == localIdConversation) {
                    console.log(&quot;---&gt; &quot; + localIdConversation);
                    console.log(&quot;inside subscribe&quot;);
                    this._chatService.findChatMessage(notif.idChatNotif).subscribe(
                      message =&gt; {
                        this.messages.push(message);
                        this._webSocketClientService.notificationReceived.next(true);
                      }
                    );
                  }
                }
              );
          }
        }
      },
      error =&gt; console.log('something wrong occurred: ' + error)
    );
  }
</code></pre>
<p>The findChatMessage method within the ChatService file</p>
<pre class=""lang-js prettyprint-override""><code>findChatMessage(idMessage:number): Observable&lt;IMessage&gt;{
    const URL: string = environment.url_base + '/messages/' + idMessage;
    return this._http.get&lt;IMessage&gt;(URL);
  }
</code></pre>
","8988361","","","","","2020-12-07 08:05:27","How to control what Observables to run in Angular","<angular><typescript><rxjs><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"65183369","1","65183795","","2020-12-07 14:13:46","","0","41","<p>I have app that opens stream where server pumps SSEs.
I want the loop to run until desired value arrives, then leave the loop and continue.
I've looked at <code>takeWhile</code> operator, but couldn't find a way to implement it. I also don't know how could I <code>unsubscribe</code> and since the stream never completes...</p>
<pre><code>const stream = this.sseService.returnAsObservable();
      for await (const data of eachValueFrom(stream)) {
        console.log(data);
        if (data.jobid === &quot;JOB05879&quot;) {
          this.sseService.stopConnection();
          // how to get out now?
        }
      }
      console.log('we are out');
</code></pre>
","1122667","","","","","2020-12-09 16:27:22","Leave rxjs-for-await loop programatically","<rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"65210592","1","","","2020-12-09 04:21:05","","0","19","<p>I have this method for checking if a firestore document exists:</p>
<pre><code>rating_exists(userId : string, gameId :  string) : Boolean {
        let exists: boolean = false;
        const docRef = this.afs.collection('ratings').doc(`${userId}_${gameId}`).snapshotChanges()
        .subscribe(x =&gt; exists = x.payload.exists);
        return exists;

    }
</code></pre>
<p>but it seems that this method always returns false.</p>
<p>Its necessary for checking if a user has provided a rating for media. If the user has not provided a rating yet, it should create a rating document for that user</p>
<p>in rating component</p>
<pre><code>    ngOnInit(): void {
        if(!this.starsService.rating_exists(this.userId, this.gameId)) {
            console.log(&quot;this happened- conditional dose not work!&quot;);
            this.starsService.setRating(this.userId, this.gameId, 0)
        }
        this.starsService.getGameRating(this.userId, this.gameId)
        .subscribe(doc =&gt; this.stars = doc);    
    }
</code></pre>
<p>I think that I'm misunderstanding how the scope of observable subscriptions work. console log message always prints despite the fact that document exists for the currently signed in user.</p>
","13063790","","","","","2020-12-09 04:21:05","Confusion about observable scope","<angular><google-cloud-firestore><rxjs-observables>","0","2","","","","CC BY-SA 4.0"
"65221614","1","65230719","","2020-12-09 17:12:52","","1","153","<p>I am not so into RxJS and I ahve the following doubt.</p>
<p>Into this an Angular service class I have this method retrieving data from Firebase FireStore database:</p>
<pre><code>async getAllEmployees() { 
    return &lt;Observable&lt;User[]&gt;&gt; this.firestore.collection('users',ref =&gt; ref.where('profileType', '!=', 'admin')).valueChanges();          
  } 
</code></pre>
<p>As you can see it is returning an Observable of <strong>User</strong> object.</p>
<p>where <strong>User</strong> is this interface:</p>
<pre><code>export interface User {
    firstName: string;
    surname: string;   
    completeName: string;  
    email: string;
    photoUrl: string;
    phoneNumber: string;
    companyName: string;
    vatID: string;
    profileType: 'admin' | 'user' | 'unknown';    
    UID: string;    
    approved:boolean;
}
</code></pre>
<p>Now I need to add the <strong>completeName</strong> field (not presented on Firestore, so this field is not retrieved) that is the concatenation of the <strong>firstName</strong> and the <strong>surname</strong> field to each object of the retrieved array of the returned Observable. I am thinking that maybe I can use RxJS map operator to achieve this task. I was trying to do something like this:</p>
<pre><code>return &lt;Observable&lt;Employee[]&gt;&gt; this.firestore.collection('users',ref =&gt; ref.where('isEmployee', '==', true)).valueChanges()
                                              .pipe(map(userObj =&gt; {

                                                        const completeObj = {
                                                          completeName = userObj[&quot;firstName&quot;] + &quot; &quot; + userObj[&quot;surname&quot;],
                                                          ...userObj
                                                        }
                                                        console.log(&quot;completeObj: &quot;, completeObj);
                                                        return userObj;
                                                    }));
</code></pre>
<p>But doing in this way I obtain that it is created the following object (I can see it in the console.log into my Chrome console):</p>
<pre><code>completeObj:  
{0: {…}, completeName: &quot;undefined undefined&quot;}
0: {firstName: &quot;Andrea&quot;, isEmployee: true, socialSecurityCode: &quot;NBLNDRH501O&quot;, password: &quot;XXXXXX&quot;, isAdmin: false, …}
completeName: &quot;undefined undefined&quot;
__proto__: Object
</code></pre>
<p>So basically it seems to me that it is not adding this new calculated field to each object of the array returned as Observable but it is adding to the Observable itself.</p>
<p>Why? What is wrong? What am I missing?  How can I fix it?</p>
","1833945","","","","","2020-12-10 08:12:22","How can I correctly use RxJS to add a new field to each object of an array returned into an Observable?","<angular><typescript><rxjs><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"65249852","1","65250310","","2020-12-11 10:47:39","","0","287","<p>I have a working code to convert my File object to base64:</p>
<pre><code>let reader = new FileReader();
     reader.readAsDataURL(myFile);
     reader.onload = () =&gt; {
         let resultStrOrArrayBuf = reader.result;
         if (!(resultStrOrArrayBuf instanceof ArrayBuffer)) {
            ..do something with resultStrOrArrayBuf
         }
    };
</code></pre>
<p>However I do now have to integrate this part to an existing rxjs chain. In the chain I receive the File object and would like to go on with the base64 result of the conversion. However the conversion is done with the help of the <code>onload</code> event. Is there some way to convert this event to a new observable and pass this to the chain?</p>
","1105488","","4370109","","2020-12-11 13:58:36","2020-12-11 13:58:36","Rxjs chain to convert observable<File> to observable<string> (base64)","<javascript><angular><rxjs><dom-events><rxjs-observables>","2","1","","","","CC BY-SA 4.0"
"65254597","1","","","2020-12-11 15:58:18","","0","252","<p>I am using <a href=""https://github.com/ng-select/ng-select"" rel=""nofollow noreferrer"">ng-select</a> and specifically using typeahead to fetch the list from the server as user types. like this:</p>
<p>defining an observable of Agents list to subscribe to whenever a string is inserted</p>
<pre><code>agents$: Observable&lt;Agent[]&gt;
agentsInput$ = new Subject&lt;string&gt;();
</code></pre>
<p>notice here i am mapping the Agents to a specific desired object:</p>
<pre><code>loadAgents() {
    this.agents$ = concat(
      of([]),
      this.agentsInput$.pipe(
        distinctUntilChanged(),
        tap(() =&gt; this.agentsLoading = true),
        switchMap(term =&gt; this.obexService.searchAgents(term).pipe(
          map(agent =&gt; agent.map(agent =&gt; ({
            id: agent._id,
            name: `${agent.firstName} ${agent.lastName}`
          }))),
          catchError(() =&gt; of([])), // empty the agents list on error
          tap(() =&gt; this.agentsLoading = false)
        ))
      )
    )
  }
</code></pre>
<p>here is the HTML:</p>
<pre><code>&lt;ng-select 
    id=&quot;contact-person&quot; 
    labelForId=&quot;contact-person&quot; 
    [items]=&quot;agents$ | async&quot; 
    bindValue=&quot;id&quot; 
    bindLabel=&quot;name&quot;
    [loading]=&quot;agentsLoading&quot; 
    typeToSearchText=&quot;Please enter 3 or more characters&quot;
    [typeahead]=&quot;agentsInput$&quot; 
    class=&quot;custom&quot; 
    notFoundText=&quot;Agent Not Found&quot;
    formControlName=&quot;contactAgent&quot; 
    placeholder=&quot;Select a contact person&quot;&gt;
  &lt;/ng-select&gt;
</code></pre>
<p>basiclly what I am trying to do is to insert an initial list to agents$, so that to be able to set a default agent on the form control, so I want to turn the agent$ into behaviuor subject</p>
<p>sonmething like this:</p>
<pre><code>agents$: BehaviorSubject&lt;Agent[]&gt; = new BehaviorSubject([{id: '123', name: 'john doe'}])
</code></pre>
<p>Now I have 2 problems:</p>
<p>1- how do I map agents on setting initial value the same way I mapped them in <code>loadAgents()</code> method?</p>
<p>2- The telesense shows the below error when setting the <code>agents$</code> in the <code>loadAgents()</code> method</p>
<blockquote>
<p>Type 'Observable&lt;any[]&gt;' is missing the following properties from type
'BehaviorSubject&lt;Agent[]&gt;': _value, value, getValue, next, and 9
more.ts(2740)</p>
</blockquote>
<p>please advise.</p>
","8056544","","","","","2020-12-11 16:20:58","How to insert an initial value for an async list in an ng-select (Angular 2+, ng-select, and rxjs)","<angular><behaviorsubject><rxjs-observables><angular-ngselect>","1","0","","","","CC BY-SA 4.0"
"65293143","1","","","2020-12-14 16:57:52","","3","359","<p>I have the following code and, for the life of me, can't figure out why the requests don't execute concurrently. I'm still new to RxJS and observables, so any help in improving the code below would be greatly appreciated as well. Basically, I'm making a call to a REST API on the backend to get some data. Then, for every element in that array of data I'm making another request to a different endpoint (hence using the 'forkJoin' operator). All the requests get sent at once, but they seem to execute one after another still instead of concurrently.</p>
<pre><code>this.sites$.subscribe(data =&gt; {

    // data.forEach(element =&gt; {
    //     this.siteCaptureMap[element.id] = new CaptureData();
            
    //     this.sitesService.getCaptureData(element.nameOrNumber, element.owner.name).subscribe(data =&gt; {
    //         this.siteCaptureMap[element.id].count = data.length;
    //     });
    // });

    var obs: Observable&lt;any&gt;[] = [];
    for (var _i = 0; _i &lt; data.length; _i++) {
        this.siteCaptureMap[data[_i].id] = new CaptureData();
        this.siteCaptureMap[data[_i].id].id = _i;
        obs.push(this.sitesService.getCaptureData(data[_i].nameOrNumber, data[_i].owner.name));
    }

    forkJoin(obs).subscribe(results =&gt; {
        for (var _i = 0; _i &lt; results.length; _i++) {
            this.siteCaptureMap[data[_i].id].count = results[_i].length;
        }
    });


    this.dataSource.data = data;
    this.dataSource.filteredData = data;
});
</code></pre>
<p>Again, any help would be greatly appreciated. If I need to clarify anything or provide any additional code snippets, please let me know! Thanks!</p>
","13813314","","","","","2020-12-14 17:54:48","RxJS Observable forkJoin Not Executing in Parallel","<javascript><angular><typescript><rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"65297321","1","","","2020-12-14 22:19:33","","0","45","<p>In my Angular app , and to test some features in HorLigne mode , i need to mock http usefull responses :</p>
<ul>
<li>the 200 OK return containing some data</li>
<li>the 404 KO return with no data</li>
</ul>
<p>Usually i tried this :</p>
<pre><code>@Injectable()
export class VerifService {
  mockedResult = false;
  verifData(mail, uuid) {
    if (this.mockedResult) {
      return ObservaleOf({ status: &quot;OK&quot; }).pipe(delay(3000));
    } else {
      return throwError({ status: 500, message: &quot;not found&quot; }).pipe(
        delay(3000)
      );
    }
  }
}
</code></pre>
<p>After that within my component i m doing this :</p>
<pre><code>this.verifService.verifData(mail, uuid).subscribe(data=&gt;{
  console.log('THIS WORKS')
}, err =&gt; {
  console.log('THIS FAILS')
}
</code></pre>
<p>For the case <strong>mockedResult</strong>  equals true , the successful 200 OK return is working</p>
<p>But for the 404 error return , it's not working</p>
<p>Is there any other good way to mock the <strong>404</strong> <strong>error</strong> <strong>observable</strong> return ?</p>
<p><strong>Suggestions ?</strong></p>
","4957388","","","","","2020-12-15 15:21:09","Angular 9 : rxjs 6 : how to return a manual Observable of Error","<javascript><angular><rxjs><rxjs6><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"65323020","1","65323170","","2020-12-16 12:12:13","","0","74","<p>I am working with Angular 10 and trying to handle multiple API calls using forkJoin. The API calls are defined inside a function where I also need to process the API result and then resolve each promise. I want to achieve the combined result of all these functions to be returned. However, the forkJoin is never resolved. What am I doing wrong. My code is as below:</p>
<pre><code>const promises = [];   
for (let i = 0; i &lt; bulkImportSets.length; i++) {
promises.push(
          this.policyService.importPolicy({files: bulkImportSets[i]}, this.selectedFiles)
      );
}
this.value$ = forkJoin(promises);




  importPolicy( policies, filesMetadata): Observable&lt;any&gt; {

        let result: { data: { items: { data: any[]; result_code: string } } } = null;

        return new Observable( (observer) =&gt; {
            const url = `${COMMON.LEGACY_API_PATH}sep/import/policy`;

            /*
             * This is done this way to send data via multipart/form-data
             * */
            const fd = new FormData();
            fd.append('policies', new Blob([JSON.stringify(policies)], {
                type: 'application/json'
            }));

            this.baseService.postData(url, fd).subscribe(
                (resolve) =&gt; {
                    result = resolve['data'];
                    observer.next(result);
                },
                (error) =&gt; {
                    result = getServiceFailureResponseJson(policies, filesMetadata, error);
                    observer.next(result);
                }
            );
        } );

    }
</code></pre>
<p>In error case the data needs to be transformed using 'getServiceFailureResponseJson' and still resolved.</p>
<p>postData is an http client call method:</p>
<pre><code>postData(url: string, data?: any, params?: any): Observable&lt;import(&quot;@angular/common/http&quot;).HttpEvent&lt;any[]&gt;&gt;;
</code></pre>
","3248320","","11011793","","2020-12-16 12:38:03","2020-12-16 12:38:03","Angular rxjs forkjoin does not resolve array of chained observable","<angular><typescript><rxjs><observable><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"65357160","1","65358093","","2020-12-18 12:33:08","","0","61","<p>Most of the time I am able to avoid nested subscriptions but I'm not sure how to do it with this code:</p>
<pre><code>const appleStuff = obtainAppleStuff();
// observeAll returns Observable&lt;Apple[]&gt;
appleService.observeAll().subscribe(apples =&gt; {
  let apple = apples.find(this.appleFilter);
  if(!apple){
    apple = appleService.create();
    apple.type = &quot;Red&quot;;
    apple.size = 5;
    appleService.update(apple);
    if(apples.length !== 0){
      this.appleService.observeWormsOfApple(apples[0]).subscribe(worms =&gt; {
        appleService.linkWorms(worms, apple);
      });
    }
  }
  this.linkAppleStuff(appleStuff, apple);
});
</code></pre>
<p>Ideally I want to have all side effects either in a tap() or in a single non-nested subscribe(), how do I do this?</p>
","3343983","","","","","2020-12-18 13:41:28","How to avoid nested subscription with logic and side effects","<angular><typescript><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"65359708","1","65361783","","2020-12-18 15:30:17","","1","91","<p>I have the following setup, which, every 3 seconds would make a new HTTP request to a server.</p>
<pre class=""lang-js prettyprint-override""><code>  getData(param1: string): Observable&lt;any&gt; {
    return timer(0, 3000).pipe(
      switchMap(() =&gt; this.http.get(param1))
    );
  }
</code></pre>
<p>If a given request takes more than 3 seconds, the <code>switchMap()</code> (I think) will cancel it and fire off a new one.</p>
<p>Now, I want to make it so that if a request is taking more than 3 seconds it waits for it to complete before firing off another one. Just for context, the idea is that if there's performance issues with the requests, my front-end is not stuck firing off and cancelling requests too early.</p>
<p>I somewhat got this to work with the following:</p>
<pre class=""lang-js prettyprint-override""><code>currentObs: Observable&lt;any&gt;;

getData(param1: string): Observable&lt;any&gt; {
  return timer(0, 3000).pipe(
    throttle(_ =&gt; this.currentObs),
    switchMap(() =&gt; {
      this.currentObs = this.http.get(param1)
      return this.currentObs;
    })
  );
}
</code></pre>
<p>This will keep track of the <code>currentObs</code> which is the observable of the current HTTP request. It then passes it to a <code>throttle()</code> method so that the values from <code>timer()</code> that normally prompt new requests are ignored until the request (<code>currentObs</code>) completes.</p>
<p>This seems to work but it's a bit awkward as I'd need to keep some of the state outside the <code>pipe()</code>. It's also a bit confusing because the throttling is based on an event that happens after it. I've been looking for a way to pass the result of the <code>switchMap()</code> onto the <code>throttle()</code> but first I didn't find one, and second, wouldn't that cause the <code>throttle()</code> to be in the wrong side of the pipe?</p>
<p>Is there a neater way to achieve this using RxJS?</p>
<h1>Edit:</h1>
<p>With @Mrk Sef's answer for a more elegant solution and @kvetis' warning for handling errors, I ended up with the following pipe that will make a request, wait for 3 seconds after a success and then make another request. If the request fails, it's going to wait for 3 seconds and make another request. and then start from the top.</p>
<pre class=""lang-js prettyprint-override""><code>getData(param1: string): Observable&lt;any&gt; {
  return this.http.get(param1).pipe(
    repeatWhen(s =&gt; s.pipe(
      delay(3000)
    )),
    retryWhen(s =&gt; s.pipe(
      delay(3000)
    ))
  );
}
</code></pre>
","1821741","","1821741","","2020-12-21 13:39:15","2020-12-21 13:39:15","Throttle based on a previous Observable","<rxjs><angular-httpclient><rxjs-observables><rxjs-pipeable-operators>","2","1","","","","CC BY-SA 4.0"
"65368293","1","65370906","","2020-12-19 09:15:21","","1","44","<p>To emit any click from child to parent we can make use of @output in the child and in parent html we can listen to that event using the way shown below</p>
<p><strong>&lt;app-item-output (newItemEvent)=&quot;addItem($event)&quot;&gt;</strong></p>
<p>in parent we can write method <strong>addItem($event)</strong> and do our work but is there any way to convert it into stream so that i can use it in combination with other observable.</p>
<p>One way I can think of now is having a subject in parent and then emitting a value like below to create a stream in parent</p>
<pre><code>addItem($event) {
subject.emit()
}
</code></pre>
<p>But if we have any direct way to convert the event emitted from child into observable that would be better.</p>
","9834715","","5535245","","2020-12-19 09:33:14","2020-12-19 14:36:21","Is there any way to convert event emitted by child component using @output into observable stream in parent","<angular><rxjs><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"65391087","1","","","2020-12-21 10:27:10","","0","83","<p>I get address information with a Get request but need to insert position into the objects before returning. In order to do this I need to map over the initial results, run another get request for Geolocation and insert the positions.</p>
<p>I must be out of scope but do not know how to make the loop function before returning the result. As is the else statement (object without zipcode and with no need for a geolocation request) is insert fine but then the final array returns with only this object changed and all others untouched.</p>
<pre><code>    @Get()
    @UseGuards(new AnyUserGuard())
    getParticipantLocation(@Query() params, @User() user): any {
...
        return from(this.getDataService.getQueryResult({ queries, database, values }))
            .pipe(
                take(1),
                map((participantLocation: unknown[]) =&gt; participantLocation[0]),
                retry(2),
                map((zipCodeData: unknown[]) =&gt; {
                    const updatedZipCodeData = [];
                    zipCodeData.map(zipCode =&gt; {
                        if (zipCode['zip_code']) {
                            // The request never runs (or finishes). The loop works fine
                            this.getCoordinates(zipCode['zip_code'])
                                .pipe(
                                    map(location =&gt; {
                                        const updatedZipCode = Object.assign({}, zipCode);
                                        updatedZipCode['coordinates'] = location;
                                        updatedZipCodeData.push(updatedZipCode);
                                    })
                                );
                        } else {
                            const updatedZipCode = Object.assign({}, zipCode);
                            updatedZipCode['zip_code'] = '-1';
                            updatedZipCode['coordinates'] = '0, 0';
                            updatedZipCodeData.push(updatedZipCode);
                        }
                    })
                    console.log('RESULT', updatedZipCodeData);
                    return updatedZipCodeData;
                })
            )

    }

    getCoordinates(zipCode: string): Observable&lt;string&gt; {
        const hereUrl = `https://geocode.search.hereapi.com/v1/geocode?q=${zipCode}+denmark&amp;xxx`;
        return this.httpService.get(hereUrl)
        .pipe(
            take(1),
            map(data =&gt; {
                const locate = data.data.items[0].position;
                return `${locate.lat.toString()}, ${locate.lng.toString()}`;
            }),
            retry(2)
        )
    }
</code></pre>
","9607391","","9607391","","2020-12-24 10:13:42","2020-12-24 10:13:42","NestJS map over get request inside observable","<rxjs><nestjs><rxjs-observables>","0","0","","","","CC BY-SA 4.0"
"65393683","1","","","2020-12-21 13:30:26","","0","62","<p>When dealing with concatMap, how can I abort the execution of observables further down the line <em>and</em> prevent calling the completion handler?<br>
Here is a simple example.</p>
<pre class=""lang-js prettyprint-override""><code>of(...[1, 2, 3]).pipe(
  concatMap(t =&gt; of(t)),
  map(n =&gt; {
    console.log(n);
    if (n === 2) {
      throw new Error('OK, fail here');
    }
  }),
  catchError((e, c) =&gt; of(console.log('Caught ' + e)))
)
  .subscribe(
    {
      complete: () =&gt; console.log('Complete should not be triggered in an error case, but here it is'),
      error: (err: any) =&gt; {
        console.log('I did never trigger, thats ok!');
      }
    });
</code></pre>
<p>A source observable emits 1,2,3 which is piped into concatMap.<br>
There are two possible scenarios: All three observables are emitted without error in this case complete handler should be triggered. Or the other case depicted here: Somewhere down the line there is an error like when n === 2. ConcatMap stops executing the next observable which is <em>perfect</em> but it still triggers the completion handler, which is undesired.</p>
<h1>Actual result</h1>
<pre>1
2
Caught Error: OK, fail here
Complete should not be triggered in an error case, but here it is
</pre>
<h1>Desired result</h1>
<pre>1
2
Caught Error: OK, fail here
</pre>
<p>Any hints? My previous attempt was to throw in the next handler but that turned out to be really bad :/ as it triggered a <code>hostReportError</code></p>
","2416394","","13909768","","2020-12-21 13:33:30","2020-12-21 14:21:50","How to not trigger 'complete' handler when error occurred in concatMap?","<rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"65424254","1","65424503","","2020-12-23 12:24:09","","0","27","<p>So I currently have a subscription which returns teams and inside of teams theres an array which stores users Object. I would like to call another subscription for each of these users.
Heres a view of the team object:</p>
<pre><code>team: {
    teamName: 'blueberries',
    teamMembers: [{UserObject}, {UserObject}]
}
</code></pre>
<p>Heres a look at the userObject:</p>
<pre><code>user: {
    uid: 1,
    uname: 'DPR'
}
</code></pre>
<p>I currently have this code where I subscribe to a getRequest for the team and then tap the team Observable and get the users array and then for each I run a subscription. Heres the code:</p>
<pre><code>this.teamService.getTeam(id)
   .pipe(
       tap(team =&gt; {
          team.teamMembers.forEach((eachUser) =&gt; {this.userService.updateUser(eachUser).subscribe()})
       })
   )
   .subscribe()
</code></pre>
<p>Although it works, I would really like to avoid a subscription within a subscription I have tried doing it with <code>switchMap</code> but it doesnt seem to run the code within the <code>switchMap</code> operator. Heres the code I tried but didn't work:</p>
<pre><code>this.teamService.getTeam(id)
   .pipe(
       tap(team =&gt; {
          team.teamMembers.forEach((eachUser) =&gt; 
          switchMap(() =&gt; {return this.userService.update(eachUser)})
       })
   )
   .subscribe()
</code></pre>
","12949177","","","","","2020-12-23 14:47:08","A way to call a subscription for each value within the subscription value without callback hell","<angular><rxjs><angular2-observables><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"65446887","1","","","2020-12-25 09:31:19","","1","69","<p>How to combine the distinct, switchMap and mergeMap operators, so that when the source emits repeated values (detected by distinct.keySelector), the previous subscription is canceled (as in the switchMap), but if the value is not repeated follow the behavior of mergeMap?</p>
<p>Example:</p>
<pre><code>source = from(1, 2, 1, 2, 3) // 'abcde'
result = source.pipe(delay(), combination() // '--cde'
</code></pre>
<p>I'm currently doing something like:</p>
<pre><code>const activeSubscriptions = new Map();
source$.pipe(
  mergeMap((value) =&gt; {
    const pendingSubscription = activeSubscriptions.get(value);
    if (pendingSubscription) {
      pendingSubscription.unsubscribe();
      activeSubscriptions.delete(value);
    }
    const request$ = new Subject();
    const subscription = this.service.get(value).subscribe({
      complete: () =&gt; request$.complete(),
      error: (err) =&gt; request$.error(err),
      next: (value) =&gt; request$.next(value),
    });
    activeSubscriptions.set(value, subscription);
    return request$;
  })
);
</code></pre>
<p>But looking for a better way to do that.</p>
<p>Thank you in advance</p>
","4233401","","","","","2020-12-26 12:16:14","Cancel repeated subscription in mergeMap","<rxjs><rxjs5><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"65487767","1","","","2020-12-29 05:41:36","","0","76","<p>I'm trying to find an elegant way of handling a scenario on one of our apps, where a task, depending on the filter criteria supplied, can return quite a substantial amount of data. The scenario is uncommon, sure, however, it can, and will happen in the wild.</p>
<p>One scenario we're investigating is splitting the return result into a smaller portions and returning those pockets for display, however, we want to give the user the ability to &quot;cancel&quot; the execution if it takes longer than a certain period of time, for example, 30 seconds.</p>
<p>To handle the subscription cancellation, a simple call to our subscription to unsubscribe, works, however, we're struggling to find an elegant way of 'timing' the execution.</p>
<p>Is there a simple way in rxJS that I can just go <code>myObs.pipe(timeMe()).subscribe((result: MyModel[]) =&gt; {});</code></p>
<p><strong>Update</strong></p>
<p>Forgot to add. We're attempting this with <code>timeoutWith(interval, fallback)</code> as it seems to be the best solution for out scenario, however, I'd like to find out if there is a better way to do this.</p>
","428682","","428682","","2020-12-29 05:51:32","2020-12-29 05:51:32","Measure an observable execution time in rxJS","<rxjs-observables>","0","0","","","","CC BY-SA 4.0"
"65550277","1","65551175","","2021-01-03 13:16:55","","1","49","<p>The context is that of a musical piano. I am interested in catching <strong>key-up</strong> events that occur <strong>when the sustain pedal is not pressed</strong>.</p>
<p>I have these streams:</p>
<pre><code>pedalDown$
pedalUp$
keyUp$
</code></pre>
<p>How can I pipe these together into an observable <code>unsustainedUp$</code> that emits of <code>keyUp$</code> events only while the pedal is not down?</p>
<p>I thought this could work, but <code>unsustainedUp$</code> fires even when the <code>keyUp$</code> comes after a <code>pedalDown$</code> and before a <code>pedalUp$</code>.</p>
<pre><code>unsustainedUp$ = keyUp$.pipe(
    skipUntil(pedalUp$),
    takeUntil(pedalDown$),
    repeat()
)

// once at setup, fire into pedal-up to get this into the correct, normal piano initial state
pedalUp$.next()
</code></pre>
","102181","","","","","2021-01-04 10:08:28","How to create an observable that skips emissions between 2 events","<javascript><rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"65590495","1","65590550","","2021-01-06 05:06:31","","0","32","<p>I have a situation where i need to cancel an previous observable if new observable is returned.
See below</p>
<pre><code>function fooService(timeOut: number): Observable&lt;string&gt; {
    return new Observable(subs =&gt; {
        setTimeout(() =&gt; {
            subs.next(new Date().toTimeString());
        }, timeOut);
    });
}

function barComponent(timeOut: number): void {
    // here it should cancel previous subscription if this function called again
    fooService(timeOut).subscribe(
        time =&gt; console.log(time)
    );
}


barComponent(5000);
barComponent(2000); // i need to cancel last call
</code></pre>
","6789995","","","","","2021-01-06 05:13:49","Cancel previous observable returned from another function","<javascript><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"65630099","1","65630277","","2021-01-08 13:42:13","","0","63","<p>Folks, can anyone explain this behaviour?</p>
<p>This is working:</p>
<pre><code>this.sessionService.current$.subscribe(session =&gt; { console.log('WORKING', session); });
</code></pre>
<p>But this is NOT working:</p>
<pre><code>forkJoin([
      this.sessionService.current$
    ])
      .subscribe(([
        session
      ]) =&gt; {
        console.log('NOT WORKING', session);
...
    
</code></pre>
<p>After a little change got it working:</p>
<pre><code>forkJoin([
      this.sessionService.current$.pipe(take(1))
    ])
      .subscribe(([
        session
      ]) =&gt; {
        console.log('WORKING', session);
...
    
</code></pre>
<p>current$ property in SessionService is defined like this:</p>
<pre><code>private readonly subject$: Subject&lt;Session&gt; = new BehaviorSubject&lt;Session&gt;(null);
public readonly current$: Observable&lt;Session&gt; = this.subject$.asObservable();
</code></pre>
<p>there is then a <code>init()</code> method where I <code>GET</code> data over http and emit to <code>this.subject$</code>;</p>
<p>Thanks a lot for a right direction!</p>
","8244989","","8244989","","2021-01-08 15:50:09","2021-01-08 15:50:09","Angular: Subject behaviour different when using forkJoin","<angular><typescript><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"65660118","1","","","2021-01-11 00:53:32","","0","112","<p>Angular 10, NGRX/Data 10</p>
<p>I have a route guard set up with the intent of loading all of my data before the getting to the page. I'm checking for a token in storage first, if no token - then redirect. If there is a token, check if the user data is loaded (the four dataService calls require user info to load). I want to wait until all four dataService calls are complete before allowing the guard to go to true.</p>
<p>I'm struggling with the Observables and how to wait for them to resolve. Here's what I have in the route guard.</p>
<pre><code>userLoaded$ = this.store.pipe(select(fromState.getLoaded));

canActivate(): Observable&lt;boolean&gt; | boolean {

    if (!this.authService.getToken()) {
      this.router.navigateByUrl('/login');
      return false;
    } else {
      return this.userLoaded$.pipe(
          tap(userLoaded =&gt; {
            if (!userLoaded) {
              this.store.dispatch(new GetUser({id: Number(this.authService.getUserId())}));
            }
          }),
          filter(userLoaded =&gt; !!userLoaded),
          tap( () =&gt; {
              this.typeDataService.getAll();
              this.groupDataService.getAll();
              this.routeDataService.getAll();
              this.officeDataService.getAll();
          })
      );
    }
  }
</code></pre>
<p>I really just don't have a good grasp on observables, pipes and subscriptions.</p>
<p>How do I set up the code to return an observable once all of the dataService calls have loaded the data?</p>
","14949855","","","","","2021-01-13 10:40:06","NGRX/Data angular route guard - help waiting for data to load","<ngrx><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"65689898","1","","","2021-01-12 18:31:08","","2","50","<p>There are two observables that may be emiting together or separately: <code>stream1</code> and <code>stream2</code>.
I need my subscription to fire only if <code>stream2</code> fires less then 1 second after <code>stream1</code> does.
<br>
Any way to achieve that with RxJS?</p>
","10344505","","","","","2021-01-12 22:33:47","RxJS. Combine observables that emit less then 1 second apart","<javascript><rxjs><reactive-programming><rxjs-observables><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"65693517","1","","","2021-01-12 23:22:44","","0","162","<p>I want to dynamically update the value of the notification icon after the user deleted the notification. Now I have a tab-menu style app and I don't know how can I transmit the information object from the service , back to the component where it should update..</p>
<p>I am new to Angular, but this is for a project and I need some quick tutorial if it's possible.</p>
<p><strong>main-service.ts</strong></p>
<pre><code>// function to get all notifications and update;
 getAllNotifications(userID) {
    try {
      return this.http.get(`${this.notificationGet_API}${userID}`, httpOptions);
    }

    catch (err) {
      console.log(&quot;Coudn't load notifications...&quot;)
    }
  }

</code></pre>
<p>Component where the  function is called:</p>
<p><strong>tab4.ts</strong></p>
<pre><code>// notification icon number;
  notificationIconSubject = new BehaviorSubject&lt;any&gt;(null);
  public notificationIcon$: Observable&lt;any&gt; = this.notificationIconSubject.asObservable();
  notificationNumber$: BehaviorSubject&lt;any&gt;;

//notification body;
  notificationSubject = new BehaviorSubject&lt;any&gt;(null);
  notification$: Observable&lt;any&gt; = this.notificationSubject.asObservable();

// not working.. sending this observable to another component ends as 'undefined';
refresh$: Observable&lt;any&gt;;

getNotifications(userID) {

    userID = this.userID;
    console.log(userID);
    this.mainService.getAllNotifications(userID).pipe(takeUntil(this.destroyNotification$)).subscribe((res: any) =&gt; {
      console.log(res.length);

      //getting the length of notification into an observable
      localStorage.setItem(&quot;notification&quot;, JSON.stringify(res.length));
      const getNotifications = localStorage.getItem(&quot;notification&quot;);
      this.notificationIconSubject = new BehaviorSubject(JSON.parse(getNotifications));

      console.log(this.notificationIconSubject)
 
      //subscribing to observable to get data and use in html;
      this.refresh$ = this.notificationIconSubject.asObservable();
      this.refresh$.subscribe((notification: any) =&gt; {
        console.log(notification);
        this.virtualNotification = notification;
        return this.virtualNotification;
      });

      //this is for notification body;
      return this.notificationSubject.next(res.data);
    });
}
</code></pre>
<p>Component where data should update after function started:</p>
<p><strong>tabs.ts</strong></p>
<pre><code>  public notificationIconSubject = new BehaviorSubject&lt;any&gt;(null);
  public notificationIcon$: Observable&lt;any&gt; = this.notificationIconSubject.asObservable();
  notificationNumber$: BehaviorSubject&lt;any&gt;;

constructor(){
  this.notificationIconSubject = new BehaviorSubject(JSON.parse(localStorage.getItem('notification')));
    this.notificationIcon$ = this.notificationIconSubject.asObservable();

if (this.notificationIcon$) {

      this.notificationIcon$.subscribe((notif: any) =&gt; {
        console.log(notif)
        if (notif &gt; 0) {
          this.notificationNumber$ = new BehaviorSubject(notif);
          this.is0 = notif;
          console.log(this.is0)
        }


      });

    }
}

//tabs.html
      &lt;ion-tab-button class=&quot;notification-button&quot; tab=&quot;tab4&quot;&gt;
      &lt;ion-icon class=&quot;notify&quot; name=&quot;notifications-sharp&quot;&gt;
      &lt;/ion-icon&gt;
      &lt;div *ngIf=&quot;is0 &gt; 0&quot; class=&quot;notification-counter&quot;&gt;{{(notificationIcon$) | async}}&lt;/div&gt;
     &lt;/ion-tab-button&gt;
</code></pre>
<p>I don't know logically how I can implement this feature , please any advice?</p>
","14597385","","13302","","2021-01-31 20:03:38","2021-01-31 20:03:38","How to get value of behavior subject and transfer to another component?","<angular><typescript><rxjs-observables>","0","0","","","","CC BY-SA 4.0"
"65693554","1","","","2021-01-12 23:28:13","","-1","62","<p>Property 'interval' does not exist on type 'typeof Observable'. Even though its imported in and I dont know why it wont work. Ive seen some posts about this involving angular 6 but this is angular 11 so I hope someone can help me figure this out.</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { TokenService } from '../../authentication/services/token.service';
import { Router } from '@angular/router';
import { HttpErrorResponse } from '@angular/common/http';
import { AdminService } from '../../authentication/services/admin.service';
import { CrudService } from '../services/crud.service';
import { Observable } from 'rxjs';
import { switchMap, startWith } from 'rxjs/operators';
@Component({
  selector: 'app-admin-dashboard',
  templateUrl: './admin-dashboard.component.html',
  styleUrls: ['./admin-dashboard.component.css'],
})
export class AdminDashboardComponent {
  constructor(
    private _token: TokenService,
    private _router: Router,
    private _admin: AdminService,
    private _crud: CrudService
  ) {}

  adminId: string;
  adminName: string;
  adminEmail: string;
  userCount$: Observable&lt;any&gt;;
  userCount: string;

  ngOnInit(): void {
    this._token.verifyToken().subscribe(
      (res) =&gt; {
        this.adminId = res.admin._id;
        localStorage.setItem('adminid', this.adminId);
        this._admin.getAdminById(this.adminId).subscribe((res) =&gt; {
          this.adminName = res.admin.name;
          this.adminEmail = res.admin.email;
          // this._crud.getUserCount().subscribe((count) =&gt; {
          //   this.userCount$ = count.count;
          // });
          this.userCount$ = Observable.interval(1000)
            .startsWith(0)
            .switchMap(() =&gt; {
              this._crud.getUserCount().subscribe((count) =&gt; {
                this.userCount = count.count;
              });
            });
        });
      },
      (err) =&gt; {
        if (err instanceof HttpErrorResponse) {
          if (err.status === 400) {
            this._router.navigate(['/login']);
          }
        }
      }
    );
  }
}

</code></pre>
","14700925","","","","","2021-01-13 00:20:52","Property 'interval' does not exist on type 'typeof Observable'. Even though its imported","<javascript><angular><rxjs><rxjs6><rxjs-observables>","2","4","","","","CC BY-SA 4.0"
"65710733","1","65711943","","2021-01-13 22:30:45","","0","166","<pre><code>of([1,2,3]).subscribe(console.log)
</code></pre>
<p>prints:<code>[1,2,3]</code></p>
<p>But:</p>
<pre><code>of([1,2,3]).pipe(concatAll()).subscribe(console.log)
</code></pre>
<p>prints:</p>
<pre><code>1
2
3
</code></pre>
<p><strong>Why the above happens?</strong> Why adding <code>concatAll()</code> emits the elements of the array one by one? Isn't this somehow the opposite of what the word concat means?</p>
<p>I feel that <code>concatAll()</code> acts differently depending on the input.</p>
<p>Consider also this:</p>
<pre><code>from([of(1),of(2),of(3)]).pipe(concatAll()).subscribe(console.log)
</code></pre>
<p>It will again print:</p>
<pre><code>1
2
3
</code></pre>
<p>So <code>of([1,2,3]).pipe(concatAll())</code> <strong>==</strong> <code>from([of(1),of(2),of(3)]).pipe(concatAll())</code></p>
<p>But <code>of([1,2,3])</code> <strong>!=</strong> <code>from([of(1),of(2),of(3)])</code> because subscribing to the latter will print:</p>
<pre><code>Observable { _isScalar: false, _subscribe: [Function] }
Observable { _isScalar: false, _subscribe: [Function] }
Observable { _isScalar: false, _subscribe: [Function] }
</code></pre>
<p>The right side of the above equality is pretty clear to me, but where is documented that <code>concatAll()</code> should emit all the values of the array separately, acting like a pipeable <code>from</code>?</p>
","1555615","","","","","2021-01-14 00:55:04","How can of([1,2,3]).pipe(concatAll()) emit 3 values when of([1,2,3]) emits one?","<rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","0","1","","","CC BY-SA 4.0"
"65722201","1","65732545","","2021-01-14 15:46:59","","0","42","<p>With angular 10, in a service I have the method getCurrentUser() that makes an http call to my api to return the current user as observable (with one of the property is &quot;isAdmin:boolean&quot;), and I have this other service where I would like to create the method getAllUsers that would return the list of all users (user[]) also as observable but only if the current user is an admin (user.isAdmin = true). I tried a few stuff with rxjs operators like map, switchMap and flatMap but I can feel that I a am completly mistaken, could you give some hints for this?</p>
<p>Here is what I tried in the second service:</p>
<pre><code>@Injectable({
    providedIn: &quot;root&quot;,
})
export class BackofficeService {

    constructor(private http: HttpClient, private userService: UserService) {}

    public getAllUsers(): Observable&lt;User[]&gt; {
        this.userService.getCurrentUser().pipe(
            map((user: User) =&gt; {
                if (user.roles.includes(&quot;admin&quot;)) {
                    return this.http.get&lt;User[]&gt;(&quot;/api/settings/users/all&quot;);
                } else throw new Error(&quot;User not admin.&quot;);
            })
        );
    }
}
</code></pre>
<p>I also don't know how to manage the return of getAllUsers() since sometimes it won't return anything if user is not admin. With the simple &quot;else throw new Error()&quot; I got a compiler error because I declared that getAllUsers() should return an Observable.</p>
<p>And then in my component I do:</p>
<pre><code>@Component({
    selector: &quot;app-users&quot;,
    templateUrl: &quot;./users.component.html&quot;,
})
export class UsersComponent implements OnInit {
  public usersList: User[];
  constructor(private boService: BackofficeService) {}

    ngOnInit(): void {
    this.boService
      .getAllUsers()
      .subscribe((users?: User[]) =&gt; {
        if(users){
          this.usersList = users;
        }
      })
    }
}
</code></pre>
","5367939","","5367939","","2021-01-14 16:59:10","2021-01-15 08:11:12","How to subscribe (or not!) to an observable depending of the result of another observable","<angular><rxjs-observables>","3","2","","","","CC BY-SA 4.0"
"65739522","1","","","2021-01-15 16:09:45","","0","28","<p>Need help finding a value in an observable array of objects (public rules$: Observable&lt;Rule[]&gt;) from a rule service. When a new rule is created I need to check that a rule with the same label does not already exist. To do that I am trying to find a rule in the array with the same label and return the label. I suppose I don't have to return the label, as if it is found I can just return true and reject/inform user.</p>
<p>Just to test functionality I call the function when the page loads and if label is found I attempt to print to console. print shows {object object} weather I find an object matching or not.</p>
<p>Thanks in advance, any guidance would be appreciated</p>
<p><a href=""https://i.stack.imgur.com/bmiFz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bmiFz.png"" alt=""rule.service.ts"" /></a></p>
<p><a href=""https://i.stack.imgur.com/h4und.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/h4und.png"" alt=""rule.model.ts"" /></a></p>
<p><a href=""https://i.stack.imgur.com/FeiKr.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FeiKr.jpg"" alt=""rule.Component.ts"" /></a></p>
","5914492","","5914492","","2021-01-15 16:22:38","2021-01-15 16:22:38","Get a value from an observable array of objects","<rxjs-observables>","0","0","","","","CC BY-SA 4.0"
"65878765","1","","","2021-01-25 03:53:52","","1","121","<p>I am using a subject in <code>rxjs</code> to pass data from my login component to the user-profile component but what happens is in my login component I call the <code>sendUser</code> method in the login component then in the user-profile component I subscribe to the observable but the currentUserObj value is undefined when I console.log the value. Can someone please help me since I've been trying to fix this for hours? Thanks.</p>
<p><strong>auth.service.ts</strong></p>
<pre><code>  private userSource = new Subject&lt;User&gt;();
  currentUser$ = this.userSource.asObservable();

  sendUser(user: any) {
    this.userSource.next(user);
  }

</code></pre>
<p><strong>login.component.ts</strong></p>
<pre><code>loginUser() {
    this.user = {
      email: this.email,
      password: this.password,
    };
    this._auth.loginUser(this.user).subscribe(
      (res) =&gt; {
        this.token = res.access_token;
        this.user = res.user;
        localStorage.setItem('token', this.token);
        this._auth.sendUser(this.user); // This is where I use the send user function in my auth service
        this._router.navigate(['/profile']);
      },
      (err) =&gt; {
        this.errorMessage = err.message;
      }
    );
  }
</code></pre>
<p><strong>user-profile.component.ts</strong></p>
<pre><code>  constructor(private _auth: AuthService) {}

  currentUserObj: {};

  ngOnInit(): void {
    this._auth.currentUser$.subscribe((user) =&gt; {
      this.currentUserObj = user;
    });
    console.log(this.currentUserObj);
  }
</code></pre>
","14700925","","","user12582716","2021-01-25 09:38:03","2021-01-25 09:52:27","Undefined value for the currentUserObj using Subject in rxjs in angular","<javascript><angular><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"65940720","1","","","2021-01-28 15:59:37","","0","42","<p>I'm implementing a JWT system in my Angular app, and in this case, in an Http Interceptor.</p>
<p>My &quot;issue&quot; is that the code below :</p>
<pre><code>request = request.clone({
        setHeaders: {
          Authorization: `Bearer ${token}`
        }
      });
</code></pre>
<p>is trigerred before :</p>
<pre><code>this.authService.refreshToken(token_refresh).subscribe(
            response =&gt; {
              localStorage.setItem('token', response.token);
              token = response.token;
            }
          );
</code></pre>
<p>Which is a normal behavior due to the asynchronous nature of the subscribe function, but in my case, I need the token in the <code>setHeaders</code> to be up to date, because is takes the older token which is invalid at this point.</p>
<p>I tried to make <code>refreshtoken()</code> return a promise with async await, but it didn't change anything.</p>
<p>Here's the whole code block :</p>
<pre><code> let token = localStorage.getItem('token');
 // if token is not valid or not set
  if ((this.jwtHelper.isTokenExpired(token) || token === null)) {
    if (token_refresh !== null) {
      // if token_refresh exists and is valid
      this.authService.refreshToken(token_refresh).subscribe(
        response =&gt; {
          localStorage.setItem('token', response.token);
          token = response.token;
        }
      );
    } else {
      // if no token_refresh exists or is expired
      this.router.navigate(['/register']);
    }
  }

  // always executed
  request = request.clone({
    setHeaders: {
      Authorization: `Bearer ${token}`
    }
  });
</code></pre>
","7422393","","7422393","","2021-01-28 19:11:50","2021-01-28 19:11:50","Angular - Unable to wait for observable subscribe to finish to execute rest of the code in http interceptor","<javascript><angular><asynchronous><rxjs-observables>","1","2","","2021-01-28 20:04:44","","CC BY-SA 4.0"
"66014594","1","66016036","","2021-02-02 17:23:27","","1","56","<p>I get an array of products with this code</p>
<pre><code> proyecto$:Observable&lt;Proyecto&gt;
 this.proyecto$=this.http.get&lt;ProjectApi&gt;(`${this.urlProyecto}/${this.proyectoId}`)
.pipe(
  map(p =&gt; &lt;Proyecto&gt;{
    id: p.id,
    descripcion: p.name,
    fechaComienzoTrabajos: p.workStartDate,
    fechaHistorico: p.historicoDate,
    fechaFinPlanificacion: p.planningEndDate,
    proyectoCerrado: p.projectClosed,
    faseCerrada: p.phaseClosed,
    tieneHijos: p.tieneHijos
  }),
  tap(data=&gt;console.log('Proyecto: ',JSON.stringify(data))),
  catchError(this.handleError)
);
</code></pre>
<p>But I need now to get the Hours charged in this project in function of its properties:</p>
<ul>
<li>id</li>
<li>fechaComiezoTrabajos</li>
<li>fechaFinPlanificacion</li>
</ul>
<p>That is, I need something like this</p>
<p><a href=""https://i.stack.imgur.com/AzTpH.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/AzTpH.jpg"" alt=""concatMap"" /></a></p>
<p>But I get an error cause concatMap returns an Observable&lt;Horas[]&gt; and proyecto$ is an Observable</p>
<p>If I try this</p>
<pre><code>horas$:Observable&lt;Horas[]&gt;
this.horas$=this.proyecto$=this.http.get&lt;ProjectApi&gt;(`${this.urlProyecto}/${this.proyectoId}`)
.pipe(
  map(p =&gt; &lt;Proyecto&gt;{
    id: p.id,
    descripcion: p.name,
    fechaComienzoTrabajos: p.workStartDate,
    fechaHistorico: p.historicoDate,
    fechaFinPlanificacion: p.planningEndDate,
    proyectoCerrado: p.projectClosed,
    faseCerrada: p.phaseClosed,
    tieneHijos: p.tieneHijos,
  }),
  tap(data=&gt;console.log('Proyecto: ',JSON.stringify(data))),
  concatMap(proyecto=&gt;this.http.get&lt;Horas[]&gt;(`${this.urlProyecto}/fechainicio/${proyecto.fechaComienzoTrabajos}/fechafin/${proyecto.fechaFinPlanificacion}/horas`)),
  catchError(this.handleError)
);
</code></pre>
<p>I get error in both variables</p>
<p>If I try this</p>
<pre><code>this.proyecto$=this.http.get&lt;ProjectApi&gt;(`${this.urlProyecto}/${this.proyectoId}`)
.pipe(
  map(p =&gt; &lt;Proyecto&gt;{
    id: p.id,
    descripcion: p.name,
    fechaComienzoTrabajos: p.workStartDate,
    fechaHistorico: p.historicoDate,
    fechaFinPlanificacion: p.planningEndDate,
    proyectoCerrado: p.projectClosed,
    faseCerrada: p.phaseClosed,
    tieneHijos: p.tieneHijos,
  }),
  tap(data=&gt;console.log('Proyecto: ',JSON.stringify(data))),
  catchError(this.handleError)
);

this.horas$=this.proyecto$
  .pipe(
    concatMap(proyecto=&gt;this.http.get&lt;Horas[]&gt;(`${this.urlProyecto}/fechainicio/${proyecto.fechaComienzoTrabajos}/fechafin/${proyecto.fechaFinPlanificacion}/horas`)),
    tap(data=&gt;console.log('Horas: ',JSON.stringify(data)))
  );
</code></pre>
<p>I get nothing in his.horas$ in fact the http.get it is not carried out</p>
<p>How can I assign the value returned from concatMap in another observable variable?</p>
<p>Thanks</p>
","3367720","","3367720","","2021-02-03 08:05:48","2021-02-03 08:05:48","How to avoid nested subscriptions with concatMap in Angular","<angular><rxjs-observables><concatmap>","1","0","","","","CC BY-SA 4.0"
"66018071","1","","","2021-02-02 21:44:57","","0","83","<p>I have an input search with debounceTime operator, but I want to emit only when the typing event is stopped by the user, in that window of time I will emit the value, if another value is coming it should cancel this new values and waiting for stopped event to emit the new value.</p>
<p>The behavior happened when the I pressed a letter key for a while (one second), after that I erase with backspace emitting the value after pressed not waiting for the new value after backspace event.</p>
<pre><code>  Observable.fromEvent(this.emailRef.nativeElement, 'keyup')
  .map((evt: any) =&gt; evt.target.value)
  .debounceTime(700)        
  .distinctUntilChanged()
   // emit only when the typing is paused for 1000 ms
  .subscribe((text: string) =&gt; this.submit(text));
</code></pre>
<p><a href=""https://stackblitz.com/edit/angular-rxjs-observable-form-input-debounce-qneels"" rel=""nofollow noreferrer"">Link to stackblitz</a></p>
","1399262","","","","","2021-02-02 21:44:57","How to emit value in a window of time when keyup event is paused in rxjs?","<javascript><angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","0","2","","","","CC BY-SA 4.0"
"66050842","1","","","2021-02-04 17:33:59","","1","62","<p>I have a situation where I have an observable, and for each emitted item, I want to create another observable, but ignore that observable's value and instead return the result of the first observable.<br />
For example, if I click a button, I want to track something that happens in another button, only when the first button is toggled on.</p>
<p>I can do this now, sort of, with a hack, by taking the output of the child observable and piping it to a <code>mapTo</code> with the parent's value.  You can see it in this code, which can be played with in a <a href=""https://codesandbox.io/s/rxjs-playground-forked-61tgl?file=/src/index.js"" rel=""nofollow noreferrer"">code sandbox</a>:</p>
<pre class=""lang-js prettyprint-override""><code>import { fromEvent, from } from &quot;rxjs&quot;;
import { mapTo, switchMap, tap, scan  } from &quot;rxjs/operators&quot;;

const buttonA = document.getElementById(&quot;a&quot;);
const buttonB = document.getElementById(&quot;b&quot;);

const textA = document.querySelector('#texta');
const textB = document.querySelector('#textb');

fromEvent(buttonA, 'click').pipe(
  // this toggles active or not.
  scan((active) =&gt; !active, false),
  switchMap(active =&gt; {

    if (active) {
      const buttonBClicks$ = fromEvent(buttonB, 'click');
 
      // here we can observe button b clicks, when button a is toggled on.
      return buttonBClicks$.pipe(
        // count the sum of button b clicks since button a was toggled on.
        scan((count) =&gt; count+1, 0),
        tap(buttonBCount  =&gt; {
          textB.value = `button b count ${buttonBCount}`;
        }),
        // ignore the value of the button b count for the final observable output. 
        mapTo(active)
      )
    } else {
      textB.value = ``;

      return from([active]);
    }
   
  })
).subscribe({
  next: buttonActive =&gt; {
    textA.value = `Button a active: ${buttonActive}`
  }
});
</code></pre>
<p>A couple issues here.  In the case that the button is toggled on, the outer observable only receives a value once the button is clicked.
This <code>mapTo</code> use seems hacky.</p>
<p>Any better ways to do this?</p>
","773210","","","","","2021-03-24 02:49:14","rxjs - how can you create another observable from an observable but ignore its output in the parent observable?","<rxjs><rxjs-observables><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"66060312","1","","","2021-02-05 08:58:09","","1","15","<p>I'm using Angular 9. I have a root NgModule called AppModule which bootstraps the AppComponent that houses the core layout and frame of my app. In AppModule, I also import NotificationComponent which visually displays notifications by subscribing to an observable in NotificationService (that I also import into AppModule) and the NotificationComponent is referenced in the HTML template of the bootstrapped AppComponent.</p>
<p>I then lazy-load ProjectDetailModule which declares the ProjectDetailComponent that too imports the NotificationService so that it can trigger notifications. However, when I trigger notifications using the NotificationService from within the ProjectDetailComponent, the NotificationComponent doesn't update with that notification. Any ideas where I'm going wrong?</p>
<p><strong>app.module.ts:</strong></p>
<pre><code>import { AppComponent } from './app.component';
import { NotificationComponent } from './_shared/notifications/notification.component';
import { NotificationService } from './_shared/notifications/notification.service';
@NgModule({
    declarations: [NotificationComponent],
    imports: [
        RouterModule.forRoot([
            {
                path: 'projects/:id',
                loadChildren: () =&gt; import('./project-detail/project-detail.module').then(m =&gt; m.ProjectDetailModule)
            }
        ])
    ],
    providers: [NotificationService],
    bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>
<p><strong>app.component.html:</strong></p>
<pre><code>&lt;div&gt;
&lt;header&gt;&lt;img src=&quot;assets/logo.png&quot; /&gt;&lt;/header&gt;
&lt;notification&gt;&lt;/notification&gt;
&lt;div&gt;
</code></pre>
<p><strong>project-detail.component.ts:</strong></p>
<pre><code>import { NotificationService } from './../_shared/notifications/notification.service'; 
export class ProjectDetailComponent implements OnInit {
    constructor(private notificationService: NotificationService) {}

    ngOnInit(): void {
        this.notificationService.sendNotification('Project saved');
    }
}
</code></pre>
<p><strong>notification.service.ts:</strong></p>
<pre><code>import { Injectable } from '@angular/core';
import { Observable, Subject } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class NotificationService {
    private subject = new Subject&lt;any&gt;();

    sendNotification(message: string, type: string = null): void {
        this.subject.next({ text: message, type: type });
    }
    
    getNotification(): Observable&lt;any&gt; {
        return this.subject.asObservable();
    }
}
</code></pre>
<p><strong>notification.component.ts:</strong></p>
<pre><code>import { Component, OnDestroy } from '@angular/core';
import { NotificationService } from './notification.service';
import { Subscription } from 'rxjs';

@Component({
  selector: 'notification',
  templateUrl: './notification.component.html',
  styleUrls: ['./notification.component.css']
})

export class NotificationComponent implements OnDestroy {
    public type: string = '';
    public message: any;
    public show: boolean = false;
    public sub: Subscription;

    constructor(
        private notificationService: NotificationService
    ) {
        this.sub = this.notificationService
                        .getNotification()
                        .subscribe(message =&gt; {
                            this.message = message;
                            this.type = message.type;
                            this.show = true;
                        });
    }

    ngOnDestroy() {
        this.sub.unsubscribe();
    }
}
</code></pre>
","5793989","","","","","2021-02-05 08:58:09","Not receiving events from subscribing to observable across modules","<angular><lazy-loading><rxjs-observables>","0","0","","","","CC BY-SA 4.0"
"66068156","1","","","2021-02-05 17:49:38","","0","38","<p>I have a product table with 20 rows. I have to display the product image on each row which I should get from another service. The limitation is the image API takes only one product id at a time to return the image URL. So I have to make 20 API calls to get 20 images.</p>
<p>I am trying to do using the reactive approach and trying to subscribe to the API in the template itself as below</p>
<pre><code>      &lt;div  let-product-data=&quot;getProductImage(1234)| async&quot; &gt;
        
          &lt;img  src=&quot;{{product-data.image}}&quot;&gt;

      &lt;/div&gt;
</code></pre>
<p>TS Code :</p>
<pre><code>      getProductImage(imageId) {
         const url = `${environment.DEV}/product/stockroomInfo`;
         return this.http.post(url, {id:imageId});
      }
     
</code></pre>
<p>But the above code is not working. Can someone help me with what I am making wrong here?</p>
<p>Or this won't work this way? should I go for some other approach. Suggestions, please</p>
","9588631","","9588631","","2021-02-05 17:59:48","2021-02-08 01:00:22","Creating a variable inside angular template and assign data from API in template itself","<angular><rxjs><rxjs6><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"66081014","1","","","2021-02-06 19:28:02","","-2","48","<p>I am working on an Angular application using Firebase FireStore database and I have the following problem trying to use RxJS. I will try to explain you what I am trying to do.</p>
<p>I simply have this service method defined into a service class:</p>
<pre><code>  getPatientAesteticEvaluationData(patientUID): Observable&lt;AestheticEvaluation&gt; {
    return this.firestore.collection('aesthetic-evaluation')
    .doc(patientUID)
    .valueChanges()
    .pipe(
      map(aestheticEvaluation =&gt; !!aestheticEvaluation ? aestheticEvaluation : {}),
      tap(console.log)
    )
  }
</code></pre>
<p>The previous method should retrieve, if exist, data from a FireStore collection returning it as Observable.</p>
<p>Then into the component code I am doing:</p>
<pre><code>  ngOnInit(): void {
    console.log(&quot;AestheticEvaluationComponent INIT&quot;);

    //this.patientAestheticEvaluationData$ = this.patientService.getPatientAesteticEvaluationData(this.patientUID)
    this.patientAestheticEvaluationData$ = this.patientService.getPatientAesteticEvaluationData(this.patientUID)
        .pipe(

          tap(aestheticEvaluationData =&gt; !!aestheticEvaluationData ? this.fillAestheticEvaluationForm(aestheticEvaluationData) : null),
          tap(console.log)
        );

    //this.patientAestheticEvaluationData$.subscribe();
  }
</code></pre>
<p>I am trying to call the previous service method in order to retrieve the returned <strong>Observable</strong> object.
Then I am trying to access to the content of this object in order to call the <strong>fillAestheticEvaluationForm(aestheticEvaluationData)</strong> passing it these data.</p>
<p>At the moment this is the only code in my <strong>fillAestheticEvaluationForm()</strong> method:</p>
<pre><code>  fillAestheticEvaluationForm(aestheticEvaluationData) {
    console.log(&quot;fillAestheticEvaluationForm START !!! aestheticEvaluationData: &quot;, aestheticEvaluationData);

  }
</code></pre>
<p>The problem is that doing in this way this method is never called. I think that I have to subscribe the returned observable but if I try to do in this way:</p>
<pre><code>this.patientAestheticEvaluationData$ = this.patientService.getPatientAesteticEvaluationData(this.patientUID)
    .pipe(

      tap(aestheticEvaluationData =&gt; !!aestheticEvaluationData ? this.fillAestheticEvaluationForm(aestheticEvaluationData) : null),
      tap(console.log)
    ).subscribe();
</code></pre>
<p>I obtain an error on <strong>this.patientAestheticEvaluationData$</strong>:</p>
<pre><code>ERROR in src/app/features/patient/patient-details/aesthetic-evaluation/aesthetic-evaluation.component.ts:24:5 - error TS2740: Type 'Subscription' is missing the following properties from type 'Observable&lt;AestheticEvaluation&gt;': _isScalar, source, operator, lift, and 6 more.

24     this.patientAestheticEvaluationData$ = this.patientService.getPatientAesteticEvaluationData(this.patientUID)
</code></pre>
<p>What is wrong? What am I missing? How can I fix this code?</p>
","1833945","","","","","2021-02-06 19:34:30","Why am I obtaining this error trying to subscribe an Observable after the execution of RxJS tap() operator?","<angular><typescript><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"66103314","1","","","2021-02-08 14:12:20","","0","26","<p>I have a scenario with 3 webservices, say A, B and C.</p>
<p>A and B can be invoked without arguments. C requires parameters deriving from both A and B. For example:</p>
<pre><code>   http.get(&quot;A&quot;).subscribe(x =&gt; console.log(x))
   // prints 'goofy'
   http.get(&quot;B&quot;).subscribe(y =&gt; console.log(y))
   // prints 'mickey'
   http.get(&quot;C?param1=goofy&amp;param2=mickey&quot;).subscribe(z =&gt; console.log(z))
   // prints 'daisy'
</code></pre>
<p>I wonder how to create a single Observable that does the job, and whose subscription return the result from webservice C.</p>
<pre><code>  obs1 = http.get(&quot;A&quot;)
  obs2 = http.get(&quot;B&quot;)
  f3 = (x,y =&gt; http.get(&quot;C?param1=&quot;+x+&quot;&amp;param2=&quot;+y))
  bigObservable = someconcatenationof(obs1, obs2, f3)
</code></pre>
<p>and I would like that</p>
<pre><code>  bigObservable.subscribe(z =&gt; console.log(z))
  // should print &quot;daisy&quot;
</code></pre>
<p>I suppose that this question can be a little bit generalized: A, B, C do not need to be webservices, they can just be some kind of Observable's, where C's constructor requires results from both A and B.</p>
","5116356","","","","","2021-02-08 14:18:43","Feed an observable with two more observables","<javascript><rxjs><angular-httpclient><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"66107307","1","66109723","","2021-02-08 18:29:26","","1","127","<p>I have two observables: cities and addresses.  In my <code>addresses</code> array I have an object with a property <code>city_code</code> which has a value and a property <code>city</code> which is empty.  In <code>cities</code> I have objects with both properties.</p>
<p>How can I transform the data in <code>addresses</code>? I want to get the value for <code>city</code> from the <code>cities</code> array by matching the <code>city_code</code> and put that value into the corresponding object in <code>addresses</code>.</p>
<pre><code>addresses$ = this.store.select(getAddresses);
cities$ = this.citiesFacade.allCities$;

function getAddressesWithCityName() {
   // some code here
}
</code></pre>
<p>Address and City:</p>
<pre><code>export interface Address {
   city_code: string;
   city: string; // in addresses$ this property is empty and I should get it from cities$
}

export interface City{
   city_code: string;
   city: string;
}
</code></pre>
","1798370","","10431574","","2021-02-08 21:21:58","2021-02-08 21:35:26","Transform data from one observable using another observable in angular rxjs","<angular><typescript><rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"66119300","1","66120197","","2021-02-09 12:46:49","","1","40","<p>This is my first angular project, and I'm still not familiar that well with Observables and RxJS.
In my project, at first I want to fetch all notifications with get request. After that, I want to take id of the last notification, so I could send post request to server to mark them all as read.
So the code in service looks like this:</p>
<pre><code> getNotifications(limit: number, page: number): any {
    return this.http
      .get&lt;INotifications&gt;(
        `${API_URL}/notifications?direction=desc&amp;limit=${limit}&amp;order_by=created_at&amp;page=${page}`
      )
      .pipe(
        switchMap((response) =&gt; {
          const id = response.data[0].id;
          return this.markNotificationsAsRead(id);
        })
      );
  }

markNotificationsAsRead(id: number) {
    return this.http.post(`${API_URL}/notifications/${id}/mark_all_as_read`, {
      id,
    });
  }
</code></pre>
<p>I tried with <em>switchMap</em> and <em>mergeMap</em></p>
<p>operators, but I get</p>
<blockquote>
<p>RangeError: Invalid array length</p>
</blockquote>
<p>Code in component:</p>
<pre><code> fetchData() {
    this.notificationsService.getNotifications(this.limit, this.meta?.next_page || 1).subscribe(
      (response) =&gt; {
        this.notifications = [...this.notifications, ...response.data];
        this.meta = response.meta;
        this.isLoading = false;
        // const mostRecentNotification = response.data[0].id;
        // this.markNotificationsAsRead(mostRecentNotification);
      },
      (error) =&gt; {
        this.handleErrors(error);
      }
    );
  }
</code></pre>
<p>Btw: I can make it work, by deleting this commented section in fetchData function, and just returning get request without piping another operator, but I wanted to give it a  try and do it in service.
Any ideas why it wont work?</p>
","13067004","","","","","2021-02-09 13:43:54","Handling two HTTP requests (Angular + RxJS)","<angular><rxjs><rxjs-observables><switchmap><mergemap>","1","12","1","","","CC BY-SA 4.0"
"66130089","1","66130483","","2021-02-10 02:25:34","","3","75","<p>I am writing a service that I intend will store local copies of <code>Place</code> objects and fetch them from a back end only when they are not stored locally. However, I am having trouble implementing this functionality. I could set up my page to call <code>fetchPlace()</code> if the value from <code>place()</code> is <em>undefined</em>, but I intend on keeping <code>fetchPlace()</code> private so that I may later implement a system for checking if a request was made recently so that the server isn't flooded with requests if the user rapidly switches pages.</p>
<p><em>places.service.ts</em></p>
<pre class=""lang-js prettyprint-override""><code>export class PlacesService {
  private _places = new BehaviorSubject&lt;Place[]&gt;([]);
  get places() {
    return this._places.asObservable();
  }

  constructor(private _http: HttpClient) {}

  place(placeId: number): Observable&lt;Place&gt; {
    return this._places.pipe(
      take(1),
      map((places: Place[]) =&gt; {
        console.log(places);
        let place = places.find((place: Place) =&gt; place.id === placeId);

        if (place === undefined) {
          console.log('Time to send a request!');
          this.fetchPlace(placeId).subscribe(
            (fetchedPlace: Place) =&gt; {
              console.log('We got one!');
              place = fetchedPlace;
              console.log(place);
            },
            (error) =&gt; {
              console.error('Looks like a 404.');
            },
          );
        }

        console.log('Okay, returning place now!');
        return place;
      }),
    );
  }

  private fetchPlace(placeId: number): Observable&lt;Place&gt; {
    return this._http
      .get&lt;Place.ResponseBody&gt;(`http://localhost:8000/v1/places/${placeId}/`)
      .pipe(map((response: Place.ResponseBody) =&gt; Place.create(response)));
  }
}
</code></pre>
<p>The problem with the code above is that when the variable <code>place</code> is <em>undefined</em>, the subscription to <code>fetchPlace()</code> gets called asynchronously, so <code>place</code> is returned before the value of <code>place</code> is overwritten by <code>fetchedPlace</code>. I would like some way of returning an observable containing <code>place</code> from the <code>place()</code> function.</p>
<p>For completion's sake, here is how the code above is called, and the console output:</p>
<p><em>place-detail.page.ts</em></p>
<pre class=""lang-js prettyprint-override""><code>ngOnInit() {
  this._route.paramMap.subscribe((paramMap: ParamMap) =&gt; {
    if (!paramMap.has('placeId')) {
      this._navCtrl.navigateBack('/places/discover');
      return;
    }

    const placeId = +paramMap.get('placeId');
    this._placesSub = this._placesSrv.place(placeId).subscribe(
      (place: Place) =&gt; {
        if (place === undefined) {
          console.log('Got here.');
        } else {
          this._isBookable = place.user !== this._authSrv.user;
          this._place = place;
        }
      },
      (error) =&gt; {
        console.error(error);
      }
    );
  });
}
</code></pre>
<p><em>Console</em></p>
<pre><code>Angular is running in development mode. Call enableProdMode() to enable production mode. core.js:26833
Native: tried calling StatusBar.styleDefault, but Cordova is not available. Make sure to include cordova.js or run in a device/simulator common.js:284
Native: tried calling SplashScreen.hide, but Cordova is not available. Make sure to include cordova.js or run in a device/simulator common.js:284
[WDS] Live Reloading enabled. client:52
Array []
places.service.ts:81:16
Time to send a request! places.service.ts:85:18
Okay, returning place now! places.service.ts:98:16
Got here. place-detail.page.ts:75:20
We got one! places.service.ts:88:22
Object { _id: 1, _user: 2, _title: &quot;Manhattan Mansion&quot;, _description: &quot;In the heart of New York City.&quot;, _imgUrl: &quot;https://www.idesignarch.com/wp-content/uploads/New-York-Fifth-Avenue-Mansion_1.jpg&quot;, _price: &quot;149.99&quot;, _availableFrom: Date Fri Dec 31 2021 18:00:00 GMT-0600 (Central Standard Time), _availableTo: Date Sat Dec 30 2023 18:00:00 GMT-0600 (Central Standard Time) }
places.service.ts:90:22
</code></pre>
","2858094","","","","","2021-02-10 04:10:28","How can I return an observable with a value that's in a callback?","<angular><rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"66143095","1","66143236","","2021-02-10 18:44:56","","0","32","<p>As I'm using this technique to get dummy data from <strong>SWAPI</strong>.<br></p>
<pre><code>const httpStarwars$ = createHttpObservables('https://swapi.dev/api/films/');    
fromEvent&lt;any&gt;(this.sTxt.nativeElement,'keypress').pipe(
   map(event =&gt; event.target.value),
   debounceTime(400),
   distinctUntilChanged(),
   switchMap(val =&gt; httpStarwars$.pipe(
      map(res =&gt; Object.values(res[&quot;results&quot;]))
   ))
).subscribe(courses =&gt; console.log(courses));
</code></pre>
<p>Here is the expected result after key press.<br></p>
<pre><code>0: {title: &quot;A New Hope&quot;, episode_id: 4, opening_crawl: &quot;It is a period of civil war.
↵Rebel spaceships, st…er
↵people and restore
↵freedom to the galaxy....&quot;, director: &quot;George Lucas&quot;, producer: &quot;Gary Kurtz, Rick McCallum&quot;, …}
1: {title: &quot;The Empire Strikes Back&quot;, episode_id: 5, opening_crawl: &quot;It is a dark time for the
↵Rebellion. Although the… remote probes into
↵the far reaches of space....&quot;, director: &quot;Irvin Kershner&quot;, producer: &quot;Gary Kurtz, Rick McCallum&quot;, …}
2: {title: &quot;Return of the Jedi&quot;, episode_id: 6, opening_crawl: &quot;Luke Skywalker has returned to
↵his home planet of…
↵struggling to restore freedom
↵to the galaxy...&quot;, director: &quot;Richard Marquand&quot;, producer: &quot;Howard G. Kazanjian, George Lucas, Rick McCallum&quot;, …}
3: {title: &quot;The Phantom Menace&quot;, episode_id: 1, opening_crawl: &quot;Turmoil has engulfed the
↵Galactic Republic. The t…ustice in the
↵galaxy, to settle the conflict....&quot;, director: &quot;George Lucas&quot;, producer: &quot;Rick McCallum&quot;, …}
4: {title: &quot;Attack of the Clones&quot;, episode_id: 2, opening_crawl: &quot;There is unrest in the Galactic
↵Senate. Several t…THE REPUBLIC
↵to assist the overwhelmed
↵Jedi....&quot;, director: &quot;George Lucas&quot;, producer: &quot;Rick McCallum&quot;, …}
5: {title: &quot;Revenge of the Sith&quot;, episode_id: 3, opening_crawl: &quot;War! The Republic is crumbling
↵under attacks by t…ate mission to rescue the
↵captive Chancel
</code></pre>
<p>Now I want to filter the result of the above data below using filters.<br></p>
<pre><code>map(res =&gt; Object.values(res[&quot;results&quot;]))
</code></pre>
<p>What I will filter is <code>title</code>. So far what I used is this technique below.<br></p>
<pre><code>map(res =&gt; Object.values(res[&quot;results&quot;]).filter(j =&gt; j[&quot;title&quot;] == res))
</code></pre>
<p>It gave me empty array like this <code>[]</code>.</p>
<p><strong>UPDATE 1:</strong></p>
<p><a href=""https://i.stack.imgur.com/k6PzK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/k6PzK.png"" alt=""array of object"" /></a></p>
<p><strong>Update 2:</strong>
<a href=""https://i.stack.imgur.com/S13gv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/S13gv.png"" alt=""error"" /></a></p>
","10668235","","10668235","","2021-02-10 19:08:42","2021-02-10 19:28:33","Object.values filter on 'keypress'","<javascript><rxjs><javascript-objects><rxjs6><rxjs-observables>","1","4","","","","CC BY-SA 4.0"
"66155699","1","66164527","","2021-02-11 13:29:05","","0","451","<p>I'm trying to automatize a process of updating some data in the backend of my program.
I'm using my Angular frontend, where I created a function only the master user can access and that should make him login in every administration (tenant), where it will download some objects with some wrong data inside, ask from a google service the right data and update the data in the backend, and do all this operations for each tenant.</p>
<p>I thougt of writing each of this operations as an observable and using concat to do everything in order, but before even finishing getting the right data, which I do inside a tap, it alredy tries to login in the next tenant, so when it actually has the right data he wont be able to upload them to the backend since it will refuse them as from the wrong tenant.</p>
<p>I think this problem is caused by the long operations needed in the tap (and there are some stuff I'll need to do that will require even more time),.</p>
<p>This is my code snippet (without unrelated stuff):</p>
<pre><code>const obsList = [] as Observable&lt;any&gt;[];
this.assignedTenants.forEach(tenant =&gt; {
  const obsList2 = [] as Observable&lt;any&gt;[];
  obsList.push(this.authenticationService.login(new Credentials(usr, psw), tenant.id));
  obsList.push(this.structureService.getStructuresWithWrongAltitude()
    .pipe(tap(structuresReceived =&gt; {
      obsList2 = [] as Observable&lt;any&gt;[];
      if (structuresReceived != null &amp;&amp; structuresReceived.length &gt; 0) {
        structuresReceived.forEach(s =&gt; {
          this.getElevation(new google.maps.LatLng(s.centro.coordinates[0], s.centro.coordinates[1]))
            .then(a =&gt; {
              s.centroAltitudine = a;
              this.obsList2.push(this.structureService.putStructure(s));
            })
            .catch();
        });
      }
  })));
  obsList.push(forkJoin(obsList2)
    .pipe(tap(() =&gt; this.storageService.logout())));
});
concat(...obsList).subscribe();
</code></pre>
<p>As you can see the this code should create and execute 3 observables for each tenant, the first one used to login, the second one to get the wrong data, get the right data and prepare for the third, which will update the data.
As I said, usually when entering the tap from the second observable, the getStructuresWithWrongAltitude one, I can alredy see by using logs that it tries to login to other tenants.</p>
<p>My theory is that as soon as it gets the wrong data it tries to execute the third observable, which is still void, and go to the next tenant, but I dont know how to fix this.</p>
<p>I would need a way for the second observable to not emit until the tap is completed, or another way to prevent the concat to go on before other operations have finished</p>
<p>Thank you for your help</p>
<p>EDIT:</p>
<p>I was able to fix this by making the getElevation (which returns a promise) to an observable list, which would in turn create a new observable list to save the data.</p>
<p>As I said before I need to do something very similar, with the difference that this time the tap will actually have to do a lot of calculations that will take a long time, so I wont be able to use the same fix, as such my question remains: can I make the concat wait until the tap is finished?</p>
<p>EDIT 2 for clarification</p>
<p>As I said in my last edit, that specific example got solved by converting the stuff inside the tap into other observables, but I have almost the same problem with another function</p>
<p>this function needs to find files inside a folder, before uploading them</p>
<pre><code>const folderInput = this.folderInput.nativeElement;
folderInput.onchange = () =&gt; {
  this.filesUploaded = folderInput.files;
  const obsList = [] as any[];

  this.assignedTenants.forEach(tenant =&gt; {
    const obsList2 = [] as Observable&lt;any&gt;[];

    obsList.push(this.authenticationService.login(new Credentials(usr, psw), tenant.id));

    obsList.push(this.fileService.getAll()
      .pipe(
        tap(filesReceived =&gt; {
          if (filesReceived != null &amp;&amp; filesReceived.length &gt; 0) {
            console.log('upload picture: received list of files to update');

            let i = filesReceived?.length;
            filesReceived?.forEach(f =&gt; {
              const pathReceived = (f.originalFilename as string).substr(1).split('\\');

              let found = false;
              let index = -1;
              
              // searching the file in the folder
              //...
              
              if (found) {
                console.log('found a file');
                const selectedFile = this.filesUploaded[index];
                const formData = new FormData();
                formData.append('file', selectedFile, selectedFile.name);
                obsList2.push(this.fileService.updateFile(formData, f.id));
              }
              i--;
            });
            console.log('upload picture: updated obsList2');
            obsList.push(forkJoin(obsList2).subscribe(() =&gt; {
              console.log('upload picture: uploaded pictures');
              this.storageService.logout();
            }));
          }
      }))
    );
  });

  this.loadingIndicatorService.loading$.next(true);
  let counter = obsList.length;
  concat(...obsList).subscribe(() =&gt; {
    counter--;
    console.log('upload pictures: remaining phases: ' + counter);
    if (counter &lt;= 0) {
      this.loadingIndicatorService.loading$.next(false);
  }
});
};
folderInput.click();
</code></pre>
","14762821","","14762821","","2021-02-11 15:37:10","2021-02-12 16:34:48","Angular Rxjs: Have concat wait for a very long tap","<rxjs><concatenation><rxjs-observables><rxjs-pipeable-operators><rxjs-pipe>","2","4","","","","CC BY-SA 4.0"
"66203533","1","66204234","","2021-02-15 06:22:47","","0","58","<p>I have a question regarding to resolving observables in an array. (Using Angular 11)</p>
<p>First, I want to describe the scenario. Let's assume we have a component, with a ag-grid</p>
<p><code>table.component.html</code></p>
<pre><code>    &lt;ag-grid-angular
      [rowData]=&quot;data&quot;
      [columnDefs]=&quot;columnDefs&quot;
    &gt;
    &lt;/ag-grid-angular&gt;

</code></pre>
<p>where rowData is something like</p>
<pre><code>[
  {id:0, user: 'userName1', valueBefore: 1, valueAfter:2},
  {id:1, user: 'userName1', valueBefore: 3, valueAfter:4},
  ...
]

</code></pre>
<p>Nothing fancy yet - however, the ids of <code>valueBefore</code> and <code>valueAfter</code> need to be resolved to their names. For that, a http request must be done, e.g. <code>HTTP GET /name/1</code> which returns <code>{id:1, name: 'one'}</code></p>
<p>Unfortunately, I don't see a nice way to do it.</p>
<p>I see a solution like fetching all the names first. Then, update the <code>rowData</code> object in one brush so the table is only rerendered once.
But then I'd have to maintain an array of <code>id/name</code> pairs which I don't like.</p>
<p>I don't know if I'm missing some features that I could use here or so.</p>
<p>Do you have an idea? How would you solve that problem?</p>
<p>Thanks!</p>
","15211609","","","","","2021-02-15 07:40:12","Resolve objects in array from observables","<angular><rxjs><frontend><ag-grid><rxjs-observables>","1","2","1","","","CC BY-SA 4.0"
"66243990","1","66244858","","2021-02-17 14:31:30","","0","63","<p>My first observable returns an array of Persons. I want to update each person of that array with a list of clients from second observable. How do I do that? So far I have this:</p>
<pre><code>const json: Person[] = [new Person('Alice'), new Person('Bob')];

const resultsObservable = new Observable&lt;string[]&gt;(subscriber =&gt; {

  setTimeout(() =&gt; {
    subscriber.next(['Client1', 'Client2', 'Client3']);
    subscriber.complete();
  }, 1000);
});

of(json).pipe(
  switchMap( dataArray =&gt; {
    return from(dataArray);
  }),
  map((x: Person) =&gt; {
    resultsObservable.subscribe(r =&gt; {
      x.clients = r;
    });
    return x;
  }),
).subscribe(value =&gt; {
    console.log(value);
});
</code></pre>
<p>}</p>
<p>Person:</p>
<pre><code>export class Person{
  name: string;
  clients?: string[];

  constructor(name: string) {
    this.name = name;
  }
}
</code></pre>
<p>But the problem is that return happens before the values are set, so at the end value of person.clients is undefined. How do I fix this? Or what is a better way to achieve what I'm trying to do?</p>
","1328889","","","","","2021-02-17 15:18:55","rxjs: subscribing to observable in map","<rxjs><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"66251354","1","","","2021-02-17 23:17:37","","3","212","<p>I have an Angular service with an exposed observable that I'm trying to marble test with the rxjs TestScheduler.  A method on the service controls the value the observable emits, using a BehaviorSubject as the source.  Here's a really simple example:</p>
<pre><code>import { Injectable } from &quot;@angular/core&quot;;
import { Observable } from &quot;rxjs&quot;;
import { BehaviorSubject } from &quot;rxjs&quot;;

@Injectable()
export class MyService {
  private _isVisibleSubject: BehaviorSubject&lt;boolean&gt; = new BehaviorSubject&lt;
    boolean
  &gt;(true);

  isVisible$: Observable&lt;boolean&gt; = this._isVisibleSubject.asObservable();

  constructor() {}

  toggleVisibility() {
    this._isVisibleSubject.next(!this._isVisibleSubject.value);
  }
}
</code></pre>
<p>A simple unit test for MyService.  I want to test 2 conditions:</p>
<ol>
<li>The isVisible$ observable starts with true</li>
<li>When toggleVisibility is called twice, isVisible$ has 3 values, true, false, and back to true</li>
</ol>
<p>Here's the test class</p>
<pre><code>import { TestBed } from '@angular/core/testing';
import { TestScheduler } from 'rxjs/testing';

import { MyService } from './my.service';

describe('MyService ', () =&gt; {

  let service: MyService ;
  const testScheduler: TestScheduler = new TestScheduler((actual, expected) =&gt; {
    expect(actual).toEqual(expected);
  });

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({ providers: [MyService] });
    service = TestBed.inject(MyService);
  });

  it('Should start out visible', () =&gt; {

    // This one is easy enough, it starts out visible and nothing else happens

    testScheduler.run((helpers) =&gt; {

      const { expectObservable } = helpers;

      const values: {[key: string]: boolean} = {'a': true};
      const expected = 'a';

      expectObservable(service.isVisible$).toBe(expected, values);
    });


  it('Should toggle visibility back and forth', () =&gt; {

    testScheduler.run((helpers) =&gt; {

      const { expectObservable } = helpers;

      const values: {[key: string]: boolean} = {'a': true, 'b': false};
      const expected = 'aba';  // I've also tried with various frames between, eg '-a-b-a'

      service.toggleVisibility();
      service.toggleVisibility();

      expectObservable(service.isVisible$).toBe(expected, values);
    });
  });
</code></pre>
<p>When I run this, the first test passes, but the second fails with an error like <code>Expected $.length = 1 to equal 3.</code>  I have verified that the value actually changes by running a test like:</p>
<pre><code>    testScheduler.run((helpers) =&gt; {

      const { expectObservable } = helpers;

      const values: {[key: string]: boolean} = {'b': false};
      const expected = 'b';

      service.toggleVisibility();

      expectObservable(service.isVisible$).toBe(expected, values);
    });
</code></pre>
<p>I'm assuming the issue is that service.isVisible$ isn't subscribed to until expectObservable() is called, so the previous values are lost.  I looked through the <a href=""https://rxjs-dev.firebaseapp.com/guide/testing/marble-testing"" rel=""nofollow noreferrer"">rxjs documentation on marble testing</a> but can't figure this out.</p>
<p>I realize I could just set up a subscription manually to the isVisible$ observable when the test starts, and verify state along the way as I make changes, but that doesn't feel as nice as using the marble testing.</p>
<p>Is what I want to do possible?</p>
","91856","","91856","","2021-02-18 01:02:13","2021-02-18 13:19:39","Marble testing rxjs observable on an angular service","<angular><unit-testing><rxjs><rxjs-observables>","1","4","","","","CC BY-SA 4.0"
"66263164","1","","","2021-02-18 15:36:44","","1","38","<p>I have seen and tried a lot of other threads describing the same issue, but couldn't find the solution. I am a beginner in angular technology. I am using angular 11. I am trying to refresh the JWT token in the HttpInterceptor class</p>
<pre><code>this.loginService.checkRefreshToken(this.refreshtoke).pipe(
switchMap((tokenResponse: any) =&gt; {
          if (tokenResponse) {
            localStorage.setItem('authToken', tokenResponse.Token)
            localStorage.setItem('refreshToken', tokenResponse.RefreshToken)
            this.tokenSubject.next(tokenResponse);
            console.log('token refreshed');
            return next.handle(this.attachAuthToken(request));
          }
          else return &lt;any&gt;this.loginService.LogOutUser();
        })
      );
</code></pre>
<p>The above is my interceptor class calling login service</p>
<pre><code>checkRefreshToken(data : Irefreshtoken) : Observable&lt;any&gt; {
        var body = JSON.stringify(data)
    const httpOptions = {
      headers: new HttpHeaders({
          'Content-Type': 'application/json',
          'Authorization': 'my-auth-token'
      }),
        
    };

    const postURL = this.constants.API_ENDPOINT + this.constants.CheckRefreshToken;

    return this.http.post&lt;any&gt;(postURL,data,httpOptions)
        .pipe(
            tap((result: any) =&gt; {
            localStorage.setItem('authToken', result.Token)
            localStorage.setItem('refreshToken', result.RefreshToken)
        })
    );
</code></pre>
<p>This is my login service function</p>
<pre><code>[HttpPost]
        [Route(&quot;CheckRefreshToken&quot;)]
        public async Task&lt;IActionResult&gt; CheckRefreshToken(RefreshToken data)
</code></pre>
<p>This is my controller method</p>
<p>The post call is not hitting the back end and is always ending up with error</p>
<pre><code>ERROR TypeError: You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
    at subscribeTo (subscribeTo.js:27)
    at innerSubscribe (innerSubscribe.js:69)
    at CatchSubscriber.error (catchError.js:36)
    at XMLHttpRequest.onLoad (http.js:1700)
    at ZoneDelegate.invokeTask (zone-evergreen.js:402)
    at Object.onInvokeTask (core.js:28499)
    at ZoneDelegate.invokeTask (zone-evergreen.js:401)
    at Zone.runTask (zone-evergreen.js:174)
    at ZoneTask.invokeTask [as invoke] (zone-evergreen.js:483)
    at invokeTask (zone-evergreen.js:1596)
</code></pre>
<p>I know that this is a general error in angular. Any help will be much appreciated. Correct me if I am wrong somewhere. These codes were copied from tutorial codes</p>
<p>Thanks for your help</p>
","10325225","","","","","2021-02-18 15:47:27","You provided 'undefined' where a stream was expected. Error in HttpInterceptor","<angular><rxjs><angular-httpclient><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"66277643","1","66277918","","2021-02-19 12:32:12","","1","65","<p>I made a service that gets some userdata from a remote source. The service a method for getting multiple users, and one for getting a specific user.
The observables returned from the two methonds get .pipe(ed) thru a map() to be able to mutate the user-objects before they get consumed.</p>
<p>What I want is to only define the mutators once, for both the multiple users stream and the single users stream, but I run into scope problems with my current approach.</p>
<p>Be aware that I call users &quot;heroes&quot;. This is a design aspect.
Following are the corresponding methods from my HeroService class:</p>
<pre><code>export class HeroService {
  // [...]

  getHeroes(): Observable&lt;Hero[]&gt; {
    return this.http.get&lt;Hero[]&gt;(this.heroesUrl).pipe(
      map((heroes: Hero[]) =&gt; this.mutateHeroes(heroes, this.addSkillsToHero)),
      map((heroes: Hero[]) =&gt; this.mutateHeroes(heroes, this.splitName))
    );
  }

  getHero(id): Observable&lt;Hero&gt; {
    return this.http.get&lt;Hero&gt;(this.heroesUrl + &quot;/&quot; + id).pipe(
      map((hero: Hero) =&gt; this.addSkillsToHero(hero)),
      map((hero: Hero) =&gt; this.splitName(hero))
    );
  }

  private mutateHeroes(heroes: Hero[], mutator) {
    heroes.forEach((hero: Hero) =&gt; {
      hero = mutator(hero);
    });
    return heroes;
  }

  private splitName(hero: Hero) {
    let heroNames: string[] = hero.name.split(&quot; &quot;);

    hero.firstname = heroNames.splice(0, 1).join(&quot; &quot;);
    hero.lastname = heroNames.splice(heroNames.length - 1, 1).join(&quot; &quot;);
    hero.middlename = heroNames.join(&quot; &quot;);

    return hero;
  }

  private addSkillsToHero(hero: Hero) {
    hero.skills = this.getSkills(Math.ceil(Math.random() * 10));
    return hero;
  }

  private getSkills(count: number): string[] {
    let skills: string[] = [];
    let i;

    for (i = 0; i &lt; count; i++) {
      skills.push(this.getRandomSkill());
    }

    return skills;
  }

  private getRandomSkill(): string {
    return SKILL_TAGS[Math.floor(Math.random() * SKILL_TAGS.length)];
  }
  // [...]
}
</code></pre>
<p>The catchError() of the Observable(s) return: <code>Cannot read property 'getSkills' of undefined</code>
I am suspecting that the mutator does not get called inside the class scope, and cant be found therefore.</p>
<p>How would I do such a thing in JS?</p>
<p>The whole project can be inspected at:</p>
<ul>
<li><a href=""https://github.com/maxbethke/myFirstAngularApp"" rel=""nofollow noreferrer"">https://github.com/maxbethke/myFirstAngularApp</a></li>
<li><a href=""https://stackblitz.com/edit/angular-ivy-rfghml"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-ivy-rfghml</a></li>
</ul>
","5641300","","","","","2021-02-19 21:00:49","Mutating a RxJS observable with variable mutators - Angular","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"66288388","1","66290173","","2021-02-20 05:38:55","","0","46","<p>Hi I have some class objects to POST and I need to store the result back into them, e.g.:</p>
<pre><code>class Bid {
    price: number;
    result?: string;
}
const bids: Bid[] = [{price: 10},{price:20}];
for (const bid of bids) {
    http.post(bid).subscribe(
        r =&gt; bid.result = r,
        e =&gt; bid.result = &quot;error:&quot; + e
    );
}
</code></pre>
<p>So far so good, but now I want to be notified when all POSTs return, as if I am forkjoining all the POSTs and subscribe to that, then do something when they all complete.</p>
<p>Different from forkjoin is I need to do error handling in each POST subscription.</p>
<p>I wonder how that can be done as I also need to subscribe to each POST to store the result in each corresponding source class object.</p>
","1589188","","","","","2021-02-20 11:00:57","Rxjs notify when all http requests finish with error handling for each request","<typescript><rxjs><subscription><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"66289100","1","","","2021-02-20 07:30:25","","0","48","<p>I have an observable which contains an array of object arrays. For example the pseudocode below</p>
<pre><code>observable = Observable([[object1, object2], [object3, object4],[object5], [object6]]])
</code></pre>
<p>Now, I want to map through the arrays and check if object.name === 'something' and return first occurrence. If no object in a list match, then return undefined. From each array only one object will be returned. So the output will be like <code>Observable([object2, object3, undefined, object6])</code>. How can I do this with rxjs operator?</p>
","8274639","","","","","2021-02-20 22:37:30","Rxjs operator: filter array of array","<filter><rxjs><rxjs-observables>","2","1","","","","CC BY-SA 4.0"
"66311923","1","66312238","","2021-02-22 07:58:28","","0","61","<p>I want to find string sequence with rxjs</p>
<p>for example</p>
<p>Target string: <code>01234010</code></p>
<p>Match stringe: <code>01</code></p>
<p>answer = 2</p>
<p>I have a solution with using javascript</p>
<pre><code>let index = 0;
while (true) {
  let foundIndex = targetSequence.indexOf(matchSequence, index);
  if (foundIndex == -1) break;

  index = foundIndex + 1;
}
</code></pre>
<p>but the problem is that I have to use rxjs with those skeleton code</p>
<pre><code>import { from, Observable } from &quot;rxjs&quot;;
const targetSequence = `01234010`;
const matchSequence = &quot;01&quot;;

const _target = from(targetSequence);
const _output: Observable&lt;number&gt; = _target.pipe(
  // here is your code
);

_output.subscribe({
    next: val =&gt; console.log(`count : ${val}`)
  });
</code></pre>
<p>do you guys have any idea?</p>
","12905645","","","","","2021-02-22 08:25:22","I want to find string sequence with rxjs","<javascript><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"66318339","1","66318546","","2021-02-22 15:12:28","","0","98","<p><a href=""https://i.stack.imgur.com/kch2t.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kch2t.png"" alt=""enter image description here"" /></a></p>
<p><strong>Above is the structure of json data.</strong></p>
<p><a href=""https://i.stack.imgur.com/vr6q9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vr6q9.png"" alt=""enter image description here"" /></a></p>
<p><strong>Above is the code I wrote to fetch &quot;AllTranscations&quot; array for particular user.</strong></p>
<p>Can someone please help me with what logic I'm putting wrong in getAllTansactionsByUser().</p>
","12699059","","","","","2021-02-22 15:35:48","How to fetch data from json file using angular HttpClient service using pipe and filter?","<json><angular><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"66386331","1","66387980","","2021-02-26 13:04:24","","0","378","<p>I am a novice with <strong>Rxjs</strong>, I'm trying to do a request to my API with limits passed in parameters.
My problem is sometimes the returned result is empty for some reasons. The thing I need to do is retry this API call with updated parameters (skip param)</p>
<pre><code>pollService.getPoll$(skip, limit).subscribe((pollList) =&gt; {        
    doStuff;
},
(error) =&gt; {
    doStuff;
});
</code></pre>
<p>I read some topics about the <strong>RetryWhen</strong> RXJS function but it is about errors when the request fail and you want to retry the same one but I ve no errors and I don't want to retry the same request, I also saw topics about <strong>Replay</strong> function but it is not very clear to me.</p>
<p>Can someone explain me what to do here please !!</p>
<p>Thanks</p>
<p>Alex</p>
","14321357","","6139527","","2021-02-26 13:48:56","2021-02-28 10:20:00","Rxjs : Retry http call with updated parameters if no results","<javascript><angular><rxjs><rxjs-observables>","2","4","","","","CC BY-SA 4.0"
"66405627","1","66406485","","2021-02-28 03:46:13","","0","64","<p>I have an array of <code>inputIds</code> where I am doing a map that returns a name and value object. Inside the map, I am calling <code>this.inputService.getInputFieldObject</code> which returns an <code>Observable&lt;InputValue&gt;</code>. How do I return the value of the subscription instead of returning an array of subscription values? So I could have attributes returned as an array with only name and value.</p>
<pre><code>const attributes = inputIds.map((attributeName: string) =&gt; {
  // this.inputService.getInputFieldObject returns Observable&lt;InputValue&gt;

  const inputSubscription = this.inputService.getInputFieldObject(attributeName).subscribe((val) =&gt; val.value)

  return {
    name: attributeName,
    value: inputSubscription, // is there a getValue method to get value of subscription?
  };
});
</code></pre>
","5871609","","","","","2021-02-28 06:49:55","RXJS - return observable value when doing a map","<javascript><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"66408615","1","","","2021-02-28 11:34:02","","0","42","<p>I decided that I needed to improve my Angular app by actually testing the code before it got deployed. I have a C#/.Net background and I know my way around unit testing in that context.</p>
<p>Most of the unit tests I've written so far for my Angular app have been relatively straightforward, but testing an observable subject has become a stumbling block.</p>
<p>The code I'm writing tests for, consists of the following:</p>
<ul>
<li>A service that fetches news items (JSON) from a .Net App running in Azure</li>
<li>A component that uses the above</li>
</ul>
<p>The service retrieves news items using an HTTP GET request and updates an observable subject, the component subscribes to the subject and processes the JSON as it is offered by the subject.</p>
<p>The issue that I run into is testing the function that subscribes to the subject from the service and hands off the processing to another function.</p>
<p>Here's the code for the service:</p>
<pre><code>export class NewsService {

  userObject!: UserSettings;
  localeId = 'da';
  data: any;

  public newsFeed!: News[];
  public newsFeedSubject = new Subject&lt;any&gt;();
  public newsFeedTimer = new Subscription();

  constructor(private http: HttpClient) {

    this.newsFeedTimer = this.timerSubscription();
    console.log('constructor called');
  }

  public timerSubscription(): Subscription {
    return timer(globalConstants.interval10Secs, globalConstants.interval2Hours).subscribe(() =&gt; {
      this.updateNewsFeedsSubject();
    });
  }

  public updateNewsFeedsSubject(): void {
    console.log(`Calling newsfeed service`);

    this.getNewsFeed(this.localeId).subscribe(newsFeed =&gt; {
      this.newsFeedSubject.next(newsFeed);

      console.log('NewsFeedTimer updated, newsfeed updated');
    });
  }

  public getNewsFeed(locale: string): Observable&lt;News[]&gt; {
    return this.http.get&lt;News[]&gt;(`${environment.baseURL}/${environment.newsServiceUrl}?locale=${this.localeId}`).pipe(
      tap(data =&gt; console.log('NewsFeed Items retrieved: ', data)),
      tap(() =&gt; console.log('getNewsFeed: HTTP Request executed'))
    );
  }
}
</code></pre>
<p>and here's the code for the component:</p>
<pre><code>export class HomeComponent implements OnInit {

  // Newsfeed service
  public newsFeed!: News[];

  constructor(private newsFeedService: NewsService) { }

  ngOnInit(): void {

    this.newsFeedServiceSubscribe();
  }

  public newsFeedServiceSubscribe(): void {
    this.newsFeedService.newsFeedSubject.subscribe(newsFeed =&gt; {
      this.updateNewsFeed(newsFeed);
      console.log('newsFeedServiceSubscribe function has been called');
    });
  }

  public updateNewsFeed(newsFeed: any): void {
    this.newsFeed = newsFeed;
    console.log('updateNewsFeed function has been called');
    console.log(newsFeed);
  }
}
</code></pre>
<p>And finally my (probably botched) attempt to test the newsFeedServiceSubscribe function:</p>
<pre><code>  it('#newsFeedServiceSubscribe should call on the subscribe function on the updateNewsFeed subject', fakeAsync(() =&gt; {
    const spyNewsFeedSubjectSubj = spyOn(newsService.newsFeedSubject, 'subscribe');    
    spyOn(component, 'updateNewsFeed');
    
    expect(spyNewsFeedSubjectSubj.calls.any()).toBe(false,'subject should not have been called');
    expect(component.updateNewsFeed).toHaveBeenCalledTimes(0);

    component.newsFeedServiceSubscribe();
    fixture.detectChanges();
    
    newsService.newsFeedSubject.next(mockNewsfeedTestData);
    fixture.detectChanges();

    expect(spyNewsFeedSubjectSubj.calls.any()).toBe(true,'subject should have been called');
    expect(component.updateNewsFeed).toHaveBeenCalledTimes(1);
  }));
</code></pre>
<p>The actual code runs just fine the news items are &quot;returned&quot; from the subject and processed just fine, but I just can't seem to get the test right. I would be expecting that the subject (in the service) is updated when I call the &quot;next&quot; method on the subject and I would then expect the subscription in the newsFeedServiceSubscribe function to actually call the updateNewsFeed function in the component.</p>
<p>Unfortunately, that doesn't seem to work. How do I actually test that the subscription on the subject returns data and the updateNewsFeed is called?</p>
<p>Thanks,
Bjarne</p>
","6130423","","","","","2021-03-01 04:02:22","Testing an a observable subject from a backend service","<angular><unit-testing><jasmine><karma-jasmine><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"66415607","1","","","2021-03-01 01:37:26","","2","127","<p>Using Data/Action Streams via RxJS, I want to return/pass an error if a user inputs an invalid bay number. My code currently will return a bay object if it matches the number that the user inputs, <strong>BUT I can't figure out how to throw an error if the user inputs an invalid bay number that doesn't exist in my list of bays</strong></p>
<ol>
<li>In order for me to share data amongst multiple components/pages, I've done most of my stuff in the BayService class:</li>
</ol>
<pre><code>  private baysUrl = 'api/bays';

  bays$ = this.http.get&lt;Bay[]&gt;(this.baysUrl)
    .pipe(
      tap(data =&gt; console.log('Bays: ', JSON.stringify(data))),
      catchError(this.handleError)
    );

  /*--------------------------------------------------------------*/
  // Grab A Single Bay
  private baySelectedSubject = new BehaviorSubject&lt;number&gt;(0);
  baySelectedAction$ = this.baySelectedSubject.asObservable();

  selectedBay$ = combineLatest([
    this.bays$,
    this.baySelectedAction$
  ])
    .pipe(
      map(([bays, selectedBayNumber]) =&gt;
        bays.find(bay =&gt; bay.bayCode === selectedBayNumber)
      ),
    );

  selectedBayChanged(selectedBayNumber: number): void {
    this.baySelectedSubject.next(selectedBayNumber);
  }
</code></pre>
<ol start=""2"">
<li>I created an Action stream by making a BehaviorSubject. Then I created a method to emit a value onto my Action stream. I then call this method in the <code>bay.page.ts</code> where I pass the input parameter and then emit it to my Data stream.</li>
<li>I then combine my data stream and my action stream and then return a single bay object that matches the value from my action Stream.</li>
<li><strong>ISSUE</strong>: SO, I can already emit the value from a users input into my observable and return the bay object based on the number like so:</li>
</ol>
<pre><code>onSubmit() {
     this.bayDoesNotExistError = false;
      this.bayService.selectedBayChanged(this.bayForm.get('bayStart').value);
      this.navCtrl.navigateForward([`/results/`]);
      this.bayForm.reset();
    }
</code></pre>
<p>, but <strong>HOW</strong> do I handle an Invalid number? For example, How, when a user presses the submit button after typing in a number, check if it's invalid against my observable, and then return something back to my component to display on the UI? Currently, I client-side check what the user types and then display an error, But I need to actually check if the input value actually exists in my Observable&lt;bay[]&gt; objects and if it doesn't, return an error or something back to my bay.page.ts file to display in my HTML.</p>
<p>Sorry If I didn't explain this very well as I am trying to figure out how to word it.</p>
<p>Here's my BayService:
<a href=""https://i.stack.imgur.com/SVrUn.png"" rel=""nofollow noreferrer"">BayService.ts</a></p>
<p>Here's my Bay.page.ts: <a href=""https://i.stack.imgur.com/u9gnZ.png"" rel=""nofollow noreferrer"">Bay.page.ts</a></p>
","11569843","","11569843","","2021-03-01 20:12:13","2021-03-02 05:05:17","Check if object in array of objects exists against user input in RxJS HTTP Request","<angular><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"66432993","1","66433187","","2021-03-02 03:40:41","","0","180","<p>I just want to apologize for my lack of understanding of RxJS and Observables. I posted a question earlier but it was very poorly worded and I know it wasn't understandable, so after a day I think I can explain my issue better.</p>
<ol>
<li>The objective of my code is to grab user input, pass it as an action stream to my data stream, compare the input to my array of bays, if it exists, return that single bay. If it doesn't exist <strong>(This is where I'm struggling)</strong> return an observable that I can call back in my <code>bay.page.ts</code> and check to see if its <code>true</code> or <code>false</code>. If it's <code>false</code> <strong>[Show client side error]</strong>.
If it's <code>true</code>, navigate forward to the results page.</li>
<li>My <code>bay-service.ts</code> class contains my Data &amp; Actions streams:</li>
</ol>
<pre><code>export class BayServiceService {
  private baysUrl = 'api/bays';

  bays$ = this.http.get&lt;Bay[]&gt;(this.baysUrl)
    .pipe(
      tap(data =&gt; console.log('Bays: ', JSON.stringify(data))),
      catchError(this.handleError)
    );

  /*--------------------------------------------------------------*/
  // Grab A Single Bay
  private baySelectedSubject = new BehaviorSubject&lt;number&gt;(0);
  baySelectedAction$ = this.baySelectedSubject.asObservable();

  invalidBay = new BehaviorSubject&lt;boolean&gt;(false);

  selectedBay$ = combineLatest([
    this.bays$,
    this.baySelectedAction$
  ])
    .pipe(
      map(([bays, selectedBayNumber]) =&gt; {
        if (!bays.find(bay =&gt; bay.bayCode === selectedBayNumber)){
          this.invalidBay.next(false);
        } else {
          this.invalidBay.next(true);
          return bays.find(bay =&gt; bay.bayCode === selectedBayNumber);
        }
      }),
      );

  selectedBayChanged(selectedBayNumber: number): void {
    this.baySelectedSubject.next(selectedBayNumber);
  }
</code></pre>
<p>^ In the above code I use a declarative RxJS approach <code>selectedBay$</code> in which I combine my <code>bay$</code> data stream, and my <code>baySelectedAction$</code> Action Stream (Which contains the user input). I then map them and then compare the user input <code>selectedBayNumber</code> to a single bay number.</p>
<p><strong>ISSUE:</strong> I am trying to use the Observable -&gt; <code>invalidBay = new BehaviorSubject&lt;boolean&gt;(false);</code> that I created back in my <code>bay-service.ts</code> and check it's result: If it's true, navigate forward. If it's false, show a client side error that it doesn't exist. <strong>However</strong>, If the user enters a valid bay number, I try to change that Observable to <code>true</code> by doing <code>this.invalidBay.next(true);</code> BUT, the observable won't update it's value? The BehaviorObservable stays it's default value of 'false'. So the code is partially working, but not quite.</p>
<ol start=""3"">
<li>This is my <code>onSubmit</code> method in my <code>bay-page.ts</code> where I handle the user input for my action stream. I passed the user input into a method (which is in my <code>bay-service.ts</code> class). Depending on their input, I try to subscribe to the Observable that is &quot;supposedly updated&quot; and go from there. But the Observable is not being updated. Please help.</li>
</ol>
<pre class=""lang-js prettyprint-override""><code>onSubmit() {
    this.bayService.selectedBayChanged(this.bayForm.get('bayStart').value);
    this.subscription = this.bayService.invalidBay.subscribe(value =&gt; {
        if (value) {
            this.navCtrl.navigateForward([`/results/`]);
        } else {
            this.bayDoesNotExistError = true;
            this.selectedBay = this.bayForm.get('bayStart').value;
            this.vibration.vibrate(500);
            console.log('Vibrating for 3 second...')
        }
    })
}
</code></pre>
<p>Why is the Observable not having it's value updated? Please, my mind hurts and I don't know what else to do.</p>
","11569843","","446519","","2021-03-02 08:00:27","2021-03-02 08:00:27","BehaviorSubject .next() is not emitting updated value","<angular><typescript><rxjs><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"66469172","1","","","2021-03-04 05:34:38","","0","23","<p>I have an rxjs that pass an id, and I need to call an api, the api will return some data and I need to process that data regards to the projectId that wasa available before the switchMap.</p>
<p>if I map it to <code>{projectId, api: this.http.get('/api/projects/'+projectId)}</code> will not work like switchmap.</p>
<pre class=""lang-js prettyprint-override""><code>selectedProject$.pipe(
    switchMap(projectId=&gt; this.http.get('/api/projects/'+projectId)), 
    map(data=&gt; this.createChart(
                    projectId, /* I need the project id that was available before the switchMap */
                        data))
)
</code></pre>
<p>I know I can set <code>tap(projectId=&gt; this.selectedProjectId=projectId)</code> and use it later, but I want to know a way to handle it with rxjs</p>
","2326139","","","","","2021-03-04 06:27:21","how to carry forward a value that was available before switchmap?","<rxjs><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"66488782","1","66488930","","2021-03-05 07:57:58","","0","25","<p>I'm currently developing an Angular component that needs manual &quot;re-fetch from server&quot; functionality.</p>
<p>The version listed below works but is there any way to simplify it? It looks a bit complicated.</p>
<pre class=""lang-js prettyprint-override""><code>private refreshSignalSubject = new Subject&lt;any&gt;();
refreshSignal$: Observable&lt;any&gt; = this.refreshSignalSubject.asObservable();

ngOnInit() {
  this.item$ = combineLatest(
    this.route.paramMap.pipe(
      map(params =&gt; params.get('id')),
    ),
    this.refreshSignal$.pipe(
      startWith(() =&gt; Math.random())
    )
  ).pipe(
    map((values) =&gt; {
      const [id, _] = values
      return id
    }),
    switchMap(id =&gt; this.apiService.get(`/items/${id}`)),
    share()
  )
}

reloadItem() { // this method is triggered from the view and from other methods in this component
  this.refreshSignalSubject.next(Math.random());
}
</code></pre>
","74089","","","","","2021-03-05 08:24:50","ActivatedRoute observable with manual refresh ability","<angular><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"66501199","1","68346511","","2021-03-06 00:23:04","","0","38","<p>I see this question being asked a lot but I couldn't find a clear explanation that explains why my code doesn't work!</p>
<pre><code>  getItemValueHistory(ids: number) {
this.itemResource.getItemValueHistory(ids).subscribe(
  (res: ItemItemValueHistory[]) =&gt; {
    res.forEach((itemHistory) =&gt; {
      const history = itemHistory.second.listOfPrices.map(values =&gt; values.currentPrice);
      const item = itemHistory.first;
      this.simpleCharts.push(this.createSimpleChart(item, history));
    });
  }
);}
</code></pre>
<p>So this function gits an array of ids for which it will fetch some values from the backend (I know the naming for the response is not very clear but this will all be fixed later).</p>
<p>On the HTML side of things there is an ngFor that loops over the array simpleCharts.</p>
<pre><code>   &lt;div class=&quot;col-sm-4&quot; *ngFor=&quot;let simpleChart of simpleCharts&quot;&gt;
    &lt;app-simple-graph [simpleChart]=&quot;simpleChart&quot;&gt;&lt;/app-simple-graph&gt;
  &lt;/div&gt;
</code></pre>
<p>The issue I'm having is when I try to split up the response I get from the backend into an item and a history part. The <em>map</em> on the history always fails because I cant read the undefined list. I thought that when I executed code within the subscribe this would only run when you get the observable?</p>
<p>Probably something very obvious I'm missing but would love to know what it is!</p>
<p>By suggestion of Alexander update code: this still gives me an TypeError: Cannot read property 'map' of undefined error at itemHistory.second.listOfPrices.map</p>
<pre><code>  getItemValueHistory(ids: number) {
    this.itemResource.getItemValueHistory(ids)
      .pipe(
        map((itemHistories: ItemItemValueHistory[]) =&gt; {
          return itemHistories.map(itemHistory =&gt; {
            const history = itemHistory.second.listOfPrices.map(values =&gt; values.currentPrice);
            const item = itemHistory.first;
            return this.createSimpleChart(item, history);
          });
        })
      ).subscribe(res =&gt; {
      return this.simpleCharts.push(res);
    });
  }

</code></pre>
","5763193","","5763193","","2021-03-06 11:11:43","2021-07-12 11:22:44","Mapping an http request within subscribe()","<angular><pipe><mapping><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"66505623","1","66505923","","2021-03-06 12:27:26","","1","55","<p>I am wondering if there is a way to able to catch a subscribe error on an observable <strong>without the error callback</strong>?</p>
<p>For instance, you catch errors like this</p>
<pre><code> .subscribe({
 next: (obj) =&gt; {
    // Placeholder for code
 },

 // At the moment we need to include this error callback to show that an error has happened.
 // Forgetting to put this in means it 'bubbles' up so we cannot catch it and do anything with it.
 error: (e) =&gt; {
    this.showError(e.message);
 }, 
</code></pre>
<p>But if you look at the comment above, this is what happens when not including the callback.</p>
<p><strong>Forgetting to put this in means it 'bubbles' up so we cannot catch it and do anything with it.</strong></p>
<p>To be more explicit, even putting a <code>try-catch</code> around the method doesn't catch the error either.</p>
<p>I want to know this, because, if for some reason, a developer forgets to put the catch callback in, is there any way it can be caught? Because if not the error cannot be handled.</p>
<p>I think the issue is that as an observable is an async process, which happens on a new thread/task.</p>
<p>Thanks</p>
","3428422","","","","","2021-03-06 13:01:26","RxJS observables catch errors without the error callback","<angular><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"66513221","1","66513370","","2021-03-07 04:32:19","","2","42","<pre><code>let fruit = {
  id: 1,
  isGood: false
}
</code></pre>
<p>lets say I have a function call that accepts an id of a fruit object and returns an observable that resolves into a boolean indicating whether the value isGood is true or false.</p>
<p>I want to map through an array of fruit objects and call the function described above then use the value returned to set isGood on an object and set an id from the fruit on the same object that is returned.</p>
<p>In my mind, I should be able to do something like this:</p>
<pre><code>forkJoin(
  fruitArray.map(fruit =&gt; { 
     return of({ 
       &quot;data&quot;: isFruitGood(fruit.id)),
       &quot;id&quot;: fruid.id
      })
    })  
   ).subscribe(result =&gt; console.log(result))
</code></pre>
<p>The problem here is that an array of objects is returned, but the observable set to data in the object is not resolving.</p>
","10112234","","","","","2021-03-07 05:02:40","Can you return an array of objects, with each object containing an observable from forkJoin?","<javascript><angular><rxjs><fork-join><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"66546315","1","66547763","","2021-03-09 11:48:38","","1","42","<p>I am new to rxjs and am trying to do two requests. When I try to see the result, I get Observable.</p>
<pre><code>copy() {
    const obj = {};

    this.create(skill)
      .pipe(
        mergeMap((res) =&gt; {
          return [res, forkJoin(this.levels.map((level) =&gt; this.level(level)))];
        }),
      )
      .subscribe((res) =&gt; {
        console.log(res);
      });
  }

level(level) {
    return this.create(level);
  }
</code></pre>
<p>Output:
object of created skill,
Observable {_isScalar: false, _subscribe: ƒ}</p>
<p>I get the response of the first request normally and the second one comes to me as &quot;Observable&quot;.</p>
","14569009","","","","","2021-03-09 13:35:05","Why is it returned when trying to execute the request Observable?","<javascript><angular><typescript><rxjs><rxjs-observables>","2","4","","","","CC BY-SA 4.0"
"66548689","1","66549424","","2021-03-09 14:20:34","","0","22","<p>I have two different data streams which gives same object with modified property values. I want to write a single subscription so that whenever any of the two DataStream notifies about property modification I can reuse the same code.</p>
<pre><code>const selectedItems$ = this.grid.onSelect.pipe(.... this gives me the selected object);
const updatedItem$ = this.fetchData.onUpdate.pipe(.....this gives me the updated object);

displayItem$(selection$, updatedItem$) {
   (..here i want to get notified whenever there is change in).subscribe(item =&gt; {
       this.displayLatest(item)
   })
}
</code></pre>
<p>selectedItem$ and updatedItem$ can return same object with different property values when the already selected item is modified.</p>
<p>This is the first time I am working on RxJs and bit confused about this part. I searched in RxJS operators list (like concat, merge, combine) but most of the working examples are for different data structures. Also is there any other better way to achieve this?</p>
","2467136","","","","","2021-03-09 15:04:46","how to handle same value from multiple datastreams in Angular RxJs","<javascript><angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"66554068","1","66562801","","2021-03-09 20:09:54","","0","48","<p><strong>OBJECTIVE:</strong> I want to <strong>GET</strong> a single object and/or a range of objects from my backend service by passing in user inputs as HTTP params using RxJS.
For Example, I am using declarative RxJS and so I have two Subjects (Action streams) to grab the input from the user when they hit Submit. I want to pass those Subjects values, <strong>as HTTP params</strong>, into my http request in order to get either the specified bay object, or a range of bays.
The first Subject/UserInput will always be mandatory, whereas the second Subject/UserInput will be optional. So if someone enters 4 for the first input, and then nothing for the second input. The backend will accept both inputs as 4 and 'null' because nothing was put in. If that's the case, return the bay that has a bay Number of 4. If there is a second input like 6, return a range of bays from 4 -&gt; 6, if they exist.</p>
<p><strong>The Issue:</strong> How do I pass those two Subjects as http params using declarative RxJS?</p>
<p>Here are my two subjects and their method, as well as my attempt at the HTTP request in my <code>bay-service.ts</code> file.</p>
<pre><code>  private bayStartSelectedSubject = new Subject&lt;number&gt;();
  baySelectedAction$ = this.bayStartSelectedSubject.asObservable();

  private bayEndSelectedSubject = new Subject&lt;number&gt;();
  bayEndSelectedAction$ = this.bayEndSelectedSubject.asObservable();

  selectedBayChanged(selectedBayStartNumber: number, selectedBayEndNumber?: number): void {
    this.bayStartSelectedSubject.next(selectedBayStartNumber);
    this.bayEndSelectedSubject.next(selectedBayEndNumber);
  }

  private HandlingUnitResponseUrlSecondary = 'http://localhost:8080/sbtemplate/readBayInventory';


bayOrBays$ = combineLatest([
    this.baySelectedAction$,
    this.bayEndSelectedAction$
  ])
    .pipe(
      map(([bayStart, bayEnd]) =&gt; {
        mergeMap(() =&gt; this.http.get&lt;HuResponse&gt;(`${this.HandlingUnitResponseUrlSecondary}/COS/${bayStart}/${bayEnd}`))
      })
    );
</code></pre>
<p>Here is where I grab the user inputs in my <code>bay-page.ts</code> file, and call their method to emit the user inputs value:</p>
<pre><code>onSubmit() {
    this.bayService.selectedBayChanged(this.bayForm.get('bayStart').value, this.bayForm.get('bayEnd').value);
    if(!this.invalidBay) {
      this.bayDoesNotExistError = true;
      this.selectedBay = this.bayForm.get('bayStart').value;
      this.vibration.vibrate(500);
      console.log('Vibrating for 3 second...')
    } else {
      this.navCtrl.navigateForward([`/results/`]);
    }
</code></pre>
<p>I know the code doesn't look great, but I can't find any information on this. Thanks for the help!</p>
<p><strong>Also</strong> Here is the backend API that I am trying to hit:</p>
<pre><code>@RequestMapping(value=&quot;/readBayInventory/{centerId}/{beginBayId}/{endBayId}&quot;, method = GET)
    public ResponseEntity&lt;HUResponse&gt; readBayInventory(@PathVariable String centerId, @PathVariable int beginBayId, @PathVariable(required = false) int endBayId) {
</code></pre>
","11569843","","11569843","","2021-03-09 20:43:46","2021-03-10 10:24:55","How to pass two Subjects/Action streams as HTTP Params in a GET request to return a single object/Array of objects in Angular using RxJS?","<angular><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","6","","","","CC BY-SA 4.0"
"66562373","1","66562661","","2021-03-10 09:58:56","","0","39","<p>I need to obtain a series of data for each of the dates of origin that I have in an array</p>
<p><a href=""https://i.stack.imgur.com/OKjBX.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/OKjBX.jpg"" alt=""array"" /></a></p>
<p>and I need to obtain them in order so I use concatMap to go through my observable of dates and when I obtain the first group of values everything goes fine</p>
<pre><code>of(...this.etiquetasEjeX)
  .pipe(
    concatMap(item=&gt;
        this.dataService.getGastadoRealizadoEnMesYAño(this.proyectoId,
        getMonthNumber(item.slice(0,item.length-4)),
        +item.slice(-4),
        this.acumular)
        ),
    toArray()
  )
  .subscribe(item=&gt;{
    this.gastadoRealizado=item;
    console.log('this.gastadoRealizado: ', this.gastadoRealizado);
  });
</code></pre>
<p>I have my this.gastoRealizado array</p>
<p><a href=""https://i.stack.imgur.com/aw83o.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aw83o.jpg"" alt=""gastorealizado"" /></a></p>
<p>but I need to do 3 More calls to the backend to obtain a total of 4 arrays that then feed a graph and I don't know how to add more calls in this established order</p>
<p>Any idea, please?</p>
<p>Thanks</p>
","3367720","","","","","2021-03-10 13:55:47","how to make concatMap nested","<rxjs><rxjs-observables><concatmap>","1","0","","","","CC BY-SA 4.0"
"66569315","1","","","2021-03-10 16:51:11","","0","42","<p>In ngOnInit() I call to getGastado() method where I iterate over an array of dates to obtain several data related to and fill 2 arrays that I will need later and are private properties of my class, so, accessible in all the code of my class, like a global variable</p>
<pre><code>export class AppComponent implements OnInit {

private gastadoRealizadoAcumulado:number=100;
private gastadoRealizado: number[] = [];

ngOnInit(): void {
 this.getGastado();
}

 getGastado(){
  let mes:string;
  of(...this.etiquetasEjeX)
  .pipe(
    concatMap(item=&gt;
      zip(
        of(item),
        this.dataService.getGastadoRealizadoEnMesYAño(this.proyectoId,
         this.getMonthNumber(item.slice(0,item.length-4)),
         +item.slice(-4),
         this.acumular),

        this.dataService.getGastoPlanificadoEnMesYAño(this.proyectoId,
         this.getMonthNumber(item.slice(0,item.length-4)),
         +item.slice(-4),
          this.acumular)
        )
       )
      )
     .subscribe(([mes,gastadoRealizado, gastadoPlanificado])=&gt;{
       this.gastadoRealizado.push(gastadoRealizado);
       this.gastadoPlanificado.push(gastadoPlanificado);
    });  
   }
</code></pre>
<p>When the observable of(...this.etiquetasEjeX) completes I have 2 arrays with the values calculated</p>
<p>Now I need to iterate over these 2 arrays to obtain another one but in ngOnInit If I try to access to this.gastadoRealizado array for example after this.getGastado() I have an undefined object because the asynchronism I assume.</p>
<p>Then. How can I access to any of these arrays generated in this.getGastado() after the method has ended?</p>
<p>Thanks</p>
<p>Here I have a demo code: <a href=""https://stackblitz.com/edit/rxjsangular-kintela?file=src/app/app.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjsangular-kintela?file=src/app/app.component.ts</a></p>
","3367720","","","","","2021-03-11 10:09:42","How to access to observables out of the subscribe method were are getted in Angular","<angular><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"66591763","1","","","2021-03-11 22:55:55","","0","26","<p>I want to use from BehaviorSubject for my login user.
i have <code>user</code> BehaviorSubject. that retuen a abservble.</p>
<pre><code> get IsAuthenticated() {
return this.user.asObservable().pipe(switchMap(res =&gt; {
  if (res != null) {
    return of(true);
  }
  return of(false);
}));

}
</code></pre>
<p>for using this result abservble i use <code>take(1)</code> but return multiple one result and hangout app.</p>
<pre><code>return this.authService.IsAuthenticated.pipe(take(1),tap(res =&gt; {
      console.log(res);
      if (res == true) {
        this.router.navigateByUrl(&quot;/status&quot;);
      }else{
        this.router.navigateByUrl(&quot;/auth&quot;);
      }
    }));
</code></pre>
<p><a href=""https://i.stack.imgur.com/8qTY6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8qTY6.png"" alt=""enter image description here"" /></a></p>
","11879932","","","","","2021-03-12 00:23:15","Afrer return a BehaviorSubject , app was pulled for multiple result","<angular><ionic-framework><rxjs><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"66615681","1","","","2021-03-13 16:10:10","","0","154","<h2>Intro</h2>
<p>I am trying to use RxJS in a TypeScript project but I am seeing strange behavior when using the <code>switchMap</code> and <code>mergeMap</code> pipeline operator where the type is being lost somewhere. I have separate TypeScript project (react app) that includes the same version of RxJS and I am not seeing this behavior. Both projects are being evaluated by the same version of TypeScript (4.2.3). I am at a loss as to what might be wrong, any help would be appreciated.</p>
<h2>Context</h2>
<p>Here is a simple test case that I created to demonstrate the problem. Copying this code into my other project compiles and works as expected. As you can see I have one source stream or type <code>Observable&lt;number&gt;</code> and when I map this into a <code>string</code> the output type is <code>Observable&lt;string&gt;</code>, which is correct. However, when I apply a <code>switchMap</code> and return a stream of a string, the type emitted by the call to pipe is <code>Observable&lt;unknown&gt;</code></p>
<p><a href=""https://i.stack.imgur.com/Skhgu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Skhgu.png"" alt=""Sample code"" /></a></p>
<p>Here you can see the IDE highlighting the type mismatch</p>
<p><a href=""https://i.stack.imgur.com/8eq5i.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8eq5i.png"" alt=""TypeScript error"" /></a></p>
<p>I examining the type of the <code>switchMap</code> operation itself shows that the type is being inferred correctly going in, but the type is lost in the return value. I have inspected the <code>OperatorFunction</code> type and I don't see anything wrong (and is no different in the other project)</p>
<p><a href=""https://i.stack.imgur.com/bv68z.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bv68z.png"" alt=""switchMap type"" /></a></p>
<h2>Config</h2>
<p>Given the problem above and the fact that this works in another project, makes me think that the problem is in my TypeScript config. After half an hour of switching things on and off I have seem glimmers of hope but nothing has worked. Here is my <code>tsconfig.json</code> and I am using TypeScript 4.2.3:</p>
<pre class=""lang-json prettyprint-override""><code>{
  &quot;compilerOptions&quot;: {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */

    /* Basic Options */
    // &quot;incremental&quot;: true,                         /* Enable incremental compilation */
    &quot;target&quot;: &quot;es5&quot;,                                /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */
    &quot;module&quot;: &quot;commonjs&quot;,                           /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */
    // &quot;lib&quot;: [],                                   /* Specify library files to be included in the compilation. */
    // &quot;allowJs&quot;: true,                             /* Allow javascript files to be compiled. */
    // &quot;checkJs&quot;: true,                             /* Report errors in .js files. */
    // &quot;jsx&quot;: &quot;preserve&quot;,                           /* Specify JSX code generation: 'preserve', 'react-native', 'react', 'react-jsx' or 'react-jsxdev'. */
     &quot;declaration&quot;: true,                         /* Generates corresponding '.d.ts' file. */
     &quot;declarationMap&quot;: true,                      /* Generates a sourcemap for each corresponding '.d.ts' file. */
     &quot;sourceMap&quot;: true,                           /* Generates corresponding '.map' file. */
    // &quot;outFile&quot;: &quot;./&quot;,                             /* Concatenate and emit output to single file. */
     &quot;outDir&quot;: &quot;./lib&quot;,                              /* Redirect output structure to the directory. */
    // &quot;rootDir&quot;: &quot;./&quot;,                             /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */
    // &quot;composite&quot;: true,                           /* Enable project compilation */
    // &quot;tsBuildInfoFile&quot;: &quot;./&quot;,                     /* Specify file to store incremental compilation information */
    // &quot;removeComments&quot;: true,                      /* Do not emit comments to output. */
    // &quot;noEmit&quot;: true,                              /* Do not emit outputs. */
    // &quot;importHelpers&quot;: true,                       /* Import emit helpers from 'tslib'. */
    // &quot;downlevelIteration&quot;: true,                  /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
    // &quot;isolatedModules&quot;: true,                     /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */

    /* Strict Type-Checking Options */
    &quot;strict&quot;: true,                                 /* Enable all strict type-checking options. */
     &quot;noImplicitAny&quot;: true,                       /* Raise error on expressions and declarations with an implied 'any' type. */
     &quot;strictNullChecks&quot;: true,                    /* Enable strict null checks. */
     &quot;strictFunctionTypes&quot;: true,                 /* Enable strict checking of function types. */
     &quot;strictBindCallApply&quot;: true,                 /* Enable strict 'bind', 'call', and 'apply' methods on functions. */
     &quot;strictPropertyInitialization&quot;: true,        /* Enable strict checking of property initialization in classes. */
     &quot;noImplicitThis&quot;: true,                      /* Raise error on 'this' expressions with an implied 'any' type. */
     &quot;alwaysStrict&quot;: true,                        /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */

    /* Additional Checks */
     &quot;noUnusedLocals&quot;: true,                      /* Report errors on unused locals. */
     &quot;noUnusedParameters&quot;: true,                  /* Report errors on unused parameters. */
     &quot;noImplicitReturns&quot;: true,                   /* Report error when not all code paths in function return a value. */
     &quot;noFallthroughCasesInSwitch&quot;: true,          /* Report errors for fallthrough cases in switch statement. */
//     &quot;noUncheckedIndexedAccess&quot;: false,            /* Include 'undefined' in index signature results */
//     &quot;noPropertyAccessFromIndexSignature&quot;: false,  /* Require undeclared properties from index signatures to use element accesses. */

    /* Module Resolution Options */
    // &quot;moduleResolution&quot;: &quot;node&quot;,                  /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    // &quot;baseUrl&quot;: &quot;./&quot;,                             /* Base directory to resolve non-absolute module names. */
    // &quot;paths&quot;: {},                                 /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    // &quot;rootDirs&quot;: [],                              /* List of root folders whose combined content represents the structure of the project at runtime. */
    // &quot;typeRoots&quot;: [],                             /* List of folders to include type definitions from. */
    // &quot;types&quot;: [],                                 /* Type declaration files to be included in compilation. */
    // &quot;allowSyntheticDefaultImports&quot;: true,        /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
    &quot;esModuleInterop&quot;: true,                        /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */
    // &quot;preserveSymlinks&quot;: true,                    /* Do not resolve the real path of symlinks. */
    // &quot;allowUmdGlobalAccess&quot;: true,                /* Allow accessing UMD globals from modules. */

    /* Source Map Options */
    // &quot;sourceRoot&quot;: &quot;&quot;,                            /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // &quot;mapRoot&quot;: &quot;&quot;,                               /* Specify the location where debugger should locate map files instead of generated locations. */
    // &quot;inlineSourceMap&quot;: true,                     /* Emit a single file with source maps instead of having a separate file. */
    // &quot;inlineSources&quot;: true,                       /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */

    /* Experimental Options */
     &quot;experimentalDecorators&quot;: true,              /* Enables experimental support for ES7 decorators. */
     &quot;emitDecoratorMetadata&quot;: true,               /* Enables experimental support for emitting type metadata for decorators. */

    /* Advanced Options */
    &quot;skipLibCheck&quot;: true,                           /* Skip type checking of declaration files. */
    &quot;forceConsistentCasingInFileNames&quot;: true,        /* Disallow inconsistently-cased references to the same file. */
    &quot;lib&quot;: [
      &quot;dom&quot;,
      &quot;es5&quot;,
      &quot;scripthost&quot;,
      &quot;es2015.collection&quot;,
      &quot;es2015.promise&quot;
    ]
  },
  &quot;include&quot;: [&quot;./src/**/*.ts&quot;],
  &quot;exclude&quot;: [&quot;./node_modules/**/*&quot;]
}
</code></pre>
<p>and just for completeness, here is the code from the pictures above</p>
<pre class=""lang-js prettyprint-override""><code>import { Observable, of } from &quot;rxjs&quot;;
import { map, switchMap } from &quot;rxjs/operators&quot;;

const source = new Observable&lt;number&gt;();

const switchMapToString: Observable&lt;string&gt; = source.pipe(
    switchMap(n =&gt; of(`${n}`)),
);

const mapToString: Observable&lt;string&gt; = source.pipe(
    map(n =&gt; `${n}`),
);
</code></pre>
","5053124","","","","","2021-03-13 16:10:10","RxJS switchMap/mergeMap resulting in Obserable<unknown>","<typescript><rxjs><tsconfig><rxjs-observables><rxjs-pipeable-operators>","0","7","1","","","CC BY-SA 4.0"
"66633711","1","66638793","","2021-03-15 07:13:43","","1","121","<p>I've following interfaces and <code>Observable&lt;Machine[]&gt;</code>, what I want to achive is group by Machine <code>symbol</code> property in  <code>Observable&lt;Machine[]&gt;</code> and return mapped observable <code>Observable&lt;Order[]&gt;</code>.</p>
<pre><code>export interface Machine {
    symbol: string;
    price: number;
    amount: number;
    id: number;
}

export interface Order {
    symbol: string;
    machines: OrderMachine[];
}

export interface OrderMachine {
    price: number;
    amount: number;
    id: number;
}
</code></pre>
<p>I've tried to use RxJS gropBy operator but it seems it return grouped array one by one.</p>
<pre><code>machines: Machine[] = [
        { amount: 1,  id: 1, symbol: &quot;A&quot;, price: 1 },
        { amount: 1,  id: 2, symbol: &quot;A&quot;, price: 2 }
    ];


of(machines).pipe(
        takeUntil(this.unsubscribe),
        mergeMap(res =&gt; res),
        groupBy(m =&gt; m.symbol),
        mergeMap(group =&gt; zip(of(group.key), group.pipe(toArray()))),
        map(x =&gt; { // here I have probably wrong model [string, Machine[]]
            const orderMachines = x[1].map(y =&gt; { return &lt;OrderMachine&gt;{price: y.price, amount: y.amount, id: y.id }})
            return &lt;Order&gt;{ symbol: x[0], machines: orderMachines }  })
        );
</code></pre>
<p>as in result I have <code>Observable&lt;Order&gt;</code> istead of<code>Observable&lt;Order[]&gt;</code>.</p>
<p>expected result model:</p>
<pre><code>orders: Order[] = [
        {   
            symbol: &quot;A&quot;, 
            machines: [
                { amount: 1, price: 1, id: 1 },
                { amount: 1, price: 2, id: 2 }
            ]
        }
    ];
</code></pre>
","5953169","","5953169","","2021-03-15 11:02:08","2021-03-17 12:47:55","RxJS group by field and return new observable","<rxjs><rxjs5><rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"66646173","1","66646935","","2021-03-15 21:53:11","","0","41","<p>I'm using declarative RxJS to return a response object from my back-end service. I am able to grab the data in my <code>bay-page.ts</code> file and display it in my html. However, I want the data to be displayed in my <code>results-page.ts</code> file. I grab the user inputs using Subjects and pass them in a method in my <code>bay-page.ts</code> file, that will then fire off the HTTP request.</p>
<p><strong>But, how do I grab those results and display them in my <code>results-page.html</code> file?</strong></p>
<p><code>bay-service.ts</code> file:</p>
<pre><code>private bayStartSelectedSubject = new Subject&lt;number&gt;();
  bayStartSelectedAction$ = this.bayStartSelectedSubject.asObservable();

  private bayEndSelectedSubject = new Subject&lt;number&gt;();
  bayEndSelectedAction$ = this.bayEndSelectedSubject.asObservable();


  selectedBayChanged(selectedBayStartNumber: number, selectedBayEndNumber?: number): void {
    this.bayStartSelectedSubject.next(selectedBayStartNumber);
    this.bayEndSelectedSubject.next(selectedBayEndNumber);
  }

  grabHuResponsePOST$ = combineLatest([
    this.bayStartSelectedAction$,
    this.bayEndSelectedAction$
  ])
    .pipe(
      switchMap(([bayStart, bayEnd]) =&gt; {
        if (bayEnd == null || bayEnd &lt;= 0) {
          bayEnd = bayStart;
        }
        let huRequest: HuRequest = {
          &quot;centerId&quot;: &quot;COS&quot;,
          &quot;beginBayId&quot;: bayStart,
          &quot;endBayId&quot;: bayEnd
        }
        const headers = new HttpHeaders({
          'Content-Type': 'application/json'
        });
        let options = {
          headers: headers
        }
        // this.invalidBay.next(true);
        return this.httpClient.post&lt;HuResponse&gt;(this.HandlingUnitResponseUrl, huRequest, options);
      }),
      tap(showDataPlease =&gt; console.log('Bays: ', JSON.stringify(showDataPlease))),
    );
</code></pre>
<p><code>bay-page.ts</code> file:</p>
<pre><code>ngOnInit() {
    this.bayForm = new FormGroup({
      'bayStart': new FormControl(null, [Validators.required]),
      'bayEnd': new FormControl(null, [Validators.required])
    });
    this.bayService.invalidBay$.subscribe(
      value =&gt; {
        console.log(value);
        this.invalidBay = value;
      }
    );
    this.bayService.grabHuResponsePOST$.subscribe(p =&gt; {

    });
  }

  onSubmit() {
    this.bayService.selectedBayChanged(this.bayForm.get('bayStart').value, this.bayForm.get('bayEnd').value);
    this.navCtrl.navigateForward([`/results/`]);
  }
</code></pre>
<p><code>results-page.ts</code> file:</p>
<pre><code>bayOrBays$ = this.bayService.grabHuResponsePOST$
    .pipe(
      map(response =&gt; response.bays),
      catchError(err =&gt; {
        this.errorMessageSubject.next(err);
        return EMPTY;
      }),
      tap(showDataPlease =&gt; console.log('Bays: ', JSON.stringify(showDataPlease)))
    );
</code></pre>
<p><code>results-page.html</code> file:</p>
<pre><code>&lt;ion-card *ngFor=&quot;let bay of bayOrBays$ | async; index as i&quot;
                    class=&quot;ion-no-margin&quot;&gt;
            &lt;ion-card-header&gt;
              &lt;ion-card-title&gt;Bay {{ bay.bayCode }}&lt;/ion-card-title&gt;
              &lt;ion-card-subtitle&gt;{{ bay.shipments.length }} Shipments&lt;/ion-card-subtitle&gt;
            &lt;/ion-card-header&gt;
          &lt;/ion-card&gt;
</code></pre>
<p>I am obviously missing something with a subscription because this doesn't work in my <code>results-page.ts</code> file, but it DOES work, if I put it in my <code>bay-page.ts</code> file.</p>
","11569843","","","","","2021-03-15 23:12:10","Using declarative RxJS, is there a way to pass Observable data to child component from parent component?","<angular><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","7","","","","CC BY-SA 4.0"
"66679615","1","","","2021-03-17 19:03:36","","1","51","<p>I'm working on an Angular app and among other features, now I'm working on an image gallery (carousel).</p>
<p>When the user opens the image gallery, he's also able to upload new photos.</p>
<p>Because I need to know the upload process globally, I'm trying to implement a service for this as follow:</p>
<p>In <strong>ts</strong> component I have the following function:</p>
<pre><code>onUploadFile(files: File[]) {
    if (!files?.length) {
      return;
    }

    const uploading = this.attachmentsService
      .uploadMultiple(files)
      .map((x) =&gt; ({ attachment: x }));

    uploading.forEach((file) =&gt; {
      this.filesStateService
        .getProgress(file.attachment.url)
        .pipe(untilDestroyed(this))
        .subscribe({
          complete: () =&gt; {
            this.referenceAttachments = [...this.referenceAttachments];
          },
          error: () =&gt; {
            this.deleteAttachment(file);
          },
        });
    });

    this.referenceAttachments = [...uploading, ...this.referenceAttachments];
}
</code></pre>
<p><strong>attachments.service.ts</strong>:</p>
<pre><code>uploadMultiple(files: File[]) {
    if (!files?.length) {
      return [];
    }

    return files.map((x) =&gt; this.upload(x));
}

upload(file: File) {
    const fileUpload = this.filesService.upload(file);

    this.filesStateService.addProgress(fileUpload.url, fileUpload.progress$);

    const attachment: Attachment = {
      url: fileUpload.url,
      size: file.size,
      type: file.type,
    };

    return attachment;
}
</code></pre>
<p><strong>files.service.ts</strong>:</p>
<pre><code>upload(file: File) {
    ...
    return {
      url: fileUrl,
      progress$: new Observable&lt;number&gt;((observer) =&gt; {
        blockBlobClient
          .uploadData(file, {
            onProgress: this.onProgress(observer),
          })
          .then(
            this.onUploadComplete(observer, file, fileUrl),
            this.onUploadError(observer, fileUrl)
          );
      }).pipe(distinctUntilChanged(), startWith(0), shareReplay()),
    };
}

private onUploadError(observer: Subscriber&lt;number&gt;, fileUrl: string) {
    return (error: any) =&gt; {
      observer.error(error);

      this.filesStateService.removeProgress(fileUrl);
    };
}

private onUploadComplete(
    observer: Subscriber&lt;number&gt;,
    file: File,
    fileUrl: string
) {
    return () =&gt; {
      observer.next(file.size);

      this.filesStateService.removeProgress(fileUrl);

      observer.complete();
    };
}

private onProgress(observer: Subscriber&lt;number&gt;) {
    return (progress: TransferProgressEvent) =&gt;
      observer.next(progress.loadedBytes);
}
</code></pre>
<p>In the view, the progress is rendered as follow:</p>
<pre><code>&lt;app-file-upload-progress
     *ngIf=&quot;file.attachment.url | fileProgress | async as progress&quot;
     [progress]=&quot;progress&quot;
     [size]=&quot;file.attachment?.size&quot;
&gt;&lt;/app-file-upload-progress&gt;
</code></pre>
<p><strong>file-progress.pipe</strong> is just returning the progress form the list:</p>
<pre><code>@Pipe({
  name: 'fileProgress',
})
export class FileProgressPipe implements PipeTransform {
  constructor(private filesStateService: FilesStateService) {}

  transform(value: string): Observable&lt;number&gt; {
    if (!value) {
      return null;
    }

    return this.filesStateService.getProgress(value);
  }
}
</code></pre>
<p>and the <strong>files-state.service</strong> where the files progress are stored:</p>
<pre><code>@Injectable()
export class FilesStateService {
  filesProgress: Map&lt;string, Observable&lt;number&gt;&gt; = new Map();

  addProgress(url: string, progress$: Observable&lt;number&gt;): void {
    this.filesProgress.set(url, progress$);
  }

  removeProgress(url: string): void {
    this.filesProgress.delete(url);
  }

  getProgress(url: string): Observable&lt;number&gt; {
    return this.filesProgress.get(url);
  }
}
</code></pre>
<p>I can't understand why, after the file was successfully uploaded and the progress is removed from the <code>filesProgress</code> list, the <strong>app-file-upload-progress</strong> is not removed from the interface.</p>
<p>I also tried to use <code>pure: false</code> in <strong>file-progress.pipe</strong> and with this, after the upload is complete if I click on another element, the changes are reflected and the progress is removed from UI (but from what I've read, using <code>pure: false</code> will lead to poor performance.</p>
","8916057","","","","","2021-03-18 17:16:18","Observable value not updated on UI","<angular><typescript><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"66696284","1","66696907","","2021-03-18 17:37:07","","1","83","<p>I'm trying to use below simplified version of my http request pipeline to ensure that if my response  does not have the required data in res.myCondition to utlize repeatWhen and make another call, but I'm clearly not utilizing repeatWhen the way it's meant to be. (angular 8/ rxjs 6.5)</p>
<p>Intention is for the first call to come into the map, where I check the returned data, if the data is there I'll return it to the subscriber back in my component, but if myCondition is missing from res I'd like to repeat the api call a pre-determined number of times stored in reties.</p>
<p>any thoughts on where I'm going wrong with my repeatWhen implementation?</p>
<p>method1:</p>
<pre><code>return this.http.get()
   .pipe(map(res =&gt; res.myCondition ? res : null),
        repeatWhen(res =&gt; retries-- &gt; 0 ? of(res) : res), 
        catchError((error: HttpErrorResponse) =&gt; (error))
</code></pre>
","10768827","","","","","2021-03-20 20:01:12","Utilizing rxjs repeatWhen in http request pipe in order to repeat the request if desired response is not returned","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"66804684","1","66805457","","2021-03-25 17:29:22","","0","40","<p>Angular 11 site.  I've searched all over but I'm still struggling with what seems like it should be a pretty common scenario.</p>
<p><strong>Goal:</strong> Do an http call to retrieve a list of items, then do another http call to retrieve details for the first item.  After both calls are done (whether they succeeded or failed), hide the component's overall wait indicator.</p>
<p>Here is a highly simplified version without null-checking and error handling:</p>
<pre><code>  ngOnInit(): void {
    this.getPackages();
  }

  private getPackages() {
    this._packageSubscription = this.packageService.getPackages()
      .pipe(
        finalize(() =&gt; {
          console.log('getPackages finalize');
          this.loadingPackages = false; //hide wait indicator: happens BEFORE getPackageDetails is finished
        })
      )
      .subscribe(
        packages =&gt; {
          this.packageOptions = packages;
          this.selectedPackage = packages[0];
          this.loadSelectedPackage();
        }
      );
  }

  public loadSelectedPackage() {
    this._packageDetailsSubscription = this.packageService.getPackageDetails(this.selectedPackage!.Id)
      .pipe(
        finalize(() =&gt; {
          console.log('getPackageDetails finalize');
        })
      )
      .subscribe(
        packageDetails =&gt; {
          this.packageDetails = packageDetails;
        }
      );
  }
</code></pre>
<p>When executed, the console reads:</p>
<pre><code>getPackages finalize
getPackageDetails finalize
</code></pre>
<p>I would expect it the other way around.</p>
<p>I'm aware I could add my code to deactivate the wait indicator in the inner <code>finalize()</code> for <code>getPackageDetails()</code>, but there are a few issues with that:</p>
<ol>
<li>It just seems wrong. Why can't I know when the chain is complete at the outer level?</li>
<li>That would only cover the case where everything succeeded.  I'd have to add a second line of code somewhere to hide the wait indicator when something with the first call failed.</li>
<li><code>loadSelectedPackage()</code> can be called again later after a user action changes the selected package, so it makes even less sense for it to deal with something that is only relevant on the initial load.</li>
</ol>
<p>So why doesn't my outer <code>finalize()</code> wait until the chain is complete?  Or how else can I know when the chain is complete?</p>
","11991371","","","","","2021-03-25 18:20:25","Why does RxJs finalize execute before chained http calls are complete?","<angular><asynchronous><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"66817700","1","","","2021-03-26 13:18:02","","0","49","<p>I am trying to refresh my data from my Observable on click</p>
<p>Here is my code
My Parent Component</p>
<pre class=""lang-js prettyprint-override""><code>export class StepComponent implements OnInit, AfterViewInit{

  displayedColumns: string[] = ['dateCreation','siteName', 'adress'/*,'enseigne'*/, 'postCode', 'commune','prestation', 'validation'];

  dataset! : DataTable[];

  @ViewChild(ButtonComponent) bhuttonChild!: ButtonComponent;

  constructor(private dataTableService : DataTableService) { }

  ngAfterViewInit(): void {
  }

  ngOnInit(): void {
    this.dataTableService.fetchDataTableNewPrestation().subscribe(r =&gt; this.dataset = r); // I would like to refresh this data with the event of the buttonChild

  }
}
</code></pre>
<p>step.html ( the parent component)</p>
<pre class=""lang-html prettyprint-override""><code>&lt;table class=&quot;table&quot; mat-table [dataSource]=&quot;dataset&quot;&gt;
[...]

      &lt;ng-container matColumnDef=&quot;validation&quot;&gt;
        &lt;th mat-header-cell *matHeaderCellDef&gt; Validation &lt;/th&gt;
        &lt;mat-cell mat-cell *matCellDef=&quot;let element&quot;&gt;
          &lt;app-button [element]=&quot;element&quot;&gt;&lt;/app-button&gt;
        &lt;/mat-cell&gt;
      &lt;/ng-container&gt;

      &lt;tr mat-header-row *matHeaderRowDef=&quot;displayedColumns&quot;&gt;&lt;/tr&gt;
      &lt;tr mat-row *matRowDef=&quot;let row; columns: displayedColumns;&quot;&gt;&lt;/tr&gt;
    &lt;/table&gt;
</code></pre>
<p>Here my child component which is a buttoon :</p>
<pre class=""lang-js prettyprint-override""><code>@Component({
  selector: 'app-button',
  template: `
      &lt;div  *ngIf=&quot;element.id&quot;  &gt;
        &lt;button mat-raised-button [value]=&quot;false&quot; (click)=&quot;initTaskOnPrestation(false)&quot; color=&quot;primary&quot;&gt;Normal&lt;/button&gt;
        &lt;button mat-raised-button [value]=&quot;true&quot; (click)=&quot;initTaskOnPrestation(true)&quot; color=&quot;warn&quot;&gt;Urgent&lt;/button&gt;
      &lt;/div&gt;

  `,
  styleUrls: ['./button.component.scss']
})
export class ButtonComponent implements OnInit, AfterViewInit {

  @Input() element!: Prestation;
  urgent!: boolean

  @Input() lastStatus!: number;
  statusHistory!: StatusHistory;

  @ViewChild('button')
  button!: ElementRef;

  constructor(private taskService : TaskService) { }

  ngAfterViewInit(): void {
  }

  ngOnInit(): void {
    
  }

  initTaskOnPrestation(bool : boolean){
    this.prestation.urgency = bool;
    this.taskService.initTaskOnPrestation(this.prestation);
  }

}
</code></pre>
<p>My button is charged to send a request who will change my data in my backend but then I need to reload the data from my StepComponent with the <code>fetchDataTableNewPrestation()</code> method.</p>
<p>I am trying to get button event to use it, but I don't know how to do it even after check many time the the <a href=""https://angular.io/guide/rx-library"" rel=""nofollow noreferrer"">Rxjs documentation</a></p>
","13888234","","5437671","","2021-03-26 13:30:31","2021-03-26 13:30:31","Angular How to refresh data in observable on click","<angular><observable><rxjs-observables>","1","0","0","","","CC BY-SA 4.0"
"66837657","1","","","2021-03-28 01:27:11","","2","278","<p>I'm passing a value from a service to a component using <code>BehaviorSubject</code> -</p>
<p>In serviceFile.service.ts:</p>
<pre class=""lang-js prettyprint-override""><code>taskComplete = new BehaviorSubject&lt;{ complete: Boolean; error: any }&gt;(null);
...
this.taskComplete.next({ complete: false, error: error });
...
</code></pre>
<p>In componentFile.component.ts:</p>
<pre class=""lang-js prettyprint-override""><code>ngOnInit() {
    this.taskCompleteSub = this.myService.taskComplete.subscribe(
      (data) =&gt; {
            this.error = data.error
            ? data.error.error.message
            : null;
          console.log(this.error);
        }
    ); 
}
</code></pre>
<p>The problem is that the value of property <code>this.error</code> is changed and printed in <code>console.log()</code>, but this change is not reflected in the component template. In other words, angular does not check this change and re-render.</p>
","11729745","","446519","","2021-03-29 02:17:05","2021-03-29 02:17:05","Value from BehaviorSubject is not rendered in the subscribed component","<javascript><angular><rxjs><rxjs-observables>","3","3","","","","CC BY-SA 4.0"
"66871224","1","","","2021-03-30 12:44:36","","1","102","<p>I am currently writing an <a href=""https://ng-bootstrap.github.io/#/components/typeahead/api"" rel=""nofollow noreferrer"">ngbTypeahead</a> search and I am stuck because I have never really worked with Observables, which are the expected return type of the <a href=""https://ng-bootstrap.github.io/#/components/typeahead/examples#basic"" rel=""nofollow noreferrer"">ngbTypeahead search</a>.</p>
<p>The search function in my component looks like this:</p>
<pre class=""lang-js prettyprint-override""><code>  search: OperatorFunction&lt;string,  readonly LoqateResponseModel[]&gt; = (text$: Observable&lt;string&gt;) =&gt; {
return text$.pipe(
  switchMap(term =&gt; this.addressService.searchAddress(term, this.countryCode)),
  map(results =&gt; {
    const searchResults = results[LoqateKeyEnum.ITEMS] as [];
    const searchResultLoqateModels: LoqateResponseModel[] = [];
    searchResults.forEach(result =&gt; {
      searchResultLoqateModels.push(new LoqateResponseModel(
        result[LoqateKeyEnum.ID],
        result[LoqateKeyEnum.TYPE],
        result[LoqateKeyEnum.TEXT],
        result[LoqateKeyEnum.HIGHLIGHT],
        result[LoqateKeyEnum.DESCRIPTION]));
    });
    return searchResultLoqateModels;
  })
);
</code></pre>
<p>}</p>
<pre><code>resultFormatter = (loqateResponse: LoqateResponseModel): string =&gt; loqateResponse.display();
</code></pre>
<p>I am conducting a loqate search and am storing the results as model objects in a list and return them.</p>
<pre class=""lang-js prettyprint-override""><code>public searchAddress(searchValue, countryCode): Observable&lt;object&gt; 
  {
    const httpParams = new HttpParams();
    return this.httpClient.post(this.addressSearchUrl, {}, {
      headers: this.headers,
      params: new HttpParams()
        .set('Key', loqateKey)
        .set('Text', searchValue)
        .set('Origin', countryCode)
    });
  }
</code></pre>
<p>The Model looks like this:</p>
<pre class=""lang-js prettyprint-override""><code>export class LoqateResponseModel {
  constructor(
    public id: string,
    public type: LoqateTypeEnum,
    public text: string,
    public highlight: string,
    public description: string) {
  }

  public isAddress(): boolean { return this.type === LoqateTypeEnum.ADDRESS; }
  public display(): string { return this.text + ', ' + this.description; }
}
</code></pre>
<p>Now I thought, that a list of <code>LoqateResponseModels</code> is stored as result of the <code>search</code> and then each of these list items are being formatted properly to display in the typeahead popup through the <code>resultFormatter</code>.</p>
<p>tldr: I want to search something with the ngbTypeahead and query the search term from an API endpoint and display the search results in the typeahead popup.</p>
<p><strong>Edit</strong>: I've edited the answer, this code is working.</p>
","2968265","","2968265","","2021-03-30 16:32:42","2021-03-30 16:32:42","ngbTypeahead search results missing","<angularjs><typescript><rxjs><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"66896536","1","66903638","","2021-03-31 23:25:32","","0","46","<p>I am trying to setup a poller using expand but the behavior is not what I want</p>
<p><a href=""https://stackblitz.com/edit/rxjs-finalize-unsubscribe-6xy2yb?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-finalize-unsubscribe-6xy2yb?file=index.ts</a></p>
<p>checkExistence produces a random boolean - With the expand, I expect a recursive delayed call of the same checkExistence function producing random booleans every 5 seconds (after one initial call).</p>
<p>I also expect the stop to kick in 30seconds and stop the polling and 5 seconds later resume the random boolean stream. Any pointers will help.</p>
<p>Instead I get the same boolean value getting printed; also after the start is triggered, it produces batches of booleans together.</p>
","2789284","","","","","2021-04-01 11:25:29","Polling using expand in rxjs gives an unexpected result","<rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"66922012","1","66922310","","2021-04-02 16:01:27","","0","39","<p>I don't understand how to solve an issue in the following scenario:</p>
<pre><code>getPosts(): Observable&lt;Post[]&gt; {
    return this.http.get&lt;Post[]&gt;(this.postsUrl).pipe(
      tap(() =&gt; console.log('fetched posts')),
      catchError(this.handleError&lt;Post[]&gt;('getPosts', []))
    );
  }
</code></pre>
<p>.......</p>
<pre><code>export const mapYearWeek = (post: Post): Post =&gt; {
  post.time = `
  ${moment(parseInt(post.time)).year()}
  -${moment(parseInt(post.time)).week()}
  `;
  return post;
};
</code></pre>
<p>.........</p>
<pre><code>ngOnInit(): void {
    this.postService
      .getPosts()
      .pipe(
        mergeMap(res =&gt; res.map(mapYearWeek(post: Post))),  
        tap((res) =&gt; console.log(res)),
        groupBy((post: Post) =&gt; post.time),
        mergeMap((group) =&gt; group.pipe(toArray())),
        tap((res) =&gt; console.log(res))
      )
      .subscribe();
  }
</code></pre>
<p>I'm getting error with mapYearweek func:</p>
<blockquote>
<p>Argument of type 'Post' is not assignable to parameter of type
'(value: Post, index: number, array: Post[]) =&gt; unknown'.   Type
'Post' provides no match for the signature '(value: Post, index:
number, array: Post[]): unknown'.ts(2345)</p>
</blockquote>
","12566163","","","","","2021-04-02 16:25:57","RxJs map operator","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"67046042","1","","","2021-04-11 14:17:25","","0","37","<p>I have this method:</p>
<pre><code>onFormSubmit(formData: Pick&lt;Habit, 'name' | 'repeatVal' | 'notification' | 'color' | 'question'&gt;): void {
this.habitService
  // tslint:disable-next-line:max-line-length
  .createHabit(formData, this.authService.userId)
  .pipe(first())
  .subscribe((results) =&gt; console.log(results)
  });
console.log(formData);

// I would like to use the id from my Observable here in this method
this.statusService.createStatuses(id); 

this.updateService.callRefresh.next(true);
this.customizeForm.reset();
this.formDirective.resetForm();
// here the function to refresh the data-table should be called
this.updateService.callRefresh.next(false);
/*this.refresh.emit(null);*/
  }
</code></pre>
<p>Unfortunately &quot;results&quot; gets logged as &quot;undefined&quot;.
This is my service with the method that makes a post request and returns an Observable:</p>
<pre><code>createHabit(
formData: Partial&lt;Habit&gt;,
userId: Pick&lt;User, 'id'&gt;
): Observable&lt;Habit&gt; {
    return this.http
      .post&lt;Habit&gt;(
        this.habitsUrl,
        { name: formData.name,
          repeatVal: formData.repeatVal,
          notification: formData.notification,
          color: formData.color,
          question: formData.question,
          id: userId },
        this.httpOptions
      )
      .pipe(
        catchError(this.errorHandlerService.handleError&lt;Habit&gt;('createHabit'))
      );
  }
</code></pre>
<p>My service makes a post request to my database and there an automatic- autoincremented id gets created.</p>
<p><strong>How can I access the id within my &quot;onFormSubmit&quot;-Method in order to use it in my &quot;createStatuses&quot; function?</strong></p>
<p>This is my async-post-request-function:</p>
<pre><code>exports.postHabit = async (req, res, next) =&gt; {
const errors = validationResult(req);

if(!errors.isEmpty()) return;

const name = req.body.name;
const repeatVal = req.body.repeatVal;
const notification = req.body.notification;
const color = req.body.color;
const question = req.body.question;
const id = req.body.id;

try {
    const habitDetails = {
        name: name,
        repeatVal: repeatVal,
        notification: notification,
        color: color,
        question: question,
        id: id,
    };

    const result = await Habit.save(habitDetails);

    res.status(201).json(result)
} catch (err) {
    if(!err.statusCode){
        err.statusCode = 500;
    }
    next(err)
}
};
</code></pre>
","14016390","","14016390","","2021-04-11 17:41:50","2021-04-11 17:41:50","Access automatically created id of database while Observable is being created?","<javascript><angular><typescript><observable><rxjs-observables>","0","8","","","","CC BY-SA 4.0"
"67047367","1","","","2021-04-11 16:20:16","","0","23","<p>Specifically my question is about how to return a true observable from a .netcore web api controller, using efcore. This is so datasets can be returned as a stream so the front end can start building the page at once using the data that it receives in the first iteration and keep on until all data has been received.</p>
<p>So I have seen observable collections. I have also seen that EFCore now streams rather than buffers.</p>
<p>Can anyone point me at the documentation, or an example so I can do more reading?</p>
<p>Let's say I am returning 20 records, from my web api and returning them to a reactjs project. Reactjs supports observables using rxjs. What do I need to do in the web api app to support this observable flow from sql server all the way up to the controller level?</p>
","823073","","","","","2021-04-11 16:32:27","Return observable from .net web api","<sql-server><.net-core><entity-framework-core><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"67047554","1","67048704","","2021-04-11 16:35:39","","0","90","<p>I want to combine observables as is done with the &quot;merge&quot; operator but I still want to be able to know which input observable emitted, is there a way to do that?</p>
<p>For example:</p>
<pre><code>private result$ = merge(this.obs1$, this.obs2$).pipe(
    scan((result, change) =&gt; index + change, 0),
    shareReplay(1)
  );
</code></pre>
<p>Here both values from obs1 and obs2 will go into the &quot;change&quot; variable in the scan function whenever any of the input observables emit, but if I had access to a projector function where I could mark the values from the input observables with different names I could then do different things in the following scan function depending on which input observable emitted. Other operators like CombineLatest or ForkJoin do not seem to be applicable here either as they require completion or emits from all input observables.</p>
","10103655","","","","","2021-04-11 18:23:20","Use RxJs operator like merge but keep track of source observables in the result?","<rxjs><rxjs-observables>","2","1","","","","CC BY-SA 4.0"
"67048962","1","67049130","","2021-04-11 18:51:00","","-2","625","<p>I have this service that calls to an API to get a bunch of movie descriptions and returns an Observable:</p>
<pre><code>getNowPlayingMovies$(page: number, country?: string): Observable&lt;NowPlaying&gt; {
    console.log(`${this.baseUrl}${this.now_playing}?${this.key}&amp;region=${country || 'US'}&amp;page=${page}`);
    return this.http.get&lt;NowPlaying&gt;(
      `${this.baseUrl}${this.now_playing}?${this.key}&amp;region=${country || 'US'}&amp;page=${page}`
    );
  }
</code></pre>
<p>On the component that uses this function above I call it changing every time the page value so I can offer to the user pagination on the component view.</p>
<p>And this is the component that calls the service:</p>
<pre><code>getNowPlayingMovies(): void {
    this.nowPlayingService.getNowPlayingMovies$(this.page).subscribe((data) =&gt; {
      this.nowPlaying.push(
        ...data.results.filter((result) =&gt; result.backdrop_path)
      );
      if(!this.last_page){
        this.last_page = data.total_pages
        this.page++;
      } else if(this.page &lt;= data.total_pages) {
        this.page++;
      }
      console.log(data);
      console.log(this.nowPlaying);
    });
  }
</code></pre>
<p>I've read that on Angular you should always try to work using Observable rather than Promises but on scenarios like this I don't see any advantage of subscribing to the api call response.</p>
<p>It would be correct to transform the Observable in the service to a Promise like this?</p>
<pre><code>getNowPlayingMovies$(page: number, country?: string): Promise&lt;NowPlaying&gt; {
    console.log(`${this.baseUrl}${this.now_playing}?${this.key}&amp;region=${country || 'US'}&amp;page=${page}`);
    return this.http.get&lt;NowPlaying&gt;(
      `${this.baseUrl}${this.now_playing}?${this.key}&amp;region=${country || 'US'}&amp;page=${page}`
    ).toPromise();
  }
</code></pre>
<p>I'm learning Angular and I'm working this to add it to my portfolio so I want to learn to do it the right way and the best way possible.</p>
","3675533","","","","","2021-06-05 17:30:37","Angular api call: Observable vs Promise","<angular><promise><observable><angular-promise><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"67084167","1","","","2021-04-14 00:59:04","","0","60","<p>I'm sure this is a design issue on my part, but I'm trying to understand why RxJS pipe.subscribe callbacks do not fire. In the code below, <code>next</code>, <code>error</code>, and <code>complete</code> callbacks do not fire. What needs to change to make that happen?</p>
<p>In this case, the polling of the endpoint works just fine but the .subscribe callbacks never get called.</p>
<pre><code>this.service
      .postThing('/endpoint', {params})
      .then((response.id) =&gt; {
        interval(3000)
          .pipe(
            switchMap(() =&gt; this.service.getThing('/endpoint', response.id)),
            retryWhen((errors) =&gt;
              errors.pipe(filter((err) =&gt; err.status === 404))
            )
          )
          .subscribe(
            (data) =&gt; {
              console.log(data);
            },
            (error) =&gt; {
              console.log(error)
            },
            () =&gt; {
              this.service.stopLoading()
            }
          );
      });
</code></pre>
","469842","","","","","2021-04-14 14:53:41","Why do RxJS pipe subscribe callbacks sometimes not fire?","<angular><rxjs><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"67090904","1","67091436","","2021-04-14 11:31:20","","1","129","<p>Currently I am making 3 different API calls which are below like this:-</p>
<pre><code>//API Call1
getUserById(id){
return this.http
      .get(`${environment.userAPI}/user/${Id}`, { headers: this.headers })
      .pipe(
        catchError(err =&gt; {
          return throwError(this.errorHandler.handleError(err));
        }),
      );
}
//API Call 2:-
getTeamById(id){
return this.http
      .get(`${environment.TEAM_API}/team/${Id}`, { headers: this.headers })
      .pipe(
        catchError(err =&gt; {
          return throwError(this.errorHandler.handleError(err));
        }),
      );
};
////API Call 3:-
getGroupById(id){
return this.http
      .get(`${environment.GROUP_API}/group/${Id}`, { headers: this.headers })
      .pipe(
        catchError(err =&gt; {
          return throwError(this.errorHandler.handleError(err));
        }),
      );
};

//Now I am making all the Three API calls at once using forkJoin in the below way:-
forkJoin([getUserById(1), getTeamById(1),getGroupById(1)]).pipe(
      catchError(this.getCatchError)
    )
.subscribe([res1,res2,res3]=&gt;{
  console.log(res1,res2,res3)
})
</code></pre>
<p>Now I am  having a requirment where using res1 i need to check one condition and make another API call and combine with the above 3 results and my condition is on API call 1 when we get user details i need to check one field team-leader which contains one Id and based on that Id i need to make another API call which is like below:-</p>
<pre><code>////API Call 3:-
getLeaderById(id){
return this.http
      .get(`${environment.Leader_API}/leader/${Id}`, { headers: this.headers })
      .pipe(
        catchError(err =&gt; {
          return throwError(this.errorHandler.handleError(err));
        }),
      );
};
</code></pre>
<p>I am achieving the above requirement in the below way:-</p>
<pre><code>forkJoin([getUserById(1), getTeamById(1),getGroupById(1)]).pipe(
      catchError(this.getCatchError)
    )
.pipe(
mergeMap(res =&gt; 
if(res[0]?.teamLeaderId){
   return getLeaderById(res[0]?.teamLeaderId).//Here I am getting res as undefined
} else{
  return res;
}
)
)
.subscribe([res1,res2,res3,res4]=&gt;{
  console.log(res1,res2,res3,res4);//I am never ever reaching this line of code
})
</code></pre>
<p>Is there any mistake I am doing? By the end when all API calls are done I need to have 3 results as mandatory and 4th one is optional based on condition.
I am new to RXJS.
<strong>Note:-</strong>
I am using the above code in Angular9 using typescrip</p>
","13851398","","","","","2021-04-14 12:14:35","Getting error making a API call(using mergeMap) from the result array of forkJoin and need the combinedResult in Angular","<javascript><angular><rxjs><observable><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"67111776","1","67112389","","2021-04-15 15:50:39","","0","46","<p>There are several resources out there (<a href=""https://www.seangwright.me/blog/development/unsubscribe-angular-2-http-observables/"" rel=""nofollow noreferrer"">like this one</a>) that define what a &quot;finite&quot; observable is (an observable that eventually stops emitting values). From what I've read, it is generally accepted that finite observables do not need to be unsubscribed from.</p>
<p>Is there anything that needs to be done to explicitly define an Observable as &quot;finite&quot;? <a href=""https://lukaonik.medium.com/do-we-need-to-unsubscribe-http-client-in-angular-86d781522b99"" rel=""nofollow noreferrer"">This article</a> shows how the Angular HttpClient calls <code>complete()</code> on its <code>Observer</code> is something that forces its observers to unsubscribe. Is this what makes it &quot;finite&quot;? Or can an observable be finite just by its nature, without explicitly calling <code>complete()</code>? If so, is it safe to NOT unsubscribe from an observable that is finite by nature?</p>
","4321862","","","","","2021-04-15 16:30:05","Do I have to explicitly define an observable as ""finite""?","<angular><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"67139504","1","67159341","","2021-04-17 14:52:23","","3","159","<p>Considering I have the following code:</p>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let Rx = window['rxjs'];
const { of,
    queueScheduler,
    asapScheduler,
    asyncScheduler,
    animationFrameScheduler
} = Rx;
const { observeOn, tap } = Rx.operators;
console.clear();


let source$ = of(1, 2, 3, asapScheduler).pipe(
    tap((v) =&gt; {
        console.log('tap ', v);
    }),
)

source$.subscribe((v) =&gt; {
    console.log('Value ', v);
    Promise.resolve().then(() =&gt; {
        console.log('Microtask value ', v);
    });
});</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.2.1/rxjs.umd.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
<p>Which I use asapScheduler operator.</p>
<p>As per the documentation,</p>
<p>asap will wait for the current synchronously executing code to end and then it will try to execute the given task as fast as possible.</p>
<p>What's the execution order of the above code? How do they work? I would not have expected that the tap3 to print at the last</p>
<p>Below are the output,</p>
<pre><code>tap  1
Value  1  
tap  2    // here why did this not print Microtask value 1 and Microtask value 2 after printing tap1 and value1?
Value  2
Microtask value  1
Microtask value  2
tap  3
Value  3
Microtask value  3
</code></pre>
","4646531","","4646531","","2021-04-18 18:23:22","2021-04-19 09:25:57","Order of execution with rxjs asapscheduler","<rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators><rxjs-marbles>","2","0","","","","CC BY-SA 4.0"
"67174632","1","","","2021-04-20 07:49:39","","0","68","<p>Working in <code>Angular</code> with <code>RxJs</code> all data retrieval is done with <code>Observables</code> and the <code>async</code> pipe in the html.
This is the correct approach to avoid <code>Subscriptions</code> in the <code>Component</code>.</p>
<p>How can i achieve the same when posting data to the server? I have no view that can await this call but i want to remove the <code>.subscribe()</code> from my Component.</p>
","1903386","","","","","2021-04-20 09:41:53","Angular RxJS HttpPost without subscriptions","<angular><rxjs><http-post><rxjs-observables>","3","3","","","","CC BY-SA 4.0"
"67180861","1","67181016","","2021-04-20 14:24:34","","0","96","<p>want to optimize the following code:
multiple subscription in multiple if else statements.</p>
<p>consider:-</p>
<pre><code>getList(): void {
    this.subs.sink = this.subscription1.subscribe((user) =&gt; {
      if (user) {
        this.method1();
      }
    });
  }

method1() {
//code
//code
if (condition){
//code
} else {
this.method2()
}

method2(){
 this.subs.sink = this.subscription2.subscribe(
      (response) =&gt; {
if(){
//code
} else {
this.method3();
}
}

method3(){
this.subs.sink = this.subcription3.subscribe(
      (response) =&gt; {
//code
}
}
</code></pre>
<p>this resulting in triggering multiple subscription.</p>
<p>Any help. Appreciated.</p>
","4300263","","","","","2021-04-20 14:44:14","RXJS - subscription trigger multiple times. Nested Subscription with multiple if else conditions","<angular><if-statement><rxjs-observables><angular-observable>","1","0","","","","CC BY-SA 4.0"
"67200196","1","","","2021-04-21 16:51:38","","0","16","<p>I am writing tests for a module which contains an Observable that emits several values. In short, the observable emits a value every time the module logs on or off. For the test, I use beforeAll to log in and I create a test to then test the observable. The problem I'm getting is that after the test, I log off again during cleanup, which causes the test to fail.</p>
<p>The test looks like this:</p>
<pre><code>test('Connected', (done) =&gt; {
const connectedSub: Subscription = service.loggedIn.subscribe((data) =&gt; {
    console.log(&quot;ConnectedSub: &quot;+data);
    if(data === true){
        done();
    }else{
        done.fail(&quot;loggedin was &quot;+data);
    }
});
</code></pre>
<p>}, 2000);</p>
<p>The problem i run into is that the test passes as expected (As I can see in the console log). But when the test logs off during cleanup, done.fail() gets called, and the test ends up being flagged as failed.</p>
<p>I tried to put in an unsubscribe:</p>
<pre><code>test('Connected', (done) =&gt; {
const connectedSub: Subscription = service.loggedIn.subscribe((data) =&gt; {
    console.log(&quot;ConnectedSub: &quot;+data);
    if(data === true){
        done();
        connectedSub.unsubscribe();
    }else{
        done.fail(&quot;loggedin was &quot;+data);
    }
});
</code></pre>
<p>}, 2000);</p>
<p>But I then end up with this error, even though the test is actually flagged as passed:</p>
<pre><code>console.error
ReferenceError: connectedSub is not defined
</code></pre>
<p>What exactly am i doing wrong here? How do I test the value of an observable in a test, and then stop listening before the next events come in?</p>
","929587","","929587","","2021-04-21 17:16:09","2021-04-21 17:16:09","Testing recurring observable with jest","<ecmascript-6><jestjs><rxjs-observables>","0","1","","","","CC BY-SA 4.0"
"67224707","1","67226647","","2021-04-23 06:01:34","","0","63","<p>I tried to understand, how mergeMap worked in this example and still don't understand. Can you help me?</p>
<pre><code>import { interval } from 'rxjs';
import { mergeMap, take } from 'rxjs/operators';


// emit value every 1s
const source$ = interval(1000);

source$
  .pipe(
    mergeMap(
      // project
      val =&gt; interval(5000).pipe(take(2)),
      // resultSelector
      (oVal, iVal, oIndex, iIndex) =&gt; [oIndex, oVal, iIndex, iVal],
      // concurrent
      2
    )
  )
  /*
        Output:
        [0, 0, 0, 0] &lt;--1st inner observable
        [1, 1, 0, 0] &lt;--2nd inner observable
        [0, 0, 1, 1] &lt;--1st inner observable
        [1, 1, 1, 1] &lt;--2nd inner observable
        [2, 2, 0, 0] &lt;--3rd inner observable
        [3, 3, 0, 0] &lt;--4th inner observable
*/
  .subscribe(val =&gt; console.log(val));
</code></pre>
<p><a href=""https://stackblitz.com/edit/typescript-r3gcr4?file=index.ts&amp;devtoolsheight=100"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/typescript-r3gcr4?file=index.ts&amp;devtoolsheight=100</a></p>
<p>I don't understand the values displayed in the console</p>
<p>I thank you in advance.</p>
","10932458","","10932458","","2021-04-23 06:09:38","2021-04-23 08:35:17","How the mergeMap operator works?","<rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"67235013","1","","","2021-04-23 18:15:11","","2","798","<p>I am using Angular 11 and I am accessing an observable in the template of my component with <strong>async</strong> pipe.</p>
<p>First load of the route, everything works perfectly fine. No error. When I navigate away from the page and come back, I get following error:</p>
<p>Component Template:
&lt;RM-map
*ngIf=&quot;(layers$ | async) as layers&quot;
[layers]=&quot;layers.layerConfig&quot;
showLayersPanel=&quot;true&quot; id=&quot;RIS-map&quot;&gt;
</p>
<p><strong>Component</strong></p>
<pre><code>import { Component, OnDestroy, OnInit } from '@angular/core';
import { Observable, Subject } from 'rxjs';

import { FullMapViewService } from '../services/full-map-view.service';
import { RISLayerConfigResponse } from '@RM/interfaces';
import { takeUntil } from 'rxjs/operators';

@Component({
  selector: 'RM-full-map-view',
  templateUrl: './full-map-view.component.html',
  styleUrls: ['./full-map-view.component.scss']
})
export class FullMapViewComponent implements OnInit, OnDestroy {
  layers$: Observable&lt;RISLayerConfigResponse&gt;;
  destroyed$: Subject&lt;boolean&gt; = new Subject();
  constructor(private fullMapViewService: FullMapViewService) {}

  ngOnInit(): void {
    this.fullMapViewService.setParamsRequiredForRIS();
    this.fullMapViewService.initializeRISLayerCreationService();
    this.layers$ = this.fullMapViewService
      .getLayersForAllProjects()
      .pipe(takeUntil(this.destroyed$));
  }

  ngOnDestroy() {
    this.destroyed$.next(true);
  }
}
</code></pre>
<p><strong>full-map-view.service.ts</strong></p>
<pre><code>import { DEPLOYMENT_PATH, SET_FROM_SERVER } from '@XYZ/RIS';
import {
  DataSet,
  DatasetsAndLayerConfig,
  RISLayerConfigResponse,
  RISLayerSettingsWithKind,
  Layer,
  LayerConfig,
  UpdateViewVCS
} from '@XYZ/interfaces';
import { Injectable, OnDestroy } from '@angular/core';
import { Observable, Subscription } from 'rxjs';

import { API_PATHS } from '../../api-paths';
import { BaseAPIService } from '@XYZ/core';
import { ClauseGenerationUtility } from '../../utils/clause-generation/clause-generation.util';
import { RISLayerCreationService } from '@ABC-innersource/RIS-canvas';
import { LAYER_COLOR_PALLET } from '../../services/services.constant';
import { map } from 'rxjs/operators';

@Injectable()
export class FullMapViewService implements OnDestroy {
  layersMappingConfiguration: {};
  layers: LayerConfig;
  private clauseGenerator = new ClauseGenerationUtility();
  private addUpdateVCSForKindSubscriptions: Subscription[];
  private initializeRISLayerCreationServiceSubscription: Subscription;
  private deploymentUrl: string;
  private appKey: string;
  private ABCDataPartitionId: string;
  private sToken: string;

  constructor(
    private baseAPIService: BaseAPIService,
    private layerCreationService: RISLayerCreationService
  ) {}

  // eslint-disable-next-line max-lines-per-function
  getLayersForAllProjects(): Observable&lt;RISLayerConfigResponse&gt; {
    return this.baseAPIService
      .get(API_PATHS.LAYERS.GET_LAYERS + '/projects/all')
      .pipe(
        map((res: DatasetsAndLayerConfig) =&gt; {
          return res;
        }),
        // eslint-disable-next-line max-lines-per-function
        map((datasetsAndLayerConfig: DatasetsAndLayerConfig) =&gt; {
          const datasets = [...datasetsAndLayerConfig.datasets];
          const notConfiguredKinds = [
            ...datasetsAndLayerConfig.layerConfig.notConfiguredKinds
          ];
          const notConfiguredKindsLayers = this.getNonConfiguredKindsLayers(
            notConfiguredKinds
          );
          const layers = this.combineLayersAndNotConfiguredKindsLayers(
            datasetsAndLayerConfig.layerConfig.layerConfig,
            notConfiguredKindsLayers
          );
          const kindsLayersHashmap = this.getKindsLayersHashmap(layers);
          const layersByDatasets = datasets
            .map((dataset: DataSet) =&gt; {
              return {
                ...this.updateLayersWithDatasetNameAndClauses(
                  kindsLayersHashmap,
                  dataset
                )
              };
            })
            .filter((layer) =&gt; {
              return Object.keys(layer).length !== 0;
            })
            .map((layer, index) =&gt; {
              return {
                ...this.assignColourToLayer(layer, index)
              };
            });
          return {
            layerConfig: layersByDatasets,
            notConfiguredKinds: []
          };
        })
      );
  }

  setParamsRequiredForRIS(): void {
    this.sToken = SET_FROM_SERVER;
    this.deploymentUrl = DEPLOYMENT_PATH;
    this.appKey = SET_FROM_SERVER;
    this.ABCDataPartitionId = SET_FROM_SERVER;
  }

  initializeRISLayerCreationService(): void {
    this.initializeRISLayerCreationServiceSubscription = this.layerCreationService
      .initialize(
        this.sToken,
        this.deploymentUrl,
        this.appKey,
        this.ABCDataPartitionId
      )
      .subscribe();
  }

  ngOnDestroy(): void {
    this.initializeRISLayerCreationServiceSubscription.unsubscribe();
    this.addUpdateVCSForKindSubscriptions.forEach(
      (subscription: Subscription) =&gt; {
        subscription.unsubscribe();
      }
    );
  }

  private updateLayersWithDatasetNameAndClauses(
    kindsLayersHashmap: Map&lt;string, RISLayerSettingsWithKind&gt;,
    dataset: DataSet
  ): RISLayerSettingsWithKind {
    const currentDataset = { ...dataset };
    const datasetKind = this.generateKindFromDataset(currentDataset);
    const layer = kindsLayersHashmap.get(datasetKind);
    const queryRef = this.getFormattedQuery(
      currentDataset.dataSetDefinition.queryDefinition.queryRef
    );
    const clause = this.clauseGenerator.generateClause(queryRef);

    if (!layer) {
      return undefined;
    }

    layer.name = currentDataset.name;
    layer.tableInfo.where = clause;
    return JSON.parse(JSON.stringify(layer));
  }

  private generateKindFromDataset(dataset: DataSet): string {
    const currentDataset = { ...dataset };
    const datasetQueryDefinition =
      currentDataset.dataSetDefinition.queryDefinition;
    return `${datasetQueryDefinition.authority}:${datasetQueryDefinition.source}:${datasetQueryDefinition.entity}:${datasetQueryDefinition.version}`;
  }

  private getKindsLayersHashmap(
    layers: RISLayerSettingsWithKind[]
  ): Map&lt;string, RISLayerSettingsWithKind&gt; {
    const kindsLayersHashmap = new Map();
    const allLayers = [...layers];
    allLayers.forEach((layer: RISLayerSettingsWithKind) =&gt; {
      kindsLayersHashmap.set(layer.kind, layer);
    });
    return kindsLayersHashmap;
  }

  private getNonConfiguredKindsLayers(
    kinds: string[]
  ): RISLayerSettingsWithKind[] {
    const notConfiguredKindsLayers: RISLayerSettingsWithKind[] = [];
    kinds.forEach((kind) =&gt; {
      const layer: RISLayerSettingsWithKind[] = this.layerCreationService.getLayerInfoByKindName(
        kind
      ) as RISLayerSettingsWithKind[];
      if (layer.length &gt; 0) {
        layer[0].kind = kind;
        notConfiguredKindsLayers.push(layer[0]);
        this.addUpdateRISLayerInVCS({ kind: kind, configuration: layer[0] });
      }
    });
    return notConfiguredKindsLayers;
  }

  private addUpdateRISLayerInVCS(layer: Layer): void {
    const currentLayer = { ...layer };
    const updateViewPayload: UpdateViewVCS = {
      control: 'RIS',
      definition: [{ ...currentLayer.configuration }]
    };
    this.addUpdateVCSForKind(currentLayer.kind, updateViewPayload);
  }

  private addUpdateVCSForKind(kind: string, payload: UpdateViewVCS): void {
    const subscription = this.baseAPIService
      .post(
        `${API_PATHS.CONFIG.VIEW.UPDATE_RIS_VIEW_CONFIG}`.replace(
          '${kind}',
          kind
        ),
        payload
      )
      .subscribe();
    this.addUpdateVCSForKindSubscriptions.push(subscription);
  }

  private combineLayersAndNotConfiguredKindsLayers(
    layers: RISLayerSettingsWithKind[],
    notConfiguredKindsLayers: RISLayerSettingsWithKind[]
  ): RISLayerSettingsWithKind[] {
    const allLayers = [...layers];
    const allNotConfiguredKindsLayers = [...notConfiguredKindsLayers];
    return [...allLayers, ...allNotConfiguredKindsLayers];
  }

  private getFormattedQuery(query: string): string {
    let formattedQuery = '';
    if (
      this.clauseGenerator.hasAndOperator(query) ||
      this.clauseGenerator.hasOrOperator(query)
    ) {
      formattedQuery = this.clauseGenerator.isWrappedWithRoundBrackets(query)
        ? query
        : `(${query})`;
      return formattedQuery;
    }
    return formattedQuery;
  }

  private assignColourToLayer(
    layer: RISLayerSettingsWithKind,
    index: number
  ): RISLayerSettingsWithKind {
    const colors = LAYER_COLOR_PALLET;
    const currentLayer = JSON.parse(JSON.stringify(layer));
    currentLayer.style.rules[0].style.fillColor = colors[index];
    currentLayer.style.rules[0].style.borderColor = '#000';
    return currentLayer;
  }
}
</code></pre>
<p>For e.g. route B is my component containing the observable
A ---&gt; B the observable loads perfectly fine. B ----&gt; A and again A ----&gt; B the observable throws below error.</p>
<pre><code>ObjectUnsubscribedErrorImpl {message: &quot;object unsubscribed&quot;, name: &quot;ObjectUnsubscribedError&quot;}
message: &quot;object unsubscribed&quot;
name: &quot;ObjectUnsubscribedError&quot;
</code></pre>
<p>Full stack trace snapshot is as shown below:</p>
<pre><code>    core.js:6162 ERROR ObjectUnsubscribedErrorImpl {message: &quot;object unsubscribed&quot;, name: &quot;ObjectUnsubscribedError&quot;}message: &quot;object unsubscribed&quot;name: &quot;ObjectUnsubscribedError&quot;__proto__: Error

defaultErrorLogger  @   core.js:6162
handleError @   core.js:6210
(anonymous) @   core.js:29503
invoke  @   zone-evergreen.js:364
run @   zone-evergreen.js:123
runOutsideAngular   @   core.js:28439
tick    @   core.js:29503
(anonymous) @   core.js:29372
invoke  @   zone-evergreen.js:364
onInvoke    @   core.js:28510
invoke  @   zone-evergreen.js:363
run @   zone-evergreen.js:123
run @   core.js:28394
next    @   core.js:29371
schedulerFn @   core.js:25848
__tryOrUnsub    @   Subscriber.js:183
next    @   Subscriber.js:122
_next   @   Subscriber.js:72
next    @   Subscriber.js:49
next    @   Subject.js:39
emit    @   core.js:25838
checkStable @   core.js:28447
onLeave @   core.js:28560
onInvokeTask    @   core.js:28504
invokeTask  @   zone-evergreen.js:398
runTask @   zone-evergreen.js:167
invokeTask  @   zone-evergreen.js:480
invokeTask  @   zone-evergreen.js:1621
globalZoneAwareCallback @   zone-evergreen.js:1658
load (async)        
customScheduleGlobal    @   zone-evergreen.js:1773
scheduleTask    @   zone-evergreen.js:385
onScheduleTask  @   zone-evergreen.js:272
scheduleTask    @   zone-evergreen.js:378
scheduleTask    @   zone-evergreen.js:210
scheduleEventTask   @   zone-evergreen.js:236
(anonymous) @   zone-evergreen.js:1928
(anonymous) @   http.js:1805
_trySubscribe   @   Observable.js:42
subscribe   @   Observable.js:28
call    @   catchError.js:14
subscribe   @   Observable.js:23
call    @   catchError.js:14
subscribe   @   Observable.js:23
innerSubscribe  @   innerSubscribe.js:67
_innerSub   @   mergeMap.js:57
_tryNext    @   mergeMap.js:51
_next   @   mergeMap.js:34
next    @   Subscriber.js:49
(anonymous) @   subscribeToArray.js:3
_trySubscribe   @   Observable.js:42
subscribe   @   Observable.js:28
call    @   mergeMap.js:19
subscribe   @   Observable.js:23
call    @   filter.js:13
subscribe   @   Observable.js:23
call    @   map.js:16
subscribe   @   Observable.js:23
call    @   map.js:16
subscribe   @   Observable.js:23
call    @   map.js:16
subscribe   @   Observable.js:23
createSubscription  @   common.js:4224
_subscribe  @   common.js:4305
transform   @   common.js:4292
ɵɵpipeBind1 @   core.js:25718
FullMapViewComponent_Template   @   full-map-view.component.html:2
executeTemplate @   core.js:9549
refreshView @   core.js:9418
refreshComponent    @   core.js:10584
refreshChildComponents  @   core.js:9215
refreshView @   core.js:9468
refreshEmbeddedViews    @   core.js:10538
refreshView @   core.js:9442
refreshEmbeddedViews    @   core.js:10538
refreshView @   core.js:9442
refreshComponent    @   core.js:10584
refreshChildComponents  @   core.js:9215
refreshView @   core.js:9468
renderComponentOrTemplate   @   core.js:9532
tickRootContext @   core.js:10758
detectChangesInRootView @   core.js:10783
detectChanges   @   core.js:22751
tick    @   core.js:29491
(anonymous) @   core.js:29372
invoke  @   zone-evergreen.js:364
onInvoke    @   core.js:28510
invoke  @   zone-evergreen.js:363
run @   zone-evergreen.js:123
run @   core.js:28394
next    @   core.js:29371
schedulerFn @   core.js:25848
__tryOrUnsub    @   Subscriber.js:183
next    @   Subscriber.js:122
_next   @   Subscriber.js:72
next    @   Subscriber.js:49
next    @   Subject.js:39
emit    @   core.js:25838
checkStable @   core.js:28447
onHasTask   @   core.js:28527
hasTask @   zone-evergreen.js:419
_updateTaskCount    @   zone-evergreen.js:440
_updateTaskCount    @   zone-evergreen.js:263
runTask @   zone-evergreen.js:184
drainMicroTaskQueue @   zone-evergreen.js:569
invokeTask  @   zone-evergreen.js:484
invokeTask  @   zone-evergreen.js:1621
globalZoneAwareCallback @   zone-evergreen.js:1647
</code></pre>
<p>If you see, <code>FullMapViewComponent_Template  @   full-map-view.component.html:2</code> mentions an issue with the observable on the template.</p>
<p>I am unsure how to handle this. This template is on Route B.</p>
","1696515","","1696515","","2021-04-24 11:57:15","2021-07-24 22:18:35","ObjectUnsubscribedErrorImpl on an observable in a template in Angular","<javascript><angular><rxjs><reactive-programming><rxjs-observables>","5","15","1","","","CC BY-SA 4.0"
"67247897","1","67248047","","2021-04-24 22:10:01","","1","102","<p>I get the error</p>
<pre><code>Argument of type 'string' is not assignable to parameter of type 'never'.
</code></pre>
<p>When trying to spy on <code>timer</code> like this:</p>
<pre class=""lang-js prettyprint-override""><code>it('should start a timer', async () =&gt; {
  spyOn(Observable, 'timer');
});
</code></pre>
<p>Import statement:</p>
<pre class=""lang-js prettyprint-override""><code>import { Observable } from 'rxjs';
</code></pre>
<p>Any idea why?</p>
","5748151","","","","","2021-04-24 22:33:40","spyOn Observable timer not possible - Argument of type 'string' is not assignable to parameter of type 'never'","<timer><rxjs><jasmine><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"67275111","1","67276518","","2021-04-26 23:41:18","","0","33","<h3>Issue description</h3>
<p>First of all, let me start by saying that I am using <strong>Angular 10 with the Nebular UI Library</strong> for the front-end, <strong>Node.js</strong> for the back-end API, and <strong>JWT with the email/password strategy</strong> for authentication. I have noticed that <em>for every time the user sings-in and signs back out without refreshing the application, a new duplicate sign-out request is made to the server</em> (multiple http requests are being sent out).
<strong>If you refresh the application after you sign back out though, the problem goes away</strong>. I'm not sure if I'm skipping something or I'm simply ignorant on the right way to log out and sign back in using JWTs, but I've been trying to find a solution to this problem for days now with no success so I'm eager for some help.</p>
<p><strong>Current behavior:</strong></p>

<p>If the user were to sign in and logs back out again more than once, <strong>the sign-out request made to the server is duplicated</strong>. This issue persists REGARDLESS of if you use an http interceptor (NbAuthJWTInterceptor or otherwise).</p>
<p><strong>Expected behavior:</strong></p>

<p>If the user were to sign in and log back out again, <strong>there should be NO redundant sign-out requests made to the server</strong> regardless of how many times the user repeats these steps without refreshing the app.</p>
<p><strong>Steps to reproduce:</strong></p>

<ol>
<li>The first time the user signs in everything works fine and there are no duplicate requests made to the server when you log out.</li>
<li>After you <strong>sign back in for the 2nd time</strong> and <strong>sign out for the 2nd time</strong> without refreshing the application, the 2nd sign out request you make to the server will send out a duplicate sign-out request (2 identical sign-out requests are sent to the server).</li>
<li>If the user <strong>signs in again for a 3rd time</strong> and <strong>signs back out for a 3rd time</strong>, then 3 sign-out requests will be sent to the server (a total of 3 identical requests sent out).</li>
<li>If the user were to sign in and log back out again, <strong>the sign-out request would sent be duplicated one more time</strong> and a total of 4 identical sign-out requests would be sent out. This continues indefinitely.</li>
</ol>
<p>Here is a screenshot from my dev-tools network tab for these 4 steps (after signing-in and signing back out 4 times):
<img src=""https://user-images.githubusercontent.com/22666742/116158448-606fba80-a6f7-11eb-9917-19ac488bd557.jpg"" alt=""duplicates"" /></p>
<p><strong>Related code:</strong>
On the client side I have the <strong>header.component.ts</strong> file from which the sign out process is initiated:</p>
<pre><code>...
ngOnInit() {
    // Context Menu Event Handler.
    this.menuService.onItemClick().pipe(
      filter(({ tag }) =&gt; tag === 'my-context-menu'),
      map(({ item: { title } }) =&gt; title),
    ).subscribe((title) =&gt; {
      // Check if the Logout menu item was clicked.
      if (title == 'Log out') {

        // Logout the user.
        this.authService.logout('email').subscribe(() =&gt; {
          // Clear the token.
          this.tokenService.clear()
          // Navigate to the login page.
          return this.router.navigate([`/auth/login`]);
        });

      }
      if (title == 'Profile') {
        return this.router.navigate([`/pages/profile/${this.user[&quot;_id&quot;]}`]);
      }
    });
}
...
</code></pre>
<p>On the server side, there is the sign-out API route that returns a successful 200 response:</p>
<pre><code>// Asynchronous POST request to logout the user.
router.post('/sign-out', async (req, res) =&gt; {
    return res.status(200).send();
});
</code></pre>
","10850718","","10850718","","2021-04-27 09:39:46","2021-04-27 09:39:46","A new duplicate sign-out HTTP request is sent every time the user logs out: Angular, RxJs","<angular><rxjs><jwt><rxjs-observables><nebular>","1","0","","","","CC BY-SA 4.0"
"67283570","1","","","2021-04-27 13:00:04","","0","41","<p><strong>Problem:</strong>
I'm using Subject observable to pass String data between components (that are too far apart in the hierarchy). I would like to be able to tell how many subscribers there are to the Subject when a component subscribes or unsubscribes. How can above be achieved? Sorry I'm new to RxJS.</p>
<p><strong>Backstory:</strong>
I have a simple search/filter field at the top (navbar). The main view displays a component, some components are searchable, other are not. Each searchable component subscribes to the search/filter (via service). <strong>I would like to hide search/filter field when there are no subscribers and display when there is at least one subscriber.</strong></p>
<p>I know the above logic can be archived via routes, but I would like to do it via observable count.</p>
","635610","","542251","","2021-04-27 13:14:59","2021-04-27 13:21:58","RxJS subscribe to change in subscribers count","<angular><rxjs><rxjs-observables><subject-observer>","1","1","","2021-04-27 14:43:52","","CC BY-SA 4.0"
"67294007","1","","","2021-04-28 05:00:41","","0","43","<p>What i am trying to do is</p>
<ol>
<li>call a service and bind the data on ngOnit()</li>
<li>In the given textbox, when a user types something, instead of calling API call for every letter, wait for a second, if user doesn't type further, then make API call (need to debounce between user strokes).</li>
<li>When the search is done, i want to bind that data back.</li>
</ol>
<p>Issue: For the below API call, for the same search keyword 3 to 4 calls are made, i want to make 1 call instead, any help will be appreciated, thanks.</p>
<p>In my html file</p>
<pre><code>&lt;div *ngIf=let result in result$ | async&gt;
  
&lt;/div&gt;
&lt;input type=&quot;text&quot; (keyup)=&quot;filterData($event)&quot;&gt;
</code></pre>
<p>In my component file</p>
<pre><code>ngOnInit(){

this.result$ =  someServiceCall(); //result$ is an observable
}

filterData(event)
{
  fromEvent(event.target, 'keyup')
  .pipe(debounceTime(1000), distinctUntilChanged(),
  mergeMap((search) =&gt; {
    this.result$ = someServiceCall(event.target.value)
    }))
observable.subscribe(value) =&gt; {
})
}
return this.result$
}
</code></pre>
","441664","","","","","2021-04-28 05:43:31","Avoiding duplicate calls inside keyup event in angular","<angular><rxjs><angular-material><rxjs5><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"67297034","1","67297650","","2021-04-28 09:00:06","","0","49","<p>I am having a requirement to make multiple API calls using fork-join we need to make a retry if any one of the API calls after 3seconds and even then the API is failing then we should not go to subscribe. And the retry should also happen for one time retry that's all
For the above requirement, I implemented in the below way:-</p>
<pre><code>const getPosts = this.api
      .get(&quot;/posts/&quot;)
      .pipe(catchError(this.getCatchError));
    const getPostsFaliure = this.api.get(&quot;/postsasdfs/&quot;)
      .pipe(catchError(this.getCatchError));
    ;
    forkJoin(getPosts, getPostsFaliure)
      .pipe(
        retryWhen(err =&gt; {
          err.pipe(
            tap(val =&gt; console.log(`Value ${val} was too high!`)),
            //restart in 6 seconds
            delayWhen(val =&gt; timer(val * 1000))
          );
        })
      )
      .subscribe(res =&gt; console.log(res));
</code></pre>
<p>and getCatcherror is there in this way:-</p>
<pre><code>getCatchError(error) {
    return of(false);
  }
</code></pre>
<p>for the above implementation, I am getting the below result:-</p>
<pre><code>[Array(100),false]
</code></pre>
<p>it's not going into err and retry is also not working for me API call is going only one time and  I need to restrict it going to subscribe until the APIs are passing if at least one is failing I need to go to err part of subscribing. And I am having a strict rule to use retry when from rxjs
How to solve this issue</p>
<p>Stackblitz URL:-<a href=""https://stackblitz.com/edit/angular-api-call-cpr1hk?file=src/app/app.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-api-call-cpr1hk?file=src/app/app.component.ts</a></p>
","13851398","","9406763","","2021-04-29 16:26:35","2021-04-29 16:26:35","Unable to make a retry for API call Getting the success event","<angular><typescript><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","6","","","","CC BY-SA 4.0"
"67319467","1","67319771","","2021-04-29 14:32:10","","1","105","<p>I have a project based on the Angular.io tutorial, including &quot;Hero&quot;-interface and data, as well as a &quot;HeroService&quot; using HTTPClient.</p>
<p>I am able to fetch the data and display it using standard HTML in the template, but not when using the PrimeNG table, using the example from their webpage. So I have the data I need for the template, but I am not sure how to correctly pass it to PrimeNG. I am hoping to do it whithout changing how the HeroSerice works.</p>
<p>I am in general confused by Observables, Promises, and associated tech, so it's hard to describe further. I have read <a href=""https://stackoverflow.com/questions/44238215/using-primeng-with-observables-rxjs-in-angular-4"">Using PrimeNG with Observables (rxjs) in Angular 4</a>, without solving my issue.</p>
<p>Hero Interface:</p>
<pre><code>export interface Hero {
  id: number;
  name: string;
}
</code></pre>
<p>InMemoryDataService:</p>
<pre><code>export class InMemoryDataService implements InMemoryDbService {
  createDb() {
    const heroes = [
      { id: 11, name: 'Dr Nice' },
      { id: 12, name: 'Narco' },
      { id: 13, name: 'Bombasto' },
      { id: 14, name: 'Celeritas' },
      { id: 15, name: 'Magneta' },
      { id: 16, name: 'RubberMan' },
      { id: 17, name: 'Dynama' },
      { id: 18, name: 'Dr IQ' },
      { id: 19, name: 'Magma' },
      { id: 20, name: 'Tornado' }
    ];
    return {heroes};
  }
</code></pre>
<p>Method from HeroService:</p>
<pre><code>  /** GET heroes from the server */
  getHeroes(): Observable&lt;Hero[]&gt; {
    return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
      .pipe(
        catchError(this.handleError&lt;Hero[]&gt;('getHeroes', []))
      );
  }
</code></pre>
<p>My TreeTableComponent:(naming from before I scaled it down to be a table)</p>
<pre><code>export class TreeTableComponent implements OnInit {

  heroes: Hero[] = [];
  

  constructor(private heroService : HeroService) { }

  ngOnInit() {
    this.getHeroes();
  }
  
  getHeroes(): void {
    this.heroService.getHeroes().pipe(tap(heros =&gt; console.log(heros)))
    .subscribe((heroes: Hero[]) =&gt; {
      this.heroes = heroes as Hero[];
    }
      )};
</code></pre>
<p><strong>So, the issue:</strong></p>
<p>This works:</p>
<pre><code>  &lt;ul class=&quot;heroes&quot;&gt;
    &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;
      &lt;a routerLink=&quot;/detail/{{hero.id}}&quot;&gt;
        &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
      &lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
</code></pre>
<p>But this does not:</p>
<pre><code>&lt;p-table [value]=&quot;heroes&quot;| async&gt;
    &lt;ng-template pTemplate=&quot;header&quot;&gt;
        &lt;tr&gt;
            &lt;th&gt;id&lt;/th&gt;
            &lt;th&gt;name&lt;/th&gt;        
        &lt;/tr&gt;
    &lt;/ng-template&gt;
    &lt;ng-template pTemplate=&quot;body&quot; let-hero&gt;
        &lt;tr&gt;
            &lt;td&gt;{{heroes.id}}&lt;/td&gt;
            &lt;td&gt;{{heroes.name}}&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/ng-template&gt;
  &lt;/p-table&gt;[enter image description here][1]
</code></pre>
<p>The error I get is:</p>
<p>TS2339: Property 'id' does not exist on type 'Hero[]'.</p>
<p>TS2339: Property 'name' does not exist on type 'Hero[]'.</p>
<p>![1]: <a href=""https://i.stack.imgur.com/EJ06E.png"" rel=""nofollow noreferrer"">https://i.stack.imgur.com/EJ06E.png</a></p>
","15793633","","","","","2021-04-29 15:16:43","Format Angular observable data for PrimeNG Table","<angular><primeng><angular2-observables><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"67330808","1","67336582","","2021-04-30 08:41:20","","1","77","<p>I am using RxJs Behaviour subjects in following manner as below.</p>
<p>=&gt; Made a common service for all behaviour subjects like sample code below</p>
<pre><code>@Injectable()
export class ProjectJobSelectionService {

public postTypeSubject = new BehaviorSubject(PostType.Project);
public selectedProjectSubject = new BehaviorSubject(null);
public selectedJobsiteSubject = new BehaviorSubject(null);
public selectedJobSubject = new BehaviorSubject(null);
public addJobsiteSubject = new BehaviorSubject(null);

}
</code></pre>
<p>I have one side bar component which needs to be refreshed everytime on the next method or any new value gets emitted from various components.</p>
<p>side bar is the common component where all these subjects are subscribed in ngOnInit method and these subjects are being next (I mean emit values from various respected components)</p>
<p><strong>Problem</strong></p>
<p>Each and every time these subjects gets called by itself and the respected logic gets called when no respective components are instantiated or are not in life cycle.</p>
<p>was not able to retrive the cause of it also tried to comment the code from where it gets next still gets called automatically.</p>
<p>Any help would be highly appreciated.</p>
","7413086","","","","","2021-04-30 15:29:54","Behavior subjects (Rxjs) gets called automatically","<angular><rxjs><rxjs-observables>","2","4","","","","CC BY-SA 4.0"
"67372486","1","67372774","","2021-05-03 16:30:08","","0","49","<p>I'm trying to merge multiple responses from Observables to one stream. I'm fetching <code>companies</code> and each company has multiple <code>inspections</code> (which are stored as IDs). For each <code>inspection</code> I have to fetch the respective data.</p>
<p>This is how my code currently looks like. Please check the commented out section for the current result.</p>
<pre><code>// Get companies
getCompanies().pipe(
   switchMap(companies =&gt; companies.map(
     company =&gt; {
       return company['inspections'].map(inspection =&gt; {
         // Get inspections by each company
         return this.getInspectionById(inspection['id']);
       })
     }
   ))
).subscribe(result =&gt; {
   /* 
     console.log(result) returns the following (company1 has two inspections, company2 has three 
     inspections):

     (2) [Observable, Observable]
       0: Observable
       1: Observable

     (3) [Observable, Observable, Observable]
       0: Observable
       1: Observable
       2: Observable
   */
});
</code></pre>
<p>As you can see, my subscription currently returns the Observables only. I guess I'm just missing the part for merging the data streams, I've tried different operators like mergeMap, combineLatest, forkJoin etc. but didn't found the right one.</p>
<p>My desired output would be something like this (quite the same as above, but real data instead of observables):</p>
<pre><code>company1:
   company_data: ...
   inspections: [a, b]

company2:
   company_data: ...
   inspections: [a, b, c]
</code></pre>
<p>Does anybody know which operator to use and how to do it?
Thank you in advance!</p>
","5620626","","","","","2021-05-03 16:50:57","How to merge multiple Observable responses","<angular><typescript><rxjs><observable><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"67379098","1","","","2021-05-04 05:06:31","","-1","27","<p>I am getting dynamic values as array format like this</p>
<pre><code>var sections = [
    { id: &quot;1&quot;, section: &quot;I&quot;, group: &quot;Section1&quot;},
    { id: &quot;2&quot;, section: &quot;I&quot;, group: &quot;Section1&quot;},
    { id: &quot;3&quot;, section: &quot;I&quot;, group: &quot;Section2&quot;},
    { id: &quot;4&quot;, section: &quot;I&quot;, group: &quot;Section2&quot;},
    { id: &quot;5&quot;, section: &quot;II&quot;, group: &quot;Section3&quot;},
    { id: &quot;6&quot;, section: &quot;III&quot;, group: &quot;Section4&quot;},
    { id: &quot;7&quot;, section: &quot;IV&quot;, group: &quot;Section5&quot;}
];
</code></pre>
<p>Output should be in tree structure format like below</p>
<p>I
|--- Section1
|--- Section2</p>
<p>II
|-- Section3</p>
<p>III
|-- Section4</p>
<p>IV
|--- Section5</p>
<p>How to do it, I am getting values from Rest API, I am using Angular 8 version, How can we achieve this filter in javascript/typescript</p>
","14442579","","","","","2021-05-04 06:21:26","Filter data from dynamic array values and bring a structure format as output in angular","<javascript><angular><typescript><rxjs-observables><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"67385195","1","67385288","","2021-05-04 12:55:31","","2","242","<p>I have 2 API calls in a service that each return an Observable, and in my component I have some condition that, if true, I must call both those functions, but I need to wait for the get() call, so that I can execute the post function with arguments returned from the get call. If false, I just want to call the post function with the already defined arguments.</p>
<p>service:</p>
<pre><code>  get(id: string) {
    return this.http.get&lt;any&gt;('get path');
  }

  post(data: data) {
    return this.http.post&lt;any&gt;('post path', {data: data});
  }
</code></pre>
<p>component:</p>
<pre><code>  execute() {
    if (condition) {
      this.service.get(id).subscribe( (res) =&gt;
        // ...
        this.data = res.data;
        post(data).subscribe(() =&gt; // do stuff...);
      );
    } else { post(data).subscribe(() =&gt; // do stuff...); }
   }

</code></pre>
<p>I want to not repeat code for the post call, or if not at all possible, just not use a subscribe() inside another subscribe(). How can I do this? without async await.</p>
<p>Thanks in advance</p>
","15832673","","","","","2021-05-04 13:07:14","rxjs - Angular: How to wait for an Observable function, to call another function that returns an Observable?","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","2","1","","","","CC BY-SA 4.0"
"67386838","1","","","2021-05-04 14:32:46","","0","56","<p>I have an rxjs function using several rxjs operators from which I need to ultimately return an observable.  My challenge is detailed below in the sample code with details of what I am trying to do.  How can I accomplish this?  Do I need a rewrite?  Without the change I'm trying to make to access the values from Observable3 everything works as needed.  I've tried many things including using <code>withLatestFrom</code> to bring in observable three and also <code>combineLatest</code> but to no luck.</p>
<pre><code>Observable3 = of({obs3Prop1: value1, obs3Prop2: value2})

    this.Observable1
        .pipe(
            switchMap(param1) =&gt; {
                return this.getCount(param1);
            }), 
            mergeMap((param2: number) =&gt; 
                this.Observable2
                .pipe(
                    //inside this pipe, return another observable from here using some rxjs operators
                    //where I need access to param2 
                    //but I also need access to the value from Observable3
                )
            ),
        )
</code></pre>
","1991118","","1991118","","2021-05-04 15:07:42","2021-05-04 15:07:42","RXJS Observables how to access multiple observable values from mergeMap","<rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"67409484","1","67409556","","2021-05-05 22:24:30","","0","26","<p>I need to reset the data in my database which involves the actions -</p>
<ol>
<li>fetch all data</li>
<li>delete all data</li>
<li>create new data</li>
</ol>
<p>in sequence, and I have the following three methods in my service -</p>
<pre class=""lang-js prettyprint-override""><code>getAllData(): Observable&lt;IUser[]&gt; {
    //
}

clearAllData(users: IUser[]): Observable&lt;boolean&gt; {
    //
}

generateNewData(cleared: boolean): Observable&lt;IUser[]&gt; {
    //
}
</code></pre>
<p>In my component, I used them like below -</p>
<pre class=""lang-js prettyprint-override""><code>resetData(): void {
    this.service.getAllData()
        .pipe(
            concatMap(p =&gt; this.service.clearAllData(p)
                .pipe(
                    concatMap(p =&gt; this.service.generateNewData(p))
                ))
        )
        .subscribe(
            p =&gt; {
                this.dataSource = p;
            },
            e =&gt; {
                console.log('Error: ', e)
            }
        );
}
</code></pre>
<p>It works. It also works if I used them like -</p>
<pre class=""lang-js prettyprint-override""><code>resetData(): void {
    this.service.getAllData()
        .pipe(
            concatMap(p =&gt; this.service.clearAllData(p)),
            concatMap(p =&gt; this.service.generateNewData(p))
        )
        .subscribe(
            p =&gt; {
                this.dataSource = p;
            },
            e =&gt; {
                console.log('Error: ', e)
            }
        );
}
</code></pre>
<p>I'm just trying to understand the difference between how this two approaches work behind the scene.</p>
<p>As far as I know, higher order mapping operators subscribes to their outer observable. Therefore, in the first approach -</p>
<ul>
<li>the first <code>concatMap()</code> subscribes to the observable returned by the <code>service.getAllData()</code> method, and</li>
<li>the second <code>concatMap()</code> subscribes to the observable returned by the <code>service.clearAllData()</code> method</li>
</ul>
<p>(Please correct me if I'm wrong here).</p>
<p>But in the second approach, shouldn't both <code>concatMap()</code> subscribe to the observable returned by the <code>service.getAllData()</code> method?</p>
<p>How are the both approach producing the same result then?</p>
","446519","","","","","2021-05-05 22:31:30","Chaining higher order mapping operators - how does it work under the hood?","<angular><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"67419836","1","","","2021-05-06 14:08:18","","1","54","<p>I want to use <code>switchMap</code> in my subscriptions array, I want to call <code>invokeRequest</code> method which triggers http requests, basically I want to cancel subscription if same http call is triggered, can anyone please help.</p>
<pre><code>private subscriptions: Subscription[] = [];
this.subscriptions.push(trigger.pipe(skip(1)).subscribe((e) =&gt;
 this.invokeRequest(callConfig, e))
);
</code></pre>
","7226654","","7226654","","2021-05-06 14:15:44","2021-05-06 14:19:42","How to use switchMap in RxJs Subsciption array?","<javascript><angular><rxjs><rxjs-observables>","1","0","1","","","CC BY-SA 4.0"
"67458349","1","","","2021-05-09 13:37:37","","0","51","<p>I want to return a boolean from an observable but the return line is executed before the subscribe.
How can I do to return the boolean ?</p>
<pre><code>private isLowResolution (file: File): boolean {
    this.getImageUri(file).pipe(
      mergeMap((imageUri: string) =&gt; this.readImage(imageUri)),
      mergeMap((image: HTMLImageElement) =&gt; of(this.minWidth &gt; image.naturalWidth || this.minHeight &gt; image.naturalHeight))
    ).subscribe(
      (isLow: boolean) =&gt; {
        this.isLow$.next(isLow);
      }
    );
    return this.isLow$.getValue();
  }
</code></pre>
<p>I looked at this <a href=""https://stackoverflow.com/questions/43055706/how-do-i-return-the-response-from-an-observable-http-async-call-in-angular"">How do I return the response from an Observable/http/async call in angular?</a> and it don't answer to my question because I can't put the return into the subscribe. If I do that <code>isLowResolution</code> don't return the boolean anymore and I have and error</p>
","9063707","","9063707","","2021-05-09 14:27:37","2021-05-09 14:41:57","get boolean from Observable<boolean>","<angular><rxjs><rxjs-observables>","1","3","","2021-05-10 07:55:41","","CC BY-SA 4.0"
"67492689","1","","","2021-05-11 18:46:35","","0","54","<p>I havent been able to make it work properly and will appreciate if someone can point out problem and issues with what I am attempting. I am not sure if issue is with chaining of observables or something else.</p>
<p><strong>Description</strong>:</p>
<ol>
<li>Post a file to server that immediately issues an id for this request</li>
<li>Subsequently check whether processing is completed for that id by polling</li>
<li>When processing is completed, access results from server using same id</li>
</ol>
<p><strong>Issues</strong>:
I see that below solution keeps on posting file instead of posting once and then arbitrarily either will escape or get results. Needless to say that I am doing something wrong.</p>
<p><strong>Attempted solution</strong> (Snippets are schematic here, so please ignore syntax etc):</p>
<ol>
<li>Main observable calls <em>Post</em> method and then calls <em>poll</em> method using id that it recieves from server</li>
</ol>
<pre><code>    this.postData(inputFormData).pipe(
          map(res =&gt; {
            console.log(res.message);
            return res.message
          }),
          catchError(
            err =&gt; {
              console.log(err.message);
              this.errorSubject.next(err.message);
              return throwError(err.message);
            }
          ),
          delay(5000),
          concatMap((id) =&gt; this.pollData(id))
        )

</code></pre>
<p>and <em>post</em> method implementation is trivial</p>
<pre><code>  postData(dataForm: any){
    let headers = this.headers;
    headers.set('Content-Type', 'multipart/form-data');
    return this.httpClient.post&lt;MessageInterface&gt;(this.endPoint, dataForm, {headers: headers})
  }
</code></pre>
<ol start=""2"">
<li><em>PollData</em> observable runs at regular interval of 5sec and checks server if status is completed. If status is completed, then it call a <em>Get</em> method and retrieves result from server</li>
</ol>
<pre><code>      pollData(id: string){
        return timer(0, 5000)
        .pipe(
          switchMap( () =&gt; {
            console.log(id);
            return this.checkStatus(id)
          }),
          map(res =&gt; res.message),
          filter(status =&gt; status === 'completed'),
          take(1),
          timeout(100000),
          concatMap(() =&gt; this.getData(id)),
          catchError(err =&gt; throwError(err))
        )
      }
</code></pre>
<p><em>checkStatus</em> is trivial</p>
<pre><code>  checkStatus(id: string){
    console.log(id);
    return this.httpClient.get&lt;MessageInterface&gt;(this.endPointMain + `/status/${id}`, {headers: this.headers})
  }
</code></pre>
<p>3 <em>Get</em> data method is trivial and uses id to fetch</p>
<pre><code>  getData(id: string){
    return this.httpClient.get(this.endPointMain + `/results/${id}`, {headers: this.headers, observe: 'response', responseType: 'blob'})
  }
</code></pre>
","5870471","","5870471","","2021-05-11 19:06:25","2021-05-11 19:06:25","RxJs polling job - is the chaining correct?","<rxjs><rxjs6><rxjs-observables>","0","3","","","","CC BY-SA 4.0"
"67512084","1","67512303","","2021-05-12 23:16:00","","1","42","<p>A technique of getting data from a an API is to declare it like this in the service:</p>
<pre><code>getItems$ = this.httpClient.get&lt;Item[]&gt;(this.url);
</code></pre>
<p>then either subscribe to it or utilize async in the consuming component.</p>
<p>How would you do this if the get call requires parameters like get by id?</p>
<p>EDIT: The above is an example of a declarative approach to working with RxJS streams. The <code>getItems$</code> is a property.</p>
<p>So the question is, when using a declarative approach with a <em>property</em> defining the stream instead of calling a <code>getItems(itemId)</code> method, how to you pass in parameters?</p>
","787958","","1647604","","2021-05-12 23:53:13","2021-05-13 00:47:32","How do you declare a GET call with parameters?","<angular><rxjs><angular-httpclient><rxjs-observables>","3","0","","","","CC BY-SA 4.0"
"67547805","1","67548031","","2021-05-15 14:30:56","","0","157","<p>I'm having a really rough time with Angular / RxJS trying to learn it under crazy pressure!</p>
<p>If I'm returning this Observable:</p>
<pre><code> return this.apiProvider.Tracker(parameters).map((res: any) =&gt; {
      let response = res.Result;
      return response;
  }).catch(error =&gt; {
      this.presentToast('An error has occurred. If this problem persists, please contact us.', false);
      let res: ConsentResponse = null
      return Observable.of(res);
  });
</code></pre>
<p>It works perfectly fine.  The Tracker function is just a simple http.post return, like this:</p>
<pre><code>Tracker(params) {

I NEED TO GET A NEW TOKEN HERE FIRST BY DOING ANOTHER POST REQUEST - and that is my question :-)
var auth = 'Bearer ' + localStorage.getItem(&quot;pptoken&quot;);
const requestHeaders = {
  'Authorization': auth,
  'Content-Type': 'application/json'
}
var data = JSON.stringify({
  uid: params.uid,
  Type: params.type
});
return this.http.post('https://' +
params.apiBaseUrl + '/Tracker/api/Track/Consented/', data, { 'headers': requestHeaders });
</code></pre>
<p>}</p>
<p>So everything works perfectly fine.</p>
<p>However, I do need to get a new token every time before calling Tracker().  How can I call GetNewToken() and wait for it to finish and then do Tracker() with the new token?  Every time I do this, I get an error .map() does not support void - which I understand is because I'm first trying to get the token and then return the value from Tracker() which obviously isn't the right way - but I don't know with my limited knowledge how to first get the token when the Observable Tracker() is calling that function...</p>
<p>Would really appreciate any help.</p>
","14535890","","","","","2021-05-15 15:22:32","Return observable bit first get new token in Angular 11 / RxJS 7","<angular><rxjs><angular-promise><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"67584300","1","67588201","","2021-05-18 10:19:18","","0","39","<p>I'm making a stopwatch and when I wanna reset the clock for the second time, it is not changed.
On click at the first time, it sets h: 0, m: 0, s: 0. But when click again, it doesn't set h: 0, m: 0, s: 0 and stopwatch goes ahead.</p>
<pre><code>const events$ = merge(
    fromEvent(startBtn, 'click').pipe(mapTo({count: true})),
    click$.pipe(mapTo({count: false})), 
    fromEvent(resetBtn, 'click').pipe(mapTo({time: {h: 0, m: 0, s: 0}})) // there is reseting
    )
    
const stopWatch$ = events$.pipe(
    startWith({count: false, time: {h: 0, m: 0, s: 0}}), 
    scan((state, curr) =&gt; (Object.assign(Object.assign({}, state), curr)), {}), 
    switchMap((state) =&gt; state.count
    ? interval(1000)
        .pipe(
            tap(_ =&gt; {
                if (state.time.s &gt; 59) {
                    state.time.s = 0
                    state.time.m++
                }
                if (state.time.s &gt; 59) {
                    state.time.s = 0
                    state.time.h++
                }
                const {h, m, s} = state.time
                secondsField.innerHTML = s + 1
                minuitesField.innerHTML = m
                hours.innerHTML = h
                state.time.s++
            }),
        )
    : EMPTY)
stopWatch$.subscribe()
</code></pre>
","14795542","","","","","2021-05-18 15:18:13","Why mapTo changes only one time?","<rxjs><rxjs-observables><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"67592695","1","67593055","","2021-05-18 19:19:25","","0","87","<p>(FYI: Angular+Typescript)</p>
<p>I have a function that needs to return cheap <strong>Observable 1</strong> if it has anything, otherwise expensive <strong>Observable 2</strong>.</p>
<p>I use <strong>Race</strong> to pick the faster one, but that's not ideal as the <strong>http</strong> calls start then are killed.</p>
<pre><code>get(): Observable&lt;Cat&gt; {
    let cachedValues$ = (gets from fast cache)
    let serverValues$ = (gets from expensive server)
    return race(cachedValues$, serverValues$);
}
</code></pre>
","172861","","","","","2021-05-18 20:06:50","RxJs 2 Observables: Take first one$ else second$ if empty","<angular><typescript><rxjs><rxjs-observables>","4","0","","","","CC BY-SA 4.0"
"67597928","1","","","2021-05-19 06:22:19","","0","21","<p>Below is my HttpInterceptorService Code. Code is working fine as excepted. I would like to retry based on count. Let say my initial retryWaitMilliSeconds = 300 and retryCount = 3</p>
<p>First time I want to retry with 300 * 1</p>
<p>Second time I want to retry with 300 * 2</p>
<p>Third time I want to retry with 300 * 3</p>
<pre><code>private retryCount = 3;
private retryWaitMilliSeconds = 500;

intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {

        let ok: string;
        const started = Date.now();

        // Handle request
        request =    request.clone({
            setHeaders: {
                &quot;Authorization&quot;: &quot;Bearer  XXXXXXXXXXXXXXXXXXX&quot;
            }
        });

        return next.handle(request).pipe(
            tap(event =&gt; ok = event instanceof HttpResponse ? 'succeeded' : ''),
            retryWhen(error =&gt; error.pipe(concatMap((error, count) =&gt; {
                ok = 'failed'
                if (count &lt;= this.retryCount &amp;&amp; error.status === 500) {
                    return of(error);
                }
                return throwError(error);
            }), delay(this.retryWaitMilliSeconds),
                tap(err =&gt; console.log(&quot;Retrying...&quot;)))
            ), finalize(() =&gt; {
                
            }))
    }
</code></pre>
","2527399","","","","","2021-05-19 06:22:19","Angular HttpClient Interceptor request with retry and delay dynamically based on count","<angular><angular-http-interceptors><rxjs-observables>","0","0","","","","CC BY-SA 4.0"
"67601577","1","67602291","","2021-05-19 10:33:45","","0","47","<p>The following code works as expected:</p>
<pre><code>    const source = interval(1000).pipe(
        take(5),    
        share()
  );

  source.subscribe(x =&gt; console.log('c1', x));
  setTimeout(() =&gt; {
    source.subscribe(x =&gt; console.log('c2', x));
  }, 2000);
</code></pre>
<p>producing the following output:
c1 0
c1 1
c1 2
c2 2
c1 3
c2 3
c1 4
c2 4</p>
<p>but when I change the second subscription to use delay(2000) instead of the setTimeout()
I get a different stream that is not shared.</p>
<pre><code>    const source = interval(1000).pipe(
        take(5),    
        share()
  );

  source.subscribe(x =&gt; console.log('c1', x));

  source.pipe(delay(2000)).subscribe(x =&gt; console.log('c2', x));
</code></pre>
<p>Produces this output:</p>
<p>c1 0
c1 1
c1 2
c2 0
c1 3
c2 1
c1 4
c2 2
c2 3
c2 4</p>
<p>How do I get the second subscriber to use the shared stream?
I obviously don't understand fully how RX operators work under the hood.</p>
","15970355","","","","","2021-05-21 11:32:41","Sharing an observable becomes unicast when I add delay operator to a 2nd subscription","<rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"67606419","1","67606618","","2021-05-19 15:38:50","","0","35","<p>I'm trying to combine two Observables to have few values for the call to service method that accepts two values. But here I have few errors</p>
<ul>
<li><p>Argument of type '([filter, sort]: [string, string]) =&gt; void' is not assignable to parameter of type '(value: [string, string], index: number) =&gt; ObservableInput'.
Type 'void' is not assignable to type 'ObservableInput'.</p>
</li>
<li><p>in console -</p>
<p>You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
at subscribeTo (subscribeTo.js:27)
at innerSubscribe (innerSubscribe.js:71)
at SwitchMapSubscriber._innerSub (switchMap.js:44)
at SwitchMapSubscriber._next (switchMap.js:34)
at SwitchMapSubscriber.next (Subscriber.js:49)
at CombineLatestSubscriber.notifyNext (combineLatest.js:73)
at InnerSubscriber._next (InnerSubscriber.js:11)
at InnerSubscriber.next (Subscriber.js:49)
at BehaviorSubject._subscribe (BehaviorSubject.js:14)
at BehaviorSubject._trySubscribe (Observable.js:42)</p>
</li>
</ul>
<ol>
<li><p>Defining Observables and Subjects.</p>
<pre><code> private openSortQuerySubject: BehaviorSubject&lt;string&gt; = new BehaviorSubject&lt;string&gt;(this.formatSortQuery(this.multiSortMeta));
 public openSortQuery: Observable&lt;string&gt; = this.openSortQuerySubject.asObservable();

 private closedSortQuerySubject: BehaviorSubject&lt;string&gt; = new BehaviorSubject&lt;string&gt;(this.formatSortQuery(this.multiSortMeta));
 public closedSortQuery = this.closedSortQuerySubject.asObservable();
</code></pre>
</li>
<li><p>Combine observables.</p>
<pre><code>   const openQueries$ = combineLatest([this.openFilterQuery, this.openSortQuery]);
   const closedQueries$ = combineLatest([this.closedFilterQuery, this.closedSortQuery]);
</code></pre>
</li>
<li><p>Use merged values in service method.</p>
</li>
</ol>
<pre><code>openQueries$
      .pipe(
        switchMap(([filter, sort]) =&gt; {
          this.alertService
            .listAlerts(filter, sort);
        }),
        tap(v =&gt; console.log(v))
      )
      .subscribe((openAlerts) =&gt; {
        this.openAlertsCount = openAlerts.length;
        this.openAlerts = this.parseAlerts(openAlerts);
      });

    closedQueries$
      .pipe(
        switchMap(([filter, sort]) =&gt; {
          this.alertService
            .listAlerts(filter, sort);
        })
      )
      .subscribe((closedAlerts) =&gt; {
        this.closedAlertsCount = closedAlerts.length;
        this.closedAlerts = this.parseAlerts(closedAlerts);
      });
</code></pre>
","924646","","","","","2021-05-19 15:49:31","undefined when combine combineLatest and switchMap","<rxjs><rxjs-observables><rxjs-pipeable-operators><switchmap><combinelatest>","1","0","","","","CC BY-SA 4.0"
"67632525","1","67632576","","2021-05-21 07:28:17","","0","20","<p>In my Angular component, I have this</p>
<pre><code>ngOnInit(): void {
this.route.paramMap
.pipe(
  tap(item=&gt;console.log(item))
)
.subscribe(
  params =&gt; {
    const proyectoId = params.get('proyectoId');
    this.empleadoId = +params.get('empleadoId');
  }
  ,err=&gt;console.log(err)
  ,()=&gt;{
    console.log('Hola');
  }
);
</code></pre>
<p>}</p>
<p>But when I debug I don't see the console.log</p>
<p><a href=""https://i.stack.imgur.com/NAGYS.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/NAGYS.jpg"" alt=""log"" /></a></p>
<p>Any idea, please?</p>
<p>Thanks</p>
","3367720","","","","","2021-05-21 08:26:05","nothing happens when the observable is completed in my angular component","<angular><rxjs-observables><angular-observable>","1","0","","","","CC BY-SA 4.0"
"67654628","1","67658030","","2021-05-22 22:17:11","","1","118","<p>i have a problem with emiting values from behavior subject after switchMap operator from parent to child component. If i call real http API in console.log in child compoennt i only see empty array [] (default value), but in tap operator in parent component if i console.log data i saw array with 20 items, but in child component not. When i tried to make a mock service and return mocked data.</p>
<p>eg. <code>return of(['item1', 'item2']</code></p>
<p>This case works fine, but when i only switched call service name, it doesn't work correctly for me, in tap i see data, but in child input not.</p>
<pre><code>import { Component, VERSION } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { switchMap } from 'rxjs/operators';
import { AppserviceService } from './appservice.service';

@Component({
  selector: 'my-app',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  name = 'Angular ' + VERSION.major;
  refresh$: Subject&lt;void&gt; = new Subject();
  data$: BehaviorSubject&lt;string[]&gt; = new BehaviorSubject&lt;string[]&gt;([]);

  constructor(private _appService: AppserviceService) {
    this.refresh$
      .pipe(switchMap(() =&gt; this._appService.test2()))
      .subscribe(res =&gt; {
        console.log('Subscribe:');
        console.log(res);
        this.data$.next(res)
      });

    this.refresh$.next();
  }
}


</code></pre>
<p>Child component</p>
<pre><code>import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Component({
  selector: 'hello',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    &lt;h1&gt;Hello {{ name }}!&lt;/h1&gt;
  `,
  styles: [
    `
      h1 {
        font-family: Lato;
      }
    `
  ]
})
export class HelloComponent {
  @Input() name: string;
  @Input() set test(value: BehaviorSubject&lt;any[]&gt;) {
    console.log(value.getValue());
  }
}
</code></pre>
<p><a href=""https://stackblitz.com/edit/angular-ivy-7wezwh?file=src/app/app.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-ivy-7wezwh?file=src/app/app.component.ts</a></p>
<p>Did you met with this issue ? Thanks.</p>
","9202425","","9202425","","2021-05-23 04:14:34","2021-05-23 09:10:36","BehaviorSubject doesn't emit values","<angular><typescript><rxjs><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"67662552","1","","","2021-05-23 17:24:19","","0","68","<p>How to use RXJs Subject like store variable in Svelte? You can use the Subject variable in Svelte with $ prefix. But when you bind the variable to input it throws an exception: &quot;Error: name.set is not a function&quot; because the Subject type has not a set method.</p>
","2549901","","","","","2021-05-23 17:24:19","How to use RXJs Subject like store variable in Svelte","<rxjs><svelte><svelte-3><rxjs-observables><svelte-store>","1","0","","","","CC BY-SA 4.0"
"67667767","1","","","2021-05-24 06:51:50","","0","14","<p>I'm trying to populate the dropdown list like this:</p>
<pre><code>this.service.loadProducts()
   .pipe(
        map(response =&gt; response.map(element =&gt; new Product(element)))
   )
   .subscribe(arr =&gt; this.products = arr);
</code></pre>
<p>Is there any reason why do item.constructor === Object check is performed in ng-autocomplete filter list function?</p>
<pre><code>filterList() {
        this.selectedIdx = -1;
        this.initSearchHistory();
        if (this.query != null &amp;&amp; this.data) {
            this.toHighlight = this.query;
            this.filteredList = this.data.filter((/**
             * @param {?} item
             * @return {?}
             */
            (item) =&gt; {
                if (typeof item === 'string') {
                    // string logic, check equality of strings
                    return item.toLowerCase().indexOf(this.query.toLowerCase()) &gt; -1;
                }
                else if (typeof item === 'object' &amp;&amp; item.constructor === Object) {
                    // object logic, check property equality
                    return item[this.searchKeyword].toLowerCase().indexOf(this.query.toLowerCase()) &gt; -1;
                }
            }));
        }
        else {
            this.notFound = false;
        }
    }
</code></pre>
<p>Filtering fails due to that check. Is there any way to do that without using return statement in the map method?</p>
","6006616","","","","","2021-05-24 06:51:50","Ng autocomplete filter list function with mapped values","<angular><autocomplete><rxjs-observables>","0","1","","","","CC BY-SA 4.0"
"67675395","1","","","2021-05-24 16:08:05","","0","35","<p>When I run the code below I get the desired result followed by a re-subscription of the delayed shared observable when the other observable completes.</p>
<pre><code>const source = interval(1000).pipe(
take(5),        
share());
source.subscribe(x =&gt; console.log('c1', x)); 

source.pipe(
  delay(2000),  // doesn't delay subscription buffers the output from interval observable
  switchMapTo(source)
</code></pre>
<p>).subscribe(x =&gt; console.log('c2', x));</p>
<p>output :
c1 0
c1 1
c1 2
c1 3
c2 3
c1 4
c2 4
c2 0<br />
c2 1
c2 2
c2 3
c2 4</p>
","15970355","","","","","2021-05-25 14:59:49","Why does a shared observable re-subscribe when the first one completes","<rxjs><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"67704385","1","67704670","","2021-05-26 11:57:22","","0","65","<p>Example code from <a href=""https://ng-bootstrap.github.io/#/components/typeahead/examples#http"" rel=""nofollow noreferrer"">ng-bootstrap documentation</a>:</p>
<p><sup>See the example &quot;Wikipedia search&quot;, click on &quot;&lt;/&gt; Code&quot; and choose the file &quot;typeahead-http.ts&quot;.</sup></p>
<pre class=""lang-js prettyprint-override""><code>  search: OperatorFunction&lt;string, readonly string[]&gt; = (text$: Observable&lt;string&gt;) =&gt;
    text$.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      tap(() =&gt; this.searching = true),
      switchMap(term =&gt;
        this._service.search(term).pipe(
          tap(() =&gt; this.searchFailed = false),
          catchError(() =&gt; {
            this.searchFailed = true;
            return of([]);
          }))
      ),
      tap(() =&gt; this.searching = false)
    )
</code></pre>
<p>And the definition of <code>OperatorFunction</code> from <a href=""https://rxjs.dev/api/index/interface/OperatorFunction"" rel=""nofollow noreferrer"">RxJS documentation</a>:</p>
<pre class=""lang-js prettyprint-override""><code>interface OperatorFunction&lt;T, R&gt; extends UnaryFunction, Observable&gt; {

  // inherited from index/UnaryFunction
  (source: T): R
}
</code></pre>
<hr />
<p>Why is it that the type of <code>search</code> can be declared as:</p>
<ul>
<li><code>OperatorFunction&lt;string, string[]&gt;</code></li>
</ul>
<p>which by definition is:</p>
<ul>
<li><code>(param: string): string[]</code></li>
</ul>
<p>but then assigned to the arrow function with signature</p>
<ul>
<li><code>(param: Observable&lt;string&gt;): Observable&lt;string[]&gt;</code></li>
</ul>
<p>Shouldn't there be a conflict from attempting to assign <code>Observable&lt;T&gt;</code> to <code>T</code>? What am I missing here? What is the actual resulting return type of the arrow function <code>search</code>?</p>
","2237467","","","","","2021-05-26 12:15:25","Why does (Observable<T>) => Observable<R> resolve as OperatorFunction<T, R>","<angular><typescript><rxjs><ng-bootstrap><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"67706700","1","67717333","","2021-05-26 14:11:05","","0","42","<p>Just for one time, fired in <code>ngOnInit</code> from a Observable, I am receiving a JSON Object with a Text and a Image.</p>
<p>The Image comes as an Array. The Text-Binding works well, but the Source Attribute Binding for the Image is a killer - the data for the Images can be up to 1MB and more.</p>
<p>The Text <code>&lt;h2&gt;{{support.VehicleName}}&lt;/h2&gt;</code> can change from a another Observable, this part works well. But I dont need to change the image. How do I bind my Image-Source as a One-Time ?</p>
<p>HTML:</p>
<pre><code>&lt;div *ngFor=&quot;let support of IsSupportInOperation&quot;&gt;
    &lt;h2&gt;{{support.VehicleName}}&lt;/h2&gt;
    &lt;img [src]='innerHtml(support.VehicleImage.data)' /&gt;
&lt;/div&gt;`
</code></pre>
<p>TypeScript:</p>
<pre><code>import { Component, OnInit, OnDestroy, Input } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators'
import { FireCrewService, ViewOnSupportInOperation } from '../shared/fire-crew.service';
import { DomSanitizer } from '@angular/platform-browser';


@Component({
    selector: 'app-display',
    templateUrl: './display.component.html',
    styleUrls: ['./display.component.css']
})

export class DisplayComponent implements OnInit {

@Input() OperationId: number = 0;

destroy$ = new Subject();
IsSupportInOperation = new Array&lt;ViewOnSupportInOperation&gt;();

observer = {
    next: (value: ViewOnSupportInOperation[]) =&gt; this.onNext(value),
    error: (err: string) =&gt; this.onError(err),
    complete: () =&gt; this.onComplete(),
};

constructor(private fs: FireCrewService,
    private sanitizer: DomSanitizer) {
}


ngOnDestroy(): void {
    this.destroy$.next();
}

ngOnInit(): void {
    this.fs.getAlarm(this.OperationId)
        .pipe(takeUntil(this.destroy$))
        .subscribe(this.observer);
}


onNext(value: ViewOnSupportInOperation[]): void
{
    this.IsSupportInOperation = [];

    value.forEach(element =&gt; {
        if (element.SrcId == element.DstId) {
            this.IsSupportInOperation.push(element);
        }
    });
}

onError(value: string): void {
}

onComplete(): void {
}


innerHtml(value: Buffer) {
    return this.sanitizer.bypassSecurityTrustUrl('data:image/jpeg;base64,' + this._arrayBufferToBase64(value));
}

_arrayBufferToBase64(value: Buffer) {
    var binary = '';
    var bytes = new Uint8Array(value);
    var len = bytes.byteLength;
    for (var i = 0; i &lt; len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return window.btoa(binary);
}

}
</code></pre>
<p>SQL:</p>
<pre><code>CREATE TABLE [dbo].[Vehicle]
(
    [Id] INT IDENTITY (1, 1) NOT NULL
    , [SrcId] INTEGER NOT NULL
    , [DstId] INTEGER NOT NULL
    , [VehicleName] NVARCHAR (32)   NOT NULL
    , [VehicleImage] VARBINARY(MAX) NULL
)
</code></pre>
<p>Interface:</p>
<pre><code>export interface ViewOnSupportInOperation {
    Id: number;
    SrcId: number;
    DstId: number;
    VehicleName: string;
    VehicleImage: any;
}
</code></pre>
<p>JSON:</p>
<pre><code>[
    {
        &quot;Id&quot;:1,
        &quot;VehicleName&quot;:&quot;Car&quot;,
        &quot;VehicleImage&quot;: {
            &quot;type&quot;:&quot;Buffer&quot;,
            &quot;data&quot;:[
                255,254,253, ...
            ]
        }
    }
]
</code></pre>
<p>API:</p>
<pre><code>async function getAlarm(id) {
    try {
        let pool = await sql.connect(config);
        let query = await pool.request().query(&quot;SELECT * FROM Vehicle WHERE Id = &quot; + id);
        return query.recordset;
    }
    catch (error) {
        console.error(error);
    }
}
</code></pre>
","4165274","","4165274","","2021-05-27 07:07:27","2021-05-27 07:34:50","Angular Binding a Image Attribute Source just for One-Time","<json><angular><typescript><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"67801221","1","67801676","","2021-06-02 08:04:49","","0","21","<p>I subscribe to an <code>Observable</code> with a <code>pairwise</code> pipe in order to get previous and new value.</p>
<p>But sometime I would like to tell the <code>Observable</code> that the value has been updated without applying the <code>subscribe</code> function. It will ensure that the <code>previousValue</code> is always updated but without always applying the subscribe function.</p>
<pre><code>// Listen to FomControl -&gt; update value variable.
this.valueChangesSubscription = this.control.valueChanges
    .pipe(startWith(this.defaultValue), pairwise())
    .subscribe(async ([previousValue, newValue]) =&gt; {
        // Do something
    });
</code></pre>
<p>I update the value of the <code>formControl</code> and sometime emitting the event, sometimes not:</p>
<pre><code>this.control.setValue(formattedValue, { emitEvent });
</code></pre>
<p>But I would like that even if the event is not emitted, the <code>previousValue</code> of the <code>subscribe</code> function will be the real <code>previousValue</code> and not juste the latest emitted one.</p>
<p>Thank you.</p>
","3520621","","","","","2021-06-02 08:35:22","Updating value of an observable without applying the subscribe","<rxjs><angular-forms><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"67957778","1","67958005","","2021-06-13 11:33:08","","0","45","<p>I made this code:</p>
<pre><code>return this.projectService.oneById(id).pipe(mergeMap(project =&gt; {
      if (!project) {
        return [];
      }

      const stories = this.getStories(id);

      return combineLatest(project.members.map(member =&gt; {
        return this.userService.one(member.id).pipe(map(memberData =&gt; {
          const assigned = stories.pipe(mergeMap(t =&gt; combineLatest(t.filter(task =&gt; {
            if (task &amp;&amp; task.assignee?.id === member.id) {
              return {
                ...task,
                id: task.id
              };
            }
          }))));

          return {
            id: member.id,
            name: memberData?.displayName ?? 'Unknown',
            assigned
          };
        }));
      }));
    }));
</code></pre>
<p>But I'm having a problem because my function expects to return <code>Observable&lt;Type[]&gt;</code>, but it is currently returning <code>Observable&lt;{ ...etc, object: Observable&lt;Type[]&gt; }</code>.</p>
<p>Obviously the problem is the observable inside the observable. I am, however, unsure how to fix this in this case. I have solved this many times in my current code, but this one is hard for me to understand because whatever I try nothing changes.</p>
<p>Thank you for helping in advance.</p>
<p>PS: the exact warning is this:</p>
<pre><code>Type 'Observable&lt;{ id: string; name: string; assigned: Observable&lt;[UserStory | undefined]&gt;; }[]&gt;' is not assignable to type 'Observable&lt;Member[]&gt;'.   Type '{ id: string; name: string; assigned: Observable&lt;[UserStory | undefined]&gt;; }[]' is not assignable to type 'Member[]'.     Type '{ id: string; name: string; assigned: Observable&lt;[UserStory | undefined]&gt;; }' is not assignable to type 'Member'.       Types of property 'assigned' are incompatible.         Type 'Observable&lt;[UserStory | undefined]&gt;' is missing the following properties from type 'UserStory[]': length, pop, push, concat, and 25 more.
</code></pre>
","7801732","","","","","2021-06-13 12:00:11","RXJS observable in observable","<angular><typescript><rxjs><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"67960660","1","67966935","","2021-06-13 16:52:15","","0","75","<p>I am a newbie to RXKotlin/RXJava.
I am developing the background service in Android.</p>
<p>In my service, I have</p>
<ul>
<li>Bluetooth socket</li>
<li>TCP Socket</li>
</ul>
<p>Whenever the data is available on the Bluetooth socket, read and write to the TCP socket. And whenever data is received in the TCP socket, write to the Bluetooth socket.</p>
<p>Can someone help me:</p>
<ul>
<li>how to achieve this using Observables?</li>
<li>how to exchange the socket id information?</li>
<li>how to exchange the data?
Thanks</li>
</ul>
","16216084","","2801860","","2021-06-14 18:21:18","2021-06-14 18:21:18","RXKOTLIN/RXJAVA: Communication between the socket using Observables","<android><rx-java><rxjs-observables><rx-kotlin>","1","2","","","","CC BY-SA 4.0"
"67966213","1","67966399","","2021-06-14 07:20:08","","0","99","<p>For some reason, I'm unable to use <code>shareReplay()</code> inside the <code>pipe()</code> operator in the observable, <code>courses$</code>.</p>
<p>Below is the <code>home.component.ts</code></p>
<pre><code>import {Component, OnInit} from '@angular/core';
import {Course} from &quot;../model/course&quot;;
import { Observable } from 'rxjs';
import {interval, noop, of, timer} from 'rxjs';
import {catchError, delayWhen, map, retryWhen, shareReplay, tap} from 'rxjs/operators';
import { createHttpObservable } from '../common/util';



@Component({
    selector: 'home',
    templateUrl: './home.component.html',
    styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit {
beginnerCourses$: Observable&lt;Course[]&gt;;

advancedCourses$: Observable&lt;Course[]&gt;;


constructor() {

}

ngOnInit() {

    const http$ = createHttpObservable('/api/courses');

    const courses$: Observable&lt;Course[]&gt; = http$
        .pipe(
            tap(() =&gt; console.log('HTTP request')), // tap() operator is used to produce the side effects in our obsevable chain. Whenever we want to update something outside of our observable chain, we use the tap() operator.
            map(res =&gt; Object.values(res['payload'])),
            shareReplay()
        ); // Whenever we want to derive new observables from existing observables, we need to use one of the RxJs operators, the pipe() operator. The pipe() function is what allows us to chain multiple operators in order to produce a new observable.

    this.beginnerCourses$ = courses$
        .pipe(
            map(courses =&gt; courses.filter(course =&gt; course.category == 'BEGINNER'))
        )

    this.advancedCourses$ = courses$
        .pipe(
            map(courses =&gt; courses.filter(course =&gt; course.category == 'ADVANCED'))
        )
</code></pre>
<p>I get this error when I try to run it:</p>
<pre><code>Error: src/app/home/home.component.ts:30:15 - error TS2322: Type 'Observable&lt;unknown[]&gt;' is not assignable to type 'Observable&lt;Course[]&gt;'.
  Type 'unknown[]' is not assignable to type 'Course[]'.
    Type '{}' is missing the following properties from type 'Course': id, description, iconUrl, courseListIcon, and 3 more.
</code></pre>
<p>But whenever I remove the <code>shareReplay()</code> from the <code>pipe()</code> in the <code>courses$</code>, it works. What could be the problem here? I want to be able to use <code>shareReplay()</code> without any errors.</p>
<pre><code>home.component.html
</code></pre>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-css lang-css prettyprint-override""><code>.courses-panel {
    max-width: 400px;
    margin: 0 auto;
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;div class=""courses-panel""&gt;

  &lt;h3&gt;All Courses&lt;/h3&gt;

  &lt;mat-tab-group&gt;

    &lt;mat-tab label=""Beginners""&gt;

      &lt;courses-card-list [courses]=""beginnerCourses$ | async""&gt;
        &lt;!--What ""async"" pipe does is, it's going to subscribe to this observable ""beginnerCourses$"" and it's going to retrieve that data and assign it to the ""[courses]"".--&gt;

      &lt;/courses-card-list&gt;

    &lt;/mat-tab&gt;

    &lt;mat-tab label=""Advanced""&gt;

      &lt;courses-card-list [courses]=""advancedCourses$ | async""&gt;&lt;/courses-card-list&gt;

    &lt;/mat-tab&gt;

  &lt;/mat-tab-group&gt;



&lt;/div&gt;</code></pre>
</div>
</div>
</p>
<p>Above is the HTML and CSS for reference. It's working without any problems when I remove <code>shareReplay()</code>. I'm watching a tutorial that's using the same code as this but it runs without any problem, unlike mine.</p>
","12825619","","","","","2021-06-14 07:34:54","RxJs: Type 'unknown[]' is not assignable to type 'Course[]'","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"68021260","1","","","2021-06-17 14:22:50","","0","12","<p>I am trying to use combineLatest in my code. Here is the code:</p>
<pre><code>this.selectedIcon$ = this.iconForm.get('selectedIcon').valueChanges
   .pipe(takeUntil(this.unsubscribe$))
   .pipe(startWith(''))
   .pipe(tap((value) =&gt; { 
    //This not being called / set, every time the values changes.
    this.searchIcon = value;
    }));
 
   this.selectedColour$ = this.iconForm.get('selectedColour').valueChanges
   .pipe(takeUntil(this.unsubscribe$))
   .pipe(startWith(''))
   .pipe(tap((value) =&gt; { 
       this.selectedColour = value; 
    }));
 
   let data$ = this.menuNavigationProvider.iconCssData
    .pipe(takeUntil(this.unsubscribe$));
 
 combineLatest([data$, this.selectedIcon$]).subscribe(([data, icon]) =&gt; {
     console.log(data+ ' - ' + icon);
 });
</code></pre>
<p>The subscribe is not working when the 'selectedIcon' value changes. Can anyone correct me what the mistake i am doing here? In the above code i want the <code>this.searchIcon = value</code> to be set everytime the value changes.</p>
<p>Thanks</p>
","4717427","","","","","2021-06-17 14:22:50","Angular RxJS combineLatest not subscribing when the element value changes is fired","<angular11><rxjs-observables><combinelatest>","0","0","","","","CC BY-SA 4.0"
"68037016","1","","","2021-06-18 14:31:43","","1","41","<p>I want to unsubscribe to an observable with takeUntil in any case where the number does not equal 5.
If the number is 5 want to do something and unsubscribe later, but it does not work.</p>
<p>This is my stackblitz link: <a href=""https://stackblitz.com/edit/angular-ivy-lpkzyf?file=src%2Fapp%2Fapp.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-ivy-lpkzyf?file=src%2Fapp%2Fapp.component.ts</a></p>
<p>Thank you.</p>
","16261659","","","","","2021-06-18 15:13:41","Unsubscribe later with takeUntil if a condition is met","<angular><rxjs><observable><rxjs-observables><unsubscribe>","1","0","","","","CC BY-SA 4.0"
"68037022","1","","","2021-06-18 14:31:55","","0","31","<p>i have trouble to set the boolean value of the observable in my template so as to disable a button.</p>
<p>In my component</p>
<pre><code>public hasAccess$: Observable&lt;boolean&gt;; 
this.hasAccess$ = this.store.select(hasAccessGetStudentData).pipe(takeUntil(this.destroy$));
</code></pre>
<p>In my template</p>
<pre><code> &lt;button [disabled]=&quot;(hasAccess$ | async)&quot;  (click)=&quot;add()&quot;  &gt;
      add new student
 &lt;/button&gt;
</code></pre>
<p><a href=""https://i.stack.imgur.com/TB9mD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TB9mD.png"" alt=""enter image description here"" /></a></p>
","6413218","","6413218","","2021-06-18 14:39:55","2021-06-18 14:39:55","Get the value of an observable in the template angular 2","<angular><typescript><rxjs-observables>","0","5","","","","CC BY-SA 4.0"
"68048489","1","68051788","","2021-06-19 15:51:37","","0","32","<p>I'd like to replicate the observable dependency graph for time travel debugging, similar to this example (<a href=""https://youtu.be/HQWnCo_lMJQ?t=74"" rel=""nofollow noreferrer"">https://youtu.be/HQWnCo_lMJQ?t=74</a>).</p>
<p>How can I access the names of the observables and piped operators?  Initial attempts have been so far unsuccessful.</p>
<p>e.g., in <a href=""https://stackblitz.com/edit/j7tvss-adrhxq?devtoolsheight=33&amp;file=index.ts"" rel=""nofollow noreferrer"">this example</a>, tap can access the values, but I haven't found a way to log <code>map</code>, <code>take</code>, and <code>interval</code> at the same time.</p>
<pre class=""lang-js prettyprint-override""><code>import { interval } from 'rxjs';
import { map, take } from 'rxjs/operators';
interval(100)
  .pipe(
    take(3),
    map((e, i) =&gt; i * 2),
    tap(console.log)
  )
  .subscribe({
    next: console.log,
    error: console.error,
    complete: () =&gt; console.log('complete')
  });
</code></pre>
","656259","","","","","2021-06-20 00:42:58","How to log rxjs observable and operator names?","<rxjs><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"68102802","1","","","2021-06-23 15:26:24","","1","15","<p>Defined a callback function definition in child</p>
<pre><code>  private ModalNextAction: (callback?:(isUpdated: boolean) =&gt; void) =&gt; void;
</code></pre>
<p>its call back is defined as below. Parent returns if a modal can be opened or not</p>
<pre><code>canOpenModalDialog() {
this.ModalNextAction = (canOpen) =&gt; {
  if (canOpen) {
    this.openDialog();
  } else {
  this.proceed();
  }
};
this.canOpen.emit();}
</code></pre>
<p>in ngOnInit subscribed as below in child</p>
<pre><code> this.sharedService.isUpdated.pipe(takeUntil(this.childDestroyed$)).subscribe(isUpdated=&gt; {
  if(this.ModalNextAction) {
    this.ModalNextAction(() =&gt; isUpdated);
  }
})
</code></pre>
<p>Parent component will set</p>
<pre><code>this.sharedService.isUpdated.next(true);

**IsUpdated** - flag is returned as true but when passed to **ModalNextAction** passed as a function as below. Why its passed as function?
ƒ () { return isUpdated; }
</code></pre>
","1016740","","1016740","","2021-06-23 15:32:33","2021-06-23 15:32:33","Angular 6 how to pass the parameter returned from parent to child call back method","<typescript><callback><angular6><rxjs-observables>","0","2","","","","CC BY-SA 4.0"
"68118043","1","68118122","","2021-06-24 14:50:06","","0","35","<p>I use from() with pipe and concatMap and i would like to have access to the object in concatMap because i need it for doing a mapping after.</p>
<pre><code>         from(objects)
          .pipe(
            concatMap(object =&gt; // i need to have access to object in subscribe
              defer(() =&gt;
                this.service.getObjectInfors(object.id)
              )
            )
          )
          .subscribe(objectInfos =&gt; {
            if (objectInfos) {
              this.objectsTab.push(
                this.mappingObject(
                  object, // i need object in this mapping
                  objectInfos
                )
              );
            }
          });
</code></pre>
<p>Is it possible to do that ? Is there another way which can help me doing that ? Thanks</p>
","3659739","","","","","2021-06-25 15:17:14","How can i have access to concatMap object in subscribe in rxjs","<angular><rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"68133561","1","68134180","","2021-06-25 15:32:34","","0","36","<p>For a project I have a simple container which contains a number of cards. Since there are a lot of cards, there are multiple pages and when the screen is displayed it automatically rotates to the next page every X seconds <strong>OR</strong> when the user hits the space bar.</p>
<p>For a new feature we have added a toggle button to turn the automatic rotation off. I have created an <code>EventEmitter</code> for the <code>toggle-button</code> as can be seen below in <code>toggleEmitter</code> but I am quite new to rxjs and not sure how to use it to actually stop the rotation. Anyone can help?</p>
<pre><code>@Component({
  selector: 'rotator-container',
  templateUrl: './rotator-container.component.html',
})
export class RotatorContainerComponent implements AfterViewInit, OnDestroy {
  @ContentChildren(RotatorItemComponent, { read: ElementRef })
  rotatorItems: QueryList&lt;ElementRef&gt;;

  @Input() rotationInterval = 30 * 1000;

  @Output() toggleEmitter: EventEmitter&lt;MatSlideToggleChange&gt; =
    new EventEmitter();
  toggle(event: MatSlideToggleChange) {
    this.toggleEmitter.emit(event);
  }

  timer$ = this.activatedRoute.queryParams.pipe(
    map(params =&gt; params['rotate']),
    switchMap(rotate =&gt;
      rotate === 'false' ? of(0) : timer(0, this.rotationInterval)
    )
  );

  spaceCounter$ = fromEvent&lt;KeyboardEvent&gt;(document, 'keydown').pipe(
    filter(({ code }) =&gt; code === 'Space'),
    tap(e =&gt; e.preventDefault()),
    map(() =&gt; 1),
    scan((acc, curr) =&gt; acc + curr, 0),
    startWith(0)
  );

  rotationCounter$ = combineLatest([this.timer$, this.spaceCounter$]).pipe(
    map(([index, offset]) =&gt; index + offset)
  );

  rotatorSubscription: Subscription;

  constructor(private activatedRoute: ActivatedRoute) {}

  ngAfterViewInit() {
    const rotatorItemsLength$ = this.rotatorItems.changes.pipe(
      map(() =&gt; this.rotatorItems.length),
      startWith(this.rotatorItems.length)
    );

    const visibleIndex$ = combineLatest([
      this.rotationCounter$,
      rotatorItemsLength$,
    ]).pipe(
      map(([index, length]) =&gt; index % length),
      startWith(0)
    );

    this.rotatorSubscription = visibleIndex$.subscribe(visibleIndex =&gt;
      this.rotatorItems.forEach((item, index) =&gt; {
        (&lt;HTMLElement&gt;item.nativeElement).style.visibility =
          visibleIndex === index ? 'visible' : 'hidden';
        (&lt;HTMLElement&gt;item.nativeElement).style.position =
          visibleIndex === index ? 'relative' : 'absolute';
      })
    );
  }

  ngOnDestroy() {
    this.rotatorSubscription &amp;&amp; this.rotatorSubscription.unsubscribe();
  }
}
</code></pre>
","9318464","","15527686","","2021-06-27 10:29:20","2021-06-27 10:29:20","Implement toggle-based page rotation rxjs Angular","<javascript><angular><typescript><rxjs><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"68172148","1","68172925","","2021-06-29 03:09:01","","0","34","<p>This question is for learning purposes, not to solve a particular problem (please move it to the appropriate section if necessary).</p>
<p>I'm learning about piping operators in the RxJS library. At this site here (<a href=""https://rxjs.dev/guide/operators"" rel=""nofollow noreferrer"">https://rxjs.dev/guide/operators</a>) it distinguishes between pipeable operators and creator operators.</p>
<p>It defines pipeable operators as follows:</p>
<blockquote>
<p>A Pipeable Operator is a function that takes an Observable as its input and returns another Observable. It is a pure operation: the previous Observable stays unmodified.</p>
</blockquote>
<p>And it defines creator operators as follows:</p>
<blockquote>
<p>Creation Operators are the other kind of operator, which can be called as standalone functions to create a new Observable. For example: of(1, 2, 3) creates an observable that will emit 1, 2, and 3, one right after another.</p>
</blockquote>
<p>But this leaves me wondering: is there such an operator as one that DOES modify the observable it gets as input and returns it as output? I haven't come across anything like that. Is there a reason such an operator doesn't exist? What kind of undesired behavior would result from such an operator?</p>
","9334823","","","","","2021-06-29 05:09:46","Are there RxJS operators that modify the observable?","<rxjs><pipe><rxjs-observables><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"68173187","1","68173566","","2021-06-29 05:43:44","","1","47","<p>How is it possible with RXJS to make a cascaded <code>forEach</code> loop? Currently, I have 4 observables containing simple string lists, called <code>x1 - x4</code>. What I want to achieve now is to run over all variation and to call a REST-Api with an object of variation data. Usually, I would do something like that with a forEach, but how to do with RXJS? Please see the abstracted code:</p>
<pre><code>    let x1$ = of([1,2]);
    let x2$ = of([a,b,c,d,e,f]);
    let x3$ = of([A,B,C,D,E,F]);
    let x4$ = of([M,N,O,P]);

    x1$.forEach(x1 =&gt; {
        x2$.forEach(x2 =&gt; {
            x3$.forEach(x3 =&gt; {
                x4$.forEach(x4 =&gt; {
                    let data = {
                        a: x1,
                        b: x2,
                        c: x3,
                        d: x4
                    }

                    return this.restService.post('/xxxx', data)
                })  
            })  
        })          
    })
</code></pre>
<p>Is something like that possible with RXJS in an elegant way?</p>
","9939844","","","","","2021-06-29 06:50:12","Using RXJS like a cascaded forEach loop?","<rxjs><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"68181461","1","","","2021-06-29 15:14:55","","1","34","<p>I have an endpoint which receives an array of ids to do some processing.</p>
<p>The backend dev, asked me to send only 10 ids during rushhour, and 50 outside them.</p>
<p>The user enters in a field, all the ids they want to process (top 100).</p>
<p>What I need to do is, first, know how much ids send to the back, regarding the current time.</p>
<p>I haven't chunked the ids before hand, because I wanted to take a number of ids related to the condition mentioned before, so I was trying to repeat the whole obs until there are none ids to process.
There is another challenged, which is that it must have a delay of 1 min between each.</p>
<pre><code>    concatMap(() =&gt;
      of(null).pipe(
        map(() =&gt; this.isRushHour()),
        map(isRushHour =&gt; this.storeListToProccess.splice(0, isRushHour ? 10 : 50)),
        switchMap(p =&gt; this.createZones(p)),
        delayWhen(() =&gt; this.storeListToProccess.length ? interval(this.delayMs) : interval(0)),
        repeatWhen(()=&gt; !!this.storeListToProccess.length)
      )
    )
</code></pre>
<p>Is there any way to achieve this or is prechunking the ids the only way to do it?</p>
","16343557","","13302","","2021-06-29 15:48:27","2021-06-30 17:20:08","Rxjs Repeat Until items to process is zero","<angular><typescript><rxjs><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"68191360","1","","","2021-06-30 08:44:24","","0","65","<p>I've created a Service which contains the next methods:</p>
<pre><code>public getSomething(): Observable&lt;MyObject&gt; {
    if (this.myObject) {
      return of(this.myObject); #
    } else {
      return this.myService.DoIt().pipe(
        switchMap((result) =&gt; {
          if (result) {
            return this.getObject();  !!!!
          } else {          
            const myObject = new MyObject('Something');
            return of(myObject); #
          }
        }),
        catchError((error) =&gt; {
          return this.handleError(error);
        })
      );
    }
  }
  private getObject(): Observable&lt;MyObject&gt; {
    const tempresult = this._http.get&lt;MyObject&gt;({
      endpoint: '/something'
    });
    return tempresult.pipe(
      map((result) =&gt; {
        this.myObject = MyObject.fromJson(result);
        return this.myObject;
      })
    );
  }
</code></pre>
<p>In a component, the 'getSomething' method will be called, using:</p>
<pre><code>this.someService.getSomething().subscribe((result) =&gt; {
      result -&gt; The subscribe never contains the data of the 'return this.getObject();'
    });
</code></pre>
<p>The lines marked with # are returing the correct data, but the !!!! marked line never returns the value in the subscribe. So apparently I'm doing something wrong, but I can't find a solution. I would expect the value of 'return this.getObject(); ' in certain cases as result in the subscribe.</p>
<p>Could you point me in the right direction? I think the issue is caused by the current structure of having a pipe -&gt; pipe which needs to return the Observable.</p>
","1974344","","1974344","","2021-06-30 12:33:51","2021-06-30 12:33:51","Observable - Subscribe doesn't receive expected value","<angular><rxjs><rxjs-observables>","2","3","","","","CC BY-SA 4.0"
"68260536","1","68260785","","2021-07-05 18:14:54","","0","64","<p>In my angular component I have the below properties:</p>
<pre><code>memberInfoLists$: Observable&lt;MemberInfo[]&gt;;
total$: Observable&lt;number&gt;;
memberPhotoUrl: string = environment.memberPhotoUrl;
memberDefaultPhoto: string = environment.defaultPersonPhoto;
</code></pre>
<p>Now in <strong>ngOnInit</strong> function I have called the service to get the observable to fill <strong>memberInfoLists$</strong> property. But before the fill I want to change one of the property value of each object in the collection. Here is my code:</p>
<pre><code>ngOnInit(): void {
        this.memberInfoLists$ = this.service.memberInfoLists$.pipe(map(item =&gt; item.forEach(y =&gt; {
            if (y.MemberPhotoUrl) {
                y.MemberPhotoUrl = this.memberPhotoUrl + y.MemberPhotoUrl;
            }   
            else{
                y.MemberPhotoUrl = this.memberDefaultPhoto;
            }   
            
            if (y.VoterPhotoUrl) {
                y.VoterPhotoUrl = this.memberPhotoUrl + y.VoterPhotoUrl;
            }   
            else{
                y.VoterPhotoUrl = this.memberDefaultPhoto;
            }   

            return item;
        })));
        this.total$ = this.service.total$;
    }
</code></pre>
<p>But it throws the below exceptions:</p>
<blockquote>
<p>src/app/setup-module/pages/member-info-list/member-info.component.ts:69:3</p>
<ul>
<li><p>error TS2322: Type 'Observable' is not assignable to type 'Observable&lt;MemberInfo[]&gt;'.   Type 'void' is not assignable to type
'MemberInfo[]'.</p>
<p>this.memberInfoLists$ =
this.service.memberInfoLists$.pipe(map(item =&gt; item.forEach(y =&gt; {</p>
</li>
</ul>
</blockquote>
<p>Can anyone help me to solve the problem?</p>
","2975931","","2975931","","2021-07-05 18:22:10","2021-07-05 18:44:05","RxJs map operator to change the property value of a collection of objects in angular","<angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"68268495","1","","","2021-07-06 10:04:03","","0","21","<p>In my React application I am using Webworker to upload files. Once a file is uploaded I am updating main thread using the <strong>postMessage</strong> which is making the application a little slow, so is there any other approach by which I can update my main thread when a file upload is complete?</p>
<p>I have tried to use <strong>rxjs</strong>, but it's it's not working. Any other solution is appreciated.
<a href=""https://jasonwatmore.com/post/2019/02/13/react-rxjs-communicating-between-components-with-observable-subject"" rel=""nofollow noreferrer"">https://jasonwatmore.com/post/2019/02/13/react-rxjs-communicating-between-components-with-observable-subject</a></p>
<p>Thanks!</p>
","8823436","","","","","2021-07-06 10:04:03","Is there any other way to pass data from a Webworker to main thread?","<reactjs><rxjs><web-worker><rxjs-observables>","0","0","","","","CC BY-SA 4.0"
"68271722","1","68271950","","2021-07-06 13:44:40","","0","191","<p>I am building out an app and planning to use rxjs for Observables. However, I like react-query cache functionality and would like to merge them together to get it working.</p>
<p>I am facing an issue where the error code is not clear to me.</p>
<p>Please advice.</p>
<pre><code>import React, { FunctionComponent } from 'react';
import { render } from 'react-dom';
import { useQueryStream } from './useQueryStream';
import API from './apiService';
import './style.css';
import { Observable, of } from 'rxjs';
import { catchError, take } from 'rxjs/operators';

const Hello: FunctionComponent = () =&gt; {
  const fetchPokemon = &lt;T&gt;(): Observable&lt;T[]&gt; =&gt; {
    const data =  API.get&lt;T[]&gt;('pokemon?limit=100&amp;offset=0').pipe(
      take(1),
      catchError(err =&gt; of(console.log(err)))
    ) as Observable&lt;T[]&gt;;

    console.log(data)
  };

  const result = useQueryStream('data', fetchPokemon);
  return &lt;&gt;{JSON.stringify(result, null, 2)}&lt;/&gt;;
};

export default Hello;
</code></pre>
<p>I am also extending react-query to accept an observable and subscribe to it and send the data.</p>
<pre><code>import { QueryFunction, useQuery, useQueryClient } from 'react-query';
import { Observable, combineLatest } from 'rxjs';
import { useEffect } from 'react';
import { UseQueryOptions } from 'react-query/types/react/types';

export const useQueryStream = (
  queryKey: string,
  fetcher: QueryFunction,
  config?: UseQueryOptions
) =&gt; {
  const queryClient = useQueryClient();
  const queryResult = useQuery(queryKey, fetcher, config);

  useEffect(() =&gt; {
    if (queryResult.data instanceof Observable) {
      queryResult.data.subscribe({
        next: data =&gt; {
          queryClient.setQueryData(queryKey, (currentQueryData: any) =&gt; {
            currentQueryData &amp;&amp; combineLatest(currentQueryData, data);
          });
        },
        error: error =&gt; {
          console.error(error);
        }
      });
    }
  }, [queryKey, queryResult.data]);

  console.log('queryResult', queryResult);

  return queryResult;
};
</code></pre>
<p>This is my stackblitz link:  <a href=""https://stackblitz.com/edit/react-ts-3tqgbx?file=Hello.tsx"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/react-ts-3tqgbx?file=Hello.tsx</a></p>
<p>Please advice on how I fix the error and how I get the data back.</p>
","6731368","","","","","2021-07-06 14:00:37","Using observables in react-query","<reactjs><typescript><rxjs><rxjs-observables><react-query>","1","0","","","","CC BY-SA 4.0"
"68288843","1","","","2021-07-07 15:24:54","","0","50","<p>I'm working on Angular project with NgRx and I'm in the following scenario:</p>
<pre><code>   forkJoin({
     sub1: this.getSub1(),
     sub2: this.getSub2()
   }).pipe(takeUntil(this.destroy$));
 }

 getSub1() {
   return this.store.select(select1)
     .subscribe();
 }

 getSub2() {
   return this.store.select(select2)
     .subscribe();
 }
</code></pre>
<p>The question is: Will takeUntil(this.destroy$) affects getSub1 and getSub2?</p>
<p>Many thanks in advance.</p>
","12566163","","","","","2021-07-07 15:24:54","How to unsubscribe the forkJoin subscriptions","<angular><rxjs><ngrx><rxjs-observables><rxjs-pipeable-operators>","0","2","","","","CC BY-SA 4.0"
"68337691","1","","","2021-07-11 15:40:22","","0","13","<p>I want to switch one of my state values from true, to false, to true by calling actions.blinkingClockAction(). So I'm trying to call the same action in a row inside of my observable. It seems as though the action can only be called once or is only received once. I'm new to observables so if you could explain why that is that would be great.</p>
<p>observable:</p>
<pre><code>const someEpic$: Epic&lt;AnyAction, AnyAction, ReducerState | any, Services&gt; = (
action$,
state$,
{ AlarmClock }
) =&gt;
action$.pipe(
filter(isActionOf(actions.resetClockAction)),
map(() =&gt; actions.blinkingClockAction()),
delay(1000),
map(() =&gt; actions.blinkingClockAction()),
delay(1000),
map(() =&gt; actions.blinkingClockAction()),
map(() =&gt; actions.restartClockAction()),
tap((val) =&gt; console.log(val))
);
</code></pre>
<p>Reducer:</p>
<pre><code>export const firstReducer: Reducer&lt;typeof initialState, ReducerActions&gt; = (
state = initialState,
action: ReducerActions
) =&gt; {
switch (action.type) {
case getType(actions.pauseAction):
 return { ...state, timeRunning: !state.timeRunning };
case getType(actions.resetClockAction):
 return {
  ...state,
  currentTime: new Date().toLocaleTimeString(&quot;en-US&quot;),
  timeRunning: false,
  showing: false,
 };
case getType(actions.runClockAction):
 if (state.timeRunning) {
  return { ...state, currentTime: new Date().toLocaleTimeString(&quot;en-US&quot;) };
 } else {
  return state;
 }
case getType(actions.blinkingClockAction):
  return { ...state, showing: !state.showing };
case getType(actions.restartClockAction):
  return { ...state, timeRunning: true };
default:
  return state;
 }
};
</code></pre>
<p>actions:</p>
<pre><code>import { ActionType } from &quot;typesafe-actions&quot;;
import { createAction } from &quot;typesafe-actions&quot;;
export const pauseAction = createAction(&quot;PAUSE_TIME&quot;)();
export const runClockAction = createAction(&quot;RUN_CLOCK&quot;)();
export const resetClockAction = createAction(&quot;RESET_CLOCK&quot;)();
export const restartClockAction = createAction(&quot;RESTART_CLOCK&quot;)();
export const blinkingClockAction = createAction(&quot;BLINKING_CLOCK&quot;)();

export const actions = {
pauseAction,
runClockAction,
resetClockAction,
restartClockAction,
blinkingClockAction,
</code></pre>
<p>};</p>
<p>export type Action = ActionType;</p>
","13683254","","","","","2021-07-11 15:40:22","RxJs Observable/Epic not able to call the same action in a row?","<reactjs><redux><rxjs><rxjs-observables><epic>","0","0","","","","CC BY-SA 4.0"
"68341120","1","","","2021-07-12 01:48:17","","0","18","<p>I am working on my application to increase the speed
Actually, I have two observables. I want to know how long each of them take to complete, and which of them is faster. What is the best way to gain this.</p>
","2526617","","","","","2021-07-12 11:56:51","RXJS, Calculate how long an observable takes to complete","<rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"68366836","1","68367505","","2021-07-13 17:18:36","","4","34","<p>hope you can help me out.</p>
<p>I have a function called getEnergyFromPower which returns a string of values:</p>
<pre><code>getEnergyFromPower(systemId: number, objectId?: string) {
    ...

    return this.httpClient.get(this.BASE_URL + this.AGGREGATE_URL, {
      headers: this.BEARER_OPTIONS.headers,
      responseType: 'text',
      params: params
    })
  }

</code></pre>
<p>And another one that was supposed to loop through the values of an Observable.
But when I subscribe and console.log it it returns instead an array of observables like so:</p>
<pre><code>organizeEnergy(systemId: number = 49439) {
    return this.getSystemLayout(systemId).pipe(
      map(res =&gt; {
        return res.map(({object_id}) =&gt; this.getEnergyFromPower(49439, object_id))
      })
    )
  }


this.optService.organizeEnergy().subscribe(res =&gt; console.log(res))

// Returns: 
// [Observable, Observable, Observable, Observable, Observable, Observable, Observable, Observable]

</code></pre>
<p>I tested to see if the object_id was right and it returns the right values like so:</p>
<pre><code>organizeEnergy(systemId: number = 49439) {
    return this.getSystemLayout(systemId).pipe(
      map(res =&gt; {
        return res.map(({object_id}) =&gt; object_id)
      })
    )
  }

this.optService.organizeEnergy().subscribe(res =&gt; console.log(res))
//RETURNS 
// (8) [83978300, 83978301, 83978302, 83978303, 83978304, 83978305, 83978306, 83978307]
</code></pre>
<p>I also tested it hard coded like so and it works:</p>
<pre><code>  organizeEnergy(systemId: number = 49439) {
    return this.getEnergyFromPower(systemId, '83978300')
  }

this.optService.organizeEnergy().subscribe(res =&gt; console.log(res))
//RETURNS 
// 2021/07/13 08:55:00.000,38

</code></pre>
<p>So I'm guessing my problem is when I try to map the response in this line:</p>
<pre><code>organizeEnergy(systemId: number = 49439) {
     ...
        return res.map(({object_id}) =&gt; this.getEnergyFromPower(49439, object_id))
     ...
  }

</code></pre>
<p>So I would like to loop through it and dynamically the results whenever I subscribe to it.</p>
<p>Maybe it's something I didn't yet grasp since it's been two weeks I started with Angular/Observables/HttpClient</p>
","16440941","","","","","2021-07-14 00:45:04","Mapping through an observable and return values of nested observable","<javascript><angular><rxjs><observable><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"68393691","1","68393752","","2021-07-15 12:18:13","","2","58","<p>I have a navbar in my App component:</p>
<p>app.component.html</p>
<pre><code>&lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarSupportedContent&quot;&gt;
  &lt;ul class=&quot;navbar-nav me-auto mb-2 mb-lg-0&quot;&gt;
    &lt;li class=&quot;nav-item&quot;&gt;          
      &lt;div *ngIf=&quot;_loginService.user.name.length &gt; 0 &amp;&amp; _loginService.user.id.length &gt; 0 ; else elseBlock&quot;&gt;
        &lt;a class=&quot;nav-link&quot; (click)=&quot;logout()&quot;&gt;Logout {{ _loginService.user.name }}&lt;/a&gt; 
      &lt;/div&gt;
      &lt;ng-template #elseBlock&gt;
        &lt;a class=&quot;nav-link&quot; routerLink=&quot;login&quot;&gt;Login&lt;/a&gt;            
      &lt;/ng-template&gt;                                          
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<p>app.component.ts</p>
<pre><code>export class AppComponent implements OnInit {
  user: User = {
    name: '',
    id: ''
  };
  
  constructor(public _loginService: LoginService){
  }

  ngOnInit(): void {    
  }

  getUser(): User{
    return this._loginService.user;
  }

  logout(){
    this._loginService.logout()    
  }    

}
</code></pre>
<p>When user is logged in, the navbar should display 'logout username'.
I have successfully implemented a login service to do so:</p>
<pre><code>@Injectable()
export class LoginService{

    user: User = {
      name:'',
      id:''
    };

    userChange: Subject&lt;User&gt; = new Subject&lt;User&gt;();

    constructor(){
      this.userChange.subscribe(value =&gt;{
        console.log(&quot;userChange.subscribe&quot;,value)
        this.user = value
      })
    }
  
    login(name = &quot;&quot;,id = &quot;&quot;){      
      this.userChange.next({name: name, id: id})
    }
  
    logout(){
      this.userChange.next({name:'',id:''})
    }      
   
}
</code></pre>
<p>But as you can see, I am exposing my <em>loginService</em> as <em>public</em> in my App component.</p>
<pre><code>&lt;div *ngIf=&quot;_loginService.user.name.length &gt; 0 &amp;&amp; _loginService.user.id.length &gt; 0 ; else elseBlock&quot;&gt;
</code></pre>
<p>I tried to do a:</p>
<pre><code>  getUser(): User{
    return this._loginService.user;
  }
</code></pre>
<p>and then use getUser in app.component.html:</p>
<pre><code>&lt;div *ngIf=&quot;getUser.name.length &gt; 0 &amp;&amp; getUser.id.length &gt; 0 ; else elseBlock&quot;&gt;
</code></pre>
<p>but it doesn't work. Please help!</p>
","404109","","","","","2021-07-15 12:32:04","Angular Navbar change when Logged in","<angular><authentication><rxjs-observables><angular-observable>","1","0","","","","CC BY-SA 4.0"
"68396794","1","","","2021-07-15 15:37:45","","0","18","<p>I'm trying to get the result of one selector to be used in an other one, all being synchronous.
I have my method searchBirthTown :</p>
<pre><code>searchBirthTowns({ debounce, scheduler } = { debounce: 500, scheduler: asyncScheduler }) {
        // This selector gives me the birthDate
        this.store.pipe(select(fromStore.getBirthDate), first()).subscribe(x =&gt; this.date = x);

        // This one returns me the city, ideally with the birthDate 
        return this.store.pipe(
            select(fromStore.selectBirthFormAutocompleteField),
            filter(field =&gt; field === 'birthCommune'),
            switchMap(_ =&gt;
                this.store.pipe(
                    select(fromStore.selectBirthFormAutocompleteData),
                    map(x =&gt; x.seized),
                    filter(x =&gt; !!x),
                    debounceTime(debounce, scheduler),
                    distinctUntilChanged(),
                    switchMap(city =&gt; this.nomenclatureService.listBirthTowns({ label: city, birthDate: ? }))
                )
            )
        );
    }
</code></pre>
<p>I have tried to use combineLatest to merge them both but without success.
Any idea ?</p>
<p>EDIT :</p>
<p>I solved it by gibing <code>this.store.pipe(select(fromStore.getBirthDate), first())</code> as a parameter for birthDate and then treating the Observalbe in listBirthTowns().</p>
<p>It might not be the best solution though.</p>
","7984932","","7984932","","2021-07-15 16:04:55","2021-07-15 16:04:55","Use a selector value in a selector without losing synchronicity","<angular><rxjs><rxjs-observables>","0","2","","","","CC BY-SA 4.0"
"68416907","1","","","2021-07-17 02:17:16","","0","46","<p>What I am trying to do - I need to add conditional check before triggering the api call (getterFunc), which check if data is already present in store or not,  if it’s not then fetch the data from backend. But if it’s available, then simulate the success event and provide store data in payload. Can you help me with what’s exactly wrong am I doing in this implementation</p>
<pre class=""lang-js prettyprint-override""><code>const getTemplateEpic = (getterFunc, initial, success, cancel, failure) =&gt; (action$, store) =&gt; action$.pipe(
  ofType(initial),
  mergeMap(action =&gt; iif(() =&gt; Object.keys(store.value.getIn(['whatsApp'].templateListData)).length,
    of({
      type: success,
      payload: { res: store.value.getIn(['whatsApp'].templateListData) }
    }),
    getterFunc('GET', action.payload)
  ).pipe(
    map(response =&gt; ({
      type: success,
      payload: { res: response.response },
    })),
    takeUntil(action$.pipe(ofType(cancel))),
    catchError(error =&gt; of({
      type: failure,
      payload: { res: error },
    })
    )
  )
  )
);

</code></pre>
","6727545","","","","","2021-07-17 02:17:16","How can I trigger action in RxJS based on a conditional logic?","<reactjs><rxjs><rxjs-observables>","0","2","1","","","CC BY-SA 4.0"
"68435450","1","","","2021-07-19 05:25:03","","1","52","<p>I'm stuck here right now I hope someone can help me :-)</p>
<p><strong>following scenario:</strong></p>
<p>I have two streams which transfer the same data type.
The first stream provides initial data (REST call) and completes afterwards.
The second stream gets its data via websocket and does not complete.</p>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const mockData: User[] = [
  { id: '1', status: 'active' },
  { id: '2', status: 'inactive' },
  { id: '3', status: 'active' }
];

const initial$: Observable&lt;User[]&gt; = of(mockData);

const sub$: BehaviorSubject&lt;User[]&gt; = new BehaviorSubject(mockData);
const dynamic$ = sub$.asObservable();</code></pre>
</div>
</div>
</p>
<p>Now I want to merge both streams and create two new streams based on a filter criterion, one for the active and one for the deactivated users.</p>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const merged$ = merge(initial$, dynamic$).pipe(
  distinctUntilChanged((a, b) =&gt; JSON.stringify(a) === JSON.stringify(b))
);

const grouped$ = merged$.pipe(
  mergeMap((users: User[]) =&gt; from(users)),
  tap(a =&gt; console.log('Before group by', a)),
  groupBy(item =&gt; item.status),
  tap(a =&gt; console.log('After group by', a.key)),
  mergeMap(group =&gt; zip(of(group.key), group.pipe(toArray()))),
  tap(a =&gt; console.log('after merge map', a))
);

const activeByGrouped$ = grouped$.pipe(
  filter(([key]) =&gt; key === 'active'),
  map(([key, value]) =&gt; value)
);

activeByGrouped$.subscribe(a =&gt; console.log('final subscribe', a));</code></pre>
</div>
</div>
</p>
<p>The whole thing works if both streams complete, but not if one is open.
Attached is a stackblitz for better understanding.</p>
<p><strong>&gt;&gt; stackblitz <a href=""https://stackblitz.com/edit/typescript-ixc3nu"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/typescript-ixc3nu</a> &lt;&lt;</strong></p>
","16477790","","","","","2021-07-20 06:07:48","RxJs - can't create two new Observables from merged one","<javascript><merge><rxjs><behaviorsubject><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"68511027","1","","","2021-07-24 14:42:49","","0","58","<p>I'm trying to create an in-memory singleton that holds the current vendor a person is browsing on.</p>
<p>A guard is use on all specific routes to catch the parameter:</p>
<pre><code>canActivate(
  route: ActivatedRouteSnapshot,
  state: RouterStateSnapshot): Observable&lt;boolean | UrlTree&gt; {

  let currentUrl = this._router.url;
  const param = route.params['vendname'];

  return this._vendorService.getByName(param).pipe(map(a =&gt; {
    if (a == null) {
      this._snackBarService.open('Vendor not found', 'x', { duration: 5000 });
      return this._router.parseUrl(currentUrl);
    }
    return true;
  }));
}
</code></pre>
<p>A service is used to get the the vendor by name. If it exists in-memory return it. If it doesn't, get it from the server first.</p>
<pre><code>set vendor(value: IUser) {
  this._vendor.next(value);
}

get vendor$(): Observable&lt;IUser&gt; {
  return this._vendor.asObservable();
}

getByName(name: string): Observable&lt;IUser&gt; {
  const result = this.vendor$.pipe(map(v =&gt; {
    if (v != null &amp;&amp; v.displayName == name) {
      return v;
    }
    else {
      return this.Get&lt;IUser&gt;(`api/vendor/${name}`).pipe(switchMap(v =&gt; {
        this.vendor = v;
        return of(v)
        // ...
      }));
    }
  }))
  return result;
}
</code></pre>
<p>The problem is I need to check <code>vendor$</code> for its value which returns an <code>Obervable&lt;IUser&gt;</code> but the switchMap also returns an <code>Obervable&lt;IUser&gt;</code>, causing the result to be <code>Observable&lt;Observable&lt;IUser&gt;&gt;</code>. How can I make the <code>result</code> return a single User Observable?</p>
","1659605","","","","","2021-07-26 13:02:06","Can you transform the result of switchMap observable to get its value and not the observable itself?","<angular><typescript><rxjs><rxjs-observables><switchmap>","3","4","","","","CC BY-SA 4.0"
"68528702","1","68530897","","2021-07-26 11:02:45","","2","52","<p>I have an Observable array which looks like this:</p>
<pre><code>persons$: Observable&lt;Person[]&gt; = new Observable&lt;Person[]&gt;();
private personSource: BehaviorSubject&lt;Person[]&gt;;

  constructor() {
    this.personSource = new BehaviorSubject&lt;Person[]&gt;([
    new Person('Meenique'),
    new Person('Wolfcastle'),
    new Person('Stradivarius Cain'),
    new Person('Wiggum'),
    new Person('McKenna'),
    new Person('Flanders'),
    new Person('Kent Brockman'),
    new Person('Manjula')
]);
</code></pre>
<p>Now, I want to select values between given property. eg: 'Name'</p>
<pre><code>async selectBetween(start: string, end: string): Promise&lt;Person[]&gt; {
// return this.persons$.pipe(map(p =&gt; p.Name)).toPromise();
}
</code></pre>
<p>The <code>selectBetween</code> function will take two sting values. In this case, the <code>Person.Name</code>, and should return all values between given names.</p>
<p>e.g:</p>
<pre><code>const test1 = await this.selectBetween('Wolfcastle', 'McKenna');
</code></pre>
<p>Should return: [Wolfcastle, Stradivarius Cain, Wiggum, McKenna]</p>
<p>Here my StackBlitz example:</p>
<p><a href=""https://stackblitz.com/edit/example-rxjs-observable-create-from-scratch-pqvmqj?file=app/app.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/example-rxjs-observable-create-from-scratch-pqvmqj?file=app/app.component.ts</a></p>
","7409169","","7409169","","2021-07-26 11:28:07","2021-07-26 13:51:11","Rxjs Observable array select between given start and end values","<typescript><rxjs><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"68591861","1","","","2021-07-30 13:35:06","","1","72","<p>Below code with one api request is working fine. But instead of find in forEach loop, want to get data from another API call, which is not working as it return the values from function and response received later on, as a result view not getting updated.</p>
<pre><code>getResults: Observable&lt;Entity&gt; {
        const entityData= [{id: '3', name:'abc', products: []}, {id: '4', name: 'xyz', products: []}];
        return this.service.getResults().pipe(
        map((data) =&gt; this.convert(data, entityData)));
   }

   convert(item, entityData): any {
    let values=[];
    const node: {
      products: item.products ? item.products : [],
      expand: true //getting result(true/false) from another function.
    }
    values.push(node);
    node.products.forEach((childUnit)=&gt; {
        const result = entityData.find(a=&gt;a.id==childUnit.id));

        // want result from another api call, which returns the observable.
        // Once all the result get iterated then want to return the {Values}.
        // this.service.getresultById(item.id).subscribe((data)=&gt;{this.convert(data)})

        const child = this.convert(result, entityData);
        values = values.concat(child);
    });
    return {values};
   }
</code></pre>
<p>Any help for the same.</p>
","6541631","","6541631","","2021-07-30 16:42:29","2021-07-30 16:42:29","Angular Observable not working with another API call","<javascript><angular><angular2-observables><rxjs-observables>","0","13","","","","CC BY-SA 4.0"
"68625711","1","68626062","","2021-08-02 17:25:22","","1","55","<p>I have 3 filter values (select boxes basically). When there is a selection change, I want to fire a combined API call along with other filter values selected previously (using BehaviorSubject for each filter). Unfortunately, in the 'combineLatest' I can see only 1 filter value. Other values from other subjects are disappearing. Please help me understand where am i going wrong:</p>
<p><strong>Service:</strong></p>
<pre class=""lang-ts prettyprint-override""><code>private typeFilterSubject = new BehaviorSubject('');
typeFilterObs$ = this.typeFilterSubject.asObservable();

private priceFilterSubject = new BehaviorSubject('');
priceFilterObs$ = this.priceFilterSubject.asObservable();

private brandFilterSubject = new BehaviorSubject('');
brandFilterObs$ = this.brandFilterSubject.asObservable();

updateTypeFilter(filter) {
  this.typeFilterSubject.next(filter);
}
updatePriceFilter(filter) {
  this.priceFilterSubject.next(filter);
}
updateBrandFilter(filter) {
  this.brandFilterSubject.next(filter);
}

getData$ = combineLatest([
  this.typeFilterObs$,
  this.priceFilterObs$,
  this.brandFilterObs$
]).pipe(
  switchMap(([type, price,brand]) =&gt; {
    console.log([type, price, brand]);

    // here i am getting [&quot;electronics&quot;,&quot;&quot;,&quot;&quot;]
    // or [14, &quot;&quot;, &quot;&quot;] or [&quot;IKEA&quot;, &quot;&quot;, &quot;&quot;]
    // instead of [&quot;electronics&quot;, 14, &quot;IKEA&quot;]

    return this._http.get&lt;IProduct[]&gt;(
      `http://localhost:3000/products?type=${type}&amp;price=${price}&amp;brand=${brand}`
    );
  })
);
</code></pre>
<p><strong>Component -1 : from where 'next' is fired</strong></p>
<pre class=""lang-ts prettyprint-override""><code>onTypeChanged() {
  this._appService.updateTypeFilter(this.typeSelected) //&quot;Electronics&quot;
}

onBrandChanged() {
  this._appService.updateTypeFilter(this.brandSelected) //&quot;IKEA&quot;
} 

onPriceChanged() {
  this._appService.updateTypeFilter(this.priceSlected) //14
}
</code></pre>
<p><strong>component 2 - from where I am subscribing to the combined data</strong></p>
<pre class=""lang-ts prettyprint-override""><code>this.getData = this._appService.getData$
</code></pre>
","6456247","","17447","","2021-08-02 17:35:56","2021-08-02 17:57:46","RxJS combineLatest: Unable to merge with latest values in Angular 12","<angular><rxjs><angular2-observables><rxjs-observables><rxjs-pipeable-operators>","1","2","1","","","CC BY-SA 4.0"
"68679054","1","","","2021-08-06 09:10:31","","0","47","<p>First of all thank you for your time.</p>
<p>I would like to get a nudge into the right direction regarding making my own custom Rxjs operator that results into the same as shareReplay() except when I want it to update.</p>
<p>Basically we have a session storage variable which sets the users organization AND a JWT token that contains the organization of the user (Token is single source of truth).
Based upon that organization we have API data that is just set in stone for the session. Only if the user changes organization we would like to refresh that data and make a new call. shareReplay() is perfect to use, except I don't know how I can get my own logic to check if I need to refresh. (As in, if JWTToken === sessionstorage.getItem('organization')).</p>
<p>Currently I have something like this, but at the moment I am not experienced enough with Rxjs to do it properly, any help is appreciated! Btw, If you have a better approach, thats fine too. I just thought it would be easy to reuse the operator.</p>
<ul>
<li>Rxjs version 6.5.5</li>
<li>Angular version 12.1.0</li>
</ul>
<pre><code>/**
 * Replay this when organization is the same
 * @returns
 */
export function replayWhenSameOrganization&lt;T&gt;() {
  return function (source: Observable&lt;T&gt;) {
    if (this.token.organization === sessionStorage.getItem('organization')) {
      return source;
    } else {
      return new Observable&lt;T&gt;((subscriber) =&gt; {
        source.subscribe({
          next(value) {
            subscriber.next(value);
          },
          error(error) {
            subscriber.error(error);
          },
          complete() {
            subscriber.complete();
          },
        });
      });
    }
  };
}

</code></pre>
<p>Currently shareReplay would be nice as I can rewrite a legacy application that is using subscribe in subscribe every component again for the same data, resulting in stepping through the router through 7 components, and 7 times its calling the same URL with the same response, I think it has been done to fight the refresh issue. shareReplay resolves this as it will send the last received value if there is any and will send a request if there is none. My issue is that I need to set a condition on when I actually want to get fresh server data even if I have a value already. ( In the case of the user switching organizations without refreshing the app ). I know using Ngrx might be a solution as you can send an action to reset the store, except the team is not there yet.</p>
<p><strong>Legacy</strong></p>
<p>APISERVICE</p>
<pre><code>GetConfig() {
  return this.http.get('apiurl/config');
}

</code></pre>
<pre><code>ngOnInit(): void {
   this.apiService.GetConfig().subscribe(config =&gt; {
     this.apiService.GetComponentData(config.id).subscribe( 
        componentdata =&gt; { 
          this.componentdata = componentdata;
        }
     );
   })
}
</code></pre>
<p><strong>My refactor idea</strong></p>
<p>I would like to use the async pipe in the HTML files and rewrite some stuff as I think it will improve readability and makes the front-end code more testable as you can mock Observable values.</p>
<p>APISERVICE</p>
<pre><code>GetConfig(): Observable&lt;IConfig&gt; {
  return this.http.get('apiurl/config').pipe(
    tap(config =&gt; this.config = config),
    shareReplay()
  )
}
</code></pre>
<pre><code>$componentData: Observable&lt;ComponentData&gt; = this.getComponentData();

ngOnInit(): void {}

getComponentData(): Observable&lt;ComponentData&gt; {
  return this.apiService.$config.pipe(
       mergeMap(config =&gt; 
            this.apiService.GetComponentDataByConfig(config)
       )
   )
}

</code></pre>
","11792347","","11792347","","2021-08-06 14:19:37","2021-08-06 14:19:37","Angular Rxjs: Write custom operator to replace shareReplay() with my own business logic","<angular><rxjs><rxjs6><rxjs-observables>","0","4","","","","CC BY-SA 4.0"
"68725299","1","68726614","","2021-08-10 10:40:54","","3","45","<p>I have the following code:</p>
<pre class=""lang-js prettyprint-override""><code>const fetchBook = (bookId: number) =&gt; {
    const title = 'Book' + bookId;
    console.log('fetch book:', title)
    // mimic http request
    return timer(200).pipe(mapTo({ bookId, title }));
}

const bookId$ = new Subject&lt;number&gt;();

const book$ = bookId$.pipe(
    mergeMap(bookId =&gt; fetchBook(bookId))
);

book$.subscribe(book =&gt; console.log('subscriber1: ', book.title))
book$.subscribe(book =&gt; console.log('subscriber2: ', book.title))

bookId$.next(1);
</code></pre>
<p>console output:</p>
<pre><code>fetch book: Book1
fetch book: Book1 &lt;--- called second time
subscriber1:  Book1
subscriber2:  Book1
</code></pre>
<p>What is the best practice to prevent multiple fetches in RxJS?</p>
<p><strong>Upd:</strong> I don't use Angular</p>
<p><strong>Upd2:</strong> The problem is caused by multiple subscribers</p>
","5171110","","5171110","","2021-08-10 12:05:20","2021-08-10 12:12:00","How to prevent multiple fetch calling in RxJS?","<rxjs><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"68728725","1","68729261","","2021-08-10 14:32:39","","3","47","<p>I have a code that fetches book by its id</p>
<pre class=""lang-js prettyprint-override""><code>const fetchBook = (bookId: number) =&gt; {
    const title = 'Book' + bookId;
    // mimic http request
    return timer(200).pipe(mapTo({ bookId, title }));
}

const bookId$ = new Subject&lt;number&gt;();

const book$ = bookId$.pipe(
    switchMap(bookId =&gt; fetchBook(bookId)),
    shareReplay(1)
);

book$.subscribe(book =&gt; console.log('book title: ', book.title))

bookId$.next(1);
</code></pre>
<p>I have an API method that patches values and returns the updated object:</p>
<pre class=""lang-js prettyprint-override""><code>const patchBook = (bookId: number, newTitle: string) =&gt; {
    return timer(200).pipe(mapTo({ bookId, title: newTitle }));
}
</code></pre>
<p>What should I do to get <code>book$</code> to emit the new value after I call <code>patchBook(1, 'New Book Title')</code>?</p>
<p>I can declare <code>book$</code> as <code>Subject</code> explicitly and update it manually. But it will be imperative, not reactive approach.</p>
<p><strong>Upd:</strong> The patch is called as a result of user action at any time (or never)</p>
<p><strong>Upd2:</strong> Actually <code>book$</code> can be also changed on server side and my real code looks like this:</p>
<pre><code>const book$ = combineLatest([bookId$, currentBookChangedServerSignal$]).pipe...
</code></pre>
","5171110","","5171110","","2021-08-10 15:34:42","2021-08-16 19:11:10","What is the best way to patch fetched objects in RxJS?","<rxjs><rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"68732782","1","68758549","","2021-08-10 19:51:55","","1","25","<p>I am using <a href=""https://github.com/extend-chrome/messages"" rel=""nofollow noreferrer"">this</a> library for messaging.</p>
<p>I have my background script like this</p>
<pre class=""lang-js prettyprint-override""><code>import { sendUrlInfo, waitForUrl } from 'utils/messaging';
import URL from 'url-parse';

chrome.webNavigation.onHistoryStateUpdated.addListener((details) =&gt; {
  const url = new URL(details.url);
  console.log('sending', url.hostname, url.pathname);
  sendUrlInfo(new URL(details.url));
});

chrome.webNavigation.onCompleted.addListener((details) =&gt; {
  if (details.url !== 'about:blank') {
    const url = new URL(details.url);
    console.log('sending', url.hostname, url.pathname);
    sendUrlInfo(new URL(details.url));
  }
});
</code></pre>
<p>And according to documentation i have message.js as shown below</p>
<pre class=""lang-js prettyprint-override""><code>import { getMessage } from '@extend-chrome/messages';
import URL from 'url-parse';

const messageTypes = {
  URL_INFO: 'URL_INFO',
};

export const [sendUrlInfo, urlStream, waitForUrl] = getMessage&lt;URL&gt;(
  messageTypes.URL_INFO,
);

</code></pre>
<p>and now content script I have written in react
So i am trying to subscribe to stream when the component is mounted</p>
<pre class=""lang-js prettyprint-override""><code>import React, { useState, useEffect, useRef } from 'react';

import Editor from 'content/components/Editor';
import Opener from 'content/components/Opener';
import { urlStream, waitForUrl } from 'utils/messaging';

const Main: React.FC = () =&gt; {
  const [isOpen, setIsOpen] = useState(false);
  const [showContent, setShowContent] = useState(false);

  const editorRef = useRef&lt;HTMLTextAreaElement | null&gt;(null);

  useEffect(() =&gt; {
    console.log('MOunted');
    urlStream.subscribe(([url]) =&gt; {
      console.log('Received', url.hostname, url.pathname);
      if (url.hostname === 'www.youtube.com' &amp;&amp; url.pathname === '/watch') {
        if (!showContent) setShowContent(true);
      } else {
        if (showContent) setShowContent(false);
      }
    });
  }, []);

  useEffect(() =&gt; {
    document.addEventListener('keydown', onKeyPress);
    return () =&gt; {
      document.removeEventListener('keydown', onKeyPress);
    };
  });

  const onKeyPress = (e: KeyboardEvent) =&gt; {
    if (e.ctrlKey &amp;&amp; e.which === 192) {
      e.preventDefault();
      setIsOpen(!isOpen);
    }
  };

  if (!showContent) return &lt;&gt;&lt;/&gt;;

  return (
    &lt;&gt;
      &lt;div&gt;test&lt;/div&gt;
      &lt;Opener isOpen={isOpen} onClick={() =&gt; setIsOpen(true)} /&gt;
      &lt;Editor
        isOpen={isOpen}
        ref={editorRef}
        onClose={() =&gt; setIsOpen(false)}
      /&gt;
    &lt;/&gt;
  );
};

export default Main;

</code></pre>
<p>The error I am getting in background script console is</p>
<blockquote>
<p>Could not establish connection. Receiving end does not exist</p>
</blockquote>
<p>I think as much as i understand the background script is trying to send msg but the content script observable is not subscribed yet. As content script run after the page is loaded.
If this is the issue is there any way to use this library properly.</p>
<p>BTW this works if we use normal chrome api like this</p>
<pre class=""lang-js prettyprint-override""><code>chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
    chrome.tabs.sendMessage(
        tabs[0].id,
        message,
        function () {
                console.log(&quot;msg sent&quot;)     
        }
    );
});
</code></pre>
<p>and use onMessage to receive the msg.</p>
","11730918","","","","","2021-08-12 13:37:08","Get error while using extend-chrome/messages while sending messgae from background script to content script","<javascript><reactjs><google-chrome-extension><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"68738483","1","68746729","","2021-08-11 08:26:31","","2","27","<p>I created an Observable Alert in AG Grid (using Adaptable) which is correctly firing when an order is stale for 2 minutes.
But I only see the Alert in the Toolbar and not as a popup notification in the grid like happens in this demo: <a href=""https://demo.adaptabletools.com/alertsmessages/aggridobservablealertdemo"" rel=""nofollow noreferrer"">https://demo.adaptabletools.com/alertsmessages/aggridobservablealertdemo</a></p>
<p>The Expression for the Alert is</p>
<pre><code>GRID_CHANGE( [order_tick] ), TIMEFRAME('2m') ) 
</code></pre>
<p>What am I doing wrong?</p>
","11857476","","","","","2021-08-11 17:51:00","How can I make an Alert appear in the screen using AG Grid and Adaptable/","<ag-grid><rxjs5><rxjs6><ag-grid-react><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"68739199","1","","","2021-08-11 09:14:49","","4","209","<p>I have a code to fetch book and library card associated with it:</p>
<pre class=""lang-js prettyprint-override""><code>// mimic http requests
const fetchBook = (bookId: number) =&gt; {
    const title = 'Book' + bookId;
    return timer(200).pipe(mapTo({ bookId, title }));
}
const fetchLibraryCard = (bookId: number) =&gt; {
    const borrowerName = 'Borrower of Book' + bookId;
    return timer(300).pipe(mapTo({ borrowerName }));
}

const bookId$ = new Subject&lt;number&gt;();

const book$ = bookId$.pipe(
    switchMap(bookId =&gt; fetchBook(bookId)),
    shareReplay(1)
);

// e.g. 'Refresh library card' button
const libraryCardUpdater$ = new BehaviorSubject&lt;void&gt;(undefined);

const libraryCard$ = combineLatest([bookId$, libraryCardUpdater$]).pipe(
    switchMap(([bookId]) =&gt; fetchLibraryCard(bookId)),
    shareReplay(1)
);

combineLatest([book$, libraryCard$]).subscribe(([book, libraryCard]) =&gt; {
    console.log('book:', book.title, '| borrower:', libraryCard.borrowerName)
})

bookId$.next(1);
setTimeout(() =&gt; bookId$.next(2), 500);
setTimeout(() =&gt; libraryCardUpdater$.next(), 1000);
setTimeout(() =&gt; bookId$.next(3), 1500);
</code></pre>
<p>The problem that I get inconsistent state in subscriber:</p>
<pre><code>book: Book1 | borrower: Borrower of Book1  &lt;-- OK
book: Book2 | borrower: Borrower of Book1  &lt;-- Not OK
book: Book2 | borrower: Borrower of Book2  &lt;-- OK
book: Book2 | borrower: Borrower of Book2  &lt;-- OK, but redundant
book: Book3 | borrower: Borrower of Book2  &lt;-- Not OK
book: Book3 | borrower: Borrower of Book3  &lt;-- OK
</code></pre>
<p>I think about something like pushing <code>undefined</code> to <code>libraryCard$</code> at the same moment when <code>bookId$</code> is changed.</p>
<p>But how to do that in a reactive manner?</p>
<p><strong>Update:</strong></p>
<p>Library card should be always consistent with fetched book (or be <code>undefined</code> at loading time). <code>bookId$</code> can be changed by user action at any time. Also library card can be updated at any time manually by user (<code>libraryCardUpdater$</code>). <code>libraryCardUpdater$</code> emitting should re-fetch card, but shouldn't re-fetch book</p>
<p><strong>Update2:</strong>
I just realized that library card can be fetched sequentially after book. It is acceptable, although not perfect solution for end-user.</p>
","5171110","","5171110","","2021-08-18 08:55:43","2021-08-20 06:49:06","How to wait for a consistent state in RxJS?","<rxjs><rxjs6><rxjs-observables>","6","2","","","","CC BY-SA 4.0"
"68797757","1","68797839","","2021-08-16 05:26:04","","0","36","<pre><code>somefunction(){
    isUserLoggedin(): boolean {
        this.isUserInDB().subscribe((result: any) =&gt; {
          if (result.code === 200) {
            return true;
          }
        });
      return false;
  }
</code></pre>
<p><em>isUserInDB(): this API takes a token from localstorage and returns 200 if the user exists in DB or returns 404 if the user does not exist in DB (someone is trying to try his/her own token.)</em></p>
<p><strong>In this I always get false I know because of first return false is executed and then subscribe method is invoked. So I want to know that is that any other way exists or I just doing some extra stuff ?</strong></p>
","13920303","","","","","2021-08-16 08:26:21","Assign value to the variable based on returning data from the subscribe in Angular . (Is it possible ?)","<angular><typescript><promise><rxjs-observables>","3","2","","","","CC BY-SA 4.0"
"68805848","1","68805939","","2021-08-16 15:52:45","","1","62","<p>I'm attempting to simulate latency with my observables.</p>
<p>I want to unwrap the observable using the async pipe, and add a bit of delay with the 'delay' operator.</p>
<p><strong>app.component.html</strong></p>
<pre><code>&lt;ul *ngIf=&quot;items$ | async as items&quot;&gt;
   &lt;li *ngFor=let item of items&quot;&gt;{{ item }}&lt;li&gt;
&lt;/ul&gt;
</code></pre>
<p><strong>app.component.ts</strong></p>
<pre><code>get items$(): Observable&lt;string[]&gt; {
    return of(['alpha', 'bravo', 'charlie', 'delta']).pipe(delay(3000));
}
</code></pre>
<p>However, doing it in this fashion returns no HTML markup.  Removing the <code>pipe(delay(3000))</code> allows it to work.</p>
<p>If I implement 'OnInit' and just check on the observable:</p>
<pre><code>ngOnInit(): void {
   this.items$.subscribe(val =&gt; console.log(val));
}
</code></pre>
<p>In three seconds the console will output:</p>
<blockquote>
<p><em>(4) [&quot;alpha&quot;, &quot;bravo&quot;, &quot;charlie&quot;, &quot;delta&quot;]</em></p>
</blockquote>
<p>So the observable is behaving like I want it to, but it seems I am not utilizing the async pipe correctly.</p>
<p>What am I missing about about how the async pipe works?  How do I simulate this delay in a simple fashion?</p>
","1964732","","","","","2021-08-16 16:05:18","Angular Async Pipe and the 'delay' operator","<angular><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"68813250","1","","","2021-08-17 07:27:24","","0","62","<p>I have an options object which is a BehaviorSubject</p>
<pre><code>options: new BehaviorSubject&lt;Record&lt;string, Options&gt;&gt;({}),
</code></pre>
<p>I currently subscribe to changes using one of my services</p>
<pre><code>this.storeService.state.options.subscribe((options) =&gt; {
  this.options = options;
});
</code></pre>
<p>I have a method that removes a key/value pair inside the options object. <code>REMOVE_CATALOG_ITEM_OPTIONS</code></p>
<pre><code>export type RemoveCatalogItemOptionsAction = {
  type: typeof REMOVE_CATALOG_ITEM_OPTIONS;
  payload: string;
};

export type MyState = {
  options: Observable&lt;Record&lt;string, Options&gt;&gt;;
};

export type MyInitialState = {
  options: Record&lt;string, Options&gt;;
};

export class StoreService implements StoreServiceInterface&lt;MyState, MyAction&gt; {
  constructor(private store: Store&lt;AppState&gt;, initialState?: Partial&lt;MyInitialState&gt;) {
    if (initialState) this.initialiseState(initialState);
  }
 
  get state() {
    return {
      options: this._state.options.asObservable(),
    };
  }

  private _state = {
    options: new BehaviorSubject&lt;Record&lt;string, Options&gt;&gt;({}),
  }

  public update(actions: Array&lt;MyAction&gt;) {
    actions.forEach((action: MyAction) =&gt; {
     switch (action.type) {
        case REMOVE_OPTIONS: {
          const entities = this._state.options.getValue();
          const optionId = action.payload;

          const { [optionId]: _removedEntity, ...newEntities } = entities;

          this._state.options.next(newEntities);

          break;
        }
      }
    }
  }


  private initialiseState(state: Partial&lt;MyInitialState&gt;) {
    if (state.options) this._state.options.next(state.options);
  }
}
</code></pre>
<p>the key/value pair is successfully removed but the changes aren't updated in the service that's subscribing to its changes.</p>
<p>Why isn't it triggering the <code>.subscribe</code> call when I updated the state?</p>
<p><strong>edit</strong>(adding the service consuming StoreService):</p>
<pre><code>export class TableService implements ITableService {
  private options: Record&lt;string, options&gt; = {};

  constructor(
    private storeService: StoreService&lt;MyState, MyAction&gt;,
    private offerId: Id,
  ) {
    this.storeService.state.options.subscribe((options) =&gt; {
      this.options = options;
    });
  }

  public removeOptions(optionsId: string): void {
    return this.storeService.update([
      {
        type: REMOVE_OPTIONS,
        payload: optionsId,
      },
    ]);
  }

}
</code></pre>
<p>edit - other solution that's working for me is:</p>
<pre><code>    case REMOVE_OPTIONS: {
      const entities = this._state.options.getValue();
      const optionId = action.payload;

      const { [optionId]: _removedEntity, ...newEntities } = entities;

      this._state.optionId.next({
        ...newEntities,
        [optionId]: {} as Option,
      });
      break;
     }
</code></pre>
<p>as long as I don't remove the key/value pair completely, it emits a new value in the stream. I don't understand why that works though and my original solution doesn't</p>
","5871609","","5871609","","2021-08-17 10:18:02","2021-08-17 10:18:02","Observable BehaviorSubject does not trigger subscribe changes on removing key value pair","<javascript><rxjs><rxjs6><rxjs-observables>","0","13","","","","CC BY-SA 4.0"
"68813724","1","68814191","","2021-08-17 08:02:47","","-5","49","<p>Let's imagine I have this code using async/await that's working very well:</p>
<pre class=""lang-js prettyprint-override""><code>async function getMeSomething() : Promise&lt;Something&gt; {
  // some async code
}

async function getMeStuff() : Promise&lt;Stuff&gt; {
  // some async code
}

async function getMeSomethingWithStuff: Promise&lt;SomethingWithStuff&gt; {
  const something: Something = await getMeSomething();
  const stuff: Stuff = await getMeStuff();
  return new SomethingWithStuff(something, stuff);
}
</code></pre>
<p>This code could effectively be written with promises, like any code using async/await (it's just longer):</p>
<pre class=""lang-js prettyprint-override""><code>// this is strictly equivalent to previous example, including exception management
function getMeSomethingWithStuff: Promise&lt;SomethingWithStuff&gt; {
  let something;
  return getMeSomething().then((res) =&gt; {
    something = res;
    return getMeStuff();
  }).then((stuff) =&gt; {
    return new SomethingWithStuff(something, stuff);
  });
}
</code></pre>
<p>When calling the third function it will call the first one and second one, combine the results and return me the final result in a way that the caller of the third function has no idea which underlying functions were called:</p>
<pre class=""lang-js prettyprint-override""><code>const somethingWithStuff: SomethingWithStuff = getMeSomethingWithStuff();
// we have the result, we don't care how we got it, the logic is completely encapsulated
</code></pre>
<p>How could we write an equivalent code using only rxjs ?</p>
<pre class=""lang-js prettyprint-override""><code>// the following two functions are already defined and we can't redefine them
function getMeSomething() : Observable&lt;Something&gt; {
  // some async code
}

function getMeStuff() : Observable&lt;Stuff&gt; {
  // some async code
}

// we want to define this function that should return an observable
function getMeSomethingWithStuff: Observable&lt;SomethingWithStuff&gt; {
  // what's the code ?
}
</code></pre>
<p>The rules:</p>
<ul>
<li>No cheating with promises, async/await or conversion between observables and promises, it must only use rxjs</li>
<li>Exceptions must be correctly handled</li>
</ul>
<p>It may seem a trivial question but I couldn't find an answer by myself despite reading carefully the documentation of rxjs and a lot of tutorials.</p>
","2491400","","13146415","","2021-08-17 09:16:46","2021-08-17 09:16:46","How to chain observables like using Promises or async/await?","<angular><rxjs><observable><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"68817467","1","68817518","","2021-08-17 12:34:06","","1","51","<p>I have below code:</p>
<pre><code> subscriber.pipe(
       switchMap(data =&gt; {
          this.getData().pipe(
             map(() =&gt; res),
             catchError(error =&gt; {
                 return of(null);
             })
          );
       }),
       switchMap(data =&gt; {
    
       })
    
    ).subscribe();
</code></pre>
<p>In case of error in first switchMap i am returning of(null) so next switchMap is reciving data as null.
But i like to stop the execution in case first switchMap goes to catchError block, it should not execute second switchMap. Is there a way to achieve this?</p>
","1658941","","","","","2021-08-17 13:00:48","Angular - pipe function break execution flow","<angular><typescript><rxjs><rxjs-observables>","3","3","","","","CC BY-SA 4.0"
"68838290","1","68839032","","2021-08-18 19:28:52","","1","29","<p>I have been struggling with this all day long. I have a component with an interface called Invoice and I need to assign values to some of the fields so I can pass the invoice object to a service to save to database. I normally program more imperatively but trying to be more declarative in this new component.</p>
<p>in my component I have some streams that I am trying to combineLatest on and then I need to get values from the combined streams and assign:</p>
<pre><code>private newInvoice = {} as Invoice;

invoiceBatch$ = this.invoiceBatchService.invoiceBatch$;
nextInvoiceNumber$ = this.invoiceBatchService.newInvoiceNumberAction$;

ngOnInit() {
     combineLatest([
      this.nextInvoiceNumber$,
      this.invoiceBatch$,
      this.userService.currentUser$]
    ).subscribe(res =&gt; {
      this.newInvoice.InvoiceBatchID = res[1].InvoiceBatchID;
      this.newInvoice.FiscYearPer = res[1].FiscYearPer;
      this.newInvoice.InvoiceNumber = res[0];
      this.newInvoice.CreatedByID = +res[2].ApplicationUserID;
      this.newInvoice.CreatedBy = res[2].UserName;
    })
  }


  createNextInvoice(){
    this.invoiceBatchService.getNextInvoiceNumber();
}
</code></pre>
<p>in my my template, the user clicks a button to add a new invoice and it fires the createNextInvoice() method. This method calls the service that goes out and gets the next invoice number.</p>
<p><strong>Invoice Batch Service</strong></p>
<pre><code>  private newInvoiceNumberSubject = new Subject&lt;string&gt;();
  private invoiceNumberDataStore: { invoicenumber: string } = { invoicenumber: null};
  readonly newInvoiceNumberAction$ = this.newInvoiceNumberSubject.asObservable();

  public getNextInvoiceNumber() {
    return this.http.get&lt;string&gt;(this.baseUrl + `/batch/GetNextReferenceNumber/9`)
      .subscribe(
        data =&gt; {
          this.invoiceNumberDataStore.invoicenumber = data;
          this.newInvoiceNumberSubject.next(Object.assign({}, this.invoiceNumberDataStore).invoicenumber);
          console.log(&quot;NewInvoice: &quot;, data);
        }, error =&gt; {
        }
      );
  }

</code></pre>
<p>My thought was that when the 'createNextInvoice()' is called, it gets the next invoice number and updates nextInvoiceNumber$. Shouldn't the combineLastest react to the change to the nextInvoiceNumber$? Is subscribibg wrong? I've tried many combinations with map, mergeMap, switchMap, etc.</p>
<p>The invoiceBatch$ and  this.userService.currentUser$ are set once when the component is created So nextInvoiceNumber$ is the only thing that will be updated from user action.</p>
<p><strong>Update</strong></p>
<p>I've gotten closer. I can assign values to object but it's firing twice every time a new invoice is added. It's progress!</p>
<p>I made these changes in my component:</p>
<pre><code>  newInvoice$ = combineLatest([
    this.nextInvoiceNumber$,
    this.invoiceBatch$,
    this.userService.currentUser$]
  );

  ngOnInit() {

    this.newInvoice$.
      subscribe(res =&gt; {
        this.newInvoice.fdInvoiceNumber = res[0];
        this.newInvoice.fdInvoiceBatchID = res[1].fdInvoiceBatchID;
        this.newInvoice.fdFiscYearPer = res[1].fdFiscYearPer;
        this.newInvoice.fdCreatedByID = +res[2].fdApplicationUserID;
        this.newInvoice.fdCreatedBy = res[2].fdUserName;

        this.invoiceService.CreateInvoice(this.newInvoice);
      });
</code></pre>
","12489003","","12489003","","2021-08-18 20:32:50","2021-08-18 20:43:06","Angular 11: trying to assign values to an object using combineLatest","<angular><rxjs><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"68839846","1","68839955","","2021-08-18 22:06:38","","0","63","<p>Let's say I have an observable of an object in the shape of:</p>
<pre><code>export interface Invoice {
  fdInvoiceID: number;
  fdInvoiceNumber: string;
  fdCustomerID: number;
  fdTotal: number
  invoiceLineItems: InvoiceLineItem[];
</code></pre>
<p>If the user adds a line item, how can I add that to the invoiceLineItems list of the observable?</p>
<p>I have an observer invoices$ and I am using async in the template</p>
<pre><code>*ngIf=&quot;invoices$ | async as invoices&quot;

</code></pre>
<p>After the the new lineItem is saved to the database, I want add it to the invoices$.invoiceLineItems and have it displayed via async.</p>
","12489003","","","","","2021-08-18 23:54:09","Angular 11 RxJS: How do you add an object to a nested list of objects of an observable?","<angular><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"68865704","1","","","2021-08-20 16:59:07","","0","49","<pre><code>this.httpService
          .getCustomer(id)
          .pipe(
            switchMap((customerObj) =&gt; this.httpService.getCustomerAccount(customerObj.account_id)),
            switchMap((accountObj) =&gt;
              this.httpService.getAccountHoliday(accountObj.holiday_id),
            ),
          )
          .subscribe((holidays: Holiday[]) =&gt; {
            for (const holiday of holidays) {
              this.httpService.getDestination(holiday.dest_id).subscribe((destination) =&gt; {
                if (holiday.identifier === destination.name) {
                  console.log(holiday);
                }
              });
            }
          });
</code></pre>
<p>I want to do something like this</p>
<pre><code>  this.httpService
      .getCustomer(id)
      .pipe(
        switchMap((customerObj) =&gt; this.httpService.getCustomerAccount(customerObj.account_id)),
        switchMap((accountObj) =&gt;
          this.httpService.getAccountHoliday(accountObj.holiday_id),
        ),
        filter(holiday =&gt; this.httpService.getDestination(holiday.dest_id).name === holiday.identifier)
      )
      .subscribe((holiday: Holiday[]) =&gt; {
        for (const holiday of holidays) {
          console.log(holiday);
        }
      });
</code></pre>
<p>That is, merge the logic of for loop with the overservables i.e I need to filter out the holidays before I subscribe. How can I do this?</p>
","13040314","","3128796","","2021-08-20 19:15:28","2021-08-20 19:53:30","Remove for loop from observable subscribe","<angular><rxjs><rxjs-observables>","2","1","","","","CC BY-SA 4.0"
"68913406","1","","","2021-08-24 19:54:34","","0","35","<p>I am new to Node/angular and really am struggling to understand observables/subscriptions etc. I am working off of some existing code and am running into an issue that I want to understand how to solve.</p>
<p>I have a component which is a list of records, and within that component I run this function on button click:</p>
<pre><code>deleteRecord(id) {
    this.recordService.delete(id);
    this.recordService.responseMessage$.subscribe(response =&gt; {
        if (response.message = 'record deleted') {
            this.messageService.add({severity:'success', summary:'Success', detail:`Record ${id} deleted`});
        } else if (response.message = 'could not delete record') {
            this.messageService.add({severity:'error', summary:'Oops!', detail:`Not able to delete record.`});
        }
    });
}
</code></pre>
<p>The message service is from PrimeNg (angular framework) - and all it does is create a 'toast' message (green popup message) that the record was succesfully deleted. The problem I'm running into is that if I delete one record from the list, and then delete another, the second time I delete a record it will show two toast messages, rather than just the last one. If I keep deleting, it will keep adding to the amount of toast messages that it shows when I click delete. If I console.log the response within this function, I do see that every time I click delete, it adds another object to the response so I am sure this is why it is showing multiple toast messages. I simply want to know if/how I can limit it to only the last one I clicked - or understand how I can fix this otherwise.</p>
<p>The delete function in my record service looks like this:</p>
<pre><code>...

export class RecordService {
    private responseMessageListener = new Subject&lt;any&gt;();
    responseMessage$ = this.responseMessageListener.asObservable();

...

    delete(id: number) {
        this.http.delete&lt;{message:string}&gt;(this.authService.getApiUrl(`/record/${id}`)).subscribe(response =&gt; {
            this.getRecords();  // this is so the list updates in the browser
            this.responseMessageListener.next(response);
        })
    }
}
</code></pre>
<p>the response message will either be 'record deleted' or 'could not delete record' based on if the SQL query is successful or not.</p>
<p>I also tried doing this a slightly different way, and it does seem to only show one toast at a time (although it never shows the first one), but if I console.log the response it is still showing multiple instances of a response if I click delete on more than one item on the list. This is the second way I tried ... though I think I would like to stick with the first example unless there are strong reasons why I shouldn't. I tried it this way so I can unsubscribe from the 'recordListenerSub', since I didn't know how to unsubscribe the first way.</p>
<pre><code>private responseListenerSub: Subscription; // maybe delete

...
ngOnInit(): void {

    deleteRecord(id) {
      this.responseListenerSub = this.recordService.getResponseListener().subscribe(response =&gt; {
        console.log(response);
        this.response = response.message;
      });
      this.recordService.delete(id);
    
        if (this.response == 'recorddeleted') {
          this.messageService.add({severity:'success', summary:'Success', detail:`Record ${id} deleted`});
        } 
        if (this.response == 'could not delete record') {
          this.messageService.add({severity:'error', summary:'Oops!', detail:`Not able to delete record ${id}.`});
        }
    }
}

...

ngOnDestroy() {
    this.responseListenerSub.unsubscribe();
}
</code></pre>
","8010912","","","","","2021-08-24 20:16:38","node/angular app - trouble with subscriptions/observables - how to limit what comes back on subscription","<node.js><angular><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"68932089","1","","","2021-08-26 03:20:25","","2","54","<p>Based on searchCriteria collected from a form, I have a method that return observable of talents.</p>
<pre><code>getTalents(searchCriteria) {
        return this._allUsers$.pipe(
            tap((talents) =&gt; console.log(talents)),
            map((talents: any) =&gt; {
                let filtered = talents.filter(
                    (t) =&gt;
                        (t.userType === 'talent' || t.userType === 'both') &amp;&amp;
                        this.matchOccupationOrSkill(
                            searchCriteria.occupation,
                            t.occupation,
                            t.skills
                        )
                );
                if (searchCriteria.loggedInUserId) {
                    filtered = filtered.filter(
                        (t) =&gt; t.id !== searchCriteria.loggedInUserId
                    );
                }
                return filtered;
            })
        );
    }
</code></pre>
<p>where _allUsers$ is a shared observable,</p>
<pre><code>this._allUsers$ = firestore.collection&lt;any&gt;('users').valueChanges().pipe(share());
</code></pre>
<p>I am calling getTalents inside ngOnInit method of a route component TalentSearchResult.</p>
<pre><code>ngOnInit(): void {
    this.subs.add(
        this.route.queryParams.subscribe(params =&gt; {
            if (params.action==='homesearch' || params.action==='jobsearch'){
                this.criteria = {
                    occupation:params.occupation,
                    industry:params.industry,
                    loggedInUserId:params.loggedInUserId,
                }
                this.dataService.getTalents(this.criteria).pipe(take(1)).subscribe(talents =&gt; {
                    this.count = talents.length;
                    if (this.count &gt;0){
                       this.Talents = talents.sort((p1,p2)=&gt; p2.createdate-p1.createdate);
                    }
                })
            }
        })
    )
  }
</code></pre>
<p>Search works for the first time, then when I go back (using brower back button) and search with a new criteria, it routed correctly to the TalentSearchResult component, however, stale list is being returned. I debugged and found that line 3 in the first code section above, i.e. tap((talents) =&gt; console.log(talents)) already logs in the stale value, even before the pipe/map/filter is executed !
Please advice</p>
","1126248","","","","","2021-08-30 05:39:10","Angular rxjs data not updating correctly when using share , map & filter","<javascript><angular><rxjs><rxjs-observables><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"68986671","1","","","2021-08-30 15:34:15","","0","37","<p>I've written a function to combine two firestore collection observables and it's working great, however it's running the map function 7 times for just one result. Am I doing something wrong here, or is there a way to reduce the amount of processing being done?</p>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>return combineLatest(
    [
      this.approvedToppings$,
      this.myPendingToppings$
    ],
  ).pipe(
    map(([approved, pending], index) =&gt; {
      console.log(index);
      //console.log(pending);
      let toppingDocs = approved.concat(pending);
      //console.log(toppingDocs);
      let toppings: Topping[] = [];
      toppingDocs.forEach((toppingDoc) =&gt; {
        toppings.push(this.convertToppingDocToTopping(toppingDoc));
      });
      return toppings as Topping[];
    })
  );
}</code></pre>
</div>
</div>
</p>
<p>The console.log at the top of the map runs 7 times for every update, and that doesn't make any sense to me.
Subscribing to each of the input observables shows one result each, and subscribing to the output observable also shows one combined output.</p>
","4363576","","","","","2021-08-31 15:18:59","RXJS combineLatest running pipe 7 times for one emit","<typescript><rxjs><observable><rxjs-observables><rxjs-pipeable-operators>","2","5","","","","CC BY-SA 4.0"
"69030545","1","69030695","","2021-09-02 12:43:39","","2","35","<p>The goal is to retrieve a document from firestore, and for each document, complete it with an array of documents coming another collection.</p>
<p>Firestore isn't supporting the &quot;inclusion&quot; of subcollection.</p>
<p>In my cases, I've a <code>Test</code>, which has a whole array of &quot;TestResults&quot;. The name of the test results is the firebase ID.</p>
<p>So far, I've the following:</p>
<pre><code>const result = this.firestore
         .doc&lt;Test&gt;(`tests/${testId}`)
         .valueChanges({ idField: 'id' })
         .pipe(
            switchMap((test) =&gt;
               this.firestore
                  .collection&lt;TestResult&gt;(`tests/${test.id}/results`)
                  .valueChanges({ idField: 'name' })
                  .pipe
                  //How to assign my testResults[] to my current test
                  //And how to return a test?
                  ()
            )
         );
</code></pre>
<p>I guess I do a <code>tap(results=&gt;test.results =results)</code>, but then <code>result</code> would not be a <code>Observable&lt;Test&gt;</code>.</p>
<p>How would you achieve this? The same logic will be used to get all tests.</p>
<p>Thank you very much for your help</p>
","397830","","","","","2021-09-02 12:53:55","How to return an observable that combines results of another observable?","<angular><rxjs><observable><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"69047303","1","69047531","","2021-09-03 15:24:10","","1","51","<p>I have following pseudocode</p>
<pre><code>zip(
        ...[1, 2, 3].map((id) =&gt;
          this.http.function1(id).pipe(
            mergeMap((obj1) =&gt; this.http.function2(obj1.id)),
            mergeMap((obj2) =&gt; this.http.function3(obj2.id)),
          ),
        ),
      ).subscribe((result) =&gt; {
        console.log('This should be an array of all the results of the requests to this.http.function3');
      });
</code></pre>
<p>I want the result of all the request together. How can I do this?</p>
","13040314","","","","","2021-09-03 15:41:51","RxJs: get array of observables","<angular><rxjs><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"69148070","1","69163397","","2021-09-12 02:48:09","","0","52","<p>I was composing an observable stream with this intent:<br />
having an observable emitting from a web request and 2 triggers, one for re-emitting the value obtained and the other trigger to re-load the value (re-executing the request). Also, late subscribers should get the last value obtained and be able to receive reset/reload.</p>
<p>Initially I ended up with the following code (which didn't work):</p>
<pre class=""lang-js prettyprint-override""><code>public readonly initialValueFlat$ = this.seed$
  .pipe(
    switchMap(seed =&gt; defer(
      () =&gt; {
        this._isLoading$$.next(true);
        return this.getFakeData(seed)
          .pipe(
            finalize(() =&gt; this._isLoading$$.next(false)));
      })),
    repeatWhen(x =&gt; this._reloadTrigger$),
    switchMap(x =&gt; of(x)),
    repeatWhen(x =&gt; this._resetTrigger$),
    shareReplay(1));
</code></pre>
<p>working on it I found the following solution:</p>
<pre class=""lang-js prettyprint-override""><code>public readonly initialValue$ = this.seed$
  .pipe(
    switchMap(seed =&gt; defer(
      () =&gt; {
        this._isLoading$$.next(true);
        return this.getFakeData(seed)
          .pipe(
            finalize(() =&gt; this._isLoading$$.next(false)));
      })
      .pipe(
        repeatWhen(x =&gt; this._reloadTrigger$))
      .pipe(
        switchMap(x =&gt;
          of(x)
            .pipe(
              repeatWhen(x =&gt; this._resetTrigger$))))),
    shareReplay(1));
</code></pre>
<p>But it is not fully clear to me why the first one doesn't work, and how is the multiple <code>.pipe</code> operators affect the chain.
Can you help me make it clear?
Thanks</p>
","1790497","","1790497","","2021-09-12 14:37:36","2021-09-13 13:16:32","Difference between single and multiple .pipe","<rxjs><observable><reactive><rxjs-observables>","1","12","","","","CC BY-SA 4.0"
"69200622","1","69214284","","2021-09-15 23:01:30","","1","32","<p>I have two observables (obs1 and obs2) that I want to pay attention to. They never complete and over their lifetime I can expect that they emit the same number of items. I cannot know which one will emit first. I need something that will emit every time the source observables have each emitted their nth item. So, I am looking for an observable that acts in either of these ways:</p>
<ul>
<li>(a) It emits every time the source observables have each emitted the same number of items.</li>
<li>(b) It emits every time the source observable, that has currently emitted the least amount of items, makes an emission.</li>
</ul>
<h2><strong>Example for a:</strong></h2>
<p>If <strong>obs1</strong> emits its <strong>1st item</strong> and then <strong>obs2</strong> emits its <strong>1st item</strong>, <strong>myObservable</strong> will produce its <strong>1st emission</strong>.
Then if <strong>obs2</strong> emits a <strong>2nd</strong> and <strong>3rd item</strong> nothing will happen until <strong>obs1</strong> emits its <strong>2nd item</strong> and only then will <strong>myObservable</strong> produce its <strong>2nd emission</strong>.</p>
<p><a href=""https://i.stack.imgur.com/rlxT6.png"" rel=""nofollow noreferrer"">(a) When source observables have the same number of items emitted.</a></p>
<p><a href=""https://i.stack.imgur.com/2UIXg.png"" rel=""nofollow noreferrer"">(b) Whenever, across all the source observables, the lowest number of items emitted increases.</a></p>
","16922764","","16922764","","2021-09-15 23:20:18","2021-09-16 19:41:20","Using RXJS, is there a way to produce an observable that emits when the number of items, CURRENTLY emitted by the source Observables, is the same?","<javascript><typescript><rxjs><rxjs-observables>","2","3","","","","CC BY-SA 4.0"
"69206021","1","","","2021-09-16 09:41:09","","1","37","<p>The given oberservable has the following structure</p>
<pre><code>... interface experimentalresult {
   Name: User;
   Results: {
     Experiment: Task
     Attempts: Number
     Status: Boolean
   } [];
</code></pre>
<p>I would like to calculate the average attempts of all users who have passed the experiment with a positive status (true). This average should then be given to an array based on the experiments (task).
It should then be something that the array looks like this.</p>
<blockquote>
<p>['2.7', '3.4', 2.1 ']</p>
</blockquote>
<p>Semantically, the results should be the following facts:</p>
<blockquote>
<p>['average experiment for experiment 1', 'average experimental
experiment 2', ....]</p>
</blockquote>
<p>Can this complicated fact be implemented with a simply subscribe? If this is not the case, someone has a different suggestion as you can implement this function.</p>
","16853055","","16853055","","2021-09-16 09:47:26","2021-09-16 11:36:00","Calculate average about the return of an observable","<angular><rxjs><observable><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"69218776","1","","","2021-09-17 06:35:44","","0","4","<p>I have two consecutive HTTP requests (after cca 5 seconds) which are handled as Observable. What I need is to be able to wait for result (without <code>subscribe</code> as I need the result on the next line), so <code>await</code> and <code>toPromise()</code> looks like straightforward solution. But I also need to be able to cancel the subscription to the first request, if it is still active when the second comes and I haven't found a solution how to cancel a promise yet.</p>
<p>Any help is appreciated.</p>
","4741929","","","","","2021-09-17 06:35:44","Awaitable cancellable promise","<async-await><rxjs-observables>","0","0","","","","CC BY-SA 4.0"